{"files":[{"patch":"@@ -2134,1 +2134,1 @@\n-%% This notice is provided with respect to libpng 1.6.39, which may be\n+%% This notice is provided with respect to libpng 1.6.51, which may be\n@@ -2145,5 +2145,5 @@\n-Copyright (c) 1995-2022 The PNG Reference Library Authors.\n-Copyright (c) 2018-2022 Cosmin Truta\n-Copyright (c) 1998-2018 Glenn Randers-Pehrson\n-Copyright (c) 1996-1997 Andreas Dilger\n-Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\n+Copyright (C) 1995-2025 The PNG Reference Library Authors.\n+Copyright (C) 2018-2025 Cosmin Truta\n+Copyright (C) 1998-2018 Glenn Randers-Pehrson\n+Copyright (C) 1996-1997 Andreas Dilger\n+Copyright (C) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\n@@ -2309,0 +2309,1 @@\n+ * Adam Richter\n@@ -2310,0 +2311,1 @@\n+ * Chris Blume\n@@ -2320,0 +2322,1 @@\n+ * Lucas Chollet\n@@ -2322,0 +2325,1 @@\n+ * Manfred Schlaegl\n@@ -2327,0 +2331,1 @@\n+ * Philippe Antoine\n@@ -2332,0 +2337,1 @@\n+ * Tobias Stoeckmann\n@@ -2337,0 +2343,2 @@\n+ * Apple Inc.\n+    - Zixu Wang (王子旭)\n@@ -2338,7 +2346,15 @@\n-   - Richard Townsend\n- * Google Inc.\n-   - Dan Field\n-   - Leon Scroggins III\n-   - Matt Sarett\n-   - Mike Klein\n-   - Sami Boukortt\n+    - Richard Townsend\n+ * Google LLC\n+    - Dan Field\n+    - Dragoș Tiselice\n+    - Leon Scroggins III\n+    - Matt Sarett\n+    - Mike Klein\n+    - Sami Boukortt\n+    - Wan-Teh Chang\n+ * Loongson Technology Corporation Ltd.\n+    - GuXiWei (顾希伟)\n+    - JinBo (金波)\n+    - ZhangLixia (张利霞)\n+ * Samsung Group\n+    - Filip Wasil\n@@ -2347,1 +2363,1 @@\n-files in the \"ci\", \"projects\", \"scripts\" and \"tests\" directories, have\n+files in the \"projects\", \"scripts\" and \"tests\" directories, have\n@@ -2350,3 +2366,4 @@\n-Some files in the \"contrib\" directory, and some tools-generated files\n-that are distributed with libpng, have other copyright owners, and are\n-released under other open source licenses.\n+Some files in the \"ci\" and \"contrib\" directories, as well as some\n+of the tools-generated files that are distributed with libpng, have\n+other copyright owners, and are released under other open source\n+licenses.\n","filename":"THIRD_PARTY_README","additions":34,"deletions":17,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-    all configurable options can be selected from command-line instead\n+    all configurable options can be selected from command line instead\n@@ -945,1 +945,1 @@\n-  Fixed seqence-point bug in contrib\/pngminus\/png2pnm (Martin Zinser)\n+  Fixed sequence-point bug in contrib\/pngminus\/png2pnm (Martin Zinser)\n@@ -2298,1 +2298,1 @@\n-  Reformated sources in libpng style (3-space indentation, comment format)\n+  Reformatted sources in libpng style (3-space indentation, comment format)\n@@ -2664,1 +2664,1 @@\n-  Added defineable PNG_USER_CHUNK_CACHE_MAX, PNG_USER_CHUNK_MALLOC_MAX,\n+  Added definable PNG_USER_CHUNK_CACHE_MAX, PNG_USER_CHUNK_MALLOC_MAX,\n@@ -3922,1 +3922,1 @@\n-    option is now done automagically only when required, so that commandline\n+    option is now done automagically only when required, so that command-line\n@@ -4055,1 +4055,1 @@\n-  Fixed PNG_LIBPNG_BUILD_BASE_TYPE definition. \n+  Fixed PNG_LIBPNG_BUILD_BASE_TYPE definition.\n@@ -4965,1 +4965,1 @@\n-    \n+\n@@ -5456,1 +5456,1 @@\n-    in the BigEndian tests by not testing it, making the BE code the same \n+    in the BigEndian tests by not testing it, making the BE code the same\n@@ -5520,1 +5520,1 @@\n-    were accidentally removed from libpng-1.6.17. \n+    were accidentally removed from libpng-1.6.17.\n@@ -5930,1 +5930,1 @@\n-  Replaced local eXIf_buf with info_ptr-eXIf_buf in png_handle_eXIf().\n+  Replaced local eXIf_buf with info_ptr->eXIf_buf in png_handle_eXIf().\n@@ -5953,1 +5953,1 @@\n-  \n+\n@@ -6124,0 +6124,183 @@\n+Version 1.6.40 [June 21, 2023]\n+  Fixed the eXIf chunk multiplicity checks.\n+  Fixed a memory leak in pCAL processing.\n+  Corrected the validity report about tRNS inside png_get_valid().\n+  Fixed various build issues on *BSD, Mac and Windows.\n+  Updated the configurations and the scripts for continuous integration.\n+  Cleaned up the code, the build scripts, and the documentation.\n+\n+Version 1.6.41 [January 24, 2024]\n+  Added SIMD-optimized code for the LoongArch LSX hardware.\n+    (Contributed by GuXiWei, JinBo and ZhangLixia)\n+  Fixed the run-time discovery of MIPS MSA hardware.\n+    (Contributed by Sui Jingfeng)\n+  Fixed an off-by-one error in the function png_do_check_palette_indexes(),\n+    which failed to recognize errors that might have existed in the first\n+    column of a broken palette-encoded image. This was a benign regression\n+    accidentally introduced in libpng-1.6.33. No pixel was harmed.\n+    (Contributed by Adam Richter; reviewed by John Bowler)\n+  Fixed, improved and modernized the contrib\/pngminus programs, i.e.,\n+    png2pnm.c and pnm2png.c\n+  Removed old and peculiar portability hacks that were meant to silence\n+    warnings issued by gcc version 7.1 alone.\n+    (Contributed by John Bowler)\n+  Fixed and modernized the CMake file, and raised the minimum required\n+    CMake version from 3.1 to 3.6.\n+    (Contributed by Clinton Ingram, Timothy Lyanguzov, Tyler Kropp, et al.)\n+  Allowed the configure script to disable the building of auxiliary tools\n+    and tests, thus catching up with the CMake file.\n+    (Contributed by Carlo Bramini)\n+  Fixed a build issue on Mac.\n+    (Contributed by Zixu Wang)\n+  Moved the Autoconf macro files to scripts\/autoconf.\n+  Moved the CMake files (except for the main CMakeLists.txt) to\n+    scripts\/cmake and moved the list of their contributing authors to\n+    scripts\/cmake\/AUTHORS.md\n+  Updated the CI configurations and scripts.\n+  Relicensed the CI scripts to the MIT License.\n+  Improved the test coverage.\n+    (Contributed by John Bowler)\n+\n+Version 1.6.42 [January 29, 2024]\n+  Fixed the implementation of the macro function png_check_sig().\n+    This was an API regression, introduced in libpng-1.6.41.\n+    (Reported by Matthieu Darbois)\n+  Fixed and updated the libpng manual.\n+\n+Version 1.6.43 [February 23, 2024]\n+  Fixed the row width check in png_check_IHDR().\n+    This corrected a bug that was specific to the 16-bit platforms,\n+    and removed a spurious compiler warning from the 64-bit builds.\n+    (Reported by Jacek Caban; fixed by John Bowler)\n+  Added eXIf chunk support to the push-mode reader in pngpread.c.\n+    (Contributed by Chris Blume)\n+  Added contrib\/pngexif for the benefit of the users who would like\n+    to inspect the content of eXIf chunks.\n+  Added contrib\/conftest\/basic.dfa, a basic build-time configuration.\n+    (Contributed by John Bowler)\n+  Fixed a preprocessor condition in pngread.c that broke build-time\n+    configurations like contrib\/conftest\/pngcp.dfa.\n+    (Contributed by John Bowler)\n+  Added CMake build support for LoongArch LSX.\n+    (Contributed by GuXiWei)\n+  Fixed a CMake build error that occurred under a peculiar state of the\n+    dependency tree. This was a regression introduced in libpng-1.6.41.\n+    (Contributed by Dan Rosser)\n+  Marked the installed libpng headers as system headers in CMake.\n+    (Contributed by Benjamin Buch)\n+  Updated the build support for RISCOS.\n+    (Contributed by Cameron Cawley)\n+  Updated the makefiles to allow cross-platform builds to initialize\n+    conventional make variables like AR and ARFLAGS.\n+  Added various improvements to the CI scripts in areas like version\n+    consistency verification and text linting.\n+  Added version consistency verification to pngtest.c also.\n+\n+Version 1.6.44 [September 12, 2024]\n+  Hardened calculations in chroma handling to prevent overflows, and\n+    relaxed a constraint in cHRM validation to accomodate the standard\n+    ACES AP1 set of color primaries.\n+    (Contributed by John Bowler)\n+  Removed the ASM implementation of ARM Neon optimizations and updated\n+    the build accordingly. Only the remaining C implementation shall be\n+    used from now on, thus ensuring the support of the PAC\/BTI security\n+    features on ARM64.\n+    (Contributed by Ross Burton and John Bowler)\n+  Fixed the pickup of the PNG_HARDWARE_OPTIMIZATIONS option in the\n+    CMake build on FreeBSD\/amd64. This is an important performance fix\n+    on this platform.\n+  Applied various fixes and improvements to the CMake build.\n+    (Contributed by Eric Riff, Benjamin Buch and Erik Scholz)\n+  Added fuzzing targets for the simplified read API.\n+    (Contributed by Mikhail Khachayants)\n+  Fixed a build error involving pngtest.c under a custom config.\n+    This was a regression introduced in a code cleanup in libpng-1.6.43.\n+    (Contributed by Ben Wagner)\n+  Fixed and improved the config files for AppVeyor CI and Travis CI.\n+\n+Version 1.6.45 [January 7, 2025]\n+  Added support for the cICP chunk.\n+    (Contributed by Lucas Chollet and John Bowler)\n+  Adjusted and improved various checks in colorspace calculations.\n+    (Contributed by John Bowler)\n+  Rearranged the write order of colorspace chunks for better conformance\n+    with the PNG v3 draft specification.\n+    (Contributed by John Bowler)\n+  Raised the minimum required CMake version from 3.6 to 3.14.\n+  Forked off a development branch for libpng version 1.8.\n+\n+Version 1.6.46 [January 23, 2025]\n+  Added support for the mDCV and cLLI chunks.\n+    (Contributed by John Bowler)\n+  Fixed a build issue affecting C89 compilers.\n+    This was a regression introduced in libpng-1.6.45.\n+    (Contributed by John Bowler)\n+  Added makefile.c89, specifically for testing C89 compilers.\n+  Cleaned up contrib\/pngminus: corrected an old typo, removed an old\n+    workaround, and updated the CMake file.\n+\n+Version 1.6.47 [February 18, 2025]\n+  Modified the behaviour of colorspace chunks in order to adhere\n+    to the new precedence rules formulated in the latest draft of\n+    the PNG Specification.\n+    (Contributed by John Bowler)\n+  Fixed a latent bug in `png_write_iCCP`.\n+    This would have been a read-beyond-end-of-malloc vulnerability,\n+    introduced early in the libpng-1.6.0 development, yet (fortunately!)\n+    it was inaccessible before the above-mentioned modification of the\n+    colorspace precedence rules, due to pre-existing colorspace checks.\n+    (Reported by Bob Friesenhahn; fixed by John Bowler)\n+\n+Version 1.6.48 [April 30, 2025]\n+  Fixed the floating-point version of the mDCv setter `png_set_mDCv`.\n+    (Reported by Mohit Bakshi; fixed by John Bowler)\n+  Added #error directives to discourage the inclusion of private\n+    libpng implementation header files in PNG-supporting applications.\n+  Added the CMake build option `PNG_LIBCONF_HEADER`, to be used as an\n+    alternative to `DFA_XTRA`.\n+  Removed the Travis CI configuration files, with heartfelt thanks for\n+    their generous support of our project over the past five years!\n+\n+Version 1.6.49 [June 12, 2025]\n+  Added SIMD-optimized code for the RISC-V Vector Extension (RVV).\n+    (Contributed by Manfred Schlaegl, Dragos Tiselice and Filip Wasil)\n+  Added various fixes and improvements to the build scripts and to\n+    the sample code.\n+\n+Version 1.6.50 [July 1, 2025]\n+  Improved the detection of the RVV Extension on the RISC-V platform.\n+    (Contributed by Filip Wasil)\n+  Replaced inline ASM with C intrinsics in the RVV code.\n+    (Contributed by Filip Wasil)\n+  Fixed a decoder defect in which unknown chunks trailing IDAT, set\n+    to go through the unknown chunk handler, incorrectly triggered\n+    out-of-place IEND errors.\n+    (Contributed by John Bowler)\n+  Fixed the CMake file for cross-platform builds that require `libm`.\n+\n+Version 1.6.51 [November 21, 2025]\n+  Fixed CVE-2025-64505 (moderate severity):\n+    Heap buffer overflow in `png_do_quantize` via malformed palette index.\n+    (Reported by Samsung; analyzed by Fabio Gritti.)\n+  Fixed CVE-2025-64506 (moderate severity):\n+    Heap buffer over-read in `png_write_image_8bit` with 8-bit input and\n+    `convert_to_8bit` enabled.\n+    (Reported by Samsung and <weijinjinnihao@users.noreply.github.com>;\n+    analyzed by Fabio Gritti.)\n+  Fixed CVE-2025-64720 (high severity):\n+    Buffer overflow in `png_image_read_composite` via incorrect palette\n+    premultiplication.\n+    (Reported by Samsung; analyzed by John Bowler.)\n+  Fixed CVE-2025-65018 (high severity):\n+    Heap buffer overflow in `png_combine_row` triggered via\n+    `png_image_finish_read`.\n+    (Reported by <yosiimich@users.noreply.github.com>.)\n+  Fixed a memory leak in `png_set_quantize`.\n+    (Reported by Samsung; analyzed by Fabio Gritti.)\n+  Removed the experimental and incomplete ERROR_NUMBERS code.\n+    (Contributed by Tobias Stoeckmann.)\n+  Improved the RISC-V vector extension support; required RVV 1.0 or newer.\n+    (Contributed by Filip Wasil.)\n+  Added GitHub Actions workflows for automated testing.\n+  Performed various refactorings and cleanups.\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/CHANGES","additions":194,"deletions":11,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -7,2 +7,2 @@\n- * Copyright (c) 1995-2022 The PNG Reference Library Authors.\n- * Copyright (c) 2018-2022 Cosmin Truta.\n+ * Copyright (c) 1995-2025 The PNG Reference Library Authors.\n+ * Copyright (c) 2018-2025 Cosmin Truta.\n@@ -134,1 +134,1 @@\n-be appreciated.\n\\ No newline at end of file\n+be appreciated.\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/LICENSE","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-README for libpng version 1.6.39\n+README for libpng version 1.6.51\n@@ -4,2 +4,2 @@\n-See the note about version numbers near the top of png.h.\n-See INSTALL for instructions on how to install libpng.\n+See the note about version numbers near the top of `png.h`.\n+See `INSTALL` for instructions on how to install libpng.\n@@ -7,3 +7,3 @@\n-Libpng comes in several distribution formats.  Get libpng-*.tar.gz or\n-libpng-*.tar.xz if you want UNIX-style line endings in the text files,\n-or lpng*.7z or lpng*.zip if you want DOS-style line endings.\n+Libpng comes in several distribution formats.  Get `libpng-*.tar.gz`\n+or `libpng-*.tar.xz` if you want UNIX-style line endings in the text\n+files, or `lpng*.7z` or `lpng*.zip` if you want DOS-style line endings.\n@@ -11,7 +11,5 @@\n-Version 0.89 was the first official release of libpng.  Don't let the\n-fact that it's the first release fool you.  The libpng library has been\n-in extensive use and testing since mid-1995.  By late 1997 it had\n-finally gotten to the stage where there hadn't been significant\n-changes to the API in some time, and people have a bad feeling about\n-libraries with versions < 1.0.  Version 1.0.0 was released in\n-March 1998.\n+For a detailed description on using libpng, read `libpng-manual.txt`.\n+For examples of libpng in a program, see `example.c` and `pngtest.c`.\n+For usage information and restrictions (what little they are) on libpng,\n+see `png.h`.  For a description on using zlib (the compression library\n+used by libpng) and zlib's restrictions, see `zlib.h`.\n@@ -19,56 +17,1 @@\n-****\n-Note that some of the changes to the png_info structure render this\n-version of the library binary incompatible with libpng-0.89 or\n-earlier versions if you are using a shared library.  The type of the\n-\"filler\" parameter for png_set_filler() has changed from png_byte to\n-png_uint_32, which will affect shared-library applications that use\n-this function.\n-\n-To avoid problems with changes to the internals of the png info_struct,\n-new APIs have been made available in 0.95 to avoid direct application\n-access to info_ptr.  These functions are the png_set_<chunk> and\n-png_get_<chunk> functions.  These functions should be used when\n-accessing\/storing the info_struct data, rather than manipulating it\n-directly, to avoid such problems in the future.\n-\n-It is important to note that the APIs did not make current programs\n-that access the info struct directly incompatible with the new\n-library, through libpng-1.2.x.  In libpng-1.4.x, which was meant to\n-be a transitional release, members of the png_struct and the\n-info_struct can still be accessed, but the compiler will issue a\n-warning about deprecated usage.  Since libpng-1.5.0, direct access\n-to these structs is not allowed, and the definitions of the structs\n-reside in private pngstruct.h and pnginfo.h header files that are not\n-accessible to applications.  It is strongly suggested that new\n-programs use the new APIs (as shown in example.c and pngtest.c), and\n-older programs be converted to the new format, to facilitate upgrades\n-in the future.\n-****\n-\n-Additions since 0.90 include the ability to compile libpng as a\n-Windows DLL, and new APIs for accessing data in the info struct.\n-Experimental functions include the ability to set weighting and cost\n-factors for row filter selection, direct reads of integers from buffers\n-on big-endian processors that support misaligned data access, faster\n-methods of doing alpha composition, and more accurate 16->8 bit color\n-conversion.\n-\n-The additions since 0.89 include the ability to read from a PNG stream\n-which has had some (or all) of the signature bytes read by the calling\n-application.  This also allows the reading of embedded PNG streams that\n-do not have the PNG file signature.  As well, it is now possible to set\n-the library action on the detection of chunk CRC errors.  It is possible\n-to set different actions based on whether the CRC error occurred in a\n-critical or an ancillary chunk.\n-\n-For a detailed description on using libpng, read libpng-manual.txt.\n-For examples of libpng in a program, see example.c and pngtest.c.  For\n-usage information and restrictions (what little they are) on libpng,\n-see png.h.  For a description on using zlib (the compression library\n-used by libpng) and zlib's restrictions, see zlib.h\n-\n-I have included a general makefile, as well as several machine and\n-compiler specific ones, but you may have to modify one for your own\n-needs.\n-\n-You should use zlib 1.0.4 or later to run this, but it MAY work with\n+You should use zlib 1.0.4 or later to run this, but it _may_ work with\n@@ -81,1 +24,1 @@\n-replacement for fread() and fwrite(), if you are so inclined.\n+replacement for `fread()` and `fwrite()`, if you are so inclined.\n@@ -84,1 +27,1 @@\n-https:\/\/zlib.net.\n+https:\/\/zlib.net .\n@@ -90,2 +33,2 @@\n-This code is currently being archived at libpng.sourceforge.io in the\n-[DOWNLOAD] area, and at http:\/\/libpng.download\/src .\n+This code is currently being archived at https:\/\/libpng.sourceforge.io\n+in the download area, and at http:\/\/libpng.download\/src .\n@@ -97,2 +40,2 @@\n-Send comments\/corrections\/commendations to png-mng-implement at\n-lists.sourceforge.net (subscription required; visit\n+Send comments, corrections and commendations to `png-mng-implement`\n+at `lists.sourceforge.net`.  (Subscription is required; visit\n@@ -100,1 +43,6 @@\n-to subscribe).\n+to subscribe.)\n+\n+Send general questions about the PNG specification to `png-mng-misc`\n+at `lists.sourceforge.net`.  (Subscription is required; visit\n+https:\/\/lists.sourceforge.net\/lists\/listinfo\/png-mng-misc\n+to subscribe.)\n@@ -102,4 +50,53 @@\n-Send general questions about the PNG specification to png-mng-misc\n-at lists.sourceforge.net (subscription required; visit\n-https:\/\/lists.sourceforge.net\/lists\/listinfo\/png-mng-misc to\n-subscribe).\n+Historical notes\n+----------------\n+\n+The libpng library has been in extensive use and testing since mid-1995.\n+Version 0.89, published a year later, was the first official release.\n+By late 1997, it had finally gotten to the stage where there hadn't\n+been significant changes to the API in some time, and people have a bad\n+feeling about libraries with versions below 1.0.  Version 1.0.0 was\n+released in March 1998.\n+\n+Note that some of the changes to the `png_info` structure render this\n+version of the library binary incompatible with libpng-0.89 or\n+earlier versions if you are using a shared library.  The type of the\n+`filler` parameter for `png_set_filler()` has changed from `png_byte`\n+to `png_uint_32`, which will affect shared-library applications that\n+use this function.\n+\n+To avoid problems with changes to the internals of the `info_struct`,\n+new APIs have been made available in 0.95 to avoid direct application\n+access to `info_ptr`.  These functions are the `png_set_<chunk>` and\n+`png_get_<chunk>` functions.  These functions should be used when\n+accessing\/storing the `info_struct` data, rather than manipulating it\n+directly, to avoid such problems in the future.\n+\n+It is important to note that the APIs did not make current programs\n+that access the info struct directly incompatible with the new\n+library, through libpng-1.2.x.  In libpng-1.4.x, which was meant to\n+be a transitional release, members of the `png_struct` and the\n+`info_struct` can still be accessed, but the compiler will issue a\n+warning about deprecated usage.  Since libpng-1.5.0, direct access\n+to these structs is not allowed, and the definitions of the structs\n+reside in private `pngstruct.h` and `pnginfo.h` header files that are\n+not accessible to applications.  It is strongly suggested that new\n+programs use the new APIs (as shown in `example.c` and `pngtest.c`),\n+and older programs be converted to the new format, to facilitate\n+upgrades in the future.\n+\n+The additions since 0.89 include the ability to read from a PNG stream\n+which has had some (or all) of the signature bytes read by the calling\n+application.  This also allows the reading of embedded PNG streams that\n+do not have the PNG file signature.  As well, it is now possible to set\n+the library action on the detection of chunk CRC errors.  It is possible\n+to set different actions based on whether the CRC error occurred in a\n+critical or an ancillary chunk.\n+\n+The additions since 0.90 include the ability to compile libpng as a\n+Windows DLL, and new APIs for accessing data in the `info_struct`.\n+Experimental functions included the ability to set weighting and cost\n+factors for row filter selection, direct reads of integers from buffers\n+on big-endian processors that support misaligned data access, faster\n+methods of doing alpha composition, and more accurate 16-to-8 bit color\n+conversion.  Some of these experimental functions, such as the weighted\n+filter heuristics, have since been removed.\n@@ -107,1 +104,2 @@\n-Files in this distribution:\n+Files included in this distribution\n+-----------------------------------\n@@ -147,4 +145,6 @@\n-    arm\/          =>  Optimized code for the ARM platform\n-    intel\/        =>  Optimized code for the INTEL-SSE2 platform\n-    mips\/         =>  Optimized code for the MIPS platform\n-    powerpc\/      =>  Optimized code for the PowerPC platform\n+    arm\/          =>  Optimized code for ARM Neon\n+    intel\/        =>  Optimized code for INTEL SSE2\n+    loongarch\/    =>  Optimized code for LoongArch LSX\n+    mips\/         =>  Optimized code for MIPS MSA and MIPS MMI\n+    powerpc\/      =>  Optimized code for PowerPC VSX\n+    riscv\/        =>  Optimized code for the RISC-V platform\n@@ -156,1 +156,1 @@\n-        examples\/     =>  Example programs\n+        examples\/     =>  Examples of libpng usage\n@@ -161,2 +161,1 @@\n-        oss-fuzz\/     =>  Files used by the OSS-Fuzz project for fuzz-testing\n-                          libpng\n+        pngexif\/      =>  Program to inspect the EXIF information in PNG files\n@@ -167,0 +166,1 @@\n+        riscv-rvv\/    =>  Optimized code for the RISC-V Vector platform\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/README","additions":88,"deletions":88,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+Updating libpng in OpenJDK\n+\n+1) Update the libpng section of the THIRD_PARTY_README file.  Usually\n+this is just a matter of updating the version at the top, and in the\n+embedded text, and extending the copyright date.\n+\n+The updated info comes from the LICENSE, TRADEMARK and AUTHORS files.\n+\n+2) Copy LICENSE, README, and CHANGES from the new version into OpenJDK's\n+libpng source directory\n+\n+3) OpenJDK includes just a subset of the files, since we use it only for reading.\n+Copy only the same .c and .h files as are already there and re-apply the\n+GPL v2 + CP header to all the updated files. These files also have a special\n+note referencing the previous license. Restore everything as it was.\n+You can either do this with a clever-enough script, or manually copy\/paste.\n+There are 18 files to update so either is do-able.\n+\n+4) Special and careful handling of pnglibconf.h\n+OpenJDK has a heavily modified copy of pnglibconf.h.\n+This is the trickiest part of the whole exercise.\n+This file is generated by png at build time.\n+Except for the dates and version, you should generally not need to update\n+OpenJDK's copy unless the new version of PNG has added required new #defines\n+that cause problems building.\n+You can run configure && make on the downloaded source and compare, but we\n+do not want to enable any of the WRITE support, and there are many more\n+modifications as well.\n+So do NOT just copy in a file from the new libpng.\n+The header may be the only thing you want to update.\n+Also this file has a special \"THIS FILE WAS MODIFIED BY ORACLE, INC.\"\n+line in the GPL header.\n+So lots of reasons to not copy over the new version,\n+and instead just tweak the existing one.\n+\n+5) Run script to expand tabs and remove trailing white space from source files.\n+\n+First cd into the libpng folder and run the following script.\n+\n+    shopt -s nullglob\n+    for f in *.c *.h;\n+         do\n+            # replace tabs with spaces\n+            expand ${f} > ${f}.tmp\n+            mv ${f}.tmp $f\n+\n+            # fix line endings to LF\n+            sed -e 's\/\\r$\/\/g' ${f} > ${f}.tmp\n+            mv ${f}.tmp $f\n+\n+            # remove trailing spaces\n+            sed -e 's\/[ ]* $\/\/g' ${f} > ${f}.tmp\n+            mv ${f}.tmp $f\n+         done\n+\n+6) As with all native code, run it through the official build systems, in case\n+the updated code trigger any fatal warnings with the official compilers.\n+\n+7) Run the splashscreen jtreg tests. \n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/UPDATING.txt","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2022 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -45,13 +45,20 @@\n-typedef png_libpng_version_1_6_39 Your_png_h_is_not_version_1_6_39;\n-\n-#ifdef __GNUC__\n-\/* The version tests may need to be added to, but the problem warning has\n- * consistently been fixed in GCC versions which obtain wide-spread release.\n- * The problem is that many versions of GCC rearrange comparison expressions in\n- * the optimizer in such a way that the results of the comparison will change\n- * if signed integer overflow occurs.  Such comparisons are not permitted in\n- * ANSI C90, however GCC isn't clever enough to work out that that do not occur\n- * below in png_ascii_from_fp and png_muldiv, so it produces a warning with\n- * -Wextra.  Unfortunately this is highly dependent on the optimizer and the\n- * machine architecture so the warning comes and goes unpredictably and is\n- * impossible to \"fix\", even were that a good idea.\n+typedef png_libpng_version_1_6_51 Your_png_h_is_not_version_1_6_51;\n+\n+\/* Sanity check the chunks definitions - PNG_KNOWN_CHUNKS from pngpriv.h and the\n+ * corresponding macro definitions.  This causes a compile time failure if\n+ * something is wrong but generates no code.\n+ *\n+ * (1) The first check is that the PNG_CHUNK(cHNK, index) 'index' values must\n+ * increment from 0 to the last value.\n+ *\/\n+#define PNG_CHUNK(cHNK, index) != (index) || ((index)+1)\n+\n+#if 0 PNG_KNOWN_CHUNKS < 0\n+#  error PNG_KNOWN_CHUNKS chunk definitions are not in order\n+#endif\n+\n+#undef PNG_CHUNK\n+\n+\/* (2) The chunk name macros, png_cHNK, must all be valid and defined.  Since\n+ * this is a preprocessor test undefined pp-tokens come out as zero and will\n+ * fail this test.\n@@ -59,6 +66,4 @@\n-#if __GNUC__ == 7 && __GNUC_MINOR__ == 1\n-#define GCC_STRICT_OVERFLOW 1\n-#endif \/* GNU 7.1.x *\/\n-#endif \/* GNU *\/\n-#ifndef GCC_STRICT_OVERFLOW\n-#define GCC_STRICT_OVERFLOW 0\n+#define PNG_CHUNK(cHNK, index) !PNG_CHUNK_NAME_VALID(png_ ## cHNK) ||\n+\n+#if PNG_KNOWN_CHUNKS 0\n+#  error png_cHNK not defined for some known cHNK\n@@ -67,0 +72,2 @@\n+#undef PNG_CHUNK\n+\n@@ -104,1 +111,1 @@\n-   png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};\n+   static const png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};\n@@ -110,1 +117,1 @@\n-      return (-1);\n+      return -1;\n@@ -113,1 +120,1 @@\n-      return (-1);\n+      return -1;\n@@ -118,1 +125,1 @@\n-   return ((int)(memcmp(&sig[start], &png_signature[start], num_to_check)));\n+   return memcmp(&sig[start], &png_signature[start], num_to_check);\n@@ -133,1 +140,7 @@\n-   if (items >= (~(png_alloc_size_t)0)\/size)\n+   \/* This check against overflow is vestigial, dating back from\n+    * the old times when png_zalloc used to be an exported function.\n+    * We're still keeping it here for now, as an extra-cautious\n+    * prevention against programming errors inside zlib, although it\n+    * should rather be a debug-time assertion instead.\n+    *\/\n+   if (size != 0 && items >= (~(png_alloc_size_t)0) \/ size)\n@@ -135,2 +148,2 @@\n-      png_warning (png_voidcast(png_structrp, png_ptr),\n-          \"Potential overflow in png_zalloc()\");\n+      png_warning(png_voidcast(png_structrp, png_ptr),\n+                  \"Potential overflow in png_zalloc()\");\n@@ -263,4 +276,0 @@\n-#ifdef PNG_ERROR_NUMBERS_SUPPORTED\n-      png_ptr->flags = 0;\n-#endif\n-\n@@ -293,1 +302,0 @@\n-   \/* Added at libpng-1.2.6 *\/\n@@ -299,1 +307,0 @@\n-      \/* Added at libpng-1.2.43 and 1.4.0 *\/\n@@ -303,4 +310,1 @@\n-#     ifdef PNG_USER_CHUNK_MALLOC_MAX\n-      \/* Added at libpng-1.2.43 and 1.4.1, required only for read but exists\n-       * in png_struct regardless.\n-       *\/\n+#     if PNG_USER_CHUNK_MALLOC_MAX > 0 \/* default to compile-time limit *\/\n@@ -308,0 +312,7 @@\n+\n+      \/* No compile-time limit, so initialize to the system limit: *\/\n+#     elif defined PNG_MAX_MALLOC_64K \/* legacy system limit *\/\n+      create_struct.user_chunk_malloc_max = 65536U;\n+\n+#     else \/* modern system limit SIZE_MAX (C99) *\/\n+      create_struct.user_chunk_malloc_max = PNG_SIZE_MAX;\n@@ -478,1 +489,0 @@\n-\/* The following API is not called internally *\/\n@@ -650,7 +660,0 @@\n-# ifdef PNG_READ_eXIf_SUPPORTED\n-      if (info_ptr->eXIf_buf)\n-      {\n-         png_free(png_ptr, info_ptr->eXIf_buf);\n-         info_ptr->eXIf_buf = NULL;\n-      }\n-# endif\n@@ -717,1 +720,1 @@\n-      return (NULL);\n+      return NULL;\n@@ -719,1 +722,1 @@\n-   return (png_ptr->io_ptr);\n+   return png_ptr->io_ptr;\n@@ -731,1 +734,1 @@\n-png_init_io(png_structrp png_ptr, png_FILE_p fp)\n+png_init_io(png_structrp png_ptr, FILE *fp)\n@@ -783,1 +786,1 @@\n-      char number_buf[5]; \/* enough for a four-digit year *\/\n+      char number_buf[5] = {0, 0, 0, 0, 0}; \/* enough for a four-digit year *\/\n@@ -846,2 +849,2 @@\n-      \"libpng version 1.6.39\" PNG_STRING_NEWLINE \\\n-      \"Copyright (c) 2018-2022 Cosmin Truta\" PNG_STRING_NEWLINE \\\n+      \"libpng version 1.6.51\" PNG_STRING_NEWLINE \\\n+      \"Copyright (c) 2018-2025 Cosmin Truta\" PNG_STRING_NEWLINE \\\n@@ -1008,1 +1011,1 @@\n-   return (inflateReset(&png_ptr->zstream));\n+   return inflateReset(&png_ptr->zstream);\n@@ -1017,1 +1020,1 @@\n-   return((png_uint_32)PNG_LIBPNG_VER);\n+   return (png_uint_32)PNG_LIBPNG_VER;\n@@ -1091,18 +1094,3 @@\n-\/* png_convert_size: a PNGAPI but no longer in png.h, so deleted\n- * at libpng 1.5.5!\n- *\/\n-\n-\/* Added at libpng version 1.2.34 and 1.4.0 (moved from pngset.c) *\/\n-#ifdef PNG_GAMMA_SUPPORTED \/* always set if COLORSPACE *\/\n-static int\n-png_colorspace_check_gamma(png_const_structrp png_ptr,\n-    png_colorspacerp colorspace, png_fixed_point gAMA, int from)\n-   \/* This is called to check a new gamma value against an existing one.  The\n-    * routine returns false if the new gamma value should not be written.\n-    *\n-    * 'from' says where the new gamma value comes from:\n-    *\n-    *    0: the new gamma value is the libpng estimate for an ICC profile\n-    *    1: the new gamma value comes from a gAMA chunk\n-    *    2: the new gamma value comes from an sRGB chunk\n-    *\/\n+#ifdef PNG_COLORSPACE_SUPPORTED\n+static png_int_32\n+png_fp_add(png_int_32 addend0, png_int_32 addend1, int *error)\n@@ -1110,5 +1098,7 @@\n-   png_fixed_point gtest;\n-\n-   if ((colorspace->flags & PNG_COLORSPACE_HAVE_GAMMA) != 0 &&\n-       (png_muldiv(&gtest, colorspace->gamma, PNG_FP_1, gAMA) == 0  ||\n-      png_gamma_significant(gtest) != 0))\n+   \/* Safely add two fixed point values setting an error flag and returning 0.5\n+    * on overflow.\n+    * IMPLEMENTATION NOTE: ANSI requires signed overflow not to occur, therefore\n+    * relying on addition of two positive values producing a negative one is not\n+    * safe.\n+    *\/\n+   if (addend0 > 0)\n@@ -1116,20 +1106,2 @@\n-      \/* Either this is an sRGB image, in which case the calculated gamma\n-       * approximation should match, or this is an image with a profile and the\n-       * value libpng calculates for the gamma of the profile does not match the\n-       * value recorded in the file.  The former, sRGB, case is an error, the\n-       * latter is just a warning.\n-       *\/\n-      if ((colorspace->flags & PNG_COLORSPACE_FROM_sRGB) != 0 || from == 2)\n-      {\n-         png_chunk_report(png_ptr, \"gamma value does not match sRGB\",\n-             PNG_CHUNK_ERROR);\n-         \/* Do not overwrite an sRGB value *\/\n-         return from == 2;\n-      }\n-\n-      else \/* sRGB tag not involved *\/\n-      {\n-         png_chunk_report(png_ptr, \"gamma value does not match libpng estimate\",\n-             PNG_CHUNK_WARNING);\n-         return from == 1;\n-      }\n+      if (0x7fffffff - addend0 >= addend1)\n+         return addend0+addend1;\n@@ -1137,36 +1109,1 @@\n-\n-   return 1;\n-}\n-\n-void \/* PRIVATE *\/\n-png_colorspace_set_gamma(png_const_structrp png_ptr,\n-    png_colorspacerp colorspace, png_fixed_point gAMA)\n-{\n-   \/* Changed in libpng-1.5.4 to limit the values to ensure overflow can't\n-    * occur.  Since the fixed point representation is asymmetrical it is\n-    * possible for 1\/gamma to overflow the limit of 21474 and this means the\n-    * gamma value must be at least 5\/100000 and hence at most 20000.0.  For\n-    * safety the limits here are a little narrower.  The values are 0.00016 to\n-    * 6250.0, which are truly ridiculous gamma values (and will produce\n-    * displays that are all black or all white.)\n-    *\n-    * In 1.6.0 this test replaces the ones in pngrutil.c, in the gAMA chunk\n-    * handling code, which only required the value to be >0.\n-    *\/\n-   png_const_charp errmsg;\n-\n-   if (gAMA < 16 || gAMA > 625000000)\n-      errmsg = \"gamma value out of range\";\n-\n-#  ifdef PNG_READ_gAMA_SUPPORTED\n-   \/* Allow the application to set the gamma value more than once *\/\n-   else if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&\n-      (colorspace->flags & PNG_COLORSPACE_FROM_gAMA) != 0)\n-      errmsg = \"duplicate\";\n-#  endif\n-\n-   \/* Do nothing if the colorspace is already invalid *\/\n-   else if ((colorspace->flags & PNG_COLORSPACE_INVALID) != 0)\n-      return;\n-\n-   else\n+   else if (addend0 < 0)\n@@ -1174,15 +1111,2 @@\n-      if (png_colorspace_check_gamma(png_ptr, colorspace, gAMA,\n-          1\/*from gAMA*\/) != 0)\n-      {\n-         \/* Store this gamma value. *\/\n-         colorspace->gamma = gAMA;\n-         colorspace->flags |=\n-            (PNG_COLORSPACE_HAVE_GAMMA | PNG_COLORSPACE_FROM_gAMA);\n-      }\n-\n-      \/* At present if the check_gamma test fails the gamma of the colorspace is\n-       * not updated however the colorspace is not invalidated.  This\n-       * corresponds to the case where the existing gamma comes from an sRGB\n-       * chunk or profile.  An error message has already been output.\n-       *\/\n-      return;\n+      if (-0x7fffffff - addend0 <= addend1)\n+         return addend0+addend1;\n@@ -1190,0 +1114,2 @@\n+   else\n+      return addend1;\n@@ -1191,3 +1117,2 @@\n-   \/* Error exit - errmsg has been set. *\/\n-   colorspace->flags |= PNG_COLORSPACE_INVALID;\n-   png_chunk_report(png_ptr, errmsg, PNG_CHUNK_WRITE_ERROR);\n+   *error = 1;\n+   return PNG_FP_1\/2;\n@@ -1196,2 +1121,2 @@\n-void \/* PRIVATE *\/\n-png_colorspace_sync_info(png_const_structrp png_ptr, png_inforp info_ptr)\n+static png_int_32\n+png_fp_sub(png_int_32 addend0, png_int_32 addend1, int *error)\n@@ -1199,1 +1124,2 @@\n-   if ((info_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)\n+   \/* As above but calculate addend0-addend1. *\/\n+   if (addend1 > 0)\n@@ -1201,10 +1127,2 @@\n-      \/* Everything is invalid *\/\n-      info_ptr->valid &= ~(PNG_INFO_gAMA|PNG_INFO_cHRM|PNG_INFO_sRGB|\n-         PNG_INFO_iCCP);\n-\n-#     ifdef PNG_COLORSPACE_SUPPORTED\n-      \/* Clean up the iCCP profile now if it won't be used. *\/\n-      png_free_data(png_ptr, info_ptr, PNG_FREE_ICCP, -1\/*not used*\/);\n-#     else\n-      PNG_UNUSED(png_ptr)\n-#     endif\n+      if (-0x7fffffff + addend1 <= addend0)\n+         return addend0-addend1;\n@@ -1212,2 +1130,1 @@\n-\n-   else\n+   else if (addend1 < 0)\n@@ -1215,23 +1132,2 @@\n-#     ifdef PNG_COLORSPACE_SUPPORTED\n-      \/* Leave the INFO_iCCP flag set if the pngset.c code has already set\n-       * it; this allows a PNG to contain a profile which matches sRGB and\n-       * yet still have that profile retrievable by the application.\n-       *\/\n-      if ((info_ptr->colorspace.flags & PNG_COLORSPACE_MATCHES_sRGB) != 0)\n-         info_ptr->valid |= PNG_INFO_sRGB;\n-\n-      else\n-         info_ptr->valid &= ~PNG_INFO_sRGB;\n-\n-      if ((info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)\n-         info_ptr->valid |= PNG_INFO_cHRM;\n-\n-      else\n-         info_ptr->valid &= ~PNG_INFO_cHRM;\n-#     endif\n-\n-      if ((info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_GAMMA) != 0)\n-         info_ptr->valid |= PNG_INFO_gAMA;\n-\n-      else\n-         info_ptr->valid &= ~PNG_INFO_gAMA;\n+      if (0x7fffffff + addend1 >= addend0)\n+         return addend0-addend1;\n@@ -1239,0 +1135,5 @@\n+   else\n+      return addend0;\n+\n+   *error = 1;\n+   return PNG_FP_1\/2;\n@@ -1241,3 +1142,3 @@\n-#ifdef PNG_READ_SUPPORTED\n-void \/* PRIVATE *\/\n-png_colorspace_sync(png_const_structrp png_ptr, png_inforp info_ptr)\n+static int\n+png_safe_add(png_int_32 *addend0_and_result, png_int_32 addend1,\n+      png_int_32 addend2)\n@@ -1245,5 +1146,9 @@\n-   if (info_ptr == NULL) \/* reduce code size; check here not in the caller *\/\n-      return;\n-\n-   info_ptr->colorspace = png_ptr->colorspace;\n-   png_colorspace_sync_info(png_ptr, info_ptr);\n+   \/* Safely add three integers.  Returns 0 on success, 1 on overflow.  Does not\n+    * set the result on overflow.\n+    *\/\n+   int error = 0;\n+   int result = png_fp_add(*addend0_and_result,\n+                           png_fp_add(addend1, addend2, &error),\n+                           &error);\n+   if (!error) *addend0_and_result = result;\n+   return error;\n@@ -1251,2 +1156,0 @@\n-#endif\n-#endif \/* GAMMA *\/\n@@ -1254,1 +1157,0 @@\n-#ifdef PNG_COLORSPACE_SUPPORTED\n@@ -1260,1 +1162,1 @@\n-static int\n+int \/* PRIVATE *\/\n@@ -1263,1 +1165,2 @@\n-   png_int_32 d, dwhite, whiteX, whiteY;\n+   \/* NOTE: returns 0 on success, 1 means error. *\/\n+   png_int_32 d, dred, dgreen, dblue, dwhite, whiteX, whiteY;\n@@ -1265,2 +1168,5 @@\n-   d = XYZ->red_X + XYZ->red_Y + XYZ->red_Z;\n-   if (png_muldiv(&xy->redx, XYZ->red_X, PNG_FP_1, d) == 0)\n+   \/* 'd' in each of the blocks below is just X+Y+Z for each component,\n+    * x, y and z are X,Y,Z\/(X+Y+Z).\n+    *\/\n+   d = XYZ->red_X;\n+   if (png_safe_add(&d, XYZ->red_Y, XYZ->red_Z))\n@@ -1268,1 +1174,4 @@\n-   if (png_muldiv(&xy->redy, XYZ->red_Y, PNG_FP_1, d) == 0)\n+   dred = d;\n+   if (png_muldiv(&xy->redx, XYZ->red_X, PNG_FP_1, dred) == 0)\n+      return 1;\n+   if (png_muldiv(&xy->redy, XYZ->red_Y, PNG_FP_1, dred) == 0)\n@@ -1270,3 +1179,0 @@\n-   dwhite = d;\n-   whiteX = XYZ->red_X;\n-   whiteY = XYZ->red_Y;\n@@ -1274,2 +1180,5 @@\n-   d = XYZ->green_X + XYZ->green_Y + XYZ->green_Z;\n-   if (png_muldiv(&xy->greenx, XYZ->green_X, PNG_FP_1, d) == 0)\n+   d = XYZ->green_X;\n+   if (png_safe_add(&d, XYZ->green_Y, XYZ->green_Z))\n+      return 1;\n+   dgreen = d;\n+   if (png_muldiv(&xy->greenx, XYZ->green_X, PNG_FP_1, dgreen) == 0)\n@@ -1277,1 +1186,1 @@\n-   if (png_muldiv(&xy->greeny, XYZ->green_Y, PNG_FP_1, d) == 0)\n+   if (png_muldiv(&xy->greeny, XYZ->green_Y, PNG_FP_1, dgreen) == 0)\n@@ -1279,3 +1188,0 @@\n-   dwhite += d;\n-   whiteX += XYZ->green_X;\n-   whiteY += XYZ->green_Y;\n@@ -1283,2 +1189,2 @@\n-   d = XYZ->blue_X + XYZ->blue_Y + XYZ->blue_Z;\n-   if (png_muldiv(&xy->bluex, XYZ->blue_X, PNG_FP_1, d) == 0)\n+   d = XYZ->blue_X;\n+   if (png_safe_add(&d, XYZ->blue_Y, XYZ->blue_Z))\n@@ -1286,1 +1192,4 @@\n-   if (png_muldiv(&xy->bluey, XYZ->blue_Y, PNG_FP_1, d) == 0)\n+   dblue = d;\n+   if (png_muldiv(&xy->bluex, XYZ->blue_X, PNG_FP_1, dblue) == 0)\n+      return 1;\n+   if (png_muldiv(&xy->bluey, XYZ->blue_Y, PNG_FP_1, dblue) == 0)\n@@ -1288,3 +1197,0 @@\n-   dwhite += d;\n-   whiteX += XYZ->blue_X;\n-   whiteY += XYZ->blue_Y;\n@@ -1292,2 +1198,3 @@\n-   \/* The reference white is simply the sum of the end-point (X,Y,Z) vectors,\n-    * thus:\n+   \/* The reference white is simply the sum of the end-point (X,Y,Z) vectors so\n+    * the fillowing calculates (X+Y+Z) of the reference white (media white,\n+    * encoding white) itself:\n@@ -1295,0 +1202,18 @@\n+   d = dblue;\n+   if (png_safe_add(&d, dred, dgreen))\n+      return 1;\n+   dwhite = d;\n+\n+   \/* Find the white X,Y values from the sum of the red, green and blue X,Y\n+    * values.\n+    *\/\n+   d = XYZ->red_X;\n+   if (png_safe_add(&d, XYZ->green_X, XYZ->blue_X))\n+      return 1;\n+   whiteX = d;\n+\n+   d = XYZ->red_Y;\n+   if (png_safe_add(&d, XYZ->green_Y, XYZ->blue_Y))\n+      return 1;\n+   whiteY = d;\n+\n@@ -1303,1 +1228,1 @@\n-static int\n+int \/* PRIVATE *\/\n@@ -1306,0 +1231,1 @@\n+   \/* NOTE: returns 0 on success, 1 means error. *\/\n@@ -1313,0 +1239,8 @@\n+    *\n+    * The limits here will *not* accept ACES AP0, where bluey is -7700\n+    * (-0.0770) because the PNG spec itself requires the xy values to be\n+    * unsigned.  whitey is also required to be 5 or more to avoid overflow.\n+    *\n+    * Instead the upper limits have been relaxed to accomodate ACES AP1 where\n+    * redz ends up as -600 (-0.006).  ProPhotoRGB was already \"in range.\"\n+    * The new limit accomodates the AP0 and AP1 ranges for z but not AP0 redy.\n@@ -1314,8 +1248,9 @@\n-   if (xy->redx   < 0 || xy->redx > PNG_FP_1) return 1;\n-   if (xy->redy   < 0 || xy->redy > PNG_FP_1-xy->redx) return 1;\n-   if (xy->greenx < 0 || xy->greenx > PNG_FP_1) return 1;\n-   if (xy->greeny < 0 || xy->greeny > PNG_FP_1-xy->greenx) return 1;\n-   if (xy->bluex  < 0 || xy->bluex > PNG_FP_1) return 1;\n-   if (xy->bluey  < 0 || xy->bluey > PNG_FP_1-xy->bluex) return 1;\n-   if (xy->whitex < 0 || xy->whitex > PNG_FP_1) return 1;\n-   if (xy->whitey < 5 || xy->whitey > PNG_FP_1-xy->whitex) return 1;\n+   const png_fixed_point fpLimit = PNG_FP_1+(PNG_FP_1\/10);\n+   if (xy->redx   < 0 || xy->redx > fpLimit) return 1;\n+   if (xy->redy   < 0 || xy->redy > fpLimit-xy->redx) return 1;\n+   if (xy->greenx < 0 || xy->greenx > fpLimit) return 1;\n+   if (xy->greeny < 0 || xy->greeny > fpLimit-xy->greenx) return 1;\n+   if (xy->bluex  < 0 || xy->bluex > fpLimit) return 1;\n+   if (xy->bluey  < 0 || xy->bluey > fpLimit-xy->bluex) return 1;\n+   if (xy->whitex < 0 || xy->whitex > fpLimit) return 1;\n+   if (xy->whitey < 5 || xy->whitey > fpLimit-xy->whitex) return 1;\n@@ -1466,5 +1401,10 @@\n-    * The input values have 5 decimal digits of accuracy.  The values are all in\n-    * the range 0 < value < 1, so simple products are in the same range but may\n-    * need up to 10 decimal digits to preserve the original precision and avoid\n-    * underflow.  Because we are using a 32-bit signed representation we cannot\n-    * match this; the best is a little over 9 decimal digits, less than 10.\n+    * The input values have 5 decimal digits of accuracy.\n+    *\n+    * In the previous implementation the values were all in the range 0 < value\n+    * < 1, so simple products are in the same range but may need up to 10\n+    * decimal digits to preserve the original precision and avoid underflow.\n+    * Because we are using a 32-bit signed representation we cannot match this;\n+    * the best is a little over 9 decimal digits, less than 10.\n+    *\n+    * This range has now been extended to allow values up to 1.1, or 110,000 in\n+    * fixed point.\n@@ -1474,4 +1414,4 @@\n-    * difference between two products of values that must be in the range -1..+1\n-    * it is sufficient to divide the product by 7; ceil(100,000\/32767*2).  The\n-    * factor is irrelevant in the calculation because it is applied to both\n-    * numerator and denominator.\n+    * difference between two products of values that must be in the range\n+    * -1.1..+1.1 it is sufficient to divide the product by 8;\n+    * ceil(121,000\/32767*2).  The factor is irrelevant in the calculation\n+    * because it is applied to both numerator and denominator.\n@@ -1499,23 +1439,2 @@\n-   \/* By the argument, above overflow should be impossible here. The return\n-    * value of 2 indicates an internal error to the caller.\n-    *\/\n-   if (png_muldiv(&left, xy->greenx-xy->bluex, xy->redy - xy->bluey, 7) == 0)\n-      return 2;\n-   if (png_muldiv(&right, xy->greeny-xy->bluey, xy->redx - xy->bluex, 7) == 0)\n-      return 2;\n-   denominator = left - right;\n-\n-   \/* Now find the red numerator. *\/\n-   if (png_muldiv(&left, xy->greenx-xy->bluex, xy->whitey-xy->bluey, 7) == 0)\n-      return 2;\n-   if (png_muldiv(&right, xy->greeny-xy->bluey, xy->whitex-xy->bluex, 7) == 0)\n-      return 2;\n-\n-   \/* Overflow is possible here and it indicates an extreme set of PNG cHRM\n-    * chunk values.  This calculation actually returns the reciprocal of the\n-    * scale value because this allows us to delay the multiplication of white-y\n-    * into the denominator, which tends to produce a small number.\n-    *\/\n-   if (png_muldiv(&red_inverse, xy->whitey, denominator, left-right) == 0 ||\n-       red_inverse <= xy->whitey \/* r+g+b scales = white scale *\/)\n-      return 1;\n+   {\n+      int error = 0;\n@@ -1523,8 +1442,13 @@\n-   \/* Similarly for green_inverse: *\/\n-   if (png_muldiv(&left, xy->redy-xy->bluey, xy->whitex-xy->bluex, 7) == 0)\n-      return 2;\n-   if (png_muldiv(&right, xy->redx-xy->bluex, xy->whitey-xy->bluey, 7) == 0)\n-      return 2;\n-   if (png_muldiv(&green_inverse, xy->whitey, denominator, left-right) == 0 ||\n-       green_inverse <= xy->whitey)\n-      return 1;\n+      \/* By the argument above overflow should be impossible here, however the\n+       * code now simply returns a failure code.  The xy subtracts in the\n+       * arguments to png_muldiv are *not* checked for overflow because the\n+       * checks at the start guarantee they are in the range 0..110000 and\n+       * png_fixed_point is a 32-bit signed number.\n+       *\/\n+      if (png_muldiv(&left, xy->greenx-xy->bluex, xy->redy - xy->bluey, 8) == 0)\n+         return 1;\n+      if (png_muldiv(&right, xy->greeny-xy->bluey, xy->redx - xy->bluex, 8) ==\n+            0)\n+         return 1;\n+      denominator = png_fp_sub(left, right, &error);\n+      if (error) return 1;\n@@ -1532,7 +1456,16 @@\n-   \/* And the blue scale, the checks above guarantee this can't overflow but it\n-    * can still produce 0 for extreme cHRM values.\n-    *\/\n-   blue_scale = png_reciprocal(xy->whitey) - png_reciprocal(red_inverse) -\n-       png_reciprocal(green_inverse);\n-   if (blue_scale <= 0)\n-      return 1;\n+      \/* Now find the red numerator. *\/\n+      if (png_muldiv(&left, xy->greenx-xy->bluex, xy->whitey-xy->bluey, 8) == 0)\n+         return 1;\n+      if (png_muldiv(&right, xy->greeny-xy->bluey, xy->whitex-xy->bluex, 8) ==\n+            0)\n+         return 1;\n+\n+      \/* Overflow is possible here and it indicates an extreme set of PNG cHRM\n+       * chunk values.  This calculation actually returns the reciprocal of the\n+       * scale value because this allows us to delay the multiplication of\n+       * white-y into the denominator, which tends to produce a small number.\n+       *\/\n+      if (png_muldiv(&red_inverse, xy->whitey, denominator,\n+                     png_fp_sub(left, right, &error)) == 0 || error ||\n+          red_inverse <= xy->whitey \/* r+g+b scales = white scale *\/)\n+         return 1;\n@@ -1540,0 +1473,19 @@\n+      \/* Similarly for green_inverse: *\/\n+      if (png_muldiv(&left, xy->redy-xy->bluey, xy->whitex-xy->bluex, 8) == 0)\n+         return 1;\n+      if (png_muldiv(&right, xy->redx-xy->bluex, xy->whitey-xy->bluey, 8) == 0)\n+         return 1;\n+      if (png_muldiv(&green_inverse, xy->whitey, denominator,\n+                     png_fp_sub(left, right, &error)) == 0 || error ||\n+          green_inverse <= xy->whitey)\n+         return 1;\n+\n+      \/* And the blue scale, the checks above guarantee this can't overflow but\n+       * it can still produce 0 for extreme cHRM values.\n+       *\/\n+      blue_scale = png_fp_sub(png_fp_sub(png_reciprocal(xy->whitey),\n+                                         png_reciprocal(red_inverse), &error),\n+                              png_reciprocal(green_inverse), &error);\n+      if (error || blue_scale <= 0)\n+         return 1;\n+   }\n@@ -1541,1 +1493,4 @@\n-   \/* And fill in the png_XYZ: *\/\n+   \/* And fill in the png_XYZ.  Again the subtracts are safe because of the\n+    * checks on the xy values at the start (the subtracts just calculate the\n+    * corresponding z values.)\n+    *\/\n@@ -1568,0 +1523,1 @@\n+#endif \/* COLORSPACE *\/\n@@ -1569,243 +1525,1 @@\n-static int\n-png_XYZ_normalize(png_XYZ *XYZ)\n-{\n-   png_int_32 Y;\n-\n-   if (XYZ->red_Y < 0 || XYZ->green_Y < 0 || XYZ->blue_Y < 0 ||\n-      XYZ->red_X < 0 || XYZ->green_X < 0 || XYZ->blue_X < 0 ||\n-      XYZ->red_Z < 0 || XYZ->green_Z < 0 || XYZ->blue_Z < 0)\n-      return 1;\n-\n-   \/* Normalize by scaling so the sum of the end-point Y values is PNG_FP_1.\n-    * IMPLEMENTATION NOTE: ANSI requires signed overflow not to occur, therefore\n-    * relying on addition of two positive values producing a negative one is not\n-    * safe.\n-    *\/\n-   Y = XYZ->red_Y;\n-   if (0x7fffffff - Y < XYZ->green_X)\n-      return 1;\n-   Y += XYZ->green_Y;\n-   if (0x7fffffff - Y < XYZ->blue_X)\n-      return 1;\n-   Y += XYZ->blue_Y;\n-\n-   if (Y != PNG_FP_1)\n-   {\n-      if (png_muldiv(&XYZ->red_X, XYZ->red_X, PNG_FP_1, Y) == 0)\n-         return 1;\n-      if (png_muldiv(&XYZ->red_Y, XYZ->red_Y, PNG_FP_1, Y) == 0)\n-         return 1;\n-      if (png_muldiv(&XYZ->red_Z, XYZ->red_Z, PNG_FP_1, Y) == 0)\n-         return 1;\n-\n-      if (png_muldiv(&XYZ->green_X, XYZ->green_X, PNG_FP_1, Y) == 0)\n-         return 1;\n-      if (png_muldiv(&XYZ->green_Y, XYZ->green_Y, PNG_FP_1, Y) == 0)\n-         return 1;\n-      if (png_muldiv(&XYZ->green_Z, XYZ->green_Z, PNG_FP_1, Y) == 0)\n-         return 1;\n-\n-      if (png_muldiv(&XYZ->blue_X, XYZ->blue_X, PNG_FP_1, Y) == 0)\n-         return 1;\n-      if (png_muldiv(&XYZ->blue_Y, XYZ->blue_Y, PNG_FP_1, Y) == 0)\n-         return 1;\n-      if (png_muldiv(&XYZ->blue_Z, XYZ->blue_Z, PNG_FP_1, Y) == 0)\n-         return 1;\n-   }\n-\n-   return 0;\n-}\n-\n-static int\n-png_colorspace_endpoints_match(const png_xy *xy1, const png_xy *xy2, int delta)\n-{\n-   \/* Allow an error of +\/-0.01 (absolute value) on each chromaticity *\/\n-   if (PNG_OUT_OF_RANGE(xy1->whitex, xy2->whitex,delta) ||\n-       PNG_OUT_OF_RANGE(xy1->whitey, xy2->whitey,delta) ||\n-       PNG_OUT_OF_RANGE(xy1->redx,   xy2->redx,  delta) ||\n-       PNG_OUT_OF_RANGE(xy1->redy,   xy2->redy,  delta) ||\n-       PNG_OUT_OF_RANGE(xy1->greenx, xy2->greenx,delta) ||\n-       PNG_OUT_OF_RANGE(xy1->greeny, xy2->greeny,delta) ||\n-       PNG_OUT_OF_RANGE(xy1->bluex,  xy2->bluex, delta) ||\n-       PNG_OUT_OF_RANGE(xy1->bluey,  xy2->bluey, delta))\n-      return 0;\n-   return 1;\n-}\n-\n-\/* Added in libpng-1.6.0, a different check for the validity of a set of cHRM\n- * chunk chromaticities.  Earlier checks used to simply look for the overflow\n- * condition (where the determinant of the matrix to solve for XYZ ends up zero\n- * because the chromaticity values are not all distinct.)  Despite this it is\n- * theoretically possible to produce chromaticities that are apparently valid\n- * but that rapidly degrade to invalid, potentially crashing, sets because of\n- * arithmetic inaccuracies when calculations are performed on them.  The new\n- * check is to round-trip xy -> XYZ -> xy and then check that the result is\n- * within a small percentage of the original.\n- *\/\n-static int\n-png_colorspace_check_xy(png_XYZ *XYZ, const png_xy *xy)\n-{\n-   int result;\n-   png_xy xy_test;\n-\n-   \/* As a side-effect this routine also returns the XYZ endpoints. *\/\n-   result = png_XYZ_from_xy(XYZ, xy);\n-   if (result != 0)\n-      return result;\n-\n-   result = png_xy_from_XYZ(&xy_test, XYZ);\n-   if (result != 0)\n-      return result;\n-\n-   if (png_colorspace_endpoints_match(xy, &xy_test,\n-       5\/*actually, the math is pretty accurate*\/) != 0)\n-      return 0;\n-\n-   \/* Too much slip *\/\n-   return 1;\n-}\n-\n-\/* This is the check going the other way.  The XYZ is modified to normalize it\n- * (another side-effect) and the xy chromaticities are returned.\n- *\/\n-static int\n-png_colorspace_check_XYZ(png_xy *xy, png_XYZ *XYZ)\n-{\n-   int result;\n-   png_XYZ XYZtemp;\n-\n-   result = png_XYZ_normalize(XYZ);\n-   if (result != 0)\n-      return result;\n-\n-   result = png_xy_from_XYZ(xy, XYZ);\n-   if (result != 0)\n-      return result;\n-\n-   XYZtemp = *XYZ;\n-   return png_colorspace_check_xy(&XYZtemp, xy);\n-}\n-\n-\/* Used to check for an endpoint match against sRGB *\/\n-static const png_xy sRGB_xy = \/* From ITU-R BT.709-3 *\/\n-{\n-   \/* color      x       y *\/\n-   \/* red   *\/ 64000, 33000,\n-   \/* green *\/ 30000, 60000,\n-   \/* blue  *\/ 15000,  6000,\n-   \/* white *\/ 31270, 32900\n-};\n-\n-static int\n-png_colorspace_set_xy_and_XYZ(png_const_structrp png_ptr,\n-    png_colorspacerp colorspace, const png_xy *xy, const png_XYZ *XYZ,\n-    int preferred)\n-{\n-   if ((colorspace->flags & PNG_COLORSPACE_INVALID) != 0)\n-      return 0;\n-\n-   \/* The consistency check is performed on the chromaticities; this factors out\n-    * variations because of the normalization (or not) of the end point Y\n-    * values.\n-    *\/\n-   if (preferred < 2 &&\n-       (colorspace->flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)\n-   {\n-      \/* The end points must be reasonably close to any we already have.  The\n-       * following allows an error of up to +\/-.001\n-       *\/\n-      if (png_colorspace_endpoints_match(xy, &colorspace->end_points_xy,\n-          100) == 0)\n-      {\n-         colorspace->flags |= PNG_COLORSPACE_INVALID;\n-         png_benign_error(png_ptr, \"inconsistent chromaticities\");\n-         return 0; \/* failed *\/\n-      }\n-\n-      \/* Only overwrite with preferred values *\/\n-      if (preferred == 0)\n-         return 1; \/* ok, but no change *\/\n-   }\n-\n-   colorspace->end_points_xy = *xy;\n-   colorspace->end_points_XYZ = *XYZ;\n-   colorspace->flags |= PNG_COLORSPACE_HAVE_ENDPOINTS;\n-\n-   \/* The end points are normally quoted to two decimal digits, so allow +\/-0.01\n-    * on this test.\n-    *\/\n-   if (png_colorspace_endpoints_match(xy, &sRGB_xy, 1000) != 0)\n-      colorspace->flags |= PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB;\n-\n-   else\n-      colorspace->flags &= PNG_COLORSPACE_CANCEL(\n-         PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB);\n-\n-   return 2; \/* ok and changed *\/\n-}\n-\n-int \/* PRIVATE *\/\n-png_colorspace_set_chromaticities(png_const_structrp png_ptr,\n-    png_colorspacerp colorspace, const png_xy *xy, int preferred)\n-{\n-   \/* We must check the end points to ensure they are reasonable - in the past\n-    * color management systems have crashed as a result of getting bogus\n-    * colorant values, while this isn't the fault of libpng it is the\n-    * responsibility of libpng because PNG carries the bomb and libpng is in a\n-    * position to protect against it.\n-    *\/\n-   png_XYZ XYZ;\n-\n-   switch (png_colorspace_check_xy(&XYZ, xy))\n-   {\n-      case 0: \/* success *\/\n-         return png_colorspace_set_xy_and_XYZ(png_ptr, colorspace, xy, &XYZ,\n-             preferred);\n-\n-      case 1:\n-         \/* We can't invert the chromaticities so we can't produce value XYZ\n-          * values.  Likely as not a color management system will fail too.\n-          *\/\n-         colorspace->flags |= PNG_COLORSPACE_INVALID;\n-         png_benign_error(png_ptr, \"invalid chromaticities\");\n-         break;\n-\n-      default:\n-         \/* libpng is broken; this should be a warning but if it happens we\n-          * want error reports so for the moment it is an error.\n-          *\/\n-         colorspace->flags |= PNG_COLORSPACE_INVALID;\n-         png_error(png_ptr, \"internal error checking chromaticities\");\n-   }\n-\n-   return 0; \/* failed *\/\n-}\n-\n-int \/* PRIVATE *\/\n-png_colorspace_set_endpoints(png_const_structrp png_ptr,\n-    png_colorspacerp colorspace, const png_XYZ *XYZ_in, int preferred)\n-{\n-   png_XYZ XYZ = *XYZ_in;\n-   png_xy xy;\n-\n-   switch (png_colorspace_check_XYZ(&xy, &XYZ))\n-   {\n-      case 0:\n-         return png_colorspace_set_xy_and_XYZ(png_ptr, colorspace, &xy, &XYZ,\n-             preferred);\n-\n-      case 1:\n-         \/* End points are invalid. *\/\n-         colorspace->flags |= PNG_COLORSPACE_INVALID;\n-         png_benign_error(png_ptr, \"invalid end points\");\n-         break;\n-\n-      default:\n-         colorspace->flags |= PNG_COLORSPACE_INVALID;\n-         png_error(png_ptr, \"internal error checking chromaticities\");\n-   }\n-\n-   return 0; \/* failed *\/\n-}\n-\n-#if defined(PNG_sRGB_SUPPORTED) || defined(PNG_iCCP_SUPPORTED)\n+#ifdef PNG_READ_iCCP_SUPPORTED\n@@ -1851,2 +1565,2 @@\n-png_icc_profile_error(png_const_structrp png_ptr, png_colorspacerp colorspace,\n-    png_const_charp name, png_alloc_size_t value, png_const_charp reason)\n+png_icc_profile_error(png_const_structrp png_ptr, png_const_charp name,\n+   png_alloc_size_t value, png_const_charp reason)\n@@ -1857,3 +1571,0 @@\n-   if (colorspace != NULL)\n-      colorspace->flags |= PNG_COLORSPACE_INVALID;\n-\n@@ -1873,2 +1584,2 @@\n-      {\n-         char number[PNG_NUMBER_BUFFER_SIZE]; \/* +24 = 114 *\/\n+   {\n+      char number[PNG_NUMBER_BUFFER_SIZE]; \/* +24 = 114 *\/\n@@ -1876,5 +1587,5 @@\n-         pos = png_safecat(message, (sizeof message), pos,\n-             png_format_number(number, number+(sizeof number),\n-             PNG_NUMBER_FORMAT_x, value));\n-         pos = png_safecat(message, (sizeof message), pos, \"h: \"); \/* +2 = 116 *\/\n-      }\n+      pos = png_safecat(message, (sizeof message), pos,\n+          png_format_number(number, number+(sizeof number),\n+          PNG_NUMBER_FORMAT_x, value));\n+      pos = png_safecat(message, (sizeof message), pos, \"h: \"); \/* +2 = 116 *\/\n+   }\n@@ -1886,7 +1597,1 @@\n-   \/* This is recoverable, but make it unconditionally an app_error on write to\n-    * avoid writing invalid ICC profiles into PNG files (i.e., we handle them\n-    * on read, with a warning, but on write unless the app turns off\n-    * application errors the PNG won't be written.)\n-    *\/\n-   png_chunk_report(png_ptr, message,\n-       (colorspace != NULL) ? PNG_CHUNK_ERROR : PNG_CHUNK_WRITE_ERROR);\n+   png_chunk_benign_error(png_ptr, message);\n@@ -1896,91 +1601,0 @@\n-#endif \/* sRGB || iCCP *\/\n-\n-#ifdef PNG_sRGB_SUPPORTED\n-int \/* PRIVATE *\/\n-png_colorspace_set_sRGB(png_const_structrp png_ptr, png_colorspacerp colorspace,\n-    int intent)\n-{\n-   \/* sRGB sets known gamma, end points and (from the chunk) intent. *\/\n-   \/* IMPORTANT: these are not necessarily the values found in an ICC profile\n-    * because ICC profiles store values adapted to a D50 environment; it is\n-    * expected that the ICC profile mediaWhitePointTag will be D50; see the\n-    * checks and code elsewhere to understand this better.\n-    *\n-    * These XYZ values, which are accurate to 5dp, produce rgb to gray\n-    * coefficients of (6968,23435,2366), which are reduced (because they add up\n-    * to 32769 not 32768) to (6968,23434,2366).  These are the values that\n-    * libpng has traditionally used (and are the best values given the 15bit\n-    * algorithm used by the rgb to gray code.)\n-    *\/\n-   static const png_XYZ sRGB_XYZ = \/* D65 XYZ (*not* the D50 adapted values!) *\/\n-   {\n-      \/* color      X      Y      Z *\/\n-      \/* red   *\/ 41239, 21264,  1933,\n-      \/* green *\/ 35758, 71517, 11919,\n-      \/* blue  *\/ 18048,  7219, 95053\n-   };\n-\n-   \/* Do nothing if the colorspace is already invalidated. *\/\n-   if ((colorspace->flags & PNG_COLORSPACE_INVALID) != 0)\n-      return 0;\n-\n-   \/* Check the intent, then check for existing settings.  It is valid for the\n-    * PNG file to have cHRM or gAMA chunks along with sRGB, but the values must\n-    * be consistent with the correct values.  If, however, this function is\n-    * called below because an iCCP chunk matches sRGB then it is quite\n-    * conceivable that an older app recorded incorrect gAMA and cHRM because of\n-    * an incorrect calculation based on the values in the profile - this does\n-    * *not* invalidate the profile (though it still produces an error, which can\n-    * be ignored.)\n-    *\/\n-   if (intent < 0 || intent >= PNG_sRGB_INTENT_LAST)\n-      return png_icc_profile_error(png_ptr, colorspace, \"sRGB\",\n-          (png_alloc_size_t)intent, \"invalid sRGB rendering intent\");\n-\n-   if ((colorspace->flags & PNG_COLORSPACE_HAVE_INTENT) != 0 &&\n-       colorspace->rendering_intent != intent)\n-      return png_icc_profile_error(png_ptr, colorspace, \"sRGB\",\n-         (png_alloc_size_t)intent, \"inconsistent rendering intents\");\n-\n-   if ((colorspace->flags & PNG_COLORSPACE_FROM_sRGB) != 0)\n-   {\n-      png_benign_error(png_ptr, \"duplicate sRGB information ignored\");\n-      return 0;\n-   }\n-\n-   \/* If the standard sRGB cHRM chunk does not match the one from the PNG file\n-    * warn but overwrite the value with the correct one.\n-    *\/\n-   if ((colorspace->flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0 &&\n-       !png_colorspace_endpoints_match(&sRGB_xy, &colorspace->end_points_xy,\n-       100))\n-      png_chunk_report(png_ptr, \"cHRM chunk does not match sRGB\",\n-         PNG_CHUNK_ERROR);\n-\n-   \/* This check is just done for the error reporting - the routine always\n-    * returns true when the 'from' argument corresponds to sRGB (2).\n-    *\/\n-   (void)png_colorspace_check_gamma(png_ptr, colorspace, PNG_GAMMA_sRGB_INVERSE,\n-       2\/*from sRGB*\/);\n-\n-   \/* intent: bugs in GCC force 'int' to be used as the parameter type. *\/\n-   colorspace->rendering_intent = (png_uint_16)intent;\n-   colorspace->flags |= PNG_COLORSPACE_HAVE_INTENT;\n-\n-   \/* endpoints *\/\n-   colorspace->end_points_xy = sRGB_xy;\n-   colorspace->end_points_XYZ = sRGB_XYZ;\n-   colorspace->flags |=\n-      (PNG_COLORSPACE_HAVE_ENDPOINTS|PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB);\n-\n-   \/* gamma *\/\n-   colorspace->gamma = PNG_GAMMA_sRGB_INVERSE;\n-   colorspace->flags |= PNG_COLORSPACE_HAVE_GAMMA;\n-\n-   \/* Finally record that we have an sRGB profile *\/\n-   colorspace->flags |=\n-      (PNG_COLORSPACE_MATCHES_sRGB|PNG_COLORSPACE_FROM_sRGB);\n-\n-   return 1; \/* set *\/\n-}\n-#endif \/* sRGB *\/\n@@ -1988,1 +1602,0 @@\n-#ifdef PNG_iCCP_SUPPORTED\n@@ -1998,2 +1611,2 @@\n-icc_check_length(png_const_structrp png_ptr, png_colorspacerp colorspace,\n-    png_const_charp name, png_uint_32 profile_length)\n+icc_check_length(png_const_structrp png_ptr, png_const_charp name,\n+   png_uint_32 profile_length)\n@@ -2002,2 +1615,1 @@\n-      return png_icc_profile_error(png_ptr, colorspace, name, profile_length,\n-          \"too short\");\n+      return png_icc_profile_error(png_ptr, name, profile_length, \"too short\");\n@@ -2007,1 +1619,0 @@\n-#ifdef PNG_READ_iCCP_SUPPORTED\n@@ -2009,2 +1620,2 @@\n-png_icc_check_length(png_const_structrp png_ptr, png_colorspacerp colorspace,\n-    png_const_charp name, png_uint_32 profile_length)\n+png_icc_check_length(png_const_structrp png_ptr, png_const_charp name,\n+   png_uint_32 profile_length)\n@@ -2012,1 +1623,1 @@\n-   if (!icc_check_length(png_ptr, colorspace, name, profile_length))\n+   if (!icc_check_length(png_ptr, name, profile_length))\n@@ -2021,15 +1632,3 @@\n-#  ifdef PNG_SET_USER_LIMITS_SUPPORTED\n-      else if (png_ptr->user_chunk_malloc_max > 0 &&\n-               png_ptr->user_chunk_malloc_max < profile_length)\n-         return png_icc_profile_error(png_ptr, colorspace, name, profile_length,\n-             \"exceeds application limits\");\n-#  elif PNG_USER_CHUNK_MALLOC_MAX > 0\n-      else if (PNG_USER_CHUNK_MALLOC_MAX < profile_length)\n-         return png_icc_profile_error(png_ptr, colorspace, name, profile_length,\n-             \"exceeds libpng limits\");\n-#  else \/* !SET_USER_LIMITS *\/\n-      \/* This will get compiled out on all 32-bit and better systems. *\/\n-      else if (PNG_SIZE_MAX < profile_length)\n-         return png_icc_profile_error(png_ptr, colorspace, name, profile_length,\n-             \"exceeds system limits\");\n-#  endif \/* !SET_USER_LIMITS *\/\n+   if (profile_length > png_chunk_max(png_ptr))\n+      return png_icc_profile_error(png_ptr, name, profile_length,\n+            \"profile too long\");\n@@ -2039,1 +1638,0 @@\n-#endif \/* READ_iCCP *\/\n@@ -2042,3 +1640,3 @@\n-png_icc_check_header(png_const_structrp png_ptr, png_colorspacerp colorspace,\n-    png_const_charp name, png_uint_32 profile_length,\n-    png_const_bytep profile\/* first 132 bytes only *\/, int color_type)\n+png_icc_check_header(png_const_structrp png_ptr, png_const_charp name,\n+   png_uint_32 profile_length,\n+   png_const_bytep profile\/* first 132 bytes only *\/, int color_type)\n@@ -2055,1 +1653,1 @@\n-      return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+      return png_icc_profile_error(png_ptr, name, temp,\n@@ -2060,1 +1658,1 @@\n-      return png_icc_profile_error(png_ptr, colorspace, name, profile_length,\n+      return png_icc_profile_error(png_ptr, name, profile_length,\n@@ -2066,1 +1664,1 @@\n-      return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+      return png_icc_profile_error(png_ptr, name, temp,\n@@ -2074,1 +1672,1 @@\n-      return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+      return png_icc_profile_error(png_ptr, name, temp,\n@@ -2081,1 +1679,1 @@\n-      (void)png_icc_profile_error(png_ptr, NULL, name, temp,\n+      (void)png_icc_profile_error(png_ptr, name, temp,\n@@ -2098,1 +1696,1 @@\n-      return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+      return png_icc_profile_error(png_ptr, name, temp,\n@@ -2109,1 +1707,1 @@\n-      (void)png_icc_profile_error(png_ptr, NULL, name, 0\/*no tag value*\/,\n+      (void)png_icc_profile_error(png_ptr, name, 0\/*no tag value*\/,\n@@ -2137,1 +1735,1 @@\n-            return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+            return png_icc_profile_error(png_ptr, name, temp,\n@@ -2143,1 +1741,1 @@\n-            return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+            return png_icc_profile_error(png_ptr, name, temp,\n@@ -2148,1 +1746,1 @@\n-         return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+         return png_icc_profile_error(png_ptr, name, temp,\n@@ -2173,1 +1771,1 @@\n-         return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+         return png_icc_profile_error(png_ptr, name, temp,\n@@ -2183,1 +1781,1 @@\n-         return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+         return png_icc_profile_error(png_ptr, name, temp,\n@@ -2191,1 +1789,1 @@\n-         (void)png_icc_profile_error(png_ptr, NULL, name, temp,\n+         (void)png_icc_profile_error(png_ptr, name, temp,\n@@ -2201,1 +1799,1 @@\n-         (void)png_icc_profile_error(png_ptr, NULL, name, temp,\n+         (void)png_icc_profile_error(png_ptr, name, temp,\n@@ -2217,1 +1815,1 @@\n-         return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+         return png_icc_profile_error(png_ptr, name, temp,\n@@ -2225,3 +1823,3 @@\n-png_icc_check_tag_table(png_const_structrp png_ptr, png_colorspacerp colorspace,\n-    png_const_charp name, png_uint_32 profile_length,\n-    png_const_bytep profile \/* header plus whole tag table *\/)\n+png_icc_check_tag_table(png_const_structrp png_ptr, png_const_charp name,\n+   png_uint_32 profile_length,\n+   png_const_bytep profile \/* header plus whole tag table *\/)\n@@ -2253,1 +1851,1 @@\n-         return png_icc_profile_error(png_ptr, colorspace, name, tag_id,\n+         return png_icc_profile_error(png_ptr, name, tag_id,\n@@ -2262,1 +1860,1 @@\n-         (void)png_icc_profile_error(png_ptr, NULL, name, tag_id,\n+         (void)png_icc_profile_error(png_ptr, name, tag_id,\n@@ -2269,0 +1867,1 @@\n+#endif \/* READ_iCCP *\/\n@@ -2270,64 +1869,2 @@\n-#ifdef PNG_sRGB_SUPPORTED\n-#if PNG_sRGB_PROFILE_CHECKS >= 0\n-\/* Information about the known ICC sRGB profiles *\/\n-static const struct\n-{\n-   png_uint_32 adler, crc, length;\n-   png_uint_32 md5[4];\n-   png_byte    have_md5;\n-   png_byte    is_broken;\n-   png_uint_16 intent;\n-\n-#  define PNG_MD5(a,b,c,d) { a, b, c, d }, (a!=0)||(b!=0)||(c!=0)||(d!=0)\n-#  define PNG_ICC_CHECKSUM(adler, crc, md5, intent, broke, date, length, fname)\\\n-      { adler, crc, length, md5, broke, intent },\n-\n-} png_sRGB_checks[] =\n-{\n-   \/* This data comes from contrib\/tools\/checksum-icc run on downloads of\n-    * all four ICC sRGB profiles from www.color.org.\n-    *\/\n-   \/* adler32, crc32, MD5[4], intent, date, length, file-name *\/\n-   PNG_ICC_CHECKSUM(0x0a3fd9f6, 0x3b8772b9,\n-       PNG_MD5(0x29f83dde, 0xaff255ae, 0x7842fae4, 0xca83390d), 0, 0,\n-       \"2009\/03\/27 21:36:31\", 3048, \"sRGB_IEC61966-2-1_black_scaled.icc\")\n-\n-   \/* ICC sRGB v2 perceptual no black-compensation: *\/\n-   PNG_ICC_CHECKSUM(0x4909e5e1, 0x427ebb21,\n-       PNG_MD5(0xc95bd637, 0xe95d8a3b, 0x0df38f99, 0xc1320389), 1, 0,\n-       \"2009\/03\/27 21:37:45\", 3052, \"sRGB_IEC61966-2-1_no_black_scaling.icc\")\n-\n-   PNG_ICC_CHECKSUM(0xfd2144a1, 0x306fd8ae,\n-       PNG_MD5(0xfc663378, 0x37e2886b, 0xfd72e983, 0x8228f1b8), 0, 0,\n-       \"2009\/08\/10 17:28:01\", 60988, \"sRGB_v4_ICC_preference_displayclass.icc\")\n-\n-   \/* ICC sRGB v4 perceptual *\/\n-   PNG_ICC_CHECKSUM(0x209c35d2, 0xbbef7812,\n-       PNG_MD5(0x34562abf, 0x994ccd06, 0x6d2c5721, 0xd0d68c5d), 0, 0,\n-       \"2007\/07\/25 00:05:37\", 60960, \"sRGB_v4_ICC_preference.icc\")\n-\n-   \/* The following profiles have no known MD5 checksum. If there is a match\n-    * on the (empty) MD5 the other fields are used to attempt a match and\n-    * a warning is produced.  The first two of these profiles have a 'cprt' tag\n-    * which suggests that they were also made by Hewlett Packard.\n-    *\/\n-   PNG_ICC_CHECKSUM(0xa054d762, 0x5d5129ce,\n-       PNG_MD5(0x00000000, 0x00000000, 0x00000000, 0x00000000), 1, 0,\n-       \"2004\/07\/21 18:57:42\", 3024, \"sRGB_IEC61966-2-1_noBPC.icc\")\n-\n-   \/* This is a 'mntr' (display) profile with a mediaWhitePointTag that does not\n-    * match the D50 PCS illuminant in the header (it is in fact the D65 values,\n-    * so the white point is recorded as the un-adapted value.)  The profiles\n-    * below only differ in one byte - the intent - and are basically the same as\n-    * the previous profile except for the mediaWhitePointTag error and a missing\n-    * chromaticAdaptationTag.\n-    *\/\n-   PNG_ICC_CHECKSUM(0xf784f3fb, 0x182ea552,\n-       PNG_MD5(0x00000000, 0x00000000, 0x00000000, 0x00000000), 0, 1\/*broken*\/,\n-       \"1998\/02\/09 06:49:00\", 3144, \"HP-Microsoft sRGB v2 perceptual\")\n-\n-   PNG_ICC_CHECKSUM(0x0398f3fc, 0xf29e526d,\n-       PNG_MD5(0x00000000, 0x00000000, 0x00000000, 0x00000000), 1, 1\/*broken*\/,\n-       \"1998\/02\/09 06:49:00\", 3144, \"HP-Microsoft sRGB v2 media-relative\")\n-};\n-\n+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n+#if (defined PNG_READ_mDCV_SUPPORTED) || (defined PNG_READ_cHRM_SUPPORTED)\n@@ -2335,2 +1872,1 @@\n-png_compare_ICC_profile_with_sRGB(png_const_structrp png_ptr,\n-    png_const_bytep profile, uLong adler)\n+have_chromaticities(png_const_structrp png_ptr)\n@@ -2338,6 +1874,15 @@\n-   \/* The quick check is to verify just the MD5 signature and trust the\n-    * rest of the data.  Because the profile has already been verified for\n-    * correctness this is safe.  png_colorspace_set_sRGB will check the 'intent'\n-    * field too, so if the profile has been edited with an intent not defined\n-    * by sRGB (but maybe defined by a later ICC specification) the read of\n-    * the profile will fail at that point.\n+   \/* Handle new PNGv3 chunks and the precedence rules to determine whether\n+    * png_struct::chromaticities must be processed.  Only required for RGB to\n+    * gray.\n+    *\n+    * mDCV: this is the mastering colour space and it is independent of the\n+    *       encoding so it needs to be used regardless of the encoded space.\n+    *\n+    * cICP: first in priority but not yet implemented - the chromaticities come\n+    *       from the 'primaries'.\n+    *\n+    * iCCP: not supported by libpng (so ignored)\n+    *\n+    * sRGB: the defaults match sRGB\n+    *\n+    * cHRM: calculate the coefficients\n@@ -2345,0 +1890,5 @@\n+#  ifdef PNG_READ_mDCV_SUPPORTED\n+      if (png_has_chunk(png_ptr, mDCV))\n+         return 1;\n+#     define check_chromaticities 1\n+#  endif \/*mDCV*\/\n@@ -2346,87 +1896,4 @@\n-   png_uint_32 length = 0;\n-   png_uint_32 intent = 0x10000; \/* invalid *\/\n-#if PNG_sRGB_PROFILE_CHECKS > 1\n-   uLong crc = 0; \/* the value for 0 length data *\/\n-#endif\n-   unsigned int i;\n-\n-#ifdef PNG_SET_OPTION_SUPPORTED\n-   \/* First see if PNG_SKIP_sRGB_CHECK_PROFILE has been set to \"on\" *\/\n-   if (((png_ptr->options >> PNG_SKIP_sRGB_CHECK_PROFILE) & 3) ==\n-               PNG_OPTION_ON)\n-      return 0;\n-#endif\n-\n-   for (i=0; i < (sizeof png_sRGB_checks) \/ (sizeof png_sRGB_checks[0]); ++i)\n-   {\n-      if (png_get_uint_32(profile+84) == png_sRGB_checks[i].md5[0] &&\n-         png_get_uint_32(profile+88) == png_sRGB_checks[i].md5[1] &&\n-         png_get_uint_32(profile+92) == png_sRGB_checks[i].md5[2] &&\n-         png_get_uint_32(profile+96) == png_sRGB_checks[i].md5[3])\n-      {\n-         \/* This may be one of the old HP profiles without an MD5, in that\n-          * case we can only use the length and Adler32 (note that these\n-          * are not used by default if there is an MD5!)\n-          *\/\n-#        if PNG_sRGB_PROFILE_CHECKS == 0\n-            if (png_sRGB_checks[i].have_md5 != 0)\n-               return 1+png_sRGB_checks[i].is_broken;\n-#        endif\n-\n-         \/* Profile is unsigned or more checks have been configured in. *\/\n-         if (length == 0)\n-         {\n-            length = png_get_uint_32(profile);\n-            intent = png_get_uint_32(profile+64);\n-         }\n-\n-         \/* Length *and* intent must match *\/\n-         if (length == (png_uint_32) png_sRGB_checks[i].length &&\n-            intent == (png_uint_32) png_sRGB_checks[i].intent)\n-         {\n-            \/* Now calculate the adler32 if not done already. *\/\n-            if (adler == 0)\n-            {\n-               adler = adler32(0, NULL, 0);\n-               adler = adler32(adler, profile, length);\n-            }\n-\n-            if (adler == png_sRGB_checks[i].adler)\n-            {\n-               \/* These basic checks suggest that the data has not been\n-                * modified, but if the check level is more than 1 perform\n-                * our own crc32 checksum on the data.\n-                *\/\n-#              if PNG_sRGB_PROFILE_CHECKS > 1\n-                  if (crc == 0)\n-                  {\n-                     crc = crc32(0, NULL, 0);\n-                     crc = crc32(crc, profile, length);\n-                  }\n-\n-                  \/* So this check must pass for the 'return' below to happen.\n-                   *\/\n-                  if (crc == png_sRGB_checks[i].crc)\n-#              endif\n-               {\n-                  if (png_sRGB_checks[i].is_broken != 0)\n-                  {\n-                     \/* These profiles are known to have bad data that may cause\n-                      * problems if they are used, therefore attempt to\n-                      * discourage their use, skip the 'have_md5' warning below,\n-                      * which is made irrelevant by this error.\n-                      *\/\n-                     png_chunk_report(png_ptr, \"known incorrect sRGB profile\",\n-                         PNG_CHUNK_ERROR);\n-                  }\n-\n-                  \/* Warn that this being done; this isn't even an error since\n-                   * the profile is perfectly valid, but it would be nice if\n-                   * people used the up-to-date ones.\n-                   *\/\n-                  else if (png_sRGB_checks[i].have_md5 == 0)\n-                  {\n-                     png_chunk_report(png_ptr,\n-                         \"out-of-date sRGB profile with no signature\",\n-                         PNG_CHUNK_WARNING);\n-                  }\n+#  ifdef PNG_READ_sRGB_SUPPORTED\n+      if (png_has_chunk(png_ptr, sRGB))\n+         return 0;\n+#  endif \/*sRGB*\/\n@@ -2434,17 +1901,5 @@\n-                  return 1+png_sRGB_checks[i].is_broken;\n-               }\n-            }\n-\n-# if PNG_sRGB_PROFILE_CHECKS > 0\n-         \/* The signature matched, but the profile had been changed in some\n-          * way.  This probably indicates a data error or uninformed hacking.\n-          * Fall through to \"no match\".\n-          *\/\n-         png_chunk_report(png_ptr,\n-             \"Not recognizing known sRGB profile that has been edited\",\n-             PNG_CHUNK_WARNING);\n-         break;\n-# endif\n-         }\n-      }\n-   }\n+#  ifdef PNG_READ_cHRM_SUPPORTED\n+      if (png_has_chunk(png_ptr, cHRM))\n+         return 1;\n+#     define check_chromaticities 1\n+#  endif \/*cHRM*\/\n@@ -2452,1 +1907,1 @@\n-   return 0; \/* no match *\/\n+   return 0; \/* sRGB defaults *\/\n@@ -2454,0 +1909,1 @@\n+#endif \/* READ_mDCV || READ_cHRM *\/\n@@ -2456,2 +1912,1 @@\n-png_icc_set_sRGB(png_const_structrp png_ptr,\n-    png_colorspacerp colorspace, png_const_bytep profile, uLong adler)\n+png_set_rgb_coefficients(png_structrp png_ptr)\n@@ -2459,2 +1914,3 @@\n-   \/* Is this profile one of the known ICC sRGB profiles?  If it is, just set\n-    * the sRGB information.\n+   \/* Set the rgb_to_gray coefficients from the colorspace if available.  Note\n+    * that '_set' means that png_rgb_to_gray was called **and** it successfully\n+    * set up the coefficients.\n@@ -2462,20 +1918,1 @@\n-   if (png_compare_ICC_profile_with_sRGB(png_ptr, profile, adler) != 0)\n-      (void)png_colorspace_set_sRGB(png_ptr, colorspace,\n-         (int)\/*already checked*\/png_get_uint_32(profile+64));\n-}\n-#endif \/* PNG_sRGB_PROFILE_CHECKS >= 0 *\/\n-#endif \/* sRGB *\/\n-\n-int \/* PRIVATE *\/\n-png_colorspace_set_ICC(png_const_structrp png_ptr, png_colorspacerp colorspace,\n-    png_const_charp name, png_uint_32 profile_length, png_const_bytep profile,\n-    int color_type)\n-{\n-   if ((colorspace->flags & PNG_COLORSPACE_INVALID) != 0)\n-      return 0;\n-\n-   if (icc_check_length(png_ptr, colorspace, name, profile_length) != 0 &&\n-       png_icc_check_header(png_ptr, colorspace, name, profile_length, profile,\n-           color_type) != 0 &&\n-       png_icc_check_tag_table(png_ptr, colorspace, name, profile_length,\n-           profile) != 0)\n+   if (png_ptr->rgb_to_gray_coefficients_set == 0)\n@@ -2483,6 +1920,2 @@\n-#     if defined(PNG_sRGB_SUPPORTED) && PNG_sRGB_PROFILE_CHECKS >= 0\n-         \/* If no sRGB support, don't try storing sRGB information *\/\n-         png_icc_set_sRGB(png_ptr, colorspace, profile, 0);\n-#     endif\n-      return 1;\n-   }\n+#  if check_chromaticities\n+      png_XYZ xyz;\n@@ -2490,26 +1923,2 @@\n-   \/* Failure case *\/\n-   return 0;\n-}\n-#endif \/* iCCP *\/\n-\n-#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n-void \/* PRIVATE *\/\n-png_colorspace_set_rgb_coefficients(png_structrp png_ptr)\n-{\n-   \/* Set the rgb_to_gray coefficients from the colorspace. *\/\n-   if (png_ptr->rgb_to_gray_coefficients_set == 0 &&\n-      (png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)\n-   {\n-      \/* png_set_background has not been called, get the coefficients from the Y\n-       * values of the colorspace colorants.\n-       *\/\n-      png_fixed_point r = png_ptr->colorspace.end_points_XYZ.red_Y;\n-      png_fixed_point g = png_ptr->colorspace.end_points_XYZ.green_Y;\n-      png_fixed_point b = png_ptr->colorspace.end_points_XYZ.blue_Y;\n-      png_fixed_point total = r+g+b;\n-\n-      if (total > 0 &&\n-         r >= 0 && png_muldiv(&r, r, 32768, total) && r >= 0 && r <= 32768 &&\n-         g >= 0 && png_muldiv(&g, g, 32768, total) && g >= 0 && g <= 32768 &&\n-         b >= 0 && png_muldiv(&b, b, 32768, total) && b >= 0 && b <= 32768 &&\n-         r+g+b <= 32769)\n+      if (have_chromaticities(png_ptr) &&\n+          png_XYZ_from_xy(&xyz, &png_ptr->chromaticities) == 0)\n@@ -2517,4 +1926,2 @@\n-         \/* We allow 0 coefficients here.  r+g+b may be 32769 if two or\n-          * all of the coefficients were rounded up.  Handle this by\n-          * reducing the *largest* coefficient by 1; this matches the\n-          * approach used for the default coefficients in pngrtran.c\n+         \/* png_set_rgb_to_gray has not set the coefficients, get them from the\n+          * Y * values of the colorspace colorants.\n@@ -2522,1 +1929,17 @@\n-         int add = 0;\n+         png_fixed_point r = xyz.red_Y;\n+         png_fixed_point g = xyz.green_Y;\n+         png_fixed_point b = xyz.blue_Y;\n+         png_fixed_point total = r+g+b;\n+\n+         if (total > 0 &&\n+            r >= 0 && png_muldiv(&r, r, 32768, total) && r >= 0 && r <= 32768 &&\n+            g >= 0 && png_muldiv(&g, g, 32768, total) && g >= 0 && g <= 32768 &&\n+            b >= 0 && png_muldiv(&b, b, 32768, total) && b >= 0 && b <= 32768 &&\n+            r+g+b <= 32769)\n+         {\n+            \/* We allow 0 coefficients here.  r+g+b may be 32769 if two or\n+             * all of the coefficients were rounded up.  Handle this by\n+             * reducing the *largest* coefficient by 1; this matches the\n+             * approach used for the default coefficients in pngrtran.c\n+             *\/\n+            int add = 0;\n@@ -2524,4 +1947,4 @@\n-         if (r+g+b > 32768)\n-            add = -1;\n-         else if (r+g+b < 32768)\n-            add = 1;\n+            if (r+g+b > 32768)\n+               add = -1;\n+            else if (r+g+b < 32768)\n+               add = 1;\n@@ -2529,9 +1952,9 @@\n-         if (add != 0)\n-         {\n-            if (g >= r && g >= b)\n-               g += add;\n-            else if (r >= g && r >= b)\n-               r += add;\n-            else\n-               b += add;\n-         }\n+            if (add != 0)\n+            {\n+               if (g >= r && g >= b)\n+                  g += add;\n+               else if (r >= g && r >= b)\n+                  r += add;\n+               else\n+                  b += add;\n+            }\n@@ -2539,4 +1962,4 @@\n-         \/* Check for an internal error. *\/\n-         if (r+g+b != 32768)\n-            png_error(png_ptr,\n-                \"internal error handling cHRM coefficients\");\n+            \/* Check for an internal error. *\/\n+            if (r+g+b != 32768)\n+               png_error(png_ptr,\n+                   \"internal error handling cHRM coefficients\");\n@@ -2544,4 +1967,5 @@\n-         else\n-         {\n-            png_ptr->rgb_to_gray_red_coeff   = (png_uint_16)r;\n-            png_ptr->rgb_to_gray_green_coeff = (png_uint_16)g;\n+            else\n+            {\n+               png_ptr->rgb_to_gray_red_coeff   = (png_uint_16)r;\n+               png_ptr->rgb_to_gray_green_coeff = (png_uint_16)g;\n+            }\n@@ -2550,5 +1974,0 @@\n-\n-      \/* This is a png_error at present even though it could be ignored -\n-       * it should never happen, but it is important that if it does, the\n-       * bug is fixed.\n-       *\/\n@@ -2556,1 +1975,7 @@\n-         png_error(png_ptr, \"internal error handling cHRM->XYZ\");\n+#  endif \/* check_chromaticities *\/\n+      {\n+         \/* Use the historical REC 709 (etc) values: *\/\n+         png_ptr->rgb_to_gray_red_coeff   = 6968;\n+         png_ptr->rgb_to_gray_green_coeff = 23434;\n+         \/* png_ptr->rgb_to_gray_blue_coeff  = 2366; *\/\n+      }\n@@ -2561,13 +1986,0 @@\n-#endif \/* COLORSPACE *\/\n-\n-#ifdef __GNUC__\n-\/* This exists solely to work round a warning from GNU C. *\/\n-static int \/* PRIVATE *\/\n-png_gt(size_t a, size_t b)\n-{\n-   return a > b;\n-}\n-#else\n-#   define png_gt(a,b) ((a) > (b))\n-#endif\n-\n@@ -2595,2 +2007,10 @@\n-   if (png_gt(((width + 7) & (~7U)),\n-       ((PNG_SIZE_MAX\n+   \/* The bit mask on the first line below must be at least as big as a\n+    * png_uint_32.  \"~7U\" is not adequate on 16-bit systems because it will\n+    * be an unsigned 16-bit value.  Casting to (png_alloc_size_t) makes the\n+    * type of the result at least as bit (in bits) as the RHS of the > operator\n+    * which also avoids a common warning on 64-bit systems that the comparison\n+    * of (png_uint_32) against the constant value on the RHS will always be\n+    * false.\n+    *\/\n+   if (((width + 7) & ~(png_alloc_size_t)7) >\n+       (((PNG_SIZE_MAX\n@@ -2922,8 +2342,0 @@\n-#if GCC_STRICT_OVERFLOW\n-#pragma GCC diagnostic push\n-\/* The problem arises below with exp_b10, which can never overflow because it\n- * comes, originally, from frexp and is therefore limited to a range which is\n- * typically +\/-710 (log2(DBL_MAX)\/log2(DBL_MIN)).\n- *\/\n-#pragma GCC diagnostic warning \"-Wstrict-overflow=2\"\n-#endif \/* GCC_STRICT_OVERFLOW *\/\n@@ -3251,4 +2663,0 @@\n-#if GCC_STRICT_OVERFLOW\n-#pragma GCC diagnostic pop\n-#endif \/* GCC_STRICT_OVERFLOW *\/\n-\n@@ -3282,1 +2690,1 @@\n-         char digits[10];\n+         char digits[10] = {0};\n@@ -3359,1 +2767,21 @@\n-#if defined(PNG_GAMMA_SUPPORTED) || defined(PNG_COLORSPACE_SUPPORTED) ||\\\n+#if defined(PNG_FLOATING_POINT_SUPPORTED) && \\\n+   !defined(PNG_FIXED_POINT_MACRO_SUPPORTED) && \\\n+   (defined(PNG_cLLI_SUPPORTED) || defined(PNG_mDCV_SUPPORTED))\n+png_uint_32\n+png_fixed_ITU(png_const_structrp png_ptr, double fp, png_const_charp text)\n+{\n+   double r = floor(10000 * fp + .5);\n+\n+   if (r > 2147483647. || r < 0)\n+      png_fixed_error(png_ptr, text);\n+\n+#  ifndef PNG_ERROR_TEXT_SUPPORTED\n+   PNG_UNUSED(text)\n+#  endif\n+\n+   return (png_uint_32)r;\n+}\n+#endif\n+\n+\n+#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_COLORSPACE_SUPPORTED) ||\\\n@@ -3367,10 +2795,1 @@\n-#if GCC_STRICT_OVERFLOW \/* from above *\/\n-\/* It is not obvious which comparison below gets optimized in such a way that\n- * signed overflow would change the result; looking through the code does not\n- * reveal any tests which have the form GCC complains about, so presumably the\n- * optimizer is moving an add or subtract into the 'if' somewhere.\n- *\/\n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic warning \"-Wstrict-overflow=2\"\n-#endif \/* GCC_STRICT_OVERFLOW *\/\n-int\n+int \/* PRIVATE *\/\n@@ -3490,22 +2909,0 @@\n-#if GCC_STRICT_OVERFLOW\n-#pragma GCC diagnostic pop\n-#endif \/* GCC_STRICT_OVERFLOW *\/\n-#endif \/* READ_GAMMA || INCH_CONVERSIONS *\/\n-\n-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_INCH_CONVERSIONS_SUPPORTED)\n-\/* The following is for when the caller doesn't much care about the\n- * result.\n- *\/\n-png_fixed_point\n-png_muldiv_warn(png_const_structrp png_ptr, png_fixed_point a, png_int_32 times,\n-    png_int_32 divisor)\n-{\n-   png_fixed_point result;\n-\n-   if (png_muldiv(&result, a, times, divisor) != 0)\n-      return result;\n-\n-   png_warning(png_ptr, \"fixed point overflow ignored\");\n-   return 0;\n-}\n-#endif\n@@ -3513,1 +2910,0 @@\n-#ifdef PNG_GAMMA_SUPPORTED \/* more fixed point functions for gamma *\/\n@@ -3532,0 +2928,1 @@\n+#endif \/* READ_GAMMA || COLORSPACE || INCH_CONVERSIONS || READ_pHYS *\/\n@@ -3533,0 +2930,1 @@\n+#ifdef PNG_READ_GAMMA_SUPPORTED\n@@ -3539,0 +2937,12 @@\n+   \/* sRGB:       1\/2.2 == 0.4545(45)\n+    * AdobeRGB:   1\/(2+51\/256) ~= 0.45471 5dp\n+    *\n+    * So the correction from AdobeRGB to sRGB (output) is:\n+    *\n+    *    2.2\/(2+51\/256) == 1.00035524\n+    *\n+    * I.e. vanishly small (<4E-4) but still detectable in 16-bit linear (+\/-\n+    * 23).  Note that the Adobe choice seems to be something intended to give an\n+    * exact number with 8 binary fractional digits - it is the closest to 2.2\n+    * that is possible a base 2 .8p representation.\n+    *\/\n@@ -3542,1 +2952,0 @@\n-#endif\n@@ -3544,2 +2953,1 @@\n-#ifdef PNG_READ_GAMMA_SUPPORTED\n-#ifdef PNG_16BIT_SUPPORTED\n+#ifndef PNG_FLOATING_ARITHMETIC_SUPPORTED\n@@ -3550,2 +2958,2 @@\n-   \/* The required result is 1\/a * 1\/b; the following preserves accuracy. *\/\n-#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\n+   \/* The required result is a * b; the following preserves accuracy. *\/\n+#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED \/* Should now be unused *\/\n@@ -3567,1 +2975,1 @@\n-#endif \/* 16BIT *\/\n+#endif \/* FLOATING_ARITHMETIC *\/\n@@ -3569,1 +2977,0 @@\n-\/* The inverse of the above. *\/\n@@ -4222,0 +3629,3 @@\n+ *\n+ * TODO: move this to pngrtran.c and make it static.  Better yet create\n+ * pngcolor.c and put all the PNG_COLORSPACE stuff in there.\n@@ -4223,0 +3633,8 @@\n+#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \\\n+   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \\\n+   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)\n+#  define GAMMA_TRANSFORMS 1 \/* #ifdef CSE *\/\n+#else\n+#  define GAMMA_TRANSFORMS 0\n+#endif\n+\n@@ -4226,0 +3644,6 @@\n+   png_fixed_point file_gamma, screen_gamma;\n+   png_fixed_point correction;\n+#  if GAMMA_TRANSFORMS\n+      png_fixed_point file_to_linear, linear_to_screen;\n+#  endif\n+\n@@ -4240,0 +3664,25 @@\n+   \/* The following fields are set, finally, in png_init_read_transformations.\n+    * If file_gamma is 0 (unset) nothing can be done otherwise if screen_gamma\n+    * is 0 (unset) there is no gamma correction but to\/from linear is possible.\n+    *\/\n+   file_gamma = png_ptr->file_gamma;\n+   screen_gamma = png_ptr->screen_gamma;\n+#  if GAMMA_TRANSFORMS\n+      file_to_linear = png_reciprocal(file_gamma);\n+#  endif\n+\n+   if (screen_gamma > 0)\n+   {\n+#     if GAMMA_TRANSFORMS\n+         linear_to_screen = png_reciprocal(screen_gamma);\n+#     endif\n+      correction = png_reciprocal2(screen_gamma, file_gamma);\n+   }\n+   else \/* screen gamma unknown *\/\n+   {\n+#     if GAMMA_TRANSFORMS\n+         linear_to_screen = file_gamma;\n+#     endif\n+      correction = PNG_FP_1;\n+   }\n+\n@@ -4242,4 +3691,1 @@\n-      png_build_8bit_table(png_ptr, &png_ptr->gamma_table,\n-          png_ptr->screen_gamma > 0 ?\n-          png_reciprocal2(png_ptr->colorspace.gamma,\n-          png_ptr->screen_gamma) : PNG_FP_1);\n+      png_build_8bit_table(png_ptr, &png_ptr->gamma_table, correction);\n@@ -4247,3 +3693,1 @@\n-#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \\\n-   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \\\n-   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)\n+#if GAMMA_TRANSFORMS\n@@ -4252,2 +3696,1 @@\n-         png_build_8bit_table(png_ptr, &png_ptr->gamma_to_1,\n-             png_reciprocal(png_ptr->colorspace.gamma));\n+         png_build_8bit_table(png_ptr, &png_ptr->gamma_to_1, file_to_linear);\n@@ -4256,3 +3699,1 @@\n-             png_ptr->screen_gamma > 0 ?\n-             png_reciprocal(png_ptr->screen_gamma) :\n-             png_ptr->colorspace.gamma\/* Probably doing rgb_to_gray *\/);\n+            linear_to_screen);\n@@ -4260,1 +3701,1 @@\n-#endif \/* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY *\/\n+#endif \/* GAMMA_TRANSFORMS *\/\n@@ -4326,4 +3767,2 @@\n-          png_build_16to8_table(png_ptr, &png_ptr->gamma_16_table, shift,\n-          png_ptr->screen_gamma > 0 ? png_product2(png_ptr->colorspace.gamma,\n-          png_ptr->screen_gamma) : PNG_FP_1);\n-\n+         png_build_16to8_table(png_ptr, &png_ptr->gamma_16_table, shift,\n+            png_reciprocal(correction));\n@@ -4331,3 +3770,2 @@\n-          png_build_16bit_table(png_ptr, &png_ptr->gamma_16_table, shift,\n-          png_ptr->screen_gamma > 0 ? png_reciprocal2(png_ptr->colorspace.gamma,\n-          png_ptr->screen_gamma) : PNG_FP_1);\n+         png_build_16bit_table(png_ptr, &png_ptr->gamma_16_table, shift,\n+            correction);\n@@ -4335,3 +3773,1 @@\n-#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \\\n-   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \\\n-   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)\n+#  if GAMMA_TRANSFORMS\n@@ -4341,1 +3777,1 @@\n-             png_reciprocal(png_ptr->colorspace.gamma));\n+            file_to_linear);\n@@ -4348,2 +3784,1 @@\n-             png_ptr->screen_gamma > 0 ? png_reciprocal(png_ptr->screen_gamma) :\n-             png_ptr->colorspace.gamma\/* Probably doing rgb_to_gray *\/);\n+            linear_to_screen);\n@@ -4351,1 +3786,1 @@\n-#endif \/* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY *\/\n+#endif \/* GAMMA_TRANSFORMS *\/\n@@ -4566,1 +4001,1 @@\n-         FILE *fp = png_voidcast(FILE*, cp->png_ptr->io_ptr);\n+         FILE *fp = png_voidcast(FILE *, cp->png_ptr->io_ptr);\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/png.c","additions":476,"deletions":1041,"binary":false,"changes":1517,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * libpng version 1.6.39 - November 20, 2022\n+ * libpng version 1.6.51\n@@ -34,1 +34,1 @@\n- * Copyright (c) 2018-2022 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -46,1 +46,1 @@\n- *   libpng versions 1.6.36, December 2018, through 1.6.39, November 2022:\n+ *   libpng versions 1.6.36, December 2018, through 1.6.51, November 2025:\n@@ -58,2 +58,2 @@\n- *  * Copyright (c) 1995-2022 The PNG Reference Library Authors.\n- *  * Copyright (c) 2018-2022 Cosmin Truta.\n+ *  * Copyright (c) 1995-2025 The PNG Reference Library Authors.\n+ *  * Copyright (c) 2018-2025 Cosmin Truta.\n@@ -270,1 +270,1 @@\n- *    1.6.39                  16    10639  16.so.16.39[.0]\n+ *    1.6.51                  16    10651  16.so.16.51[.0]\n@@ -286,3 +286,0 @@\n- *    DLLNUM will change each time there are forward or backward changes\n- *    in binary compatibility (e.g., when a new feature is added).\n- *\n@@ -309,2 +306,2 @@\n-#define PNG_LIBPNG_VER_STRING \"1.6.39\"\n-#define PNG_HEADER_VERSION_STRING \" libpng version 1.6.39 - November 20, 2022\\n\"\n+#define PNG_LIBPNG_VER_STRING \"1.6.51\"\n+#define PNG_HEADER_VERSION_STRING \" libpng version \" PNG_LIBPNG_VER_STRING \"\\n\"\n@@ -312,2 +309,4 @@\n-#define PNG_LIBPNG_VER_SONUM   16\n-#define PNG_LIBPNG_VER_DLLNUM  16\n+\/* The versions of shared library builds should stay in sync, going forward *\/\n+#define PNG_LIBPNG_VER_SHAREDLIB 16\n+#define PNG_LIBPNG_VER_SONUM     PNG_LIBPNG_VER_SHAREDLIB \/* [Deprecated] *\/\n+#define PNG_LIBPNG_VER_DLLNUM    PNG_LIBPNG_VER_SHAREDLIB \/* [Deprecated] *\/\n@@ -318,1 +317,1 @@\n-#define PNG_LIBPNG_VER_RELEASE 39\n+#define PNG_LIBPNG_VER_RELEASE 51\n@@ -321,1 +320,1 @@\n- * development version.  [Deprecated]\n+ * development version.\n@@ -323,1 +322,1 @@\n-#define PNG_LIBPNG_VER_BUILD  0\n+#define PNG_LIBPNG_VER_BUILD 0\n@@ -326,4 +325,4 @@\n-#define PNG_LIBPNG_BUILD_ALPHA    1\n-#define PNG_LIBPNG_BUILD_BETA     2\n-#define PNG_LIBPNG_BUILD_RC       3\n-#define PNG_LIBPNG_BUILD_STABLE   4\n+#define PNG_LIBPNG_BUILD_ALPHA               1\n+#define PNG_LIBPNG_BUILD_BETA                2\n+#define PNG_LIBPNG_BUILD_RC                  3\n+#define PNG_LIBPNG_BUILD_STABLE              4\n@@ -349,1 +348,1 @@\n-#define PNG_LIBPNG_VER 10639 \/* 1.6.39 *\/\n+#define PNG_LIBPNG_VER 10651 \/* 1.6.51 *\/\n@@ -459,1 +458,1 @@\n-typedef char* png_libpng_version_1_6_39;\n+typedef char* png_libpng_version_1_6_51;\n@@ -777,0 +776,15 @@\n+#define PNG_INFO_cICP 0x20000U \/* PNGv3: 1.6.45 *\/\n+#define PNG_INFO_cLLI 0x40000U \/* PNGv3: 1.6.45 *\/\n+#define PNG_INFO_mDCV 0x80000U \/* PNGv3: 1.6.45 *\/\n+\/* APNG: these chunks are stored as unknown, these flags are never set\n+ * however they are provided as a convenience for implementors of APNG and\n+ * avoids any merge conflicts.\n+ *\n+ * Private chunks: these chunk names violate the chunk name recommendations\n+ * because the chunk definitions have no signature and because the private\n+ * chunks with these names have been reserved.  Private definitions should\n+ * avoid them.\n+ *\/\n+#define PNG_INFO_acTL 0x100000U \/* PNGv3: 1.6.45: unknown *\/\n+#define PNG_INFO_fcTL 0x200000U \/* PNGv3: 1.6.45: unknown *\/\n+#define PNG_INFO_fdAT 0x400000U \/* PNGv3: 1.6.45: unknown *\/\n@@ -856,1 +870,1 @@\n-PNG_FUNCTION(void, (PNGCAPI *png_longjmp_ptr), PNGARG((jmp_buf, int)), typedef);\n+PNG_FUNCTION(void, (PNGCAPI *png_longjmp_ptr), (jmp_buf, int), typedef);\n@@ -880,1 +894,1 @@\n-#if INT_MAX >= 0x8000 \/* else this might break *\/\n+#if ~0U > 0xffffU \/* or else this might break on a 16-bit machine *\/\n@@ -939,1 +953,1 @@\n- * start > 7 will always fail (ie return non-zero).\n+ * start > 7 will always fail (i.e. return non-zero).\n@@ -945,1 +959,1 @@\n- * png_check_sig(sig, n) := !png_sig_cmp(sig, 0, n).\n+ * png_check_sig(sig, n) := (png_sig_cmp(sig, 0, n) == 0).\n@@ -947,1 +961,1 @@\n-#define png_check_sig(sig, n) !png_sig_cmp((sig), 0, (n))\n+#define png_check_sig(sig, n) (png_sig_cmp((sig), 0, (n)) == 0) \/* DEPRECATED *\/\n@@ -1588,1 +1602,1 @@\n-PNG_EXPORT(74, void, png_init_io, (png_structrp png_ptr, png_FILE_p fp));\n+PNG_EXPORT(74, void, png_init_io, (png_structrp png_ptr, FILE *fp));\n@@ -1761,1 +1775,1 @@\n-\/* Reassign responsibility for freeing existing data, whether allocated\n+\/* Reassign the responsibility for freeing existing data, whether allocated\n@@ -1763,4 +1777,1 @@\n- * in, it does not change the state for other png_info structures.\n- *\n- * It is unlikely that this function works correctly as of 1.6.0 and using it\n- * may result either in memory leaks or double free of allocated data.\n+ * in, without changing the state for other png_info structures.\n@@ -2009,0 +2020,40 @@\n+#ifdef PNG_cICP_SUPPORTED\n+PNG_EXPORT(250, png_uint_32, png_get_cICP, (png_const_structrp png_ptr,\n+    png_const_inforp info_ptr, png_bytep colour_primaries,\n+    png_bytep transfer_function, png_bytep matrix_coefficients,\n+    png_bytep video_full_range_flag));\n+#endif\n+\n+#ifdef PNG_cICP_SUPPORTED\n+PNG_EXPORT(251, void, png_set_cICP, (png_const_structrp png_ptr,\n+    png_inforp info_ptr, png_byte colour_primaries,\n+    png_byte transfer_function, png_byte matrix_coefficients,\n+    png_byte video_full_range_flag));\n+#endif\n+\n+#ifdef PNG_cLLI_SUPPORTED\n+PNG_FP_EXPORT(252, png_uint_32, png_get_cLLI, (png_const_structrp png_ptr,\n+         png_const_inforp info_ptr, double *maximum_content_light_level,\n+         double *maximum_frame_average_light_level))\n+PNG_FIXED_EXPORT(253, png_uint_32, png_get_cLLI_fixed,\n+    (png_const_structrp png_ptr, png_const_inforp info_ptr,\n+    \/* The values below are in cd\/m2 (nits) and are scaled by 10,000; not\n+     * 100,000 as in the case of png_fixed_point.\n+     *\/\n+    png_uint_32p maximum_content_light_level_scaled_by_10000,\n+    png_uint_32p maximum_frame_average_light_level_scaled_by_10000))\n+#endif\n+\n+#ifdef PNG_cLLI_SUPPORTED\n+PNG_FP_EXPORT(254, void, png_set_cLLI, (png_const_structrp png_ptr,\n+         png_inforp info_ptr, double maximum_content_light_level,\n+         double maximum_frame_average_light_level))\n+PNG_FIXED_EXPORT(255, void, png_set_cLLI_fixed, (png_const_structrp png_ptr,\n+    png_inforp info_ptr,\n+    \/* The values below are in cd\/m2 (nits) and are scaled by 10,000; not\n+     * 100,000 as in the case of png_fixed_point.\n+     *\/\n+    png_uint_32 maximum_content_light_level_scaled_by_10000,\n+    png_uint_32 maximum_frame_average_light_level_scaled_by_10000))\n+#endif\n+\n@@ -2053,0 +2104,54 @@\n+#ifdef PNG_mDCV_SUPPORTED\n+PNG_FP_EXPORT(256, png_uint_32, png_get_mDCV, (png_const_structrp png_ptr,\n+    png_const_inforp info_ptr,\n+    \/* The chromaticities of the mastering display.  As cHRM, but independent of\n+     * the encoding endpoints in cHRM, or cICP, or iCCP.  These values will\n+     * always be in the range 0 to 1.3107.\n+     *\/\n+    double *white_x, double *white_y, double *red_x, double *red_y,\n+    double *green_x, double *green_y, double *blue_x, double *blue_y,\n+    \/* Mastering display luminance in cd\/m2 (nits). *\/\n+    double *mastering_display_maximum_luminance,\n+    double *mastering_display_minimum_luminance))\n+\n+PNG_FIXED_EXPORT(257, png_uint_32, png_get_mDCV_fixed,\n+    (png_const_structrp png_ptr, png_const_inforp info_ptr,\n+    png_fixed_point *int_white_x, png_fixed_point *int_white_y,\n+    png_fixed_point *int_red_x, png_fixed_point *int_red_y,\n+    png_fixed_point *int_green_x, png_fixed_point *int_green_y,\n+    png_fixed_point *int_blue_x, png_fixed_point *int_blue_y,\n+    \/* Mastering display luminance in cd\/m2 (nits) multiplied (scaled) by\n+     * 10,000.\n+     *\/\n+    png_uint_32p mastering_display_maximum_luminance_scaled_by_10000,\n+    png_uint_32p mastering_display_minimum_luminance_scaled_by_10000))\n+#endif\n+\n+#ifdef PNG_mDCV_SUPPORTED\n+PNG_FP_EXPORT(258, void, png_set_mDCV, (png_const_structrp png_ptr,\n+    png_inforp info_ptr,\n+    \/* The chromaticities of the mastering display.  As cHRM, but independent of\n+     * the encoding endpoints in cHRM, or cICP, or iCCP.\n+     *\/\n+    double white_x, double white_y, double red_x, double red_y, double green_x,\n+    double green_y, double blue_x, double blue_y,\n+    \/* Mastering display luminance in cd\/m2 (nits). *\/\n+    double mastering_display_maximum_luminance,\n+    double mastering_display_minimum_luminance))\n+\n+PNG_FIXED_EXPORT(259, void, png_set_mDCV_fixed, (png_const_structrp png_ptr,\n+    png_inforp info_ptr,\n+    \/* The admissible range of these values is not the full range of a PNG\n+     * fixed point value.  Negative values cannot be encoded and the maximum\n+     * value is about 1.3 *\/\n+    png_fixed_point int_white_x, png_fixed_point int_white_y,\n+    png_fixed_point int_red_x, png_fixed_point int_red_y,\n+    png_fixed_point int_green_x, png_fixed_point int_green_y,\n+    png_fixed_point int_blue_x, png_fixed_point int_blue_y,\n+    \/* These are PNG unsigned 4 byte values: 31-bit unsigned values.  The MSB\n+     * must be zero.\n+     *\/\n+    png_uint_32 mastering_display_maximum_luminance_scaled_by_10000,\n+    png_uint_32 mastering_display_minimum_luminance_scaled_by_10000))\n+#endif\n+\n@@ -3015,1 +3120,1 @@\n-   FILE* file));\n+   FILE *file));\n@@ -3090,1 +3195,1 @@\n-   \/* Write the image to the given (FILE*). *\/\n+   \/* Write the image to the given FILE object. *\/\n@@ -3230,0 +3335,2 @@\n+\n+\/* HARDWARE: ARM Neon SIMD instructions supported *\/\n@@ -3231,1 +3338,1 @@\n-#  define PNG_ARM_NEON   0 \/* HARDWARE: ARM Neon SIMD instructions supported *\/\n+#  define PNG_ARM_NEON 0\n@@ -3233,2 +3340,8 @@\n-#define PNG_MAXIMUM_INFLATE_WINDOW 2 \/* SOFTWARE: force maximum window *\/\n-#define PNG_SKIP_sRGB_CHECK_PROFILE 4 \/* SOFTWARE: Check ICC profile for sRGB *\/\n+\n+\/* SOFTWARE: Force maximum window *\/\n+#define PNG_MAXIMUM_INFLATE_WINDOW 2\n+\n+\/* SOFTWARE: Check ICC profile for sRGB *\/\n+#define PNG_SKIP_sRGB_CHECK_PROFILE 4\n+\n+\/* HARDWARE: MIPS MSA SIMD instructions supported *\/\n@@ -3236,1 +3349,1 @@\n-#  define PNG_MIPS_MSA   6 \/* HARDWARE: MIPS Msa SIMD instructions supported *\/\n+#  define PNG_MIPS_MSA 6\n@@ -3238,1 +3351,7 @@\n-#define PNG_IGNORE_ADLER32 8\n+\n+\/* SOFTWARE: Disable Adler32 check on IDAT *\/\n+#ifdef PNG_DISABLE_ADLER32_CHECK_SUPPORTED\n+#  define PNG_IGNORE_ADLER32 8\n+#endif\n+\n+\/* HARDWARE: PowerPC VSX SIMD instructions supported *\/\n@@ -3240,1 +3359,11 @@\n-#  define PNG_POWERPC_VSX   10 \/* HARDWARE: PowerPC VSX SIMD instructions supported *\/\n+#  define PNG_POWERPC_VSX 10\n+#endif\n+\n+\/* HARDWARE: MIPS MMI SIMD instructions supported *\/\n+#ifdef PNG_MIPS_MMI_API_SUPPORTED\n+#  define PNG_MIPS_MMI 12\n+#endif\n+\n+\/* HARDWARE: RISC-V RVV SIMD instructions supported *\/\n+#ifdef PNG_RISCV_RVV_API_SUPPORTED\n+#  define PNG_RISCV_RVV 14\n@@ -3242,1 +3371,3 @@\n-#define PNG_OPTION_NEXT  12 \/* Next option - numbers must be even *\/\n+\n+\/* Next option - numbers must be even *\/\n+#define PNG_OPTION_NEXT 16\n@@ -3266,1 +3397,1 @@\n-  PNG_EXPORT_LAST_ORDINAL(249);\n+  PNG_EXPORT_LAST_ORDINAL(259);\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/png.h","additions":174,"deletions":43,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * libpng version 1.6.39\n+ * libpng version 1.6.51\n@@ -34,1 +34,1 @@\n- * Copyright (c) 2018-2022 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -119,1 +119,1 @@\n- * prototypes.  It is not required for modern C compilers.\n+ * prototypes.  [Deprecated.]\n@@ -251,1 +251,1 @@\n-#     error \"PNG_USER_PRIVATEBUILD must be defined if PNGAPI is changed\"\n+#     error PNG_USER_PRIVATEBUILD must be defined if PNGAPI is changed\n@@ -254,16 +254,4 @@\n-#  if (defined(_MSC_VER) && _MSC_VER < 800) ||\\\n-      (defined(__BORLANDC__) && __BORLANDC__ < 0x500)\n-   \/* older Borland and MSC\n-    * compilers used '__export' and required this to be after\n-    * the type.\n-    *\/\n-#    ifndef PNG_EXPORT_TYPE\n-#      define PNG_EXPORT_TYPE(type) type PNG_IMPEXP\n-#    endif\n-#    define PNG_DLL_EXPORT __export\n-#  else \/* newer compiler *\/\n-#    define PNG_DLL_EXPORT __declspec(dllexport)\n-#    ifndef PNG_DLL_IMPORT\n-#      define PNG_DLL_IMPORT __declspec(dllimport)\n-#    endif\n-#  endif \/* compiler *\/\n+#  define PNG_DLL_EXPORT __declspec(dllexport)\n+#  ifndef PNG_DLL_IMPORT\n+#    define PNG_DLL_IMPORT __declspec(dllimport)\n+#  endif\n@@ -329,1 +317,1 @@\n-      PNG_FUNCTION(PNG_EXPORT_TYPE(type), (PNGAPI name), PNGARG(args), \\\n+      PNG_FUNCTION(PNG_EXPORT_TYPE(type), (PNGAPI name), args, \\\n@@ -347,1 +335,1 @@\n-#  define PNG_CALLBACK(type, name, args) type (PNGCBAPI name) PNGARG(args)\n+#  define PNG_CALLBACK(type, name, args) type (PNGCBAPI name) args\n@@ -511,1 +499,1 @@\n-#  error \"libpng requires 8-bit bytes\"\n+#  error libpng requires 8-bit bytes\n@@ -519,1 +507,1 @@\n-#  error \"libpng requires a signed 16-bit type\"\n+#  error libpng requires a signed 16-bit integer type\n@@ -527,1 +515,1 @@\n-#  error \"libpng requires an unsigned 16-bit type\"\n+#  error libpng requires an unsigned 16-bit integer type\n@@ -535,1 +523,1 @@\n-#  error \"libpng requires a signed 32-bit (or more) type\"\n+#  error libpng requires a signed 32-bit (or longer) integer type\n@@ -543,1 +531,1 @@\n-#  error \"libpng requires an unsigned 32-bit (or more) type\"\n+#  error libpng requires an unsigned 32-bit (or longer) integer type\n@@ -624,4 +612,0 @@\n-#ifdef PNG_STDIO_SUPPORTED\n-typedef FILE            * png_FILE_p;\n-#endif\n-\n@@ -649,0 +633,9 @@\n+#ifdef PNG_STDIO_SUPPORTED\n+\/* With PNG_STDIO_SUPPORTED it was possible to use I\/O streams that were\n+ * not necessarily stdio FILE streams, to allow building Windows applications\n+ * before Win32 and Windows CE applications before WinCE 3.0, but that kind\n+ * of support has long been discontinued.\n+ *\/\n+typedef FILE            * png_FILE_p; \/* [Deprecated] *\/\n+#endif\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/pngconf.h","additions":24,"deletions":31,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/* pngdebug.h - Debugging macros for libpng, also used in pngtest.c\n+\/* pngdebug.h - internal debugging macros for libpng\n@@ -32,1 +32,1 @@\n- * Copyright (c) 2018 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -42,0 +42,4 @@\n+#ifndef PNGPRIV_H\n+#  error This file must not be included by applications; please include <png.h>\n+#endif\n+\n@@ -66,3 +70,0 @@\n-#  ifndef PNG_LITERAL_SHARP\n-#    define PNG_LITERAL_SHARP 0x23\n-#  endif\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/pngdebug.h","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -51,2 +51,3 @@\n-static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,\n-    png_const_charp error_message)),PNG_NORETURN);\n+static PNG_FUNCTION(void \/* PRIVATE *\/,\n+png_default_error,(png_const_structrp png_ptr, png_const_charp error_message),\n+    PNG_NORETURN);\n@@ -56,2 +57,2 @@\n-png_default_warning PNGARG((png_const_structrp png_ptr,\n-    png_const_charp warning_message));\n+png_default_warning(png_const_structrp png_ptr,\n+    png_const_charp warning_message);\n@@ -70,40 +71,0 @@\n-#ifdef PNG_ERROR_NUMBERS_SUPPORTED\n-   char msg[16];\n-   if (png_ptr != NULL)\n-   {\n-      if ((png_ptr->flags &\n-         (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT)) != 0)\n-      {\n-         if (*error_message == PNG_LITERAL_SHARP)\n-         {\n-            \/* Strip \"#nnnn \" from beginning of error message. *\/\n-            int offset;\n-            for (offset = 1; offset<15; offset++)\n-               if (error_message[offset] == ' ')\n-                  break;\n-\n-            if ((png_ptr->flags & PNG_FLAG_STRIP_ERROR_TEXT) != 0)\n-            {\n-               int i;\n-               for (i = 0; i < offset - 1; i++)\n-                  msg[i] = error_message[i + 1];\n-               msg[i - 1] = '\\0';\n-               error_message = msg;\n-            }\n-\n-            else\n-               error_message += offset;\n-         }\n-\n-         else\n-         {\n-            if ((png_ptr->flags & PNG_FLAG_STRIP_ERROR_TEXT) != 0)\n-            {\n-               msg[0] = '0';\n-               msg[1] = '\\0';\n-               error_message = msg;\n-            }\n-         }\n-      }\n-   }\n-#endif\n@@ -247,15 +208,0 @@\n-   if (png_ptr != NULL)\n-   {\n-#ifdef PNG_ERROR_NUMBERS_SUPPORTED\n-   if ((png_ptr->flags &\n-       (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT)) != 0)\n-#endif\n-      {\n-         if (*warning_message == PNG_LITERAL_SHARP)\n-         {\n-            for (offset = 1; offset < 15; offset++)\n-               if (warning_message[offset] == ' ')\n-                  break;\n-         }\n-      }\n-   }\n@@ -286,1 +232,1 @@\n-   char buffer[PNG_NUMBER_BUFFER_SIZE];\n+   char buffer[PNG_NUMBER_BUFFER_SIZE] = {0};\n@@ -296,1 +242,1 @@\n-   char buffer[PNG_NUMBER_BUFFER_SIZE];\n+   char buffer[PNG_NUMBER_BUFFER_SIZE] = {0};\n@@ -743,36 +689,3 @@\n-#ifdef PNG_ERROR_NUMBERS_SUPPORTED\n-   \/* Check on NULL only added in 1.5.4 *\/\n-   if (error_message != NULL && *error_message == PNG_LITERAL_SHARP)\n-   {\n-      \/* Strip \"#nnnn \" from beginning of error message. *\/\n-      int offset;\n-      char error_number[16];\n-      for (offset = 0; offset<15; offset++)\n-      {\n-         error_number[offset] = error_message[offset + 1];\n-         if (error_message[offset] == ' ')\n-            break;\n-      }\n-\n-      if ((offset > 1) && (offset < 15))\n-      {\n-         error_number[offset - 1] = '\\0';\n-         fprintf(stderr, \"libpng error no. %s: %s\",\n-             error_number, error_message + offset + 1);\n-         fprintf(stderr, PNG_STRING_NEWLINE);\n-      }\n-\n-      else\n-      {\n-         fprintf(stderr, \"libpng error: %s, offset=%d\",\n-             error_message, offset);\n-         fprintf(stderr, PNG_STRING_NEWLINE);\n-      }\n-   }\n-   else\n-#endif\n-   {\n-      fprintf(stderr, \"libpng error: %s\", error_message ? error_message :\n-         \"undefined\");\n-      fprintf(stderr, PNG_STRING_NEWLINE);\n-   }\n+   fprintf(stderr, \"libpng error: %s\", error_message ? error_message :\n+      \"undefined\");\n+   fprintf(stderr, PNG_STRING_NEWLINE);\n@@ -816,34 +729,2 @@\n-#  ifdef PNG_ERROR_NUMBERS_SUPPORTED\n-   if (*warning_message == PNG_LITERAL_SHARP)\n-   {\n-      int offset;\n-      char warning_number[16];\n-      for (offset = 0; offset < 15; offset++)\n-      {\n-         warning_number[offset] = warning_message[offset + 1];\n-         if (warning_message[offset] == ' ')\n-            break;\n-      }\n-\n-      if ((offset > 1) && (offset < 15))\n-      {\n-         warning_number[offset + 1] = '\\0';\n-         fprintf(stderr, \"libpng warning no. %s: %s\",\n-             warning_number, warning_message + offset);\n-         fprintf(stderr, PNG_STRING_NEWLINE);\n-      }\n-\n-      else\n-      {\n-         fprintf(stderr, \"libpng warning: %s\",\n-             warning_message);\n-         fprintf(stderr, PNG_STRING_NEWLINE);\n-      }\n-   }\n-   else\n-#  endif\n-\n-   {\n-      fprintf(stderr, \"libpng warning: %s\", warning_message);\n-      fprintf(stderr, PNG_STRING_NEWLINE);\n-   }\n+   fprintf(stderr, \"libpng warning: %s\", warning_message);\n+   fprintf(stderr, PNG_STRING_NEWLINE);\n@@ -889,1 +770,1 @@\n-   return ((png_voidp)png_ptr->error_ptr);\n+   return (png_voidp)png_ptr->error_ptr;\n@@ -897,6 +778,2 @@\n-   if (png_ptr != NULL)\n-   {\n-      png_ptr->flags &=\n-         ((~(PNG_FLAG_STRIP_ERROR_NUMBERS |\n-         PNG_FLAG_STRIP_ERROR_TEXT))&strip_mode);\n-   }\n+   PNG_UNUSED(png_ptr)\n+   PNG_UNUSED(strip_mode)\n@@ -964,1 +841,1 @@\n-png_safe_execute(png_imagep image_in, int (*function)(png_voidp), png_voidp arg)\n+png_safe_execute(png_imagep image, int (*function)(png_voidp), png_voidp arg)\n@@ -966,3 +843,1 @@\n-   volatile png_imagep image = image_in;\n-   volatile int result;\n-   volatile png_voidp saved_error_buf;\n+   const png_voidp saved_error_buf = image->opaque->error_buf;\n@@ -971,5 +846,2 @@\n-   \/* Safely execute function(arg) with png_error returning to this function. *\/\n-   saved_error_buf = image->opaque->error_buf;\n-   result = setjmp(safe_jmpbuf) == 0;\n-\n-   if (result != 0)\n+   \/* Safely execute function(arg), with png_error returning back here. *\/\n+   if (setjmp(safe_jmpbuf) == 0)\n@@ -977,0 +849,1 @@\n+      int result;\n@@ -980,0 +853,4 @@\n+      image->opaque->error_buf = saved_error_buf;\n+\n+      if (result)\n+         return 1; \/* success *\/\n@@ -982,0 +859,5 @@\n+   \/* The function failed either because of a caught png_error and a regular\n+    * return of false above or because of an uncaught png_error from the\n+    * function itself.  Ensure that the error_buf is always set back to the\n+    * value saved above:\n+    *\/\n@@ -984,2 +866,5 @@\n-   \/* And do the cleanup prior to any failure return. *\/\n-   if (result == 0)\n+   \/* On the final false return, when about to return control to the caller, the\n+    * image is freed (png_image_free does this check but it is duplicated here\n+    * for clarity:\n+    *\/\n+   if (saved_error_buf == NULL)\n@@ -988,1 +873,1 @@\n-   return result;\n+   return 0; \/* failure *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/pngerror.c","additions":36,"deletions":151,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -52,1 +52,12 @@\n-      return(info_ptr->valid & flag);\n+   {\n+#ifdef PNG_READ_tRNS_SUPPORTED\n+      \/* png_handle_PLTE() may have canceled a valid tRNS chunk but left the\n+       * 'valid' flag for the detection of duplicate chunks. Do not report a\n+       * valid tRNS chunk in this case.\n+       *\/\n+      if (flag == PNG_INFO_tRNS && png_ptr->num_trans == 0)\n+         return 0;\n+#endif\n+\n+      return info_ptr->valid & flag;\n+   }\n@@ -54,1 +65,1 @@\n-   return(0);\n+   return 0;\n@@ -61,1 +72,1 @@\n-      return(info_ptr->rowbytes);\n+      return info_ptr->rowbytes;\n@@ -63,1 +74,1 @@\n-   return(0);\n+   return 0;\n@@ -71,1 +82,1 @@\n-      return(info_ptr->row_pointers);\n+      return info_ptr->row_pointers;\n@@ -73,1 +84,1 @@\n-   return(0);\n+   return 0;\n@@ -85,1 +96,1 @@\n-   return (0);\n+   return 0;\n@@ -94,1 +105,1 @@\n-   return (0);\n+   return 0;\n@@ -103,1 +114,1 @@\n-   return (0);\n+   return 0;\n@@ -112,1 +123,1 @@\n-   return (0);\n+   return 0;\n@@ -121,1 +132,1 @@\n-   return (0);\n+   return 0;\n@@ -130,1 +141,1 @@\n-   return (0);\n+   return 0;\n@@ -139,1 +150,1 @@\n-   return (0);\n+   return 0;\n@@ -147,0 +158,2 @@\n+   png_debug(1, \"in png_get_x_pixels_per_meter\");\n+\n@@ -149,7 +162,4 @@\n-      {\n-         png_debug1(1, \"in %s retrieval function\",\n-             \"png_get_x_pixels_per_meter\");\n-\n-         if (info_ptr->phys_unit_type == PNG_RESOLUTION_METER)\n-            return (info_ptr->x_pixels_per_unit);\n-      }\n+   {\n+      if (info_ptr->phys_unit_type == PNG_RESOLUTION_METER)\n+         return info_ptr->x_pixels_per_unit;\n+   }\n@@ -161,1 +171,1 @@\n-   return (0);\n+   return 0;\n@@ -169,0 +179,2 @@\n+   png_debug(1, \"in png_get_y_pixels_per_meter\");\n+\n@@ -172,3 +184,0 @@\n-      png_debug1(1, \"in %s retrieval function\",\n-          \"png_get_y_pixels_per_meter\");\n-\n@@ -176,1 +185,1 @@\n-         return (info_ptr->y_pixels_per_unit);\n+         return info_ptr->y_pixels_per_unit;\n@@ -183,1 +192,1 @@\n-   return (0);\n+   return 0;\n@@ -190,0 +199,2 @@\n+   png_debug(1, \"in png_get_pixels_per_meter\");\n+\n@@ -193,2 +204,0 @@\n-      png_debug1(1, \"in %s retrieval function\", \"png_get_pixels_per_meter\");\n-\n@@ -197,1 +206,1 @@\n-         return (info_ptr->x_pixels_per_unit);\n+         return info_ptr->x_pixels_per_unit;\n@@ -204,1 +213,1 @@\n-   return (0);\n+   return 0;\n@@ -213,0 +222,2 @@\n+   png_debug(1, \"in png_get_pixel_aspect_ratio\");\n+\n@@ -216,2 +227,0 @@\n-      png_debug1(1, \"in %s retrieval function\", \"png_get_aspect_ratio\");\n-\n@@ -219,2 +228,2 @@\n-         return ((float)((float)info_ptr->y_pixels_per_unit\n-             \/(float)info_ptr->x_pixels_per_unit));\n+         return (float)info_ptr->y_pixels_per_unit\n+              \/ (float)info_ptr->x_pixels_per_unit;\n@@ -227,1 +236,1 @@\n-   return ((float)0.0);\n+   return (float)0.0;\n@@ -237,0 +246,2 @@\n+   png_debug(1, \"in png_get_pixel_aspect_ratio_fixed\");\n+\n@@ -245,2 +256,0 @@\n-      png_debug1(1, \"in %s retrieval function\", \"png_get_aspect_ratio_fixed\");\n-\n@@ -267,0 +276,2 @@\n+   png_debug(1, \"in png_get_x_offset_microns\");\n+\n@@ -270,2 +281,0 @@\n-      png_debug1(1, \"in %s retrieval function\", \"png_get_x_offset_microns\");\n-\n@@ -273,1 +282,1 @@\n-         return (info_ptr->x_offset);\n+         return info_ptr->x_offset;\n@@ -280,1 +289,1 @@\n-   return (0);\n+   return 0;\n@@ -287,0 +296,2 @@\n+   png_debug(1, \"in png_get_y_offset_microns\");\n+\n@@ -290,2 +301,0 @@\n-      png_debug1(1, \"in %s retrieval function\", \"png_get_y_offset_microns\");\n-\n@@ -293,1 +302,1 @@\n-         return (info_ptr->y_offset);\n+         return info_ptr->y_offset;\n@@ -300,1 +309,1 @@\n-   return (0);\n+   return 0;\n@@ -307,0 +316,2 @@\n+   png_debug(1, \"in png_get_x_offset_pixels\");\n+\n@@ -310,2 +321,0 @@\n-      png_debug1(1, \"in %s retrieval function\", \"png_get_x_offset_pixels\");\n-\n@@ -313,1 +322,1 @@\n-         return (info_ptr->x_offset);\n+         return info_ptr->x_offset;\n@@ -320,1 +329,1 @@\n-   return (0);\n+   return 0;\n@@ -327,0 +336,2 @@\n+   png_debug(1, \"in png_get_y_offset_pixels\");\n+\n@@ -330,2 +341,0 @@\n-      png_debug1(1, \"in %s retrieval function\", \"png_get_y_offset_pixels\");\n-\n@@ -333,1 +342,1 @@\n-         return (info_ptr->y_offset);\n+         return info_ptr->y_offset;\n@@ -340,1 +349,1 @@\n-   return (0);\n+   return 0;\n@@ -403,1 +412,7 @@\n-   return png_muldiv_warn(png_ptr, microns, 500, 127);\n+   png_fixed_point result;\n+\n+   if (png_muldiv(&result, microns, 500, 127) != 0)\n+      return result;\n+\n+   png_warning(png_ptr, \"fixed point overflow ignored\");\n+   return 0;\n@@ -413,1 +428,1 @@\n-#endif\n+#endif \/* FIXED_POINT *\/\n@@ -454,0 +469,2 @@\n+   png_debug1(1, \"in %s retrieval function\", \"pHYs\");\n+\n@@ -457,2 +474,0 @@\n-      png_debug1(1, \"in %s retrieval function\", \"pHYs\");\n-\n@@ -484,1 +499,1 @@\n-   return (retval);\n+   return retval;\n@@ -498,1 +513,1 @@\n-      return(info_ptr->channels);\n+      return info_ptr->channels;\n@@ -500,1 +515,1 @@\n-   return (0);\n+   return 0;\n@@ -508,1 +523,1 @@\n-      return(info_ptr->signature);\n+      return info_ptr->signature;\n@@ -510,1 +525,1 @@\n-   return (NULL);\n+   return NULL;\n@@ -519,0 +534,2 @@\n+   png_debug1(1, \"in %s retrieval function\", \"bKGD\");\n+\n@@ -523,2 +540,0 @@\n-      png_debug1(1, \"in %s retrieval function\", \"bKGD\");\n-\n@@ -526,1 +541,1 @@\n-      return (PNG_INFO_bKGD);\n+      return PNG_INFO_bKGD;\n@@ -529,1 +544,1 @@\n-   return (0);\n+   return 0;\n@@ -541,2 +556,2 @@\n-    double *white_x, double *white_y, double *red_x, double *red_y,\n-    double *green_x, double *green_y, double *blue_x, double *blue_y)\n+    double *whitex, double *whitey, double *redx, double *redy,\n+    double *greenx, double *greeny, double *bluex, double *bluey)\n@@ -544,6 +559,3 @@\n-   \/* Quiet API change: this code used to only return the end points if a cHRM\n-    * chunk was present, but the end points can also come from iCCP or sRGB\n-    * chunks, so in 1.6.0 the png_get_ APIs return the end points regardless and\n-    * the png_set_ APIs merely check that set end points are mutually\n-    * consistent.\n-    *\/\n+   png_debug1(1, \"in %s retrieval function\", \"cHRM\");\n+\n+   \/* PNGv3: this just returns the values store from the cHRM, if any. *\/\n@@ -551,1 +563,1 @@\n-      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)\n+       (info_ptr->valid & PNG_INFO_cHRM) != 0)\n@@ -553,27 +565,17 @@\n-      png_debug1(1, \"in %s retrieval function\", \"cHRM\");\n-\n-      if (white_x != NULL)\n-         *white_x = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_xy.whitex, \"cHRM white X\");\n-      if (white_y != NULL)\n-         *white_y = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_xy.whitey, \"cHRM white Y\");\n-      if (red_x != NULL)\n-         *red_x = png_float(png_ptr, info_ptr->colorspace.end_points_xy.redx,\n-             \"cHRM red X\");\n-      if (red_y != NULL)\n-         *red_y = png_float(png_ptr, info_ptr->colorspace.end_points_xy.redy,\n-             \"cHRM red Y\");\n-      if (green_x != NULL)\n-         *green_x = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_xy.greenx, \"cHRM green X\");\n-      if (green_y != NULL)\n-         *green_y = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_xy.greeny, \"cHRM green Y\");\n-      if (blue_x != NULL)\n-         *blue_x = png_float(png_ptr, info_ptr->colorspace.end_points_xy.bluex,\n-             \"cHRM blue X\");\n-      if (blue_y != NULL)\n-         *blue_y = png_float(png_ptr, info_ptr->colorspace.end_points_xy.bluey,\n-             \"cHRM blue Y\");\n-      return (PNG_INFO_cHRM);\n+      if (whitex != NULL)\n+         *whitex = png_float(png_ptr, info_ptr->cHRM.whitex, \"cHRM wx\");\n+      if (whitey != NULL)\n+         *whitey = png_float(png_ptr, info_ptr->cHRM.whitey, \"cHRM wy\");\n+      if (redx   != NULL)\n+         *redx   = png_float(png_ptr, info_ptr->cHRM.redx,   \"cHRM rx\");\n+      if (redy   != NULL)\n+         *redy   = png_float(png_ptr, info_ptr->cHRM.redy,   \"cHRM ry\");\n+      if (greenx != NULL)\n+         *greenx = png_float(png_ptr, info_ptr->cHRM.greenx, \"cHRM gx\");\n+      if (greeny != NULL)\n+         *greeny = png_float(png_ptr, info_ptr->cHRM.greeny, \"cHRM gy\");\n+      if (bluex  != NULL)\n+         *bluex  = png_float(png_ptr, info_ptr->cHRM.bluex,  \"cHRM bx\");\n+      if (bluey  != NULL)\n+         *bluey  = png_float(png_ptr, info_ptr->cHRM.bluey,  \"cHRM by\");\n+      return PNG_INFO_cHRM;\n@@ -582,1 +584,1 @@\n-   return (0);\n+   return 0;\n@@ -591,0 +593,3 @@\n+   png_XYZ XYZ;\n+   png_debug1(1, \"in %s retrieval function\", \"cHRM_XYZ(float)\");\n+\n@@ -592,1 +597,2 @@\n-       (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)\n+       (info_ptr->valid & PNG_INFO_cHRM) != 0 &&\n+       png_XYZ_from_xy(&XYZ, &info_ptr->cHRM) == 0)\n@@ -594,2 +600,0 @@\n-      png_debug1(1, \"in %s retrieval function\", \"cHRM_XYZ(float)\");\n-\n@@ -597,2 +601,1 @@\n-         *red_X = png_float(png_ptr, info_ptr->colorspace.end_points_XYZ.red_X,\n-             \"cHRM red X\");\n+         *red_X = png_float(png_ptr, XYZ.red_X, \"cHRM red X\");\n@@ -600,2 +603,1 @@\n-         *red_Y = png_float(png_ptr, info_ptr->colorspace.end_points_XYZ.red_Y,\n-             \"cHRM red Y\");\n+         *red_Y = png_float(png_ptr, XYZ.red_Y, \"cHRM red Y\");\n@@ -603,2 +605,1 @@\n-         *red_Z = png_float(png_ptr, info_ptr->colorspace.end_points_XYZ.red_Z,\n-             \"cHRM red Z\");\n+         *red_Z = png_float(png_ptr, XYZ.red_Z, \"cHRM red Z\");\n@@ -606,2 +607,1 @@\n-         *green_X = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_XYZ.green_X, \"cHRM green X\");\n+         *green_X = png_float(png_ptr, XYZ.green_X, \"cHRM green X\");\n@@ -609,2 +609,1 @@\n-         *green_Y = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_XYZ.green_Y, \"cHRM green Y\");\n+         *green_Y = png_float(png_ptr, XYZ.green_Y, \"cHRM green Y\");\n@@ -612,2 +611,1 @@\n-         *green_Z = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_XYZ.green_Z, \"cHRM green Z\");\n+         *green_Z = png_float(png_ptr, XYZ.green_Z, \"cHRM green Z\");\n@@ -615,2 +613,1 @@\n-         *blue_X = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_XYZ.blue_X, \"cHRM blue X\");\n+         *blue_X = png_float(png_ptr, XYZ.blue_X, \"cHRM blue X\");\n@@ -618,2 +615,1 @@\n-         *blue_Y = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_XYZ.blue_Y, \"cHRM blue Y\");\n+         *blue_Y = png_float(png_ptr, XYZ.blue_Y, \"cHRM blue Y\");\n@@ -621,3 +617,2 @@\n-         *blue_Z = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_XYZ.blue_Z, \"cHRM blue Z\");\n-      return (PNG_INFO_cHRM);\n+         *blue_Z = png_float(png_ptr, XYZ.blue_Z, \"cHRM blue Z\");\n+      return PNG_INFO_cHRM;\n@@ -626,1 +621,1 @@\n-   return (0);\n+   return 0;\n@@ -639,0 +634,3 @@\n+   png_XYZ XYZ;\n+   png_debug1(1, \"in %s retrieval function\", \"cHRM_XYZ\");\n+\n@@ -640,1 +638,2 @@\n-      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)\n+       (info_ptr->valid & PNG_INFO_cHRM) != 0U &&\n+       png_XYZ_from_xy(&XYZ, &info_ptr->cHRM) == 0)\n@@ -642,21 +641,10 @@\n-      png_debug1(1, \"in %s retrieval function\", \"cHRM_XYZ\");\n-\n-      if (int_red_X != NULL)\n-         *int_red_X = info_ptr->colorspace.end_points_XYZ.red_X;\n-      if (int_red_Y != NULL)\n-         *int_red_Y = info_ptr->colorspace.end_points_XYZ.red_Y;\n-      if (int_red_Z != NULL)\n-         *int_red_Z = info_ptr->colorspace.end_points_XYZ.red_Z;\n-      if (int_green_X != NULL)\n-         *int_green_X = info_ptr->colorspace.end_points_XYZ.green_X;\n-      if (int_green_Y != NULL)\n-         *int_green_Y = info_ptr->colorspace.end_points_XYZ.green_Y;\n-      if (int_green_Z != NULL)\n-         *int_green_Z = info_ptr->colorspace.end_points_XYZ.green_Z;\n-      if (int_blue_X != NULL)\n-         *int_blue_X = info_ptr->colorspace.end_points_XYZ.blue_X;\n-      if (int_blue_Y != NULL)\n-         *int_blue_Y = info_ptr->colorspace.end_points_XYZ.blue_Y;\n-      if (int_blue_Z != NULL)\n-         *int_blue_Z = info_ptr->colorspace.end_points_XYZ.blue_Z;\n-      return (PNG_INFO_cHRM);\n+      if (int_red_X != NULL) *int_red_X = XYZ.red_X;\n+      if (int_red_Y != NULL) *int_red_Y = XYZ.red_Y;\n+      if (int_red_Z != NULL) *int_red_Z = XYZ.red_Z;\n+      if (int_green_X != NULL) *int_green_X = XYZ.green_X;\n+      if (int_green_Y != NULL) *int_green_Y = XYZ.green_Y;\n+      if (int_green_Z != NULL) *int_green_Z = XYZ.green_Z;\n+      if (int_blue_X != NULL) *int_blue_X = XYZ.blue_X;\n+      if (int_blue_Y != NULL) *int_blue_Y = XYZ.blue_Y;\n+      if (int_blue_Z != NULL) *int_blue_Z = XYZ.blue_Z;\n+      return PNG_INFO_cHRM;\n@@ -665,1 +653,1 @@\n-   return (0);\n+   return 0;\n@@ -670,3 +658,3 @@\n-    png_fixed_point *white_x, png_fixed_point *white_y, png_fixed_point *red_x,\n-    png_fixed_point *red_y, png_fixed_point *green_x, png_fixed_point *green_y,\n-    png_fixed_point *blue_x, png_fixed_point *blue_y)\n+    png_fixed_point *whitex, png_fixed_point *whitey, png_fixed_point *redx,\n+    png_fixed_point *redy, png_fixed_point *greenx, png_fixed_point *greeny,\n+    png_fixed_point *bluex, png_fixed_point *bluey)\n@@ -676,0 +664,1 @@\n+   \/* PNGv3: this just returns the values store from the cHRM, if any. *\/\n@@ -677,1 +666,1 @@\n-      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)\n+       (info_ptr->valid & PNG_INFO_cHRM) != 0)\n@@ -679,17 +668,9 @@\n-      if (white_x != NULL)\n-         *white_x = info_ptr->colorspace.end_points_xy.whitex;\n-      if (white_y != NULL)\n-         *white_y = info_ptr->colorspace.end_points_xy.whitey;\n-      if (red_x != NULL)\n-         *red_x = info_ptr->colorspace.end_points_xy.redx;\n-      if (red_y != NULL)\n-         *red_y = info_ptr->colorspace.end_points_xy.redy;\n-      if (green_x != NULL)\n-         *green_x = info_ptr->colorspace.end_points_xy.greenx;\n-      if (green_y != NULL)\n-         *green_y = info_ptr->colorspace.end_points_xy.greeny;\n-      if (blue_x != NULL)\n-         *blue_x = info_ptr->colorspace.end_points_xy.bluex;\n-      if (blue_y != NULL)\n-         *blue_y = info_ptr->colorspace.end_points_xy.bluey;\n-      return (PNG_INFO_cHRM);\n+      if (whitex != NULL) *whitex = info_ptr->cHRM.whitex;\n+      if (whitey != NULL) *whitey = info_ptr->cHRM.whitey;\n+      if (redx   != NULL) *redx   = info_ptr->cHRM.redx;\n+      if (redy   != NULL) *redy   = info_ptr->cHRM.redy;\n+      if (greenx != NULL) *greenx = info_ptr->cHRM.greenx;\n+      if (greeny != NULL) *greeny = info_ptr->cHRM.greeny;\n+      if (bluex  != NULL) *bluex  = info_ptr->cHRM.bluex;\n+      if (bluey  != NULL) *bluey  = info_ptr->cHRM.bluey;\n+      return PNG_INFO_cHRM;\n@@ -698,1 +679,1 @@\n-   return (0);\n+   return 0;\n@@ -711,0 +692,1 @@\n+   \/* PNGv3 compatibility: only report gAMA if it is really present. *\/\n@@ -712,2 +694,1 @@\n-       (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_GAMMA) != 0 &&\n-       file_gamma != NULL)\n+       (info_ptr->valid & PNG_INFO_gAMA) != 0)\n@@ -715,2 +696,2 @@\n-      *file_gamma = info_ptr->colorspace.gamma;\n-      return (PNG_INFO_gAMA);\n+      if (file_gamma != NULL) *file_gamma = info_ptr->gamma;\n+      return PNG_INFO_gAMA;\n@@ -719,1 +700,1 @@\n-   return (0);\n+   return 0;\n@@ -730,0 +711,1 @@\n+   \/* PNGv3 compatibility: only report gAMA if it is really present. *\/\n@@ -731,2 +713,1 @@\n-      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_GAMMA) != 0 &&\n-      file_gamma != NULL)\n+       (info_ptr->valid & PNG_INFO_gAMA) != 0)\n@@ -734,3 +715,4 @@\n-      *file_gamma = png_float(png_ptr, info_ptr->colorspace.gamma,\n-          \"png_get_gAMA\");\n-      return (PNG_INFO_gAMA);\n+      if (file_gamma != NULL)\n+         *file_gamma = png_float(png_ptr, info_ptr->gamma, \"gAMA\");\n+\n+      return PNG_INFO_gAMA;\n@@ -739,1 +721,1 @@\n-   return (0);\n+   return 0;\n@@ -752,1 +734,1 @@\n-      (info_ptr->valid & PNG_INFO_sRGB) != 0 && file_srgb_intent != NULL)\n+      (info_ptr->valid & PNG_INFO_sRGB) != 0)\n@@ -754,2 +736,3 @@\n-      *file_srgb_intent = info_ptr->colorspace.rendering_intent;\n-      return (PNG_INFO_sRGB);\n+      if (file_srgb_intent != NULL)\n+         *file_srgb_intent = info_ptr->rendering_intent;\n+      return PNG_INFO_sRGB;\n@@ -758,1 +741,1 @@\n-   return (0);\n+   return 0;\n@@ -782,1 +765,1 @@\n-      return (PNG_INFO_iCCP);\n+      return PNG_INFO_iCCP;\n@@ -785,1 +768,1 @@\n-   return (0);\n+   return 0;\n@@ -795,0 +778,2 @@\n+   png_debug1(1, \"in %s retrieval function\", \"sPLT\");\n+\n@@ -801,1 +786,26 @@\n-   return (0);\n+   return 0;\n+}\n+#endif\n+\n+#ifdef PNG_cICP_SUPPORTED\n+png_uint_32 PNGAPI\n+png_get_cICP(png_const_structrp png_ptr,\n+             png_const_inforp info_ptr, png_bytep colour_primaries,\n+             png_bytep transfer_function, png_bytep matrix_coefficients,\n+             png_bytep video_full_range_flag)\n+{\n+    png_debug1(1, \"in %s retrieval function\", \"cICP\");\n+\n+    if (png_ptr != NULL && info_ptr != NULL &&\n+        (info_ptr->valid & PNG_INFO_cICP) != 0 &&\n+        colour_primaries != NULL && transfer_function != NULL &&\n+        matrix_coefficients != NULL && video_full_range_flag != NULL)\n+    {\n+        *colour_primaries = info_ptr->cicp_colour_primaries;\n+        *transfer_function = info_ptr->cicp_transfer_function;\n+        *matrix_coefficients = info_ptr->cicp_matrix_coefficients;\n+        *video_full_range_flag = info_ptr->cicp_video_full_range_flag;\n+        return (PNG_INFO_cICP);\n+    }\n+\n+    return 0;\n@@ -805,0 +815,105 @@\n+#ifdef PNG_cLLI_SUPPORTED\n+#  ifdef PNG_FIXED_POINT_SUPPORTED\n+png_uint_32 PNGAPI\n+png_get_cLLI_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\n+    png_uint_32p maxCLL,\n+    png_uint_32p maxFALL)\n+{\n+   png_debug1(1, \"in %s retrieval function\", \"cLLI\");\n+\n+   if (png_ptr != NULL && info_ptr != NULL &&\n+       (info_ptr->valid & PNG_INFO_cLLI) != 0)\n+   {\n+      if (maxCLL != NULL) *maxCLL = info_ptr->maxCLL;\n+      if (maxFALL != NULL) *maxFALL = info_ptr->maxFALL;\n+      return PNG_INFO_cLLI;\n+   }\n+\n+   return 0;\n+}\n+#  endif\n+\n+#  ifdef PNG_FLOATING_POINT_SUPPORTED\n+png_uint_32 PNGAPI\n+png_get_cLLI(png_const_structrp png_ptr, png_const_inforp info_ptr,\n+      double *maxCLL, double *maxFALL)\n+{\n+   png_debug1(1, \"in %s retrieval function\", \"cLLI(float)\");\n+\n+   if (png_ptr != NULL && info_ptr != NULL &&\n+       (info_ptr->valid & PNG_INFO_cLLI) != 0)\n+   {\n+      if (maxCLL != NULL) *maxCLL = info_ptr->maxCLL * .0001;\n+      if (maxFALL != NULL) *maxFALL = info_ptr->maxFALL * .0001;\n+      return PNG_INFO_cLLI;\n+   }\n+\n+   return 0;\n+}\n+#  endif\n+#endif \/* cLLI *\/\n+\n+#ifdef PNG_mDCV_SUPPORTED\n+#  ifdef PNG_FIXED_POINT_SUPPORTED\n+png_uint_32 PNGAPI\n+png_get_mDCV_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\n+    png_fixed_point *white_x, png_fixed_point *white_y,\n+    png_fixed_point *red_x, png_fixed_point *red_y,\n+    png_fixed_point *green_x, png_fixed_point *green_y,\n+    png_fixed_point *blue_x, png_fixed_point *blue_y,\n+    png_uint_32p mastering_maxDL, png_uint_32p mastering_minDL)\n+{\n+   png_debug1(1, \"in %s retrieval function\", \"mDCV\");\n+\n+   if (png_ptr != NULL && info_ptr != NULL &&\n+       (info_ptr->valid & PNG_INFO_mDCV) != 0)\n+   {\n+      if (white_x != NULL) *white_x = info_ptr->mastering_white_x * 2;\n+      if (white_y != NULL) *white_y = info_ptr->mastering_white_y * 2;\n+      if (red_x != NULL) *red_x = info_ptr->mastering_red_x * 2;\n+      if (red_y != NULL) *red_y = info_ptr->mastering_red_y * 2;\n+      if (green_x != NULL) *green_x = info_ptr->mastering_green_x * 2;\n+      if (green_y != NULL) *green_y = info_ptr->mastering_green_y * 2;\n+      if (blue_x != NULL) *blue_x = info_ptr->mastering_blue_x * 2;\n+      if (blue_y != NULL) *blue_y = info_ptr->mastering_blue_y * 2;\n+      if (mastering_maxDL != NULL) *mastering_maxDL = info_ptr->mastering_maxDL;\n+      if (mastering_minDL != NULL) *mastering_minDL = info_ptr->mastering_minDL;\n+      return PNG_INFO_mDCV;\n+   }\n+\n+   return 0;\n+}\n+#  endif\n+\n+#  ifdef PNG_FLOATING_POINT_SUPPORTED\n+png_uint_32 PNGAPI\n+png_get_mDCV(png_const_structrp png_ptr, png_const_inforp info_ptr,\n+    double *white_x, double *white_y, double *red_x, double *red_y,\n+    double *green_x, double *green_y, double *blue_x, double *blue_y,\n+    double *mastering_maxDL, double *mastering_minDL)\n+{\n+   png_debug1(1, \"in %s retrieval function\", \"mDCV(float)\");\n+\n+   if (png_ptr != NULL && info_ptr != NULL &&\n+       (info_ptr->valid & PNG_INFO_mDCV) != 0)\n+   {\n+      if (white_x != NULL) *white_x = info_ptr->mastering_white_x * .00002;\n+      if (white_y != NULL) *white_y = info_ptr->mastering_white_y * .00002;\n+      if (red_x != NULL) *red_x = info_ptr->mastering_red_x * .00002;\n+      if (red_y != NULL) *red_y = info_ptr->mastering_red_y * .00002;\n+      if (green_x != NULL) *green_x = info_ptr->mastering_green_x * .00002;\n+      if (green_y != NULL) *green_y = info_ptr->mastering_green_y * .00002;\n+      if (blue_x != NULL) *blue_x = info_ptr->mastering_blue_x * .00002;\n+      if (blue_y != NULL) *blue_y = info_ptr->mastering_blue_y * .00002;\n+      if (mastering_maxDL != NULL)\n+         *mastering_maxDL = info_ptr->mastering_maxDL * .0001;\n+      if (mastering_minDL != NULL)\n+         *mastering_minDL = info_ptr->mastering_minDL * .0001;\n+      return PNG_INFO_mDCV;\n+   }\n+\n+   return 0;\n+}\n+#  endif \/* FLOATING_POINT *\/\n+#endif \/* mDCV *\/\n+\n@@ -827,1 +942,1 @@\n-      return (PNG_INFO_eXIf);\n+      return PNG_INFO_eXIf;\n@@ -830,1 +945,1 @@\n-   return (0);\n+   return 0;\n@@ -845,1 +960,1 @@\n-      return (PNG_INFO_hIST);\n+      return PNG_INFO_hIST;\n@@ -848,1 +963,1 @@\n-   return (0);\n+   return 0;\n@@ -861,1 +976,1 @@\n-      return (0);\n+      return 0;\n@@ -893,1 +1008,1 @@\n-   return (1);\n+   return 1;\n@@ -910,1 +1025,1 @@\n-      return (PNG_INFO_oFFs);\n+      return PNG_INFO_oFFs;\n@@ -913,1 +1028,1 @@\n-   return (0);\n+   return 0;\n@@ -937,1 +1052,1 @@\n-      return (PNG_INFO_pCAL);\n+      return PNG_INFO_pCAL;\n@@ -940,1 +1055,1 @@\n-   return (0);\n+   return 0;\n@@ -952,0 +1067,2 @@\n+   png_debug1(1, \"in %s retrieval function\", \"sCAL\");\n+\n@@ -963,1 +1080,1 @@\n-      return (PNG_INFO_sCAL);\n+      return PNG_INFO_sCAL;\n@@ -966,1 +1083,1 @@\n-   return(0);\n+   return 0;\n@@ -975,0 +1092,2 @@\n+   png_debug1(1, \"in %s retrieval function\", \"sCAL(float)\");\n+\n@@ -981,1 +1100,1 @@\n-      return (PNG_INFO_sCAL);\n+      return PNG_INFO_sCAL;\n@@ -984,1 +1103,1 @@\n-   return(0);\n+   return 0;\n@@ -991,0 +1110,2 @@\n+   png_debug1(1, \"in %s retrieval function\", \"sCAL(str)\");\n+\n@@ -997,1 +1118,1 @@\n-      return (PNG_INFO_sCAL);\n+      return PNG_INFO_sCAL;\n@@ -1000,1 +1121,1 @@\n-   return(0);\n+   return 0;\n@@ -1035,1 +1156,1 @@\n-   return (retval);\n+   return retval;\n@@ -1051,1 +1172,1 @@\n-      return (PNG_INFO_PLTE);\n+      return PNG_INFO_PLTE;\n@@ -1054,1 +1175,1 @@\n-   return (0);\n+   return 0;\n@@ -1068,1 +1189,1 @@\n-      return (PNG_INFO_sBIT);\n+      return PNG_INFO_sBIT;\n@@ -1071,1 +1192,1 @@\n-   return (0);\n+   return 0;\n@@ -1082,1 +1203,1 @@\n-      png_debug1(1, \"in 0x%lx retrieval function\",\n+      png_debug1(1, \"in text retrieval function, chunk typeid = 0x%lx\",\n@@ -1097,1 +1218,1 @@\n-   return(0);\n+   return 0;\n@@ -1112,1 +1233,1 @@\n-      return (PNG_INFO_tIME);\n+      return PNG_INFO_tIME;\n@@ -1115,1 +1236,1 @@\n-   return (0);\n+   return 0;\n@@ -1125,0 +1246,3 @@\n+\n+   png_debug1(1, \"in %s retrieval function\", \"tRNS\");\n+\n@@ -1128,2 +1252,0 @@\n-      png_debug1(1, \"in %s retrieval function\", \"tRNS\");\n-\n@@ -1161,1 +1283,1 @@\n-   return (retval);\n+   return retval;\n@@ -1176,1 +1298,1 @@\n-   return (0);\n+   return 0;\n@@ -1272,1 +1394,1 @@\n-   return (-1);\n+   return -1;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/pngget.c","additions":342,"deletions":220,"binary":false,"changes":562,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/* pnginfo.h - header file for PNG reference library\n+\/* pnginfo.h - internal structures for libpng\n@@ -32,1 +32,1 @@\n- * Copyright (c) 2018 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -42,19 +42,5 @@\n- \/* png_info is a structure that holds the information in a PNG file so\n- * that the application can find out the characteristics of the image.\n- * If you are reading the file, this structure will tell you what is\n- * in the PNG file.  If you are writing the file, fill in the information\n- * you want to put into the PNG file, using png_set_*() functions, then\n- * call png_write_info().\n- *\n- * The names chosen should be very close to the PNG specification, so\n- * consult that document for information about the meaning of each field.\n- *\n- * With libpng < 0.95, it was only possible to directly set and read the\n- * the values in the png_info_struct, which meant that the contents and\n- * order of the values had to remain fixed.  With libpng 0.95 and later,\n- * however, there are now functions that abstract the contents of\n- * png_info_struct from the application, so this makes it easier to use\n- * libpng with dynamic libraries, and even makes it possible to use\n- * libraries that don't have all of the libpng ancillary chunk-handing\n- * functionality.  In libpng-1.5.0 this was moved into a separate private\n- * file that is not visible to applications.\n+#ifndef PNGPRIV_H\n+#  error This file must not be included by applications; please include <png.h>\n+#endif\n+\n+\/* INTERNAL, PRIVATE definition of a PNG.\n@@ -62,7 +48,3 @@\n- * The following members may have allocated storage attached that should be\n- * cleaned up before the structure is discarded: palette, trans, text,\n- * pcal_purpose, pcal_units, pcal_params, hist, iccp_name, iccp_profile,\n- * splt_palettes, scal_unit, row_pointers, and unknowns.   By default, these\n- * are automatically freed when the info structure is deallocated, if they were\n- * allocated internally by libpng.  This behavior can be changed by means\n- * of the png_data_freer() function.\n+ * png_info is a modifiable description of a PNG datastream.  The fields inside\n+ * this structure are accessed through png_get_<CHUNK>() functions and modified\n+ * using png_set_<CHUNK>() functions.\n@@ -70,9 +52,4 @@\n- * More allocation details: all the chunk-reading functions that\n- * change these members go through the corresponding png_set_*\n- * functions.  A function to clear these members is available: see\n- * png_free_data().  The png_set_* functions do not depend on being\n- * able to point info structure members to any of the storage they are\n- * passed (they make their own copies), EXCEPT that the png_set_text\n- * functions use the same storage passed to them in the text_ptr or\n- * itxt_ptr structure argument, and the png_set_rows and png_set_unknowns\n- * functions do not make their own copies.\n+ * Some functions in libpng do directly access members of png_info.  However,\n+ * this should be avoided.  png_struct objects contain members which hold\n+ * caches, sometimes optimised, of the values from png_info objects, and\n+ * png_info is not passed to the functions which read and write image data.\n@@ -118,12 +95,6 @@\n-#if defined(PNG_COLORSPACE_SUPPORTED) || defined(PNG_GAMMA_SUPPORTED)\n-   \/* png_colorspace only contains 'flags' if neither GAMMA or COLORSPACE are\n-    * defined.  When COLORSPACE is switched on all the colorspace-defining\n-    * chunks should be enabled, when GAMMA is switched on all the gamma-defining\n-    * chunks should be enabled.  If this is not done it becomes possible to read\n-    * inconsistent PNG files and assign a probably incorrect interpretation to\n-    * the information.  (In other words, by carefully choosing which chunks to\n-    * recognize the system configuration can select an interpretation for PNG\n-    * files containing ambiguous data and this will result in inconsistent\n-    * behavior between different libpng builds!)\n-    *\/\n-   png_colorspace colorspace;\n+#ifdef PNG_cICP_SUPPORTED\n+   \/* cICP chunk data *\/\n+   png_byte cicp_colour_primaries;\n+   png_byte cicp_transfer_function;\n+   png_byte cicp_matrix_coefficients;\n+   png_byte cicp_video_full_range_flag;\n@@ -139,0 +110,18 @@\n+#ifdef PNG_cLLI_SUPPORTED\n+   png_uint_32 maxCLL;  \/* cd\/m2 (nits) * 10,000 *\/\n+   png_uint_32 maxFALL;\n+#endif\n+\n+#ifdef PNG_mDCV_SUPPORTED\n+   png_uint_16 mastering_red_x;  \/* CIE (xy) x * 50,000 *\/\n+   png_uint_16 mastering_red_y;\n+   png_uint_16 mastering_green_x;\n+   png_uint_16 mastering_green_y;\n+   png_uint_16 mastering_blue_x;\n+   png_uint_16 mastering_blue_y;\n+   png_uint_16 mastering_white_x;\n+   png_uint_16 mastering_white_y;\n+   png_uint_32 mastering_maxDL; \/* cd\/m2 (nits) * 10,000 *\/\n+   png_uint_32 mastering_minDL;\n+#endif\n+\n@@ -217,1 +206,1 @@\n-   int num_exif;  \/* Added at libpng-1.6.31 *\/\n+   png_uint_32 num_exif;  \/* Added at libpng-1.6.31 *\/\n@@ -219,3 +208,0 @@\n-# ifdef PNG_READ_eXIf_SUPPORTED\n-   png_bytep eXIf_buf;  \/* Added at libpng-1.6.32 *\/\n-# endif\n@@ -294,0 +280,11 @@\n+#ifdef PNG_cHRM_SUPPORTED\n+   png_xy cHRM;\n+#endif\n+\n+#ifdef PNG_gAMA_SUPPORTED\n+   png_fixed_point gamma;\n+#endif\n+\n+#ifdef PNG_sRGB_SUPPORTED\n+   int rendering_intent;\n+#endif\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/pnginfo.h","additions":50,"deletions":53,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-\/* libpng version 1.6.39 *\/\n+\/* libpng version 1.6.51 *\/\n@@ -36,1 +36,1 @@\n-\/* Copyright (c) 2018-2022 Cosmin Truta *\/\n+\/* Copyright (c) 2018-2025 Cosmin Truta *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/pnglibconf.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -104,3 +104,9 @@\n-#ifndef PNG_USER_MEM_SUPPORTED\n-   PNG_UNUSED(png_ptr)\n-#endif\n+#  ifdef PNG_MAX_MALLOC_64K\n+      \/* This is support for legacy systems which had segmented addressing\n+       * limiting the maximum allocation size to 65536.  It takes precedence\n+       * over PNG_SIZE_MAX which is set to 65535 on true 16-bit systems.\n+       *\n+       * TODO: libpng-1.8: finally remove both cases.\n+       *\/\n+      if (size > 65536U) return NULL;\n+#  endif\n@@ -108,2 +114,1 @@\n-   \/* Some compilers complain that this is always true.  However, it\n-    * can be false when integer overflow happens.\n+   \/* This is checked too because the system malloc call below takes a (size_t).\n@@ -111,7 +116,3 @@\n-   if (size > 0 && size <= PNG_SIZE_MAX\n-#     ifdef PNG_MAX_MALLOC_64K\n-         && size <= 65536U\n-#     endif\n-      )\n-   {\n-#ifdef PNG_USER_MEM_SUPPORTED\n+   if (size > PNG_SIZE_MAX) return NULL;\n+\n+#  ifdef PNG_USER_MEM_SUPPORTED\n@@ -120,0 +121,3 @@\n+#  else\n+      PNG_UNUSED(png_ptr)\n+#  endif\n@@ -121,7 +125,2 @@\n-      else\n-#endif\n-         return malloc((size_t)size); \/* checked for truncation above *\/\n-   }\n-\n-   else\n-      return NULL;\n+   \/* Use the system malloc *\/\n+   return malloc((size_t)\/*SAFE*\/size); \/* checked for truncation above *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/pngmem.c","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -63,0 +63,15 @@\n+#ifdef PNG_READ_INTERLACING_SUPPORTED\n+\/* Arrays to facilitate interlacing - use pass (0 - 6) as index. *\/\n+\n+\/* Start of interlace block *\/\n+static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\n+\/* Offset to next interlace block *\/\n+static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n+\/* Start of interlace block in the y direction *\/\n+static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};\n+\/* Offset to next interlace block in the y direction *\/\n+static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n+\n+\/* TODO: Move these arrays to a common utility module to avoid duplication. *\/\n+#endif\n+\n@@ -176,1 +191,1 @@\n-   if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check))\n+   if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check) != 0)\n@@ -179,1 +194,1 @@\n-          png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4))\n+          png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4) != 0)\n@@ -210,3 +225,0 @@\n-      png_byte chunk_length[4];\n-      png_byte chunk_tag[4];\n-\n@@ -214,7 +226,1 @@\n-      png_push_fill_buffer(png_ptr, chunk_length, 4);\n-      png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);\n-      png_reset_crc(png_ptr);\n-      png_crc_read(png_ptr, chunk_tag, 4);\n-      png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(chunk_tag);\n-      png_check_chunk_name(png_ptr, png_ptr->chunk_name);\n-      png_check_chunk_length(png_ptr, png_ptr->push_length);\n+      png_ptr->push_length = png_read_chunk_header(png_ptr);\n@@ -255,0 +261,8 @@\n+   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n+   {\n+      \/* These flags must be set consistently for all non-IDAT chunks,\n+       * including the unknown chunks.\n+       *\/\n+      png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT | PNG_AFTER_IDAT;\n+   }\n+\n@@ -261,1 +275,1 @@\n-      png_handle_IHDR(png_ptr, info_ptr, png_ptr->push_length);\n+      png_handle_chunk(png_ptr, info_ptr, png_ptr->push_length);\n@@ -267,1 +281,1 @@\n-      png_handle_IEND(png_ptr, info_ptr, png_ptr->push_length);\n+      png_handle_chunk(png_ptr, info_ptr, png_ptr->push_length);\n@@ -284,6 +298,0 @@\n-   else if (chunk_name == png_PLTE)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_PLTE(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n@@ -302,136 +310,0 @@\n-#ifdef PNG_READ_gAMA_SUPPORTED\n-   else if (png_ptr->chunk_name == png_gAMA)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_gAMA(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_sBIT_SUPPORTED\n-   else if (png_ptr->chunk_name == png_sBIT)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_sBIT(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_cHRM_SUPPORTED\n-   else if (png_ptr->chunk_name == png_cHRM)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_cHRM(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_sRGB_SUPPORTED\n-   else if (chunk_name == png_sRGB)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_sRGB(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_iCCP_SUPPORTED\n-   else if (png_ptr->chunk_name == png_iCCP)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_iCCP(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_sPLT_SUPPORTED\n-   else if (chunk_name == png_sPLT)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_sPLT(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_tRNS_SUPPORTED\n-   else if (chunk_name == png_tRNS)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_tRNS(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_bKGD_SUPPORTED\n-   else if (chunk_name == png_bKGD)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_bKGD(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_hIST_SUPPORTED\n-   else if (chunk_name == png_hIST)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_hIST(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_pHYs_SUPPORTED\n-   else if (chunk_name == png_pHYs)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_pHYs(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_oFFs_SUPPORTED\n-   else if (chunk_name == png_oFFs)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_oFFs(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-#endif\n-\n-#ifdef PNG_READ_pCAL_SUPPORTED\n-   else if (chunk_name == png_pCAL)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_pCAL(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_sCAL_SUPPORTED\n-   else if (chunk_name == png_sCAL)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_sCAL(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_tIME_SUPPORTED\n-   else if (chunk_name == png_tIME)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_tIME(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_tEXt_SUPPORTED\n-   else if (chunk_name == png_tEXt)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_zTXt_SUPPORTED\n-   else if (chunk_name == png_zTXt)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_iTXt_SUPPORTED\n-   else if (chunk_name == png_iTXt)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-#endif\n-\n@@ -441,2 +313,1 @@\n-      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length,\n-          PNG_HANDLE_CHUNK_AS_DEFAULT);\n+      png_handle_chunk(png_ptr, info_ptr, png_ptr->push_length);\n@@ -999,21 +870,0 @@\n-#ifdef PNG_READ_INTERLACING_SUPPORTED\n-   \/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index *\/\n-\n-   \/* Start of interlace block *\/\n-   static const png_byte png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};\n-\n-   \/* Offset to next interlace block *\/\n-   static const png_byte png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};\n-\n-   \/* Start of interlace block in the y direction *\/\n-   static const png_byte png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};\n-\n-   \/* Offset to next interlace block in the y direction *\/\n-   static const png_byte png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};\n-\n-   \/* Height of interlace block.  This is not currently used - if you need\n-    * it, uncomment it here and in png.h\n-   static const png_byte png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};\n-   *\/\n-#endif\n-\n@@ -1120,1 +970,1 @@\n-      return (NULL);\n+      return NULL;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/pngpread.c","additions":31,"deletions":181,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2022 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -51,0 +51,5 @@\n+\n+\/* pngpriv.h must be included first in each translation unit inside libpng.\n+ * On the other hand, it must not be included at all, directly or indirectly,\n+ * by any application code that uses the libpng API.\n+ *\/\n@@ -52,1 +57,8 @@\n-#define PNGPRIV_H\n+#  define PNGPRIV_H\n+#else\n+#  error Duplicate inclusion of pngpriv.h; please check the libpng source files\n+#endif\n+\n+#if defined(PNG_H) || defined(PNGCONF_H) || defined(PNGLCONF_H)\n+#  error This file must not be included by applications; please include <png.h>\n+#endif\n@@ -67,1 +79,1 @@\n-# define _POSIX_SOURCE 1 \/* Just the POSIX 1003.1 and C89 APIs *\/\n+#  define _POSIX_SOURCE 1 \/* Just the POSIX 1003.1 and C89 APIs *\/\n@@ -89,1 +101,0 @@\n-\n@@ -99,3 +110,1 @@\n-#ifndef PNGLCONF_H\n-#  include \"pnglibconf.h\"\n-#endif\n+#include \"pnglibconf.h\"\n@@ -166,0 +175,14 @@\n+#ifndef PNG_RISCV_RVV_OPT\n+   \/* RISCV_RVV optimizations are being controlled by the compiler settings,\n+    * typically the target compiler will define __riscv but the rvv extension\n+    * availability has to be explicitly stated. This is why if no\n+    * PNG_RISCV_RVV_OPT was defined then a runtime check will be executed.\n+    *\n+    * To enable RISCV_RVV optimizations unconditionally, and compile the\n+    * associated code, pass --enable-riscv-rvv=yes or --enable-riscv-rvv=on\n+    * to configure or put -DPNG_RISCV_RVV_OPT=2 in CPPFLAGS.\n+    *\/\n+\n+#  define PNG_RISCV_RVV_OPT 0\n+#endif\n+\n@@ -171,41 +194,0 @@\n-\n-   \/* By default the 'intrinsics' code in arm\/filter_neon_intrinsics.c is used\n-    * if possible - if __ARM_NEON__ is set and the compiler version is not known\n-    * to be broken.  This is controlled by PNG_ARM_NEON_IMPLEMENTATION which can\n-    * be:\n-    *\n-    *    1  The intrinsics code (the default with __ARM_NEON__)\n-    *    2  The hand coded assembler (the default without __ARM_NEON__)\n-    *\n-    * It is possible to set PNG_ARM_NEON_IMPLEMENTATION in CPPFLAGS, however\n-    * this is *NOT* supported and may cease to work even after a minor revision\n-    * to libpng.  It *is* valid to do this for testing purposes, e.g. speed\n-    * testing or a new compiler, but the results should be communicated to the\n-    * libpng implementation list for incorporation in the next minor release.\n-    *\/\n-#  ifndef PNG_ARM_NEON_IMPLEMENTATION\n-#     if defined(__ARM_NEON__) || defined(__ARM_NEON)\n-#        if defined(__clang__)\n-            \/* At present it is unknown by the libpng developers which versions\n-             * of clang support the intrinsics, however some or perhaps all\n-             * versions do not work with the assembler so this may be\n-             * irrelevant, so just use the default (do nothing here.)\n-             *\/\n-#        elif defined(__GNUC__)\n-            \/* GCC 4.5.4 NEON support is known to be broken.  4.6.3 is known to\n-             * work, so if this *is* GCC, or G++, look for a version >4.5\n-             *\/\n-#           if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 6)\n-#              define PNG_ARM_NEON_IMPLEMENTATION 2\n-#           endif \/* no GNUC support *\/\n-#        endif \/* __GNUC__ *\/\n-#     else \/* !defined __ARM_NEON__ *\/\n-         \/* The 'intrinsics' code simply won't compile without this -mfpu=neon:\n-          *\/\n-#        if !defined(__aarch64__) && !defined(_M_ARM64)\n-            \/* The assembler code currently does not work on ARM64 *\/\n-#          define PNG_ARM_NEON_IMPLEMENTATION 2\n-#        endif \/* __aarch64__ *\/\n-#     endif \/* __ARM_NEON__ *\/\n-#  endif \/* !PNG_ARM_NEON_IMPLEMENTATION *\/\n-\n@@ -221,1 +203,2 @@\n-#  if defined(__mips_msa) && (__mips_isa_rev >= 5) && defined(PNG_ALIGNED_MEMORY_SUPPORTED)\n+#  if defined(__mips_msa) && (__mips_isa_rev >= 5) && \\\n+   defined(PNG_ALIGNED_MEMORY_SUPPORTED)\n@@ -228,0 +211,13 @@\n+#ifndef PNG_MIPS_MMI_OPT\n+#  ifdef PNG_MIPS_MMI\n+#    if defined(__mips_loongson_mmi) && (_MIPS_SIM == _ABI64) && \\\n+     defined(PNG_ALIGNED_MEMORY_SUPPORTED)\n+#       define PNG_MIPS_MMI_OPT 1\n+#    else\n+#       define PNG_MIPS_MMI_OPT 0\n+#    endif\n+#  else\n+#    define PNG_MIPS_MMI_OPT 0\n+#  endif\n+#endif\n+\n@@ -236,0 +232,8 @@\n+#ifndef PNG_LOONGARCH_LSX_OPT\n+#  if defined(__loongarch_sx)\n+#     define PNG_LOONGARCH_LSX_OPT 1\n+#  else\n+#     define PNG_LOONGARCH_LSX_OPT 0\n+#  endif\n+#endif\n+\n@@ -242,1 +246,1 @@\n-#     if defined(__SSE4_1__) || defined(__AVX__) || defined(__SSSE3__) || \\\n+#      if defined(__SSE4_1__) || defined(__AVX__) || defined(__SSSE3__) || \\\n@@ -279,1 +283,0 @@\n-#  define PNG_FILTER_OPTIMIZATIONS png_init_filter_functions_msa\n@@ -295,0 +298,1 @@\n+#     define PNG_FILTER_OPTIMIZATIONS png_init_filter_functions_mips\n@@ -300,0 +304,16 @@\n+#if PNG_MIPS_MMI_OPT > 0\n+#  ifndef PNG_MIPS_MMI_IMPLEMENTATION\n+#     if defined(__mips_loongson_mmi) && (_MIPS_SIM == _ABI64)\n+#        define PNG_MIPS_MMI_IMPLEMENTATION 2\n+#     else \/* !defined __mips_loongson_mmi  || _MIPS_SIM != _ABI64 *\/\n+#        define PNG_MIPS_MMI_IMPLEMENTATION 0\n+#     endif \/* __mips_loongson_mmi  && _MIPS_SIM == _ABI64 *\/\n+#  endif \/* !PNG_MIPS_MMI_IMPLEMENTATION *\/\n+\n+#   if PNG_MIPS_MMI_IMPLEMENTATION > 0\n+#      define PNG_FILTER_OPTIMIZATIONS png_init_filter_functions_mips\n+#   endif\n+#else\n+#   define PNG_MIPS_MMI_IMPLEMENTATION 0\n+#endif \/* PNG_MIPS_MMI_OPT > 0 *\/\n+\n@@ -307,0 +327,16 @@\n+#if PNG_LOONGARCH_LSX_OPT > 0\n+#   define PNG_FILTER_OPTIMIZATIONS png_init_filter_functions_lsx\n+#   define PNG_LOONGARCH_LSX_IMPLEMENTATION 1\n+#else\n+#   define PNG_LOONGARCH_LSX_IMPLEMENTATION 0\n+#endif\n+\n+#if PNG_RISCV_RVV_OPT > 0 && __riscv_v >= 1000000\n+#  define PNG_FILTER_OPTIMIZATIONS png_init_filter_functions_rvv\n+#  ifndef PNG_RISCV_RVV_IMPLEMENTATION\n+      \/* Use the intrinsics code by default. *\/\n+#     define PNG_RISCV_RVV_IMPLEMENTATION 1\n+#  endif\n+#else\n+#  define PNG_RISCV_RVV_IMPLEMENTATION 0\n+#endif \/* PNG_RISCV_RVV_OPT > 0 && __riscv_v >= 1000000 *\/\n@@ -545,12 +581,2 @@\n-#  if (defined(__MWERKS__) && defined(macintosh)) || defined(applec) || \\\n-    defined(THINK_C) || defined(__SC__) || defined(TARGET_OS_MAC)\n-   \/* We need to check that <math.h> hasn't already been included earlier\n-    * as it seems it doesn't agree with <fp.h>, yet we should really use\n-    * <fp.h> if possible.\n-    *\/\n-#    if !defined(__MATH_H__) && !defined(__MATH_H) && !defined(__cmath__)\n-#      include <fp.h>\n-#    endif\n-#  else\n-#    include <math.h>\n-#  endif\n+#  include <math.h>\n+\n@@ -657,1 +683,1 @@\n-                   \/*             0x4000U (unused) *\/\n+#define PNG_WROTE_eXIf            0x4000U\n@@ -710,1 +736,1 @@\n-#define PNG_FLAG_ASSUME_sRGB              0x1000U \/* Added to libpng-1.5.4 *\/\n+\/*      PNG_FLAG_ASSUME_sRGB unused       0x1000U  * Added to libpng-1.5.4 *\/\n@@ -716,1 +742,1 @@\n-#define PNG_FLAG_STRIP_ERROR_NUMBERS     0x40000U\n+                                  \/*     0x40000U    unused *\/\n@@ -821,0 +847,2 @@\n+#define png_fixed_ITU(png_ptr, fp, s) ((fp) <= 214748 && (fp) >= 0 ?\\\n+    ((png_uint_32)(10000 * (fp))) : (png_fixed_error(png_ptr, s),0))\n@@ -839,0 +867,4 @@\n+ *\n+ * 1.6.47: PNG_32b was made into a preprocessor evaluable macro by replacing the\n+ * static_cast with a promoting binary operation using a guaranteed 32-bit\n+ * (minimum) unsigned value.\n@@ -840,1 +872,1 @@\n-#define PNG_32b(b,s) ((png_uint_32)(b) << (s))\n+#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))\n@@ -844,0 +876,16 @@\n+\/* Chunk name validation.  When using these macros all the arguments should be\n+ * constants, otherwise code bloat may well occur.  The macros are provided\n+ * primarily for use in #if checks.\n+ *\n+ * PNG_32to8 produces a byte value with the right shift; used to extract the\n+ * byte value from a chunk name.\n+ *\/\n+#define PNG_32to8(cn,s) (((cn) >> (s)) & 0xffU)\n+#define PNG_CN_VALID_UPPER(b) ((b) >= 65 && (b) <= 90) \/* upper-case ASCII *\/\n+#define PNG_CN_VALID_ASCII(b) PNG_CN_VALID_UPPER((b) & ~32U)\n+#define PNG_CHUNK_NAME_VALID(cn) (\\\n+   PNG_CN_VALID_ASCII(PNG_32to8(cn,24)) && \/* critical, !ancillary *\/\\\n+   PNG_CN_VALID_ASCII(PNG_32to8(cn,16)) && \/* public, !privately defined *\/\\\n+   PNG_CN_VALID_UPPER(PNG_32to8(cn, 8)) && \/* VALID, !reserved *\/\\\n+   PNG_CN_VALID_ASCII(PNG_32to8(cn, 0))   \/* data-dependent, !copy ok *\/)\n+\n@@ -871,0 +919,1 @@\n+#define png_acTL PNG_U32( 97,  99,  84,  76) \/* PNGv3: APNG *\/\n@@ -873,0 +922,2 @@\n+#define png_cICP PNG_U32( 99,  73,  67,  80) \/* PNGv3 *\/\n+#define png_cLLI PNG_U32( 99,  76,  76,  73) \/* PNGv3 *\/\n@@ -874,0 +925,2 @@\n+#define png_fcTL PNG_U32(102,  99,  84,  76) \/* PNGv3: APNG *\/\n+#define png_fdAT PNG_U32(102, 100,  65,  84) \/* PNGv3: APNG *\/\n@@ -882,0 +935,1 @@\n+#define png_mDCV PNG_U32(109,  68,  67,  86) \/* PNGv3 *\/\n@@ -922,0 +976,50 @@\n+\/* Known chunks.  All supported chunks must be listed here.  The macro PNG_CHUNK\n+ * contains the four character ASCII name by which the chunk is identified.  The\n+ * macro is implemented as required to build tables or switch statements which\n+ * require entries for every known chunk.  The macro also contains an index\n+ * value which should be in order (this is checked in png.c).\n+ *\n+ * Notice that \"known\" does not require \"SUPPORTED\"; tables should be built in\n+ * such a way that chunks unsupported in a build require no more than the table\n+ * entry (which should be small.)  In particular function pointers for\n+ * unsupported chunks should be NULL.\n+ *\n+ * At present these index values are not exported (not part of the public API)\n+ * so can be changed at will.  For convenience the names are in lexical sort\n+ * order but with the critical chunks at the start in the order of occurence in\n+ * a PNG.\n+ *\n+ * PNG_INFO_ values do not exist for every one of these chunk handles; for\n+ * example PNG_INFO_{IDAT,IEND,tEXt,iTXt,zTXt} and possibly other chunks in the\n+ * future.\n+ *\/\n+#define PNG_KNOWN_CHUNKS\\\n+   PNG_CHUNK(IHDR,  0)\\\n+   PNG_CHUNK(PLTE,  1)\\\n+   PNG_CHUNK(IDAT,  2)\\\n+   PNG_CHUNK(IEND,  3)\\\n+   PNG_CHUNK(acTL,  4)\\\n+   PNG_CHUNK(bKGD,  5)\\\n+   PNG_CHUNK(cHRM,  6)\\\n+   PNG_CHUNK(cICP,  7)\\\n+   PNG_CHUNK(cLLI,  8)\\\n+   PNG_CHUNK(eXIf,  9)\\\n+   PNG_CHUNK(fcTL, 10)\\\n+   PNG_CHUNK(fdAT, 11)\\\n+   PNG_CHUNK(gAMA, 12)\\\n+   PNG_CHUNK(hIST, 13)\\\n+   PNG_CHUNK(iCCP, 14)\\\n+   PNG_CHUNK(iTXt, 15)\\\n+   PNG_CHUNK(mDCV, 16)\\\n+   PNG_CHUNK(oFFs, 17)\\\n+   PNG_CHUNK(pCAL, 18)\\\n+   PNG_CHUNK(pHYs, 19)\\\n+   PNG_CHUNK(sBIT, 20)\\\n+   PNG_CHUNK(sCAL, 21)\\\n+   PNG_CHUNK(sPLT, 22)\\\n+   PNG_CHUNK(sRGB, 23)\\\n+   PNG_CHUNK(tEXt, 24)\\\n+   PNG_CHUNK(tIME, 25)\\\n+   PNG_CHUNK(tRNS, 26)\\\n+   PNG_CHUNK(zTXt, 27)\n+\n@@ -927,0 +1031,13 @@\n+\/* gamma sanity check.  libpng cannot implement gamma transforms outside a\n+ * certain limit because of its use of 16-bit fixed point intermediate values.\n+ * Gamma values that are too large or too small will zap the 16-bit values all\n+ * to 0 or 65535 resulting in an obvious 'bad' image.\n+ *\n+ * In libpng 1.6.0 the limits were changed from 0.07..3 to 0.01..100 to\n+ * accommodate the optimal 16-bit gamma of 36 and its reciprocal.\n+ *\n+ * These are png_fixed_point integral values:\n+ *\/\n+#define PNG_LIB_GAMMA_MIN 1000\n+#define PNG_LIB_GAMMA_MAX 10000000\n+\n@@ -939,7 +1056,5 @@\n-#  error ZLIB_VERNUM != PNG_ZLIB_VERNUM \\\n-      \"-I (include path) error: see the notes in pngpriv.h\"\n-   \/* This means that when pnglibconf.h was built the copy of zlib.h that it\n-    * used is not the same as the one being used here.  Because the build of\n-    * libpng makes decisions to use inflateInit2 and inflateReset2 based on the\n-    * zlib version number and because this affects handling of certain broken\n-    * PNG files the -I directives must match.\n+#  error The include path of <zlib.h> is incorrect\n+   \/* When pnglibconf.h was built, the copy of zlib.h that it used was not the\n+    * same as the one being used here.  Considering how libpng makes decisions\n+    * to use the zlib API based on the zlib version number, the -I options must\n+    * match.\n@@ -947,3 +1062,3 @@\n-    * The most likely explanation is that you passed a -I in CFLAGS. This will\n-    * not work; all the preprocessor directives and in particular all the -I\n-    * directives must be in CPPFLAGS.\n+    * A possible cause of this mismatch is that you passed an -I option in\n+    * CFLAGS, which is unlikely to work.  All the preprocessor options, and all\n+    * the -I options in particular, should be in CPPFLAGS.\n@@ -990,1 +1105,0 @@\n-\n@@ -1009,0 +1123,1 @@\n+   defined(PNG_mDCV_SUPPORTED) || \\\n@@ -1016,0 +1131,7 @@\n+#if defined(PNG_FLOATING_POINT_SUPPORTED) && \\\n+   !defined(PNG_FIXED_POINT_MACRO_SUPPORTED) && \\\n+   (defined(PNG_cLLI_SUPPORTED) || defined(PNG_mDCV_SUPPORTED))\n+PNG_INTERNAL_FUNCTION(png_uint_32,png_fixed_ITU,(png_const_structrp png_ptr,\n+   double fp, png_const_charp text),PNG_EMPTY);\n+#endif\n+\n@@ -1022,0 +1144,19 @@\n+#ifdef PNG_READ_SUPPORTED \/* should only be used on read *\/\n+\/* Security: read limits on the largest allocations while reading a PNG.  This\n+ * avoids very large allocations caused by PNG files with damaged or altered\n+ * chunk 'length' fields.\n+ *\/\n+#ifdef PNG_SET_USER_LIMITS_SUPPORTED \/* run-time limit *\/\n+#  define png_chunk_max(png_ptr) ((png_ptr)->user_chunk_malloc_max)\n+\n+#elif PNG_USER_CHUNK_MALLOC_MAX > 0 \/* compile-time limit *\/\n+#  define png_chunk_max(png_ptr) ((void)png_ptr, PNG_USER_CHUNK_MALLOC_MAX)\n+\n+#elif (defined PNG_MAX_MALLOC_64K)  \/* legacy system limit *\/\n+#  define png_chunk_max(png_ptr) ((void)png_ptr, 65536U)\n+\n+#else                               \/* modern system limit SIZE_MAX (C99) *\/\n+#  define png_chunk_max(png_ptr) ((void)png_ptr, PNG_SIZE_MAX)\n+#endif\n+#endif \/* READ *\/\n+\n@@ -1121,3 +1262,0 @@\n-\/* Read the CRC from the file and compare it to the libpng calculated CRC *\/\n-PNG_INTERNAL_FUNCTION(int,png_crc_error,(png_structrp png_ptr),PNG_EMPTY);\n-\n@@ -1169,0 +1307,20 @@\n+#ifdef PNG_WRITE_cICP_SUPPORTED\n+PNG_INTERNAL_FUNCTION(void,png_write_cICP,(png_structrp png_ptr,\n+    png_byte colour_primaries, png_byte transfer_function,\n+    png_byte matrix_coefficients, png_byte video_full_range_flag), PNG_EMPTY);\n+#endif\n+\n+#ifdef PNG_WRITE_cLLI_SUPPORTED\n+PNG_INTERNAL_FUNCTION(void,png_write_cLLI_fixed,(png_structrp png_ptr,\n+   png_uint_32 maxCLL, png_uint_32 maxFALL), PNG_EMPTY);\n+#endif\n+\n+#ifdef PNG_WRITE_mDCV_SUPPORTED\n+PNG_INTERNAL_FUNCTION(void,png_write_mDCV_fixed,(png_structrp png_ptr,\n+   png_uint_16 red_x, png_uint_16 red_y,\n+   png_uint_16 green_x, png_uint_16 green_y,\n+   png_uint_16 blue_x, png_uint_16 blue_y,\n+   png_uint_16 white_x, png_uint_16 white_y,\n+   png_uint_32 maxDL, png_uint_32 minDL), PNG_EMPTY);\n+#endif\n+\n@@ -1181,4 +1339,4 @@\n-   png_const_charp name, png_const_bytep profile), PNG_EMPTY);\n-   \/* The profile must have been previously validated for correctness, the\n-    * length comes from the first four bytes.  Only the base, deflate,\n-    * compression is supported.\n+   png_const_charp name, png_const_bytep profile, png_uint_32 proflen),\n+   PNG_EMPTY);\n+   \/* Writes a previously 'set' profile.  The profile argument is **not**\n+    * compressed.\n@@ -1337,1 +1495,1 @@\n-#if PNG_MIPS_MSA_OPT > 0\n+#if PNG_MIPS_MSA_IMPLEMENTATION == 1\n@@ -1354,0 +1512,17 @@\n+#if PNG_MIPS_MMI_IMPLEMENTATION > 0\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_up_mmi,(png_row_infop row_info,\n+    png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_sub3_mmi,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_sub4_mmi,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_avg3_mmi,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_avg4_mmi,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_paeth3_mmi,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_paeth4_mmi,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+#endif\n+\n@@ -1386,0 +1561,34 @@\n+#if PNG_LOONGARCH_LSX_IMPLEMENTATION == 1\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_up_lsx,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_sub3_lsx,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_sub4_lsx,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_avg3_lsx,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_avg4_lsx,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_paeth3_lsx,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_paeth4_lsx,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+#endif\n+\n+#if PNG_RISCV_RVV_IMPLEMENTATION == 1\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_up_rvv,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_sub3_rvv,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_sub4_rvv,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_avg3_rvv,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_avg4_rvv,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_paeth3_rvv,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_paeth4_rvv,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+#endif\n+\n@@ -1459,107 +1668,18 @@\n-\n-\/* Decode the IHDR chunk *\/\n-PNG_INTERNAL_FUNCTION(void,png_handle_IHDR,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-PNG_INTERNAL_FUNCTION(void,png_handle_PLTE,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-PNG_INTERNAL_FUNCTION(void,png_handle_IEND,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-\n-#ifdef PNG_READ_bKGD_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_bKGD,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_cHRM_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_cHRM,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_eXIf_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_eXIf,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_gAMA_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_gAMA,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_hIST_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_hIST,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_iCCP_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_iCCP,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif \/* READ_iCCP *\/\n-\n-#ifdef PNG_READ_iTXt_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_iTXt,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_oFFs_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_oFFs,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_pCAL_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_pCAL,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_pHYs_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_pHYs,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_sBIT_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_sBIT,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_sCAL_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_sCAL,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_sPLT_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_sPLT,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif \/* READ_sPLT *\/\n-\n-#ifdef PNG_READ_sRGB_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_sRGB,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_tEXt_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_tEXt,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_tIME_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_tIME,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_tRNS_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_tRNS,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_zTXt_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_zTXt,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-PNG_INTERNAL_FUNCTION(void,png_check_chunk_name,(png_const_structrp png_ptr,\n-    png_uint_32 chunk_name),PNG_EMPTY);\n-\n-PNG_INTERNAL_FUNCTION(void,png_check_chunk_length,(png_const_structrp png_ptr,\n-    png_uint_32 chunk_length),PNG_EMPTY);\n-\n-PNG_INTERNAL_FUNCTION(void,png_handle_unknown,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length, int keep),PNG_EMPTY);\n+typedef enum\n+{\n+   \/* Result of a call to png_handle_chunk made to handle the current chunk\n+    * png_struct::chunk_name on read.  Always informational, either the stream\n+    * is read for the next chunk or the routine will call png_error.\n+    *\n+    * NOTE: order is important internally.  handled_saved and above are regarded\n+    * as handling the chunk.\n+    *\/\n+   handled_error = 0,  \/* bad crc or known and bad format or too long *\/\n+   handled_discarded,  \/* not saved in the unknown chunk list *\/\n+   handled_saved,      \/* saved in the unknown chunk list *\/\n+   handled_ok          \/* known, supported and handled without error *\/\n+} png_handle_result_code;\n+\n+PNG_INTERNAL_FUNCTION(png_handle_result_code,png_handle_unknown,\n+    (png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length, int keep),\n+    PNG_EMPTY);\n@@ -1572,0 +1692,6 @@\n+PNG_INTERNAL_FUNCTION(png_handle_result_code,png_handle_chunk,\n+    (png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n+   \/* This handles the current chunk png_ptr->chunk_name with unread\n+    * data[length] and returns one of the above result codes.\n+    *\/\n+\n@@ -1611,2 +1737,0 @@\n-PNG_INTERNAL_FUNCTION(void,png_push_handle_unknown,(png_structrp png_ptr,\n-   png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n@@ -1625,19 +1749,0 @@\n-#  ifdef PNG_READ_tEXt_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_push_handle_tEXt,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-PNG_INTERNAL_FUNCTION(void,png_push_read_tEXt,(png_structrp png_ptr,\n-    png_inforp info_ptr),PNG_EMPTY);\n-#  endif\n-#  ifdef PNG_READ_zTXt_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_push_handle_zTXt,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-PNG_INTERNAL_FUNCTION(void,png_push_read_zTXt,(png_structrp png_ptr,\n-    png_inforp info_ptr),PNG_EMPTY);\n-#  endif\n-#  ifdef PNG_READ_iTXt_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_push_handle_iTXt,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-PNG_INTERNAL_FUNCTION(void,png_push_read_iTXt,(png_structrp png_ptr,\n-    png_inforp info_ptr),PNG_EMPTY);\n-#  endif\n-\n@@ -1646,43 +1751,0 @@\n-\/* Added at libpng version 1.6.0 *\/\n-#ifdef PNG_GAMMA_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_colorspace_set_gamma,(png_const_structrp png_ptr,\n-    png_colorspacerp colorspace, png_fixed_point gAMA), PNG_EMPTY);\n-   \/* Set the colorspace gamma with a value provided by the application or by\n-    * the gAMA chunk on read.  The value will override anything set by an ICC\n-    * profile.\n-    *\/\n-\n-PNG_INTERNAL_FUNCTION(void,png_colorspace_sync_info,(png_const_structrp png_ptr,\n-    png_inforp info_ptr), PNG_EMPTY);\n-   \/* Synchronize the info 'valid' flags with the colorspace *\/\n-\n-PNG_INTERNAL_FUNCTION(void,png_colorspace_sync,(png_const_structrp png_ptr,\n-    png_inforp info_ptr), PNG_EMPTY);\n-   \/* Copy the png_struct colorspace to the info_struct and call the above to\n-    * synchronize the flags.  Checks for NULL info_ptr and does nothing.\n-    *\/\n-#endif\n-\n-\/* Added at libpng version 1.4.0 *\/\n-#ifdef PNG_COLORSPACE_SUPPORTED\n-\/* These internal functions are for maintaining the colorspace structure within\n- * a png_info or png_struct (or, indeed, both).\n- *\/\n-PNG_INTERNAL_FUNCTION(int,png_colorspace_set_chromaticities,\n-   (png_const_structrp png_ptr, png_colorspacerp colorspace, const png_xy *xy,\n-    int preferred), PNG_EMPTY);\n-\n-PNG_INTERNAL_FUNCTION(int,png_colorspace_set_endpoints,\n-   (png_const_structrp png_ptr, png_colorspacerp colorspace, const png_XYZ *XYZ,\n-    int preferred), PNG_EMPTY);\n-\n-#ifdef PNG_sRGB_SUPPORTED\n-PNG_INTERNAL_FUNCTION(int,png_colorspace_set_sRGB,(png_const_structrp png_ptr,\n-   png_colorspacerp colorspace, int intent), PNG_EMPTY);\n-   \/* This does set the colorspace gAMA and cHRM values too, but doesn't set the\n-    * flags to write them, if it returns false there was a problem and an error\n-    * message has already been output (but the colorspace may still need to be\n-    * synced to record the invalid flag).\n-    *\/\n-#endif \/* sRGB *\/\n-\n@@ -1690,6 +1752,0 @@\n-PNG_INTERNAL_FUNCTION(int,png_colorspace_set_ICC,(png_const_structrp png_ptr,\n-   png_colorspacerp colorspace, png_const_charp name,\n-   png_uint_32 profile_length, png_const_bytep profile, int color_type),\n-   PNG_EMPTY);\n-   \/* The 'name' is used for information only *\/\n-\n@@ -1699,2 +1755,1 @@\n-   png_colorspacerp colorspace, png_const_charp name,\n-   png_uint_32 profile_length), PNG_EMPTY);\n+   png_const_charp name, png_uint_32 profile_length), PNG_EMPTY);\n@@ -1703,2 +1758,1 @@\n-   png_colorspacerp colorspace, png_const_charp name,\n-   png_uint_32 profile_length,\n+   png_const_charp name, png_uint_32 profile_length,\n@@ -1708,2 +1762,1 @@\n-   png_colorspacerp colorspace, png_const_charp name,\n-   png_uint_32 profile_length,\n+   png_const_charp name, png_uint_32 profile_length,\n@@ -1711,9 +1764,0 @@\n-#ifdef PNG_sRGB_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_icc_set_sRGB,(\n-   png_const_structrp png_ptr, png_colorspacerp colorspace,\n-   png_const_bytep profile, uLong adler), PNG_EMPTY);\n-   \/* 'adler' is the Adler32 checksum of the uncompressed profile data. It may\n-    * be zero to indicate that it is not available.  It is used, if provided,\n-    * as a fast check on the profile when checking to see if it is sRGB.\n-    *\/\n-#endif\n@@ -1723,3 +1767,3 @@\n-PNG_INTERNAL_FUNCTION(void,png_colorspace_set_rgb_coefficients,\n-   (png_structrp png_ptr), PNG_EMPTY);\n-   \/* Set the rgb_to_gray coefficients from the colorspace Y values *\/\n+PNG_INTERNAL_FUNCTION(void,png_set_rgb_coefficients, (png_structrp png_ptr),\n+   PNG_EMPTY);\n+   \/* Set the rgb_to_gray coefficients from the cHRM Y values (if unset) *\/\n@@ -1727,1 +1771,0 @@\n-#endif \/* COLORSPACE *\/\n@@ -1941,1 +1984,1 @@\n-\/* Result codes for the parser (boolean - true meants ok, false means\n+\/* Result codes for the parser (boolean - true means ok, false means\n@@ -1989,2 +2032,4 @@\n-#if defined(PNG_GAMMA_SUPPORTED) ||\\\n-    defined(PNG_INCH_CONVERSIONS_SUPPORTED) || defined(PNG_READ_pHYs_SUPPORTED)\n+#if defined(PNG_READ_GAMMA_SUPPORTED) ||\\\n+    defined(PNG_COLORSPACE_SUPPORTED) ||\\\n+    defined(PNG_INCH_CONVERSIONS_SUPPORTED) ||\\\n+    defined(PNG_READ_pHYs_SUPPORTED)\n@@ -1999,8 +2044,0 @@\n-#endif\n-\n-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_INCH_CONVERSIONS_SUPPORTED)\n-\/* Same deal, but issue a warning on overflow and return 0. *\/\n-PNG_INTERNAL_FUNCTION(png_fixed_point,png_muldiv_warn,\n-   (png_const_structrp png_ptr, png_fixed_point a, png_int_32 multiplied_by,\n-   png_int_32 divided_by),PNG_EMPTY);\n-#endif\n@@ -2008,1 +2045,0 @@\n-#ifdef PNG_GAMMA_SUPPORTED\n@@ -2015,0 +2051,1 @@\n+#endif\n@@ -2023,1 +2060,0 @@\n-#endif\n@@ -2028,1 +2064,0 @@\n-#endif\n@@ -2030,1 +2065,11 @@\n-#ifdef PNG_READ_GAMMA_SUPPORTED\n+\/* PNGv3: 'resolve' the file gamma according to the new PNGv3 rules for colour\n+ * space information.\n+ *\n+ * NOTE: this uses precisely those chunks that libpng supports.  For example it\n+ * doesn't use iCCP and it can only use cICP for known and manageable\n+ * transforms.  For this reason a gamma specified by png_set_gamma always takes\n+ * precedence.\n+ *\/\n+PNG_INTERNAL_FUNCTION(png_fixed_point,png_resolve_file_gamma,\n+   (png_const_structrp png_ptr),PNG_EMPTY);\n+\n@@ -2048,0 +2093,16 @@\n+#endif \/* READ_GAMMA *\/\n+\n+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n+\/* Set the RGB coefficients if not already set by png_set_rgb_to_gray *\/\n+PNG_INTERNAL_FUNCTION(void,png_set_rgb_coefficients,(png_structrp png_ptr),\n+   PNG_EMPTY);\n+#endif\n+\n+#if defined(PNG_cHRM_SUPPORTED) || defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)\n+PNG_INTERNAL_FUNCTION(int,png_XYZ_from_xy,(png_XYZ *XYZ, const png_xy *xy),\n+   PNG_EMPTY);\n+#endif \/* cHRM || READ_RGB_TO_GRAY *\/\n+\n+#ifdef PNG_COLORSPACE_SUPPORTED\n+PNG_INTERNAL_FUNCTION(int,png_xy_from_XYZ,(png_xy *xy, const png_XYZ *XYZ),\n+   PNG_EMPTY);\n@@ -2125,2 +2186,2 @@\n-#if PNG_MIPS_MSA_OPT > 0\n-PNG_INTERNAL_FUNCTION(void, png_init_filter_functions_msa,\n+#if PNG_MIPS_MSA_IMPLEMENTATION == 1\n+PNG_INTERNAL_FUNCTION(void, png_init_filter_functions_mips,\n@@ -2130,0 +2191,5 @@\n+#  if PNG_MIPS_MMI_IMPLEMENTATION > 0\n+PNG_INTERNAL_FUNCTION(void, png_init_filter_functions_mips,\n+   (png_structp png_ptr, unsigned int bpp), PNG_EMPTY);\n+#  endif\n+\n@@ -2136,0 +2202,10 @@\n+#if PNG_LOONGARCH_LSX_OPT > 0\n+PNG_INTERNAL_FUNCTION(void, png_init_filter_functions_lsx,\n+    (png_structp png_ptr, unsigned int bpp), PNG_EMPTY);\n+#endif\n+\n+#  if PNG_RISCV_RVV_IMPLEMENTATION == 1\n+PNG_INTERNAL_FUNCTION(void, png_init_filter_functions_rvv,\n+   (png_structp png_ptr, unsigned int bpp), PNG_EMPTY);\n+#endif\n+\n@@ -2171,1 +2247,0 @@\n-#endif \/* PNGPRIV_H *\/\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/pngpriv.h","additions":375,"deletions":300,"binary":false,"changes":675,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2019 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -163,3 +163,0 @@\n-      \/* This should be a binary subdivision search or a hash for\n-       * matching the chunk name rather than a linear search.\n-       *\/\n@@ -167,1 +164,1 @@\n-         png_handle_IHDR(png_ptr, info_ptr, length);\n+         png_handle_chunk(png_ptr, info_ptr, length);\n@@ -170,1 +167,1 @@\n-         png_handle_IEND(png_ptr, info_ptr, length);\n+         png_handle_chunk(png_ptr, info_ptr, length);\n@@ -187,2 +184,0 @@\n-      else if (chunk_name == png_PLTE)\n-         png_handle_PLTE(png_ptr, info_ptr, length);\n@@ -196,90 +191,0 @@\n-#ifdef PNG_READ_bKGD_SUPPORTED\n-      else if (chunk_name == png_bKGD)\n-         png_handle_bKGD(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_cHRM_SUPPORTED\n-      else if (chunk_name == png_cHRM)\n-         png_handle_cHRM(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_eXIf_SUPPORTED\n-      else if (chunk_name == png_eXIf)\n-         png_handle_eXIf(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_gAMA_SUPPORTED\n-      else if (chunk_name == png_gAMA)\n-         png_handle_gAMA(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_hIST_SUPPORTED\n-      else if (chunk_name == png_hIST)\n-         png_handle_hIST(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_oFFs_SUPPORTED\n-      else if (chunk_name == png_oFFs)\n-         png_handle_oFFs(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_pCAL_SUPPORTED\n-      else if (chunk_name == png_pCAL)\n-         png_handle_pCAL(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_sCAL_SUPPORTED\n-      else if (chunk_name == png_sCAL)\n-         png_handle_sCAL(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_pHYs_SUPPORTED\n-      else if (chunk_name == png_pHYs)\n-         png_handle_pHYs(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_sBIT_SUPPORTED\n-      else if (chunk_name == png_sBIT)\n-         png_handle_sBIT(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_sRGB_SUPPORTED\n-      else if (chunk_name == png_sRGB)\n-         png_handle_sRGB(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_iCCP_SUPPORTED\n-      else if (chunk_name == png_iCCP)\n-         png_handle_iCCP(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_sPLT_SUPPORTED\n-      else if (chunk_name == png_sPLT)\n-         png_handle_sPLT(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_tEXt_SUPPORTED\n-      else if (chunk_name == png_tEXt)\n-         png_handle_tEXt(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_tIME_SUPPORTED\n-      else if (chunk_name == png_tIME)\n-         png_handle_tIME(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_tRNS_SUPPORTED\n-      else if (chunk_name == png_tRNS)\n-         png_handle_tRNS(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_zTXt_SUPPORTED\n-      else if (chunk_name == png_zTXt)\n-         png_handle_zTXt(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_iTXt_SUPPORTED\n-      else if (chunk_name == png_iTXt)\n-         png_handle_iTXt(png_ptr, info_ptr, length);\n-#endif\n-\n@@ -287,2 +192,1 @@\n-         png_handle_unknown(png_ptr, info_ptr, length,\n-             PNG_HANDLE_CHUNK_AS_DEFAULT);\n+         png_handle_chunk(png_ptr, info_ptr, length);\n@@ -599,1 +503,5 @@\n-   if (png_ptr->transformations)\n+   if (png_ptr->transformations\n+#     ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED\n+         || png_ptr->num_palette_max >= 0\n+#     endif\n+      )\n@@ -816,1 +724,1 @@\n-       png_ptr->num_palette_max > png_ptr->num_palette)\n+       png_ptr->num_palette_max >= png_ptr->num_palette)\n@@ -826,1 +734,6 @@\n-         png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;\n+      {\n+         \/* These flags must be set consistently for all non-IDAT chunks,\n+          * including the unknown chunks.\n+          *\/\n+         png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT | PNG_AFTER_IDAT;\n+      }\n@@ -829,1 +742,1 @@\n-         png_handle_IEND(png_ptr, info_ptr, length);\n+         png_handle_chunk(png_ptr, info_ptr, length);\n@@ -832,1 +745,1 @@\n-         png_handle_IHDR(png_ptr, info_ptr, length);\n+         png_handle_chunk(png_ptr, info_ptr, length);\n@@ -866,92 +779,0 @@\n-      else if (chunk_name == png_PLTE)\n-         png_handle_PLTE(png_ptr, info_ptr, length);\n-\n-#ifdef PNG_READ_bKGD_SUPPORTED\n-      else if (chunk_name == png_bKGD)\n-         png_handle_bKGD(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_cHRM_SUPPORTED\n-      else if (chunk_name == png_cHRM)\n-         png_handle_cHRM(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_eXIf_SUPPORTED\n-      else if (chunk_name == png_eXIf)\n-         png_handle_eXIf(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_gAMA_SUPPORTED\n-      else if (chunk_name == png_gAMA)\n-         png_handle_gAMA(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_hIST_SUPPORTED\n-      else if (chunk_name == png_hIST)\n-         png_handle_hIST(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_oFFs_SUPPORTED\n-      else if (chunk_name == png_oFFs)\n-         png_handle_oFFs(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_pCAL_SUPPORTED\n-      else if (chunk_name == png_pCAL)\n-         png_handle_pCAL(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_sCAL_SUPPORTED\n-      else if (chunk_name == png_sCAL)\n-         png_handle_sCAL(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_pHYs_SUPPORTED\n-      else if (chunk_name == png_pHYs)\n-         png_handle_pHYs(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_sBIT_SUPPORTED\n-      else if (chunk_name == png_sBIT)\n-         png_handle_sBIT(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_sRGB_SUPPORTED\n-      else if (chunk_name == png_sRGB)\n-         png_handle_sRGB(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_iCCP_SUPPORTED\n-      else if (chunk_name == png_iCCP)\n-         png_handle_iCCP(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_sPLT_SUPPORTED\n-      else if (chunk_name == png_sPLT)\n-         png_handle_sPLT(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_tEXt_SUPPORTED\n-      else if (chunk_name == png_tEXt)\n-         png_handle_tEXt(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_tIME_SUPPORTED\n-      else if (chunk_name == png_tIME)\n-         png_handle_tIME(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_tRNS_SUPPORTED\n-      else if (chunk_name == png_tRNS)\n-         png_handle_tRNS(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_zTXt_SUPPORTED\n-      else if (chunk_name == png_zTXt)\n-         png_handle_zTXt(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_iTXt_SUPPORTED\n-      else if (chunk_name == png_iTXt)\n-         png_handle_iTXt(png_ptr, info_ptr, length);\n-#endif\n@@ -960,2 +781,1 @@\n-         png_handle_unknown(png_ptr, info_ptr, length,\n-             PNG_HANDLE_CHUNK_AS_DEFAULT);\n+         png_handle_chunk(png_ptr, info_ptr, length);\n@@ -1026,1 +846,2 @@\n-    defined(PNG_ARM_NEON_IMPLEMENTATION)\n+    (defined(PNG_ARM_NEON_IMPLEMENTATION) || \\\n+     defined(PNG_RISCV_RVV_IMPLEMENTATION))\n@@ -1080,0 +901,2 @@\n+   png_debug(1, \"in png_read_png\");\n+\n@@ -1410,0 +1233,25 @@\n+static int\n+chromaticities_match_sRGB(const png_xy *xy)\n+{\n+#  define sRGB_TOLERANCE 1000\n+   static const png_xy sRGB_xy = \/* From ITU-R BT.709-3 *\/\n+   {\n+      \/* color      x       y *\/\n+      \/* red   *\/ 64000, 33000,\n+      \/* green *\/ 30000, 60000,\n+      \/* blue  *\/ 15000,  6000,\n+      \/* white *\/ 31270, 32900\n+   };\n+\n+   if (PNG_OUT_OF_RANGE(xy->whitex, sRGB_xy.whitex,sRGB_TOLERANCE) ||\n+       PNG_OUT_OF_RANGE(xy->whitey, sRGB_xy.whitey,sRGB_TOLERANCE) ||\n+       PNG_OUT_OF_RANGE(xy->redx,   sRGB_xy.redx,  sRGB_TOLERANCE) ||\n+       PNG_OUT_OF_RANGE(xy->redy,   sRGB_xy.redy,  sRGB_TOLERANCE) ||\n+       PNG_OUT_OF_RANGE(xy->greenx, sRGB_xy.greenx,sRGB_TOLERANCE) ||\n+       PNG_OUT_OF_RANGE(xy->greeny, sRGB_xy.greeny,sRGB_TOLERANCE) ||\n+       PNG_OUT_OF_RANGE(xy->bluex,  sRGB_xy.bluex, sRGB_TOLERANCE) ||\n+       PNG_OUT_OF_RANGE(xy->bluey,  sRGB_xy.bluey, sRGB_TOLERANCE))\n+      return 0;\n+   return 1;\n+}\n+\n@@ -1418,8 +1266,3 @@\n-   if (g < PNG_FP_1)\n-   {\n-      \/* An uninitialized gamma is assumed to be sRGB for the simplified API. *\/\n-      if (g == 0)\n-         return 0;\n-\n-      return png_gamma_significant((g * 11 + 2)\/5 \/* i.e. *2.2, rounded *\/);\n-   }\n+   \/* 1.6.47: use the same sanity checks as used in pngrtran.c *\/\n+   if (g < PNG_LIB_GAMMA_MIN || g > PNG_LIB_GAMMA_MAX)\n+      return 0; \/* Includes the uninitialized value 0 *\/\n@@ -1427,1 +1270,1 @@\n-   return 1;\n+   return png_gamma_significant((g * 11 + 2)\/5 \/* i.e. *2.2, rounded *\/);\n@@ -1434,0 +1277,27 @@\n+static int\n+png_image_is_not_sRGB(png_const_structrp png_ptr)\n+{\n+   \/* Does the colorspace **not** match sRGB?  The flag is only set if the\n+    * answer can be determined reliably.\n+    *\n+    * png_struct::chromaticities always exists since the simplified API\n+    * requires rgb-to-gray.  The mDCV, cICP and cHRM chunks may all set it to\n+    * a non-sRGB value, so it needs to be checked but **only** if one of\n+    * those chunks occured in the file.\n+    *\/\n+   \/* Highest priority: check to be safe. *\/\n+   if (png_has_chunk(png_ptr, cICP) || png_has_chunk(png_ptr, mDCV))\n+      return !chromaticities_match_sRGB(&png_ptr->chromaticities);\n+\n+   \/* If the image is marked as sRGB then it is... *\/\n+   if (png_has_chunk(png_ptr, sRGB))\n+      return 0;\n+\n+   \/* Last stop: cHRM, must check: *\/\n+   if (png_has_chunk(png_ptr, cHRM))\n+      return !chromaticities_match_sRGB(&png_ptr->chromaticities);\n+\n+   \/* Else default to sRGB *\/\n+   return 0;\n+}\n+\n@@ -1455,5 +1325,3 @@\n-#ifdef PNG_COLORSPACE_SUPPORTED\n-      \/* Does the colorspace match sRGB?  If there is no color endpoint\n-       * (colorant) information assume yes, otherwise require the\n-       * 'ENDPOINTS_MATCHP_sRGB' colorspace flag to have been set.  If the\n-       * colorspace has been determined to be invalid ignore it.\n+      \/* Greyscale images don't (typically) have colour space information and\n+       * using it is pretty much impossible, so use sRGB for grayscale (it\n+       * doesn't matter r==g==b so the transform is irrelevant.)\n@@ -1461,3 +1329,2 @@\n-      if ((format & PNG_FORMAT_FLAG_COLOR) != 0 && ((png_ptr->colorspace.flags\n-         & (PNG_COLORSPACE_HAVE_ENDPOINTS|PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB|\n-            PNG_COLORSPACE_INVALID)) == PNG_COLORSPACE_HAVE_ENDPOINTS))\n+      if ((format & PNG_FORMAT_FLAG_COLOR) != 0 &&\n+          png_image_is_not_sRGB(png_ptr))\n@@ -1465,1 +1332,0 @@\n-#endif\n@@ -1500,1 +1366,1 @@\n-png_image_begin_read_from_stdio(png_imagep image, FILE* file)\n+png_image_begin_read_from_stdio(png_imagep image, FILE *file)\n@@ -1653,3 +1519,1 @@\n-    * too.  This allows the simplified API to be compiled without iCCP support,\n-    * however if the support is there the chunk is still checked to detect\n-    * errors (which are unfortunately quite common.)\n+    * too.  This allows the simplified API to be compiled without iCCP support.\n@@ -1661,0 +1525,1 @@\n+            99,  73,  67,  80, '\\0',  \/* cICP *\/\n@@ -1662,3 +1527,1 @@\n-#        ifdef PNG_READ_iCCP_SUPPORTED\n-           105,  67,  67,  80, '\\0',  \/* iCCP *\/\n-#        endif\n+           109,  68,  67,  86, '\\0',  \/* mDCV *\/\n@@ -1667,1 +1530,1 @@\n-           };\n+         };\n@@ -1696,1 +1559,9 @@\n-   png_fixed_point g = display->image->opaque->png_ptr->colorspace.gamma;\n+   png_structrp png_ptr = display->image->opaque->png_ptr;\n+   png_fixed_point g = png_resolve_file_gamma(png_ptr);\n+\n+   \/* PNGv3: the result may be 0 however the 'default_gamma' should have been\n+    * set before this is called so zero is an error:\n+    *\/\n+   if (g == 0)\n+      png_error(png_ptr, \"internal: default gamma not set\");\n+\n@@ -2184,1 +2055,5 @@\n-    * format.\n+    * format.  The 'default' gamma value is also set by png_set_alpha_mode, but\n+    * this is happening before any such call, so:\n+    *\n+    * TODO: should be an internal API and all this code should be copied into a\n+    * single common gamma+colorspace file.\n@@ -2186,13 +2061,3 @@\n-   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_GAMMA) == 0)\n-   {\n-      \/* Do this directly, not using the png_colorspace functions, to ensure\n-       * that it happens even if the colorspace is invalid (though probably if\n-       * it is the setting will be ignored)  Note that the same thing can be\n-       * achieved at the application interface with png_set_gAMA.\n-       *\/\n-      if (png_ptr->bit_depth == 16 &&\n-         (image->flags & PNG_IMAGE_FLAG_16BIT_sRGB) == 0)\n-         png_ptr->colorspace.gamma = PNG_GAMMA_LINEAR;\n-\n-      else\n-         png_ptr->colorspace.gamma = PNG_GAMMA_sRGB_INVERSE;\n+   if (png_ptr->bit_depth == 16 &&\n+      (image->flags & PNG_IMAGE_FLAG_16BIT_sRGB) == 0)\n+      png_ptr->default_gamma = PNG_GAMMA_LINEAR;\n@@ -2200,2 +2065,2 @@\n-      png_ptr->colorspace.flags |= PNG_COLORSPACE_HAVE_GAMMA;\n-   }\n+   else\n+      png_ptr->default_gamma = PNG_GAMMA_sRGB_INVERSE;\n@@ -2579,0 +2444,2 @@\n+               const png_fixed_point gamma = png_resolve_file_gamma(png_ptr);\n+\n@@ -2593,0 +2460,3 @@\n+                *\n+                * NOTE: PNGv3: check the resolved result of all the potentially\n+                * different colour space chunks.\n@@ -2596,1 +2466,1 @@\n-                  png_gamma_not_sRGB(png_ptr->colorspace.gamma) != 0)\n+                  png_gamma_not_sRGB(gamma) != 0)\n@@ -2628,2 +2498,2 @@\n-                     gray = PNG_DIV257(png_gamma_16bit_correct(gray,\n-                         png_ptr->colorspace.gamma)); \/* now P_FILE *\/\n+                     gray = PNG_DIV257(png_gamma_16bit_correct(gray, gamma));\n+                        \/* now P_FILE *\/\n@@ -3291,0 +3161,48 @@\n+\/* Row reading for interlaced 16-to-8 bit depth conversion with local buffer. *\/\n+static int\n+png_image_read_direct_scaled(png_voidp argument)\n+{\n+   png_image_read_control *display = png_voidcast(png_image_read_control*,\n+       argument);\n+   png_imagep image = display->image;\n+   png_structrp png_ptr = image->opaque->png_ptr;\n+   png_bytep local_row = png_voidcast(png_bytep, display->local_row);\n+   png_bytep first_row = png_voidcast(png_bytep, display->first_row);\n+   ptrdiff_t row_bytes = display->row_bytes;\n+   int passes;\n+\n+   \/* Handle interlacing. *\/\n+   switch (png_ptr->interlaced)\n+   {\n+      case PNG_INTERLACE_NONE:\n+         passes = 1;\n+         break;\n+\n+      case PNG_INTERLACE_ADAM7:\n+         passes = PNG_INTERLACE_ADAM7_PASSES;\n+         break;\n+\n+      default:\n+         png_error(png_ptr, \"unknown interlace type\");\n+   }\n+\n+   \/* Read each pass using local_row as intermediate buffer. *\/\n+   while (--passes >= 0)\n+   {\n+      png_uint_32 y = image->height;\n+      png_bytep output_row = first_row;\n+\n+      for (; y > 0; --y)\n+      {\n+         \/* Read into local_row (gets transformed 8-bit data). *\/\n+         png_read_row(png_ptr, local_row, NULL);\n+\n+         \/* Copy from local_row to user buffer. *\/\n+         memcpy(output_row, local_row, (size_t)row_bytes);\n+         output_row += row_bytes;\n+      }\n+   }\n+\n+   return 1;\n+}\n+\n@@ -3709,0 +3627,1 @@\n+   int do_local_scale = 0; \/* for interlaced 16-to-8 bit conversion *\/\n@@ -3760,0 +3679,6 @@\n+         \/* This is safe but should no longer be necessary as\n+          * png_ptr->default_gamma should have been set after the\n+          * info-before-IDAT was read in png_image_read_header.\n+          *\n+          * TODO: 1.8: remove this and see what happens.\n+          *\/\n@@ -3815,2 +3740,3 @@\n-         if (png_muldiv(&gtest, output_gamma, png_ptr->colorspace.gamma,\n-             PNG_FP_1) != 0 && png_gamma_significant(gtest) == 0)\n+         if (png_muldiv(&gtest, output_gamma,\n+                  png_resolve_file_gamma(png_ptr), PNG_FP_1) != 0 &&\n+             png_gamma_significant(gtest) == 0)\n@@ -3835,0 +3761,1 @@\n+         {\n@@ -3837,0 +3764,7 @@\n+            \/* For interlaced images, use local_row buffer to avoid overflow\n+             * in png_combine_row() which writes using IHDR bit-depth.\n+             *\/\n+            if (png_ptr->interlaced != 0)\n+               do_local_scale = 1;\n+         }\n+\n@@ -4112,0 +4046,18 @@\n+   else if (do_local_scale != 0)\n+   {\n+      \/* For interlaced 16-to-8 conversion, use an intermediate row buffer\n+       * to avoid buffer overflows in png_combine_row. The local_row is sized\n+       * for the transformed (8-bit) output, preventing the overflow that would\n+       * occur if png_combine_row wrote 16-bit data directly to the user buffer.\n+       *\/\n+      int result;\n+      png_voidp row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr));\n+\n+      display->local_row = row;\n+      result = png_safe_execute(image, png_image_read_direct_scaled, display);\n+      display->local_row = NULL;\n+      png_free(png_ptr, row);\n+\n+      return result;\n+   }\n+\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/pngread.c","additions":200,"deletions":248,"binary":false,"changes":448,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -88,1 +88,1 @@\n-   check = fread(data, 1, length, png_voidcast(png_FILE_p, png_ptr->io_ptr));\n+   check = fread(data, 1, length, png_voidcast(FILE *, png_ptr->io_ptr));\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/pngrio.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2019 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -60,0 +60,6 @@\n+#ifdef PNG_RISCV_RVV_IMPLEMENTATION\n+#  if PNG_RISCV_RVV_IMPLEMENTATION == 1\n+#    define PNG_RISCV_RVV_INTRINSICS_AVAILABLE\n+#  endif\n+#endif\n+\n@@ -250,0 +256,51 @@\n+\/* PNGv3 conformance: this private API exists to resolve the now mandatory error\n+ * resolution when multiple conflicting sources of gamma or colour space\n+ * information are available.\n+ *\n+ * Terminology (assuming power law, \"gamma\", encodings):\n+ *    \"screen\" gamma: a power law imposed by the output device when digital\n+ *    samples are converted to visible light output.  The EOTF - volage to\n+ *    luminance on output.\n+ *\n+ *    \"file\" gamma: a power law used to encode luminance levels from the input\n+ *    data (the scene or the mastering display system) into digital voltages.\n+ *    The OETF - luminance to voltage on input.\n+ *\n+ *    gamma \"correction\": a power law matching the **inverse** of the overall\n+ *    transfer function from input luminance levels to output levels.  The\n+ *    **inverse** of the OOTF; the correction \"corrects\" for the OOTF by aiming\n+ *    to make the overall OOTF (including the correction) linear.\n+ *\n+ * It is important to understand this terminology because the defined terms are\n+ * scattered throughout the libpng code and it is very easy to end up with the\n+ * inverse of the power law required.\n+ *\n+ * Variable and struct::member names:\n+ *    file_gamma        OETF  how the PNG data was encoded\n+ *\n+ *    screen_gamma      EOTF  how the screen will decode digital levels\n+ *\n+ *    -- not used --    OOTF  the net effect OETF x EOTF\n+ *    gamma_correction        the inverse of OOTF to make the result linear\n+ *\n+ * All versions of libpng require a call to \"png_set_gamma\" to establish the\n+ * \"screen\" gamma, the power law representing the EOTF.  png_set_gamma may also\n+ * set or default the \"file\" gamma; the OETF.  gamma_correction is calculated\n+ * internally.\n+ *\n+ * The earliest libpng versions required file_gamma to be supplied to set_gamma.\n+ * Later versions started allowing png_set_gamma and, later, png_set_alpha_mode,\n+ * to cause defaulting from the file data.\n+ *\n+ * PNGv3 mandated a particular form for this defaulting, one that is compatible\n+ * with what libpng did except that if libpng detected inconsistencies it marked\n+ * all the chunks as \"invalid\".  PNGv3 effectively invalidates this prior code.\n+ *\n+ * Behaviour implemented below:\n+ *    translate_gamma_flags(gamma, is_screen)\n+ *       The libpng-1.6 API for the gamma parameters to libpng APIs\n+ *       (png_set_gamma and png_set_alpha_mode at present).  This allows the\n+ *       'gamma' value to be passed as a png_fixed_point number or as one of a\n+ *       set of integral values for specific \"well known\" examples of transfer\n+ *       functions.  This is compatible with PNGv3.\n+ *\/\n@@ -251,2 +308,1 @@\n-translate_gamma_flags(png_structrp png_ptr, png_fixed_point output_gamma,\n-    int is_screen)\n+translate_gamma_flags(png_fixed_point output_gamma, int is_screen)\n@@ -262,8 +318,0 @@\n-      \/* If there is no sRGB support this just sets the gamma to the standard\n-       * sRGB value.  (This is a side effect of using this function!)\n-       *\/\n-#     ifdef PNG_READ_sRGB_SUPPORTED\n-         png_ptr->flags |= PNG_FLAG_ASSUME_sRGB;\n-#     else\n-         PNG_UNUSED(png_ptr)\n-#     endif\n@@ -311,0 +359,27 @@\n+\n+static int\n+unsupported_gamma(png_structrp png_ptr, png_fixed_point gamma, int warn)\n+{\n+   \/* Validate a gamma value to ensure it is in a reasonable range.  The value\n+    * is expected to be 1 or greater, but this range test allows for some\n+    * viewing correction values.  The intent is to weed out the API users\n+    * who might use the inverse of the gamma value accidentally!\n+    *\n+    * 1.6.47: apply the test in png_set_gamma as well but only warn and return\n+    * false if it fires.\n+    *\n+    * TODO: 1.8: make this an app_error in png_set_gamma as well.\n+    *\/\n+   if (gamma < PNG_LIB_GAMMA_MIN || gamma > PNG_LIB_GAMMA_MAX)\n+   {\n+#     define msg \"gamma out of supported range\"\n+      if (warn)\n+         png_app_warning(png_ptr, msg);\n+      else\n+         png_app_error(png_ptr, msg);\n+      return 1;\n+#     undef msg\n+   }\n+\n+   return 0;\n+}\n@@ -318,1 +393,0 @@\n-   int compose = 0;\n@@ -320,0 +394,1 @@\n+   int compose = 0;\n@@ -321,1 +396,1 @@\n-   png_debug(1, \"in png_set_alpha_mode\");\n+   png_debug(1, \"in png_set_alpha_mode_fixed\");\n@@ -326,13 +401,3 @@\n-   output_gamma = translate_gamma_flags(png_ptr, output_gamma, 1\/*screen*\/);\n-\n-   \/* Validate the value to ensure it is in a reasonable range. The value\n-    * is expected to be 1 or greater, but this range test allows for some\n-    * viewing correction values.  The intent is to weed out users of this API\n-    * who use the inverse of the gamma value accidentally!  Since some of these\n-    * values are reasonable this may have to be changed:\n-    *\n-    * 1.6.x: changed from 0.07..3 to 0.01..100 (to accommodate the optimal 16-bit\n-    * gamma of 36, and its reciprocal.)\n-    *\/\n-   if (output_gamma < 1000 || output_gamma > 10000000)\n-      png_error(png_ptr, \"output gamma out of expected range\");\n+   output_gamma = translate_gamma_flags(output_gamma, 1\/*screen*\/);\n+   if (unsupported_gamma(png_ptr, output_gamma, 0\/*error*\/))\n+      return;\n@@ -341,1 +406,3 @@\n-    * gamma may be changed below so get the file value first:\n+    * gamma may be changed below so get the file value first.  The default_gamma\n+    * is set here and from the simplified API (which uses a different algorithm)\n+    * so don't overwrite a set value:\n@@ -343,1 +410,6 @@\n-   file_gamma = png_reciprocal(output_gamma);\n+   file_gamma = png_ptr->default_gamma;\n+   if (file_gamma == 0)\n+   {\n+      file_gamma = png_reciprocal(output_gamma);\n+      png_ptr->default_gamma = file_gamma;\n+   }\n@@ -394,11 +466,1 @@\n-   \/* Only set the default gamma if the file gamma has not been set (this has\n-    * the side effect that the gamma in a second call to png_set_alpha_mode will\n-    * be ignored.)\n-    *\/\n-   if (png_ptr->colorspace.gamma == 0)\n-   {\n-      png_ptr->colorspace.gamma = file_gamma;\n-      png_ptr->colorspace.flags |= PNG_COLORSPACE_HAVE_GAMMA;\n-   }\n-\n-   \/* But always set the output gamma: *\/\n+   \/* Set the screen gamma values: *\/\n@@ -414,1 +476,1 @@\n-      png_ptr->background_gamma = png_ptr->colorspace.gamma; \/* just in case *\/\n+      png_ptr->background_gamma = file_gamma; \/* just in case *\/\n@@ -471,0 +533,10 @@\n+      \/* Initialize the array to index colors.\n+       *\n+       * Ensure quantize_index can fit 256 elements (PNG_MAX_PALETTE_LENGTH)\n+       * rather than num_palette elements. This is to prevent buffer overflows\n+       * caused by malformed PNG files with out-of-range palette indices.\n+       *\n+       * Be careful to avoid leaking memory. Applications are allowed to call\n+       * this function more than once per png_struct.\n+       *\/\n+      png_free(png_ptr, png_ptr->quantize_index);\n@@ -472,2 +544,2 @@\n-          (png_alloc_size_t)((png_uint_32)num_palette * (sizeof (png_byte))));\n-      for (i = 0; i < num_palette; i++)\n+          PNG_MAX_PALETTE_LENGTH);\n+      for (i = 0; i < PNG_MAX_PALETTE_LENGTH; i++)\n@@ -485,5 +557,2 @@\n-         int i;\n-\n-         \/* Initialize an array to sort colors *\/\n-         png_ptr->quantize_sort = (png_bytep)png_malloc(png_ptr,\n-             (png_alloc_size_t)((png_uint_32)num_palette * (sizeof (png_byte))));\n+         png_bytep quantize_sort;\n+         int i, j;\n@@ -491,1 +560,3 @@\n-         \/* Initialize the quantize_sort array *\/\n+         \/* Initialize the local array to sort colors. *\/\n+         quantize_sort = (png_bytep)png_malloc(png_ptr,\n+             (png_alloc_size_t)num_palette);\n@@ -493,1 +564,1 @@\n-            png_ptr->quantize_sort[i] = (png_byte)i;\n+            quantize_sort[i] = (png_byte)i;\n@@ -505,1 +576,0 @@\n-            int j;\n@@ -510,2 +580,2 @@\n-               if (histogram[png_ptr->quantize_sort[j]]\n-                   < histogram[png_ptr->quantize_sort[j + 1]])\n+               if (histogram[quantize_sort[j]]\n+                   < histogram[quantize_sort[j + 1]])\n@@ -515,3 +585,3 @@\n-                  t = png_ptr->quantize_sort[j];\n-                  png_ptr->quantize_sort[j] = png_ptr->quantize_sort[j + 1];\n-                  png_ptr->quantize_sort[j + 1] = t;\n+                  t = quantize_sort[j];\n+                  quantize_sort[j] = quantize_sort[j + 1];\n+                  quantize_sort[j + 1] = t;\n@@ -529,1 +599,1 @@\n-            int j = num_palette;\n+            j = num_palette;\n@@ -536,1 +606,1 @@\n-               if ((int)png_ptr->quantize_sort[i] >= maximum_colors)\n+               if ((int)quantize_sort[i] >= maximum_colors)\n@@ -540,1 +610,1 @@\n-                  while ((int)png_ptr->quantize_sort[j] >= maximum_colors);\n+                  while ((int)quantize_sort[j] >= maximum_colors);\n@@ -548,1 +618,1 @@\n-            int j = num_palette;\n+            j = num_palette;\n@@ -556,1 +626,1 @@\n-               if ((int)png_ptr->quantize_sort[i] >= maximum_colors)\n+               if ((int)quantize_sort[i] >= maximum_colors)\n@@ -562,1 +632,1 @@\n-                  while ((int)png_ptr->quantize_sort[j] >= maximum_colors);\n+                  while ((int)quantize_sort[j] >= maximum_colors);\n@@ -600,2 +670,1 @@\n-         png_free(png_ptr, png_ptr->quantize_sort);\n-         png_ptr->quantize_sort = NULL;\n+         png_free(png_ptr, quantize_sort);\n@@ -623,2 +692,1 @@\n-             (png_alloc_size_t)((png_uint_32)num_palette *\n-             (sizeof (png_byte))));\n+             (png_alloc_size_t)num_palette);\n@@ -626,2 +694,1 @@\n-             (png_alloc_size_t)((png_uint_32)num_palette *\n-             (sizeof (png_byte))));\n+             (png_alloc_size_t)num_palette);\n@@ -792,1 +859,1 @@\n-          (png_alloc_size_t)(num_entries * (sizeof (png_byte))));\n+          (png_alloc_size_t)(num_entries));\n@@ -794,2 +861,1 @@\n-      distance = (png_bytep)png_malloc(png_ptr, (png_alloc_size_t)(num_entries *\n-          (sizeof (png_byte))));\n+      distance = (png_bytep)png_malloc(png_ptr, (png_alloc_size_t)num_entries);\n@@ -797,1 +863,1 @@\n-      memset(distance, 0xff, num_entries * (sizeof (png_byte)));\n+      memset(distance, 0xff, num_entries);\n@@ -855,2 +921,2 @@\n-   scrn_gamma = translate_gamma_flags(png_ptr, scrn_gamma, 1\/*screen*\/);\n-   file_gamma = translate_gamma_flags(png_ptr, file_gamma, 0\/*file*\/);\n+   scrn_gamma = translate_gamma_flags(scrn_gamma, 1\/*screen*\/);\n+   file_gamma = translate_gamma_flags(file_gamma, 0\/*file*\/);\n@@ -870,2 +936,1 @@\n-      png_error(png_ptr, \"invalid file gamma in png_set_gamma\");\n-\n+      png_app_error(png_ptr, \"invalid file gamma in png_set_gamma\");\n@@ -873,1 +938,5 @@\n-      png_error(png_ptr, \"invalid screen gamma in png_set_gamma\");\n+      png_app_error(png_ptr, \"invalid screen gamma in png_set_gamma\");\n+\n+   if (unsupported_gamma(png_ptr, file_gamma, 1\/*warn*\/) ||\n+       unsupported_gamma(png_ptr, scrn_gamma, 1\/*warn*\/))\n+      return;\n@@ -875,3 +944,3 @@\n-   \/* Set the gamma values unconditionally - this overrides the value in the PNG\n-    * file if a gAMA chunk was present.  png_set_alpha_mode provides a\n-    * different, easier, way to default the file gamma.\n+   \/* 1.6.47: png_struct::file_gamma and png_struct::screen_gamma are now only\n+    * written by this API.  This removes dependencies on the order of API calls\n+    * and allows the complex gamma checks to be delayed until needed.\n@@ -879,2 +948,1 @@\n-   png_ptr->colorspace.gamma = file_gamma;\n-   png_ptr->colorspace.flags |= PNG_COLORSPACE_HAVE_GAMMA;\n+   png_ptr->file_gamma = file_gamma;\n@@ -1001,1 +1069,1 @@\n-   png_debug(1, \"in png_set_rgb_to_gray\");\n+   png_debug(1, \"in png_set_rgb_to_gray_fixed\");\n@@ -1058,20 +1126,3 @@\n-      else\n-      {\n-         if (red >= 0 && green >= 0)\n-            png_app_warning(png_ptr,\n-                \"ignoring out of range rgb_to_gray coefficients\");\n-\n-         \/* Use the defaults, from the cHRM chunk if set, else the historical\n-          * values which are close to the sRGB\/HDTV\/ITU-Rec 709 values.  See\n-          * png_do_rgb_to_gray for more discussion of the values.  In this case\n-          * the coefficients are not marked as 'set' and are not overwritten if\n-          * something has already provided a default.\n-          *\/\n-         if (png_ptr->rgb_to_gray_red_coeff == 0 &&\n-             png_ptr->rgb_to_gray_green_coeff == 0)\n-         {\n-            png_ptr->rgb_to_gray_red_coeff   = 6968;\n-            png_ptr->rgb_to_gray_green_coeff = 23434;\n-            \/* png_ptr->rgb_to_gray_blue_coeff  = 2366; *\/\n-         }\n-      }\n+      else if (red >= 0 && green >= 0)\n+         png_app_warning(png_ptr,\n+               \"ignoring out of range rgb_to_gray coefficients\");\n@@ -1318,0 +1369,74 @@\n+#ifdef PNG_READ_GAMMA_SUPPORTED\n+png_fixed_point \/* PRIVATE *\/\n+png_resolve_file_gamma(png_const_structrp png_ptr)\n+{\n+   png_fixed_point file_gamma;\n+\n+   \/* The file gamma is determined by these precedence rules, in this order\n+    * (i.e. use the first value found):\n+    *\n+    *    png_set_gamma; png_struct::file_gammma if not zero, then:\n+    *    png_struct::chunk_gamma if not 0 (determined the PNGv3 rules), then:\n+    *    png_set_gamma; 1\/png_struct::screen_gamma if not zero\n+    *\n+    *    0 (i.e. do no gamma handling)\n+    *\/\n+   file_gamma = png_ptr->file_gamma;\n+   if (file_gamma != 0)\n+      return file_gamma;\n+\n+   file_gamma = png_ptr->chunk_gamma;\n+   if (file_gamma != 0)\n+      return file_gamma;\n+\n+   file_gamma = png_ptr->default_gamma;\n+   if (file_gamma != 0)\n+      return file_gamma;\n+\n+   \/* If png_reciprocal oveflows it returns 0 which indicates to the caller that\n+    * there is no usable file gamma.  (The checks added to png_set_gamma and\n+    * png_set_alpha_mode should prevent a screen_gamma which would overflow.)\n+    *\/\n+   if (png_ptr->screen_gamma != 0)\n+      file_gamma = png_reciprocal(png_ptr->screen_gamma);\n+\n+   return file_gamma;\n+}\n+\n+static int\n+png_init_gamma_values(png_structrp png_ptr)\n+{\n+   \/* The following temporary indicates if overall gamma correction is\n+    * required.\n+    *\/\n+   int gamma_correction = 0;\n+   png_fixed_point file_gamma, screen_gamma;\n+\n+   \/* Resolve the file_gamma.  See above: if png_ptr::screen_gamma is set\n+    * file_gamma will always be set here:\n+    *\/\n+   file_gamma = png_resolve_file_gamma(png_ptr);\n+   screen_gamma = png_ptr->screen_gamma;\n+\n+   if (file_gamma > 0) \/* file has been set *\/\n+   {\n+      if (screen_gamma > 0) \/* screen set too *\/\n+         gamma_correction = png_gamma_threshold(file_gamma, screen_gamma);\n+\n+      else\n+         \/* Assume the output matches the input; a long time default behavior\n+          * of libpng, although the standard has nothing to say about this.\n+          *\/\n+         screen_gamma = png_reciprocal(file_gamma);\n+   }\n+\n+   else \/* both unset, prevent corrections: *\/\n+      file_gamma = screen_gamma = PNG_FP_1;\n+\n+   png_ptr->file_gamma = file_gamma;\n+   png_ptr->screen_gamma = screen_gamma;\n+   return gamma_correction;\n+\n+}\n+#endif \/* READ_GAMMA *\/\n+\n@@ -1337,0 +1462,10 @@\n+    *\n+    * PNGv3: the new mandatory precedence\/priority rules for colour space chunks\n+    * are handled here (by calling the above function).\n+    *\n+    * Turn the gamma transformation on or off as appropriate.  Notice that\n+    * PNG_GAMMA just refers to the file->screen correction.  Alpha composition\n+    * may independently cause gamma correction because it needs linear data\n+    * (e.g. if the file has a gAMA chunk but the screen gamma hasn't been\n+    * specified.)  In any case this flag may get turned off in the code\n+    * immediately below if the transform can be handled outside the row loop.\n@@ -1338,11 +1473,2 @@\n-   {\n-      \/* The following temporary indicates if overall gamma correction is\n-       * required.\n-       *\/\n-      int gamma_correction = 0;\n-\n-      if (png_ptr->colorspace.gamma != 0) \/* has been set *\/\n-      {\n-         if (png_ptr->screen_gamma != 0) \/* screen set too *\/\n-            gamma_correction = png_gamma_threshold(png_ptr->colorspace.gamma,\n-                png_ptr->screen_gamma);\n+   if (png_init_gamma_values(png_ptr) != 0)\n+      png_ptr->transformations |= PNG_GAMMA;\n@@ -1350,40 +1476,2 @@\n-         else\n-            \/* Assume the output matches the input; a long time default behavior\n-             * of libpng, although the standard has nothing to say about this.\n-             *\/\n-            png_ptr->screen_gamma = png_reciprocal(png_ptr->colorspace.gamma);\n-      }\n-\n-      else if (png_ptr->screen_gamma != 0)\n-         \/* The converse - assume the file matches the screen, note that this\n-          * perhaps undesirable default can (from 1.5.4) be changed by calling\n-          * png_set_alpha_mode (even if the alpha handling mode isn't required\n-          * or isn't changed from the default.)\n-          *\/\n-         png_ptr->colorspace.gamma = png_reciprocal(png_ptr->screen_gamma);\n-\n-      else \/* neither are set *\/\n-         \/* Just in case the following prevents any processing - file and screen\n-          * are both assumed to be linear and there is no way to introduce a\n-          * third gamma value other than png_set_background with 'UNIQUE', and,\n-          * prior to 1.5.4\n-          *\/\n-         png_ptr->screen_gamma = png_ptr->colorspace.gamma = PNG_FP_1;\n-\n-      \/* We have a gamma value now. *\/\n-      png_ptr->colorspace.flags |= PNG_COLORSPACE_HAVE_GAMMA;\n-\n-      \/* Now turn the gamma transformation on or off as appropriate.  Notice\n-       * that PNG_GAMMA just refers to the file->screen correction.  Alpha\n-       * composition may independently cause gamma correction because it needs\n-       * linear data (e.g. if the file has a gAMA chunk but the screen gamma\n-       * hasn't been specified.)  In any case this flag may get turned off in\n-       * the code immediately below if the transform can be handled outside the\n-       * row loop.\n-       *\/\n-      if (gamma_correction != 0)\n-         png_ptr->transformations |= PNG_GAMMA;\n-\n-      else\n-         png_ptr->transformations &= ~PNG_GAMMA;\n-   }\n+   else\n+      png_ptr->transformations &= ~PNG_GAMMA;\n@@ -1461,1 +1549,1 @@\n-      png_colorspace_set_rgb_coefficients(png_ptr);\n+      png_set_rgb_coefficients(png_ptr);\n@@ -1604,1 +1692,1 @@\n-        (png_gamma_significant(png_ptr->colorspace.gamma) != 0 ||\n+        (png_gamma_significant(png_ptr->file_gamma) != 0 ||\n@@ -1607,1 +1695,1 @@\n-         (png_gamma_significant(png_ptr->colorspace.gamma) != 0 ||\n+         (png_gamma_significant(png_ptr->file_gamma) != 0 ||\n@@ -1663,2 +1751,2 @@\n-                     g = png_reciprocal(png_ptr->colorspace.gamma);\n-                     gs = png_reciprocal2(png_ptr->colorspace.gamma,\n+                     g = png_reciprocal(png_ptr->file_gamma);\n+                     gs = png_reciprocal2(png_ptr->file_gamma,\n@@ -1725,13 +1813,45 @@\n-                     png_byte v, w;\n-\n-                     v = png_ptr->gamma_to_1[palette[i].red];\n-                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.red);\n-                     palette[i].red = png_ptr->gamma_from_1[w];\n-\n-                     v = png_ptr->gamma_to_1[palette[i].green];\n-                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.green);\n-                     palette[i].green = png_ptr->gamma_from_1[w];\n-\n-                     v = png_ptr->gamma_to_1[palette[i].blue];\n-                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.blue);\n-                     palette[i].blue = png_ptr->gamma_from_1[w];\n+                     if ((png_ptr->flags & PNG_FLAG_OPTIMIZE_ALPHA) != 0)\n+                     {\n+                        \/* Premultiply only:\n+                         * component = round((component * alpha) \/ 255)\n+                         *\/\n+                        png_uint_32 component;\n+\n+                        component = png_ptr->gamma_to_1[palette[i].red];\n+                        component =\n+                            (component * png_ptr->trans_alpha[i] + 128) \/ 255;\n+                        palette[i].red = png_ptr->gamma_from_1[component];\n+\n+                        component = png_ptr->gamma_to_1[palette[i].green];\n+                        component =\n+                            (component * png_ptr->trans_alpha[i] + 128) \/ 255;\n+                        palette[i].green = png_ptr->gamma_from_1[component];\n+\n+                        component = png_ptr->gamma_to_1[palette[i].blue];\n+                        component =\n+                            (component * png_ptr->trans_alpha[i] + 128) \/ 255;\n+                        palette[i].blue = png_ptr->gamma_from_1[component];\n+                     }\n+                     else\n+                     {\n+                        \/* Composite with background color:\n+                         * component =\n+                         *    alpha * component + (1 - alpha) * background\n+                         *\/\n+                        png_byte v, w;\n+\n+                        v = png_ptr->gamma_to_1[palette[i].red];\n+                        png_composite(w, v,\n+                            png_ptr->trans_alpha[i], back_1.red);\n+                        palette[i].red = png_ptr->gamma_from_1[w];\n+\n+                        v = png_ptr->gamma_to_1[palette[i].green];\n+                        png_composite(w, v,\n+                            png_ptr->trans_alpha[i], back_1.green);\n+                        palette[i].green = png_ptr->gamma_from_1[w];\n+\n+                        v = png_ptr->gamma_to_1[palette[i].blue];\n+                        png_composite(w, v,\n+                            png_ptr->trans_alpha[i], back_1.blue);\n+                        palette[i].blue = png_ptr->gamma_from_1[w];\n+                     }\n@@ -1772,2 +1892,2 @@\n-                  g = png_reciprocal(png_ptr->colorspace.gamma);\n-                  gs = png_reciprocal2(png_ptr->colorspace.gamma,\n+                  g = png_reciprocal(png_ptr->file_gamma);\n+                  gs = png_reciprocal2(png_ptr->file_gamma,\n@@ -2023,3 +2143,3 @@\n-    * TODO: this looks wrong; the info_ptr should end up with a gamma equal to\n-    * the screen_gamma value.  The following probably results in weirdness if\n-    * the info_ptr is used by the app after the rows have been read.\n+    * TODO: this is confusing.  It only changes the result of png_get_gAMA and,\n+    * yes, it does return the value that the transformed data effectively has\n+    * but does any app really understand this?\n@@ -2027,1 +2147,1 @@\n-   info_ptr->colorspace.gamma = png_ptr->colorspace.gamma;\n+   info_ptr->gamma = png_ptr->file_gamma;\n@@ -4960,1 +5080,0 @@\n-   {\n@@ -4963,4 +5082,0 @@\n-\n-      if (row_info->rowbytes == 0)\n-         png_error(png_ptr, \"png_do_quantize returned rowbytes=0\");\n-   }\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/pngrtran.c","additions":297,"deletions":182,"binary":false,"changes":479,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2022 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -49,0 +49,20 @@\n+\/* The minimum 'zlib' stream is assumed to be just the 2 byte header, 5 bytes\n+ * minimum 'deflate' stream, and the 4 byte checksum.\n+ *\/\n+#define LZ77Min  (2U+5U+4U)\n+\n+#ifdef PNG_READ_INTERLACING_SUPPORTED\n+\/* Arrays to facilitate interlacing - use pass (0 - 6) as index. *\/\n+\n+\/* Start of interlace block *\/\n+static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\n+\/* Offset to next interlace block *\/\n+static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n+\/* Start of interlace block in the y direction *\/\n+static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};\n+\/* Offset to next interlace block in the y direction *\/\n+static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n+\n+\/* TODO: Move these arrays to a common utility module to avoid duplication. *\/\n+#endif\n+\n@@ -57,24 +77,1 @@\n-   return (uval);\n-}\n-\n-#if defined(PNG_READ_gAMA_SUPPORTED) || defined(PNG_READ_cHRM_SUPPORTED)\n-\/* The following is a variation on the above for use with the fixed\n- * point values used for gAMA and cHRM.  Instead of png_error it\n- * issues a warning and returns (-1) - an invalid value because both\n- * gAMA and cHRM use *unsigned* integers for fixed point values.\n- *\/\n-#define PNG_FIXED_ERROR (-1)\n-\n-static png_fixed_point \/* PRIVATE *\/\n-png_get_fixed_point(png_structrp png_ptr, png_const_bytep buf)\n-{\n-   png_uint_32 uval = png_get_uint_32(buf);\n-\n-   if (uval <= PNG_UINT_31_MAX)\n-      return (png_fixed_point)uval; \/* known to be in range *\/\n-\n-   \/* The caller can turn off the warning by passing NULL. *\/\n-   if (png_ptr != NULL)\n-      png_warning(png_ptr, \"PNG fixed point integer out of range\");\n-\n-   return PNG_FIXED_ERROR;\n+   return uval;\n@@ -82,1 +79,0 @@\n-#endif\n@@ -171,1 +167,1 @@\n-          png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4))\n+          png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4) != 0)\n@@ -180,0 +176,32 @@\n+\/* This function is called to verify that a chunk name is valid.\n+ * Do this using the bit-whacking approach from contrib\/tools\/pngfix.c\n+ *\n+ * Copied from libpng 1.7.\n+ *\/\n+static int\n+check_chunk_name(png_uint_32 name)\n+{\n+   png_uint_32 t;\n+\n+   \/* Remove bit 5 from all but the reserved byte; this means\n+    * every 8-bit unit must be in the range 65-90 to be valid.\n+    * So bit 5 must be zero, bit 6 must be set and bit 7 zero.\n+    *\/\n+   name &= ~PNG_U32(32,32,0,32);\n+   t = (name & ~0x1f1f1f1fU) ^ 0x40404040U;\n+\n+   \/* Subtract 65 for each 8-bit quantity, this must not\n+    * overflow and each byte must then be in the range 0-25.\n+    *\/\n+   name -= PNG_U32(65,65,65,65);\n+   t |= name;\n+\n+   \/* Subtract 26, handling the overflow which should set the\n+    * top three bits of each byte.\n+    *\/\n+   name -= PNG_U32(25,25,25,26);\n+   t |= ~name;\n+\n+   return (t & 0xe0e0e0e0U) == 0U;\n+}\n+\n@@ -187,1 +215,1 @@\n-   png_uint_32 length;\n+   png_uint_32 chunk_name, length;\n@@ -193,2 +221,3 @@\n-   \/* Read the length and the chunk name.\n-    * This must be performed in a single I\/O call.\n+   \/* Read the length and the chunk name.  png_struct::chunk_name is immediately\n+    * updated even if they are detectably wrong.  This aids error message\n+    * handling by allowing png_chunk_error to be used.\n@@ -198,6 +227,1 @@\n-\n-   \/* Put the chunk name into png_ptr->chunk_name. *\/\n-   png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(buf+4);\n-\n-   png_debug2(0, \"Reading %lx chunk, length = %lu\",\n-       (unsigned long)png_ptr->chunk_name, (unsigned long)length);\n+   png_ptr->chunk_name = chunk_name = PNG_CHUNK_FROM_STRING(buf+4);\n@@ -209,2 +233,8 @@\n-   \/* Check to see if chunk name is valid. *\/\n-   png_check_chunk_name(png_ptr, png_ptr->chunk_name);\n+   png_debug2(0, \"Reading chunk typeid = 0x%lx, length = %lu\",\n+       (unsigned long)png_ptr->chunk_name, (unsigned long)length);\n+\n+   \/* Sanity check the length (first by <= 0x80) and the chunk name.  An error\n+    * here indicates a broken stream and libpng has no recovery from this.\n+    *\/\n+   if (buf[0] >= 0x80U)\n+      png_chunk_error(png_ptr, \"bad header (invalid length)\");\n@@ -212,2 +242,3 @@\n-   \/* Check for too-large chunk length *\/\n-   png_check_chunk_length(png_ptr, length);\n+   \/* Check to see if chunk name is valid. *\/\n+   if (!check_chunk_name(chunk_name))\n+      png_chunk_error(png_ptr, \"bad header (invalid type)\");\n@@ -233,0 +264,66 @@\n+\/* Compare the CRC stored in the PNG file with that calculated by libpng from\n+ * the data it has read thus far.\n+ *\/\n+static int\n+png_crc_error(png_structrp png_ptr, int handle_as_ancillary)\n+{\n+   png_byte crc_bytes[4];\n+   png_uint_32 crc;\n+   int need_crc = 1;\n+\n+   \/* There are four flags two for ancillary and two for critical chunks.  The\n+    * default setting of these flags is all zero.\n+    *\n+    * PNG_FLAG_CRC_ANCILLARY_USE\n+    * PNG_FLAG_CRC_ANCILLARY_NOWARN\n+    *  USE+NOWARN: no CRC calculation (implemented here), else;\n+    *  NOWARN:     png_chunk_error on error (implemented in png_crc_finish)\n+    *  else:       png_chunk_warning on error (implemented in png_crc_finish)\n+    *              This is the default.\n+    *\n+    *    I.e. NOWARN without USE produces png_chunk_error.  The default setting\n+    *    where neither are set does the same thing.\n+    *\n+    * PNG_FLAG_CRC_CRITICAL_USE\n+    * PNG_FLAG_CRC_CRITICAL_IGNORE\n+    *  IGNORE: no CRC calculation (implemented here), else;\n+    *  USE:    png_chunk_warning on error (implemented in png_crc_finish)\n+    *  else:   png_chunk_error on error (implemented in png_crc_finish)\n+    *          This is the default.\n+    *\n+    * This arose because of original mis-implementation and has persisted for\n+    * compatibility reasons.\n+    *\n+    * TODO: the flag names are internal so maybe this can be changed to\n+    * something comprehensible.\n+    *\/\n+   if (handle_as_ancillary || PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0)\n+   {\n+      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==\n+          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))\n+         need_crc = 0;\n+   }\n+\n+   else \/* critical *\/\n+   {\n+      if ((png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)\n+         need_crc = 0;\n+   }\n+\n+#ifdef PNG_IO_STATE_SUPPORTED\n+   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_CRC;\n+#endif\n+\n+   \/* The chunk CRC must be serialized in a single I\/O call. *\/\n+   png_read_data(png_ptr, crc_bytes, 4);\n+\n+   if (need_crc != 0)\n+   {\n+      crc = png_get_uint_32(crc_bytes);\n+      return crc != png_ptr->crc;\n+   }\n+\n+   else\n+      return 0;\n+}\n+\n@@ -237,0 +334,5 @@\n+ *\n+ * There is one public version which is used in most places and another which\n+ * takes the value for the 'critical' flag to check.  This allows PLTE and IEND\n+ * handling code to ignore the CRC error and removes some confusing code\n+ * duplication.\n@@ -238,2 +340,3 @@\n-int \/* PRIVATE *\/\n-png_crc_finish(png_structrp png_ptr, png_uint_32 skip)\n+static int\n+png_crc_finish_critical(png_structrp png_ptr, png_uint_32 skip,\n+      int handle_as_ancillary)\n@@ -257,1 +360,12 @@\n-   if (png_crc_error(png_ptr) != 0)\n+   \/* If 'handle_as_ancillary' has been requested and this is a critical chunk\n+    * but PNG_FLAG_CRC_CRITICAL_IGNORE was set then png_read_crc did not, in\n+    * fact, calculate the CRC so the ANCILLARY settings should not be used\n+    * instead.\n+    *\/\n+   if (handle_as_ancillary &&\n+       (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)\n+      handle_as_ancillary = 0;\n+\n+   \/* TODO: this might be more comprehensible if png_crc_error was inlined here.\n+    *\/\n+   if (png_crc_error(png_ptr, handle_as_ancillary) != 0)\n@@ -259,1 +373,2 @@\n-      if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0 ?\n+      \/* See above for the explanation of how the flags work. *\/\n+      if (handle_as_ancillary || PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0 ?\n@@ -262,1 +377,0 @@\n-      {\n@@ -264,1 +378,0 @@\n-      }\n@@ -269,1 +382,1 @@\n-      return (1);\n+      return 1;\n@@ -272,1 +385,1 @@\n-   return (0);\n+   return 0;\n@@ -275,3 +388,0 @@\n-\/* Compare the CRC stored in the PNG file with that calculated by libpng from\n- * the data it has read thus far.\n- *\/\n@@ -279,1 +389,1 @@\n-png_crc_error(png_structrp png_ptr)\n+png_crc_finish(png_structrp png_ptr, png_uint_32 skip)\n@@ -281,32 +391,1 @@\n-   png_byte crc_bytes[4];\n-   png_uint_32 crc;\n-   int need_crc = 1;\n-\n-   if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0)\n-   {\n-      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==\n-          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))\n-         need_crc = 0;\n-   }\n-\n-   else \/* critical *\/\n-   {\n-      if ((png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)\n-         need_crc = 0;\n-   }\n-\n-#ifdef PNG_IO_STATE_SUPPORTED\n-   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_CRC;\n-#endif\n-\n-   \/* The chunk CRC must be serialized in a single I\/O call. *\/\n-   png_read_data(png_ptr, crc_bytes, 4);\n-\n-   if (need_crc != 0)\n-   {\n-      crc = png_get_uint_32(crc_bytes);\n-      return ((int)(crc != png_ptr->crc));\n-   }\n-\n-   else\n-      return (0);\n+   return png_crc_finish_critical(png_ptr, skip, 0\/*critical handling*\/);\n@@ -318,1 +397,2 @@\n-    defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_SEQUENTIAL_READ_SUPPORTED)\n+    defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_READ_eXIf_SUPPORTED) ||\\\n+    defined(PNG_SEQUENTIAL_READ_SUPPORTED)\n@@ -322,2 +402,1 @@\n- * it will call png_error (via png_malloc) on failure.  (warn == 2 means\n- * 'silent').\n+ * it will call png_error on failure.\n@@ -326,1 +405,1 @@\n-png_read_buffer(png_structrp png_ptr, png_alloc_size_t new_size, int warn)\n+png_read_buffer(png_structrp png_ptr, png_alloc_size_t new_size)\n@@ -330,0 +409,2 @@\n+   if (new_size > png_chunk_max(png_ptr)) return NULL;\n+\n@@ -344,1 +425,3 @@\n-         memset(buffer, 0, new_size); \/* just in case *\/\n+#        ifndef PNG_NO_MEMZERO \/* for detecting UIM bugs **only** *\/\n+            memset(buffer, 0, new_size); \/* just in case *\/\n+#        endif\n@@ -348,9 +431,0 @@\n-\n-      else if (warn < 2) \/* else silent *\/\n-      {\n-         if (warn != 0)\n-             png_chunk_warning(png_ptr, \"insufficient memory to read chunk\");\n-\n-         else\n-             png_chunk_error(png_ptr, \"insufficient memory to read chunk\");\n-      }\n@@ -361,1 +435,1 @@\n-#endif \/* READ_iCCP|iTXt|pCAL|sCAL|sPLT|tEXt|zTXt|SEQUENTIAL_READ *\/\n+#endif \/* READ_iCCP|iTXt|pCAL|sCAL|sPLT|tEXt|zTXt|eXIf|SEQUENTIAL_READ *\/\n@@ -452,2 +526,1 @@\n-#if ZLIB_VERNUM >= 0x1290 && \\\n-   defined(PNG_SET_OPTION_SUPPORTED) && defined(PNG_IGNORE_ADLER32)\n+#ifdef PNG_DISABLE_ADLER32_CHECK_SUPPORTED\n@@ -649,10 +722,1 @@\n-   png_alloc_size_t limit = PNG_SIZE_MAX;\n-\n-# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n-   if (png_ptr->user_chunk_malloc_max > 0 &&\n-       png_ptr->user_chunk_malloc_max < limit)\n-      limit = png_ptr->user_chunk_malloc_max;\n-# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n-   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n-      limit = PNG_USER_CHUNK_MALLOC_MAX;\n-# endif\n+   png_alloc_size_t limit = png_chunk_max(png_ptr);\n@@ -863,0 +927,1 @@\n+\/* CHUNK HANDLING *\/\n@@ -864,2 +929,1 @@\n-\n-void \/* PRIVATE *\/\n+static png_handle_result_code\n@@ -875,6 +939,1 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) != 0)\n-      png_chunk_error(png_ptr, \"out of place\");\n-\n-   \/* Check the length *\/\n-   if (length != 13)\n-      png_chunk_error(png_ptr, \"invalid\");\n+   \/* Length and position are checked by the caller. *\/\n@@ -934,0 +993,4 @@\n+\n+   \/* Rely on png_set_IHDR to completely validate the data and call png_error if\n+    * it's wrong.\n+    *\/\n@@ -936,0 +999,3 @@\n+\n+   return handled_ok;\n+   PNG_UNUSED(length)\n@@ -939,1 +1005,5 @@\n-void \/* PRIVATE *\/\n+\/* TODO: there are several obvious errors in this code when handling\n+ * out-of-place chunks and there is much over-complexity caused by trying to\n+ * patch up the problems.\n+ *\/\n+static png_handle_result_code\n@@ -942,5 +1012,1 @@\n-   png_color palette[PNG_MAX_PALETTE_LENGTH];\n-   int max_palette_length, num, i;\n-#ifdef PNG_POINTER_INDEXING_SUPPORTED\n-   png_colorp pal_ptr;\n-#endif\n+   png_const_charp errmsg = NULL;\n@@ -950,7 +1016,4 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   \/* Moved to before the 'after IDAT' check below because otherwise duplicate\n-    * PLTE chunks are potentially ignored (the spec says there shall not be more\n-    * than one PLTE, the error is not treated as benign, so this check trumps\n-    * the requirement that PLTE appears before IDAT.)\n+   \/* 1.6.47: consistency.  This used to be especially treated as a critical\n+    * error even in an image which is not colour mapped, there isn't a good\n+    * justification for treating some errors here one way and others another so\n+    * everything uses the same logic.\n@@ -958,2 +1021,2 @@\n-   else if ((png_ptr->mode & PNG_HAVE_PLTE) != 0)\n-      png_chunk_error(png_ptr, \"duplicate\");\n+   if ((png_ptr->mode & PNG_HAVE_PLTE) != 0)\n+      errmsg = \"duplicate\";\n@@ -962,8 +1025,1 @@\n-   {\n-      \/* This is benign because the non-benign error happened before, when an\n-       * IDAT was encountered in a color-mapped image with no PLTE.\n-       *\/\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n+      errmsg = \"out of place\";\n@@ -971,1 +1027,2 @@\n-   png_ptr->mode |= PNG_HAVE_PLTE;\n+   else if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0)\n+      errmsg = \"ignored in grayscale PNG\";\n@@ -973,6 +1030,2 @@\n-   if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"ignored in grayscale PNG\");\n-      return;\n-   }\n+   else if (length > 3*PNG_MAX_PALETTE_LENGTH || (length % 3) != 0)\n+      errmsg = \"invalid\";\n@@ -980,7 +1033,14 @@\n-#ifndef PNG_READ_OPT_PLTE_SUPPORTED\n-   if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      return;\n-   }\n-#endif\n+   \/* This drops PLTE in favour of tRNS or bKGD because both of those chunks\n+    * can have an effect on the rendering of the image whereas PLTE only matters\n+    * in the case of an 8-bit display with a decoder which controls the palette.\n+    *\n+    * The alternative here is to ignore the error and store the palette anyway;\n+    * destroying the tRNS will definately cause problems.\n+    *\n+    * NOTE: the case of PNG_COLOR_TYPE_PALETTE need not be considered because\n+    * the png_handle_ routines for the three 'after PLTE' chunks tRNS, bKGD and\n+    * hIST all check for a preceding PLTE in these cases.\n+    *\/\n+   else if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE &&\n+            (png_has_chunk(png_ptr, tRNS) || png_has_chunk(png_ptr, bKGD)))\n+      errmsg = \"out of place\";\n@@ -988,1 +1048,1 @@\n-   if (length > 3*PNG_MAX_PALETTE_LENGTH || length % 3)\n+   else\n@@ -990,4 +1050,8 @@\n-      png_crc_finish(png_ptr, length);\n-\n-      if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)\n-         png_chunk_benign_error(png_ptr, \"invalid\");\n+      \/* If the palette has 256 or fewer entries but is too large for the bit\n+       * depth we don't issue an error to preserve the behavior of previous\n+       * libpng versions. We silently truncate the unused extra palette entries\n+       * here.\n+       *\/\n+      const unsigned max_palette_length =\n+         (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?\n+            1U << png_ptr->bit_depth : PNG_MAX_PALETTE_LENGTH;\n@@ -995,2 +1059,5 @@\n-      else\n-         png_chunk_error(png_ptr, \"invalid\");\n+      \/* The cast is safe because 'length' is less than\n+       * 3*PNG_MAX_PALETTE_LENGTH\n+       *\/\n+      const unsigned num = (length > 3U*max_palette_length) ?\n+         max_palette_length : (unsigned)length \/ 3U;\n@@ -998,2 +1065,3 @@\n-      return;\n-   }\n+      unsigned i, j;\n+      png_byte buf[3*PNG_MAX_PALETTE_LENGTH];\n+      png_color palette[PNG_MAX_PALETTE_LENGTH];\n@@ -1001,2 +1069,5 @@\n-   \/* The cast is safe because 'length' is less than 3*PNG_MAX_PALETTE_LENGTH *\/\n-   num = (int)length \/ 3;\n+      \/* Read the chunk into the buffer then read to the end of the chunk. *\/\n+      png_crc_read(png_ptr, buf, num*3U);\n+      png_crc_finish_critical(png_ptr, length - 3U*num,\n+            \/* Handle as ancillary if PLTE is optional: *\/\n+            png_ptr->color_type != PNG_COLOR_TYPE_PALETTE);\n@@ -1004,12 +1075,6 @@\n-   \/* If the palette has 256 or fewer entries but is too large for the bit\n-    * depth, we don't issue an error, to preserve the behavior of previous\n-    * libpng versions. We silently truncate the unused extra palette entries\n-    * here.\n-    *\/\n-   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n-      max_palette_length = (1 << png_ptr->bit_depth);\n-   else\n-      max_palette_length = PNG_MAX_PALETTE_LENGTH;\n-\n-   if (num > max_palette_length)\n-      num = max_palette_length;\n+      for (i = 0U, j = 0U; i < num; i++)\n+      {\n+         palette[i].red = buf[j++];\n+         palette[i].green = buf[j++];\n+         palette[i].blue = buf[j++];\n+      }\n@@ -1017,4 +1082,2 @@\n-#ifdef PNG_POINTER_INDEXING_SUPPORTED\n-   for (i = 0, pal_ptr = palette; i < num; i++, pal_ptr++)\n-   {\n-      png_byte buf[3];\n+      \/* A valid PLTE chunk has been read *\/\n+      png_ptr->mode |= PNG_HAVE_PLTE;\n@@ -1022,15 +1085,15 @@\n-      png_crc_read(png_ptr, buf, 3);\n-      pal_ptr->red = buf[0];\n-      pal_ptr->green = buf[1];\n-      pal_ptr->blue = buf[2];\n-   }\n-#else\n-   for (i = 0; i < num; i++)\n-   {\n-      png_byte buf[3];\n-\n-      png_crc_read(png_ptr, buf, 3);\n-      \/* Don't depend upon png_color being any order *\/\n-      palette[i].red = buf[0];\n-      palette[i].green = buf[1];\n-      palette[i].blue = buf[2];\n+      \/* TODO: png_set_PLTE has the side effect of setting png_ptr->palette to\n+       * its own copy of the palette.  This has the side effect that when\n+       * png_start_row is called (this happens after any call to\n+       * png_read_update_info) the info_ptr palette gets changed.  This is\n+       * extremely unexpected and confusing.\n+       *\n+       * REVIEW: there have been consistent bugs in the past about gamma and\n+       * similar transforms to colour mapped images being useless because the\n+       * modified palette cannot be accessed because of the above.\n+       *\n+       * CONSIDER: Fix this by not sharing the palette in this way.  But does\n+       * this completely fix the problem?\n+       *\/\n+      png_set_PLTE(png_ptr, info_ptr, palette, num);\n+      return handled_ok;\n@@ -1038,1 +1101,0 @@\n-#endif\n@@ -1040,6 +1102,1 @@\n-   \/* If we actually need the PLTE chunk (ie for a paletted image), we do\n-    * whatever the normal CRC configuration tells us.  However, if we\n-    * have an RGB image, the PLTE can be considered ancillary, so\n-    * we will act as though it is.\n-    *\/\n-#ifndef PNG_READ_OPT_PLTE_SUPPORTED\n+   \/* Here on error: errmsg is non NULL. *\/\n@@ -1047,1 +1104,0 @@\n-#endif\n@@ -1049,1 +1105,2 @@\n-      png_crc_finish(png_ptr, (png_uint_32) (length - (unsigned int)num * 3));\n+      png_crc_finish(png_ptr, length);\n+      png_chunk_error(png_ptr, errmsg);\n@@ -1052,2 +1109,1 @@\n-#ifndef PNG_READ_OPT_PLTE_SUPPORTED\n-   else if (png_crc_error(png_ptr) != 0)  \/* Only if we have a CRC error *\/\n+   else \/* not critical to this image *\/\n@@ -1055,21 +1111,2 @@\n-      \/* If we don't want to use the data from an ancillary chunk,\n-       * we have two options: an error abort, or a warning and we\n-       * ignore the data in this chunk (which should be OK, since\n-       * it's considered ancillary for a RGB or RGBA image).\n-       *\n-       * IMPLEMENTATION NOTE: this is only here because png_crc_finish uses the\n-       * chunk type to determine whether to check the ancillary or the critical\n-       * flags.\n-       *\/\n-      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_USE) == 0)\n-      {\n-         if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) != 0)\n-            return;\n-\n-         else\n-            png_chunk_error(png_ptr, \"CRC error\");\n-      }\n-\n-      \/* Otherwise, we (optionally) emit a warning and use the chunk. *\/\n-      else if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) == 0)\n-         png_chunk_warning(png_ptr, \"CRC error\");\n+      png_crc_finish_critical(png_ptr, length, 1\/*handle as ancillary*\/);\n+      png_chunk_benign_error(png_ptr, errmsg);\n@@ -1077,1 +1114,0 @@\n-#endif\n@@ -1079,7 +1115,2 @@\n-   \/* TODO: png_set_PLTE has the side effect of setting png_ptr->palette to its\n-    * own copy of the palette.  This has the side effect that when png_start_row\n-    * is called (this happens after any call to png_read_update_info) the\n-    * info_ptr palette gets changed.  This is extremely unexpected and\n-    * confusing.\n-    *\n-    * Fix this by not sharing the palette in this way.\n+   \/* Because PNG_UNUSED(errmsg) does not work if all the uses are compiled out\n+    * (this does happen).\n@@ -1087,37 +1118,1 @@\n-   png_set_PLTE(png_ptr, info_ptr, palette, num);\n-\n-   \/* The three chunks, bKGD, hIST and tRNS *must* appear after PLTE and before\n-    * IDAT.  Prior to 1.6.0 this was not checked; instead the code merely\n-    * checked the apparent validity of a tRNS chunk inserted before PLTE on a\n-    * palette PNG.  1.6.0 attempts to rigorously follow the standard and\n-    * therefore does a benign error if the erroneous condition is detected *and*\n-    * cancels the tRNS if the benign error returns.  The alternative is to\n-    * amend the standard since it would be rather hypocritical of the standards\n-    * maintainers to ignore it.\n-    *\/\n-#ifdef PNG_READ_tRNS_SUPPORTED\n-   if (png_ptr->num_trans > 0 ||\n-       (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS) != 0))\n-   {\n-      \/* Cancel this because otherwise it would be used if the transforms\n-       * require it.  Don't cancel the 'valid' flag because this would prevent\n-       * detection of duplicate chunks.\n-       *\/\n-      png_ptr->num_trans = 0;\n-\n-      if (info_ptr != NULL)\n-         info_ptr->num_trans = 0;\n-\n-      png_chunk_benign_error(png_ptr, \"tRNS must be after\");\n-   }\n-#endif\n-\n-#ifdef PNG_READ_hIST_SUPPORTED\n-   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST) != 0)\n-      png_chunk_benign_error(png_ptr, \"hIST must be after\");\n-#endif\n-\n-#ifdef PNG_READ_bKGD_SUPPORTED\n-   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD) != 0)\n-      png_chunk_benign_error(png_ptr, \"bKGD must be after\");\n-#endif\n+   return errmsg != NULL ? handled_error : handled_error;\n@@ -1126,1 +1121,6 @@\n-void \/* PRIVATE *\/\n+\/* On read the IDAT chunk is always handled specially, even if marked for\n+ * unknown handling (this is allowed), so:\n+ *\/\n+#define png_handle_IDAT NULL\n+\n+static png_handle_result_code\n@@ -1131,4 +1131,0 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0 ||\n-       (png_ptr->mode & PNG_HAVE_IDAT) == 0)\n-      png_chunk_error(png_ptr, \"out of place\");\n-\n@@ -1137,2 +1133,0 @@\n-   png_crc_finish(png_ptr, length);\n-\n@@ -1142,0 +1136,3 @@\n+   png_crc_finish_critical(png_ptr, length, 1\/*handle as ancillary*\/);\n+\n+   return handled_ok;\n@@ -1146,1 +1143,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code\n@@ -1149,1 +1146,1 @@\n-   png_fixed_point igamma;\n+   png_uint_32 ugamma;\n@@ -1154,2 +1151,1 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n+   png_crc_read(png_ptr, buf, 4);\n@@ -1157,6 +1153,2 @@\n-   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n+   if (png_crc_finish(png_ptr, 0) != 0)\n+      return handled_error;\n@@ -1164,1 +1156,3 @@\n-   if (length != 4)\n+   ugamma = png_get_uint_32(buf);\n+\n+   if (ugamma > PNG_UINT_31_MAX)\n@@ -1166,1 +1160,0 @@\n-      png_crc_finish(png_ptr, length);\n@@ -1168,1 +1161,1 @@\n-      return;\n+      return handled_error;\n@@ -1171,1 +1164,1 @@\n-   png_crc_read(png_ptr, buf, 4);\n+   png_set_gAMA_fixed(png_ptr, info_ptr, (png_fixed_point)\/*SAFE*\/ugamma);\n@@ -1173,4 +1166,7 @@\n-   if (png_crc_finish(png_ptr, 0) != 0)\n-      return;\n-\n-   igamma = png_get_fixed_point(NULL, buf);\n+#ifdef PNG_READ_GAMMA_SUPPORTED\n+      \/* PNGv3: chunk precedence for gamma is cICP, [iCCP], sRGB, gAMA.  gAMA is\n+       * at the end of the chain so simply check for an unset value.\n+       *\/\n+      if (png_ptr->chunk_gamma == 0)\n+         png_ptr->chunk_gamma = (png_fixed_point)\/*SAFE*\/ugamma;\n+#endif \/*READ_GAMMA*\/\n@@ -1178,2 +1174,2 @@\n-   png_colorspace_set_gamma(png_ptr, &png_ptr->colorspace, igamma);\n-   png_colorspace_sync(png_ptr, info_ptr);\n+   return handled_ok;\n+   PNG_UNUSED(length)\n@@ -1181,0 +1177,2 @@\n+#else\n+#  define png_handle_gAMA NULL\n@@ -1184,1 +1182,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -1193,17 +1191,0 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n-\n@@ -1222,1 +1203,1 @@\n-   if (length != truelen || length > 4)\n+   if (length != truelen)\n@@ -1224,1 +1205,0 @@\n-      png_chunk_benign_error(png_ptr, \"invalid\");\n@@ -1226,1 +1206,2 @@\n-      return;\n+      png_chunk_benign_error(png_ptr, \"bad length\");\n+      return handled_error;\n@@ -1233,1 +1214,1 @@\n-      return;\n+      return handled_error;\n@@ -1240,1 +1221,1 @@\n-         return;\n+         return handled_error;\n@@ -1252,1 +1233,1 @@\n-   else\n+   else \/* grayscale *\/\n@@ -1262,0 +1243,1 @@\n+   return handled_ok;\n@@ -1263,0 +1245,2 @@\n+#else\n+#  define png_handle_sBIT NULL\n@@ -1266,2 +1250,2 @@\n-void \/* PRIVATE *\/\n-png_handle_cHRM(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n+static png_int_32\n+png_get_int_32_checked(png_const_bytep buf, int *error)\n@@ -1269,2 +1253,3 @@\n-   png_byte buf[32];\n-   png_xy xy;\n+   png_uint_32 uval = png_get_uint_32(buf);\n+   if ((uval & 0x80000000) == 0) \/* non-negative *\/\n+      return (png_int_32)uval;\n@@ -1272,1 +1257,3 @@\n-   png_debug(1, \"in png_handle_cHRM\");\n+   uval = (uval ^ 0xffffffff) + 1;  \/* 2's complement: -x = ~x+1 *\/\n+   if ((uval & 0x80000000) == 0) \/* no overflow *\/\n+      return -(png_int_32)uval;\n@@ -1274,2 +1261,6 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n+   \/* This version of png_get_int_32 has a way of returning the error to the\n+    * caller, so:\n+    *\/\n+   *error = 1;\n+   return 0; \/* Safe *\/\n+}\n@@ -1277,6 +1268,6 @@\n-   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n+static png_handle_result_code \/* PRIVATE *\/\n+png_handle_cHRM(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n+{\n+   int error = 0;\n+   png_xy xy;\n+   png_byte buf[32];\n@@ -1284,6 +1275,1 @@\n-   if (length != 32)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"invalid\");\n-      return;\n-   }\n+   png_debug(1, \"in png_handle_cHRM\");\n@@ -1294,1 +1280,1 @@\n-      return;\n+      return handled_error;\n@@ -1296,17 +1282,10 @@\n-   xy.whitex = png_get_fixed_point(NULL, buf);\n-   xy.whitey = png_get_fixed_point(NULL, buf + 4);\n-   xy.redx   = png_get_fixed_point(NULL, buf + 8);\n-   xy.redy   = png_get_fixed_point(NULL, buf + 12);\n-   xy.greenx = png_get_fixed_point(NULL, buf + 16);\n-   xy.greeny = png_get_fixed_point(NULL, buf + 20);\n-   xy.bluex  = png_get_fixed_point(NULL, buf + 24);\n-   xy.bluey  = png_get_fixed_point(NULL, buf + 28);\n-\n-   if (xy.whitex == PNG_FIXED_ERROR ||\n-       xy.whitey == PNG_FIXED_ERROR ||\n-       xy.redx   == PNG_FIXED_ERROR ||\n-       xy.redy   == PNG_FIXED_ERROR ||\n-       xy.greenx == PNG_FIXED_ERROR ||\n-       xy.greeny == PNG_FIXED_ERROR ||\n-       xy.bluex  == PNG_FIXED_ERROR ||\n-       xy.bluey  == PNG_FIXED_ERROR)\n+   xy.whitex = png_get_int_32_checked(buf +  0, &error);\n+   xy.whitey = png_get_int_32_checked(buf +  4, &error);\n+   xy.redx   = png_get_int_32_checked(buf +  8, &error);\n+   xy.redy   = png_get_int_32_checked(buf + 12, &error);\n+   xy.greenx = png_get_int_32_checked(buf + 16, &error);\n+   xy.greeny = png_get_int_32_checked(buf + 20, &error);\n+   xy.bluex  = png_get_int_32_checked(buf + 24, &error);\n+   xy.bluey  = png_get_int_32_checked(buf + 28, &error);\n+\n+   if (error)\n@@ -1314,2 +1293,2 @@\n-      png_chunk_benign_error(png_ptr, \"invalid values\");\n-      return;\n+      png_chunk_benign_error(png_ptr, \"invalid\");\n+      return handled_error;\n@@ -1318,3 +1297,6 @@\n-   \/* If a colorspace error has already been output skip this chunk *\/\n-   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)\n-      return;\n+   \/* png_set_cHRM may complain about some of the values but this doesn't matter\n+    * because it was a cHRM and it did have vaguely (if, perhaps, ridiculous)\n+    * values.  Ridiculousity will be checked if the values are used later.\n+    *\/\n+   png_set_cHRM_fixed(png_ptr, info_ptr, xy.whitex, xy.whitey, xy.redx, xy.redy,\n+         xy.greenx, xy.greeny, xy.bluex, xy.bluey);\n@@ -1322,7 +1304,10 @@\n-   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_FROM_cHRM) != 0)\n-   {\n-      png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;\n-      png_colorspace_sync(png_ptr, info_ptr);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n+   \/* We only use 'chromaticities' for RGB to gray *\/\n+#  ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n+      \/* There is no need to check sRGB here, cICP is NYI and iCCP is not\n+       * supported so just check mDCV.\n+       *\/\n+      if (!png_has_chunk(png_ptr, mDCV))\n+      {\n+         png_ptr->chromaticities = xy;\n+      }\n+#  endif \/* READ_RGB_TO_GRAY *\/\n@@ -1330,4 +1315,2 @@\n-   png_ptr->colorspace.flags |= PNG_COLORSPACE_FROM_cHRM;\n-   (void)png_colorspace_set_chromaticities(png_ptr, &png_ptr->colorspace, &xy,\n-       1\/*prefer cHRM values*\/);\n-   png_colorspace_sync(png_ptr, info_ptr);\n+   return handled_ok;\n+   PNG_UNUSED(length)\n@@ -1335,0 +1318,2 @@\n+#else\n+#  define png_handle_cHRM NULL\n@@ -1338,1 +1323,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -1345,17 +1330,0 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   if (length != 1)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"invalid\");\n-      return;\n-   }\n-\n@@ -1365,5 +1333,1 @@\n-      return;\n-\n-   \/* If a colorspace error has already been output skip this chunk *\/\n-   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)\n-      return;\n+      return handled_error;\n@@ -1371,2 +1335,4 @@\n-   \/* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect\n-    * this.\n+   \/* This checks the range of the \"rendering intent\" because it is specified in\n+    * the PNG spec itself; the \"reserved\" values will result in the chunk not\n+    * being accepted, just as they do with the various \"reserved\" values in\n+    * IHDR.\n@@ -1374,1 +1340,1 @@\n-   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_INTENT) != 0)\n+   if (intent > 3\/*PNGv3 spec*\/)\n@@ -1376,4 +1342,2 @@\n-      png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;\n-      png_colorspace_sync(png_ptr, info_ptr);\n-      png_chunk_benign_error(png_ptr, \"too many profiles\");\n-      return;\n+      png_chunk_benign_error(png_ptr, \"invalid\");\n+      return handled_error;\n@@ -1382,2 +1346,16 @@\n-   (void)png_colorspace_set_sRGB(png_ptr, &png_ptr->colorspace, intent);\n-   png_colorspace_sync(png_ptr, info_ptr);\n+   png_set_sRGB(png_ptr, info_ptr, intent);\n+   \/* NOTE: png_struct::chromaticities is not set here because the RGB to gray\n+    * coefficients are known without a need for the chromaticities.\n+    *\/\n+\n+#ifdef PNG_READ_GAMMA_SUPPORTED\n+      \/* PNGv3: chunk precedence for gamma is cICP, [iCCP], sRGB, gAMA.  iCCP is\n+       * not supported by libpng so the only requirement is to check for cICP\n+       * setting the gamma (this is NYI, but this check is safe.)\n+       *\/\n+      if (!png_has_chunk(png_ptr, cICP) || png_ptr->chunk_gamma == 0)\n+         png_ptr->chunk_gamma = PNG_GAMMA_sRGB_INVERSE;\n+#endif \/*READ_GAMMA*\/\n+\n+   return handled_ok;\n+   PNG_UNUSED(length)\n@@ -1385,0 +1363,2 @@\n+#else\n+#  define png_handle_sRGB NULL\n@@ -1388,1 +1368,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -1397,19 +1377,3 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   \/* Consistent with all the above colorspace handling an obviously *invalid*\n-    * chunk is just ignored, so does not invalidate the color space.  An\n-    * alternative is to set the 'invalid' flags at the start of this routine\n-    * and only clear them in they were not set before and all the tests pass.\n-    *\/\n-\n-   \/* The keyword must be at least one character and there is a\n-    * terminator (0) byte and the compression method byte, and the\n-    * 'zlib' datastream is at least 11 bytes.\n+   \/* PNGv3: allow PNG files with both sRGB and iCCP because the PNG spec only\n+    * ever said that there \"should\" be only one, not \"shall\" and the PNGv3\n+    * colour chunk precedence rules give a handling for this case anyway.\n@@ -1417,18 +1381,0 @@\n-   if (length < 14)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"too short\");\n-      return;\n-   }\n-\n-   \/* If a colorspace error has already been output skip this chunk *\/\n-   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      return;\n-   }\n-\n-   \/* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect\n-    * this.\n-    *\/\n-   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_INTENT) == 0)\n@@ -1444,1 +1390,1 @@\n-         read_length = (uInt)length;\n+         read_length = (uInt)\/*SAFE*\/length;\n@@ -1449,4 +1395,1 @@\n-      \/* The minimum 'zlib' stream is assumed to be just the 2 byte header,\n-       * 5 bytes minimum 'deflate' stream, and the 4 byte checksum.\n-       *\/\n-      if (length < 11)\n+      if (length < LZ77Min)\n@@ -1456,1 +1399,1 @@\n-         return;\n+         return handled_error;\n@@ -1493,2 +1436,2 @@\n-                  if (png_icc_check_length(png_ptr, &png_ptr->colorspace,\n-                      keyword, profile_length) != 0)\n+                  if (png_icc_check_length(png_ptr, keyword, profile_length) !=\n+                      0)\n@@ -1499,3 +1442,2 @@\n-                     if (png_icc_check_header(png_ptr, &png_ptr->colorspace,\n-                         keyword, profile_length, profile_header,\n-                         png_ptr->color_type) != 0)\n+                     if (png_icc_check_header(png_ptr, keyword, profile_length,\n+                              profile_header, png_ptr->color_type) != 0)\n@@ -1511,1 +1453,1 @@\n-                            profile_length, 2\/*silent*\/);\n+                              profile_length);\n@@ -1530,2 +1472,1 @@\n-                                  &png_ptr->colorspace, keyword, profile_length,\n-                                  profile) != 0)\n+                                       keyword, profile_length, profile) != 0)\n@@ -1563,7 +1504,0 @@\n-# if defined(PNG_sRGB_SUPPORTED) && PNG_sRGB_PROFILE_CHECKS >= 0\n-                                    \/* Check for a match against sRGB *\/\n-                                    png_icc_set_sRGB(png_ptr,\n-                                        &png_ptr->colorspace, profile,\n-                                        png_ptr->zstream.adler);\n-# endif\n-\n@@ -1592,3 +1526,0 @@\n-                                       {\n-                                          png_ptr->colorspace.flags |=\n-                                             PNG_COLORSPACE_INVALID;\n@@ -1596,1 +1527,0 @@\n-                                       }\n@@ -1604,3 +1534,0 @@\n-                                    if (info_ptr != NULL)\n-                                       png_colorspace_sync(png_ptr, info_ptr);\n-\n@@ -1610,1 +1537,1 @@\n-                                       return;\n+                                       return handled_ok;\n@@ -1651,3 +1578,0 @@\n-   else\n-      errmsg = \"too many profiles\";\n-\n@@ -1658,2 +1582,0 @@\n-   png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;\n-   png_colorspace_sync(png_ptr, info_ptr);\n@@ -1662,0 +1584,2 @@\n+\n+   return handled_error;\n@@ -1663,0 +1587,2 @@\n+#else\n+#  define png_handle_iCCP NULL\n@@ -1666,1 +1592,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -1687,1 +1613,1 @@\n-         return;\n+         return handled_error;\n@@ -1694,1 +1620,1 @@\n-         return;\n+         return handled_error;\n@@ -1699,20 +1625,1 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-#ifdef PNG_MAX_MALLOC_64K\n-   if (length > 65535U)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"too large to fit in memory\");\n-      return;\n-   }\n-#endif\n-\n-   buffer = png_read_buffer(png_ptr, length+1, 2\/*silent*\/);\n+   buffer = png_read_buffer(png_ptr, length+1);\n@@ -1723,1 +1630,1 @@\n-      return;\n+      return handled_error;\n@@ -1734,1 +1641,1 @@\n-      return;\n+      return handled_error;\n@@ -1747,1 +1654,1 @@\n-      return;\n+      return handled_error;\n@@ -1761,1 +1668,1 @@\n-      return;\n+      return handled_error;\n@@ -1770,1 +1677,1 @@\n-      return;\n+      return handled_error;\n@@ -1781,1 +1688,1 @@\n-      return;\n+      return handled_error;\n@@ -1784,1 +1691,0 @@\n-#ifdef PNG_POINTER_INDEXING_SUPPORTED\n@@ -1807,25 +1713,0 @@\n-#else\n-   pp = new_palette.entries;\n-\n-   for (i = 0; i < new_palette.nentries; i++)\n-   {\n-\n-      if (new_palette.depth == 8)\n-      {\n-         pp[i].red   = *entry_start++;\n-         pp[i].green = *entry_start++;\n-         pp[i].blue  = *entry_start++;\n-         pp[i].alpha = *entry_start++;\n-      }\n-\n-      else\n-      {\n-         pp[i].red   = png_get_uint_16(entry_start); entry_start += 2;\n-         pp[i].green = png_get_uint_16(entry_start); entry_start += 2;\n-         pp[i].blue  = png_get_uint_16(entry_start); entry_start += 2;\n-         pp[i].alpha = png_get_uint_16(entry_start); entry_start += 2;\n-      }\n-\n-      pp[i].frequency = png_get_uint_16(entry_start); entry_start += 2;\n-   }\n-#endif\n@@ -1839,0 +1720,1 @@\n+   return handled_ok;\n@@ -1840,0 +1722,2 @@\n+#else\n+#  define png_handle_sPLT NULL\n@@ -1843,1 +1727,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -1850,17 +1734,0 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n-\n@@ -1875,1 +1742,1 @@\n-         return;\n+         return handled_error;\n@@ -1891,1 +1758,1 @@\n-         return;\n+         return handled_error;\n@@ -1905,1 +1772,0 @@\n-         \/* TODO: is this actually an error in the ISO spec? *\/\n@@ -1908,1 +1774,1 @@\n-         return;\n+         return handled_error;\n@@ -1917,1 +1783,1 @@\n-         return;\n+         return handled_error;\n@@ -1928,1 +1794,1 @@\n-      return;\n+      return handled_error;\n@@ -1934,1 +1800,1 @@\n-      return;\n+      return handled_error;\n@@ -1943,0 +1809,1 @@\n+   return handled_ok;\n@@ -1944,0 +1811,2 @@\n+#else\n+#  define png_handle_tRNS NULL\n@@ -1947,1 +1816,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -1956,13 +1825,1 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0 ||\n-       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&\n-       (png_ptr->mode & PNG_HAVE_PLTE) == 0))\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD) != 0)\n+   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n@@ -1970,4 +1827,6 @@\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n+      if ((png_ptr->mode & PNG_HAVE_PLTE) == 0)\n+      {\n+         png_crc_finish(png_ptr, length);\n+         png_chunk_benign_error(png_ptr, \"out of place\");\n+         return handled_error;\n+      }\n@@ -1975,1 +1834,0 @@\n-   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n@@ -1977,0 +1835,1 @@\n+   }\n@@ -1988,1 +1847,1 @@\n-      return;\n+      return handled_error;\n@@ -1994,1 +1853,1 @@\n-      return;\n+      return handled_error;\n@@ -2010,1 +1869,1 @@\n-            return;\n+            return handled_error;\n@@ -2031,1 +1890,1 @@\n-            return;\n+            return handled_error;\n@@ -2049,1 +1908,1 @@\n-            return;\n+            return handled_error;\n@@ -2061,0 +1920,117 @@\n+   return handled_ok;\n+}\n+#else\n+#  define png_handle_bKGD NULL\n+#endif\n+\n+#ifdef PNG_READ_cICP_SUPPORTED\n+static png_handle_result_code \/* PRIVATE *\/\n+png_handle_cICP(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n+{\n+   png_byte buf[4];\n+\n+   png_debug(1, \"in png_handle_cICP\");\n+\n+   png_crc_read(png_ptr, buf, 4);\n+\n+   if (png_crc_finish(png_ptr, 0) != 0)\n+      return handled_error;\n+\n+   png_set_cICP(png_ptr, info_ptr, buf[0], buf[1],  buf[2], buf[3]);\n+\n+   \/* We only use 'chromaticities' for RGB to gray *\/\n+#  ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n+      if (!png_has_chunk(png_ptr, mDCV))\n+      {\n+         \/* TODO: png_ptr->chromaticities = chromaticities; *\/\n+      }\n+#  endif \/* READ_RGB_TO_GRAY *\/\n+\n+#ifdef PNG_READ_GAMMA_SUPPORTED\n+      \/* PNGv3: chunk precedence for gamma is cICP, [iCCP], sRGB, gAMA.  cICP is\n+       * at the head so simply set the gamma if it can be determined.  If not\n+       * chunk_gamma remains unchanged; sRGB and gAMA handling check it for\n+       * being zero.\n+       *\/\n+      \/* TODO: set png_struct::chunk_gamma when possible *\/\n+#endif \/*READ_GAMMA*\/\n+\n+   return handled_ok;\n+   PNG_UNUSED(length)\n+}\n+#else\n+#  define png_handle_cICP NULL\n+#endif\n+\n+#ifdef PNG_READ_cLLI_SUPPORTED\n+static png_handle_result_code \/* PRIVATE *\/\n+png_handle_cLLI(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n+{\n+   png_byte buf[8];\n+\n+   png_debug(1, \"in png_handle_cLLI\");\n+\n+   png_crc_read(png_ptr, buf, 8);\n+\n+   if (png_crc_finish(png_ptr, 0) != 0)\n+      return handled_error;\n+\n+   \/* The error checking happens here, this puts it in just one place: *\/\n+   png_set_cLLI_fixed(png_ptr, info_ptr, png_get_uint_32(buf),\n+         png_get_uint_32(buf+4));\n+   return handled_ok;\n+   PNG_UNUSED(length)\n+}\n+#else\n+#  define png_handle_cLLI NULL\n+#endif\n+\n+#ifdef PNG_READ_mDCV_SUPPORTED\n+static png_handle_result_code \/* PRIVATE *\/\n+png_handle_mDCV(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n+{\n+   png_xy chromaticities;\n+   png_byte buf[24];\n+\n+   png_debug(1, \"in png_handle_mDCV\");\n+\n+   png_crc_read(png_ptr, buf, 24);\n+\n+   if (png_crc_finish(png_ptr, 0) != 0)\n+      return handled_error;\n+\n+   \/* The error checking happens here, this puts it in just one place.  The\n+    * odd \/50000 scaling factor makes it more difficult but the (x.y) values are\n+    * only two bytes so a <<1 is safe.\n+    *\n+    * WARNING: the PNG specification defines the cHRM chunk to **start** with\n+    * the white point (x,y).  The W3C PNG v3 specification puts the white point\n+    * **after* R,G,B.  The x,y values in mDCV are also scaled by 50,000 and\n+    * stored in just two bytes, whereas those in cHRM are scaled by 100,000 and\n+    * stored in four bytes.  This is very, very confusing.  These APIs remove\n+    * the confusion by copying the existing, well established, API.\n+    *\/\n+   chromaticities.redx   = png_get_uint_16(buf+ 0U) << 1; \/* red x *\/\n+   chromaticities.redy   = png_get_uint_16(buf+ 2U) << 1; \/* red y *\/\n+   chromaticities.greenx = png_get_uint_16(buf+ 4U) << 1; \/* green x *\/\n+   chromaticities.greeny = png_get_uint_16(buf+ 6U) << 1; \/* green y *\/\n+   chromaticities.bluex  = png_get_uint_16(buf+ 8U) << 1; \/* blue x *\/\n+   chromaticities.bluey  = png_get_uint_16(buf+10U) << 1; \/* blue y *\/\n+   chromaticities.whitex = png_get_uint_16(buf+12U) << 1; \/* white x *\/\n+   chromaticities.whitey = png_get_uint_16(buf+14U) << 1; \/* white y *\/\n+\n+   png_set_mDCV_fixed(png_ptr, info_ptr,\n+         chromaticities.whitex, chromaticities.whitey,\n+         chromaticities.redx, chromaticities.redy,\n+         chromaticities.greenx, chromaticities.greeny,\n+         chromaticities.bluex, chromaticities.bluey,\n+         png_get_uint_32(buf+16U), \/* peak luminance *\/\n+         png_get_uint_32(buf+20U));\/* minimum perceivable luminance *\/\n+\n+   \/* We only use 'chromaticities' for RGB to gray *\/\n+#  ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n+      png_ptr->chromaticities = chromaticities;\n+#  endif \/* READ_RGB_TO_GRAY *\/\n+\n+   return handled_ok;\n+   PNG_UNUSED(length)\n@@ -2062,0 +2038,2 @@\n+#else\n+#  define png_handle_mDCV NULL\n@@ -2065,1 +2043,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2068,1 +2046,1 @@\n-   unsigned int i;\n+   png_bytep buffer = NULL;\n@@ -2072,9 +2050,1 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   if (length < 2)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"too short\");\n-      return;\n-   }\n+   buffer = png_read_buffer(png_ptr, length);\n@@ -2082,1 +2052,1 @@\n-   else if (info_ptr == NULL || (info_ptr->valid & PNG_INFO_eXIf) != 0)\n+   if (buffer == NULL)\n@@ -2085,2 +2055,2 @@\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n+      png_chunk_benign_error(png_ptr, \"out of memory\");\n+      return handled_error;\n@@ -2089,1 +2059,1 @@\n-   info_ptr->free_me |= PNG_FREE_EXIF;\n+   png_crc_read(png_ptr, buffer, length);\n@@ -2091,2 +2061,2 @@\n-   info_ptr->eXIf_buf = png_voidcast(png_bytep,\n-             png_malloc_warn(png_ptr, length));\n+   if (png_crc_finish(png_ptr, 0) != 0)\n+      return handled_error;\n@@ -2094,1 +2064,4 @@\n-   if (info_ptr->eXIf_buf == NULL)\n+   \/* PNGv3: the code used to check the byte order mark at the start for MM or\n+    * II, however PNGv3 states that the the first 4 bytes should be checked.\n+    * The caller ensures that there are four bytes available.\n+    *\/\n@@ -2096,4 +2069,1 @@\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of memory\");\n-      return;\n-   }\n+      png_uint_32 header = png_get_uint_32(buffer);\n@@ -2101,6 +2071,2 @@\n-   for (i = 0; i < length; i++)\n-   {\n-      png_byte buf[1];\n-      png_crc_read(png_ptr, buf, 1);\n-      info_ptr->eXIf_buf[i] = buf[0];\n-      if (i == 1)\n+      \/* These numbers are copied from the PNGv3 spec: *\/\n+      if (header != 0x49492A00 && header != 0x4D4D002A)\n@@ -2108,9 +2074,2 @@\n-         if ((buf[0] != 'M' && buf[0] != 'I') ||\n-             (info_ptr->eXIf_buf[0] != buf[0]))\n-         {\n-            png_crc_finish(png_ptr, length - 2);\n-            png_chunk_benign_error(png_ptr, \"incorrect byte-order specifier\");\n-            png_free(png_ptr, info_ptr->eXIf_buf);\n-            info_ptr->eXIf_buf = NULL;\n-            return;\n-         }\n+         png_chunk_benign_error(png_ptr, \"invalid\");\n+         return handled_error;\n@@ -2120,5 +2079,2 @@\n-   if (png_crc_finish(png_ptr, 0) == 0)\n-      png_set_eXIf_1(png_ptr, info_ptr, length, info_ptr->eXIf_buf);\n-\n-   png_free(png_ptr, info_ptr->eXIf_buf);\n-   info_ptr->eXIf_buf = NULL;\n+   png_set_eXIf_1(png_ptr, info_ptr, length, buffer);\n+   return handled_ok;\n@@ -2126,0 +2082,2 @@\n+#else\n+#  define png_handle_eXIf NULL\n@@ -2129,1 +2087,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2137,19 +2095,7 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0 ||\n-       (png_ptr->mode & PNG_HAVE_PLTE) == 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n-\n-   num = length \/ 2 ;\n+   \/* This cast is safe because the chunk definition limits the length to a\n+    * maximum of 1024 bytes.\n+    *\n+    * TODO: maybe use png_uint_32 anyway, not unsigned int, to reduce the\n+    * casts.\n+    *\/\n+   num = (unsigned int)length \/ 2 ;\n@@ -2163,1 +2109,1 @@\n-      return;\n+      return handled_error;\n@@ -2175,1 +2121,1 @@\n-      return;\n+      return handled_error;\n@@ -2178,0 +2124,1 @@\n+   return handled_ok;\n@@ -2179,0 +2126,2 @@\n+#else\n+#  define png_handle_hIST NULL\n@@ -2182,1 +2131,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2191,24 +2140,0 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n-\n-   if (length != 9)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"invalid\");\n-      return;\n-   }\n-\n@@ -2218,1 +2143,1 @@\n-      return;\n+      return handled_error;\n@@ -2224,0 +2149,2 @@\n+   return handled_ok;\n+   PNG_UNUSED(length)\n@@ -2225,0 +2152,2 @@\n+#else\n+#  define png_handle_pHYs NULL\n@@ -2228,1 +2157,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2237,24 +2166,0 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n-\n-   if (length != 9)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"invalid\");\n-      return;\n-   }\n-\n@@ -2264,1 +2169,1 @@\n-      return;\n+      return handled_error;\n@@ -2270,0 +2175,2 @@\n+   return handled_ok;\n+   PNG_UNUSED(length)\n@@ -2271,0 +2178,2 @@\n+#else\n+#  define png_handle_oFFs NULL\n@@ -2275,1 +2184,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2285,18 +2194,0 @@\n-\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n-\n@@ -2306,1 +2197,1 @@\n-   buffer = png_read_buffer(png_ptr, length+1, 2\/*silent*\/);\n+   buffer = png_read_buffer(png_ptr, length+1);\n@@ -2312,1 +2203,1 @@\n-      return;\n+      return handled_error;\n@@ -2318,1 +2209,1 @@\n-      return;\n+      return handled_error;\n@@ -2334,1 +2225,1 @@\n-      return;\n+      return handled_error;\n@@ -2354,1 +2245,1 @@\n-      return;\n+      return handled_error;\n@@ -2373,1 +2264,1 @@\n-      return;\n+      return handled_error;\n@@ -2391,1 +2282,1 @@\n-         return;\n+         return handled_error;\n@@ -2398,0 +2289,6 @@\n+   \/* TODO: BUG: png_set_pCAL calls png_chunk_report which, in this case, calls\n+    * png_benign_error and that can error out.\n+    *\n+    * png_read_buffer needs to be allocated with space for both nparams and the\n+    * parameter strings.  Not hard to do.\n+    *\/\n@@ -2399,0 +2296,1 @@\n+   return handled_ok;\n@@ -2400,0 +2298,2 @@\n+#else\n+#  define png_handle_pCAL NULL\n@@ -2404,1 +2304,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2412,26 +2312,0 @@\n-\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n-\n-   \/* Need unit type, width, \\0, height: minimum 4 bytes *\/\n-   else if (length < 4)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"invalid\");\n-      return;\n-   }\n-\n@@ -2441,1 +2315,1 @@\n-   buffer = png_read_buffer(png_ptr, length+1, 2\/*silent*\/);\n+   buffer = png_read_buffer(png_ptr, length+1);\n@@ -2445,1 +2319,0 @@\n-      png_chunk_benign_error(png_ptr, \"out of memory\");\n@@ -2447,1 +2320,2 @@\n-      return;\n+      png_chunk_benign_error(png_ptr, \"out of memory\");\n+      return handled_error;\n@@ -2454,1 +2328,1 @@\n-      return;\n+      return handled_error;\n@@ -2460,1 +2334,1 @@\n-      return;\n+      return handled_error;\n@@ -2489,0 +2363,1 @@\n+      {\n@@ -2492,0 +2367,2 @@\n+         return handled_ok;\n+      }\n@@ -2493,0 +2370,2 @@\n+\n+   return handled_error;\n@@ -2494,0 +2373,2 @@\n+#else\n+#  define png_handle_sCAL NULL\n@@ -2497,1 +2378,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2505,10 +2386,4 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n-\n+   \/* TODO: what is this doing here?  It should be happened in pngread.c and\n+    * pngpread.c, although it could be moved to png_handle_chunk below and\n+    * thereby avoid some code duplication.\n+    *\/\n@@ -2518,7 +2393,0 @@\n-   if (length != 7)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"invalid\");\n-      return;\n-   }\n-\n@@ -2528,1 +2396,1 @@\n-      return;\n+      return handled_error;\n@@ -2538,0 +2406,2 @@\n+   return handled_ok;\n+   PNG_UNUSED(length)\n@@ -2539,0 +2409,2 @@\n+#else\n+#  define png_handle_tIME NULL\n@@ -2543,1 +2415,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2560,1 +2432,1 @@\n-         return;\n+         return handled_error;\n@@ -2567,1 +2439,1 @@\n-         return;\n+         return handled_error;\n@@ -2572,16 +2444,1 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-      png_ptr->mode |= PNG_AFTER_IDAT;\n-\n-#ifdef PNG_MAX_MALLOC_64K\n-   if (length > 65535U)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"too large to fit in memory\");\n-      return;\n-   }\n-#endif\n-\n-   buffer = png_read_buffer(png_ptr, length+1, 1\/*warn*\/);\n+   buffer = png_read_buffer(png_ptr, length+1);\n@@ -2591,0 +2448,1 @@\n+      png_crc_finish(png_ptr, length);\n@@ -2592,1 +2450,1 @@\n-      return;\n+      return handled_error;\n@@ -2598,1 +2456,1 @@\n-      return;\n+      return handled_error;\n@@ -2617,2 +2475,5 @@\n-   if (png_set_text_2(png_ptr, info_ptr, &text_info, 1) != 0)\n-      png_warning(png_ptr, \"Insufficient memory to process text chunk\");\n+   if (png_set_text_2(png_ptr, info_ptr, &text_info, 1) == 0)\n+      return handled_ok;\n+\n+   png_chunk_benign_error(png_ptr, \"out of memory\");\n+   return handled_error;\n@@ -2620,0 +2481,2 @@\n+#else\n+#  define png_handle_tEXt NULL\n@@ -2624,1 +2487,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2639,1 +2502,1 @@\n-         return;\n+         return handled_error;\n@@ -2646,1 +2509,1 @@\n-         return;\n+         return handled_error;\n@@ -2651,6 +2514,0 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-      png_ptr->mode |= PNG_AFTER_IDAT;\n-\n@@ -2658,1 +2515,2 @@\n-    * a null terminator later.\n+    * a null terminator later.  The limit check in png_handle_chunk should be\n+    * sufficient.\n@@ -2660,1 +2518,1 @@\n-   buffer = png_read_buffer(png_ptr, length, 2\/*silent*\/);\n+   buffer = png_read_buffer(png_ptr, length);\n@@ -2666,1 +2524,1 @@\n-      return;\n+      return handled_error;\n@@ -2672,1 +2530,1 @@\n-      return;\n+      return handled_error;\n@@ -2725,2 +2583,4 @@\n-            if (png_set_text_2(png_ptr, info_ptr, &text, 1) != 0)\n-               errmsg = \"insufficient memory\";\n+            if (png_set_text_2(png_ptr, info_ptr, &text, 1) == 0)\n+               return handled_ok;\n+\n+            errmsg = \"out of memory\";\n@@ -2734,2 +2594,2 @@\n-   if (errmsg != NULL)\n-      png_chunk_benign_error(png_ptr, errmsg);\n+   png_chunk_benign_error(png_ptr, errmsg);\n+   return handled_error;\n@@ -2737,0 +2597,2 @@\n+#else\n+#  define png_handle_zTXt NULL\n@@ -2741,1 +2603,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2756,1 +2618,1 @@\n-         return;\n+         return handled_error;\n@@ -2763,1 +2625,1 @@\n-         return;\n+         return handled_error;\n@@ -2768,7 +2630,1 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-      png_ptr->mode |= PNG_AFTER_IDAT;\n-\n-   buffer = png_read_buffer(png_ptr, length+1, 1\/*warn*\/);\n+   buffer = png_read_buffer(png_ptr, length+1);\n@@ -2780,1 +2636,1 @@\n-      return;\n+      return handled_error;\n@@ -2786,1 +2642,1 @@\n-      return;\n+      return handled_error;\n@@ -2876,2 +2732,4 @@\n-         if (png_set_text_2(png_ptr, info_ptr, &text, 1) != 0)\n-            errmsg = \"insufficient memory\";\n+         if (png_set_text_2(png_ptr, info_ptr, &text, 1) == 0)\n+            return handled_ok;\n+\n+         errmsg = \"out of memory\";\n@@ -2886,0 +2744,1 @@\n+   return handled_error;\n@@ -2887,0 +2746,2 @@\n+#else\n+#  define png_handle_iTXt NULL\n@@ -2894,1 +2755,1 @@\n-   png_alloc_size_t limit = PNG_SIZE_MAX;\n+   const png_alloc_size_t limit = png_chunk_max(png_ptr);\n@@ -2902,10 +2763,0 @@\n-#  ifdef PNG_SET_USER_LIMITS_SUPPORTED\n-   if (png_ptr->user_chunk_malloc_max > 0 &&\n-       png_ptr->user_chunk_malloc_max < limit)\n-      limit = png_ptr->user_chunk_malloc_max;\n-\n-#  elif PNG_USER_CHUNK_MALLOC_MAX > 0\n-   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n-      limit = PNG_USER_CHUNK_MALLOC_MAX;\n-#  endif\n-\n@@ -2950,1 +2801,1 @@\n-void \/* PRIVATE *\/\n+png_handle_result_code \/*PRIVATE*\/\n@@ -2954,1 +2805,1 @@\n-   int handled = 0; \/* the chunk was handled *\/\n+   png_handle_result_code handled = handled_discarded; \/* the default *\/\n@@ -3001,1 +2852,1 @@\n-         if (ret < 0)\n+         if (ret < 0) \/* handled_error *\/\n@@ -3035,1 +2886,1 @@\n-            handled = 1;\n+            handled = handled_ok;\n@@ -3120,1 +2971,1 @@\n-            handled = 1;\n+            handled = handled_saved;\n@@ -3146,1 +2997,1 @@\n-   if (handled == 0 && PNG_CHUNK_CRITICAL(png_ptr->chunk_name))\n+   if (handled < handled_saved && PNG_CHUNK_CRITICAL(png_ptr->chunk_name))\n@@ -3148,0 +2999,2 @@\n+\n+   return handled;\n@@ -3150,5 +3003,8 @@\n-\/* This function is called to verify that a chunk name is valid.\n- * This function can't have the \"critical chunk check\" incorporated\n- * into it, since in the future we will need to be able to call user\n- * functions to handle unknown critical chunks after we check that\n- * the chunk name itself is valid.\n+\/* APNG handling: the minimal implementation of APNG handling in libpng 1.6\n+ * requires that those significant applications which already handle APNG not\n+ * get hosed.  To do this ensure the code here will have to ensure than APNG\n+ * data by default (at least in 1.6) gets stored in the unknown chunk list.\n+ * Maybe this can be relaxed in a few years but at present it's just the only\n+ * safe way.\n+ *\n+ * ATM just cause unknown handling for all three chunks:\n@@ -3156,0 +3012,3 @@\n+#define png_handle_acTL NULL\n+#define png_handle_fcTL NULL\n+#define png_handle_fdAT NULL\n@@ -3157,1 +3016,2 @@\n-\/* Bit hacking: the test for an invalid byte in the 4 byte chunk name is:\n+\/*\n+ * 1.6.47: This is the new table driven interface to all the chunk handling.\n@@ -3159,1 +3019,7 @@\n- * ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))\n+ * The table describes the PNG standard rules for **reading** known chunks -\n+ * every chunk which has an entry in PNG_KNOWN_CHUNKS.  The table contains an\n+ * entry for each PNG_INDEX_cHNK describing the rules.\n+ *\n+ * In this initial version the only information in the entry is the\n+ * png_handle_cHNK function for the chunk in question.  When chunk support is\n+ * compiled out the entry will be NULL.\n@@ -3161,3 +3027,1 @@\n-\n-void \/* PRIVATE *\/\n-png_check_chunk_name(png_const_structrp png_ptr, png_uint_32 chunk_name)\n+static const struct\n@@ -3165,4 +3029,5 @@\n-   int i;\n-   png_uint_32 cn=chunk_name;\n-\n-   png_debug(1, \"in png_check_chunk_name\");\n+   png_handle_result_code (*handler)(\n+         png_structrp, png_inforp, png_uint_32 length);\n+      \/* A chunk-specific 'handler', NULL if the chunk is not supported in this\n+       * build.\n+       *\/\n@@ -3170,1 +3035,100 @@\n-   for (i=1; i<=4; ++i)\n+   \/* Crushing these values helps on modern 32-bit architectures because the\n+    * pointer and the following bit fields both end up requiring 32 bits.\n+    * Typically this will halve the table size.  On 64-bit architectures the\n+    * table entries will typically be 8 bytes.\n+    *\/\n+   png_uint_32 max_length :12; \/* Length min, max in bytes *\/\n+   png_uint_32 min_length :8;\n+      \/* Length errors on critical chunks have special handling to preserve the\n+       * existing behaviour in libpng 1.6.  Anciallary chunks are checked below\n+       * and produce a 'benign' error.\n+       *\/\n+   png_uint_32 pos_before :4; \/* PNG_HAVE_ values chunk must precede *\/\n+   png_uint_32 pos_after  :4; \/* PNG_HAVE_ values chunk must follow *\/\n+      \/* NOTE: PLTE, tRNS and bKGD require special handling which depends on\n+       * the colour type of the base image.\n+       *\/\n+   png_uint_32 multiple   :1; \/* Multiple occurences permitted *\/\n+      \/* This is enabled for PLTE because PLTE may, in practice, be optional *\/\n+}\n+read_chunks[PNG_INDEX_unknown] =\n+{\n+   \/* Definitions as above but done indirectly by #define so that\n+    * PNG_KNOWN_CHUNKS can be used safely to build the table in order.\n+    *\n+    * Each CDcHNK definition lists the values for the parameters **after**\n+    * the first, 'handler', function.  'handler' is NULL when the chunk has no\n+    * compiled in support.\n+    *\/\n+#  define NoCheck 0x801U      \/* Do not check the maximum length *\/\n+#  define Limit   0x802U      \/* Limit to png_chunk_max bytes *\/\n+#  define LKMin   3U+LZ77Min  \/* Minimum length of keyword+LZ77 *\/\n+\n+#define hIHDR PNG_HAVE_IHDR\n+#define hPLTE PNG_HAVE_PLTE\n+#define hIDAT PNG_HAVE_IDAT\n+   \/* For the two chunks, tRNS and bKGD which can occur in PNGs without a PLTE\n+    * but must occur after the PLTE use this and put the check in the handler\n+    * routine for colour mapped images were PLTE is required.  Also put a check\n+    * in PLTE for other image types to drop the PLTE if tRNS or bKGD have been\n+    * seen.\n+    *\/\n+#define hCOL  (PNG_HAVE_PLTE|PNG_HAVE_IDAT)\n+   \/* Used for the decoding chunks which must be before PLTE. *\/\n+#define aIDAT PNG_AFTER_IDAT\n+\n+   \/* Chunks from W3C PNG v3: *\/\n+   \/*       cHNK  max_len,   min, before, after, multiple *\/\n+#  define CDIHDR      13U,   13U,  hIHDR,     0,        0\n+#  define CDPLTE  NoCheck,    0U,      0, hIHDR,        1\n+      \/* PLTE errors are only critical for colour-map images, consequently the\n+       * hander does all the checks.\n+       *\/\n+#  define CDIDAT  NoCheck,    0U,  aIDAT, hIHDR,        1\n+#  define CDIEND  NoCheck,    0U,      0, aIDAT,        0\n+      \/* Historically data was allowed in IEND *\/\n+#  define CDtRNS     256U,    0U,  hIDAT, hIHDR,        0\n+#  define CDcHRM      32U,   32U,   hCOL, hIHDR,        0\n+#  define CDgAMA       4U,    4U,   hCOL, hIHDR,        0\n+#  define CDiCCP  NoCheck, LKMin,   hCOL, hIHDR,        0\n+#  define CDsBIT       4U,    1U,   hCOL, hIHDR,        0\n+#  define CDsRGB       1U,    1U,   hCOL, hIHDR,        0\n+#  define CDcICP       4U,    4U,   hCOL, hIHDR,        0\n+#  define CDmDCV      24U,   24U,   hCOL, hIHDR,        0\n+#  define CDeXIf    Limit,    4U,      0, hIHDR,        0\n+#  define CDcLLI       8U,    8U,   hCOL, hIHDR,        0\n+#  define CDtEXt  NoCheck,    2U,      0, hIHDR,        1\n+      \/* Allocates 'length+1'; checked in the handler *\/\n+#  define CDzTXt    Limit, LKMin,      0, hIHDR,        1\n+#  define CDiTXt  NoCheck,    6U,      0, hIHDR,        1\n+      \/* Allocates 'length+1'; checked in the handler *\/\n+#  define CDbKGD       6U,    1U,  hIDAT, hIHDR,        0\n+#  define CDhIST    1024U,    0U,  hPLTE, hIHDR,        0\n+#  define CDpHYs       9U,    9U,  hIDAT, hIHDR,        0\n+#  define CDsPLT  NoCheck,    3U,  hIDAT, hIHDR,        1\n+      \/* Allocates 'length+1'; checked in the handler *\/\n+#  define CDtIME       7U,    7U,      0, hIHDR,        0\n+#  define CDacTL       8U,    8U,  hIDAT, hIHDR,        0\n+#  define CDfcTL      25U,   26U,      0, hIHDR,        1\n+#  define CDfdAT    Limit,    4U,  hIDAT, hIHDR,        1\n+   \/* Supported chunks from PNG extensions 1.5.0, NYI so limit *\/\n+#  define CDoFFs       9U,    9U,  hIDAT, hIHDR,        0\n+#  define CDpCAL  NoCheck,   14U,  hIDAT, hIHDR,        0\n+      \/* Allocates 'length+1'; checked in the handler *\/\n+#  define CDsCAL    Limit,    4U,  hIDAT, hIHDR,        0\n+      \/* Allocates 'length+1'; checked in the handler *\/\n+\n+#  define PNG_CHUNK(cHNK, index) { png_handle_ ## cHNK, CD ## cHNK },\n+   PNG_KNOWN_CHUNKS\n+#  undef PNG_CHUNK\n+};\n+\n+\n+static png_index\n+png_chunk_index_from_name(png_uint_32 chunk_name)\n+{\n+   \/* For chunk png_cHNK return PNG_INDEX_cHNK.  Return PNG_INDEX_unknown if\n+    * chunk_name is not known.  Notice that in a particular build \"known\" does\n+    * not necessarily mean \"supported\", although the inverse applies.\n+    *\/\n+   switch (chunk_name)\n@@ -3172,1 +3136,4 @@\n-      int c = cn & 0xff;\n+#     define PNG_CHUNK(cHNK, index)\\\n+         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; \/* == index *\/\n+\n+      PNG_KNOWN_CHUNKS\n@@ -3174,2 +3141,1 @@\n-      if (c < 65 || c > 122 || (c > 90 && c < 97))\n-         png_chunk_error(png_ptr, \"invalid chunk type\");\n+#     undef PNG_CHUNK\n@@ -3177,1 +3143,1 @@\n-      cn >>= 8;\n+      default: return PNG_INDEX_unknown;\n@@ -3181,2 +3147,2 @@\n-void \/* PRIVATE *\/\n-png_check_chunk_length(png_const_structrp png_ptr, png_uint_32 length)\n+png_handle_result_code \/*PRIVATE*\/\n+png_handle_chunk(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n@@ -3184,11 +3150,16 @@\n-   png_alloc_size_t limit = PNG_UINT_31_MAX;\n-\n-# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n-   if (png_ptr->user_chunk_malloc_max > 0 &&\n-       png_ptr->user_chunk_malloc_max < limit)\n-      limit = png_ptr->user_chunk_malloc_max;\n-# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n-   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n-      limit = PNG_USER_CHUNK_MALLOC_MAX;\n-# endif\n-   if (png_ptr->chunk_name == png_IDAT)\n+   \/* CSE: these things don't change, these autos are just to save typing and\n+    * make the code more clear.\n+    *\/\n+   const png_uint_32 chunk_name = png_ptr->chunk_name;\n+   const png_index chunk_index = png_chunk_index_from_name(chunk_name);\n+\n+   png_handle_result_code handled = handled_error;\n+   png_const_charp errmsg = NULL;\n+\n+   \/* Is this a known chunk?  If not there are no checks performed here;\n+    * png_handle_unknown does the correct checks.  This means that the values\n+    * for known but unsupported chunks in the above table are not used here\n+    * however the chunks_seen fields in png_struct are still set.\n+    *\/\n+   if (chunk_index == PNG_INDEX_unknown ||\n+       read_chunks[chunk_index].handler == NULL)\n@@ -3196,15 +3167,82 @@\n-      png_alloc_size_t idat_limit = PNG_UINT_31_MAX;\n-      size_t row_factor =\n-         (size_t)png_ptr->width\n-         * (size_t)png_ptr->channels\n-         * (png_ptr->bit_depth > 8? 2: 1)\n-         + 1\n-         + (png_ptr->interlaced? 6: 0);\n-      if (png_ptr->height > PNG_UINT_32_MAX\/row_factor)\n-         idat_limit = PNG_UINT_31_MAX;\n-      else\n-         idat_limit = png_ptr->height * row_factor;\n-      row_factor = row_factor > 32566? 32566 : row_factor;\n-      idat_limit += 6 + 5*(idat_limit\/row_factor+1); \/* zlib+deflate overhead *\/\n-      idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;\n-      limit = limit < idat_limit? idat_limit : limit;\n+      handled = png_handle_unknown(\n+            png_ptr, info_ptr, length, PNG_HANDLE_CHUNK_AS_DEFAULT);\n+   }\n+\n+   \/* First check the position.   The first check is historical; the stream must\n+    * start with IHDR and anything else causes libpng to give up immediately.\n+    *\/\n+   else if (chunk_index != PNG_INDEX_IHDR &&\n+            (png_ptr->mode & PNG_HAVE_IHDR) == 0)\n+      png_chunk_error(png_ptr, \"missing IHDR\"); \/* NORETURN *\/\n+\n+   \/* Before all the pos_before chunks, after all the pos_after chunks. *\/\n+   else if (((png_ptr->mode & read_chunks[chunk_index].pos_before) != 0) ||\n+            ((png_ptr->mode & read_chunks[chunk_index].pos_after) !=\n+             read_chunks[chunk_index].pos_after))\n+   {\n+      errmsg = \"out of place\";\n+   }\n+\n+   \/* Now check for duplicates: duplicated critical chunks also produce a\n+    * full error.\n+    *\/\n+   else if (read_chunks[chunk_index].multiple == 0 &&\n+            png_file_has_chunk(png_ptr, chunk_index))\n+   {\n+      errmsg = \"duplicate\";\n+   }\n+\n+   else if (length < read_chunks[chunk_index].min_length)\n+      errmsg = \"too short\";\n+   else\n+   {\n+      \/* NOTE: apart from IHDR the critical chunks (PLTE, IDAT and IEND) are set\n+       * up above not to do any length checks.\n+       *\n+       * The png_chunk_max check ensures that the variable length chunks are\n+       * always checked at this point for being within the system allocation\n+       * limits.\n+       *\/\n+      unsigned max_length = read_chunks[chunk_index].max_length;\n+\n+      switch (max_length)\n+      {\n+         case Limit:\n+            \/* png_read_chunk_header has already png_error'ed chunks with a\n+             * length exceeding the 31-bit PNG limit, so just check the memory\n+             * limit:\n+             *\/\n+            if (length <= png_chunk_max(png_ptr))\n+               goto MeetsLimit;\n+\n+            errmsg = \"length exceeds libpng limit\";\n+            break;\n+\n+         default:\n+            if (length <= max_length)\n+               goto MeetsLimit;\n+\n+            errmsg = \"too long\";\n+            break;\n+\n+         case NoCheck:\n+         MeetsLimit:\n+            handled = read_chunks[chunk_index].handler(\n+                  png_ptr, info_ptr, length);\n+            break;\n+      }\n+   }\n+\n+   \/* If there was an error or the chunk was simply skipped it is not counted as\n+    * 'seen'.\n+    *\/\n+   if (errmsg != NULL)\n+   {\n+      if (PNG_CHUNK_CRITICAL(chunk_name)) \/* stop immediately *\/\n+         png_chunk_error(png_ptr, errmsg);\n+      else \/* ancillary chunk *\/\n+      {\n+         \/* The chunk data is skipped: *\/\n+         png_crc_finish(png_ptr, length);\n+         png_chunk_benign_error(png_ptr, errmsg);\n+      }\n@@ -3213,1 +3251,1 @@\n-   if (length > limit)\n+   else if (handled >= handled_saved)\n@@ -3215,3 +3253,2 @@\n-      png_debug2(0,\" length = %lu, limit = %lu\",\n-         (unsigned long)length,(unsigned long)limit);\n-      png_benign_error(png_ptr, \"chunk data is too large\");\n+      if (chunk_index != PNG_INDEX_unknown)\n+         png_file_add_chunk(png_ptr, chunk_index);\n@@ -3219,0 +3256,2 @@\n+\n+   return handled;\n@@ -3716,4 +3755,0 @@\n-   \/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index *\/\n-   \/* Offset to next interlace block *\/\n-   static const unsigned int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n-\n@@ -4212,0 +4247,3 @@\n+         if (avail_in > png_chunk_max(png_ptr))\n+            avail_in = (uInt)\/*SAFE*\/png_chunk_max(png_ptr);\n+\n@@ -4219,0 +4257,2 @@\n+          *\n+          * An error here corresponds to the system being out of memory.\n@@ -4220,1 +4260,4 @@\n-         buffer = png_read_buffer(png_ptr, avail_in, 0\/*error*\/);\n+         buffer = png_read_buffer(png_ptr, avail_in);\n+\n+         if (buffer == NULL)\n+            png_chunk_error(png_ptr, \"out of memory\");\n@@ -4357,14 +4400,0 @@\n-   \/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index *\/\n-\n-   \/* Start of interlace block *\/\n-   static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\n-\n-   \/* Offset to next interlace block *\/\n-   static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n-\n-   \/* Start of interlace block in the y direction *\/\n-   static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};\n-\n-   \/* Offset to next interlace block in the y direction *\/\n-   static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n-\n@@ -4422,14 +4451,0 @@\n-   \/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index *\/\n-\n-   \/* Start of interlace block *\/\n-   static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\n-\n-   \/* Offset to next interlace block *\/\n-   static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n-\n-   \/* Start of interlace block in the y direction *\/\n-   static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};\n-\n-   \/* Offset to next interlace block in the y direction *\/\n-   static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n-\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/pngrutil.c","additions":950,"deletions":935,"binary":false,"changes":1885,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2022 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -73,2 +73,0 @@\n-   png_xy xy;\n-\n@@ -80,12 +78,8 @@\n-   xy.redx = red_x;\n-   xy.redy = red_y;\n-   xy.greenx = green_x;\n-   xy.greeny = green_y;\n-   xy.bluex = blue_x;\n-   xy.bluey = blue_y;\n-   xy.whitex = white_x;\n-   xy.whitey = white_y;\n-\n-   if (png_colorspace_set_chromaticities(png_ptr, &info_ptr->colorspace, &xy,\n-       2\/* override with app values*\/) != 0)\n-      info_ptr->colorspace.flags |= PNG_COLORSPACE_FROM_cHRM;\n+   info_ptr->cHRM.redx = red_x;\n+   info_ptr->cHRM.redy = red_y;\n+   info_ptr->cHRM.greenx = green_x;\n+   info_ptr->cHRM.greeny = green_y;\n+   info_ptr->cHRM.bluex = blue_x;\n+   info_ptr->cHRM.bluey = blue_y;\n+   info_ptr->cHRM.whitex = white_x;\n+   info_ptr->cHRM.whitey = white_y;\n@@ -93,1 +87,1 @@\n-   png_colorspace_sync_info(png_ptr, info_ptr);\n+   info_ptr->valid |= PNG_INFO_cHRM;\n@@ -105,0 +99,1 @@\n+   png_xy xy;\n@@ -121,3 +116,5 @@\n-   if (png_colorspace_set_endpoints(png_ptr, &info_ptr->colorspace,\n-       &XYZ, 2) != 0)\n-      info_ptr->colorspace.flags |= PNG_COLORSPACE_FROM_cHRM;\n+   if (png_xy_from_XYZ(&xy, &XYZ) == 0)\n+   {\n+      info_ptr->cHRM = xy;\n+      info_ptr->valid |= PNG_INFO_cHRM;\n+   }\n@@ -125,1 +122,2 @@\n-   png_colorspace_sync_info(png_ptr, info_ptr);\n+   else\n+      png_app_error(png_ptr, \"invalid cHRM XYZ\");\n@@ -165,0 +163,183 @@\n+#ifdef PNG_cICP_SUPPORTED\n+void PNGAPI\n+png_set_cICP(png_const_structrp png_ptr, png_inforp info_ptr,\n+             png_byte colour_primaries, png_byte transfer_function,\n+             png_byte matrix_coefficients, png_byte video_full_range_flag)\n+{\n+   png_debug1(1, \"in %s storage function\", \"cICP\");\n+\n+   if (png_ptr == NULL || info_ptr == NULL)\n+      return;\n+\n+   info_ptr->cicp_colour_primaries = colour_primaries;\n+   info_ptr->cicp_transfer_function = transfer_function;\n+   info_ptr->cicp_matrix_coefficients = matrix_coefficients;\n+   info_ptr->cicp_video_full_range_flag = video_full_range_flag;\n+\n+   if (info_ptr->cicp_matrix_coefficients != 0)\n+   {\n+      png_warning(png_ptr, \"Invalid cICP matrix coefficients\");\n+      return;\n+   }\n+\n+   info_ptr->valid |= PNG_INFO_cICP;\n+}\n+#endif \/* cICP *\/\n+\n+#ifdef PNG_cLLI_SUPPORTED\n+void PNGFAPI\n+png_set_cLLI_fixed(png_const_structrp png_ptr, png_inforp info_ptr,\n+    \/* The values below are in cd\/m2 (nits) and are scaled by 10,000; not\n+     * 100,000 as in the case of png_fixed_point.\n+     *\/\n+    png_uint_32 maxCLL, png_uint_32 maxFALL)\n+{\n+   png_debug1(1, \"in %s storage function\", \"cLLI\");\n+\n+   if (png_ptr == NULL || info_ptr == NULL)\n+      return;\n+\n+   \/* Check the light level range: *\/\n+   if (maxCLL > 0x7FFFFFFFU || maxFALL > 0x7FFFFFFFU)\n+   {\n+      \/* The limit is 200kcd\/m2; somewhat bright but not inconceivable because\n+       * human vision is said to run up to 100Mcd\/m2.  The sun is about 2Gcd\/m2.\n+       *\n+       * The reference sRGB monitor is 80cd\/m2 and the limit of PQ encoding is\n+       * 2kcd\/m2.\n+       *\/\n+      png_chunk_report(png_ptr, \"cLLI light level exceeds PNG limit\",\n+            PNG_CHUNK_WRITE_ERROR);\n+      return;\n+   }\n+\n+   info_ptr->maxCLL = maxCLL;\n+   info_ptr->maxFALL = maxFALL;\n+   info_ptr->valid |= PNG_INFO_cLLI;\n+}\n+\n+#  ifdef PNG_FLOATING_POINT_SUPPORTED\n+void PNGAPI\n+png_set_cLLI(png_const_structrp png_ptr, png_inforp info_ptr,\n+   double maxCLL, double maxFALL)\n+{\n+   png_set_cLLI_fixed(png_ptr, info_ptr,\n+       png_fixed_ITU(png_ptr, maxCLL, \"png_set_cLLI(maxCLL)\"),\n+       png_fixed_ITU(png_ptr, maxFALL, \"png_set_cLLI(maxFALL)\"));\n+}\n+#  endif \/* FLOATING_POINT *\/\n+#endif \/* cLLI *\/\n+\n+#ifdef PNG_mDCV_SUPPORTED\n+static png_uint_16\n+png_ITU_fixed_16(int *error, png_fixed_point v)\n+{\n+   \/* Return a safe uint16_t value scaled according to the ITU H273 rules for\n+    * 16-bit display chromaticities.  Functions like the corresponding\n+    * png_fixed() internal function with regard to errors: it's an error on\n+    * write, a chunk_benign_error on read: See the definition of\n+    * png_chunk_report in pngpriv.h.\n+    *\/\n+   v \/= 2; \/* rounds to 0 in C: avoids insignificant arithmetic errors *\/\n+   if (v > 65535 || v < 0)\n+   {\n+      *error = 1;\n+      return 0;\n+   }\n+\n+   return (png_uint_16)\/*SAFE*\/v;\n+}\n+\n+void PNGAPI\n+png_set_mDCV_fixed(png_const_structrp png_ptr, png_inforp info_ptr,\n+    png_fixed_point white_x, png_fixed_point white_y,\n+    png_fixed_point red_x, png_fixed_point red_y,\n+    png_fixed_point green_x, png_fixed_point green_y,\n+    png_fixed_point blue_x, png_fixed_point blue_y,\n+    png_uint_32 maxDL,\n+    png_uint_32 minDL)\n+{\n+   png_uint_16 rx, ry, gx, gy, bx, by, wx, wy;\n+   int error;\n+\n+   png_debug1(1, \"in %s storage function\", \"mDCV\");\n+\n+   if (png_ptr == NULL || info_ptr == NULL)\n+      return;\n+\n+   \/* Check the input values to ensure they are in the expected range: *\/\n+   error = 0;\n+   rx = png_ITU_fixed_16(&error, red_x);\n+   ry = png_ITU_fixed_16(&error, red_y);\n+   gx = png_ITU_fixed_16(&error, green_x);\n+   gy = png_ITU_fixed_16(&error, green_y);\n+   bx = png_ITU_fixed_16(&error, blue_x);\n+   by = png_ITU_fixed_16(&error, blue_y);\n+   wx = png_ITU_fixed_16(&error, white_x);\n+   wy = png_ITU_fixed_16(&error, white_y);\n+\n+   if (error)\n+   {\n+      png_chunk_report(png_ptr,\n+         \"mDCV chromaticities outside representable range\",\n+         PNG_CHUNK_WRITE_ERROR);\n+      return;\n+   }\n+\n+   \/* Check the light level range: *\/\n+   if (maxDL > 0x7FFFFFFFU || minDL > 0x7FFFFFFFU)\n+   {\n+      \/* The limit is 200kcd\/m2; somewhat bright but not inconceivable because\n+       * human vision is said to run up to 100Mcd\/m2.  The sun is about 2Gcd\/m2.\n+       *\n+       * The reference sRGB monitor is 80cd\/m2 and the limit of PQ encoding is\n+       * 2kcd\/m2.\n+       *\/\n+      png_chunk_report(png_ptr, \"mDCV display light level exceeds PNG limit\",\n+            PNG_CHUNK_WRITE_ERROR);\n+      return;\n+   }\n+\n+   \/* All values are safe, the settings are accepted.\n+    *\n+    * IMPLEMENTATION NOTE: in practice the values can be checked and assigned\n+    * but the result is confusing if a writing app calls png_set_mDCV more than\n+    * once, the second time with an invalid value.  This approach is more\n+    * obviously correct at the cost of typing and a very slight machine\n+    * overhead.\n+    *\/\n+   info_ptr->mastering_red_x = rx;\n+   info_ptr->mastering_red_y = ry;\n+   info_ptr->mastering_green_x = gx;\n+   info_ptr->mastering_green_y = gy;\n+   info_ptr->mastering_blue_x = bx;\n+   info_ptr->mastering_blue_y = by;\n+   info_ptr->mastering_white_x = wx;\n+   info_ptr->mastering_white_y = wy;\n+   info_ptr->mastering_maxDL = maxDL;\n+   info_ptr->mastering_minDL = minDL;\n+   info_ptr->valid |= PNG_INFO_mDCV;\n+}\n+\n+#  ifdef PNG_FLOATING_POINT_SUPPORTED\n+void PNGAPI\n+png_set_mDCV(png_const_structrp png_ptr, png_inforp info_ptr,\n+    double white_x, double white_y, double red_x, double red_y, double green_x,\n+    double green_y, double blue_x, double blue_y,\n+    double maxDL, double minDL)\n+{\n+   png_set_mDCV_fixed(png_ptr, info_ptr,\n+      png_fixed(png_ptr, white_x, \"png_set_mDCV(white(x))\"),\n+      png_fixed(png_ptr, white_y, \"png_set_mDCV(white(y))\"),\n+      png_fixed(png_ptr, red_x, \"png_set_mDCV(red(x))\"),\n+      png_fixed(png_ptr, red_y, \"png_set_mDCV(red(y))\"),\n+      png_fixed(png_ptr, green_x, \"png_set_mDCV(green(x))\"),\n+      png_fixed(png_ptr, green_y, \"png_set_mDCV(green(y))\"),\n+      png_fixed(png_ptr, blue_x, \"png_set_mDCV(blue(x))\"),\n+      png_fixed(png_ptr, blue_y, \"png_set_mDCV(blue(y))\"),\n+      png_fixed_ITU(png_ptr, maxDL, \"png_set_mDCV(maxDL)\"),\n+      png_fixed_ITU(png_ptr, minDL, \"png_set_mDCV(minDL)\"));\n+}\n+#  endif \/* FLOATING_POINT *\/\n+#endif \/* mDCV *\/\n+\n@@ -168,1 +349,1 @@\n-    png_bytep eXIf_buf)\n+    png_bytep exif)\n@@ -172,1 +353,1 @@\n-  PNG_UNUSED(eXIf_buf)\n+  PNG_UNUSED(exif)\n@@ -177,1 +358,1 @@\n-    png_uint_32 num_exif, png_bytep eXIf_buf)\n+    png_uint_32 num_exif, png_bytep exif)\n@@ -179,1 +360,1 @@\n-   int i;\n+   png_bytep new_exif;\n@@ -183,1 +364,2 @@\n-   if (png_ptr == NULL || info_ptr == NULL)\n+   if (png_ptr == NULL || info_ptr == NULL ||\n+       (png_ptr->mode & PNG_WROTE_eXIf) != 0)\n@@ -186,10 +368,1 @@\n-   if (info_ptr->exif)\n-   {\n-      png_free(png_ptr, info_ptr->exif);\n-      info_ptr->exif = NULL;\n-   }\n-\n-   info_ptr->num_exif = num_exif;\n-\n-   info_ptr->exif = png_voidcast(png_bytep, png_malloc_warn(png_ptr,\n-       info_ptr->num_exif));\n+   new_exif = png_voidcast(png_bytep, png_malloc_warn(png_ptr, num_exif));\n@@ -197,1 +370,1 @@\n-   if (info_ptr->exif == NULL)\n+   if (new_exif == NULL)\n@@ -203,1 +376,1 @@\n-   info_ptr->free_me |= PNG_FREE_EXIF;\n+   memcpy(new_exif, exif, (size_t)num_exif);\n@@ -205,2 +378,1 @@\n-   for (i = 0; i < (int) info_ptr->num_exif; i++)\n-      info_ptr->exif[i] = eXIf_buf[i];\n+   png_free_data(png_ptr, info_ptr, PNG_FREE_EXIF, 0);\n@@ -208,0 +380,3 @@\n+   info_ptr->num_exif = num_exif;\n+   info_ptr->exif = new_exif;\n+   info_ptr->free_me |= PNG_FREE_EXIF;\n@@ -222,2 +397,2 @@\n-   png_colorspace_set_gamma(png_ptr, &info_ptr->colorspace, file_gamma);\n-   png_colorspace_sync_info(png_ptr, info_ptr);\n+   info_ptr->gamma = file_gamma;\n+   info_ptr->valid |= PNG_INFO_gAMA;\n@@ -268,1 +443,0 @@\n-\n@@ -272,2 +446,0 @@\n-   info_ptr->free_me |= PNG_FREE_HIST;\n-\n@@ -277,0 +449,1 @@\n+   info_ptr->free_me |= PNG_FREE_HIST;\n@@ -398,0 +571,2 @@\n+   info_ptr->free_me |= PNG_FREE_PCAL;\n+\n@@ -414,1 +589,0 @@\n-\n@@ -426,1 +600,0 @@\n-\n@@ -444,1 +617,0 @@\n-\n@@ -452,1 +624,0 @@\n-   info_ptr->free_me |= PNG_FREE_PCAL;\n@@ -509,1 +680,1 @@\n-      png_free (png_ptr, info_ptr->scal_s_width);\n+      png_free(png_ptr, info_ptr->scal_s_width);\n@@ -513,1 +684,0 @@\n-\n@@ -519,1 +689,0 @@\n-   info_ptr->valid |= PNG_INFO_sCAL;\n@@ -521,0 +690,1 @@\n+   info_ptr->valid |= PNG_INFO_sCAL;\n@@ -656,0 +826,1 @@\n+\n@@ -658,1 +829,0 @@\n-\n@@ -660,1 +830,0 @@\n-\n@@ -688,2 +857,2 @@\n-   (void)png_colorspace_set_sRGB(png_ptr, &info_ptr->colorspace, srgb_intent);\n-   png_colorspace_sync_info(png_ptr, info_ptr);\n+   info_ptr->rendering_intent = srgb_intent;\n+   info_ptr->valid |= PNG_INFO_sRGB;\n@@ -701,7 +870,1 @@\n-   if (png_colorspace_set_sRGB(png_ptr, &info_ptr->colorspace,\n-       srgb_intent) != 0)\n-   {\n-      \/* This causes the gAMA and cHRM to be written too *\/\n-      info_ptr->colorspace.flags |=\n-         PNG_COLORSPACE_FROM_gAMA|PNG_COLORSPACE_FROM_cHRM;\n-   }\n+   png_set_sRGB(png_ptr, info_ptr, srgb_intent);\n@@ -709,1 +872,12 @@\n-   png_colorspace_sync_info(png_ptr, info_ptr);\n+#  ifdef PNG_gAMA_SUPPORTED\n+      png_set_gAMA_fixed(png_ptr, info_ptr, PNG_GAMMA_sRGB_INVERSE);\n+#  endif \/* gAMA *\/\n+\n+#  ifdef PNG_cHRM_SUPPORTED\n+      png_set_cHRM_fixed(png_ptr, info_ptr,\n+         \/* color      x       y *\/\n+         \/* white *\/ 31270, 32900,\n+         \/* red   *\/ 64000, 33000,\n+         \/* green *\/ 30000, 60000,\n+         \/* blue  *\/ 15000,  6000);\n+#  endif \/* cHRM *\/\n@@ -732,21 +906,0 @@\n-   \/* Set the colorspace first because this validates the profile; do not\n-    * override previously set app cHRM or gAMA here (because likely as not the\n-    * application knows better than libpng what the correct values are.)  Pass\n-    * the info_ptr color_type field to png_colorspace_set_ICC because in the\n-    * write case it has not yet been stored in png_ptr.\n-    *\/\n-   {\n-      int result = png_colorspace_set_ICC(png_ptr, &info_ptr->colorspace, name,\n-          proflen, profile, info_ptr->color_type);\n-\n-      png_colorspace_sync_info(png_ptr, info_ptr);\n-\n-      \/* Don't do any of the copying if the profile was bad, or inconsistent. *\/\n-      if (result == 0)\n-         return;\n-\n-      \/* But do write the gAMA and cHRM chunks from the profile. *\/\n-      info_ptr->colorspace.flags |=\n-         PNG_COLORSPACE_FROM_gAMA|PNG_COLORSPACE_FROM_cHRM;\n-   }\n-\n@@ -806,2 +959,2 @@\n-   png_debug1(1, \"in %lx storage function\", png_ptr == NULL ? 0xabadca11U :\n-      (unsigned long)png_ptr->chunk_name);\n+   png_debug1(1, \"in text storage function, chunk typeid = 0x%lx\",\n+      png_ptr == NULL ? 0xabadca11UL : (unsigned long)png_ptr->chunk_name);\n@@ -810,1 +963,1 @@\n-      return(0);\n+      return 0;\n@@ -990,1 +1143,1 @@\n-   return(0);\n+   return 0;\n@@ -1051,1 +1204,0 @@\n-          info_ptr->valid |= PNG_INFO_tRNS;\n@@ -1053,0 +1205,1 @@\n+          info_ptr->valid |= PNG_INFO_tRNS;\n@@ -1085,1 +1238,0 @@\n-      info_ptr->valid |= PNG_INFO_tRNS;\n@@ -1087,0 +1239,1 @@\n+      info_ptr->valid |= PNG_INFO_tRNS;\n@@ -1106,0 +1259,2 @@\n+   png_debug1(1, \"in %s storage function\", \"sPLT\");\n+\n@@ -1120,1 +1275,0 @@\n-\n@@ -1125,0 +1279,1 @@\n+\n@@ -1278,1 +1433,0 @@\n-\n@@ -1283,0 +1437,1 @@\n+\n@@ -1436,0 +1591,2 @@\n+         99,  73,  67,  80, '\\0',  \/* cICP *\/\n+         99,  76,  76,  73, '\\0',  \/* cLLI *\/\n@@ -1441,0 +1598,1 @@\n+        109,  68,  67,  86, '\\0',  \/* mDCV *\/\n@@ -1580,1 +1738,1 @@\n-   png_debug1(1, \"in %s storage function\", \"rows\");\n+   png_debug(1, \"in png_set_rows\");\n@@ -1599,0 +1757,2 @@\n+   png_debug(1, \"in png_set_compression_buffer_size\");\n+\n@@ -1670,0 +1830,2 @@\n+   png_debug(1, \"in png_set_user_limits\");\n+\n@@ -1685,0 +1847,2 @@\n+   png_debug(1, \"in png_set_chunk_cache_max\");\n+\n@@ -1694,0 +1858,7 @@\n+   png_debug(1, \"in png_set_chunk_malloc_max\");\n+\n+   \/* pngstruct::user_chunk_malloc_max is initialized to a non-zero value in\n+    * png.c.  This API supports '0' for unlimited, make sure the correct\n+    * (unlimited) value is set here to avoid a need to check for 0 everywhere\n+    * the parameter is used.\n+    *\/\n@@ -1695,1 +1866,12 @@\n-      png_ptr->user_chunk_malloc_max = user_chunk_malloc_max;\n+   {\n+      if (user_chunk_malloc_max == 0U) \/* unlimited *\/\n+      {\n+#        ifdef PNG_MAX_MALLOC_64K\n+            png_ptr->user_chunk_malloc_max = 65536U;\n+#        else\n+            png_ptr->user_chunk_malloc_max = PNG_SIZE_MAX;\n+#        endif\n+      }\n+      else\n+         png_ptr->user_chunk_malloc_max = user_chunk_malloc_max;\n+   }\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/pngset.c","additions":276,"deletions":94,"binary":false,"changes":370,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/* pngstruct.h - header file for PNG reference library\n+\/* pngstruct.h - internal structures for libpng\n@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2022 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -42,5 +42,3 @@\n-\/* The structure that holds the information to read and write PNG files.\n- * The only people who need to care about what is inside of this are the\n- * people who will be modifying the library for their own special needs.\n- * It should NOT be accessed directly by an application.\n- *\/\n+#ifndef PNGPRIV_H\n+#  error This file must not be included by applications; please include <png.h>\n+#endif\n@@ -101,5 +99,0 @@\n- *\n- * PNG_COLORSPACE_SUPPORTED is only required if the application will perform\n- * colorspace corrections, otherwise all the colorspace information can be\n- * skipped and the size of libpng can be reduced (significantly) by compiling\n- * out the colorspace support.\n@@ -107,1 +100,0 @@\n-#ifdef PNG_COLORSPACE_SUPPORTED\n@@ -128,1 +120,0 @@\n-#endif \/* COLORSPACE *\/\n@@ -130,9 +121,2 @@\n-#if defined(PNG_COLORSPACE_SUPPORTED) || defined(PNG_GAMMA_SUPPORTED)\n-\/* A colorspace is all the above plus, potentially, profile information;\n- * however at present libpng does not use the profile internally so it is only\n- * stored in the png_info struct (if iCCP is supported.)  The rendering intent\n- * is retained here and is checked.\n- *\n- * The file gamma encoding information is also stored here and gamma correction\n- * is done by libpng, whereas color correction must currently be done by the\n- * application.\n+\/* Chunk index values as an enum, PNG_INDEX_unknown is also a count of the\n+ * number of chunks.\n@@ -140,1 +124,2 @@\n-typedef struct png_colorspace\n+#define PNG_CHUNK(cHNK, i) PNG_INDEX_ ## cHNK = (i),\n+typedef enum\n@@ -142,9 +127,4 @@\n-#ifdef PNG_GAMMA_SUPPORTED\n-   png_fixed_point gamma;        \/* File gamma *\/\n-#endif\n-\n-#ifdef PNG_COLORSPACE_SUPPORTED\n-   png_xy      end_points_xy;    \/* End points as chromaticities *\/\n-   png_XYZ     end_points_XYZ;   \/* End points as CIE XYZ colorant values *\/\n-   png_uint_16 rendering_intent; \/* Rendering intent of a profile *\/\n-#endif\n+   PNG_KNOWN_CHUNKS\n+   PNG_INDEX_unknown\n+} png_index;\n+#undef PNG_CHUNK\n@@ -152,3 +132,10 @@\n-   \/* Flags are always defined to simplify the code. *\/\n-   png_uint_16 flags;            \/* As defined below *\/\n-} png_colorspace, * PNG_RESTRICT png_colorspacerp;\n+\/* Chunk flag values.  These are (png_uint_32 values) with exactly one bit set\n+ * and can be combined into a flag set with bitwise 'or'.\n+ *\n+ * TODO: C23: convert these macros to C23 inlines (which are static).\n+ *\/\n+#define png_chunk_flag_from_index(i) (0x80000000U >> (31 - (i)))\n+   \/* The flag coresponding to the given png_index enum value.  This is defined\n+    * for png_unknown as well (until it reaches the value 32) but this should\n+    * not be relied on.\n+    *\/\n@@ -156,1 +143,3 @@\n-typedef const png_colorspace * PNG_RESTRICT png_const_colorspacerp;\n+#define png_file_has_chunk(png_ptr, i)\\\n+   (((png_ptr)->chunks & png_chunk_flag_from_index(i)) != 0)\n+   \/* The chunk has been recorded in png_struct *\/\n@@ -158,12 +147,3 @@\n-\/* General flags for the 'flags' field *\/\n-#define PNG_COLORSPACE_HAVE_GAMMA           0x0001\n-#define PNG_COLORSPACE_HAVE_ENDPOINTS       0x0002\n-#define PNG_COLORSPACE_HAVE_INTENT          0x0004\n-#define PNG_COLORSPACE_FROM_gAMA            0x0008\n-#define PNG_COLORSPACE_FROM_cHRM            0x0010\n-#define PNG_COLORSPACE_FROM_sRGB            0x0020\n-#define PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB 0x0040\n-#define PNG_COLORSPACE_MATCHES_sRGB         0x0080 \/* exact match on profile *\/\n-#define PNG_COLORSPACE_INVALID              0x8000\n-#define PNG_COLORSPACE_CANCEL(flags)        (0xffff ^ (flags))\n-#endif \/* COLORSPACE || GAMMA *\/\n+#define png_file_add_chunk(pnt_ptr, i)\\\n+   ((void)((png_ptr)->chunks |= png_chunk_flag_from_index(i)))\n+   \/* Record the chunk in the png_struct *\/\n@@ -241,0 +221,5 @@\n+   png_uint_32 chunks; \/* PNG_CF_ for every chunk read or (NYI) written *\/\n+#  define png_has_chunk(png_ptr, cHNK)\\\n+      png_file_has_chunk(png_ptr, PNG_INDEX_ ## cHNK)\n+      \/* Convenience accessor - use this to check for a known chunk by name *\/\n+\n@@ -317,0 +302,4 @@\n+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n+   png_xy          chromaticities; \/* From mDVC, cICP, [iCCP], sRGB or cHRM *\/\n+#endif\n+\n@@ -319,1 +308,4 @@\n-   png_fixed_point screen_gamma; \/* screen gamma value (display_exponent) *\/\n+   png_fixed_point screen_gamma; \/* screen gamma value (display exponent) *\/\n+   png_fixed_point file_gamma;   \/* file gamma value (encoding exponent) *\/\n+   png_fixed_point chunk_gamma;  \/* from cICP, iCCP, sRGB or gAMA *\/\n+   png_fixed_point default_gamma;\/* from png_set_alpha_mode *\/\n@@ -331,1 +323,1 @@\n-#endif\n+#endif \/* READ_GAMMA *\/\n@@ -381,2 +373,2 @@\n-#endif\n-#endif\n+#endif \/* TIME_RFC1123 *\/\n+#endif \/* LIBPNG_VER < 10700 *\/\n@@ -392,2 +384,2 @@\n-#endif\n-#endif\n+#endif \/* READ_USER_CHUNKS *\/\n+#endif \/* USER_CHUNKS *\/\n@@ -415,1 +407,2 @@\n-    defined(PNG_ARM_NEON_IMPLEMENTATION)\n+    (defined(PNG_ARM_NEON_IMPLEMENTATION) || \\\n+     defined(PNG_RISCV_RVV_IMPLEMENTATION))\n@@ -444,1 +437,0 @@\n-   png_bytep quantize_sort;          \/* working sort array *\/\n@@ -500,6 +492,0 @@\n-\n-#ifdef PNG_READ_SUPPORTED\n-#if defined(PNG_COLORSPACE_SUPPORTED) || defined(PNG_GAMMA_SUPPORTED)\n-   png_colorspace   colorspace;\n-#endif\n-#endif\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/pngstruct.h","additions":49,"deletions":63,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018 Cosmin Truta\n+ * Copyright (c) 2018-2024 Cosmin Truta\n@@ -134,1 +134,1 @@\n-      return (7);\n+      return 7;\n@@ -137,1 +137,1 @@\n-   return (1);\n+   return 1;\n@@ -529,0 +529,2 @@\n+   png_debug(1, \"in png_do_strip_channel\");\n+\n@@ -729,0 +731,2 @@\n+   png_debug(1, \"in png_do_check_palette_indexes\");\n+\n@@ -739,1 +743,1 @@\n-      png_bytep rp = png_ptr->row_buf + row_info->rowbytes - 1;\n+      png_bytep rp = png_ptr->row_buf + row_info->rowbytes;\n@@ -864,1 +868,1 @@\n-      return (NULL);\n+      return NULL;\n","filename":"jdk\/src\/share\/native\/sun\/awt\/libpng\/pngtrans.c","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"}]}