{"files":[{"patch":"@@ -174,0 +174,1 @@\n+    Boolean showUnchanged;\n@@ -184,1 +185,0 @@\n-    boolean showEqual;\n@@ -339,0 +339,10 @@\n+        \/**\n+         * {@code --show-unchanged} <var>boolean-value<\/var>\n+         *\/\n+        SHOW_UNCHANGED(\"--show-unchanged\", \"opt.arg.boolean\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.showUnchanged = asBoolean(arg);\n+            }\n+        },\n+\n@@ -912,0 +922,9 @@\n+    \/**\n+     * Returns whether unchanged API elements should be unconditionally shown.\n+     *\n+     * @return {@code true} if unchanged API elements should be unconditionally shown\n+     *\/\n+    public boolean showUnchanged() {\n+        return showUnchanged;\n+    }\n+\n@@ -984,4 +1003,0 @@\n-    public boolean showEqual() {\n-        return showEqual;\n-    }\n-\n@@ -1085,0 +1100,4 @@\n+        if (showUnchanged == null) {\n+            showUnchanged = false;\n+        }\n+\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/Options.java","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Optional;\n@@ -40,0 +41,1 @@\n+import java.util.stream.Stream;\n@@ -166,1 +168,1 @@\n-                               BiFunction<RelativePosition<?>, APIMap<T>, Content> f) {\n+                               BiFunction<RelativePosition<?>, APIMap<T>, ContentAndResultKind> f) {\n@@ -182,1 +184,9 @@\n-        if (!dMaps.isEmpty()) {\n+        List<ContentAndResultKind> converted =\n+                dMaps.entrySet()\n+                     .stream()\n+                     .map(e -> f.apply(e.getKey(), e.getValue()))\n+                     .toList();\n+\n+        if (!converted.isEmpty()) {\n+            boolean allUnchanged = converted.stream()\n+                                            .allMatch(c -> c.resultKind() == ResultKind.SAME);\n@@ -186,1 +196,7 @@\n-            dMaps.forEach((rp, apiMap) -> ul.add(HtmlTree.LI(f.apply(rp, apiMap))));\n+            for (ContentAndResultKind c : converted) {\n+                HtmlTree item = HtmlTree.LI(c.content());\n+                if (!allUnchanged && c.resultKind() == ResultKind.SAME) {\n+                    item.setClass(\"unchanged\");\n+                }\n+                ul.add(item);\n+            }\n@@ -188,0 +204,3 @@\n+            if (allUnchanged) {\n+                section = HtmlTree.DIV(section).setClass(\"unchanged\");\n+            }\n@@ -192,1 +211,1 @@\n-    private Content buildExports(RelativePosition<?> rPos, APIMap<ExportsDirective> apiMap) {\n+    private ContentAndResultKind buildExports(RelativePosition<?> rPos, APIMap<ExportsDirective> apiMap) {\n@@ -197,1 +216,1 @@\n-    private Content buildOpens(RelativePosition<?> rPos, APIMap<OpensDirective> apiMap) {\n+    private ContentAndResultKind buildOpens(RelativePosition<?> rPos, APIMap<OpensDirective> apiMap) {\n@@ -202,1 +221,1 @@\n-    private Content buildProvides(RelativePosition<?> rPos, APIMap<ProvidesDirective> apiMap) {\n+    private ContentAndResultKind buildProvides(RelativePosition<?> rPos, APIMap<ProvidesDirective> apiMap) {\n@@ -211,1 +230,1 @@\n-    private Content buildUses(RelativePosition<?> rPos, APIMap<UsesDirective> apiMap) {\n+    private ContentAndResultKind buildUses(RelativePosition<?> rPos, APIMap<UsesDirective> apiMap) {\n@@ -217,1 +236,1 @@\n-    Content buildExportsOpensProvides(RelativePosition<?> rPos, APIMap<T> apiMap,\n+    ContentAndResultKind buildExportsOpensProvides(RelativePosition<?> rPos, APIMap<T> apiMap,\n@@ -264,1 +283,0 @@\n-\n@@ -268,2 +286,0 @@\n-        return HtmlTree.SPAN(getResultGlyph(rPos), Text.SPACE)\n-                .add(HtmlTree.SPAN(contents).setClass(\"signature\"));\n@@ -271,0 +287,4 @@\n+        ResultKind result = getResultKind(rPos);\n+\n+        return new ContentAndResultKind(HtmlTree.SPAN(result.getContent(), Text.SPACE)\n+                .add(HtmlTree.SPAN(contents).setClass(\"signature\")), result);\n@@ -291,1 +311,1 @@\n-    private Content buildRequires(RelativePosition<?> rPos, APIMap<RequiresDirective> apiMap) {\n+    private ContentAndResultKind buildRequires(RelativePosition<?> rPos, APIMap<RequiresDirective> apiMap) {\n@@ -340,1 +360,0 @@\n-\n@@ -344,2 +363,4 @@\n-        return HtmlTree.SPAN(getResultGlyph(rPos), Text.SPACE)\n-                .add(HtmlTree.SPAN(contents).setClass(\"signature\"));\n+        ResultKind result = getResultKind(rPos);\n+\n+        return new ContentAndResultKind(HtmlTree.SPAN(result.getContent(), Text.SPACE)\n+                .add(HtmlTree.SPAN(contents).setClass(\"signature\")), result);\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/ModulePageReporter.java","additions":36,"deletions":15,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+import java.util.Optional;\n@@ -513,1 +514,31 @@\n-        contents.add(HtmlTree.DIV(new RawHtml(infoText)).setClass(\"info\"));\n+        List<Content> infoBox = new ArrayList<>();\n+        infoBox.add(new RawHtml(infoText));\n+        if (kind == InfoTextKind.HEADER && !parent.options.showUnchanged()) {\n+            String showUnchangedCheckbox =\n+                    \"\"\"\n+                    <script>\n+                        function adjustShowUnchanged() {\n+                            if (document.getElementById(\"show-unchanged-checkbox\").checked) {\n+                                var unchanged = document.getElementsByClassName(\"unchanged\");\n+                                for (var i = 0; i < unchanged.length; i++) {\n+                                    unchanged[i].classList.remove(\"hidden\");\n+                                }\n+                            } else {\n+                                var unchanged = document.getElementsByClassName(\"unchanged\");\n+                                for (var i = 0; i < unchanged.length; i++) {\n+                                    unchanged[i].classList.add(\"hidden\");\n+                                }\n+                            }\n+                        }\n+                        document.addEventListener(\"DOMContentLoaded\", function() {\n+                            adjustShowUnchanged();\n+                        });\n+                    <\/script>\n+                    <input type='checkbox' id='show-unchanged-checkbox'\n+                           onchange='adjustShowUnchanged()'>\n+                    Show unchanged\n+                    <\/input>\n+                    \"\"\";\n+            infoBox.add(new RawHtml(showUnchangedCheckbox));\n+        }\n+        contents.add(HtmlTree.DIV(infoBox.toArray(Content[]::new)).setClass(\"info\"));\n@@ -539,1 +570,1 @@\n-        List<Content> prelude = List.of(getResultGlyph(pagePos), buildMissingInfo(pagePos), buildNotes(pageKey));\n+        List<Content> prelude = List.of(PageReporter.this.getResultKind(pagePos).getContent(), buildMissingInfo(pagePos), buildNotes(pageKey));\n@@ -753,1 +784,7 @@\n-        if (!enclosed.isEmpty()) {\n+        List<ContentAndResultKind> converted =\n+                enclosed.stream()\n+                        .map(eKey -> buildEnclosedElement(eKey))\n+                        .toList();\n+\n+        if (!converted.isEmpty()) {\n+            boolean allUnchanged = converted.stream().allMatch(c -> c.resultKind() == ResultKind.SAME);\n@@ -757,2 +794,5 @@\n-            for (ElementKey eKey : enclosed) {\n-                HtmlTree li = HtmlTree.LI(buildEnclosedElement(eKey));\n+            for (ContentAndResultKind c : converted) {\n+                HtmlTree li = HtmlTree.LI(c.content());\n+                if (!allUnchanged && c.resultKind() == ResultKind.SAME) {\n+                    li.setClass(\"unchanged\");\n+                }\n@@ -762,0 +802,3 @@\n+            if (allUnchanged) {\n+                section = HtmlTree.DIV(section).setClass(\"unchanged\");\n+            }\n@@ -775,1 +818,1 @@\n-    protected Content buildEnclosedElement(ElementKey eKey) {\n+    protected ContentAndResultKind buildEnclosedElement(ElementKey eKey) {\n@@ -778,1 +821,2 @@\n-        return HtmlTree.SPAN(r.getResultGlyph(eKey),\n+        ResultKind result = r.getResultKind(eKey);\n+        return new ContentAndResultKind(HtmlTree.SPAN(result.getContent(),\n@@ -780,1 +824,1 @@\n-                links.createLink(eKey));\n+                links.createLink(eKey)), result);\n@@ -795,1 +839,1 @@\n-                HtmlTree li = HtmlTree.LI(getResultGlyph(p), buildMissingInfo(p));\n+                HtmlTree li = HtmlTree.LI(PageReporter.this.getResultKind(p).getContent(), buildMissingInfo(p));\n@@ -837,0 +881,1 @@\n+            ResultKind result = PageReporter.this.getResultKind(pos);\n@@ -849,1 +894,1 @@\n-            return HtmlTree.SPAN(Text.of(info)).setClass(\"missing\");\n+            return HtmlTree.SPAN(Text.of(info)).setClass(result.getMissingCaptionClass() != null ? \"missing \" + result.getMissingCaptionClass() : \"missing\");\n@@ -866,32 +911,1 @@\n-    \/\/ The following names are intended to be \"semantic\" or \"abstract\" names,\n-    \/\/ distinct from the concrete representations used in the generated documentation.\n-    \/\/ The names are intentionally different from any corresponding entity names.\n-\n-    \/**\n-     * Used when two elements compare as equal.\n-     *\/\n-    \/\/ possible alternatives: Entity.CHECK\n-    private static final Content SAME = HtmlTree.SPAN(Entity.EQUALS).setClass(\"same\");\n-    \/**\n-     * Used when two elements compare as not equal.\n-     *\/\n-    \/\/ possible alternatives: Entity.CROSS\n-    private static final Content DIFFERENT = HtmlTree.SPAN(Entity.NE).setClass(\"diff\");\n-    \/**\n-     * Used when an element does not appear in all instances of the APIs being compared.\n-     * See also {@link #ADDED}, {@link #REMOVED}.\n-     *\/\n-    private static final Content PARTIAL = HtmlTree.SPAN(Entity.CIRCLED_DIGIT_ONE).setClass(\"partial\");\n-    \/**\n-     * Used in a 2-way comparison when it is determined that an element has been added.\n-     *\/\n-    \/\/ possible alternatives: '>' (for example, as used in text diff tools) or other right-pointing arrows\n-    private static final Content ADDED = HtmlTree.SPAN(Entity.PLUS).setClass(\"partial\");\n-    \/**\n-     * Used in a 2-way comparison when it is determined that an element has been removed.\n-     *\/\n-    \/\/ possible alternatives: '<' (for example, as used in text diff tools) or other left-pointing arrows\n-    private static final Content REMOVED = HtmlTree.SPAN(Entity.MINUS).setClass(\"partial\");\n-\n-\n-    protected Content getResultGlyph(ElementKey eKey) {\n+    protected ResultKind getResultKind(ElementKey eKey) {\n@@ -899,1 +913,1 @@\n-        return getResultGlyph(pos, apiMaps.get(pos));\n+        return getResultKind(pos, apiMaps.get(pos));\n@@ -902,2 +916,2 @@\n-    protected Content getResultGlyph(Position pos) {\n-        return getResultGlyph(pos, apiMaps.get(pos));\n+    protected ResultKind getResultKind(Position pos) {\n+        return getResultKind(pos, apiMaps.get(pos));\n@@ -906,1 +920,1 @@\n-    protected Content getResultGlyph(Position pos, APIMap<?> map) {\n+    protected ResultKind getResultKind(Position pos, APIMap<?> map) {\n@@ -909,1 +923,1 @@\n-            return Text.of(\"?\");\n+            return ResultKind.UNKNOWN;\n@@ -921,1 +935,1 @@\n-                    return REMOVED;\n+                    return ResultKind.REMOVED;\n@@ -923,1 +937,1 @@\n-                    return ADDED;\n+                    return ResultKind.ADDED;\n@@ -926,1 +940,1 @@\n-                    return PARTIAL;\n+                    return ResultKind.PARTIAL;\n@@ -929,1 +943,1 @@\n-            return PARTIAL;\n+            return ResultKind.PARTIAL;\n@@ -932,1 +946,1 @@\n-        return (eq == null) ? PARTIAL : eq ? SAME : DIFFERENT;\n+        return (eq == null) ? ResultKind.PARTIAL : eq ? ResultKind.SAME : ResultKind.DIFFERENT;\n@@ -936,1 +950,1 @@\n-    protected Content getResultGlyph(APIMap<?> map, Position pos) {\n+    protected ResultKind getResultKind(APIMap<?> map, Position pos) {\n@@ -938,1 +952,1 @@\n-            return PARTIAL;\n+            return ResultKind.PARTIAL;\n@@ -941,1 +955,1 @@\n-        return (eq == null) ? PARTIAL : eq ? SAME : DIFFERENT;\n+        return (eq == null) ? ResultKind.PARTIAL : eq ? ResultKind.SAME : ResultKind.DIFFERENT;\n@@ -1501,1 +1515,1 @@\n-            main.add(HtmlTree.SPAN(getResultGlyph(fPos), buildMissingInfo(fPos)).setClass(\"doc-files\"));\n+            main.add(HtmlTree.SPAN(getResultKind(fPos).getContent(), buildMissingInfo(fPos)).setClass(\"doc-files\"));\n@@ -1597,0 +1611,54 @@\n+    public enum ResultKind {\n+        UNKNOWN(Text.of(\"?\"), null),\n+        \/\/ The following names are intended to be \"semantic\" or \"abstract\" names,\n+        \/\/ distinct from the concrete representations used in the generated documentation.\n+        \/\/ The names are intentionally different from any corresponding entity names.\n+        \/**\n+         * Used when two elements compare as equal.\n+         *\/\n+        \/\/ possible alternatives: Entity.CHECK\n+        SAME(HtmlTree.SPAN(Entity.EQUALS).setClass(\"same\"), null),\n+\n+        \/**\n+         * Used when two elements compare as not equal.\n+         *\/\n+        \/\/ possible alternatives: Entity.CROSS\n+        DIFFERENT(HtmlTree.SPAN(Entity.NE).setClass(\"diff\"), null),\n+\n+        \/**\n+         * Used when an element does not appear in all instances of the APIs being compared.\n+         * See also {@link #ADDED}, {@link #REMOVED}.\n+         *\/\n+        PARTIAL(HtmlTree.SPAN(Entity.CIRCLED_DIGIT_ONE).setClass(\"partial\"), null),\n+\n+        \/**\n+         * Used in a 2-way comparison when it is determined that an element has been added.\n+         *\/\n+        \/\/ possible alternatives: '>' (for example, as used in text diff tools) or other right-pointing arrows\n+        ADDED(HtmlTree.SPAN(Entity.PLUS).setClass(\"add\"), \"missing-caption-add\"),\n+\n+        \/**\n+         * Used in a 2-way comparison when it is determined that an element has been removed.\n+         *\/\n+        \/\/ possible alternatives: '<' (for example, as used in text diff tools) or other left-pointing arrows\n+        REMOVED(HtmlTree.SPAN(Entity.MINUS).setClass(\"remove\"), \"missing-caption-remove\"),\n+        ;\n+\n+        private final Content content;\n+        private final String missingCaptionClass;\n+\n+        private ResultKind(Content content, String missingCaptionClass) {\n+            this.content = content;\n+            this.missingCaptionClass = missingCaptionClass;\n+        }\n+\n+        public Content getContent() {\n+            return content;\n+        }\n+\n+        public String getMissingCaptionClass() {\n+            return missingCaptionClass;\n+        }\n+    }\n+\n+    protected record ContentAndResultKind(Content content, ResultKind resultKind) {}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/PageReporter.java","additions":124,"deletions":56,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.Optional;\n@@ -381,1 +382,1 @@\n-    protected Content buildEnclosedElement(ElementKey eKey) {\n+    protected ContentAndResultKind buildEnclosedElement(ElementKey eKey) {\n@@ -555,2 +556,4 @@\n-        Content build() {\n-            Content eq = getResultGlyph(ePos);\n+        ContentAndResultKind build() {\n+            ResultKind result = getResultKind(ePos);\n+\n+            Content eq = result.getContent();\n@@ -616,1 +619,1 @@\n-            return HtmlTree.DIV(eq, buildMissingInfo(ePos), buildNotes(ePos),\n+            return new ContentAndResultKind(HtmlTree.DIV(eq, buildMissingInfo(ePos), buildNotes(ePos),\n@@ -619,1 +622,1 @@\n-                    .set(HtmlAttr.ID, links.getId(ePos));\n+                    .set(HtmlAttr.ID, links.getId(ePos)), result);\n@@ -755,2 +758,3 @@\n-        private Content build() {\n-            Content eq = getResultGlyph(vPos);\n+        private ContentAndResultKind build() {\n+            ResultKind result = getResultKind(vPos);\n+            Content eq = result.getContent();\n@@ -790,1 +794,1 @@\n-            return HtmlTree.DIV(eq, buildMissingInfo(vPos), buildNotes(vKey),\n+            return new ContentAndResultKind(HtmlTree.DIV(eq, buildMissingInfo(vPos), buildNotes(vKey),\n@@ -793,1 +797,1 @@\n-                    .set(HtmlAttr.ID, links.getId(vKey));\n+                    .set(HtmlAttr.ID, links.getId(vKey)), result);\n@@ -989,1 +993,1 @@\n-            section.add(getResultGlyph(sfPos)).add(buildMissingInfo(sfPos));\n+            section.add(getResultKind(sfPos).getContent()).add(buildMissingInfo(sfPos));\n@@ -1003,1 +1007,1 @@\n-            section.add(getResultGlyph(uPos));\n+            section.add(getResultKind(uPos).getContent());\n@@ -1060,1 +1064,1 @@\n-            Content glyph = getResultGlyph(fPos);\n+            Content glyph = getResultKind(fPos).getContent();\n@@ -1113,1 +1117,5 @@\n-                    HtmlTree li = HtmlTree.LI(buildSerializedMethod(pos));\n+                    ContentAndResultKind content = buildSerializedMethod(pos);\n+                    HtmlTree li = HtmlTree.LI(content.content());\n+                    if (content.resultKind() == ResultKind.SAME) {\n+                        li.setClass(\"unchanged\");\n+                    }\n@@ -1121,1 +1129,1 @@\n-        private Content buildSerializedMethod(Position mPos) {\n+        private ContentAndResultKind buildSerializedMethod(Position mPos) {\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/TypePageReporter.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -182,1 +182,3 @@\n-.doc-files span.partial, .element span.partial, .enclosed span.partial, .serial-form span.partial {\n+.doc-files span.partial, .element span.partial, .enclosed span.partial, .serial-form span.partial,\n+.doc-files span.add, .element span.add, .enclosed span.add, .serial-form span.add,\n+.doc-files span.remove, .element span.remove, .enclosed span.remove, .serial-form span.remove {\n@@ -191,2 +193,2 @@\n-    background: #fdd;\n-    color: #800;\n+    background: #e0e0e0;\n+    color: #000;\n@@ -196,2 +198,2 @@\n-    background: #dfd;\n-    color: #080;\n+    background: #ffffff;\n+    color: #000;\n@@ -202,1 +204,23 @@\n-    color: #008;\n+    color: #000;\n+}\n+\n+.doc-files span.add, .element span.add, .enclosed span.add, .serial-form span.add {\n+    background: #cfc;\n+    color: #000;\n+}\n+\n+.doc-files span.remove, .element span.remove, .enclosed span.remove, .serial-form span.remove {\n+    background: #fcc;\n+    color: #000;\n+}\n+\n+.doc-files span.missing-caption-add, .element span.missing-caption-add,\n+.enclosed span.missing-caption-add, .serial-form span.missing-caption-add {\n+    background: #cfc;\n+    color: #000;\n+}\n+\n+.doc-files span.missing-caption-remove, .element span.missing-caption-remove,\n+.enclosed span.missing-caption-remove, .serial-form span.missing-caption-remove {\n+    background: #fcc;\n+    color: #000;\n@@ -476,0 +500,2 @@\n+ .unchanged {\n+ }\n@@ -477,0 +503,3 @@\n+ .hidden {\n+     display: none;\n+ }\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/resources\/apidiff.css","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-  Only in {0}; not i {1}\n+  Only in {0}; not in {1}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/resources\/report.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,0 +130,3 @@\n+opt.desc.show-unchanged=\\\n+    Unchanged elements should be unconditionally shown in the resulting diff\n+\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/resources\/help.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -290,0 +290,5 @@\n+<a id=\"option-show-unchanged\">`--show-unchanged` *boolean*<\/a>\n+:   If true, unchanged elements will be show unconditionally. When false or\n+    missing, the user viewing the diff will have an option to show or hide the\n+    unchanged elements.\n+\n","filename":"src\/share\/doc\/apidiff.md","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,511 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import apitest.lib.APITester;\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.EndElementTree;\n+import com.sun.source.doctree.StartElementTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.util.DocTreeScanner;\n+import com.sun.source.util.DocTrees;\n+import com.sun.source.util.JavacTask;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.Stack;\n+import javax.tools.FileObject;\n+import javax.tools.ToolProvider;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import toolbox.ModuleBuilder;\n+\n+\/**\n+ * Tests the output for unchanged elements.\n+ *\/\n+public class UnchangedTest extends APITester {\n+\n+    @Test\n+    public void testAllUnchanged() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        Path originalDir = base.resolve(\"original\").resolve(\"src\");\n+        Path updatedDir = base.resolve(\"updated\").resolve(\"src\");\n+\n+        for (Path target : new Path[] {originalDir, updatedDir}) {\n+            ModuleBuilder m =\n+                    new ModuleBuilder(tb, \"m\")\n+                            .exports(\"p\").exports(\"p2\")\n+                            .opens(\"p\").opens(\"p2\")\n+                            .provides(\"java.lang.Runnable\", \"p.C1\", \"p.C2\")\n+                            .provides(\"java.lang.FunctionalInterface\", \"p2.C\")\n+                            .uses(\"java.lang.Runnable\")\n+                            .uses(\"java.lang.FunctionalInterface\")\n+                            .requiresTransitive(\"java.compiler\")\n+                            .requiresTransitive(\"jdk.compiler\");\n+\n+            m.classes(\"\"\"\n+                       package p;\n+                       \/** class documentation *\/\n+                       public class C1 implements Runnable {\n+                           \/** test field documentation1 *\/\n+                           public final int F1;\n+                           \/** test field documentation2 *\/\n+                           public final int F2;\n+                           \/** test constructor documentation1 *\/\n+                           public C1() {}\n+                           \/** test constructor documentation2 *\/\n+                           public C1(int i) {}\n+                           \/** test method documentation *\/\n+                           public void test() { }\n+                           \/** run method documentation *\/\n+                           public void run() { }\n+                       }\n+                       \"\"\");\n+\n+            m.classes(\"\"\"\n+                       package p;\n+                       \/** class documentation *\/\n+                       public class C2 implements Runnable {\n+                           \/** test method documentation *\/\n+                           public void test() { }\n+                           \/** run method documentation *\/\n+                           public void run() { }\n+                       }\n+                       \"\"\");\n+\n+            m.classes(\"\"\"\n+                       package p2;\n+                       \/** class documentation *\/\n+                       public class C implements FunctionalInterface {\n+                           \/** test method documentation *\/\n+                           public void test() { }\n+                           \/** run method documentation *\/\n+                           public void run() { }\n+                       }\n+                       \"\"\");\n+\n+            m.write(target);\n+\n+            new ModuleBuilder(tb, \"m2\").write(target);\n+\n+            options.addAll(List.of(\n+                    \"--api\", target.getParent().getFileName().toString(),\n+                    \"--module-source-path\", target.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"--include\", \"m\/**\",\n+                \"--include\", \"m2\/**\",\n+                \"-d\", base.resolve(\"out\").toString(),\n+                \"--verbose\", \"missing\"));\n+\n+        log.println(\"Options: \" + options);\n+\n+        run(options);\n+\n+        {\n+            List<String> unchangedTexts =\n+                    gatherUnchangedTexts(base, \"out\/index.html\");\n+            List<String> expectedUnchangedTextsModule =\n+                    List.of(\"\"\"\n+                            Modules\n+                             m m2\n+                            \"\"\");\n+            Assertions.assertEquals(expectedUnchangedTextsModule, unchangedTexts);\n+        }\n+\n+        {\n+            List<String> unchangedTexts =\n+                    gatherUnchangedTexts(base, \"out\/m\/module-summary.html\");\n+            List<String> expectedUnchangedTextsModule =\n+                    List.of(\"\"\"\n+                            Exports\n+                             exports p exports p2\n+                            \"\"\",\n+                            \"\"\"\n+                            Opens\n+                             opens p opens p2\n+                            \"\"\",\n+                            \"\"\"\n+                            Requires\n+                             requires transitive java.compiler requires transitive jdk.compiler\n+                            \"\"\",\n+                            \"\"\"\n+                            Packages\n+                             p p2\n+                            \"\"\");\n+            Assertions.assertEquals(expectedUnchangedTextsModule, unchangedTexts);\n+        }\n+\n+        {\n+            List<String> unchangedTexts =\n+                    gatherUnchangedTexts(base, \"out\/m\/p\/package-summary.html\");\n+            List<String> expectedUnchangedTextsModule =\n+                    List.of(\"\"\"\n+                            Types\n+                             C1 C2\n+                            \"\"\");\n+            Assertions.assertEquals(expectedUnchangedTextsModule, unchangedTexts);\n+        }\n+\n+        {\n+            List<String> unchangedTexts =\n+                    gatherUnchangedTexts(base, \"out\/m\/p\/C1.html\");\n+            List<String> expectedUnchangedTextsModule =\n+                    List.of(\"\"\"\n+                            Fields\n+                            public final int F1\n+                            public final int F2\n+                            \"\"\",\n+                            \"\"\"\n+                            Constructors\n+                            public C1()\n+                            public C1(int i)\n+                            \"\"\",\n+                            \"\"\"\n+                            Methods\n+                            public void run()\n+                            public void test()\n+                            \"\"\");\n+            Assertions.assertEquals(expectedUnchangedTextsModule, unchangedTexts);\n+        }\n+    }\n+\n+    @Test\n+    public void testSomeUnchanged() throws IOException {\n+        \/\/one method in C1 with a changed javadoc, and module info changed:\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        Path originalDir = base.resolve(\"original\").resolve(\"src\");\n+        Path updatedDir = base.resolve(\"updated\").resolve(\"src\");\n+\n+        for (Path target : new Path[] {originalDir, updatedDir}) {\n+            ModuleBuilder m;\n+            if (target == originalDir) {\n+                m =\n+                    new ModuleBuilder(tb, \"m\")\n+                            .exports(\"p\").exports(\"p2\").exports(\"p3\")\n+                            .opens(\"p\").opens(\"p2\").opens(\"p3\")\n+                            .provides(\"java.lang.Runnable\", \"p.C1\", \"p.C2\")\n+                            .provides(\"java.lang.FunctionalInterface\", \"p2.C\")\n+                            .uses(\"java.lang.Runnable\")\n+                            .uses(\"java.lang.FunctionalInterface\")\n+                            .requiresTransitive(\"java.compiler\")\n+                            .requiresTransitive(\"jdk.compiler\");\n+            } else {\n+                m =\n+                    new ModuleBuilder(tb, \"m\")\n+                            .exports(\"p\").exports(\"p3\").exports(\"p4\")\n+                            .opens(\"p\").opens(\"p3\").opens(\"p4\")\n+                            .provides(\"java.lang.Runnable\", \"p.C1\", \"p4.C\")\n+                            .provides(\"java.lang.FunctionalInterface\", \"p2.C\")\n+                            .provides(\"java.io.Serializable\", \"p4.C\")\n+                            .uses(\"java.io.Serializable\")\n+                            .uses(\"java.lang.FunctionalInterface\")\n+                            .requiresTransitive(\"java.compiler\")\n+                            .requiresTransitive(\"java.desktop\");\n+            }\n+\n+            if (target == originalDir) {\n+                m.classes(\"\"\"\n+                           package p;\n+                           \/** class documentation *\/\n+                           public class C1 implements Runnable {\n+                               \/** test field documentation1 *\/\n+                               public final int F1;\n+                               \/** test field documentation2 *\/\n+                               public final int F2;\n+                               \/** test constructor documentation1 *\/\n+                               public C1() {}\n+                               \/** test constructor documentation2 *\/\n+                               public C1(int i) {}\n+                               \/** test method documentation *\/\n+                               public void test() { }\n+                               \/** run method documentation *\/\n+                               public void run() { }\n+                           }\n+                           \"\"\");\n+            } else {\n+                m.classes(\"\"\"\n+                           package p;\n+                           \/** class documentation *\/\n+                           public class C1 implements Runnable {\n+                               \/** test field documentation1 - updated *\/\n+                               public final int F1;\n+                               \/** test field documentation2 *\/\n+                               public final int F2;\n+                               \/** test constructor documentation1 - updated *\/\n+                               public C1() {}\n+                               \/** test constructor documentation2 *\/\n+                               public C1(int i) {}\n+                               \/** test method documentation - updated *\/\n+                               public void test() { }\n+                               \/** run method documentation *\/\n+                               public void run() { }\n+                           }\n+                           \"\"\");\n+            }\n+\n+            m.classes(\"\"\"\n+                       package p;\n+                       \/** class documentation *\/\n+                       public class C2 implements Runnable {\n+                           \/** test method documentation *\/\n+                           public void test() { }\n+                           \/** run method documentation *\/\n+                           public void run() { }\n+                       }\n+                       \"\"\");\n+\n+            m.classes(\"\"\"\n+                       package p2;\n+                       \/** class documentation *\/\n+                       public class C implements FunctionalInterface {\n+                           \/** test method documentation *\/\n+                           public void test() { }\n+                           \/** run method documentation *\/\n+                           public void run() { }\n+                       }\n+                       \"\"\");\n+\n+            m.classes(\"\"\"\n+                       package p3;\n+                       \/** class documentation *\/\n+                       public class C {\n+                       }\n+                       \"\"\");\n+\n+            if (target == updatedDir) {\n+                m.classes(\"\"\"\n+                           package p4;\n+                           \/** class documentation *\/\n+                           public class C implements java.io.Serializable, Runnable {\n+                               \/** test method documentation *\/\n+                               public void test() { }\n+                               \/** run method documentation *\/\n+                               public void run() { }\n+                           }\n+                           \"\"\");\n+            }\n+\n+            m.write(target);\n+\n+            new ModuleBuilder(tb, \"m2\").write(target);\n+\n+            options.addAll(List.of(\n+                    \"--api\", target.getParent().getFileName().toString(),\n+                    \"--module-source-path\", target.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"--include\", \"m\/**\",\n+                \"--include\", \"m2\/**\",\n+                \"-d\", base.resolve(\"out\").toString(),\n+                \"--verbose\", \"missing\"));\n+\n+        log.println(\"Options: \" + options);\n+\n+        run(options);\n+\n+        {\n+            List<String> unchangedTexts =\n+                    gatherUnchangedTexts(base, \"out\/index.html\");\n+            List<String> expectedUnchangedTextsModule =\n+                    List.of(\" m2\");\n+            Assertions.assertEquals(expectedUnchangedTextsModule, unchangedTexts);\n+        }\n+\n+        {\n+            List<String> unchangedTexts =\n+                    gatherUnchangedTexts(base, \"out\/m\/module-summary.html\");\n+            List<String> expectedUnchangedTextsModule =\n+                    List.of(\" exports p\", \" exports p3\",\n+                            \" opens p\", \" opens p3\",\n+                            \" requires transitive java.compiler\",\n+                            \" p3\");\n+            Assertions.assertEquals(expectedUnchangedTextsModule, unchangedTexts);\n+        }\n+\n+        {\n+            List<String> unchangedTexts =\n+                    gatherUnchangedTexts(base, \"out\/m\/p\/package-summary.html\");\n+            List<String> expectedUnchangedTextsModule =\n+                    List.of(\" C2\");\n+            Assertions.assertEquals(expectedUnchangedTextsModule, unchangedTexts);\n+        }\n+\n+        {\n+            List<String> unchangedTexts =\n+                    gatherUnchangedTexts(base, \"out\/m\/p\/C1.html\");\n+            List<String> expectedUnchangedTextsModule =\n+                    List.of(\"public final int F2\\n\",\n+                            \"public C1(int i)\\n\",\n+                            \"public void run()\\n\");\n+            Assertions.assertEquals(expectedUnchangedTextsModule, unchangedTexts);\n+        }\n+    }\n+\n+    private List<String> gatherUnchangedTexts(Path base, String path) throws IOException {\n+        DocCommentTree html = parseHTML(base, path);\n+        List<String> unchangedTexts = new ArrayList<>();\n+\n+        new DocTreeScanner<>() {\n+            \/\/HTML elements which may hold the unchanged class:\n+            private static final Set<String> ELEMENTS_WITH_UNCHANGED_CLASS =\n+                    Set.of(\"span\", \"div\", \"li\");\n+            private final Stack<ElementDesc> nestedElements = new Stack<>();\n+            private boolean unchanged;\n+            private final StringBuilder unchangedText = new StringBuilder();\n+\n+            @Override\n+            public Object visitStartElement(StartElementTree node, Object p) {\n+                String name = node.getName().toString();\n+                \n+                if (ELEMENTS_WITH_UNCHANGED_CLASS.contains(name)) {\n+                    nestedElements.push(new ElementDesc(name, unchanged));\n+\n+                    for (DocTree t : node.getAttributes()) {\n+                        String treeText = t.toString();\n+                        if (treeText.contains(\"class=\") && treeText.contains(\"unchanged\")) {\n+                            unchanged = true;\n+                        }\n+                    }\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public Object visitEndElement(EndElementTree node, Object p) {\n+                String name = node.getName().toString();\n+                \n+                if (ELEMENTS_WITH_UNCHANGED_CLASS.contains(name)) {\n+                    ElementDesc removed = nestedElements.pop();\n+\n+                    if (!removed.name().equals(name)) {\n+                        throw new IllegalStateException(\"Unexpected name!\");\n+                    }\n+\n+                    boolean wasUnchanged = unchanged;\n+\n+                    unchanged = removed.previousUnchanged();\n+\n+                    if (wasUnchanged && !unchanged) {\n+                        String text = unchangedText.toString();\n+\n+                        unchangedTexts.add(text.replaceAll(\"\\n+\", \"\\n\"));\n+                        unchangedText.delete(0, unchangedText.length());\n+                    }\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public Object visitText(TextTree node, Object p) {\n+                if (unchanged) {\n+                    unchangedText.append(node.getBody());\n+                }\n+                return null;\n+            }\n+            \n+            record ElementDesc(String name, boolean previousUnchanged) {}\n+        }.scan(html, null);\n+\n+        return unchangedTexts;\n+    }\n+\n+    private DocCommentTree parseHTML(Path base, String path) throws IOException {\n+        String[] pathElements = path.split(\"\/\");\n+        Path fileToTest = base;\n+        for (String el : pathElements) {\n+            fileToTest = fileToTest.resolve(el);\n+        }\n+        String content = Files.readString(fileToTest);\n+        JavacTask task = (JavacTask) ToolProvider.getSystemJavaCompiler().getTask(null, null, null, null, null, null);\n+        DocTrees trees = DocTrees.instance(task);\n+        DocCommentTree html = trees.getDocCommentTree(new FileObject() {\n+            @Override\n+            public URI toUri() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public String getName() {\n+                return \"test.html\";\n+            }\n+\n+            @Override\n+            public InputStream openInputStream() throws IOException {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public OutputStream openOutputStream() throws IOException {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public Reader openReader(boolean ignoreEncodingErrors) throws IOException {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                return content;\n+            }\n+\n+            @Override\n+            public Writer openWriter() throws IOException {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public long getLastModified() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public boolean delete() {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+        });\n+        return html;\n+    }\n+}\n","filename":"test\/junit\/apitest\/UnchangedTest.java","additions":511,"deletions":0,"binary":false,"changes":511,"status":"added"}]}