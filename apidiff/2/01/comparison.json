{"files":[{"patch":"@@ -0,0 +1,13 @@\n+**.iml\n+.DS_store\n+.idea\n+\/.src-rev\n+\/build.properties\n+attic\n+build\n+dist\n+nbproject\n+out\n+play\n+tmp\n+webrev\n","filename":".gitignore","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+# Contributing to APIDiff\n+\n+APIDiff is part of the OpenJDK [CodeTools] Project.\n+\n+Please see <https:\/\/openjdk.java.net\/contribute\/> for how to contribute.\n+\n+\n+[CodeTools]: https:\/\/openjdk.java.net\/projects\/code-tools\n\\ No newline at end of file\n","filename":"CONTRIBUTING.md","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n","filename":"COPYRIGHT","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,347 @@\n+The GNU General Public License (GPL)\n+\n+Version 2, June 1991\n+\n+Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n+59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n+\n+Everyone is permitted to copy and distribute verbatim copies of this license\n+document, but changing it is not allowed.\n+\n+Preamble\n+\n+The licenses for most software are designed to take away your freedom to share\n+and change it.  By contrast, the GNU General Public License is intended to\n+guarantee your freedom to share and change free software--to make sure the\n+software is free for all its users.  This General Public License applies to\n+most of the Free Software Foundation's software and to any other program whose\n+authors commit to using it.  (Some other Free Software Foundation software is\n+covered by the GNU Library General Public License instead.) You can apply it to\n+your programs, too.\n+\n+When we speak of free software, we are referring to freedom, not price.  Our\n+General Public Licenses are designed to make sure that you have the freedom to\n+distribute copies of free software (and charge for this service if you wish),\n+that you receive source code or can get it if you want it, that you can change\n+the software or use pieces of it in new free programs; and that you know you\n+can do these things.\n+\n+To protect your rights, we need to make restrictions that forbid anyone to deny\n+you these rights or to ask you to surrender the rights.  These restrictions\n+translate to certain responsibilities for you if you distribute copies of the\n+software, or if you modify it.\n+\n+For example, if you distribute copies of such a program, whether gratis or for\n+a fee, you must give the recipients all the rights that you have.  You must\n+make sure that they, too, receive or can get the source code.  And you must\n+show them these terms so they know their rights.\n+\n+We protect your rights with two steps: (1) copyright the software, and (2)\n+offer you this license which gives you legal permission to copy, distribute\n+and\/or modify the software.\n+\n+Also, for each author's protection and ours, we want to make certain that\n+everyone understands that there is no warranty for this free software.  If the\n+software is modified by someone else and passed on, we want its recipients to\n+know that what they have is not the original, so that any problems introduced\n+by others will not reflect on the original authors' reputations.\n+\n+Finally, any free program is threatened constantly by software patents.  We\n+wish to avoid the danger that redistributors of a free program will\n+individually obtain patent licenses, in effect making the program proprietary.\n+To prevent this, we have made it clear that any patent must be licensed for\n+everyone's free use or not licensed at all.\n+\n+The precise terms and conditions for copying, distribution and modification\n+follow.\n+\n+TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n+\n+0. This License applies to any program or other work which contains a notice\n+placed by the copyright holder saying it may be distributed under the terms of\n+this General Public License.  The \"Program\", below, refers to any such program\n+or work, and a \"work based on the Program\" means either the Program or any\n+derivative work under copyright law: that is to say, a work containing the\n+Program or a portion of it, either verbatim or with modifications and\/or\n+translated into another language.  (Hereinafter, translation is included\n+without limitation in the term \"modification\".) Each licensee is addressed as\n+\"you\".\n+\n+Activities other than copying, distribution and modification are not covered by\n+this License; they are outside its scope.  The act of running the Program is\n+not restricted, and the output from the Program is covered only if its contents\n+constitute a work based on the Program (independent of having been made by\n+running the Program).  Whether that is true depends on what the Program does.\n+\n+1. You may copy and distribute verbatim copies of the Program's source code as\n+you receive it, in any medium, provided that you conspicuously and\n+appropriately publish on each copy an appropriate copyright notice and\n+disclaimer of warranty; keep intact all the notices that refer to this License\n+and to the absence of any warranty; and give any other recipients of the\n+Program a copy of this License along with the Program.\n+\n+You may charge a fee for the physical act of transferring a copy, and you may\n+at your option offer warranty protection in exchange for a fee.\n+\n+2. You may modify your copy or copies of the Program or any portion of it, thus\n+forming a work based on the Program, and copy and distribute such modifications\n+or work under the terms of Section 1 above, provided that you also meet all of\n+these conditions:\n+\n+    a) You must cause the modified files to carry prominent notices stating\n+    that you changed the files and the date of any change.\n+\n+    b) You must cause any work that you distribute or publish, that in whole or\n+    in part contains or is derived from the Program or any part thereof, to be\n+    licensed as a whole at no charge to all third parties under the terms of\n+    this License.\n+\n+    c) If the modified program normally reads commands interactively when run,\n+    you must cause it, when started running for such interactive use in the\n+    most ordinary way, to print or display an announcement including an\n+    appropriate copyright notice and a notice that there is no warranty (or\n+    else, saying that you provide a warranty) and that users may redistribute\n+    the program under these conditions, and telling the user how to view a copy\n+    of this License.  (Exception: if the Program itself is interactive but does\n+    not normally print such an announcement, your work based on the Program is\n+    not required to print an announcement.)\n+\n+These requirements apply to the modified work as a whole.  If identifiable\n+sections of that work are not derived from the Program, and can be reasonably\n+considered independent and separate works in themselves, then this License, and\n+its terms, do not apply to those sections when you distribute them as separate\n+works.  But when you distribute the same sections as part of a whole which is a\n+work based on the Program, the distribution of the whole must be on the terms\n+of this License, whose permissions for other licensees extend to the entire\n+whole, and thus to each and every part regardless of who wrote it.\n+\n+Thus, it is not the intent of this section to claim rights or contest your\n+rights to work written entirely by you; rather, the intent is to exercise the\n+right to control the distribution of derivative or collective works based on\n+the Program.\n+\n+In addition, mere aggregation of another work not based on the Program with the\n+Program (or with a work based on the Program) on a volume of a storage or\n+distribution medium does not bring the other work under the scope of this\n+License.\n+\n+3. You may copy and distribute the Program (or a work based on it, under\n+Section 2) in object code or executable form under the terms of Sections 1 and\n+2 above provided that you also do one of the following:\n+\n+    a) Accompany it with the complete corresponding machine-readable source\n+    code, which must be distributed under the terms of Sections 1 and 2 above\n+    on a medium customarily used for software interchange; or,\n+\n+    b) Accompany it with a written offer, valid for at least three years, to\n+    give any third party, for a charge no more than your cost of physically\n+    performing source distribution, a complete machine-readable copy of the\n+    corresponding source code, to be distributed under the terms of Sections 1\n+    and 2 above on a medium customarily used for software interchange; or,\n+\n+    c) Accompany it with the information you received as to the offer to\n+    distribute corresponding source code.  (This alternative is allowed only\n+    for noncommercial distribution and only if you received the program in\n+    object code or executable form with such an offer, in accord with\n+    Subsection b above.)\n+\n+The source code for a work means the preferred form of the work for making\n+modifications to it.  For an executable work, complete source code means all\n+the source code for all modules it contains, plus any associated interface\n+definition files, plus the scripts used to control compilation and installation\n+of the executable.  However, as a special exception, the source code\n+distributed need not include anything that is normally distributed (in either\n+source or binary form) with the major components (compiler, kernel, and so on)\n+of the operating system on which the executable runs, unless that component\n+itself accompanies the executable.\n+\n+If distribution of executable or object code is made by offering access to copy\n+from a designated place, then offering equivalent access to copy the source\n+code from the same place counts as distribution of the source code, even though\n+third parties are not compelled to copy the source along with the object code.\n+\n+4. You may not copy, modify, sublicense, or distribute the Program except as\n+expressly provided under this License.  Any attempt otherwise to copy, modify,\n+sublicense or distribute the Program is void, and will automatically terminate\n+your rights under this License.  However, parties who have received copies, or\n+rights, from you under this License will not have their licenses terminated so\n+long as such parties remain in full compliance.\n+\n+5. You are not required to accept this License, since you have not signed it.\n+However, nothing else grants you permission to modify or distribute the Program\n+or its derivative works.  These actions are prohibited by law if you do not\n+accept this License.  Therefore, by modifying or distributing the Program (or\n+any work based on the Program), you indicate your acceptance of this License to\n+do so, and all its terms and conditions for copying, distributing or modifying\n+the Program or works based on it.\n+\n+6. Each time you redistribute the Program (or any work based on the Program),\n+the recipient automatically receives a license from the original licensor to\n+copy, distribute or modify the Program subject to these terms and conditions.\n+You may not impose any further restrictions on the recipients' exercise of the\n+rights granted herein.  You are not responsible for enforcing compliance by\n+third parties to this License.\n+\n+7. If, as a consequence of a court judgment or allegation of patent\n+infringement or for any other reason (not limited to patent issues), conditions\n+are imposed on you (whether by court order, agreement or otherwise) that\n+contradict the conditions of this License, they do not excuse you from the\n+conditions of this License.  If you cannot distribute so as to satisfy\n+simultaneously your obligations under this License and any other pertinent\n+obligations, then as a consequence you may not distribute the Program at all.\n+For example, if a patent license would not permit royalty-free redistribution\n+of the Program by all those who receive copies directly or indirectly through\n+you, then the only way you could satisfy both it and this License would be to\n+refrain entirely from distribution of the Program.\n+\n+If any portion of this section is held invalid or unenforceable under any\n+particular circumstance, the balance of the section is intended to apply and\n+the section as a whole is intended to apply in other circumstances.\n+\n+It is not the purpose of this section to induce you to infringe any patents or\n+other property right claims or to contest validity of any such claims; this\n+section has the sole purpose of protecting the integrity of the free software\n+distribution system, which is implemented by public license practices.  Many\n+people have made generous contributions to the wide range of software\n+distributed through that system in reliance on consistent application of that\n+system; it is up to the author\/donor to decide if he or she is willing to\n+distribute software through any other system and a licensee cannot impose that\n+choice.\n+\n+This section is intended to make thoroughly clear what is believed to be a\n+consequence of the rest of this License.\n+\n+8. If the distribution and\/or use of the Program is restricted in certain\n+countries either by patents or by copyrighted interfaces, the original\n+copyright holder who places the Program under this License may add an explicit\n+geographical distribution limitation excluding those countries, so that\n+distribution is permitted only in or among countries not thus excluded.  In\n+such case, this License incorporates the limitation as if written in the body\n+of this License.\n+\n+9. The Free Software Foundation may publish revised and\/or new versions of the\n+General Public License from time to time.  Such new versions will be similar in\n+spirit to the present version, but may differ in detail to address new problems\n+or concerns.\n+\n+Each version is given a distinguishing version number.  If the Program\n+specifies a version number of this License which applies to it and \"any later\n+version\", you have the option of following the terms and conditions either of\n+that version or of any later version published by the Free Software Foundation.\n+If the Program does not specify a version number of this License, you may\n+choose any version ever published by the Free Software Foundation.\n+\n+10. If you wish to incorporate parts of the Program into other free programs\n+whose distribution conditions are different, write to the author to ask for\n+permission.  For software which is copyrighted by the Free Software Foundation,\n+write to the Free Software Foundation; we sometimes make exceptions for this.\n+Our decision will be guided by the two goals of preserving the free status of\n+all derivatives of our free software and of promoting the sharing and reuse of\n+software generally.\n+\n+NO WARRANTY\n+\n+11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR\n+THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN OTHERWISE\n+STATED IN WRITING THE COPYRIGHT HOLDERS AND\/OR OTHER PARTIES PROVIDE THE\n+PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,\n+INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND\n+PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE,\n+YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n+\n+12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL\n+ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND\/OR REDISTRIBUTE THE\n+PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\n+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR\n+INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA\n+BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A\n+FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER\n+OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n+\n+END OF TERMS AND CONDITIONS\n+\n+How to Apply These Terms to Your New Programs\n+\n+If you develop a new program, and you want it to be of the greatest possible\n+use to the public, the best way to achieve this is to make it free software\n+which everyone can redistribute and change under these terms.\n+\n+To do so, attach the following notices to the program.  It is safest to attach\n+them to the start of each source file to most effectively convey the exclusion\n+of warranty; and each file should have at least the \"copyright\" line and a\n+pointer to where the full notice is found.\n+\n+    One line to give the program's name and a brief idea of what it does.\n+\n+    Copyright (C) <year> <name of author>\n+\n+    This program is free software; you can redistribute it and\/or modify it\n+    under the terms of the GNU General Public License as published by the Free\n+    Software Foundation; either version 2 of the License, or (at your option)\n+    any later version.\n+\n+    This program is distributed in the hope that it will be useful, but WITHOUT\n+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+    more details.\n+\n+    You should have received a copy of the GNU General Public License along\n+    with this program; if not, write to the Free Software Foundation, Inc., 59\n+    Temple Place, Suite 330, Boston, MA 02111-1307 USA\n+\n+Also add information on how to contact you by electronic and paper mail.\n+\n+If the program is interactive, make it output a short notice like this when it\n+starts in an interactive mode:\n+\n+    Gnomovision version 69, Copyright (C) year name of author Gnomovision comes\n+    with ABSOLUTELY NO WARRANTY; for details type 'show w'.  This is free\n+    software, and you are welcome to redistribute it under certain conditions;\n+    type 'show c' for details.\n+\n+The hypothetical commands 'show w' and 'show c' should show the appropriate\n+parts of the General Public License.  Of course, the commands you use may be\n+called something other than 'show w' and 'show c'; they could even be\n+mouse-clicks or menu items--whatever suits your program.\n+\n+You should also get your employer (if you work as a programmer) or your school,\n+if any, to sign a \"copyright disclaimer\" for the program, if necessary.  Here\n+is a sample; alter the names:\n+\n+    Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n+    'Gnomovision' (which makes passes at compilers) written by James Hacker.\n+\n+    signature of Ty Coon, 1 April 1989\n+\n+    Ty Coon, President of Vice\n+\n+This General Public License does not permit incorporating your program into\n+proprietary programs.  If your program is a subroutine library, you may\n+consider it more useful to permit linking proprietary applications with the\n+library.  If this is what you want to do, use the GNU Library General Public\n+License instead of this License.\n+\n+\n+\"CLASSPATH\" EXCEPTION TO THE GPL\n+\n+Certain source files distributed by Sun Microsystems, Inc.  are subject to\n+the following clarification and special exception to the GPL, but only where\n+Sun has expressly included in the particular source file's header the words\n+\"Sun designates this particular file as subject to the \"Classpath\" exception\n+as provided by Sun in the LICENSE file that accompanied this code.\"\n+\n+    Linking this library statically or dynamically with other modules is making\n+    a combined work based on this library.  Thus, the terms and conditions of\n+    the GNU General Public License cover the whole combination.\n+\n+    As a special exception, the copyright holders of this library give you\n+    permission to link this library with independent modules to produce an\n+    executable, regardless of the license terms of these independent modules,\n+    and to copy and distribute the resulting executable under terms of your\n+    choice, provided that you also meet, for each linked independent module,\n+    the terms and conditions of the license of that module.  An independent\n+    module is a module which is not derived from or based on this library.  If\n+    you modify this library, you may extend this exception to your version of\n+    the library, but you are not obligated to do so.  If you do not wish to do\n+    so, delete this exception statement from your version.\n","filename":"LICENSE","additions":347,"deletions":0,"binary":false,"changes":347,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+# APIDiff\n+\n+APIDiff is a utility to compare two or more versions of an API, each as\n+defined by a series of options similar to those supported by `javac`.\n+\n+## Building `apidiff`\n+\n+`apidiff` uses the following dependencies:\n+\n+* _[Daisy Diff]_: an HTML comparison library, required when building `apidiff`\n+* _[Java Diff Utils]_: a plain-text comparison library, required when building `apidiff`\n+* _[TestNG]_: the testing framework, used to run some of the tests for `apidiff`\n+\n+Suitable versions of these dependencies can be downloaded by running\n+`make\/build.sh`.\n+\n+### Building with Apache Ant\n+\n+The default configuration assumes that dependencies have been downloaded\n+into the `build\/deps` directory.\n+These values can be overridden with project-specific local configuration values\n+in `build.properties`, if it exists in the root directory of the repo.\n+\n+````\n+    ant -f make\/build.xml <target>\n+````\n+\n+### Building with GNU Make\n+\n+The default configuration uses values provided in `make\/dependencies.gmk`,\n+unless these values have been overridden on the command line used to run `make`.\n+\n+````\n+    make -C make Makefile <target>\n+````\n+\n+### Building with an IDE\n+\n+An IDE such as IntelliJ IDEA needs the following configuration:\n+\n+* Sources Root: `src`\n+* TestNG Test Root: `test\/testng`\n+* Libraries:\n+  * _Daisy Diff_, _Java Diff Utils_ available for compilation\n+  * _TestNG_ available for testing\n+\n+In addition, some TestNG tests require access to internal classes in\n+the `jdk.compiler` and `jdk.jdeps` modules:\n+\n+````\n+--add-exports jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED\n+--add-exports jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\n+--add-modules jdk.jdeps\n+--add-exports jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED\n+````\n+\n+The following compiler options may also be desirable:\n+\n+````\n+-Xdoclint:missing\/protected\n+-Xlint:unchecked\n+````\n+\n+_Note:_ When working on the test files, be careful not to mark module source directories\n+as `Test Sources Root` at the same time as any source directories that are not \n+for a module.\n+\n+## Documentation\n+\n+A \"man\" page is generated as part of the build, and is the primary source\n+of information for how to run `apidiff`.\n+\n+## ShowDocs\n+\n+`showDocs` is a small utility program that is a simple wrapper around the \n+`APIReader` and `SerializedFormReader` classes in `apidiff`, that can provide\n+filtered views of the files generated by `javadoc`, in order to view the\n+parts of those files that will be compared by `apidiff`.\n+\n+\n+[Daisy Diff]: https:\/\/github.com\/DaisyDiff\/DaisyDiff\n+[Java Diff Utils]: https:\/\/github.com\/java-diff-utils\/java-diff-utils\n+[TestNG]: https:\/\/testng.org\/\n","filename":"README.md","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,1367 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+# This program will download\/build the dependencies for apidiff and then\n+# build apidiff. Downloaded files are verified against known\/specified\n+# checksums.\n+#\n+# The program can be executed directly as a single source-file program\n+# by the Java launcher, using JDK 12 or later.\n+#\n+#     $ \/path\/to\/jdk  make\/Build.java  options\n+#\n+# For help on command-line options, use the --help option.\n+# Note: apidiff itself requires JDK 17 or later.\n+\n+# As a side effect, the program writes a file build\/make.sh which\n+# can subsequently be used directly to build apidiff, bypassing\n+# the need to rerun this program if all the dependencies are still\n+# available.\n+\n+# The default version to use when building apidiff can be found in the\n+# make\/version-numbers file, where the default versions and\n+# corresponding known checksums for the dependencies are also\n+# specified. Almost all the defaults can be overridden by setting\n+# the properties on the command line, or in a properties file,\n+# or as environment variables.\n+\n+# For each of the dependency the following steps are applied and the\n+# first successful one is used:\n+#\n+# 1. Check if the dependency is available locally\n+# 2. Download a prebuilt version of the dependency\n+# 3. Build the dependency from source, downloading the source archive\n+#    first\n+#\n+# In particular, when not found locally the dependencies will be\n+# handled as follows:\n+#\n+# * JUnit, Java Diff Utils, and HtmlCleaner are by default downloaded from Maven Central.\n+# * Daisy Diff is by default built from source.\n+#\n+\n+# Some noteworthy control variables:\n+#\n+# MAVEN_REPO_URL_BASE (e.g. \"https:\/\/repo1.maven.org\/maven2\")\n+#     The base URL for the maven central repository.\n+#\n+# APIDIFF_VERSION         (e.g. \"1.0\")\n+# APIDIFF_VERSION_STRING  (e.g. \"apidiff-1.0+8\"\n+# APIDIFF_BUILD_NUMBER    (e.g. \"8\")\n+# APIDIFF_BUILD_MILESTONE (e.g. \"dev\")\n+#     The version information to use for when building apidiff.\n+#     Additional arguments to pass to make when building apidiff.\n+#\n+# RM, TAR, UNZIP\n+#     Paths to standard POSIX commands.\n+\n+# The control variables for dependencies are on the following general\n+# form (not all of them are relevant for all dependencies):\n+#\n+# <dependency>_URL (e.g. DAISYDIFF_BIN_ARCHIVE_URL)\n+#     The full URL for the dependency.\n+#\n+# <dependency>_URL_BASE (e.g. DAISYDIFF_BIN_ARCHIVE_URL_BASE)\n+#     The base URL for the dependency. Requires additional dependency\n+#     specific variables to be specified.\n+#\n+# <dependency>_CHECKSUM (e.g. DAISYDIFF_BIN_ARCHIVE_CHECKSUM)\n+#     The expected checksum of the download file.\n+#\n+\n+# The below outlines the details of how the dependencies are\n+# handled. For each dependency the steps are tried in order and the\n+# first successful one will be used.\n+#\n+# JDK\n+#     Checksum variables:\n+#         JDK_ARCHIVE_CHECKSUM: checksum of binary archive\n+#\n+#     1. JAVA_HOME\n+#         The path to the JDK.\n+#     2a. JDK_ARCHIVE_URL\n+#         The full URL for the archive.\n+#     2b. JDK_ARCHIVE_URL_BASE + JDK_VERSION + JDK_BUILD_NUMBER + JDK_FILE\n+#         The individual URL components used to construct the full URL.\n+#\n+# Java Diff Utils\n+#     Checksum variables:\n+#         JAVADIFFUTILS_JAR_CHECKSUM: checksum of jar\n+#         JAVADIFFUTILS_LICENSE_CHECKSUM: checksum of LICENSE file\n+#\n+#     1. JAVADIFFUTILS_JAR + JAVADIFFUTILS_LICENSE\n+#         The path to java-diff-utils.jar and LICENSE.txt respectively.\n+#     2a. JAVADIFFUTILS_JAR_URL\n+#         The full URL for the jar.\n+#     2b. JAVADIFFUTILS_JAR_URL_BASE + JAVADIFFUTILS_VERSION + JAVADIFFUTILS_FILE\n+#         The individual URL components used to construct the full URL.\n+#\n+# Daisy Diff\n+#     Checksum variables:\n+#         DAISYDIFF_BIN_ARCHIVE_CHECKSUM: checksum of binary archive\n+#         DAISYDIFF_LICENSE_CHECKSUM: checksum of LICENSE file\n+#\n+#     1. DAISYDIFF_JAR + DAISYDIFF_LICENSE\n+#         The path to daisydiff.jar and LICENSE.txt respectively.\n+#     2a. DAISYDIFF_JAR_URL\n+#         The full URL for the jar.\n+#     2b. DAISYDIFF_JAR_URL_BASE + DAISYDIFF_BIN_VERSION + DAISYDIFF_FILE\n+#         The individual URL components used to construct the full URL.\n+#\n+# Html Cleaner\n+#     Checksum variables:\n+#         HTMLCLEANER_JAR_CHECKSUM: checksum of jar\n+#         HTMLCLEANER_LICENSE_CHECKSUM: checksum of LICENSE file\n+#\n+#     1. HTMLCLEANER_JAR + HTMLCLEANER_LICENSE\n+#         The path to htmlcleaner.jar and licence.txt respectively.\n+#     2a. HTMLCLEANER_JAR_URL\n+#         The full URL for the jar.\n+#     2b. HTMLCLEANER_JAR_URL_BASE + HTMLCLEANER_VERSION + HTMLCLEANER_FILE\n+#         The individual URL components used to construct the full URL.\n+#\n+# JUnit, for running self-tests\n+#     Checksum variables:\n+#         JUNIT_JAR_CHECKSUM: checksum of binary archive\n+#\n+#     1. JUNIT_JAR + JUNIT_LICENSE\n+#         The path to junit.jar and LICENSE respectively.\n+#     2a. JUNIT_JAR_URL\n+#         The full URL for the jar.\n+#     2b. JUNIT_JAR_URL_BASE + JUNIT_VERSION + JUNIT_FILE\n+#         The individual URL components used to construct the full URL.\n+#\n+# Some control variables can be overridden by command-line options.\n+# Use the  --help option for details.\n+*\/\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.reflect.Field;\n+import java.net.MalformedURLException;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.FileTime;\n+import java.security.DigestInputStream;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+import java.util.function.BiFunction;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Utility to download the dependencies needed to build APIDiff,\n+ * based on command-line parameters, configuration info in\n+ * make\/build-support\/version-numbers, and environment variables.\n+ *\n+ * <p>The class can be executed directly by the Java source code launcher,\n+ * using JDK 17 or later.\n+ *\/\n+public class Build {\n+    public enum Exit {\n+        OK, BAD_OPTION, ERROR\n+    }\n+\n+    \/**\n+     * Execute the main program.\n+     *\n+     * @param args command-line arguments\n+     *\/\n+    public static void main(String... args) {\n+        try {\n+            PrintWriter outWriter = new PrintWriter(System.out);\n+            PrintWriter errWriter = new PrintWriter(System.err, true);\n+            try {\n+                try {\n+                    new Build().run(outWriter, errWriter, args);\n+                } finally {\n+                    outWriter.flush();\n+                }\n+            } finally {\n+                errWriter.flush();\n+            }\n+            System.exit(Exit.OK.ordinal());\n+        } catch (BadOption e) {\n+            System.err.println(\"Error: \" + e.getMessage());\n+            System.exit(Exit.BAD_OPTION.ordinal());\n+        } catch (Fault e) {\n+            System.err.println(\"Error: \" + e.getMessage());\n+            System.exit(Exit.ERROR.ordinal());\n+        }\n+    }\n+\n+    \/**\n+     * The root directory for the repo containing this class.\n+     *\/\n+    private final Path rootDir;\n+\n+    \/**\n+     * The minimum version of JDK required to build apidiff.\n+     *\/\n+    private static final int requiredJDKVersion = 17;\n+\n+    \/**\n+     * Creates an instance of the utility.\n+     *\n+     * @throws Fault if an unrecoverable error occurs while determining the root directory\n+     *\/\n+    Build() throws Fault {\n+        rootDir = getRootDir();\n+    }\n+\n+    \/**\n+     * The main worker method for the utility.\n+     *\n+     * @param out the stream to which to write any requested output\n+     * @param err the stream to which to write any logging or error output\n+     * @param args any command-line arguments\n+     * @throws BadOption if there is an error in any of the command-line arguments\n+     * @throws Fault if there is an unrecoverable error\n+     *\/\n+    public void run(PrintWriter out, PrintWriter err, String... args) throws BadOption, Fault {\n+\n+        \/\/ The collection of values specified by the command-line options.\n+        var options = Options.handle(rootDir, List.of(args));\n+\n+        \/\/ The collection of values derived from command-line options,\n+        \/\/ the make\/build-support\/version-numbers file, and default values.\n+        var config = new Config(rootDir, options, out, err);\n+\n+        var done = false;\n+\n+        if (options.help) {\n+            options.showCommandHelp(config.out);\n+            done = true;\n+        }\n+\n+        if (options.showDefaultVersions) {\n+            showProperties(config.properties, config.out);\n+            done = true;\n+        }\n+\n+        if (options.showConfigDetails) {\n+            if (config.properties.isEmpty()) {\n+                config.out.println(\"no custom configuration values\");\n+            } else {\n+                showProperties(config.properties, config.out);\n+            }\n+            done = true;\n+        }\n+\n+        if (done) {\n+            return;\n+        }\n+\n+        DaisyDiff dd;\n+        var dependencies = List.of(\n+                new BuildInfo(config),\n+                dd = new DaisyDiff(config),\n+                new Equinox(config, dd),\n+                new HtmlCleaner(config),\n+                new JavaDiffUtils(config),\n+                new JUnit(config)\n+        );\n+\n+        for (var d : dependencies) {\n+            d.setup();\n+        }\n+\n+        for (var d : dependencies) {\n+            d.verify();\n+        }\n+\n+        var makeScript = config.buildDir.resolve(\"make.sh\");\n+        new MakeScript(config).writeFile(makeScript, dependencies);\n+\n+        if (!options.skipMake) {\n+            config.log(\"Building\");\n+            config.out.flush();\n+            config.err.flush();\n+            execScript(makeScript, config.options.makeArgs);\n+        }\n+    }\n+\n+    \/**\n+     * Writes a set of properties to a given output stream.\n+     *\n+     * @param p the properties\n+     * @param out the output stream\n+     *\/\n+    private static void showProperties(Properties p, PrintWriter out) {\n+        p.stringPropertyNames().stream()\n+                .sorted()\n+                .forEach(k -> out.println(k + \"=\" + p.getProperty(k)));\n+    }\n+\n+    \/**\n+     * Executes a shell script.\n+     *\n+     * @param script the path for the script\n+     * @param args the arguments, if any, for the script\n+     * @throws Fault if an error occurs while executing the script\n+     *\/\n+    private static void execScript(Path script, List<String> args) throws Fault {\n+        try {\n+            Process p = new ProcessBuilder(join(\"sh\", join(script.toString(), args)))\n+                    .redirectError(ProcessBuilder.Redirect.INHERIT)\n+                    .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n+                    .start();\n+            p.waitFor();\n+            int rc = p.exitValue();\n+            if (rc != 0) {\n+                throw new Fault(\"Error while running \" + script + \": rc=\" + rc);\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            throw new Fault(\"error running \" + script + \": \" + e);\n+        }\n+    }\n+\n+    \/**\n+     * Forms a single list from a string and a list of strings.\n+     *\n+     * @param cmd the string\n+     * @param args the list of strings\n+     * @return a list formed from the string and list of strings\n+     *\/\n+    private static List<String> join(String cmd, List<String> args) {\n+        if (args.isEmpty()) {\n+            return List.of(cmd);\n+        }\n+        var list = new ArrayList<String>();\n+        list.add(cmd);\n+        list.addAll(args);\n+        return list;\n+    }\n+\n+    \/**\n+     * Returns the root directory for the repo containing this class,\n+     * as determined by checking enclosing directories for the marker\n+     * file make\/Makefile.\n+     *\n+     * @return the root directory\n+     * @throws Fault if the root directory cannot be determined\n+     *\/\n+    private static Path getRootDir() throws Fault {\n+        Path dir = getThisClass().getParent();\n+        Path marker = Path.of(\"make\").resolve(\"Makefile\");\n+        while (dir != null) {\n+            if (Files.isRegularFile(dir.resolve(marker))) {\n+                return dir;\n+            }\n+            dir = dir.getParent();\n+        }\n+        throw new Fault(\"cannot determine root directory\");\n+    }\n+\n+    \/**\n+     * Returns the path for this class, determined from the location in\n+     * the class' protection domain.\n+     *\n+     * @return the path\n+     * @throws Fault if an error occurs\n+     *\/\n+    private static Path getThisClass() throws Fault {\n+        try {\n+            return Path.of(Build.class.getProtectionDomain().getCodeSource().getLocation().toURI());\n+        } catch (URISyntaxException e) {\n+            throw new Fault(\"cannot determine location of this class\");\n+        }\n+    }\n+\n+    \/**\n+     * Exception used to report a bad command-line option.\n+     *\/\n+    static class BadOption extends Exception {\n+        BadOption(String message) {\n+            super(message);\n+        }\n+        BadOption(String message, Throwable cause) {\n+            super(message, cause);\n+        }\n+    }\n+\n+    \/**\n+     * Exception used to report an unrecoverable error.\n+     *\/\n+    static class Fault extends Exception {\n+        Fault(String message) {\n+            super(message);\n+        }\n+        Fault(String message, Throwable cause) {\n+            super(message, cause);\n+        }\n+    }\n+\n+    \/**\n+     * The set of allowable command-line options.\n+     *\/\n+    enum Option {\n+        @Description(\"Show this message\")\n+        HELP(\"--help -h -help -?\", null) {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.help = true;\n+            }\n+        },\n+\n+        @Description(\"Path to JDK; must be JDK \" + requiredJDKVersion + \" or higher\")\n+        JDK(\"--jdk\", \"<jdk>\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.jdk = asExistingPath(arg);\n+            }\n+        },\n+\n+        @Description(\"Reduce the logging output\")\n+        QUIET(\"--quiet -q\", null) {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.quiet = true;\n+            }\n+        },\n+\n+        @Description(\"Show default versions of external components\")\n+        SHOW_DEFAULT_VERSIONS(\"--show-default-versions\", null) {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.showDefaultVersions = true;\n+            }\n+        },\n+\n+        @Description(\"Show configuration details\")\n+        SHOW_CONFIG_DETAILS(\"--show-config-details\", null) {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.showConfigDetails = true;\n+            }\n+        },\n+\n+        @Description(\"Skip checksum check\")\n+        SKIP_CHECKSUM_CHECK(\"--skip-checksum-check\", null) {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.skipChecksumCheck = true;\n+            }\n+        },\n+\n+        @Description(\"Skip downloads if file available locally\")\n+        SKIP_DOWNLOAD(\"--skip-download\", null) {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.skipDownloads = true;\n+            }\n+        },\n+\n+        @Description(\"Skip running 'make' (just download dependencies if needed)\")\n+        SKIP_MAKE(\"--skip-make\", null) {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.skipMake = true;\n+            }\n+        },\n+\n+        @Description(\"Provide an alternate file containing dependency version information\")\n+        VERSION_NUMBERS(\"--version-numbers\", \"<file>\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.versionNumbers = asExistingPath(arg);\n+            }\n+        },\n+\n+        @Description(\"Provide an alternate file containing configuration details\")\n+        CONFIG_FILE(\"--config\", \"<file>\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption, Fault {\n+                var p = asExistingPath(arg);\n+                try (BufferedReader r = Files.newBufferedReader(p)) {\n+                    options.configProperties.load(r);\n+                } catch (IOException e) {\n+                    throw new Fault(\"error reading \" + p + \": \" + e, e);\n+                }\n+            }\n+        },\n+\n+        @Description(\"Override a specific configuration value\")\n+        CONFIG_VALUE(\"NAME=VALUE\", null),\n+\n+        @Description(\"Subsequent arguments are for 'make'\")\n+        MAKE_ARGS(\"--\", null);\n+\n+        @Retention(RetentionPolicy.RUNTIME)\n+        @interface Description {\n+            String value();\n+        }\n+\n+        final List<String> names;\n+        final String arg;\n+\n+        Option(String names, String arg) {\n+            this.names = Arrays.asList(names.split(\"\\\\s+\"));\n+            this.arg = arg;\n+        }\n+\n+        void process(String opt, String arg, Options options) throws BadOption, Fault {\n+            throw new Error(\"internal error\");\n+        }\n+\n+        static Path asPath(String p) throws BadOption {\n+            try {\n+                return Path.of(p);\n+            } catch (InvalidPathException e) {\n+                throw new BadOption(\"File not found: \" + p, e);\n+            }\n+        }\n+\n+        static Path asExistingPath(String p) throws BadOption {\n+            var path = asPath(p);\n+            if (!Files.exists(path)) {\n+                throw new BadOption(\"File not found: \" + p);\n+            }\n+            return path;\n+        }\n+    }\n+\n+    \/**\n+     * The set of values given by the command-line options.\n+     *\/\n+    static class Options {\n+        boolean help;\n+        Path jdk;\n+        boolean quiet;\n+        boolean showDefaultVersions;\n+        boolean showConfigDetails;\n+        boolean skipChecksumCheck;\n+        boolean skipDownloads;\n+        boolean skipMake;\n+        private Path versionNumbers;\n+        private List<String> makeArgs = List.of();\n+\n+        final private Properties configProperties;\n+\n+        Options(Path rootDir) {\n+            var dir = rootDir.resolve(\"make\").resolve(\"build-support\");\n+            versionNumbers = dir.resolve(\"version-numbers\");\n+            configProperties = new Properties();\n+        }\n+\n+        static Options handle(Path rootDir, List<String> args) throws BadOption, Fault {\n+            Options options = new Options(rootDir);\n+\n+            Map<String, Option> map = new HashMap<>();\n+            for (Option o : Option.values()) {\n+                o.names.forEach(n -> map.put(n, o));\n+            }\n+\n+            for (int i = 0; i < args.size(); i++) {\n+                String arg = args.get(i);\n+                \/\/ currently no support for positional args\n+                String optName, optValue;\n+                int eq = arg.indexOf(\"=\");\n+                if (eq == -1) {\n+                    optName = arg;\n+                    optValue = null;\n+                } else {\n+                    optName = arg.substring(0, eq);\n+                    optValue = arg.substring(eq + 1);\n+                }\n+                if (optName.isEmpty()) {\n+                    throw new BadOption(\"bad argument: \" + arg);\n+                } else {\n+                    Option opt = map.get(optName);\n+                    if (opt == null) {\n+                        if (optName.matches(\"[A-Z_]+\")) {\n+                            options.configProperties.setProperty(optName, optValue);\n+                        } else {\n+                            throw new BadOption(\"unknown option: \" + optName);\n+                        }\n+                    } else {\n+                        if (opt == Option.MAKE_ARGS) {\n+                            options.makeArgs = args.subList(i + 1, args.size());\n+                            i = args.size();\n+                        } else if (opt.arg == null) {\n+                            \/\/ no value for option required\n+                            if (optValue != null) {\n+                                throw new BadOption(\"unexpected value for \" + optName + \" option: \" + optValue);\n+                            } else {\n+                                opt.process(optName, null, options);\n+                            }\n+                        } else {\n+                            \/\/ value for option required; use next arg if not found after '='\n+                            if (optValue == null) {\n+                                if (i + 1 < args.size()) {\n+                                    optValue = args.get(++i);\n+                                } else {\n+                                    throw new BadOption(\"no value for \" + optName + \" option\");\n+                                }\n+                            }\n+                            opt.process(optName, optValue, options);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return options;\n+        }\n+\n+        void showCommandHelp(PrintWriter out) {\n+            out.println(\"Usage: java \" + Build.class.getSimpleName() + \".java \"\n+                    + \"<options> [ -- <make options and target>]\" );\n+            out.println(\"Options:\");\n+            for (var o : Option.values()) {\n+                out.println(o.names.stream()\n+                        .map(n -> n + (o.arg == null ? \"\" : \" \" + o.arg))\n+                        .collect(Collectors.joining(\", \", \"  \", \"\")));\n+                try {\n+                    Field f = Option.class.getDeclaredField(o.name());\n+                    Option.Description d = f.getAnnotation(Option.Description.class);\n+                    out.println(\"      \" + d.value());\n+                } catch (ReflectiveOperationException e) {\n+                    throw new Error(e);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * The set of configuration values determined from command-line options,\n+     * the make\/build-support\/version-numbers file, and any defaults.\n+     *\/\n+    static class Config {\n+        final Path rootDir;\n+        final Options options;\n+        final PrintWriter out;\n+        final PrintWriter err;\n+        private final Path buildDir;\n+        private final Properties properties;\n+        private final Path jdk;\n+        private final Map<String, String>sysEnv;\n+\n+        Config(Path rootDir, Options options, PrintWriter out, PrintWriter err) throws Fault {\n+            this.rootDir = rootDir;\n+            this.options = options;\n+            this.out = out;\n+            this.err = err;\n+\n+            this.buildDir = rootDir.resolve(\"build\");\n+\n+            var versionNumbers = readProperties(options.versionNumbers);\n+            properties = new Properties(versionNumbers);\n+            properties.putAll(options.configProperties);\n+\n+            sysEnv = System.getenv();\n+\n+            var jdk = options.jdk;\n+            if (jdk == null) {\n+                jdk = getPath(\"JAVA_HOME\");\n+            }\n+            if (jdk == null) {\n+                jdk = Path.of(System.getProperty(\"java.home\"));\n+            }\n+            this.jdk = jdk;\n+        }\n+\n+        void log(String line) {\n+            if (!options.quiet) {\n+                err.println(line);\n+            }\n+        }\n+\n+        void error(String lines) {\n+            lines.lines().forEach(err::println);\n+        }\n+\n+        private String getString(String key) {\n+            var v = properties.getProperty(key);\n+            if (v == null) {\n+                if (key.endsWith(\"_VERSION\")\n+                        || key.endsWith(\"_CHECKSUM\")\n+                        || key.endsWith(\"_SRC_TAG\")\n+                        || key.contains(\"_LICENSE_\")) {\n+                    v = properties.getProperty(\"DEFAULT_\" + key);\n+                }\n+\n+                if (v == null) {\n+                    v = sysEnv.get(key);\n+                }\n+            }\n+            return v;\n+        }\n+\n+        private String getRequiredString(String key) throws Fault {\n+            var v = getString(key);\n+            if (v == null) {\n+                throw new Fault(\"no configuration value for \" + key);\n+            }\n+            return v;\n+        }\n+\n+        public Path getPath(String key) throws Fault {\n+            String v = getString(key);\n+            try {\n+                return v == null ? null : Path.of(v);\n+            } catch (InvalidPathException e) {\n+                throw new Fault(\"bad path: \" + v + \": \" + e);\n+            }\n+        }\n+\n+        public Path getCommandPath(String name) throws Fault {\n+            String n = name.toUpperCase(Locale.ROOT);\n+            Path p = getPath(n);\n+            if (p == null) {\n+                p = which(name);\n+                if (p != null) {\n+                    properties.put(n, p.toString());\n+                }\n+            }\n+            return p;\n+        }\n+\n+        public URL getURL(String key) {\n+            var v = getString(key);\n+            try {\n+                return v == null ? null : new URL(v);\n+            } catch (MalformedURLException e) {\n+                throw new Error(\"Bad URL for \" + key + \": \" + v + \": \" + e);\n+            }\n+        }\n+\n+        private Properties readProperties(Path file) throws Fault {\n+            Properties p = new Properties();\n+            if (file != null) {\n+                try (Reader r = Files.newBufferedReader(file)) {\n+                    p.load(r);\n+                } catch (IOException e) {\n+                    throw new Fault(\"error reading \" + file + \": \" + e, e);\n+                }\n+            }\n+            return p;\n+        }\n+\n+        Path which(String cmd) throws Fault {\n+            try {\n+                Process p = new ProcessBuilder(List.of(\"which\", cmd))\n+                        .redirectErrorStream(true)\n+                        .start();\n+                try (var r = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n+                    String out = r.lines().collect(Collectors.joining());\n+                    p.waitFor();\n+                    int rc = p.exitValue();\n+                    if (rc != 0) {\n+                        throw new Fault(\"error running '\" + cmd + \"': rc=\" + rc);\n+                    }\n+                    return out.isEmpty() ? null : Path.of(out);\n+                }\n+            } catch (InvalidPathException e) {\n+                throw new Fault(\"Unexpected output from 'which \" + cmd + \"': \" + e, e);\n+            } catch (IOException | InterruptedException e) {\n+                throw new Fault(\"error running '\" + cmd +\"': \" + e);\n+            }\n+        }\n+    }\n+    \/**\n+     * Base class for a dependency to be made available for the build.\n+     *\/\n+    static abstract class Dependency {\n+        protected final String name;\n+        protected final Path depsDir;\n+        protected final Config config;\n+\n+        private static final String DEFAULT_MAVEN_URL = \"https:\/\/repo1.maven.org\/maven2\";\n+\n+        Dependency(String name, Config config) {\n+            this.name = name;\n+            this.config = config;\n+            this.depsDir = config.rootDir.resolve(\"build\").resolve(\"deps\").resolve(name);\n+        }\n+\n+        public abstract void setup() throws Fault;\n+\n+        public abstract void verify() throws Fault;\n+\n+        public Map<String, String> getMakeArgs() {\n+            return Collections.emptyMap();\n+        }\n+\n+        protected void createDepsDir() throws Fault {\n+            try {\n+                Files.createDirectories(depsDir);\n+            } catch (IOException e) {\n+                throw new Fault(\"Failed to create \" + depsDir + \": \" + e, e);\n+            }\n+        }\n+\n+        protected Path download(URL url, Path file, String checksum) throws Fault {\n+            if (Files.isDirectory(file)) {\n+                file = file.resolve(baseName(url));\n+            }\n+\n+            if (Files.isReadable(file) && config.options.skipDownloads) {\n+                return file;\n+            }\n+\n+            config.log(\"Downloading \" + url);\n+            try {\n+                Files.createDirectories(file.getParent());\n+            } catch (IOException e) {\n+                throw new Fault(\"Error creating directory for \" + file + \": \" + e);\n+            }\n+\n+            try (var in = url.openStream()) {\n+                var md = MessageDigest.getInstance(\"SHA-1\");\n+                try (var in2 = new DigestInputStream(in, md)) {\n+                    Files.copy(in2, file, StandardCopyOption.REPLACE_EXISTING);\n+                }\n+                var digest = toString(md.digest());\n+                if ((!config.options.skipChecksumCheck && !checksum.equals(\"--\"))\n+                        && !checksum.equals(digest)) {\n+                    config.error(\"Checksum error for \" + url + \"\\n\"\n+                            + \"  expect: \" + checksum + \"\\n\"\n+                            + \"  actual: \" + digest);\n+                }\n+            } catch (IOException | NoSuchAlgorithmException e) {\n+                throw new Fault(\"Error downloading \" + url + \": \" + e, e);\n+            }\n+\n+            return file;\n+        }\n+\n+        protected Path downloadStandardJar(BiFunction<URL, String, String> makeDefaultURL) throws Fault {\n+            createDepsDir();\n+            var prefix = name.toUpperCase(Locale.ROOT).replaceAll(\"[^A-Z_]+\", \"\");\n+            var jarURL = config.getURL(prefix + \"_JAR_URL\");\n+            if (jarURL == null) {\n+                var jarURLBase = config.getURL(prefix + \"_JAR_URL_BASE\");\n+                if (jarURLBase == null) {\n+                    jarURLBase = config.getURL(\"MAVEN_REPO_URL_BASE\");\n+                    if (jarURLBase == null) {\n+                        jarURLBase = newURL(DEFAULT_MAVEN_URL);\n+                    }\n+                }\n+                var version = config.getString(prefix + \"_VERSION\");\n+                jarURL = newURL(makeDefaultURL.apply(jarURLBase, version));\n+            }\n+            var checksum = config.getString(prefix + \"_JAR_CHECKSUM\");\n+            return download(jarURL, depsDir, checksum);\n+        }\n+\n+        protected Path unpack(Path archive, Path dir) throws Fault {\n+            try (var ds = Files.newDirectoryStream(depsDir, Files::isDirectory)) {\n+                for (var d : ds) {\n+                    exec(config.getCommandPath(\"rm\"), List.of(\"-rf\", d.toString()));\n+                }\n+            } catch (IOException e) {\n+                throw new Fault(\"error listing \" + depsDir +\": \" + e, e);\n+            }\n+\n+            String s = archive.getFileName().toString();\n+            if (s.endsWith(\".tar.gz\")) {\n+                exec(config.getCommandPath(\"tar\"),\n+                        List.of(\"-xzf\", archive.toString(), \"-C\", dir.toString()));\n+            } else if (s.endsWith(\".zip\")) {\n+                \/\/ cannot extract files with permissions using standard ZipFile API\n+                \/\/ so resort to the unzip command\n+                exec(config.getCommandPath(\"unzip\"),\n+                        List.of(\"-q\", archive.toString(), \"-d\", dir.toString()));\n+            } else {\n+                throw new Fault(\"unrecognized archive type for file \" + archive);\n+            }\n+\n+            try (DirectoryStream<Path> ds = Files.newDirectoryStream(dir, Files::isDirectory)) {\n+                Path bestSoFar = null;\n+                FileTime bestSoFarTime = null;\n+                for (var p : ds) {\n+                    var pTime = Files.getLastModifiedTime(p);\n+                    if (bestSoFar == null || pTime.compareTo(bestSoFarTime) > 0) {\n+                        bestSoFar = p;\n+                    }\n+                    bestSoFarTime = pTime;\n+                }\n+                return bestSoFar;\n+            } catch (IOException e) {\n+                throw new Fault(\"Error listing contents of \" + dir + \": \" + e, e);\n+            }\n+        }\n+\n+        protected void checkFile(Path file) throws Fault {\n+            config.log(\"Checking \" + file);\n+            if (!(Files.isRegularFile(file) && Files.isReadable(file))) {\n+                throw new Fault(file + \" is not a readable file\");\n+            }\n+        }\n+\n+        protected void checkDirectory(Path dir) throws Fault {\n+            config.log(\"Checking \" + dir);\n+            if (!Files.isDirectory(dir)) {\n+                throw new Fault(dir + \" is not a directory\");\n+            }\n+        }\n+\n+        private String toString(byte[] bytes) {\n+            StringBuilder sb = new StringBuilder();\n+            for (var b : bytes) {\n+                sb.append(String.format(\"%02x\", b));\n+            }\n+            return sb.toString();\n+        }\n+\n+        protected URL newURL(String u) throws Fault {\n+            try {\n+                return new URL(u);\n+            } catch (MalformedURLException e) {\n+                throw new Fault(\"Error creating URL \" + u + \": \" + e);\n+            }\n+        }\n+\n+        protected String baseName(URL url) {\n+            var p = url.getPath();\n+            var lastSep = p.lastIndexOf(\"\/\");\n+            return lastSep == -1 ? p : p.substring(lastSep+ 1);\n+        }\n+\n+        protected void exec(Path cmd, List<String> args) throws Fault {\n+            config.out.flush();\n+            config.err.flush();\n+\/\/            System.err.println(\"exec: \" + cmd + \" \" + args);\n+            try {\n+                Process p = new ProcessBuilder(join(cmd.toString(), args))\n+                        .redirectError(ProcessBuilder.Redirect.INHERIT)\n+                        .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n+                        .start();\n+                p.waitFor();\n+                int rc = p.exitValue();\n+                if (rc != 0) {\n+                    throw new Fault(\"error running '\" + cmd + \"': rc=\" + rc);\n+                }\n+            } catch (IOException | InterruptedException e) {\n+                throw new Fault(\"error running '\" + cmd + \"': \" + e);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A pseudo-dependency to provide build version details.\n+     *\/\n+    static class BuildInfo extends Dependency {\n+        String version;\n+        String buildMileStone;\n+        String buildNumber;\n+        String versionString;\n+\n+        BuildInfo(Config config) {\n+            super(\"apidiff\", config);\n+        }\n+\n+        @Override\n+        public void setup() throws Fault {\n+            var prefix = name.toUpperCase(Locale.ROOT);\n+            version = config.getRequiredString(prefix + \"_VERSION\");\n+\n+            buildMileStone = config.getString(prefix + \"_BUILD_MILESTONE\");\n+            if (buildMileStone == null) {\n+                buildMileStone = \"dev\";\n+            }\n+\n+            buildNumber = config.getString(prefix + \"_BUILD_NUMBER\");\n+            if (buildNumber == null) {\n+                buildNumber = \"0\";\n+            }\n+\n+            versionString = config.getString(prefix + \"_VERSION_STRING\");\n+            if (versionString == null) {\n+                versionString = version\n+                        + (buildMileStone.isEmpty() ? \"\" : \"-\" + buildMileStone)\n+                        + \"+\" + buildNumber;\n+            }\n+        }\n+\n+        @Override\n+        public void verify() throws Fault {\n+            int version;\n+            if (config.jdk.equals(Path.of(System.getProperty(\"java.home\")))) {\n+                version = Runtime.version().feature();\n+            } else {\n+                var javaCmd = config.jdk.resolve(\"bin\").resolve(\"java\");\n+                try {\n+                    Process p = new ProcessBuilder(List.of(javaCmd.toString(), \"-version\"))\n+                            .redirectErrorStream(true)\n+                            .start();\n+                    try (var r = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n+                        String out = r.lines()\n+                                .filter(l -> l.matches(\".*(java|openjdk).*\"))\n+                                .findFirst()\n+                                .orElse(\"\");\n+                        var m = Pattern.compile(\"\\\"(1.)?(?<v>[0-9]+)[^ \\\"]*\\\"\").matcher(out);\n+                        if (m.find()) {\n+                            version = Integer.parseInt(m.group(\"v\"));\n+                        } else {\n+                            throw new Fault(\"version info not found in output from '\" + javaCmd + \" -version'\");\n+                        }\n+                    }\n+                } catch (IOException e) {\n+                    throw new Fault(\"Error running '\" + javaCmd + \" -version': \" + e, e);\n+                }\n+            }\n+\n+            if (version < requiredJDKVersion) {\n+                throw new Fault(\"JDK \" + requiredJDKVersion + \" or newer is required to build apidiff\");\n+            }\n+        }\n+\n+        @Override\n+        public Map<String, String> getMakeArgs() {\n+            return Map.of(\n+                    \"BUILDDIR\", config.buildDir.toString(),\n+                    \"JDKHOME\", config.jdk.toString(),\n+                    \"BUILD_VERSION\", version,\n+                    \"BUILD_MILESTONE\", buildMileStone,\n+                    \"BUILD_NUMBER\", buildNumber,\n+                    \"BUILD_VERSION_STRING\", versionString\n+            );\n+        }\n+    }\n+\n+    \/**\n+     * DaisyDiff, providing the ability to compare HTML files.\n+     *\n+     * @see <a href=\"https:\/\/github.com\/guyvdbroeck\/daisydiff-1\">DaisyDiff<\/a>\n+     *\/\n+    static class DaisyDiff extends Dependency {\n+        private Path jar;\n+        private Path src;\n+        private Path license;\n+\n+        static final String DEFAULT_REPO_URL = \"https:\/\/github.com\/guyvdbroeck\/daisydiff-1\";\n+\n+        DaisyDiff(Config config) {\n+            super(\"daisydiff\", config);\n+        }\n+\n+        @Override\n+        public void setup() throws Fault {\n+            jar = config.getPath(\"DAISYDIFF_JAR\");\n+            if (jar == null) {\n+                createDepsDir();\n+                src = config.getPath(\"DAISYDIFF_SRC\");\n+                if (src == null) {\n+                    var srcArchiveURL = config.getURL(\"DAISYDIFF_SRC_ARCHIVE_URL\");\n+                    if (srcArchiveURL == null) {\n+                        \/\/ build URL from base and version number\n+                        var srcArchiveURLBase = config.getURL(\"DAISYDIFF_SRC_ARCHIVE_URL_BASE\");\n+                        if (srcArchiveURLBase == null) {\n+                            var repoURLBase = config.getURL(\"DAISYDIFF_REPO_URL_BASE\");\n+                            if (repoURLBase == null) {\n+                                repoURLBase = newURL(DEFAULT_REPO_URL);\n+                            }\n+                            srcArchiveURLBase = repoURLBase;\n+                        }\n+                        var srcVersion = config.getString(\"DAISYDIFF_SRC_VERSION\");\n+                        srcArchiveURL = newURL(srcArchiveURLBase\n+                                + \"\/archive\/refs\/tags\/release-\"\n+                                + srcVersion\n+                                + \".tar.gz\");\n+                    }\n+                    var checksum = config.getString(\"DAISYDIFF_SRC_ARCHIVE_CHECKSUM\");\n+                    var srcArchive = download(srcArchiveURL, depsDir, checksum);\n+                    src = unpack(srcArchive, depsDir).resolve(\"src\");\n+                }\n+            }\n+\n+            license = config.getPath(\"DAISYDIFF_LICENSE\");\n+            if (license == null) {\n+                var version = config.getString(\"DAISYDIFF_LICENSE_VERSION\");\n+                var licenseURL = newURL(\"https:\/\/raw.githubusercontent.com\/DaisyDiff\/DaisyDiff\/\"\n+                        + version\n+                        + \"\/LICENSE.txt\");\n+                var licenseChecksum = config.getString(\"DAISYDIFF_LICENSE_CHECKSUM\");\n+                license = download(licenseURL, depsDir, licenseChecksum);\n+            }\n+        }\n+\n+        @Override\n+        public void verify() throws Fault {\n+            if (jar == null && src == null) {\n+                throw new Fault(\"jar file or source directory not found for DaisyDiff\");\n+            }\n+            if (jar != null) {\n+                checkFile(jar);\n+            }\n+            if (src != null) {\n+                checkDirectory(src);\n+            }\n+            checkFile(license);\n+        }\n+\n+        @Override\n+        public Map<String, String> getMakeArgs() {\n+            var args = new HashMap<String, String>();\n+            if (jar != null) {\n+                args.put(\"DAISYDIFF_JAR\", jar.toString());\n+            }\n+            if (src != null) {\n+                args.put(\"DAISYDIFF_SRC\", src.toString());\n+            }\n+            args.put(\"DAISYDIFF_LICENSE\", license.toString());\n+            return args;\n+        }\n+    }\n+\n+    \/**\n+     * Eclipse Equinox, required when building DaisyDiff from source.\n+     *\n+     * @see <a href=\"https:\/\/eclipse.dev\/equinox\/\">Common Eclipse Runtime<\/a>\n+     *\/\n+    static class Equinox extends Dependency {\n+        Path jar;\n+        Path license;\n+        DaisyDiff daisyDiff;\n+\n+        private static final String DEFAULT_LICENSE_URL = \"https:\/\/www.eclipse.org\/org\/documents\/epl-v10.html\";\n+\n+        Equinox(Config config, DaisyDiff daisyDiff) {\n+            super(\"equinox\", config);\n+            this.daisyDiff = daisyDiff;\n+        }\n+\n+        @Override\n+        public void setup() throws Fault {\n+            \/\/ Only need equinox when building daisydiff from source\n+            if (daisyDiff.src == null) {\n+                return;\n+            }\n+\n+            jar = config.getPath(\"EQUINOX_JAR\");\n+            if (jar == null) {\n+                jar = downloadStandardJar((urlBase, version) ->\n+                        urlBase\n+                        + \"\/org\/eclipse\/equinox\/org.eclipse.equinox.common\/\"\n+                        + version\n+                        + \"\/org.eclipse.equinox.common-\" + version + \".jar\"\n+                );\n+            }\n+\n+            license = config.getPath(\"EQUINOX_LICENSE\");\n+            if (license == null) {\n+                var licenseURL = newURL(DEFAULT_LICENSE_URL);\n+                var licenseChecksum = config.getString(\"EQUINOX_LICENSE_CHECKSUM\");\n+                license = download(licenseURL, depsDir, licenseChecksum);\n+            }\n+        }\n+\n+        @Override\n+        public void verify() throws Fault {\n+            checkFile(jar);\n+            checkFile(license);\n+        }\n+\n+        @Override\n+        public Map<String, String> getMakeArgs() {\n+            return daisyDiff.src == null\n+                    ? Collections.emptyMap()\n+                    : Map.of(\n+                    \"EQUINOX_JAR\", jar.toString(),\n+                    \"EQUINOX_LICENSE\", license.toString());\n+        }\n+    }\n+\n+    \/**\n+     * HtmlCleaner, to transform dirty HTML to well-formed XML.\n+     *\n+     * @see <a href=\"https:\/\/htmlcleaner.sourceforge.net\">HtmlCleaner<\/a>\n+     *\/\n+    static class HtmlCleaner extends Dependency {\n+        private Path jar;\n+        private Path license;\n+\n+        HtmlCleaner(Config config) {\n+            super(\"htmlcleaner\", config);\n+        }\n+\n+        @Override\n+        public void setup() throws Fault {\n+            jar = config.getPath(\"HTMLCLEANER_JAR\");\n+            if (jar == null) {\n+                jar = downloadStandardJar((urlBase, version) ->\n+                        urlBase\n+                        + \"\/net\/sourceforge\/htmlcleaner\/htmlcleaner\/\"\n+                        + version\n+                        + \"\/htmlcleaner-\" + version + \".jar\");\n+            }\n+\n+            license = config.getPath(\"HTMLCLEANER_LICENSE\");\n+            if (license == null) {\n+                var version = config.getString(\"HTMLCLEANER_VERSION\");\n+                var licenseURL = newURL(\"https:\/\/sourceforge.net\/p\/htmlcleaner\/code\/HEAD\/tree\/tags\/\"\n+                        + \"htmlcleaner-\" + version\n+                        + \"\/licence.txt?format=raw\");\n+                var licenseChecksum = config.getString(\"HTMLCLEANER_LICENSE_CHECKSUM\");\n+                license = download(licenseURL, depsDir, licenseChecksum);\n+            }\n+        }\n+\n+        @Override\n+        public void verify() throws Fault {\n+            checkFile(jar);\n+            checkFile(license);\n+        }\n+\n+        @Override\n+        public Map<String, String> getMakeArgs() {\n+            return Map.of(\n+                    \"HTMLCLEANER_JAR\", jar.toString(),\n+                    \"HTMLCLEANER_LICENSE\", license.toString());\n+        }\n+    }\n+\n+    \/**\n+     * Java Diff Utilities, to compare text files.\n+     *\n+     * @see <a href=\"https:\/\/github.com\/java-diff-utils\/java-diff-utils\">Java Diff Utilities<\/a>\n+     *\/\n+    static class JavaDiffUtils extends Dependency {\n+        private Path jar;\n+        private Path license;\n+\n+        JavaDiffUtils(Config config) {\n+            super(\"java-diff-utils\", config);\n+        }\n+\n+        @Override\n+        public void setup() throws Fault {\n+            jar = config.getPath(\"JAVADIFFUTILS_JAR\");\n+            if (jar == null) {\n+                jar = downloadStandardJar((urlBase, version) ->\n+                        urlBase\n+                        + \"\/io\/github\/java-diff-utils\/java-diff-utils\/\"\n+                        + version\n+                        + \"\/java-diff-utils-\" + version + \".jar\");\n+            }\n+\n+            license = config.getPath(\"JAVADIFFUTILS_LICENSE\");\n+            if (license == null) {\n+                var version = config.getString(\"JAVADIFFUTILS_LICENSE_VERSION\");\n+                var licenseURL = newURL(\"https:\/\/raw.githubusercontent.com\/java-diff-utils\/java-diff-utils\/\"\n+                        + \"java-diff-utils-\" + version\n+                        + \"\/LICENSE\");\n+                var licenseChecksum = config.getString(\"JAVADIFFUTILS_LICENSE_CHECKSUM\");\n+                license = download(licenseURL, depsDir, licenseChecksum);\n+            }\n+        }\n+\n+        @Override\n+        public void verify() throws Fault {\n+            checkFile(jar);\n+        }\n+\n+        @Override\n+        public Map<String, String> getMakeArgs() {\n+            return Map.of(\n+                    \"JAVADIFFUTILS_JAR\", jar.toString(),\n+                    \"JAVADIFFUTILS_LICENSE\", license.toString());\n+        }\n+    }\n+\n+    \/**\n+     * JUnit, to run tests for APIDiff.\n+     *\n+     * @see <a href=\"https:\/\/junit.org\/junit5\/\">JUnit<\/a>\n+     *\/\n+    static class JUnit extends Dependency {\n+        private Path jar;\n+\n+        JUnit(Config config) {\n+            super(\"junit\", config);\n+        }\n+\n+        @Override\n+        public void setup() throws Fault {\n+            jar = config.getPath(\"JUNIT_JAR\");\n+            if (jar == null) {\n+                jar = downloadStandardJar((urlBase, version) ->\n+                        urlBase\n+                        + \"\/org\/junit\/platform\/junit-platform-console-standalone\/\"\n+                        + version\n+                        + \"\/junit-platform-console-standalone-\" + version + \".jar\");\n+            }\n+        }\n+\n+        @Override\n+        public void verify() throws Fault {\n+            checkFile(jar);\n+        }\n+\n+        @Override\n+        public Map<String, String> getMakeArgs() {\n+            return Map.of(\"JUNIT_JAR\", jar.toString());\n+        }\n+    }\n+\n+    \/**\n+     * Generates a script to run \"make\", based on the set of dependencies.\n+     *\/\n+    static class MakeScript {\n+        private final Config config;\n+        MakeScript(Config config) {\n+            this.config = config;\n+        }\n+\n+        void writeFile(Path file, List<? extends Dependency> deps) throws Fault {\n+            var allMakeArgs = new TreeMap<String, String>();\n+            deps.forEach(d -> allMakeArgs.putAll(d.getMakeArgs()));\n+\n+            try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(file))) {\n+                out.println(\"#!\/bin\/sh\");\n+                out.println();\n+                out.println(\"cd \\\"\" + config.rootDir.resolve(\"make\") + \"\\\"\");\n+                out.println(\"make \\\\\");\n+                allMakeArgs.forEach((name, value) ->\n+                        out.printf(\"    %s=\\\"%s\\\" \\\\%n\", name, value));\n+                out.println(\"    \\\"$@\\\"\");\n+            } catch (IOException e) {\n+                throw new Fault(\"Error writing make command script: \" + file + \": \" + e);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"make\/Build.java","additions":1367,"deletions":0,"binary":false,"changes":1367,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+#\n+# Copyright (c) 1996, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# include host-specific defs, if any\n+-include Defs-$(shell hostname).gmk\n+\n+# TOPDIR set in Makefile\n+ABSTOPDIR = $(shell cd $(TOPDIR); pwd)\n+\n+# clobber settings from user's environment\n+JAVA_HOME=\n+CLASSPATH=\n+JAVA_COMPILER=\n+LD_LIBRARY_PATH=\n+\n+#----------------------------------------------------------------------\n+#\n+# Support for Cygwin\n+\n+SYSTEM_UNAME := $(shell uname)\n+\n+# Where is unwanted output to be delivered?\n+# On Windows, MKS uses the special file \"NUL\", cygwin uses the customary unix file.\n+ifeq ($(SYSTEM_UNAME), Windows_NT)\n+DEV_NULL = NUL\n+else\n+DEV_NULL = \/dev\/null\n+endif\n+\n+ifneq (,$(findstring CYGWIN,$(SYSTEM_UNAME)))\n+USING_CYGWIN = true\n+endif\n+\n+ifdef USING_CYGWIN\n+define FullPath\n+$(shell cygpath -a -m $1 2> $(DEV_NULL))\n+endef\n+define PosixPath\n+$(shell cygpath -a -u $1 2> $(DEV_NULL))\n+endef\n+else\n+define FullPath\n+$(abspath $1)\n+endef\n+define PosixPath\n+$1\n+endef\n+endif\n+\n+ifndef BUILDDIR\n+  BUILDDIR = $(TOPDIR)\/build\n+endif\n+override BUILDDIR := $(call FullPath, $(BUILDDIR))\n+\n+BUILDTESTDIR=$(BUILDDIR)\/test\n+\n+\n+#----------------------------------------------------------------------\n+#\n+# Parameters to control what to build and test with.\n+\n+JAVA    = $(JDKHOME)\/bin\/java\n+JAVAC   = $(JDKHOME)\/bin\/javac\n+JAVADOC = $(JDKHOME)\/bin\/javadoc\n+JAR     = $(JDKHOME)\/bin\/jar\n+\n+#----- Unix commands\n+\n+AWK     = \/usr\/bin\/awk\n+CAT     = \/bin\/cat\n+CHMOD   = \/bin\/chmod\n+CP      = \/bin\/cp\n+DIFF    = \/usr\/bin\/diff\n+ECHO    = \/bin\/echo\n+FIND    = \/usr\/bin\/find\n+GREP    := $(shell if [ -r \/bin\/grep ]; then echo \/bin\/grep ; else echo \/usr\/bin\/grep ; fi )\n+LN      = \/bin\/ln\n+MKDIR   = \/bin\/mkdir\n+MV      = \/bin\/mv\n+PANDOC  = $(shell if [ -r \/usr\/bin\/pandoc ]; then \\\n+\t\techo \/usr\/bin\/pandoc ; \\\n+\telif [ -r \/usr\/local\/bin\/pandoc ]; then \\\n+\t\techo \/usr\/local\/bin\/pandoc ; \\\n+\telif [ -r \/opt\/homebrew\/bin\/pandoc ]; then \\\n+\t\techo \/opt\/homebrew\/bin\/pandoc ; \\\n+\telse \\\n+\t\techo \/bin\/echo \"pandoc not available\" ; \\\n+\tfi )\n+PERL    = \/usr\/bin\/perl\n+PRINTF  = \/usr\/bin\/printf\n+RM      = \/bin\/rm -rf\n+SED     := $(shell if [ -r \/bin\/sed ]; then echo \/bin\/sed ; else echo \/usr\/bin\/sed ; fi )\n+SH      = \/bin\/sh\n+SORT    = \/usr\/bin\/sort\n+TEST    = \/usr\/bin\/test\n+# tidy needs to support HTML 5; typically means `tidy -version` reports 5.x or higher\n+ifeq ($(SYSTEM_UNAME), Darwin)\n+TIDY \t:= $(shell if [ -r \/usr\/local\/bin\/tidy ]; then \\\n+\t\techo \/usr\/local\/bin\/tidy ; \\\n+\telif [ -r \/opt\/homebrew\/bin\/tidy ]; then \\\n+\t\techo \/opt\/homebrew\/bin\/tidy ; \\\n+\telse \\\n+\t\techo \/usr\/bin\/tidy ; \\\n+\tfi )\n+else\n+TIDY\t= \/usr\/bin\/tidy\n+endif\n+TOUCH   = \/usr\/bin\/touch\n+UNZIP   = \/usr\/bin\/unzip\n+WC      = \/usr\/bin\/wc\n+ZIP     = \/usr\/bin\/zip\n+\n+\n+#----------------------------------------------------------------------\n+#\n+# Identification of parts of the system\n+\n+SRCDIR = $(TOPDIR)\/src\n+JAVADIR = $(SRCDIR)\/share\/classes\n+SRCDOCDIR = $(SRCDIR)\/share\/doc\n+SRCSHAREBINDIR = $(SRCDIR)\/share\/bin\n+TESTDIR = $(TOPDIR)\/test\n+\n+CLASSDIR = $(BUILDDIR)\/classes\n+ABSCLASSDIR = $(cd $(CLASSDIR); pwd)\n+\n+IMAGES_DIR = $(BUILDDIR)\/images\n+APIDIFF_IMAGEDIR = $(IMAGES_DIR)\/apidiff\n+APIDIFF_IMAGEDOCDIR = $(APIDIFF_IMAGEDIR)\/doc\n+APIDIFF_IMAGEJARDIR = $(APIDIFF_IMAGEDIR)\/lib\n+ABS_APIDIFF_IMAGEJARDIR = $(shell cd $(APIDIFF_IMAGEJARDIR); pwd)\n+\n+# source bundle locations\n+IMAGESRC_SRCDIR = $(IMAGESRC_TOPDIR)\/src\/share\/classes\n+\n+#----------------------------------------------------------------------\n+#\n+# Version tags\n+#\n+BUILD_VERSION = 0.0\n+BUILD_MILESTONE = dev\n+BUILD_NUMBER = b00\n+\n+# munge the BUILD values suitable for use in the bundle name\n+ZIPSFX_VERSION_sh = echo '$(BUILD_VERSION)'\n+ZIPSFX_MILESTONE_sh = echo '$(BUILD_MILESTONE)' | sed -e 's\/\\(..*\\)\/-\\1\/'\n+ZIPSFX_BUILD_sh = echo '$(BUILD_NUMBER)' | sed -e 's|[^[0-9]||g' | xargs printf \"%d\"\n+\n+VERBOSE_ZIP_SUFFIX = $(shell $(ZIPSFX_VERSION_sh))$(shell $(ZIPSFX_ MILESTONE_sh))+$(shell $(ZIPSFX_BUILD_sh))_bin\n\\ No newline at end of file\n","filename":"make\/Defs.gmk","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+#\n+# Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+TOPDIR = ..\n+\n+include Defs.gmk\n+\n+default: build\n+\n+all: build test\n+\n+#----------------------------------------------------------------------\n+\n+include apidiff.gmk\n+include $(TOPDIR)\/test\/*\/*.gmk\n+include Rules.gmk\n+\n+build: check-build-vars $(BUILDFILES)\n+\n+images: $(VERBOSEZIPFILES)\n+\n+test: check-test-vars $(INITIAL_TESTS) $(TESTS) $(FINAL_TESTS)\n+\tcount=`echo $+ | wc -w` ; \\\n+\techo \"All ($${count}) selected tests completed successfully\"\n+\n+clean:\n+\t$(RM) $(BUILDDIR)\n+\n+.NO_PARALLEL: clean\n+\n+sanity:\n+\t@echo \"JDKHOME               = $(JDKHOME)\"\n+\t@echo \"JUNIT_JAR             = $(JUNIT_JAR)\"\n+\t@echo \"JCOMMANDER_JAR        = $(JCOMMANDER_JAR)\"\n+\t@echo \"JAVADIFFUTILS_JAR     = $(JAVADIFFUTILS_JAR)\"\n+\t@echo \"JAVADIFFUTILS_LICENSE = $(JAVADIFFUTILS_LICENSE)\"\n+\t@echo \"DAISYDIFF_JAR         = $(DAISYDIFF_JAR)\"\n+\t@echo \"DAISYDIFF_LICENSE     = $(DAISYDIFF_LICENSE)\"\n+\t@echo \"HTMLCLEANER_JAR       = $(HTMLCLEANER_JAR)\"\n+\t@echo \"HTMLCLEANER_LICENSE   = $(HTMLCLEANER_LICENSE)\"\n+\n+check-build-vars:\n+\t@if [ -z \"$(JDKHOME)\" ]; then \\\n+\t\techo \"JDKHOME not set; must be JDK 17 or later\" ; exit 1 ; \\\n+\tfi\n+\t@if [ -z \"$(DAISYDIFF_JAR)\" -a -z \"$(DAISYDIFF_SRC)\" ]; then \\\n+\t\techo \"DAISYDIFF_JAR or DAISYDIFF_SRC not set\" ; exit 1 ; \\\n+\tfi\n+\t@if [ -z \"$(DAISYDIFF_LICENSE)\" ]; then \\\n+\t\techo \"DAISYDIFF_LICENSE not set (will not be included)\" ; \\\n+\tfi\n+\t@if [ -z \"$(HTMLCLEANER_JAR)\" ]; then \\\n+\t\techo \"HTMLCLEANER_JAR not set\" ; exit 1 ; \\\n+\tfi\n+\t@if [ -z \"$(HTMLCLEANER_LICENSE)\" ]; then \\\n+\t\techo \"HTMLCLEANER_LICENSE not set (will not be included)\" ; \\\n+\tfi\n+\t@if [ -z \"$(JAVADIFFUTILS_JAR)\" ]; then \\\n+\t\techo \"JAVADIFFUTILS_JAR not set\" ; exit 1 ; \\\n+\tfi\n+\t@if [ -z \"$(JAVADIFFUTILS_LICENSE)\" ]; then \\\n+\t\techo \"JAVADIFFUTILS_LICENSE not set (will not be included)\" ; \\\n+\tfi\n+\n+check-test-vars:\n+\t@if [ -z \"$(JUNIT_JAR)\" ]; then \\\n+\t\techo \"JUNIT_JAR not set\" ; exit 1 ; \\\n+\tfi\n+\n+dependencies: check-build-vars check-test-vars\n+\n+#----------------------------------------------------------------------\n+\n+\n+.PHONY: default all build test images clean sanity\n+\n+\n","filename":"make\/Makefile","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+# Building _apidiff_\n+\n+The fundamental way to build _apidiff_ is with GNU `make`, although there is\n+a convenient wrapper script `make\/build.sh` to help download the necessary\n+dependencies before invoking `make`. Once the dependencies have been downloaded,\n+you can also configure an IDE to build the tool and run the tests.\n+\n+_apidiff_ has various external dependencies:\n+\n+* _JDK_: must be at least JDK 17\n+* _Java Diff Utils_\n+* _Daisy Diff_\n+* _TestNG_ and _JCommander_ (for testing only)\n+\n+## Using `make\/build.sh`\n+\n+`make\/build.sh` is a script that can download the necessary dependencies\n+for _apidiff_ and then run `make`.  You can configure all values used\n+by the script by setting environment variables; you can also configure\n+some commonly used options with command-line argume nts for the script.\n+\n+The `make\/build.sh` script reads the details of the dependencies from\n+a file, which defaults to `make\/version-numbers`, although an alternate\n+file can be specified, depending on the build environment.\n+\n+The script supports the following build scenarios:\n+\n+* Download dependencies from standard default locations such as Maven Central\n+  and Google Code Archive. This is the default.\n+\n+* Download dependencies from other available locations, such as an instance of\n+  Artifactory. The details can be specified in an alternate `version-numbers`\n+  file.\n+\n+* Use local copies of the dependencies on the same machine.\n+  The details can be specified in an alternate `version-numbers` file,\n+  or you can bypas the script entirely and invoke `make` directly.\n+\n+For more details, see the comments in `make\/build.sh` and use the `--help`\n+option when running the script.\n+\n+The makefile provides the following targets:\n+\n+* `build`: build _apidiff_\n+\n+   Requires the following to be set:\n+   `JDKHOME`, `JAVA_DIFF_UTILS_JAR`, `JAVA_DIFF_UTILS_LICENSE`, `DAISYDIFF_JAR`, `DAISYDIFF_LICENSE`.\n+\n+* `test`: run tests\n+\n+    Requires `TESTNG_JAR` and `JCOMMANDER_JAR` to be set.\n+\n+* `clean`: delete the `build` directory and its contents\n+\n+* `images`: create bundles for uploading to an available server\n+\n+* `sanity`: show the settings of the standard variables.\n+\n+### Examples:\n+\n+    $ JDKHOME=\/opt\/jdk\/17 sh build.sh\n+\n+    $ JDKHOME=\/opt\/jdk\/17 sh build.sh build test images\n+\n+\n+\n+## File Locations\n+\n+| Files                | GNU Make                          | Ant                                     | IntelliJ          |\n+|----------------------|-----------------------------------|-----------------------------------------|-------------------|\n+| Default Dependencies | build\/deps                        | build\/deps                              | build\/deps        |\n+| Main Classes         | build\/classes                     | build\/classes                           | out\/production    |\n+| Test Classes         | build\/TestNGTests\/classes         | build\/test\/classes                      | out\/test          |\n+| Test Work            | build\/TestNGTests\/work            | build\/test\/work                         | build\/test\/work   |\n+| Test Report          | build\/TestNGTests\/report          | build\/test\/report                       |                   |\n+| Image                | build\/images\/apidiff              | dist\/apidiff                            |                   |\n+| Bundle               | build\/images\/apidiff.zip          | dist\/apidiff.zip                        |                   |\n","filename":"make\/README.md","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+#\n+# Copyright (c) 1996, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+\n+#---------------------------------------------------------------------\n+#\n+# Copy resources (*.properties, etc) into classes directory from source tree\n+\n+$(CLASSDIR)\/%.properties: $(JAVADIR)\/%.properties\n+\t$(RM) -f $@\n+\tif [ ! -d $(@D) ] ; then $(MKDIR) -p $(@D) ; fi\n+\t$(CP) $(@:$(CLASSDIR)\/%=$(JAVADIR)\/%) $@\n+\n+$(CLASSDIR)\/%.gif: $(JAVADIR)\/%.gif\n+\t$(RM) -f $@\n+\tif [ ! -d $(@D) ] ; then $(MKDIR) -p $(@D) ; fi\n+\t$(CP) $(@:$(CLASSDIR)\/%=$(JAVADIR)\/%) $@\n+\n+$(CLASSDIR)\/%.png: $(JAVADIR)\/%.png\n+\t$(RM) -f $@\n+\tif [ ! -d $(@D) ] ; then $(MKDIR) -p $(@D) ; fi\n+\t$(CP) $(@:$(CLASSDIR)\/%=$(JAVADIR)\/%) $@\n+\n+$(CLASSDIR)\/%.css: $(JAVADIR)\/%.css\n+\t$(RM) -f $@\n+\tif [ ! -d $(@D) ] ; then $(MKDIR) -p $(@D) ; fi\n+\t$(CP) $(@:$(CLASSDIR)\/%=$(JAVADIR)\/%) $@\n+\n+#---------------------------------------------------------------------\n+\n+$(CLASSDIR) $(BUILDDIR):\n+\t$(MKDIR) -p $@\n+\n+#----------------------------------------------------------------------\n+#\n+# Build a JAR file containing the contents of any classes\/* files\n+# listed in the FILES.JAR.%\n+\n+# default copyright; override as necessary\n+JAR_COPYRIGHT = -C $(TOPDIR) COPYRIGHT\n+\n+$(IMAGES_DIR)\/%.jar: pkgsToFiles.sh\n+\t$(RM) $@ $(@:$(IMAGES_DIR)\/%.jar=$(BUILDDIR)\/jarData\/%)\n+\t$(MKDIR) -p $(@D)\n+\t$(MKDIR) -p $(@:$(IMAGES_DIR)\/%.jar=$(BUILDDIR)\/jarData\/%)\n+\t( if [ ! -z \"$(JAR_MAINCLASS)\" ]; then echo \"Main-class: $(JAR_MAINCLASS)\" ; fi ; \\\n+\t  if [ ! -z \"$(JAR_CLASSPATH)\" ]; then echo \"Class-Path: $(JAR_CLASSPATH)\" ; fi ; \\\n+\t  echo \"$(@F:%.jar=%)-Name: $(@F:%.jar=%)\" ; \\\n+\t  echo \"$(@F:%.jar=%)-Version: $(BUILD_VERSION)\" ; \\\n+\t  echo \"$(@F:%.jar=%)-Milestone: $(BUILD_MILESTONE)\" ; \\\n+\t  echo \"$(@F:%.jar=%)-Build: $(BUILD_NUMBER)\" ; \\\n+\t  echo \"$(@F:%.jar=%)-BuildJavaVersion: `$(JAVA) -fullversion 2>&1 | awk '{print $$NF}'  | \\\n+\t\tsed -e 's|^\"\\(.*\\)\"$$|Java(TM) 2 SDK, Version \\1|'`\" ; \\\n+\t  echo \"$(@F:%.jar=%)-BuildDate: `\/bin\/date +'%B %d, %Y'`\" ; \\\n+\t) \\\n+\t\t> $(@:$(IMAGES_DIR)\/%.jar=$(BUILDDIR)\/jarData\/%\/manifest.txt)\n+\t$(JAR) -cmf $(@:$(IMAGES_DIR)\/%.jar=$(BUILDDIR)\/jarData\/%\/manifest.txt) $@ \\\n+\t    $(JAR_COPYRIGHT) \\\n+\t    `sh pkgsToFiles.sh $(CLASSDIR) $($(@F:%.jar=PKGS.JAR.%))` \\\n+\t    $(patsubst $(CLASSDIR)\/%,-C $(CLASSDIR) %,$(sort $(FILES.JAR.$(@F:%.jar=%)))) \\\n+\t    $(JAR_EXTRAS)\n+\t$(CHMOD) a-w $@\n+\n+#----------------------------------------------------------------------\n+#\n+# Build zips with verbose names\n+\n+%-$(VERBOSE_ZIP_SUFFIX).zip: %.zip\n+\tln $(@:%-$(VERBOSE_ZIP_SUFFIX).zip=%.zip) $@\n+\n+#----------------------------------------------------------------------\n+#\n+# cancel implicit rules\n+\n+%: %.o\n+%: %.obj\n+%: %.dll\n+%: %.c\n+%: %.cc\n+%: %.cpp\n+%: %.C\n+%: %.p\n+%: %.f\n+%: %.s\n+%: %.F\n+%: %.r\n+%: %.S\n+%: %.mod\n+%: %.sh\n+\n+\n+\n","filename":"make\/Rules.gmk","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,329 @@\n+#\n+# Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#----------------------------------------------------------------------\n+#\n+# compile jdk.codetools.apidiff\n+\n+JAVAFILES.jdk.codetools.apidiff := \\\n+\t$(shell $(FIND) $(JAVADIR) -name \\*.java -print )\n+\n+ifneq ($(DAISYDIFF_SRC),)\n+\tDAISYDIFF_SRC_JAVA = $(DAISYDIFF_SRC)\/main\/java\n+\tDAISYDIFF_SRC_RESOURCES = $(DAISYDIFF_SRC)\/main\/resources\n+endif\n+\n+$(BUILDDIR)\/classes.jdk.codetools.apidiff.ok: $(JAVAFILES.jdk.codetools.apidiff)\n+\t$(JAVAC) $(JAVAC_OPTIONS) \\\n+\t\t-cp $(JAVADIFFUTILS_JAR):$(DAISYDIFF_JAR):$(DAISYDIFF_SRC_JAVA):$(EQUINOX_JAR):$(HTMLCLEANER_JAR) \\\n+\t\t-d $(CLASSDIR) \\\n+\t\t$(JAVAFILES.jdk.codetools.apidiff)\n+\techo \"classes built at `date`\" > $@\n+\n+TARGETS.jdk.codetools.apidiff += $(BUILDDIR)\/classes.jdk.codetools.apidiff.ok\n+\n+#----------------------------------------------------------------------\n+#\n+# resources required for jdk.codetools.apidiff\n+\n+RESOURCES.jdk.codetools.apidiff = \\\n+\t$(CLASSDIR)\/jdk\/codetools\/apidiff\/resources\/help.properties \\\n+\t$(CLASSDIR)\/jdk\/codetools\/apidiff\/resources\/log.properties \\\n+\t$(CLASSDIR)\/jdk\/codetools\/apidiff\/report\/html\/resources\/apidiff.css \\\n+\t$(CLASSDIR)\/jdk\/codetools\/apidiff\/report\/html\/resources\/report.properties\n+\n+TARGETS.jdk.codetools.apidiff += $(RESOURCES.jdk.codetools.apidiff)\n+\n+ifneq ($(DAISYDIFF_SRC),)\n+DAISYDIFF_RESOURCE_FILES = $(shell $(FIND) $(DAISYDIFF_SRC_RESOURCES) -name \\*.properties -print )\n+RESOURCES.daisydiff = $(DAISYDIFF_RESOURCE_FILES:$(DAISYDIFF_SRC_RESOURCES)\/%.properties=$(CLASSDIR)\/%.properties)\n+\n+$(CLASSDIR)\/%.properties: $(DAISYDIFF_SRC_RESOURCES)\/%.properties\n+\t$(RM) -f $@\n+\tif [ ! -d $(@D) ] ; then $(MKDIR) -p $(@D) ; fi\n+\t$(CP) $(@:$(CLASSDIR)\/%=$(DAISYDIFF_SRC_RESOURCES)\/%) $@\n+\n+TARGETS.jdk.codetools.apidiff += $(RESOURCES.daisydiff)\n+endif\n+\n+#----------------------------------------------------------------------\n+#\n+# Misc. doc files\n+\n+APIDIFF_COPYRIGHT \t= $(APIDIFF_IMAGEDIR)\/COPYRIGHT\n+APIDIFF_LICENSE\t\t= $(APIDIFF_IMAGEDIR)\/LICENSE\n+APIDIFF_MAN_HTML \t= $(APIDIFF_IMAGEDIR)\/doc\/apidiff.html\n+APIDIFF_MAN_NROFF \t= $(APIDIFF_IMAGEDIR)\/man\/man1\/apidiff.1\n+APIDIFF_README\t\t= $(APIDIFF_IMAGEDIR)\/README\n+APIDIFF_USAGE \t\t= $(APIDIFF_IMAGEDIR)\/doc\/usage.txt\n+\n+APIDIFF_DOCS = \\\n+\t$(APIDIFF_COPYRIGHT) \\\n+\t$(APIDIFF_LICENSE) \\\n+\t$(APIDIFF_MAN_HTML) \\\n+\t$(APIDIFF_MAN_NROFF) \\\n+\t$(APIDIFF_README) \\\n+\t$(APIDIFF_USAGE)\n+\n+$(APIDIFF_COPYRIGHT): $(TOPDIR)\/COPYRIGHT\n+\t$(MKDIR) -p $(@D)\n+\t$(RM) $@\n+\t$(CP) $< $@\n+\n+$(APIDIFF_README): $(SRCDOCDIR)\/README\n+\t$(MKDIR) -p $(@D)\n+\t$(RM) $@\n+\t$(CP) $< $@\n+\n+$(APIDIFF_USAGE): $(BUILDDIR)\/apidiff-usage.txt\n+\t$(MKDIR) -p $(@D)\n+\t$(CP) $^ $@\n+\n+$(APIDIFF_LICENSE): $(TOPDIR)\/LICENSE\n+\t$(MKDIR) -p $(@D)\n+\t$(CP) $^ $@\n+\n+$(BUILDDIR)\/apidiff-usage.txt: \\\n+\t\t$(BUILDDIR)\/classes.jdk.codetools.apidiff.ok \\\n+\t\t$(CLASSDIR)\/jdk\/codetools\/apidiff\/resources\/help.properties \\\n+\t\t$(CLASSDIR)\/jdk\/codetools\/apidiff\/resources\/log.properties\n+\t$(JAVA) -cp \"$(CLASSDIR)\" \\\n+\t    -Dprogram=apidiff jdk.codetools.apidiff.Main --help > $@\n+\n+$(APIDIFF_MAN_HTML): $(SRCDOCDIR)\/apidiff.md $(SRCDOCDIR)\/apidiff.css\n+\t$(MKDIR) -p $(@D)\n+\t$(CP) $(SRCDOCDIR)\/apidiff.css $(@D)\n+\t$(PANDOC) --standalone --to html5 --css apidiff.css $(SRCDOCDIR)\/apidiff.md | \\\n+\t\t$(SED) -e '\/class=\"title\"\/s|>.*<|>apidiff<|' -e 's|<p class=\"date\">.*<\/p>||' \\\n+\t\t\t> $@\n+\n+$(APIDIFF_MAN_NROFF): $(SRCDOCDIR)\/apidiff.md\n+\t$(MKDIR) -p $(@D)\n+\t$(PANDOC) --standalone --to man -o $@ $^\n+\n+TARGETS.ZIP.apidiff += $(APIDIFF_DOCS)\n+\n+#----------------------------------------------------------------------\n+#\n+# create apidiff.jar\n+\n+PKGS.JAR.apidiff += \\\n+\tjdk.codetools.apidiff \\\n+\tjdk.codetools.apidiff.resources \\\n+\tjdk.codetools.apidiff.html \\\n+\tjdk.codetools.apidiff.model \\\n+\tjdk.codetools.apidiff.report \\\n+\tjdk.codetools.apidiff.report.html \\\n+\tjdk.codetools.apidiff.report.html.resources\n+\n+ifneq ($(DAISYDIFF_SRC),)\n+\tPKGS.JAR.apidiff += \\\n+\t\tl10n \\\n+\t\torg.eclipse.compare.internal \\\n+\t\torg.eclipse.compare.rangedifferencer \\\n+\t\torg.outerj.daisy.diff.html \\\n+\t\torg.outerj.daisy.diff.html.modification \\\n+\t\torg.outerj.daisy.diff.html.ancestor \\\n+\t\torg.outerj.daisy.diff.html.ancestor.tagtostring \\\n+\t\torg.outerj.daisy.diff.html.dom \\\n+\t\torg.outerj.daisy.diff.html.dom.helper \\\n+\t\torg.outerj.daisy.diff.output\n+endif\n+\n+TARGETS.JAR.apidiff += $(TARGETS.jdk.codetools.apidiff)\n+\n+$(APIDIFF_IMAGEDIR)\/lib\/apidiff.jar: JAR_MAINCLASS = jdk.codetools.apidiff.Main\n+$(APIDIFF_IMAGEDIR)\/lib\/apidiff.jar: JAR_EXTRAS = -C $(JAVADIR) META-INF\/services\/java.util.spi.ToolProvider\n+\n+$(APIDIFF_IMAGEJARDIR)\/apidiff.jar: \\\n+\t$(TARGETS.JAR.apidiff)\n+\n+TARGETS.ZIP.apidiff += $(APIDIFF_IMAGEJARDIR)\/apidiff.jar\n+\n+debug:\n+\techo TARGETS.ZIP.apidiff $(TARGETS.ZIP.apidiff)\n+\n+#----------------------------------------------------------------------\n+#\n+# executable scripts\n+\n+$(APIDIFF_IMAGEDIR)\/bin\/apidiff: $(SRCSHAREBINDIR)\/apidiff.sh\n+\t$(MKDIR) -p $(@D)\n+\t$(RM) $@\n+\t$(CP) $<  $@\n+\t$(CHMOD) a+x,a-w $@\n+\n+TARGETS.ZIP.apidiff += \\\n+\t$(APIDIFF_IMAGEDIR)\/bin\/apidiff\n+\n+#----------------------------------------------------------------------\n+#\n+# dependencies\n+\n+$(APIDIFF_IMAGEDIR)\/lib\/$(notdir $(JAVADIFFUTILS_JAR)): $(JAVADIFFUTILS_JAR)\n+\t$(MKDIR) -p $(@D)\n+\t$(RM) $@\n+\t$(CP) $(JAVADIFFUTILS_JAR) $@\n+\t$(CHMOD) a-w $@\n+\n+ifneq ($(JAVADIFFUTILS_LICENSE),)\n+$(APIDIFF_IMAGEDIR)\/legal\/java-diff-utils\/LICENSE: $(JAVADIFFUTILS_LICENSE)\n+\t$(MKDIR) -p $(@D)\n+\t$(RM) $@\n+\t$(CP) $(JAVADIFFUTILS_LICENSE) $@\n+\t$(CHMOD) a-w $@\n+\n+TARGETS.ZIP.apidiff += \\\n+\t$(APIDIFF_IMAGEDIR)\/legal\/java-diff-utils\/LICENSE\n+endif\n+\n+JAR_CLASSPATH += $(notdir $(JAVADIFFUTILS_JAR))\n+\n+TARGETS.ZIP.apidiff += \\\n+\t$(APIDIFF_IMAGEDIR)\/lib\/$(notdir $(JAVADIFFUTILS_JAR))\n+\n+$(APIDIFF_IMAGEDIR)\/lib\/$(notdir $(DAISYDIFF_JAR)): $(DAISYDIFF_JAR)\n+\t$(MKDIR) -p $(@D)\n+\t$(RM) $@\n+\t$(CP) $(DAISYDIFF_JAR) $@\n+\t$(CHMOD) a-w $@\n+\n+ifneq ($(DAISYDIFF_JAR),)\n+JAR_CLASSPATH += $(notdir $(DAISYDIFF_JAR))\n+\n+TARGETS.ZIP.apidiff += \\\n+\t$(APIDIFF_IMAGEDIR)\/lib\/$(notdir $(DAISYDIFF_JAR))\n+endif\n+\n+ifneq ($(DAISYDIFF_SRC),)\n+$(APIDIFF_IMAGEDIR)\/lib\/$(notdir $(EQUINOX_JAR)): $(EQUINOX_JAR)\n+\t$(MKDIR) -p $(@D)\n+\t$(RM) $@\n+\t$(CP) $(EQUINOX_JAR) $@\n+\t$(CHMOD) a-w $@\n+\n+JAR_CLASSPATH += $(notdir $(EQUINOX_JAR))\n+\n+TARGETS.ZIP.apidiff += \\\n+\t$(APIDIFF_IMAGEDIR)\/lib\/$(notdir $(EQUINOX_JAR))\n+endif\n+\n+ifneq ($(DAISYDIFF_LICENSE),)\n+$(APIDIFF_IMAGEDIR)\/legal\/daisydiff\/LICENSE: $(DAISYDIFF_LICENSE)\n+\t$(MKDIR) -p $(@D)\n+\t$(RM) $@\n+\t$(CP) $(DAISYDIFF_LICENSE) $@\n+\t$(CHMOD) a-w $@\n+\n+TARGETS.ZIP.apidiff += \\\n+\t$(APIDIFF_IMAGEDIR)\/legal\/daisydiff\/LICENSE\n+endif\n+\n+$(APIDIFF_IMAGEDIR)\/lib\/$(notdir $(HTMLCLEANER_JAR)): $(HTMLCLEANER_JAR)\n+\t$(MKDIR) -p $(@D)\n+\t$(RM) $@\n+\t$(CP) $(HTMLCLEANER_JAR) $@\n+\t$(CHMOD) a-w $@\n+\n+JAR_CLASSPATH += $(notdir $(HTMLCLEANER_JAR))\n+\n+TARGETS.ZIP.apidiff += \\\n+\t$(APIDIFF_IMAGEDIR)\/lib\/$(notdir $(HTMLCLEANER_JAR))\n+\n+ifneq ($(HTMLCLEANER_LICENSE),)\n+$(APIDIFF_IMAGEDIR)\/legal\/htmlcleaner\/LICENSE: $(HTMLCLEANER_LICENSE)\n+\t$(MKDIR) -p $(@D)\n+\t$(RM) $@\n+\t$(CP) $(HTMLCLEANER_LICENSE) $@\n+\t$(CHMOD) a-w $@\n+\n+TARGETS.ZIP.apidiff += \\\n+\t$(APIDIFF_IMAGEDIR)\/legal\/htmlcleaner\/LICENSE\n+endif\n+\n+#----------------------------------------------------------------------\n+#\n+# release info\n+\n+# based on code in OpenJDK make\/SourceRevision.gmk\n+ID_COMMAND := $(PRINTF) \"git:%s%s\\n\" \\\n+                 \"$$(git log -n1 --format=%H | cut -c1-12)\" \\\n+                 \"$$(if test -n \"$$(git status --porcelain)\"; then printf '+'; fi)\"\n+\n+$(APIDIFF_IMAGEDIR)\/release:\n+\techo \"APIDIFF_VERSION=$(BUILD_VERSION) $(BUILD_NUMBER)\" > $@\n+\techo \"BUILD_DATE=`\/bin\/date +'%B %d, %Y'`\" >> $@\n+\tif [ -r $(TOPDIR)\/.git ]; then \\\n+\t    echo \"SOURCE=$$($(ID_COMMAND))\" >> $@ ; \\\n+\telif [ -r $(TOPDIR)\/.src-rev ]; then \\\n+\t    echo \"SOURCE=\\\"$$($(CAT) $(TOPDIR)\/.src-rev | $(SED) -e 's\/:\/:git:\/' -e 's\/  *$$\/\/')\\\"\" >> $@ ; \\\n+\tfi\n+\n+TARGETS.ZIP.apidiff += \\\n+\t$(APIDIFF_IMAGEDIR)\/release\n+\n+#----------------------------------------------------------------------\n+#\n+#  create apidiff.zip bundles\n+\n+APIDIFF_ZIP = $(IMAGES_DIR)\/apidiff.zip\n+\n+$(APIDIFF_ZIP): $(TARGETS.ZIP.apidiff)\n+\t$(RM) $@\n+\tcd $(IMAGES_DIR); $(ZIP) -rq $@ $(@F:%.zip=%)\n+\n+APIDIFF_ZIPFILES = $(APIDIFF_ZIP)\n+\n+#----------------------------------------------------------------------\n+#\n+#  create javadoc bundles\n+\n+$(BUILDDIR)\/api.jdk.codetools.apidiff.ok: \\\n+\t\t$(JAVAFILES.jdk.codetools.apidiff) \\\n+\t\t$(SRCDOCDIR)\/overview.html \\\n+\t\t$(SRCDOCDIR)\/jdk17.api\/element-list\n+\t$(JAVADOC) $(JAVADOC_OPTIONS) \\\n+\t\t-Xdoclint:-missing \\\n+\t\t-quiet \\\n+\t\t-cp $(JAVADIFFUTILS_JAR):$(DAISYDIFF_JAR) \\\n+\t\t-overview $(SRCDOCDIR)\/overview.html \\\n+\t\t-linkoffline \\\n+\t\t    https:\/\/docs.oracle.com\/en\/java\/javase\/11\/docs\/api\/index.html \\\n+\t\t    $(SRCDOCDIR)\/jdk17.api \\\n+\t\t-d $(BUILDDIR)\/api \\\n+\t\t$(JAVAFILES.jdk.codetools.apidiff)\n+\techo \"api built at `date`\" > $@\n+\n+TARGETS.jdk.codetools.apidiff += $(BUILDDIR)\/api.jdk.codetools.apidiff.ok\n+\n+#----------------------------------------------------------------------\n+\n+BUILDFILES += $(APIDIFF_ZIPFILES)\n+\n+VERBOSEZIPFILES += $(APIDIFF_ZIPFILES:%.zip=%-$(VERBOSE_ZIP_SUFFIX).zip)\n+\n+#APIDIFF_OPTS = \t$(APIDIFF_JAVA_OPTS:%=-J%)\n+\n+TESTS += $(TESTS.apidiff)\n","filename":"make\/apidiff.gmk","additions":329,"deletions":0,"binary":false,"changes":329,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+#\n+# Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+log_message() {\n+    local level=\"$1\"\n+    shift\n+    echo \"[${log_module}][${level}] $@\"\n+}\n+\n+error() {\n+    log_message \"ERROR\" \"$@\"\n+}\n+\n+info() {\n+    if [ -z \"${QUIET:-}\" ]; then\n+        log_message \"INFO\" \"$@\"\n+    fi\n+}\n+\n+##\n+# Helper used to ensure the correct number of arguments is passed to bash functions\n+check_arguments() {\n+    local name=\"$1\"\n+    local expected=\"$2\"\n+    local actual=\"$3\"\n+\n+    if [ ! \"${expected}\" = \"${actual}\" ]; then\n+        error \"Incorrect number of arguments to function '${name}' (expecting ${expected} but got ${actual})\"\n+        exit 1\n+    fi\n+}\n+\n+##\n+# Print an absolute path\n+abspath() {\n+    check_arguments \"${FUNCNAME}\" 1 $#\n+\n+    local path=\"$1\"\n+\n+    if [[ ${path} = \/* ]]; then\n+        echo \"${path}\"\n+    else\n+        echo \"$PWD\/${path}\"\n+    fi\n+}\n+\n+##\n+# Set up the checksum tool to use\n+#\n+setup_shasum() {\n+    if [ -n \"${SHASUM:-}\" ]; then\n+        return\n+    fi\n+\n+    if [ -n \"$(which sha1sum)\" ]; then\n+        SHASUM=\"sha1sum\"\n+        SHASUM_OPTIONS=\"\"\n+    elif [ -n \"$(which shasum)\" ]; then\n+        SHASUM=\"shasum\"\n+        SHASUM_OPTIONS=\"-a 1\"\n+    else\n+        error \"Can't find shasum or sha1sum\"\n+        exit 1\n+    fi\n+}\n+\n+native_path() {\n+    check_arguments \"${FUNCNAME}\" 1 $#\n+\n+    if [ $CYGWIN -eq 1 ]; then echo $(cygpath -w $1); else echo \"$1\"; fi\n+}\n+\n+mixed_path() {\n+    check_arguments \"${FUNCNAME}\" 1 $#\n+\n+    if [ $CYGWIN -eq 1 ]; then echo $(cygpath -m $1); else echo \"$1\"; fi\n+}\n+\n+##\n+# Download a file using wget\n+#\n+# wget options can be provided through the WGET_OPTIONS environment\n+# variable\n+#\n+download_using_wget() {\n+    check_arguments \"${FUNCNAME}\" 2 $#\n+\n+    local url=\"$1\"\n+    local destfile=\"$2\"\n+\n+    set +e\n+    \"${WGET}\" ${WGET_OPTIONS} \"${url}\" -O \"${destfile}\"\n+    ret=$?\n+    if [ ! ${ret} = 0 ]; then\n+        error \"wget exited with exit code ${ret}\"\n+        exit 1\n+    fi\n+    set -e\n+}\n+\n+##\n+# Download a file using curl\n+#\n+# curl options can be provided through the CURL_OPTIONS environment\n+# variable\n+#\n+download_using_curl() {\n+    check_arguments \"${FUNCNAME}\" 2 $#\n+\n+    local url=\"$1\"\n+    local destfile=\"$2\"\n+\n+    set +e\n+    \"${CURL}\" ${CURL_OPTIONS} \"${url}\" -o \"${destfile}\"\n+    ret=$?\n+     if [ ! ${ret} = 0 ]; then\n+        error \"curl exited with exit code ${ret}\"\n+        exit 1\n+    fi\n+    set -e\n+}\n+\n+##\n+# Download a file\n+#\n+# Will attempt to skip the download if the SKIP_DOWNLOAD environment\n+# variable is set and the destination file already exists\n+#\n+download() {\n+    check_arguments \"${FUNCNAME}\" 2 $#\n+\n+    local url=\"$1\"\n+    local destfile=\"$2\"\n+\n+    if [ \"${SKIP_DOWNLOAD:-}\" != \"\" -a -r \"${destfile}\" ]; then\n+        info \"Skipping download of ${url}...\"\n+        return\n+    fi\n+\n+    info \"Downloading ${url} to ${destfile}\"\n+    mkdir -p \"$(dirname \"${destfile}\")\"\n+    if [ -n \"${WGET}\" ]; then\n+        download_using_wget \"${url}\" \"${destfile}\"\n+    elif [ -n \"${CURL}\" ]; then\n+        download_using_curl \"${url}\" \"${destfile}\"\n+    else\n+        error \"Cannot find a suitable tool for downloading fils (tried 'wget' and 'curl')\"\n+        exit 1\n+    fi\n+}\n+\n+##\n+# Checksum a file\n+#\n+checksum() {\n+    check_arguments \"${FUNCNAME}\" 2 $#\n+\n+    local file=\"$1\"\n+    local expected=\"$2\"\n+\n+    if [ -n \"${SKIP_CHECKSUM_CHECK:-}\" ]; then\n+        return\n+    fi\n+\n+    if [ x\"${expected}\" = x\"\" ]; then\n+        error \"Expected checksum unexpectedly empty..\"\n+        exit 1\n+    fi\n+\n+    local actual=\"$(\"${SHASUM}\" ${SHASUM_OPTIONS} \"${dest}\" | awk '{ print $1; }')\"\n+    if [ ! x\"${actual}\" = x\"${expected}\" ]; then\n+        error \"Checksum mismatch for ${dest}:\"\n+        error \"Expected: ${expected}\"\n+        error \"Actual  : ${actual}\"\n+        exit 1\n+    fi\n+}\n+\n+##\n+# Download and checksum a file\n+#\n+download_and_checksum() {\n+    check_arguments \"${FUNCNAME}\" 3 $#\n+\n+    local url=\"$1\"\n+    local dest=\"$2\"\n+    local shasum=\"$3\"\n+\n+    download \"${url}\" \"${dest}\"\n+    checksum \"${dest}\" \"${shasum}\"\n+}\n+\n+##\n+# Unpack an archive\n+#\n+unpack() {\n+    check_arguments \"${FUNCNAME}\" 2 $#\n+\n+    local file=\"$1\"\n+    local unpackdir=\"$2\"\n+\n+    info \"Unpacking $file in $unpackdir\"\n+\n+    (\n+        mkdir -p \"${unpackdir}\"\n+        case ${file} in\n+            *.tar.gz)\n+                \"${TAR_CMD}\" -xzf \"$1\" -C \"${unpackdir}\"\n+                ;;\n+            *.zip)\n+                \"${UNZIP_CMD}\" -q \"$1\" -d \"${unpackdir}\"\n+                ;;\n+            *)\n+                error \"Unknown archive type for file '${file}'\"\n+                exit 1\n+        esac\n+    )\n+}\n+\n+##\n+# Download and unpack an archive without performing a checksum check\n+#\n+get_archive_no_checksum() {\n+    check_arguments \"${FUNCNAME}\" 3 $#\n+\n+    local url=\"$1\"\n+    local destfile=\"$2\"\n+    local unpackdir=\"$3\"\n+\n+    download \"${url}\" \"${destfile}\"\n+    unpack \"${destfile}\" \"${unpackdir}\"\n+}\n+\n+##\n+# Download, checksum, and unpack an archive\n+#\n+get_archive() {\n+    check_arguments \"${FUNCNAME}\" 4 $#\n+\n+    local url=\"$1\"\n+    local destfile=\"$2\"\n+    local unpackdir=\"$3\"\n+    local shasum=\"$4\"\n+\n+    download_and_checksum \"${url}\" \"${destfile}\" \"${shasum}\"\n+    unpack \"${destfile}\" \"${unpackdir}\"\n+}\n+\n+set -e\n+set -u\n+\n+if [ -z \"${mydir:-}\" ]; then\n+    error \"mydir not set in caller (line\/file): $(caller)\"\n+    exit 1\n+fi\n+if [ -z \"${log_module:-}\" ]; then\n+    error \"log_module not set in caller (line\/file): $(caller)\"\n+    exit 1\n+fi\n+\n+ROOT=\"$(abspath ${ROOT:-${mydir}\/..})\"\n+BUILD_DIR=\"$(abspath \"${BUILD_DIR:-${ROOT}\/build}\")\"\n+DEPS_DIR=\"${BUILD_DIR}\/deps\"\n+\n+export TAR_CMD=\"${TAR_CMD:-tar}\"\n+export TAR_OPTIONS=\"${TAR_OPTIONS:-}\"\n+export UNZIP_CMD=\"${UNZIP_CMD:-unzip}\"\n+export UNZIP_OPTIONS=\"${UNZIP_OPTIONS:--q} -u\"\n+export WGET=\"${WGET:-$(which wget)}\"\n+export WGET_OPTIONS=\"${WGET_OPTIONS:--q}\"\n+export CURL=\"${CURL:-$(which curl)}\"\n+export CURL_OPTIONS=\"${CURL_OPTIONS:--s -f -L}\"\n+\n+export MAVEN_REPO_URL_BASE=\"${MAVEN_REPO_URL_BASE:-https:\/\/repo1.maven.org\/maven2}\"\n+export GOOGLE_CODE_URL_BASE=\"${GOOGLE_CODE_URL_BASE:-https:\/\/storage.googleapis.com\/google-code-archive-downloads\/v2}\"\n+export DAISYDIFF_REPO_URL_BASE=${DAISYDIFF_REPO_URL_BASE:-\"https:\/\/github.com\/guyvdbroeck\/daisydiff-1\"}\n+export EQUINOX_REPO_URL_BASE=${EQUINOX_REPO_URL_BASE:-\"https:\/\/github.com\/eclipse-equinox\"}\n+\n+setup_shasum\n+\n+case $(uname) in CYGWIN*) CYGWIN=1 ;; *) CYGWIN=0 ;; esac\n","filename":"make\/build-support\/build-common.sh","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+#\n+# Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+APIDIFF_VERSION=1\n+\n+DEFAULT_DAISYDIFF_BIN_VERSION=1.2\n+DEFAULT_DAISYDIFF_BIN_ARCHIVE_CHECKSUM=fba904baf92f5208f36dc3ed3d6a19fbe9502b46\n+DEFAULT_DAISYDIFF_LICENSE_VERSION=master\n+DEFAULT_DAISYDIFF_LICENSE_CHECKSUM=7df059597099bb7dcf25d2a9aedfaf4465f72d8d\n+\n+DEFAULT_DAISYDIFF_SRC_VERSION=1.2-NX4\n+DEFAULT_DAISYDIFF_SRC_ARCHIVE_CHECKSUM=742a36fe6471790f91190cdf33e4cb348b6754b2\n+\n+DEFAULT_EQUINOX_VERSION=3.6.0\n+DEFAULT_EQUINOX_JAR_CHECKSUM=78e5d0b8516b042495660da36ce5114650f8f156\n+DEFAULT_EQUINOX_LICENSE_CHECKSUM=8d80da0c92c1269b610b03cc8061556004898c85\n+\n+DEFAULT_HTMLCLEANER_VERSION=2.29\n+DEFAULT_HTMLCLEANER_JAR_CHECKSUM=7b42d564b7d2a4674612ef0ec3696985cbd38343\n+DEFAULT_HTMLCLEANER_LICENSE_CHECKSUM=800231adc60dec964ec28270f0f0b94398ce9b3f\n+\n+DEFAULT_JAVADIFFUTILS_VERSION=4.12\n+DEFAULT_JAVADIFFUTILS_JAR_CHECKSUM=1a712a91324d566eef39817fc5c9980eb10c21db\n+DEFAULT_JAVADIFFUTILS_LICENSE_VERSION=parent-4.12\n+DEFAULT_JAVADIFFUTILS_LICENSE_CHECKSUM=7df059597099bb7dcf25d2a9aedfaf4465f72d8d\n+\n+# for testing\n+# JUnit 5 = JUnit Platform 1.y.z + JUnit Jupiter 5.y.z + JUnit Vintage 5.y.z\n+DEFAULT_JUNIT_VERSION=1.9.2\n+DEFAULT_JUNIT_JAR_CHECKSUM=bb856bc86a6e6cd48080546afcaf7a210713ea21\n+DEFAULT_JUNIT_LICENSE_FILE=LICENSE-junit.txt\n\\ No newline at end of file\n","filename":"make\/build-support\/version-numbers","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+#\n+# Copyright (c) 2007, 2016, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# set locations here, or in ${root}\/build.properties, or set on the\n+# ant command line\n+\n+apidiff.build.resources = \/opt\n+\n+build.version = 1.0\n+build.milestone = dev\n+build.number = b00\n","filename":"make\/build.properties","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,687 @@\n+#!\/bin\/sh\n+\n+#\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# This script will download\/build the dependencies for apidiff and then\n+# build apidiff. Downloaded files are verified against known\/specified\n+# specified checksums.\n+\n+# The default version to use when building apidiff can be found in the\n+# make\/version-numbers file, where the default versions and\n+# corresponding known checksums for the dependencies are also\n+# specified. Almost all of the defaults can be overridden by setting\n+# the respective environment variables.\n+\n+# For each of the dependency the following steps are applied and the\n+# first successful one is used:\n+#\n+# 1. Check if the dependency is available locally\n+# 2. Download a prebuilt version of the dependency\n+#\n+# In particular, when not found locally the dependencies will be\n+# handled as follows:\n+#\n+# * JUnit, Java Diff Utils, and HtmlCleaner are by default downloaded from Maven Central.\n+# * Daisy Diff is by default downloaded from Google Code Archive.\n+# * The JDK dependency is downloaded. No default URL is set.\n+#\n+\n+# Some noteworthy control variables:\n+#\n+# MAVEN_REPO_URL_BASE (e.g. \"https:\/\/repo1.maven.org\/maven2\")\n+#     The base URL for the maven central repository.\n+#\n+# GOOGLE_CODE_URL_BASE (e.g. \"https:\/\/code.google.com\/archive\/p\")\n+#     The base URL for the Google Code Archive repository.\n+#\n+# APIDIFF_VERSION         (e.g. \"1.0\")\n+# APIDIFF_VERSION_STRING  (e.g. \"apidiff-1.0+8\"\n+# APIDIFF_BUILD_NUMBER    (e.g. \"8\")\n+# APIDIFF_BUILD_MILESTONE (e.g. \"dev\")\n+#     The version information to use for when building apidiff.\n+#\n+# MAKE_ARGS (e.g. \"-j4 all\")\n+#     Additional arguments to pass to make when building apidiff.\n+#\n+# WGET\n+#     The wget-like executable to use when downloading files.\n+#\n+# WGET_OPTS (e.g. \"-v\")\n+#     Additional arguments to pass to WGET when downloading files.\n+#\n+# CURL (e.g. \"\/path\/to\/my\/wget\")\n+#     The curl-like executable to use when downloading files.\n+#     Note: If available, wget will be prefered.\n+#\n+# CURL_OPTS (e.g. \"-v\")\n+#     Additional arguments to pass to CURL when downloading files.\n+#\n+# SKIP_DOWNLOAD\n+#     Skip the downloads if the file is already present locally.\n+#\n+# SKIP_CHECKSUM_CHECK\n+#     Skip the checksum verification for downloaded files.\n+\n+# The control variables for dependencies are on the following general\n+# form (not all of them are relevant for all dependencies):\n+#\n+# <dependency>_URL (e.g. DAISYDIFF_BIN_ARCHIVE_URL)\n+#     The full URL for the dependency.\n+#\n+# <dependency>_URL_BASE (e.g. DAISYDIFF_BIN_ARCHIVE_URL_BASE)\n+#     The base URL for the dependency. Requires additional dependency\n+#     specific variables to be specified.\n+#\n+# <dependency>_CHECKSUM (e.g. DAISYDIFF_BIN_ARCHIVE_CHECKSUM)\n+#     The expected checksum of the download file.\n+#\n+\n+# The below outlines the details of how the dependencies are\n+# handled. For each dependency the steps are tried in order and the\n+# first successful one will be used.\n+#\n+# JDK\n+#     Checksum variables:\n+#         JDK_ARCHIVE_CHECKSUM: checksum of binary archive\n+#\n+#     1. JAVA_HOME\n+#         The path to the JDK.\n+#     2a. JDK_ARCHIVE_URL\n+#         The full URL for the archive.\n+#     2b. JDK_ARCHIVE_URL_BASE + JDK_VERSION + JDK_BUILD_NUMBER + JDK_FILE\n+#         The individual URL components used to construct the full URL.\n+#\n+# Java Diff Utils\n+#     Checksum variables:\n+#         JAVADIFFUTILS_JAR_CHECKSUM: checksum of jar\n+#         JAVADIFFUTILS_LICENSE_CHECKSUM: checksum of LICENSE file\n+#\n+#     1. JAVADIFFUTILS_JAR + JAVADIFFUTILS_LICENSE\n+#         The path to java-diff-utils.jar and LICENSE.txt respectively.\n+#     2a. JAVADIFFUTILS_JAR_URL\n+#         The full URL for the jar.\n+#     2b. JAVADIFFUTILS_JAR_URL_BASE + JAVADIFFUTILS_VERSION + JAVADIFFUTILS_FILE\n+#         The individual URL components used to construct the full URL.\n+#\n+# Daisy Diff\n+#     Checksum variables:\n+#         DAISYDIFF_BIN_ARCHIVE_CHECKSUM: checksum of binary archive\n+#         DAISYDIFF_LICENSE_CHECKSUM: checksum of LICENSE file\n+#\n+#     1. DAISYDIFF_JAR + DAISYDIFF_LICENSE\n+#         The path to daisydiff.jar and LICENSE.txt respectively.\n+#     2a. DAISYDIFF_JAR_URL\n+#         The full URL for the jar.\n+#     2b. DAISYDIFF_JAR_URL_BASE + DAISYDIFF_BIN_VERSION + DAISYDIFF_FILE\n+#         The individual URL components used to construct the full URL.\n+#\n+# Html Cleaner\n+#     Checksum variables:\n+#         HTMLCLEANER_JAR_CHECKSUM: checksum of jar\n+#         HTMLCLEANER_LICENSE_CHECKSUM: checksum of LICENSE file\n+#\n+#     1. HTMLCLEANER_JAR + HTMLCLEANER_LICENSE\n+#         The path to htmlcleaner.jar and licence.txt respectively.\n+#     2a. HTMLCLEANER_JAR_URL\n+#         The full URL for the jar.\n+#     2b. HTMLCLEANER_JAR_URL_BASE + HTMLCLEANER_VERSION + HTMLCLEANER_FILE\n+#         The individual URL components used to construct the full URL.\n+#\n+# JUnit, for running self-tests\n+#     Checksum variables:\n+#         JUNIT_JAR_CHECKSUM: checksum of binary archive\n+#\n+#     1. JUNIT_JAR + JUNIT_LICENSE\n+#         The path to junit.jar and LICENSE respectively.\n+#     2a. JUNIT_JAR_URL\n+#         The full URL for the jar.\n+#     2b. JUNIT_JAR_URL_BASE + JUNIT_VERSION + JUNIT_FILE\n+#         The individual URL components used to construct the full URL.\n+#\n+# Some control variables can be overridden by command-line options.\n+# Use the  --help option for details.\n+\n+mydir=\"$(dirname ${BASH_SOURCE[0]})\"\n+log_module=\"$(basename \"${BASH_SOURCE[0]}\")\"\n+. \"${mydir}\/build-support\/build-common.sh\"\n+\n+usage() {\n+    echo \"Usage: $0 <options> [ [--] <make-options-and-targets> ]\"\n+    echo \"--help\"\n+    echo \"      Show this message\"\n+    echo \"--jdk \/path\/to\/jdk\"\n+    echo \"      Path to JDK; must be JDK 17 or higher\"\n+    echo \"--quiet | -q\"\n+    echo \"      Reduce the logging output.\"\n+    echo \"--show-default-versions\"\n+    echo \"      Show default versions of external components\"\n+    echo \"--show-config-details\"\n+    echo \"      Show configuration details\"\n+    echo \"--skip-checksum-check\"\n+    echo \"      Skip the checksum check for downloaded files.\"\n+    echo \"--skip-download\"\n+    echo \"      Skip downloading files if file already available\"\n+    echo \"--skip-make\"\n+    echo \"      Skip running 'make' (just download dependencies if needed)\"\n+    echo \"--version-numbers file\"\n+    echo \"      Provide an alternate file containing dependency version information\"\n+    echo \"--\"\n+    echo \"      Subsequent arguments are for 'make'\"\n+}\n+\n+ensure_arg() {\n+    check_arguments \"${FUNCNAME}\" 2 $#\n+    local option=\"$1\"\n+    local arg_count=\"$2\"\n+    if [ \"$2\" -lt \"2\" ]; then\n+        echo \"The $option option requires an argument\"\n+        exit\n+    fi\n+}\n+\n+process_args() {\n+    while [ \"$#\" -gt 0 ]; do\n+        case \"$1\" in\n+            --help|-h )             HELP=1 ;                                        shift ;;\n+            --jdk )                 ensure_arg \"$1\" $# ; JAVA_HOME=\"$2\" ;           shift ; shift ;;\n+            --quiet|-q )            export QUIET=1 ;                                shift ;;\n+            --show-config-details ) SHOW_CONFIG_DETAILS=1 ;                         shift ;;\n+            --show-default-versions ) SHOW_DEFAULT_VERSIONS=1 ;                     shift ;;\n+            --skip-checksum-check ) export SKIP_CHECKSUM_CHECK=1 ;                  shift ;;\n+            --skip-download )       export SKIP_DOWNLOAD=1 ;                        shift ;;\n+            --skip-make )           SKIP_MAKE=1 ;                                   shift ;;\n+            --version-numbers )     ensure_arg \"$1\" $# ; VERSION_NUMBERS=\"$2\" ;     shift ; shift ;;\n+            -- )                    shift ; MAKE_ARGS=\"$@\" ;                        break ;;\n+            -* )                    error \"unknown option: '$1'\" ;                  exit 1 ;;\n+            * )                     MAKE_ARGS=\"$@\" ;                                break ;;\n+        esac\n+    done\n+}\n+\n+process_args \"$@\"\n+\n+if [ -n \"${HELP:-}\" ]; then\n+    usage\n+    exit\n+fi\n+\n+. \"${VERSION_NUMBERS:-${mydir}\/build-support\/version-numbers}\"\n+\n+APIDIFF_VERSION=\"${APIDIFF_VERSION:-}\"\n+\n+DAISYDIFF_BIN_VERSION=\"${DAISYDIFF_BIN_VERSION:-${DEFAULT_DAISYDIFF_BIN_VERSION}}\"\n+# uncomment or override to download a precompiled jar file for daisydiff\n+#DAISYDIFF_BIN_ARCHIVE_URL_BASE=\"${DAISYDIFF_BIN_ARCHIVE_URL_BASE:-${GOOGLE_CODE_URL_BASE}}\"\n+#DAISYDIFF_BIN_ARCHIVE_CHECKSUM=\"${DAISYDIFF_BIN_ARCHIVE_CHECKSUM:-${DEFAULT_DAISYDIFF_BIN_ARCHIVE_CHECKSUM}}\"\n+DAISYDIFF_LICENSE_VERSION=\"${DAISYDIFF_LICENSE_VERSION:-${DEFAULT_DAISYDIFF_LICENSE_VERSION:-${DAISYDIFF_BIN_VERSION}}}\"\n+DAISYDIFF_LICENSE_CHECKSUM=\"${DAISYDIFF_LICENSE_CHECKSUM:-${DEFAULT_DAISYDIFF_LICENSE_CHECKSUM}}\"\n+\n+DAISYDIFF_SRC_VERSION=\"${DAISYDIFF_SRC_VERSION:-${DEFAULT_DAISYDIFF_SRC_VERSION}}\"\n+DAISYDIFF_SRC_ARCHIVE_URL_BASE=\"${DAISYDIFF_SRC_ARCHIVE_URL_BASE:-${DAISYDIFF_REPO_URL_BASE}}\"\n+DAISYDIFF_SRC_ARCHIVE_CHECKSUM=\"${DAISYDIFF_SRC_ARCHIVE_CHECKSUM:-${DEFAULT_DAISYDIFF_SRC_ARCHIVE_CHECKSUM}}\"\n+\n+EQUINOX_VERSION=\"${EQUINOX_VERSION:-${DEFAULT_EQUINOX_VERSION}}\"\n+EQUINOX_JAR_URL_BASE=\"${EQUINOX_JAR_URL_BASE:-${MAVEN_REPO_URL_BASE}}\"\n+EQUINOX_JAR_CHECKSUM=\"${EQUINOX_JAR_CHECKSUM:-${DEFAULT_EQUINOX_JAR_CHECKSUM}}\"\n+EQUINOX_LICENSE_CHECKSUM=\"${EQUINOX_LICENSE_CHECKSUM:-${DEFAULT_EQUINOX_LICENSE_CHECKSUM}}\"\n+\n+HTMLCLEANER_VERSION=\"${HTMLCLEANER_VERSION:-${DEFAULT_HTMLCLEANER_VERSION}}\"\n+HTMLCLEANER_JAR_URL_BASE=\"${HTMLCLEANER_JAR_URL_BASE:-${MAVEN_REPO_URL_BASE}}\"\n+HTMLCLEANER_JAR_CHECKSUM=\"${HTMLCLEANER_JAR_CHECKSUM:-${DEFAULT_HTMLCLEANER_JAR_CHECKSUM}}\"\n+HTMLCLEANER_LICENSE_CHECKSUM=\"${HTMLCLEANER_LICENSE_CHECKSUM:-${DEFAULT_HTMLCLEANER_LICENSE_CHECKSUM}}\"\n+\n+JAVADIFFUTILS_VERSION=\"${JAVADIFFUTILS_VERSION:-${DEFAULT_JAVADIFFUTILS_VERSION}}\"\n+JAVADIFFUTILS_JAR_URL_BASE=\"${JAVADIFFUTILS_JAR_URL_BASE:-${MAVEN_REPO_URL_BASE}}\"\n+JAVADIFFUTILS_JAR_CHECKSUM=\"${JAVADIFFUTILS_JAR_CHECKSUM:-${DEFAULT_JAVADIFFUTILS_JAR_CHECKSUM}}\"\n+JAVADIFFUTILS_LICENSE_VERSION=\"${JAVADIFFUTILS_LICENSE_VERSION:-${DEFAULT_JAVADIFFUTILS_LICENSE_VERSION:-${JAVADIFFUTILS_VERSION}}}\"\n+JAVADIFFUTILS_LICENSE_CHECKSUM=\"${JAVADIFFUTILS_LICENSE_CHECKSUM:-${DEFAULT_JAVADIFFUTILS_LICENSE_CHECKSUM}}\"\n+\n+JUNIT_VERSION=\"${JUNIT_VERSION:-${DEFAULT_JUNIT_VERSION}}\"\n+JUNIT_JAR_URL_BASE=\"${JUNIT_JAR_URL_BASE:-${MAVEN_REPO_URL_BASE}}\"\n+JUNIT_JAR_CHECKSUM=\"${JUNIT_JAR_CHECKSUM:-${DEFAULT_JUNIT_JAR_CHECKSUM}}\"\n+JUNIT_LICENSE_FILE=\"${JUNIT_LICENSE_FILE:-${DEFAULT_JUNIT_LICENSE_FILE}}\"\n+\n+if [ \"${SHOW_DEFAULT_VERSIONS:-}\" != \"\" ]; then\n+    find ${mydir} -name version-numbers | \\\n+        xargs cat | \\\n+        grep -v '^#' | \\\n+        grep -E 'DEFAULT.*(_VERSION|_SRC_TAG)' | \\\n+        sort -u\n+    exit\n+fi\n+\n+if [ \"${SHOW_CONFIG_DETAILS:-}\" != \"\" ]; then\n+    ( set -o posix ; set ) | \\\n+        grep -E '^(DAISYDIFF|JAVADIFFUTILS|JUNIT)_[A-Z_]*=' | \\\n+        sort -u\n+    exit\n+fi\n+\n+setup_java_home() {\n+    check_arguments \"${FUNCNAME}\" 0 $#\n+\n+    if [ -n \"${JAVA_HOME:-}\" ]; then\n+        return\n+    fi\n+\n+    if [ -z \"${JDK_ARCHIVE_URL:-}\" ]; then\n+        if [ -n \"${JDK_ARCHIVE_URL_BASE:-}\" ]; then\n+            if [ -z \"${JDK_VERSION:-}\" ]; then\n+                error \"JDK_VERSION not set\"\n+                exit 1\n+            fi\n+            if [ -z \"${JDK_BUILD_NUMBER:-}\" ]; then\n+                error \"JDK_BUILD_NUMBER not set\"\n+                exit 1\n+            fi\n+            if [ -z \"${JDK_FILE:-}\" ]; then\n+                error \"JDK_FILE not set\"\n+                exit 1\n+            fi\n+            JDK_ARCHIVE_URL=\"${JDK_ARCHIVE_URL_BASE}\/${JDK_VERSION}\/${JDK_BUILD_NUMBER}\/${JDK_FILE}\"\n+        fi\n+    fi\n+\n+    local JDK_DEPS_DIR=\"${DEPS_DIR}\"\n+\n+    if [ -n \"${JDK_ARCHIVE_URL:-}\" ]; then\n+        local JDK_LOCAL_ARCHIVE_FILE=\"${JDK_DEPS_DIR}\/$(basename \"${JDK_ARCHIVE_URL}\")\"\n+        if [ -n \"${JDK_ARCHIVE_CHECKSUM:-}\" ]; then\n+            get_archive \"${JDK_ARCHIVE_URL}\" \"${JDK_LOCAL_ARCHIVE_FILE}\" \"${JDK_DEPS_DIR}\" \"${JDK_ARCHIVE_CHECKSUM}\"\n+        else\n+            get_archive_no_checksum \"${JDK_ARCHIVE_URL}\" \"${JDK_LOCAL_ARCHIVE_FILE}\" \"${JDK_DEPS_DIR}\"\n+        fi\n+        local JDK_JAVAC=\"$(find \"${JDK_DEPS_DIR}\" -path '*\/bin\/javac')\"\n+        JAVA_HOME=\"$(dirname $(dirname \"${JDK_JAVAC}\"))\"\n+        return\n+    fi\n+\n+    error \"None of --jdk, JAVA_HOME, JDK_ARCHIVE_URL or JDK_ARCHIVE_URL_BASE are set\"\n+    exit 1\n+}\n+\n+sanity_check_java_home() {\n+    if [ -z \"${JAVA_HOME:-}\" ]; then\n+        error \"No JAVA_HOME set\"\n+        exit 1\n+    fi\n+\n+    if [ ! -d \"${JAVA_HOME}\" ]; then\n+        error \"'${JAVA_HOME}' is not a directory\"\n+        exit 1\n+    fi\n+\n+    if [ ! -x \"${JAVA_HOME}\/bin\/java\" ]; then\n+        error \"Could not find an executable binary at '${JAVA_HOME}\/bin\/java'\"\n+        exit 1\n+    fi\n+\n+    local version=$(${JAVA_HOME}\/bin\/java -version 2>&1)\n+    local vnum=$(echo \"${version}\" | \\\n+        grep -i -E '^(java|openjdk)' |\n+        head -n 1 | \\\n+        sed -e 's\/^[^0-9]*\/\/' -e 's\/[^0-9].*\/\/' )\n+    if [ \"${vnum:-0}\" -lt \"17\" ]; then\n+        error \"JDK 17 or newer is required to build apidiff\"\n+        exit 1\n+    fi\n+}\n+setup_java_home\n+sanity_check_java_home\n+export JAVA_HOME\n+info \"JAVA_HOME: ${JAVA_HOME}\"\n+\n+#----- Daisy Diff -----\n+setup_daisydiff_jar() {\n+    check_arguments \"${FUNCNAME}\" 0 $#\n+\n+    if [ -n \"${DAISYDIFF_JAR:-}\" ]; then\n+        return\n+    fi\n+\n+    local DAISYDIFF_DEPS_DIR=\"${DEPS_DIR}\/daisydiff\"\n+\n+    if [ -z \"${DAISYDIFF_SRC_ARCHIVE_URL:-}\" ]; then\n+        if [ -n \"${DAISYDIFF_SRC_ARCHIVE_URL_BASE:-}\" ]; then\n+            DAISYDIFF_SRC_ARCHIVE_URL=\"${DAISYDIFF_SRC_ARCHIVE_URL_BASE}\/archive\/refs\/tags\/release-${DAISYDIFF_SRC_VERSION}.tar.gz\"\n+        fi\n+    fi\n+\n+    if [ -n \"${DAISYDIFF_SRC_ARCHIVE_URL:-}\" ]; then\n+        local DAISYDIFF_LOCAL_ARCHIVE_FILE=\"${DAISYDIFF_DEPS_DIR}\/$(basename \"${DAISYDIFF_SRC_ARCHIVE_URL}\")\"\n+        get_archive \"${DAISYDIFF_SRC_ARCHIVE_URL}\" \"${DAISYDIFF_LOCAL_ARCHIVE_FILE}\" \"${DAISYDIFF_DEPS_DIR}\" \"${DAISYDIFF_SRC_ARCHIVE_CHECKSUM}\"\n+        DAISYDIFF_SRC=$(cd \"${DAISYDIFF_DEPS_DIR}\"\/*\/src; pwd)\n+        return\n+    fi\n+\n+    info \"None of DAISYDIFF_JAR, DAISYDIFF_SRC_ARCHIVE_URL, DAISYDIFF_SRC_ARCHIVE_URL_BASE are set\"\n+}\n+\n+setup_daisydiff_jar\n+if [ -n \"${DAISYDIFF_JAR:-}\" ]; then\n+    info \"DAISYDIFF_JAR: ${DAISYDIFF_JAR}\"\n+else\n+    info \"DAISYDIFF_SRC: ${DAISYDIFF_SRC}\"\n+fi\n+\n+#----- Daisy Diff License -----\n+setup_daisydiff_license() {\n+    check_arguments \"${FUNCNAME}\" 0 $#\n+\n+    if [ -n \"${DAISYDIFF_LICENSE:-}\" ]; then\n+        return\n+    fi\n+\n+    local DAISYDIFF_LICENSE_DEPS_DIR=\"${DEPS_DIR}\/daisydiff-license\"\n+    DAISYDIFF_LICENSE=\"${DAISYDIFF_LICENSE_DEPS_DIR}\/LICENSE\"\n+    download_and_checksum \"https:\/\/raw.githubusercontent.com\/DaisyDiff\/DaisyDiff\/${DAISYDIFF_LICENSE_VERSION}\/LICENSE.txt\" \"${DAISYDIFF_LICENSE}\" \"${DAISYDIFF_LICENSE_CHECKSUM}\"\n+}\n+setup_daisydiff_license\n+info \"DAISYDIFF_LICENSE: ${DAISYDIFF_LICENSE}\"\n+\n+#----- Eclipse Equinox Common Runtime\n+setup_equinox_jar() {\n+    check_arguments \"${FUNCNAME}\" 0 $#\n+\n+    if [ -n \"${EQUINOX_JAR:-}\" ]; then\n+        return\n+    fi\n+\n+    if [ -z \"${EQUINOX_JAR_URL:-}\" ]; then\n+        if [ -n \"${EQUINOX_JAR_URL_BASE:-}\" ]; then\n+            EQUINOX_JAR_URL=\"${EQUINOX_JAR_URL_BASE}\/org\/eclipse\/equinox\/org.eclipse.equinox.common\/${EQUINOX_VERSION}\/org.eclipse.equinox.common-${EQUINOX_VERSION}.jar\"\n+        fi\n+    fi\n+\n+    local EQUINOX_DEPS_DIR=\"${DEPS_DIR}\/equinox\"\n+\n+    if [ -n \"${EQUINOX_JAR_URL:-}\" ]; then\n+        EQUINOX_JAR=\"${EQUINOX_DEPS_DIR}\/$(basename \"${EQUINOX_JAR_URL}\")\"\n+        download_and_checksum \"${EQUINOX_JAR_URL}\" \"${EQUINOX_JAR}\" \"${EQUINOX_JAR_CHECKSUM}\"\n+        return\n+    fi\n+\n+    error \"Neither EQUINOX_JAR_URL nor EQUINOX_JAR_URL_BASE is set\"\n+    exit 1\n+}\n+\n+if [ -n \"${DAISYDIFF_SRC:-}\" ]; then\n+    setup_equinox_jar\n+    info \"EQUINOX_JAR: ${EQUINOX_JAR}\"\n+fi\n+\n+#----- Eclipse Equinox Common Runtime License -----\n+setup_equinox_license() {\n+    check_arguments \"${FUNCNAME}\" 0 $#\n+\n+    if [ -n \"${EQUINOX_LICENSE:-}\" ]; then\n+        return\n+    fi\n+\n+    local EQUINOX_LICENSE_DEPS_DIR=\"${DEPS_DIR}\/equinox-license\"\n+    EQUINOX_LICENSE=\"${EQUINOX_LICENSE_DEPS_DIR}\/epl-v10.html\"\n+    download_and_checksum \"http:\/\/www.eclipse.org\/org\/documents\/epl-v10.html\" \"${EQUINOX_LICENSE}\" \"${EQUINOX_LICENSE_CHECKSUM}\"\n+\n+}\n+\n+if [ -n \"${DAISYDIFF_SRC:-}\" ]; then\n+    setup_equinox_license\n+    info \"EQUINOX_LICENSE: ${EQUINOX_LICENSE}\"\n+fi\n+\n+#----- Html Cleaner\n+setup_htmlcleaner_jar() {\n+    check_arguments \"${FUNCNAME}\" 0 $#\n+\n+    if [ -n \"${HTMLCLEANER_JAR:-}\" ]; then\n+        return\n+    fi\n+\n+    if [ -z \"${HTMLCLEANER_JAR_URL:-}\" ]; then\n+        if [ -n \"${HTMLCLEANER_JAR_URL_BASE:-}\" ]; then\n+            HTMLCLEANER_JAR_URL=\"${HTMLCLEANER_JAR_URL_BASE}\/net\/sourceforge\/htmlcleaner\/htmlcleaner\/${HTMLCLEANER_VERSION}\/htmlcleaner-${HTMLCLEANER_VERSION}.jar\"\n+        fi\n+    fi\n+\n+    local HTMLCLEANER_DEPS_DIR=\"${DEPS_DIR}\/htmlcleaner\"\n+\n+    if [ -n \"${HTMLCLEANER_JAR_URL:-}\" ]; then\n+        HTMLCLEANER_JAR=\"${HTMLCLEANER_DEPS_DIR}\/$(basename \"${HTMLCLEANER_JAR_URL}\")\"\n+        download_and_checksum \"${HTMLCLEANER_JAR_URL}\" \"${HTMLCLEANER_JAR}\" \"${HTMLCLEANER_JAR_CHECKSUM}\"\n+        return\n+    fi\n+\n+    error \"Neither HTMLCLEANER_JAR_URL nor HTMLCLEANER_JAR_URL_BASE is set\"\n+    exit 1\n+}\n+setup_htmlcleaner_jar\n+info \"HTMLCLEANER_JAR: ${HTMLCLEANER_JAR}\"\n+\n+#----- Html Cleaner License -----\n+setup_htmlcleaner_license() {\n+    check_arguments \"${FUNCNAME}\" 0 $#\n+\n+    if [ -n \"${HTMLCLEANER_LICENSE:-}\" ]; then\n+        return\n+    fi\n+\n+    local HTMLCLEANER_LICENSE_DEPS_DIR=\"${DEPS_DIR}\/htmlcleaner-license\"\n+    HTMLCLEANER_LICENSE=\"${HTMLCLEANER_LICENSE_DEPS_DIR}\/licence.txt\"\n+    download_and_checksum \"https:\/\/sourceforge.net\/p\/htmlcleaner\/code\/HEAD\/tree\/tags\/htmlcleaner-${HTMLCLEANER_VERSION}\/licence.txt?format=raw\" \"${HTMLCLEANER_LICENSE}\" \"${HTMLCLEANER_LICENSE_CHECKSUM}\"\n+\n+}\n+setup_htmlcleaner_license\n+info \"HTMLCLEANER_LICENSE: ${HTMLCLEANER_LICENSE}\"\n+\n+\n+#----- Java Diff Utils -----\n+setup_javadiffutils() {\n+    check_arguments \"${FUNCNAME}\" 0 $#\n+\n+    if [ -n \"${JAVADIFFUTILS_JAR:-}\" ]; then\n+        return\n+    fi\n+\n+    if [ -z \"${JAVADIFFUTILS_JAR_URL:-}\" ]; then\n+        if [ -n \"${JAVADIFFUTILS_JAR_URL_BASE:-}\" ]; then\n+            JAVADIFFUTILS_JAR_URL=\"${JAVADIFFUTILS_JAR_URL_BASE}\/io\/github\/java-diff-utils\/java-diff-utils\/${JAVADIFFUTILS_VERSION}\/java-diff-utils-${JAVADIFFUTILS_VERSION}.jar\"\n+        fi\n+    fi\n+\n+    local JAVADIFFUTILS_DEPS_DIR=\"${DEPS_DIR}\/java-diff-utils\"\n+\n+    if [ -n \"${JAVADIFFUTILS_JAR_URL:-}\" ]; then\n+        JAVADIFFUTILS_JAR=\"${JAVADIFFUTILS_DEPS_DIR}\/$(basename \"${JAVADIFFUTILS_JAR_URL}\")\"\n+        download_and_checksum \"${JAVADIFFUTILS_JAR_URL}\" \"${JAVADIFFUTILS_JAR}\" \"${JAVADIFFUTILS_JAR_CHECKSUM}\"\n+        return\n+    fi\n+\n+    error \"Neither JAVADIFFUTILS_JAR_URL nor JAVADIFFUTILS_JAR_URL_BASE is set\"\n+    exit 1\n+}\n+setup_javadiffutils\n+info \"JAVADIFFUTILS_JAR: ${JAVADIFFUTILS_JAR}\"\n+\n+#----- Java Diff Utils License -----\n+setup_javadiffutils_license() {\n+    check_arguments \"${FUNCNAME}\" 0 $#\n+\n+    if [ -n \"${JAVADIFFUTILS_LICENSE:-}\" ]; then\n+        return\n+    fi\n+\n+    local JAVADIFFUTILS_LICENSE_DEPS_DIR=\"${DEPS_DIR}\/javadiffutils-license\"\n+    JAVADIFFUTILS_LICENSE=\"${JAVADIFFUTILS_LICENSE_DEPS_DIR}\/LICENSE\"\n+    download_and_checksum \"https:\/\/raw.githubusercontent.com\/java-diff-utils\/java-diff-utils\/java-diff-utils-${JAVADIFFUTILS_LICENSE_VERSION}\/LICENSE\" \"${JAVADIFFUTILS_LICENSE}\" \"${JAVADIFFUTILS_LICENSE_CHECKSUM}\"\n+}\n+setup_javadiffutils_license\n+info \"JAVADIFFUTILS_LICENSE: ${JAVADIFFUTILS_LICENSE}\"\n+\n+\n+\n+#----- JUnit -----\n+setup_junit() {\n+    check_arguments \"${FUNCNAME}\" 0 $#\n+\n+    if [ -n \"${JUNIT_JAR:-}\" ]; then\n+        return\n+    fi\n+\n+    if [ -z \"${JUNIT_JAR_URL:-}\" ]; then\n+        if [ -n \"${JUNIT_JAR_URL_BASE:-}\" ]; then\n+            JUNIT_JAR_URL=\"${JUNIT_JAR_URL_BASE}\/org\/junit\/platform\/junit-platform-console-standalone\/${JUNIT_VERSION}\/junit-platform-console-standalone-${JUNIT_VERSION}.jar\"\n+        fi\n+    fi\n+\n+    local JUNIT_DEPS_DIR=\"${DEPS_DIR}\/junit\"\n+\n+    if [ -n \"${JUNIT_JAR_URL:-}\" ]; then\n+        JUNIT_JAR=\"${JUNIT_DEPS_DIR}\/$(basename ${JUNIT_JAR_URL})\"\n+        download_and_checksum \"${JUNIT_JAR_URL}\" \"${JUNIT_JAR}\" \"${JUNIT_JAR_CHECKSUM}\"\n+        return\n+    fi\n+\n+    error \"None of JUNIT_JAR, JUNIT_JAR_URL or JUNIT_JAR_URL_BASE is set\"\n+    exit 1\n+}\n+setup_junit\n+info \"JUNIT_JAR ${JUNIT_JAR}\"\n+\n+#----- JUnit license -----\n+setup_junit_license() {\n+    check_arguments \"${FUNCNAME}\" 0 $#\n+\n+    if [ -n \"${JUNIT_LICENSE:-}\" ]; then\n+        return\n+    fi\n+\n+    local JUNIT_LICENSE_DEPS_DIR=\"${DEPS_DIR}\/junit-license\"\n+    \"${UNZIP_CMD}\" ${UNZIP_OPTIONS} \"${JUNIT_JAR}\" ${JUNIT_LICENSE_FILE} -d \"${JUNIT_LICENSE_DEPS_DIR}\"\n+    JUNIT_LICENSE=\"${JUNIT_LICENSE_DEPS_DIR}\/${JUNIT_LICENSE_FILE}\"\n+}\n+setup_junit_license\n+info \"JUNIT_LICENSE: ${JUNIT_LICENSE}\"\n+\n+##\n+# Build number defaults to 0\n+#\n+setup_build_info() {\n+    check_arguments \"${FUNCNAME}\" 0 $#\n+\n+    APIDIFF_BUILD_MILESTONE=\"${APIDIFF_BUILD_MILESTONE:-dev}\"\n+    APIDIFF_BUILD_NUMBER=\"${APIDIFF_BUILD_NUMBER:-0}\"\n+\n+    if [ -z \"${APIDIFF_VERSION_STRING:-}\" ]; then\n+        MILESTONE=\"\"\n+        if [ -n \"${APIDIFF_BUILD_MILESTONE}\" ]; then\n+            MILESTONE=\"-${APIDIFF_BUILD_MILESTONE}\"\n+        fi\n+        APIDIFF_VERSION_STRING=\"${APIDIFF_VERSION}${MILESTONE}+${APIDIFF_BUILD_NUMBER}\"\n+    fi\n+}\n+setup_build_info\n+info \"APIDIFF_VERSION: ${APIDIFF_VERSION}\"\n+info \"APIDIFF_BUILD_NUMBER: ${APIDIFF_BUILD_NUMBER}\"\n+info \"APIDIFF_BUILD_MILESTONE: ${APIDIFF_BUILD_MILESTONE}\"\n+\n+check_file() {\n+    check_arguments \"${FUNCNAME}\" 1 $#\n+\n+    info \"Checking $1\"\n+    if [ ! -f \"$1\" ]; then\n+        error \"Missing: $1\"\n+        exit 1\n+    fi\n+}\n+\n+check_dir() {\n+    check_arguments \"${FUNCNAME}\" 1 $#\n+\n+    info \"Checking $1\"\n+    if [ ! -d \"$1\" ]; then\n+        error \"Missing: $1\"\n+        exit 1\n+    fi\n+}\n+\n+check_dir  \"${JAVA_HOME}\"\n+check_file \"${JUNIT_JAR}\"\n+check_file \"${JAVADIFFUTILS_JAR}\"\n+if [ -n \"${JAVADIFFUTILS_LICENSE:-}\" ]; then\n+    check_file \"${JAVADIFFUTILS_LICENSE}\"\n+fi\n+if [ -n \"${DAISYDIFF_JAR:-}\" ]; then\n+    check_file \"${DAISYDIFF_JAR}\"\n+fi\n+if [ -n \"${DAISYDIFF_SRC:-}\" ]; then\n+    check_dir \"${DAISYDIFF_SRC}\"\n+fi\n+if [ -n \"${DAISYDIFF_LICENSE:-}\" ]; then\n+    check_file \"${DAISYDIFF_LICENSE}\"\n+fi\n+if [ -n \"${EQUINOX_JAR:-}\" ]; then\n+    check_file \"${EQUINOX_JAR}\"\n+fi\n+if [ -n \"${EQUINOX_LICENSE:-}\" ]; then\n+    check_file \"${EQUINOX_LICENSE}\"\n+fi\n+check_file \"${HTMLCLEANER_JAR}\"\n+if [ -n \"${HTMLCLEANER_LICENSE:-}\" ]; then\n+    check_file \"${HTMLCLEANER_LICENSE}\"\n+fi\n+\n+if [ -n \"${SKIP_MAKE:-}\" ]; then\n+    exit\n+fi\n+\n+\n+# save make command for possible later reuse, bypassing this script\n+mkdir -p ${BUILD_DIR}\n+cat > ${BUILD_DIR}\/make.sh << EOF\n+#!\/bin\/sh\n+\n+# Build apidiff\n+cd \"${ROOT}\/make\"\n+make BUILDDIR=\"${BUILD_DIR}\"                                  \\\\\n+     BUILD_MILESTONE=\"${APIDIFF_BUILD_MILESTONE}\"             \\\\\n+     BUILD_NUMBER=\"${APIDIFF_BUILD_NUMBER}\"                   \\\\\n+     BUILD_VERSION=\"${APIDIFF_VERSION}\"                       \\\\\n+     BUILD_VERSION_STRING=\"${APIDIFF_VERSION_STRING}\"         \\\\\n+     DAISYDIFF_JAR=\"$(mixed_path \"${DAISYDIFF_JAR:-}\")\"       \\\\\n+     DAISYDIFF_SRC=\"$(mixed_path \"${DAISYDIFF_SRC:-}\")\"       \\\\\n+     DAISYDIFF_LICENSE=\"${DAISYDIFF_LICENSE}\"                 \\\\\n+     EQUINOX_JAR=\"$(mixed_path \"${EQUINOX_JAR:-}\")\"           \\\\\n+     EQUINOX_LICENSE=\"$(mixed_path \"${EQUINOX_LICENSE:-}\")\"   \\\\\n+     HTMLCLEANER_JAR=\"${HTMLCLEANER_JAR}\"                     \\\\\n+     HTMLCLEANER_LICENSE=\"${HTMLCLEANER_LICENSE}\"             \\\\\n+     JAVADIFFUTILS_JAR=\"$(mixed_path \"${JAVADIFFUTILS_JAR}\")\" \\\\\n+     JAVADIFFUTILS_LICENSE=\"${JAVADIFFUTILS_LICENSE}\"         \\\\\n+     JDKHOME=\"${JAVA_HOME}\"                                   \\\\\n+     JUNIT_JAR=\"$(mixed_path \"${JUNIT_JAR}\")\"                 \\\\\n+   \"\\$@\"\n+EOF\n+\n+sh ${BUILD_DIR}\/make.sh ${MAKE_ARGS:-}\n","filename":"make\/build.sh","additions":687,"deletions":0,"binary":false,"changes":687,"status":"added"},{"patch":"@@ -0,0 +1,219 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+ Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+ This code is free software; you can redistribute it and\/or modify it\n+ under the terms of the GNU General Public License version 2 only, as\n+ published by the Free Software Foundation.  Oracle designates this\n+ particular file as subject to the \"Classpath\" exception as provided\n+ by Oracle in the LICENSE file that accompanied this code.\n+\n+ This code is distributed in the hope that it will be useful, but WITHOUT\n+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ version 2 for more details (a copy is included in the LICENSE file that\n+ accompanied this code).\n+\n+ You should have received a copy of the GNU General Public License version\n+ 2 along with this work; if not, write to the Free Software Foundation,\n+ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ or visit www.oracle.com if you need additional information or have any\n+ questions.\n+-->\n+\n+<project name=\"apidiff\" default=\"build\" basedir=\"..\">\n+\n+    <!-- ********** system-specific values ********************************* -->\n+\n+    <property file=\"build.properties\"\/>  <!-- for user overrides -->\n+    <property file=\"make\/build.properties\"\/>\n+\n+    <!-- ********** general useful values ********************************** -->\n+\n+    <property environment=\"env\"\/>\n+\n+    <property name=\"src.bin.dir\" location=\"src\/share\/bin\"\/>\n+    <property name=\"src.classes.dir\" location=\"src\/share\/classes\"\/>\n+    <property name=\"src.test.dir\" location=\"test\"\/>\n+    <property name=\"src.doc.dir\" location=\"src\/share\/doc\"\/>\n+    <property name=\"test.dir\" location=\"test\"\/>\n+    <property name=\"build.dir\" location=\"build\"\/>\n+    <property name=\"build.classes.dir\" location=\"${build.dir}\/classes\" \/>\n+    <property name=\"build.test.classes.dir\" location=\"${build.dir}\/test\/classes\" \/>\n+    <property name=\"deps.dir\" location=\"${build.dir}\/deps\" \/>\n+    <property name=\"dist.dir\" location=\"dist\" \/>\n+    <property name=\"dist.apidiff.dir\" location=\"${dist.dir}\/apidiff\" \/>\n+    <property name=\"dist.apidiff.zip\" location=\"${dist.dir}\/apidiff.zip\" \/>\n+\n+    <!-- The following properties assume that the dependencies have been downloaded into build\/deps. -->\n+    <property name=\"daisydiff.jar\" location=\"${deps.dir}\/daisydiff\/daisydiff-1.2\/daisydiff.jar\"\/>\n+    <property name=\"daisydiff.LICENSE\" location=\"${deps.dir}\/daisydiff\/daisydiff-1.2\/LICENSE.txt\"\/>\n+    <property name=\"java-diff-utils.jar\" location=\"${deps.dir}\/java-diff-utils\/java-diff-utils-4.12.jar\"\/>\n+    <property name=\"java-diff-utils.LICENSE\" location=\"${deps.dir}\/java-diff-utils\/LICENSE\"\/>\n+    <property name=\"junit.jar\" location=\"${deps.dir}\/junit\/junit-platform-console-standalone-1.9.2.jar \"\/>\n+\n+    <!-- ********** top level and shared targets *************************** -->\n+\n+    <target name=\"build\" depends=\"dist-apidiff\"\n+        description=\"default build target: build apidiff for distribution\"\/>\n+\n+    <target name=\"clean\" description=\"remove all generated files\">\n+        <delete dir=\"${build.dir}\"\/>\n+        <delete dir=\"${dist.dir}\"\/>\n+    <\/target>\n+\n+    <!-- ********** init *************************************************** -->\n+\n+    <target name=\"-init\">\n+        <tstamp>\n+            <format property=\"build.date\" pattern=\"MM\/dd\/yyyy\"\/>\n+            <format property=\"build.date.time\" pattern=\"MM\/dd\/yyyy hh:mm aa\"\/>\n+        <\/tstamp>\n+    <\/target>\n+\n+    <!-- ********** apidiff ************************************************** -->\n+\n+    <patternset id=\"apidiff.packages\">\n+        <include name=\"jdk\/codetools\/apidiff\/**\"\/>\n+    <\/patternset>\n+\n+    <target name=\"dist-apidiff\"\n+        depends=\"jar-apidiff,-dist-apidiff.bin,-dist-apidiff.doc,-dist-apidiff.legal,-dist-apidiff.lib\"\n+        description=\"build apidiff for distribution\">\n+        <zip destfile=\"${dist.apidiff.zip}\" filesOnly=\"true\" basedir=\"${dist.dir}\">\n+            <include name=\"apidiff\/\"\/>\n+        <\/zip>\n+    <\/target>\n+\n+    <target name=\"-dist-apidiff.bin\" depends=\"jar-apidiff,-dist-apidiff.doc\">\n+        <copy file=\"${src.bin.dir}\/apidiff.sh\" tofile=\"${dist.apidiff.dir}\/bin\/apidiff\"\/>\n+        <chmod dir=\"${dist.apidiff.dir}\" perm=\"+x\">\n+            <include name=\"bin\/apidiff\"\/>\n+        <\/chmod>\n+    <\/target>\n+\n+    <target name=\"-dist-apidiff.doc\" depends=\"-compile-apidiff.usage\">\n+        <mkdir dir=\"${dist.apidiff.dir}\/doc\/apidiff\"\/>\n+        <copy todir=\"${dist.apidiff.dir}\" file=\"${src.doc.dir}\/README\"\/>\n+        <copy todir=\"${dist.apidiff.dir}\/doc\/apidiff\">\n+            <fileset file=\"${build.dir}\/apidiff\/usage.txt\"\/>\n+        <\/copy>\n+    <\/target>\n+\n+    <target name=\"-dist-apidiff.legal\">\n+        <copy todir=\"${dist.apidiff.dir}\" file=\"COPYRIGHT\"\/>\n+        <copy todir=\"${dist.apidiff.dir}\" file=\"LICENSE\"\/>\n+        <copy todir=\"${dist.apidiff.dir}\/legal\/java-diff-utils\" file=\"${java-diff-utils.LICENSE}\"\/>\n+        <copy todir=\"${dist.apidiff.dir}\/legal\/daisydiff\" file=\"${daisydiff.LICENSE}\"\/>\n+    <\/target>\n+\n+    <target name=\"-dist-apidiff.lib\">\n+        <copy todir=\"${dist.apidiff.dir}\/lib\" file=\"${java-diff-utils.jar}\"\/>\n+        <copy todir=\"${dist.apidiff.dir}\/lib\" file=\"${daisydiff.jar}\"\/>\n+    <\/target>\n+\n+    <target name=\"jar-apidiff\" depends=\"-init,-check-apidiff.jar\" unless=\"apidiff.jar.ok\">\n+        <mkdir dir=\"${dist.apidiff.dir}\/lib\"\/>\n+        <jar destfile=\"${dist.apidiff.dir}\/lib\/apidiff.jar\"\n+            basedir=\"${build.classes.dir}\" >\n+            <manifest>\n+                <attribute name=\"Built-By\" value=\"${user.name}\"\/>\n+                <attribute name=\"Class-Path\" value=\"java-diff-utils-4.0.jar daisydiff.jar\"\/>\n+                <attribute name=\"Main-Class\" value=\"jdk.codetools.apidiff.Main\"\/>\n+                <attribute name=\"apidiff-Name\" value=\"apidiff\"\/>\n+                <attribute name=\"apidiff-Version\" value=\"${build.version}\"\/>\n+                <attribute name=\"apidiff-Milestone\" value=\"${build.milestone}\"\/>\n+                <attribute name=\"apidiff-Build\" value=\"${build.number}\"\/>\n+                <attribute name=\"apidiff-BuildJavaVersion\" value=\"${java.version}\"\/>\n+                <attribute name=\"apidiff-BuildDate\" value=\"${build.date.time}\"\/>\n+            <\/manifest>\n+            <include name=\"COPYRIGHT\"\/>\n+            <include name=\"buildInfo.txt\"\/>\n+            <patternset refid=\"apidiff.packages\"\/>\n+        <\/jar>\n+    <\/target>\n+\n+    <target name=\"-check-apidiff.jar\" depends=\"compile-apidiff\">\n+        <dependset>\n+            <srcfileset dir=\"${build.classes.dir}\">\n+                <patternset refid=\"apidiff.packages\"\/>\n+            <\/srcfileset>\n+            <targetfilelist dir=\"${dist.apidiff.dir}\/lib\" files=\"apidiff.jar\"\/>\n+        <\/dependset>\n+        <available property=\"apidiff.jar.ok\" file=\"${dist.apidiff.dir}\/lib\/apidiff.jar\"\/>\n+    <\/target>\n+\n+    <target name=\"compile-apidiff\" depends=\"-compile-apidiff.classes,-compile-apidiff.resources\"\/>\n+\n+    <target name=\"-compile-apidiff.classes\">\n+        <mkdir dir=\"${build.classes.dir}\"\/>\n+        <javac encoding=\"utf-8\" source=\"17\" target=\"17\"\n+            debug=\"true\" debuglevel=\"source,lines\"\n+            srcdir=\"${src.classes.dir}\"\n+            destdir=\"${build.classes.dir}\"\n+            classpath=\"${build.classes.dir};${java-diff-utils.jar};${daisydiff.jar}\"\n+            includeantruntime=\"false\">\n+            <compilerarg value=\"-Xlint:all\"\/>\n+            <patternset refid=\"apidiff.packages\"\/>\n+        <\/javac>\n+    <\/target>\n+\n+    <target name=\"test\" depends=\"compile-apidiff.tests\">\n+        <junitlauncher haltonfailure=\"true\">\n+            <classpath path=\"${build.test.classes.dir};${build.classes.dir};${java-diff-utils.jar};${daisydiff.jar};${junit.jar}\" \/>\n+            <testclasses outputDir=\"${build.dir}\/test\/report\">\n+                <fileset dir=\"${build.test.classes.dir}\"\/>\n+                <fork>\n+                    <jvmarg line=\"--add-exports jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\"\/>\n+                    <jvmarg line=\"--add-exports jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED\"\/>\n+                    <jvmarg line=\"--add-exports jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED\"\/>\n+                <\/fork>\n+            <\/testclasses>\n+        <\/junitlauncher>\n+    <\/target>\n+\n+    <target name=\"compile-apidiff.tests\" depends=\"compile-apidiff\">\n+        <mkdir dir=\"${build.test.classes.dir}\"\/>\n+        <javac encoding=\"utf-8\" source=\"17\" target=\"17\"\n+            debug=\"true\" debuglevel=\"source,lines\"\n+            srcdir=\"${src.test.dir}\/junit\"\n+            destdir=\"${build.test.classes.dir}\"\n+            classpath=\"${build.classes.dir};${java-diff-utils.jar};${daisydiff.jar};${junit.jar}\"\n+            includeantruntime=\"false\">\n+            <compilerarg value=\"-Xlint:all\"\/>\n+            <compilerarg line=\"--add-modules jdk.compiler,jdk.jdeps\"\/>\n+            <compilerarg line=\"--add-exports jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED\"\/>\n+            <compilerarg line=\"--add-exports jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED\"\/>\n+            <compilerarg line=\"--add-exports jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED\"\/>\n+        <\/javac>\n+    <\/target>\n+\n+    <target name=\"-compile-apidiff.resources\">\n+        <copy todir=\"${build.classes.dir}\" file=\"COPYRIGHT\"\/>\n+        <copy todir=\"${build.classes.dir}\">\n+            <fileset dir=\"${src.classes.dir}\">\n+                <patternset refid=\"apidiff.packages\"\/>\n+                <include name=\"**\/*.properties\"\/>\n+                <include name=\"**\/*.js\"\/>\n+                <exclude name=\"**\/*.java\"\/>\n+            <\/fileset>\n+        <\/copy>\n+    <\/target>\n+\n+    <target name=\"-compile-apidiff.usage\" depends=\"-compile-apidiff.classes\">\n+        <!-- generate the usage page from the command line help -->\n+        <!-- have to set fork=true because otherwise output redirection gets screwed up -->\n+        <mkdir dir=\"${build.dir}\/apidiff\"\/>\n+        <java fork=\"true\" failonerror=\"true\"\n+            classname=\"jdk.codetools.apidiff.Main\"\n+            classpath=\"${build.classes.dir}\"\n+            output=\"${build.dir}\/apidiff\/usage.txt\">\n+            <jvmarg value=\"-Dprogram=apidiff\"\/>\n+            <arg value=\"--help\"\/>\n+        <\/java>\n+    <\/target>\n+\n+<\/project>\n","filename":"make\/build.xml","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+#! \/bin\/sh\n+#\n+# Copyright (c) 2001, 2013, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+classdir=$1; shift\n+cd $classdir\n+\n+if [ \"$#\" -gt 0 ]; then\n+    for i in $* ; do\n+        dir=`echo $i | sed -e 's|\\.|\/|g'`\n+        ls -F $dir | grep -v '\/$' | sed -e 's|\\*$||' -e \"s|\\(.*\\)|-C $classdir $dir\/\\1|\"\n+    done\n+fi\n","filename":"make\/pkgsToFiles.sh","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+#!\/bin\/sh\n+#\n+# Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# Usage:\n+#    apidiff ...args....\n+#       Run the application with the given arguments.\n+#       The Java runtime used to run apidiff is found as follows:\n+#       -   $JAVA_HOME\/bin\/java is used if $JAVA_HOME is set\n+#           (cf JDK.)\n+#       -   Otherwise, \"java\" is used\n+#\n+# apidiff requires a version of Java equivalent to JDK 17 or higher.\n+#\n+# You can also run the jar file directly, as in\n+#   java -jar <path>\/lib\/apidiff.jar ...args...\n+\n+\n+# Deduce where script is installed\n+# - should work on most derivatives of Bourne shell, like ash, bash, ksh,\n+#   sh, zsh, etc, including on Windows, MKS (ksh) and Cygwin (ash or bash)\n+if type -p type 1>\/dev\/null 2>&1 && test -z \"`type -p type`\" ; then\n+    myname=`type -p \"$0\"`\n+elif type type 1>\/dev\/null 2>&1 ; then\n+    myname=`type \"$0\" | sed -e 's\/^.* is a tracked alias for \/\/' -e 's\/^.* is \/\/'`\n+elif whence whence 1>\/dev\/null 2>&1 ; then\n+    myname=`whence \"$0\"`\n+fi\n+mydir=`dirname \"$myname\"`\n+p=`cd \"$mydir\" ; pwd`\n+while [ -n \"$p\" -a \"$p\" != \"\/\" ]; do\n+    if [ -r \"$p\"\/lib\/apidiff.jar ]; then APIDIFF_HOME=\"$p\" ; break; fi\n+    p=`dirname \"$p\"`\n+done\n+if [ -z \"$APIDIFF_HOME\" ]; then\n+    echo \"Cannot determine APIDIFF_HOME\"; exit 1\n+fi\n+\n+# Normalize APIDIFF_HOME if using Cygwin\n+case \"`uname -s`\" in\n+    CYGWIN* ) cygwin=1 ; APIDIFF_HOME=`cygpath -a -m \"$APIDIFF_HOME\"` ;;\n+esac\n+\n+\n+# Separate out -J* options for the JVM=\n+# Unset IFS and use newline as arg separator to preserve spaces in args\n+DUALCASE=1  # for MKS: make case statement case-sensitive (6709498)\n+saveIFS=\"$IFS\"\n+nl='\n+'\n+for i in \"$@\" ; do\n+    IFS=\n+    if [ -n \"$cygwin\" ]; then i=`echo $i | sed -e 's|\/cygdrive\/\\([A-Za-z]\\)\/|\\1:\/|'` ; fi\n+    case $i in\n+    -J* )       javaOpts=$javaOpts$nl`echo $i | sed -e 's\/^-J\/\/'` ;;\n+    *   )       apidiffOpts=$apidiffOpts$nl$i ;;\n+    esac\n+    IFS=\"$saveIFS\"\n+done\n+unset DUALCASE\n+\n+# Determine java for apidiff, from JAVA_HOME, java\n+if [ -n \"$JAVA_HOME\" ]; then\n+    APIDIFF_JAVA=\"$JAVA_HOME\/bin\/java\"\n+else\n+    APIDIFF_JAVA=java\n+fi\n+\n+# Verify java version 17 or newer used to run apidiff\n+version=`\"$APIDIFF_JAVA\" -classpath \"${APIDIFF_HOME}\/lib\/apidiff.jar\" jdk.codetools.apidiff.GetSystemProperty java.version 2>&1 |\n+        grep 'java.version=' | sed -e 's\/^.*=\/\/' -e 's\/^1\\.\/\/' -e 's\/\\([1-9][0-9]*\\).*\/\\1\/'`\n+\n+if [ -z \"$version\" ]; then\n+    echo \"Cannot determine version of java to run apidiff\"\n+    exit 1;\n+elif [ \"$version\" -lt 17 ]; then\n+    echo \"java version 17 or later is required to run apidiff\"\n+    exit 1;\n+fi\n+\n+# And finally ...\n+\n+IFS=$nl\n+\n+\"${APIDIFF_JAVA}\" \\\n+    $javaOpts \\\n+    -Dprogram=`basename \"$0\"` \\\n+    -jar \"${APIDIFF_HOME}\/lib\/apidiff.jar\" \\\n+    $apidiffOpts\n","filename":"src\/share\/bin\/apidiff.sh","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,259 @@\n+#!\/bin\/bash\n+#\n+# Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# Demonstrates how to compare the API docs for different builds or versions of JDK.\n+#\n+# The script has three parts or phases:\n+# 1. Determine which versions to compare\n+# 2. Build the docs for those versions\n+# 3. Compare the generated docs\n+\n+DEFAULT_LATEST_JDK=\n+DEFAULT_APIDIFF=\n+DEFAULT_REPO=.\n+DEFAULT_OUTDIR=build\n+\n+# Helper used to ensure the correct number of arguments is passed to bash functions\n+check_arguments() {\n+    local name=\"$1\"\n+    local expected=\"$2\"\n+    local actual=\"$3\"\n+\n+    if [ ! \"${expected}\" = \"${actual}\" ]; then\n+        echo \"Incorrect number of arguments to function '${name}' (expecting ${expected} but got ${actual})\" 2>&1\n+        exit 1\n+    fi\n+}\n+\n+ensure_arg() {\n+    check_arguments \"${FUNCNAME}\" 2 $#\n+    local option=\"$1\"\n+    local arg_count=\"$2\"\n+    if [ \"$arg_count\" -lt \"2\" ]; then\n+        echo \"The $option option requires an argument\" 2>&1\n+        exit\n+    fi\n+}\n+\n+process_args() {\n+    while [ \"$#\" -gt 0 ]; do\n+        case \"$1\" in\n+            --help|-h )             HELP=1 ;                                    shift ;;\n+            --apidiff )             ensure_arg \"$1\" $# ; APIDIFF=\"$2\" ;         shift ; shift ;;\n+            --jdk )                 ensure_arg \"$1\" $# ; LATEST_JDK=\"$2\" ;      shift ; shift ;;\n+            --output )              ensure_arg \"$1\" $# ; OUTDIR=\"$2\" ;          shift ; shift ;;\n+            --repo )                ensure_arg \"$1\" $# ; REPO=\"$2\" ;            shift ; shift ;;\n+            --latest-ga | --previous | --latest | jdk-* )\n+                                    versions=\"${versions} $1\" ;                 shift ;;\n+            * )                     echo \"unknown option: '$1'\" 1>&2;          exit 1 ;;\n+        esac\n+    done\n+}\n+\n+usage() {\n+    echo \"Usage: $0 <options> <versions>\"\n+    echo \"--help\"\n+    echo \"      Show this message.\"\n+    echo \"--apidiff <dir>\"\n+    echo \"      Specify location of apidiff.\"\n+    echo \"--jdk <dir>\"\n+    echo \"      Specify location of JDK used to run comparison tools.\"\n+    echo \"--repo <dir>\"\n+    echo \"      Specify location of repository in which to build docs.\"\n+    echo \"      Default: ${DEFAULT_REPO}\"\n+    echo \"--output <dir>\"\n+    echo \"      Specify directory for comparison reports.\"\n+    echo \"      Default: <repo>\/${DEFAULT_OUTDIR}\"\n+    echo \"<versions>\"\n+    echo \"      0, 1, 2 or 3 of --latest-ga, --previous, --latest, jdk-*\"\n+    echo \"      where jdk-* is a git tag for the repo.\"\n+    echo \"      Default if none specified:     --latest-ga --latest\"\n+    echo \"      Default if just one specified:  <version>  --latest\"\n+}\n+\n+process_args \"$@\"\n+\n+if [ -n \"${HELP:-}\" ]; then\n+    usage\n+    exit\n+fi\n+\n+if [ -f ~\/.config\/apidiff\/apidiff.conf ]; then\n+    source ~\/.config\/apidiff\/apidiff.conf\n+fi\n+\n+LATEST_JDK=${LATEST_JDK:-${DEFAULT_LATEST_JDK}}\n+APIDIFF=${APIDIFF:-${DEFAULT_APIDIFF}}\n+REPO=${REPO:-${DEFAULT_REPO}}\n+OUTDIR=${OUTDIR:-${REPO}\/${DEFAULT_OUTDIR}}\n+\n+# Sanity check args\n+\n+if [ -z \"${APIDIFF}\" ]; then\n+    echo \"no path specified for apidiff\" 1>&2 ; exit 1\n+elif [ ! -r ${APIDIFF}\/lib\/apidiff.jar ]; then\n+    echo \"invalid path for apidiff\" 1>&2 ; exit 1\n+fi\n+\n+if [ -z \"${LATEST_JDK}\" ]; then\n+    echo \"no path specified for latest JDK\" 1>&2 ; exit 1\n+elif [ ! -r ${LATEST_JDK}\/bin\/java ]; then\n+    echo \"invalid path for latest JDK: ${LATEST_JDK}\" 1>&2 ; exit 1\n+fi\n+\n+if [ ! -d ${REPO}\/.git ]; then\n+    echo \"invalid path for repo: ${REPO}\" 1>&2 ; exit 1\n+fi\n+\n+# use echo in next line to trim excess whitespace from wc output\n+case $(echo $(wc -w <<< \"${versions}\")) in\n+    0 )   versions=\"--latest-ga --latest\" ;;\n+    1 )   versions=\"${versions} --latest\" ;;\n+    2 | 3 )   ;;\n+    * )   echo \"unexpected number of versions given: ${versions}\" 1>&2 ; exit 1 ;;\n+esac\n+\n+# Determine whether running in a closed+open pair, or just an open repo.\n+if [ -d ${REPO}\/open ]; then\n+    OPEN=open\n+else\n+    OPEN=.\n+fi\n+\n+# Phase 1: determine which versions to build and compare,\n+#          identified by the corresponding `git` tags.\n+# The versions (and hence tags) are determined automatically, from\n+# version-numbers.conf and the output of `git tag`.\n+# The following tags are determined:\n+#   PREVIOUS_GA_TAG, PREVIOUS_TAG, LATEST_TAG\n+\n+# ensure the files in the work area are up to date before reading\n+# version-numbers.conf; it is assumed that the `master` branch\n+# always has the latest version numbers\n+git -C ${REPO}\/${OPEN} checkout master\n+source ${REPO}\/${OPEN}\/make\/conf\/version-numbers.conf\n+VERSION_FEATURE=${VERSION_FEATURE:-${DEFAULT_VERSION_FEATURE}}\n+\n+TAGS=( $(git -C ${REPO} tag --list \"jdk-${VERSION_FEATURE}*\" | sort --version-sort --reverse) )\n+LATEST_TAG=${TAGS[0]}\n+PREVIOUS_TAG=${TAGS[1]}\n+\n+PREVIOUS_FEATURE=$(( ${VERSION_FEATURE} - 1))\n+LATEST_GA_TAG=\"jdk-${PREVIOUS_FEATURE}-ga\"\n+\n+tag() {\n+    case \"$1\" in\n+        --latest-ga ) echo ${LATEST_GA_TAG} ;;\n+        --previous )  echo ${PREVIOUS_TAG} ;;\n+        --latest )    echo ${LATEST_TAG} ;;\n+        jdk-* )       echo $1 ;;\n+        * ) echo \"bad tag: $1\" 1>&2 ; exit 1 ;;\n+    esac\n+}\n+\n+check_tag() {\n+    local tag=\"$1\"\n+    if ! git -C \"$REPO\" rev-parse \"$tag\" > \/dev\/null 2>&1 ; then\n+        echo tag \"$tag\" not found in repo \"$REPO\"\n+        exit 1\n+    fi\n+    if [ \"${OPEN}\" = \"open\" ]; then\n+        if ! git -C \"$REPO\"\/$OPEN rev-parse \"$tag\" > \/dev\/null 2>&1 ; then\n+            echo tag \"$tag\" not found in repo \"$OPEN\"\/$OPEN\n+            exit 1\n+        fi\n+    fi\n+}\n+\n+# Phase 2: build the docs to be compared\n+# $1 is the tag for the version to checkout and build.\n+# It should be one of `--latest-ga`, `--previous`, `--latest` or an actual `jdk-*` tag.\n+# The build is skipped if `images\/jdk` and `images\/docs-reference` both exist.\n+#\n+# Configure and use the `docs-reference` target with the $LATEST_JDK.\n+# The same version of JDK should be used for all versions to be compared.\n+# `apidiff` also requires a JDK image for the comparison.\n+#\n+# Note: building the JDK image and docs for each version to be compared\n+# may take a while.\n+\n+configure_jdk() {\n+    if [ -n \"${APIDIFF_CONFIGURE_JDK}\" ]; then\n+        \"${APIDIFF_CONFIGURE_JDK}\" \"$@\" ;\n+    elif [ -r jib.sh -a -r closed\/bin\/jib.sh ]; then\n+        sh jib.sh configure -- \"$@\"\n+    elif [ -r bin\/jib.sh -a -r ..\/closed\/make\/conf\/jib-install.conf ]; then\n+        sh bin\/jib.sh configure -- \"$@\"\n+    elif [ -r bin\/jib.sh -a -n \"${JIB_SERVER}\" ]; then\n+        sh bin\/jib.sh configure -- \"$@\"\n+    else\n+        sh .\/configure \"$@\"\n+    fi\n+}\n+\n+build_reference_docs() {\n+    TAG=$(tag $1)\n+    if [ -d ${REPO}\/build\/${TAG}\/images\/jdk -a -d ${REPO}\/build\/${TAG}\/images\/docs-reference ]; then\n+        echo \"Skipping build for ${TAG}\"\n+        return\n+    fi\n+\n+    git -C ${REPO} checkout --detach ${TAG}\n+    if [ \"${OPEN}\" = \"open\" ]; then\n+        git -C ${REPO}\/open checkout --detach ${TAG}\n+    fi\n+\n+    (   cd $REPO\n+        configure_jdk \\\n+            --with-conf-name=${TAG} \\\n+            --enable-full-docs \\\n+            --with-docs-reference-jdk=${LATEST_JDK} \\\n+            --quiet\n+        make CONF_NAME=${TAG} jdk-image docs-reference\n+    )\n+}\n+\n+# Phase 3: Compare the documentation and generate reports.\n+\n+apidiff_javase() {\n+    for t in \"$@\" ; do tags=\"$tags $(tag $t)\" ; done\n+    for t in $tags ; do check_tag $t ; done\n+    for t in $tags ; do build_reference_docs $t ; done\n+    title=\"Comparing Java SE modules for $(echo $tags | sed -e 's\/ \/, \/g' -e 's\/\\(.*\\),\\(.*\\)\/\\1 and\\2\/')\"\n+    outdir=\"${OUTDIR}\/apidiff\/javase--$(echo $tags | sed -e 's\/ \/--\/g')\"\n+    echo \"${title}\"\n+    JAVA_HOME=${LATEST_JDK} ${APIDIFF}\/bin\/apidiff \\\n+        $(for t in $tags ; do echo \"--api $t --jdk-build ${REPO}\/build\/$t\" ; done) \\\n+        --include java.*\/java.** --include java.*\/javax.** \\\n+        --exclude java.smartcardio\/ \\\n+        --jdk-docs docs-reference \\\n+        --output-directory ${outdir} \\\n+        --title \"${title}\" \\\n+        \"${EXTRA_APIDIFF_OPTIONS[@]}\"\n+    echo \"Results written to ${outdir}\"\n+}\n+\n+apidiff_javase ${versions}\n","filename":"src\/share\/bin\/compare-jdk-versions.sh","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+jdk.codetools.apidiff.APIDiff\n","filename":"src\/share\/classes\/META-INF\/services\/java.util.spi.ToolProvider","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff;\n+\n+import java.io.PrintWriter;\n+import java.util.spi.ToolProvider;\n+\n+\/**\n+ * An entry point for the \"apidiff\" utility that implements {@link ToolProvider}.\n+ *\/\n+public class APIDiff implements ToolProvider {\n+    @Override\n+    public String name() {\n+        return \"apidiff\";\n+    }\n+\n+    @Override\n+    public int run(PrintWriter out, PrintWriter err, String... args) {\n+        return new Main(out, err).run(args).exitCode;\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/APIDiff.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff;\n+\n+\/**\n+ * An exception to indicate that processing has been aborted.\n+ *\/\n+public class Abort extends Error {\n+    private static final long serialVersionUID = 0;\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/Abort.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,333 @@\n+\/*\n+ * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+\/**\n+ * Utility methods for processing command line arguments.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public class CommandLine {\n+    \/**\n+     * Process Win32-style command files for the specified command line\n+     * arguments and return the resulting arguments. A command file argument\n+     * is of the form '@file' where 'file' is the name of the file whose\n+     * contents are to be parsed for additional arguments. The contents of\n+     * the command file are parsed using StreamTokenizer and the original\n+     * '@file' argument replaced with the resulting tokens. Recursive command\n+     * files are not supported. The '@' character itself can be quoted with\n+     * the sequence '@@'.\n+     * @param args the arguments that may contain @files\n+     * @return the arguments, with @files expanded\n+     * @throws IOException if there is a problem reading any of the @files\n+     *\/\n+    public static String[] parse(String[] args) throws IOException {\n+        List<String> newArgs = new ArrayList<>();\n+        appendParsedCommandArgs(newArgs, Arrays.asList(args));\n+        return newArgs.toArray(new String[newArgs.size()]);\n+    }\n+\n+    \/**\n+     * Process Win32-style command files for the specified command line\n+     * arguments and return the resulting arguments. A command file argument\n+     * is of the form '@file' where 'file' is the name of the file whose\n+     * contents are to be parsed for additional arguments. The contents of\n+     * the command file are parsed using StreamTokenizer and the original\n+     * '@file' argument replaced with the resulting tokens. Recursive command\n+     * files are not supported. The '@' character itself can be quoted with\n+     * the sequence '@@'.\n+     * @param args the arguments that may contain @files\n+     * @return the arguments, with @files expanded\n+     * @throws IOException if there is a problem reading any of the @files\n+     *\/\n+    public static List<String> parse(List<String> args) throws IOException {\n+        List<String> newArgs = new ArrayList<>();\n+        appendParsedCommandArgs(newArgs, args);\n+        return Collections.unmodifiableList(newArgs);\n+    }\n+\n+    private static void appendParsedCommandArgs(List<String> newArgs, List<String> args) throws IOException {\n+        for (String arg : args) {\n+            if (arg.length() > 1 && arg.charAt(0) == '@') {\n+                arg = arg.substring(1);\n+                if (arg.charAt(0) == '@') {\n+                    newArgs.add(arg);\n+                } else {\n+                    loadCmdFile(arg, newArgs);\n+                }\n+            } else {\n+                newArgs.add(arg);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Process the given environment variable and appends any Win32-style\n+     * command files for the specified command line arguments and return\n+     * the resulting arguments. A command file argument\n+     * is of the form '@file' where 'file' is the name of the file whose\n+     * contents are to be parsed for additional arguments. The contents of\n+     * the command file are parsed using StreamTokenizer and the original\n+     * '@file' argument replaced with the resulting tokens. Recursive command\n+     * files are not supported. The '@' character itself can be quoted with\n+     * the sequence '@@'.\n+     * @param envVariable the env variable to process\n+     * @param args the arguments that may contain @files\n+     * @return the arguments, with environment variable's content and expansion of @files\n+     * @throws IOException if there is a problem reading any of the @files\n+     * @throws CommandLine.UnmatchedQuote if an unmatched quote is found\n+     *\/\n+    public static List<String> parse(String envVariable, List<String> args)\n+            throws IOException, UnmatchedQuote {\n+\n+        List<String> inArgs = new ArrayList<>();\n+        appendParsedEnvVariables(inArgs, envVariable);\n+        inArgs.addAll(args);\n+        List<String> newArgs = new ArrayList<>();\n+        appendParsedCommandArgs(newArgs, inArgs);\n+        return newArgs;\n+    }\n+\n+    \/**\n+     * Process the given environment variable and appends any Win32-style\n+     * command files for the specified command line arguments and return\n+     * the resulting arguments. A command file argument\n+     * is of the form '@file' where 'file' is the name of the file whose\n+     * contents are to be parsed for additional arguments. The contents of\n+     * the command file are parsed using StreamTokenizer and the original\n+     * '@file' argument replaced with the resulting tokens. Recursive command\n+     * files are not supported. The '@' character itself can be quoted with\n+     * the sequence '@@'.\n+     * @param envVariable the env variable to process\n+     * @param args the arguments that may contain @files\n+     * @return the arguments, with environment variable's content and expansion of @files\n+     * @throws IOException if there is a problem reading any of the @files\n+     * @throws CommandLine.UnmatchedQuote if an unmatched quote is found\n+     *\/\n+    public static String[] parse(String envVariable, String[] args) throws IOException, UnmatchedQuote {\n+        List<String> out = parse(envVariable, Arrays.asList(args));\n+        return out.toArray(new String[out.size()]);\n+    }\n+\n+    private static void loadCmdFile(String name, List<String> args) throws IOException {\n+        try (Reader r = Files.newBufferedReader(Paths.get(name), Charset.defaultCharset())) {\n+            Tokenizer t = new Tokenizer(r);\n+            String s;\n+            while ((s = t.nextToken()) != null) {\n+                args.add(s);\n+            }\n+        }\n+    }\n+\n+    private static class Tokenizer {\n+        private final Reader in;\n+        private int ch;\n+\n+        public Tokenizer(Reader in) throws IOException {\n+            this.in = in;\n+            ch = in.read();\n+        }\n+\n+        public String nextToken() throws IOException {\n+            skipWhite();\n+            if (ch == -1) {\n+                return null;\n+            }\n+\n+            StringBuilder sb = new StringBuilder();\n+            char quoteChar = 0;\n+\n+            while (ch != -1) {\n+                switch (ch) {\n+                    case ' ':\n+                    case '\\t':\n+                    case '\\f':\n+                        if (quoteChar == 0) {\n+                            return sb.toString();\n+                        }\n+                        sb.append((char) ch);\n+                        break;\n+\n+                    case '\\n':\n+                    case '\\r':\n+                        return sb.toString();\n+\n+                    case '\\'':\n+                    case '\"':\n+                        if (quoteChar == 0) {\n+                            quoteChar = (char) ch;\n+                        } else if (quoteChar == ch) {\n+                            quoteChar = 0;\n+                        } else {\n+                            sb.append((char) ch);\n+                        }\n+                        break;\n+\n+                    case '\\\\':\n+                        if (quoteChar != 0) {\n+                            ch = in.read();\n+                            switch (ch) {\n+                                case '\\n', '\\r' -> {\n+                                    while (ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t' || ch == '\\f') {\n+                                        ch = in.read();\n+                                    }\n+                                    continue;\n+                                }\n+                                case 'n' -> ch = '\\n';\n+                                case 'r' -> ch = '\\r';\n+                                case 't' -> ch = '\\t';\n+                                case 'f' -> ch = '\\f';\n+                            }\n+                        }\n+                        sb.append((char) ch);\n+                        break;\n+\n+                    default:\n+                        sb.append((char) ch);\n+                }\n+\n+                ch = in.read();\n+            }\n+\n+            return sb.toString();\n+        }\n+\n+        void skipWhite() throws IOException {\n+            while (ch != -1) {\n+                switch (ch) {\n+                    case ' ':\n+                    case '\\t':\n+                    case '\\n':\n+                    case '\\r':\n+                    case '\\f':\n+                        break;\n+\n+                    case '#':\n+                        ch = in.read();\n+                        while (ch != '\\n' && ch != '\\r' && ch != -1) {\n+                            ch = in.read();\n+                        }\n+                        break;\n+\n+                    default:\n+                        return;\n+                }\n+\n+                ch = in.read();\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    private static void appendParsedEnvVariables(List<String> newArgs, String envVariable)\n+            throws UnmatchedQuote {\n+\n+        if (envVariable == null) {\n+            return;\n+        }\n+        String in = System.getenv(envVariable);\n+        if (in == null || in.trim().isEmpty()) {\n+            return;\n+        }\n+\n+        final char NUL = (char)0;\n+        final int len = in.length();\n+\n+        int pos = 0;\n+        StringBuilder sb = new StringBuilder();\n+        char quote = NUL;\n+        char ch;\n+\n+        loop:\n+        while (pos < len) {\n+            ch = in.charAt(pos);\n+            switch (ch) {\n+                case '\\\"': case '\\'':\n+                    if (quote == NUL) {\n+                        quote = ch;\n+                    } else if (quote == ch) {\n+                        quote = NUL;\n+                    } else {\n+                        sb.append(ch);\n+                    }\n+                    pos++;\n+                    break;\n+                case '\\f': case '\\n': case '\\r': case '\\t': case ' ':\n+                    if (quote == NUL) {\n+                        newArgs.add(sb.toString());\n+                        sb.setLength(0);\n+                        while (ch == '\\f' || ch == '\\n' || ch == '\\r' || ch == '\\t' || ch == ' ') {\n+                            pos++;\n+                            if (pos >= len) {\n+                                break loop;\n+                            }\n+                            ch = in.charAt(pos);\n+                        }\n+                        break;\n+                    }\n+                    \/\/ fall through\n+                default:\n+                    sb.append(ch);\n+                    pos++;\n+            }\n+        }\n+        if (sb.length() != 0) {\n+            newArgs.add(sb.toString());\n+        }\n+        if (quote != NUL) {\n+            throw new UnmatchedQuote(envVariable);\n+        }\n+    }\n+\n+    \/**\n+     * Thrown when an unmatched quote is found when expanding an eneviornment variable.\n+     *\/\n+    public static class UnmatchedQuote extends Exception {\n+        private static final long serialVersionUID = 0;\n+\n+        \/**\n+         * The name of the environment variable.\n+         *\/\n+        public final String variableName;\n+\n+        UnmatchedQuote(String variable) {\n+            this.variableName = variable;\n+        }\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/CommandLine.java","additions":333,"deletions":0,"binary":false,"changes":333,"status":"added"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/\/ See JDK: jdk.compiler\/com.sun.tools.javac.util.StringUtils.DamerauLevenshteinDistance\n+\n+\/**Call {@link #of(String, String)} to calculate the distance.\n+ *\n+ * <h2>Usage Examples<\/h2>\n+ *\n+ * Pick top three vocabulary words whose normalized distance from\n+ * the misspelled word is no greater than one-third.\n+ *\n+ * {@snippet :\n+ *     record Pair(String word, int distance) { }\n+ *\n+ *     var suggestions = vocabulary.stream()\n+ *             .map(v -> new Pair(v, DamerauLevenshteinDistance.of(v, misspelledWord)))\n+ *             .filter(p -> Double.compare(1.0 \/ 3, ((double) p.distance()) \/ p.word().length()) >= 0)\n+ *             .sorted(Comparator.comparingDouble(Pair::distance))\n+ *             .limit(3)\n+ *             .toList();\n+ * }\n+ *\/\n+class DamerauLevenshteinDistance {\n+\n+    \/*\n+     * This is a Java implementation of the algorithm from \"An Extension of\n+     * the String-to-String Correction Problem\" by R. Lowrance and\n+     * R. A. Wagner (https:\/\/dl.acm.org\/doi\/10.1145\/321879.321880).\n+     * That algorithm is O(|a|*|b|) in both space and time.\n+     *\n+     * This implementation encapsulates arrays and (most of) strings behind\n+     * methods to accommodate for algorithm indexing schemes which are -1,\n+     * 0, and 1 based and to offset memory and performance overhead if any\n+     * strings in the pair contain non-ASCII symbols.\n+     *\/\n+\n+    private final int INF;\n+    private final int[][] h;\n+    private final String a;\n+    private final String b;\n+\n+    private static final int Wi = 1; \/\/ insert\n+    private static final int Wd = 1; \/\/ delete\n+    private static final int Wc = 1; \/\/ change\n+    private static final int Ws = 1; \/\/ interchange\n+\n+    static {\n+        assert 2L * Ws >= Wi + Wd; \/\/ algorithm requirement\n+    }\n+\n+    private int[] smallDA;\n+    private Map<Character, Integer> bigDA;\n+\n+    \/** {@return the edit distance between two strings}\n+     * The distance returned from this method has the following properties:\n+     * <ol>\n+     *     <li> {@code a.equals(b) && of(a, b) == 0) || (!a.equals(b) && of(a, b) > 0)}\n+     *     <li> {@code of(a, b) == of(b, a)}\n+     *     <li> {@code of(a, b) + of(b, c) >= of(a, c)}\n+     * <\/ol>\n+     *\n+     * @implSpec\n+     * This method is safe to be called by multiple threads.\n+     * @throws NullPointerException if any of the two strings are null\n+     * @throws ArithmeticException if any step of the calculation\n+     *                             overflows an int\n+     *\/\n+    public static int of(String a, String b) {\n+        return new DamerauLevenshteinDistance(a, b).calculate();\n+    }\n+\n+    private int calculate() {\n+        for (int i = 0; i <= a.length(); i++) {\n+            h(i, 0, i * Wd);\n+            h(i, -1, INF);\n+        }\n+        for (int j = 0; j <= b.length(); j++) {\n+            h(0, j, j * Wi);\n+            h(-1, j, INF);\n+        }\n+        \/\/ algorithm's line #8 that initializes DA is not needed here\n+        \/\/ because this class encapsulates DA and initializes it\n+        \/\/ separately\n+        for (int i = 1; i <= a.length(); i++) {\n+            int db = 0;\n+            for (int j = 1; j <= b.length(); j++) {\n+                int i1 = da(characterAt(b, j));\n+                int j1 = db;\n+                boolean eq = characterAt(a, i) == characterAt(b, j);\n+                int d = eq ? 0 : Wc;\n+                if (eq) {\n+                    db = j;\n+                }\n+                int m = min(h(i - 1, j - 1) + d,\n+                        h(i, j - 1) + Wi,\n+                        h(i - 1, j) + Wd,\n+                        h(i1 - 1, j1 - 1) + (i - i1 - 1) * Wd + Ws + (j - j1 - 1) * Wi);\n+                h(i, j, m);\n+            }\n+            da(characterAt(a, i), i);\n+        }\n+        return h(a.length(), b.length());\n+    }\n+\n+    private int characterAt(String s, int i) {\n+        return s.charAt(i - 1);\n+    }\n+\n+    private void h(int i, int j, int value) {\n+        h[i + 1][j + 1] = value;\n+    }\n+\n+    private int h(int i, int j) {\n+        return h[i + 1][j + 1];\n+    }\n+\n+    \/*\n+     * This implementation works with UTF-16 strings, but favours strings\n+     * that comprise ASCII characters. Measuring distance between a pair\n+     * of ASCII strings is likely to be a typical use case for this\n+     * implementation.\n+     *\n+     * If a character for which the value is to be stored does not fit into\n+     * the ASCII range, this implementation switches to a different storage\n+     * dynamically. Since neither string lengths nor character values\n+     * change, any state accumulated so far, including any loops and local\n+     * variables, remains valid.\n+     *\n+     * Note, that if the provided character were a surrogate and this\n+     * implementation dealt with code points, which it does not, dynamic\n+     * switching of the storage would not be enough. The complete\n+     * representation would need to be changed. That would entail\n+     * discarding any accumulated state and repeating the computation.\n+     *\/\n+\n+    private int da(int i) {\n+        if (smallDA != null && i < '\\u0080') {\n+            return smallDA[i];\n+        }\n+        \/\/ if a character cannot be found, it means that the character\n+        \/\/ hasn't been updated, which means that the associated value\n+        \/\/ is the default value, which is 0\n+        if (bigDA != null) {\n+            Integer v = bigDA.get((char) i);\n+            return v == null ? 0 : v;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    private void da(int i, int value) {\n+        if (bigDA == null && i < '\\u0080') {\n+            if (smallDA == null) {\n+                smallDA = new int[127];\n+            }\n+            smallDA[i] = value;\n+        } else {\n+            if (bigDA == null) {\n+                bigDA = new HashMap<>();\n+                if (smallDA != null) { \/\/ rebuild DA accumulated so far\n+                    for (int j = 0; j < smallDA.length; j++) {\n+                        int v = smallDA[j];\n+                        if (v != 0)\n+                            bigDA.put((char) j, v);\n+                    }\n+                    smallDA = null; \/\/ no longer needed\n+                }\n+            }\n+            bigDA.put((char) i, value);\n+        }\n+        assert smallDA == null ^ bigDA == null; \/\/ at most one in use\n+    }\n+\n+    private static int min(int a, int b, int c, int d) {\n+        return Math.min(a, Math.min(b, Math.min(c, d)));\n+    }\n+\n+    private DamerauLevenshteinDistance(String a, String b) {\n+        this.a = a;\n+        this.b = b;\n+        this.h = new int[this.a.length() + 2][this.b.length() + 2];\n+        INF = this.a.length() * Wd + this.b.length() * Wi + 1;\n+        if (INF < 0)\n+            throw new ArithmeticException(\"Overflow\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/DamerauLevenshteinDistance.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff;\n+\n+import java.io.IOException;\n+\n+\/**\n+ * A standalone utility to get one or more system properties.\n+ * The command line arguments should either be {@code -all}\n+ * or a series of system property names.\n+ *\/\n+public class GetSystemProperty\n+{\n+    \/**\n+     * The main program.\n+     * @param args a series of property names, or {@code -all}.\n+     *\/\n+    public static void main(String[] args) {\n+        if (args.length == 1 && args[0].equals(\"-all\")) {\n+            try {\n+                System.getProperties().store(System.out, \"system properties\");\n+            } catch (IOException e) {\n+                System.err.println(e);\n+                System.exit(1);\n+            }\n+        } else {\n+            for (String arg : args) {\n+                String v = System.getProperty(arg);\n+                System.out.println(arg + \"=\" + (v == null ? \"\" : v));\n+            }\n+        }\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/GetSystemProperty.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2020,2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.DirectoryIteratorException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import jdk.codetools.apidiff.model.Selector;\n+\n+\/**\n+ * A class to encapsulate the functionality of the {@code --jdk-build} option,\n+ * which provides a shorthand for the underlying primitive options when doing\n+ * a \"standard\" comparison involving JDK builds.\n+ *\/\n+public class JDKBuildOption {\n+    private final Path buildDir;\n+    private final Path imagesDir;\n+\n+    JDKBuildOption(Path dir) {\n+        this.buildDir = dir;\n+        this.imagesDir = dir.resolve(\"images\");\n+    }\n+\n+    void expand(Options options, Options.APIOptions apiOptions, Log log) {\n+        apiOptions.addFileManagerOpt(\"--system\", getSystem().toString());\n+\n+        \/\/ proactively get api dir if available, in case we want to subsequently\n+        \/\/ set compareAPIDescriptions by default\n+        apiOptions.apiDir = getAPIDirectory(options, log);\n+\n+        if (options.compareDocComments == Boolean.TRUE) {\n+            Set<String> modules = new LinkedHashSet<>();\n+            Path tmpDir = unpackSource(options, log, modules);\n+            for (String m : modules) {\n+                apiOptions.addFileManagerOpt(\"--patch-module\",\n+                        m + \"=\" + tmpDir.resolve(m));\n+            }\n+            \/\/ since we're also setting the --system option,\n+            \/\/ just set the --source option here\n+            apiOptions.source = getRelease(log);\n+        }\n+    }\n+\n+    private Path getSystem() {\n+        return imagesDir.resolve(\"jdk\");\n+    }\n+\n+    private Path getAPIDirectory(Options options, Log log) {\n+        Map<String, Path> dirs = new HashMap<>();\n+        try (DirectoryStream<Path> stream = Files.newDirectoryStream(imagesDir,\n+                p -> Files.isDirectory(p) && p.getFileName().toString().contains(\"docs\"))) {\n+            for (Path entry: stream) {\n+                dirs.put(entry.getFileName().toString(), entry);\n+            }\n+        } catch (DirectoryIteratorException e) {\n+            \/\/ I\/O error encountered during the iteration; the cause is an IOException\n+            softError(log, options, \"jdkbuild.ioerror-finding-docs\", e.getCause());\n+            return null;\n+        } catch (IOException e) {\n+            softError(log, options, \"jdkbuild.ioerror-finding-docs\", e);\n+            return null;\n+        }\n+        Path docsDir;\n+        if (dirs.isEmpty()) {\n+            softError(log, options, \"jdkbuild.err.no-docs\", imagesDir);\n+            return null;\n+        } else if (options.jdkDocs == null) {\n+            if (dirs.size() > 1) {\n+                softError(log, options, \"jdkbuild.err.multiple-docs\",\n+                        imagesDir,\n+                        String.join(\", \", dirs.keySet()));\n+                return null;\n+            } else {\n+                docsDir = dirs.values().iterator().next();\n+            }\n+        } else {\n+            Path dir = dirs.get(options.jdkDocs);\n+            if (dir == null) {\n+                softError(log, options, \"jdkbuild.err.cannot-find-docs\", options.jdkDocs, imagesDir);\n+                return null;\n+            }\n+            docsDir = dir;\n+        }\n+        return docsDir.resolve(\"api\");\n+    }\n+\n+    \/**\n+     * Reports a hard error if comparison of API descriptions has been explicitly requested.\n+     * Otherwise, does nothing.\n+     *\n+     * @param log     the log\n+     * @param options the options\n+     * @param key     the resource key\n+     * @param args    the arguments\n+     *\/\n+    void softError(Log log, Options options, String key, Object... args) {\n+        if (options.compareApiDescriptions == Boolean.TRUE) {\n+            log.error(key, args);\n+        }\n+    }\n+\n+    private String getRelease(Log log) {\n+        Map<String, String> map = getReleaseInfo(log);\n+        return map.get(\"JAVA_VERSION\");\n+    }\n+\n+    private Map<String, String> getReleaseInfo(Log log) {\n+        Map<String, String> map = new LinkedHashMap<>();\n+        Pattern p = Pattern.compile(\"(?<name>[A-Z0-9_]+)=\\\"(?<value>.*)\\\"$\");\n+        Path releaseFile = getSystem().resolve(\"release\");\n+        try {\n+            for (String line : Files.readAllLines(releaseFile)) {\n+                Matcher m = p.matcher(line);\n+                if (m.matches()) {\n+                    map.put(m.group(\"name\"), m.group(\"value\"));\n+                }\n+            }\n+        } catch (IOException e) {\n+            log.error(\"jdkbuild.err.error-reading-release-file\", releaseFile, e);\n+        }\n+        return map;\n+    }\n+\n+    private Path unpackSource(Options options, Log log, Set<String> modules) {\n+        Selector s = new Selector(options.includes, options.excludes);\n+\n+        Path tmpSrcDir = buildDir.resolve(\"apidiff.tmp\").resolve(\"src\");\n+        Path srcZip = buildDir.resolve(\"support\").resolve(\"src.zip\");\n+        try (ZipFile zf = new ZipFile(srcZip.toFile())) {\n+            Enumeration<? extends ZipEntry> e = zf.entries();\n+            while (e.hasMoreElements()) {\n+                ZipEntry ze = e.nextElement();\n+                String name = ze.getName();\n+                if (!name.endsWith(\".java\")) {\n+                    continue;\n+                }\n+                if (name.startsWith(\"\/\")) {\n+                    name = name.substring(1);\n+                }\n+                int firstSep = name.indexOf(\"\/\"); \/\/ after module name\n+                int lastSep = name.lastIndexOf(\"\/\"); \/\/ before type name\n+                if (lastSep > firstSep) { \/\/ ensures two or more instances\n+                    String m = name.substring(0, firstSep);\n+                    String p = name.substring(firstSep + 1, lastSep).replace(\"\/\", \".\");\n+                    String t = name.substring(lastSep + 1).replace(\".java\", \"\");\n+                    if (s.acceptsType(m, p, t)) {\n+                        try (InputStream in = zf.getInputStream(ze)) {\n+                            Path outFile = tmpSrcDir.resolve(name.replace(\"\/\", File.separator));\n+                            Files.createDirectories(outFile.getParent());\n+                            Files.copy(in, outFile, StandardCopyOption.REPLACE_EXISTING);\n+                        }\n+                        modules.add(m);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            log.error(\"jdkbuild.err.error-reading-src.zip\", srcZip, e);\n+\n+        }\n+        return tmpSrcDir;\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/JDKBuildOption.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2018,2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff;\n+\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+\/**\n+ * Utilities to write logging messages.\n+ *\/\n+public class Log {\n+    \/**\n+     * An output stream for \"expected\" output.\n+     *\/\n+    public final PrintWriter out;\n+\n+    \/**\n+     * An output stream for \"diagnostic\" output.\n+     *\/\n+    public final PrintWriter err;\n+\n+    \/**\n+     * The messages used by this log.\n+     *\/\n+    private final Messages messages = Messages.instance( \"jdk.codetools.apidiff.resources.log\");\n+\n+    private String errPrefix = messages.getString(\"log.err-prefix\");\n+    private String warnPrefix = messages.getString(\"log.warn-prefix\");\n+    private String notePrefix = messages.getString(\"log.note-prefix\");\n+\n+    private int errCount = 0;\n+    private int warnCount = 0;\n+\n+    \/**\n+     * Creates an instance of a log.\n+     *\n+     * @param out the stream to which to write normal output\n+     * @param err the stream to which to write error output\n+     *\/\n+    public Log(PrintWriter out, PrintWriter err) {\n+        this.out = out;\n+        this.err = err;\n+    }\n+\n+    public void flush() {\n+        out.flush();\n+        err.flush();\n+    }\n+\n+    \/**\n+     * Reports an error message, based on a resource key and optional arguments.\n+     *\n+     * @param key the resource key\n+     * @param args the arguments\n+     *\/\n+    public void error(String key, Object... args) {\n+        err.println(errPrefix + \" \" + messages.getString(key, args));\n+        errCount++;\n+    }\n+\n+    \/**\n+     * Reports a warning message, based on a resource key and optional arguments.\n+     *\n+     * @param key the resource key\n+     * @param args the arguments\n+     *\/\n+    public void warning(String key, Object... args) {\n+        err.println(warnPrefix + \" \" + messages.getString(key, args));\n+        warnCount++;\n+    }\n+\n+    \/**\n+     * Reports a message, based on a resource key and optional arguments.\n+     *\n+     * @param key the resource key\n+     * @param args the arguments\n+     *\/\n+    public void report(String key, Object... args) {\n+        err.println(messages.getString(key, args));\n+    }\n+\n+    \/**\n+     * Reports an error message, with optional file position.\n+     *\n+     * @param file the file, or null\n+     * @param line the line of the file, if any\n+     * @param key the resource key for the message, or null if the first arg is a localized message\n+     * @param args the arguments for the message\n+     *\/\n+    public void error(Path file, long line, String key, Object... args) {\n+        String message = (key == null) ? args[0].toString() : messages.getString(key, args);\n+        if (file == null) {\n+            err.println(errPrefix + \" \" + message);\n+        } else {\n+            err.println(file + \":\" + line + \": \" + message);\n+        }\n+        errCount++;\n+    }\n+\n+    \/**\n+     * Reports a warning message, with optional file position.\n+     *\n+     * @param file the file, or null\n+     * @param line the line of the file, if any\n+     * @param key the resource key for the message, or null if the first arg is a localized message\n+     * @param args the arguments for the message\n+     *\/\n+    public void warning(Path file, long line, String key, Object... args) {\n+        String message = (key == null) ? args[0].toString() : messages.getString(key, args);\n+        if (file == null) {\n+            err.println(warnPrefix + \" \" + message);\n+        } else {\n+            err.println(file + \":\" + line + \": \" + warnPrefix + \" \" + message);\n+        }\n+        warnCount++;\n+    }\n+\n+    \/**\n+     * Reports a note, with optional file position.\n+     *\n+     * @param file the file, or null\n+     * @param line the line of the file, if any\n+     * @param key the resource key for the message, or null if the first arg is a localized message\n+     * @param args the arguments for the message\n+     *\/\n+    public void note(Path file, long line, String key, Object... args) {\n+        String message = key == null ? args[0].toString() : messages.getString(key, args);\n+        if (file == null) {\n+            err.println(notePrefix + \" \" + message);\n+        } else {\n+            err.println(file + \":\" + line + \": \" + notePrefix + \" \" + message);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the number of errors that have been reported.\n+     *\n+     * @return the number of errors\n+     *\/\n+    public int errorCount() {\n+        return errCount;\n+    }\n+\n+    \/**\n+     * Returns the number of warnings that have been reported.\n+     *\n+     * @return the number of errors\n+     *\/\n+    public int warningCount() {\n+        return warnCount;\n+    }\n+\n+    \/**\n+     * Reports the number of errors and warnings that have been reported.\n+     *\/\n+    void reportCounts() {\n+        if (errCount > 0) {\n+            err.println(messages.getString(\"log.errors\", errCount));\n+        }\n+\n+        if (warnCount > 0) {\n+            err.println(messages.getString(\"log.warnings\", errCount));\n+        }\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/Log.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 2018,2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.lang.reflect.Proxy;\n+import java.nio.file.Files;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import jdk.codetools.apidiff.Options.VerboseKind;\n+import jdk.codetools.apidiff.model.API;\n+import jdk.codetools.apidiff.model.APIComparator;\n+import jdk.codetools.apidiff.model.AccessKind;\n+import jdk.codetools.apidiff.model.Selector;\n+import jdk.codetools.apidiff.report.LogReporter;\n+import jdk.codetools.apidiff.report.MultiplexReporter;\n+import jdk.codetools.apidiff.report.Reporter;\n+import jdk.codetools.apidiff.report.html.HtmlReporter;\n+\n+\/**\n+ * Main entry point for the \"apidiff\" utility.\n+ * The code can be invoked from the command line,\n+ * or by equivalent API methods.\n+ *\/\n+public class Main {\n+    \/**\n+     * An encapsulation of the exit code from running the tool.\n+     *\/\n+    public enum Result {\n+        OK(0),\n+        DIFFS(1),\n+        BAD_ARGS(2),\n+        FAULT(3);\n+        final int exitCode;\n+\n+        Result(int exitCode) {\n+            this.exitCode = exitCode;\n+        }\n+    }\n+\n+    \/**\n+     * Executes the tool, configured with the given arguments.\n+     *\n+     * This is the main entry point when invoked from the command-line.\n+     * It uses the standard output and error stream.\n+     *\n+     * @param args the arguments to configure the tool\n+     *\/\n+    public static void main(String... args) {\n+        Result r = new Main().run(args);\n+        if (r != Result.OK) {\n+            System.exit(r.exitCode);\n+        }\n+    }\n+\n+    private final PrintWriter out;\n+    private final PrintWriter err;\n+\n+    \/**\n+     * Creates an instance of the class that uses\n+     * the standard output and error streams.\n+     *\/\n+    public Main() {\n+        out = new PrintWriter(System.out);\n+        err = new PrintWriter(System.err, true);\n+    }\n+\n+    \/**\n+     * Creates an instance of the class that uses the given stream.\n+     *\n+     * @param out the stream for standard output\n+     * @param err the stream for error messages and other diagnostics.\n+     *\/\n+    public Main(PrintWriter out, PrintWriter err) {\n+        this.out = out;\n+        this.err = err;\n+    }\n+\n+    \/**\n+     * Executes the tool, configured with the given arguments.\n+     *\n+     * @param args the arguments to configure the tool\n+     *\n+     * @return a value indicating the outcome of the comparison\n+     *\/\n+    public Result run(String... args) {\n+        return run(List.of(args));\n+    }\n+\n+    \/**\n+     * Executes the tool, configured with the given arguments.\n+     *\n+     * @param args the arguments to configure the tool\n+     *\n+     * @return a value indicating the outcome of the comparison\n+     *\/\n+    public Result run(List<String> args) {\n+        Log log = new Log(out, err);\n+        try {\n+            return run(args, log);\n+        } finally {\n+            log.flush();\n+        }\n+    }\n+\n+    private Result run(List<String> args, Log log) {\n+        try {\n+            args = CommandLine.parse(args);\n+        } catch (IOException e) {\n+            log.error(\"main.err.bad-@file\", e.getMessage());\n+            return Result.BAD_ARGS;\n+        }\n+\n+        Options options = new Options(log, args);\n+        if (log.errorCount() > 0) {\n+            return Result.BAD_ARGS;\n+        }\n+\n+        if (options.version) {\n+            Version.getCurrent().show(log.out);\n+        }\n+\n+        if (options.help) {\n+            options.showHelp();\n+            log.flush();\n+        }\n+\n+        if ((options.version || options.help) && options.allAPIOptions.isEmpty()) {\n+            return Result.OK;\n+        }\n+\n+        options.validate();\n+        if (log.errorCount() > 0) {\n+            return Result.BAD_ARGS;\n+        }\n+\n+        Instant start = Instant.now();\n+\n+        Selector s = new Selector(options.includes, options.excludes);\n+        AccessKind ak = options.getAccessKind();\n+\n+        Set<API> apis = options.allAPIOptions.values().stream()\n+                .map(a -> API.of(a, s, ak, log))\n+                .collect(Collectors.toCollection(LinkedHashSet::new));\n+\n+        List<Reporter> rList = new ArrayList<>();\n+\n+        rList.add(new LogReporter(log, options));\n+        if (options.getHiddenOption(\"trace-reporter\") != null) {\n+            rList.add(createTraceReporter(log));\n+        }\n+\n+        if (options.getOutDir() != null) {\n+            try {\n+                Files.createDirectories((options.getOutDir()));\n+            } catch (IOException e) {\n+                log.error(\"main.err.cant-create-output-directory\", options.getOutDir());\n+                return Result.FAULT;\n+            }\n+            Notes notes = null;\n+            if (options.notes != null) {\n+                try {\n+                    notes = Notes.read(options.notes, log);\n+                } catch (IOException e) {\n+                    log.error(\"main.err.cant-read-notes\", options.notes, e);\n+                    return Result.FAULT;\n+                }\n+            }\n+            rList.add(new HtmlReporter(apis, options, notes, log));\n+        }\n+\n+        Reporter r = (rList.size() == 1) ? rList.get(0) : new MultiplexReporter(rList);\n+\n+        boolean equal;\n+        try {\n+            APIComparator ac = new APIComparator(apis, options, r, log);\n+            equal = ac.compare();\n+        } catch (Abort ex) {\n+            \/\/ processing aborted\n+            equal = false;\n+        }\n+\n+        if (options.isVerbose((VerboseKind.TIME))) {\n+            Instant now = Instant.now();\n+            Duration d = Duration.between(start, now);\n+            long hours = d.toHours();\n+            int minutes = d.toMinutesPart();\n+            int seconds = d.toSecondsPart();\n+            log.report(\"main.elapsed\", hours, minutes, seconds);\n+        }\n+\n+        log.reportCounts();\n+        log.flush();\n+\n+        return (log.errorCount() > 0) ? Result.FAULT : equal ? Result.OK : Result.DIFFS;\n+    }\n+\n+    private Reporter createTraceReporter(Log log) {\n+        return (Reporter) Proxy.newProxyInstance(\n+                getClass().getClassLoader(),\n+                new Class<?>[]{ Reporter.class },\n+                (proxy, method, args) -> {\n+                    log.err.println(\"!! \" + method.getName() + \": \" + Arrays.toString(args));\n+                    return null;\n+                });\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/Main.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2018,2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff;\n+\n+import java.text.MessageFormat;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.MissingResourceException;\n+import java.util.ResourceBundle;\n+import java.util.Set;\n+\n+\/**\n+ * A utility class to provide localized messages, based on resources in a resource bundle.\n+ *\/\n+public class Messages {\n+    static final Map<String, Messages> map = new HashMap<>();\n+\n+    \/**\n+     * Returns a singleton instance of a {@code Messages} object for a given\n+     * resource bundle name.\n+     *\n+     * @param name the name of the resource bundle\n+     * @return the instance\n+     *\/\n+    \/\/ TODO: Locale?\n+    public static Messages instance(String name) {\n+        synchronized (map) {\n+            return map.computeIfAbsent(name, n -> new Messages(name));\n+        }\n+    }\n+\n+    \/**\n+     * Gets an entry from the resource bundle.\n+     * If the resource cannot be found, a message is printed to the console\n+     * and the result will be a string containing the method parameters.\n+     * @param key the name of the entry to be returned\n+     * @param args an array of arguments to be formatted into the result using\n+     *      {@link java.text.MessageFormat#format}\n+     * @return the formatted string\n+     *\/\n+    public String getString(String key, Object... args) {\n+        try {\n+            return MessageFormat.format(bundle.getString(key), args);\n+        } catch (MissingResourceException e) {\n+            System.err.println(\"WARNING: missing resource: \" + key + \" for \" + name);\n+            return key + Arrays.toString(args);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the set of keys defined in the resource bundle.\n+     * @return the keys\n+     *\/\n+    public Set<String> getKeys() {\n+        return bundle.keySet();\n+    }\n+\n+    \/**\n+     * Creates a resource bundle for the given name.\n+     * @param name the name of the resource bundle\n+     *\/\n+    private Messages(String name) {\n+        this.name = name;\n+        bundle = ResourceBundle.getBundle(name);\n+    }\n+\n+    private final String name;\n+    private final ResourceBundle bundle;\n+}\n+\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/Messages.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,449 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import jdk.codetools.apidiff.model.ElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.ExecutableElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.ModuleElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.PackageElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.TypeElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.TypeParameterElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.VariableElementKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.ArrayTypeKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.DeclaredTypeKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.PrimitiveTypeKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.TypeVariableKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.WildcardTypeKey;\n+\n+\/**\n+ * A class to associate URIs and descriptions with elements.\n+ *\/\n+public class Notes {\n+    \/**\n+     * A class for an individual note that may be associated with one or more elements.\n+     *\/\n+    public static class Entry {\n+        \/**\n+         * The name of the entry, that is used to identify the associated elements.\n+         *\/\n+        public final String name;\n+\n+        \/**\n+         * The URI for the note.\n+         *\/\n+        public final URI uri;\n+\n+        \/**\n+         * The description for the note.\n+         *\/\n+        public final String description;\n+\n+        \/**\n+         * Whether the note applies to enclosed elements as well.\n+         *\/\n+        public final boolean recursive;\n+\n+        \/**\n+         * Creates a note\n+         *\n+         * @param name        the name of the note\n+         * @param uri         the URI for the note\n+         * @param description the description for the note\n+         * @param recursive   whether the note applies to enclosed elements as well\n+         *\/\n+        Entry(String name, URI uri, String description, boolean recursive) {\n+            this.name = name;\n+            this.uri = uri;\n+            this.description = description;\n+            this.recursive = recursive;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Entry[name=\" + name + \",uri=\" + uri + \",description=\" + description + \",recursive=\" + recursive + \"]\";\n+        }\n+    }\n+\n+    private final Map<String, List<Entry>> entries;\n+\n+    private Notes() {\n+        entries = new HashMap<>();\n+    }\n+\n+    \/**\n+     * Reads a file containing a description of the notes to be used.\n+     * If there are errors in the content of the file, they will be reported to the log.\n+     *\n+     * @param file the file\n+     * @param log  the log\n+     *\n+     * @return the result of reading the file\n+     * @throws IOException if an IO exception occurs while reading the file\n+     *\/\n+    public static Notes read(Path file, Log log) throws IOException {\n+        return new Reader(log).read(file);\n+    }\n+\n+    \/**\n+     * Returns the entries for a given element key.\n+     * The entries are returned in a map, that associates a boolean value with each entry,\n+     * which indicates whether the entry is for an enclosing element.\n+     *\n+     * @param k the element key\n+     * @return a map containing the entries for the key.\n+     *\/\n+    public Map<Entry, Boolean> getEntries(ElementKey k) {\n+        GetEntriesVisitor v = new GetEntriesVisitor();\n+        return v.getEntries(k);\n+    }\n+\n+    private class GetEntriesVisitor implements ElementKey.Visitor<Void, Boolean> {\n+        private Map<Entry, Boolean> map = new LinkedHashMap<>();\n+\n+        Map<Entry, Boolean> getEntries(ElementKey k) {\n+            k.accept(this, false);\n+            return map;\n+        }\n+\n+        @Override\n+        public Void visitModuleElement(ModuleElementKey mKey, Boolean isParent) {\n+            add(nameVisitor.getName(mKey), isParent);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitPackageElement(PackageElementKey pKey, Boolean isParent) {\n+            if (pKey.moduleKey != null) {\n+                pKey.moduleKey.accept(this, true);\n+            }\n+            add(nameVisitor.getName(pKey), isParent);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitTypeElement(TypeElementKey tKey, Boolean isParent) {\n+            if (tKey.enclosingKey != null) {\n+                tKey.enclosingKey.accept(this, true);\n+            }\n+            add(nameVisitor.getName(tKey), isParent);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitExecutableElement(ExecutableElementKey eKey, Boolean isParent) {\n+            add(nameVisitor.getName(eKey), isParent);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitVariableElement(VariableElementKey vKey, Boolean isParent) {\n+            add(nameVisitor.getName(vKey), isParent);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitTypeParameterElement(TypeParameterElementKey tKey, Boolean all) {\n+            throw new IllegalArgumentException(tKey.toString());\n+        }\n+\n+        private void add(String name, boolean isParent) {\n+            List<Entry> l = entries.get(name);\n+            if (l != null) {\n+                if (isParent) {\n+                    l.stream().filter(e -> e.recursive).forEach(e -> map.put(e, true));\n+                } else {\n+                    l.forEach(e -> map.put(e, false));\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns the display name for an element key.\n+     *\n+     * @param eKey the element key\n+     *\n+     * @return the display name\n+     *\/\n+    public static String getName(ElementKey eKey) {\n+        return nameVisitor.getName(eKey);\n+    }\n+\n+    private static final NameVisitor nameVisitor = new NameVisitor();\n+\n+    private static class NameVisitor implements ElementKey.Visitor<StringBuilder, StringBuilder>, TypeMirrorKey.Visitor<StringBuilder, StringBuilder> {\n+        String getName(ElementKey k) {\n+            return k.accept(this, new StringBuilder()).toString();\n+        }\n+\n+        @Override\n+        public StringBuilder visitModuleElement(ModuleElementKey mKey, StringBuilder sb) {\n+            return sb.append(mKey.name);\n+        }\n+\n+        @Override\n+        public StringBuilder visitPackageElement(PackageElementKey pKey, StringBuilder sb) {\n+            if (pKey.moduleKey != null) {\n+                pKey.moduleKey.accept(this, sb);\n+                sb.append(\"\/\");\n+            }\n+            return sb.append(pKey.name);\n+        }\n+\n+        @Override\n+        public StringBuilder visitTypeElement(TypeElementKey tKey, StringBuilder sb) {\n+            if (tKey.enclosingKey != null) {\n+                tKey.enclosingKey.accept(this, sb);\n+                sb.append(\".\");\n+            }\n+            return sb.append(tKey.name);\n+        }\n+\n+        @Override\n+        public StringBuilder visitExecutableElement(ExecutableElementKey eKey, StringBuilder sb) {\n+            eKey.typeKey.accept(this, sb).append(\"#\").append(eKey.name).append(\"(\");\n+            boolean first = true;\n+            for (TypeMirrorKey t :  eKey.params) {\n+                if (first) {\n+                    first = false;\n+                } else {\n+                    sb.append(\",\");\n+                }\n+                t.accept(this, sb);\n+            }\n+            return sb.append(\")\");\n+        }\n+\n+        @Override\n+        public StringBuilder visitVariableElement(VariableElementKey vKey, StringBuilder sb) {\n+            vKey.typeKey.accept(this, sb);\n+            return sb.append(\"#\").append(vKey.name);\n+        }\n+\n+        @Override\n+        public StringBuilder visitTypeParameterElement(TypeParameterElementKey k, StringBuilder sb) {\n+            throw new IllegalArgumentException(k.toString());\n+        }\n+\n+        @Override\n+        public StringBuilder visitArrayType(ArrayTypeKey k, StringBuilder sb) {\n+            return k.componentKey.accept(this, sb).append(\"[]\");\n+        }\n+\n+        @Override\n+        public StringBuilder visitDeclaredType(DeclaredTypeKey k, StringBuilder sb) {\n+            ElementKey eKey = k.elementKey;\n+            return switch (eKey.kind) {\n+                case TYPE -> sb.append(((TypeElementKey) eKey).name); \/\/ simple name only\n+                case TYPE_PARAMETER -> sb.append(((TypeParameterElementKey) eKey).name); \/\/ simple name only\n+                default -> throw new IllegalArgumentException((k.toString()));\n+            };\n+        }\n+\n+        @Override\n+        public StringBuilder visitPrimitiveType(PrimitiveTypeKey k, StringBuilder sb) {\n+            return sb.append(k.kind.toString().toLowerCase(Locale.ROOT));\n+        }\n+\n+        @Override\n+        public StringBuilder visitTypeVariable(TypeVariableKey k, StringBuilder sb) {\n+            return sb.append(k.name);\n+        }\n+\n+        @Override\n+        public StringBuilder visitWildcardType(WildcardTypeKey k, StringBuilder sb) {\n+            throw new IllegalArgumentException((k.toString()));\n+        }\n+\n+    }\n+\n+    private static class Reader {\n+        private final Log log;\n+        private Path file;\n+\n+        Pattern p = Pattern.compile(\"\\\\s*([\\\\S]+)\\\\s*(.*?)\\\\s*\");\n+        Notes notes = new Notes();\n+        URI uri = null;\n+        String description = null;\n+        int lineNumber = 0;\n+        boolean skipLines = false;\n+\n+        Reader(Log log) {\n+            this.log = log;\n+        }\n+\n+        Notes read(Path file) throws IOException {\n+            this.file = file;\n+\n+            for (String line : Files.readAllLines(file)) {\n+                lineNumber++;\n+                process(line);\n+            }\n+\n+            return notes;\n+        }\n+\n+        void process(String line) {\n+\n+            if (line.startsWith(\"#\") || line.isBlank()) {\n+                return;\n+            }\n+\n+            Matcher m = p.matcher(line);\n+            if (!m.matches()) {\n+                \/\/ should not happen, since we already ignored blank lines\n+                log.error(file, lineNumber, \"notes.err.bad-line\", line);\n+                return;\n+            }\n+\n+            String first = m.group(1);\n+            String rest = m.group(2);\n+\n+            if (first.contains(\":\")) {\n+                try {\n+                    uri = new URI(first);\n+                    description = rest;\n+                    skipLines = false;\n+                } catch (URISyntaxException e) {\n+                    log.error(file, lineNumber, \"notes.err.bad-uri\", first);\n+                    skipLines = true;\n+                }\n+                return;\n+            }\n+\n+            if (!rest.isEmpty()) {\n+                log.error(file, lineNumber, \"notes.err.bad-line\", line);\n+                return;\n+            }\n+\n+            boolean recursive;\n+            if (first.endsWith(\"\/*\") || first.endsWith(\".*\")) {\n+                first = first.substring(0, first.length() - 2);\n+                recursive = true;\n+            } else {\n+                recursive = false;\n+            }\n+\n+            if (!isValidSignature(first)) {\n+                log.error(file, lineNumber, \"notes.err.bad-signature\", first);\n+                return;\n+            }\n+\n+            if (skipLines) {\n+                \/\/ uri has been reported as invalid; can't create entry\n+                return;\n+            }\n+\n+            if (uri == null) {\n+                log.error(file, lineNumber, \"notes.err.no-current-uri\");\n+                skipLines = true;\n+                return;\n+            }\n+\n+            notes.entries.computeIfAbsent(first, __ -> new ArrayList<>())\n+                    .add(new Entry(first, uri, description, recursive));\n+        }\n+\n+        boolean isValidSignature(String sig) {\n+            int slash = sig.indexOf(\"\/\");\n+            if (slash != -1) {\n+                if  (!isQualifiedIdentifier(sig.substring(0, slash))) {\n+                    return false;\n+                }\n+                sig = sig.substring(slash + 1);\n+                if (sig.isEmpty()) {\n+                    \/\/ signature was module\/\n+                    return true;\n+                }\n+            }\n+\n+            int hash = sig.indexOf(\"#\");\n+            if (hash == -1) {\n+                \/\/ signature was [module\/] package-or-type\n+                return isQualifiedIdentifier(sig);\n+            }\n+\n+            String type = sig.substring(0, hash);\n+            String member = sig.substring(hash + 1);\n+            if (!isQualifiedIdentifier(type)) {\n+                \/\/ bad [package .] type\n+                return false;\n+            }\n+\n+            int lParen = member.indexOf(\"(\");\n+            if (lParen == -1) {\n+                \/\/ signature looks like [module\/] [package .] type # field\n+                return isIdentifier(member);\n+            }\n+\n+            \/\/ signature looks like [module\/] type # method ( param-types )\n+            String method = member.substring(0, lParen);\n+            String params = member.substring(lParen + 1, member.length() - 1);\n+            return (isIdentifier(method) || method.equals(\"<init>\"))\n+                    && (params.isEmpty()\n+                        || Stream.of(params.split(\",\", -1)).allMatch(this::isIdentifier));\n+\n+        }\n+\n+        boolean isQualifiedIdentifier(String name) {\n+            return Stream.of(name.split(\"\\\\.\", -1)).allMatch(this::isIdentifier);\n+        }\n+\n+        boolean isIdentifier(String name) {\n+            if (name.isEmpty()) {\n+                return false;\n+            }\n+\n+            if (!Character.isJavaIdentifierStart(name.charAt(0))) {\n+                return false;\n+            }\n+\n+            for (int i = 1; i < name.length(); i++) {\n+                if (!Character.isUnicodeIdentifierPart(name.charAt(i))) {\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n+        }\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/Notes.java","additions":449,"deletions":0,"binary":false,"changes":449,"status":"added"},{"patch":"@@ -0,0 +1,1184 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff;\n+\n+import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.lang.model.SourceVersion;\n+\n+import jdk.codetools.apidiff.model.AccessKind;\n+\n+\/**\n+ * The command-line options for the {@code apidiff} program.\n+ *\/\n+public class Options {\n+\n+    static class BadOption extends Exception {\n+        private static final long serialVersionUID = -1L;\n+        final String key;\n+        final Object[] args;\n+        BadOption(String key, Object... args) {\n+            super(key + Arrays.toString(args));\n+            this.key = key;\n+            this.args = args;\n+        }\n+    }\n+\n+    private final Log log;\n+\n+    \/**\n+     * A container for the options to configure an API.\n+     *\/\n+    public static class APIOptions {\n+        \/**\n+         * The name of the API.\n+         *\/\n+        public final String name;\n+\n+        \/**\n+         * A short plain-text label for the API.\n+         *\/\n+        public String label;\n+\n+        \/**\n+         * The options to configure a file manager for the API.\n+         *\/\n+        public Map<String, List<String>> fileManagerOpts = new LinkedHashMap<>();\n+\n+        \/**\n+         * The value of the {@code --release} option for the API.\n+         *\/\n+        public String release;\n+\n+        \/**\n+         * The value of the {@code --source} option for the API.\n+         *\/\n+        public String source;\n+\n+        \/**\n+         * Whether or not {@code --enable-preview} has been specified.\n+         *\/\n+        public boolean enablePreview;\n+\n+        \/**\n+         * The API directory containing the documentation generated by javadoc.\n+         *\/\n+        public Path apiDir;\n+\n+        \/**\n+         * The location of a JDK build, from which to derive a series of options.\n+         *\/\n+        public Path jdkBuildDir;\n+\n+        public APIOptions(String name) {\n+            this.name = name;\n+        }\n+\n+        void addFileManagerOpt(String opt, String arg) {\n+            fileManagerOpts.computeIfAbsent(opt, _o -> new ArrayList<>()).add(arg);\n+        }\n+\n+        public String toString() {\n+            return \"APIOptions[name:\" + name\n+                    + \",label:\" + label\n+                    + \",fmOpts:\" + fileManagerOpts\n+                    + \",release:\" + release\n+                    + \",source:\" + source\n+                    + \",enablePreview:\" + enablePreview\n+                    + \",apiDir:\" + apiDir\n+                    + \",jdkBuildDir:\" + jdkBuildDir\n+                    + \"]\";\n+        }\n+    }\n+\n+    \/\/ env options\n+    Map<String, APIOptions> allAPIOptions = new LinkedHashMap<>();\n+    APIOptions currAPIOptions = null;\n+    boolean apiOption = false;\n+\n+    \/\/ selection\/filtering options\n+    List<String> includes = new ArrayList<>();\n+    List<String> excludes = new ArrayList<>();\n+    AccessKind access;\n+    Boolean compareDocComments;\n+    Boolean compareApiDescriptions;\n+    Boolean compareApiDescriptionsAsText;\n+    String jdkDocs;\n+\n+    \/\/ output options\n+    Path outDir;\n+    String title;\n+    String description;\n+    Path notes;\n+    Path mainStylesheet;\n+    List<Path> extraStylesheets;\n+    List<Path> resourceFiles;\n+    boolean showEqual;\n+\n+    \/**\n+     * The position of additional text to be included in the report.\n+     *\/\n+    public enum InfoTextKind {\n+        \/**\n+         * At the top of each page, above the header bar.\n+         * Intended for warning and status messages.\n+         *\/\n+        TOP,\n+\n+        \/**\n+         * Within the main header bar, on the right hand side.\n+         * Intended for a short name for the report.\n+         *\/\n+        HEADER,\n+\n+        \/**\n+         * Within the main footer bar, on the right hand side.\n+         * Intended for a short name for the report.\n+         *\/\n+        FOOTER,\n+\n+        \/**\n+         * At the bottom of each page, below the footer bar.\n+         * Intended for legal details, such as license and copyright info.\n+         *\/\n+        BOTTOM\n+    }\n+\n+    private Map<InfoTextKind, String> infoText = new EnumMap<>(InfoTextKind.class);\n+\n+    \/**\n+     * The level for which messages should be generated in \"verbose: mode.\n+     *\/\n+    public enum VerboseKind {\n+        \/** Generate messages about comparing modules. *\/\n+        MODULE,\n+        \/** Generate messages about comparing modules and packages. *\/\n+        PACKAGE,\n+        \/** Generate messages about comparing modules, packages, and types. *\/\n+        TYPE,\n+        \/** Generate messages about different items. *\/\n+        DIFFERENCES,\n+        \/** Generate messages about missing items. *\/\n+        MISSING,\n+        \/** Generate messages about the time taken. *\/\n+        TIME\n+    }\n+\n+    private Set<VerboseKind> verboseKinds = EnumSet.noneOf(VerboseKind.class);\n+\n+    \/\/ meta options\n+    boolean help;\n+    boolean version;\n+    private boolean verbose;\n+\n+    \/\/ hidden options\n+    private Map<String, String> hidden = new HashMap<>();\n+\n+    \/**\n+     * The comparison mode, inferred from the `--include` options.\n+     * The mode determines the file manager locations in which to\n+     * look for the elements to be compared.\n+     *\/\n+    public enum Mode {\n+        \/**\n+         * Elements are in modules, to be found on the aggregate module path.\n+         *\/\n+        MODULE,\n+        \/**\n+         * Elements are either in the unnamed module, or are in no module,\n+         * to be found on the source path, class path, and so on.\n+         *\/\n+        PACKAGE\n+    }\n+\n+    \/**\n+     * A class that defines the set of supported options.\n+     *\/\n+    public enum Option {\n+        \/**\n+         * {@code --api} <var>name<\/var>.\n+         *\n+         * <p>The option should be followed by any API-specific configuration options in the\n+         * arguments that immediately follow this option.\n+         *\/\n+        API(\"--api\", \"opt.arg.api\") {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.currAPIOptions = options.allAPIOptions.computeIfAbsent(arg, APIOptions::new);\n+                options.apiOption = true;\n+            }\n+        },\n+\n+        \/**\n+         * {@code --api-directory} <var>directory<\/var>.\n+         *\n+         * <p>This is an API-specific option. .\n+         *\/\n+        API_DIR(\"--api-directory\", \"opt.arg.api-directory\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                Path p = asExistingPath(arg);\n+                options.putAPIOption(opt, a -> a.apiDir = p);\n+            }\n+        },\n+\n+        \/**\n+         * {@code --class-path} <var>path<\/var>.\n+         *\n+         * <p>This is an API-specific option. See the {@code javac} documentation for details.\n+         *\/\n+        CLASS_PATH(\"--class-path\", \"opt.arg.class-path\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.putAPIOption(opt, a -> a.addFileManagerOpt(opt, arg));\n+            }\n+        },\n+\n+        \/**\n+         * {@code --compare-api-descriptions} <var>boolean-value<\/var>\n+         *\/\n+        COMPARE_API_DESCRIPTIONS(\"--compare-api-descriptions\", \"opt.arg.boolean\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.compareApiDescriptions = asBoolean(arg);\n+            }\n+        },\n+\n+        \/**\n+         * {@code --compare-api-descriptions-as-text} <var>boolean-value<\/var>\n+         *\/\n+        COMPARE_API_DESCRIPTIONS_AS_TEXT(\"--compare-api-descriptions-as-text\", \"opt.arg.boolean\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.compareApiDescriptionsAsText = asBoolean(arg);\n+                if (options.compareApiDescriptionsAsText) {\n+                    options.compareApiDescriptions = true;\n+                }\n+            }\n+        },\n+\n+        \/**\n+         * {@code --compare-doc-comments} <var>boolean-value<\/var>\n+         *\/\n+        COMPARE_DOC_COMMENTS(\"--compare-doc-comments\", \"opt.arg.boolean\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.compareDocComments = asBoolean(arg);\n+            }\n+        },\n+\n+        \/**\n+         * {@code --enable-preview}.\n+         *\n+         * <p>This is an API-specific option. See the {@code javac} documentation for details.\n+         *\/\n+        ENABLE_PREVIEW(\"--enable-preview\", null) {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.putAPIOption(opt, a -> a.enablePreview = true);\n+            }\n+        },\n+\n+        \/**\n+         * {@code --label} <var>text<\/var>.\n+         *\n+         * <p>This is an API-specific option. .\n+         *\/\n+        LABEL(\"--label\", \"opt.arg.plain-text\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.putAPIOption(opt, a -> a.label = arg);\n+            }\n+        },\n+\n+        \/**\n+         * {@code --module-path} <var>path<\/var>.\n+         *\n+         * <p>This is an API-specific option. See the {@code javac} documentation for details.\n+         *\/\n+        MODULE_PATH(\"--module-path\", \"opt.arg.module-path\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.putAPIOption(opt, a -> a.addFileManagerOpt(opt, arg));\n+            }\n+        },\n+\n+        \/**\n+         * {@code --module-source-path} <var>pattern-or-module-specific-path<\/var>.\n+         *\n+         * <p>This is an API-specific option. See the {@code javac} documentation for details.\n+         *\/\n+        MODULE_SOURCE_PATH(\"--module-source-path\", \"opt.arg.module-source-path\")  {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.putAPIOption(opt, a -> a.addFileManagerOpt(opt, arg));\n+            }\n+        },\n+\n+        \/**\n+         * {@code --module-path} <var>module-specific-path<\/var>.\n+         *\n+         * <p>This is an API-specific option. See the {@code javac} documentation for details.\n+         *\/\n+        PATCH_MODULE(\"--patch-module\", \"opt.arg.patch-module\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.putAPIOption(opt, a -> a.addFileManagerOpt(opt, arg));\n+            }\n+        },\n+\n+        \/**\n+         * {@code --release} <var>release<\/var>.\n+         *\n+         * <p>This is an API-specific option. See the {@code javac} documentation for details.\n+         *\/\n+        RELEASE(\"--release\", \"opt.arg.jdk-version\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.putAPIOption(opt, a -> a.release = arg);\n+            }\n+        },\n+\n+        \/**\n+         * {@code --source} <var>release<\/var>.\n+         *\n+         * <p>This is an API-specific option. See the {@code javac} documentation for details.\n+         *\/\n+        SOURCE(\"--source\", \"opt.arg.jdk-version\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.putAPIOption(opt, a -> a.source = arg);\n+            }\n+        },\n+\n+        \/**\n+         * {@code --source-path} <var>path<\/var>.\n+         *\n+         * <p>This is an API-specific option. See the {@code javac} documentation for details.\n+         *\/\n+        SOURCE_PATH(\"--source-path\", \"opt.arg.source-path\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.putAPIOption(opt, a -> a.addFileManagerOpt(opt, arg));\n+            }\n+        },\n+\n+        \/**\n+         * {@code --system} <var>jdk<\/var>.\n+         *\n+         * <p>This is an API-specific option. See the {@code javac} documentation for details.\n+         *\/\n+        SYSTEM(\"--system\", \"opt.arg.jdk-home\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.putAPIOption(opt, a -> a.addFileManagerOpt(opt, arg));\n+            }\n+        },\n+\n+        \/**\n+         * {@code --jdk-build} <var>build-directory<\/var>\n+         *\n+         * Shorthand for a series of API-specific options that can be derived from the\n+         * location of a JDK build.\n+         *\/\n+        JDK_BUILD(\"--jdk-build\", \"opt.arg.jdk-build\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                Path jdkBuildDir = asExistingPath(arg);\n+                options.putAPIOption(opt, a -> a.jdkBuildDir = jdkBuildDir);\n+            }\n+        },\n+\n+        \/**\n+         * {@code --jdk-docs} <var>docs-directory-name<\/var>\n+         *\n+         * Used with {@code --jdk-build} to specify the name of the docs directory.\n+         *\/\n+        JDK_DOCS(\"--jdk-docs\", \"opt.arg.jdk-docs\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.jdkDocs = arg;\n+            }\n+        },\n+\n+        \/\/ Selection options\n+\n+        \/**\n+         * {@code --access} {@code }public|protected|package|private}.\n+         *\n+         * <p>Specifies the access level of items to be compared.\n+         * The default is {@code protected}.\n+         *\/\n+        ACCESS(\"--access\", \"opt.arg.access\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.access = switch (arg) {\n+                    case \"public\" -> AccessKind.PUBLIC;\n+                    case \"protected\" -> AccessKind.PROTECTED;\n+                    case \"package\" -> AccessKind.PACKAGE;\n+                    case \"private\" -> AccessKind.PRIVATE;\n+                    default -> throw new BadOption(\"options.err.bad-access\", arg);\n+                };\n+            }\n+        },\n+\n+        \/**\n+         * {@code --exclude} <var>pattern<\/var>.\n+         *\n+         * <p>Specify patterns for elements to be excluded from the comparison.\n+         *\/\n+        EXCLUDE(\"--exclude\", \"opt.arg.pattern\") {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.excludes.add(arg);\n+            }\n+        },\n+\n+        \/**\n+         * {@code --include} <var>pattern<\/var>.\n+         *\n+         * <p>Specify patterns for elements to be included in the comparison.\n+         *\/\n+        INCLUDE(\"--include\", \"opt.arg.pattern\") {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.includes.add(arg);\n+            }\n+        },\n+\n+        \/\/ Output options\n+\n+        \/**\n+         * {@code --output-directory} <var>dir<\/var>.\n+         *\n+         * <p>The directory in which to generate the comparison report.\n+         *\/\n+        OUTDIR(\"--output-directory -d\", \"opt.arg.directory\") {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.outDir = Path.of(arg);\n+            }\n+        },\n+\n+        \/**\n+         * {@code --title} <var>string<\/var>.\n+         *\n+         * <p>A plain-text title for the report.\n+         *\/\n+        TITLE(\"--title\", \"opt.arg.plain-text\") {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.title = arg;\n+            }\n+        },\n+\n+        \/**\n+         * {@code --description} <var>html-text<\/var>.\n+         *\n+         * <p>A description to be included in the report.\n+         *\/\n+        DESCRIPTION(\"--description\", \"opt.arg.html-text\") {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.description = arg;\n+            }\n+        },\n+\n+        \/**\n+         * {@code --info-text}  <var>place-list<\/var>{@code =}<var>html-text<\/var>.\n+         *\n+         * <p>Additional text to be included in one or more of the top, header, footer or bottom\n+         * of the page. The option may be given more than once, but at most once for any one\n+         * position.\n+         *\/\n+        INFO_TEXT(\"--info-text\", \"opt.arg.info-text\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                int eq = arg.indexOf('=');\n+                if (eq == -1) {\n+                    throw new BadOption(\"options.err.invalid.info.text\");\n+                }\n+                String[] keys = arg.substring(0, eq).split(\",\");\n+                for (String k : keys) {\n+                    try {\n+                        InfoTextKind kind = InfoTextKind.valueOf(k.toUpperCase(Locale.ROOT));\n+                        options.infoText.put(kind, arg.substring(eq + 1));\n+                    } catch (IllegalArgumentException e) {\n+                        throw new BadOption(\"options.err.invalid-info-text-kind\", k);\n+                    }\n+                }\n+            }\n+        },\n+\n+        \/**\n+         * {@code --notes} <var>notes-file<\/var>\n+         *\n+         * <p>Details of notes (links) to be associated with various individual elements.<\/p>\n+         *\/\n+        NOTES(\"--notes\", \"opt.arg.file\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.notes = asExistingPath(arg);\n+            }\n+        },\n+\n+        \/**\n+         * {@code --main-stylesheet} <var>file<\/var>\n+         *\n+         * <p>Specify an alternative default stylesheet.\n+         *\/\n+        MAIN_STYLESHEET(\"--main-stylesheet\", \"opt.arg.file\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.mainStylesheet = asExistingPath(arg);\n+            }\n+\n+        },\n+\n+        \/**\n+         * {@code --extra-stylesheet} <var>file<\/var>\n+         *\n+         * <p>Specify an additional stylesheet.\n+         *\/\n+        EXTRA_STYLESHEET(\"--extra-stylesheet\", \"opt.arg.file\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                if (options.extraStylesheets == null) {\n+                    options.extraStylesheets = new ArrayList<>();\n+                }\n+                options.extraStylesheets.add(asExistingPath(arg));\n+            }\n+\n+        },\n+\n+        \/**\n+         * {@code --resource-files} <var>file<\/var>\n+         *\n+         * <p>Specify additional resource files to be included in the output.\n+         *\/\n+        RESOURCE_FILES(\"--resource-files\", \"opt.arg.file-or-directory\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                if (options.resourceFiles == null) {\n+                    options.resourceFiles = new ArrayList<>();\n+                }\n+                options.resourceFiles.add(asPath(arg));\n+            }\n+\n+        },\n+\n+\n+        \/\/ Help and information options\n+\n+        \/**\n+         * {@code --help}.\n+         *\n+         * <p>Show command line help.\n+         *\/\n+        HELP(\"--help -h -help -?\", null) {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.help = true;\n+            }\n+        },\n+\n+        \/**\n+         * {@code --version}.\n+         *\n+         * <p>Show the version of the program.\n+         *\/\n+        VERSION(\"--version -v\", null) {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.version = true;\n+            }\n+        },\n+\n+        \/**\n+         * {@code --verbose [flag|-flag|all|none]*}.\n+         *\n+         * <p>Specify the verbosity of the program.\n+         *\/\n+        VERBOSE(\"--verbose\", \"opt.arg.verbose\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                for (String a : arg.split(\",+\")) {\n+                    switch (a) {\n+                        case \"all\" ->\n+                            options.verboseKinds.addAll(EnumSet.allOf(VerboseKind.class));\n+\n+                        case \"none\" ->\n+                            options.verboseKinds.clear();\n+\n+                        default -> {\n+                            String name;\n+                            boolean clear = false;\n+                            if (a.startsWith(\"-\")) {\n+                                clear = true;\n+                                name = a.substring(1);\n+                            } else {\n+                                name = a;\n+                            }\n+                            try {\n+                                VerboseKind k = VerboseKind.valueOf(name.toUpperCase(Locale.ROOT));\n+                                if (clear) {\n+                                    options.verboseKinds.remove(k);\n+                                } else {\n+                                    options.verboseKinds.add(k);\n+                                }\n+                            } catch (IllegalArgumentException e) {\n+                                throw new BadOption(\"options.err.invalid-arg-for-verbose\", a);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            @Override\n+            public String getHelpDescription(Messages msgs, String key) {\n+                String flags = Arrays.stream(VerboseKind.values())\n+                        .map(k -> k.name().toLowerCase(Locale.ROOT))\n+                        .collect(Collectors.joining(\" \"));\n+                return msgs.getString(key, flags);\n+            }\n+        };\n+\n+        final List<String> names;\n+        final String arg;\n+\n+        Option(String names, String arg) {\n+            this.names = Arrays.asList(names.split(\"\\\\s+\"));\n+            this.arg = arg;\n+        }\n+\n+        abstract void process(String opt, String arg, Options options) throws BadOption;\n+\n+        \/**\n+         * Returns the list of names for the option.\n+         *\n+         * @return the names\n+         *\/\n+        public List<String> getNames() {\n+            return names;\n+        }\n+\n+        \/**\n+         * Returns the resource key for the argument accepted by the option,\n+         * or {@code null} if the option does not take an argument.\n+         *\n+         * @return the resource key\n+         *\/\n+        public String getArg() {\n+            return arg;\n+        }\n+\n+        \/**\n+         * Returns the description for an option, based on a resource key.\n+         *\n+         * @param msgs the messages to be used to generate the description\n+         * @param key  the resource key\n+         *\n+         * @return the description\n+         *\/\n+        public String getHelpDescription(Messages msgs, String key) {\n+            return msgs.getString(key);\n+        }\n+\n+        private static boolean asBoolean(String arg) throws BadOption {\n+            return switch (arg.toLowerCase(Locale.ROOT)) {\n+                case \"true\", \"yes\", \"on\" -> true;\n+                case \"false\", \"no\", \"off\" -> false;\n+                default -> throw new BadOption(\"options.err.invalid-boolean\", arg);\n+            };\n+        }\n+    }\n+\n+    Options(Log log, List<String> args) {\n+        \/\/ @files should have already been processed\n+\n+        this.log = log;\n+\n+        Map<String, Option> map = new HashMap<>();\n+        for (Option o : Option.values()) {\n+            o.names.forEach(n -> map.put(n, o));\n+        }\n+\n+        \/\/ TODO: convert to use Iterator or ListIterator\n+        for (int i = 0; i < args.size(); i++) {\n+            String arg = args.get(i);\n+            \/\/ currently no support for positional args\n+            String optName, optValue;\n+            int eq = arg.startsWith(\"--\") ? arg.indexOf(\"=\") : -1;\n+            if (eq == -1) {\n+                optName = arg;\n+                optValue = null;\n+            } else {\n+                optName = arg.substring(0, eq);\n+                optValue = arg.substring(eq + 1);\n+            }\n+            if (optName.isEmpty()) {\n+                log.error(\"options.err.bad.argument\", arg);\n+            } else {\n+                Option opt = map.get(optName);\n+                if (opt == null) {\n+                    if (optName.startsWith(\"-XD\")) {\n+                        setHiddenOption(optName.substring(3));\n+                    } else {\n+                        reportBadOption(optName);\n+                    }\n+                } else {\n+                    apiOption = false;\n+                    try {\n+                        if (opt.arg == null) {\n+                            \/\/ no value for option required\n+                            if (optValue != null) {\n+                                log.error(\"options.err.unexpected-value-for-option\", optName, optValue);\n+                            } else {\n+                                opt.process(optName, null, this);\n+                            }\n+                        } else {\n+                            \/\/ value for option required; use next arg if not found after '='\n+                            if (optValue == null) {\n+                                if (i + 1 < args.size()) {\n+                                    optValue = args.get(++i);\n+                                } else {\n+                                    log.error(\"options.err.missing-value-for-option\", optName);\n+                                    continue;\n+                                }\n+                            }\n+                            opt.process(optName, optValue, this);\n+                        }\n+                    } catch (BadOption e) {\n+                        log.error(e.key, e.args);\n+                    }\n+                    \/\/ Cancel the \"API options mode\" when a non-API option is used.\n+                    if (!apiOption) {\n+                        currAPIOptions = null;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void reportBadOption(String name) {\n+        log.error(\"options.err.unknown-option\", name);\n+\n+        var allOptionNames = Stream.of(Option.values())\n+                .flatMap(o -> o.getNames().stream());\n+        record Pair(String word, double similarity) { }\n+        final double MIN_SIMILARITY = 0.7;\n+        var suggestions = allOptionNames\n+                .map(t -> new Pair(t, similarity(t, name)))\n+                .sorted(Comparator.comparingDouble(Pair::similarity).reversed() \/* more similar first *\/)\n+                \/\/ .peek(p -> System.out.printf(\"%.3f, (%s ~ %s)%n\", p.similarity, p.word, name)) \/\/ debug\n+                .takeWhile(p -> Double.compare(p.similarity, MIN_SIMILARITY) >= 0)\n+                .map(Pair::word)\n+                .toList();\n+        switch (suggestions.size()) {\n+            case 0 -> { }\n+            case 1 -> log.report(\"options.did-you-mean\", suggestions.get(0));\n+            default -> log.report(\"options.did-you-mean-one-of\", String.join(\" \", suggestions));\n+        }\n+        log.report(\"options.for-more-details-see-usage\");\n+    }\n+\n+    \/\/ a value in [0, 1] range: the closer the value is to 1, the more similar\n+    \/\/ the strings are\n+    private static double similarity(String a, String b) {\n+        \/\/ Normalize the distance so that similarity between \"x\" and \"y\" is\n+        \/\/ less than that of \"ax\" and \"ay\". Use the greater of two lengths\n+        \/\/ as normalizer, as it's an upper bound for the distance.\n+        return 1.0 - ((double) DamerauLevenshteinDistance.of(a, b))\n+                \/ Math.max(a.length(), b.length());\n+    }\n+\n+    \/**\n+     * Returns the collection of API options.\n+     *\n+     * @return the collection of API options\n+     *\/\n+    public Map<String, APIOptions> getAllAPIOptions() {\n+        return allAPIOptions;\n+    }\n+\n+    \/**\n+     * Returns the mode for the comparison.\n+     *\n+     * @return the mode for the comparison\n+     *\/\n+    public Mode getMode() {\n+        return includes.isEmpty()\n+                ? null\n+                : includes.get(0).contains(\"\/\") ? Mode.MODULE : Mode.PACKAGE;\n+    }\n+\n+    \/**\n+     * Returns the access kind to be used to select items to be compared.\n+     * If a value was not specified in the options provided to the constructor,\n+     * a default value of {@code PROTECTED} is returned.\n+     *\n+     * @return the access\n+     *\/\n+    public AccessKind getAccessKind() {\n+        return access != null ? access : AccessKind.PROTECTED;\n+    }\n+\n+    \/**\n+     * Returns whether API descriptions should be compared.\n+     *\n+     * @return {@code true} if API descriptions should be compared\n+     *\/\n+    public boolean compareApiDescriptions() {\n+        return compareApiDescriptions;\n+    }\n+\n+    \/**\n+     * Returns whether API descriptions should be compared as plain text.\n+     *\n+     * @return {@code true} if API descriptions should be compared as plain text\n+     *\/\n+    public boolean compareApiDescriptionsAsText() {\n+        return compareApiDescriptionsAsText;\n+    }\n+\n+    \/**\n+     * Returns whether documentation comments should be compared.\n+     *\n+     * @return {@code true} if documentation comments should be compared\n+     *\/\n+    public boolean compareDocComments() {\n+        return compareDocComments;\n+    }\n+\n+    \/**\n+     * Returns the output directory to be used.\n+     *\n+     * @return the output directory\n+     *\/\n+    public Path getOutDir() {\n+        return outDir;\n+    }\n+\n+    \/**\n+     * Returns the title for the report.\n+     *\n+     * @return the title\n+     *\/\n+    public String getTitle() {\n+        return title;\n+    }\n+\n+    \/**\n+     * Returns the description for the report.\n+     *\n+     * @return the description\n+     *\/\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    \/**\n+     * Returns the additional text for the report.\n+     * @param kind the kind of the text\n+     * @return the text\n+     *\/\n+    public String getInfoText(InfoTextKind kind) {\n+        return infoText.get(kind);\n+    }\n+\n+    \/**\n+     * Returns the user-specified main stylesheet for the report.\n+     *\n+     * @return the stylesheet\n+     *\/\n+    public Path getMainStylesheet() {\n+        return mainStylesheet;\n+    }\n+\n+    \/**\n+     * Returns any user-specified additional stylesheets for the report.\n+     *\n+     * @return the stylesheets\n+     *\/\n+    public List<Path> getExtraStylesheets() {\n+        return (extraStylesheets == null) ? Collections.emptyList() : extraStylesheets;\n+    }\n+\n+    \/**\n+     * Returns any user-specified additional stylesheets for the report.\n+     *\n+     * @return the stylesheets\n+     *\/\n+    public List<Path> getResourceFiles() {\n+        return (resourceFiles == null) ? Collections.emptyList() : resourceFiles;\n+    }\n+\n+    public boolean showEqual() {\n+        return showEqual;\n+    }\n+\n+    \/**\n+     * Returns the value of a \"hidden\" option, set by {@code -XD<name>} or\n+     * {@code -XD<name>=<value>}.\n+     *\n+     * @param name the name of the hidden option\n+     * @return the value of the option, or null if not set\n+     *\/\n+    public String getHiddenOption(String name) {\n+        return hidden.get(name);\n+    }\n+\n+    \/**\n+     * Returns whether a kind of verbose mode is enabled.\n+     * @param k the kind of verbose mode\n+     * @return {@code true} if a kind of verbose mode is enabled\n+     *\/\n+    public boolean isVerbose(VerboseKind k) {\n+        return verboseKinds.contains(k);\n+    }\n+\n+    void putAPIOption(String optName, Consumer<APIOptions> f) throws BadOption {\n+        if (currAPIOptions == null) {\n+            throw new BadOption(\"options.err.no-api-for-option\", optName);\n+        }\n+        apiOption = true;\n+        f.accept(currAPIOptions);\n+    }\n+\n+    void setHiddenOption(String s) {\n+        int eq = s.indexOf('=');\n+        if (eq == -1) {\n+            hidden.put(s, s);\n+        } else {\n+            hidden.put(s.substring(0, eq), s.substring(eq + 1));\n+        }\n+    }\n+\n+    static Path asPath(String p) throws BadOption {\n+        try {\n+            return Path.of(p);\n+        } catch (InvalidPathException e) {\n+            throw new BadOption(\"options.err.bad-file\", p);\n+        }\n+    }\n+\n+    static Path asExistingPath(String p) throws BadOption {\n+        try {\n+            Path path = Path.of(p);\n+            if (!Files.exists(path)) {\n+                throw new BadOption(\"options.err.file-not-found\", p);\n+            }\n+            return path;\n+        } catch (InvalidPathException e) {\n+            throw new BadOption(\"options.err.bad-file\", p);\n+        }\n+    }\n+\n+    void validate() {\n+\/\/        \/\/ fixme?\n+\/\/        \/\/ check not package and module paths for different APIs\n+\/\/        \/\/ check not mixed modes for different APIs\n+\/\/\n+        \/\/ Check at least one includes option\n+        if (includes.isEmpty()) {\n+            log.error(\"options.err.no-include-options\");\n+        } else {\n+            Mode mode = getMode();\n+            includes.forEach(s -> checkPattern(mode, s));\n+            excludes.forEach(s -> checkPattern(mode, s));\n+        }\n+\n+        allAPIOptions.values().forEach(this::checkAPIOptions);\n+        if (log.errorCount() > 0) {\n+            return;\n+        }\n+\n+        boolean allApiHaveApiDir = allAPIOptions.values().stream().allMatch(a -> a.apiDir != null);\n+        if (compareApiDescriptions == null) {\n+            \/\/ if not specified explicitly, compare API descriptions if not comparing doc comments\n+            \/\/ and if --api-directory is specified for all API instances\n+            compareApiDescriptions = (compareDocComments != Boolean.TRUE) && allApiHaveApiDir;\n+        } else {\n+            \/\/ if specified, check --api-directory is specified for all API instances\n+            if (compareApiDescriptions && !allApiHaveApiDir) {\n+                log.error(\"options.err.compare-api-but-missing-dir\");\n+            }\n+        }\n+\n+        if (compareApiDescriptionsAsText == null) {\n+            compareApiDescriptionsAsText = false;\n+        }\n+\n+        if (compareDocComments == null) {\n+            \/\/ if not specified explicitly, compare doc comments if not comparing API descriptions\n+            compareDocComments = !compareApiDescriptions;\n+        }\n+\n+        if (resourceFiles != null) {\n+            for (var resFile : resourceFiles) {\n+                if (resFile.isAbsolute() && !Files.exists(resFile)) {\n+                    \/\/ if it is an absolute path and doesn't exist,\n+                    \/\/ report error, no need to check further\n+                    log.error(\"options.err.resource-file-not-found\", resFile);\n+                } else {\n+                    \/\/ otherwise check that the file is in at least one api directory\n+                    boolean found = false;\n+                    for (var apiOpts : allAPIOptions.values()) {\n+                        var apiDir = apiOpts.apiDir;\n+                        if (apiDir != null) {\n+                            var absApiDir = apiDir.toAbsolutePath();\n+                            if (resFile.isAbsolute() && resFile.startsWith(absApiDir)\n+                                    || Files.exists(absApiDir.resolve(resFile))) {\n+                                found = true;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    if (!found) {\n+                        log.error(\"options.err.resource-file-not-found-in-api-dirs\", resFile);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void checkAPIOptions(APIOptions apiOptions) {\n+        if (apiOptions.jdkBuildDir != null) {\n+            Path dir = apiOptions.jdkBuildDir;\n+            if (!Files.exists(dir.resolve(\"spec.gmk\"))) {\n+                log.error(\"options.err.bad-jdk-build-dir\", apiOptions.name, dir);\n+            } else if (!Files.exists(dir.resolve(\"images\"))) {\n+                log.error(\"options.err.no-images-in-jdk-build-dir\", apiOptions.name, dir);\n+            } else {\n+                JDKBuildOption o = new JDKBuildOption(apiOptions.jdkBuildDir);\n+                o.expand(this, apiOptions, log);\n+            }\n+        }\n+    }\n+\n+    private void checkPattern(Mode mode, String arg) {\n+        String s = arg;\n+        int slash = s.indexOf(\"\/\");\n+        if (slash == -1) {\n+            if (mode == Mode.MODULE) {\n+                log.error(\"options.err.missing-module-name\", arg);\n+            }\n+        } else {\n+            String mdl = s.substring(0, slash);\n+            if (mdl.endsWith(\".*\")) {\n+                mdl = mdl.substring(0, mdl.length() - 2);\n+            }\n+            if (mdl.isEmpty()) {\n+                log.error(\"options.err.empty-module-name\", arg);\n+            } else if (!SourceVersion.isName(mdl, SourceVersion.latestSupported())) {\n+                log.error(\"options.err.bad-module-name\", arg);\n+            } else if (mode == Mode.PACKAGE) {\n+                log.error(\"options.err.unexpected-module-name\", arg);\n+            }\n+            s = s.substring(slash + 1);\n+        }\n+\n+        if (s.equals(\"**\")) {\n+            if (mode == Mode.PACKAGE) {\n+                log.error(\"options.err.bad-package-name\", arg);\n+            }\n+        } else {\n+            String pkg;\n+            if (s.endsWith(\".*\")) {\n+                pkg = s.substring(0, s.length() - 2);\n+            } else if (s.endsWith(\".**\")) {\n+                pkg = s.substring(0, s.length() - 3);\n+            } else {\n+                pkg = s;\n+            }\n+            if (pkg.isEmpty()) {\n+                if (mode == Mode.PACKAGE) {\n+                    log.error(\"options.err.empty-package-name\", arg);\n+                }\n+            } else if (!SourceVersion.isName(pkg, SourceVersion.latestSupported())) {\n+                log.error(\"options.err.bad-package-name\", arg);\n+            }\n+        }\n+    }\n+\n+    private SourceVersion getSourceVersion(String v) {\n+        switch (v) {\n+            case \"1.6\", \"1.7\", \"1.8\", \"1.9\", \"1.10\" -> v = v.substring(2);\n+        }\n+        try {\n+            return SourceVersion.valueOf(\"RELEASE_\" + v);\n+        } catch (IllegalArgumentException e) {\n+            log.error(\"options.err.bad-source\", v);\n+            return SourceVersion.latest();\n+        }\n+    }\n+\n+    void showHelp() {\n+        Messages messages = Messages.instance(\"jdk.codetools.apidiff.resources.help\");\n+        PrintWriter out = log.out;\n+        String header = messages.getString(\"options.usage.header\");\n+        header.lines().forEach(out::println);\n+        for (Option o: Option.values()) {\n+            String argText = o.arg == null ? null : messages.getString(o.arg);\n+            String first = \"\";\n+            for (String name : o.names) {\n+                if (first.isEmpty()) {\n+                    first = name;\n+                } else {\n+                    out.print(\", \");\n+                }\n+                out.print(\" \" + name);\n+                if (argText != null) {\n+                    log.out.print(\" \");\n+                    log.out.print(argText);\n+                }\n+            }\n+            out.println();\n+            String helpTextKey = \"opt.desc.\" + first.replaceAll(\"^-+\", \"\")\n+                    .replaceAll(\"(?i)[^A-Z0-9-]+\", \".\");\n+            String helpText = o.getHelpDescription(messages, helpTextKey);\n+            helpText.lines().forEach(l -> out.println(\"    \" + l));\n+        }\n+    }\n+\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/Options.java","additions":1184,"deletions":0,"binary":false,"changes":1184,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2006, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.codetools.apidiff;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintWriter;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Enumeration;\n+import java.util.Properties;\n+\n+\/**\n+ * A class to access version info from the manifest info in a jar file.\n+ *\/\n+public class Version {\n+    \/**\n+     * Returns the current version.\n+     * @return the current version\n+     *\/\n+    public static Version getCurrent() {\n+        if (currentVersion == null)\n+            currentVersion = new Version();\n+        return currentVersion;\n+    }\n+\n+    private static Version currentVersion;\n+\n+    \/** The name of the product. *\/\n+    public final String product;\n+    \/** The version string. *\/\n+    public final String version;\n+    \/** The milestone. *\/\n+    public final String milestone;\n+    \/** The build number. *\/\n+    public final String build;\n+    \/** The version of Java used to build the jar file. *\/\n+    public final String buildJavaVersion;\n+    \/** The date on which the jar file was built. *\/\n+    public final String buildDate;\n+\n+    private Version() {\n+        Properties manifest = getManifestForClass(getClass());\n+        if (manifest == null)\n+            manifest = new Properties();\n+\n+        String prefix = \"apidiff\";\n+        product = manifest.getProperty(prefix + \"-Name\");\n+        version = manifest.getProperty(prefix + \"-Version\");\n+        milestone = manifest.getProperty(prefix + \"-Milestone\");\n+        build = manifest.getProperty(prefix + \"-Build\");\n+        buildJavaVersion = manifest.getProperty(prefix + \"-BuildJavaVersion\");\n+        buildDate = manifest.getProperty(prefix + \"-BuildDate\");\n+    }\n+\n+    void show(PrintWriter out) {\n+        String thisJavaHome = System.getProperty(\"java.home\");\n+        String thisJavaVersion = System.getProperty(\"java.version\");\n+\n+        File classPathFile = getClassPathFileForClass(Main.class);\n+        String unknown = messages.getString(\"version.msg.unknown\");\n+        String classPath = (classPathFile == null ? unknown : classPathFile.getPath());\n+\n+        Object[] versionArgs = {\n+            product,\n+            version,\n+            milestone,\n+            build,\n+            classPath,\n+            thisJavaVersion,\n+            thisJavaHome,\n+            buildJavaVersion,\n+            buildDate\n+        };\n+\n+        \/*\n+         * Example format string:\n+         *\n+         * {0}, version {1} {2} {3}\n+         * Installed in {4}\n+         * Running on platform version {5} from {6}.\n+         * Built with {7} on {8}.\n+         *\n+         * Example output:\n+         *\n+         * apidiff, version 1.0 dev b00\n+         * Installed in \/usr\/local\/apidiff\/lib\/apidiff.jar\n+         * Running on platform version 1.8 from \/opt\/jdk\/1.8.0.\n+         * Built with 1.8 on 09\/11\/2006 07:52 PM.\n+         *\/\n+\n+        out.println(messages.getString(\"version.msg.info\", versionArgs));\n+    }\n+\n+    private Properties getManifestForClass(Class<?> c) {\n+        URL classPathEntry = getClassPathEntryForClass(c);\n+        if (classPathEntry == null)\n+            return null;\n+\n+        try {\n+            Enumeration<URL> e = getClass().getClassLoader().getResources(\"META-INF\/MANIFEST.MF\");\n+            while (e.hasMoreElements()) {\n+                URL url = e.nextElement();\n+                if (url.getProtocol().equals(\"jar\")) {\n+                    String path = url.getPath();\n+                    int sep = path.lastIndexOf(\"!\");\n+                    URL u = new URL(path.substring(0, sep));\n+                    if (u.equals(classPathEntry )) {\n+                        Properties p = new Properties();\n+                        try (InputStream in = url.openStream()) {\n+                            p.load(in);\n+                        }\n+                        return p;\n+                    }\n+                }\n+            }\n+        } catch (IOException ignore) {\n+        }\n+        return null;\n+    }\n+\n+    private URL getClassPathEntryForClass(Class<?> c) {\n+        try {\n+            URL url = c.getResource(\"\/\" + c.getName().replace('.', '\/') + \".class\");\n+            if (url != null && url.getProtocol().equals(\"jar\")) {\n+                String path = url.getPath();\n+                int sep = path.lastIndexOf(\"!\");\n+                return new URL(path.substring(0, sep));\n+            }\n+        } catch (MalformedURLException ignore) {\n+        }\n+        return null;\n+    }\n+\n+    private File getClassPathFileForClass(Class<?> c) {\n+        URL url = getClassPathEntryForClass(c);\n+        if (url.getProtocol().equals(\"file\"))\n+            return new File(url.getPath());\n+        return null;\n+    }\n+\n+    private final Messages messages = Messages.instance(\"jdk.codetools.apidiff.resources.log\");\n+\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/Version.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.html;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+\/**\n+ * Superclass for all items in an HTML tree.\n+ *\/\n+public abstract class Content {\n+    \/**\n+     * An empty item, which does not generate any output when written to a stream.\n+     *\/\n+    public static final Content empty = new Content() {\n+        @Override\n+        protected void write(Writer out) throws IOException { }\n+    };\n+\n+    \/**\n+     * Writes this object as a fragment of HTML.\n+     *\n+     * @param out the writer\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    protected abstract void write(Writer out) throws IOException;\n+\n+    \/**\n+     * Writes a string, escaping characters {@code <}, {@code >}, {@code &}.\n+     *\n+     * @param out the writer\n+     * @param s   the string\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    protected void writeEscaped(Writer out, String s) throws IOException {\n+        for (int i = 0; i < s.length(); i++) {\n+            char ch = s.charAt(i);\n+            switch (ch) {\n+                case '<' -> out.write(\"&lt;\");\n+                case '>' -> out.write(\"&gt;\");\n+                case '&' -> out.write(\"&amp;\");\n+                default ->  out.write(ch);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/html\/Content.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.html;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+\/**\n+ * An HTML entity.\n+ *\n+ * @see <a href=\"home.unicode.org\">Unicode<\/a>\n+ * @see <a href=\"https:\/\/www.fileformat.info\/info\/unicode\/\">FileFormat.info Unicode<\/a>\n+ *\/\n+public class Entity extends Content {\n+    \/** Unicode CHECK MARK. *\/\n+    public static final Entity CHECK = new Entity(\"check\", 0x2713);\n+    \/** Unicode CIRCLED DIGIT ONE. *\/\n+    public static final Entity CIRCLED_DIGIT_ONE = new Entity(null, 0x2460);\n+    \/** Unicode DINGBAT NEGATIVE CIRCLED DIGIT ONE. *\/\n+    public static final Entity NEGATIVE_CIRCLED_DIGIT_ONE = new Entity(null, 0x2776);\n+    \/** Unicode BALLOT X. *\/\n+    public static final Entity CROSS = new Entity(\"cross\", 0x2717);\n+    \/** Unicode EQUALS SIGN. *\/\n+    public static final Entity EQUALS = new Entity(\"equals\", 0x3d);\n+    \/** Unicode NOT EQUAL TO. *\/\n+    public static final Entity NE = new Entity(\"ne\", 0x2260);\n+    \/** Unicode NO-BREAK SPACE. *\/\n+    public static final Entity NBSP = new Entity(\"nbsp\", 0xa0);\n+\n+    private static final boolean useNumericEntities = Boolean.getBoolean(\"useNumericEntities\");\n+\n+    private final String name;\n+    private final int value;\n+\n+    private Entity(String name, int value) {\n+        this.name = name;\n+        this.value = value;\n+    }\n+\n+    @Override\n+    protected void write(Writer out) throws IOException {\n+        out.write(\"&\");\n+        out.write(name == null || useNumericEntities ? String.format(\"#x%x\", value) : name);\n+        out.write(\";\");\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/html\/Entity.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.html;\n+\n+import java.util.Locale;\n+\n+\/**\n+ * HTML attributes for {@code HtmlTree} nodes.\n+ *\n+ * This should be a superset of the attributes that may be generated by the standard doclet.\n+ * However, we still need to be able to cope with unknown attributes, such as may be found\n+ * in user doc-comments.\n+ *\/\n+public enum HtmlAttr {\n+    ALT,\n+    ARIA_CONTROLS(\"aria-controls\"),\n+    ARIA_EXPANDED(\"aria-expanded\"),\n+    ARIA_LABEL(\"aria-label\"),\n+    ARIA_LABELLEDBY(\"aria-labelledby\"),\n+    ARIA_ORIENTATION(\"aria-orientation\"),\n+    ARIA_SELECTED(\"aria-selected\"),\n+    CHANGETYPE,\n+    CHARSET,\n+    CHECKED,\n+    CLASS,\n+    CLEAR,\n+    COLS,\n+    COLSPAN,\n+    CONTENT,\n+    DATA_COPIED(\"data-copied\"), \/\/ custom HTML5 data attribute\n+    DISABLED,\n+    DOWNLOAD,\n+    FOR,\n+    HEADERS,\n+    HEIGHT,\n+    HREF,\n+    HTTP_EQUIV(\"http-equiv\"),\n+    ID,\n+    LANG,\n+    NAME,\n+    ONCLICK,\n+    ONKEYDOWN,\n+    ONLOAD,\n+    PLACEHOLDER,\n+    REL,\n+    ROLE,\n+    ROWS,\n+    ROWSPAN,\n+    SCOPE,\n+    SCROLLING,\n+    SIZES,\n+    SRC,\n+    STYLE,\n+    SUMMARY,\n+    TABINDEX,\n+    TARGET,\n+    TITLE,\n+    TYPE,\n+    VALUE,\n+    WIDTH;\n+\n+    private final String value;\n+\n+    HtmlAttr() {\n+        this.value = name().toLowerCase(Locale.ROOT);\n+    }\n+\n+    HtmlAttr(String name) {\n+        this.value = name;\n+    }\n+\n+    public String toString() {\n+        return value;\n+    }\n+\n+    public static HtmlAttr of(String name) {\n+        return valueOf(name.toUpperCase(Locale.ROOT).replace(\"-\", \"_\"));\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/html\/HtmlAttr.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,588 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.html;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * An HTML element.\n+ *\/\n+public final class HtmlTree extends Content {\n+\n+    private static final boolean coalesceText = Boolean.getBoolean(\"coalesceText\");\n+\n+\n+    \/\/-----------------------------------------------------\n+    \/\/\n+    \/\/ Head items\n+\n+    \/**\n+     * Creates a {@code <head>} with a given charset and title.\n+     *\n+     * @param charset the charset\n+     * @param title the title\n+     * @return the {@code <head>} element\n+     *\/\n+    public static HtmlTree HEAD(String charset, String title) {\n+        return new HtmlTree(TagName.HEAD)\n+                .add(new HtmlTree(TagName.META)\n+                        .set(HtmlAttr.CHARSET, charset))\n+                .add(new HtmlTree(TagName.TITLE).add(title));\n+    }\n+\n+    \/**\n+     * Creates a {@code <base>} with a given {@code href} attribute.\n+     *\n+     * @param href the value for the {@code href} attribute\n+     * @return the {@code <base>} element\n+     *\/\n+    public static HtmlTree BASE(String href) {\n+        return new HtmlTree(TagName.BASE)\n+                .set(HtmlAttr.HREF, encodeURL(href));\n+    }\n+\n+    \/**\n+     * Creates a {@code <link>} with a given {@code rel} and {@code href} attributes.\n+     *\n+     * @param rel the value for the {@code rel} attribute\n+     * @param href the value for the {@code href} attribute\n+     * @return the {@code <link>} element\n+     *\/\n+    public static HtmlTree LINK(String rel, String href) {\n+        return new HtmlTree(TagName.LINK)\n+                .set(HtmlAttr.REL, rel)\n+                .set(HtmlAttr.TYPE, MediaType.forPath(href).contentType)\n+                .set(HtmlAttr.HREF, encodeURL(href));\n+    }\n+\n+    \/**\n+     * Creates a {@code <link>} for an icon for the page.\n+     *\n+     * @param iconURI the value for the {@code href} attribute\n+     * @return the {@code <link>} element\n+     *\/\n+    public static HtmlTree LINK_ICON(String iconURI) {\n+        \/\/ see https:\/\/stackoverflow.com\/questions\/48956465\/favicon-standard-2018-svg-ico-png-and-dimensions\n+        \/\/ for suggestion that IE expects \"shortcut icon\"\n+        HtmlTree link =  LINK(\"icon\", iconURI);\n+        Pattern p = Pattern.compile(\"[0-9]+x[0-9]+\");\n+        Matcher m = p.matcher(iconURI);\n+        if (m.find()) {\n+            link.set(HtmlAttr.SIZES, m.group(0));\n+        }\n+        return link;\n+    }\n+\n+    \/**\n+     * Creates a {@code <link>} for a stylesheet for the page.\n+     *\n+     * @param stylesheetURI the value for the {@code href} attribute\n+     * @return the {@code <link>} element\n+     *\/\n+    public static HtmlTree LINK_STYLESHEET(String stylesheetURI) {\n+        return LINK(\"stylesheet\", stylesheetURI);\n+    }\n+\n+    \/**\n+     * Creates a {@code <meta>} element with given name and content attributes.\n+     *\n+     * @param name the value for the {@code name} attribute\n+     * @param content the value for the {@code content} attribute\n+     * @return the {@code <meta>} element\n+     *\/\n+    public static HtmlTree META(String name, String content) {\n+        return new HtmlTree(TagName.META)\n+                .set(HtmlAttr.NAME, name)\n+                .set(HtmlAttr.CONTENT, content);\n+    }\n+\n+    \/**\n+     * Creates a {@code <meta>} element for a default viewport.\n+     *\n+     * @return the {@code <meta>} element\n+     *\/\n+    public static HtmlTree META_VIEWPORT() {\n+        return META_VIEWPORT(\"width=device-width, initial-scale=1.0\");\n+    }\n+\n+    \/**\n+     * Creates a {@code <meta>} element for a specific viewport.\n+     *\n+     * @param content the value for the {@code content} attribute\n+     * @return the {@code <meta>} element\n+     *\/\n+    public static HtmlTree META_VIEWPORT(String content) {\n+        return META(\"viewport\", content);\n+    }\n+\n+    \/\/-----------------------------------------------------\n+    \/\/\n+    \/\/ Body, regions, div\n+\n+\n+    public static HtmlTree BODY() {\n+        return new HtmlTree(TagName.BODY);\n+    }\n+\n+    public static HtmlTree BODY(List<Content> contents) {\n+        return new HtmlTree(TagName.BODY, contents);\n+    }\n+\n+    public static HtmlTree HEADER(Content... contents) {\n+        return new HtmlTree(TagName.HEADER, contents);\n+    }\n+\n+    public static HtmlTree MAIN(Content... contents) {\n+        return new HtmlTree(TagName.MAIN, contents);\n+    }\n+\n+    public static HtmlTree NAV(Content... contents) {\n+        return new HtmlTree(TagName.NAV, contents);\n+    }\n+\n+    public static HtmlTree FOOTER(Content... contents) {\n+        return new HtmlTree(TagName.FOOTER, contents);\n+    }\n+\n+    public static HtmlTree DIV(Content... contents) {\n+        return new HtmlTree(TagName.DIV, contents);\n+    }\n+\n+    public static HtmlTree DIV(List<? extends Content> contents) {\n+        return new HtmlTree(TagName.DIV, contents);\n+    }\n+    public static HtmlTree SECTION(Content... contents) {\n+        return new HtmlTree(TagName.SECTION, contents);\n+    }\n+\n+    public static HtmlTree SECTION(List<? extends Content> contents) {\n+        return new HtmlTree(TagName.SECTION, contents);\n+    }\n+\n+    public static HtmlTree PRE(Content... contents) {\n+        return new HtmlTree(TagName.PRE, contents);\n+    }\n+\n+    public static HtmlTree PRE(List<Content> contents) {\n+        return new HtmlTree(TagName.PRE, contents);\n+    }\n+\n+    public static HtmlTree DETAILS(Content... contents) {\n+        return new HtmlTree(TagName.DETAILS, contents);\n+    }\n+\n+    public static HtmlTree SUMMARY(Content... contents) {\n+        return new HtmlTree(TagName.SUMMARY, contents);\n+    }\n+\n+    \/\/-----------------------------------------------------\n+    \/\/\n+    \/\/ Headers\n+\n+    public static HtmlTree H1(Content... contents) {\n+        return new HtmlTree(TagName.H1, contents);\n+    }\n+\n+    public static HtmlTree H2(Content... contents) {\n+        return new HtmlTree(TagName.H2, contents);\n+    }\n+\n+    public static HtmlTree H3(Content... contents) {\n+        return new HtmlTree(TagName.H3, contents);\n+    }\n+\n+    \/\/-----------------------------------------------------\n+    \/\/\n+    \/\/ Table items\n+\n+    public static HtmlTree TABLE(Content... contents) {\n+        return new HtmlTree(TagName.TABLE, contents);\n+    }\n+\n+    public static HtmlTree CAPTION(Content... contents) {\n+        return new HtmlTree(TagName.CAPTION, contents);\n+    }\n+\n+    public static HtmlTree THEAD(Content... contents) {\n+        return new HtmlTree(TagName.THEAD, contents);\n+    }\n+\n+    public static HtmlTree TBODY(Content... contents) {\n+        return new HtmlTree(TagName.TBODY, contents);\n+    }\n+\n+    public static HtmlTree TFOOT(Content... contents) {\n+        return new HtmlTree(TagName.TFOOT, contents);\n+    }\n+\n+    public static HtmlTree TR(Content... contents) {\n+        return new HtmlTree(TagName.TR, contents);\n+    }\n+\n+    public static HtmlTree TH(Content... contents) {\n+        return new HtmlTree(TagName.TH, contents);\n+    }\n+\n+    public static HtmlTree TD(Content... contents) {\n+        return new HtmlTree(TagName.TD, contents);\n+    }\n+\n+    \/\/-----------------------------------------------------\n+    \/\/\n+    \/\/ List items\n+\n+    public static HtmlTree UL(Content... contents) {\n+        return new HtmlTree(TagName.UL, contents);\n+    }\n+\n+    public static HtmlTree UL(List<? extends Content> contents) {\n+        return new HtmlTree(TagName.UL, contents);\n+    }\n+\n+    public static HtmlTree OL(Content... contents) {\n+        return new HtmlTree(TagName.OL, contents);\n+    }\n+\n+    public static HtmlTree LI(Content... contents) {\n+        return new HtmlTree(TagName.LI, contents);\n+    }\n+\n+    public static HtmlTree LI(List<Content> contents) {\n+        return new HtmlTree(TagName.LI, contents);\n+    }\n+\n+    public static HtmlTree DL(Content... contents) {\n+        return new HtmlTree(TagName.DL, contents);\n+    }\n+\n+    public static HtmlTree DT(Content... contents) {\n+        return new HtmlTree(TagName.DT, contents);\n+    }\n+\n+    public static HtmlTree DD(Content... contents) {\n+        return new HtmlTree(TagName.DD, contents);\n+    }\n+\n+    \/\/-----------------------------------------------------\n+    \/\/\n+    \/\/ Basic text items\n+\n+    public static HtmlTree A(String href, Content... contents) {\n+        return new HtmlTree(TagName.A)\n+                .set(HtmlAttr.HREF, encodeURL(href))\n+                .add(contents);\n+    }\n+\n+    public static HtmlTree A(URI href, Content... contents) {\n+        return A(href.toString(), contents);\n+    }\n+\n+    public static HtmlTree B(Content... contents) {\n+        return new HtmlTree(TagName.B, contents);\n+    }\n+\n+    public static HtmlTree P(Content... contents) {\n+        return new HtmlTree(TagName.P, contents);\n+    }\n+\n+    public static HtmlTree SPAN(Content... contents) {\n+        return new HtmlTree(TagName.SPAN, contents);\n+    }\n+\n+    public static HtmlTree SPAN(List<Content> contents) {\n+        return new HtmlTree(TagName.SPAN, contents);\n+    }\n+\n+    \/\/-----------------------------------------------------\n+    \/\/\n+    \/\/ An HTMLTree is a tag name, a collection of attributes and a sequence of contents.\n+    \/\/ The tag name is normally represented by a TagName, but we need to model the\n+    \/\/ HTML being compared in HtmlDiffBuilder, which may use tag names that are not\n+    \/\/ present in the TagName enum. Likewise, the attribute names are normally\n+    \/\/ represented by HtmlAttr, but we need to model attributes that are not present\n+    \/\/ in the enum.  Therefore, both the tag name and attribute name are represented\n+    \/\/ by an Object, which is either the relevant enum, or a normalized (upper-case)\n+    \/\/ string.\n+\n+    private final Object tag;  \/\/ TagName or String\n+    private final Map<Object, String> attrs; \/\/ key is HtmlAttr or String\n+    private final List<Content> contents;\n+\n+    public HtmlTree(TagName tag) {\n+        this.tag = tag;\n+        attrs = new LinkedHashMap<>();\n+        contents = new ArrayList<>();\n+    }\n+\n+    public HtmlTree(String tag) {\n+        this.tag = tag.toUpperCase(Locale.ROOT);\n+        attrs = new LinkedHashMap<>();\n+        contents = new ArrayList<>();\n+    }\n+\n+    public HtmlTree(TagName tag, Content... contents) {\n+        this(tag);\n+        add(contents);\n+    }\n+\n+    public HtmlTree(TagName tag, List<? extends Content> contents) {\n+        this(tag);\n+        add(contents);\n+    }\n+\n+    public HtmlTree add(Content content) {\n+        if (coalesceText && !contents.isEmpty()) {\n+            if (content instanceof Text) {\n+                return add(((Text) content).s);\n+            } else {\n+                Content c = contents.get(contents.size() - 1);\n+                if (c instanceof TextBuilder) {\n+                    ((TextBuilder) c).trimToSize();\n+                }\n+            }\n+        }\n+        contents.add(content);\n+        return this;\n+    }\n+\n+    public HtmlTree add(Content... contents) {\n+        List.of(contents).forEach(this::add);\n+        return this;\n+    }\n+\n+    public HtmlTree add(List<? extends Content> contents) {\n+        contents.forEach(this::add);\n+        return this;\n+    }\n+\n+    public HtmlTree add(Stream<? extends Content> contents) {\n+        contents.forEach(this::add);\n+        return this;\n+    }\n+\n+    public HtmlTree add(CharSequence text) {\n+        if (text.length() == 0) {\n+            return this;\n+        }\n+\n+        if (coalesceText && !contents.isEmpty()) {\n+            Content c = contents.get(contents.size() - 1);\n+            if (c instanceof TextBuilder) {\n+                ((TextBuilder) c).append(text);\n+                return this;\n+            } else if (c instanceof Text) {\n+                TextBuilder mt = new TextBuilder(((Text) c).s).append(text);\n+                contents.set(contents.size() - 1, mt);\n+                return this;\n+            }\n+        }\n+\n+        contents.add(new Text(text));\n+        return this;\n+    }\n+\n+    public String getTagString() {\n+        return (tag instanceof TagName) ? ((TagName) tag).name() : ((String) tag);\n+    }\n+\n+    public boolean hasTag(TagName t) {\n+        return tag == t;\n+    }\n+\n+    public boolean hasTag(String t) {\n+        return getTagString().equalsIgnoreCase(t);\n+    }\n+\n+    public String get(HtmlAttr attr) {\n+        return attrs.get(attr);\n+    }\n+\n+    public HtmlTree set(HtmlAttr attr, String value) {\n+        attrs.put(attr, value);\n+        return this;\n+    }\n+\n+    public HtmlTree set(String unknownAttr, String value) {\n+        attrs.put(unknownAttr, value);\n+        return this;\n+    }\n+\n+\n+    public HtmlTree setId(String id) {\n+        return set(HtmlAttr.ID, id);\n+    }\n+\n+    public HtmlTree setClass(String id) {\n+        return set(HtmlAttr.CLASS, id);\n+    }\n+\n+    public HtmlTree setTitle(String text) {\n+        return set(HtmlAttr.TITLE, text);\n+    }\n+\n+    public List<Content> contents() {\n+        return contents;\n+    }\n+\n+    @Override\n+    public void write(Writer out) throws IOException {\n+        if (tag == TagName.HTML) {\n+            out.write(\"<!DOCTYPE html>\\n\");\n+        }\n+        out.write(\"<\");\n+        out.write(toLowerCase(tag));\n+        for (Map.Entry<Object, String> e : attrs.entrySet()) {\n+            out.write(\" \");\n+            out.write(toLowerCase(e.getKey()));\n+            if (e.getValue() != null) {\n+                out.write(\"=\\\"\");\n+                writeEscaped(out, e.getValue());  \/\/ should also escape \" as &quot;\n+                out.write(\"\\\"\");\n+            }\n+        }\n+        out.write(\">\");\n+        for (Content c : contents) {\n+            c.write(out);\n+        }\n+\n+        if (tag instanceof TagName) {\n+            var tn = (TagName) tag;\n+            switch (tn) {\n+                case BASE:\n+                case LINK:\n+                case META:\n+                case BR:\n+                case HR:\n+                    break;\n+                default:\n+                    out.write(\"<\/\");\n+                    out.write(toLowerCase(tag));\n+                    out.write(\">\");\n+            }\n+\n+            switch (tn) {\n+                case A:\n+                case B:\n+                case I:\n+                case LI:\n+                case SPAN:\n+                    break;\n+                default:\n+                    out.write(\"\\n\");\n+            }\n+        } else {\n+            out.write(\"<\/\");\n+            out.write(toLowerCase(tag));\n+            out.write(\">\");\n+        }\n+    }\n+\n+    private String toLowerCase(Object o) {\n+        return (o instanceof Enum ? ((Enum) o).name() : o.toString()).toLowerCase(Locale.ROOT);\n+    }\n+\n+\n+\n+    \/*\n+     * The sets of ASCII URI characters to be left unencoded.\n+     * See \"Uniform Resource Identifier (URI): Generic Syntax\"\n+     * IETF RFC 3986. https:\/\/tools.ietf.org\/html\/rfc3986\n+     *\/\n+    public static final BitSet MAIN_CHARS;\n+    public static final BitSet QUERY_FRAGMENT_CHARS;\n+\n+    static {\n+        BitSet alphaDigit = bitSet(bitSet('A', 'Z'), bitSet('a', 'z'), bitSet('0', '9'));\n+        BitSet unreserved = bitSet(alphaDigit, bitSet(\"-._~\"));\n+        BitSet genDelims = bitSet(\":\/?#[]@\");\n+        BitSet subDelims = bitSet(\"!$&'()*+,;=\");\n+        MAIN_CHARS = bitSet(unreserved, genDelims, subDelims);\n+        BitSet pchar = bitSet(unreserved, subDelims, bitSet(\":@\"));\n+        QUERY_FRAGMENT_CHARS = bitSet(pchar, bitSet(\"\/?\"));\n+    }\n+\n+    private static BitSet bitSet(String s) {\n+        BitSet result = new BitSet();\n+        for (int i = 0; i < s.length(); i++) {\n+            result.set(s.charAt(i));\n+        }\n+        return result;\n+    }\n+\n+    private static BitSet bitSet(char from, char to) {\n+        BitSet result = new BitSet();\n+        result.set(from, to + 1);\n+        return result;\n+    }\n+\n+    private static BitSet bitSet(BitSet... sets) {\n+        BitSet result = new BitSet();\n+        for (BitSet set : sets) {\n+            result.or(set);\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Apply percent-encoding to a URL.\n+     * This is similar to {@link java.net.URLEncoder} but\n+     * is less aggressive about encoding some characters,\n+     * like '(', ')', ',' which are used in the anchor\n+     * names for Java methods in HTML5 mode.\n+     *\n+     * @param url the url to be percent-encoded.\n+     * @return a percent-encoded string.\n+     *\/\n+    public static String encodeURL(String url) {\n+        BitSet nonEncodingChars = MAIN_CHARS;\n+        StringBuilder sb = new StringBuilder();\n+        for (byte c : url.getBytes(StandardCharsets.UTF_8)) {\n+            if (c == '?' || c == '#') {\n+                sb.append((char) c);\n+                \/\/ switch to the more restrictive set inside\n+                \/\/ the query and\/or fragment\n+                nonEncodingChars = QUERY_FRAGMENT_CHARS;\n+            } else if (nonEncodingChars.get(c & 0xFF)) {\n+                sb.append((char) c);\n+            } else {\n+                sb.append(String.format(\"%%%02X\", c & 0xFF));\n+            }\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/html\/HtmlTree.java","additions":588,"deletions":0,"binary":false,"changes":588,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.html;\n+\n+\/**\n+ * A media-type, for use in {@code <link>} nodes.\n+ *\/\n+ public enum MediaType {\n+    IMAGE_GIF(\"image\/gif\"),\n+     \/\/ see https:\/\/stackoverflow.com\/questions\/13827325\/correct-mime-type-for-favicon-ico\n+    IMAGE_ICON(\"image\/vnd.microsoft.icon\"),\n+    IMAGE_JPEG(\"image\/jpeg\"),\n+    IMAGE_PNG(\"image\/png\"),\n+    TEXT_CSS(\"text\/css; charset=UTF-8\"),\n+    TEXT_HTML(\"text\/html; charset=UTF-8\"),\n+    TEXT_PLAIN(\"text\/plain; charset=UTF-8\");\n+\n+    public final String contentType;\n+\n+    MediaType(String contentType) {\n+        this.contentType = contentType;\n+    }\n+\n+    \/**\n+     * Infers the media type for a file, based on the filename extension.\n+     *\n+     * @param path the path for the file\n+     *\n+     * @return the media type\n+     *\/\n+    public static MediaType forPath(String path){\n+        if (path.endsWith(\".css\")) {\n+            return MediaType.TEXT_CSS;\n+        } else if (path.endsWith(\".html\")) {\n+            return MediaType.TEXT_HTML;\n+        } else if (path.endsWith(\".txt\")) {\n+            return MediaType.TEXT_PLAIN;\n+        } else if (path.endsWith(\".png\")) {\n+            return MediaType.IMAGE_PNG;\n+        } else if (path.endsWith(\".jpg\")) {\n+            return MediaType.IMAGE_JPEG;\n+        } else if (path.endsWith(\".ico\")) {\n+            return MediaType.IMAGE_ICON;\n+        } else if (path.endsWith(\".gif\")) {\n+            return MediaType.IMAGE_GIF;\n+        } else {\n+           throw new IllegalArgumentException(path);\n+        }\n+    }\n+\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/html\/MediaType.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.html;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+\/**\n+ * A fragment of raw HTML.\n+ *\/\n+public class RawHtml extends Content {\n+    private final String html;\n+\n+    \/**\n+     * Creates an object containing raw HTML. No additional escaping is provided,\n+     * @param html the HTML\n+     *\/\n+    public RawHtml(String html) {\n+        this.html = html;\n+    }\n+\n+    @Override\n+    protected void write(Writer out) throws IOException {\n+        out.write(html);\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/html\/RawHtml.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.html;\n+\n+import java.util.Locale;\n+\n+\/**\n+ * Tags for {@code HtmlTree} nodes.\n+ *\n+ * This should be a superset of the tags that may be generated by the standard doclet.\n+ * However, we still need to be able to cope with unknown tags, such as may be found\n+ * in user doc-comments.\n+ *\/\n+public enum TagName {\n+    A,\n+    B,\n+    BASE,\n+    BLOCKQUOTE,\n+    BODY,\n+    BR,\n+    BUTTON,\n+    CAPTION,\n+    CITE,\n+    CODE,\n+    COL,\n+    COLGROUP,\n+    DD,\n+    DETAILS,\n+    DFN,\n+    DIV,\n+    DL,\n+    DT,\n+    EM,\n+    FOOTER,\n+    FORM,\n+    H1, H2, H3, H4, H5, H6,\n+    HEAD,\n+    HEADER,\n+    HR,\n+    HTML,\n+    I,\n+    IMG,\n+    INPUT,\n+    LABEL,\n+    LI,\n+    LISTING,\n+    LINK,\n+    MAIN,\n+    MENU,\n+    META,\n+    NAV,\n+    NOSCRIPT,\n+    OL,\n+    P,\n+    PRE,\n+    SAMP,\n+    SCRIPT,\n+    SECTION,\n+    SMALL,\n+    SPAN,\n+    STRONG,\n+    STYLE,\n+    SUB,\n+    SUMMARY,\n+    SUP,\n+    TABLE,\n+    TBODY,\n+    TD,\n+    TFOOT,\n+    TH,\n+    THEAD,\n+    TITLE,\n+    TR,\n+    U,\n+    UL,\n+    VAR,\n+    WBR;\n+\n+    public static TagName of(String name) {\n+        return valueOf(name.toUpperCase(Locale.ROOT));\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/html\/TagName.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.html;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+\/**\n+ * Textual content.\n+ *\n+ * @see TextBuilder\n+ *\/\n+public class Text extends Content {\n+    \/\/ TODO: provide additional constants (somewhere?) for common strings\n+\n+    \/**\n+     * An object providing a single space character.\n+     *\n+     * @see Entity#NBSP\n+     *\/\n+    public static final Text SPACE = new Text(\" \");\n+\n+    final String s;\n+\n+    \/**\n+     * Creates textual content from a sequence of characters.\n+     *\n+     * @param text the characters\n+     * @return the textual content\n+     *\/\n+    public static Text of(CharSequence text) {\n+        return new Text(text);\n+    }\n+\n+    \/**\n+     * Creates textual content from a sequence of characters.\n+     *\n+     * @param text the characters\n+     *\/\n+    public Text(String text) {\n+        s = text;\n+    }\n+\n+    \/**\n+     * Creates textual content from a sequence of characters.\n+     *\n+     * @param text the characters\n+     *\/\n+    public Text(CharSequence text) {\n+        s = text.toString();\n+    }\n+\n+    \/**\n+     * Writes the content.\n+     * Special characters ('{@code <}', '{@code &}' and '{@code >}') will be escaped.\n+     *\n+     * @param out the stream to which to write the content\n+     * @throws IOException if an IO exception occurs.\n+     *\/\n+    @Override\n+    public void write(Writer out) throws IOException {\n+        writeEscaped(out, s);\n+    }\n+\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/html\/Text.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.html;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+\/**\n+ * Class for generating string content for {@code HTMLTree} nodes.\n+ * The content is mutable to the extent that additional content may be added.\n+ *\n+ * @see Text\n+ *\/\n+public class TextBuilder extends Content {\n+\n+    private final StringBuilder sb;\n+\n+    \/**\n+     * Creates a mutable container for textual content.\n+     *\n+     * @param text the initial content\n+     *\/\n+    public TextBuilder(CharSequence text) {\n+        sb = new StringBuilder(text);\n+    }\n+\n+    \/**\n+     * Append additional characters to the content.\n+     *\n+     * @param text the characters\n+     *\n+     * @return this object\n+     *\/\n+    public TextBuilder append(CharSequence text) {\n+        sb.append(text);\n+        return this;\n+    }\n+\n+    \/**\n+     * Trims the size of the internal string builder.\n+     *\n+     * @return this object\n+     *\/\n+    TextBuilder trimToSize() {\n+        sb.trimToSize();\n+        return this;\n+    }\n+\n+    \/**\n+     * Writes the content.\n+     * Special characters ('{@code <}', '{@code &}' and '{@code >}') will be escaped.\n+     *\n+     * @param out the stream to which to write the content\n+     *\n+     * @throws IOException if an IO exception occurs.\n+     *\/\n+    @Override\n+    public void write(Writer out) throws IOException {\n+        writeEscaped(out, sb.toString());\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/html\/TextBuilder.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Utilities for building HTML trees and writing them to files.\n+ *\/\n+package jdk.codetools.apidiff.html;\n\\ No newline at end of file\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/html\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,1128 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ElementVisitor;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.Name;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.ArrayType;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.ErrorType;\n+import javax.lang.model.type.ExecutableType;\n+import javax.lang.model.type.IntersectionType;\n+import javax.lang.model.type.NoType;\n+import javax.lang.model.type.NullType;\n+import javax.lang.model.type.PrimitiveType;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.type.TypeVariable;\n+import javax.lang.model.type.TypeVisitor;\n+import javax.lang.model.type.UnionType;\n+import javax.lang.model.type.WildcardType;\n+import javax.lang.model.util.Elements;\n+import javax.lang.model.util.Types;\n+import javax.tools.Diagnostic;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileManager.Location;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.StandardLocation;\n+import javax.tools.ToolProvider;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.util.DocTrees;\n+import com.sun.source.util.JavacTask;\n+\n+import jdk.codetools.apidiff.Log;\n+import jdk.codetools.apidiff.Options.APIOptions;\n+\n+\/**\n+ * An abstraction of an API, as represented by some combination of source files,\n+ * class files, and generated documentation.\n+ *\/\n+public abstract class API {\n+    private static final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+\n+    \/**\n+     * Creates an API object for the given parameters.\n+     *\n+     * @param opts  the options to configure the API\n+     * @param s     a selector to filter the set of modules, packages and types to be compared\n+     * @param ak    the access kind, to filter the set of elements to be compared according\n+     *              their declared access\n+     * @param log   a log, to which any problems will be reported\n+     *\n+     * @return the API\n+     *\/\n+    public static API of(APIOptions opts, Selector s, AccessKind ak, Log log) {\n+        return new JavacAPI(opts, s, ak, log);\n+    }\n+\n+    \/**\n+     * The name of the API, as provided in the API options.\n+     *\/\n+    public final String name;\n+\n+    \/**\n+     * A short plain text label for the API, as provided in the API options.\n+     *\/\n+    public final String label;\n+\n+    \/**\n+     * The selector to filter the set of modules, packages and types to be compared.\n+     *\/\n+    protected final Selector selector;\n+\n+    \/**\n+     * The access kind, to filter the set of elements to be compared according\n+     * their declared access.\n+     *\/\n+    protected final AccessKind accessKind;\n+\n+    \/**\n+     * The log, to which any problems will be reported.\n+     *\/\n+    protected final Log log;\n+\n+    \/**\n+     * The file manager used to read files, derived from the API options.\n+     *\/\n+    protected final StandardJavaFileManager fileManager;\n+\n+    \/**\n+     * Creates an instance of an API.\n+     *\n+     * @param opts  the options for the API\n+     * @param s     the selector for the elements to be compared\n+     * @param ak    the access kind for the elements to be compared\n+     * @param log   the log, to which any any problems will be reported\n+     *\/\n+    protected API(APIOptions opts, Selector s, AccessKind ak, Log log) {\n+        this.name = opts.name;\n+        this.label = opts.label;\n+        this.selector = s;\n+        this.accessKind = ak;\n+        this.log = log;\n+\n+        fileManager = compiler.getStandardFileManager(null, null, null);\n+    }\n+\n+    \/**\n+     * Returns the set of packages to be compared that are defined in this API.\n+     *\n+     * @return the package to be compared\n+     *\/\n+    public abstract Set<PackageElement> getPackageElements();\n+\n+    \/**\n+     * Returns the set of modules to be compared that are defined in this API.\n+     *\n+     * @return the modules to be compared\n+     *\/\n+    public abstract Set<ModuleElement> getModuleElements();\n+\n+    \/**\n+     * Returns the set of packages to be compared that are defined in this API in a given module.\n+     *\n+     * @param m the module\n+     *\n+     * @return the packages to be compared\n+     *\/\n+    public abstract Set<PackageElement> getPackageElements(ModuleElement m);\n+\n+    \/**\n+     * Returns the set of packages to be compared that are defined in this API\n+     * and exported to all modules by a given module.\n+     *\n+     * @param m the module\n+     *\n+     * @return the packages to be compared\n+     *\/\n+    public abstract Set<PackageElement> getExportedPackageElements(ModuleElement m);\n+\n+    \/**\n+     * Returns the set of types to be compared that are defined in this API in a given package.\n+     *\n+     * @param p the module\n+     *\n+     * @return the packages to be compared\n+     *\/\n+    public abstract Set<TypeElement> getTypeElements(PackageElement p);\n+\n+    \/**\n+     * Returns the collection of annotation values, including defaults, for a given annotation mirror.\n+     *\n+     * @param am the annotation mirror\n+     *\n+     * @return the collection of annotation values\n+     *\/\n+    public abstract Map<? extends ExecutableElement, ? extends AnnotationValue> getAnnotationValuesWithDefaults(AnnotationMirror am);\n+\n+    \/**\n+     * Returns whether the annotation type of an annotation is {@code @Documented}.\n+     *\n+     * @param am the annotation\n+     *\n+     * @return {@code true} if and only if the type of the annotation is {@code @Documented}\n+     *\/\n+    public boolean isDocumented(AnnotationMirror am) {\n+        TypeElement te = (TypeElement) am.getAnnotationType().asElement();\n+        for (AnnotationMirror a : te.getAnnotationMirrors()) {\n+            Name n = ((TypeElement) a.getAnnotationType().asElement()).getQualifiedName();\n+            if (n.contentEquals(\"java.lang.annotation.Documented\")) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns the serialized form for a type element, or null if none.\n+     *\n+     * @param e the type element\n+     *\n+     * @return the serialized form\n+     *\/\n+    public abstract SerializedForm getSerializedForm(TypeElement e);\n+\n+    \/**\n+     * Returns the parsed documentation comment for a given element.\n+     *\n+     * @param e the element\n+     *\n+     * @return the doc comment tree\n+     *\/\n+    public abstract DocCommentTree getDocComment(Element e);\n+\n+    \/**\n+     * Returns the parsed documentation comment in a given file.\n+     * The file must be an HTML file.\n+     *\n+     * @param fo the file object\n+     *\n+     * @return the doc comment tree\n+     *\/\n+    public abstract DocCommentTree getDocComment(JavaFileObject fo);\n+\n+    \/**\n+     * Returns the API description for a given element, extracted from the API documentation.\n+     *\n+     * @param e the element\n+     *\n+     * @return the API description\n+     *\/\n+    public abstract String getApiDescription(Element e);\n+\n+    \/**\n+     * Returns the API description in a given file.\n+     * The file must be an HTML file.\n+     *\n+     * @param fo the file object\n+     *\n+     * @return the API description\n+     *\/\n+    public abstract String getApiDescription(JavaFileObject fo);\n+\n+    \/**\n+     * Returns the content of a file as an array of bytes, or null if there is\n+     * an error reading the file.\n+     *\n+     * @param fo the file\n+     *\n+     * @return the bytes\n+     *\/\n+    public abstract byte[] getAllBytes(JavaFileObject fo);\n+\n+    \/**\n+     * The kind of location for which to list files.\n+     *\n+     * @see #listFiles\n+     *\/\n+    public enum LocationKind {\n+        \/** Source files, as found on the module source path, source path or class path, as appropriate. *\/\n+        SOURCE,\n+        \/** API files, as found in the API directory. *\/\n+        API\n+    }\n+\n+    \/**\n+     * Returns a list of the files found in a subdirectory of the source directories or API directory\n+     * for a module or package.\n+     *\n+     * @param kind         the kind of location to search\n+     * @param e            the module or package\n+     * @param subdirectory the optional subdirectory\n+     * @param kinds        the kinds of files\n+     * @param recurse      whether to recurse into subdirectories\n+     *\n+     * @return the list of files\n+     *\/\n+    public abstract List<JavaFileObject> listFiles(LocationKind kind, Element e, String subdirectory,\n+                                                   Set<JavaFileObject.Kind> kinds, boolean recurse);\n+\n+    \/**\n+     * Returns the {@code Elements Elements} utility class for this API.\n+     *\n+     * @return the {@code Elements} utility class\n+     *\/\n+    public abstract Elements getElements();\n+\n+    \/**\n+     * Returns the {@code Types Types} utility class for this API.\n+     *\n+     * @return the {@code Types} utility class\n+     *\/\n+    public abstract Types getTypes();\n+\n+    \/**\n+     * Returns the {@code DocTrees DocTrees} utility class for this API.\n+     *\n+     * @return the {@code DocTrees} utility class\n+     *\/\n+    public abstract DocTrees getTrees();\n+\n+    static class JavacAPI extends API {\n+        private List<String> javacOpts;\n+        private int platformVersion;\n+        private Elements elements;\n+        private Types types;\n+        private DocTrees docTrees;\n+        private SerializedFormFactory serializedFormFactory;\n+        private Map<String, SerializedFormDocs> serializedFormDocsMap;\n+        private final Path apiDir;\n+        private final APIReader apiReader;\n+        private final boolean apiModuleDirectories;\n+\n+        \/**\n+         * A tuple containing a location and the kinds of files that may be read from that location.\n+         *\/\n+        private class LocationAndKinds {\n+            final Location locn;\n+            final Set<JavaFileObject.Kind> kinds;\n+            LocationAndKinds(Location locn, Set<JavaFileObject.Kind> kinds) {\n+                this.locn = locn;\n+                this.kinds = kinds;\n+            }\n+        }\n+\n+        private Map<String, LocationAndKinds> moduleLocationAndKinds;\n+        private Set<ModuleElement> modules;\n+        private Map<ModuleElement, Set<PackageElement>> modulePackages;\n+\n+        private Set<PackageElement> packages;\n+\n+        \/** Map of recently accessed APIDocs, organized as an LRU cache. *\/\n+        private static final int MAX_APIDOCS = 20;\n+        private LinkedHashMap<Path, APIDocs> apiDocs = new LinkedHashMap<>(MAX_APIDOCS, 0.9f, true) {\n+            @Override\n+            protected boolean removeEldestEntry(Map.Entry<Path,APIDocs> eldest) {\n+                return size() > MAX_APIDOCS;\n+            }\n+        };\n+\n+        JavacAPI(APIOptions opts, Selector s, AccessKind ak, Log log) {\n+            super(opts, s, ak, log);\n+\n+            for (Map.Entry<String, List<String>> e : opts.fileManagerOpts.entrySet()) {\n+                String opt = e.getKey();\n+                List<String> args = e.getValue();\n+                for (String arg : args) {\n+                    Iterator<String> argIter = arg == null\n+                            ? Collections.emptyIterator()\n+                            : Collections.singleton(arg).iterator();\n+                    boolean ok = fileManager.handleOption(opt, argIter);\n+                    if (!ok) {\n+                        throw new IllegalArgumentException(opt);\n+                    }\n+                }\n+            }\n+\n+            javacOpts = new ArrayList<>();\n+\n+            if (opts.release != null && opts.source != null) {\n+                throw new IllegalArgumentException(\"both --release and --source\");\n+            } else if (opts.release != null) {\n+                javacOpts.addAll(List.of(\"--release\", opts.release));\n+                platformVersion = Integer.parseInt(opts.release);\n+            } else if (opts.source != null) {\n+                javacOpts.addAll(List.of(\"--source\", opts.source));\n+                platformVersion = Integer.parseInt(opts.source);\n+            } else {\n+                platformVersion = Runtime.version().feature();\n+            }\n+\n+            if (opts.enablePreview) {\n+                if (opts.release == null && opts.source == null) {\n+                    throw new IllegalArgumentException(\"either --release or --source must be specified with --enable-preview\");\n+                }\n+                javacOpts.add(\"--enable-preview\");\n+            }\n+\n+            apiDir = opts.apiDir;\n+            apiReader = new APIReader(log);\n+\n+            if (apiDir == null) {\n+                apiModuleDirectories = false;\n+            } else {\n+                boolean foundModuleSummary = false;\n+                try (Stream<Path> ds = Files.walk(apiDir, 1)) {\n+                    foundModuleSummary = ds.anyMatch(p -> Files.isDirectory(p) && Files.exists(p.resolve(\"module-summary.html\")));\n+                } catch (IOException e) {\n+                    \/\/ TODO: report error and exit\n+                }\n+                apiModuleDirectories = foundModuleSummary;\n+            }\n+        }\n+\n+        void initJavac(Set<String> selectedModules) {\n+            if (!selectedModules.isEmpty()) {\n+                javacOpts.add(\"--add-modules\");\n+                javacOpts.add(String.join(\",\", selectedModules));\n+            }\n+            javacOpts.add(\"-proc:only\");\n+            JavacTask javacTask = (JavacTask) compiler.getTask(log.err, fileManager, this::reportDiagnostic, javacOpts, null, null);\n+            elements = javacTask.getElements();\n+            elements.getModuleElement(\"java.base\"); \/\/ forces module graph to be instantiated, etc\n+            types = javacTask.getTypes();\n+            docTrees = DocTrees.instance(javacTask);\n+            serializedFormFactory = new SerializedFormFactory(this) {\n+                @Override\n+                public SerializedFormDocs getSerializedFormDocs(TypeElement te) {\n+                    \/\/ TODO: should we stop if there is a problem reading the file, other than \"file not found\"\n+                    \/\/       related: should this file be read proactively, if it exists, and if comparing API descriptions\n+                    if (serializedFormDocsMap == null) {\n+                        if (apiDir == null) {\n+                            serializedFormDocsMap = Collections.emptyMap();\n+                        } else {\n+                            Path file = apiDir.resolve(\"serialized-form.html\");\n+                            serializedFormDocsMap = SerializedFormDocs.read(log, file);\n+                        }\n+                    }\n+                    String name = te.getQualifiedName().toString();\n+                    return serializedFormDocsMap.get(name);\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public Set<PackageElement> getPackageElements() {\n+            if (packages == null) {\n+                initJavac(Collections.emptySet());\n+\n+                packages = new HashSet<>();\n+\n+                List<LocationAndKinds> locationAndKinds = new ArrayList<>();\n+                if (fileManager.hasLocation(StandardLocation.SOURCE_PATH)) {\n+                    locationAndKinds.add(new LocationAndKinds(StandardLocation.SOURCE_PATH,\n+                            EnumSet.of(JavaFileObject.Kind.SOURCE, JavaFileObject.Kind.HTML, JavaFileObject.Kind.OTHER)));\n+                    locationAndKinds.add(new LocationAndKinds(StandardLocation.CLASS_PATH,\n+                            EnumSet.of(JavaFileObject.Kind.CLASS)));\n+                } else {\n+                    locationAndKinds.add(new LocationAndKinds(StandardLocation.CLASS_PATH,\n+                            EnumSet.allOf(JavaFileObject.Kind.class)));\n+                }\n+\n+                if (platformVersion <= 8) {\n+                    locationAndKinds.add(new LocationAndKinds(StandardLocation.PLATFORM_CLASS_PATH,\n+                            EnumSet.of(JavaFileObject.Kind.CLASS)));\n+                }\n+\n+                packages = getPackageElements(null, locationAndKinds);\n+            }\n+            return packages;\n+        }\n+\n+        @Override\n+        public Set<ModuleElement> getModuleElements() {\n+            if (modules == null) {\n+                \/\/ Note: the following code does not support module source code on the source path.\n+                \/\/ If necessary, use the module-specific form of --module-source-path to specify\n+                \/\/ the source path for a single module.\n+                \/\/ While it would be reasonable to check the source path, and even look for\n+                \/\/ module-info.java, determining the module name would require reading and parsing\n+                \/\/ the file. Not impossible, but ...\n+                List<Location> modulePaths = List.of(\n+                        StandardLocation.MODULE_SOURCE_PATH,\n+                        StandardLocation.UPGRADE_MODULE_PATH,\n+                        StandardLocation.SYSTEM_MODULES,\n+                        StandardLocation.MODULE_PATH);\n+\n+                moduleLocationAndKinds = new HashMap<>();\n+                for (Location mp : modulePaths) {\n+                    Set<JavaFileObject.Kind> kinds = (mp == StandardLocation.MODULE_SOURCE_PATH)\n+                            ? EnumSet.of(JavaFileObject.Kind.SOURCE, JavaFileObject.Kind.HTML, JavaFileObject.Kind.OTHER)\n+                            : EnumSet.of(JavaFileObject.Kind.CLASS);\n+                    try {\n+                        for (Set<Location> locns : fileManager.listLocationsForModules(mp)) {\n+                            for (Location locn : locns) {\n+                                String mdlName = fileManager.inferModuleName(locn);\n+                                moduleLocationAndKinds.putIfAbsent(mdlName, new LocationAndKinds(locn, kinds));\n+                            }\n+                        }\n+                    } catch (IOException e) {\n+                        \/\/ ignore for now; eventually save first and suppress the rest\n+                    }\n+                }\n+\n+                Set<String> selectedModules = moduleLocationAndKinds.keySet().stream()\n+                        .filter(selector::acceptsModule)\n+                        .collect(Collectors.toSet());\n+\n+                initJavac(selectedModules);\n+\n+                modules = selectedModules.stream()\n+                        .map(elements::getModuleElement)\n+                        .collect(Collectors.toSet());\n+            }\n+\n+            return modules;\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\n+         * @see #getExportedPackageElements(ModuleElement)\n+         *\/\n+        @Override\n+        public Set<PackageElement> getPackageElements(ModuleElement m) {\n+            if (modulePackages == null) {\n+                modulePackages = new LinkedHashMap<>();\n+            }\n+\n+            Set<PackageElement> packages = modulePackages.get(m);\n+            if (packages == null) {\n+                String moduleName = m.getQualifiedName().toString();\n+                LocationAndKinds lk = moduleLocationAndKinds.get(moduleName);\n+                packages = (lk == null) ? Collections.emptySet() : getPackageElements(m, List.of(lk));\n+                modulePackages.put(m, packages);\n+            }\n+            return packages;\n+        }\n+\n+        @Override\n+        public Set<PackageElement> getExportedPackageElements(ModuleElement m) {\n+            Set<PackageElement> allExported = m.getDirectives().stream()\n+                    .filter(d -> d.getKind() == ModuleElement.DirectiveKind.EXPORTS)\n+                    .map(d -> (ModuleElement.ExportsDirective) d)\n+                    .filter(d -> d.getTargetModules() == null)\n+                    .map(d -> d.getPackage())\n+                    .collect(Collectors.toSet());\n+\n+            return getPackageElements(m).stream()\n+                    .filter(allExported::contains)\n+                    .collect(Collectors.toSet());\n+        }\n+\n+        \/**\n+         * Returns the packages found for a given module (or no module) in a series of locations.\n+         * The Language Model API does not provided an explicit way to obtain the collection of packages\n+         * for a module (or no module.) And so, the packages are determined by listing files in combinations\n+         * of the selected packages and given locations. The package names are inferred from the file names,\n+         * and the packages are then obtained by using {@link Elements#getPackageElement(CharSequence)} or\n+         * {@link Elements#getPackageElement(ModuleElement, CharSequence)} as appropriate.\n+         *\n+         * @param me            the module, or {@code null} for \"no module\" or the unnamed module\n+         * @param locationAndKinds the locations and the kinds of files to check in those locations\n+         *\n+         * @return the packages\n+         *\/\n+        private Set<PackageElement> getPackageElements(ModuleElement me, List<LocationAndKinds> locationAndKinds) {\n+            String moduleName = (me == null) ? null : me.getQualifiedName().toString();\n+            Map<String,Boolean> selectedPackages = new LinkedHashMap<>();\n+            for (Selector.Entry entry : selector.includes) {\n+                if (!entry.includeModule.test(moduleName)) {\n+                    continue;\n+                }\n+                String packagePart = entry.packagePart;\n+                boolean recurse = entry.typePart.equals(\"**\");\n+                for (LocationAndKinds lk : locationAndKinds) {\n+                    try {\n+                        for (JavaFileObject f : fileManager.list(lk.locn, packagePart, lk.kinds, recurse)) {\n+                            String binaryName = fileManager.inferBinaryName(lk.locn, f);\n+                            int lastDot = binaryName.lastIndexOf(\".\");\n+                            if (lastDot != -1) {\n+                                String packageName = binaryName.substring(0, lastDot);\n+                                if (!selectedPackages.containsKey(packageName)) {\n+                                    selectedPackages.put(packageName, selector.acceptsPackage(moduleName, packageName));\n+                                }\n+                            }\n+                        }\n+                    } catch (IOException e) {\n+                        \/\/ TODO: ignore for now; eventually save first and suppress the rest, and abort?\n+                    }\n+                }\n+            }\n+\n+            Function<String,PackageElement> getPackageElement = (me == null)\n+                    ? pkgName -> elements.getPackageElement(pkgName)\n+                    : pkgName -> elements.getPackageElement(me, pkgName);\n+\n+            return selectedPackages.entrySet().stream()\n+                    .filter(Entry::getValue)\n+                    .map(e -> getPackageElement.apply(e.getKey()))\n+                    .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        public Set<TypeElement> getTypeElements(PackageElement p) {\n+            ModuleElement me = elements.getModuleOf(p);\n+            String mn = (me == null) ? null : me.getQualifiedName().toString();\n+            String pn = p.getQualifiedName().toString();\n+            Set<TypeElement> types = new HashSet<>();\n+            for (Element e : p.getEnclosedElements()) {\n+                if (accessKind.accepts(e)) {\n+                    TypeElement te = (TypeElement) e;\n+                    String tn = te.getSimpleName().toString();\n+                    if (selector.acceptsType(mn, pn, tn)) {\n+                        types.add(te);\n+                    }\n+                }\n+            }\n+            return types;\n+        }\n+\n+        @Override\n+        public Map<? extends ExecutableElement, ? extends AnnotationValue> getAnnotationValuesWithDefaults(AnnotationMirror am) {\n+            return elements.getElementValuesWithDefaults(am);\n+        }\n+\n+        @Override\n+        public SerializedForm getSerializedForm(TypeElement e) {\n+            return serializedFormFactory.get(e);\n+        }\n+\n+        @Override\n+        public DocCommentTree getDocComment(Element e) {\n+            return docTrees.getDocCommentTree(e);\n+        }\n+\n+        private final ApiDescriptionVisitor apiDescriptionVisitor = new ApiDescriptionVisitor();\n+\n+        @Override\n+        public String getApiDescription(Element e) {\n+            if (apiDir == null) {\n+                return null;\n+            }\n+\n+            APIDocs d = apiDocs.computeIfAbsent(getSpecFile(e), f -> APIDocs.read(apiReader, f));\n+            return apiDescriptionVisitor.visit(e, d);\n+        }\n+\n+        private Path getSpecFile(Element e) {\n+            switch (e.getKind()) {\n+                case MODULE:\n+                    return getSpecDir(e).resolve(\"module-summary.html\");\n+\n+                case PACKAGE:\n+                    return getSpecDir(e).resolve(\"package-summary.html\");\n+\n+                default:\n+                    var eKind = e.getKind();\n+                    if (eKind.isClass() || eKind.isInterface()) {\n+                        StringBuilder typeFile = new StringBuilder(e.getSimpleName() + \".html\");\n+                        while (e.getEnclosingElement().getKind() != ElementKind.PACKAGE) {\n+                            e = e.getEnclosingElement();\n+                            typeFile.insert(0, e.getSimpleName() + \".\");\n+                        }\n+                        return getSpecDir(e).resolve(typeFile.toString());\n+                    } else {\n+                        return getSpecFile(e.getEnclosingElement());\n+                    }\n+            }\n+        }\n+\n+        private Path getSpecDir(Element e) {\n+            switch (e.getKind()) {\n+                case MODULE: {\n+                    ModuleElement me = (ModuleElement) e;\n+                    return apiDir.resolve(me.getQualifiedName().toString());\n+                }\n+\n+                case PACKAGE: {\n+                    PackageElement pe = (PackageElement) e;\n+                    ModuleElement me = (ModuleElement) pe.getEnclosingElement();\n+                    Path dir = (me == null) ? apiDir : getSpecDir(me);\n+                    String sep = dir.getFileSystem().getSeparator();\n+                    return dir.resolve(pe.getQualifiedName().toString().replace(\".\", sep));\n+                }\n+\n+                default:\n+                    return getSpecDir(e.getEnclosingElement());\n+            }\n+        }\n+\n+        @Override\n+        public DocCommentTree getDocComment(JavaFileObject fo) {\n+            if (fo.getKind() != JavaFileObject.Kind.HTML) {\n+                throw new IllegalArgumentException(fo.getName());\n+            }\n+\n+            return docTrees.getDocCommentTree(fo);\n+        }\n+\n+        @Override\n+        public String getApiDescription(JavaFileObject fo) {\n+            if (fo.getKind() != JavaFileObject.Kind.HTML) {\n+                throw new IllegalArgumentException(fo.getName());\n+            }\n+\n+            Path p = fileManager.asPath(fo);\n+            if (p == null || !Files.exists(p)) {\n+                return null;\n+            }\n+\n+            try {\n+                \/\/ TODO: consider using a new reader, DocFileReader, possibly returning a new object,\n+                \/\/       containing title and body, or a single more versatile pattern\n+                String s = Files.readString(p);\n+                Matcher startMain = Pattern.compile(\"(?i)<main\\\\b[^>]*>\").matcher(s);\n+                if (startMain.find()) {\n+                    int start = startMain.end();\n+                    Matcher endMain = Pattern.compile(\"(?i)<\/main>\").matcher(s);\n+                    if (endMain.find(start)) {\n+                        int end = endMain.start();\n+                        return s.substring(start, end);\n+                    }\n+                }\n+                Matcher startBody = Pattern.compile(\"(?i)<body\\\\b[^>]*>\").matcher(s);\n+                if (startBody.find()) {\n+                    int start = startBody.end();\n+                    Matcher endBody = Pattern.compile(\"(?i)<\/body>\").matcher(s);\n+                    if (endBody.find(start)) {\n+                        int end = endBody.start();\n+                        return s.substring(start, end);\n+                    }\n+                }\n+                \/\/ TODO: report cannot find content\n+                return null;\n+            } catch (IOException e) {\n+                \/\/ TODO: should report\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public byte[] getAllBytes(JavaFileObject fo) {\n+            Path p = fileManager.asPath(fo);\n+            if (p == null) {\n+                return null;\n+            }\n+            try {\n+                return Files.readAllBytes(p);\n+            } catch (IOException e) {\n+                \/\/ TODO: report error, or propagate\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public List<JavaFileObject> listFiles(LocationKind kind, Element e, String subdirectory,\n+                                              Set<JavaFileObject.Kind> kinds, boolean recurse) {\n+            return switch (kind) {\n+                case SOURCE -> listSourceFiles(e, subdirectory, kinds, recurse);\n+                case API ->    listApiFiles(e, subdirectory, kinds, recurse);\n+            };\n+        }\n+\n+        private List<JavaFileObject> listSourceFiles(Element e, String subdirectory,\n+                                                     Set<JavaFileObject.Kind> kinds, boolean recurse) {\n+            Location locn;\n+            ModuleElement me = elements.getModuleOf(e);\n+            if (me != null && !me.isUnnamed()) {\n+                LocationAndKinds lk = moduleLocationAndKinds.get(me.getQualifiedName().toString());\n+                locn = (lk == null) ? null : lk.locn;\n+            } else if (fileManager.hasLocation(StandardLocation.SOURCE_PATH)) {\n+                locn = StandardLocation.SOURCE_PATH;\n+            } else if (fileManager.hasLocation(StandardLocation.CLASS_PATH)) {\n+                locn = StandardLocation.CLASS_PATH;\n+            } else {\n+                locn = null;\n+            }\n+\n+            if (locn == null) {\n+                return Collections.emptyList();\n+            }\n+\n+            String dirName = switch (e.getKind()) {\n+                case MODULE -> \"\";\n+                case PACKAGE -> ((PackageElement) e).getQualifiedName().toString().replaceAll(\"\\\\.\", \"\/\");\n+                default -> throw new IllegalArgumentException(e.getKind() + \" \" + e);\n+            };\n+\n+            if (subdirectory != null && !subdirectory.isEmpty()) {\n+                dirName = dirName.isEmpty() ? subdirectory : dirName + \"\/\" + subdirectory;\n+            }\n+\n+            List<JavaFileObject> files = new ArrayList<>();\n+            try {\n+                for (JavaFileObject f : fileManager.list(locn, dirName, kinds, recurse)) {\n+                    files.add(f);\n+                }\n+            } catch (IOException ex) {\n+                \/\/ TODO: ignore for now; eventually save first and suppress the rest, and abort?\n+                \/\/       or simply throw up to caller, which can fail the comparison\n+            }\n+            return files;\n+\n+        }\n+\n+        private List<JavaFileObject> listApiFiles(Element e, String subdirectory,\n+                                                  Set<JavaFileObject.Kind> kinds, boolean recurse) {\n+            if (apiDir == null) {\n+                return Collections.emptyList();\n+            }\n+\n+            Path dir = apiDir;\n+            ModuleElement me = elements.getModuleOf(e);\n+            if (me != null && !me.isUnnamed()) {\n+                \/\/ handle module directories anomaly from JDK 9\n+                if (apiModuleDirectories) {\n+                    dir = dir.resolve(me.getQualifiedName().toString());\n+                } else {\n+                    \/\/ doc files for named modules are not supported if there is no\n+                    \/\/ module subdirectory.\n+                    return Collections.emptyList();\n+                }\n+            }\n+            if (e instanceof PackageElement) {\n+                PackageElement pe = (PackageElement) e;\n+                if (!pe.isUnnamed()) {\n+                    dir = dir.resolve(pe.getQualifiedName().toString().replace(\".\", File.separator));\n+                }\n+            }\n+            if (subdirectory != null && !subdirectory.isEmpty()) {\n+                dir = dir.resolve(subdirectory);\n+            }\n+\n+            List<Path> files = new ArrayList<>();\n+            try {\n+                boolean allKinds = kinds.equals(EnumSet.allOf(JavaFileObject.Kind.class));\n+                Files.walkFileTree(dir, Set.of(), recurse ? Integer.MAX_VALUE : 1, new SimpleFileVisitor<>() {\n+                    @Override\n+                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n+                        if (allKinds || kinds.contains(getKind(file))) {\n+                            files.add(file);\n+                        }\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+                });\n+            } catch (IOException ex) {\n+                \/\/ TODO: ignore for now; eventually save first and suppress the rest, and abort?\n+                \/\/       or simply throw up to caller, which can fail the comparison\n+            }\n+            return asFileObjects(files);\n+        }\n+\n+        private JavaFileObject.Kind getKind(Path file) {\n+            String name = file.getFileName().toString();\n+            int lastDot = name.lastIndexOf(name);\n+            String extn = lastDot == -1 ? \"\" : name.substring(lastDot + 1);\n+            return switch (extn) {\n+                case \"java\" -> JavaFileObject.Kind.SOURCE;\n+                case \"class\" -> JavaFileObject.Kind.CLASS;\n+                case \"html\" -> JavaFileObject.Kind.HTML;\n+                default -> JavaFileObject.Kind.OTHER;\n+            };\n+        }\n+\n+        private List<JavaFileObject> asFileObjects(List<Path> files) {\n+            List<JavaFileObject> fileObjects = new ArrayList<>();\n+            for (JavaFileObject fo : fileManager.getJavaFileObjectsFromPaths(files)) {\n+                fileObjects.add(fo);\n+            }\n+            return fileObjects;\n+        }\n+\n+        @Override\n+        public Elements getElements() {\n+            return elements;\n+        }\n+\n+        @Override\n+        public Types getTypes() {\n+            return types;\n+        }\n+\n+        @Override\n+        public DocTrees getTrees() {\n+            return docTrees;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getSimpleName() + \"[\" + name + \"]\";\n+        }\n+\n+        private void reportDiagnostic(Diagnostic<? extends JavaFileObject> d) {\n+            JavaFileObject fo = d.getSource();\n+            Path file = fo == null ? null : fileManager.asPath(fo);\n+            long line = d.getLineNumber();\n+            String message = d.getMessage(Locale.getDefault());\n+\n+            switch (d.getKind()) {\n+                case ERROR -> log.error(file, line, null, message);\n+                case WARNING -> log.warning(file, line, null, message);\n+                case NOTE -> log.note(file, line, null, message);\n+            }\n+        }\n+\n+        \/**\n+         * A visitor to access the API description for an element from the collection\n+         * of API docs read from the appropriate file.\n+         * The visitor determines the appropriate method and\/or signature to use to\n+         * access the description.\n+         *\/\n+        private static class ApiDescriptionVisitor implements ElementVisitor<String, APIDocs> {\n+            private ExecutableSignatureVisitor signatureVisitor = new ExecutableSignatureVisitor();\n+\n+            @Override\n+            public String visit(Element e, APIDocs d) {\n+                return e.accept(this, d);\n+            }\n+\n+            @Override\n+            public String visitModule(ModuleElement me, APIDocs d) {\n+                return d.getDescription();\n+            }\n+\n+            @Override\n+            public String visitPackage(PackageElement pe, APIDocs d) {\n+                return d.getDescription();\n+            }\n+\n+            @Override \/\/ CLASS, INTERFACE, ANNOTATION_TYPE, ENUM, etc (RECORD, SEALED_TYPE...)\n+            public String visitType(TypeElement te, APIDocs d) {\n+                return d.getDescription();\n+            }\n+\n+            @Override \/\/ FIELD, ENUM_CONSTANT\n+            public String visitVariable(VariableElement ve, APIDocs d) {\n+                return d.getDescription(ve.getSimpleName().toString());\n+            }\n+\n+            @Override \/\/ METHOD, CONSTRUCTOR\n+            public String visitExecutable(ExecutableElement ee, APIDocs d) {\n+                return d.getDescription(signatureVisitor.getSignature(ee));\n+            }\n+\n+            @Override\n+            public String visitTypeParameter(TypeParameterElement tpe, APIDocs d) {\n+                throw new IllegalArgumentException(tpe.getKind() + \" \" + tpe.getSimpleName());\n+            }\n+\n+            @Override\n+            public String visitUnknown(Element e, APIDocs d) {\n+                throw new IllegalArgumentException(e.getKind() + \" \" + e.getSimpleName());\n+            }\n+        }\n+\n+        \/**\n+         * A visitor to determine the signature for an executable element, as used by\n+         * {@code javadoc} to identify the description for the element in the page\n+         * for the enclosing type, and thereby used to identify the description in\n+         * the appropriate {@code APIDocs} object.\n+         *\/\n+        private static class ExecutableSignatureVisitor\n+                implements ElementVisitor<Void, StringBuilder>, TypeVisitor<Void, StringBuilder> {\n+            String getSignature(ExecutableElement ee) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(ee.getSimpleName());  \/\/ automatically uses <init> for constructor\n+                List<? extends VariableElement> params = ee.getParameters();\n+                if (params.isEmpty()) {\n+                    sb.append(\"()\");\n+                } else {\n+                    String sep = \"(\";\n+                    for (VariableElement ve : ee.getParameters()) {\n+                        sb.append(sep);\n+                        ve.asType().accept(this, sb);\n+                        sep = \",\";\n+                    }\n+                    sb.append(\")\");\n+                }\n+                return sb.toString();\n+            }\n+\n+            @Override\n+            public Void visit(Element e, StringBuilder sb) {\n+                return e.accept(this, sb);\n+            }\n+\n+            @Override\n+            public Void visitPackage(PackageElement e, StringBuilder sb) {\n+                error(e);\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitType(TypeElement e, StringBuilder sb) {\n+                sb.append(e.getQualifiedName());\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitVariable(VariableElement e, StringBuilder sb) {\n+                error(e);\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitExecutable(ExecutableElement e, StringBuilder sb) {\n+                error(e);\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitTypeParameter(TypeParameterElement e, StringBuilder sb) {\n+                sb.append(e.getSimpleName());\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitUnknown(Element e, StringBuilder sb) {\n+                error(e);\n+                return null;\n+            }\n+\n+            private void error(Element e) {\n+                throw new IllegalArgumentException(e.getKind() + \"[\" + e + \"]\");\n+            }\n+\n+            @Override\n+            public Void visit(TypeMirror t, StringBuilder sb) {\n+                return t.accept(this, sb);\n+            }\n+\n+            @Override\n+            public Void visitPrimitive(PrimitiveType t, StringBuilder sb) {\n+                sb.append(t.getKind().toString().toLowerCase(Locale.ROOT));\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitNull(NullType t, StringBuilder sb) {\n+                throw new IllegalArgumentException(t.getKind() + \" \" + t.toString());\n+            }\n+\n+            @Override\n+            public Void visitArray(ArrayType t, StringBuilder sb) {\n+                visit(t.getComponentType(), sb);\n+                sb.append(\"[]\");\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitDeclared(DeclaredType t, StringBuilder sb) {\n+                visit(t.asElement(), sb);\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitError(ErrorType t, StringBuilder sb) {\n+                error(t);\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitTypeVariable(TypeVariable t, StringBuilder sb) {\n+                visit(t.asElement(), sb);\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitWildcard(WildcardType t, StringBuilder sb) {\n+                visit(t.getSuperBound(), sb);\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitExecutable(ExecutableType t, StringBuilder sb) {\n+                error(t);\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitNoType(NoType t, StringBuilder sb) {\n+                error(t);\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitUnknown(TypeMirror t, StringBuilder sb) {\n+                error(t);\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitUnion(UnionType t, StringBuilder sb) {\n+                error(t); \/\/ TODO? should not happen in args of ExecutableElement\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitIntersection(IntersectionType t, StringBuilder sb) {\n+                error(t); \/\/ TODO? should not happen in args of ExecutableElement\n+                return null;\n+            }\n+\n+            private void error(TypeMirror t) {\n+                throw new IllegalArgumentException(t.getKind() + \"[\" + t + \"]\");\n+            }\n+\n+        }\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/API.java","additions":1128,"deletions":0,"binary":false,"changes":1128,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.Set;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+\n+import jdk.codetools.apidiff.Abort;\n+import jdk.codetools.apidiff.Log;\n+import jdk.codetools.apidiff.Options;\n+import jdk.codetools.apidiff.report.Reporter;\n+\n+\/**\n+ * A comparator for APIs.\n+ *\/\n+public class APIComparator {\n+    private final Set<API> apis;\n+    private final Options options;\n+    private final Options.Mode mode;\n+    private final Reporter reporter;\n+    private final Log log;\n+\n+    \/**\n+     * Creates an comparator to compare the specifications of the declared elements\n+     * in a series of APIs, using a reporter to generate a report of the results.\n+     * Depending on the mode of the comparison, the items to be compared will be\n+     * read from the overall module path or from the source and class path.\n+     *\n+     * @param apis the APIs\n+     * @param options the command-line options\n+     * @param reporter the reporter\n+     * @param log the log\n+     *\/\n+    public APIComparator(Set<API> apis, Options options, Reporter reporter, Log log) {\n+        this.apis = apis;\n+        this.options = options;\n+        this.mode = options.getMode();\n+        this.reporter = reporter;\n+        this.log = log;\n+    }\n+\n+    \/**\n+     * Compares the collection of APIs specified for this comparator.\n+     *\n+     * @return {@code true} if the APIs are equivalent according to the configured settings\n+     *\/\n+    public boolean compare() {\n+        boolean equal = switch (mode) {\n+            case MODULE ->  compareModules();\n+            case PACKAGE -> comparePackages();\n+        };\n+        if (log.errorCount() > 0) {\n+            throw new Abort();\n+        }\n+        reporter.completed(equal);\n+        return equal;\n+    }\n+\n+    private boolean compareModules() {\n+        KeyTable<ModuleElement> allModules = new KeyTable<>();\n+\n+        for (API api: apis) {\n+            for (ModuleElement me : api.getModuleElements()) {\n+                allModules.put(ElementKey.of(me), api, me);\n+            }\n+        }\n+\n+        ModuleComparator mc = new ModuleComparator(apis, options, reporter);\n+        return mc.compareAll(allModules);\n+    }\n+\n+    private boolean comparePackages() {\n+        KeyTable<PackageElement> allPackages = new KeyTable<>();\n+\n+        for (API api: apis) {\n+            for (PackageElement pe : api.getPackageElements()) {\n+                allPackages.put(ElementKey.of(pe), api, pe);\n+            }\n+        }\n+\n+        PackageComparator pc = new PackageComparator(apis, options, reporter);\n+        return pc.compareAll(allPackages);\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/APIComparator.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import jdk.codetools.apidiff.Log;\n+\n+\/**\n+ * A class that encapsulates the descriptions generated by javadoc in a file\n+ * for a module, package or type.\n+ *\/\n+public class APIDocs {\n+    \/**\n+     * Reads a file generated by javadoc, and extracts the descriptions for\n+     * the declarations contained therein.\n+     *\n+     * <p>If the file does not exist, an empty object will be returned,\n+     * which returns {@code null} for {@link #getDescription()} and {@link #getDescription(String)},\n+     * and an empty map for {@link #getMemberDescriptions()}.\n+     *\n+     * @param log  a log to which any errors will be reported\n+     * @param file the file to be read\n+     *\n+     * @return an instance of {@code APIDocs} that contains the descriptions\n+     *      found in the file.\n+     *\/\n+    public static APIDocs read(Log log, Path file) {\n+        return read(new APIReader(log), file);\n+\n+    }\n+\n+    \/**\n+     * Reads a file generated by javadoc, and extracts the descriptions for\n+     * the declarations contained therein.\n+     *\n+     * <p>If the file does not exist, an empty object will be returned,\n+     * which returns {@code null} for {@link #getDescription()} and {@link #getDescription(String)},\n+     * and an empty map for {@link #getMemberDescriptions()}.\n+     *\n+     * @param r    an API reader to read the file\n+     * @param file the file to be read\n+     *\n+     * @return an instance of {@code APIDocs} that contains the descriptions\n+     *      found in the file.\n+     *\/\n+    public static APIDocs read(APIReader r, Path file) {\n+        if (!Files.exists(file)) {\n+            return EMPTY;\n+        }\n+\n+        r.read(file);\n+        return new APIDocs(r.getDeclarationNames(), r.getDescription(), r.getMemberDescriptions());\n+    }\n+\n+    private final Map<String, String> declNames;\n+    private final String description;\n+    private final Map<String, String> memberDescriptions;\n+\n+    private static final APIDocs EMPTY = new APIDocs(Collections.emptyMap(), null, Collections.emptyMap());\n+\n+    private APIDocs(Map<String, String> declNames, String description, Map<String, String> memberDescriptions) {\n+        this.declNames = declNames;\n+        this.description = description;\n+        this.memberDescriptions = memberDescriptions;\n+    }\n+\n+    \/**\n+     * Returns the parts of the names for the top-level element defined in the file.\n+     * The keys for the names are {@code module}, {@code package} and {@code class}.\n+     *\n+     * @return a map containing the parts of the names\n+     *\/\n+    public Map<String, String> getDeclarationNames() {\n+        return declNames;\n+    }\n+\n+    \/**\n+     * Returns the description for the primary element declared in the file:\n+     * the module, page or type.\n+     *\n+     * @return the description\n+     *\/\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    \/**\n+     * Returns the description for a member declared in the file, or null if the member is not found.\n+     *\n+     * Only types contain members; modules and packages do not.\n+     * Members are identified by their signature.\n+     * The signature is either the name of the member, or {@code <init>} for a constructor,\n+     * followed by a comma-separated list of argument types enclosed in parentheses if the member\n+     * is a constructor or method.\n+     *\n+     * @param memberSignature the signature of the member\n+     * @return the description of the member\n+     *\/\n+    public String getDescription(String memberSignature) {\n+        return memberDescriptions.get(memberSignature);\n+    }\n+\n+    \/**\n+     * Returns a map containing the descriptions of all the members found in the file.\n+     *\n+     * @return a map of descriptions, indexed by signature\n+     *\/\n+    public Map<String,String> getMemberDescriptions() {\n+        return memberDescriptions;\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/APIDocs.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+\/**\n+ * A map in which to store the instances of corresponding items in different\n+ * instances of an API.\n+ *\n+ * <p>Null values are not permitted in the map.\n+ *\n+ * <p>The representation of the map is intended to be opaque.\n+ *\n+ * @param <T> the type of the items in this map\n+ *\/\n+public class APIMap<T> extends LinkedHashMap<API, T> {\n+    private static final long serialVersionUID = 0;\n+\n+    private APIMap() { }\n+\n+    \/**\n+     * Creates an instance of an {@code APIMap}.\n+     *\n+     * @param <T> the type of the instances in the map.\n+     * @return the map\n+     *\/\n+    public static <T> APIMap<T> of()  {\n+        return new APIMap<>();\n+    }\n+\n+    \/**\n+     * Creates an instance of an {@code APIMap} containing an initial entry.\n+     *\n+     * @param <T> the type of the instances in the map.\n+     * @param api the API\n+     * @param t   the instance of the item for the given API\n+     * @return the map\n+     *\/\n+    public static <T> APIMap<T> of(API api, T t)  {\n+        APIMap<T> map = new APIMap<>();\n+        map.put(api, t);\n+        return map;\n+    }\n+\n+    @Override\n+    public T put(API api, T t) {\n+        Objects.requireNonNull(api);\n+        Objects.requireNonNull(t);\n+        return super.put(api, t);\n+    }\n+\n+    \/**\n+     * Creates a new map by applying a function to each of the values in this map.\n+     * If the function returns {@code null} for an entry, no corresponding entry\n+     * is put in the new map.\n+     *\n+     * @param f   the function\n+     * @param <R> the type of entries in the new map\n+     *\n+     * @return the new map\n+     *\/\n+    public <R> APIMap<R> map(Function<T, R> f) {\n+        APIMap<R> result = APIMap.of();\n+        for (Map.Entry<API, ? extends T> e : entrySet()) {\n+            R r = f.apply(e.getValue());\n+            if (r != null) {\n+                result.put(e.getKey(), r);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Creates a new map by applying a bi-function to each of the entries in this map.\n+     * If the function returns {@code null} for an entry, no corresponding entry\n+     * is put in the new map.\n+     *\n+     * @param f   the function\n+     * @param <R> the type of entries in the new map\n+     *\n+     * @return the new map\n+     *\/\n+    public <R> APIMap<R> map(BiFunction<API, T, R> f) {\n+        APIMap<R> result = APIMap.of();\n+        for (Map.Entry<API, ? extends T> e : entrySet()) {\n+            R r = f.apply(e.getKey(), e.getValue());\n+            if (r != null) {\n+                result.put(e.getKey(), r);\n+            }\n+        }\n+        return result;\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/APIMap.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,520 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.codetools.apidiff.Log;\n+\n+\/**\n+ * A reader that reads descriptions for program elements from HTML files generated by javadoc.\n+ * Only files in HTML5 format are supported: the primary reason being the lossy-encoding\n+ * of member signatures into {@code name} attributes in HTML4 files.\n+ *\n+ * The output generated by javadoc is not well-specified and varies across releases.\n+ * The following rules allow fuzzy parsing for at least JDK version 11 and later.\n+ *\n+ * <ul>\n+ * <li> For a module, the description is the smallest enclosing {@code <section>} containing\n+ *      {@code id=\"module-description\"} or {@code id=\"module.description\"}, or the {@code <div>}\n+ *      within that section. It may be followed by an additional {@code <section>} containing\n+ *      the block tags for the description.\n+ *\n+ * <li> For a package, the description is the smallest enclosing {@code <section>} containing\n+ *      {@code id=\"package-description\"} or {@code id=\"package.description\"}, or the {@code <div>}\n+ *      within that section.\n+ *\n+ * <li> For a type, the description is the enclosing\n+ *      {@code <div id=\"class-description\" class=\"class-description\">} or\n+ *      {@code <div class=\"description\">},\n+ *      or the {@code <div>} within that section.\n+ *\n+ * <li> For a member, the description follows the \"...Detail\" heading, then an\n+ *      {@code id=\"signature\"}, then a heading and a subsequent {@code <div>}.\n+ *      There may be enclosing {@code <ul>} and {@code <li>} nodes to be taken into\n+ *      account, for older versions of javadoc.  There is an enclosing {@code <div>}\n+ *      we could select as well. Note the heading has an incomplete signature;\n+ *      the preceding {@code id} is more accurate.\n+ * <\/ul>\n+ *\/\n+public class APIReader extends HtmlParser {\n+    private enum Kind { MODULE, PACKAGE, TYPE }\n+\n+    private final Log log;\n+    private Kind kind;\n+    private String description;\n+    private Map<String, String> memberDescriptions;\n+    private Map<String, String> declarationNames;\n+\n+    APIReader(Log log) {\n+        this.log = log;\n+    }\n+\n+    \/\/ TEMPORARY!\n+    boolean debug = false;\n+    private void debugPrintln(Supplier<String> s) {\n+        if (debug) {\n+            System.err.println(s.get());\n+        }\n+    }\n+\n+    @Override\n+    public void read(Path file) {\n+        debug = Objects.equals(file.getFileName().toString(), System.getProperty(\"debug.APIReader\"));\n+        kind = getKind(file);\n+        description = null;\n+        memberDescriptions = new HashMap<>();\n+        debugPrintln(() -> \"**************************************** read \" + file + \" \" + kind);\n+        super.read(file);\n+    }\n+\n+    \/**\n+     * Returns the parts of the names for the top-level element defined on this page.\n+     * The keys for the names are {@code module}, {@code package} and {@code class}.\n+     *\n+     * @return a map containing the parts of the names\n+     *\/\n+    public Map<String, String> getDeclarationNames() {\n+        return (declarationNames == null) ? Collections.emptyMap() : declarationNames;\n+    }\n+\n+    \/**\n+     * Returns the main description of the primary element declared on this page.\n+     *\n+     * @return the description\n+     *\/\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    \/**\n+     * Returns a map containing the descriptions of the member elements enclosed by the\n+     * primary element declared on the page.\n+     * The keys of the map are the signatures of the individual members.\n+     *\n+     * @return the map\n+     *\/\n+    public Map<String, String> getMemberDescriptions() {\n+        return memberDescriptions;\n+    }\n+\n+    @Override\n+    protected void error(Path file, int lineNumber, String message) {\n+        log.err.println(file + \":\" + lineNumber + \": \" + message);\n+    }\n+\n+    @Override\n+    protected void error(Path file, int lineNumber, Throwable t) {\n+        log.err.println(file + \":\" + lineNumber + \": \" + t);\n+    }\n+\n+    private StringBuilder contentBuffer;\n+    private boolean inMain;\n+    private int startDescriptionIndex;\n+    private boolean inDescription;\n+    private String descriptionId;\n+    private int blockDepth;\n+    private boolean inDetails;\n+    private boolean inHeader;\n+    private boolean inSubTitle;\n+    private String detailHeading;\n+    private boolean allowMoreModuleSections;\n+\n+    @Override\n+    protected void content(Supplier<String> content) {\n+        if (contentBuffer != null) {\n+            contentBuffer.append(content.get());\n+        }\n+    }\n+\n+    @Override\n+    protected void html() {\n+        if (startDescriptionIndex == -1) {\n+            startDescriptionIndex = getBufferIndex() - 1;\n+        }\n+        super.html();\n+        if (!inDescription) {\n+            startDescriptionIndex = -1;\n+        }\n+    }\n+\n+    @Override\n+    protected void startElement(String name, Map<String, String> attrs, boolean isSelfClosing) {\n+        \/\/ skip almost everything not in the `<main>` element\n+        if (!inMain) {\n+            switch (name) {\n+                case \"meta\" -> {\n+                    String nameAttr = attrs.get(\"name\");\n+                    String contentAttr = attrs.get(\"content\");\n+                    if (Objects.equals(nameAttr, \"description\")\n+                            && contentAttr != null\n+                            && contentAttr.startsWith(\"declaration: \")) {\n+                        Map<String, String> names = new LinkedHashMap<>();\n+                        Pattern p = Pattern.compile(\"(?<key>[a-z]+):\\\\s+(?<value>[A-Za-z0-9_$.]+)\");\n+                        Matcher m = p.matcher(contentAttr.substring(contentAttr.indexOf(' ')));\n+                        while (m.find()) {\n+                            names.put(m.group(\"key\"), m.group(\"value\"));\n+                        }\n+                        declarationNames = names;\n+                    }\n+                }\n+                case \"main\" ->\n+                    inMain = true;\n+            }\n+            return;\n+        }\n+\n+        debugPrintln(() -> \"<\" + name + \" \" + attrs + \">\");\n+        String classAttr = attrs.get(\"class\");\n+        switch (name) {\n+            case \"div\":\n+                \/\/ For some older versions of javadoc, the description for a type declaration\n+                \/\/ is contained in `<div class=\"description\">...<\/div>`\n+                if ((kind == Kind.TYPE) && isClassDescription(attrs)) {\n+                    debugPrintln(() -> \"!! start description for TYPE\");\n+                    inDescription = true;\n+                    blockDepth = 1;\n+                } else if (Objects.equals(classAttr, \"header\")) {\n+                    inHeader = true;\n+                } else if (Objects.equals(classAttr, \"subTitle\")\n+                        || Objects.equals(classAttr, \"sub-title\") ) {\n+                    inSubTitle = true;\n+                    contentBuffer = new StringBuilder();\n+                } else {\n+                    if (inDescription) {\n+                        blockDepth++;\n+                    }\n+                }\n+                break;\n+\n+            case \"section\":\n+                \/\/ For some versions of javadoc, the description for a module or package\n+                \/\/ is contained in a section containing an element with `id` set to\n+                \/\/ `module.description` or `package.description`.  For these,\n+                \/\/ proactively set inDescription, but cancel if the first id is incorrect.\n+                \/\/ For some more recent versions of javadoc, the description for a type\n+                \/\/ is contained in `<section class=\"description\">...<\/section>`, or\n+                \/\/ `<section class=\"class-description\" id=\"class-description\">...<\/section>` but\n+                \/\/ note that the section is poorly formed for not having a heading.\n+                \/\/ For some more recent versions of javadoc, the description for a member\n+                \/\/ is contained in `<section class=\"detail\">...<\/section>`.\n+                if ((kind == Kind.MODULE || kind == Kind.PACKAGE) && description == null\n+                        || kind == Kind.MODULE && allowMoreModuleSections) {\n+                    if (inDescription) {\n+                        blockDepth++;\n+                    } else {\n+                        debugPrintln(() -> \"?? start description for MODULE or PACKAGE\");\n+                        inDescription = true;\n+                        blockDepth = 1;\n+                    }\n+                } else if ((kind == Kind.TYPE) && isClassDescription(attrs)) {\n+                    debugPrintln(() -> \"!! start description for TYPE\");\n+                    inDescription = true;\n+                    blockDepth = 1;\n+                } else if ((kind == Kind.TYPE) && Objects.equals(classAttr, \"detail\")) {\n+                    debugPrintln(() -> \"!! start description for TYPE member\");\n+                    inDescription = true;\n+                    blockDepth = 1;\n+                }\n+                debugPrintln(() -> \">>>>>> in section \" + inDescription + \" \" + blockDepth);\n+                break;\n+\n+            \/\/ For some versions of javadoc, the description for a member starts in the\n+            \/\/ details section, with a heading of the appropriate rank.  By itself,\n+            \/\/ the content of the heading does not fully identify the member;\n+            \/\/ an `id` attribute in the heading or in an element that follows provides\n+            \/\/ the information.\n+            case \"h1\": case \"h2\": case \"h3\": case \"h4\":\n+                contentBuffer = new StringBuilder();\n+                if (inDetails && !inDescription && name.equals(detailHeading)) {\n+                    debugPrintln(() -> \"!! start description because inDetails but !inDescription\");\n+                    inDescription = true;\n+                    descriptionId = null;\n+                }\n+                break;\n+\n+            \/\/ Some versions of javadoc use two sections for the description, instead of one.\n+            \/\/ This is handled by reading sections until the first `<ul>` element that is not\n+            \/\/ part of the description. For these versions of javadoc, this `<ul>` introduces\n+            \/\/ the summary sections.\n+            case \"ul\":\n+                if (inDescription) {\n+                    blockDepth++;\n+                } else {\n+                    allowMoreModuleSections = false;\n+                }\n+                break;\n+        }\n+\n+        \/\/ id attributes are used to help identify the beginning of descriptions\n+        \/\/ and (for members) the basic signature of the member itself.\n+        String id = attrs.get(\"id\");\n+        switch (kind) {\n+            \/\/ For a module, the main description is a section containing\n+            \/\/ `id=\"module-description\"` or `id=\"module.description\"`\n+            case MODULE:\n+                if (inDescription && descriptionId == null && id != null) {\n+                    if (isModuleDescription(attrs)) {\n+                        debugPrintln(() -> \"!! commit description for MODULE\");\n+                        descriptionId = id;\n+                        allowMoreModuleSections = true;\n+                    } else {\n+                        debugPrintln(() -> \"XX cancel description for MODULE\");\n+                        inDescription = false;\n+                    }\n+                }\n+                break;\n+\n+            \/\/ For a package, the main description is a section containing\n+            \/\/ `id=\"package-description\"` or `id=\"package.description\"`\n+            case PACKAGE:\n+                if (inDescription && descriptionId == null && id != null) {\n+                    if (isPackageDescription(attrs)) {\n+                        debugPrintln(() -> \"!! commit description for PACKAGE\");\n+                        descriptionId = id;\n+                    } else {\n+                        debugPrintln(() -> \"XX cancel description for PACKAGE\");\n+                        inDescription = false;\n+                    }\n+                }\n+                break;\n+\n+            \/\/ For a type, identifying the main description does not depend on\n+            \/\/ any `id` attribute (it depends on the element and class).\n+            \/\/ But, an `id` in the details part of the file may indicate the\n+            \/\/ beginning of the description of a member, or may provide the\n+            \/\/ `declarationId` if the description has already been started ...\n+            \/\/ for example, by a heading.\n+            case TYPE:\n+                if (inDetails && descriptionId == null && (id != null) && !id.matches(\"[a-z]+[-.]detail[s]?\")) {\n+                    if (!inDescription) {\n+                        debugPrintln(() -> \"!! start description for TYPE \" + id);\n+                        inDescription = true;\n+                        blockDepth = 0;\n+                    }\n+                    debugPrintln(() -> \"!! set id for TYPE member \" + id);\n+                    descriptionId = id;\n+                }\n+                break;\n+        }\n+\n+        debugPrintln(() -> \"   inDesc:\" + inDescription + \" depth:\" + blockDepth + \" descId:\" + descriptionId);\n+    }\n+\n+    \/*\n+     * Match the following strings:\n+     *   Constructor Detail\n+     *   Element Detail\n+     *   Enum Constant Detail\n+     *   Field Detail\n+     *   Method Detail\n+     *\n+     * For now, it's a weak match.\n+     * If we get false positives, we can strengthen the match.\n+     * Ideally, we should not need to rely on javadoc's marker comments.\n+     *\n+     * The headings would be more grammatically correct if they were\n+     * plural, and ended in \"s\". The pattern proactively anticipates this\n+     * possibility.\n+     *\/\n+    private final Pattern detail = Pattern.compile(\"(?i)[a-z ]+ detail[s]?\");\n+\n+    @Override\n+    protected void endElement(String name) {\n+        \/\/ skip everything not in the `<main>` element\n+        if (!inMain) {\n+            return;\n+        }\n+\n+        debugPrintln(() -> \"<\/\" + name + \">\" + blockDepth);\n+        switch (name) {\n+            case \"div\":\n+                if (inSubTitle) {\n+                    String subTitle = contentBuffer.toString().replace(\"&nbsp;\", \" \");\n+                    debugPrintln(() -> \"subTitle: \" + subTitle);\n+                    setDeclarationName(subTitle);\n+                    inSubTitle = false;\n+                }\n+                break;\n+\n+            case \"h1\": case \"h2\": case \"h3\": case \"h4\":\n+                String content = contentBuffer.toString();\n+                if (inHeader) {\n+                    String heading = content.replace(\"&nbsp;\", \" \");\n+                    debugPrintln(() -> \"heading: \" + heading);\n+                    setDeclarationName(heading);\n+                    inHeader = false;\n+                } else if (detail.matcher(content).matches()) {\n+                    debugPrintln(() -> \"START inDetails\");\n+                    inDetails = true;\n+                    detailHeading = \"h\" + (char)(name.charAt(1) + 1);\n+                    debugPrintln(() -> \"detailHeading: \" + detailHeading);\n+                }\n+                break;\n+\n+            \/\/ nothing more to do\n+            case \"main\":\n+                inDetails = false;\n+                inMain = false;\n+                break;\n+        }\n+\n+        \/\/ Once a description has been started, in general the description is ended\n+        \/\/ when the block nesting level drops to zero.\n+        if (inDescription) {\n+            switch (name) {\n+                case \"section\":\n+                case \"div\":\n+                case \"ul\":\n+                    if (--blockDepth == 0) {\n+                        String d = getBufferString(startDescriptionIndex, getBufferIndex());\n+                        switch (kind) {\n+                            case MODULE:\n+                                \/\/ Some versions of javadoc use multiple section elements for the\n+                                \/\/ description of a module, so we concatenate them here.\n+                                debugPrintln(() -> (\"*** \" + kind + \":\\n\" + d).replace(\"\\n\", \"\\n*** \"));\n+                                description = (description == null) ? d : description + d;\n+                                break;\n+\n+                            case PACKAGE:\n+                                debugPrintln(() -> (\"*** \" + kind + \":\\n\" + d).replace(\"\\n\", \"\\n*** \"));\n+                                description = d;\n+                                break;\n+\n+                            case TYPE:\n+                                \/\/ Determine whether this is the end of the main description, or the end of the description\n+                                \/\/ of a member.\n+                                if (descriptionId == null) {\n+                                    debugPrintln(() -> (\"*** \" + kind + \":\\n\" + d).replace(\"\\n\", \"\\n*** \"));\n+                                    description = d;\n+                                } else {\n+                                    debugPrintln(() -> (\"*** \" + kind + \": \" + descriptionId + \"\\n\" + d).replace(\"\\n\", \"\\n*** \"));\n+                                    memberDescriptions.put(descriptionId, d);\n+                                }\n+                                break;\n+                        }\n+                        inDescription = false;\n+                        descriptionId = null;\n+                    }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Module descriptions are recognised as one of the following:\n+     *   {@code }<TAG id=\"module-description\">}\n+     *   {@code }<TAG id=\"module.description\">}\n+     *\n+     * @param attrs the attributes\n+     * @return whether the attributes indicate a class description\n+     *\/\n+    private boolean isModuleDescription(Map<String, String> attrs) {\n+        String id = attrs.get(\"id\");\n+        if (id == null) {\n+            return false;\n+        }\n+\n+        return switch (id) {\n+            case \"module-description\",      \/\/ new style\n+                 \"module.description\" ->    \/\/ old style\n+                true;\n+\n+            default ->\n+                false;\n+        };\n+    }\n+\n+    \/**\n+     * Package descriptions are recognised as one of the following:\n+     *   {@code }<TAG id=\"package-description\">}\n+     *   {@code }<TAG id=\"package.description\">}\n+     *\n+     * @param attrs the attributes\n+     * @return whether the attributes indicate a class description\n+     *\/\n+    private boolean isPackageDescription(Map<String, String> attrs) {\n+        String id = attrs.get(\"id\");\n+        if (id == null) {\n+            return false;\n+        }\n+\n+        return switch (id) {\n+            case \"package-description\",     \/\/ new style\n+                 \"package.description\" ->   \/\/ old style\n+                true;\n+\n+            default ->\n+                false;\n+        };\n+    }\n+\n+    \/**\n+     * Class descriptions are recognised as one of the following:\n+     *   {@code }<TAG class=\"class-description\" id=\"class-description>}\n+     *   {@code }<TAG class=\"description\">}\n+     *\n+     * @param attrs the attributes\n+     * @return whether the attributes indicate a class description\n+     *\/\n+    private boolean isClassDescription(Map<String, String> attrs) {\n+        String id = attrs.get(\"id\");\n+        if (id != null) {\n+            return id.equals(\"class-description\"); \/\/ new style\n+        } else {\n+            return Objects.equals(attrs.get(\"class\"), \"description\"); \/\/ old style\n+        }\n+    }\n+\n+    private void setDeclarationName(String keyValue) {\n+        Pattern p = Pattern.compile(\"(?<key>[A-Za-z]+):?\\\\s+(?<value>[A-Za-z0-9_$.]+)\");\n+        Matcher m = p.matcher(keyValue);\n+        if (m.matches()) {\n+            if (declarationNames == null) {\n+                declarationNames = new LinkedHashMap<>();\n+            }\n+            declarationNames.putIfAbsent(\n+                    m.group(\"key\").toLowerCase(Locale.ROOT),\n+                    m.group(\"value\"));\n+        }\n+    }\n+\n+    private Kind getKind(Path file) {\n+        return switch (file.getFileName().toString()) {\n+            case \"module-summary.html\" -> Kind.MODULE;\n+            case \"package-summary.html\" -> Kind.PACKAGE;\n+            default -> Kind.TYPE;\n+        };\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/APIReader.java","additions":520,"deletions":0,"binary":false,"changes":520,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.Set;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.Modifier;\n+\n+\/**\n+ * The kind of access filters.\n+ *\/\n+public enum AccessKind {\n+    \/**\n+     * A filter for items declared to be {@code public}.\n+     *\/\n+    PUBLIC {\n+        @Override\n+        public boolean accepts(Set<Modifier> modifiers) {\n+            return modifiers.contains(Modifier.PUBLIC);\n+        }\n+\n+        @Override\n+        public boolean allModuleDetails() {\n+            return false;\n+        }\n+    },\n+\n+    \/**\n+     * A filter for items declared to be {@code public} or {@code protected}.\n+     *\/\n+    PROTECTED {\n+        @Override\n+        public boolean accepts(Set<Modifier> modifiers) {\n+            return modifiers.contains(Modifier.PUBLIC) || modifiers.contains(Modifier.PROTECTED);\n+        }\n+\n+        @Override\n+        public boolean allModuleDetails() {\n+            return false;\n+        }\n+    },\n+\n+    \/**\n+     * A filter for items declared to be {@code public}, {@code protected} or package-private.\n+     *\/\n+    PACKAGE {\n+        @Override\n+        public boolean accepts(Set<Modifier> modifiers) {\n+            return !modifiers.contains(Modifier.PRIVATE);\n+        }\n+\n+        @Override\n+        public boolean allModuleDetails() {\n+            return true;\n+        }\n+    },\n+\n+    \/**\n+     * A filter for all items.\n+     *\/\n+    PRIVATE {\n+        @Override\n+        public boolean accepts(Set<Modifier> modifiers) {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean allModuleDetails() {\n+            return true;\n+        }\n+    };\n+\n+    \/**\n+     * Returns whether the filter accepts an item with the given set of modifiers.\n+     *\n+     * @param modifiers the modifiers\n+     * @return {@code true} if the item is accepted by the filter\n+     *\/\n+    public abstract boolean accepts(Set<Modifier> modifiers);\n+\n+    \/**\n+     * Returns whether the filter accepts an element according to its modifiers.\n+     *\n+     * @param e the element\n+     * @return {@code true} if the element is accepted by the filter\n+     *\/\n+    public boolean accepts(Element e) {\n+        return accepts(e.getModifiers());\n+    }\n+\n+    \/**\n+     * Returns whether all module details should be compared and displayed.\n+     *\n+     * @return {@code true} if and only if all module details should be compared and displayed\n+     *\/\n+    public abstract boolean allModuleDetails();\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/AccessKind.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,321 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import javax.lang.model.AnnotatedConstruct;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.AbstractAnnotationValueVisitor14;\n+\n+import jdk.codetools.apidiff.report.Reporter;\n+\n+\/**\n+ * A comparator for the {@link AnnotationMirror annotations} on {@link AnnotatedConstruct annotated constructs}.\n+ *\n+ * <p>Annotations are compared according to their structure (\"deep equals\") down to\n+ * the level of element names, which are compared using {@link ElementKey#equals ElementKey.equals}.\n+ *\/\n+public class AnnotationComparator {\n+    \/** The APIs to be compared. *\/\n+    protected final Set<API> apis;\n+    \/** The access kind. *\/\n+    private final AccessKind accessKind;\n+    \/** The reporter to which to report any differences. *\/\n+    protected final Reporter reporter;\n+\n+    \/**\n+     * Creates an instance of comparator for annotations.\n+     *\n+     * @param apis       the APIs being compared\n+     * @param accessKind the access kind\n+     * @param reporter   the reporter to which to report any differences.\n+     *\/\n+    protected AnnotationComparator(Set<API> apis, AccessKind accessKind, Reporter reporter) {\n+        this.apis = apis;\n+        this.accessKind = accessKind;\n+        this.reporter = reporter;\n+    }\n+\n+    \/**\n+     * Compares all the annotations at a given position within instances of an API.\n+     *\n+     * @param pos the position of the annotations to be compared\n+     * @param acMap the annotated constructs whose annotations are being compared\n+     * @return {@code true} if and only if all the annotations are equal\n+     *\/\n+    public boolean compareAll(Position pos, APIMap<? extends AnnotatedConstruct> acMap) {\n+        Map<ElementKey, APIMap<AnnotationMirror>> annoMap = extractAnnotations(acMap);\n+\n+        boolean allEqual = true;\n+        for (Map.Entry<ElementKey, APIMap<AnnotationMirror>> e : annoMap.entrySet()) {\n+            ElementKey k = e.getKey();\n+            APIMap<AnnotationMirror> v = e.getValue();\n+            boolean equal = compare(pos.annotation(k), v);\n+            allEqual &= equal;\n+        }\n+        return allEqual;\n+    }\n+\n+    private Map<ElementKey, APIMap<AnnotationMirror>> extractAnnotations(APIMap<? extends AnnotatedConstruct> acMap) {\n+        Map<ElementKey, APIMap<AnnotationMirror>> annoMap = new HashMap<>();\n+        for (Map.Entry<API, ? extends AnnotatedConstruct> entry : acMap.entrySet()) {\n+            API api = entry.getKey();\n+            AnnotatedConstruct c = entry.getValue();\n+            for (AnnotationMirror am : c.getAnnotationMirrors()) {\n+                if (isIncluded(api, am)) {\n+                    annoMap.computeIfAbsent(ElementKey.of(am.getAnnotationType().asElement()), e -> APIMap.of())\n+                            .put(api, am);\n+                }\n+            }\n+        }\n+        return annoMap;\n+    }\n+\n+    private boolean isIncluded(API api, AnnotationMirror am) {\n+        return switch (accessKind) {\n+            case PUBLIC, PROTECTED -> api.isDocumented(am);\n+            default -> true;\n+        };\n+    }\n+\n+    \/**\n+     * Compares the annotations found at a given position in the instances of\n+     * the APIs being compared.\n+     *\n+     * @param pos the position\n+     * @param map the annotations\n+     * @return {@code true} if and only if all the annotations are equal\n+     *\/\n+    public boolean compare(Position pos, APIMap<AnnotationMirror> map) {\n+        Map<ElementKey, APIMap<AnnotationValue>> valueMap = new HashMap<>();\n+        for (Map.Entry<API, AnnotationMirror> entry : map.entrySet()) {\n+            API api = entry.getKey();\n+            AnnotationMirror am = entry.getValue();\n+            Map<? extends ExecutableElement, ? extends AnnotationValue> values = api.getAnnotationValuesWithDefaults(am);\n+            for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> e : values.entrySet()) {\n+                ExecutableElement ee = e.getKey();\n+                AnnotationValue av = e.getValue();\n+                valueMap.computeIfAbsent(ElementKey.of(ee), e_ -> APIMap.of()).put(api, av);\n+            }\n+        }\n+\n+        boolean allEqual = true;\n+        reporter.comparing(pos, map);\n+        try {\n+            for (Map.Entry<ElementKey, APIMap<AnnotationValue>> entry : valueMap.entrySet()) {\n+                ElementKey key = entry.getKey();\n+                APIMap<AnnotationValue> avMap = entry.getValue();\n+                allEqual &= new AnnotationValueComparator(pos.annotationValue(key)).compare(avMap);\n+            }\n+        } finally {\n+            reporter.completed(pos, allEqual);\n+        }\n+\n+        return allEqual;\n+    }\n+\n+    class AnnotationValueComparator extends AbstractAnnotationValueVisitor14<Boolean, APIMap<AnnotationValue>> {\n+\n+        private final Position pos;\n+\n+        AnnotationValueComparator(Position pos) {\n+            this.pos = pos;\n+        }\n+\n+        boolean compare(APIMap<AnnotationValue> avMap) {\n+            boolean equal = false;\n+            reporter.comparing(pos, avMap);\n+            try {\n+                AnnotationValue baseline = avMap.values().stream()\n+                        .filter(Objects::nonNull)\n+                        .findFirst()\n+                        .orElse(null);\n+                if (baseline == null) {\n+                    \/\/ no non-null value found, so all must be null, and hence equal\n+                    return true;\n+                }\n+                equal = visit(baseline, avMap);\n+            } finally {\n+                reporter.completed(pos, equal);\n+            }\n+            return equal;\n+        }\n+\n+        @Override\n+        public Boolean visitAnnotation(AnnotationMirror a, APIMap<AnnotationValue> avMap) {\n+            APIMap<AnnotationMirror> amMap = APIMap.of();\n+            for (Map.Entry<API, AnnotationValue> entry : avMap.entrySet()) {\n+                API api = entry.getKey();\n+                AnnotationValue av = entry.getValue();\n+                Object avo = av.getValue();\n+                if (avo instanceof AnnotationMirror) {\n+                    amMap.put(api, (AnnotationMirror) avo);\n+                } else {\n+                    reporter.reportDifferentAnnotationValues(pos, avMap);\n+                    return false;\n+                }\n+            }\n+            return AnnotationComparator.this.compare(pos, amMap);\n+        }\n+\n+        @Override\n+        public Boolean visitArray(List<? extends AnnotationValue> l, APIMap<AnnotationValue> avMap) {\n+            IntTable<AnnotationValue> t = new IntTable<>();\n+            for (Map.Entry<API, AnnotationValue> entry : avMap.entrySet()) {\n+                API api = entry.getKey();\n+                AnnotationValue av = entry.getValue();\n+                if (av.getValue() instanceof List<?>) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    List<? extends AnnotationValue> avList = (List<? extends AnnotationValue>) av.getValue();\n+                    t.put(api, avList);\n+                } else {\n+                    reporter.reportDifferentAnnotationValues(pos, avMap);\n+                    return false;\n+                }\n+            }\n+\n+            boolean allEqual = true;\n+            for (int i = 0; i < t.size(); i++) {\n+                APIMap<AnnotationValue> map = t.entries(i);\n+                allEqual &= new AnnotationValueComparator(pos.annotationArrayIndex(i)).compare(map);\n+            }\n+            return allEqual;\n+        }\n+\n+        @Override\n+        public Boolean visitBoolean(boolean b, APIMap<AnnotationValue> avMap) {\n+            return compare(b, avMap);\n+        }\n+\n+        @Override\n+        public Boolean visitByte(byte b, APIMap<AnnotationValue> avMap) {\n+            return compare(b, avMap);\n+        }\n+\n+        @Override\n+        public Boolean visitChar(char c, APIMap<AnnotationValue> avMap) {\n+            return compare(c, avMap);\n+        }\n+\n+        @Override\n+        public Boolean visitDouble(double d, APIMap<AnnotationValue> avMap) {\n+            return compare(d, avMap);\n+        }\n+\n+        @Override\n+        public Boolean visitEnumConstant(VariableElement ve, APIMap<AnnotationValue> avMap) {\n+            return compare(ElementKey.of(ve), avMap, o -> {\n+                if (!(o instanceof VariableElement))\n+                    return false;\n+                return ElementKey.of((VariableElement) o);\n+            });\n+        }\n+\n+        @Override\n+        public Boolean visitFloat(float f, APIMap<AnnotationValue> avMap) {\n+            return compare(f, avMap);\n+        }\n+\n+        @Override\n+        public Boolean visitInt(int i, APIMap<AnnotationValue> avMap) {\n+            return compare(i, avMap);\n+        }\n+\n+        @Override\n+        public Boolean visitLong(long l, APIMap<AnnotationValue> avMap) {\n+            return compare(l, avMap);\n+        }\n+\n+        @Override\n+        public Boolean visitShort(short s, APIMap<AnnotationValue> avMap) {\n+            return compare(s, avMap);\n+        }\n+\n+        @Override\n+        public Boolean visitString(String s, APIMap<AnnotationValue> avMap) {\n+            return compare(s, avMap);\n+        }\n+\n+        @Override\n+        public Boolean visitType(TypeMirror t, APIMap<AnnotationValue> avMap) {\n+            return compare(TypeMirrorKey.of(t), avMap, o -> {\n+                if (!(o instanceof TypeMirror))\n+                    return false;\n+                return TypeMirrorKey.of((TypeMirror) o);\n+            });\n+        }\n+\n+        @Override\n+        public Boolean visitUnknown(AnnotationValue av, APIMap<AnnotationValue> avMap) {\n+            \/\/ should not happen!\n+            reporter.reportDifferentAnnotationValues(pos, avMap);\n+            return false;\n+        }\n+\n+        \/**\n+         * Compares an object against all the given annotation values, using {@code Object.equals}.\n+         * @param o the object\n+         * @param avMap the collection of annotation values\n+         * @return {@code true} if the object equals all the annotation values\n+         *\/\n+        private boolean compare(Object o,  APIMap<AnnotationValue> avMap) {\n+            for (AnnotationValue v : avMap.values()) {\n+                if (v == null || !o.equals(v.getValue())) {\n+                    reporter.reportDifferentAnnotationValues(pos, avMap);\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        \/**\n+         * Compares an object against all the given annotation values, a function to derive a value\n+         * to be compare with using {@code Object.equals}.\n+         * @param o the object\n+         * @param avMap the collection of annotation values\n+         * @return {@code true} if the object equals all the transformed annotation values\n+         *\/\n+        private boolean compare(Object o, APIMap<AnnotationValue> avMap, Function<Object, ?> f) {\n+            for (AnnotationValue v : avMap.values()) {\n+                if (v == null || !o.equals(f.apply(v.getValue()))) {\n+                    reporter.reportDifferentAnnotationValues(pos, avMap);\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/AnnotationComparator.java","additions":321,"deletions":0,"binary":false,"changes":321,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.Set;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+\n+\/**\n+ * A comparator for {@link DocCommentTree documentation comments}.\n+ *\/\n+public class DocCommentComparator {\n+    private final Set<API> apis;\n+\n+    \/**\n+     * Creates a comparator for instances of documentation comments found in\n+     * different APIs.\n+     *\n+     * @param apis the APIs\n+     *\/\n+    public DocCommentComparator(Set<API> apis) {\n+        this.apis = apis;\n+    }\n+\n+    \/**\n+     * Compare instances of a documentation comment for an element in different APIs.\n+     *\n+     * @param dPos the position of the element\n+     * @param dMap the map giving the instance of the comment in different APIs\n+     * @return {@code true} if all the instances are equivalent\n+     *\/\n+    public boolean compare(Position dPos, APIMap<DocCommentTree> dMap) {\n+        \/\/ TODO: compare first sentence, body, sorted block tags\n+        return true;\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/DocCommentComparator.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.Element;\n+import javax.tools.JavaFileObject;\n+\n+\/**\n+ * An object representing a file in a {@code doc-files} subdirectory\n+ * of the source directory or generated API directory for a package.\n+ *\/\n+public class DocFile {\n+    \/**\n+     * The standard name of the subdirectory used for doc files.\n+     *\/\n+    public static final String DOC_FILES = \"doc-files\";\n+\n+    \/**\n+     * The API for the doc file.\n+     *\/\n+    public final API api;\n+\n+    \/**\n+     * The element that \"contains\" the doc file.  It may be a module element or a package element.\n+     *\/\n+    public final Element element;\n+\n+    \/**\n+     * The source and\/or API file.\n+     * One or the other (but not both) may be null if no such file is found.\n+     *\/\n+    public final Map<API.LocationKind, JavaFileObject> files;\n+\n+    \/**\n+     * Returns a table built by listing all the files in the {@code doc-files}\n+     * subdirectory of  the source and generated API directories for a module or package.\n+     *\n+     * @param pMap the map of corresponding packages in the APIs being compared\n+     *\n+     * @return the table\n+     *\/\n+    static Map<String, APIMap<DocFile>> listDocFiles(APIMap<? extends Element> pMap) {\n+        Set<JavaFileObject.Kind> allKinds = EnumSet.allOf(JavaFileObject.Kind.class);\n+        Map<String, APIMap<DocFile>> fMap = new TreeMap<>();\n+        pMap.forEach((api, e) -> {\n+            for (API.LocationKind lk : API.LocationKind.values()) {\n+                for (JavaFileObject fo : api.listFiles(lk, e, DOC_FILES, allKinds, true)) {\n+\n+                    \/\/ There is no supported way to get the name of the file relative to the package in which\n+                    \/\/ the search was done.  JavaFileManager.inferBinaryName comes close, but is not ideal.\n+                    \/\/ The following assumes that \"doc-files\" only appears once in the path name.\n+                    \/\/ A more rigorous check would be to include the module name or package name,\n+                    \/\/ but even that is not guaranteed to be unique.\n+\n+                    String name = fo.getName();\n+                    int index = name.indexOf(DOC_FILES);\n+                    if (index == -1) {\n+                        throw new IllegalArgumentException(fo.getName());\n+                    }\n+                    String path = name.substring(index + DOC_FILES.length() + 1);\n+\n+                    APIMap<DocFile> dMap = fMap.computeIfAbsent(path, __ -> APIMap.of());\n+                    DocFile df = dMap.computeIfAbsent(api, __ -> new DocFile(api, e));\n+                    df.files.put(lk, fo);\n+                }\n+            }\n+        });\n+        return fMap;\n+    }\n+\n+    private DocFile(API api, Element element) {\n+        this.api = api;\n+        this.element = element;\n+        this.files = new EnumMap<>(API.LocationKind.class);\n+    }\n+\n+    \/**\n+     * Returns the kind of these doc files.\n+     * By construction, they all have the same file name, and hence all have the\n+     * same kind, so it is sufficient to just pick one.\n+     *\n+     * @return the kind\n+     *\/\n+    public JavaFileObject.Kind getKind() {\n+        return files.values().iterator().next().getKind();\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/DocFile.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.tools.JavaFileObject;\n+\n+import jdk.codetools.apidiff.Options;\n+import jdk.codetools.apidiff.model.API.LocationKind;\n+import jdk.codetools.apidiff.report.Reporter;\n+\n+\/**\n+ * A comparator for the \"doc files\" for a package.\n+ * These are the files in the \"doc-files\" subdirectory of the\n+ * source directories for the package, or in the \"doc-files\"\n+ * subdirectory of the directory for the package in the generated\n+ * API.\n+ *\n+ * <p>The comparison includes:\n+ * <ul>\n+ *     <li>the documentation comment for HTML files found in the source directory\n+ *     <li>the API description for HTML files found in the generated API directory\n+ *     <li>other files in the source and generated API directories\n+ * <\/ul>\n+ *\/\n+public class DocFilesComparator {\n+    \/** The APIs to be compared. *\/\n+    protected final Set<API> apis;\n+    \/** The command-line options. *\/\n+    protected final Options options;\n+    \/** The reporter to which to report any differences. *\/\n+    protected final Reporter reporter;\n+\n+    \/**\n+     * Creates a comparator to compare \"doc files\" across a set of APIs.\n+     *\n+     * @param apis the set of APIs\n+     * @param reporter the reporter to which to report differences\n+     *\/\n+    public DocFilesComparator(Set<API> apis, Options options, Reporter reporter) {\n+        this.apis = apis;\n+        this.options = options;\n+        this.reporter = reporter;\n+    }\n+\n+    \/**\n+     * Compares all the doc files with the same name within instances of an API.\n+     *\n+     * @param pPos the position for the package containing the doc files\n+     * @param table the table containing the doc files to be compared\n+     *\n+     * @return {@code true} if and only if all the elements are equal\n+     *\/\n+    public boolean compareAll(Position pPos, Map<String, APIMap<DocFile>> table) {\n+        boolean allEqual = true;\n+        for (Map.Entry<String, APIMap<DocFile>> e : table.entrySet()) {\n+            String name = e.getKey();\n+            APIMap<DocFile> fMap = e.getValue();\n+            boolean equal = compare(pPos.docFile(name), fMap);\n+            allEqual &= equal;\n+        }\n+        return allEqual;\n+    }\n+\n+    private boolean compare(Position fPos, APIMap<DocFile> fMap) {\n+        boolean allEqual = false;\n+        reporter.comparing(fPos, fMap);\n+        try {\n+            allEqual = checkMissing(fPos, fMap);\n+            if (fMap.size() > 1) {\n+                \/\/ compare doc comments and API description for HTML files;\n+                \/\/ compare file contents for all other files (typically images)\n+                if (fMap.values().iterator().next().getKind() == JavaFileObject.Kind.HTML) {\n+                    allEqual &= compareDocComments(fPos, fMap);\n+                    allEqual &= compareApiDescriptions(fPos, fMap);\n+                } else {\n+                    allEqual &= compareFiles(fPos, fMap);\n+                }\n+            }\n+        } finally {\n+            reporter.completed(fPos, allEqual);\n+        }\n+        return allEqual;\n+    }\n+\n+    \/**\n+     * Checks whether any expected doc files are missing in any APIs.\n+     * Missing files will be reported to the comparator's reporter.\n+     *\n+     * @param fPos the position of the file\n+     * @param fMap the map giving the files in the different APIs\n+     * @return {@code true} if all the expected files are found\n+     *\/\n+    private boolean checkMissing(Position fPos, APIMap<DocFile> fMap) {\n+        Set<API> missing = apis.stream()\n+                .filter(a -> !fMap.containsKey(a))\n+                .collect(Collectors.toSet()); \/\/ warning: unordered\n+\n+        if (missing.isEmpty()) {\n+            return true;\n+        } else {\n+            reporter.reportMissing(fPos, missing);\n+            return false;\n+        }\n+    }\n+\n+\n+    \/**\n+     * Compares the documentation for the doc files at a given position in\n+     * different instances of an API.\n+     *\n+     * @param fPos the position\n+     * @param fMap the map of file files\n+     * @return {@code true} if and only if all the instances of the documentation are equal\n+     *\/\n+    protected boolean compareDocComments(Position fPos, APIMap<DocFile> fMap) {\n+        if (!options.compareDocComments()) {\n+            return true;\n+        }\n+\n+        \/\/ TODO: make this depend on command-line options to compare some combination of\n+        \/\/       raw doc comments, (parsed) doc comments.\n+\/\/        APIMap<DocCommentTree> docComments = APIMap.of();\n+\/\/        for (Map.Entry<API, E> e : eMap.entrySet()) {\n+\/\/            API api = e.getKey();\n+\/\/            Element te = e.getValue();\n+\/\/            DocCommentTree dct = api.getDocComment(te);\n+\/\/            if (dct != null) {\n+\/\/                docComments.put(api, dct);\n+\/\/            }\n+\/\/        }\n+\/\/        DocCommentComparator dc = new DocCommentComparator(eMap.keySet());\n+\/\/        return dc.compare(ePos, docComments);\n+\n+        APIMap<String> rawDocComments = fMap.map((api, df) -> {\n+            JavaFileObject fo = df.files.get(LocationKind.SOURCE);\n+            return fo == null ? \"\" : api.getTrees().getDocCommentTree(fo).toString();\n+        });\n+\n+        \/\/ raw doc comments are equal if none of the doc-files has a doc comment,\n+        \/\/ or if they all have the same doc comment.\n+        boolean allEqual = rawDocComments.isEmpty()\n+                || rawDocComments.size() == fMap.size() && rawDocComments.values().stream().distinct().count() == 1;\n+        if (!allEqual) {\n+            reporter.reportDifferentRawDocComments(fPos, rawDocComments);\n+        }\n+        return allEqual;\n+    }\n+\n+    \/**\n+     * Compares the API descriptions for the doc files at a given position\n+     * in different instances of an API.\n+     *\n+     * @param fPos the position\n+     * @param fMap the map of doc files\n+     *\n+     * @return {@code true} if and only if all the instances of the API description are equal\n+     *\/\n+    protected boolean compareApiDescriptions(Position fPos, APIMap<DocFile> fMap) {\n+        if (!options.compareApiDescriptions()) {\n+            return true;\n+        }\n+\n+        APIMap<String> apiDescriptions = fMap.map((api, df) -> {\n+            JavaFileObject fo = df.files.get(LocationKind.API);\n+            return fo == null ? \"\" : api.getApiDescription(fo);\n+        });\n+\n+        \/\/ API descriptions are equal if none of the doc-files has a description,\n+        \/\/ or if they all have the same description.\n+        boolean allEqual = apiDescriptions.isEmpty()\n+                || apiDescriptions.size() == fMap.size() && apiDescriptions.values().stream().distinct().count() == 1;\n+        if (!allEqual) {\n+            reporter.reportDifferentApiDescriptions(fPos, apiDescriptions);\n+        }\n+        return allEqual;\n+    }\n+\n+    private boolean compareFiles(Position fPos, APIMap<DocFile> fMap) {\n+        return compareFiles(fPos, fMap, API.LocationKind.SOURCE)\n+                && compareFiles(fPos, fMap, API.LocationKind.API);\n+    }\n+\n+    private boolean compareFiles(Position fPos, APIMap<DocFile> fMap, API.LocationKind kind) {\n+        \/\/ If there are no files at all in this location-kind, that's OK,\n+        \/\/ and they are vacuously equal.\n+        boolean noFiles = fMap.values().stream().allMatch(df -> df.files.get(kind) == null);\n+        if (noFiles) {\n+            return true;\n+        }\n+\n+        \/\/ But if some files are present and some are missing, that's an automatic difference.\n+        boolean missingFiles = fMap.values().stream().anyMatch(df -> df.files.get(kind) == null);\n+        if (missingFiles) {\n+            return false;\n+        }\n+\n+        \/\/ Otherwise, compare the contents of each file (other than the first) against the first.\n+        \/\/ While it would be possible to open streams on each file, and read\/compare the streams\n+        \/\/ in parallel, that seems overall. And note, for reference, we do read the full contents\n+        \/\/ of HTML files into memory.\n+        byte[] ref = null;\n+        for (Map.Entry<API, DocFile> entry : fMap.entrySet()) {\n+            API api = entry.getKey();\n+            DocFile df = entry.getValue();\n+            byte[] bytes = api.getAllBytes(df.files.get(kind));\n+            if (bytes == null) {\n+                return false;\n+            }\n+            if (ref == null) {\n+                ref = bytes;\n+            } else if (!Arrays.equals(ref, bytes)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/DocFilesComparator.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -0,0 +1,307 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.EnumSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.Modifier;\n+\n+import jdk.codetools.apidiff.Options;\n+import jdk.codetools.apidiff.report.Reporter;\n+\n+\/**\n+ * A base class for comparators that compare elements.\n+ *\n+ * @param <E> the type of element to be compared\n+ *\/\n+public abstract class ElementComparator<E extends Element> {\n+    \/** The APIs to be compared. *\/\n+    protected final Set<API> apis;\n+    \/** The command-line options. *\/\n+    protected final Options options;\n+    \/** The access kind. *\/\n+    protected final AccessKind accessKind;\n+    \/** The reporter to which to report any differences. *\/\n+    protected final Reporter reporter;\n+\n+    \/**\n+     * Creates an instance of comparator for elements.\n+     *\n+     * @param apis     the APIs being compared\n+     * @param options  the command line options\n+     * @param reporter the reporter to which to report any differences.\n+     *\/\n+    protected ElementComparator(Set<API> apis, Options options, Reporter reporter) {\n+        this.apis = apis;\n+        this.options = options;\n+        this.accessKind = options.getAccessKind();\n+        this.reporter = reporter;\n+    }\n+\n+    \/**\n+     * Compares all the elements with equivalent keys within instances of an API.\n+     *\n+     * @param table the table containing the elements to be compared\n+     * @return {@code true} if and only if all the elements are equal\n+     *\/\n+    public boolean compareAll(KeyTable<E> table) {\n+        boolean allEqual = true;\n+        for (Map.Entry<ElementKey, APIMap<E>> e : table.entries()) {\n+            ElementKey k = e.getKey();\n+            APIMap<E> v = e.getValue();\n+            boolean equal = compare(k, v);\n+            allEqual &= equal;\n+        }\n+        return allEqual;\n+    }\n+\n+    \/**\n+     * Compares all the elements at equivalent positions within instances of an API.\n+     *\n+     * @param f a function to provide the position of each row in the table\n+     * @param table the table containing the elements to be compared\n+     * @return {@code true} if and only if all the elements are equal\n+     *\/\n+    public boolean compareAll(Function<Integer, Position> f, IntTable<E> table) {\n+        boolean allEqual = true;\n+        for (int i = 0; i < table.size(); i++) {\n+            allEqual &= compare(f.apply(i), table.entries(i));\n+        }\n+        return allEqual;\n+    }\n+\n+    \/**\n+     * Compares the elements found at the given position in different APIs.\n+     *\n+     * <p>This implementation delegates to {@link #compare(Position, APIMap)}.\n+     *\n+     * @param eKey the key for the element\n+     * @param eMap the map giving the elements in the different APIs\n+     * @return {@code true} if all the elements are equal\n+     *\/\n+    public boolean compare(ElementKey eKey, APIMap<E> eMap) {\n+        return compare(Position.of(eKey), eMap);\n+    }\n+\n+    \/**\n+     * Compares the elements found at the given position in different APIs.\n+     *\n+     * @param ePos the position of the element\n+     * @param eMap the map giving the elements in the different APIs\n+     * @return {@code true} if all the elements are equal\n+     *\/\n+    public abstract boolean compare(Position ePos, APIMap<E> eMap);\n+\n+    \/**\n+     * Checks whether any expected elements are missing in any APIs.\n+     * Missing elements will be reported to the comparator's reporter.\n+     *\n+     * @param ePos the position of the element\n+     * @param eMap the map giving the elements in the different APIs\n+     * @return {@code true} if all the expected elements are found\n+     *\/\n+    public boolean checkMissing(Position ePos, APIMap<E> eMap) {\n+        Set<API> missing = apis.stream()\n+                .filter(a -> !eMap.containsKey(a))\n+                .collect(Collectors.toSet()); \/\/ warning: unordered\n+\n+        if (missing.isEmpty()) {\n+            return true;\n+        } else {\n+            reporter.reportMissing(ePos, missing);\n+            return false;\n+        }\n+    }\n+\n+    \/**\n+     * Compares the annotations for elements at a given position in\n+     * different instances of an API.\n+     *\n+     * @param ePos the position\n+     * @param eMap the map of elements\n+     * @return {@code true} if and only if all the annotations are equal\n+     *\/\n+    protected boolean compareAnnotations(Position ePos, APIMap<E> eMap) {\n+        AnnotationComparator ac = new AnnotationComparator(eMap.keySet(), accessKind, reporter);\n+        return ac.compareAll(ePos, eMap);\n+    }\n+\n+    \/**\n+     * Compares the documentation for the elements at a given position in\n+     * different instances of an API.\n+     *\n+     * @param ePos the position\n+     * @param eMap the map of elements\n+     * @return {@code true} if and only if all the instances of the documentation are equal\n+     *\/\n+    protected boolean compareDocComments(Position ePos, APIMap<E> eMap) {\n+        if (!options.compareDocComments()) {\n+            return true;\n+        }\n+\n+\/\/        APIMap<DocCommentTree> docComments = APIMap.of();\n+\/\/        for (Map.Entry<API, E> e : eMap.entrySet()) {\n+\/\/            API api = e.getKey();\n+\/\/            Element te = e.getValue();\n+\/\/            DocCommentTree dct = api.getDocComment(te);\n+\/\/            if (dct != null) {\n+\/\/                docComments.put(api, dct);\n+\/\/            }\n+\/\/        }\n+\/\/        DocCommentComparator dc = new DocCommentComparator(eMap.keySet());\n+\/\/        return dc.compare(ePos, docComments);\n+\n+        APIMap<String> rawDocComments = APIMap.of();\n+        for (Map.Entry<API, E> entry : eMap.entrySet()) {\n+            API api = entry.getKey();\n+            Element e = entry.getValue();\n+            String c = getDocComment(api, e);\n+            if (c != null) {\n+                rawDocComments.put(api, c);\n+            }\n+        }\n+        \/\/ raw doc comments are equal if none of the elements has a doc comment,\n+        \/\/ or if they all have the same doc comment.\n+        boolean allEqual = rawDocComments.isEmpty()\n+                || rawDocComments.size() == eMap.size() && rawDocComments.values().stream().distinct().count() == 1;\n+        if (!allEqual) {\n+            reporter.reportDifferentRawDocComments(ePos, rawDocComments);\n+        }\n+        return allEqual;\n+    }\n+\n+    \/**\n+     * Returns the doc comment for an element in a given API.\n+     *\n+     * <p>This implementation uses {@link API#getElements()}.getDocComment(Element)}.\n+     *\n+     * @param api the API\n+     * @param e   the element\n+     *\n+     * @return the doc comment\n+     *\/\n+    protected String getDocComment(API api, Element e) {\n+        return api.getElements().getDocComment(e);\n+    }\n+\n+    \/**\n+     * Compares the API descriptions for the elements at a given position\n+     * in different instances of an API.\n+     *\n+     * @param ePos the position\n+     * @param eMap the map of elements\n+     *\n+     * @return {@code true} if and only if all the instances of the API description are equal\n+     *\/\n+    protected boolean compareApiDescriptions(Position ePos, APIMap<E> eMap) {\n+        if (!options.compareApiDescriptions()) {\n+            return true;\n+        }\n+\n+        APIMap<String> apiDescriptions = APIMap.of();\n+        for (Map.Entry<API, E> entry : eMap.entrySet()) {\n+            API api = entry.getKey();\n+            Element e = entry.getValue();\n+            String c = getApiDescription(api, e);\n+            if (c != null) {\n+                apiDescriptions.put(api, c);\n+            }\n+        }\n+        \/\/ API descriptions are equal if none of the elements has a description,\n+        \/\/ or if they all have the same doc comment.\n+        boolean allEqual = apiDescriptions.isEmpty()\n+                || apiDescriptions.size() == eMap.size() && apiDescriptions.values().stream().distinct().count() == 1;\n+        if (!allEqual) {\n+            reporter.reportDifferentApiDescriptions(ePos, apiDescriptions);\n+        }\n+        return allEqual;\n+    }\n+\n+\n+    \/**\n+     * Returns the API description for an element in a given API.\n+     *\n+     * <p>This implementation uses {@link API#getApiDescription(Element)}.\n+     *\n+     * @param api the API\n+     * @param e   the element\n+     *\n+     * @return the API description\n+     *\/\n+    protected String getApiDescription(API api, Element e) {\n+        return api.getApiDescription(e);\n+    }\n+\n+    \/**\n+     * Compares the doc files for a module or package at a given position\n+     * in different instance of an API.\n+     *\n+     * @param ePos the position\n+     * @param eMap the map of elements\n+     *\n+     * @return {@code true} if and only if all the doc files are equal\n+     *\/\n+    protected boolean compareDocFiles(Position ePos, APIMap<? extends Element> eMap) {\n+        Map<String, APIMap<DocFile>> fMap = DocFile.listDocFiles(eMap);\n+        DocFilesComparator dfc = new DocFilesComparator(apis, options, reporter);\n+        return dfc.compareAll(ePos, fMap);\n+    }\n+\n+    \/**\n+     * Compares the modifiers for the elements at a given position in\n+     * different instances of an API.\n+     *\n+     * @param ePos the position\n+     * @param eMap the map of elements\n+     * @return {@code true} if and only if all the modifiers are equal\n+     *\/\n+    protected boolean compareModifiers(Position ePos, APIMap<E> eMap) {\n+        if (eMap.size() == 1)\n+            return true;\n+\n+        Set<Modifier> baseline = null;\n+        for (E e : eMap.values()) {\n+            Set<Modifier> modifiers = e.getModifiers();\n+            if (modifiers.contains(Modifier.NATIVE) || modifiers.contains(Modifier.SYNCHRONIZED)) {\n+                modifiers = EnumSet.copyOf(modifiers);\n+                modifiers.removeAll(EnumSet.of(Modifier.NATIVE, Modifier.SYNCHRONIZED));\n+            }\n+            if (baseline == null) {\n+                baseline = modifiers;\n+            } else if (!baseline.equals(modifiers)) {\n+                reporter.reportDifferentModifiers(ePos, eMap);\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/ElementComparator.java","additions":307,"deletions":0,"binary":false,"changes":307,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+\/**\n+ * A class to encapsulate reflective access to recent API, thereby allowing the\n+ * tool to run on older versions of the platform when such API is not required.\n+ *\/\n+public class ElementExtras {\n+    public class Fault extends Error {\n+        Fault(Throwable cause) {\n+            super(cause);\n+        }\n+    }\n+\n+    private static final ElementExtras instance = new ElementExtras();\n+\n+    private final Runtime.Version version = Runtime.version();\n+    private final Method getRecordComponentsMethod;\n+    private final Method getPermittedSubclassesMethod;\n+\n+    \/**\n+     * Returns the instance of this class.\n+     *\n+     * @return the instance\n+     *\/\n+    public static ElementExtras instance() {\n+        return instance;\n+    }\n+\n+    \/**\n+     * Creates the one instance of this class.\n+     *\/\n+    private ElementExtras() {\n+        getRecordComponentsMethod = lookup(14, TypeElement.class, \"getRecordComponents\");\n+        getPermittedSubclassesMethod = lookup(15, TypeElement.class, \"getPermittedSubclasses\");\n+    }\n+\n+    private Method lookup(int since, Class<?> c, String name, Class<?>... paramTypes) {\n+        try {\n+            if (version.feature() >= since) {\n+                return c.getDeclaredMethod(name, paramTypes);\n+            }\n+        } catch (ReflectiveOperationException e) {\n+            System.err.println(\"Cannot find \" + c + \".\" + name + \"(\" +\n+                    Stream.of(paramTypes).map(Class::getSimpleName).collect(Collectors.joining(\",\"))\n+                    + \")\");\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Invokes {@code TypeElement.getRecordComponents()} for a type element, if the method is available,\n+     * and returns the result of calling that method.\n+     * If the method is not available, {@code null} is returned.\n+     *\n+     * @param e the element\n+     * @return the result of calling {@code TypeElement.getRecordComponent()}, or {@code null}\n+     *\/\n+    public List<? extends Element> getRecordComponents(TypeElement e) {\n+        if (getRecordComponentsMethod == null) {\n+            return Collections.emptyList();\n+        }\n+\n+        try {\n+            return (List<? extends Element>) getRecordComponentsMethod.invoke(e);\n+        } catch (InvocationTargetException ite) {\n+            Throwable cause = ite.getCause();\n+            if (cause instanceof RuntimeException) {\n+                throw (RuntimeException) cause;\n+            } else if (cause instanceof Error) {\n+                throw (Error) cause;\n+            } else {\n+                throw new Fault(ite);\n+            }\n+        } catch (ReflectiveOperationException roe) {\n+            throw new Fault(roe);\n+        }\n+    }\n+\n+    \/**\n+     * Invokes {@code TypeElement.getPermittedSubclasses()} for a type element, if the method is available,\n+     * and returns the result of calling that method.\n+     * If the method is not available, {@code null} is returned.\n+     *\n+     * @param e the element\n+     * @return the result of calling {@code TypeElement.getPermittedSubclasses()}, or {@code null}\n+     *\/\n+    public List<? extends TypeMirror> getPermittedSubclasses(TypeElement e) {\n+        if (getPermittedSubclassesMethod == null) {\n+            return Collections.emptyList();\n+        }\n+\n+        try {\n+            return (List<? extends TypeMirror>) getPermittedSubclassesMethod.invoke(e);\n+        } catch (InvocationTargetException ite) {\n+            Throwable cause = ite.getCause();\n+            if (cause instanceof RuntimeException) {\n+                throw (RuntimeException) cause;\n+            } else if (cause instanceof Error) {\n+                throw (Error) cause;\n+            } else {\n+                throw new Fault(ite);\n+            }\n+        } catch (ReflectiveOperationException roe) {\n+            throw new Fault(roe);\n+        }\n+    }\n+\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/ElementExtras.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,825 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.lang.ref.SoftReference;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.WeakHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ElementVisitor;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.Name;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.RecordComponentElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.SimpleElementVisitor14;\n+\n+\/**\n+ * A lightweight wrapper for an element that is independent of any API environment and\n+ * that can be used to associate corresponding elements in different instances of an API.\n+ * It can also be used to check for nominal equality of reference types in a type mirror.\n+ *\n+ * <p>Values are cached in a memory-sensitive cache.\n+ *\n+ * @see KeyTable\n+ *\/\n+public abstract sealed class ElementKey implements Comparable<ElementKey> {\n+    \/**\n+     * The {@code kind} of an element key.\n+     *\/\n+    public enum Kind {\n+        \/** A module. *\/\n+        MODULE,\n+        \/** A package. *\/\n+        PACKAGE,\n+        \/** A class or interface. *\/\n+        TYPE,\n+        \/** An executable element. *\/\n+        EXECUTABLE,\n+        \/** A variable (field) element. *\/\n+        VARIABLE,\n+        \/** A type parameter element. *\/\n+        TYPE_PARAMETER\n+    }\n+\n+    private static final ElementVisitor<ElementKey,Void> factory = new SimpleElementVisitor14<>() {\n+        @Override\n+        public ElementKey visitModule(ModuleElement e, Void _p) {\n+            return new ModuleElementKey(e);\n+        }\n+        @Override\n+        public ElementKey visitPackage(PackageElement e, Void _p) {\n+            return new PackageElementKey(e);\n+        }\n+        @Override\n+        public ElementKey visitType(TypeElement e, Void _p) {\n+            return new TypeElementKey(e);\n+        }\n+        @Override\n+        public ElementKey visitExecutable(ExecutableElement e, Void _p) {\n+            return new ExecutableElementKey(e);\n+        }\n+        @Override\n+        public ElementKey visitVariable(VariableElement e, Void _p) {\n+            return new VariableElementKey(e);\n+        }\n+        @Override\n+        public ElementKey visitTypeParameter(TypeParameterElement e, Void _p) {\n+            return new TypeParameterElementKey(e);\n+        }\n+        @Override\n+        public ElementKey visitRecordComponent(RecordComponentElement e, Void _p) {\n+            return new VariableElementKey((VariableElement) e);\n+        }\n+        @Override\n+        public ElementKey defaultAction(Element e, Void _p) {\n+            throw new UnsupportedOperationException(e.getKind() + \" \" + e);\n+        }\n+    };\n+\n+    \/\/ TODO: handle javax.lang.model.element.UnknownElementException; maybe handle visitUnknown in the factory visitor;\n+    \/\/       the error may arise for unknown annotation types\n+    private static final Cache<Element,ElementKey> cache = new Cache<>(e -> factory.visit(e, null));\n+\n+    \/**\n+     * Returns the key for an element.\n+     *\n+     * @param e the element\n+     *\n+     * @return they key\n+     *\/\n+    public static ElementKey of(Element e) {\n+        return cache.get(e);\n+    }\n+\n+    public final Kind kind;\n+\n+    \/**\n+     * Creates a key with a given kind.\n+     *\n+     * @param kind the kind.\n+     *\/\n+    protected ElementKey(Kind kind) {\n+        this.kind = kind;\n+    }\n+\n+    \/**\n+     * Returns the enclosing element key, or {@code null} if none.\n+     *\n+     * @return the enclosing element key\n+     *\/\n+    public abstract ElementKey getEnclosingKey();\n+\n+    \/**\n+     * Applies a visitor to this key.\n+     *\n+     * @param v   the visitor\n+     * @param p   a visitor-specified parameter\n+     * @param <R> the type of the result\n+     * @param <P> the type of the parameter\n+     *\n+     * @return a visitor-specified result\n+     *\/\n+    public abstract <R, P> R accept(Visitor<R,P> v, P p);\n+\n+    \/**\n+     * Checks whether this key is of a given kind.\n+     *\n+     * @param kind the kind\n+     *\n+     * @return {@code true} if and only if the key is of the given kind\n+     *\/\n+    public boolean is(Kind kind) {\n+        return kind == this.kind;\n+    }\n+\n+    \/**\n+     * Checks whether this key is of a given kind.\n+     *\n+     * @param kind the kind\n+     *\n+     * @return {@code true} if and only if the key is of the given kind\n+     *\/\n+    public abstract boolean is(ElementKind kind);\n+\n+    \/**\n+     * Compares two names.\n+     *\n+     * @param n1 the first name\n+     * @param n2 the second name\n+     *\n+     * @return the result of the comparison\n+     *\/\n+    protected static int compare(Name n1, Name n2) {\n+        \/\/ For now, just do a simple lexicographic compare.\n+        \/\/ We may want to upgrade this to do a case-ignore comparison first,\n+        \/\/ and only do a case-significant comparison if the case-ignore reports equal.\n+        \/\/ This would be to get the following example sort order:\n+        \/\/   double, Double, float, Float, int, Integer, etc\n+        return CharSequence.compare(n1, n2);\n+    }\n+\n+    \/**\n+     * Compares two lists of items.\n+     *\n+     * @param <T> the type of items in the list\n+     * @param l1  the first list\n+     * @param l2  the second list\n+     *\n+     * @return the result of the comparison\n+     *\/\n+    protected static <T extends Comparable<T>> int compare(List<T> l1, List<T> l2) {\n+        if (l1.isEmpty() && l2.isEmpty()) {\n+            return 0;\n+        }\n+        Iterator<T> iter1 = l1.iterator();\n+        Iterator<T> iter2 = l2.iterator();\n+        while (iter1.hasNext() && iter2.hasNext()) {\n+            int i = iter1.next().compareTo(iter2.next());\n+            if (i != 0) {\n+                return i;\n+            }\n+        }\n+        return iter1.hasNext() ? +1 : iter2.hasNext() ? -1 : 0;\n+    }\n+\n+    \/**\n+     * Compares two names for equality.\n+     *\n+     * @param n1 the first name\n+     * @param n2 the second name\n+     *\n+     * @return {@code true} if and only if the two names have the exact same contents\n+     *\/\n+    protected static boolean equals(Name n1, Name n2) {\n+        return n1.contentEquals(n2);\n+    }\n+\n+    \/**\n+     * Returns a non-zero hash code for a name.\n+     *\n+     * @param n the name\n+     *\n+     * @return the hash code\n+     *\/\n+    protected static int hashCode(Name n) {\n+        int hashCode = n.toString().hashCode();\n+        return (hashCode == 0) ? 1 : hashCode;\n+    }\n+\n+    \/**\n+     * A visitor of element keys, in the style of the visitor design pattern.\n+     * Classes implementing this interface are used to operate on an element key\n+     * when the kind of key is unknown at compile time.\n+     * When a visitor is passed to an element key's {@code accept} method,\n+     * the <code>visit<em>Xyz<\/em><\/code> method applicable to that key is invoked.\n+     *\n+     * @param <R> the return type of this visitor's methods.\n+     *            Use Void for visitors that do not need to return results.\n+     * @param <P> the type of the additional parameter to this visitor's methods.\n+     *            Use Void for visitors that do not need an additional parameter.\n+     *\/\n+    public interface Visitor<R,P> {\n+        \/**\n+         * Visits a key for a module element.\n+         *\n+         * @param k the key to visit\n+         * @param p a visitor-specified parameter\n+         *\n+         * @return a visitor-specified result\n+         *\/\n+        R visitModuleElement(ModuleElementKey k, P p);\n+\n+        \/**\n+         * Visits a key for a package element.\n+         *\n+         * @param k the key to visit\n+         * @param p a visitor-specified parameter\n+         *\n+         * @return a visitor-specified result\n+         *\/\n+        R visitPackageElement(PackageElementKey k, P p);\n+\n+        \/**\n+         * Visits a key for a type element.\n+         *\n+         * @param k the key to visit\n+         * @param p a visitor-specified parameter\n+         *\n+         * @return a visitor-specified result\n+         *\/\n+        R visitTypeElement(TypeElementKey k, P p);\n+\n+        \/**\n+         * Visits a key for an executable element.\n+         *\n+         * @param k the key to visit\n+         * @param p a visitor-specified parameter\n+         *\n+         * @return a visitor-specified result\n+         *\/\n+        R visitExecutableElement(ExecutableElementKey k, P p);\n+\n+        \/**\n+         * Visits a key for a variable element.\n+         *\n+         * @param k the key to visit\n+         * @param p a visitor-specified parameter\n+         *\n+         * @return a visitor-specified result\n+         *\/\n+        R visitVariableElement(VariableElementKey k, P p);\n+\n+        \/**\n+         * Visits a key for a type parameter element.\n+         *\n+         * @param k the key to visit\n+         * @param p a visitor-specified parameter\n+         *\n+         * @return a visitor-specified result\n+         *\/\n+        R visitTypeParameterElement(TypeParameterElementKey k, P p);\n+    }\n+\n+    \/**\n+     * A memory-sensitive cache of values generated by a factory.\n+     * The cache is a {@link WeakHashMap} of {@link SoftReference} values.\n+     *\n+     * @param <K> the type of keys for the cache\n+     * @param <V> the type of values stored in the cache\n+     *\/\n+    static class Cache<K,V> {\n+        private final Function<K, V> factory;\n+        private final WeakHashMap<K, SoftReference<V>> map = new WeakHashMap<>();\n+\n+        \/**\n+         * Creates a cache for values generated by a factory.\n+         *\n+         * @param factory the factory for values to be cached\n+         *\/\n+        Cache(Function<K,V> factory) {\n+            this.factory = factory;\n+        }\n+\n+        \/**\n+         * Gets the value for a key, creating it if it does not already exist.\n+         * Because values are stored in the cache with soft references, there\n+         * is no guarantee that the same value will be returned for the same key.\n+         *\n+         * @param k the key\n+         *\n+         * @return the value\n+         *\/\n+        synchronized V get(K k) {\n+            SoftReference<V> vr = map.get(k);\n+            V v = (vr == null) ? null : vr.get();\n+            if (v == null) {\n+                v = factory.apply(k);\n+                map.put(k, new SoftReference<>(v));\n+            }\n+            return v;\n+        }\n+    }\n+\n+    \/**\n+     * An element key for a module element.\n+     *\/\n+    public static final class ModuleElementKey extends ElementKey {\n+\n+        public final Name name;\n+        private int hashCode;\n+\n+        ModuleElementKey(ModuleElement me) {\n+            super(Kind.MODULE);\n+            name = me.getQualifiedName();\n+        }\n+\n+        @Override\n+        public ElementKey getEnclosingKey() {\n+            return null;\n+        }\n+\n+        @Override\n+        public int compareTo(ElementKey other) {\n+            int ck = kind.compareTo(other.kind);\n+            return (ck != 0) ? ck : compare(name, ((ModuleElementKey) other).name);\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            } else if (other == null || other.getClass() != getClass()) {\n+                return false;\n+            } else {\n+                return equals(name, ((ModuleElementKey) other).name);\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            if (hashCode == 0) {\n+                hashCode = hashCode(name);\n+            }\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"ModuleKey[\" + name + \"]\";\n+        }\n+\n+        @Override\n+        public <R, P> R accept(Visitor<R,P> v, P p) {\n+            return v.visitModuleElement(this, p);\n+        }\n+\n+        @Override\n+        public boolean is(ElementKind kind) {\n+            return (kind == ElementKind.MODULE);\n+        }\n+\n+    }\n+\n+    \/**\n+     * An element key for a package element.\n+     *\/\n+    public static final class PackageElementKey extends ElementKey {\n+        public final ElementKey moduleKey;\n+        public final Name name;\n+        private int hashCode;\n+\n+        PackageElementKey(PackageElement pe) {\n+            super(Kind.PACKAGE);\n+            ModuleElement me = (ModuleElement) pe.getEnclosingElement();\n+            moduleKey = (me == null || me.isUnnamed()) ? null : ElementKey.of(me);\n+            name = pe.getQualifiedName();\n+        }\n+\n+        @Override\n+        public ElementKey getEnclosingKey() {\n+            return moduleKey;\n+        }\n+\n+        @Override\n+        public int compareTo(ElementKey other) {\n+            int ck = kind.compareTo(other.kind);\n+            if (ck != 0) {\n+                return ck;\n+            }\n+            PackageElementKey otherPackage = (PackageElementKey) other;\n+            int cm;\n+            if (moduleKey == null) {\n+                cm = otherPackage.moduleKey == null ? 0 : -1;\n+            } else if (otherPackage.moduleKey == null) {\n+                cm = 1;\n+            } else {\n+                cm = moduleKey.compareTo(otherPackage.moduleKey);\n+            }\n+            return (cm != 0) ? cm : compare(name, otherPackage.name);\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            } else if (other == null || other.getClass() != getClass()) {\n+                return false;\n+            } else {\n+                PackageElementKey otherPackage = (PackageElementKey) other;\n+                return Objects.equals(moduleKey, otherPackage.moduleKey)\n+                        && equals(name, otherPackage.name);\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            if (hashCode == 0) {\n+                hashCode = (moduleKey == null ? 0 : moduleKey.hashCode() * 37) + hashCode(name);\n+            }\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"PackageKey[\" + (moduleKey == null ? \"\" : moduleKey + \",\") + name + \"]\";\n+        }\n+\n+        @Override\n+        public <R, P> R accept(Visitor<R,P> v, P p) {\n+            return v.visitPackageElement(this, p);\n+        }\n+\n+        @Override\n+        public boolean is(ElementKind kind) {\n+            return (kind == ElementKind.PACKAGE);\n+        }\n+\n+    }\n+\n+    \/**\n+     * An element key for a type element.\n+     *\/\n+    public static final class TypeElementKey extends ElementKey {\n+        public final ElementKey enclosingKey; \/\/ A type can be enclosed in a package or another type\n+        public final Name name;\n+        private int hashCode;\n+\n+        TypeElementKey(TypeElement te) {\n+            super(Kind.TYPE);\n+            enclosingKey = ElementKey.of(te.getEnclosingElement());\n+            name = te.getSimpleName();\n+        }\n+\n+        @Override\n+        public ElementKey getEnclosingKey() {\n+            return enclosingKey;\n+        }\n+\n+        @Override\n+        public int compareTo(ElementKey other) {\n+            int ck = kind.compareTo(other.kind);\n+            if (ck != 0) {\n+                return ck;\n+            }\n+            TypeElementKey otherType = (TypeElementKey) other;\n+            int ce = enclosingKey.compareTo(otherType.enclosingKey);\n+            return (ce != 0) ? ce : compare(name, otherType.name);\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            } else if (other == null || other.getClass() != getClass()) {\n+                return false;\n+            } else {\n+                TypeElementKey otherType = (TypeElementKey) other;\n+                return enclosingKey.equals(otherType.enclosingKey)\n+                        && equals(name, otherType.name);\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            if (hashCode == 0) {\n+                hashCode = enclosingKey.hashCode() * 37 + hashCode(name);\n+            }\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"TypeKey[\" + enclosingKey + \",\" + name + \"]\";\n+        }\n+\n+        @Override\n+        public <R, P> R accept(Visitor<R,P> v, P p) {\n+            return v.visitTypeElement(this, p);\n+        }\n+\n+        @Override\n+        public boolean is(Kind kind) {\n+            return (kind == Kind.TYPE);\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         * By design, {@code TypeElementKey} does not include details about the element kind,\n+         * and so always throws {@code UnsupportedOperationException} for any element kind\n+         * that is a type.\n+         *\n+         * @param kind the kind\n+         *\n+         * @return {@code false} for all element kinds that are not the kind of a type\n+         * @throws UnsupportedOperationException if the element kind is the kind of a type\n+         *\/\n+        @Override\n+        public boolean is(ElementKind kind) {\n+            return switch (kind) {\n+                case ANNOTATION_TYPE, CLASS, ENUM, INTERFACE -> throw new UnsupportedOperationException();\n+                default -> false;\n+            };\n+        }\n+\n+    }\n+\n+    public static abstract sealed class MemberElementKey extends ElementKey {\n+        public final ElementKey typeKey;\n+        public final ElementKind elementKind;\n+        public final Name name;\n+\n+        protected MemberElementKey(Kind kind, Element e) {\n+            super(kind);\n+            this.typeKey = ElementKey.of(e.getEnclosingElement());\n+            this.elementKind = e.getKind();\n+            this.name = e.getSimpleName();\n+        }\n+\n+        @Override\n+        public ElementKey getEnclosingKey() {\n+            return typeKey;\n+        }\n+\n+        @Override\n+        public boolean is(ElementKind kind) {\n+            return kind == elementKind;\n+        }\n+\n+    }\n+\n+    \/**\n+     * An element key for an executable element.\n+     *\/\n+    public static final class ExecutableElementKey extends MemberElementKey {\n+\n+        public final List<TypeMirrorKey> params;\n+        private int hashCode;\n+\n+        ExecutableElementKey(ExecutableElement ee) {\n+            super(Kind.EXECUTABLE, ee);\n+            params = ee.getParameters().stream()\n+                    .map(e -> TypeMirrorKey.of(e.asType()))\n+                    .collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public int compareTo(ElementKey other) {\n+            int ck = kind.compareTo(other.kind);\n+            if (ck != 0) {\n+                return ck;\n+            }\n+\n+            ExecutableElementKey otherExecutable = (ExecutableElementKey) other;\n+\n+            int ct = typeKey.compareTo(otherExecutable.typeKey);\n+            if (ct != 0) {\n+                return ct;\n+            }\n+\n+            int cek = elementKind.compareTo(otherExecutable.elementKind);\n+            if (cek != 0) {\n+                return cek;\n+            }\n+\n+            int cn = CharSequence.compare(name, otherExecutable.name);\n+            if (cn != 0) {\n+                return cn;\n+            }\n+\n+            return compare(params, otherExecutable.params);\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            } else if (other == null || other.getClass() != getClass()) {\n+                return false;\n+            } else {\n+                ExecutableElementKey otherExecutable = (ExecutableElementKey) other;\n+                return kind == otherExecutable.kind\n+                        && elementKind == otherExecutable.elementKind\n+                        && name.contentEquals(otherExecutable.name)\n+                        && params.equals(otherExecutable.params);\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            if (hashCode == 0) {\n+                hashCode = kind.ordinal() * 37 + typeKey.hashCode();\n+                hashCode = hashCode * 37 + elementKind.hashCode();\n+                hashCode = hashCode * 37 + hashCode(name);\n+                hashCode = hashCode * 37 + params.hashCode();\n+            }\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String p = params.stream().map(Object::toString).collect(Collectors.joining(\",\"));\n+            return \"ExecutableKey[\" + elementKind + \":\" + name + \"(\" + p + \")]\";\n+        }\n+\n+        @Override\n+        public <R, P> R accept(Visitor<R,P> v, P p) {\n+            return v.visitExecutableElement(this, p);\n+        }\n+    }\n+\n+\n+    \/**\n+     * An element key for a variable element.\n+     *\/\n+    public static final class VariableElementKey extends MemberElementKey {\n+\n+        private int hashCode;\n+\n+        VariableElementKey(VariableElement ve) {\n+            super(Kind.VARIABLE, ve);\n+        }\n+\n+        @Override\n+        public int compareTo(ElementKey other) {\n+            int ck = kind.compareTo(other.kind);\n+            if (ck != 0) {\n+                return ck;\n+            }\n+\n+            VariableElementKey otherVariable = (VariableElementKey) other;\n+\n+            int ct = typeKey.compareTo(otherVariable.typeKey);\n+            if (ct != 0) {\n+                return ct;\n+            }\n+\n+            int cek = elementKind.compareTo(otherVariable.elementKind);\n+            if (cek != 0) {\n+                return cek;\n+            }\n+\n+            return CharSequence.compare(name, otherVariable.name);\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            } else if (other == null || other.getClass() != getClass()) {\n+                return false;\n+            } else {\n+                VariableElementKey otherVariable = (VariableElementKey) other;\n+                return kind == otherVariable.kind\n+                        && elementKind == otherVariable.elementKind\n+                        && name.contentEquals(otherVariable.name);\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            if (hashCode == 0) {\n+                hashCode = typeKey.hashCode() * 37 + hashCode(name);\n+                hashCode = hashCode * 37 + elementKind.hashCode();\n+            }\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"VariableKey[\" + elementKind + \":\" + name + \"]\";\n+        }\n+\n+        @Override\n+        public <R, P> R accept(Visitor<R,P> v, P p) {\n+            return v.visitVariableElement(this, p);\n+        }\n+    }\n+\n+    \/**\n+     * An element key for a type parameter element.\n+     *\/\n+    public static final class TypeParameterElementKey extends ElementKey {\n+\n+        public final ElementKey typeKey;\n+        public final Name name;\n+        private int hashCode;\n+\n+        TypeParameterElementKey(TypeParameterElement ve) {\n+            super(Kind.TYPE_PARAMETER);\n+            typeKey = ElementKey.of(ve.getEnclosingElement());\n+            name = ve.getSimpleName();\n+        }\n+\n+        @Override\n+        public ElementKey getEnclosingKey() {\n+            return typeKey;\n+        }\n+\n+        @Override\n+        public int compareTo(ElementKey other) {\n+            int ck = kind.compareTo(other.kind);\n+            if (ck != 0) {\n+                return ck;\n+            }\n+\n+            TypeParameterElementKey otherTypeParameter = (TypeParameterElementKey) other;\n+\n+            int ct = typeKey.compareTo(otherTypeParameter.typeKey);\n+            if (ct != 0) {\n+                return ct;\n+            }\n+\n+            return CharSequence.compare(name, otherTypeParameter.name);\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            } else if (other == null || other.getClass() != getClass()) {\n+                return false;\n+            } else {\n+                TypeParameterElementKey otherVariable = (TypeParameterElementKey) other;\n+                return kind == otherVariable.kind\n+                        && name.contentEquals(otherVariable.name);\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            if (hashCode == 0) {\n+                hashCode = typeKey.hashCode() * 37 + hashCode(name);\n+            }\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"TypeParameterElementKey[\" + name + \"]\";\n+        }\n+\n+        @Override\n+        public <R, P> R accept(Visitor<R,P> v, P p) {\n+            return v.visitTypeParameterElement(this, p);\n+        }\n+\n+        @Override\n+        public boolean is(ElementKind kind) {\n+            return (kind == ElementKind.TYPE_PARAMETER);\n+        }\n+    }\n+\n+\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/ElementKey.java","additions":825,"deletions":0,"binary":false,"changes":825,"status":"added"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+\n+import jdk.codetools.apidiff.Options;\n+import jdk.codetools.apidiff.model.Position.RelativePosition;\n+import jdk.codetools.apidiff.report.Reporter;\n+\n+\/**\n+ * A comparator for {@link ExecutableElement executable elements}: constructors, methods, and members of annotation types.\n+ *\n+ * <p>The comparison includes:\n+ * <ul>\n+ *     <li>the \"signature\" of the element:\n+ *         its annotations, modifiers, type parameters, parameters, return type (if appropriate), throws\n+ *         and default value (if appropriate)\n+ *     <li>the documentation comment for the element\n+ * <\/ul>\n+ *\/\n+public class ExecutableComparator extends ElementComparator<ExecutableElement> {\n+\n+    \/**\n+     * Creates a comparator to compare executable elements across a set of APIs.\n+     *\n+     * @param apis     the set of APIs\n+     * @param options  the command-line options\n+     * @param reporter the reporter to which to report differences\n+     *\/\n+    public ExecutableComparator(Set<API> apis, Options options, Reporter reporter) {\n+        super(apis, options, reporter);\n+    }\n+\n+    \/**\n+     * Compare instances of an executable element found at a given position in different APIs.\n+     *\n+     * @param ePos the position of the element\n+     * @param eMap the map giving the instance of the type element in different APIs\n+     * @return {@code true} if all the instances are equivalent\n+     *\/\n+    @Override\n+    public boolean compare(Position ePos, APIMap<ExecutableElement> eMap) {\n+        boolean allEqual = false;\n+        reporter.comparing(ePos, eMap);\n+        try {\n+            allEqual = checkMissing(ePos, eMap);\n+            if (eMap.size() > 1) {\n+                allEqual &= compareSignatures(ePos, eMap);\n+                allEqual &= compareDocComments(ePos, eMap);\n+                allEqual &= compareApiDescriptions(ePos, eMap);\n+            }\n+        } finally {\n+            reporter.completed(ePos, allEqual);\n+        }\n+        return allEqual;\n+    }\n+\n+    private boolean compareSignatures(Position ePos, APIMap<ExecutableElement> eMap) {\n+        \/\/ TODO: compare signature: documented annotations, modifiers, kind, type parameters,\n+        \/\/       return type if method, parameter types, throws, default values if annotation type\n+        \/\/ By construction, the kind (method or constructor) should always be the same,\n+        \/\/ and does not need to be compared. Also by construction, the basic parameter\n+        \/\/ types will be the same, but the documented annotations on the types might differ\n+        \/\/ and so need to be compared.\n+        return compareAnnotations(ePos, eMap)\n+                & compareModifiers(ePos, eMap)\n+                & compareTypeParameters(ePos, eMap)\n+                & compareReturnType(ePos, eMap)\n+                & compareReceiverType(ePos, eMap)\n+                & compareParameters(ePos, eMap)\n+                & compareThrows(ePos, eMap)\n+                & compareDefaultValue(ePos, eMap);\n+    }\n+\n+    private boolean compareTypeParameters(Position ePos, APIMap<ExecutableElement> eMap) {\n+        TypeParameterComparator tc = new TypeParameterComparator(eMap.keySet(), options, reporter);\n+        IntTable<TypeParameterElement> typarams = IntTable.of(eMap, ExecutableElement::getTypeParameters);\n+        return tc.compareAll(ePos, typarams);\n+    }\n+\n+    private boolean compareParameters(Position ePos, APIMap<ExecutableElement> eMap) {\n+        VariableComparator vc = new VariableComparator(eMap.keySet(), options, reporter);\n+        IntTable<VariableElement> params = IntTable.of(eMap, ExecutableElement::getParameters);\n+        return vc.compareAll(ePos::parameter, params);\n+    }\n+\n+    private boolean compareReceiverType(Position ePos, APIMap<ExecutableElement> eMap) {\n+        if (ePos.is(ElementKind.CONSTRUCTOR))\n+            return true;\n+\n+        TypeMirrorComparator tc = new TypeMirrorComparator(eMap.keySet(), reporter);\n+        APIMap<TypeMirror> rMap = eMap.map((api, e) -> {\n+            TypeMirror t = e.getReceiverType();\n+            if (t == null) {\n+                \/\/ TODO: make this print optional\n+                \/\/ System.err.println(\"unexpected null for getReceiverType \" + ePos + \" \" + e);\n+                t = api.getTypes().getNoType(TypeKind.NONE);\n+            }\n+            return t;\n+        });\n+        return tc.compare(ePos.receiverType(), rMap);\n+    }\n+\n+    private boolean compareReturnType(Position ePos, APIMap<ExecutableElement> eMap) {\n+        if (ePos.is(ElementKind.CONSTRUCTOR))\n+            return true;\n+\n+        TypeMirrorComparator tc = new TypeMirrorComparator(eMap.keySet(), reporter);\n+        APIMap<TypeMirror> rMap = eMap.map(ExecutableElement::getReturnType);\n+        return tc.compare(ePos.returnType(), rMap);\n+    }\n+\n+    private boolean compareThrows(Position ePos, APIMap<ExecutableElement> eMap) {\n+        Map<TypeMirrorKey, APIMap<TypeMirror>> map = extractThrownTypes(eMap);\n+\n+        \/\/ compare the groups of thrown types\n+        Set<ElementKey> first = null;\n+        boolean allEqual = true;\n+        for (Map.Entry<TypeMirrorKey, APIMap<TypeMirror>> entry : map.entrySet()) {\n+            TypeMirrorKey tk = entry.getKey();\n+            APIMap<TypeMirror> tMap = entry.getValue();\n+            Position pos = ePos.exception(tk);\n+            if (tMap.size() < eMap.size()) {\n+                \/\/ Note: using reportDifferentTypes even if some of the thrown types are missing\n+                eMap.keySet().forEach(a -> tMap.putIfAbsent(a, null));\n+                reporter.reportDifferentTypes(pos, tMap);\n+                allEqual = false;\n+            } else {\n+                TypeMirrorComparator tmc = new TypeMirrorComparator(eMap.keySet(), reporter);\n+                allEqual = allEqual & tmc.compare(pos, tMap);\n+            }\n+        }\n+\n+        if (allEqual) {\n+            return true;\n+        } else {\n+            APIMap<List<? extends TypeMirror>> thrownTypes = APIMap.of();\n+            eMap.forEach((api, ee) -> thrownTypes.put(api, ee.getThrownTypes()));\n+            reporter.reportDifferentThrownTypes(ePos, thrownTypes);\n+            return false;\n+        }\n+    }\n+\n+    private Map<TypeMirrorKey, APIMap<TypeMirror>> extractThrownTypes(APIMap<ExecutableElement> eMap) {\n+        \/\/ The order in which thrown types may be listed is not significant,\n+        \/\/ so group the thrown types by their TypeMirrorKey.\n+        \/\/ Note that thrown types can be type variables, and even annotated\n+        Map<TypeMirrorKey, APIMap<TypeMirror>> map = new TreeMap<>();\n+        for (Map.Entry<API, ExecutableElement> entry : eMap.entrySet()) {\n+            API api = entry.getKey();\n+            ExecutableElement ee = entry.getValue();\n+            for (TypeMirror tm : ee.getThrownTypes()) {\n+                map.computeIfAbsent(TypeMirrorKey.of(tm), _k -> APIMap.of()).put(api, tm);\n+            }\n+        }\n+        return map;\n+    }\n+\n+    private boolean compareDefaultValue(Position ePos, APIMap<ExecutableElement> eMap) {\n+        boolean noDefaultValues = eMap.values().stream()\n+                .map(ExecutableElement::getDefaultValue)\n+                .allMatch(Objects::isNull);\n+        if (noDefaultValues) {\n+            return true;\n+        }\n+\n+        APIMap<AnnotationValue> defaultValues = APIMap.of();\n+        eMap.forEach((api, ee) -> {\n+            AnnotationValue dv = ee.getDefaultValue();\n+            if (dv != null) {\n+                defaultValues.put(api, dv);\n+            }\n+        });\n+\n+        Position dvPos = new RelativePosition<Void>(ePos, RelativePosition.Kind.DEFAULT_VALUE);\n+\n+        return new AnnotationComparator(apis, accessKind, reporter)\n+                .new AnnotationValueComparator(dvPos).compare(defaultValues);\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/ExecutableComparator.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -0,0 +1,559 @@\n+\/*\n+ * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CodingErrorAction;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * A basic HTML parser.\n+ *\n+ * Override the protected methods as needed to get notified of significant items\n+ * in any file that is read.\n+ *\/\n+public abstract class HtmlParser {\n+\n+    private Path file;\n+    private Reader in;\n+    private int ch;\n+    private long charNumber;\n+    private int lineNumber;\n+    private boolean inScript;\n+    private boolean xml;\n+\n+    \/**\n+     * Creates an instance of an HTML parser.\n+     *\/\n+    public HtmlParser() { }\n+\n+    \/**\n+     * Read a file.\n+     *\n+     * <p>Ideally, we should honor a charset found in a {@code <meta>} element in the head of the document,\n+     * but the reality is that all documents use one of ASCII, ISO-8859-1 or UTF-8, and generally\n+     * specify either ISO-8859-1 or UTF-8. UTF-8 is backwards compatible with both ASCII and ISO-8859-1,\n+     * and so we assume the use of UTF-8, and use a decoder to replace bad values with the\n+     * standard Unicode REPLACEMENT CHARACTER U+FFFD.<\/p>\n+     *\n+     * <p>As alternatives, we could initially assume an 8-bit encoding (e.g. ASCII or ISO-8859-1,\n+     * and switch to UTF-8 if needed (but note {@link java.io.InputStreamReader} may read ahead\n+     * some bytes for efficiency, making it hard to know the state of the stream if and when we\n+     * need to switch.  Or, we could read ahead some amount looking for a charset, and then\n+     * reset the stream and start over with the specified charset.<\/p>\n+     *\n+     * @param file the file to be read\n+     *\/\n+    public void read(Path file) {\n+        try {\n+            readBuffer(file);\n+        } catch (IOException e) {\n+            error(file, -1, e);\n+        }\n+\n+        this.file = file;\n+        startFile(file);\n+        try {\n+            int startContentIndex = 0;\n+            charNumber = 0;\n+            lineNumber = 1;\n+            xml = false;\n+            nextChar();\n+\n+            while (ch != -1) {\n+                switch (ch) {\n+                    case '<' -> {\n+                        if (bufferIndex > startContentIndex + 1) {\n+                            int from = startContentIndex;\n+                            int to = bufferIndex - 1;\n+                            content(() -> getBufferString(from, to));\n+                        }\n+                        html();\n+                        startContentIndex = bufferIndex - 1;\n+                    }\n+\n+                    case '\\n' -> {\n+                        int from = startContentIndex;\n+                        int to = bufferIndex;\n+                        content(() -> getBufferString(from, to));\n+                        startContentIndex = bufferIndex;\n+                        nextChar();\n+                    }\n+\n+                    default -> {\n+                        nextChar();\n+                    }\n+                }\n+            }\n+        } finally {\n+            endFile();\n+        }\n+    }\n+\n+    \/**\n+     * The contents of the file being processed.\n+     *\/\n+    private char[] buffer;\n+\n+    \/**\n+     * The position of the next character to be read.\n+     *\/\n+    private int bufferIndex;\n+\n+    \/**\n+     * The position of the last character in the buffer.\n+     *\/\n+    private int maxBufferIndex;\n+\n+    \/**\n+     * Read a file into the buffer.\n+     * Bad characters in the input are simply replaced with U+FFFD.\n+     *\n+     * @param file the file\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    private void readBuffer(Path file) throws IOException {\n+        CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n+                .onMalformedInput(CodingErrorAction.REPLACE)\n+                .onUnmappableCharacter(CodingErrorAction.REPLACE)\n+                .replaceWith(\"\\ufffd\");\n+        float factor = decoder.averageCharsPerByte() * 0.8f\n+                + decoder.maxCharsPerByte() * 0.2f;\n+\n+        \/\/ overestimate buffer size, to avoid reallocation\n+        long byteSize = Files.size(file);\n+        int bufferSize = (int) (byteSize * factor) + 128;\n+\n+        if (buffer == null || buffer.length < bufferSize) {\n+            buffer = new char[bufferSize];\n+        }\n+\n+        try (InputStream is = Files.newInputStream(file);\n+             Reader r = new BufferedReader(new InputStreamReader(is, decoder))) {\n+            int offset = 0;\n+            int n;\n+            while ((n = r.read(buffer, offset, buffer.length - offset)) != -1) {\n+                offset += n;\n+                if (offset == buffer.length) {\n+                    \/\/ should not happen, but just in case...\n+                    char[] newBuffer = new char[buffer.length + buffer.length \/ 4];\n+                    System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);\n+                    buffer = newBuffer;\n+                }\n+            }\n+\n+            bufferIndex = 0;\n+            maxBufferIndex = offset;\n+        }\n+    }\n+\n+    \/**\n+     * Returns the position in the file of the next character to be read.\n+     *\n+     * @return the position\n+     *\/\n+    protected int getBufferIndex() {\n+        return bufferIndex;\n+    }\n+\n+    \/**\n+     * Returns a substring of content in the buffer.\n+     *\n+     * @param from the position of the first character of the substring\n+     * @param to   the position of the first character after the substring\n+     *\n+     * @return the substring\n+     *\/\n+    protected String getBufferString(int from, int to) {\n+        return new String(buffer, from, to - from);\n+    }\n+\n+    \/**\n+     * Returns a substring of content in the buffer, excluding leading and trailing whitespace.\n+     *\n+     * @param from the position of the first character of the substring\n+     * @param to   the position of the first character after the substring\n+     *\n+     * @return the substring\n+     *\/\n+    protected String getTrimBufferString(int from, int to) {\n+        while (from < to && Character.isWhitespace(buffer[from])) {\n+            from++;\n+        }\n+        while (to > from && Character.isWhitespace(buffer[to - 1])) {\n+            to--;\n+        }\n+        return getBufferString(from, to);\n+    }\n+\n+    \/**\n+     * Returns the position in the file of the most recently read character.\n+     *\n+     * @return the position\n+     *\/\n+    protected long charNumber() {\n+        return charNumber;\n+    }\n+\n+    \/**\n+     * Returns the line number in the file of the most recently read character.\n+     *\n+     * @return the line number\n+     *\/\n+    protected int getLineNumber() {\n+        return lineNumber;\n+    }\n+\n+    \/**\n+     * Called when a file has been opened, before parsing begins.\n+     * This is always the first notification when reading a file.\n+     * This implementation does nothing.\n+     *\n+     * @param file the file\n+     *\/\n+    protected void startFile(Path file) { }\n+\n+    \/**\n+     * Called when the parser has finished reading a file.\n+     * This is always the last notification when reading a file,\n+     * unless any errors occur while closing the file.\n+     * This implementation does nothing.\n+     *\/\n+    protected void endFile() { }\n+\n+    \/**\n+     * Called when a doctype declaration is found, at the beginning of the file.\n+     * This implementation does nothing.\n+     * @param s a supplier for the doctype declaration\n+     *\/\n+    protected void doctype(Supplier<String> s) { }\n+\n+    \/**\n+     * Called when the opening tag of an HTML element is encountered.\n+     * This implementation does nothing.\n+     * @param name the name of the tag\n+     * @param attrs the attribute\n+     * @param selfClosing whether this is a self-closing tag\n+     *\/\n+    protected void startElement(String name, Map<String,String> attrs, boolean selfClosing) { }\n+\n+    \/**\n+     * Called when the closing tag of an HTML tag is encountered.\n+     * This implementation does nothing.\n+     * @param name the name of the tag\n+     *\/\n+    protected void endElement(String name) { }\n+\n+    \/**\n+     * Called for sequences of character content.\n+     * @param content a supplier for the character content\n+     *\/\n+    protected void content(Supplier<String> content) { }\n+\n+    \/**\n+     * Called for sequences of comment.\n+     * @param comment a supplier for the comment\n+     *\/\n+    protected void comment(Supplier<String> comment) { }\n+\n+    \/**\n+     * Called when an error has been encountered.\n+     * @param file the file being read\n+     * @param lineNumber the line number of line containing the error\n+     * @param message a description of the error\n+     *\/\n+    protected abstract void error(Path file, int lineNumber, String message);\n+\n+    \/**\n+     * Called when an exception has been encountered.\n+     * @param file the file being read\n+     * @param lineNumber the line number of the line being read when the exception was found\n+     * @param t the exception\n+     *\/\n+    protected abstract void error(Path file, int lineNumber, Throwable t);\n+\n+    \/**\n+     * Reads the next character from the buffer and returns it.\n+     *\n+     * @return the character\n+     *\/\n+    protected int nextChar() {\n+        if (bufferIndex == maxBufferIndex) {\n+            ch =  -1;\n+        } else {\n+            ch = buffer[bufferIndex++];\n+            charNumber++;\n+            if (ch == '\\n')\n+                lineNumber++;\n+        }\n+        return ch;\n+    }\n+\n+    \/**\n+     * Read the start or end of an HTML tag, or the doctype declaration,\n+     * skipping any HTML comments.\n+     *\n+     * Syntax:\n+     * {@literal <identifier attrs> } or {@literal <\/identifier> }\n+     *\/\n+    protected void html() {\n+        nextChar();\n+        if (isIdentifierStart((char) ch)) {\n+            String name = readIdentifier().toLowerCase(Locale.ROOT);\n+            Map<String,String> attrs = htmlAttrs();\n+            if (attrs != null) {\n+                boolean selfClosing = false;\n+                if (ch == '\/') {\n+                    nextChar();\n+                    selfClosing = true;\n+                }\n+                if (ch == '>') {\n+                    nextChar();\n+                    startElement(name, attrs, selfClosing);\n+                    if (name.equals(\"script\")) {\n+                        inScript = true;\n+                    }\n+                    return;\n+                }\n+            }\n+        } else if (ch == '\/') {\n+            nextChar();\n+            if (isIdentifierStart((char) ch)) {\n+                String name = readIdentifier().toLowerCase(Locale.ROOT);\n+                skipWhitespace();\n+                if (ch == '>') {\n+                    nextChar();\n+                    endElement(name);\n+                    if (name.equals(\"script\")) {\n+                        inScript = false;\n+                    }\n+                    return;\n+                }\n+            }\n+        } else if (ch == '!') {\n+            nextChar();\n+            if (ch == '-') {\n+                nextChar();\n+                if (ch == '-') {\n+                    nextChar();\n+                    int startCommentIndex = bufferIndex - 1;\n+                    while (ch != -1) {\n+                        int dash = 0;\n+                        while (ch == '-') {\n+                            dash++;\n+                            nextChar();\n+                        }\n+                        \/\/ Strictly speaking, a comment should not contain \"--\"\n+                        \/\/ so dash > 2 is an error, dash == 2 implies ch == '>'\n+                        \/\/ See http:\/\/www.w3.org\/TR\/html-markup\/syntax.html#syntax-comments\n+                        \/\/ for more details.\n+                        if (dash >= 2 && ch == '>') {\n+                            int to = bufferIndex - 3;\n+                            comment(() -> getBufferString(startCommentIndex, to));\n+                            nextChar();\n+                            return;\n+                        }\n+\n+                        nextChar();\n+                    }\n+                }\n+            } else if (ch == '[') {\n+                nextChar();\n+                if (ch == 'C') {\n+                    nextChar();\n+                    if (ch == 'D') {\n+                        nextChar();\n+                        if (ch == 'A') {\n+                            nextChar();\n+                            if (ch == 'T') {\n+                                nextChar();\n+                                if (ch == 'A') {\n+                                    nextChar();\n+                                    if (ch == '[') {\n+                                        while (true) {\n+                                            nextChar();\n+                                            if (ch == ']') {\n+                                                nextChar();\n+                                                if (ch == ']') {\n+                                                    nextChar();\n+                                                    if (ch == '>') {\n+                                                        nextChar();\n+                                                        return;\n+                                                    }\n+                                                }\n+                                            }\n+                                        }\n+\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            } else {\n+                int startDocTypeIndex = bufferIndex - 1;\n+                while (ch != -1 && ch != '>') {\n+                    nextChar();\n+                }\n+                nextChar();\n+                Pattern p = Pattern.compile(\"(?is)doctype\\\\s+html\\\\s?.*\");\n+                String s = getBufferString(startDocTypeIndex, bufferIndex - 2);\n+                if (p.matcher(s).matches()) {\n+                    doctype(() -> s);\n+                    return;\n+                }\n+            }\n+        } else if (ch == '?') {\n+            nextChar();\n+            if (ch == 'x') {\n+                nextChar();\n+                if (ch == 'm') {\n+                    nextChar();\n+                    if (ch == 'l') {\n+                        Map<String,String> attrs = htmlAttrs();\n+                        if (ch == '?') {\n+                            nextChar();\n+                            if (ch == '>') {\n+                                nextChar();\n+                                xml = true;\n+                                return;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+            }\n+        }\n+\n+        if (!inScript) {\n+            error(file, lineNumber, \"bad html\");\n+        }\n+    }\n+\n+    \/**\n+     * Read a series of HTML attributes, terminated by {@literal > }.\n+     * Each attribute is of the form {@literal identifier[=value] }.\n+     * \"value\" may be unquoted, single-quoted, or double-quoted.\n+     *\/\n+    private Map<String,String> htmlAttrs() {\n+        Map<String, String> map = Collections.emptyMap(); \/\/ default, for common case\n+        skipWhitespace();\n+\n+        while (isIdentifierStart((char) ch)) {\n+            String name = readAttributeName().toLowerCase(Locale.ROOT);\n+            skipWhitespace();\n+            String value = null;\n+            if (ch == '=') {\n+                nextChar();\n+                skipWhitespace();\n+                if (ch == '\\'' || ch == '\"') {\n+                    char quote = (char) ch;\n+                    nextChar();\n+                    int startValueIndex = bufferIndex - 1;\n+                    while (ch != -1 && ch != quote) {\n+                        nextChar();\n+                    }\n+                    value = replaceSimpleEntities(getBufferString(startValueIndex, bufferIndex - 1));\n+                    nextChar();\n+                } else {\n+                    int startValueIndex = bufferIndex - 1;\n+                    while (ch != -1 && !isUnquotedAttrValueTerminator((char) ch)) {\n+                        nextChar();\n+                    }\n+                    value = getBufferString(startValueIndex, bufferIndex - 1);\n+                }\n+                skipWhitespace();\n+            }\n+            if (map.isEmpty()) {\n+                \/\/ change to a mutable map\n+                map = new LinkedHashMap<>();\n+            }\n+            map.put(name, value);\n+        }\n+\n+        return map;\n+    }\n+\n+    private boolean isIdentifierStart(char ch) {\n+        return Character.isUnicodeIdentifierStart(ch);\n+    }\n+\n+    private String readIdentifier() {\n+        int startIndex = bufferIndex - 1;\n+        nextChar();\n+        while (ch != -1 && Character.isUnicodeIdentifierPart(ch)) {\n+            nextChar();\n+        }\n+        return getBufferString(startIndex, bufferIndex - 1);\n+    }\n+\n+    private String readAttributeName() {\n+        int startIndex = bufferIndex - 1;\n+        nextChar();\n+        while (ch != -1 && Character.isUnicodeIdentifierPart(ch)\n+                || ch == '-'\n+                || xml && ch == ':') {\n+            nextChar();\n+        }\n+        return getBufferString(startIndex, bufferIndex - 1);\n+    }\n+\n+    private boolean isWhitespace(char ch) {\n+        return Character.isWhitespace(ch);\n+    }\n+\n+    private void skipWhitespace() {\n+        while (isWhitespace((char) ch)) {\n+            nextChar();\n+        }\n+    }\n+\n+    private String replaceSimpleEntities(String s) {\n+        return s.replace(\"&lt;\", \"<\")\n+                .replace(\"&gt;\", \">\")\n+                .replace(\"&amp;\", \"&\");\n+    }\n+\n+    private boolean isUnquotedAttrValueTerminator(char ch) {\n+        return switch (ch) {\n+            case '\\f', '\\n', '\\r', '\\t', ' ', '\"', '\\'', '`', '=', '<', '>' -> true;\n+            default -> false;\n+        };\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/HtmlParser.java","additions":559,"deletions":0,"binary":false,"changes":559,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+\/**\n+ * A table of {@code (int x API) -> T}.\n+ *\n+ * The table can be used associate elements from different APIs\n+ * that are associated by their position in their enclosing element.\n+ *\n+ * @param <T> the type of item stored in this table\n+ *\/\n+public class IntTable<T> {\n+    private List<APIMap<T>> list = new ArrayList<>();\n+\n+    \/**\n+     * Creates a table from an API map and a function to provide a list of related items to populate the table.\n+     *\n+     * @param map the map\n+     * @param f   the function\n+     * @param <T> the type of values in the map\n+     * @param <R> the type of values in the list returned by the function\n+     *\n+     * @return the table\n+     *\n+     * @see KeyTable#of\n+     *\/\n+    \/\/ Used to get type parameters (of type and executable), parameters, and bounds of type parameters\n+    static <T, R> IntTable<R> of(APIMap<? extends T> map, Function<T, List<? extends R>> f) {\n+        IntTable<R> result = new IntTable<>();\n+        for (Map.Entry<API, ? extends T> e : map.entrySet()) {\n+            result.put(e.getKey(), f.apply(e.getValue()));\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Updates the table with a series of values for a given API.\n+     * The effect is to set the values in a column of the table,\n+     * extending the number of rows if necessary.\n+     *\n+     * @param api the api\n+     * @param items the items\n+     *\/\n+    public void put(API api, List<? extends T> items) {\n+        int i = 0;\n+        for (T item : items) {\n+            APIMap<T> m;\n+            if (i < list.size()) {\n+                m = list.get(i);\n+            } else {\n+                m = APIMap.of();\n+                list.add(m);\n+            }\n+            m.put(api, item);\n+            i++;\n+        }\n+    }\n+\n+    \/**\n+     * Adds a new entry for a given API.\n+     *\n+     * @param api the API\n+     * @param item the item\n+     *\/\n+    public void add(API api, T item) {\n+        for (APIMap<T> m : list) {\n+            if (!m.containsKey(api)) {\n+                m.put(api, item);\n+                return;\n+            }\n+        }\n+        APIMap<T> m = APIMap.of();\n+        list.add(m);\n+        m.put(api, item);\n+    }\n+\n+    \/**\n+     * Returns the number of rows in the table.\n+     *\n+     * @return the number of rows in the table.\n+     *\/\n+    public int size() {\n+        return list.size();\n+    }\n+\n+    \/**\n+     * Returns the entries for a given row in the table.\n+     *\n+     * @param index the index of the row.\n+     * @return the entries\n+     *\/\n+    public APIMap<T> entries(int index) {\n+        return list.get(index);\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/IntTable.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.function.BiFunction;\n+import javax.lang.model.element.Element;\n+\n+\/**\n+ * A table of {@code (ElementKey x API) -> T}.\n+ *\n+ * The table can be used associate items from different APIs that are associated\n+ * by means of a key representing the item.\n+ *\n+ * @param <T> the type of item stored in this table\n+ *\/\n+public class KeyTable<T> {\n+    private Map<ElementKey, APIMap<T>> map = new TreeMap<>();\n+\n+    \/**\n+     * Creates a table from an API map and a function to provide a set of related items to populate the table.\n+     *\n+     * @param map the map\n+     * @param f   the function\n+     * @param <T> the type of values in the map\n+     * @param <R> the type of values in the set returned by the function\n+     *\n+     * @return the table\n+     *\n+     * @see IntTable#of\n+     *\/\n+    \/\/ Used to get packages from a module, and types from a package\n+    static <T, R extends Element> KeyTable<R> of(APIMap<? extends T> map, BiFunction<API, T, Set<? extends R>> f) {\n+        KeyTable<R> result = new KeyTable<>();\n+        for (Map.Entry<API, ? extends T> entry : map.entrySet()) {\n+            API api = entry.getKey();\n+            for (R e : f.apply(api, entry.getValue())) {\n+                result.put(ElementKey.of(e), api, e);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Puts an item into the table, according to a key and the api in which it is\n+     * an instance.\n+     *\n+     * @param key the key\n+     * @param api the api\n+     * @param item the item\n+     * @return the previous value, if any\n+     *\/\n+    public T put(ElementKey key, API api, T item) {\n+        return map.computeIfAbsent(key, _k -> APIMap.of()).put(api, item);\n+    }\n+\n+    \/**\n+     * Returns an iterator for the collections of items within the table\n+     * for a given key.\n+     *\n+     * @return an iterable for the collections of items associated with a given key\n+     *\/\n+    public Iterable<Map.Entry<ElementKey,APIMap<T>>> entries() {\n+        return map.entrySet();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return map.toString();\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/KeyTable.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,414 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.ModuleElement.Directive;\n+import javax.lang.model.element.ModuleElement.DirectiveKind;\n+import javax.lang.model.element.ModuleElement.ExportsDirective;\n+import javax.lang.model.element.ModuleElement.OpensDirective;\n+import javax.lang.model.element.ModuleElement.ProvidesDirective;\n+import javax.lang.model.element.ModuleElement.RequiresDirective;\n+import javax.lang.model.element.ModuleElement.UsesDirective;\n+import javax.lang.model.element.PackageElement;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTreeVisitor;\n+import com.sun.source.doctree.ProvidesTree;\n+import com.sun.source.doctree.UsesTree;\n+import com.sun.source.util.DocTreeScanner;\n+\n+import jdk.codetools.apidiff.Options;\n+import jdk.codetools.apidiff.report.Reporter;\n+\n+\/**\n+ * A comparator for {@link ModuleElement module elements}.\n+ *\n+ * <p>The comparison includes:\n+ * <ul>\n+ *     <li>the annotations of the module\n+ *     <li>the modifiers of the module\n+ *     <li>the directives in the module\n+ *     <li>the documentation comment for the module\n+ *     <li>the selected packages in the module\n+ * <\/ul>\n+ *\/\n+public class ModuleComparator extends ElementComparator<ModuleElement> {\n+\n+    \/**\n+     * Creates a comparator to compare module elements across a set of APIs.\n+     *\n+     * @param apis the set of APIs\n+     * @param options the command-line options\n+     * @param reporter the reporter to which to report differences\n+     *\/\n+    public ModuleComparator(Set<API> apis, Options options, Reporter reporter) {\n+        super(apis, options, reporter);\n+    }\n+\n+    \/**\n+     * Compares instances of a module element found in different APIs.\n+     *\n+     * @param mPos the position of the element\n+     * @param mMap the map giving the instance of the module element in different APIs\n+     * @return {@code true} if all the instances are equivalent\n+     *\/\n+    @Override\n+    public boolean compare(Position mPos, APIMap<ModuleElement> mMap) {\n+        boolean allEqual = false;\n+        reporter.comparing(mPos, mMap);\n+        try {\n+            allEqual = checkMissing(mPos, mMap);\n+            if (mMap.size() > 1) {\n+                allEqual &= compareAnnotations(mPos, mMap);\n+                allEqual &= compareModifiers(mPos, mMap);\n+                allEqual &= compareDirectives(mPos, mMap);\n+                allEqual &= compareDocComments(mPos, mMap);\n+                allEqual &= compareApiDescriptions(mPos, mMap);\n+                allEqual &= comparePackages(mPos, mMap);\n+                allEqual &= compareDocFiles(mPos, mMap);\n+            }\n+        } finally {\n+            reporter.completed(mPos, allEqual);\n+        }\n+        return allEqual;\n+    }\n+\n+    private boolean comparePackages(Position mPos, APIMap<ModuleElement> mMap) {\n+        PackageComparator pc = new PackageComparator(mMap.keySet(), options, reporter);\n+        KeyTable<PackageElement> packages = options.getAccessKind().compareTo(AccessKind.PROTECTED) <= 0\n+                ? KeyTable.of(mMap, API::getExportedPackageElements)\n+                : KeyTable.of(mMap, API::getPackageElements);\n+        return pc.compareAll(packages);\n+    }\n+\n+    \/**\n+     * Compares the modifiers for instances of a module element found in different APIs.\n+     *\n+     * <p>For a module element, the only modifier is whether it is an open  module or not.\n+     *\/\n+    @Override\n+    protected boolean compareModifiers(Position mPos, APIMap<ModuleElement> mMap) {\n+        if (mMap.size() == 1)\n+            return true;\n+\n+        boolean first = true;\n+        boolean baselineIsOpen = false;\n+        for (ModuleElement me : mMap.values()) {\n+            if (first) {\n+                baselineIsOpen = me.isOpen();\n+                first = false;\n+            } else if (me.isOpen() != baselineIsOpen) {\n+                reporter.reportDifferentModifiers(mPos, mMap);\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    private boolean compareDirectives(Position mPos, APIMap<ModuleElement> mMap) {\n+        KeyTable<RequiresDirective> requires = new KeyTable<>();\n+        KeyTable<ExportsDirective> exports = new KeyTable<>();\n+        KeyTable<OpensDirective> opens = new KeyTable<>();\n+        KeyTable<ProvidesDirective> provides = new KeyTable<>();\n+        KeyTable<UsesDirective> uses = new KeyTable<>();\n+\n+        boolean allDirectiveDetails = accessKind.allModuleDetails();\n+\n+        for (Map.Entry<API, ModuleElement> e : mMap.entrySet()) {\n+            API api = e.getKey();\n+            ModuleElement me = e.getValue();\n+\n+            for (Directive d : me.getDirectives()) {\n+                switch (d.getKind()) {\n+                    case REQUIRES -> {\n+                        RequiresDirective rd = (RequiresDirective) d;\n+                        if (allDirectiveDetails || rd.isTransitive()) {\n+                            requires.put(ElementKey.of(rd.getDependency()), api, rd);\n+                        }\n+                    }\n+                    case EXPORTS -> {\n+                        ExportsDirective ed = (ExportsDirective) d;\n+                        if (allDirectiveDetails || ed.getTargetModules() == null) {\n+                            exports.put(ElementKey.of(ed.getPackage()), api, ed);\n+                        }\n+                    }\n+                    case OPENS -> {\n+                        OpensDirective od = (OpensDirective) d;\n+                        if (allDirectiveDetails || od.getTargetModules() == null) {\n+                            opens.put(ElementKey.of(od.getPackage()), api, od);\n+                        }\n+                    }\n+                    case PROVIDES -> {\n+                        ProvidesDirective pd = (ProvidesDirective) d;\n+                        if (allDirectiveDetails || isDocumented(api, me, pd)) {\n+                            provides.put(ElementKey.of(pd.getService()), api, pd);\n+                        }\n+                    }\n+                    case USES -> {\n+                        UsesDirective ud = (UsesDirective) d;\n+                        if (allDirectiveDetails || isDocumented(api, me, ud)) {\n+                            uses.put(ElementKey.of(ud.getService()), api, ud);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        Set<API> mAPIs = mMap.keySet();\n+        boolean allEqual = new RequiresComparator(mAPIs).compareAll(mPos, requires);\n+        allEqual &= new ExportsComparator(mAPIs).compareAll(mPos, exports);\n+        allEqual &= new OpensComparator(mAPIs).compareAll(mPos, opens);\n+        allEqual &= new ProvidesComparator(mAPIs, allDirectiveDetails).compareAll(mPos, provides);\n+        allEqual &= new UsesComparator(mAPIs).compareAll(mPos, uses);\n+        return allEqual;\n+    }\n+\n+    \/**\n+     * A cache of the service information derived from doc comments.\n+     *\/\n+    private Map<ModuleElement, Map<DirectiveKind, Set<String>>> documentedServices = new HashMap<>();\n+\n+    \/**\n+     * Determines if the service type in a \"provides\" or \"uses\" directive is documented or not.\n+     * A service type is documented if it is the subject of a corresponding {@code @provides}\n+     * or {@code @uses} tag identifying the service type.\n+     *\n+     * @param api the API containing the module element\n+     * @param me  the module element\n+     * @param d   the directive containing the service type\n+     *\n+     * @return {@code true} if the service type is documented in the doc comment for the module\n+     *\/\n+    private boolean isDocumented(API api, ModuleElement me, Directive d) {\n+        Map<DirectiveKind, Set<String>> servicesForModule =\n+                documentedServices.computeIfAbsent(me, __ -> getDocumentedServices(api, me));\n+        String serviceName = switch (d.getKind()) {\n+            case USES -> ((UsesDirective) d).getService().getQualifiedName().toString();\n+            case PROVIDES -> ((ProvidesDirective) d).getService().getQualifiedName().toString();\n+            default -> throw new IllegalArgumentException();\n+        };\n+        return servicesForModule.get(d.getKind()).contains(serviceName);\n+    }\n+\n+    \/**\n+     * Returns details about which services are documented for a module.\n+     * This requires the source file for the module to be available;\n+     * if it is not available, an empty map is returned.\n+     *\n+     * @param api the API containing the module element\n+     * @param me  the module element\n+     *\n+     * @return a map which identifies which services are documented for a module.\n+     *\/\n+    private Map<DirectiveKind, Set<String>> getDocumentedServices(API api, ModuleElement me) {\n+        Map<DirectiveKind, Set<String>> map = new EnumMap<>(DirectiveKind.class);\n+        map.put(DirectiveKind.PROVIDES, new HashSet<>());\n+        map.put(DirectiveKind.USES, new HashSet<>());\n+        DocCommentTree dct = api.getDocComment(me);\n+        if (dct != null) {\n+            DocTreeVisitor<Void, Map<DirectiveKind, Set<String>>> serviceScanner = new DocTreeScanner<>() {\n+                @Override\n+                public Void visitProvides(ProvidesTree pt, Map<DirectiveKind, Set<String>> map) {\n+                    map.get(DirectiveKind.PROVIDES).add(pt.getServiceType().getSignature());\n+                    return null;\n+                }\n+                @Override\n+                public Void visitUses(UsesTree ut, Map<DirectiveKind, Set<String>> map) {\n+                    map.get(DirectiveKind.USES).add(ut.getServiceType().toString());\n+                    return null;\n+                }\n+            };\n+            dct.accept(serviceScanner, map);\n+        }\n+        return map;\n+    }\n+\n+    private abstract class DirectiveComparator<D extends Directive> {\n+        final Set<API> apis;\n+        final DirectiveKind kind;\n+\n+        DirectiveComparator(Set<API> apis, DirectiveKind kind) {\n+            this.apis = apis;\n+            this.kind = kind;\n+        }\n+\n+        boolean compareAll(Position mPos, KeyTable<D> table) {\n+            boolean allEqual = true;\n+            \/\/ TODO? use comparing... try { ... } finally { compared... }\n+            for (Map.Entry<ElementKey, APIMap<D>> e : table.entries()) {\n+                ElementKey ek = e.getKey();\n+                APIMap<D> v = e.getValue();\n+                boolean equal = compare(mPos.directive(kind, ek), v);\n+                allEqual &= equal;\n+            }\n+            return allEqual;\n+        }\n+\n+        abstract boolean compare(Position pos, APIMap<D> map);\n+\n+        protected boolean checkMissing(Position dPos, APIMap<D> dMap) {\n+            Set<API> missing = apis.stream()\n+                    .filter(a -> !dMap.containsKey(a))\n+                    .collect(Collectors.toSet()); \/\/ warning: unordered\n+\n+            if (missing.isEmpty()) {\n+                return true;\n+            } else {\n+                reporter.reportMissing(dPos, missing);\n+                return false;\n+            }\n+        }\n+\n+        protected <E extends Element> boolean compare(Position dPos, APIMap<D> dMap, Function<D, List<E>> f) {\n+            boolean allEqual = false;\n+            reporter.comparing(dPos, dMap);\n+            try {\n+                allEqual = checkMissing(dPos, dMap);\n+                if (dMap.size() > 1) {\n+                    Set<ElementKey> baseline = null;\n+                    for (D d : dMap.values()) {\n+                        List<E> elements = f.apply(d);\n+                        Set<ElementKey> set = (elements == null) ? Collections.emptySet()\n+                                : elements.stream().map(ElementKey::of).collect(Collectors.toSet());\n+                        if (baseline == null) {\n+                            baseline = set;\n+                        } else if (!set.equals(baseline)) {\n+                            allEqual = false;\n+                            break;\n+                        }\n+                    }\n+                    if (!allEqual) {\n+                        reporter.reportDifferentDirectives(dPos, dMap);\n+                    }\n+                }\n+            } finally {\n+                reporter.completed(dPos, allEqual);\n+            }\n+\n+            return allEqual;\n+        }\n+    }\n+\n+    private class RequiresComparator extends DirectiveComparator<RequiresDirective> {\n+        RequiresComparator(Set<API> apis) {\n+            super(apis, DirectiveKind.REQUIRES);\n+        }\n+\n+        @Override\n+        boolean compare(Position rPos, APIMap<RequiresDirective> rMap) {\n+            boolean allEqual = false;\n+            reporter.comparing(rPos, rMap);\n+            try {\n+                allEqual = checkMissing(rPos, rMap);\n+                if (rMap.size() > 1) {\n+                    boolean first = true;\n+                    boolean baselineIsStatic = false;\n+                    boolean baselineIsTransitive = false;\n+                    for (RequiresDirective rd : rMap.values()) {\n+                        if (first) {\n+                            baselineIsStatic = rd.isStatic();\n+                            baselineIsTransitive = rd.isTransitive();\n+                            first = false;\n+                        } else if (rd.isStatic() != baselineIsStatic || rd.isTransitive() != baselineIsTransitive) {\n+                            allEqual = false;\n+                            break;\n+                        }\n+                    }\n+                    if (!allEqual) {\n+                        reporter.reportDifferentDirectives(rPos, rMap);\n+                    }\n+                }\n+            } finally {\n+                reporter.completed(rPos, allEqual);\n+            }\n+\n+            return allEqual;\n+        }\n+    }\n+\n+    private class ExportsComparator extends DirectiveComparator<ExportsDirective> {\n+        ExportsComparator(Set<API> apis) {\n+            super(apis, DirectiveKind.EXPORTS);\n+        }\n+\n+        @Override\n+        boolean compare(Position ePos, APIMap<ExportsDirective> eMap) {\n+            return compare(ePos, eMap, ExportsDirective::getTargetModules);\n+        }\n+    }\n+\n+    private class OpensComparator extends DirectiveComparator<OpensDirective> {\n+        OpensComparator(Set<API> apis) {\n+            super(apis, DirectiveKind.OPENS);\n+        }\n+\n+        @Override\n+        boolean compare(Position oPos, APIMap<OpensDirective> oMap) {\n+            return compare(oPos, oMap, OpensDirective::getTargetModules);\n+        }\n+    }\n+\n+    private class ProvidesComparator extends DirectiveComparator<ProvidesDirective> {\n+        private final boolean allDirectiveDetails;\n+\n+        ProvidesComparator(Set<API> apis, boolean allDirectiveDetails) {\n+            super(apis, DirectiveKind.PROVIDES);\n+            this.allDirectiveDetails = allDirectiveDetails;\n+        }\n+\n+        @Override\n+        boolean compare(Position pPos, APIMap<ProvidesDirective> pMap) {\n+            \/\/ The implementations listed in the directive are not considered\n+            \/\/ part of the public API, so do not compare (i.e. ignore)\n+            \/\/ that part of the API unless allDirectiveDetails is set.\n+            return compare(pPos, pMap,\n+                    d -> allDirectiveDetails ? d.getImplementations() : Collections.emptyList());\n+        }\n+    }\n+\n+    private class UsesComparator extends DirectiveComparator<UsesDirective> {\n+        UsesComparator(Set<API> apis) {\n+            super(apis, DirectiveKind.USES);\n+        }\n+\n+        @Override\n+        boolean compare(Position uPos, APIMap<UsesDirective> uMap) {\n+            return checkMissing(uPos, uMap);\n+        }\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/ModuleComparator.java","additions":414,"deletions":0,"binary":false,"changes":414,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.EnumSet;\n+import java.util.Set;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.tools.JavaFileObject;\n+\n+import jdk.codetools.apidiff.Options;\n+import jdk.codetools.apidiff.model.API.LocationKind;\n+import jdk.codetools.apidiff.report.Reporter;\n+\n+\/**\n+ * A comparator for {@link PackageElement package elements}.\n+ *\n+ * <p>The comparison includes:\n+ * <ul>\n+ *     <li>the documentation comment for the package\n+ *     <li>the selected types in the package\n+ *     <li>additional documentation files for the package\n+ * <\/ul>\n+ *\/\n+public class PackageComparator extends ElementComparator<PackageElement> {\n+\n+    \/**\n+     * Creates a comparator to compare package elements across a set of APIs.\n+     *\n+     * @param apis     the set of APIs\n+     * @param options  the command-line options\n+     * @param reporter the reporter to which to report differences\n+     *\/\n+    public PackageComparator(Set<API> apis, Options options, Reporter reporter) {\n+        super(apis, options, reporter);\n+    }\n+\n+    \/**\n+     * Compares instances of a package element found in different APIs.\n+     *\n+     * @param pPos the position of the element\n+     * @param pMap the map giving the instance of the package element in different APIs\n+     * @return {@code true} if all the instances are equivalent\n+     *\/\n+    @Override\n+    public boolean compare(Position pPos, APIMap<PackageElement> pMap) {\n+        boolean allEqual = false;\n+        reporter.comparing(pPos, pMap);\n+        try {\n+            allEqual = checkMissing(pPos, pMap);\n+            if (pMap.size() > 1) {\n+                allEqual &= compareAnnotations(pPos, pMap);\n+                allEqual &= compareDocComments(pPos, pMap);\n+                allEqual &= compareApiDescriptions(pPos, pMap);\n+                allEqual &= compareTypes(pPos, pMap);\n+                allEqual &= compareDocFiles(pPos, pMap);\n+            }\n+        } finally {\n+            reporter.completed(pPos, allEqual);\n+        }\n+        return allEqual;\n+    }\n+\n+    private boolean compareTypes(Position pPos, APIMap<PackageElement> pMap) {\n+        TypeComparator tc = new TypeComparator(pMap.keySet(), options, reporter);\n+        KeyTable<TypeElement> types = KeyTable.of(pMap, API::getTypeElements);\n+        return tc.compareAll(types);\n+    }\n+\n+    \/**\n+     * Returns the doc comment for an element in a given API.\n+     *\n+     * If the element is a package element, and no comment is found in the\n+     * package's {@code package-info.java} file, the methods looks for\n+     * a {@code package.html} file as a fallback.\n+     *\n+     * @param api the API\n+     * @param e   the element\n+     *\n+     * @return the doc comment\n+     *\/\n+    @Override\n+    protected String getDocComment(API api, Element e) {\n+        String s = super.getDocComment(api, e);\n+        if (s != null) {\n+            return s;\n+        }\n+\n+        if (e.getKind() == ElementKind.PACKAGE) {\n+            \/\/ There is no easy API to get the package.html file directly.\n+            \/\/ Trees.getDocCommentTree(Element e, String relativeName) only looks on\n+            \/\/ the source path; ideally, it should realize the package is in a module\n+            \/\/ and use the correct entry from the module source path. But even so,\n+            \/\/ this method is somewhat lower-level, and just wants the raw text,\n+            \/\/ and not the parsed doc comment tree.\n+            for (JavaFileObject fo : api.listFiles(LocationKind.SOURCE, e, \"\",\n+                    EnumSet.of(JavaFileObject.Kind.HTML), false)) {\n+                if (fo.getName().endsWith(\"\/package.html\")) {\n+                    return api.getApiDescription(fo);\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/PackageComparator.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,861 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.Comparator;\n+import java.util.Objects;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ModuleElement.DirectiveKind;\n+\n+\/**\n+ * An abstract description of the position in an API of some item\n+ * to be compared.\n+ *\n+ * <p>Positions are initially created from element keys;\n+ * additional positions describing positions within an item\n+ * can be created by various factory methods. These methods\n+ * may throw {@code UnsupportedOperationException} if the\n+ * factory method is not applicable for the parent position.\n+ *\/\n+public abstract class Position {\n+    \/**\n+     * Creates a position for a given element key, which must be\n+     * for a module, package, type, constructor, method, enum\n+     * constant or field.\n+     *\n+     * <p>Positions for parameters and type parameters should\n+     * be created using the appropriate factory method, providing\n+     * the necessary index value.\n+     *\n+     * @param k the key for the element\n+     * @return the position\n+     *\/\n+    public static Position of(ElementKey k) {\n+        return switch (k.kind) {\n+            case MODULE, PACKAGE, TYPE, VARIABLE, EXECUTABLE -> new ElementPosition(k);\n+            default -> throw new IllegalArgumentException(k.toString());\n+        };\n+    }\n+\n+    \/**\n+     * Returns whether this position is the position of an element.\n+     *\n+     * @return {@code true} if and ony if the position is the position of an element\n+     *\/\n+    public boolean isElement() {\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns whether this position represents the given kind of element.\n+     *\n+     * @param kind the kind\n+     *\n+     * @return {@code true} if and only if the position represents the given kind of element\n+     *\/\n+    public boolean is(ElementKind kind) {\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns whether this position is a relative position.\n+     *\n+     * @return {@code true} if and only if the position is a relative position\n+     *\/\n+    public boolean isRelative() {\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns whether this position represents the given kind of relative position.\n+     *\n+     * @param kind the kind\n+     *\n+     * @return {@code true} if and only if the position represents the given kind of relative position\n+     *\/\n+    public boolean is(RelativePosition.Kind kind) {\n+        return false;\n+    }\n+\n+    \/**\n+     * Creates a position for an annotation on an element,\n+     * identified by the annotation type.\n+     *\n+     * <p>Repeated annotations are assumed to be enclosed within\n+     * a container annotation.\n+     *\n+     * @param key the key of the annotation type\n+     *\n+     * @return the position\n+     *\/\n+    public abstract RelativePosition<ElementKey> annotation(ElementKey key);\n+\n+    \/**\n+     * Creates a position for a value within an array of annotation values.\n+     *\n+     * @param index the position within the array\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<Integer> annotationArrayIndex(int index) {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for value within an annotation,\n+     * identified by the annotation type element.\n+     *\n+     * @param key the key of the annotation type member\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<ElementKey> annotationValue(ElementKey key) {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for a bound of a type parameter element.\n+     *\n+     * @param index the index of the bound within the list of bounds\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<Integer> bound(int index) {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for the default value of an annotation element.\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<Void> defaultValue() {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for a directive within a module declaration,\n+     * based on the kind of the directive and the primary type described\n+     * by the directive. The kind of the primary type depends on the\n+     * kind of directive.\n+     *\n+     * @param kind the kind of directive\n+     * @param key  the key for the primary type of the directory\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<?> directive(DirectiveKind kind, ElementKey key) {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for a doc file of a module or package, identified by\n+     * the name relative to the enclosing {@code doc-files} directory.\n+     * The name always uses {@code \/} as the internal file separator\n+     * (and not the platform file separator.\n+     *\n+     * @param name the name\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<String> docFile(String name) {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for an exception that is thrown from an executable element.\n+     *\n+     * @param key the key of the exception that is thrown\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<TypeMirrorKey> exception(TypeMirrorKey key) {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for a parameter of an executable element.\n+     *\n+     * @param index the index of the parameter within the list of parameters\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<Integer> parameter(int index) {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for a permitted subtype of a sealed class.\n+     *\n+     * @param key the element key for the subtype\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<ElementKey> permittedSubclass(ElementKey key) {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for the receiver type of a method.\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<Void> receiverType() {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for a record component of a record.\n+     *\n+     * @param index the index of the component within the list of components\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<Integer> recordComponent(int index) {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for the return type of a method.\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<Void> returnType() {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for the {@code serialVersionUID} of a type element or its serialized form.\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<Void> serialVersionUID() {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for a serialization method of a type element or its serialized form.\n+     *\n+     * @param name the name of the method\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<String> serializationMethod(String name) {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for a serialization overview of a type element or its serialized form.\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<Void> serializationOverview() {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for a serialized field of a type element or its serialized form.\n+     *\n+     * @param name the name of the field\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<String> serializedField(String name) {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for the serialized form of a type element.\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<Void> serializedForm() {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for the superclass of a class type.\n+     *\n+     * @return the position\n+     *\/\n+    public RelativePosition<Void> superclass() {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for a superinterface of a class or interface type.\n+     *\n+     * @param eKey the index of the parameter within the list of parameters\n+     * @return the position\n+     *\/\n+    public RelativePosition<ElementKey> superinterface(ElementKey eKey) {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Creates a position for a type parameter of a type or executable element.\n+     *\n+     * @param index the index of the type parameter within the list of type parameters\n+     * @return the position\n+     *\/\n+    public RelativePosition<Integer> typeParameter(int index) {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Returns the element key, if this position directly represents an element.\n+     * @return the element key\n+     * @throws UnsupportedOperationException if this position does not directly represent an element\n+     *\/\n+    public ElementKey asElementKey() {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Returns the position as one with the given index class.\n+     * The method provides an easy safe way to downcast a {@code RelativePosition<?>}\n+     * to a {@code RelativePosition<T>} where {@code T} is the kind of the index\n+     * for the expected kind of the position.\n+     *\n+     * @param kind the expected kind of the position\n+     * @param c    the expected class of the index\n+     * @param <T>  the expected type of the index\n+     *\n+     * @return the position\n+     *\/\n+    public <T> RelativePosition<T> as(RelativePosition.Kind kind, Class<T> c) {\n+        throw unsupported();\n+    }\n+\n+    \/**\n+     * Returns the element key for a position.\n+     *\n+     * The element key for an element position is its key.\n+     * The element key for a relative position is the element key of its parent.\n+     *\n+     * @return the element key for a position\n+     *\/\n+    public abstract ElementKey getElementKey();\n+\n+    \/\/ Abstract, to force all subtypes to implement this method.\n+    @Override\n+    public abstract boolean equals(Object other);\n+\n+    \/\/ Abstract, to force all subtypes to implement this method.\n+    @Override\n+    public abstract int hashCode();\n+\n+    \/**\n+     * Applies a visitor to this position.\n+     * @param v the visitor\n+     * @param p a visitor-specified parameter\n+     * @param <R> the type of the result\n+     * @param <P> the type of the parameter\n+     * @return a visitor-specified result\n+     *\/\n+    public abstract <R,P> R accept(Visitor<R,P> v, P p);\n+\n+    \/**\n+     * Throws an {@code UnsupportedOperationException} if a given condition is {@code false}.\n+     *\n+     * @param cond the condition\n+     *\/\n+    protected void check(boolean cond) {\n+        if (!cond) {\n+            throw unsupported();\n+        }\n+    }\n+\n+    \/**\n+     * Creates an {@code UnsupportedOperationException} for this position.\n+     * @return the exception\n+     *\/\n+    protected UnsupportedOperationException unsupported() {\n+        return new UnsupportedOperationException(getClass().getSimpleName() + \" \" + toString());\n+    }\n+\n+    \/**\n+     * A visitor of positions, in the style of the visitor design pattern.\n+     * Classes implementing this interface are used to operate on a position\n+     * when the kind of position is unknown at compile time.\n+     * When a visitor is passed to a position's {@code accept} method,\n+     * the <code>visit<em>Xyz<\/em><\/code> method applicable to that position is invoked.\n+     *\n+     * @param <R> the return type of this visitor's methods.\n+     *              Use Void for visitors that do not need to return results.\n+     * @param <P> the type of the additional parameter to this visitor's methods.\n+     *              Use Void for visitors that do not need an additional parameter.\n+     *\/\n+    public interface Visitor<R,P> {\n+        \/**\n+         * Visits a position identified by an element key.\n+         * @param kp the position to visit\n+         * @param p a visitor-specified parameter\n+         * @return a visitor-specified result\n+         *\/\n+        R visitElementPosition(ElementPosition kp, P p);\n+\n+        \/**\n+         * Visits a relative position.\n+         * @param ip the position to visit\n+         * @param p a visitor-specified parameter\n+         * @return a visitor-specified result\n+         *\/\n+        R visitRelativePosition(RelativePosition<?> ip, P p);\n+    }\n+\n+    \/**\n+     * A position identified by an element key.\n+     *\/\n+    public static class ElementPosition extends Position {\n+        \/** The element key. *\/\n+        public final ElementKey key;\n+\n+        ElementPosition(ElementKey key) {\n+            this.key = key;\n+        }\n+\n+        @Override\n+        public boolean is(ElementKind kind) {\n+            return key.is(kind);\n+        }\n+\n+        @Override\n+        public boolean isElement() {\n+            return true;\n+        }\n+\n+        @Override\n+        public RelativePosition<ElementKey> annotation(ElementKey key) {\n+            return new RelativePosition<>(this, RelativePosition.Kind.ANNOTATION, key);\n+        }\n+\n+        @Override\n+        public RelativePosition<Void> defaultValue() {\n+            check(key.is(ElementKind.METHOD));\n+            return new RelativePosition<>(this, RelativePosition.Kind.DEFAULT_VALUE);\n+        }\n+\n+        @Override\n+        public RelativePosition<ElementKey> directive(DirectiveKind kind, ElementKey typeKey) {\n+            check(key.is(ElementKey.Kind.MODULE));\n+            return new RelativePosition<>(this, kind, typeKey);\n+        }\n+\n+        @Override\n+        public RelativePosition<String> docFile(String name) {\n+            check(key.is(ElementKey.Kind.MODULE) || key.is(ElementKey.Kind.PACKAGE));\n+            return new RelativePosition<>(this, RelativePosition.Kind.DOC_FILE, name);\n+        }\n+\n+        @Override\n+        public RelativePosition<TypeMirrorKey> exception(TypeMirrorKey key) {\n+            return new RelativePosition<>(this, RelativePosition.Kind.EXCEPTION, key);\n+        }\n+\n+        @Override\n+        public RelativePosition<Integer> parameter(int index) {\n+            check(key.is(ElementKey.Kind.EXECUTABLE));\n+            return new RelativePosition<>(this, RelativePosition.Kind.PARAMETER, index);\n+        }\n+\n+        @Override\n+        public RelativePosition<ElementKey> permittedSubclass(ElementKey key) {\n+            check(key.is(ElementKey.Kind.TYPE));\n+            return new RelativePosition<>(this, RelativePosition.Kind.PERMITTED_SUBCLASS, key);\n+        }\n+\n+        @Override\n+        public RelativePosition<Void> receiverType() {\n+            check(key.is(ElementKind.METHOD));\n+            return new RelativePosition<>(this, RelativePosition.Kind.RECEIVER_TYPE);\n+        }\n+\n+        @Override\n+        public RelativePosition<Integer> recordComponent(int index) {\n+            \/\/check(key.is(ElementKey.Kind.RECORD));\n+            return new RelativePosition<>(this, RelativePosition.Kind.RECORD_COMPONENT, index);\n+        }\n+\n+        @Override\n+        public RelativePosition<Void> returnType() {\n+            check(key.is(ElementKind.METHOD));\n+            return new RelativePosition<>(this, RelativePosition.Kind.RETURN_TYPE);\n+        }\n+\n+        @Override\n+        public RelativePosition<Void> serialVersionUID() {\n+            check(key.kind == ElementKey.Kind.TYPE);\n+            return new RelativePosition<>(this, RelativePosition.Kind.SERIAL_VERSION_UID);\n+        }\n+\n+        @Override\n+        public RelativePosition<String> serializationMethod(String name) {\n+            check(key.kind == ElementKey.Kind.TYPE);\n+            return new RelativePosition<>(this, RelativePosition.Kind.SERIALIZATION_METHOD, name);\n+        }\n+\n+        @Override\n+        public RelativePosition<Void> serializationOverview() {\n+            check(key.kind == ElementKey.Kind.TYPE);\n+            return new RelativePosition<>(this, RelativePosition.Kind.SERIALIZATION_OVERVIEW);\n+        }\n+\n+        @Override\n+        public RelativePosition<String> serializedField(String name) {\n+            check(key.kind == ElementKey.Kind.TYPE);\n+            return new RelativePosition<>(this, RelativePosition.Kind.SERIALIZED_FIELD, name);\n+        }\n+\n+        @Override\n+        public RelativePosition<Void> serializedForm() {\n+            check(key.kind == ElementKey.Kind.TYPE);\n+            return new RelativePosition<>(this, RelativePosition.Kind.SERIALIZED_FORM);\n+        }\n+\n+        @Override\n+        public RelativePosition<Void> superclass() {\n+            \/\/ Although superclass is only meaningful for elementKind CLASS,\n+            \/\/ we have to tolerate requesting a position for the superclass\n+            \/\/ on ANNOTATION_TYPE, ENUM and INTERFACE, because we might be\n+            \/\/ comparing elements that changed kind, such as from CLASS to INTERFACE.\n+            check(key.kind == ElementKey.Kind.TYPE);\n+            return new RelativePosition<>(this, RelativePosition.Kind.SUPERCLASS);\n+        }\n+\n+        @Override\n+        public RelativePosition<ElementKey> superinterface(ElementKey eKey) {\n+            check(key.kind == ElementKey.Kind.TYPE);\n+            return new RelativePosition<>(this, RelativePosition.Kind.SUPERINTERFACE, eKey);\n+        }\n+\n+        @Override\n+        public RelativePosition<Integer> typeParameter(int index) {\n+            \/\/ Strictly speaking, enum types and annotation types cannot be generic\n+            \/\/ but that will never arise in a well-formed program.\n+            check(key.kind == ElementKey.Kind.TYPE || key.kind == ElementKey.Kind.EXECUTABLE);\n+            return new RelativePosition<>(this, RelativePosition.Kind.TYPE_PARAMETER, index);\n+        }\n+\n+        @Override\n+        public ElementKey asElementKey() {\n+            return key;\n+        }\n+\n+        @Override\n+        public ElementKey getElementKey() {\n+            return key;\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            } else if (other == null || other.getClass() != getClass()) {\n+                return false;\n+            } else {\n+                return key.equals(((ElementPosition) other).key);\n+            }\n+\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return key.hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"{\" + key + \"}\";\n+        }\n+\n+        @Override\n+        public <R, P> R accept(Visitor<R,P> v, P p) {\n+            return v.visitElementPosition(this, p);\n+        }\n+    }\n+\n+    \/**\n+     * A position within an parent position, specified by its kind\n+     * and possible index.\n+     *\n+     * <p>Depending on the kind, the index should be an integer,\n+     * a name (element key) or null (void).\n+     *\/\n+    public static class RelativePosition<T> extends Position {\n+        \/**\n+         * The kind of index for an {@code RelativePosition}.\n+         *\/\n+        public enum Kind {\n+            \/** The index of an annotation on an annotated construct. *\/\n+            ANNOTATION,\n+            \/** The index of an item in an annotation array value. *\/\n+            ANNOTATION_ARRAY_INDEX,\n+            \/** The index of a value in an annotation. *\/\n+            ANNOTATION_VALUE,\n+            \/** The index of a bound in a type parameter. *\/\n+            BOUND,\n+            \/** The default value of an annotation element. *\/\n+            DEFAULT_VALUE,\n+            \/** A doc file in a module or package. *\/\n+            DOC_FILE,\n+            \/** The index of a exception that is thrown. *\/\n+            EXCEPTION,\n+            \/** The index of an {@code exports} directive in a module declaration. *\/\n+            MODULE_EXPORTS,\n+            \/** The index of an {@code requires} directive in a module declaration. *\/\n+            MODULE_REQUIRES,\n+            \/** The index of an {@code opens} directive in a module declaration. *\/\n+            MODULE_OPENS,\n+            \/** The index of an {@code provides} directive in a module declaration. *\/\n+            MODULE_PROVIDES,\n+            \/** The index of an {@code uses} directive in a module declaration. *\/\n+            MODULE_USES,\n+            \/** The index of a parameter. *\/\n+            PARAMETER,\n+            \/** The index of a permitted subclass of a type element. *\/\n+            PERMITTED_SUBCLASS,\n+            \/** The receiver type of a method. *\/\n+            RECEIVER_TYPE,\n+            \/** The index of a record component. *\/\n+            RECORD_COMPONENT,\n+            \/** The return type of a method. *\/\n+            RETURN_TYPE,\n+            \/** The {@code serialVersionUID} of a serializable class. *\/\n+            SERIAL_VERSION_UID,\n+            \/** A serialization method in a serializable class. *\/\n+            SERIALIZATION_METHOD,\n+            \/** The serialization overview of a serializable class. *\/\n+            SERIALIZATION_OVERVIEW,\n+            \/** A serialized field in a serializable class. *\/\n+            SERIALIZED_FIELD,\n+            \/** The serialized form of a serializable class. *\/\n+            SERIALIZED_FORM,\n+            \/** The superclass of a type. *\/\n+            SUPERCLASS,\n+            \/** A superinterface of a type. *\/\n+            SUPERINTERFACE,\n+            \/** The index of a type parameter. *\/\n+            TYPE_PARAMETER\n+        }\n+\n+        \/** The enclosing position. *\/\n+        public final Position parent;\n+        \/** The kind of item given by the relative position. *\/\n+        public final Kind kind;\n+        \/** The index given by the relative position. *\/\n+        public final T index;\n+\n+        RelativePosition(Position parent, Kind kind) {\n+            this.parent = Objects.requireNonNull(parent);\n+            this.kind = Objects.requireNonNull(kind);\n+            this.index = null;\n+        }\n+\n+        RelativePosition(Position parent, Kind kind, T index) {\n+            this.parent = Objects.requireNonNull(parent);\n+            this.kind = Objects.requireNonNull(kind);\n+            this.index = index;\n+        }\n+\n+        RelativePosition(Position parent, DirectiveKind kind, T index) {\n+            this(parent, getKind(kind), index);\n+        }\n+\n+        private static Kind getKind(DirectiveKind k) {\n+            return switch (k) {\n+                case EXPORTS -> Kind.MODULE_EXPORTS;\n+                case OPENS -> Kind.MODULE_OPENS;\n+                case PROVIDES -> Kind.MODULE_PROVIDES;\n+                case REQUIRES -> Kind.MODULE_REQUIRES;\n+                case USES -> Kind.MODULE_USES;\n+            };\n+        }\n+\n+        @Override\n+        public boolean isRelative() {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean is(RelativePosition.Kind kind) {\n+            return this.kind == kind;\n+        }\n+\n+        @Override\n+        public RelativePosition<ElementKey> annotation(ElementKey key) {\n+            return new RelativePosition<>(this, Kind.ANNOTATION, key);\n+        }\n+\n+        @Override\n+        public RelativePosition<Integer> annotationArrayIndex(int i) {\n+            return new RelativePosition<>(this, Kind.ANNOTATION_ARRAY_INDEX,  i);\n+        }\n+\n+        @Override\n+        public RelativePosition<ElementKey> annotationValue(ElementKey key) {\n+            return new RelativePosition<>(this, Kind.ANNOTATION_VALUE,  key);\n+        }\n+\n+        @Override\n+        public RelativePosition<Integer> bound(int i) {\n+            return new RelativePosition<>(this, Kind.BOUND,  i);\n+        }\n+\n+        @Override\n+        public RelativePosition<TypeMirrorKey> exception(TypeMirrorKey type) {\n+            check(kind == Kind.SERIALIZATION_METHOD);\n+            return new RelativePosition<>(parent, Kind.EXCEPTION, type);\n+        }\n+\n+        @Override\n+        public RelativePosition<Integer> parameter(int index) {\n+            check(kind == Kind.SERIALIZATION_METHOD);\n+            return new RelativePosition<>(this, Kind.PARAMETER, index);\n+        }\n+\n+        @Override\n+        public RelativePosition<Void> receiverType() {\n+            check(kind == Kind.SERIALIZATION_METHOD);\n+            return new RelativePosition<>(this, Kind.RECEIVER_TYPE);\n+        }\n+\n+        @Override\n+        public RelativePosition<Void> returnType() {\n+            check(kind == Kind.SERIALIZATION_METHOD);\n+            return new RelativePosition<>(this, Kind.RETURN_TYPE);\n+        }\n+\n+        @Override\n+        public RelativePosition<Void> serialVersionUID() {\n+            check(kind == Kind.SERIALIZED_FORM);\n+            return new RelativePosition<>(parent, RelativePosition.Kind.SERIAL_VERSION_UID);\n+        }\n+\n+        @Override\n+        public RelativePosition<String> serializationMethod(String name) {\n+            check(kind == Kind.SERIALIZED_FORM);\n+            return new RelativePosition<>(parent, RelativePosition.Kind.SERIALIZATION_METHOD, name);\n+        }\n+\n+        @Override\n+        public RelativePosition<Void> serializationOverview() {\n+            check(kind == Kind.SERIALIZED_FORM);\n+            return new RelativePosition<>(parent, RelativePosition.Kind.SERIALIZATION_OVERVIEW);\n+        }\n+\n+        @Override\n+        public RelativePosition<String> serializedField(String name) {\n+            check(kind == Kind.SERIALIZED_FORM);\n+            return new RelativePosition<>(parent, RelativePosition.Kind.SERIALIZED_FIELD, name);\n+        }\n+\n+        @Override\n+        public RelativePosition<Void> serializedForm() {\n+            return switch (kind) {\n+                case SERIAL_VERSION_UID, SERIALIZATION_METHOD, SERIALIZATION_OVERVIEW, SERIALIZED_FIELD ->\n+                        new RelativePosition<>(parent, Kind.SERIALIZED_FORM);\n+                default -> throw unsupported();\n+            };\n+        }\n+\n+        @Override\n+        public ElementKey getElementKey() {\n+            return parent.getElementKey();\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            } else if (other == null || other.getClass() != getClass()) {\n+                return false;\n+            } else {\n+                RelativePosition<?> ip = (RelativePosition<?>) other;\n+                return parent.equals(ip.parent)\n+                        && kind == ip.kind\n+                        && Objects.equals(index, ip.index);\n+            }\n+\n+        }\n+\n+        @Override\n+        public <U> RelativePosition<U> as(Kind kind, Class<U> c) {\n+            @SuppressWarnings(\"unchecked\")\n+            RelativePosition<U> p = (RelativePosition<U>) this;\n+            return p;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int hashCode = parent.hashCode();\n+            hashCode = hashCode * 37 + kind.hashCode();\n+            hashCode = hashCode * 37 + Objects.hashCode(index);\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            \/\/ TODO: convert to a simple debug print, and use SignatureVisitor or pretty print.\n+            return \"{\" + parent + \": \" + kind + \" #\" + index + \"}\";\n+        }\n+\n+        @Override\n+        public <R, P> R accept(Visitor<R,P> v, P p) {\n+            return v.visitRelativePosition(this, p);\n+        }\n+    }\n+\n+    \/**\n+     * A comparator for relative positions whose index is an element key.\n+     *\/\n+    public static final Comparator<RelativePosition<?>> elementKeyIndexComparator = (rp1, rp2) -> {\n+        if (rp1.parent != rp2.parent) {\n+            throw new IllegalArgumentException(\"parents not equal\");\n+        }\n+        if (rp1.kind != rp2.kind) {\n+            throw new IllegalArgumentException(\"kinds not equal\");\n+        }\n+        ElementKey i1 = (ElementKey) rp1.index;\n+        ElementKey i2 = (ElementKey) rp2.index;\n+        return i1.compareTo(i2);\n+    };\n+\n+    \/**\n+     * A comparator for relative positions whose index is a string.\n+     *\/\n+    public static final Comparator<RelativePosition<?>> stringIndexComparator = (rp1, rp2) -> {\n+        if (rp1.parent != rp2.parent) {\n+            throw new IllegalArgumentException(\"parents not equal\");\n+        }\n+        if (rp1.kind != rp2.kind) {\n+            throw new IllegalArgumentException(\"kinds not equal\");\n+        }\n+        String i1 = (String) rp1.index;\n+        String i2 = (String) rp2.index;\n+        return i1.compareTo(i2);\n+    };\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/Position.java","additions":861,"deletions":0,"binary":false,"changes":861,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.Objects;\n+import java.util.Set;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.Name;\n+import javax.lang.model.type.TypeMirror;\n+\n+import jdk.codetools.apidiff.Options;\n+import jdk.codetools.apidiff.report.Reporter;\n+\n+\/**\n+ * A comparator for record component elements.\n+ *\n+ * <p>The comparison includes:\n+ * <ul>\n+ *     <li>the \"signature\" of the element: its annotations, name and type\n+ * <\/ul>\n+ *\/\n+public class RecordComponentComparator extends ElementComparator<Element> {\n+\n+    \/**\n+     * Creates a comparator to compare record component elements across a set of APIs.\n+     *\n+     * @param apis     the set of APIs\n+     * @param options  the command-line options\n+     * @param reporter the reporter to which to report differences\n+     *\/\n+    public RecordComponentComparator(Set<API> apis, Options options, Reporter reporter) {\n+        super(apis, options, reporter);\n+    }\n+\n+    \/**\n+     * Compares instances of a record component element found in different APIs.\n+     *\n+     * @param rcPos the position of the element\n+     * @param rcMap the map giving the instance of the variable element in different APIs\n+     * @return {@code true} if all the instances are equivalent\n+     *\/\n+    @Override\n+    public boolean compare(Position rcPos, APIMap<Element> rcMap) {\n+        boolean allEqual = false;\n+        reporter.comparing(rcPos, rcMap);\n+        try {\n+            allEqual = checkMissing(rcPos, rcMap);\n+            if (rcMap.size() > 1) {\n+                allEqual &= compareSignatures(rcPos, rcMap);\n+                allEqual &= compareDocComments(rcPos, rcMap);\n+                allEqual &= compareApiDescriptions(rcPos, rcMap);\n+            }\n+        } finally {\n+            reporter.completed(rcPos, allEqual);\n+        }\n+        return allEqual;\n+    }\n+\n+    private boolean compareSignatures(Position rcPos, APIMap<Element> rcMap) {\n+        return compareAnnotations(rcPos, rcMap)\n+                & compareNames(rcPos, rcMap)\n+                & compareType(rcPos, rcMap);\n+    }\n+\n+    private boolean compareNames(Position rcPos, APIMap<Element> rcMap) {\n+\n+        if (rcMap.size() == 1)\n+            return true;\n+\n+        Name archetype = rcMap.values().stream()\n+                .filter(Objects::nonNull)\n+                .findFirst()\n+                .get()\n+                .getSimpleName();\n+\n+        for (Element e : rcMap.values()) {\n+            if (!e.getSimpleName().contentEquals(archetype)) {\n+                reporter.reportDifferentNames(rcPos, rcMap);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean compareType(Position rcPos, APIMap<Element> rcMap) {\n+        TypeMirrorComparator tmc = new TypeMirrorComparator(rcMap.keySet(), reporter);\n+        APIMap<TypeMirror> tMap = rcMap.map(Element::asType);\n+        return tmc.compare(rcPos, tMap);\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/RecordComponentComparator.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.List;\n+\n+\/**\n+ * A filter to determine whether modules, packages and types within\n+ * an API are \"selected\", according to a series of \"include\" and \"exclude\"\n+ * options.\n+ *\n+ * <p>The following patterns are accepted:\n+ * <ul>\n+ *     <li>module\/**            all types in a module\n+ *     <li>module\/package.**    all types in a package and its subpackages\n+ *     <li>module\/package.*     all types in a package\n+ *     <li>module\/package.Type  a specific type\n+ *     <li>package.**           all types in a package and its subpackages\n+ *                              that are not in a named module\n+ *     <li>package.*            all types in a package is not in a named module\n+ *     <li>package.Type         a specific type in a package that is not in a named module\n+ * <\/ul>\n+ * where:\n+ * <ul>\n+ *     <li>\"module\" is a qualified identifier, optionally ending in '.*'\n+ *          to indicate all modules beginning with the given prefix,\n+ *     <li>\"package\" is a qualified identifier indicating a package of that name\n+ *     <li>\"not in a named module\" is case when using versions of the platform\n+ *          prior to the introduction of the module system, or in the unnamed module\n+ *          thereafter.\n+ * <\/ul>\n+ *\/\n+public class Selector {\n+    static class Entry {\n+        final String pattern;\n+\n+        final String modulePart;\n+        final String packagePart;\n+        final String typePart;\n+\n+        final Predicate<String> includeModule;\n+        final Predicate<String> includePackage;\n+        final Predicate<String> includeType;\n+\n+        final Predicate<String> excludeModule;\n+        final Predicate<String> excludePackage;\n+        final Predicate<String> excludeType;\n+\n+        static final Predicate<String> ALWAYS = s -> true;\n+        static final Predicate<String> NEVER = s -> false;\n+\n+        Entry(String pattern) {\n+            this.pattern = pattern;\n+            int sep = pattern.indexOf(\"\/\");\n+            String head, tail;\n+            if (sep == -1) {\n+                head = null;\n+                tail = pattern;\n+            } else {\n+                head = pattern.substring(0, sep);\n+                tail = pattern.substring(sep + 1);\n+            }\n+\n+            if (head == null) {\n+                includeModule = s -> s == null || s.isEmpty();\n+            } else if (head.endsWith(\".*\")) {\n+                String mdlPrefix = head.substring(0, head.length() - 1);\n+                includeModule = s -> s != null && s.startsWith(mdlPrefix);\n+            } else {\n+                includeModule = s -> s != null && s.equals(head);\n+            }\n+            modulePart = head;\n+\n+            if (tail.isEmpty() || tail.equals(\"**\")) {\n+                includePackage = ALWAYS;\n+                includeType = ALWAYS;\n+                excludeModule = includeModule;\n+                excludePackage = ALWAYS;\n+                excludeType = ALWAYS;\n+                packagePart = \"\";\n+                typePart = \"**\";\n+            } else if (tail.equals(\"*\")) {\n+                includePackage = String::isEmpty;\n+                includeType = s -> true;\n+                excludeModule = NEVER;\n+                excludePackage = includePackage;\n+                excludeType = ALWAYS;\n+                packagePart = \"\";\n+                typePart = \"*\";\n+            } else if (tail.endsWith(\".*\")) {\n+                String pkgName = tail.substring(0, tail.length() - 2);\n+                includePackage = s -> s.equals(pkgName);\n+                includeType = s -> true;\n+                excludeModule = NEVER;\n+                excludePackage = includePackage;\n+                excludeType = ALWAYS;\n+                packagePart = pkgName;\n+                typePart = \"*\";\n+            } else if (tail.endsWith(\".**\")) {\n+                String pkgName = tail.substring(0, tail.length() - 3);\n+                String pkgPrefix = tail.substring(0, tail.length() - 2);\n+                includePackage = s -> s.equals(pkgName) || s.startsWith(pkgPrefix);\n+                includeType = s -> true;\n+                excludeModule = NEVER;\n+                excludePackage = includePackage;\n+                excludeType = ALWAYS;\n+                packagePart = pkgName;\n+                typePart = \"**\";\n+            } else {\n+                int lastDot = tail.lastIndexOf(\".\");\n+                if (lastDot == -1) {\n+                    includePackage = String::isEmpty;\n+                    includeType = s -> s.equals(tail);\n+                    packagePart = \"\";\n+                    typePart = tail;\n+                } else {\n+                    String pkgName = tail.substring(0, lastDot);\n+                    String typeName = tail.substring(lastDot + 1);\n+                    includePackage = s -> s.equals(pkgName);\n+                    includeType = s -> s.equals(typeName);\n+                    packagePart = pkgName;\n+                    typePart = typeName;\n+                }\n+\n+                excludeModule = NEVER;\n+                excludePackage = NEVER;\n+                excludeType = includeType;\n+            }\n+        }\n+\n+        boolean includesModule(String moduleName) {\n+            return includeModule.test(moduleName);\n+        }\n+\n+        boolean excludesModule(String moduleName) {\n+            return excludeModule.test(moduleName);\n+        }\n+\n+        boolean includesPackage(String moduleName, String packageName) {\n+            return includeModule.test(moduleName) && includePackage.test(packageName);\n+        }\n+\n+        boolean excludesPackage(String moduleName, String packageName) {\n+            return excludesModule(moduleName)\n+                    || includesModule(moduleName) && excludePackage.test(packageName);\n+        }\n+\n+        boolean includesType(String moduleName, String packageName, String typeName) {\n+            return includesPackage(moduleName, packageName) && includeType.test(typeName);\n+        }\n+\n+        boolean excludesType(String moduleName, String packageName, String typeName) {\n+            return excludesPackage(moduleName, packageName)\n+                    || includesPackage(moduleName, packageName) && excludeType.test(typeName);\n+        }\n+    }\n+\n+    final List<Entry> includes;\n+    final List<Entry> excludes;\n+\n+    \/**\n+     * Creates a selector based upon a series of \"includes\" and \"excludes\" options.\n+     *\n+     * @param includes the list of patterns describing the elements to be included\n+     * @param excludes the list of patterns describing the elements to be excluded\n+     *\/\n+    public Selector(List<String> includes, List<String> excludes) {\n+        this.includes = includes.stream().map(Entry::new).collect(Collectors.toList());\n+        this.excludes = excludes.stream().map(Entry::new).collect(Collectors.toList());\n+    }\n+\n+    \/**\n+     * Returns whether a module is selected, according to the configured options.\n+     *\n+     * @param name the module name\n+     * @return {@code true} if the module is selected\n+     *\/\n+    public boolean acceptsModule(String name) {\n+        return (includes.isEmpty() || includes.stream().anyMatch(e -> e.includesModule(name)))\n+                && excludes.stream().noneMatch(e -> e.excludesModule(name));\n+    }\n+\n+    \/**\n+     * Returns whether a package is selected, according to the configured options.\n+     *\n+     * @param moduleName the name of the module enclosing the package\n+     * @param packageName the package name\n+     * @return {@code true} if the package is selected\n+     *\/\n+    public boolean acceptsPackage(String moduleName, String packageName) {\n+        return (includes.isEmpty() || includes.stream().anyMatch(e -> e.includesPackage(moduleName, packageName)))\n+                && excludes.stream().noneMatch(e -> e.excludesPackage(moduleName, packageName));\n+    }\n+\n+    \/**\n+     * Returns whether a top-level type is selected, according to the configured options.\n+     *\n+     * @param moduleName the name of the module enclosing the type\n+     * @param packageName the name of the package enclosing the type\n+     * @param typeName the simple name of the type\n+     * @return {@code true} if the type is selected\n+     *\/\n+    public boolean acceptsType(String moduleName, String packageName, String typeName) {\n+        return (includes.isEmpty() || includes.stream().anyMatch(e -> e.includesType(moduleName, packageName, typeName)))\n+                && excludes.stream().noneMatch(e -> e.excludesType(moduleName, packageName, typeName));\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/Selector.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.List;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Name;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+\/**\n+ * A \"serialized form\" is a container for the constants, fields and methods\n+ * of a class related to Java object serialization, as defined in the\n+ * \"Java Object Serialization Specification\".\n+ *\n+ * In the context of apidiff, it provides access to fields and methods\n+ * which were declared as private (and so not included in the primary\n+ * access-based selection) but which nevertheless may contribute to\n+ * the serialized form of a type element.  But, note that the actual\n+ * serialized form may be specified narratively by the {@code serialData}\n+ * tag on one of a number of serialization methods, or by a series of\n+ * {@code @serialField} tags on the {@code serialPersistentFields}\n+ * member of a serializable class.\n+ *\n+ * Finally, note that classes may of may not be included in the documentation\n+ * by using {@code @serial include | exclude} on the class or package\n+ * documentation.\n+ *\/\n+public class SerializedForm {\n+\n+    private final long serialVersionUID;\n+    private final List<Field> fields;\n+    private final List<ExecutableElement> methods;\n+    private final SerializedFormDocs docs;\n+\n+    SerializedForm(long serialVersionUID, List<Field> fields, List<ExecutableElement> methods,\n+            SerializedFormDocs docs) {\n+        this.serialVersionUID = serialVersionUID;\n+        this.fields = fields;\n+        this.methods = methods;\n+        this.docs = docs;\n+    }\n+\n+    \/**\n+     * Returns the serial version UID for the element.\n+     *\n+     * @return the serial version UID\n+     *\/\n+    public long getSerialVersionUID() {\n+        return serialVersionUID;\n+    }\n+\n+    \/**\n+     * Returns the list of fields in the serialized form.\n+     *\n+     * @return the list of fields in the serialized form.\n+     *\/\n+    public List<? extends Field> getFields() {\n+        return fields;\n+    }\n+\n+    public Field getField(CharSequence name) {\n+        return getFields().stream()\n+                .filter(f -> f.getName().contentEquals(name))\n+                .findFirst()\n+                .orElse(null);\n+    }\n+\n+    \/**\n+     * Returns the list of serialization methods.\n+     *\n+     * @return the list of serialization.\n+     *\/\n+    public List<? extends ExecutableElement> getMethods() {\n+        return methods;\n+    }\n+\n+    \/**\n+     * Returns the descriptions for the items in the serialized form.\n+     *\n+     * @return the descriptions\n+     *\/\n+    public SerializedFormDocs getDocs() {\n+        return docs;\n+    }\n+\n+    \/**\n+     * A serialized field.\n+     *\n+     * Instances are created by information in the {@code @serialField} tags of the\n+     * {@code serialPersistentFields} member, or from the default set of serializable fields.\n+     *\/\n+    public interface Field {\n+        \/**\n+         * Returns the type element enclosing this field.\n+         *\n+         * @return the type element\n+         *\/\n+        TypeElement getEnclosingTypeElement();\n+\n+        \/**\n+         * Returns the name of the field.\n+         *\n+         * @return the name of the field\n+         *\/\n+        Name getName();\n+\n+        \/**\n+         * Returns the type of the field, or a type with of kind {@code NONE} if the type\n+         * could not be determined. The value may have kind {@code} if the field is\n+         * described by information in a {@code @serialField} tag, and the type specification\n+         * could not be resolved.\n+         *\n+         * Note: the use of {@code NONE} is non-standard in this context. It would be better\n+         * if the type were of kind {@code ERROR} if the signature cannot be resolved,\n+         * but that is not possible with the current API. {@code null} is not used because\n+         * that is generally used to mean \"missing\" instead of \"error\".\n+         *\n+         * @return the type of the field, or a type of kind {@code NONE}.\n+         *\/\n+        TypeMirror getType();\n+\n+        \/**\n+         * Returns the documentation comment of the field.\n+         *\n+         * If the field is described by information in a {@code @serialField} tag,\n+         * the comment is taken from that tag.\n+         * If the field is a default serializable field, the comment is the\n+         * full comment of that field.\n+         *\n+         * @return the documentation comment of the field.\n+         *\/\n+        List<? extends DocTree> getDocComment();\n+\n+        \/**\n+         * Returns the signature of the type of the field.\n+         * The signature is always available, even if {@link #getType()} returns a\n+         * type of kind {@code NONE}.\n+         *\n+         * If the field is described by information in a {@code @serialField} tag,\n+         * the signature is as found in that tag.\n+         * If the field is a default serializable field, the signature is the\n+         * result of {@code getType().toString()}.\n+         *\n+         * @return the type signature of the field\n+         *\/\n+        String getSignature();\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/SerializedForm.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.codetools.apidiff.Options;\n+import jdk.codetools.apidiff.model.Position.RelativePosition;\n+import jdk.codetools.apidiff.report.Reporter;\n+\n+\/**\n+ * A comparator for {@link SerializedForm serialized forms}.\n+ *\/\n+public class SerializedFormComparator {\n+    \/** The APIs to be compared. *\/\n+    protected final Set<API> apis;\n+    \/** The command-line options. *\/\n+    protected final Options options;\n+    \/** The reporter to which to report any differences. *\/\n+    protected final Reporter reporter;\n+\n+    \/**\n+     * Creates a comparator to compare the serialized forms for an element across a set of APIs.\n+     *\n+     * @param apis     the set of APIs\n+     * @param options  the command-line options\n+     * @param reporter the reporter to which to report differences\n+     *\/\n+    public SerializedFormComparator(Set<API> apis, Options options, Reporter reporter) {\n+        this.apis = apis;\n+        this.options = options;\n+        this.reporter = reporter;\n+    }\n+\n+    \/**\n+     * Compares the serialized forms for a type element found at the given position in different APIs.\n+     *\n+     * @param sfPos the position for the serialized form\n+     * @param forms the map giving the serialized forms in the different APIs\n+     *\n+     * @return {@code true} if all the elements are equal\n+     *\/\n+    public boolean compare(Position sfPos, APIMap<SerializedForm> forms) {\n+        if (forms.isEmpty()) {\n+            return true;\n+        }\n+\n+        boolean allEqual = false;\n+        reporter.comparing(sfPos, forms);\n+        try {\n+            allEqual = checkMissing(sfPos, forms);\n+            \/\/if (forms.size() > 1) {\n+                allEqual &= compareSerialVersionUIDs(sfPos, forms);\n+                allEqual &= compareSerializationOverviews(sfPos, forms);\n+                allEqual &= compareSerializedFields(sfPos, forms);\n+                allEqual &= compareSerializationMethods(sfPos, forms);\n+            \/\/}\n+        } finally {\n+            reporter.completed(sfPos, allEqual);\n+        }\n+        return allEqual;\n+    }\n+\n+    private boolean checkMissing(Position pos, Map<API, ?> map) {\n+        Set<API> missing = apis.stream()\n+                .filter(a -> !map.containsKey(a))\n+                .collect(Collectors.toSet()); \/\/ warning: unordered\n+\n+        if (missing.isEmpty()) {\n+            return true;\n+        } else {\n+            reporter.reportMissing(pos, missing);\n+            return false;\n+        }\n+    }\n+\n+    private boolean compareSerialVersionUIDs(Position sfPos, APIMap<SerializedForm> fMap) {\n+        \/\/ Just direct comparison of long values, explicit or default;\n+        \/\/ there is no doc comment, but there may be an item in the serialized-form.html file\n+        Position uPos = sfPos.serialVersionUID();\n+        APIMap<Long> uMap = APIMap.of();\n+        fMap.forEach((api, sf) -> uMap.put(api, sf.getSerialVersionUID()));\n+\n+        boolean allEqual = false;\n+        reporter.comparing(uPos, uMap);\n+        try {\n+            allEqual = checkMissing(uPos, uMap);\n+            if (fMap.size() > 1) {\n+                long archetype = uMap.values().iterator().next();\n+                boolean eq = uMap.values().stream()\n+                        .allMatch(u -> u == archetype);\n+                if (!eq) {\n+                    reporter.reportDifferentValues(uPos, uMap);\n+                }\n+                allEqual &= eq;\n+            }\n+            allEqual &= compareDescriptions(uPos, fMap, SerializedFormDocs::getSerialVersionUID);\n+        } finally {\n+            reporter.completed(uPos, allEqual);\n+        }\n+        return allEqual;\n+    }\n+\n+    private boolean compareSerializationOverviews(Position sfPos, APIMap<SerializedForm> fMap) {\n+        Position oPos = sfPos.serializationOverview();\n+\n+        boolean allEqual = false;\n+        reporter.comparing(oPos, fMap);\n+        try {\n+            \/\/ there no derivative map other than the map of descriptions created in compareDescriptions\n+            allEqual = compareDescriptions(oPos, fMap, SerializedFormDocs::getOverview);\n+        } finally {\n+            reporter.completed(oPos, allEqual);\n+        }\n+        return allEqual;\n+    }\n+\n+    private boolean compareDescriptions(Position pos, APIMap<SerializedForm> fMap,\n+                                        Function<SerializedFormDocs, String> f) {\n+        APIMap<String> descriptions = fMap.map((api, sf) -> {\n+            SerializedFormDocs docs = sf.getDocs();\n+            return (docs == null) ? null : f.apply(docs);\n+        });\n+\n+        \/\/ Descriptions are equal if none of the serialized forms has a description,\n+        \/\/ or if they all have the same description.\n+        \/\/ TODO: checkMissing?\n+        boolean allEqual = descriptions.isEmpty()\n+                || descriptions.size() == fMap.size() && descriptions.values().stream().distinct().count() == 1;\n+        if (!allEqual) {\n+            reporter.reportDifferentApiDescriptions(pos, descriptions);\n+        }\n+        return allEqual;\n+    }\n+\n+    private boolean compareSerializedFields(Position sfPos, APIMap<SerializedForm> forms) {\n+        Map<String, APIMap<SerializedForm.Field>> fieldsMap = new TreeMap<>();\n+        forms.forEach((api, sf) -> {\n+            for (SerializedForm.Field f : sf.getFields()) {\n+                fieldsMap.computeIfAbsent(f.getName().toString(), __ -> APIMap.of()).put(api, f);\n+            }\n+        });\n+\n+        boolean allEqual = true;\n+        for (Map.Entry<String, APIMap<SerializedForm.Field>> e : fieldsMap.entrySet()) {\n+            String name = e.getKey();\n+            APIMap<SerializedForm.Field> fMap = e.getValue();\n+            boolean equal = compare(sfPos, name, fMap);\n+            allEqual &= equal;\n+        }\n+        return allEqual;\n+    }\n+\n+    private boolean compare(Position sfPos, String name, APIMap<SerializedForm.Field> fMap) {\n+        RelativePosition<String> fPos = sfPos.serializedField(name);\n+        boolean allEqual = false;\n+        reporter.comparing(fPos, fMap);\n+        try {\n+            allEqual = checkMissing(fPos, fMap);\n+            if (fMap.size() > 1) {\n+                allEqual &= compareSignatures(fPos, fMap);\n+                allEqual &= compareDocComments(fPos, fMap);\n+                allEqual &= compareSerializedFieldDescriptions(fPos, fMap);\n+            }\n+        } finally {\n+            reporter.completed(fPos, allEqual);\n+        }\n+        return allEqual;\n+\n+    }\n+\n+    private boolean compareSignatures(Position fPos, APIMap<SerializedForm.Field> fMap) {\n+        \/\/ If any field being compared has type of NONE, the field's type could not be resolved.\n+        \/\/ (Ideally, the representation would use ERROR instead of NONE, but that is not possible.)\n+        \/\/ Treat all such instances are automatically different to anything else.\n+        APIMap<TypeMirror> tMap = APIMap.of();\n+        fMap.forEach((api, f) -> tMap.put(api, f.getType()));\n+        if (fMap.values().stream().anyMatch(f -> f.getType().getKind() == TypeKind.NONE)) {\n+            reporter.reportDifferentTypes(fPos, tMap);\n+            return false;\n+        } else {\n+            TypeMirrorComparator tmc = new TypeMirrorComparator(fMap.keySet(), reporter);\n+            return tmc.compare(fPos, tMap);\n+        }\n+    }\n+\n+    private boolean compareDocComments(Position fPos, APIMap<SerializedForm.Field> fMap) {\n+        APIMap<String> rawDocComments = APIMap.of();\n+        for (Map.Entry<API, SerializedForm.Field> entry : fMap.entrySet()) {\n+            API api = entry.getKey();\n+            SerializedForm.Field f = entry.getValue();\n+            String c = getDocComment(f);\n+            if (c != null) {\n+                rawDocComments.put(api, c);\n+            }\n+        }\n+        \/\/ raw doc comments are equal if none of the elements has a doc comment,\n+        \/\/ or if they all have the same doc comment.\n+        \/\/ TODO: checkMissing?\n+        boolean allEqual = rawDocComments.isEmpty()\n+                || rawDocComments.size() == fMap.size() && rawDocComments.values().stream().distinct().count() == 1;\n+        if (!allEqual) {\n+            reporter.reportDifferentRawDocComments(fPos, rawDocComments);\n+        }\n+        return allEqual;\n+    }\n+\n+    private String getDocComment(SerializedForm.Field f) {\n+        List<? extends DocTree> trees = f.getDocComment();\n+        if (trees == null) {\n+            return null;\n+        }\n+        return trees.stream().map(Object::toString).collect(Collectors.joining());\n+    }\n+\n+    private boolean compareSerializedFieldDescriptions(Position fPos, APIMap<SerializedForm.Field> fMap) {\n+        APIMap<String> descriptions = fMap.map((api, f) -> {\n+            SerializedForm form = api.getSerializedForm(f.getEnclosingTypeElement());\n+            if (form == null) return null;\n+            SerializedFormDocs docs = form.getDocs();\n+            if (docs == null) return null;\n+            return docs.getFieldDescription(f.getName().toString());\n+        });\n+\n+        \/\/ Descriptions are equal if none of the fields has a description,\n+        \/\/ or if they all have the same description.\n+        \/\/ TODO: checkMissing?\n+        boolean allEqual = descriptions.isEmpty()\n+                || descriptions.size() == fMap.size() && descriptions.values().stream().distinct().count() == 1;\n+        if (!allEqual) {\n+            reporter.reportDifferentApiDescriptions(fPos, descriptions);\n+        }\n+        return allEqual;\n+    }\n+\n+    private boolean compareSerializationMethods(Position sfPos, APIMap<SerializedForm> forms) {\n+        Map<RelativePosition<String>, APIMap<ExecutableElement>> mMap = new TreeMap<>(RelativePosition.stringIndexComparator);\n+        forms.forEach((api, sf) -> {\n+            for (ExecutableElement m : sf.getMethods()) {\n+                RelativePosition<String> mPos = sfPos.serializationMethod(m.getSimpleName().toString());\n+                mMap.computeIfAbsent(mPos, p -> APIMap.of()).put(api, m);\n+            }\n+        });\n+\n+        ExecutableComparator ec = new ExecutableComparator(apis, options, reporter) {\n+            \/**\n+             * Returns the API description found in the serialized-form.html file.\n+             *\/\n+            @Override\n+            protected String getApiDescription(API api, Element e) {\n+                SerializedFormDocs docs = forms.get(api).getDocs();\n+                return docs == null ? null : docs.getMethodDescription(e.getSimpleName().toString());\n+            }\n+        };\n+\n+        boolean allEqual = true;\n+        for (Map.Entry<RelativePosition<String>, APIMap<ExecutableElement>> entry : mMap.entrySet()) {\n+            allEqual &= ec.compare(entry.getKey(), entry.getValue());\n+        }\n+        return allEqual;\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/SerializedFormComparator.java","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import jdk.codetools.apidiff.Log;\n+\n+\/**\n+ * A class containing the descriptions for the serialized form of a type,\n+ * as found in the appropriate file generated by javadoc.\n+ *\/\n+public class SerializedFormDocs {\n+    private final String serialVersionUID;\n+    private final String overview;\n+    private final Map<String, String> fields;\n+    private final Map<String, String> methods;\n+\n+    \/**\n+     * Reads a file generated by javadoc, and extracts the descriptions for\n+     * the serialized forms of the types contained therein.\n+     *\n+     * <p>If the file does not exist, an empty map will be returned.\n+     *\n+     * @param log  a log to which any errors will be reported\n+     * @param file the file to be read\n+     *\n+     * @return an instance of {@code APIDocs} that contains the descriptions\n+     *      found in the file.\n+     *\/\n+    public static Map<String, SerializedFormDocs> read(Log log, Path file) {\n+        if (Files.exists(file)) {\n+            SerializedFormReader r = new SerializedFormReader(log);\n+            r.read(file);\n+            return r.getSerializedFormDocs();\n+        } else {\n+            return Collections.emptyMap();\n+        }\n+    }\n+\n+    \/**\n+     * Creates an instance of {@code SerializedFormDocs}.\n+     *\n+     * @param serialVersionUID the serial version UID, or {@code null}\n+     * @param overview         the overview, or {@code null}\n+     * @param fields           the collection of descriptions for the serialized fields\n+     * @param methods          the collection of descriptions for the serialization methods\n+     *\/\n+    SerializedFormDocs(String serialVersionUID, String overview,\n+                   Map<String, String> fields, Map<String, String> methods) {\n+        this.serialVersionUID = serialVersionUID;\n+        this.overview = overview;\n+        this.fields = fields;\n+        this.methods = methods;\n+    }\n+\n+    \/**\n+     * Returns the serial version UID for the type, or {@code null} if not known.\n+     *\n+     * @return the serial version UID\n+     *\/\n+    public String getSerialVersionUID() {\n+        return serialVersionUID;\n+    }\n+\n+    \/**\n+     * Returns the serialization overview for the type, or {@code null} if not given.\n+     * The overview comes from the documentation comment for the\n+     * {@code serialPersistentFields} member.\n+     *\n+     * @return the serialization overview\n+     *\/\n+    public String getOverview() {\n+        return overview;\n+    }\n+\n+    \/**\n+     * Returns a map containing the descriptions of all the serialized fields\n+     * for this type that were found in the file.\n+     *\n+     * @return a map of descriptions, indexed by the name of the field\n+     *\/\n+    public Map<String, String> getFieldDescriptions() { return fields; }\n+\n+    \/**\n+     * Returns the description for a serialized field, or {@code null} if not found.\n+     *\n+     * @param name the name of the field\n+     *\n+     * @return the description\n+     *\/\n+    public String getFieldDescription(String name) {\n+        return fields.get(name);\n+    }\n+\n+    \/**\n+     * Returns a map containing the descriptions of all the serialization methods\n+     * for this type that were found in the file.\n+     *\n+     * @return a map of descriptions, indexed by the name of the method\n+     *\/\n+    public Map<String, String> getMethodDescriptions() { return methods; }\n+\n+    \/**\n+     * Returns the description for a serialization method, or {@code null} if not found.\n+     * No serialization methods are overloaded, and so it is not necessary to include\n+     * the list of parameter types.\n+     *\n+     * @param name the name of the method\n+     *\n+     * @return the description\n+     *\/\n+    public String getMethodDescription(String name) {\n+        return methods.get(name);\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/SerializedFormDocs.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,959 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.Name;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.ArrayType;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.ExecutableType;\n+import javax.lang.model.type.NoType;\n+import javax.lang.model.type.PrimitiveType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.type.TypeVariable;\n+import javax.lang.model.type.TypeVisitor;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import javax.lang.model.util.SimpleTypeVisitor14;\n+import javax.lang.model.util.Types;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.ReferenceTree;\n+import com.sun.source.doctree.SerialFieldTree;\n+import com.sun.source.doctree.SerialTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.DocTreePath;\n+import com.sun.source.util.DocTreePathScanner;\n+import com.sun.source.util.DocTrees;\n+import com.sun.source.util.TreePath;\n+\n+\/**\n+ * A factory to create the {@link SerializedForm} object for a\n+ * type element if appropriate.\n+ *\n+ * A serialized form is only created for a type element if\n+ * it is {@code Serializable} but not an enum, and if it\n+ * is marked with {@code @serial include}, or the enclosing\n+ * package is not marked with {@code serial exclude} and\n+ * the type is {@code public} or {@code protected}.\n+ *\/\n+public class SerializedFormFactory {\n+\n+    private final Map<PackageElement, Boolean> excludedPackages;\n+\n+    private final Elements elements;\n+    private final Types types;\n+    private final DocTrees trees;\n+\n+    private final TypeMirror serializable;\n+    private final TypeMirror externalizable;\n+    private final TypeMirror objectInput;\n+    private final TypeMirror objectInputStream;\n+    private final TypeMirror objectOutput;\n+    private final TypeMirror objectOutputStream;\n+    private final TypeMirror objectStreamField;\n+\n+    private final Name readExternal;\n+    private final Name writeExternal;\n+    private final Name readObject;\n+    private final Name readObjectNoData;\n+    private final Name writeObject;\n+    private final Name readResolve;\n+    private final Name writeReplace;\n+    private final Name serialPersistentFields;\n+    private final Name serialVersionUID;\n+\n+    private Set<Modifier> privateStaticFinal = Set.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL);\n+\n+    \/**\n+     * Creates an instance of {@code SerializedFormFactory} using the utility objects for\n+     * {@code Elements}, {@code Types} and {@code Trees} available from an API.\n+     *\n+     * @param api the API\n+     *\/\n+    public SerializedFormFactory(API api) {\n+        this(api.getElements(), api.getTypes(), api.getTrees());\n+    }\n+\n+    \/**\n+     * Creates an instance of {@code SerializedFormFactory} using the given utility objects.\n+     *\n+     * @param elements the {@code Elements} utility class to be used\n+     * @param types    the {@code Types} utility class to be used\n+     * @param trees    the {@code DocTrees} utility class to be used\n+     *\/\n+    public SerializedFormFactory(Elements elements, Types types, DocTrees trees) {\n+        this.elements = elements;\n+        this.types = types;\n+        this.trees = trees;\n+\n+        excludedPackages = new HashMap<>();\n+\n+        ModuleElement javaBase = elements.getModuleElement(\"java.base\");\n+\n+        serializable            = getType(javaBase, \"java.io.Serializable\");\n+        externalizable          = getType(javaBase, \"java.io.Externalizable\");\n+        objectInput             = getType(javaBase, \"java.io.ObjectInput\");\n+        objectInputStream       = getType(javaBase, \"java.io.ObjectInputStream\");\n+        objectOutput            = getType(javaBase, \"java.io.ObjectOutput\");\n+        objectOutputStream      = getType(javaBase, \"java.io.ObjectOutputStream\");\n+        objectStreamField       = getType(javaBase, \"java.io.ObjectStreamField\");\n+\n+        readExternal            = elements.getName(\"readExternal\");\n+        writeExternal           = elements.getName(\"writeExternal\");\n+        readObject              = elements.getName(\"readObject\");\n+        readObjectNoData        = elements.getName(\"readObjectNoData\");\n+        writeObject             = elements.getName(\"writeObject\");\n+        readResolve             = elements.getName(\"readResolve\");\n+        writeReplace            = elements.getName(\"writeReplace\");\n+        serialPersistentFields  = elements.getName(\"serialPersistentFields\");\n+        serialVersionUID        = elements.getName(\"serialVersionUID\");\n+    }\n+\n+    \/**\n+     * Returns the instance of {@code SerializedFormDocs} containing the information\n+     * related to a given type element, or {@code null} if no such information is available.\n+     *\n+     * This implementation returns {@code null}.\n+     *\n+     * @param te the type element\n+     *\n+     * @return the instance of {@code SerializedFormDocs} containing the information\n+     *\/\n+    public SerializedFormDocs getSerializedFormDocs(TypeElement te) {\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns a type of an element with a given canonical name, as seen from the given module.\n+     *\n+     * @param me   the module\n+     * @param name the name\n+     *\n+     * @return the type of the element\n+     *\/\n+    private TypeMirror getType(ModuleElement me, String name) {\n+        return elements.getTypeElement(me, name).asType();\n+    }\n+\n+    \/**\n+     * Returns the {@code SerializedForm} object for a type element, or null if it does not have one.\n+     *\n+     * @param te the type element\n+     *\n+     * @return the {@code SerializedForm} object\n+     *\/\n+    public SerializedForm get(TypeElement te) {\n+        if (!isIncluded(te)) {\n+            return null;\n+        }\n+\n+        long serialVersionUID = getSerialVersionUID(te);\n+\n+        List<SerializedForm.Field> fields;\n+        List<ExecutableElement> methods;\n+\n+        if (types.isAssignable(te.asType(), externalizable)) {\n+            fields = List.of();\n+            methods = getExternalizableMethods(te);\n+        } else {\n+            fields = getSerializableFields(te);\n+            methods = getSerializableMethods(te);\n+        }\n+\n+        SerializedFormDocs docs = getSerializedFormDocs(te);\n+\n+        return new SerializedForm(serialVersionUID, fields, methods, docs);\n+    }\n+\n+    \/\/<editor-fold desc=\"Inclusion\">\n+\n+    \/**\n+     * Determines if a type element has a specific serialized form.\n+     *\n+     * A type element has a specific serialized form if\n+     * it is {@code Serializable} but not an enum, and if it\n+     * is marked with {@code @serial include}, or the enclosing\n+     * package is not marked with {@code serial exclude} and\n+     * the type is {@code public} or {@code protected}.\n+     *\n+     * @param te the type element\n+     *\n+     * @return {@code true} if and only if the type element has a specific\n+     * serialized form\n+     *\/\n+    private boolean isIncluded(TypeElement te) {\n+        if (te.getKind() == ElementKind.ENUM\n+                || !types.isAssignable(te.asType(), serializable)) {\n+            return false;\n+        }\n+\n+        Optional<SerialTree> serialTrees = getSerialTrees(te);\n+        if (matches(serialTrees, \"include\")) {\n+            return true;\n+        }\n+\n+        if (matches(serialTrees, \"exclude\")\n+            || excludedPackages.computeIfAbsent(elements.getPackageOf(te),\n+                p -> matches(getSerialTrees(p), \"exclude\"))) {\n+            return false;\n+        }\n+\n+        Set<Modifier> modifiers = te.getModifiers();\n+        return modifiers.contains(Modifier.PUBLIC)\n+                || modifiers.contains(Modifier.PROTECTED);\n+    }\n+\n+    \/**\n+     * Returns whether an optional {@code SerialTree} object matches the given kind.\n+     * The kind is typically \"include\" or \"exclude\".\n+     *\n+     * @param optSerial the optional {@code SerialTree}\n+     * @param kind      the kind\n+     *\n+     * @return {@code true} if and only if a match is found\n+     *\/\n+    private boolean matches(Optional<SerialTree> optSerial, String kind) {\n+        return optSerial.isPresent() && optSerial.get().getDescription().toString().equals(kind);\n+    }\n+\n+    \/**\n+     * Returns the {@code {@serial ...}} tag, if any, in the doc comment for an element.\n+     *\n+     * @param e the element\n+     *\n+     * @return the tag\n+     *\/\n+    private Optional<SerialTree> getSerialTrees(Element e) {\n+        DocCommentTree dct = trees.getDocCommentTree(e);\n+        if (dct == null) {\n+            return Optional.empty();\n+        }\n+\n+        return dct.getBlockTags().stream()\n+                .filter(t -> t.getKind() == DocTree.Kind.SERIAL)\n+                .map(t -> (SerialTree) t)\n+                .findFirst();\n+    }\n+\n+    \/\/<\/editor-fold>\n+\n+    \/\/<editor-fold desc=\"Serial Version UID\">\n+\n+    \/**\n+     * Returns the {@code serialVersionUID} for a type element.\n+     * If the type element defines an appropriate field, the constant value\n+     * of the field is returned; otherwise, the default value is computed.\n+     *\n+     * @param te the type element\n+     *\n+     * @return the serial version UID\n+     *\/\n+    private long getSerialVersionUID(TypeElement te) {\n+        VariableElement ve = te.getEnclosedElements().stream()\n+                .filter(e -> e.getKind() == ElementKind.FIELD\n+                        && e.getSimpleName() == serialVersionUID)\n+                .map(e -> (VariableElement) e)\n+                .findFirst()\n+                .orElse(null);\n+\n+        if (ve != null\n+                && ve.getModifiers().contains(Modifier.STATIC)\n+                && ve.getModifiers().contains(Modifier.FINAL)\n+                && types.isSameType(ve.asType(), types.getPrimitiveType(TypeKind.LONG))) {\n+            Object o = ve.getConstantValue();\n+            if (o instanceof Long) {\n+                return (Long) o;\n+            }\n+        }\n+\n+        return computeDefaultSUID(te);\n+    }\n+\n+    \/**\n+     * Computes the default serial version UID value for the given class.\n+     *\n+     * This code is translated from the corresponding code in {@code java.io.ObjectStreamClass},\n+     * converting it from using runtime reflection to compile-time reflection.\n+     *\/\n+    private long computeDefaultSUID(TypeElement te) {\n+        try {\n+            ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+            DataOutputStream dout = new DataOutputStream(bout);\n+\n+            dout.writeUTF(te.getQualifiedName().toString());\n+\n+            int classMods = IntModifier.getModifiers(te) &\n+                    (IntModifier.PUBLIC | IntModifier.FINAL |\n+                            IntModifier.INTERFACE | IntModifier.ABSTRACT);\n+\n+            \/*\n+             * compensate for javac bug in which ABSTRACT bit was set for an\n+             * interface only if the interface declared methods\n+             *\/\n+            List<ExecutableElement> methods = ElementFilter.methodsIn(te.getEnclosedElements());\n+            if ((classMods & IntModifier.INTERFACE) != 0) {\n+                classMods = (methods.size() > 0) ?\n+                        (classMods | IntModifier.ABSTRACT) :\n+                        (classMods & ~IntModifier.ABSTRACT);\n+            }\n+            dout.writeInt(classMods);\n+\n+            if (te.asType().getKind() != TypeKind.ARRAY) {\n+                \/*\n+                 * compensate for change in 1.2FCS in which\n+                 * Class.getInterfaces() was modified to return Cloneable and\n+                 * Serializable for array classes.\n+                 *\/\n+                List<? extends TypeMirror> interfaces = te.getInterfaces();\n+                List<String> ifaceNames = interfaces.stream()\n+                        .map(SerializedFormFactory::getInterfaceName)\n+                        .sorted()\n+                        .collect(Collectors.toList());\n+                for (String n : ifaceNames) {\n+                    dout.writeUTF(n);\n+                }\n+            }\n+\n+            List<? extends VariableElement> fields = ElementFilter.fieldsIn(te.getEnclosedElements());\n+            List<MemberSignature> fieldSigs = fields.stream()\n+                    .map(MemberSignature::new)\n+                    .sorted(Comparator.comparing(ms -> ms.name))\n+                    .collect(Collectors.toList());\n+            for (MemberSignature sig : fieldSigs) {\n+                int mods = IntModifier.getModifiers(sig.member) &\n+                        (IntModifier.PUBLIC | IntModifier.PRIVATE | IntModifier.PROTECTED |\n+                                IntModifier.STATIC | IntModifier.FINAL | IntModifier.VOLATILE |\n+                                IntModifier.TRANSIENT);\n+                if (((mods & IntModifier.PRIVATE) == 0) ||\n+                        ((mods & (IntModifier.STATIC | IntModifier.TRANSIENT)) == 0))\n+                {\n+                    dout.writeUTF(sig.name);\n+                    dout.writeInt(mods);\n+                    dout.writeUTF(sig.signature);\n+                }\n+            }\n+\n+            if (hasStaticInitializer(te)) {\n+                dout.writeUTF(\"<clinit>\");\n+                dout.writeInt(IntModifier.STATIC);\n+                dout.writeUTF(\"()V\");\n+            }\n+\n+            List<? extends ExecutableElement> cons = ElementFilter.constructorsIn(te.getEnclosedElements());\n+            List<MemberSignature> consSigs = cons.stream()\n+                    .map(MemberSignature::new)\n+                    .sorted(Comparator.comparing(ms -> ms.signature))\n+                    .collect(Collectors.toList());\n+            for (MemberSignature sig : consSigs) {\n+                int mods = IntModifier.getModifiers(sig.member) &\n+                        (IntModifier.PUBLIC | IntModifier.PRIVATE | IntModifier.PROTECTED |\n+                                IntModifier.STATIC | IntModifier.FINAL |\n+                                IntModifier.SYNCHRONIZED | IntModifier.NATIVE |\n+                                IntModifier.ABSTRACT | IntModifier.STRICT);\n+                if ((mods & IntModifier.PRIVATE) == 0) {\n+                    dout.writeUTF(\"<init>\");\n+                    dout.writeInt(mods);\n+                    dout.writeUTF(sig.signature.replace('\/', '.'));\n+                }\n+            }\n+\n+            List<MemberSignature> methSigs = methods.stream()\n+                    .map(MemberSignature::new)\n+                    .sorted(Comparator.comparing((MemberSignature ms) -> ms.name)\n+                            .thenComparing(ms -> ms.signature))\n+                    .collect(Collectors.toList());\n+            for (MemberSignature sig : methSigs) {\n+                int mods = IntModifier.getModifiers(sig.member) &\n+                        (IntModifier.PUBLIC | IntModifier.PRIVATE | IntModifier.PROTECTED |\n+                                IntModifier.STATIC | IntModifier.FINAL |\n+                                IntModifier.SYNCHRONIZED | IntModifier.NATIVE |\n+                                IntModifier.ABSTRACT | IntModifier.STRICT);\n+                if ((mods & IntModifier.PRIVATE) == 0) {\n+                    dout.writeUTF(sig.name);\n+                    dout.writeInt(mods);\n+                    dout.writeUTF(sig.signature.replace('\/', '.'));\n+                }\n+            }\n+\n+            dout.flush();\n+\n+            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n+            byte[] hashBytes = md.digest(bout.toByteArray());\n+            long hash = 0;\n+            for (int i = Math.min(hashBytes.length, 8) - 1; i >= 0; i--) {\n+                hash = (hash << 8) | (hashBytes[i] & 0xFF);\n+            }\n+            return hash;\n+        } catch (IOException ex) {\n+            throw new InternalError(ex);\n+        } catch (NoSuchAlgorithmException ex) {\n+            throw new InternalError(ex.getMessage());\n+        }\n+    }\n+\n+    \/**\n+     * Returns the fully qualified name for a type mirror representing an interface,\n+     * such as found in the superinterfaces of a class.\n+     *\n+     * @param t the type mirror\n+     *\n+     * @return the name\n+     *\/\n+    private static String getInterfaceName(TypeMirror t) {\n+        Element e = ((DeclaredType) t).asElement();\n+        return ((TypeElement) e).getQualifiedName().toString();\n+    }\n+\n+    \/**\n+     * Returns whether a type element has, or will have, a static initializer.\n+     * A type has a static initializer if it has an executable member named {@code <clinit>}.\n+     * This may arise due to explicit presence of {@code static { ... }} in source code,\n+     * or to hold the initialization of static fields with a non-constant value.\n+     *\n+     * @param te the type element\n+     *\n+     * @return if the type element has or will have a static initializer\n+     *\/\n+    private boolean hasStaticInitializer(TypeElement te) {\n+        if (te.getEnclosedElements().stream().anyMatch(e -> e.getKind() == ElementKind.STATIC_INIT)) {\n+            return true;\n+        }\n+\n+        \/\/ if the source is available, scan the AST for the element, looking for\n+        \/\/ either 'static { ... }' or static variables with non-constant initializers\n+        TreePath p = trees.getPath(te);\n+        if (p != null && p.getLeaf() instanceof ClassTree) {\n+            ClassTree ct = (ClassTree) p.getLeaf();\n+            for (Tree t : ct.getMembers()) {\n+                switch (t.getKind()) {\n+                    case BLOCK -> {\n+                        BlockTree bt = (BlockTree) t;\n+                        if (bt.isStatic()) {\n+                            \/\/ found an explicit static initializer block\n+                            return true;\n+                        }\n+                    }\n+                    case VARIABLE -> {\n+                        VariableTree vt = (VariableTree) t;\n+                        if (vt.getModifiers().getFlags().contains(Modifier.STATIC)\n+                                && vt.getInitializer() != null) {\n+                            Element e = trees.getElement(new TreePath(p, vt));\n+                            if (e != null && e.getKind() == ElementKind.FIELD) {\n+                                Object cv = ((VariableElement) e).getConstantValue();\n+                                if (cv == null) {\n+                                    \/\/ found field with an initializer that is not a constant\n+                                    \/\/ expression, and so will require an implicit static initializer block\n+                                    return true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * A wrapper around runtime modifiers.\n+     * These are distinct from {@link javax.lang.model.element.Modifier},\n+     * and while they are similar, there is not a direct one-to-one correspondence.\n+     * For example, {@code javax.lang.model} models interfaces differently,\n+     * and runtime reflection has not explicit value equivalent for DEFAULT.\n+     *\n+     * Note, the spec for the computing the default serialVersionUID is defined\n+     * in terms of the runtime kind of modifiers.\n+     *\/\n+    private static class IntModifier {\n+\n+        static final int ABSTRACT       = java.lang.reflect.Modifier.ABSTRACT;\n+        static final int FINAL          = java.lang.reflect.Modifier.FINAL;\n+        static final int INTERFACE      = java.lang.reflect.Modifier.INTERFACE;\n+        static final int NATIVE         = java.lang.reflect.Modifier.NATIVE;\n+        static final int PRIVATE        = java.lang.reflect.Modifier.PRIVATE;\n+        static final int PROTECTED      = java.lang.reflect.Modifier.PROTECTED;\n+        static final int PUBLIC         = java.lang.reflect.Modifier.PUBLIC;\n+        static final int STATIC         = java.lang.reflect.Modifier.STATIC;\n+        static final int STRICT         = java.lang.reflect.Modifier.STRICT;\n+        static final int SYNCHRONIZED   = java.lang.reflect.Modifier.SYNCHRONIZED;\n+        static final int TRANSIENT      = java.lang.reflect.Modifier.TRANSIENT;\n+        static final int VOLATILE       = java.lang.reflect.Modifier.VOLATILE;\n+\n+        static int getModifiers(Element e) {\n+            int mods = 0;\n+            for (Modifier m : e.getModifiers()) {\n+                switch (m) {\n+                    case ABSTRACT:      mods |= ABSTRACT;       break;\n+                    case DEFAULT:       \/* no equivalent *\/     break;\n+                    case FINAL:         mods |= FINAL;          break;\n+                    case NATIVE:        mods |= NATIVE;         break;\n+                    case PRIVATE:       mods |= PRIVATE;        break;\n+                    case PROTECTED:     mods |= PROTECTED;      break;\n+                    case PUBLIC:        mods |= PUBLIC;         break;\n+                    case STATIC:        mods |= STATIC;         break;\n+                    case STRICTFP:      mods |= STRICT;         break;\n+                    case SYNCHRONIZED:  mods |= SYNCHRONIZED;   break;\n+                    case TRANSIENT:     mods |= TRANSIENT;      break;\n+                    case VOLATILE:      mods |= VOLATILE;       break;\n+                }\n+            }\n+\n+            if (e.getKind().isInterface()) {\n+                mods |= INTERFACE;\n+            }\n+\n+            return mods;\n+        }\n+    }\n+\n+    \/**\n+     * A simple container for a field or executable member of a type element,\n+     * providing the information that will be used to computer the default serialVersionUID.\n+     *\/\n+    private static class MemberSignature {\n+        String name;\n+        Element member;\n+        String signature;\n+\n+        MemberSignature(Element ve) {\n+            name = ve.getSimpleName().toString();\n+            member = ve;\n+            signature = descriptorVisitor.visit(ve.asType(), new StringBuilder()).toString();\n+        }\n+    }\n+\n+    \/**\n+     * A visitor to compute the signature (descriptor) for members of a type element.\n+     *\/\n+    private static TypeVisitor<StringBuilder,StringBuilder> descriptorVisitor = new SimpleTypeVisitor14<>() {\n+        @Override\n+        public StringBuilder defaultAction(TypeMirror t, StringBuilder sb) {\n+            throw new Error(t.getKind() + \": \" + t.toString());\n+        }\n+\n+        @Override\n+        public StringBuilder visitArray(ArrayType t, StringBuilder sb) {\n+            sb.append(\"[\");\n+            return t.getComponentType().accept(this, sb);\n+        }\n+\n+        @Override\n+        public StringBuilder visitDeclared(DeclaredType t, StringBuilder sb) {\n+            return sb.append(\"L\")\n+                    .append(((TypeElement) t.asElement()).getQualifiedName().toString().replace(\".\", \"\/\"))\n+                    .append(\";\");\n+        }\n+\n+        @Override\n+        public StringBuilder visitExecutable(ExecutableType t, StringBuilder sb) {\n+            sb.append('(');\n+            for (TypeMirror p : t.getParameterTypes()) {\n+                p.accept(this, sb);\n+            }\n+            sb.append(')');\n+            return t.getReturnType().accept(this, sb);\n+        }\n+\n+        @Override\n+        public StringBuilder visitTypeVariable(TypeVariable t, StringBuilder sb) {\n+            return sb.append(\"Ljava\/lang\/Object;\"); \/\/ TODO: use bounds? types.erasure(t).accept(this, sb) ?\n+        }\n+\n+        @Override\n+        public StringBuilder visitNoType(NoType t, StringBuilder sb) {\n+\n+            if (t.getKind() != TypeKind.VOID) {\n+                throw new IllegalArgumentException((t.toString()));\n+            }\n+            return sb.append('V');\n+        }\n+\n+        @Override\n+        public StringBuilder visitPrimitive(PrimitiveType t, StringBuilder sb) {\n+            char ch = switch (t.getKind()) {\n+                case BYTE -> 'B';\n+                case CHAR -> 'C';\n+                case DOUBLE -> 'D';\n+                case FLOAT -> 'F';\n+                case INT -> 'I';\n+                case LONG -> 'L';\n+                case SHORT -> 'S';\n+                case BOOLEAN -> 'Z';\n+                default -> throw new IllegalArgumentException(t.toString());\n+            };\n+            return sb.append(ch);\n+        }\n+    };\n+\n+    \/\/<\/editor-fold>\n+\n+    \/\/<editor-fold desc=\"Serialized Methods\">\n+\n+    \/**\n+     * Returns the list of methods related to the serialization in a type element\n+     * that is externalizable.\n+     *\n+     * The list includes: {@code readExternal}, {@code writeExternal}, {@code readResolve}\n+     * and {@code writeReplace}.\n+     *\n+     * @param te the type element\n+     *\n+     * @return the list\n+     *\/\n+    private List<ExecutableElement> getExternalizableMethods(TypeElement te) {\n+        return getMethods(te, ee ->\n+                   isMethod(ee, readExternal, objectInput)\n+                || isMethod(ee, writeExternal, objectOutput)\n+                || isMethod(ee, readResolve)\n+                || isMethod(ee, writeReplace));\n+    }\n+\n+    \/**\n+     * Returns the list of methods related to the serialization in a type element\n+     * that is serializable (but not externalizable).\n+     *\n+     * The list includes: {@code readObject}, {@code readObjectNoData}, {@code writeObject},\n+     * {@code readResolve} and {@code writeReplace}.\n+     *\n+     * @param te the type element\n+     *\n+     * @return the list\n+     *\/\n+    private List<ExecutableElement> getSerializableMethods(TypeElement te) {\n+        return getMethods(te, ee ->\n+                   isMethod(ee, readObject, objectInputStream)\n+                || isMethod(ee, readObjectNoData)\n+                || isMethod(ee, writeObject, objectOutputStream)\n+                || isMethod(ee, readResolve)\n+                || isMethod(ee, writeReplace));\n+    }\n+\n+    \/**\n+     * Returns the list of methods in a type element that match a given predicate.\n+     *\n+     * @param te     the type element\n+     * @param filter the predicate\n+     *\n+     * @return the list\n+     *\/\n+    private List<ExecutableElement> getMethods(TypeElement te, Predicate<ExecutableElement> filter) {\n+        Map<Name, ExecutableElement> map = new HashMap<>();\n+        for (Element e : elements.getAllMembers(te)) {\n+            if (e.getKind() != ElementKind.METHOD) {\n+                continue;\n+            }\n+\n+            ExecutableElement ee = (ExecutableElement) e;\n+            if (filter.test(ee)) {\n+                ExecutableElement prev = map.get(ee.getSimpleName());\n+                if (prev == null || elements.overrides(ee, prev, te)) {\n+                    map.put(ee.getSimpleName(), ee);\n+                }\n+            }\n+        }\n+        List<ExecutableElement> list = new ArrayList<>(map.values());\n+        list.sort((e1, e2) -> CharSequence.compare(e1.getSimpleName(), e2.getSimpleName()));\n+        return list;\n+    }\n+\n+    \/**\n+     * Returns whether an executable element has a given name and no parameters.\n+     *\n+     * @param ee   the element\n+     * @param name the name\n+     *\n+     * @return true if the element has the given name and no parameters\n+     *\/\n+    private boolean isMethod(ExecutableElement ee, Name name) {\n+        return ee.getSimpleName() == name\n+                && ee.getParameters().isEmpty();\n+    }\n+\n+    \/**\n+     * Returns whether an executable element has a given name and a single parameter\n+     * of a given type.\n+     *\n+     * @param ee    the element\n+     * @param name  the name\n+     * @param param the parameter type\n+     *\n+     * @return true if the element has the given name and no parameters\n+     *\/\n+    private boolean isMethod(ExecutableElement ee, Name name, TypeMirror param) {\n+        return ee.getSimpleName() == name\n+                && ee.getParameters().size() == 1\n+                && types.isSameType(ee.getParameters().get(0).asType(), param);\n+    }\n+    \/\/<\/editor-fold>\n+\n+    \/\/<editor-fold desc=\"Serialized Fields\">\n+\n+    \/**\n+     * Returns the list of fields related to the serialization in a type element\n+     * that is serializable (but not externalizable).\n+     *\n+     * The list contains the default set of fields to be serialized.\n+     * This set is determined from the {@code @serialField} tags on the {@code persistentSerialFields}\n+     * (if defined), or the list of non-static non-transient fields declared\n+     * in the type element.\n+     *\n+     * The list also contains the fields for {@code serialVersionUID} and {@code persistentSerialFields},\n+     * if present. They can be distinguished from the default set of fields to be serialized\n+     * by name and by being declared to be {@code static}.\n+     *\n+     *\n+     * @param  te the type element\n+     *\n+     * @return the list of fields in the serialized form\n+     *\/\n+    private List<SerializedForm.Field> getSerializableFields(TypeElement te) {\n+        List<SerializedForm.Field> list = new ArrayList<>();\n+\n+        VariableElement spf = te.getEnclosedElements().stream()\n+                .filter(e -> e.getKind() == ElementKind.FIELD)\n+                .map(e -> (VariableElement) e)\n+                .filter(this::isSerialPersistentFields)\n+                .findFirst()\n+                .orElse(null);\n+\n+        if (spf != null) {\n+            DocCommentTree dct = trees.getDocCommentTree(spf);\n+            if (dct != null) {\n+                DocTreePathScanner<Void,List<SerializedForm.Field>> scanner = new DocTreePathScanner<>() {\n+                    @Override\n+                    public Void visitSerialField(SerialFieldTree tree, List<SerializedForm.Field> list) {\n+                        list.add(new DocumentedField(te, getCurrentPath()));\n+                        return null;\n+                    }\n+                };\n+                scanner.scan(new DocTreePath(trees.getPath(te), dct), list);\n+            }\n+        } else {\n+            for (VariableElement ve : ElementFilter.fieldsIn(te.getEnclosedElements())) {\n+                Set<Modifier> modifiers = ve.getModifiers();\n+                if (modifiers.contains(Modifier.STATIC) || modifiers.contains(Modifier.TRANSIENT)) {\n+                    continue;\n+                }\n+                list.add(new VariableElementField(ve));\n+            }\n+        }\n+\n+        return list;\n+    }\n+\n+    \/**\n+     * Returns whether a field is a valid declaration of {@code serialPersistentFields}.\n+     *\n+     * @param ve the field\n+     *\n+     * @return {@code true} if and only if this is a valid declaration of {@code serialPersistentFields}\n+     *\/\n+    private boolean isSerialPersistentFields(VariableElement ve) {\n+        return ve.getSimpleName() == serialPersistentFields\n+                && ve.getModifiers().equals(privateStaticFinal)\n+                && types.isSameType(ve.asType(), types.getArrayType(objectStreamField));\n+    }\n+\n+    \/**\n+     * Details for a field in a serialized form, that is derived from information\n+     * in {@code @serialField} tags on the {@code serialPersistentFields} field.\n+     *\/\n+    private class DocumentedField implements SerializedForm.Field {\n+        private final TypeElement enclosingTypeElement;\n+        private final Name name;\n+        private final TypeMirror type;\n+        private final List<? extends DocTree> description;\n+        private final String signature;\n+\n+        DocumentedField(TypeElement te, DocTreePath p) {\n+            enclosingTypeElement = te;\n+            DocTree t = p.getLeaf();\n+            if (t.getKind() != DocTree.Kind.SERIAL_FIELD) {\n+                throw new IllegalArgumentException(t.getKind().toString());\n+            }\n+            SerialFieldTree sft = (SerialFieldTree) t;\n+            name = sft.getName().getName();\n+            type = getType(p, sft.getType());\n+            description = sft.getDescription();\n+            signature = sft.getType().toString();\n+        }\n+\n+        @Override\n+        public TypeElement getEnclosingTypeElement() {\n+            return enclosingTypeElement;\n+        }\n+\n+        \/**\n+         * Returns the type for the signature found in a {@code @serialField} tag,\n+         * or a type of kind {@code NONE} if the type cannot be resolved.\n+         *\n+         * Note: it would be better if it was possible to use a type of kind ERROR\n+         * instead of NONE, but that cannot be done with the current API.\n+         *\n+         * javac does not directly support array signatures, so count and remove\n+         * the trailing '[]' characters, look up the base type, and then convert\n+         * to the appropriate number of levels of array.\n+         *\n+         * @param serialFieldPath the path for {@code serialField} tag\n+         * @param refTree           the reference tree within the {@code serialField} tag\n+         *\n+         * @return the type\n+         *\/\n+        private TypeMirror getType(DocTreePath serialFieldPath, ReferenceTree refTree) {\n+\n+            String sig = refTree.getSignature();\n+            int dims = 0;\n+            int index = sig.length();\n+            while (index > 2) {\n+                if (sig.charAt(index - 2) == '[' && sig.charAt(index - 1) == ']') {\n+                    dims++;\n+                    index -= 2;\n+                } else {\n+                    break;\n+                }\n+            }\n+\n+            String baseSig = sig.substring(0, index);\n+            TypeMirror t;\n+            switch (baseSig) {\n+                case \"boolean\" -> t = types.getPrimitiveType(TypeKind.BOOLEAN);\n+                case \"byte\" -> t = types.getPrimitiveType(TypeKind.BYTE);\n+                case \"char\" -> t = types.getPrimitiveType(TypeKind.CHAR);\n+                case \"double\" -> t = types.getPrimitiveType(TypeKind.DOUBLE);\n+                case \"float\" -> t = types.getPrimitiveType(TypeKind.FLOAT);\n+                case \"int\" -> t = types.getPrimitiveType(TypeKind.INT);\n+                case \"long\" -> t = types.getPrimitiveType(TypeKind.LONG);\n+                case \"short\" -> t = types.getPrimitiveType(TypeKind.SHORT);\n+                case \"void\" -> t = types.getPrimitiveType(TypeKind.VOID);\n+                default -> {\n+                    DocTreePath refPath = new DocTreePath(serialFieldPath,\n+                            dims == 0 ? refTree : trees.getDocTreeFactory().newReferenceTree(baseSig));\n+                    Element e = trees.getElement(refPath);\n+                    if (e == null) {\n+                        \/\/ ideally, we would be able to use an instance of an ERROR type,\n+                        \/\/ but that is not available in the API, so use NONE as a marker value instead.\n+                        return types.getNoType(TypeKind.NONE);\n+                    }\n+                    t = e.asType();\n+                }\n+            }\n+\n+            while (dims > 0) {\n+                t = types.getArrayType(t);\n+                dims--;\n+            }\n+\n+            return t;\n+        }\n+\n+        @Override\n+        public Name getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public TypeMirror getType() {\n+            return type;\n+        }\n+\n+        @Override\n+        public List<? extends DocTree> getDocComment() {\n+            return description;\n+        }\n+\n+        @Override\n+        public String getSignature() {\n+            return signature;\n+        }\n+    }\n+\n+    \/**\n+     * Details for a field in a serialized form, that is derived from a field\n+     * in the type element.\n+     *\/\n+    private class VariableElementField implements SerializedForm.Field {\n+        VariableElement ve;\n+\n+        VariableElementField(VariableElement ve) {\n+            this.ve = ve;\n+        }\n+\n+        @Override\n+        public TypeElement getEnclosingTypeElement() {\n+            return (TypeElement) ve.getEnclosingElement();\n+        }\n+\n+        @Override\n+        public Name getName() {\n+            return ve.getSimpleName();\n+        }\n+\n+        @Override\n+        public TypeMirror getType() {\n+            return ve.asType();\n+        }\n+\n+        @Override\n+        public List<? extends DocTree> getDocComment() {\n+            DocCommentTree dct = trees.getDocCommentTree(ve);\n+            return dct == null ? null : List.of(dct);\n+        }\n+\n+        @Override\n+        public String getSignature() {\n+            return ve.asType().toString();\n+        }\n+    }\n+    \/\/<\/editor-fold>\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/SerializedFormFactory.java","additions":959,"deletions":0,"binary":false,"changes":959,"status":"added"},{"patch":"@@ -0,0 +1,432 @@\n+\/*\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.codetools.apidiff.Log;\n+\n+\/**\n+ * A reader that reads the descriptions for the serialized forms of types,\n+ * from the serialized-form.html file generated by javadoc.\n+ *\n+ * <p>The output generated by javadoc is not well-specified and varies across releases.\n+ * The following rules allow fuzzy parsing for at least JDK version 11 and later.\n+ *\n+ * <ul>\n+ * <li>The details for a type are introduced by a heading beginning \"Class name\".\n+ *\n+ * <li>The serialVersionUID is contained in a definition list:\n+ *     {@code <dt>serialVersionUID:<\/dt><dd>the-value<\/dd>}\n+ *\n+ * <li>The serialization overview is introduced by a heading \"Serialization Overview\".\n+ *     The description begins after the following {@code <li>} and ends at the\n+ *     corresponding {@code <\/li>}.\n+ *\n+ * <li>The serialized fields are introduced by a heading \"Serialized Fields\".\n+ *     The individual fields are introduced by headings containing the name of the field.\n+ *     The description of the field begins after the {@code <pre>} containing the\n+ *     signature, and ends before the enclosing {@code <\/li>}.\n+ *\n+ * <li>The serialization methods are introduced by a heading \"Serialization Methods\".\n+ *     The individual methods are introduced by headings containing the name of the method.\n+ *     The description of the method begins after the {@code <pre>} containing the\n+ *     signature, and ends before the enclosing {@code <\/li>}.\n+ * <\/ul>\n+ *\n+ * The descriptions for a type end when the heading for the next type is seen,\n+ * or when {@code <\/main>} is read.\n+ *\/\n+public class SerializedFormReader extends HtmlParser {\n+    private final Log log;\n+    private Map<String, SerializedFormDocs> allDocs;\n+\n+    \/**\n+     * Creates a reader.\n+     *\n+     * @param log a log to which to report any errors.\n+     *\/\n+    SerializedFormReader(Log log) {\n+        this.log = log;\n+    }\n+\n+    \/\/ TEMPORARY!\n+    boolean debug = false;\n+    private void debugPrintln(Supplier<String> s) {\n+        if (debug) {\n+            System.err.println(s.get());\n+        }\n+    }\n+\n+    @Override\n+    public void read(Path file) {\n+        allDocs = new LinkedHashMap<>();\n+        super.read(file);\n+    }\n+\n+    \/**\n+     * Returns the collection of descriptions found during a preceding call\n+     * of {@code read}.\n+     * The descriptions are indexed by the name of the corresponding type.\n+     *\n+     * @return the descriptions.\n+     *\/\n+    Map<String, SerializedFormDocs> getSerializedFormDocs() {\n+        return allDocs;\n+    }\n+\n+    @Override\n+    protected void error(Path file, int lineNumber, String message) {\n+        log.err.println(file + \":\" + lineNumber + \": \" + message);\n+    }\n+\n+    @Override\n+    protected void error(Path file, int lineNumber, Throwable t) {\n+        log.err.println(file + \":\" + lineNumber + \": \" + t);\n+    }\n+\n+    private StringBuilder contentBuffer;\n+    private boolean inMain;\n+    private int startElementIndex;\n+    private int startDescriptionIndex;\n+    private boolean inDescription;\n+    private boolean inMemberSignature;\n+    private int ulDepth;\n+\n+    \/**\n+     * An indication of the position of the parser.\n+     *\/\n+    private enum State {\n+        \/**\n+         * Before any types have been detected.\n+         * It transitions to {@code TYPE} when the heading for a type is found.\n+         *\/\n+        INIT,\n+        \/**\n+         * Within the details for a type, but not in any specific part of the type.\n+         * The state is entered when the heading for a type is found.\n+         *\/\n+        TYPE,\n+        \/**\n+         * Within the details for the serial version UID.\n+         * The state is entered when the heading for the {@code serialVersionUID} is found,\n+         * and reverts to {@code TYPE} when the description has been read.\n+         *\/\n+        SERIAL_VERSION_UID,\n+        \/**\n+         * Within the details for the serialization overview.\n+         * The state is entered when the heading for the serialization overview is found,\n+         * and reverts to {@code TYPE} when the description has been read.\n+         *\/\n+        OVERVIEW,\n+        \/**\n+         * Within the details for the serialized fields, but not in any specific field.\n+         * The state is entered when the heading for the serialized fields is found,\n+         * and will typically progress to progress to {@code FIELD}, {@code METHODS},\n+         * or {@code TYPE}, depending on which kind of heading is found.\n+         *\/\n+        FIELDS,\n+        \/**\n+         * Within the details for a specific serialized field.\n+         * The state is entered when the heading for a specific serialized field is found,\n+         * and reverts to {@code FIELDS} when the description has been read.\n+         *\/\n+        FIELD,\n+        \/**\n+         * Within the details for the serialization methods, but not in any specific method.\n+         * The state is entered when the heading for the serialization methods is found,\n+         * and will typically progress to {@code METHOD} or {@code TYPE}, depending on\n+         * which kind of heading is found. In practice,\n+         *\/\n+        METHODS,\n+        \/**\n+         * Within the details for a specific serialization method.\n+         * The state is entered when the heading for a specific serialization method is found,\n+         * and reverts to {@code METHODS} when the description has been read.\n+         *\/\n+        METHOD\n+    }\n+    private State state;\n+\n+    \/**\n+     * The name of the current type, determined by the heading beginning {@code Class <name>}.\n+     *\/\n+    private String currType;\n+\n+    \/**\n+     * The name of the current field or method.\n+     *\/\n+    private String currMember;\n+\n+    \/**\n+     * The serialVersionUID.\n+     *\/\n+    private String serialVersionUID;\n+\n+    \/**\n+     * The serialization overview.\n+     *\/\n+    private String overview;\n+\n+    \/**\n+     * The collection of descriptions for the serialized fields of the current type.\n+     *\/\n+    private Map<String, String> fieldDescriptions;\n+\n+    \/**\n+     * The collection of descriptions for the serialization methods of the current type.\n+     *\/\n+    private Map<String, String> methodDescriptions;\n+\n+    @Override\n+    protected void content(Supplier<String> content) {\n+        if (contentBuffer != null) {\n+            contentBuffer.append(content.get());\n+        }\n+    }\n+\n+    @Override\n+    protected void html() {\n+        startElementIndex = getBufferIndex() - 1;\n+        super.html();\n+    }\n+\n+    @Override\n+    protected void startElement(String name, Map<String, String> attrs, boolean selfClosing) {\n+        \/\/ skip everything not in the `<main>` element\n+        if (!inMain) {\n+            if (name.equals(\"main\")) {\n+                inMain = true;\n+                state = State.INIT;\n+            }\n+            return;\n+        }\n+\n+        debugPrintln(() -> \"    <\" + name + \" \" + attrs + \"> \" + state + \" \" + inDescription + \" \" + ulDepth);\n+\n+        switch (name) {\n+            case \"dt\":\n+            case \"dd\":\n+            case \"h2\": case \"h3\": case \"h4\": case \"h5\":\n+                if (!inDescription) {\n+                    contentBuffer = new StringBuilder();\n+                }\n+                break;\n+\n+            case \"div\":\n+                String cssClass = attrs.get(\"class\");\n+                if (cssClass != null && cssClass.matches(\"member(S|-s)ignature\")) {\n+                    inMemberSignature = true;\n+                }\n+                break;\n+\n+            case \"li\":\n+                if (state == State.OVERVIEW && !inDescription) {\n+                    debugPrintln(() -> \"start description for \" + state + \" after start \" + name);\n+                    inDescription = true;\n+                    startDescriptionIndex = getBufferIndex();\n+                    ulDepth = 0;\n+                }\n+                break;\n+\n+            case \"ul\":\n+                if (inDescription) {\n+                    ulDepth++;\n+                }\n+                break;\n+        }\n+    }\n+\n+    private final Pattern classPtn = Pattern.compile(\"(?i)(Class|Exception|Record)(\\\\s|&nbsp;)++(?<name>\\\\S+).*\");\n+\n+    @Override\n+    protected void endElement(String name) {\n+        \/\/ skip everything not in the `<main>` element\n+        if (!inMain) {\n+            return;\n+        }\n+\n+        debugPrintln(() -> \"    <\/\" + name + \"> \" + state + \" \" + inDescription + \" \" + ulDepth);\n+\n+        switch (name) {\n+            case \"dt\":\n+                if (!inDescription && contentBuffer.toString().equals(\"serialVersionUID:\")) {\n+                    state = State.SERIAL_VERSION_UID;\n+                }\n+                break;\n+\n+            case \"dd\":\n+                if (!inDescription && state == State.SERIAL_VERSION_UID) {\n+                    serialVersionUID = contentBuffer.toString();\n+                    state = State.TYPE;\n+                }\n+                break;\n+\n+            case \"h2\": case \"h3\": case \"h4\": case \"h5\":\n+                if (inDescription) {\n+                    break;\n+                }\n+\n+                String content = contentBuffer.toString();\n+                contentBuffer = null;\n+\n+                switch (content) {\n+                    case \"Serialized Fields\":\n+                        state = State.FIELDS;\n+                        break;\n+\n+                    case \"Serialization Methods\":\n+                        state = State.METHODS;\n+                        break;\n+\n+                    case \"Serialization Overview\":\n+                        state = State.OVERVIEW;\n+                        break;\n+\n+                    default:\n+                        if (ulDepth == 0) {\n+                            Matcher m = classPtn.matcher(content);\n+                            if (m.matches()) {\n+                                if (currType != null) {\n+                                    saveCurrentDocs();\n+                                }\n+                                debugPrintln(() -> \"START TYPE \" + m.group(\"name\"));\n+                                state = State.TYPE;\n+                                currType = m.group(1);\n+                                serialVersionUID = null;\n+                                overview = null;\n+                                fieldDescriptions = Collections.emptyMap();\n+                                methodDescriptions = Collections.emptyMap();\n+                            } else {\n+                                switch (state) {\n+                                    case FIELDS -> {\n+                                        debugPrintln(() -> \"START \" + state + \" \" + content);\n+                                        currMember = content;\n+                                        state = State.FIELD;\n+                                    }\n+                                    case METHODS -> {\n+                                        debugPrintln(() -> \"START \" + state + \" \" + content);\n+                                        currMember = content;\n+                                        state = State.METHOD;\n+                                    }\n+                                }\n+                            }\n+                        }\n+                }\n+                debugPrintln(() -> \"Finished heading \" + name + \" \" + state + \": \" + content);\n+                break;\n+\n+            case \"li\":\n+                if (inDescription && ulDepth == 0) {\n+                    String d = getTrimBufferString(startDescriptionIndex, startElementIndex);\n+                    switch (state) {\n+                        case FIELD -> {\n+                            fieldDescriptions = saveMember(fieldDescriptions, d);\n+                            state = State.FIELDS;\n+                        }\n+                        case METHOD -> {\n+                            methodDescriptions = saveMember(methodDescriptions, d);\n+                            state = State.METHODS;\n+                        }\n+                        case OVERVIEW -> {\n+                            overview = d;\n+                            state = State.TYPE;\n+                        }\n+                    }\n+                    debugPrintln(() -> \"end description \" + state + \" \" + currMember + \" \" + d);\n+                    inDescription = false;\n+                }\n+                break;\n+\n+            case \"main\":\n+                saveCurrentDocs();\n+                debugPrintln(() -> \"Docs for \" + allDocs.keySet());\n+                inMain = false;\n+                break;\n+\n+            case \"pre\":\n+                switch (state) {\n+                    case FIELD:\n+                    case METHOD:\n+                        if (!inDescription) {\n+                            debugPrintln(() -> \"start description for \" + state + \" after end \" + name);\n+                            inDescription = true;\n+                            startDescriptionIndex = getBufferIndex();\n+                            ulDepth = 0;\n+                        }\n+                }\n+                break;\n+\n+            case \"div\":\n+                if (inMemberSignature) {\n+                    debugPrintln(() -> \"start description for \" + state + \" after end \" + name);\n+                    inMemberSignature = false;\n+                    inDescription = true;\n+                    startDescriptionIndex = getBufferIndex();\n+                    ulDepth = 0;\n+                }\n+                break;\n+\n+            case \"ul\":\n+                if (inDescription) {\n+                    ulDepth--;\n+                }\n+                break;\n+        }\n+    }\n+\n+    private Map<String, String> saveMember(Map<String, String> descriptions, String d) {\n+        if (descriptions.isEmpty()) {\n+            \/\/ replace the shared empty map with an unshared mutable map\n+            descriptions = new HashMap<>();\n+        }\n+\n+        descriptions.put(currMember, d);\n+\n+        return descriptions;\n+    }\n+\n+    private void saveCurrentDocs() {\n+        if (currType != null) {\n+            if (debug) {\n+                debugPrintln(() -> \"SAVE type \" + currType);\n+                fieldDescriptions.forEach((f, d) -> debugPrintln(() -> \"SAVE field \" + f + \": \" + d));\n+                methodDescriptions.forEach((m, d) -> debugPrintln(() -> \"SAVE method \" + m + \": \" + d));\n+                debugPrintln(() -> \"SAVE overview \" + overview);\n+            }\n+            allDocs.put(currType,\n+                    new SerializedFormDocs(serialVersionUID, overview, fieldDescriptions, methodDescriptions));\n+            currType = null;\n+        }\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/SerializedFormReader.java","additions":432,"deletions":0,"binary":false,"changes":432,"status":"added"},{"patch":"@@ -0,0 +1,310 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import jdk.codetools.apidiff.Options;\n+import jdk.codetools.apidiff.report.Reporter;\n+\n+\/**\n+ * A comparator for {@link TypeElement type elements}: classes, interfaces, enums and annotation types.\n+ *\n+ * <p>The comparison includes:\n+ * <ul>\n+ *     <li>the \"signature\" of the type: its annotations, modifiers, kind, type parameters, supertypes\n+ *     <li>the documentation comment for the type\n+ *     <li>the selected members in the type\n+ * <\/ul>\n+ *\/\n+public class TypeComparator extends ElementComparator<TypeElement> {\n+\n+    private final ElementExtras elementExtras = ElementExtras.instance();\n+\n+    \/**\n+     * Creates a comparator to compare type elements across a set of APIs.\n+     *\n+     * @param apis the set of APIs\n+     * @param options the command-line options\n+     * @param reporter the reporter to which to report differences\n+     *\/\n+    public TypeComparator(Set<API> apis, Options options, Reporter reporter) {\n+        super(apis, options, reporter);\n+    }\n+\n+    \/**\n+     * Compare instances of a type element found at a given position in different APIs.\n+     *\n+     * @param tPos the position of the element\n+     * @param tMap the map giving the instance of the type element in different APIs\n+     * @return {@code true} if all the instances are equivalent\n+     *\/\n+    @Override\n+    public boolean compare(Position tPos, APIMap<TypeElement> tMap) {\n+        boolean allEqual = false;\n+        reporter.comparing(tPos, tMap);\n+        try {\n+            allEqual = checkMissing(tPos, tMap);\n+            if (tMap.size() > 1) {\n+                allEqual &= compareSignatures(tPos, tMap);\n+                allEqual &= compareDocComments(tPos, tMap);\n+                allEqual &= compareApiDescriptions(tPos, tMap);\n+                allEqual &= compareMembers(tPos, tMap);\n+                allEqual &= compareSerializedForms(tPos, tMap);\n+            }\n+        } finally {\n+            reporter.completed(tPos, allEqual);\n+        }\n+        return allEqual;\n+    }\n+\n+    private boolean compareSerializedForms(Position tPos, APIMap<TypeElement> tMap) {\n+        APIMap<SerializedForm> forms = APIMap.of();\n+        tMap.forEach((api, te) -> {\n+            SerializedForm sf = api.getSerializedForm(te);\n+            if (sf != null) {\n+                forms.put(api, sf);\n+            }\n+        });\n+\n+        if (forms.isEmpty()) {\n+            return true;\n+        } else {\n+            SerializedFormComparator sfc = new SerializedFormComparator(tMap.keySet(), options, reporter);\n+            return sfc.compare(tPos.serializedForm(), forms);\n+        }\n+    }\n+\n+    \/\/ TODO: in time, the members of a record type may include record components\n+    private boolean compareMembers(Position ePos, APIMap<TypeElement> tMap) {\n+        KeyTable<TypeElement> nestedTypes = new KeyTable<>();\n+        KeyTable<ExecutableElement> constructors = new KeyTable<>();\n+        KeyTable<ExecutableElement> methods = new KeyTable<>();\n+        KeyTable<VariableElement> enumConstants = new KeyTable<>();\n+        KeyTable<VariableElement> fields = new KeyTable<>();\n+        IntTable<\/*RecordComponent*\/Element> recordComponents = new IntTable<>();\n+\n+        for (Map.Entry<API, TypeElement> e : tMap.entrySet()) {\n+            API api = e.getKey();\n+            TypeElement te = e.getValue();\n+            for (Element member : te.getEnclosedElements()) {\n+                if (!accessKind.accepts(member)) {\n+                    continue;\n+                }\n+                ElementKey key = ElementKey.of(member);\n+                switch (member.getKind()) {\n+                    case ENUM, RECORD, CLASS, INTERFACE, ANNOTATION_TYPE ->\n+                        nestedTypes.put(key, api,  (TypeElement) member);\n+\n+                    case ENUM_CONSTANT ->\n+                        enumConstants.put(key, api, (VariableElement) member);\n+\n+                    case FIELD ->\n+                        fields.put(key, api, (VariableElement) member);\n+\n+                    case CONSTRUCTOR ->\n+                        constructors.put(key, api, (ExecutableElement) member);\n+\n+                    case METHOD ->\n+                        methods.put(key, api, (ExecutableElement) member);\n+\n+                    case RECORD_COMPONENT ->\n+                        recordComponents.add(api, (VariableElement) member);\n+\n+                    case STATIC_INIT, INSTANCE_INIT -> {\n+                        \/\/ expected but ignored, since it is never part of any API\n+                    }\n+\n+                    default -> throw new Error(\"unexpected element: \" + member.getKind() + \" \" + member);\n+                }\n+            }\n+        }\n+\n+        Set<API> tMapApis = tMap.keySet();\n+        TypeComparator tc = new TypeComparator(tMapApis, options, reporter); \/\/ can we use \"this\"?\n+        VariableComparator vc = new VariableComparator(tMapApis, options, reporter);\n+        ExecutableComparator ec = new ExecutableComparator(tMapApis, options, reporter);\n+        RecordComponentComparator rc = new RecordComponentComparator(tMapApis, options, reporter);\n+\n+        return tc.compareAll(nestedTypes)\n+                & rc.compareAll(ePos::recordComponent, recordComponents)\n+                & vc.compareAll(enumConstants)\n+                & vc.compareAll(fields)\n+                & ec.compareAll(constructors)\n+                & ec.compareAll(methods);\n+    }\n+\n+    \/\/ TODO: in time, the signature of a sealed type may include the sealed modifier\n+    \/\/       and its permits list; likewise the signature of a non-sealed subtype of\n+    \/\/       a sealed type may include the non-sealed modifier\n+    private boolean compareSignatures(Position tPos, APIMap<TypeElement> tMap) {\n+        return compareAnnotations(tPos, tMap)\n+                & compareModifiers(tPos, tMap)\n+                & compareKinds(tPos, tMap)\n+                & compareTypeParameters(tPos, tMap)\n+                & compareSuperclass(tPos, tMap)\n+                & compareInterfaces(tPos, tMap)\n+                & comparePermittedSubclasses(tPos, tMap);\n+    }\n+\n+    private boolean compareKinds(Position tPos, APIMap<TypeElement> tMap) {\n+        if (tMap.size() == 1)\n+            return true;\n+\n+        ElementKind baseline = null;\n+        for (TypeElement te : tMap.values()) {\n+            if (baseline == null) {\n+                baseline = te.getKind();\n+            } else if (te.getKind() != baseline) {\n+                reporter.reportDifferentKinds(tPos, tMap);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean compareTypeParameters(Position tPos, APIMap<TypeElement> tMap) {\n+        TypeParameterComparator tc = new TypeParameterComparator(tMap.keySet(), options, reporter);\n+        IntTable<TypeParameterElement> typarams = IntTable.of(tMap, TypeElement::getTypeParameters);\n+        return tc.compareAll(tPos, typarams);\n+    }\n+\n+    private boolean compareSuperclass(Position pos, APIMap<TypeElement> eMap) {\n+        TypeMirrorComparator tc = new TypeMirrorComparator(eMap.keySet(), reporter);\n+        APIMap<TypeMirror> sMap = eMap.map(TypeElement::getSuperclass);\n+        return tc.compare(pos.superclass(), sMap); \/\/ null-friendly comparison\n+    }\n+\n+    private boolean compareInterfaces(Position ePos, APIMap<TypeElement> tMap) {\n+        Map<ElementKey, APIMap<TypeMirror>> map = extractInterfaces(tMap);\n+\n+        \/\/ TODO: the following could be a variant of TypeMirrorComparator::compareAll\n+        \/\/       and shared with compareThrownTypes\n+        \/\/ compare the groups of superinterfaces\n+        Set<ElementKey> first = null;\n+        boolean allEqual = true;\n+        for (Map.Entry<ElementKey, APIMap<TypeMirror>> entry : map.entrySet()) {\n+            ElementKey ik = entry.getKey();\n+            APIMap<TypeMirror> iMap = entry.getValue();\n+            Position pos = ePos.superinterface(ik);\n+            if (iMap.size() < tMap.size()) {\n+                \/\/ Note: using reportDifferentTypes even if some of the superinterfaces are missing\n+                tMap.keySet().forEach(a -> iMap.putIfAbsent(a, null));\n+                reporter.reportDifferentTypes(pos, iMap);\n+                allEqual = false;\n+            } else {\n+                TypeMirrorComparator tmc = new TypeMirrorComparator(tMap.keySet(), reporter);\n+                allEqual = allEqual & tmc.compare(pos, iMap);\n+            }\n+        }\n+\n+        if (allEqual) {\n+            return true;\n+        } else {\n+            APIMap<List<? extends TypeMirror>> superinterfaces = APIMap.of();\n+            tMap.forEach((api, te) -> superinterfaces.put(api, te.getInterfaces()));\n+            reporter.reportDifferentSuperinterfaces(ePos, superinterfaces);\n+            return false;\n+        }\n+    }\n+\n+    \/\/ TODO: share with extractThrownTypes?\n+    private Map<ElementKey, APIMap<TypeMirror>> extractInterfaces(APIMap<TypeElement> tMap) {\n+        \/\/ The order in which superinterfaces may be listed is not significant,\n+        \/\/ so group the superinterfaces by their ElementKey.\n+        \/\/ Note that thrown types can be type variables, and even annotated\n+        Map<ElementKey, APIMap<TypeMirror>> map = new TreeMap<>();\n+        for (Map.Entry<API, TypeElement> entry : tMap.entrySet()) {\n+            API api = entry.getKey();\n+            TypeElement ee = entry.getValue();\n+            for (TypeMirror tm : ee.getInterfaces()) {\n+                Element e = api.getTypes().asElement(tm);\n+                map.computeIfAbsent(ElementKey.of(e), _k -> APIMap.of()).put(api, tm);\n+            }\n+        }\n+        return map;\n+    }\n+\n+    private boolean comparePermittedSubclasses(Position ePos, APIMap<TypeElement> tMap) {\n+        Map<ElementKey, APIMap<TypeMirror>> map = extractPermittedSubclasses(tMap);\n+\n+        \/\/ TODO: the following could be a variant of TypeMirrorComparator::compareAll\n+        \/\/       and shared with compareInterfaces, compareThrownTypes\n+        \/\/ compare the groups of permitted subtypes\n+        Set<ElementKey> first = null;\n+        boolean allEqual = true;\n+        for (Map.Entry<ElementKey, APIMap<TypeMirror>> entry : map.entrySet()) {\n+            ElementKey sk = entry.getKey();\n+            APIMap<TypeMirror> sMap = entry.getValue();\n+            Position pos = ePos.permittedSubclass(sk);\n+            if (sMap.size() < tMap.size()) {\n+                \/\/ Note: using reportDifferentTypes even if some of the permitted subtypes are missing\n+                tMap.keySet().forEach(a -> sMap.putIfAbsent(a, null)); \/\/ TODO: is null OK here?\n+                reporter.reportDifferentTypes(pos, sMap);\n+                allEqual = false;\n+            } else {\n+                TypeMirrorComparator tmc = new TypeMirrorComparator(tMap.keySet(), reporter);\n+                allEqual = allEqual & tmc.compare(pos, sMap);\n+            }\n+        }\n+\n+        if (allEqual) {\n+            return true;\n+        } else {\n+            APIMap<List<? extends TypeMirror>> subclasses = APIMap.of();\n+            tMap.forEach((api, te) -> subclasses.put(api, elementExtras.getPermittedSubclasses(te)));\n+            reporter.reportDifferentPermittedSubclasses(ePos, subclasses);\n+            return false;\n+        }\n+    }\n+\n+    \/\/ TODO: share with extractThrownTypes?\n+    private Map<ElementKey, APIMap<TypeMirror>> extractPermittedSubclasses(APIMap<TypeElement> tMap) {\n+        \/\/ The order in which permitted subtypes may be listed is not significant,\n+        \/\/ so group the permitted subtypes by their ElementKey.\n+        \/\/ Note that permitted subtypes can be type variables, and even annotated\n+        Map<ElementKey, APIMap<TypeMirror>> map = new TreeMap<>();\n+        for (Map.Entry<API, TypeElement> entry : tMap.entrySet()) {\n+            API api = entry.getKey();\n+            TypeElement ee = entry.getValue();\n+            for (TypeMirror tm : elementExtras.getPermittedSubclasses(ee)) {\n+                Element e = api.getTypes().asElement(tm);\n+                map.computeIfAbsent(ElementKey.of(e), _k -> APIMap.of()).put(api, tm);\n+            }\n+        }\n+        return map;\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/TypeComparator.java","additions":310,"deletions":0,"binary":false,"changes":310,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.type.ArrayType;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.NoType;\n+import javax.lang.model.type.PrimitiveType;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.type.TypeVariable;\n+import javax.lang.model.type.TypeVisitor;\n+import javax.lang.model.type.WildcardType;\n+import javax.lang.model.util.SimpleTypeVisitor14;\n+\n+import jdk.codetools.apidiff.report.Reporter;\n+\n+\/**\n+ * A comparator for {@link TypeMirror type mirrors}.\n+ *\n+ * Type mirrors often occur in collections, such as the superinterfaces of a type\n+ * or the set of checked exceptions that may be thrown by an executable element.\n+ *\n+ * <p>Type mirrors are compared according to their structure (\"deep equals\") down to\n+ * the level of element names, which are compared using {@link ElementKey#equals ElementKey.equals}.\n+ *\/\n+public class TypeMirrorComparator {\n+    private final Set<API> apis;\n+    private final Reporter reporter;\n+\n+    \/**\n+     * Creates a comparator to compare type mirrors across a set of APIs.\n+     *\n+     * @param apis the set of APIs\n+     * @param reporter the reporter to which to report differences\n+     *\/\n+    protected TypeMirrorComparator(Set<API> apis, Reporter reporter) {\n+        this.apis = apis;\n+        this.reporter = reporter;\n+    }\n+\n+    \/**\n+     * Compares all the series of type mirrors at a given position in an API.\n+     *\n+     * @param pos the position\n+     * @param table the table for the type mirrors at that position\n+     * @return {@code true} if all the type mirrors are equivalent\n+     *\/\n+    boolean compareAll(Function<Integer, Position> pos, IntTable<TypeMirror> table) {\n+        boolean allEqual = true;\n+        for (int i = 0; i < table.size(); i++) {\n+            \/\/ TODO: check size of table.entries(i) against api.size()\n+            allEqual &= compare(pos.apply(i), table.entries(i));\n+        }\n+        return allEqual;\n+    }\n+\n+    \/**\n+     * Compares all the series of type mirrors at a given position in an API.\n+     *\n+     * @param pos the position\n+     * @param table the table for the type mirrors for that element\n+     * @return {@code true} if all the type mirrors are equivalent\n+     *\/\n+    boolean compareAll(Function<ElementKey, Position> pos, KeyTable<TypeMirror> table) {\n+        boolean allEqual = true;\n+        for (Map.Entry<ElementKey, APIMap<TypeMirror>> entry : table.entries()) {\n+            ElementKey key = entry.getKey();\n+            APIMap<TypeMirror> map = entry.getValue();\n+            allEqual &= compare(pos.apply(key), map);\n+        }\n+        return allEqual;\n+    }\n+\n+    boolean compare(Position pos, APIMap<TypeMirror> map) {\n+        if (map.size() == 1)\n+            return true;\n+\n+        TypeMirror archetype = map.values().stream().filter(Objects::nonNull).findFirst().orElse(null);\n+        for (TypeMirror t : map.values()) {\n+            if (!equal(archetype, t)) {\n+                reporter.reportDifferentTypes(pos, map);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private static boolean equal(Element e1, Element e2) {\n+        return ElementKey.of(e1).equals(ElementKey.of(e2));\n+    }\n+\n+    private static boolean equal(TypeMirror t1, TypeMirror t2) {\n+        if (t1 == t2)\n+            return true;\n+        if (t1 == null || t2 == null)\n+            return false;\n+        if (t1.getKind() != t2.getKind())\n+            return false;\n+        \/\/ TODO: compare type annotations\n+        return equalVisitor.visit(t1, t2);\n+    }\n+\n+    private static boolean equal(List<? extends TypeMirror> l1, List<? extends TypeMirror> l2) {\n+        if (l1 == l2)\n+            return true;\n+        if (l1 == null || l2 == null)\n+            return false;\n+        if (l1.size() != l2.size())\n+            return false;\n+        Iterator<? extends TypeMirror> iter1 = l1.iterator();\n+        Iterator<? extends TypeMirror> iter2 = l2.iterator();\n+        while (iter1.hasNext() && iter2.hasNext()) {\n+            boolean eq = equal(iter1.next(), iter2.next());\n+            if (!eq) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    static TypeVisitor<Boolean,TypeMirror> equalVisitor = new SimpleTypeVisitor14<>() {\n+\n+        @Override\n+        public Boolean visitArray(ArrayType at1, TypeMirror t2) {\n+            ArrayType at2 = (ArrayType) t2;\n+            return equal(at1.getComponentType(), at2.getComponentType());\n+        }\n+\n+        @Override\n+        public Boolean visitDeclared(DeclaredType dt1, TypeMirror t2) {\n+            DeclaredType dt2 = (DeclaredType) t2;\n+            return equal(dt1.asElement(), dt2.asElement())\n+                    && equal(dt1.getTypeArguments(), dt2.getTypeArguments());\n+        }\n+\n+        @Override\n+        public Boolean visitNoType(NoType pt, TypeMirror t) {\n+            return true;\n+        }\n+\n+        @Override\n+        public Boolean visitPrimitive(PrimitiveType pt, TypeMirror t) {\n+            return true;\n+        }\n+\n+        @Override\n+        public Boolean visitTypeVariable(TypeVariable vt1, TypeMirror t2) {\n+            TypeVariable vt2 = (TypeVariable) t2;\n+            return equal(vt1.asElement(), vt2.asElement());\n+        }\n+\n+        @Override\n+        public Boolean visitWildcard(WildcardType wt1, TypeMirror t2) {\n+            WildcardType wt2 = (WildcardType) t2;\n+            return equal(wt1.getExtendsBound(), wt2.getExtendsBound())\n+                    && equal(wt1.getSuperBound(), wt2.getSuperBound());\n+        }\n+\n+        @Override\n+        public Boolean defaultAction(TypeMirror e, TypeMirror t) {\n+            throw new UnsupportedOperationException(e.getKind() + \" \" + e);\n+        }\n+    };\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/TypeMirrorComparator.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,477 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Name;\n+import javax.lang.model.type.ArrayType;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.PrimitiveType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.type.TypeVariable;\n+import javax.lang.model.type.TypeVisitor;\n+import javax.lang.model.type.WildcardType;\n+import javax.lang.model.util.SimpleTypeVisitor14;\n+\n+import jdk.codetools.apidiff.model.ElementKey.Cache;\n+\n+\/**\n+ * A wrapper for instances of type mirror that is independent of any API environment and\n+ * that can be used to associate corresponding type mirrors in different instances of an API.\n+ *\/\n+public abstract sealed class TypeMirrorKey implements Comparable<TypeMirrorKey> {\n+    static TypeVisitor<TypeMirrorKey,Void> factory = new SimpleTypeVisitor14<>() {\n+\n+        @Override\n+        public TypeMirrorKey visitArray(ArrayType t, Void _p) {\n+            return new ArrayTypeKey(t);\n+        }\n+\n+        @Override\n+        public TypeMirrorKey visitDeclared(DeclaredType t, Void _p) {\n+            return new DeclaredTypeKey(t);\n+        }\n+\n+        @Override\n+        public TypeMirrorKey visitPrimitive(PrimitiveType t, Void _p) {\n+            return new PrimitiveTypeKey(t);\n+        }\n+\n+        @Override\n+        public TypeMirrorKey visitTypeVariable(TypeVariable t, Void _p) {\n+            return new TypeVariableKey(t);\n+        }\n+\n+        @Override\n+        public TypeMirrorKey visitWildcard(WildcardType t, Void _p) {\n+            return new WildcardTypeKey(t);\n+        }\n+\n+        @Override\n+        public TypeMirrorKey defaultAction(TypeMirror e, Void _p) {\n+            throw new UnsupportedOperationException(e.getKind() + \" \" + e);\n+        }\n+    };\n+\n+    private static final Cache<TypeMirror, TypeMirrorKey> cache = new Cache<>(t -> factory.visit(t, null));\n+\n+    \/**\n+     * Returns a key for a type mirror.\n+     * @param t the type mirror\n+     * @return the key\n+     *\/\n+    public static TypeMirrorKey of(TypeMirror t) {\n+        return (t == null) ? null : cache.get(t);\n+    }\n+\n+    \/**\n+     * The kind of the type mirror used to create this key.\n+     *\/\n+    public final TypeKind kind;\n+\n+    TypeMirrorKey(TypeMirror t) {\n+        kind = t.getKind();\n+    }\n+\n+    \/**\n+     * Applies a visitor to this key.\n+     * @param v the visitor\n+     * @param p a visitor-specified parameter\n+     * @param <R> the type of the result\n+     * @param <P> the type of the parameter\n+     * @return a visitor-specified result\n+     *\/\n+    public abstract <R, P> R accept(Visitor<R,P> v, P p);\n+\n+    \/**\n+     * A visitor of type mirror keys, in the style of the visitor design pattern.\n+     * Classes implementing this interface are used to operate on a type mirror key\n+     * when the kind of key is unknown at compile time.\n+     * When a visitor is passed to a key's {@code accept} method,\n+     * the <code>visit<em>Xyz<\/em><\/code> method applicable to that key is invoked.\n+     *\n+     * @param <R> the return type of this visitor's methods.\n+     *              Use Void for visitors that do not need to return results.\n+     * @param <P> the type of the additional parameter to this visitor's methods.\n+     *              Use Void for visitors that do not need an additional parameter.\n+    *\/\n+    public interface Visitor<R,P> {\n+        \/**\n+         * Visits a key for an array type.\n+         * @param k the key to visit\n+         * @param p a visitor-specified parameter\n+         * @return a visitor-specified result\n+         *\/\n+        R visitArrayType(ArrayTypeKey k, P p);\n+\n+        \/**\n+         * Visits a key for a declared type.\n+         * @param k the key to visit\n+         * @param p a visitor-specified parameter\n+         * @return a visitor-specified result\n+         *\/\n+        R visitDeclaredType(DeclaredTypeKey k, P p);\n+\n+        \/**\n+         * Visits a key for a primitive type.\n+         * @param k the key to visit\n+         * @param p a visitor-specified parameter\n+         * @return a visitor-specified result\n+         *\/\n+        R visitPrimitiveType(PrimitiveTypeKey k, P p);\n+\n+        \/**\n+         * Visits a key for a type variable.\n+         * @param k the key to visit\n+         * @param p a visitor-specified parameter\n+         * @return a visitor-specified result\n+         *\/\n+        R visitTypeVariable(TypeVariableKey k, P p);\n+\n+        \/**\n+         * Visits a key for a wildcard type.\n+         * @param k the key to visit\n+         * @param p a visitor-specified parameter\n+         * @return a visitor-specified result\n+         *\/\n+        R visitWildcardType(WildcardTypeKey k, P p);\n+    }\n+\n+    \/**\n+     * A key for an array type.\n+     *\/\n+    public static final class ArrayTypeKey extends TypeMirrorKey {\n+        \/**\n+         * A key for the component type of the array.\n+         *\/\n+        public final TypeMirrorKey componentKey;\n+        private int hashCode;\n+\n+        ArrayTypeKey(ArrayType t) {\n+            super(t);\n+            componentKey = Objects.requireNonNull(TypeMirrorKey.of(t.getComponentType()));\n+        }\n+\n+        @Override\n+        public int compareTo(TypeMirrorKey other) {\n+            int ck = kind.compareTo(other.kind);\n+            return (ck != 0) ? ck : componentKey.compareTo(((ArrayTypeKey) other).componentKey);\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            } else if (other == null || other.getClass() != getClass()) {\n+                return false;\n+            } else {\n+                return componentKey.equals(((ArrayTypeKey) other).componentKey);\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            if (hashCode == 0) {\n+                hashCode = componentKey.hashCode();\n+            }\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"ArrayKey[\" + componentKey + \"]\";\n+        }\n+\n+        @Override\n+        public <R, P> R accept(Visitor<R, P> v, P p) {\n+            return v.visitArrayType(this, p);\n+        }\n+    }\n+\n+    \/**\n+     * A key for a declared type.\n+     *\/\n+    public static final class DeclaredTypeKey extends TypeMirrorKey {\n+        \/**\n+         * The key for the element corresponding to this type.\n+         *\/\n+        public final ElementKey elementKey;\n+        \/**\n+         * The keys for any type arguments.\n+         *\/\n+        public final List<TypeMirrorKey> typeArgKeys;\n+        private int hashCode;\n+\n+        DeclaredTypeKey(DeclaredType t) {\n+            super(t);\n+            elementKey = ElementKey.of(t.asElement());\n+            typeArgKeys = t.getTypeArguments().stream()\n+                    .map(TypeMirrorKey::of)\n+                    .collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public int compareTo(TypeMirrorKey other) {\n+            int ck = kind.compareTo(other.kind);\n+            if (ck != 0) {\n+                return ck;\n+            }\n+            DeclaredTypeKey otherKey = (DeclaredTypeKey) other;\n+            int ce = elementKey.compareTo(otherKey.elementKey);\n+            if (ce != 0) {\n+                return ce;\n+            }\n+            return ElementKey.compare(typeArgKeys, otherKey.typeArgKeys);\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            } else if (other == null || other.getClass() != getClass()) {\n+                return false;\n+            } else {\n+                DeclaredTypeKey otherKey = (DeclaredTypeKey) other;\n+                return elementKey.equals(otherKey.elementKey) && typeArgKeys.equals(otherKey.typeArgKeys);\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            if (hashCode == 0) {\n+                hashCode = kind.hashCode() * 37 + elementKey.hashCode() * 5 + typeArgKeys.hashCode();\n+            }\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String typeArgs = typeArgKeys.isEmpty() ? \"\"\n+                    : typeArgKeys.stream().map(Object::toString).collect(Collectors.joining(\",\", \"<\", \">\"));\n+            return \"DeclaredTypeKey[\" + elementKey + typeArgs + \"]\";\n+        }\n+\n+        @Override\n+        public <R, P> R accept(Visitor<R, P> v, P p) {\n+            return v.visitDeclaredType(this, p);\n+        }\n+    }\n+\n+    \/**\n+     * A key for a primitive type:\n+     * {@code boolean}, {@code byte}, {@code char}, {@code double},\n+     * {@code float}, {@code int}, {@code long}, {@code short}.\n+     *\n+     * The kind of primitive type is identified by the {@link TypeMirrorKey#kind kind}.\n+     *\/\n+    public static final class PrimitiveTypeKey extends TypeMirrorKey {\n+        PrimitiveTypeKey(PrimitiveType t) {\n+            super(t);\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            } else if (other == null || other.getClass() != getClass()) {\n+                return false;\n+            } else {\n+                return kind.equals(((PrimitiveTypeKey) other).kind);\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return kind.hashCode();\n+        }\n+\n+        @Override\n+        public int compareTo(TypeMirrorKey other) {\n+            \/\/ TODO: compare by group?\n+            return kind.compareTo(other.kind);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"PrimitiveTypeKey[\" + kind + \"]\";\n+        }\n+\n+        @Override\n+        public <R, P> R accept(Visitor<R, P> v, P p) {\n+            return v.visitPrimitiveType(this, p);\n+        }\n+    }\n+\n+    \/**\n+     * A key for a type variable.\n+     *\/\n+    public static final class TypeVariableKey extends TypeMirrorKey {\n+        \/**\n+         * The name of the type variable.\n+         *\/\n+        public final Name name; \/\/ TODO: should this be the ElementKey?\n+        private int hashCode;\n+\n+        TypeVariableKey(TypeVariable t) {\n+            super(t);\n+            this.name = t.asElement().getSimpleName();\n+        }\n+\n+        @Override\n+        public int compareTo(TypeMirrorKey other) {\n+            int ck = kind.compareTo(other.kind);\n+            return (ck != 0) ? ck : ElementKey.compare(name, ((TypeVariableKey) other).name);\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            } else if (other == null || other.getClass() != getClass()) {\n+                return false;\n+            } else {\n+                return name.equals(((TypeVariableKey) other).name);\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            if (hashCode == 0) {\n+                hashCode = ElementKey.hashCode(name);\n+            }\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"TypeVariableTypeMirrorKey[\" + name + \"]\";\n+        }\n+\n+        @Override\n+        public <R, P> R accept(Visitor<R, P> v, P p) {\n+            return v.visitTypeVariable(this, p);\n+        }\n+    }\n+\n+    \/**\n+     * A key for a wildcard type.\n+     *\/\n+    public static final class WildcardTypeKey extends TypeMirrorKey {\n+        \/**\n+         * A key for the {@code extends} bound, if any, or null.\n+         *\/\n+        public final TypeMirrorKey extendsBoundKey;\n+        \/**\n+         * A key for the {@code super} bound, if any, or null.\n+         *\/\n+        public final TypeMirrorKey superBoundKey;\n+        private int hashCode;\n+\n+        WildcardTypeKey(WildcardType t) {\n+            super(t);\n+            extendsBoundKey = TypeMirrorKey.of(t.getExtendsBound());\n+            superBoundKey = TypeMirrorKey.of(t.getSuperBound());\n+        }\n+\n+        @Override\n+        public int compareTo(TypeMirrorKey other) {\n+            int ck = kind.compareTo(other.kind);\n+            if (ck != 0) {\n+                return ck;\n+            }\n+            WildcardTypeKey otherWildcardTypeKey = (WildcardTypeKey) other;\n+            int ce = compare(extendsBoundKey, otherWildcardTypeKey.extendsBoundKey);\n+            if (ce != 0) {\n+                return ce;\n+            }\n+            return compare(superBoundKey, otherWildcardTypeKey.superBoundKey);\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            } else if (other == null || other.getClass() != getClass()) {\n+                return false;\n+            } else {\n+                WildcardTypeKey otherWildcardTypeKey = (WildcardTypeKey) other;\n+                return Objects.equals(extendsBoundKey, otherWildcardTypeKey.extendsBoundKey)\n+                        && Objects.equals(superBoundKey, otherWildcardTypeKey.superBoundKey);\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            if (hashCode == 0) {\n+                if (extendsBoundKey != null) {\n+                    hashCode = extendsBoundKey.hashCode();\n+                }\n+                if (superBoundKey != null) {\n+                    hashCode = hashCode * 37 + superBoundKey.hashCode();\n+                }\n+                return hashCode;\n+            }\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"WildcardTypeKey[\");\n+            String sep = \"\";\n+            if (extendsBoundKey != null) {\n+                sb.append(\"extends:\").append(extendsBoundKey);\n+                sep = \",\";\n+            }\n+            if (superBoundKey != null) {\n+                sb.append(sep).append(\"super:\").append(superBoundKey);\n+            }\n+            sb.append(\"]\");\n+            return sb.toString();\n+        }\n+\n+        @Override\n+        public <R, P> R accept(Visitor<R, P> v, P p) {\n+            return v.visitWildcardType(this, p);\n+        }\n+\n+        private static int compare(TypeMirrorKey k1, TypeMirrorKey k2) {\n+            if (k1 == null && k2 == null) {\n+                return 0;\n+            }\n+            if (k1 == null) {\n+                return -1;\n+            }\n+            if (k2 == null) {\n+                return 1;\n+            }\n+            return k1.compareTo(k2);\n+        }\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/TypeMirrorKey.java","additions":477,"deletions":0,"binary":false,"changes":477,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.Set;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import jdk.codetools.apidiff.Options;\n+import jdk.codetools.apidiff.report.Reporter;\n+\n+\/**\n+ * A comparator for {@link TypeParameterElement type parameters}.\n+ *\n+ * <p>Type parameters are declared in a list on the declaration of a type or\n+ * executable element. Type parameters in different APIs are associated\n+ * according to their position in the list (and not by their name).\n+ *\n+ * <p>The comparison includes:\n+ * <ul>\n+ *     <li>the name\n+ *     <li>any annotations\n+ *     <li>any bounds\n+ * <\/ul>\n+ *\n+ *\/\n+public class TypeParameterComparator extends ElementComparator<TypeParameterElement> {\n+    \/**\n+     * Creates an instance of a comparator for type parameters.\n+     *\n+     * @param apis     the APIs to be compared\n+     * @param options  the command-line options\n+     * @param reporter the reporter to which to report any differences.\n+     *\/\n+    public TypeParameterComparator(Set<API> apis, Options options, Reporter reporter) {\n+        super(apis, options, reporter);\n+    }\n+\n+    \/**\n+     * Compares all the type parameters for a given element in an API.\n+     *\n+     * @param ePos the position of the element\n+     * @param typarams the table for the type parameters for that element\n+     * @return {@code true} if all the type parameters are equivalent\n+     *\/\n+    public boolean compareAll(Position ePos, IntTable<TypeParameterElement> typarams) {\n+        return compareAll(ePos::typeParameter, typarams);\n+    }\n+\n+    \/**\n+     * Compare instances of a type parameter found at a given position in different APIs.\n+     *\n+     * @param pos the position of the type parameter\n+     * @param map the map giving the instance of the type parameter in different APIs\n+     * @return {@code true} if all the instances are equivalent\n+     *\/\n+    @Override\n+    public boolean compare(Position pos, APIMap<TypeParameterElement> map) {\n+        boolean allEquals = true;\n+\n+        if (map.size() < apis.size()) {\n+            reporter.reportDifferentTypeParameters(pos, map);\n+            allEquals = false;\n+        }\n+\n+        allEquals &= compareNames(pos, map)\n+                & compareBounds(pos, map)\n+                & new AnnotationComparator(map.keySet(), accessKind, reporter).compareAll(pos, map);\n+\n+        return allEquals;\n+    }\n+\n+    private boolean compareNames(Position pos, APIMap<TypeParameterElement> map) {\n+        CharSequence name = null;\n+        for (TypeParameterElement e : map.values()) {\n+            if (name == null) {\n+                name = e.getSimpleName();\n+            } else {\n+                if (!e.getSimpleName().contentEquals(name)) {\n+                    reporter.reportDifferentTypeParameters(pos, map);\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean compareBounds(Position pos, APIMap<TypeParameterElement> map) {\n+        IntTable<TypeMirror> bounds = IntTable.of(map, TypeParameterElement::getBounds);\n+        return new TypeMirrorComparator(apis, reporter).compareAll(pos::bound, bounds);\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/TypeParameterComparator.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.model;\n+\n+import java.util.Set;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import jdk.codetools.apidiff.Options;\n+import jdk.codetools.apidiff.report.Reporter;\n+\n+\/**\n+ * A comparator for {@link VariableElement variable elements}: fields, enum constants, and\n+ * parameters for executable elements.\n+ *\n+ * <p>The comparison includes:\n+ * <ul>\n+ *     <li>the \"signature\" of the element: its annotations, modifiers and type\n+ *     <li>the documentation comment for the element\n+ * <\/ul>\n+ *\/\n+public class VariableComparator extends ElementComparator<VariableElement> {\n+\n+    \/**\n+     * Creates a comparator to compare variable elements across a set of APIs.\n+     *\n+     * @param apis     the set of APIs\n+     * @param options  the command-line options\n+     * @param reporter the reporter to which to report differences\n+     *\/\n+    public VariableComparator(Set<API> apis, Options options, Reporter reporter) {\n+        super(apis, options, reporter);\n+    }\n+\n+    \/**\n+     * Compares instances of a variable element found in different APIs.\n+     *\n+     * @param vPos the position of the element\n+     * @param vMap the map giving the instance of the variable element in different APIs\n+     * @return {@code true} if all the instances are equivalent\n+     *\/\n+    \/\/ TODO: should the comparison include the names for parameters?\n+    \/\/       they're not significant in the binary API but may be important in the reflective API\n+    @Override\n+    public boolean compare(Position vPos, APIMap<VariableElement> vMap) {\n+        boolean allEqual = false;\n+        reporter.comparing(vPos, vMap);\n+        try {\n+            allEqual = checkMissing(vPos, vMap);\n+            if (vMap.size() > 1) {\n+                allEqual &= compareSignatures(vPos, vMap);\n+                allEqual &= compareDocComments(vPos, vMap);\n+                allEqual &= compareApiDescriptions(vPos, vMap);\n+            }\n+        } finally {\n+            reporter.completed(vPos, allEqual);\n+        }\n+        return allEqual;\n+    }\n+\n+    private boolean compareSignatures(Position vPos, APIMap<VariableElement> vMap) {\n+        boolean parameters = vMap.values().iterator().next().getKind() == ElementKind.PARAMETER;\n+        return compareAnnotations(vPos, vMap)\n+                & (parameters || compareModifiers(vPos, vMap)) \/\/ ignore modifiers for parameters\n+                & compareType(vPos, vMap);\n+    }\n+\n+    private boolean compareType(Position vPos, APIMap<VariableElement> vMap) {\n+        TypeMirrorComparator tmc = new TypeMirrorComparator(vMap.keySet(), reporter);\n+        APIMap<TypeMirror> tMap = vMap.map(VariableElement::asType);\n+        return tmc.compare(vPos, tMap);\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/VariableComparator.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Classes used to model the comparison of APIs in different compilation\n+ * environments.\n+ *\n+ * <p>Each {@link jdk.codetools.apidiff.model.API API} is modelled as\n+ * a hierarchy of modules, packages, types, variables, executable elements,\n+ * annotations and documentation comments. Each element has a corresponding\n+ * {@link jdk.codetools.apidiff.model.ElementKey key} which is used to associate\n+ * corresponding elements in different API instances.\n+ *\n+ * <p>Collections of different kinds of elements existing in different APIs\n+ * are compared using \"comparators\".\n+ *\/\n+package jdk.codetools.apidiff.model;\n\\ No newline at end of file\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/model\/package-info.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Classes for the high-level operation of the tool, such as the command-line\n+ * entry point, options, and other general utility classes.\n+ *\/\n+package jdk.codetools.apidiff;\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/package-info.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 2018,2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report;\n+\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ModuleElement.Directive;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import jdk.codetools.apidiff.Log;\n+import jdk.codetools.apidiff.Options;\n+import jdk.codetools.apidiff.Options.VerboseKind;\n+import jdk.codetools.apidiff.model.API;\n+import jdk.codetools.apidiff.model.APIMap;\n+import jdk.codetools.apidiff.model.DocFile;\n+import jdk.codetools.apidiff.model.ElementKey;\n+import jdk.codetools.apidiff.model.Position;\n+\n+\/**\n+ * A reporter that reports messages to a log.\n+ *\/\n+public class LogReporter implements Reporter {\n+    private final Log log;\n+    private final Set<ElementKey.Kind> shouldReport;\n+    private final boolean shouldReportDifferences;\n+    private final boolean shouldReportMissing;\n+\n+    \/**\n+     * Creates a reporter that reports messages to a log.\n+     *\n+     * @param log the log\n+     * @param options the command-line options\n+     *\/\n+    public LogReporter(Log log, Options options) {\n+        this.log = log;\n+\n+        shouldReport = EnumSet.noneOf(ElementKey.Kind.class);\n+        if (options.isVerbose(VerboseKind.MODULE)) {\n+            shouldReport.add(ElementKey.Kind.MODULE);\n+        }\n+        if (options.isVerbose(VerboseKind.PACKAGE)) {\n+            shouldReport.add(ElementKey.Kind.MODULE);\n+            shouldReport.add(ElementKey.Kind.PACKAGE);\n+        }\n+        if (options.isVerbose(VerboseKind.TYPE)) {\n+            shouldReport.add(ElementKey.Kind.MODULE);\n+            shouldReport.add(ElementKey.Kind.PACKAGE);\n+            shouldReport.add(ElementKey.Kind.TYPE);\n+        }\n+        shouldReportDifferences = options.isVerbose(VerboseKind.DIFFERENCES);\n+        shouldReportMissing = options.isVerbose(VerboseKind.MISSING);\n+    }\n+\n+    private final Map<Position, APIMap<?>> apiMaps = new HashMap<>();\n+\n+    @Override\n+    public void comparing(Position pos, APIMap<?> map) {\n+        apiMaps.put(pos, map);\n+\n+        if (shouldReport(pos)) {\n+            log.report(\"logReport.comparing\", pos);\n+        }\n+    }\n+\n+    @Override\n+    public void completed(Position pos, boolean equal) {\n+        if (shouldReport(pos)) {\n+            log.report(\"logReport.completed\", pos, asInt(equal));\n+        }\n+\n+        if (pos.isElement()) {\n+            apiMaps.remove(pos);\n+        }\n+    }\n+\n+    @Override\n+    public void completed(boolean equal) {\n+        log.report(\"logReport.finished\", asInt(equal));\n+    }\n+\n+    private static int asInt(boolean b) {\n+        return b ? 1 : 0;\n+    }\n+\n+    private boolean shouldReport(Position pos) {\n+        return pos.isElement() && shouldReport.contains(pos.asElementKey().kind);\n+    }\n+\n+    @Override\n+    public void reportMissing(Position pos, Set<API> apis) {\n+        if (shouldReportMissing) {\n+            for (API api : apis) {\n+                log.report(\"logReport.item-not-found\", api.name, toString(pos));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentAnnotations(Position pos, APIMap<? extends AnnotationMirror> amMap) {\n+        if (shouldReportDifferences) {\n+            log.report(\"logReport.different-annotations\", toString(pos));\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentAnnotationValues(Position pos, APIMap<? extends AnnotationValue> dMap) {\n+        if (shouldReportDifferences) {\n+            log.report(\"logReport.different-annotation-values\", toString(pos));\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentDirectives(Position pos, APIMap<? extends Directive> eMap) {\n+        if (shouldReportDifferences) {\n+            log.report(\"logReport.different-directives\", toString(pos));\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentKinds(Position pos, APIMap<? extends Element> eMap) {\n+        if (shouldReportDifferences) {\n+            log.report(\"logReport.different-kinds\", toString(pos));\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentNames(Position pos, APIMap<? extends Element> eMap) {\n+        if (shouldReportDifferences) {\n+            log.report(\"logReport.different-names\", toString(pos));\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentTypeParameters(Position pos, APIMap<? extends TypeParameterElement> eMap) {\n+        if (shouldReportDifferences) {\n+            log.report(\"logReport.different-type-parameters\", toString(pos));\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentModifiers(Position pos, APIMap<? extends Element> eMap) {\n+        if (shouldReportDifferences) {\n+            log.report(\"logReport.different-modifiers\", toString(pos));\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentTypes(Position pos, APIMap<? extends TypeMirror> tMap) {\n+        if (shouldReportDifferences) {\n+            log.report(\"logReport.different-types\", toString(pos));\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentThrownTypes(Position pos, APIMap<List<? extends TypeMirror>> eMap) {\n+        if (shouldReportDifferences) {\n+            log.report(\"logReport.different-thrown-types\", toString(pos));\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentSuperinterfaces(Position pos, APIMap<List<? extends TypeMirror>> eMap) {\n+        if (shouldReportDifferences) {\n+            log.report(\"logReport.different-superinterfaces\", toString(pos));\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentPermittedSubclasses(Position pos, APIMap<List<? extends TypeMirror>> eMap) {\n+        if (shouldReportDifferences) {\n+            log.report(\"logReport.different-permitted-subclasses\", toString(pos));\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentValues(Position pos, APIMap<?> vMap) {\n+        if (shouldReportDifferences) {\n+            log.report(\"logReport.different-values\", toString(pos));\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentRawDocComments(Position pos, APIMap<String> cMap) {\n+        if (shouldReportDifferences) {\n+            log.report(\"logReport.different-raw-doc-comments\", toString(pos));\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentApiDescriptions(Position pos, APIMap<String> dMap) {\n+        if (shouldReportDifferences) {\n+            log.report(\"logReport.different-api-descriptions\", toString(pos));\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentDocFiles(Position pos, APIMap<DocFile> fMap) {\n+        if (shouldReportDifferences) {\n+            log.report(\"logReport.different-doc-files\", toString(pos));\n+        }\n+    }\n+\n+    String toString(Position pos) {\n+        StringBuilder sb = new StringBuilder();\n+        pos.accept(new SignatureVisitor(apiMaps), sb);\n+        return sb.toString();\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/LogReporter.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2018,2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report;\n+\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ModuleElement.Directive;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import jdk.codetools.apidiff.model.API;\n+import jdk.codetools.apidiff.model.APIMap;\n+import jdk.codetools.apidiff.model.DocFile;\n+import jdk.codetools.apidiff.model.Position;\n+\n+\/**\n+ * A class to broadcast messages to a series of reporters.\n+ *\/\n+public class MultiplexReporter implements Reporter {\n+    private final List<Reporter> reporters;\n+\n+    \/**\n+     * Creates a reporter to broadcast messages to a series of reporters.\n+     *\n+     * @param reporters the reporters\n+     *\/\n+    public MultiplexReporter(List<Reporter> reporters) {\n+        this.reporters = reporters;\n+    }\n+\n+    @Override\n+    public void comparing(Position pos, APIMap<?> apiMap) {\n+        reporters.forEach(r -> r.comparing(pos, apiMap));\n+    }\n+\n+    @Override\n+    public void completed(boolean equal) {\n+        reporters.forEach(r -> r.completed(equal));\n+    }\n+\n+    @Override\n+    public void completed(Position pos, boolean equal) {\n+        reporters.forEach(r -> r.completed(pos, equal));\n+    }\n+\n+    @Override\n+    public void reportMissing(Position pos, Set<API> apis) {\n+        reporters.forEach(r -> r.reportMissing(pos, apis));\n+    }\n+\n+    @Override\n+    public void reportDifferentAnnotations(Position pos, APIMap<? extends AnnotationMirror> amMap) {\n+        reporters.forEach(r -> r.reportDifferentAnnotations(pos, amMap));\n+    }\n+\n+    @Override\n+    public void reportDifferentAnnotationValues(Position pos, APIMap<? extends AnnotationValue> avMap) {\n+        reporters.forEach(r -> r.reportDifferentAnnotationValues(pos, avMap));\n+    }\n+\n+    @Override\n+    public void reportDifferentDirectives(Position pos, APIMap<? extends Directive> dMap) {\n+        reporters.forEach(r -> r.reportDifferentDirectives(pos, dMap));\n+    }\n+\n+    @Override\n+    public void reportDifferentKinds(Position pos, APIMap<? extends Element> eMap) {\n+        reporters.forEach(r -> r.reportDifferentKinds(pos, eMap));\n+    }\n+\n+    @Override\n+    public void reportDifferentNames(Position pos, APIMap<? extends Element> eMap) {\n+        reporters.forEach(r -> r.reportDifferentNames(pos, eMap));\n+    }\n+\n+    @Override\n+    public void reportDifferentTypeParameters(Position pos, APIMap<? extends TypeParameterElement> eMap) {\n+        reporters.forEach(r -> r.reportDifferentTypeParameters(pos, eMap));\n+    }\n+\n+    @Override\n+    public void reportDifferentModifiers(Position pos, APIMap<? extends Element> eMap) {\n+        reporters.forEach(r -> r.reportDifferentModifiers(pos, eMap));\n+    }\n+\n+    @Override\n+    public void reportDifferentTypes(Position pos, APIMap<? extends TypeMirror> tMap) {\n+        reporters.forEach(r -> r.reportDifferentTypes(pos, tMap));\n+    }\n+\n+    @Override\n+    public void reportDifferentThrownTypes(Position pos, APIMap<List<? extends TypeMirror>> tMap) {\n+        reporters.forEach(r -> r.reportDifferentThrownTypes(pos, tMap));\n+    }\n+\n+    @Override\n+    public void reportDifferentSuperinterfaces(Position pos, APIMap<List<? extends TypeMirror>> tMap) {\n+        reporters.forEach(r -> r.reportDifferentSuperinterfaces(pos, tMap));\n+    }\n+\n+    @Override\n+    public void reportDifferentPermittedSubclasses(Position pos, APIMap<List<? extends TypeMirror>> tMap) {\n+        reporters.forEach(r -> r.reportDifferentPermittedSubclasses(pos, tMap));\n+    }\n+\n+    @Override\n+    public void reportDifferentValues(Position pos, APIMap<?> vMap) {\n+        reporters.forEach(r -> r.reportDifferentValues(pos, vMap));\n+    }\n+\n+    @Override\n+    public void reportDifferentRawDocComments(Position pos, APIMap<String> cMap) {\n+        reporters.forEach(r -> r.reportDifferentRawDocComments(pos, cMap));\n+    }\n+\n+    @Override\n+    public void reportDifferentApiDescriptions(Position pos, APIMap<String> cMap) {\n+        reporters.forEach(r -> r.reportDifferentApiDescriptions(pos, cMap));\n+    }\n+\n+    @Override\n+    public void reportDifferentDocFiles(Position pos, APIMap<DocFile> fMap) {\n+        reporters.forEach(r -> r.reportDifferentDocFiles(pos, fMap));\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/MultiplexReporter.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2018,2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report;\n+\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ModuleElement.Directive;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import jdk.codetools.apidiff.model.API;\n+import jdk.codetools.apidiff.model.APIMap;\n+import jdk.codetools.apidiff.model.DocFile;\n+import jdk.codetools.apidiff.model.Position;\n+\n+\/**\n+ * A base class for reporting differences found in different instances of an API.\n+ *\/\n+public interface Reporter {\n+    \/**\n+     * Reports the elements being compared.\n+     *\n+     * @param pos the position of an item being compared\n+     * @param map the map identifying the instances to be compared\n+     * @see #completed(Position, boolean)\n+     *\/\n+    void comparing(Position pos, APIMap<?> map);\n+\n+    \/**\n+     * Reports that a comparison has completed.\n+     *\n+     * @param ePos the position of an item being compared\n+     * @param equal {@code true} if the items being compared are equivalent\n+     * @see #comparing(Position, APIMap)\n+     *\/\n+    void completed(Position ePos, boolean equal);\n+\n+    \/**\n+     * Reports that the overall comparison has been completed.\n+     *\n+     * @param equal {@code true} if the APIs being compared are equivalent\n+     *\/\n+    default void completed(boolean equal) { }\n+\n+    \/**\n+     * Reports that items were not found at a given position within instances of an API.\n+     *\n+     * @param ePos the position of the item being compared\n+     * @param apis the APIs\n+     *\/\n+    void reportMissing(Position ePos, Set<API> apis);\n+\n+\n+    \/**\n+     * Reports that different annotations were found at a given position\n+     * within instances of an API.\n+     *\n+     * @param amPos the position of the annotations\n+     * @param amMap the map identifying the instances to be compared\n+     *\/\n+    void reportDifferentAnnotations(Position amPos, APIMap<? extends AnnotationMirror> amMap);\n+\n+    \/**\n+     * Reports that different annotation values were found at a given position\n+     * within instances of an API.\n+     *\n+     * @param avPos the position of the annotations\n+     * @param avMap the map identifying the instances that were compared\n+     *\/\n+    void reportDifferentAnnotationValues(Position avPos, APIMap<? extends AnnotationValue> avMap);\n+\n+    \/**\n+     * Reports that different directives were found at a position within a module element\n+     * within instances of an API.\n+     *\n+     * @param dPos the position of the directive\n+     * @param dMap the map identifying the instances that were compared\n+     *\/\n+    void reportDifferentDirectives(Position dPos, APIMap<? extends Directive> dMap);\n+\n+    \/**\n+     * Reports that different modifiers were found at a position for an element\n+     * within instances of an API.\n+     *\n+     * @param ePos the position of the directive\n+     * @param eMap the map identifying the instances that were compared\n+     *\/\n+    void reportDifferentModifiers(Position ePos, APIMap<? extends Element> eMap);\n+\n+    \/**\n+     * Reports that different kinds of an element were found at a position\n+     * within instances of an API.  For example, a class in one API may be\n+     * declared an interface in another.\n+     *\n+     * @param ePos the position of the element\n+     * @param eMap the map identifying the instances that were compared\n+     *\/\n+    void reportDifferentKinds(Position ePos, APIMap<? extends Element> eMap);\n+\n+    \/**\n+     * Reports that different names for an element were found at a position\n+     * within instances of an API.  For example, record components may be\n+     * named differently.\n+     *\n+     * @param ePos the position of the element\n+     * @param eMap the map identifying the instances that were compared\n+     *\/\n+    void reportDifferentNames(Position ePos, APIMap<? extends Element> eMap);\n+\n+    \/**\n+     * Reports that different values were found at a position\n+     * within instances of an API.  For example, serializable objects may\n+     * have different serial version UIDs.\n+     *\n+     * @param vPos the position of the value\n+     * @param vMap the map identifying the instances that were compared\n+     *\/\n+    void reportDifferentValues(Position vPos, APIMap<?> vMap);\n+\n+    \/**\n+     * Reports that different type parameters were found at a position within\n+     * instances of an API.\n+     *\n+     * @param ePos the position of the directive\n+     * @param eMap the map identifying the instances that were compared\n+     *\/\n+    void reportDifferentTypeParameters(Position ePos, APIMap<? extends TypeParameterElement> eMap);\n+\n+    \/**\n+     * Reports that different type mirrors were found at a position\n+     * within instances of an API.\n+     *\n+     * @param tPos the position of the type\n+     * @param tMap the map identifying the instances that were compared\n+     *\/\n+    void reportDifferentTypes(Position tPos, APIMap<? extends TypeMirror> tMap);\n+\n+    \/**\n+     * Reports that different sets of thrown types were found at a position\n+     * within instances of an API.\n+     *\n+     * @param ePos the position of the executable element\n+     * @param eMap the map identifying the instances that were compared\n+     *\/\n+    void reportDifferentThrownTypes(Position ePos, APIMap<List<? extends TypeMirror>> eMap);\n+\n+    \/**\n+     * Reports that different sets of superinterfaces were found at a position\n+     * within instances of an API.\n+     *\n+     * @param ePos the position of the type element\n+     * @param eMap the map identifying the instances that were compared\n+     *\/\n+    void reportDifferentSuperinterfaces(Position ePos, APIMap<List<? extends TypeMirror>> eMap);\n+\n+    \/**\n+     * Reports that different sets of permitted subclasses were found at a position\n+     * within instances of an API.\n+     *\n+     * @param ePos the position of the type element\n+     * @param eMap the map identifying the instances that were compared\n+     *\/\n+    void reportDifferentPermittedSubclasses(Position ePos, APIMap<List<? extends TypeMirror>> eMap);\n+\n+    \/**\n+     * Reports that different raw doc comments were found at a position\n+     * within instances of an API.\n+     *\n+     * @param ePos the position of the doc comment\n+     * @param cMap the map identifying the instances that were compared\n+     *\/\n+    void reportDifferentRawDocComments(Position ePos, APIMap<String> cMap);\n+\n+    \/**\n+     * Reports that different API descriptions were found at a position\n+     * within instances of an API.\n+     *\n+     * @param ePos the position of the doc comment\n+     * @param cMap the map identifying the instances that were compared\n+     *\/\n+    void reportDifferentApiDescriptions(Position ePos, APIMap<String> cMap);\n+\n+    \/**\n+     * Reports that different doc files were found for a package\n+     * within instances of an API.\n+     *\n+     * @param fPos the position of the doc file\n+     * @param fMap the map identifying the instances that were compared\n+     *\/\n+    void reportDifferentDocFiles(Position fPos, APIMap<DocFile> fMap);\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/Reporter.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,302 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.type.TypeKind;\n+\n+import jdk.codetools.apidiff.model.APIMap;\n+import jdk.codetools.apidiff.model.ElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.ExecutableElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.MemberElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.ModuleElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.PackageElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.TypeElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.TypeParameterElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.VariableElementKey;\n+import jdk.codetools.apidiff.model.Position;\n+import jdk.codetools.apidiff.model.Position.ElementPosition;\n+import jdk.codetools.apidiff.model.Position.RelativePosition;\n+import jdk.codetools.apidiff.model.TypeMirrorKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.ArrayTypeKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.DeclaredTypeKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.PrimitiveTypeKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.TypeVariableKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.WildcardTypeKey;\n+\n+\/**\n+ * A utility class to obtain the signature for an element key.\n+ *\/\n+public class SignatureVisitor implements\n+        ElementKey.Visitor<StringBuilder, StringBuilder>,\n+        TypeMirrorKey.Visitor<StringBuilder, StringBuilder>,\n+        Position.Visitor<StringBuilder, StringBuilder> {\n+\n+    private final Map<Position, APIMap<?>> apiMaps;\n+\n+    \/**\n+     * Creates an instance of a signature visitor.\n+     *\n+     * @param apiMaps the map containing the API elements to be used in the signature\n+     *\/\n+    public SignatureVisitor(Map<Position, APIMap<?>> apiMaps) {\n+        this.apiMaps = apiMaps;\n+    }\n+\n+    \/**\n+     * Returns the signature for the elements identified by an element key.\n+     *\n+     * @param key the key\n+     * @return the signature\n+     *\/\n+    public String getSignature(ElementKey key) {\n+        return getSignature(key, new StringBuilder()).toString();\n+    }\n+\n+    \/**\n+     * Returns the signature for the elements at a given position.\n+     *\n+     * @param pos the position\n+     * @return the signature\n+     *\/\n+    public String getSignature(Position pos) {\n+        return pos.accept(this, new StringBuilder()).toString();\n+    }\n+\n+    private StringBuilder getSignature(ElementKey key, StringBuilder sb) {\n+        sb.append(getPrefix(key)).append(\" \");\n+        key.accept(this, sb);\n+        return sb;\n+    }\n+\n+    private String getPrefix(ElementKey key) {\n+        return switch (key.kind) {\n+            case MODULE ->\n+                \"module\";\n+\n+            case PACKAGE ->\n+                \"package\";\n+\n+            case TYPE -> {\n+                @SuppressWarnings(\"unchecked\")\n+                APIMap<? extends Element> map = (APIMap<? extends Element>) apiMaps.get(Position.of(key));\n+                Set<ElementKind> eKinds = (map == null) ? Collections.emptySet()\n+                        : map.values().stream().map(Element::getKind).collect(Collectors.toSet());\n+                yield switch (eKinds.size()) {\n+                    case 0 -> \"(unknown)\";\n+                    case 1 -> getPrefix(eKinds.iterator().next());\n+                    default -> \"(various)\";\n+                };\n+            }\n+\n+            case EXECUTABLE, VARIABLE ->\n+                getPrefix(((MemberElementKey) key).elementKind);\n+\n+            case TYPE_PARAMETER ->\n+                \"type parameter\";\n+        };\n+    }\n+\n+    private String getPrefix(ElementKind kind) {\n+        return switch (kind) {\n+            case ANNOTATION_TYPE -> \"@interface\";\n+            case CLASS -> \"class\";\n+            case CONSTRUCTOR -> \"constructor\";\n+            case ENUM -> \"enum\";\n+            case ENUM_CONSTANT -> \"enum constant\";\n+            case FIELD -> \"field\";\n+            case INTERFACE -> \"interface\";\n+            case METHOD -> \"method\";\n+            case MODULE -> \"module\";\n+            case PACKAGE -> \"package\";\n+            case PARAMETER -> \"parameter\";\n+            case RECORD -> \"record\";\n+            case RECORD_COMPONENT -> \"record component\";\n+            case TYPE_PARAMETER -> \"type parameter\";\n+            default -> throw new IllegalArgumentException(kind.toString());\n+        };\n+\n+    }\n+\n+    @Override\n+    public StringBuilder visitModuleElement(ModuleElementKey k, StringBuilder sb) {\n+        return sb.append(k.name);\n+    }\n+\n+    @Override\n+    public StringBuilder visitPackageElement(PackageElementKey k, StringBuilder sb) {\n+        if (k.moduleKey != null) {\n+            k.moduleKey.accept(this, sb).append(\"\/\");\n+        }\n+        return sb.append(k.name);\n+    }\n+\n+    @Override\n+    public StringBuilder visitTypeElement(TypeElementKey tek, StringBuilder sb) {\n+        return tek.enclosingKey.accept(this, sb).append(\".\").append(tek.name);\n+    }\n+\n+    @Override\n+    public StringBuilder visitExecutableElement(ExecutableElementKey k, StringBuilder sb) {\n+        k.typeKey.accept(this, sb);\n+        sb.append(\"#\");\n+        if (k.elementKind == ElementKind.CONSTRUCTOR) {\n+            TypeElementKey tek = (TypeElementKey) k.typeKey;\n+            sb.append(tek.name);\n+        } else {\n+            sb.append(k.name);\n+        }\n+        sb.append(\"(\");\n+        boolean first = true;\n+        for (TypeMirrorKey tmk : k.params) {\n+            if (first) {\n+                first = false;\n+            } else {\n+                sb.append(\",\");\n+            }\n+            tmk.accept(this, sb);\n+        }\n+        sb.append(\")\");\n+        return sb;\n+    }\n+\n+    @Override\n+    public StringBuilder visitVariableElement(VariableElementKey k, StringBuilder sb) {\n+        return k.typeKey.accept(this, sb).append(\"#\").append(k.name);\n+    }\n+\n+    @Override\n+    public StringBuilder visitTypeParameterElement(TypeParameterElementKey k, StringBuilder sb) {\n+        return k.typeKey.accept(this, sb).append(\"<\").append(k.name).append(\">\");\n+    }\n+\n+    @Override\n+    public StringBuilder visitArrayType(ArrayTypeKey k, StringBuilder sb) {\n+        return k.componentKey.accept(this, sb).append(\"[]\");\n+    }\n+\n+    @Override\n+    public StringBuilder visitDeclaredType(DeclaredTypeKey k, StringBuilder sb) {\n+        k.elementKey.accept(this, sb);\n+        if (!k.typeArgKeys.isEmpty()) {\n+            sb.append(\"<\");\n+            boolean first = true;\n+            for (TypeMirrorKey tmk : k.typeArgKeys) {\n+                if (first) {\n+                    first = false;\n+                } else {\n+                    sb.append(\",\");\n+                }\n+                tmk.accept(this, sb);\n+            }\n+            sb.append(\">\");\n+        }\n+        return sb;\n+    }\n+\n+    @Override\n+    public StringBuilder visitPrimitiveType(PrimitiveTypeKey k, StringBuilder sb) {\n+        return sb.append(toString(k.kind));\n+    }\n+\n+    private String toString(TypeKind kind) {\n+        return switch (kind) {\n+            case BOOLEAN -> \"boolean\";\n+            case BYTE -> \"byte\";\n+            case CHAR -> \"char\";\n+            case DOUBLE -> \"double\";\n+            case FLOAT -> \"float\";\n+            case INT -> \"int\";\n+            case LONG -> \"long\";\n+            case SHORT -> \"short\";\n+            case VOID -> \"void\";\n+            default -> throw new IllegalStateException(kind.toString());\n+        };\n+\n+    }\n+\n+    @Override\n+    public StringBuilder visitTypeVariable(TypeVariableKey k, StringBuilder sb) {\n+        return sb.append(k.name);\n+    }\n+\n+    @Override\n+    public StringBuilder visitWildcardType(WildcardTypeKey k, StringBuilder sb) {\n+        sb.append(\"?\");\n+        if (k.extendsBoundKey != null) {\n+            sb.append(\" extends \");\n+            k.extendsBoundKey.accept(this, sb);\n+        }\n+        if (k.superBoundKey != null) {\n+            sb.append(\" super \");\n+            k.superBoundKey.accept(this, sb);\n+        }\n+        return sb;\n+    }\n+\n+    @Override\n+    public StringBuilder visitElementPosition(ElementPosition kp, StringBuilder sb) {\n+        return sb.append(getSignature(kp.key));\n+    }\n+\n+    @Override\n+    public StringBuilder visitRelativePosition(RelativePosition<?> ip, StringBuilder sb) {\n+        \/\/ TODO: improve for non-integer indexes, perhaps by resolving String.format in each branch\n+        String suffix = switch (ip.kind) {\n+            case ANNOTATION -> \" @%s\";\n+            case ANNOTATION_ARRAY_INDEX -> \"[%d]\";\n+            case ANNOTATION_VALUE -> \", value %s\";\n+            case BOUND -> \", bound %d\";\n+            case DEFAULT_VALUE -> \", default value\";\n+            case DOC_FILE -> \", doc-file %s\";\n+            case EXCEPTION -> \", throws %s\";\n+            case MODULE_EXPORTS -> \", exports %s\";\n+            case MODULE_REQUIRES -> \", requires %s\";\n+            case MODULE_OPENS -> \", opens %s\";\n+            case MODULE_PROVIDES -> \", provides %s\";\n+            case MODULE_USES -> \", uses %s\";\n+            case PARAMETER -> \", parameter %d\";\n+            case PERMITTED_SUBCLASS -> \", permitted subclass %s\";\n+            case RECEIVER_TYPE -> \" receiver type\";\n+            case RECORD_COMPONENT -> \", record component %d\";\n+            case RETURN_TYPE -> \" return type\";\n+            case SERIAL_VERSION_UID -> \", serial version UID\";\n+            case SERIALIZATION_METHOD -> \", serialization method %s\";\n+            case SERIALIZATION_OVERVIEW -> \", serialization overview\";\n+            case SERIALIZED_FIELD -> \", serialized field %s\";\n+            case SERIALIZED_FORM -> \" serialized form\";\n+            case SUPERCLASS -> \" superclass\";\n+            case SUPERINTERFACE -> \" superinterface %s\";\n+            case TYPE_PARAMETER -> \", type parameter %d\";\n+        };\n+        return ip.parent.accept(this, sb).append(String.format(suffix, ip.index));\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/SignatureVisitor.java","additions":302,"deletions":0,"binary":false,"changes":302,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report.html;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import jdk.codetools.apidiff.html.Content;\n+import jdk.codetools.apidiff.html.Entity;\n+import jdk.codetools.apidiff.html.HtmlTree;\n+import jdk.codetools.apidiff.model.API;\n+import jdk.codetools.apidiff.model.APIMap;\n+\n+\/**\n+ * A class to build a list for the different versions of an API fragment\n+ * in different instances of an API.\n+ *\n+ * <p>The various {@code build} methods all take a collection providing\n+ * a list of alternatives. While we could use a {@code <ul>} list to display\n+ * the alternatives, in general it is expected that the alternatives will\n+ * be presented inline, and not as a typical bulleted list. In addition,\n+ * using {@code <ul>} would require that all enclosing elements are able to\n+ * accept flow content.  Therefore, instead of using {@code <ul>} and a series\n+ * of {@code <li> nodes}, the output is a {@code <span>} with class \"diffs\"\n+ * containing a series of {@code <span>} elements for the alternatives.\n+ *\/\n+public class DiffBuilder {\n+    Content build(List<Content> list) {\n+        HtmlTree outerSpan = newDiffsSpan();\n+        list.stream()\n+                .map(HtmlTree::SPAN)\n+                .forEach(outerSpan::add);\n+        return outerSpan;\n+    }\n+\n+    Content build(APIMap<Content> alternatives) {\n+        HtmlTree outerSpan = newDiffsSpan();\n+        alternatives.forEach((api, c) -> outerSpan.add(buildItem(api, c)));\n+        return outerSpan;\n+    }\n+\n+    <T> Content build(APIMap<T> alternatives, Function<T, Content> f) {\n+        HtmlTree outerSpan = newDiffsSpan();\n+        alternatives.forEach((api, t) -> outerSpan.add(buildItem(api, f.apply(t))));\n+        return outerSpan;\n+    }\n+\n+    <T> Content build(Set<API> apis, APIMap<T> alternatives, Function<T, Content> f) {\n+        HtmlTree outerSpan = newDiffsSpan();\n+        for (API api : apis) {\n+            T item = alternatives.get(api);\n+            outerSpan.add(buildItem(api, item == null ? Entity.NBSP : f.apply(item)));\n+        }\n+        return outerSpan;\n+    }\n+\n+    private HtmlTree newDiffsSpan() {\n+        return HtmlTree.SPAN().setClass(\"diffs\");\n+    }\n+\n+    private Content buildItem(API api, Content c) {\n+        return HtmlTree.SPAN(c).setClass(\"api\").setTitle(api.name); \/\/ TODO: improve class with api name\/index\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/DiffBuilder.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report.html;\n+\n+\/**\n+ * Abstraction for simple relative URIs, consisting of a path,\n+ * an optional query, and an optional fragment. {@code DocLink} objects can\n+ * be created by the constructors below or from a {@code DocPath} using the\n+ * convenience methods {@link DocPath#fragment fragment} and\n+ * {@link DocPath#query query}.\n+ *\/\n+public class DocLink {\n+    final DocPath path;\n+    final String query;\n+    final String fragment;\n+\n+    \/**\n+     * Creates a DocLink representing the URI {@code #fragment}.\n+     *\n+     * @param fragment the fragment\n+     * @return the DocLink\n+     *\/\n+    public static DocLink fragment(String fragment) {\n+        return new DocLink((DocPath) null, null, fragment);\n+    }\n+\n+    \/**\n+     * Creates a DocLink representing the URI {@code path}.\n+     * @param path the path\n+     *\/\n+    public DocLink(DocPath path) {\n+        this(path, null, null);\n+    }\n+\n+    \/**\n+     * Creates a DocLink representing the URI {@code path?query#fragment}.\n+     * Any of the component parts may be null.\n+     *\n+     * @param path the path\n+     * @param query the query\n+     * @param fragment the fragment\n+     *\/\n+    public DocLink(DocPath path, String query, String fragment) {\n+        this.path = path;\n+        this.query = query;\n+        this.fragment = fragment;\n+    }\n+\n+    \/**\n+     * Creates a DocLink representing the URI {@code path?query#fragment}.\n+     * Any of the component parts may be null.\n+     *\n+     * @param path the path\n+     * @param query the query\n+     * @param fragment the fragment\n+     *\/\n+    public DocLink(String path, String query, String fragment) {\n+        this(DocPath.create(path), query, fragment);\n+    }\n+\n+    \/**\n+     * Creates a DocLink formed by relativizing the path against a given base.\n+     *\n+     * @param base the base\n+     * @return the DocLink\n+     *\/\n+    public DocLink relativizeAgainst(DocPath base) {\n+        if (base.isEmpty() || path == null) {\n+            return this;\n+        }\n+\n+        \/\/ The following guards against the (ugly) use-case of using DocPath to contain a URL\n+        if (isAbsoluteURL(path)) {\n+            return this;\n+        }\n+\n+        DocPath newPath = base.relativize(path);\n+        \/\/ avoid generating an empty link by using the basename of the path if necessary\n+        if (newPath.isEmpty() && isEmpty(query) && isEmpty(fragment)) {\n+            newPath = path.basename();\n+        }\n+        return new DocLink(newPath, query, fragment);\n+    }\n+\n+    \/\/ return true if the path begins <letters>:\/\/\n+    private boolean isAbsoluteURL(DocPath path) {\n+        String s = path.getPath();\n+        for (int i = 0; i < s.length(); i++) {\n+            char c = s.charAt(i);\n+            if (Character.isLetter(c)) {\n+                continue;\n+            }\n+            return (c == ':' && i + 2 < s.length() && s.charAt(i + 1)== '\/' && s.charAt(i + 2)== '\/');\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns the link in the form \"path?query#fragment\", omitting any empty\n+     * components.\n+     *\n+     * @return the string\n+     *\/\n+    @Override\n+    public String toString() {\n+        \/\/ common fast path\n+        if (path != null && isEmpty(query) && isEmpty(fragment))\n+            return path.getPath();\n+\n+        StringBuilder sb = new StringBuilder();\n+        if (path != null)\n+            sb.append(path.getPath());\n+        if (!isEmpty(query))\n+            sb.append(\"?\").append(query);\n+        if (!isEmpty(fragment))\n+            sb.append(\"#\").append(fragment);\n+        return sb.toString();\n+    }\n+\n+    private static boolean isEmpty(String s) {\n+        return (s == null) || s.isEmpty();\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/DocLink.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report.html;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+\/**\n+ * Abstraction for immutable relative paths.\n+ * Paths always use '\/' as a separator, and never begin or end with '\/'.\n+ *\/\n+public class DocPath {\n+    private final String path;\n+\n+    \/** The empty path. *\/\n+    public static final DocPath empty = new DocPath(\"\");\n+\n+    \/** The empty path. *\/\n+    public static final DocPath parent = new DocPath(\"..\");\n+\n+    \/**\n+     * Creates a path from a string.\n+     * @param p the string\n+     * @return the path\n+     *\/\n+    public static DocPath create(String p) {\n+        return (p == null) || p.isEmpty() ? empty : new DocPath(p);\n+    }\n+\n+    \/**\n+     * Creates a path from a string.\n+     * @param p the string\n+     *\/\n+    protected DocPath(String p) {\n+        path = (p.endsWith(\"\/\") ? p.substring(0, p.length() - 1) : p);\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        return (other instanceof DocPath) && path.equals(((DocPath)other).path);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return path.hashCode();\n+    }\n+\n+    \/**\n+     * Returns the basename of this path.\n+     * @return the basename\n+     *\/\n+    public DocPath basename() {\n+        int sep = path.lastIndexOf(\"\/\");\n+        return (sep == -1) ? this : new DocPath(path.substring(sep + 1));\n+    }\n+\n+    \/**\n+     * Returns the parent directory of this path.\n+     * @return the parent directory\n+     *\/\n+    public DocPath parent() {\n+        int sep = path.lastIndexOf(\"\/\");\n+        return (sep == -1) ? empty : new DocPath(path.substring(0, sep));\n+    }\n+\n+    \/**\n+     * Returns the path formed by appending the specified string to the current path.\n+     * @param p the string\n+     * @return the path\n+     *\/\n+    public DocPath resolve(String p) {\n+        if (p == null || p.isEmpty())\n+            return this;\n+        if (path.isEmpty())\n+            return new DocPath(p);\n+        return new DocPath(path + \"\/\" + p);\n+    }\n+\n+    \/**\n+     * Returns the path by appending the specified path to the current path.\n+     * @param p the path\n+     * @return the path\n+     *\/\n+    public DocPath resolve(DocPath p) {\n+        if (p == null || p.isEmpty())\n+            return this;\n+        if (path.isEmpty())\n+            return p;\n+        return new DocPath(path + \"\/\" + p.getPath());\n+    }\n+\n+    \/**\n+     * Returns the file path obtained by resolving this path against a base directory.\n+     *\n+     * @param dir the directory\n+     *\n+     * @return the resolved path\n+     *\/\n+    public Path resolveAgainst(Path dir) {\n+        return dir.resolve(path.replace('\/', File.separatorChar)).normalize();\n+    }\n+\n+    \/**\n+     * Return the inverse path for this path.\n+     * For example, if the path is a\/b\/c, the inverse path is ..\/..\/..\n+     * @return the path\n+     *\/\n+    public DocPath invert() {\n+        return new DocPath(path.replaceAll(\"[^\/]+\", \"..\"));\n+    }\n+\n+    \/**\n+     * Returns the path formed by eliminating empty components,\n+     * '.' components, and redundant name\/.. components.\n+     * @return the path\n+     *\/\n+    public DocPath normalize() {\n+        return path.isEmpty()\n+                ? this\n+                : new DocPath(String.join(\"\/\", normalize(path)));\n+    }\n+\n+    private static List<String> normalize(String path) {\n+        return normalize(Arrays.asList(path.split(\"\/\")));\n+    }\n+\n+    private static List<String> normalize(List<String> parts) {\n+        if (parts.stream().noneMatch(s -> s.isEmpty() || s.equals(\".\") || s.equals(\"..\"))) {\n+            return parts;\n+        }\n+        List<String> normalized = new ArrayList<>();\n+        for (String part : parts) {\n+            switch (part) {\n+                case \"\":\n+                case \".\":\n+                    break;\n+                case \"..\":\n+                    int n = normalized.size();\n+                    if (n > 0 && !normalized.get(n - 1).equals(\"..\")) {\n+                        normalized.remove(n - 1);\n+                    } else {\n+                        normalized.add(part);\n+                    }\n+                    break;\n+                default:\n+                    normalized.add(part);\n+            }\n+        }\n+        return normalized;\n+    }\n+\n+    \/**\n+     * Normalize and make relative a given path against this path,\n+     * assuming that this path is for a file (not a directory),\n+     * in which the other path will appear.\n+     *\n+     * @param other the path to be made relative to this path\n+     * @return the simplified path\n+     *\/\n+    public DocPath relativize(DocPath other) {\n+        if (other == null || other.path.isEmpty()) {\n+            return this;\n+        }\n+\n+        if (path.isEmpty()) {\n+            return other;\n+        }\n+\n+        List<String> originParts = normalize(path);\n+        int sep = path.lastIndexOf(\"\/\");\n+        List<String> destParts = sep == -1\n+                ? normalize(other.path)\n+                : normalize(path.substring(0, sep + 1) + other.path);\n+        int common = 0;\n+        while (common < originParts.size()\n+                && common < destParts.size()\n+                && originParts.get(common).equals(destParts.get(common))) {\n+            common++;\n+        }\n+\n+        List<String> newParts;\n+        if (common == originParts.size()) {\n+            newParts = destParts.subList(common, destParts.size());\n+        } else {\n+            newParts = new ArrayList<>();\n+            newParts.addAll(Collections.nCopies(originParts.size() - common - 1, \"..\"));\n+            newParts.addAll(destParts.subList(common, destParts.size()));\n+        }\n+        return new DocPath(String.join(\"\/\", newParts));\n+    }\n+\n+    \/**\n+     * Return true if this path is empty.\n+     * @return true if this path is empty\n+     *\/\n+    public boolean isEmpty() {\n+        return path.isEmpty();\n+    }\n+\n+    \/**\n+     * Creates a DocLink formed from this path and a fragment identifier.\n+     * @param fragment the fragment\n+     * @return the link\n+     *\/\n+    public DocLink fragment(String fragment) {\n+        return new DocLink(path, null, fragment);\n+    }\n+\n+    \/**\n+     * Creates a DocLink formed from this path and a query string.\n+     * @param query the query string\n+     * @return the link\n+     *\/\n+    public DocLink query(String query) {\n+        return new DocLink(path, query, null);\n+    }\n+\n+    \/**\n+     * Returns this path as a string.\n+     * @return the path\n+     *\/\n+    \/\/ This is provided instead of using toString() to help catch\n+    \/\/ unintended use of toString() in string concatenation sequences.\n+    public String getPath() {\n+        return path;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"DocPath[\" + path + \"]\";\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/DocPath.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report.html;\n+\n+import java.io.File;\n+\n+import jdk.codetools.apidiff.model.ElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.ExecutableElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.ModuleElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.PackageElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.TypeElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.TypeParameterElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.VariableElementKey;\n+\n+class GetFileVisitor implements ElementKey.Visitor<DocPath, Void> {\n+\n+    DocPath getFile(ElementKey k) {\n+        return k.accept(this, null);\n+    }\n+\n+    @Override\n+    public DocPath visitModuleElement(ModuleElementKey k, Void _p) {\n+        return getModuleDir(k).resolve(\"module-summary.html\");\n+    }\n+\n+    private DocPath getModuleDir(ModuleElementKey k) {\n+        return (k == null)\n+                ? DocPath.empty\n+                : DocPath.create(k.name.toString());\n+    }\n+\n+    @Override\n+    public DocPath visitPackageElement(PackageElementKey k, Void _p) {\n+        return getPackageDir(k).resolve(\"package-summary.html\");\n+    }\n+\n+    private DocPath getPackageDir(PackageElementKey k) {\n+        return (k == null)\n+                ? DocPath.empty\n+                : getModuleDir((ModuleElementKey) k.moduleKey)\n+                        .resolve(k.name.toString().replace(\".\", File.separator));\n+    }\n+\n+    @Override\n+    public DocPath visitTypeElement(TypeElementKey k, Void _p) {\n+        StringBuilder fn = new StringBuilder(k.name + \".html\");\n+        while (k.enclosingKey instanceof TypeElementKey) {\n+            k = (TypeElementKey) k.enclosingKey;\n+            fn.insert(0,k.name + \".\");\n+        }\n+        return getPackageDir((PackageElementKey) k.enclosingKey).resolve(fn.toString());\n+    }\n+\n+    @Override\n+    public DocPath visitExecutableElement(ExecutableElementKey k, Void _p) {\n+        return k.typeKey.accept(this, null);\n+    }\n+\n+    @Override\n+    public DocPath visitVariableElement(VariableElementKey k, Void _p) {\n+        return k.typeKey.accept(this, null);\n+    }\n+\n+    @Override\n+    public DocPath visitTypeParameterElement(TypeParameterElementKey k, Void _p) {\n+        return null;\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/GetFileVisitor.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,586 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report.html;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.Stack;\n+import java.util.function.Consumer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.codetools.apidiff.Log;\n+import jdk.codetools.apidiff.Messages;\n+import jdk.codetools.apidiff.html.Content;\n+import jdk.codetools.apidiff.html.HtmlAttr;\n+import jdk.codetools.apidiff.html.HtmlTree;\n+import jdk.codetools.apidiff.html.RawHtml;\n+import jdk.codetools.apidiff.html.TagName;\n+import jdk.codetools.apidiff.html.Text;\n+import jdk.codetools.apidiff.model.API;\n+import jdk.codetools.apidiff.report.html.ResultTable.CountKind;\n+\n+import org.htmlcleaner.BaseToken;\n+import org.htmlcleaner.CommentNode;\n+import org.htmlcleaner.ContentNode;\n+import org.htmlcleaner.HtmlCleaner;\n+import org.htmlcleaner.SpecialEntities;\n+import org.htmlcleaner.SpecialEntity;\n+import org.htmlcleaner.TagNode;\n+\n+import org.outerj.daisy.diff.html.HTMLDiffer;\n+import org.outerj.daisy.diff.html.HtmlSaxDiffOutput;\n+import org.outerj.daisy.diff.html.TextNodeComparator;\n+import org.outerj.daisy.diff.html.dom.DomTree;\n+import org.outerj.daisy.diff.html.dom.DomTreeBuilder;\n+\n+import org.xml.sax.Attributes;\n+import org.xml.sax.ContentHandler;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.helpers.AttributesImpl;\n+\n+\/**\n+ * A class to build HTML to display the differences between strings containing HTML,\n+ * such as may be found in the documentation for corresponding elements in different\n+ * instances of an API.\n+ *\/\n+public class HtmlDiffBuilder extends PairwiseDiffBuilder<String> {\n+\n+    \/**\n+     * Creates an instance of a {@code HtmlDiffBuilder}.\n+     *\n+     * @param pageReporter the reporter for the parent page\n+     *\/\n+    public HtmlDiffBuilder(PageReporter<?> pageReporter) {\n+        super(pageReporter.parent.apis, pageReporter.log, pageReporter.msgs);\n+    }\n+\n+    \/**\n+     * Creates an instance of a {@code HtmlDiffBuilder}.\n+     *\n+     * @param log the log to which to report any problems while using this builder\n+     *\/\n+    public HtmlDiffBuilder(Set<API> apis, Log log, Messages msgs) {\n+        super(apis, log, msgs);\n+    }\n+\n+    @Override\n+    protected Content build(List<API> refAPIs, String refItem,\n+                            List<API> focusAPIs, String focusItem,\n+                            Consumer<ResultTable.CountKind> counter) {\n+        String refNames = getNameList(refAPIs);\n+        String focusNames = getNameList(focusAPIs);\n+        if (refItem != null && focusItem != null) {\n+            \/\/ item in both groups: display the comparison\n+            Content title = Text.of(msgs.getString(\"htmldiffs.comparing\", refNames, focusNames));\n+            return build(title, refItem, focusItem, counter);\n+        } else if (refItem == null) {\n+            Content title = Text.of(msgs.getString(\"htmldiffs.not-in-only-in\", refNames, focusNames));\n+            counter.accept(CountKind.DESCRIPTION_ADDED);\n+            return build(title, focusItem);\n+        } else {\n+            Content title = Text.of(msgs.getString(\"htmldiffs.only-in-not-in\", refNames, focusNames));\n+            counter.accept(CountKind.DESCRIPTION_REMOVED);\n+            return build(title, refItem);\n+        }\n+    }\n+\n+    @Override\n+    protected String getKeyString(String item) {\n+        return item;\n+    }\n+\n+    public Content build(Content title, String refItem, String modItem,\n+                                           Consumer<ResultTable.CountKind> counter) {\n+        try {\n+            Reader oldStream = new StringReader(refItem);\n+            Reader newStream = new StringReader(modItem);\n+            Handler handler = new Handler(log);\n+            diffHtml(oldStream, newStream, handler);\n+\n+            \/\/ TODO: consider styling the titles (will need custom formatter)\n+            \/\/ msgs.getString(\"htmldiffs.comparing\", refTitle, modTitle)\n+            HtmlTree title2 = HtmlTree.DIV(title)\n+                    .setClass(\"hdiffs-title\");\n+            HtmlTree doc = handler.doc;\n+            count(doc, counter);\n+            return HtmlTree.DIV(title2, doc).setClass(\"hdiffs\");\n+        } catch (IOException | SAXException e) {\n+            log.error(\"htmldiffs.err.exception-in-diff\", e);\n+            return Content.empty;\n+        }\n+\n+    }\n+\n+    private Content build(Content title, String item) {\n+        HtmlTree title2 = HtmlTree.DIV(title)\n+                .setClass(\"hdiffs-title\");\n+\n+        Content html = new RawHtml(item);\n+        List<Content> contents = List.of(title2, html);\n+        return new HtmlTree(TagName.DIV, contents).setClass(\"hdiffs\");\n+    }\n+\n+    \/\/ This method is a minimally edited extract from the DaisyDiff main program,\n+    \/\/ lines 120-157, the body of \"if (htmlDiff) { ... }\".\n+    \/\/ It runs the HtmlCleaner on the input text prior to calling HtmlDiffer,\n+    \/\/ and uses the provided content handler to process the result.\n+    void diffHtml(Reader oldStream, Reader newStream, ContentHandler postProcess)\n+            throws IOException, SAXException {\n+\n+        Locale locale = Locale.getDefault();\n+        String prefix = \"diff\";\n+\n+\/\/        HtmlCleaner cleaner = new HtmlCleaner();\n+\n+\/\/        InputSource oldSource = new InputSource(oldStream);\n+\/\/        InputSource newSource = new InputSource(newStream);\n+\n+        DomTreeBuilder oldHandler = new DomTreeBuilder();\n+\/\/        cleaner.cleanAndParse(oldSource, oldHandler);\n+        cleanAndParse(oldStream, oldHandler);\n+\/\/        System.out.print(\".\");\n+        TextNodeComparator leftComparator = new TextNodeComparator(\n+                oldHandler, locale);\n+\n+        DomTreeBuilder newHandler = new DomTreeBuilder();\n+\/\/        cleaner.cleanAndParse(newSource, newHandler);\n+        cleanAndParse(newStream, newHandler);\n+\/\/        System.out.print(\".\");\n+        TextNodeComparator rightComparator = new TextNodeComparator(\n+                newHandler, locale);\n+\n+        postProcess.startDocument();\n+        postProcess.startElement(\"\", \"diffreport\", \"diffreport\",\n+                new AttributesImpl());\n+\/\/        doCSS(css, postProcess);\n+        postProcess.startElement(\"\", \"diff\", \"diff\",\n+                new AttributesImpl());\n+        HtmlSaxDiffOutput output = new HtmlSaxDiffOutput(postProcess,\n+                prefix);\n+\n+        HTMLDiffer differ = new HTMLDiffer(output);\n+        differ.diff(leftComparator, rightComparator);\n+\/\/        System.out.print(\".\");\n+        postProcess.endElement(\"\", \"diff\", \"diff\");\n+        postProcess.endElement(\"\", \"diffreport\", \"diffreport\");\n+        postProcess.endDocument();\n+    }\n+\n+    private void cleanAndParse(Reader in, DomTreeBuilder builder) throws IOException, SAXException {\n+        HtmlCleaner cleaner = new HtmlCleaner();\n+        builder.startDocument();\n+        convert(cleaner.clean(in), builder);\n+        builder.endDocument();\n+    }\n+\n+    private void convert(BaseToken node, DomTreeBuilder builder) throws SAXException {\n+        if (node instanceof TagNode t) {\n+            String name = t.getName();\n+            AttributesImpl attrs = new AttributesImpl();\n+            t.getAttributes().forEach((k, v) -> attrs.addAttribute(\"\", k, k, \"CDATA\", v));\n+            builder.startElement(\"\", name, name, attrs);\n+            for (var c : t.getAllChildren()) {\n+                convert(c, builder);\n+            }\n+            builder.endElement(\"\", name, name);\n+        } else if (node instanceof ContentNode c) {\n+            var s = handleEntities(c.getContent());\n+            var chars = new char[s.length()];\n+            s.getChars(0, s.length(), chars, 0);\n+            builder.characters(chars, 0, chars.length);\n+        } else if (node instanceof CommentNode c) {\n+            \/\/ ignore, at least for now: it's just a comment\n+        } else {\n+            throw new IllegalArgumentException(node.getClass().toString());\n+        }\n+    }\n+\n+    private static final Pattern entity = Pattern.compile(\"(?i)&(?:(?<name>[a-z][a-z0-9]*)|#(?<dec>[0-9]+)|#x(?<hex>[0-9a-f]+))(;)?\");\n+    private String handleEntities(String s) {\n+        StringBuilder sb = null;\n+\n+        var m = entity.matcher(s);\n+        while (m.find()) {\n+            if (sb == null) {\n+                sb = new StringBuilder();\n+            }\n+            String g;\n+            if ((g = m.group(\"name\")) != null) {\n+                SpecialEntity e = SpecialEntities.INSTANCE.getSpecialEntity(g);\n+                if (e != null) {\n+                    m.appendReplacement(sb, String.valueOf(e.charValue()));\n+                } else {\n+                    m.appendReplacement(sb, m.group(0));\n+                }\n+            } else if ((g = m.group(\"dec\")) != null) {\n+                m.appendReplacement(sb, escapeReplacementCharacter((char) Integer.parseInt(g)));\n+            } else if ((g = m.group(\"hex\")) != null) {\n+                m.appendReplacement(sb, escapeReplacementCharacter((char) Integer.parseInt(g, 16)));\n+            } else {\n+                \/\/ should not happen, but if it does ...\n+                m.appendReplacement(sb, m.group(0));\n+            }\n+        }\n+\n+        if (sb != null) {\n+            m.appendTail(sb);\n+            return sb.toString();\n+        } else {\n+            return s;\n+        }\n+    }\n+\n+    private String escapeReplacementCharacter(char ch) {\n+        return switch (ch) {\n+            case '\\\\' -> \"\\\\\\\\\";\n+            case '$' -> \"\\\\$\";\n+            default -> String.valueOf(ch);\n+        };\n+    }\n+\n+    private void show(DomTree tree, PrintStream out) {\n+        show(tree.getBodyNode(), out,0);\n+    }\n+\n+    private void show(org.outerj.daisy.diff.html.dom.Node node, PrintStream out, int depth) {\n+        var indent = \"    \".repeat(depth);\n+        if (node instanceof org.outerj.daisy.diff.html.dom.TagNode tagNode) {\n+            out.println(indent + tagNode.getOpeningTag());\n+            for (var c : tagNode) {\n+                show(c, out, depth + 1);\n+            }\n+        } else if (node instanceof org.outerj.daisy.diff.html.dom.TextNode textNode) {\n+            out.println(indent + textNode.getText());\n+        } else {\n+            out.println(indent + node.getClass().getSimpleName());\n+        }\n+    }\n+\n+    private void count(HtmlTree tree, Consumer<CountKind> counter) {\n+        for (int i = 0; i < tree.contents().size(); i++) {\n+            HtmlTree t = getChildAsTree(tree.contents(), i);\n+            if (t == null) {\n+                continue;\n+            }\n+            if (isDiffSpan(t)) {\n+                Set<String> set = new HashSet<>();\n+                while (t != null && isDiffSpan(t)) {\n+                    set.add(t.get(HtmlAttr.CLASS));\n+                    t = getChildAsTree(tree.contents(), ++i);\n+                }\n+                if (set.contains(\"diff-html-changed\")\n+                        || (set.contains(\"diff-html-added\")\n+                            && set.contains(\"diff-html-removed\"))) {\n+                    counter.accept(CountKind.DESCRIPTION_CHANGED);\n+                } else if (set.contains(\"diff-html-added\")) {\n+                    counter.accept(CountKind.DESCRIPTION_ADDED);\n+                } else {\n+                    counter.accept(CountKind.DESCRIPTION_REMOVED);\n+                }\n+            } else {\n+                count(t, counter);\n+            }\n+        }\n+    }\n+\n+    private HtmlTree getChildAsTree(List<Content> contents, int i) {\n+        if (i < contents.size()) {\n+            Content c = contents.get(i);\n+            if (c instanceof HtmlTree) {\n+                return (HtmlTree) c;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private boolean isDiffSpan(HtmlTree tree) {\n+        if (tree.hasTag(TagName.SPAN)) {\n+            String classAttr = tree.get(HtmlAttr.CLASS);\n+            if (classAttr != null) {\n+                switch (classAttr) {\n+                    case \"diff-html-added\":\n+                    case \"diff-html-changed\":\n+                    case \"diff-html-removed\":\n+                        return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    static class Handler implements ContentHandler {\n+        \/** The log, for reporting any errors. *\/\n+        private final Log log;\n+        \/** The stack of {@code HtmlTree} nodes being constructed. *\/\n+        private final Stack<HtmlTree> stack;\n+        \/** A buffer for sequences of characters. *\/\n+        private final StringBuilder text;\n+\n+        HtmlTree doc;\n+\n+        Handler(Log log) {\n+            this.log = log;\n+            stack = new Stack<>();\n+            text = new StringBuilder();\n+        }\n+\n+        \/**\n+         * Returns the generated tree, after {@code endDocument} has been called.\n+         *\n+         * @return the generated tree.\n+         *\/\n+        public HtmlTree getDoc() {\n+            return doc;\n+        }\n+\n+        @Override\n+        public void setDocumentLocator(Locator locator) {\n+            \/\/ should not happen\n+        }\n+\n+        @Override\n+        public void startDocument() {\n+            stack.push(new HtmlTree(TagName.DIV));\n+        }\n+\n+        @Override\n+        public void endDocument() {\n+            doc = stack.pop();\n+        }\n+\n+        @Override\n+        public void startPrefixMapping(String prefix, String uri) {\n+            \/\/ should not happen\n+        }\n+\n+        @Override\n+        public void endPrefixMapping(String prefix) {\n+            \/\/ should not happen\n+        }\n+\n+        @Override\n+        public void startElement(String uri, String localName, String qName, Attributes atts) {\n+            flushText();\n+\n+            switch (localName) {\n+                \/\/ ignore possibility of <html>, <head>, <body> etc for now\n+                case \"diffreport\":\n+                case \"diff\":\n+                    return;\n+            }\n+\n+            HtmlTree tree;\n+            try {\n+                tree = new HtmlTree(TagName.of(localName));\n+            } catch (IllegalArgumentException e) {\n+                log.warning(\"htmldiffs.warn.unknown-tag-name\", localName);\n+                tree = new HtmlTree(localName);\n+            }\n+\n+            for (int i = 0; i < atts.getLength(); i++) {\n+                String name = atts.getLocalName(i);\n+                String value = atts.getValue(i);\n+                if (tree.hasTag(TagName.SPAN)) {\n+                    switch (name) {\n+                        case \"changes\":\n+                            \/\/ The value is an HTML fragment that describes the change.\n+                            \/\/ It may contain simple phrasing elements, as well as simple or nested lists.\n+                            \/\/ Convert it to a child node to display as a rich-text tooltip with CSS.\n+                            tree.add(getChangeTooltip(value));\n+                            continue;\n+\n+                        case \"changeId\":\n+                        case \"next\":\n+                        case \"previous\":\n+                            continue;\n+\n+                        case \"id\":\n+                            \/\/ if changeId is present, skip id to avoid duplicates;\n+                            \/\/ an alternative would be to make the names unique\n+                            if (atts.getIndex(\"changeId\") != -1) {\n+                                continue;\n+                            }\n+                    }\n+                }\n+\n+                try {\n+                    HtmlAttr a = HtmlAttr.of(name);\n+                    tree.set(a, value);\n+                } catch (IllegalArgumentException e) {\n+                    log.warning(\"htmldiffs.warn.unknown-attribute-name\", localName, name);\n+                    tree.set(name, value);\n+                }\n+            }\n+\n+            stack.push(tree);\n+        }\n+\n+        @Override\n+        public void endElement(String uri, String localName, String qName) {\n+            flushText();\n+            switch (localName) {\n+                \/\/ ignore possibility of <html>, <head>, <body> etc for now\n+                case \"diffreport\":\n+                case \"diff\":\n+                    return;\n+            }\n+            HtmlTree tree = stack.pop();\n+            if (!tree.hasTag(localName)) {\n+                log.err.println(\"popping unbalanced tree node: expect: \" + localName + \", found \" + tree.getTagString());\n+            }\n+\n+            \/\/ DaisyDiff may generate empty <span class=\"diff-html-added\"><\/span> and\n+            \/\/ <span class=\"diff-html-removed\"><\/span> nodes, which get flagged by \"tidy\", so remove them\n+            if (isEmptyDiff(tree)) {\n+                return;\n+            }\n+\n+            HtmlTree top = stack.peek();\n+            \/\/ DaisyDiff may generate adjacent nodes that can be merged\n+            if (canMergeWithPrevious(top, tree)) {\n+                getPrevious(top).contents().addAll(tree.contents());\n+            } else {\n+                top.add(tree);\n+            }\n+        }\n+\n+        private boolean isEmptyDiff(HtmlTree tree) {\n+            return isDiffAddedRemoved(tree) && tree.contents().isEmpty();\n+        }\n+\n+        private boolean canMergeWithPrevious(HtmlTree container, HtmlTree tree) {\n+            if (!container.contents().isEmpty() && isDiffAddedRemoved(tree)) {\n+                Content prev = getLast(container.contents());\n+                if (prev instanceof HtmlTree prevTree) {\n+                    if (isDiffAddedRemoved(prevTree)) {\n+                        return tree.get(HtmlAttr.CLASS).equals(prevTree.get(HtmlAttr.CLASS));\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private HtmlTree getPrevious(HtmlTree container) {\n+            return (HtmlTree) getLast(container.contents());\n+        }\n+\n+        private <T> T getLast(List<T> list) {\n+            return list.get(list.size() - 1);\n+        }\n+\n+        private boolean isDiffAddedRemoved(HtmlTree tree) {\n+            if (tree.hasTag(TagName.SPAN)) {\n+                String classAttr = tree.get(HtmlAttr.CLASS);\n+                if (classAttr != null) {\n+                    switch (classAttr) {\n+                        case \"diff-html-added\":\n+                        case \"diff-html-removed\":\n+                            return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public void characters(char[] ch, int start, int length) {\n+            text.append(ch, start, length);\n+        }\n+\n+        @Override\n+        public void ignorableWhitespace(char[] ch, int start, int length) {\n+            text.append(ch, start, length);\n+        }\n+\n+        @Override\n+        public void processingInstruction(String target, String data) {\n+            \/\/ should not happen\n+        }\n+\n+        @Override\n+        public void skippedEntity(String name) {\n+            \/\/ should not happen\n+            \/\/ Note:\n+            \/\/ known entities are translated into the equivalent character; e.g. &lt; to <\n+            \/\/ unknown entities are handled as literal strings; e.g. &foo; remains as &foo;\n+        }\n+\n+        private HtmlTree getChangeTooltip(String html) {\n+            \/\/ We must return a span (or equivalent phrasing content), but the argument may contain a\n+            \/\/ small number of block items, such as <ul> and <li>. Therefore we \"cheat\" and convert them\n+            \/\/ to <span> elements with an appropriate class, and fix the display in the CSS.\n+            List<Content> contents = new ArrayList<>();\n+            Pattern p = Pattern.compile(\"(?i)<(\/?)([a-z][a-z0-9]*)([^>]*)>\");\n+            Matcher m = p.matcher(html);\n+            int start = 0;\n+            while (m.find(start)) {\n+                if (m.start() > start) {\n+                    contents.add(new Text(html.substring(start, m.start())));\n+                }\n+                if (m.group(1).isEmpty()) {\n+                    switch (m.group(2)) {\n+                        case \"ul\", \"li\" -> {\n+                            \/\/ ignore any existing attributes in group 3 -- e.g. class\n+                            contents.add(new RawHtml(\"<span class=\\\"hdiffs-tip-\" + m.group(2) + \"\\\">\"));\n+                        }\n+                        case \"br\" -> {\n+                            \/\/ ignore <br\/> scattered in the text\n+                        }\n+                        default -> contents.add(new RawHtml(m.group()));\n+                    }\n+                } else {\n+                    switch (m.group(2)) {\n+                        case \"ul\", \"li\" -> contents.add(new RawHtml(\"<\/span>\"));\n+                        default -> contents.add(new RawHtml(m.group()));\n+                    }\n+                }\n+                start = m.end();\n+            }\n+            if (start < html.length()) {\n+                contents.add(new Text(html.substring(start)));\n+            }\n+            return HtmlTree.SPAN(contents).setClass(\"hdiffs-tooltip\");\n+        }\n+\n+        private void flushText() {\n+            if (text.length() > 0) {\n+                stack.peek().add(text);\n+                text.setLength(0);\n+            }\n+        }\n+    }\n+\n+\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/HtmlDiffBuilder.java","additions":586,"deletions":0,"binary":false,"changes":586,"status":"added"},{"patch":"@@ -0,0 +1,421 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report.html;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ModuleElement.Directive;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import jdk.codetools.apidiff.Abort;\n+import jdk.codetools.apidiff.Log;\n+import jdk.codetools.apidiff.Messages;\n+import jdk.codetools.apidiff.Notes;\n+import jdk.codetools.apidiff.Options;\n+import jdk.codetools.apidiff.model.API;\n+import jdk.codetools.apidiff.model.APIMap;\n+import jdk.codetools.apidiff.model.DocFile;\n+import jdk.codetools.apidiff.model.ElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.ExecutableElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.ModuleElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.PackageElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.TypeElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.VariableElementKey;\n+import jdk.codetools.apidiff.model.Position;\n+import jdk.codetools.apidiff.model.Position.ElementPosition;\n+import jdk.codetools.apidiff.model.Position.RelativePosition;\n+import jdk.codetools.apidiff.report.Reporter;\n+\n+\/**\n+ * The main class to generate the pages for an HTML report.\n+ * The reporting methods are dispatched to individual reporters\n+ * that handle the different types of pages.\n+ *\/\n+public class HtmlReporter implements Reporter {\n+    final Set<API> apis;\n+    final API latestAPI;\n+    final API previousAPI;\n+    final Options options;\n+    final Path outDir;\n+    final Notes notes;\n+    final Log log;\n+    final Messages msgs;\n+\n+    \/**\n+     * Creates a reporter that will generate an HTML report.\n+     *\n+     * @param apis    the APIs being compared\n+     * @param options the command-line options\n+     * @param notes   the notes to be associated with elements\n+     * @param log     the log to which to write any diagnostic messages\n+     *\/\n+    public HtmlReporter(Set<API> apis, Options options, Notes notes, Log log) {\n+        if (apis.size() < 2) {\n+            throw new IllegalArgumentException(\"too few APIs: \" + apis.size());\n+        }\n+        this.apis = apis; \/\/ TODO: change to List?\n+        this.options = options;\n+        this.outDir = options.getOutDir();\n+        this.notes = notes;\n+        this.log = log;\n+        this.msgs = Messages.instance(\"jdk.codetools.apidiff.report.html.resources.report\");\n+\n+        List<API> apiList = new ArrayList<>(apis);\n+        latestAPI = apiList.get(apiList.size() - 1);\n+        previousAPI = apiList.get(apiList.size() - 2);\n+\n+        indexPageReporter = new IndexPageReporter(this);\n+\n+        writeStylesheets();\n+        writeResourceFiles();\n+    }\n+\n+    \/\/<editor-fold desc=\"Implements Reporter\">\n+    @Override\n+    public void comparing(Position ePos, APIMap<?> apiMap) {\n+        getPageReporter(ePos).comparing(ePos, apiMap);\n+    }\n+\n+    @Override\n+    public void completed(Position ePos, boolean equal) {\n+        getPageReporter(ePos).completed(ePos, equal);\n+        \/\/ TODO: if ePos is the pageKey for the pageReporter, can clean out pageReporter from pageVisitor map\n+    }\n+\n+    @Override\n+    public void completed(boolean equal) {\n+        indexPageReporter.writeFile();\n+\n+        \/\/ Debug reporting of to-do info\n+        if (!toDoCounts.isEmpty()) {\n+            log.err.println(\"ToDo info:\");\n+            toDoCounts.forEach((k, v) -> log.err.println(\"  \" + k + \": \" + v));\n+            Map<Integer, SortedSet<String>> inverseCounts = new TreeMap<>(Comparator.reverseOrder());\n+            toDoCounts.forEach((k, v) -> inverseCounts.computeIfAbsent(v, s -> new TreeSet<>()).add(k));\n+            inverseCounts.forEach((k, v) -> log.err.println(String.format(\"%6d: %s\", k, v)));\n+        }\n+    }\n+\n+    @Override\n+    public void reportMissing(Position ePos, Set<API> apis) {\n+        getPageReporter(ePos).reportMissing(ePos, apis);\n+    }\n+\n+    @Override\n+    public void reportDifferentAnnotations(Position amPos, APIMap<? extends AnnotationMirror> amMap) {\n+        getPageReporter(amPos).reportDifferentAnnotations(amPos, amMap);\n+    }\n+\n+    @Override\n+    public void reportDifferentAnnotationValues(Position avPos, APIMap<? extends AnnotationValue> avMap) {\n+        getPageReporter(avPos).reportDifferentAnnotationValues(avPos, avMap);\n+    }\n+\n+    @Override\n+    public void reportDifferentDirectives(Position dPos, APIMap<? extends Directive> dMap) {\n+        getPageReporter(dPos).reportDifferentDirectives(dPos, dMap);\n+    }\n+\n+    @Override\n+    public void reportDifferentModifiers(Position ePos, APIMap<? extends Element> eMap) {\n+        getPageReporter(ePos).reportDifferentModifiers(ePos, eMap);\n+    }\n+\n+    @Override\n+    public void reportDifferentKinds(Position ePos, APIMap<? extends Element> eMap) {\n+        getPageReporter(ePos).reportDifferentKinds(ePos, eMap);\n+    }\n+\n+    @Override\n+    public void reportDifferentNames(Position ePos, APIMap<? extends Element> eMap) {\n+        getPageReporter(ePos).reportDifferentNames(ePos, eMap);\n+    }\n+\n+    @Override\n+    public void reportDifferentTypeParameters(Position ePos, APIMap<? extends TypeParameterElement> eMap) {\n+        getPageReporter(ePos).reportDifferentTypeParameters(ePos, eMap);\n+    }\n+\n+    @Override\n+    public void reportDifferentTypes(Position tPos, APIMap<? extends TypeMirror> tMap) {\n+        getPageReporter(tPos).reportDifferentTypes(tPos, tMap);\n+    }\n+\n+    @Override\n+    public void reportDifferentThrownTypes(Position tPos, APIMap<List<? extends TypeMirror>> tMap) {\n+        getPageReporter(tPos).reportDifferentThrownTypes(tPos, tMap);\n+    }\n+\n+    @Override\n+    public void reportDifferentSuperinterfaces(Position tPos, APIMap<List<? extends TypeMirror>> tMap) {\n+        getPageReporter(tPos).reportDifferentSuperinterfaces(tPos, tMap);\n+    }\n+\n+    @Override\n+    public void reportDifferentPermittedSubclasses(Position tPos, APIMap<List<? extends TypeMirror>> tMap) {\n+        getPageReporter(tPos).reportDifferentPermittedSubclasses(tPos, tMap);\n+    }\n+\n+    @Override\n+    public void reportDifferentValues(Position vPos, APIMap<?> vMap) {\n+        getPageReporter(vPos).reportDifferentValues(vPos, vMap);\n+    }\n+\n+    @Override\n+    public void reportDifferentRawDocComments(Position tPos, APIMap<String> cMap) {\n+        getPageReporter(tPos).reportDifferentRawDocComments(tPos, cMap);\n+    }\n+\n+    @Override\n+    public void reportDifferentApiDescriptions(Position tPos, APIMap<String> dMap) {\n+        getPageReporter(tPos).reportDifferentApiDescriptions(tPos, dMap);\n+    }\n+\n+    @Override\n+    public void reportDifferentDocFiles(Position fPos, APIMap<DocFile> fMap) {\n+        getPageReporter(fPos).reportDifferentDocFiles(fPos, fMap);\n+    }\n+    \/\/<\/editor-fold>\n+\n+    Map<String, Integer> toDoCounts = new TreeMap<>();\n+    void countToDo(String name) {\n+        toDoCounts.put(name, toDoCounts.getOrDefault(name, 0) + 1);\n+    }\n+\n+    PageReporter<?> getPageReporter(Position pos) {\n+        return pos.accept(pageVisitor, null);\n+    }\n+\n+    PageReporter<?> getPageReporter(ElementKey eKey) {\n+        return (eKey == null) ? indexPageReporter : eKey.accept(pageVisitor, null);\n+    }\n+\n+    final IndexPageReporter indexPageReporter;\n+    private final PageVisitor pageVisitor = new PageVisitor(this);\n+\n+    \/** The default stylesheet for all generated HTML files. *\/\n+    public static final String DEFAULT_STYLESHEET = \"apidiff.css\";\n+\n+    List<DocPath> getStylesheets() {\n+        DocPath resourceDir = new DocPath(\"resources\");\n+        List<DocPath> list = new ArrayList<>();\n+        if (options.getMainStylesheet() != null) {\n+            list.add(resourceDir.resolve(options.getMainStylesheet().getFileName().toString()));\n+        } else {\n+            list.add(resourceDir.resolve(DEFAULT_STYLESHEET));\n+        }\n+        for (Path extraStylesheet : options.getExtraStylesheets()) {\n+            list.add(resourceDir.resolve(extraStylesheet.getFileName().toString()));\n+        }\n+        return list;\n+    }\n+\n+    private void writeStylesheets() throws Abort {\n+        Path outResourceDir = outDir.resolve(\"resources\");\n+        try {\n+             Files.createDirectories(outResourceDir);\n+        } catch (IOException e) {\n+            log.error(\"report.err.cant-create-directory\", outResourceDir, e);\n+            throw new Abort();\n+        }\n+\n+        if (options.getMainStylesheet() != null) {\n+            copyFile(options.getMainStylesheet(), outResourceDir);\n+        } else {\n+            copyResource(DEFAULT_STYLESHEET, outResourceDir);\n+        }\n+        for (Path extraStylesheet : options.getExtraStylesheets()) {\n+            copyFile(extraStylesheet, outResourceDir);\n+        }\n+    }\n+\n+    private void writeResourceFiles() throws Abort {\n+        \/\/ in the following map, the key for each entry is the relative path\n+        \/\/ of a resource file to be written in the output directory, and the\n+        \/\/ associated value gives the location from which it should be copied.\n+        var map = new LinkedHashMap<Path, Path>();\n+\n+        for (var apiOpts : options.getAllAPIOptions().values()) {\n+            var apiDir = apiOpts.apiDir;\n+            if (apiDir != null) {\n+                listFiles(apiDir, this::isResourceFile)\n+                        .forEach(file -> map.put(apiDir.relativize(file), file));\n+                listFiles(apiDir.resolve(\"resource-files\"))\n+                        .forEach(file -> map.put(apiDir.relativize(file), file));\n+                var absApiDir = apiDir.toAbsolutePath().normalize();\n+                for (Path resFile : options.getResourceFiles()) {\n+                    \/\/ resFile may explicitly begin with a specific API directory,\n+                    \/\/ or will be considered as relative to each of the API directories\n+                    Path absResFile = resFile.toAbsolutePath().normalize();\n+                    Path pathFromApiDir;\n+                    if (absResFile.startsWith(absApiDir)) {\n+                        pathFromApiDir = absApiDir.relativize(absResFile);\n+                    } else if (!resFile.isAbsolute()) {\n+                        pathFromApiDir = resFile;\n+                    } else {\n+                        \/\/ TODO: check during Options.validate\n+                        continue;\n+                    }\n+                    Path pathInApiDir = apiDir.resolve(pathFromApiDir);\n+                    if (Files.isDirectory(pathInApiDir)) {\n+                        listFiles(pathInApiDir)\n+                                .forEach(file -> map.put(apiDir.relativize(file), file));\n+                    } else if (Files.isRegularFile(pathInApiDir)) {\n+                        map.put(pathFromApiDir, pathInApiDir);\n+                    }\n+                }\n+            }\n+        }\n+\n+        map.forEach((to, from) -> copyFile(from, outDir.resolve(to)));\n+    }\n+\n+    private List<Path> listFiles(Path dir) {\n+        return listFiles(dir, p -> true);\n+    }\n+\n+    private List<Path> listFiles(Path dir, DirectoryStream.Filter<? super Path> filter) {\n+        if (Files.isDirectory(dir)) {\n+            var list = new ArrayList<Path>();\n+            try (var ds = Files.newDirectoryStream(dir, filter)) {\n+                for (Path p : ds) {\n+                    if (Files.isRegularFile(p)) {\n+                        list.add(p);\n+                    }\n+                }\n+                return list;\n+            } catch (IOException e) {\n+                log.error(\"report.err.error-finding-resource-files\", dir, e);\n+                throw new Abort();\n+            }\n+        } else {\n+            return List.of();\n+        }\n+    }\n+\n+    private boolean isResourceFile(Path file) {\n+        return file.getFileName().toString().endsWith(\".svg\");\n+\n+    }\n+\n+    \/\/ in this context: `resource` refers to a resource item in tool's jar file\n+    private void copyResource(String name, Path dir) throws Abort {\n+        Path toFile = dir.resolve(name);\n+        try (InputStream in = getClass().getResourceAsStream(\"resources\/\" + name)) {\n+            Files.copy(in, toFile, StandardCopyOption.REPLACE_EXISTING);\n+        } catch (IOException e) {\n+            log.error(\"report.err.error-writing-file\", toFile, e);\n+            throw new Abort();\n+        }\n+    }\n+\n+    private void copyFile(Path fromFile, Path to) {\n+        Path toFile = Files.isDirectory(to) ? to.resolve(fromFile.getFileName()) : to;\n+        try {\n+            Files.createDirectories(toFile.getParent());\n+            Files.copy(fromFile, toFile, StandardCopyOption.REPLACE_EXISTING);\n+        } catch (IOException e) {\n+            log.error(\"report.err.error-writing-file\", toFile, e);\n+            throw new Abort();\n+        }\n+    }\n+\n+    \/**\n+     * A visitor to determine the page reporter for any given element or position.\n+     *\/\n+    private static class PageVisitor\n+            implements Position.Visitor<PageReporter<?>, Void>,\n+                ElementKey.Visitor<PageReporter<?>, Void> {\n+        HtmlReporter parent;\n+\n+        PageVisitor(HtmlReporter parent) {\n+            this.parent = parent;\n+        }\n+\n+        \/\/ TODO: should remove entries from the map when no longer required.\n+        \/\/       when page has been completed, use pageReporters.values().removeIf(p -> p == pr)\n+        Map<ElementKey, PageReporter<?>> pageReporters = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public PageReporter<?> visitModuleElement(ModuleElementKey mek, Void _p) {\n+            return pageReporters.computeIfAbsent(mek, k -> new ModulePageReporter(parent, k));\n+        }\n+\n+        @Override\n+        public PageReporter<?> visitPackageElement(PackageElementKey pek, Void _p) {\n+            return pageReporters.computeIfAbsent(pek, k -> new PackagePageReporter(parent, k));\n+        }\n+\n+        @Override\n+        public PageReporter<?> visitTypeElement(TypeElementKey tek, Void _p) {\n+            return pageReporters.computeIfAbsent(tek, k -> new TypePageReporter(parent, k));\n+        }\n+\n+        @Override\n+        public PageReporter<?> visitExecutableElement(ExecutableElementKey k, Void _p) {\n+            return k.typeKey.accept(this, _p);\n+        }\n+\n+        @Override\n+        public PageReporter<?> visitVariableElement(VariableElementKey k, Void _p) {\n+            return k.typeKey.accept(this, _p);\n+        }\n+\n+        @Override\n+        public PageReporter<?> visitTypeParameterElement(ElementKey.TypeParameterElementKey k, Void _p) {\n+            return k.typeKey.accept(this, _p);\n+        }\n+\n+        @Override\n+        public PageReporter<?> visitElementPosition(ElementPosition kp, Void _p) {\n+            return kp.key.accept(this, _p);\n+        }\n+\n+        @Override\n+        public PageReporter<?> visitRelativePosition(RelativePosition<?> ip, Void _p) {\n+            return ip.parent.accept(this, _p);\n+        }\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/HtmlReporter.java","additions":421,"deletions":0,"binary":false,"changes":421,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report.html;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import jdk.codetools.apidiff.html.Content;\n+import jdk.codetools.apidiff.html.HtmlTree;\n+import jdk.codetools.apidiff.html.RawHtml;\n+import jdk.codetools.apidiff.html.TagName;\n+import jdk.codetools.apidiff.html.Text;\n+import jdk.codetools.apidiff.model.ElementKey;\n+\n+\/**\n+ * A page reporter to create a top-level index page.\n+ *\/\n+public class IndexPageReporter extends PageReporter<ElementKey> {\n+    final NotesTable notesTable;\n+\n+    IndexPageReporter(HtmlReporter parent) {\n+        super(parent);\n+        notesTable = new NotesTable(links);\n+    }\n+\n+    \/**\n+     * Returns the name to be used to link to this page in the nav bar.\n+     * @return the name\n+     *\/\n+    public String getName() {\n+        return msgs.getString(\"overview.name\");\n+    }\n+\n+    @Override\n+    protected HtmlTree buildPageContent() {\n+        return new HtmlTree(TagName.HTML, buildHead(), buildBody());\n+    }\n+\n+    @Override\n+    public String getTitle() {\n+        String t = getOptions().getTitle();\n+        return t != null ? t : msgs.getString(\"overview.title\");\n+    }\n+\n+    @Override\n+    protected Content buildSignature() {\n+        throw new Error();\n+    }\n+\n+    @Override\n+    protected HtmlTree buildBody() {\n+        HtmlTree body = HtmlTree.BODY().setClass(\"index\");\n+        body.add(buildHeader());\n+        HtmlTree main = HtmlTree.MAIN();\n+        main.add(buildPageHeading());\n+        main.add(buildSummary());\n+        main.add(buildEnclosedElements());\n+        main.add(buildNotes());\n+        main.add(buildResultTable());\n+        body.add(main);\n+        body.add(buildFooter());\n+        if (getOptions().getHiddenOption(\"show-debug-summary\") != null) {\n+            body.add(new DebugSummary().build());\n+        }\n+        return body;\n+    }\n+\n+    @Override\n+    protected Content buildPageHeading() {\n+        return HtmlTree.H1(Text.of(getTitle()));\n+    }\n+\n+    private List<Content> buildSummary() {\n+        List<Content> summary = new ArrayList<>();\n+        String d = getOptions().getDescription();\n+        if (d != null) {\n+            summary.add(new RawHtml(d));\n+        }\n+        summary.add(new HtmlTree(TagName.H2, Text.of(msgs.getString(\"overview.heading.apis\"))));\n+        summary.add(HtmlTree.UL(getOptions().getAllAPIOptions().values().stream()\n+                .map(a -> Text.of(a.label == null ? a.name : a.name + \": \" + a.label))\n+                .map(HtmlTree::LI)\n+                .collect(Collectors.toList())));\n+        return summary;\n+    }\n+\n+    @Override\n+    protected List<Content> buildEnclosedElements() {\n+        List<Content> list = new ArrayList<>();\n+        addEnclosedElements(list, \"heading.modules\", ek -> ek.kind == ElementKey.Kind.MODULE);\n+        \/\/ This case should only occur when modules are not being compared\n+        addEnclosedElements(list, \"heading.packages\", ek -> ek.kind == ElementKey.Kind.PACKAGE);\n+        \/\/ This case should only occur when modules are not being compared,\n+        \/\/ and some types are in the unnamed package.\n+        \/\/ TODO: should we handle the unnamed package better?\n+        addEnclosedElements(list, \"heading.types\", ek -> ek.kind == ElementKey.Kind.TYPE);\n+        return list;\n+    }\n+\n+    \/**\n+     * Builds the list of notes (if any).\n+     *\n+     * @return the list of notes.\n+     *\/\n+    protected Content buildNotes() {\n+        if (notesTable.isEmpty()) {\n+            return Content.empty;\n+        }\n+\n+        HtmlTree section = HtmlTree.SECTION(HtmlTree.H2(Text.of(msgs.getString(\"notes.heading\"))))\n+                .setClass(\"notes\");\n+        section.add(notesTable.toContent());\n+        return section;\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/IndexPageReporter.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report.html;\n+\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.type.PrimitiveType;\n+\n+import jdk.codetools.apidiff.html.Content;\n+import jdk.codetools.apidiff.html.HtmlTree;\n+import jdk.codetools.apidiff.html.Text;\n+\n+\/**\n+ * Constants for language keywords and reserved identifiers.\n+ *\/\n+public class Keywords {\n+    private Keywords() { }\n+\n+    public static final Content ABSTRACT = keyword(\"abstract\");\n+    public static final Content AT_INTERFACE = keyword(\"@interface\");\n+    public static final Content BOOLEAN = keyword(\"boolean\");\n+    public static final Content BYTE = keyword(\"byte\");\n+    public static final Content CHAR = keyword(\"char\");\n+    public static final Content CLASS = keyword(\"class\");\n+    public static final Content DEFAULT = keyword(\"default\");\n+    public static final Content DOUBLE = keyword(\"double\");\n+    public static final Content EXPORTS = keyword(\"exports\");\n+    public static final Content ENUM = keyword(\"enum\");\n+    public static final Content EXTENDS = keyword(\"extends\");\n+    public static final Content FALSE = keyword(\"false\");\n+    public static final Content FINAL = keyword(\"final\");\n+    public static final Content FLOAT = keyword(\"float\");\n+    public static final Content IMPLEMENTS = keyword(\"implements\");\n+    public static final Content INT = keyword(\"int\");\n+    public static final Content INTERFACE = keyword(\"interface\");\n+    public static final Content LONG = keyword(\"long\");\n+    public static final Content NATIVE = keyword(\"native\");\n+    public static final Content NON_SEALED = keyword(\"non-sealed\");\n+    public static final Content MODULE = keyword(\"module\");\n+    public static final Content OPEN = keyword(\"open\");\n+    public static final Content OPENS = keyword(\"opens\");\n+    public static final Content PACKAGE = keyword(\"package\");\n+    public static final Content PERMITS = keyword(\"permits\");\n+    public static final Content PRIVATE = keyword(\"private\");\n+    public static final Content PROTECTED = keyword(\"protected\");\n+    public static final Content PROVIDES = keyword(\"provides\");\n+    public static final Content PUBLIC = keyword(\"public\");\n+    public static final Content RECORD = keyword(\"record\");\n+    public static final Content REQUIRES = keyword(\"requires\");\n+    public static final Content SEALED = keyword(\"sealed\");\n+    public static final Content SHORT = keyword(\"short\");\n+    public static final Content STATIC = keyword(\"static\");\n+    public static final Content STRICTFP = keyword(\"strictfp\");\n+    public static final Content SUPER = keyword(\"super\");\n+    public static final Content SYNCHRONIZED = keyword(\"synchronized\");\n+    public static final Content THROWS = keyword(\"throws\");\n+    public static final Content TO = keyword(\"to\");\n+    public static final Content TRANSIENT = keyword(\"transient\");\n+    public static final Content TRANSITIVE = keyword(\"transitive\");\n+    public static final Content TRUE = keyword(\"true\");\n+    public static final Content USES = keyword(\"uses\");\n+    public static final Content VOID = keyword(\"void\");\n+    public static final Content VOLATILE = keyword(\"volatile\");\n+    public static final Content WITH = keyword(\"with\");\n+\n+    \/**\n+     * Returns the keyword for a boolean value.\n+     *\n+     * @param b the value\n+     * @return the keyword\n+     *\/\n+    public static Content of(boolean b) {\n+        return b ? TRUE : FALSE;\n+    }\n+\n+    \/**\n+     * Returns the keyword for a modifier.\n+     *\n+     * @param m the modifier\n+     * @return the keyword\n+     *\/\n+    public static Content of(Modifier m) {\n+        return switch (m) {\n+            case ABSTRACT -> ABSTRACT;\n+            case DEFAULT -> DEFAULT;\n+            case FINAL -> FINAL;\n+            case NATIVE -> NATIVE;\n+            case NON_SEALED -> NON_SEALED;\n+            case PRIVATE -> PRIVATE;\n+            case PROTECTED -> PROTECTED;\n+            case PUBLIC -> PUBLIC;\n+            case SEALED -> SEALED;\n+            case STATIC -> STATIC;\n+            case STRICTFP -> STRICTFP;\n+            case SYNCHRONIZED -> SYNCHRONIZED;\n+            case TRANSIENT -> TRANSIENT;\n+            case VOLATILE -> VOLATILE;\n+        };\n+    }\n+\n+    \/**\n+     * Returns the keyword for a primitive type.\n+     *\n+     * @param t the type\n+     * @return the keyword\n+     *\/\n+    public static Content of(PrimitiveType t) {\n+        return switch (t.getKind()) {\n+            case BOOLEAN -> BOOLEAN;\n+            case BYTE -> BYTE;\n+            case CHAR -> CHAR;\n+            case DOUBLE -> DOUBLE;\n+            case FLOAT -> FLOAT;\n+            case INT -> INT;\n+            case LONG -> LONG;\n+            case SHORT -> SHORT;\n+            default -> throw new IllegalArgumentException((t.toString()));\n+        };\n+    }\n+\n+    \/**\n+     * Returns the keyword for the kind of a type element.\n+     *\n+     * @param k the kind\n+     * @return the keyword\n+     *\/\n+    public static Content of(ElementKind k) {\n+        switch (k) {\n+            case ANNOTATION_TYPE:\n+                return AT_INTERFACE;\n+            case CLASS:\n+                return CLASS;\n+            case ENUM:\n+                return ENUM;\n+            case INTERFACE:\n+                return INTERFACE;\n+            default:\n+                if (k.name().equals(\"RECORD\")) {\n+                    return RECORD;\n+                }\n+                throw new IllegalArgumentException((k.toString()));\n+        }\n+    }\n+\n+    private static Content keyword(String name) {\n+        return HtmlTree.SPAN(Text.of(name)).setClass(\"keyword\");\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/Keywords.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report.html;\n+\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import jdk.codetools.apidiff.html.HtmlTree;\n+import jdk.codetools.apidiff.html.Text;\n+import jdk.codetools.apidiff.model.ElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.ExecutableElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.ModuleElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.PackageElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.TypeElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.TypeParameterElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.VariableElementKey;\n+import jdk.codetools.apidiff.model.Position;\n+import jdk.codetools.apidiff.model.Position.RelativePosition;\n+import jdk.codetools.apidiff.model.TypeMirrorKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.ArrayTypeKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.DeclaredTypeKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.PrimitiveTypeKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.TypeVariableKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.WildcardTypeKey;\n+\n+\/**\n+ * Factory for links within the generated report.\n+ *\/\n+public class Links {\n+    private GetFileVisitor getFile = new GetFileVisitor();\n+    private final DocPath file;\n+    private final DocPath pathToRoot;\n+\n+    Links(DocPath file) {\n+        this.file = file;\n+        pathToRoot = file.parent().invert();\n+    }\n+\n+    DocPath getPath(String path) {\n+        return pathToRoot.resolve(path);\n+    }\n+\n+    DocPath getPath(DocPath path) {\n+        return pathToRoot.resolve(path);\n+    }\n+\n+    HtmlTree createLink(ElementKey key) {\n+        return createLink(key, getName(key));\n+    }\n+\n+    HtmlTree createLink(ElementKey key, CharSequence name) {\n+        DocPath keyPath = getFile.getFile(key);\n+        String id = idVisitor.getId(key);\n+        DocLink keyLink = new DocLink(pathToRoot.resolve(keyPath), null, id);\n+\n+        return HtmlTree.A(keyLink.toString(), Text.of(name));\n+    }\n+\n+    private CharSequence getName(ElementKey eKey) {\n+        return switch (eKey.kind) {\n+            case MODULE -> ((ModuleElementKey) eKey).name;\n+            case PACKAGE -> ((PackageElementKey) eKey).name;\n+            case TYPE -> ((TypeElementKey) eKey).name;\n+            default -> throw new IllegalArgumentException(eKey.toString());\n+        };\n+    }\n+\n+    String getId(Position pos) {\n+        if (pos.isElement()) {\n+            return getId(pos.asElementKey());\n+        } else if (pos.isRelative()) {\n+            RelativePosition<?> rPos = (RelativePosition<?>) pos;\n+            switch (rPos.kind) {\n+                case SERIALIZED_FIELD:\n+                    return \"serial-field-\" + rPos.index;\n+                case SERIALIZATION_METHOD:\n+                    return \"serial-method-\" + rPos.index;\n+            }\n+        }\n+        throw new IllegalArgumentException(pos.toString());\n+    }\n+\n+    String getId(ElementKey eKey) {\n+        return idVisitor.getId(eKey);\n+    }\n+\n+    private final IdVisitor idVisitor = new IdVisitor();\n+\n+    private class IdVisitor\n+            implements ElementKey.Visitor<CharSequence, Void>,\n+            TypeMirrorKey.Visitor<CharSequence, Void> {\n+\n+        String getId(ElementKey eKey) {\n+            CharSequence cs = eKey.accept(this, null);\n+            return (cs == null) ? null : cs.toString();\n+        }\n+\n+        @Override\n+        public CharSequence visitModuleElement(ModuleElementKey mKey, Void aVoid) {\n+            return null;\n+        }\n+\n+        @Override\n+        public CharSequence visitPackageElement(PackageElementKey pKey, Void aVoid) {\n+            return null;\n+        }\n+\n+        @Override\n+        public CharSequence visitTypeElement(TypeElementKey tKey, Void aVoid) {\n+            return null;\n+        }\n+\n+        @Override\n+        public CharSequence visitExecutableElement(ExecutableElementKey k, Void aVoid) {\n+            return k.name + k.params.stream()\n+                    .map(this::toString)\n+                    .collect(Collectors.joining(\",\", \"(\", \")\"));\n+        }\n+\n+        @Override\n+        public CharSequence visitVariableElement(VariableElementKey k, Void aVoid) {\n+            return k.name;\n+        }\n+\n+        @Override\n+        public CharSequence visitTypeParameterElement(TypeParameterElementKey k, Void aVoid) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        String toString(TypeMirrorKey eKey) {\n+            return eKey.accept(this, null).toString();\n+        }\n+\n+        @Override\n+        public CharSequence visitArrayType(ArrayTypeKey k, Void aVoid) {\n+            return toString(k.componentKey) + \"[]\";\n+        }\n+\n+        @Override\n+        public CharSequence visitDeclaredType(DeclaredTypeKey k, Void aVoid) {\n+            ElementKey eKey = k.elementKey;\n+            return switch (eKey.kind) {\n+                case TYPE -> ((TypeElementKey) eKey).name;\n+                case TYPE_PARAMETER -> ((TypeParameterElementKey) eKey).name;\n+                default -> throw new UnsupportedOperationException();\n+            };\n+        }\n+\n+        @Override\n+        public CharSequence visitPrimitiveType(PrimitiveTypeKey k, Void aVoid) {\n+            return k.kind.name().toLowerCase(Locale.ROOT);\n+        }\n+\n+        @Override\n+        public CharSequence visitTypeVariable(TypeVariableKey k, Void aVoid) {\n+            return k.name;\n+        }\n+\n+        @Override\n+        public CharSequence visitWildcardType(WildcardTypeKey k, Void aVoid) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/Links.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,347 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report.html;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.ModuleElement.Directive;\n+import javax.lang.model.element.ModuleElement.ExportsDirective;\n+import javax.lang.model.element.ModuleElement.OpensDirective;\n+import javax.lang.model.element.ModuleElement.ProvidesDirective;\n+import javax.lang.model.element.ModuleElement.RequiresDirective;\n+import javax.lang.model.element.ModuleElement.UsesDirective;\n+import javax.lang.model.element.PackageElement;\n+\n+import jdk.codetools.apidiff.html.Content;\n+import jdk.codetools.apidiff.html.Entity;\n+import jdk.codetools.apidiff.html.HtmlTree;\n+import jdk.codetools.apidiff.html.Text;\n+import jdk.codetools.apidiff.model.API;\n+import jdk.codetools.apidiff.model.APIMap;\n+import jdk.codetools.apidiff.model.ElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.ModuleElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.PackageElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.TypeElementKey;\n+import jdk.codetools.apidiff.model.Position;\n+import jdk.codetools.apidiff.model.Position.RelativePosition;\n+\n+\/**\n+ * A reporter that generates an HTML page for the differences in\n+ * a module declaration.\n+ *\/\n+class ModulePageReporter extends PageReporter<ModuleElementKey> {\n+    APIMap<? extends Element> mMap = null;\n+    private final boolean allDirectiveDetails;\n+\n+    ModulePageReporter(HtmlReporter parent, ElementKey mKey) {\n+        super(parent, (ModuleElementKey) mKey);\n+\n+        allDirectiveDetails = parent.options.getAccessKind().allModuleDetails();\n+    }\n+\n+    @Override\n+    protected String getTitle() {\n+        return \"module \" + pageKey.name;\n+    }\n+\n+    @Override\n+    protected Content buildSignature() {\n+        List<Content> contents = new ArrayList<>();\n+        contents.addAll(buildAnnotations(Position.of(pageKey)));\n+        contents.add(buildModifiers());\n+        contents.add(Text.SPACE);\n+        contents.add(Keywords.MODULE);\n+        contents.add(Text.SPACE);\n+        contents.add(Text.of(pageKey.name));\n+        return HtmlTree.DIV(contents).setClass(\"signature\");\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void comparing(Position pos, APIMap<?> apiMap) {\n+        super.comparing(pos, apiMap);\n+        if (pos.isElement()) {\n+            this.mMap = (APIMap<? extends Element>) apiMap;\n+        }\n+    }\n+\n+\/\/ TODO: check if required\n+\/\/    \/**\n+\/\/     * Writes a page containing details for a single module element in a given API.\n+\/\/     *\n+\/\/     * @param api the API containing the element\n+\/\/     * @param mdle the module element\n+\/\/     *\/\n+\/\/    void writeFile(API api, ModuleElement mdle) {\n+\/\/        Position pagePos = Position.of(pageKey);\n+\/\/        APIMap<ModuleElement> apiMap = APIMap.of(api, mdle);\n+\/\/        comparing(pagePos, apiMap);\n+\/\/        parent.apis.stream()\n+\/\/                .filter(a -> a != api)\n+\/\/                .forEach(a -> reportMissing(pagePos, a));\n+\/\/        completed(pagePos, true);\n+\/\/    }\n+\n+    @Override\n+    protected void writeFile() {\n+        \/\/ If this is the only copy of the module in the APIs being compared,\n+        \/\/ its enclosed elements will not have been compared or reported, and\n+        \/\/ so will not be written out as a side effect of reporting the\n+        \/\/ comparison.  So, write the files for the enclosed packages now.\n+        if (mMap.size() == 1) {\n+            Map.Entry<API, ? extends Element> e = mMap.entrySet().iterator().next();\n+            API api = e.getKey();\n+            ModuleElement mdle = (ModuleElement) e.getValue();\n+            for (PackageElement pkg : api.getPackageElements(mdle)) {\n+                PackagePageReporter r = (PackagePageReporter) parent.getPageReporter(ElementKey.of(pkg));\n+                r.writeFile(api, pkg);\n+            }\n+        }\n+\n+        super.writeFile();\n+    }\n+\n+    private Content buildModifiers() {\n+        Position pos = Position.of(pageKey);\n+        if (differentModifiers.containsKey(pos)) {\n+            return new DiffBuilder().build(mMap,\n+                    me -> ((ModuleElement) me).isOpen() ? Keywords.OPEN : Entity.NBSP);\n+        } else {\n+            ModuleElement me = (ModuleElement) mMap.values().iterator().next();\n+            return me.isOpen() ? Keywords.OPEN : Content.empty;\n+        }\n+    }\n+\n+    @Override\n+    protected List<Content> buildEnclosedElements() {\n+        List<Content> list = new ArrayList<>();\n+        addDirectives(list, \"heading.exports\", rp -> rp.kind == RelativePosition.Kind.MODULE_EXPORTS, this::buildExports);\n+        addDirectives(list, \"heading.opens\", rp -> rp.kind == RelativePosition.Kind.MODULE_OPENS, this::buildOpens);\n+        addDirectives(list, \"heading.requires\", rp -> rp.kind == RelativePosition.Kind.MODULE_REQUIRES, this::buildRequires);\n+        addDirectives(list, \"heading.provides\", rp -> rp.kind == RelativePosition.Kind.MODULE_PROVIDES, this::buildProvides);\n+        addDirectives(list, \"heading.uses\", rp -> rp.kind == RelativePosition.Kind.MODULE_USES, this::buildUses);\n+        addEnclosedElements(list, \"heading.packages\", ek -> ek.kind == ElementKey.Kind.PACKAGE);\n+        addDocFiles(list);\n+        return list;\n+    }\n+\n+    private <T> void addDirectives(List<Content> contents,\n+                               String headingKey,\n+                               Predicate<RelativePosition<?>> filter,\n+                               BiFunction<RelativePosition<?>, APIMap<T>, Content> f) {\n+        Map<RelativePosition<?>, APIMap<T>> dMaps = new TreeMap<>(RelativePosition.elementKeyIndexComparator);\n+        \/\/ apiMaps will only contain maps for directives which should be compared and displayed;\n+        \/\/ i.e. they have already been filtered according to accessKind.allDirectiveDetails\n+        for (Map.Entry<Position, APIMap<?>> e : apiMaps.entrySet()) {\n+            Position p = e.getKey();\n+            if (p instanceof RelativePosition) {\n+                RelativePosition<?> rp = (RelativePosition<?>) p;\n+                if (filter.test((RelativePosition<?>) p)) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    APIMap<T> dMap = (APIMap<T>) e.getValue();\n+                    dMaps.put(rp, dMap);\n+                }\n+            }\n+        }\n+\n+        if (!dMaps.isEmpty()) {\n+            HtmlTree section = HtmlTree.SECTION().setClass(\"enclosed\");\n+            section.add(HtmlTree.H2(Text.of(msgs.getString(headingKey))));\n+            HtmlTree ul = HtmlTree.UL();\n+            dMaps.forEach((rp, apiMap) -> ul.add(HtmlTree.LI(f.apply(rp, apiMap))));\n+            section.add(ul);\n+            contents.add(section);\n+        }\n+    }\n+\n+    private Content buildExports(RelativePosition<?> rPos, APIMap<ExportsDirective> apiMap) {\n+        return buildExportsOpensProvides(rPos, apiMap, Keywords.EXPORTS, Keywords.TO,\n+                ExportsDirective::getPackage, ExportsDirective::getTargetModules);\n+    }\n+\n+    private Content buildOpens(RelativePosition<?> rPos, APIMap<OpensDirective> apiMap) {\n+        return buildExportsOpensProvides(rPos, apiMap, Keywords.OPENS, Keywords.TO,\n+                OpensDirective::getPackage, OpensDirective::getTargetModules);\n+    }\n+\n+    private Content buildProvides(RelativePosition<?> rPos, APIMap<ProvidesDirective> apiMap) {\n+        \/\/ ProvidesDirective is unusual in that part of it (i.e. the implementations)\n+        \/\/ is not part of the public API, and should only be displayed if allDirectiveDetails\n+        \/\/ is true.\n+        return buildExportsOpensProvides(rPos, apiMap, Keywords.PROVIDES, Keywords.WITH,\n+                ProvidesDirective::getService,\n+                pd -> allDirectiveDetails ? pd.getImplementations() : Collections.emptyList());\n+    }\n+\n+    private Content buildUses(RelativePosition<?> rPos, APIMap<UsesDirective> apiMap) {\n+        return buildExportsOpensProvides(rPos, apiMap, Keywords.USES, Content.empty,\n+                UsesDirective::getService, d -> Collections.emptyList());\n+    }\n+\n+    private <T extends Directive, U extends Element, V extends Element>\n+    Content buildExportsOpensProvides(RelativePosition<?> rPos, APIMap<T> apiMap,\n+                                      Content directiveKeyword, Content sublistKeyword,\n+                                      Function<T, U> getPrimaryElement,\n+                                      Function<T, List<V>> getSecondaryElements) {\n+        List<Content> contents = new ArrayList<>();\n+\n+        contents.add(directiveKeyword);\n+        contents.add(Text.SPACE);\n+\n+        T archetype = apiMap.values().stream().filter(Objects::nonNull).findFirst().orElseThrow();\n+        contents.add(getName(ElementKey.of(getPrimaryElement.apply(archetype))));\n+\n+        APIMap<Set<ElementKey>> targetKeys = APIMap.of();\n+        Set<ElementKey> allTargetKeys = new TreeSet<>();\n+        apiMap.forEach((api, d) -> {\n+            List<V> targets = getSecondaryElements.apply(d);\n+            if (targets != null) {\n+                Set<ElementKey> s = targets.stream()\n+                        .map(ElementKey::of)\n+                        .collect(Collectors.toCollection(TreeSet::new));\n+                targetKeys.put(api, s);\n+                allTargetKeys.addAll(s);\n+            }\n+        });\n+\n+        if (!allTargetKeys.isEmpty()) {\n+            contents.add(Text.SPACE);\n+            contents.add(sublistKeyword);\n+            contents.add(Text.SPACE);\n+            boolean first = true;\n+            for (ElementKey ek : allTargetKeys) {\n+                if (first) {\n+                    first = false;\n+                } else {\n+                    contents.add(Text.of(\", \"));\n+                }\n+                boolean allMatch = targetKeys.values().stream().allMatch(s -> s.contains(ek));\n+                if (allMatch) {\n+                    contents.add(getName(ek));\n+                } else {\n+                    APIMap<Content> map = APIMap.of();\n+                    targetKeys.forEach((api, set) -> map.put(api, set.contains(ek) ? getName(ek) : Entity.NBSP));\n+                    contents.add(new DiffBuilder().build(map));\n+                }\n+            }\n+        }\n+\n+\n+        \/\/ TODO: for now, this is stylistically similar to buildEnclosedElement,\n+        \/\/       but arguably a better way would be to move code for the check or cross into\n+        \/\/       the enclosing loop that builds the list.\n+        return HtmlTree.SPAN(getResultGlyph(rPos), Text.SPACE)\n+                .add(HtmlTree.SPAN(contents).setClass(\"signature\"));\n+\n+    }\n+\n+    private Content getName(ElementKey ek) {\n+        return Text.of(getQualifiedName(ek));\n+    }\n+\n+    private CharSequence getQualifiedName(ElementKey ek) {\n+        switch (ek.kind) {\n+            case MODULE:\n+                return ((ModuleElementKey) ek).name;\n+            case PACKAGE:\n+                return ((PackageElementKey) ek).name;\n+            case TYPE:\n+                TypeElementKey tek = (TypeElementKey) ek;\n+                return tek.enclosingKey == null ? tek.name : getQualifiedName(tek.enclosingKey) + \".\" + tek.name;\n+            default:\n+                throw new IllegalArgumentException((ek.toString()));\n+        }\n+    }\n+\n+    private Content buildRequires(RelativePosition<?> rPos, APIMap<RequiresDirective> apiMap) {\n+        List<Content> contents = new ArrayList<>();\n+\n+        contents.add(Keywords.REQUIRES);\n+        contents.add(Text.SPACE);\n+\n+        \/\/ TODO: would this be a useful method on APIMap?\n+        RequiresDirective archetype = apiMap.values().stream()\n+                .filter(Objects::nonNull)\n+                .findFirst()\n+                .orElseThrow();\n+\n+        boolean allStaticEqual = apiMap.values().stream()\n+                .allMatch(rd -> rd != null && rd.isStatic() == archetype.isStatic());\n+        if (allStaticEqual) {\n+            if (archetype.isStatic()) {\n+                contents.add(Keywords.STATIC);\n+                contents.add(Text.SPACE);\n+            }\n+        } else {\n+            APIMap<Content> alternatives = APIMap.of();\n+            apiMap.forEach((api, rd) -> {\n+                Content kw = rd != null && rd.isStatic() ? Keywords.STATIC : Entity.NBSP;\n+                alternatives.put(api, kw);\n+            });\n+            contents.add(new DiffBuilder().build(alternatives));\n+            contents.add(Text.SPACE);\n+        }\n+\n+        boolean allTransitiveEqual = apiMap.values().stream()\n+                .allMatch(rd -> rd != null && rd.isTransitive() == archetype.isTransitive());\n+        if (allTransitiveEqual) {\n+            if (archetype.isTransitive()) {\n+                contents.add(Keywords.TRANSITIVE);\n+                contents.add(Text.SPACE);\n+            }\n+        } else {\n+            APIMap<Content> alternatives = APIMap.of();\n+            apiMap.forEach((api, rd) -> {\n+                Content kw = rd != null && rd.isTransitive() ? Keywords.TRANSITIVE : Entity.NBSP;\n+                alternatives.put(api, kw);\n+            });\n+            contents.add(new DiffBuilder().build(alternatives));\n+            contents.add(Text.SPACE);\n+        }\n+\n+        \/\/ TODO: would be nice to link to the module page if it can be determined to be available.\n+        contents.add(Text.of(archetype.getDependency().getQualifiedName()));\n+\n+\n+        \/\/ TODO: for now, this is stylistically similar to buildEnclosedElement,\n+        \/\/       but arguably a better way would be to move code for the check or cross into\n+        \/\/       the enclosing loop that builds the list.\n+        return HtmlTree.SPAN(getResultGlyph(rPos), Text.SPACE)\n+                .add(HtmlTree.SPAN(contents).setClass(\"signature\"));\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/ModulePageReporter.java","additions":347,"deletions":0,"binary":false,"changes":347,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report.html;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import jdk.codetools.apidiff.Notes;\n+import jdk.codetools.apidiff.html.Content;\n+import jdk.codetools.apidiff.html.HtmlTree;\n+import jdk.codetools.apidiff.html.Text;\n+import jdk.codetools.apidiff.model.ElementKey;\n+\n+\/**\n+ * A table recording the elements associated with each note.\n+ *\/\n+public class NotesTable {\n+    private final Map<Notes.Entry, List<ElementKey>> table;\n+    private final Links links;\n+\n+    \/**\n+     * Creates a table to record the elements associated with each note.\n+     *\n+     * @param links a factory to generate links to the associated elements\n+     *\/\n+    NotesTable(Links links) {\n+        table = new TreeMap<>(Comparator.comparing((Notes.Entry e) -> e.description));\n+        this.links = links;\n+    }\n+\n+    \/**\n+     * Returns whether the table is empty.\n+     *\n+     * @return {@code true} if and only if the table is empty\n+     *\/\n+    boolean isEmpty() {\n+        return table.isEmpty();\n+    }\n+\n+    \/**\n+     * Add an association for an element key with a note.\n+     *\n+     * @param e    the note\n+     * @param eKey the element key\n+     *\/\n+    void add(Notes.Entry e, ElementKey eKey) {\n+        table.computeIfAbsent(e, e_ -> new ArrayList<>()).add(eKey);\n+    }\n+\n+    \/**\n+     * Generates HTML content representing the contents of the table.\n+     *\n+     * @return the content\n+     *\/\n+    Content toContent() {\n+        if (table.isEmpty()) {\n+            return Content.empty;\n+        }\n+\n+        HtmlTree dl = HtmlTree.DL();\n+        table.forEach((e, list) -> add(dl, e, list));\n+\n+        return dl;\n+    }\n+\n+    private void add(HtmlTree dl, Notes.Entry e, List<ElementKey> list) {\n+        HtmlTree eLink = HtmlTree.A(e.uri, Text.of(e.description));\n+        dl.add(HtmlTree.DT(eLink));\n+\n+        \/\/ TODO: sort list?\n+\n+        HtmlTree dd = HtmlTree.DD();\n+        boolean first = true;\n+        for (ElementKey eKey : list) {\n+            if (first) {\n+                first = false;\n+            } else {\n+                dd.add(Text.of(\", \"));\n+            }\n+            dd.add(toContent(eKey));\n+        }\n+        dl.add(dd);\n+    }\n+\n+    private Content toContent(ElementKey eKey) {\n+        return links.createLink(eKey, Notes.getName(eKey).replace(\"#\", \".\"));\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/NotesTable.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report.html;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.util.ElementFilter;\n+\n+import jdk.codetools.apidiff.html.Content;\n+import jdk.codetools.apidiff.html.HtmlTree;\n+import jdk.codetools.apidiff.html.Text;\n+import jdk.codetools.apidiff.model.API;\n+import jdk.codetools.apidiff.model.APIMap;\n+import jdk.codetools.apidiff.model.AccessKind;\n+import jdk.codetools.apidiff.model.ElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.ModuleElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.PackageElementKey;\n+import jdk.codetools.apidiff.model.Position;\n+\n+\/**\n+ * A reporter that generates an HTML page for the differences in\n+ * a package declaration.\n+ *\/\n+class PackagePageReporter extends PageReporter<PackageElementKey> {\n+\n+    PackagePageReporter(HtmlReporter parent, ElementKey pKey) {\n+        super(parent, (PackageElementKey) pKey);\n+    }\n+\n+    \/**\n+     * Writes a page containing details for a single package element in a given API.\n+     *\n+     * @param api the API containing the element\n+     * @param pkg the package element\n+     *\/\n+    void writeFile(API api, PackageElement pkg) {\n+        Position pagePos = Position.of(pageKey);\n+        APIMap<PackageElement> apiMap = APIMap.of(api, pkg);\n+        comparing(pagePos, apiMap);\n+        Set<API> missing = parent.apis.stream()\n+                .filter(a -> a != api)\n+                .collect(Collectors.toSet());\n+        if (!missing.isEmpty()) {\n+            reportMissing(pagePos, missing);\n+        }\n+        completed(pagePos, true);\n+    }\n+\n+    @Override\n+    protected void writeFile() {\n+        \/\/ If this is the only copy of the package in the APIs being compared,\n+        \/\/ its enclosed elements will not have been compared or reported, and\n+        \/\/ so will not be written out as a side effect of reporting the\n+        \/\/ comparison.  So, write the files for the enclosed classes and\n+        \/\/ interfaces now.\n+        APIMap<? extends Element> pMap = getElementMap(pageKey);\n+        if (pMap.size() == 1) {\n+            AccessKind accessKind = parent.options.getAccessKind();\n+            Map.Entry<API, ? extends Element> e = pMap.entrySet().iterator().next();\n+            API api = e.getKey();\n+            PackageElement pkg = (PackageElement) e.getValue();\n+            for (TypeElement te : ElementFilter.typesIn(pkg.getEnclosedElements())) {\n+                if (!accessKind.accepts(te)) {\n+                    continue;\n+                }\n+                TypePageReporter r = (TypePageReporter) parent.getPageReporter(ElementKey.of(te));\n+                r.writeFile(api, te);\n+            }\n+        }\n+\n+        super.writeFile();\n+    }\n+\n+    @Override\n+    protected String getTitle() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"package \");\n+        if (pageKey.moduleKey != null) {\n+            ModuleElementKey mKey = (ModuleElementKey) pageKey.moduleKey;\n+            sb.append(mKey.name).append(\"\/\");\n+        }\n+        sb.append(pageKey.name);\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    protected Content buildSignature() {\n+        List<Content> contents = new ArrayList<>();\n+        contents.addAll(buildAnnotations(Position.of(pageKey)));\n+        contents.add(Keywords.PACKAGE);\n+        contents.add(Text.SPACE);\n+        contents.add(Text.of(pageKey.name));\n+        return HtmlTree.DIV(contents).setClass(\"signature\");\n+    }\n+\n+    @Override\n+    protected List<Content> buildEnclosedElements() {\n+        List<Content> list = new ArrayList<>();\n+        addEnclosedElements(list, \"heading.types\", ek -> ek.kind == ElementKey.Kind.TYPE);\n+        addDocFiles(list);\n+        return list;\n+    }\n+\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/PackagePageReporter.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,1553 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report.html;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ElementVisitor;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement.Directive;\n+import javax.lang.model.element.Name;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.type.ArrayType;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.NoType;\n+import javax.lang.model.type.PrimitiveType;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.type.TypeVariable;\n+import javax.lang.model.type.WildcardType;\n+import javax.lang.model.util.SimpleElementVisitor14;\n+import javax.lang.model.util.SimpleTypeVisitor14;\n+import javax.tools.JavaFileObject;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTree;\n+import jdk.codetools.apidiff.Abort;\n+import jdk.codetools.apidiff.Log;\n+import jdk.codetools.apidiff.Messages;\n+import jdk.codetools.apidiff.Notes;\n+import jdk.codetools.apidiff.Options;\n+import jdk.codetools.apidiff.Options.InfoTextKind;\n+import jdk.codetools.apidiff.html.Content;\n+import jdk.codetools.apidiff.html.Entity;\n+import jdk.codetools.apidiff.html.HtmlAttr;\n+import jdk.codetools.apidiff.html.HtmlTree;\n+import jdk.codetools.apidiff.html.RawHtml;\n+import jdk.codetools.apidiff.html.TagName;\n+import jdk.codetools.apidiff.html.Text;\n+import jdk.codetools.apidiff.model.API;\n+import jdk.codetools.apidiff.model.API.LocationKind;\n+import jdk.codetools.apidiff.model.APIMap;\n+import jdk.codetools.apidiff.model.DocFile;\n+import jdk.codetools.apidiff.model.ElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.ExecutableElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.MemberElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.ModuleElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.PackageElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.TypeElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.TypeParameterElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.VariableElementKey;\n+import jdk.codetools.apidiff.model.Position;\n+import jdk.codetools.apidiff.model.Position.ElementPosition;\n+import jdk.codetools.apidiff.model.Position.RelativePosition;\n+import jdk.codetools.apidiff.model.SerializedForm;\n+import jdk.codetools.apidiff.model.SerializedFormDocs;\n+import jdk.codetools.apidiff.report.Reporter;\n+import jdk.codetools.apidiff.report.SignatureVisitor;\n+import jdk.codetools.apidiff.report.html.ResultTable.CountKind;\n+\n+\/**\n+ * Base class for reporters handling the different pages of an HTML report.\n+ *\/\n+abstract class PageReporter<K extends ElementKey> implements Reporter {\n+\n+    \/** The enclosing HTML reporter. *\/\n+    protected final HtmlReporter parent;\n+\n+    \/** The log to which to report diagnostics. *\/\n+    protected final Log log;\n+\n+    \/** The element key for the page. *\/\n+    protected final K pageKey;\n+\n+    \/** The file for the page. *\/\n+    protected final DocPath file;\n+\n+    \/** A utility class to generate links to other pages. *\/\n+    protected final Links links;\n+\n+    protected final Messages msgs;\n+\n+    \/\/ The following collections accumulate the results reported with _report..._ methods.\n+    \/\/ TODO: the methods that put items into these maps should check they are not\n+    \/\/       overwriting any existing information\n+\n+    protected Map<Position, Set<API>> missing;\n+    protected Map<Position, APIMap<? extends AnnotationMirror>> differentAnnotations;\n+    protected Map<Position, APIMap<? extends AnnotationValue>> differentAnnotationValues;\n+    protected Map<Position, APIMap<? extends Directive>> differentDirectives;\n+    protected Map<Position, APIMap<? extends Element>> differentModifiers;\n+    protected Map<Position, APIMap<? extends Element>> differentKinds;\n+    protected Map<Position, APIMap<? extends TypeParameterElement>> differentTypeParameters;\n+    protected Map<Position, APIMap<? extends TypeMirror>> differentTypes;\n+    protected Map<Position, APIMap<List<? extends TypeMirror>>> differentThrownTypes;\n+    protected Map<Position, APIMap<List<? extends TypeMirror>>> differentSuperinterfaces;\n+    protected Map<Position, APIMap<List<? extends TypeMirror>>> differentPermittedSubclasses;\n+    protected Map<Position, APIMap<?>> differentValues;\n+    protected Map<Position, APIMap<String>> differentRawDocComments;\n+    protected Map<Position, APIMap<String>> differentApiDescriptions;\n+    protected Map<Position, APIMap<DocFile>> differentDocFiles;\n+\n+    \/** The API maps for the items on this page. *\/\n+    protected final Map<Position, APIMap<?>> apiMaps;\n+\n+    \/** The comparison results for the items on this page. *\/\n+    protected final Map<Position, Boolean> results;\n+\n+    protected final ResultTable resultTable;\n+\n+    protected PageReporter(HtmlReporter parent) {\n+        this(parent, null, new DocPath(\"index.html\"));\n+    }\n+\n+    protected PageReporter(HtmlReporter parent, K eKey) {\n+        this(parent, eKey, new GetFileVisitor().getFile(eKey));\n+    }\n+\n+    private PageReporter(HtmlReporter parent, K eKey, DocPath file) {\n+        this.parent = parent;\n+        this.pageKey = eKey;\n+        this.file = file;\n+\n+        log = Objects.requireNonNull(parent.log);\n+        msgs = Objects.requireNonNull(parent.msgs);\n+        links = new Links(file);\n+        resultTable = new ResultTable(msgs, links);\n+\n+        missing = Collections.emptyMap();\n+        differentAnnotations = Collections.emptyMap();\n+        differentAnnotationValues = Collections.emptyMap();\n+        differentDirectives = Collections.emptyMap();\n+        differentModifiers = Collections.emptyMap();\n+        differentKinds = Collections.emptyMap();\n+        differentTypes = Collections.emptyMap();\n+        differentTypeParameters = Collections.emptyMap();\n+        differentThrownTypes = Collections.emptyMap();\n+        differentSuperinterfaces = Collections.emptyMap();\n+        differentPermittedSubclasses = Collections.emptyMap();\n+        differentValues = Collections.emptyMap();\n+        differentRawDocComments = Collections.emptyMap();\n+        differentApiDescriptions = Collections.emptyMap();\n+        differentDocFiles = Collections.emptyMap();\n+\n+        apiMaps = new HashMap<>();\n+        results = new HashMap<>();\n+    }\n+\n+    \/\/<editor-fold desc=\"Implements Reporter\">\n+\n+    @Override\n+    public void comparing(Position pos, APIMap<?> apiMap) {\n+        apiMaps.put(pos, apiMap);\n+    }\n+\n+    @Override\n+    public void completed(Position ePos, boolean equal) {\n+        results.put(ePos, equal);\n+        if (ePos.isElement()) {\n+            ElementKey eKey = ePos.asElementKey();\n+            if (eKey == pageKey) {\n+                writeFile();\n+                ElementKey enclKey = eKey.getEnclosingKey();\n+                PageReporter<?> enclPage = parent.getPageReporter(enclKey);\n+                enclPage.completed(ePos, equal);\n+                enclPage.resultTable.addAll(pageKey, resultTable.getTotals());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void reportMissing(Position ePos, Set<API> apis) {\n+        if (missing.isEmpty()) {\n+            missing = new HashMap<>();\n+        }\n+        missing.put(ePos, apis);\n+        if (apis.contains(parent.latestAPI)) {\n+            resultTable.inc(ePos.getElementKey(), CountKind.ELEMENT_REMOVED);\n+        } else {\n+            resultTable.inc(ePos.getElementKey(), CountKind.ELEMENT_ADDED);\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentAnnotations(Position amPos, APIMap<? extends AnnotationMirror> amMap) {\n+        if (differentAnnotations.isEmpty()) {\n+            differentAnnotations = new HashMap<>();\n+        }\n+        differentAnnotations.put(amPos, amMap);\n+        if (amMap.containsKey(parent.latestAPI) && amMap.containsKey(parent.previousAPI)) {\n+            resultTable.inc(amPos.getElementKey(), CountKind.ELEMENT_CHANGED);\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentAnnotationValues(Position avPos, APIMap<? extends AnnotationValue> avMap) {\n+        if (differentAnnotationValues.isEmpty()) {\n+            differentAnnotationValues = new HashMap<>();\n+        }\n+        differentAnnotationValues.put(avPos, avMap);\n+        if (avMap.containsKey(parent.latestAPI) && avMap.containsKey(parent.previousAPI)) {\n+            resultTable.inc(avPos.getElementKey(), CountKind.ELEMENT_CHANGED);\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentDirectives(Position dPos, APIMap<? extends Directive> dMap) {\n+        if (differentDirectives.isEmpty()) {\n+            differentDirectives = new HashMap<>();\n+        }\n+        differentDirectives.put(dPos, dMap);\n+        if (dMap.containsKey(parent.latestAPI) && dMap.containsKey(parent.previousAPI)) {\n+            resultTable.inc(dPos.getElementKey(), CountKind.ELEMENT_CHANGED);\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentModifiers(Position ePos, APIMap<? extends Element> eMap) {\n+        if (differentModifiers.isEmpty()) {\n+            differentModifiers = new HashMap<>();\n+        }\n+        differentModifiers.put(ePos, eMap);\n+        if (eMap.containsKey(parent.latestAPI) && eMap.containsKey(parent.previousAPI)) {\n+            resultTable.inc(ePos.getElementKey(), CountKind.ELEMENT_CHANGED);\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentKinds(Position ePos, APIMap<? extends Element> eMap) {\n+        if (differentKinds.isEmpty()) {\n+            differentKinds = new HashMap<>();\n+        }\n+        differentKinds.put(ePos, eMap);\n+        if (eMap.containsKey(parent.latestAPI) && eMap.containsKey(parent.previousAPI)) {\n+            resultTable.inc(ePos.getElementKey(), CountKind.ELEMENT_CHANGED);\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentNames(Position ePos, APIMap<? extends Element> eMap) {\n+        \/\/ ignore, for now; compared locally for record components\n+    }\n+\n+    @Override\n+    public void reportDifferentValues(Position ePos, APIMap<?> vMap) {\n+        if (differentValues.isEmpty()) {\n+            differentValues = new HashMap<>();\n+        }\n+        differentValues.put(ePos, vMap);\n+        if (vMap.containsKey(parent.latestAPI) && vMap.containsKey(parent.previousAPI)) {\n+            resultTable.inc(ePos.getElementKey(), CountKind.ELEMENT_CHANGED);\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentTypeParameters(Position ePos, APIMap<? extends TypeParameterElement> eMap) {\n+        if (differentTypeParameters.isEmpty()) {\n+            differentTypeParameters = new HashMap<>();\n+        }\n+        differentTypeParameters.put(ePos, eMap);\n+        if (eMap.containsKey(parent.latestAPI) && eMap.containsKey(parent.previousAPI)) {\n+            resultTable.inc(ePos.getElementKey(), CountKind.ELEMENT_CHANGED);\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentTypes(Position tPos, APIMap<? extends TypeMirror> tMap) {\n+        if (differentTypes.isEmpty()) {\n+            differentTypes = new HashMap<>();\n+        }\n+        differentTypes.put(tPos, tMap);\n+        if (tMap.containsKey(parent.latestAPI) && tMap.containsKey(parent.previousAPI)) {\n+            resultTable.inc(tPos.getElementKey(), CountKind.ELEMENT_CHANGED);\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentThrownTypes(Position tPos, APIMap<List<? extends TypeMirror>> tMap) {\n+        if (differentThrownTypes.isEmpty()) {\n+            differentThrownTypes = new HashMap<>();\n+        }\n+        differentThrownTypes.put(tPos, tMap);\n+        if (tMap.containsKey(parent.latestAPI) && tMap.containsKey(parent.previousAPI)) {\n+            resultTable.inc(tPos.getElementKey(), CountKind.ELEMENT_CHANGED);\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentSuperinterfaces(Position tPos, APIMap<List<? extends TypeMirror>> tMap) {\n+        if (differentSuperinterfaces.isEmpty()) {\n+            differentSuperinterfaces = new HashMap<>();\n+        }\n+        differentSuperinterfaces.put(tPos, tMap);\n+        if (tMap.containsKey(parent.latestAPI) && tMap.containsKey(parent.previousAPI)) {\n+            resultTable.inc(tPos.getElementKey(), CountKind.ELEMENT_CHANGED);\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentPermittedSubclasses(Position tPos, APIMap<List<? extends TypeMirror>> tMap) {\n+        if (differentPermittedSubclasses.isEmpty()) {\n+            differentPermittedSubclasses = new HashMap<>();\n+        }\n+        differentPermittedSubclasses.put(tPos, tMap);\n+        if (tMap.containsKey(parent.latestAPI) && tMap.containsKey(parent.previousAPI)) {\n+            resultTable.inc(tPos.getElementKey(), CountKind.ELEMENT_CHANGED);\n+        }\n+    }\n+\n+    @Override\n+    public void reportDifferentRawDocComments(Position tPos, APIMap<String> cMap) {\n+        if (differentRawDocComments.isEmpty()) {\n+            differentRawDocComments = new HashMap<>();\n+        }\n+        differentRawDocComments.put(tPos, cMap);\n+        \/\/ count changes in TextDiffBuilder\n+    }\n+\n+    @Override\n+    public void reportDifferentApiDescriptions(Position tPos, APIMap<String> dMap) {\n+        if (differentApiDescriptions.isEmpty()) {\n+            differentApiDescriptions = new HashMap<>();\n+        }\n+        differentApiDescriptions.put(tPos, dMap);\n+        \/\/ count changes in HtmlDiffBuilder\n+    }\n+\n+    @Override\n+    public void reportDifferentDocFiles(Position fPos, APIMap<DocFile> fMap) {\n+        if (differentDocFiles.isEmpty()) {\n+            differentDocFiles = new HashMap<>();\n+        }\n+        differentDocFiles.put(fPos, fMap);\n+        \/\/ count changes in HtmlDiffBuilder\n+    }\n+    \/\/<\/editor-fold>\n+\n+    protected void writeFile() throws Abort {\n+        writeFile(file, buildPageContent());\n+    }\n+\n+    protected void writeFile(DocPath file, HtmlTree content) {\n+        Path path = file.resolveAgainst(parent.outDir);\n+\n+        Path dir = path.getParent();\n+        try {\n+            Files.createDirectories(dir);\n+        } catch (IOException e) {\n+            log.error(\"report.err.cant-create-directory\", dir, e);\n+            throw new Abort();\n+        }\n+\n+        try (BufferedWriter out = Files.newBufferedWriter(path, StandardCharsets.UTF_8)) {\n+            content.write(out);\n+        } catch (IOException e) {\n+            log.error(\"report.err.error-writing-file\", path, e);\n+            throw new Abort();\n+        }\n+    }\n+\n+    protected HtmlTree buildPageContent() {\n+        return new HtmlTree(TagName.HTML, buildHead(), buildBody());\n+    }\n+\n+    \/**\n+     * Returns the {@code <head>} element for the page.\n+     *\n+     * The element is mostly standard, with customizations for the\n+     * {@code <title>} and possibly the set of stylesheets imported\n+     * from the spec file, if the tool is comparing generated specs.\n+     *\n+     * @return the {@code <head>} element for the page.\n+     *\/\n+    protected HtmlTree buildHead() {\n+        String title = getTitle();\n+        if (parent.options.getTitle() != null) {\n+            title = String.format(\"%s: %s\", parent.options.getTitle(), title);\n+        }\n+        return HtmlTree.HEAD(\"UTF-8\", title)\n+                .add(HtmlTree.META(\"generator\", \"apidiff\"))\n+                .add(parent.getStylesheets().stream()\n+                        .map(links::getPath)\n+                        .map(l -> HtmlTree.LINK(\"stylesheet\", l.getPath())));\n+    }\n+\n+    protected abstract String getTitle();\n+\n+    \/**\n+     * Returns the {@code <body>} element for the page.\n+     *\n+     * TODO: the {@code <body>} element should follow a standard pattern:\n+     *   <ul>\n+     *     <li>A header, including navigation and a page heading\n+     *     <li>A report on the full \"signature\" of this element\n+     *     <li>A report on the doc comments for this element\n+     *     <li>A report on any enclosed elements: this will be\n+     *       a summary table with links for MODULE and PACKAGE,\n+     *       and inline details for members of TYPE.\n+     *     <li>A footer, including possible legal\/copyright text\n+     *   <\/ul>\n+     *\n+     * @return the {@code <body>} element for the page.\n+     *\/\n+    protected HtmlTree buildBody() {\n+        Position pagePos = Position.of(pageKey);\n+        String pageClass = pageKey.kind.toString().toLowerCase(Locale.ROOT);\n+        HtmlTree body = HtmlTree.BODY().setClass(pageClass);\n+        body.add(buildHeader());\n+        HtmlTree main = HtmlTree.MAIN();\n+        main.add(buildPageHeading());\n+        main.add(buildPageElement());\n+        main.add(buildDocComments(pagePos));\n+        main.add(buildAPIDescriptions(pagePos));\n+        main.add(buildEnclosedElements());\n+        main.add(buildResultTable());\n+        body.add(main);\n+        body.add(buildFooter());\n+        if (parent.options.getHiddenOption(\"show-debug-summary\") != null) {\n+            body.add(new DebugSummary().build());\n+        }\n+        return body;\n+    }\n+\n+    \/**\n+     * Builds the header for the page.\n+     *\n+     * @return the header\n+     *\/\n+    protected Content buildHeader() {\n+        List<Content> contents = new ArrayList<>();\n+        String topText = parent.options.getInfoText(InfoTextKind.TOP);\n+        if (topText != null) {\n+            contents.add(HtmlTree.DIV(new RawHtml(topText)).setClass(\"info\"));\n+        }\n+        contents.add(buildNav(InfoTextKind.HEADER));\n+        return new HtmlTree(TagName.HEADER, contents);\n+    }\n+\n+    \/**\n+     * Builds the footer for the page.\n+     *\n+     * @return the footer\n+     *\/\n+    protected Content buildFooter() {\n+        List<Content> contents = new ArrayList<>();\n+        contents.add(buildNav(InfoTextKind.FOOTER));\n+        String bottomText = parent.options.getInfoText(InfoTextKind.BOTTOM);\n+        if (bottomText != null) {\n+            contents.add(HtmlTree.DIV(new RawHtml(bottomText)).setClass(\"info\"));\n+        }\n+        return new HtmlTree(TagName.FOOTER, contents);\n+    }\n+\n+    \/**\n+     * Builds the main navigation bar for the page.\n+     *\n+     * @param kind the kind of info-text to be included in the bar\n+     *\n+     * @return the navigation bar\n+     *\/\n+    protected Content buildNav(InfoTextKind kind) {\n+        List<Content> contents = new ArrayList<>();\n+        String infoText = parent.options.getInfoText(kind);\n+        if (infoText == null) {\n+            infoText = String.join(\" : \", parent.options.getAllAPIOptions().keySet());\n+        }\n+        contents.add(HtmlTree.DIV(new RawHtml(infoText)).setClass(\"info\"));\n+        Text index = Text.of(parent.indexPageReporter.getName());\n+        HtmlTree ul = HtmlTree.UL();\n+        ul.add(HtmlTree.LI((pageKey == null) ? index : HtmlTree.A(links.getPath(\"index.html\").getPath(), index)));\n+        contents.add(HtmlTree.NAV(ul));\n+        return new HtmlTree(TagName.DIV, contents).setClass(\"bar\");\n+    }\n+\n+    \/**\n+     * Builds the page heading, based on the pageKey.\n+     *\n+     * @return the page heading\n+     *\/\n+    protected Content buildPageHeading() {\n+        return new PageHeading(Position.of(pageKey)).toContent();\n+    }\n+\n+    \/**\n+     * Builds the \"element\" details for the pageKey, containing the check or cross,\n+     * details about whether the element is missing in some instances of the API,\n+     * any notes, and the signature of the element.\n+     *\n+     * @return the \"element\" details\n+     *\/\n+    protected Content buildPageElement() {\n+        Position pagePos = Position.of(pageKey);\n+        List<Content> prelude = List.of(getResultGlyph(pagePos), buildMissingInfo(pagePos), buildNotes(pageKey));\n+        Content signature = buildSignature();\n+        return HtmlTree.DIV().setClass(\"element\").add(prelude).add(signature);\n+    }\n+\n+    protected Content buildNotes(Position pos) {\n+        return pos.isElement() ? buildNotes(((ElementPosition) pos).key) : Content.empty;\n+    }\n+\n+    \/**\n+     * Builds the list of notes (if any) associated with a given element key.\n+     *\n+     * @param eKey the element key\n+     *\n+     * @return the list of notes.\n+     *\/\n+    protected Content buildNotes(ElementKey eKey) {\n+        if (parent.notes == null) {\n+            return Content.empty;\n+        }\n+\n+        Map<Notes.Entry, Boolean> entries = parent.notes.getEntries(eKey);\n+        if (entries.isEmpty()) {\n+            return Content.empty;\n+        }\n+\n+        var comp = Comparator.comparing((Notes.Entry e) -> e.description).thenComparing(e -> e.uri);\n+        Map<Notes.Entry, Boolean> sorted = new TreeMap<>(comp);\n+        sorted.putAll(entries);\n+\n+        NotesTable notesTable = parent.indexPageReporter.notesTable;\n+        sorted.forEach((e, isParent) -> {\n+            if (!isParent) {\n+                notesTable.add(e, eKey);\n+            }\n+        });\n+\n+        List<Content> contents = new ArrayList<>();\n+        contents.add(Text.of(msgs.getString(\"notes.prefix\")));\n+        contents.add(Text.SPACE);\n+\n+        boolean first = true;\n+        for (Notes.Entry e : sorted.keySet()) {\n+            if (first) {\n+                first = false;\n+            } else {\n+                contents.add(Text.of(\", \"));\n+            }\n+            contents.add(HtmlTree.A(e.uri, Text.of(e.description)));\n+        }\n+        contents.add(Text.of(\".\"));\n+\n+        return HtmlTree.SPAN(contents).setClass(\"notes\");\n+    }\n+\n+    \/**\n+     * Builds the signature for the element key for the page.\n+     *\n+     * @return the signature\n+     *\/\n+    protected abstract Content buildSignature();\n+\n+    \/**\n+     * Builds the information about the documentation comments for a position in the API.\n+     *\n+     * @param pos the position\n+     *\n+     * @return the information about the documentation comments\n+     *\/\n+    protected Content buildDocComments(Position pos) {\n+        var options = getOptions();\n+        if (options.compareDocComments()) {\n+            APIMap<String> docComments = differentRawDocComments.get(pos);\n+            if (docComments == null) {\n+                docComments = getDocCommentMap(pos);\n+            }\n+            if (docComments != null && !docComments.isEmpty()) {\n+                TextDiffBuilder b = new TextDiffBuilder(this);\n+                List<Content> contents = b.build(docComments, ck -> resultTable.inc(pos.getElementKey(), ck));\n+                return new HtmlTree(TagName.DIV, contents).setClass(\"rawDocComments\");\n+            }\n+        }\n+\n+        return Content.empty;\n+    }\n+\n+    private APIMap<String> getDocCommentMap(Position pos) {\n+        if (pos.is(RelativePosition.Kind.SERIALIZED_FIELD)) {\n+            \/\/ get the APIMap<SerializedForm> and build the field map from that\n+            @SuppressWarnings(\"unchecked\")\n+            RelativePosition<String> sfPos = (RelativePosition<String>) pos;\n+            APIMap<SerializedForm> sfMap = getSerializedFormMap(pos);\n+            return sfMap == null ? null\n+                    : sfMap.map((api, sf) -> {\n+                        SerializedForm.Field f = sf.getField(sfPos.index);\n+                        List<? extends DocTree> tree = f == null ? null : f.getDocComment();\n+                        return tree == null ? null : tree.toString(); \/\/ TODO check .toString()\n+                    });\n+        } else if (pos.is(RelativePosition.Kind.DOC_FILE)) {\n+            @SuppressWarnings(\"unchecked\")\n+            APIMap<DocFile> fmap = (APIMap<DocFile>) apiMaps.get(pos);\n+            return fmap.map((api, df) -> {\n+                JavaFileObject fo = df.files.get(LocationKind.SOURCE);\n+                DocCommentTree tree = fo == null ? null : api.getDocComment(fo);\n+                return tree == null ? null : tree.toString();\n+            });\n+        } else {\n+            APIMap<? extends Element> eMap = getElementMap(pos);\n+            return eMap.map((api, e) -> {\n+                DocCommentTree dct = api.getDocComment(e);\n+                return dct == null ? null : dct.toString();\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Builds the information about the API descriptions for a position in the API.\n+     *\n+     * @param pos the position\n+     *\n+     * @return the information about the documentation comments\n+     *\/\n+    protected Content buildAPIDescriptions(Position pos) {\n+        var options = getOptions();\n+        if (options.compareApiDescriptions()) {\n+            APIMap<String> apiDescriptions = differentApiDescriptions.get(pos);\n+            if (apiDescriptions == null) {\n+                apiDescriptions = getAPIDescriptionMap(pos);\n+            }\n+            if (apiDescriptions != null && !apiDescriptions.isEmpty()) {\n+                var b = options.compareApiDescriptionsAsText()\n+                        ? new TextDiffBuilder(this)\n+                        : new HtmlDiffBuilder(this);\n+                var contents = b.build(apiDescriptions, ck -> resultTable.inc(pos.getElementKey(), ck));\n+                return new HtmlTree(TagName.DIV, contents).setClass(\"apiDescriptions\");\n+            }\n+        }\n+\n+        return Content.empty;\n+    }\n+\n+    private APIMap<String> getAPIDescriptionMap(Position pos) {\n+        \/\/ TODO: reorder with using element map first\n+        if (pos.is(RelativePosition.Kind.SERIALIZATION_OVERVIEW)) {\n+            \/\/ get the APIMap<SerializedForm> and build the overview map from that\n+            APIMap<SerializedForm> sfMap = getSerializedFormMap(pos);\n+            return sfMap == null ? null\n+                    : sfMap.map((api, sf) -> {\n+                        SerializedFormDocs sfDocs = sf.getDocs();\n+                        return sfDocs == null ? null : sfDocs.getOverview();\n+                    });\n+        } else if (pos.is(RelativePosition.Kind.SERIALIZED_FIELD)) {\n+            \/\/ get the APIMap<SerializedForm> and build the field map from that\n+            @SuppressWarnings(\"unchecked\")\n+            RelativePosition<String> sfPos = (RelativePosition<String>) pos;\n+            APIMap<SerializedForm> sfMap = getSerializedFormMap(pos);\n+            return sfMap == null ? null\n+                    : sfMap.map((api, sf) -> {\n+                        SerializedFormDocs sfDocs = sf.getDocs();\n+                        return sfDocs == null ? null : sfDocs.getFieldDescription(sfPos.index);\n+                    });\n+        } else if (pos.is(RelativePosition.Kind.DOC_FILE)) {\n+            @SuppressWarnings(\"unchecked\")\n+            APIMap<DocFile> fmap = (APIMap<DocFile>) apiMaps.get(pos);\n+            return fmap.map((api, df) -> {\n+                JavaFileObject fo = df.files.get(LocationKind.SOURCE);\n+                return fo == null ? null : api.getApiDescription(fo);\n+            });\n+        } else {\n+            APIMap<? extends Element> eMap = getElementMap(pos);\n+            return eMap.map(API::getApiDescription);\n+        }\n+    }\n+\n+    private APIMap<SerializedForm> getSerializedFormMap(Position pos) {\n+        Position sfPos = pos.serializedForm();\n+        @SuppressWarnings(\"unchecked\")\n+        APIMap<SerializedForm> sfMap = (APIMap<SerializedForm>) apiMaps.get(sfPos);\n+        return sfMap;\n+    }\n+\n+    \/**\n+     * Builds the details for the annotations at the position of an annotated construct in the API.\n+     *\n+     * @param acPos the position\n+     *\n+     * @return the details about the annotations\n+     *\/\n+    protected List<Content> buildAnnotations(Position acPos) {\n+        return new AnnotationBuilder().buildAnnotations(acPos);\n+    }\n+\n+    \/**\n+     * Builds the details about the enclosed elements of the element of the page.\n+     *\n+     * @return the details about the enclosed elements\n+     *\/\n+    protected abstract List<Content> buildEnclosedElements();\n+\n+    \/**\n+     * Adds the details for selected enclosed elements.\n+     *\n+     * @param list     the list to which the details should be added\n+     * @param titleKey the resource key for a title (heading) for the list of enclosed elements\n+     * @param filter   a filter to select the enclosed elements to be added\n+     *\/\n+    protected void addEnclosedElements(List<Content> list, String titleKey, Predicate<ElementKey> filter) {\n+        Set<? extends ElementKey> enclosed = results.keySet().stream()\n+                .filter(Position::isElement)\n+                .map(Position::asElementKey)\n+                .filter(ek -> ek != pageKey)\n+                .filter(filter)\n+                .collect(Collectors.toCollection(TreeSet::new));\n+\n+        if (!enclosed.isEmpty()) {\n+            HtmlTree section = HtmlTree.SECTION().setClass(\"enclosed\");\n+            section.add(HtmlTree.H2(Text.of(msgs.getString(titleKey))));\n+            HtmlTree ul = HtmlTree.UL();\n+            for (ElementKey eKey : enclosed) {\n+                HtmlTree li = HtmlTree.LI(buildEnclosedElement(eKey));\n+                ul.add(li);\n+            }\n+            section.add(ul);\n+            list.add(section);\n+        }\n+    }\n+\n+    \/**\n+     * Builds the content for an enclosed element.\n+     *\n+     * <p>The default is to just generate the check\/cross and a link to the enclosed element.\n+     *\n+     * @param eKey the key for the enclosed element\n+     *\n+     * @return the content\n+     *\/\n+    protected Content buildEnclosedElement(ElementKey eKey) {\n+        \/\/ The enclosed element may be on a different page, so use the appropriate page reporter\n+        PageReporter<?> r = parent.getPageReporter(eKey);\n+        return HtmlTree.SPAN(r.getResultGlyph(eKey),\n+                Text.SPACE,\n+                links.createLink(eKey));\n+    }\n+\n+    protected void addDocFiles(List<Content> list) {\n+        Set<? extends RelativePosition<String>> docFiles = results.keySet().stream()\n+                .filter(p -> p.is(RelativePosition.Kind.DOC_FILE))\n+                .map(p -> p.as(RelativePosition.Kind.DOC_FILE, String.class))\n+                .collect(Collectors.toCollection(() -> new TreeSet<>(RelativePosition.stringIndexComparator)));\n+\n+        if (!docFiles.isEmpty()) {\n+            HtmlTree section = HtmlTree.SECTION().setClass(\"doc-files\");\n+            section.add(HtmlTree.H2(Text.of(msgs.getString(\"heading.files\"))));\n+            HtmlTree ul = HtmlTree.UL();\n+            for (RelativePosition<String> p : docFiles) {\n+                DocFilesBuilder b = new DocFilesBuilder(p);\n+                HtmlTree li = HtmlTree.LI(getResultGlyph(p), buildMissingInfo(p));\n+                String name = p.index;\n+                if (name.endsWith(\".html\")) {\n+                    b.buildFile();\n+                    li.add(HtmlTree.A(\"doc-files\/\" + name, Text.of(name)));\n+                } else {\n+                    li.add(Text.of(name));\n+                    for (LocationKind lk : LocationKind.values()) {\n+                        li.add(b.buildTable(lk));\n+                    }\n+                }\n+                ul.add(li);\n+            }\n+            section.add(ul);\n+            list.add(section);\n+        }\n+    }\n+\n+    private String getChecksum(byte[] bytes) {\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n+            byte[] digest = md.digest(bytes);\n+            StringBuilder sb = new StringBuilder();\n+            for (byte b : digest) {\n+                sb.append(String.format(\"%02x\", b));\n+            }\n+            return sb.substring(0, 16);\n+        } catch (NoSuchAlgorithmException e) {\n+            return \"\";\n+        }\n+    }\n+\n+\n+    \/**\n+     * Builds the details about any missing items at a position in the API.\n+     *\n+     * @param pos the position\n+     *\n+     * @return the details\n+     *\/\n+    protected Content buildMissingInfo(Position pos) {\n+        if (missing.containsKey(pos)) {\n+            \/\/ TODO: use an L10N-friendly builder, or use an API list builder, building Content?\n+            String onlyIn = apiMaps.get(pos).keySet().stream()\n+                    .map(a -> a.name)\n+                    .collect(Collectors.joining(\", \"));\n+            \/\/ The \"missing\" sets are not guaranteed ordered, so build the list according to\n+            \/\/ the overall order of the APIs.\n+            Set<API> missingAtPos = missing.get(pos);\n+            String missingIn = parent.apis.stream()\n+                    .filter(missingAtPos::contains)\n+                    .map(a -> a.name)\n+                    .collect(Collectors.joining(\", \"));\n+            String info = msgs.getString(\"element.onlyInMissingIn\", onlyIn, missingIn);\n+            return HtmlTree.SPAN(Text.of(info)).setClass(\"missing\");\n+        } else {\n+            return Content.empty;\n+        }\n+    }\n+\n+    protected Content buildResultTable() {\n+        HtmlTree section = HtmlTree.SECTION(HtmlTree.H2(Text.of(msgs.getString(\"summary.heading\"))))\n+                .setClass(\"summary\");\n+        if (resultTable.isEmpty()) {\n+            section.add(Text.of(msgs.getString(\"summary.no-differences\")));\n+        } else {\n+            section.add(resultTable.toContent());\n+        }\n+        return section;\n+    }\n+\n+    private static final Content CHECK = HtmlTree.SPAN(Entity.CHECK).setClass(\"same\");\n+    private static final Content CROSS = HtmlTree.SPAN(Entity.CROSS).setClass(\"diff\");\n+    private static final Content SINGLE = HtmlTree.SPAN(Entity.CIRCLED_DIGIT_ONE).setClass(\"single\");\n+\n+\n+    protected Content getResultGlyph(ElementKey eKey) {\n+        Position pos = Position.of(eKey);\n+        return getResultGlyph(pos, apiMaps.get(pos));\n+    }\n+\n+    protected Content getResultGlyph(Position pos) {\n+        return getResultGlyph(pos, apiMaps.get(pos));\n+    }\n+\n+    protected Content getResultGlyph(Position pos, APIMap<?> map) {\n+        if (map == null) {\n+            \/\/ TODO...\n+            return Text.of(\"?\");\n+        }\n+        if (map.size() == 1) {\n+            return SINGLE;\n+        }\n+        Boolean eq = results.get(pos);\n+        return (eq == null) ? SINGLE : eq ? CHECK : CROSS;\n+    }\n+\n+    \/\/ TODO: improve abstraction; these args are typically reversed\n+    protected Content getResultGlyph(APIMap<?> map, Position pos) {\n+        if (map.size() == 1) {\n+            return SINGLE;\n+        }\n+        Boolean eq = results.get(pos);\n+        return (eq == null) ? SINGLE : eq ? CHECK : CROSS;\n+    }\n+\n+    protected APIMap<? extends Element> getElementMap(ElementKey eKey) {\n+        Position ePos = Position.of(eKey);\n+        @SuppressWarnings(\"unchecked\")\n+        APIMap<? extends Element> apiMap = (APIMap<? extends Element>) apiMaps.get(ePos);\n+        return apiMap;\n+    }\n+\n+    protected APIMap<? extends Element> getElementMap(Position pos) {\n+        if (!(pos.isElement() || pos.is(RelativePosition.Kind.SERIALIZATION_METHOD))) {\n+            throw new IllegalArgumentException(pos.toString());\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        APIMap<? extends Element> apiMap = (APIMap<? extends Element>) apiMaps.get(pos);\n+        return apiMap;\n+    }\n+\n+    protected boolean hasMissing(APIMap<?> apiMap) {\n+        return apiMap.size() < parent.apis.size();\n+    }\n+\n+    protected boolean getResult(Position pos) {\n+        Boolean b = results.get(pos);\n+        if (b == null) {\n+            throw new IllegalStateException(); \/\/ TODO: should this be an assertion\n+        }\n+        return b;\n+    }\n+\n+    protected boolean getResult(ElementKey eKey) {\n+        return getResult(Position.of(eKey));\n+    }\n+\n+    protected Content todo(String name) {\n+        parent.countToDo(name);\n+        return HtmlTree.SPAN(Text.of(name)).setClass(\"todo\");\n+    }\n+\n+    protected Options getOptions() {\n+        return parent.options;\n+    }\n+\n+\n+    \/**\n+     * A utility class to generate the page heading for each page.\n+     *\/\n+    protected class PageHeading implements ElementKey.Visitor<List<Content>, Void> {\n+        Position pos;\n+\n+        PageHeading(Position pos) {\n+            this.pos = pos;\n+        }\n+\n+        Content toContent() {\n+            List<Content> contents;\n+            if (pos.isElement()) {\n+                contents = pos.asElementKey().accept(this, null);\n+            } else if (pos.is(RelativePosition.Kind.DOC_FILE)) {\n+                @SuppressWarnings(\"unchecked\")\n+                RelativePosition<String> fPos = (RelativePosition<String>) pos;\n+                contents = new ArrayList<>();\n+                ElementKey eKey = fPos.getElementKey();\n+                switch (eKey.kind) {\n+                    case MODULE -> {\n+                        ModuleElementKey mKey = (ModuleElementKey) eKey;\n+                        contents.add(minor(\"heading.module\", links.createLink(mKey, mKey.name)));\n+                    }\n+                    case PACKAGE -> {\n+                        PackageElementKey pKey = (PackageElementKey) eKey;\n+                        ModuleElementKey mKey = (ModuleElementKey) pKey.moduleKey;\n+                        if (mKey != null) {\n+                            contents.add(minor(\"heading.module\", links.createLink(mKey, mKey.name)));\n+                        }\n+                        contents.add(minor(\"heading.package\", links.createLink(pKey, pKey.name)));\n+                    }\n+                }\n+                contents.add(major(\"heading.file\", fPos.index));\n+            } else {\n+                throw new IllegalStateException(pos.toString());\n+            }\n+\n+            return new HtmlTree(TagName.DIV, contents).setClass(\"pageHeading\");\n+        }\n+\n+        @Override\n+        public List<Content> visitModuleElement(ModuleElementKey mKey, Void _p) {\n+            return List.of(major(\"heading.module\", mKey.name));\n+        }\n+\n+        @Override\n+        public List<Content> visitPackageElement(PackageElementKey pKey, Void _p) {\n+            List<Content> contents = new ArrayList<>();\n+            ModuleElementKey mKey = (ModuleElementKey) pKey.moduleKey;\n+            if (mKey != null) {\n+                contents.add(minor(\"heading.module\", links.createLink(mKey, mKey.name)));\n+            }\n+            contents.add(major(\"heading.package\", pKey.name));\n+            return contents;\n+        }\n+\n+        @Override\n+        public List<Content> visitTypeElement(TypeElementKey tKey, Void _p) {\n+            List<Content> contents = new ArrayList<>();\n+\n+            String tKind;\n+            APIMap<? extends Element> tMap = getElementMap(tKey);\n+            Set<ElementKind> eKinds = (tMap == null) ? Collections.emptySet()\n+                    : tMap.values().stream().map(Element::getKind).collect(Collectors.toSet());\n+            switch (eKinds.size()) {\n+                case 0 ->\n+                    tKind = \"heading.unknown\";\n+\n+                case 1 -> {\n+                    ElementKind eKind = eKinds.iterator().next();\n+                    tKind = switch (eKind) {\n+                        case ANNOTATION_TYPE -> \"heading.annotation-type\";\n+                        case CLASS -> \"heading.class\";\n+                        case ENUM -> \"heading.enum\";\n+                        case INTERFACE -> \"heading.interface\";\n+                        case RECORD -> \"heading.record\";\n+                        default -> throw new IllegalStateException(eKind.toString());\n+                    };\n+                }\n+\n+                default ->\n+                    tKind = \"heading.mixed\";\n+            }\n+\n+            StringBuilder tName = new StringBuilder(tKey.name);\n+            while (tKey.enclosingKey instanceof TypeElementKey) {\n+                tKey = (TypeElementKey) tKey.enclosingKey;\n+                tName.insert(0, tKey.name + \".\");\n+            }\n+\n+            PackageElementKey pKey = (PackageElementKey) tKey.enclosingKey;\n+            if (pKey != null) {\n+                ModuleElementKey mKey = (ModuleElementKey) pKey.moduleKey;\n+                if (mKey != null) {\n+                    contents.add(minor(\"heading.module\", links.createLink(mKey, mKey.name)));\n+                }\n+                contents.add(minor(\"heading.package\", links.createLink(pKey, pKey.name)));\n+            }\n+\n+            contents.add(major(tKind, tName));\n+            return contents;\n+        }\n+\n+        @Override\n+        public List<Content> visitExecutableElement(ExecutableElementKey k, Void aVoid) {\n+            return null;\n+        }\n+\n+        @Override\n+        public List<Content> visitVariableElement(VariableElementKey k, Void aVoid) {\n+            return null;\n+        }\n+\n+        @Override\n+        public List<Content> visitTypeParameterElement(TypeParameterElementKey k, Void aVoid) {\n+            return null;\n+        }\n+\n+        private Content minor(String key, HtmlTree link) {\n+            return HtmlTree.DIV(\n+                    HtmlTree.SPAN(Text.of(msgs.getString(key))).setClass(\"label\"),\n+                    Entity.NBSP,\n+                    link\n+            );\n+        }\n+\n+        private Content major(String key, CharSequence name) {\n+            return HtmlTree.H1(Text.of(msgs.getString(key)), Entity.NBSP, Text.of(name));\n+        }\n+    }\n+\n+    \/**\n+     * A builder for different instances of an annotation in different instances of an API.\n+     *\/\n+    protected class AnnotationBuilder {\n+        private AnnotationValueBuilder annoValueBuilder = new AnnotationValueBuilder();\n+\n+        public List<Content> buildAnnotations(Position acPos) {\n+            Set<RelativePosition<?>> annos = getAnnotationsAt(acPos);\n+            if (annos.isEmpty()) {\n+                return List.of();\n+            }\n+\n+            Content terminator = acPos.isElement() ? new HtmlTree(TagName.BR) : Text.SPACE;\n+\n+            List<Content> contents = new ArrayList<>();\n+            for (RelativePosition<?> anno : annos) {\n+                contents.add(build(anno));\n+                contents.add(terminator);\n+            }\n+\n+            return contents;\n+        }\n+\n+        private Content build(RelativePosition<?> aPos) {\n+            \/\/ get the apiMap and result;\n+            \/\/ if the anno is equal, get\/print the first from the map;\n+            \/\/ otherwise use DiffBuilder to show the differences\n+            APIMap<? extends AnnotationMirror> aMap = getAnnotationsMap(aPos);\n+            boolean equal = getResult(aPos);\n+            AnnotationMirror archetype = aMap.values().iterator().next();\n+            Element annoType = archetype.getAnnotationType().asElement();\n+            List<Content> contents = new ArrayList<>();\n+            contents.add(new Text(\"@\"));\n+            contents.add(new Text(annoType.getSimpleName().toString()));\n+            if (equal) {\n+                Map<? extends ExecutableElement, ? extends AnnotationValue> elementValues = archetype.getElementValues();\n+                if (!elementValues.isEmpty()) {\n+                    contents.add(new Text(\"(\"));\n+                    for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> e : elementValues.entrySet()) {\n+                        ExecutableElement ee = e.getKey();\n+                        AnnotationValue av = e.getValue();\n+                        Name name = ee.getSimpleName();\n+                        if (elementValues.size() > 1 || !name.contentEquals(\"value\")) {\n+                            contents.add(new Text(name));\n+                            contents.add(new Text(\"=\"));\n+                        }\n+                        contents.add(annoValueBuilder.build(av));\n+                    }\n+                    contents.add(new Text(\")\"));\n+                }\n+            } else {\n+                \/\/ get the position for all the annotation values, sorted by the corresponding executable element\n+                Set<RelativePosition<?>> values = new TreeSet<>(Position.elementKeyIndexComparator);\n+                for (Position pos : results.keySet()) {\n+                    if (pos instanceof RelativePosition) {\n+                        RelativePosition<?> rp = (RelativePosition<?>) pos;\n+                        if (rp.kind == RelativePosition.Kind.ANNOTATION_VALUE && rp.parent.equals(aPos)) {\n+                            values.add(rp);\n+                        }\n+                    }\n+                }\n+                contents.add(new Text(\"(\"));\n+                contents.addAll(buildAnnoValues(values));\n+                contents.add(new Text(\")\"));\n+            }\n+            return HtmlTree.SPAN(contents).setClass(\"annotation\");\n+        }\n+\n+        Set<RelativePosition<?>> getAnnotationsAt(Position acPos) {\n+            Set<RelativePosition<?>> annos = new TreeSet<>(Position.elementKeyIndexComparator);\n+            for (Position pos : results.keySet()) {\n+                if (pos instanceof RelativePosition) {\n+                    RelativePosition<?> rp = (RelativePosition<?>) pos;\n+                    if (rp.kind == RelativePosition.Kind.ANNOTATION && rp.parent.equals(acPos)) {\n+                        annos.add(rp);\n+                    }\n+                }\n+            }\n+            return annos;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        APIMap<? extends AnnotationMirror> getAnnotationsMap(RelativePosition<?> aPos) {\n+            return switch (aPos.kind) {\n+                case ANNOTATION -> (APIMap<? extends AnnotationMirror>) apiMaps.get(aPos);\n+                default -> throw new IllegalArgumentException(aPos.toString());\n+            };\n+        }\n+\n+        private List<Content> buildAnnoValues(Set<RelativePosition<?>> values) {\n+            List<Content> contents = new ArrayList<>();\n+            boolean first = true;\n+            for (RelativePosition<?> value : values) {\n+                if (first) {\n+                    first = false;\n+                } else {\n+                    contents.add(new Text(\", \"));\n+                }\n+                \/\/ TODO: make this an operation on Position; check RP.kind == ANNOTATION_VALUE\n+                MemberElementKey meKey = (MemberElementKey) value.index;\n+                assert meKey != null;\n+                String name = meKey.name.toString();\n+                contents.add(new Text(name));\n+                contents.add(new Text(\" = \"));\n+                contents.addAll(annoValueBuilder.buildAnnoValue(value));\n+            }\n+            return contents;\n+        }\n+    }\n+\n+    \/**\n+     * A builder for different instances of an annotation value in different instances of an API.\n+     *\/\n+    protected class AnnotationValueBuilder {\n+\n+        List<Content> buildAnnoValue(RelativePosition<?> avPos) {\n+            APIMap<? extends AnnotationValue> avMap = getAnnotationValuesMap(avPos);\n+            boolean equal = getResult(avPos);\n+            List<Content> contents = new ArrayList<>();\n+            if (equal) {\n+                AnnotationValue archetype = avMap.values().iterator().next();\n+                contents.add(build(archetype));\n+            } else {\n+                APIMap<Content> diffs = APIMap.of();\n+                for (Map.Entry<API, ? extends AnnotationValue> e : avMap.entrySet()) {\n+                    API api = e.getKey();\n+                    AnnotationValue av = e.getValue();\n+                    diffs.put(api, build(av));\n+                }\n+                contents.add(new DiffBuilder().build(diffs));\n+            }\n+            return contents;\n+        }\n+\n+        private Content build(AnnotationValue av) {\n+            \/\/ for now, rely on javax.lang.model .toString() method, which is defined\n+            \/\/ to return a source-friendly string.\n+            \/\/ Note that this implies we can't show nested differences within composite values.\n+            return new Text(av.toString());\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        APIMap<? extends AnnotationValue> getAnnotationValuesMap(RelativePosition<?> aPos) {\n+            return switch (aPos.kind) {\n+                case ANNOTATION_VALUE, DEFAULT_VALUE ->\n+                        (APIMap<? extends AnnotationValue>) apiMaps.get(aPos);\n+\n+                default ->\n+                        throw new IllegalArgumentException(aPos.toString());\n+            };\n+        }\n+\n+    }\n+\n+    \/**\n+     * A builder for different instances of a type in different instances of an API.\n+     *\/\n+    protected class TypeBuilder extends SimpleTypeVisitor14<Content, Void> {\n+\n+        Content build(TypeMirror tm) {\n+            \/\/ TODO: maybe handle annotations here\n+            return tm.accept(this, null);\n+        }\n+\n+        @Override\n+        protected Content defaultAction(TypeMirror tm, Void _p) {\n+            return todo(tm.getKind() + \" \" + tm);\n+        }\n+\n+        @Override\n+        public Content visitArray(ArrayType t, Void _p) {\n+            List<Content> contents = new ArrayList<>();\n+            List<? extends AnnotationMirror> annos = t.getAnnotationMirrors();\n+            if (!annos.isEmpty()) {\n+                contents.add(todo(\"type annotations \" + annos));\n+                contents.add(Text.SPACE);\n+            }\n+            contents.add(visit(t.getComponentType(), _p));\n+            contents.add(Text.of(\"[]\"));\n+            return HtmlTree.SPAN(contents);\n+        }\n+\n+        @Override\n+        public Content visitDeclared(DeclaredType t, Void _p) {\n+            List<Content> contents = new ArrayList<>();\n+            List<? extends AnnotationMirror> annos = t.getAnnotationMirrors();\n+            if (!annos.isEmpty()) {\n+                contents.add(todo(\"type annotations \" + annos));\n+                contents.add(Text.SPACE);\n+            }\n+            contents.add(Text.of(elementNameVisitor.visit(t.asElement(), null)));\n+            List<? extends TypeMirror> typeArgs = t.getTypeArguments();\n+            if (!typeArgs.isEmpty()) {\n+                contents.add(Text.of(\"<\"));\n+                boolean needComma = false;\n+                for (TypeMirror ta : typeArgs) {\n+                    if (needComma) {\n+                        contents.add(Text.of(\", \"));\n+                    } else {\n+                        needComma = true;\n+                    }\n+                    contents.add(visit(ta, null));\n+                }\n+                contents.add(Text.of(\">\"));\n+            }\n+            return (contents.size() == 1) ? contents.get(0) : HtmlTree.SPAN(contents);\n+        }\n+\n+        @Override\n+        public Content visitNoType(NoType t, Void _p) {\n+            return switch (t.getKind()) {\n+                \/\/ NONE is most likely to be printed in a \"diff\" context, so generate a space\n+                case NONE -> Entity.NBSP;\n+                case VOID -> Keywords.VOID;\n+                default -> throw new IllegalArgumentException(t.getKind().toString());\n+            };\n+        }\n+\n+        @Override\n+        public Content visitPrimitive(PrimitiveType t, Void _p) {\n+            \/\/ TODO: annotations\n+            return Keywords.of(t);\n+        }\n+\n+        @Override\n+        public Content visitTypeVariable(TypeVariable t, Void _p) {\n+            List<Content> contents = new ArrayList<>();\n+            List<? extends AnnotationMirror> annos = t.getAnnotationMirrors();\n+            if (!annos.isEmpty()) {\n+                contents.add(todo(\"type annotations \" + annos));\n+                contents.add(Text.SPACE);\n+            }\n+            contents.add(Text.of(t.asElement().getSimpleName())); \/\/ TODO: link? link to declaring element (type or executable?)\n+            return (contents.size() == 1) ? contents.get(0) : HtmlTree.SPAN(contents);\n+        }\n+\n+        @Override\n+        public Content visitWildcard(WildcardType t, Void _p) {\n+            List<Content> contents = new ArrayList<>();\n+            List<? extends AnnotationMirror> annos = t.getAnnotationMirrors();\n+            if (!annos.isEmpty()) {\n+                contents.add(todo(\"type \" +\n+                        \"annotations \" + annos));\n+                contents.add(Text.SPACE);\n+            }\n+            contents.add(Text.of(\"?\"));\n+            addBound(contents, Keywords.EXTENDS, t.getExtendsBound());\n+            addBound(contents, Keywords.SUPER, t.getSuperBound());\n+            return (contents.size() == 1) ? contents.get(0) : HtmlTree.SPAN(contents);\n+        }\n+\n+        private void addBound(List<Content> contents, Content kw, TypeMirror b) {\n+            if (b == null) {\n+                return;\n+            }\n+            contents.add(Text.SPACE);\n+            contents.add(kw);\n+            contents.add(Text.SPACE);\n+            contents.add(build(b));\n+        }\n+\n+        private final ElementVisitor<Name,Void> elementNameVisitor = new SimpleElementVisitor14<>() {\n+            @Override\n+            public Name visitType(TypeElement te, Void p) {\n+                return te.getQualifiedName();\n+            }\n+            @Override\n+            public Name visitTypeParameter(TypeParameterElement tpe, Void p) {\n+                return tpe.getSimpleName();\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * A builder for different instances of doc files across instances of an API.\n+     *\n+     * Two kinds of output are supported: either a short summary table giving the\n+     * size and a checksum for the different instances, suitable for any type of file,\n+     * or a separate file, displaying the differences for HTML files, compared as\n+     * either doc comments (for instances in the source tree) or as API descriptions\n+     * (for instances found in the API directory.)\n+     *\/\n+    class DocFilesBuilder {\n+        private final RelativePosition<String> fPos;\n+        private final APIMap<DocFile> fMap;\n+        private final DocPath file;\n+        private final Links links;\n+\n+        \/**\n+         * Creates a builder for the doc files at a given position.\n+         *\n+         * @param pos the position\n+         *\/\n+        DocFilesBuilder(RelativePosition<String> pos) {\n+            this.fPos = pos;\n+            @SuppressWarnings(\"unchecked\")\n+            APIMap<DocFile> fMap = (APIMap<DocFile>) apiMaps.get(fPos);\n+            this.fMap = fMap;\n+            file = PageReporter.this.file.parent().resolve(\"doc-files\").resolve(pos.index);\n+            links = new Links(file);\n+        }\n+\n+        \/**\n+         * Returns a table displaying the size and a checksum for each of the\n+         * instances of the doc file.  The checksum is just intended to help\n+         * visualize which files may be equal and which are different.\n+         * The checksum is a short but sufficient substring of the SHA_256 digest.\n+         *\n+         * @param lk the kind of location for the files to be included in the table\n+         *\n+         * @return the table\n+         *\/\n+        Content buildTable(LocationKind lk) {\n+            @SuppressWarnings(\"unchecked\")\n+            APIMap<DocFile> fMap = (APIMap<DocFile>) apiMaps.get(fPos);\n+            if (fMap.values().stream().allMatch(Objects::isNull)) {\n+                return Content.empty;\n+            }\n+\n+            String captionKey = switch (lk) {\n+                case API -> \"docfile.details.caption.api\";\n+                case SOURCE -> \"docfile.details.caption.source\";\n+            };\n+\n+            HtmlTree caption = HtmlTree.CAPTION(Text.of(msgs.getString(captionKey, fPos.index)));\n+            HtmlTree tHead = HtmlTree.THEAD(\n+                    HtmlTree.TR(\n+                            HtmlTree.TH(Text.of(msgs.getString(\"docfile.details.th.api\"))),\n+                            HtmlTree.TH(Text.of(msgs.getString(\"docfile.details.th.size\"))),\n+                            HtmlTree.TH(Text.of(msgs.getString(\"docfile.details.th.checksum\")))\n+                    )\n+            );\n+            HtmlTree tBody = HtmlTree.TBODY();\n+            fMap.forEach((api, df) -> {\n+                    JavaFileObject fo = df.files.get(lk);\n+                    if (fo != null) {\n+                        byte[] bytes = api.getAllBytes(fo);\n+                        int size = bytes.length;\n+                        String cs = getChecksum(bytes);\n+                        tBody.add(HtmlTree.TR(\n+                                HtmlTree.TH(Text.of(api.name)).set(HtmlAttr.SCOPE, \"row\"),\n+                                HtmlTree.TD(Text.of(Integer.toString(size))),\n+                                HtmlTree.TD(Text.of(cs))\n+                        ));\n+                    }\n+            });\n+\n+            return HtmlTree.TABLE(caption, tHead, tBody).setClass(\"details\");\n+        }\n+\n+        \/**\n+         * Builds a file containing the comparison for instances of an HTML file.\n+         *\/\n+        void buildFile() {\n+            HtmlTree page = new HtmlTree(TagName.HTML, buildHead(), buildBody());\n+            writeFile(page);\n+        }\n+\n+        private void writeFile(HtmlTree content) {\n+            PageReporter.this.writeFile(file, content);\n+        }\n+\n+        private Content buildHead() {\n+            String title = getTitle();\n+            if (parent.options.getTitle() != null) {\n+                title = String.format(\"%s: %s\", parent.options.getTitle(), title);\n+            }\n+            return HtmlTree.HEAD(\"UTF-8\", title)\n+                    .add(HtmlTree.META(\"generator\", \"apidiff\"))\n+                    .add(parent.getStylesheets().stream()\n+                            .map(links::getPath)\n+                            .map(l -> HtmlTree.LINK(\"stylesheet\", l.getPath())));\n+        }\n+\n+        private String getTitle() {\n+            return file.getPath();\n+        }\n+\n+        private Content buildBody() {\n+            HtmlTree body = HtmlTree.BODY().setClass(\"doc-files\");\n+            body.add(buildHeader());\n+            HtmlTree main = HtmlTree.MAIN();\n+            main.add(buildPageHeading());\n+            main.add(HtmlTree.SPAN(getResultGlyph(fPos), buildMissingInfo(fPos)).setClass(\"doc-files\"));\n+            main.add(buildDocComments(fPos));\n+            main.add(buildAPIDescriptions(fPos));\n+\/\/            main.add(buildEnclosedElements());\n+\/\/            main.add(buildResultTable()); \/\/ TODO: info not broken out; could simulate a ResultTable?\n+            body.add(main);\n+            body.add(buildFooter());\n+            if (parent.options.getHiddenOption(\"show-debug-summary\") != null) {\n+                body.add(new DebugSummary().build()); \/\/ TODO will show package page info\n+            }\n+            return body;\n+        }\n+\n+        Content buildPageHeading() {\n+            return new PageHeading(fPos).toContent();\n+        }\n+    }\n+\n+    \/**\n+     * A builder for a summary of the differences reported for different instances of an API.\n+     *\/\n+    protected class DebugSummary {\n+        protected Content build() {\n+            List<Content> summary = new ArrayList<>();\n+\n+            if (!results.isEmpty()) {\n+                long enclosedDiffs = results.values().stream()\n+                        .filter(b -> !b)\n+                        .count();\n+                if (enclosedDiffs > 0) {\n+                    summary.add(Text.of(String.format(\"%d different enclosed elements\", enclosedDiffs)));\n+                }\n+            }\n+\n+            List<Content> list = Stream.of(\n+                    build(\"missing items\", missing),\n+                    build(\"different annotations\", differentAnnotations),\n+                    build(\"different annotation values\", differentAnnotationValues),\n+                    build(\"different directives\", differentDirectives),\n+                    build(\"different kinds\", differentKinds),\n+                    build(\"different type parameters\", differentTypeParameters),\n+                    build(\"different modifiers\", differentModifiers),\n+                    build(\"different types\", differentTypes),\n+                    build(\"different thrown types\", differentThrownTypes),\n+                    build(\"different superinterfaces\", differentSuperinterfaces),\n+                    build(\"different raw doc comments\", differentRawDocComments))\n+                    .filter(c -> c != Content.empty)\n+                    .collect(Collectors.toList());\n+            if (!list.isEmpty()) {\n+                summary.add(HtmlTree.UL(list));\n+            }\n+\n+            if (summary.isEmpty()) {\n+                summary.add(Text.of(\"no differences found\"));\n+            }\n+\n+            return new HtmlTree(TagName.SECTION, summary).setClass(\"debug\");\n+        }\n+\n+        private Content build(String name, Map<Position, ?> map) {\n+            if (map.isEmpty()) {\n+                return Content.empty;\n+            }\n+\n+            SignatureVisitor sv = new SignatureVisitor(apiMaps);\n+\n+            HtmlTree ul = HtmlTree.UL();\n+            for (Map.Entry<Position, ?> entry : map.entrySet()) {\n+                Position pos = entry.getKey();\n+                Object details = entry.getValue();\n+                HtmlTree detailsTree;\n+                if (details instanceof Set) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    Set<API> missing = (Set<API>) details;\n+                    HtmlTree list = HtmlTree.UL();\n+                    missing.stream()\n+                            .map(a -> HtmlTree.LI(Text.of(a.name)))\n+                            .forEach(list::add);\n+                    detailsTree = list;\n+                } else if (details instanceof APIMap<?> apiMap) {\n+                    HtmlTree table = new HtmlTree(TagName.TABLE);\n+                    apiMap.forEach((api, value) -> table.add(\n+                            HtmlTree.TR(\n+                                    HtmlTree.TH(Text.of(api.name)),\n+                                    HtmlTree.TD(Text.of(Objects.toString(value))))));\n+                    detailsTree = table;\n+                } else {\n+                    detailsTree = HtmlTree.DIV(Text.of(Objects.toString(details)));\n+                }\n+                ul.add(HtmlTree.LI(Text.of(sv.getSignature(pos)), detailsTree));\n+            }\n+\n+            return new HtmlTree(TagName.SECTION, HtmlTree.H2(Text.of(name)), ul);\n+        }\n+\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/PageReporter.java","additions":1553,"deletions":0,"binary":false,"changes":1553,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report.html;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import jdk.codetools.apidiff.Log;\n+import jdk.codetools.apidiff.Messages;\n+import jdk.codetools.apidiff.html.Content;\n+import jdk.codetools.apidiff.model.API;\n+import jdk.codetools.apidiff.model.APIMap;\n+\n+\/**\n+ * A class to build HTML to display pairwise differences between groups of API-specific items.\n+ *\n+ * @param <T> the type of the items.\n+ *\/\n+public abstract class PairwiseDiffBuilder<T> {\n+    private final Set<API> apis;\n+    protected final Log log;\n+    protected final Messages msgs;\n+\n+    \/**\n+     * Creates an instance of a {@code PairwiseDiffBuilder}.\n+     *\n+     * @param log the log to which to report any problems while using this builder\n+     *\/\n+    public PairwiseDiffBuilder(Set<API> apis, Log log, Messages msgs) {\n+        this.apis = apis;\n+        this.log = log;\n+        this.msgs = msgs;\n+    }\n+\n+    \/**\n+     * Builds HTML that displays the differences between API-specific items,\n+     * by doing pair-wise comparisons between a reference API and the focus API.\n+     *\n+     * @param map the map of API-specific items\n+     * @return the HTML nodes\n+     *\/\n+    public List<Content> build(APIMap<T> map, Consumer<ResultTable.CountKind> counter) {\n+        List<API> apiList = new ArrayList<>(apis);\n+        API focusAPI = apiList.get(apiList.size() - 1);\n+\n+        \/\/ first, determine the equivalence groups,\n+        Map<String, List<API>> groups = new LinkedHashMap<>();\n+        for (API api : apis) {\n+            groups.computeIfAbsent(getKeyString(map.get(api)), k -> new ArrayList<>()).add(api);\n+        }\n+\n+        List<API> focusGroup = groups.values().stream()\n+                .filter(l -> l.contains(focusAPI))\n+                .findFirst()\n+                .orElseThrow(() -> new IllegalStateException(\"ref group not found\"));\n+        String focusNames = getNameList(focusGroup);\n+        T focusItem = map.get(focusAPI);\n+\n+        List<Content> contents = new ArrayList<>();\n+        \/\/ Now, compare each group against the group containing the reference API.\n+        \/\/ Since there is only one group for all items with no content, there are\n+        \/\/ effectively only 3 possibilities:\n+        \/\/ 1. Different text in each group, display as a pair\n+        \/\/ 2. Text only in one of the groups, but not the reference group\n+        \/\/ 3. Text only in the reference group, not in the other one of the pair\n+        for (Map.Entry<String, List<API>> entry : groups.entrySet()) {\n+            String key = entry.getKey();\n+            List<API> apis = entry.getValue();\n+            if (apis == focusGroup) {\n+                \/\/ if all the entries are same, there will only be one group,\n+                \/\/ which will contain the focus, so no output will be generated;\n+                \/\/ if the entries are not all the same, skip pairwise comparison\n+                \/\/ of the focusGroup with itself!\n+                continue;\n+            }\n+\n+            T other = map.get(apis.get(0));\n+\n+            \/*\n+            String otherNames = getNameList(apis);\n+            if (focusItem != null && key != null) {\n+                \/\/ item in both groups: display the comparison\n+                Content title = Text.of(String.format(\"Comparing %s with %s\", otherNames, focusNames)); \/\/ TODO: improve\n+                contents.add(build(title, other, focusItem, counter));\n+            } else if (key == null) {\n+                Content title = Text.of(String.format(\"Not in %s; only in %s\", otherNames, focusNames)); \/\/ TODO: improve\n+                contents.add(build(title, focusItem));\n+            } else if (focusItem == null) {\n+                Content title = Text.of(String.format(\"Only in %s; not in %s\", otherNames, focusNames)); \/\/ TODO: improve\n+                contents.add(build(title, other));\n+            }\n+            *\/\n+\n+            contents.add(build(apis, other, focusGroup, focusItem, counter));\n+        }\n+\n+        return contents;\n+    }\n+\n+    protected abstract Content build(List<API> refAPIs, T refItem,\n+                                     List<API> focusAPIs, T focusItem,\n+                                     Consumer<ResultTable.CountKind> counter);\n+\n+    protected abstract String getKeyString(T t);\n+\n+\/\/    protected abstract Content build(Content title, T refItem, T modItem,\n+\/\/                                     Consumer<ResultTable.CountKind> counter);\n+\/\/\n+\/\/    protected abstract Content build(Content title, T item);\n+\n+    protected String getNameList(List<API> apis) {\n+        return apis.stream()\n+                .map(a -> a.name)\n+                .collect(Collectors.joining(\", \"));\n+    }\n+}\n+\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/PairwiseDiffBuilder.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,264 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report.html;\n+\n+import java.util.EnumMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import jdk.codetools.apidiff.Messages;\n+import jdk.codetools.apidiff.html.Content;\n+import jdk.codetools.apidiff.html.HtmlAttr;\n+import jdk.codetools.apidiff.html.HtmlTree;\n+import jdk.codetools.apidiff.html.Text;\n+import jdk.codetools.apidiff.model.ElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.ExecutableElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.ModuleElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.PackageElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.TypeElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.TypeParameterElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.VariableElementKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.ArrayTypeKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.DeclaredTypeKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.PrimitiveTypeKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.TypeVariableKey;\n+import jdk.codetools.apidiff.model.TypeMirrorKey.WildcardTypeKey;\n+\n+\/**\n+ * A class to accumulate statistics about the numbers of different kinds of changes.\n+ *\/\n+public class ResultTable {\n+    \/**\n+     * The different kinds of count recorded in a result table.\n+     *\n+     * The members are ordered according to column order in the display table.\n+     *\/\n+    public enum CountKind {\n+        ELEMENT_ADDED,\n+        ELEMENT_CHANGED,\n+        ELEMENT_REMOVED,\n+        COMMENT_ADDED,\n+        COMMENT_CHANGED,\n+        COMMENT_REMOVED,\n+        DESCRIPTION_ADDED,\n+        DESCRIPTION_CHANGED,\n+        DESCRIPTION_REMOVED\n+    }\n+\n+    private final Map<ElementKey, Map<CountKind, Integer>> entries;\n+    private final Messages msgs;\n+    private final Links links;\n+\n+    ResultTable(Messages msgs, Links links) {\n+        this.msgs = msgs;\n+        this.links = links;\n+        entries = new TreeMap<>();\n+    }\n+\n+    boolean isEmpty() {\n+        return entries.isEmpty();\n+    }\n+\n+    void inc(ElementKey eKey, CountKind ck) {\n+        add(getEntry(eKey), ck, 1);\n+    }\n+\n+    void addAll(ElementKey eKey, Map<CountKind, Integer> counts) {\n+        if (counts.values().stream().anyMatch(Objects::nonNull)) {\n+            var e = getEntry(eKey);\n+            counts.forEach((ck, i) -> add(e, ck, i));\n+        }\n+    }\n+\n+    Map<CountKind, Integer> getTotals() {\n+        Map<CountKind, Integer> totals = new EnumMap<>(CountKind.class);\n+        entries.values().forEach(e -> e.forEach((ck, i) -> add(totals, ck, i)));\n+        return totals;\n+    }\n+\n+    private Map<CountKind, Integer> getEntry(ElementKey eKey) {\n+        return entries.computeIfAbsent(eKey, e_ -> new EnumMap<>(CountKind.class));\n+    }\n+\n+    private void add(Map<CountKind, Integer> counts, CountKind ck, int i) {\n+        counts.put(ck, counts.computeIfAbsent(ck, ck_ -> 0) + i);\n+    }\n+\n+    Content toContent() {\n+        Map<CountKind, Integer> totals = getTotals();\n+\n+        HtmlTree caption = HtmlTree.CAPTION(Text.of(msgs.getString(\"summary.caption\")));\n+\n+        HtmlTree hRow1 = HtmlTree.TR();\n+        HtmlTree hRow2 = HtmlTree.TR();\n+        hRow1.add(HtmlTree.TD().set(HtmlAttr.ROWSPAN, \"2\"));\n+        \/\/ The following assumes the CountKind values are in column order\n+        Iterator<CountKind> iter = List.of(CountKind.values()).iterator();\n+        for (String k : List.of(\"summary.elements\", \"summary.comments\", \"summary.descriptions\")) {\n+            boolean noneAdded = totals.get(iter.next()) == null;\n+            boolean noneChanged = totals.get(iter.next()) == null;\n+            boolean noneRemoved = totals.get(iter.next()) == null;\n+            hRow1.add(getHead(k, noneAdded && noneChanged && noneRemoved).set(HtmlAttr.COLSPAN, \"3\"));\n+            hRow2.add(getHead(\"summary.added\", noneAdded));\n+            hRow2.add(getHead(\"summary.changed\", noneChanged));\n+            hRow2.add(getHead(\"summary.removed\", noneRemoved));\n+        }\n+        hRow1.add(getHead(\"summary.total\", false).set(HtmlAttr.ROWSPAN, \"2\"));\n+        HtmlTree head = HtmlTree.THEAD(hRow1, hRow2);\n+\n+        HtmlTree body = HtmlTree.TBODY();\n+        entries.forEach((eKey, counts) -> {\n+            HtmlTree bRow = HtmlTree.TR();\n+            bRow.add(HtmlTree.TH(links.createLink(eKey, toString(eKey))).set(HtmlAttr.SCOPE, \"row\"));\n+            for (CountKind ck : CountKind.values()) {\n+                HtmlTree cell = HtmlTree.TD();\n+                Integer c = counts.get(ck);\n+                if (c != null) {\n+                    cell.add(Text.of(String.valueOf(c)));\n+                }\n+                bRow.add(cell);\n+            }\n+            int total = counts.values().stream().mapToInt(Integer::intValue).sum();\n+            bRow.add(HtmlTree.TD(Text.of(String.valueOf(total))));\n+            body.add(bRow);\n+        });\n+\n+        HtmlTree fRow = HtmlTree.TR();\n+        fRow.add(HtmlTree.TH(Text.of(msgs.getString(\"summary.total\"))).set(HtmlAttr.SCOPE, \"row\"));\n+        HtmlTree foot = HtmlTree.TFOOT(fRow);\n+        for (CountKind ck : CountKind.values()) {\n+            HtmlTree cell = HtmlTree.TD();\n+            Integer c = totals.get(ck);\n+            if (c != null) {\n+                cell.add(Text.of(String.valueOf(c)));\n+            }\n+            fRow.add(cell);\n+        }\n+        int total = totals.values().stream().mapToInt(Integer::intValue).sum();\n+        fRow.add(HtmlTree.TD(Text.of(String.valueOf(total))));\n+\n+        return HtmlTree.TABLE(caption, head, body, foot).setClass(\"summary\");\n+    }\n+\n+    private HtmlTree getHead(String key, boolean allZero) {\n+        HtmlTree th = HtmlTree.TH(Text.of(msgs.getString(key)));\n+        if (allZero) {\n+            th.setClass(\"allZero\");\n+        }\n+        return th;\n+    }\n+\n+    private String toString(ElementKey eKey) {\n+        return toStringVisitor.toString(eKey);\n+    }\n+\n+    private final ToStringVisitor toStringVisitor = new ToStringVisitor();\n+\n+    private class ToStringVisitor\n+            implements ElementKey.Visitor<CharSequence, Void>,\n+                    TypeMirrorKey.Visitor<CharSequence, Void> {\n+        String toString(ElementKey eKey) {\n+            return eKey.accept(this, null).toString();\n+        }\n+\n+        @Override\n+        public CharSequence visitModuleElement(ModuleElementKey mKey, Void aVoid) {\n+            return mKey.name;\n+        }\n+\n+        @Override\n+        public CharSequence visitPackageElement(PackageElementKey pKey, Void aVoid) {\n+            return pKey.name;\n+        }\n+\n+        @Override\n+        public CharSequence visitTypeElement(TypeElementKey tKey, Void aVoid) {\n+            return tKey.enclosingKey instanceof TypeElementKey\n+                    ? toString(tKey.enclosingKey) + \".\" + tKey.name\n+                    : tKey.name;\n+        }\n+\n+        @Override\n+        public CharSequence visitExecutableElement(ExecutableElementKey k, Void aVoid) {\n+            return k.name + k.params.stream()\n+                    .map(this::toString)\n+                    .collect(Collectors.joining(\",\", \"(\", \")\"));\n+        }\n+\n+        @Override\n+        public CharSequence visitVariableElement(VariableElementKey k, Void aVoid) {\n+            return k.name;\n+        }\n+\n+        @Override\n+        public CharSequence visitTypeParameterElement(TypeParameterElementKey k, Void aVoid) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        String toString(TypeMirrorKey eKey) {\n+            return eKey.accept(this, null).toString();\n+        }\n+\n+        @Override\n+        public CharSequence visitArrayType(ArrayTypeKey k, Void aVoid) {\n+            return toString(k.componentKey) + \"[]\";\n+        }\n+\n+        @Override\n+        public CharSequence visitDeclaredType(DeclaredTypeKey k, Void aVoid) {\n+            return toString(k.elementKey);\n+        }\n+\n+        @Override\n+        public CharSequence visitPrimitiveType(PrimitiveTypeKey k, Void aVoid) {\n+            return k.kind.name().toLowerCase(Locale.ROOT);\n+        }\n+\n+        @Override\n+        public CharSequence visitTypeVariable(TypeVariableKey k, Void aVoid) {\n+            return k.name;\n+        }\n+\n+        @Override\n+        public CharSequence visitWildcardType(WildcardTypeKey k, Void aVoid) {\n+            StringBuilder sb = new StringBuilder(\"?\");\n+            if (k.extendsBoundKey != null) {\n+                sb.append(\"extends \").append(toString(k.extendsBoundKey));\n+            }\n+            if (k.superBoundKey != null) {\n+                sb.append(\"super \").append(toString(k.superBoundKey));\n+            }\n+            return sb.toString();\n+        }\n+\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/ResultTable.java","additions":264,"deletions":0,"binary":false,"changes":264,"status":"added"},{"patch":"@@ -0,0 +1,606 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report.html;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+import com.github.difflib.DiffUtils;\n+import com.github.difflib.patch.AbstractDelta;\n+import com.github.difflib.patch.Chunk;\n+import com.github.difflib.patch.Patch;\n+import jdk.codetools.apidiff.Log;\n+import jdk.codetools.apidiff.html.Content;\n+import jdk.codetools.apidiff.html.HtmlTree;\n+import jdk.codetools.apidiff.html.TagName;\n+import jdk.codetools.apidiff.html.Text;\n+import jdk.codetools.apidiff.model.API;\n+import jdk.codetools.apidiff.report.html.ResultTable.CountKind;\n+\n+\/**\n+ * A class to build HTML to display the differences between plain-text strings,\n+ * such as the documentation comments for corresponding elements in different\n+ * instances of an API.\n+ *\/\n+public class TextDiffBuilder extends PairwiseDiffBuilder<String> {\n+\n+    \/**\n+     * Creates an instance of a {@code TextDiffBuilder}.\n+     *\n+     * @param pageReporter the reporter for the parent page\n+     *\/\n+    public TextDiffBuilder(PageReporter<?> pageReporter) {\n+        super(pageReporter.parent.apis, pageReporter.log, pageReporter.msgs);\n+    }\n+\n+    @Override\n+    protected Content build(List<API> refAPIs, String refItem,\n+                            List<API> focusAPIs, String focusItem,\n+                            Consumer<ResultTable.CountKind> counter) {\n+        String refNames = getNameList(refAPIs);\n+        String focusNames = getNameList(focusAPIs);\n+        if (refItem != null && focusItem != null) {\n+            \/\/ item in both groups: display the comparison\n+            return build(refNames, getLines(refItem), focusNames, getLines(focusItem), counter);\n+        } else if (refItem == null) {\n+            Content title = Text.of(String.format(\"Not in %s; only in %s\", refNames, focusNames)); \/\/ TODO: improve\n+            counter.accept(CountKind.COMMENT_ADDED);\n+            return build(title, focusItem);\n+        } else {\n+            Content title = Text.of(String.format(\"Only in %s; not in %s\", refNames, focusNames)); \/\/ TODO: improve\n+            counter.accept(CountKind.COMMENT_REMOVED);\n+            return build(title, refItem);\n+        }\n+    }\n+\n+    @Override\n+    protected String getKeyString(String item) {\n+        return item;\n+    }\n+\n+    \/**\n+     * Builds HTML that displays the differences between two sets of lines.\n+     *\n+     * @param refTitle a title for the \"reference\" set of lines\n+     * @param refLines the \"reference\" set of lines\n+     * @param modTitle a title for the \"modified\" set of lines\n+     * @param modLines the \"modified\" set of lines\n+     * @param counter  a counter for the instances of the differences found in the strings\n+     *\n+     * @return the HTML nodes\n+     *\/\n+    private Content build(String refTitle, List<String> refLines,\n+                  String modTitle, List<String> modLines,\n+                  Consumer<CountKind> counter) {\n+        Patch<String> patch = DiffUtils.diff(refLines, modLines);\n+        count(patch, counter);\n+        return build(refTitle, refLines, modTitle, modLines, patch);\n+    }\n+\n+    private Content build(Content title, String item) {\n+        HtmlTree title2 = HtmlTree.DIV(title)\n+                .setClass(\"xdiffs-title\");\n+\n+        HtmlTree pre = HtmlTree.PRE(Text.of(item));\n+        List<Content> contents = List.of(title2, pre);\n+        return new HtmlTree(TagName.DIV, contents).setClass(\"xdiffs\");\n+    }\n+\n+    private void count(Patch<String> patch, Consumer<CountKind> counter) {\n+        for (AbstractDelta<String> delta : patch.getDeltas()) {\n+            Chunk<String> ref = delta.getSource();\n+            Chunk<String> mod = delta.getTarget();\n+            CountKind ck = isInsert(ref, mod) ? CountKind.COMMENT_ADDED\n+                            : isInsert(mod, ref) ? CountKind.COMMENT_REMOVED\n+                            : CountKind.COMMENT_CHANGED;\n+            counter.accept(ck);\n+        }\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the chunk on the right is as if some text has been\n+     * inserted into the chunk on the left.\n+     *\n+     * @param left the left chunk\n+     * @param right the right chunk\n+     *\n+     * @return {@code true} if the chunk on the right is as if some text has been\n+     *         inserted into the chunk on the left\n+     *\/\n+    private boolean isInsert(Chunk<String> left, Chunk<String> right) {\n+        if (left.size() == 0) {\n+            return true;\n+        }\n+\n+        if (left.size() == 1 && right.size() > 0) {\n+            String leftLine = left.getLines().get(0);\n+\n+            List<String> rightLines = right.getLines();\n+            String firstRightLine = rightLines.get(0);\n+            String lastRightLine = rightLines.get(rightLines.size() - 1);\n+            int l = Math.min(leftLine.length(), firstRightLine.length());\n+            for (int i = 0; i < l && leftLine.charAt(i) == firstRightLine.charAt(i); i++) {\n+                if (lastRightLine.endsWith(leftLine.substring(i))) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * Build HTML representing the content of a patch.\n+     *\n+     * @param refTitle the title for the \"reference\" side of the comparison\n+     * @param refLines the lines for the \"reference\" side of the comparison\n+     * @param modTitle the title for the \"modified\" side of the comparison\n+     * @param modLines the lines for the \"modified\" side of the comparison\n+     * @param patch the patch containing the differences\n+     * @return HTML displaying the differences\n+     *\/\n+    \/\/ TODO: we could support alternate presentations, perhaps\n+    \/\/       selecting one-of-n views using some input control\n+    \/\/       (e.g. radio buttons or a choice item) and JavaScript.\n+    Content build(String refTitle, List<String> refLines,\n+                  String modTitle, List<String> modLines,\n+                  Patch<String> patch) {\n+        return new SDiffs()\n+                .setReference(refTitle, refLines)\n+                .setModified(modTitle, modLines)\n+                .build(patch);\n+    }\n+\n+    private List<String> getLines(String text) {\n+        return List.of(text.split(\"\\\\R\"));\n+    }\n+\n+    \/**\n+     * A builder for side-by-side text diffs.\n+     *\n+     * <p>The structure is as follows:\n+     * <pre>{@code\n+     *     <div class=\"sdiffs\">\n+     *         <div class=\"sdiffs-ref\">\n+     *             reference-title\n+     *             <pre>\n+     *             ...\n+     *             reference-diffs\n+     *             ...\n+     *             <\/pre>\n+     *         <\/div>\n+     *         <div class=\"sdiffs-mod\">\n+     *             modified-title\n+     *             <pre>\n+     *             ...\n+     *             modified-diffs\n+     *             ...\n+     *             <\/pre>\n+     *         <\/div>\n+     *     <\/div>\n+     * }<\/pre>\n+     *\/\n+    public static class SDiffs {\n+        private String refTitle;\n+        private List<String> refLines;\n+        private String modTitle;\n+        private List<String> modLines;\n+\n+        private int contextSize = 5;\n+        private boolean showLineNumbers = true;\n+\n+        \/**\n+         * Sets the title and lines for the \"reference\" side of the comparison.\n+         *\n+         * @param title the title\n+         * @param lines the lines\n+         * @return this object\n+         *\/\n+        public SDiffs setReference(String title, List<String> lines) {\n+            this.refTitle = title;\n+            this.refLines = lines;\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the title and lines for the \"modified\" side of the comparison.\n+         *\n+         * @param title the title\n+         * @param lines the lines\n+         * @return this object\n+         *\/\n+        public SDiffs setModified(String title, List<String> lines) {\n+            this.modTitle = title;\n+            this.modLines = lines;\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the amount of context to show before and after each difference.\n+         *\n+         * @param size the number of lines to show\n+         * @return this object\n+         *\/\n+        public SDiffs setContextSize(int size) {\n+            contextSize = size;\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets whether to show line numbers in the output.\n+         *\n+         * @param showLineNumbers whether to show line numbers\n+         * @return this object\n+         *\/\n+        public SDiffs setShowLineNumbers(boolean showLineNumbers) {\n+            this.showLineNumbers = showLineNumbers;\n+            return this;\n+        }\n+\n+        \/**\n+         * Build HTML to display the differences between the two sets of input.\n+         * If an exception occurs while computing the differences, a message will\n+         * be written to the log, and {@link Content#empty} returned.\n+         *\n+         * @param log the log\n+         * @return the HTML node, or {@link Content#empty}\n+         *\/\n+        public Content build(Log log) {\n+            Patch<String> patch = DiffUtils.diff(refLines, modLines); \/\/ just differences; do not include EQUAL chunks\n+            return build(patch);\n+        }\n+\n+        \/**\n+         * Build HTML to display the differences contained in a patch.\n+         *\n+         * @param patch the patch\n+         * @return the HTML nodes\n+         *\/\n+        public Content build(Patch<String> patch) {\n+            if (patch.getDeltas().isEmpty()) {\n+                return Content.empty;\n+            }\n+\n+            List<Content> refDiffs = new ArrayList<>();\n+            List<Content> modDiffs = new ArrayList<>();\n+\n+            int refIndex = 0;\n+            int modIndex = 0;\n+            for (AbstractDelta<String> delta : patch.getDeltas()) {\n+                Chunk<String> refChunk = delta.getSource();\n+                Chunk<String> modChunk = delta.getTarget();\n+\n+                addContext(refDiffs, refLines, refIndex, refChunk.getPosition());\n+                addContext(modDiffs, modLines, modIndex, modChunk.getPosition());\n+\n+\/\/                int maxSize = Math.max(refChunk.size(), modChunk.size());\n+\/\/                addDiffLines(refDiffs, refChunk, maxSize);\n+\/\/                addDiffLines(modDiffs, modChunk, maxSize);\n+\n+                addDiffLines(refDiffs, modDiffs, delta);\n+\n+                refIndex = refChunk.last() + 1;\n+                modIndex = modChunk.last() + 1;\n+            }\n+\n+            addContext(refDiffs, refLines, refIndex, Math.min(refIndex + contextSize, refLines.size()));\n+            addContext(modDiffs, modLines, modIndex, Math.min(modIndex + contextSize, modLines.size()));\n+\n+            Content refDiv = HtmlTree.DIV()\n+                    .setClass(\"sdiffs-ref\")\n+                    .add(HtmlTree.DIV(new Text(refTitle)).setClass(\"sdiffs-title\"))\n+                    .add(refDiffs);\n+            Content modDiv = HtmlTree.DIV()\n+                    .setClass(\"sdiffs-mod\")\n+                    .add(HtmlTree.DIV(new Text(modTitle)).setClass(\"sdiffs-title\"))\n+                    .add(modDiffs);\n+            return HtmlTree.DIV(refDiv, modDiv).setClass(\"sdiffs\");\n+        }\n+\n+        private void addContext(List<Content> contents, List<String> lines, int from, int to) {\n+            if (to > from + 2 * contextSize) {\n+                addLines(contents, lines, from, from + contextSize);\n+                contents.add(new HtmlTree(TagName.HR));\n+                addLines(contents, lines, to - contextSize, to);\n+            } else {\n+                addLines(contents, lines, from, to);\n+            }\n+        }\n+\n+        void addLines(List<Content> contents, List<String> lines, int from, int to) {\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = from; i < to; i++) {\n+                if (showLineNumbers) {\n+                    sb.append(formatLineNumber(i + 1));\n+                }\n+                sb.append(lines.get(i)).append(\"\\n\");\n+            }\n+            HtmlTree pre = ensurePre(contents);\n+            pre.add(new Text(sb.toString()));\n+        }\n+\n+        \/**\n+         * Show the content of a chunk from a line-oriented diff.\n+         * The content is shown in a single block (including line numbers)\n+         * with CSS class {@code sdiffs-changed}.\n+         * The content is padding with blank lines, if necessary,\n+         * up to a given number of lines.\n+         *\n+         * @param contents the contents to which to add the details\n+         * @param chunk the chunk\n+         * @param maxSize the number of lines to be displayed\n+         *\/\n+        \/\/ An alternate presentation would be to just style the content\n+        \/\/ of each line (but not the line number) but that would not\n+        \/\/ highlight blank lines.\n+        \/\/ Another alternate presentation would be to use background color\n+        \/\/ for the CSS style.\n+        void addDiffLines(List<Content> contents, Chunk<String> chunk, int maxSize) {\n+            StringBuilder sb = new StringBuilder();\n+            List<String> lines = chunk.getLines();\n+            for (int i = 0; i < maxSize; i++) {\n+                if (i < lines.size()) {\n+                    if (showLineNumbers) {\n+                        sb.append(formatLineNumber(chunk.getPosition() + i + 1));\n+                    }\n+                    sb.append(lines.get(i));\n+                } else {\n+                    sb.append(\" \");\n+                }\n+                sb.append(\"\\n\");\n+            }\n+            HtmlTree pre = ensurePre(contents);\n+            pre.add(HtmlTree.SPAN(new Text(sb.toString())).setClass(\"sdiffs-changed\"));\n+        }\n+\n+        \/**\n+         * Show the differences in a delta from a line-oriented diff.\n+         * The chunks are tokenized and diffed, in order to show intra-delta diffs.\n+         *\n+         * @param refDiffs the content for the diffs for the reference text\n+         * @param modDiffs the content for the diffs for the modified text\n+         * @param deltaLines the delta between the two sides\n+         *\/\n+        void addDiffLines(List<Content> refDiffs, List<Content> modDiffs, AbstractDelta<String> deltaLines) {\n+            var refChunk = deltaLines.getSource();\n+            var refDefaultCSSClass = switch (deltaLines.getType()) {\n+                case CHANGE -> \"sdiffs-lines-changed\";\n+                case DELETE -> \"sdiffs-lines-deleted\";\n+                default -> null;\n+            };\n+            var refTDiffs = new TokenDiffs(refDiffs, refChunk, refDefaultCSSClass);\n+            List<String> refTokens = tokens(refChunk.getLines());\n+\n+            var modChunk = deltaLines.getTarget();\n+            var modDefaultCSSClass = switch (deltaLines.getType()) {\n+                case CHANGE -> \"sdiffs-lines-changed\";\n+                case INSERT -> \"sdiffs-lines-inserted\";\n+                default -> null;\n+            };\n+            var modTDiffs = new TokenDiffs(modDiffs, modChunk, modDefaultCSSClass);\n+            List<String> modTokens = tokens(modChunk.getLines());\n+\n+            Patch<String> patch = DiffUtils.diff(refTokens, modTokens, true); \/\/ include EQUAL chunks\n+\n+            for (var delta : patch.getDeltas()) {\n+                var deltaType = delta.getType();\n+                String cssClass = switch (deltaType) {\n+                    case EQUAL -> null;\n+                    case DELETE -> \"sdiffs-chars-deleted\";\n+                    case CHANGE -> \"sdiffs-chars-changed\";\n+                    case INSERT -> \"sdiffs-chars-inserted\";\n+                };\n+                delta.getSource().getLines().forEach(t -> refTDiffs.add(t, cssClass));\n+                delta.getTarget().getLines().forEach(t -> modTDiffs.add(t, cssClass));\n+            }\n+\n+            int refChunkSize = refChunk.size();\n+            int modChunkSize = modChunk.size();\n+            int maxChunkSize = Math.max(refChunkSize, modChunkSize);\n+            refTDiffs.padNewlines(maxChunkSize - refChunkSize);\n+            modTDiffs.padNewlines(maxChunkSize - modChunkSize);\n+        }\n+\n+        \/**\n+         * A builder for the diffs in a sequence of tokens, that can be used to show\n+         * the diffs within a chunk in an {@link SDiffs} comparison.\n+         *\/\n+        class TokenDiffs {\n+            private final HtmlTree pre;\n+            private StringBuilder pendingText;\n+            private String pendingCSSClass;\n+            private int pendingLineNumber;\n+            private int displayedLineNumber;\n+            private final String defaultCSSClass;\n+\n+            \/**\n+             * Creates a builder to display one side of the differences in a {@code SDiffs} chunk.\n+             *\n+             * @param diffs the content of line-diffs to which the token-diffs will be added\n+             * @param lineChunk the chunk containing the differences, used to get the initial line number\n+             * @param defaultCSSClass the default CSS class for the diffs, such as a background color\n+             *\/\n+            TokenDiffs(List<Content> diffs, Chunk<String> lineChunk, String defaultCSSClass) {\n+                pre = ensurePre(diffs);\n+                pendingText = new StringBuilder();\n+                pendingCSSClass = null;\n+                pendingLineNumber = lineChunk.getPosition() + 1;\n+                displayedLineNumber = -1;\n+                this.defaultCSSClass = defaultCSSClass;\n+            }\n+\n+            \/**\n+             * Adds a token to the display.\n+             * Newlines should be presented as a single-character string, and not within a longer string.\n+             *\n+             * @param token the token\n+             * @param cssClass the class for the token, or {@code null} if none required\n+             *\/\n+            void add(String token, String cssClass) {\n+                if (token.equals(\"\\n\")) {\n+                    flush();\n+                    pre.add(\"\\n\");\n+                    pendingLineNumber++;\n+                    return;\n+                }\n+\n+                if (Objects.equals(cssClass, pendingCSSClass)) {\n+                    pendingText.append(token);\n+                } else {\n+                    flush();\n+                    pendingText.append(token);\n+                    pendingCSSClass = cssClass;\n+                }\n+            }\n+\n+            \/**\n+             * Flush any pending text.\n+             *\/\n+            void flush() {\n+                if (pendingLineNumber > displayedLineNumber) {\n+                    pre.add(new Text(formatLineNumber(pendingLineNumber)));\n+                    displayedLineNumber = pendingLineNumber;\n+                }\n+                if (!pendingText.isEmpty()) {\n+                    var text = new Text(pendingText.toString());\n+                    pre.add(pendingCSSClass != null ? HtmlTree.SPAN(text).setClass(pendingCSSClass)\n+                            : defaultCSSClass != null ? HtmlTree.SPAN(text).setClass(defaultCSSClass)\n+                            : text);\n+                }\n+                pendingText.setLength(0);\n+            }\n+\n+            \/**\n+             * Pad the output with newlines.\n+             *\n+             * @param n the number of newlines required\n+             *\/\n+            void padNewlines(int n) {\n+                if (n > 0) {\n+                    pre.add(new Text(\"\\n\".repeat(n)));\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Break a series of lines into a series of smaller tokens.\n+         * In this implementation, the tokens are:\n+         *\n+         * <ul>\n+         * <li>identifiers\n+         * <li>decimal integers\n+         * <li>runs of horizontal whitespace\n+         * <li>other individual characters\n+         * <\/ul>\n+         *\n+         * Newline characters should not be found in the input lines.\n+         * A string containing a newline character will be added to the list of\n+         * tokens after each line has been processed.\n+         *\n+         * Other implementations are possible, including all characters as individual tokens.\n+         * The tradeoff is the desired granularity and resolution of the resulting tokens.\n+         *\n+         * @param lines the input lines\n+         * @return the tokens\n+         *\/\n+        List<String> tokens(List<String> lines) {\n+            var result = new ArrayList<String>();\n+            for (var line : lines) {\n+                int i = 0;\n+                while (i < line.length()) {\n+                    char ch = line.charAt(i);\n+                    if (Character.isUnicodeIdentifierStart(ch)) {\n+                        int p = i++;\n+                        while (i < line.length()) {\n+                            ch = line.charAt(i);\n+                            if (!Character.isUnicodeIdentifierPart(ch)) {\n+                                break;\n+                            }\n+                            i++;\n+                        }\n+                        result.add(line.substring(p, i));\n+                    } else if (Character.isDigit(ch)) {\n+                        int p = i++;\n+                        while (i < line.length()) {\n+                            ch = line.charAt(i);\n+                            if (!Character.isDigit(ch)) {\n+                                break;\n+                            }\n+                            i++;\n+                        }\n+                        result.add(line.substring(p, i));\n+                    } else if (Character.isWhitespace(ch)) {\n+                        int p = i++;\n+                        while (i < line.length()) {\n+                            ch = line.charAt(i);\n+                            if (!Character.isWhitespace(ch)) {\n+                                break;\n+                            }\n+                            i++;\n+                        }\n+                        result.add(line.substring(p, i));\n+                    } else {\n+                        result.add(String.valueOf(ch));\n+                        i++;\n+                    }\n+                }\n+                result.add(\"\\n\");\n+            }\n+            return result;\n+        }\n+\n+        \/**\n+         * Ensures that a list of contents has a {@code <pre>} element as the last\n+         * element, and return that element.  A new element will be created and\n+         * added to the list if the last element is not a {@code <pre>} element.\n+         *\n+         * @param contents the list of contents\n+         * @return the {@code <pre>} element at the end of the list\n+         *\/\n+        HtmlTree ensurePre(List<Content> contents) {\n+            if (contents.size() > 0) {\n+                Content last = contents.get(contents.size() - 1);\n+                if (last instanceof HtmlTree t && t.hasTag(TagName.PRE)) {\n+                    return t;\n+                }\n+            }\n+            HtmlTree t = HtmlTree.PRE();\n+            contents.add(t);\n+            return t;\n+        }\n+\n+        private String formatLineNumber(int n) {\n+            return String.format(\"%4d \", n);\n+        }\n+\n+\/\/        private void showChunk(String name, Chunk<String> c) {\n+\/\/            System.err.println(\"CHUNK: \" + name + \" \" + (c == null ? \"null\" : c.toString()));\n+\/\/        }\n+\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/TextDiffBuilder.java","additions":606,"deletions":0,"binary":false,"changes":606,"status":"added"},{"patch":"@@ -0,0 +1,1124 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.apidiff.report.html;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.Name;\n+import javax.lang.model.element.Parameterizable;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+\n+import jdk.codetools.apidiff.html.Content;\n+import jdk.codetools.apidiff.html.Entity;\n+import jdk.codetools.apidiff.html.HtmlAttr;\n+import jdk.codetools.apidiff.html.HtmlTree;\n+import jdk.codetools.apidiff.html.Text;\n+import jdk.codetools.apidiff.model.API;\n+import jdk.codetools.apidiff.model.APIMap;\n+import jdk.codetools.apidiff.model.AccessKind;\n+import jdk.codetools.apidiff.model.ElementExtras;\n+import jdk.codetools.apidiff.model.ElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.ExecutableElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.TypeElementKey;\n+import jdk.codetools.apidiff.model.ElementKey.VariableElementKey;\n+import jdk.codetools.apidiff.model.IntTable;\n+import jdk.codetools.apidiff.model.Position;\n+import jdk.codetools.apidiff.model.Position.RelativePosition;\n+import jdk.codetools.apidiff.model.SerializedForm;\n+import jdk.codetools.apidiff.model.TypeMirrorKey;\n+import jdk.codetools.apidiff.report.SignatureVisitor;\n+\n+\/**\n+ * A reporter that generates an HTML page for the differences in\n+ * a type declaration.\n+ *\/\n+class TypePageReporter extends PageReporter<TypeElementKey> {\n+    private APIMap<? extends TypeElement> tMap = null;\n+\n+    private final ElementExtras elementExtras = ElementExtras.instance();\n+\n+    TypePageReporter(HtmlReporter parent, ElementKey tKey) {\n+        super(parent, (TypeElementKey) tKey);\n+    }\n+\n+    \/**\n+     * Writes a page containing details for a single type element in a given API.\n+     *\n+     * @param api the API containing the element\n+     * @param te  the type element\n+     *\/\n+    void writeFile(API api, TypeElement te) {\n+        Position pagePos = Position.of(pageKey);\n+        APIMap<TypeElement> apiMap = APIMap.of(api, te);\n+        comparing(pagePos, apiMap);\n+        Set<API> missing = parent.apis.stream()\n+                .filter(a -> a != api)\n+                .collect(Collectors.toSet());\n+        if (!missing.isEmpty()) {\n+            reportMissing(pagePos, missing);\n+        }\n+        completed(pagePos, true);\n+    }\n+\n+    @Override\n+    protected void writeFile() {\n+        \/\/ If this is the only copy of the type in the APIs being compared,\n+        \/\/ its enclosed elements will not have been compared or reported, and\n+        \/\/ so will not be written out as a side effect of reporting the\n+        \/\/ comparison.  So, simulate the comparison of the enclosed members now,\n+        \/\/ to initialize various data structures, and write out files for\n+        \/\/ any nested classes and interfaces.\n+        APIMap<? extends Element> tMap = getElementMap(pageKey);\n+        if (tMap.size() == 1) {\n+            AccessKind accessKind = parent.options.getAccessKind();\n+            Map.Entry<API, ? extends Element> entry = tMap.entrySet().iterator().next();\n+            API api = entry.getKey();\n+            TypeElement te = (TypeElement) entry.getValue();\n+            for (Element e : te.getEnclosedElements()) {\n+                if (!accessKind.accepts(e)) {\n+                    continue;\n+                }\n+                if (e.getKind().isClass() || e.getKind().isInterface()) {\n+                    TypePageReporter r = (TypePageReporter) parent.getPageReporter(ElementKey.of(e));\n+                    r.writeFile(api, (TypeElement) e);\n+                }\n+                ElementKey eKey = ElementKey.of(e);\n+                Position ePos = Position.of(eKey);\n+                comparing(ePos, APIMap.of(api, e));\n+                completed(ePos, true);\n+            }\n+        }\n+\n+        super.writeFile();\n+    }\n+\n+    @Override\n+    protected String getTitle() {\n+        return new SignatureVisitor(apiMaps).getSignature(pageKey);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void comparing(Position pos, APIMap<?> apiMap) {\n+        super.comparing(pos, apiMap);\n+        if (pos.isElement() && pos.asElementKey() == pageKey) {\n+            this.tMap = (APIMap<? extends TypeElement>) apiMap;\n+        }\n+    }\n+\n+    @Override\n+    protected Content buildSignature() {\n+        Position pagePos = Position.of(pageKey);\n+        List<Content> contents = new ArrayList<>();\n+        contents.addAll(buildAnnotations(pagePos));\n+        contents.add(new ModifiersBuilder().build(pagePos, tMap));\n+        contents.add(Text.SPACE);\n+        contents.add(buildKind());\n+        contents.add(Text.SPACE);\n+        contents.add(Text.of(pageKey.name));\n+\n+        Content typarams = new TypeParameterBuilder().build(pagePos, tMap);\n+        if (typarams != Content.empty) {\n+            contents.add(typarams);\n+        }\n+\n+        Content components = new RecordComponentBuilder().build(pagePos, tMap);\n+        if (components != Content.empty) {\n+            contents.add(components);\n+        }\n+\n+        contents.add(Text.SPACE);\n+\n+        Content superclass = buildSuperclass();\n+        if (superclass != Content.empty) {\n+            contents.add(superclass);\n+        }\n+\n+        Content superinterfaces = buildSuperinterfaces();\n+        if (superinterfaces != Content.empty) {\n+            contents.add(superinterfaces);\n+        }\n+\n+        Content permittedSubclasses = buildPermittedSubclasses();\n+        if (permittedSubclasses != Content.empty) {\n+            contents.add(permittedSubclasses);\n+        }\n+\n+        return HtmlTree.DIV(contents).setClass(\"signature\");\n+    }\n+\n+    Content buildKind() {\n+        Position pos = Position.of(pageKey);\n+        if (differentKinds.containsKey(pos)) {\n+            return new DiffBuilder().build(tMap, te -> Keywords.of(te.getKind()));\n+        } else {\n+            TypeElement te = (TypeElement) tMap.values().iterator().next();\n+            return Keywords.of(te.getKind());\n+        }\n+    }\n+\n+    private Content buildSuperclass() {\n+        boolean noSuperclasses = tMap.values().stream()\n+                .map(e -> ((TypeElement) e).getSuperclass())\n+                .allMatch(e -> e.getKind() == TypeKind.NONE);\n+        if (noSuperclasses) {\n+            return Content.empty;\n+        }\n+\n+        Content superclass = buildType(Position.of(pageKey).superclass(),\n+                () -> ((TypeElement) tMap.values().iterator().next()).getSuperclass());\n+        return HtmlTree.DIV(Keywords.EXTENDS, Text.SPACE, superclass).setClass(\"superclass\");\n+    }\n+\n+    private Content buildSuperinterfaces() {\n+        boolean noSuperinterfaces = tMap.values().stream()\n+                .map(e -> ((TypeElement) e).getInterfaces())\n+                .allMatch(List::isEmpty);\n+        if (noSuperinterfaces) {\n+            return Content.empty;\n+        }\n+\n+        List<Content> contents = new ArrayList<>();\n+        Set<Content> keywords = tMap.values().stream()\n+                .map(e -> {\n+                    return switch (e.getKind()) {\n+                        case CLASS, ENUM -> Keywords.IMPLEMENTS;\n+                        case ANNOTATION_TYPE, INTERFACE -> Keywords.EXTENDS;\n+                        default -> throw new IllegalStateException((e.getKind().toString()));\n+                    };\n+                })\n+                .collect(Collectors.toCollection(LinkedHashSet::new)); \/\/ preserve order of discovery\n+        if (keywords.size() == 1) {\n+            contents.add(keywords.iterator().next());\n+        } else {\n+            contents.add(new DiffBuilder().build(new ArrayList<>(keywords)));\n+        }\n+        contents.add(Text.SPACE);\n+\n+        \/\/ build the map of all superinterfaces for the type\n+        Map<ElementKey, APIMap<TypeMirror>> allSuperinterfaces = new TreeMap<>();\n+        for (Map.Entry<API, ? extends Element> entry : tMap.entrySet()) {\n+            API api = entry.getKey();\n+            TypeElement te = (TypeElement) entry.getValue();\n+            for (TypeMirror tm : te.getInterfaces()) {\n+                Element i = api.getTypes().asElement(tm);\n+                allSuperinterfaces.computeIfAbsent(ElementKey.of(i), _t -> APIMap.of()).put(api, tm);\n+            }\n+        }\n+\n+        \/\/ TODO: should this be a list? the mildly tricky part is adding the comma separator\n+        Set<API> apis = tMap.keySet();\n+        boolean needComma = false;\n+        for (Map.Entry<ElementKey, APIMap<TypeMirror>> entry : allSuperinterfaces.entrySet()) {\n+            ElementKey ek = entry.getKey();\n+            APIMap<TypeMirror> tMap = entry.getValue();\n+            if (needComma) {\n+                contents.add(Text.of(\", \"));\n+            } else {\n+                needComma = true;\n+            }\n+            \/\/ TODO: use factory method\n+            Position pos = Position.of(pageKey).superinterface(ek);\n+            contents.add(buildType(pos, apis, () -> tMap.values().iterator().next()));\n+        }\n+\n+        return HtmlTree.DIV(contents).setClass(\"superinterfaces\");\n+    }\n+\n+    private Content buildPermittedSubclasses() {\n+        boolean noPermittedSubclasses = tMap.values().stream()\n+                .map(e -> elementExtras.getPermittedSubclasses((TypeElement) e))\n+                .allMatch(List::isEmpty);\n+        if (noPermittedSubclasses) {\n+            return Content.empty;\n+        }\n+\n+        List<Content> contents = new ArrayList<>();\n+        contents.add(Keywords.PERMITS);\n+        contents.add(Text.SPACE);\n+\n+        \/\/ build the map of all permitted subclasses for the type\n+        Map<ElementKey, APIMap<TypeMirror>> allPermittedSubclasses = new TreeMap<>();\n+        for (Map.Entry<API, ? extends Element> entry : tMap.entrySet()) {\n+            API api = entry.getKey();\n+            TypeElement te = (TypeElement) entry.getValue();\n+            for (TypeMirror tm : elementExtras.getPermittedSubclasses(te)) {\n+                Element i = api.getTypes().asElement(tm);\n+                allPermittedSubclasses.computeIfAbsent(ElementKey.of(i), _t -> APIMap.of()).put(api, tm);\n+            }\n+        }\n+\n+        \/\/ TODO: should this be a list? the mildly tricky part is adding the comma separator\n+        Set<API> apis = tMap.keySet();\n+        boolean needComma = false;\n+        for (Map.Entry<ElementKey, APIMap<TypeMirror>> entry : allPermittedSubclasses.entrySet()) {\n+            ElementKey ek = entry.getKey();\n+            APIMap<TypeMirror> scMap = entry.getValue();\n+            if (needComma) {\n+                contents.add(Text.of(\", \"));\n+            } else {\n+                needComma = true;\n+            }\n+            \/\/ TODO: use factory method\n+            Position pos = Position.of(pageKey).permittedSubclass(ek);\n+            contents.add(buildType(pos, apis, scMap));\n+        }\n+\n+        return HtmlTree.DIV(contents).setClass(\"permitted-subclasses\");\n+    }\n+\n+    private Content buildType(Position tPos, Supplier<TypeMirror> archetype) {\n+        APIMap<? extends TypeMirror> types;\n+        if ((types = differentTypes.get(tPos)) != null) {\n+            return new DiffBuilder().build(types, this::buildType);\n+        } else {\n+            TypeMirror tm = archetype.get();\n+            if (tm == null) {\n+                return Content.empty;\n+            }\n+            return buildType(tm);\n+        }\n+    }\n+\n+    private Content buildType(Position tPos, Set<API> apis, Supplier<TypeMirror> archetype) {\n+        APIMap<? extends TypeMirror> types;\n+        if ((types = differentTypes.get(tPos)) != null) {\n+            return new DiffBuilder().build(apis, types, this::buildType);\n+        } else {\n+            TypeMirror tm = archetype.get();\n+            if (tm == null) {\n+                return Content.empty;\n+            }\n+            return buildType(tm);\n+        }\n+    }\n+\n+    private Content buildType(Position tPos, Set<API> apis, APIMap<TypeMirror> tMap) {\n+        if (differentTypes.get(tPos) != null || tMap.size() < apis.size()) {\n+            return new DiffBuilder().build(apis, tMap, this::buildType);\n+        } else {\n+            return buildType(tMap.values().iterator().next());\n+        }\n+    }\n+\n+    \/\/ TODO: maybe use shared TypeBuilder and handle null there\n+    private Content buildType(TypeMirror t) {\n+        return (t == null) ? Entity.NBSP : new TypeBuilder().build(t);\n+    }\n+\n+    @Override\n+    protected List<Content> buildEnclosedElements() {\n+        List<Content> list = new ArrayList<>();\n+        addEnclosedElements(list, \"heading.nested-types\", ek -> ek.is(ElementKey.Kind.TYPE));\n+        addEnclosedElements(list, \"heading.enum-constants\", ek -> ek.is(ElementKind.ENUM_CONSTANT));\n+        addEnclosedElements(list, \"heading.fields\", ek -> ek.is(ElementKind.FIELD));\n+        addEnclosedElements(list, \"heading.constructors\", ek -> ek.is(ElementKind.CONSTRUCTOR));\n+        boolean isAnnoType = tMap.values().stream()\n+                .map(Element::getKind)\n+                .allMatch(k -> k == ElementKind.ANNOTATION_TYPE);\n+        String mTitle = isAnnoType ? \"heading.elements\" : \"heading.methods\";\n+        addEnclosedElements(list, mTitle, ek -> ek.is(ElementKind.METHOD));\n+\n+        list.add(new SerializedFormBuilder().build());\n+\n+        return list;\n+    }\n+\n+    \/**\n+     * Build content for an enclosed element.\n+     *\n+     * <p>If the element is an executable element or variable element, the content is generated\n+     * inline; if the element is a nested type, a link to the page for the type is generated.\n+     *\n+     * @param eKey the key for the enclosed element\n+     *\n+     * @return the content\n+     *\/\n+    @Override\n+    protected Content buildEnclosedElement(ElementKey eKey) {\n+        return switch (eKey.kind) {\n+            case TYPE -> super.buildEnclosedElement(eKey);\n+            case EXECUTABLE -> new ExecutableBuilder((ExecutableElementKey) eKey).build();\n+            case VARIABLE -> new VariableBuilder((VariableElementKey) eKey).build();\n+            default -> throw new IllegalArgumentException((eKey.toString()));\n+        };\n+    }\n+\n+    \/**\n+     * A builder for different instances of a set of modifiers in different instances of an API.\n+     *\/\n+    \/\/ TODO: display implicit modifiers in gray\n+    \/\/       ... e.g. 'abstract' on interface, 'final' on enum declaration, etc.\n+    protected class ModifiersBuilder {\n+        private final Set<Modifier> allAccessMods = EnumSet.of(Modifier.PUBLIC, Modifier.PROTECTED, Modifier.PRIVATE);\n+\n+        public Content build(ElementKey eKey, APIMap<? extends Element> eMap) {\n+            return build(Position.of(eKey), eMap);\n+        }\n+\n+        public Content build(Position ePos, APIMap<? extends Element> eMap) {\n+            if (differentModifiers.containsKey(ePos)) {\n+                \/\/ full build, with differences\n+                return build(eMap);\n+            } else {\n+                \/\/ fast-track build, since all are the same\n+                List<Content> contents = new ArrayList<>();\n+                Element e = eMap.values().iterator().next();\n+                simpleAddModifiers(contents, e.getModifiers());\n+                return wrap(contents);\n+            }\n+        }\n+\n+        public Content build(APIMap<? extends Element> eMap) {\n+            List<Content> contents = new ArrayList<>();\n+\n+            if (eMap.size() == 1) {\n+                simpleAddModifiers(contents, eMap.values().iterator().next().getModifiers());\n+            } else {\n+                addAccessModifiers(contents, eMap);\n+\n+                for (Modifier m : Modifier.values()) {\n+                    switch (m) {\n+                        case PUBLIC:\n+                        case PROTECTED:\n+                        case PRIVATE:\n+                        case NATIVE:\n+                        case SYNCHRONIZED:\n+                            break;\n+\n+                        default:\n+                            addModifier(contents, m, eMap);\n+                    }\n+                }\n+            }\n+\n+            return wrap(contents);\n+        }\n+\n+        void simpleAddModifiers(List<Content> content, Set<Modifier> mods) {\n+            for (Modifier m : mods) {\n+                switch (m) {\n+                    case NATIVE:\n+                    case SYNCHRONIZED:\n+                        continue;\n+                }\n+\n+                if (!content.isEmpty()) {\n+                    content.add(Text.SPACE);\n+                }\n+                content.add(Keywords.of(m));\n+            }\n+        }\n+\n+\n+        void addAccessModifiers(List<Content> content, APIMap<? extends Element> eMap) {\n+            \/\/ deal with the access modifiers as a group of which at most one may be set\n+            boolean allEqual = true;\n+            Set<Modifier> accessMods = null;\n+            for (Element e : eMap.values()) {\n+                Set<Modifier> mods;\n+                if (e.getModifiers().isEmpty()) {\n+                    mods = Collections.emptySet();\n+                } else {\n+                    mods = EnumSet.copyOf(e.getModifiers());\n+                    mods.retainAll(allAccessMods);\n+                }\n+                if (accessMods == null) {\n+                    accessMods = mods;\n+                } else {\n+                    if (!mods.equals(accessMods)) {\n+                        allEqual = false;\n+                        break;\n+                    }\n+                }\n+            }\n+            assert accessMods != null;\n+\n+            if (allEqual) {\n+                for (Modifier m : allAccessMods) {\n+                    if (accessMods.contains(m)) {\n+                        content.add(Keywords.of(m));\n+                        break;\n+                    }\n+                }\n+            } else {\n+                APIMap<Content> diffs = APIMap.of();\n+                for (Map.Entry<API, ? extends Element> entry : eMap.entrySet()) {\n+                    API api = entry.getKey();\n+                    Element e = entry.getValue();\n+                    Set<Modifier> eMods = e.getModifiers();\n+                    Modifier m = null;\n+                    for (Modifier am : allAccessMods) {\n+                        if (eMods.contains(am)) {\n+                            m = am;\n+                            break;\n+                        }\n+                    }\n+                    diffs.put(api, (m != null) ? Keywords.of(m) : Entity.NBSP);\n+                }\n+                content.add(new DiffBuilder().build(diffs));\n+            }\n+        }\n+\n+        void addModifier(List<Content> content, Modifier m, APIMap<? extends Element> eMap) {\n+            boolean allEqual = true;\n+            Boolean present = null;\n+            for (Element e : eMap.values()) {\n+                boolean b = e.getModifiers().contains(m);\n+                if (present == null) {\n+                    present = b;\n+                } else {\n+                    if (b != present) {\n+                        allEqual = false;\n+                        break;\n+                    }\n+                }\n+            }\n+            assert present != null;\n+\n+            if (allEqual) {\n+                if (present) {\n+                    if (!content.isEmpty()) {\n+                        content.add(Text.SPACE);\n+                    }\n+                    content.add(Keywords.of(m));\n+                }\n+            } else {\n+                if (!content.isEmpty()) {\n+                    content.add(Text.SPACE);\n+                }\n+                content.add(new DiffBuilder().build(eMap, e ->\n+                        (e.getModifiers().contains(m)) ? Keywords.of(m) : Entity.NBSP));\n+            }\n+        }\n+\n+        private Content wrap(List<Content> content) {\n+            return HtmlTree.SPAN(content).setClass(\"modifiers\");\n+        }\n+\n+    }\n+\n+    private class ExecutableBuilder {\n+        private final Position ePos;\n+\n+        ExecutableBuilder(ExecutableElementKey eKey) {\n+            this.ePos = Position.of(eKey);\n+        }\n+\n+        ExecutableBuilder(Position ePos) {\n+            this.ePos = ePos;\n+        }\n+\n+        Content build() {\n+            Content eq = getResultGlyph(ePos);\n+\n+            \/\/ TODO: could move to final field\n+            APIMap<? extends Element> eMap = getElementMap(ePos);\n+            \/\/ by design, they should all have the same ElementKind,\n+            \/\/ so pick the first\n+            Element e = eMap.values().iterator().next();\n+            ElementKind eKind = e.getKind();\n+\n+            List<Content> contents = new ArrayList<>();\n+            contents.addAll(buildAnnotations(ePos));\n+            contents.add(new ModifiersBuilder().build(ePos, eMap));\n+            contents.add(Text.SPACE);\n+\n+            Content typarams = new TypeParameterBuilder().build(ePos, eMap);\n+            if (typarams != Content.empty) {\n+                contents.add(typarams);\n+                contents.add(Text.SPACE);\n+            }\n+\n+            switch (eKind) {\n+                case CONSTRUCTOR ->\n+                    \/\/ no return type\n+                    contents.add(Text.of(pageKey.name.toString()));\n+\n+                case METHOD -> {\n+                    contents.add(buildType(ePos,\n+                            ((ExecutableElement) e)::getReturnType));\n+                    contents.add(Text.SPACE);\n+                    contents.add(Text.of(e.getSimpleName()));\n+                }\n+\n+                default -> throw new IllegalStateException(eKind.toString());\n+            }\n+\n+            contents.add(Text.of(\"(\"));\n+            Content parameters = buildParameters(ePos);\n+            if (parameters != Content.empty) {\n+                contents.add(parameters);\n+            }\n+            contents.add(Text.of(\")\"));\n+\n+            Content defaultValue = buildDefaultValue(ePos);\n+            if (defaultValue != Content.empty) {\n+                contents.add(Text.SPACE);\n+                contents.add(Keywords.DEFAULT);\n+                contents.add(Text.SPACE);\n+                contents.add(defaultValue);\n+            }\n+\n+            Content throwsTypes = buildThrows(ePos);\n+            if (throwsTypes != Content.empty) {\n+                contents.add(Text.SPACE);\n+                contents.add(throwsTypes);\n+            }\n+\n+            HtmlTree signature = HtmlTree.DIV(contents).setClass(\"signature\");\n+            Content docComments = buildDocComments(ePos);\n+            Content apiDescriptions = buildAPIDescriptions(ePos);\n+\n+            return HtmlTree.DIV(eq, buildMissingInfo(ePos), buildNotes(ePos),\n+                    signature, docComments, apiDescriptions)\n+                    .setClass(\"element\")\n+                    .set(HtmlAttr.ID, links.getId(ePos));\n+        }\n+\n+        private Content buildParameters(Position ePos) {\n+            APIMap<? extends Element> eMap = getElementMap(ePos);\n+\n+            boolean noReceiverAnnos = eMap.entrySet().stream()\n+                    .map(e -> {\n+                        API api = e.getKey();\n+                        ExecutableElement ee = (ExecutableElement) e.getValue();\n+                        TypeMirror tm = ee.getReceiverType();\n+                        \/\/ The following conditional expression is a workaround;\n+                        \/\/ The spec says that NoType should be returned instead of null.\n+                        return tm == null ? api.getTypes().getNoType(TypeKind.NONE) : tm;\n+                    })\n+                    .map(TypeMirror::getAnnotationMirrors)\n+                    .allMatch(List::isEmpty);\n+\n+            int parameterCount = eMap.values().stream()\n+                    .mapToInt(e -> ((ExecutableElement) e).getParameters().size())\n+                    .max()\n+                    .orElse(0);\n+\n+            if (noReceiverAnnos && parameterCount == 0) {\n+                return Content.empty;\n+            }\n+\n+            List<Content> contents = new ArrayList<>();\n+            boolean needComma = false;\n+            if (!noReceiverAnnos) {\n+                contents.add(todo(\"receiver\"));\n+                needComma = true;\n+            }\n+\n+            if (parameterCount > 0) {\n+                IntTable<VariableElement> pTable = new IntTable<>();\n+                eMap.forEach((api, e) -> pTable.put(api, ((ExecutableElement) e).getParameters()));\n+                for (int i = 0; i < parameterCount; i++) {\n+                    Position pPos = ePos.parameter(i);\n+                    Content parameter = buildParameter(pPos, pTable.entries(i));\n+                    if (needComma) {\n+                        contents.add(Text.of(\", \"));\n+                    }\n+                    contents.add(parameter);\n+                    needComma = true;\n+                }\n+            }\n+            return HtmlTree.SPAN(contents).setClass(\"parameters\");\n+        }\n+\n+        Content buildParameter(Position vPos, APIMap<VariableElement> vMap) {\n+            List<Content> contents = new ArrayList<>();\n+            contents.addAll(buildAnnotations(vPos));\n+\n+            VariableElement ve = vMap.values().iterator().next();\n+            \/\/ no modifiers for parameters\n+            contents.add(buildType(vPos, ve::asType));\n+            contents.add(Text.SPACE);\n+\n+            Name vName = ve.getSimpleName();\n+            boolean sameName = vMap.values().stream()\n+                    .map(Element::getSimpleName)\n+                    .allMatch(n -> n.contentEquals(vName));\n+            if (sameName) {\n+                contents.add(Text.of(vName));\n+            } else {\n+                contents.add(new DiffBuilder().build(vMap, e -> Text.of(e.getSimpleName())));\n+            }\n+\n+            return HtmlTree.SPAN(contents).setClass(\"parameter\");\n+        }\n+\n+        private Content buildThrows(Position ePos) {\n+            APIMap<? extends Element> eMap = getElementMap(ePos);\n+            boolean noThrows = eMap.values().stream()\n+                    .map(e -> ((ExecutableElement) e).getThrownTypes())\n+                    .allMatch(List::isEmpty);\n+            if (noThrows) {\n+                return Content.empty;\n+            }\n+\n+            \/\/ TODO: use latest apiMaps\n+            \/\/ build the map of all throws for the executable\n+            Map<TypeMirrorKey, APIMap<TypeMirror>> allThrows = new TreeMap<>();\n+            for (Map.Entry<API, ? extends Element> entry : eMap.entrySet()) {\n+                API api = entry.getKey();\n+                ExecutableElement ee = (ExecutableElement) entry.getValue();\n+                for (TypeMirror tm : ee.getThrownTypes()) {\n+                    allThrows.computeIfAbsent(TypeMirrorKey.of(tm), _t -> APIMap.of()).put(api, tm);\n+                }\n+            }\n+\n+            \/\/ TODO: should this be a list? the mildly tricky part is adding the comma separator\n+            Set<API> apis = eMap.keySet();\n+            List<Content> contents = new ArrayList<>();\n+            boolean needComma = false;\n+            for (Map.Entry<TypeMirrorKey, APIMap<TypeMirror>> entry : allThrows.entrySet()) {\n+                TypeMirrorKey tmk = entry.getKey();\n+                APIMap<TypeMirror> tMap = entry.getValue();\n+                if (needComma) {\n+                    contents.add(Text.of(\", \"));\n+                } else {\n+                    needComma = true;\n+                }\n+                \/\/ TODO: use factory method\n+                Position pos = ePos.exception(tmk);\n+                contents.add(buildType(pos, apis, () -> tMap.values().iterator().next()));\n+            }\n+            return HtmlTree.SPAN(Keywords.THROWS, Text.SPACE).setClass(\"throws\").add(contents);\n+        }\n+\n+        private Content buildDefaultValue(Position ePos) {\n+            APIMap<? extends Element> eMap = getElementMap(ePos);\n+            boolean noDefaultValues = eMap.values().stream()\n+                    .map(e -> ((ExecutableElement) e).getDefaultValue())\n+                    .allMatch(Objects::isNull);\n+            if (noDefaultValues) {\n+                return Content.empty;\n+            }\n+            List<Content> contents = new ArrayList<>();\n+            RelativePosition<?> dvPos = ePos.defaultValue();\n+            contents.addAll(new AnnotationValueBuilder().buildAnnoValue(dvPos));\n+            return HtmlTree.SPAN(contents).setClass(\"defaultValue\");\n+        }\n+    }\n+\n+    private class VariableBuilder {\n+\n+        private final VariableElementKey vKey;\n+        private final Position vPos;\n+\n+        VariableBuilder(VariableElementKey vKey) {\n+            this.vKey = vKey;\n+            vPos = Position.of(vKey);\n+        }\n+\n+        private Content build() {\n+            Content eq = getResultGlyph(vPos);\n+\n+            APIMap<? extends Element> vMap = getElementMap(vKey);\n+            \/\/ by design, they should all have the same ElementKind,\n+            \/\/ so pick the first\n+            VariableElement ve = (VariableElement) vMap.values().iterator().next();\n+            ElementKind eKind = ve.getKind();\n+\n+            List<Content> contents = new ArrayList<>();\n+            contents.addAll(buildAnnotations(vPos));\n+\n+            switch (eKind) {\n+                case ENUM_CONSTANT ->\n+                    \/\/ no modifiers type needed\n+                    contents.add(Text.of(ve.getSimpleName()));\n+\n+                case FIELD -> {\n+                    contents.add(new ModifiersBuilder().build(vKey, vMap));\n+                    contents.add(Text.SPACE);\n+                    contents.add(buildType(vPos, ve::asType));\n+                    contents.add(Text.SPACE);\n+                    contents.add(Text.of(ve.getSimpleName()));\n+                    Content value = buildValue(vMap);\n+                    if (value != Content.empty) {\n+                        contents.add(Text.of(\" = \"));\n+                        contents.add(value);\n+                    }\n+                }\n+            }\n+\n+            HtmlTree signature = HtmlTree.DIV(contents).setClass(\"signature\");\n+            Content docComments = buildDocComments(vPos);\n+            Content apiDescriptions = buildAPIDescriptions(vPos);\n+\n+            return HtmlTree.DIV(eq, buildMissingInfo(vPos), buildNotes(vKey),\n+                    signature, docComments, apiDescriptions)\n+                    .setClass(\"element\")\n+                    .set(HtmlAttr.ID, links.getId(vKey));\n+        }\n+\n+        private Content buildValue(APIMap<? extends Element> vMap) {\n+            Object v = ((VariableElement) vMap.values().iterator().next()).getConstantValue();\n+            boolean allEqual = vMap.values().stream()\n+                    .map(e -> ((VariableElement) e).getConstantValue())\n+                    .allMatch(v1 -> Objects.equals(v1, v));\n+            if (allEqual) {\n+                return (v == null) ? Content.empty : buildValue(v);\n+            } else {\n+                APIMap<Content> values = APIMap.of();\n+                vMap.forEach((api, ve) -> values.put(api, buildValue(((VariableElement) ve).getConstantValue())));\n+                return new DiffBuilder().build(values);\n+            }\n+        }\n+\n+        private Content buildValue(Object o) {\n+            if (o == null) {\n+                return Entity.NBSP;\n+            } else if (o instanceof Number) {\n+                return Text.of(String.valueOf(o));\n+            } else if (o instanceof Boolean) {\n+                return Keywords.of((Boolean) o);\n+            } else if (o instanceof Character) {\n+                return Text.of(\"'\" + escape(String.valueOf(o)) + \"'\");\n+            } else if (o instanceof String) {\n+                return Text.of(\"\\\"\" + escape(String.valueOf(o)) + \"\\\"\");\n+            } else {\n+                throw new IllegalArgumentException(o.getClass() + \"(\" + o + \")\");\n+            }\n+        }\n+\n+        private String escape(String s) {\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 0; i < s.length(); i++) {\n+                char c = s.charAt(i);\n+                if (Character.isSurrogate(c)) {\n+                    sb.append(String.format(\"\\\\u%04x\", (int) c));\n+                } else {\n+                    switch (c) {\n+                        case '\\b':\n+                            sb.append(\"\\\\b\");\n+                            break;\n+                        case '\\f':\n+                            sb.append(\"\\\\f\");\n+                            break;\n+                        case '\\n':\n+                            sb.append(\"\\\\n\");\n+                            break;\n+                        case '\\r':\n+                            sb.append(\"\\\\r\");\n+                            break;\n+                        case '\\t':\n+                            sb.append(\"\\\\t\");\n+                            break;\n+                        case '\\\\':\n+                            sb.append(\"\\\\\\\\\");\n+                            break;\n+                        case '\\'':\n+                            sb.append(\"\\\\'\");\n+                            break;\n+                        case '\\\"':\n+                            sb.append(\"\\\\\\\"\");\n+                            break;\n+                        default:\n+                            if (Character.isISOControl(c)) {\n+                                sb.append(String.format(\"\\\\u%04x\", (int) c));\n+                            } else {\n+                                sb.append(c);\n+                            }\n+                    }\n+                }\n+            }\n+            return sb.toString();\n+        }\n+    }\n+\n+\n+    \/**\n+     * A builder for different instances of a type parameter in different instances of an API.\n+     *\/\n+    protected class TypeParameterBuilder {\n+        protected Content build(Position ePos, APIMap<? extends Element> eMap) {\n+            int maxTypeParameters = eMap.values().stream()\n+                    .mapToInt(e -> ((Parameterizable) e).getTypeParameters().size())\n+                    .max().orElse(0);\n+            if (maxTypeParameters == 0) {\n+                return Content.empty;\n+            }\n+\n+            \/\/ use elements from this list when no differences given\n+            List<? extends TypeParameterElement> archetype =\n+                    ((Parameterizable) eMap.values().iterator().next()).getTypeParameters();\n+\n+            List<Content> contents = new ArrayList<>();\n+            contents.add(Text.of(\"<\"));\n+            boolean needComma = false;\n+            for (int i = 0; i < maxTypeParameters; i++) {\n+                if (needComma) {\n+                    contents.add(Text.of(\", \"));\n+                } else {\n+                    needComma = true;\n+                }\n+\n+                Position tpePos = ePos.typeParameter(i);\n+                APIMap<? extends TypeParameterElement> typarams;\n+                if ((typarams = differentTypeParameters.get(tpePos)) != null) {\n+                    contents.add(new DiffBuilder().build(eMap.keySet(), typarams, this::buildTypeParameter));\n+                } else {\n+                    contents.add(buildTypeParameter(archetype.get(i)));\n+                }\n+            }\n+            contents.add(Text.of(\">\"));\n+            return HtmlTree.SPAN(contents).setClass(\"typarams\");\n+        }\n+\n+        private Content buildTypeParameter(TypeParameterElement tpe) {\n+            List<Content> contents = new ArrayList<>();\n+            \/\/ TODO: annotations\n+            contents.add(Text.of(tpe.getSimpleName()));\n+            \/\/ TODO: bounds\n+            return HtmlTree.SPAN(contents);\n+        }\n+    }\n+\n+    \/**\n+     * A builder for different instances of the record components in different instances of an API.\n+     *\/\n+    protected class RecordComponentBuilder {\n+        protected Content build(Position ePos, APIMap<? extends TypeElement> eMap) {\n+            int maxComponents = eMap.values().stream()\n+                    .mapToInt(e -> getComponents(e).size())\n+                    .max().orElse(0);\n+            if (maxComponents == 0) {\n+                return Content.empty;\n+            }\n+\n+            IntTable<Element> rcTable = new IntTable<>();\n+            eMap.forEach((api, e) -> rcTable.put(api, getComponents(e)));\n+            List<Content> contents = new ArrayList<>();\n+            contents.add(Text.of(\"(\"));\n+            boolean needComma = false;\n+            for (int i = 0; i < maxComponents; i++) {\n+                Position rcPos = ePos.recordComponent(i);\n+                Content component = buildComponent(rcPos, eMap.keySet(), rcTable.entries(i));\n+                if (needComma) {\n+                    contents.add(Text.of(\", \"));\n+                }\n+                contents.add(component);\n+                needComma = true;\n+            }\n+            contents.add(Text.of(\")\"));\n+            return HtmlTree.SPAN(contents).setClass(\"components\");\n+        }\n+\n+        private Content buildComponent(Position rcPos, Set<API> apis, APIMap<\/*RecordComponent*\/Element> rcMap) {\n+            List<Content> contents = new ArrayList<>();\n+            contents.addAll(buildAnnotations(rcPos));\n+\n+            \/\/ no modifiers for record components\n+            APIMap<TypeMirror> tMap = rcMap.map(Element::asType);\n+            contents.add(buildType(rcPos, apis, tMap));\n+            contents.add(Text.SPACE);\n+\n+            Name rcn = rcMap.values().iterator().next().getSimpleName();\n+            boolean sameName = rcMap.size() == apis.size() && rcMap.values().stream()\n+                    .map(Element::getSimpleName)\n+                    .allMatch(n -> n.contentEquals(rcn));\n+            if (sameName) {\n+                contents.add(Text.of(rcn));\n+            } else {\n+                contents.add(new DiffBuilder().build(apis, rcMap, e -> Text.of(e.getSimpleName())));\n+            }\n+\n+            return HtmlTree.SPAN(contents).setClass(\"parameter\");\n+        }\n+\n+        private List<? extends Element> getComponents(TypeElement e) {\n+            return elementExtras.getRecordComponents(e);\n+        }\n+    }\n+\n+    \/**\n+     * A builder for different instances of the serialized form of a type element.\n+     *\/\n+     private class SerializedFormBuilder {\n+\n+        Content build() {\n+            Position sfPos = Position.of(pageKey).serializedForm();\n+            Boolean equal = results.get(sfPos);\n+            if (equal == null) {\n+                return Content.empty;\n+            }\n+\n+            HtmlTree section = HtmlTree.SECTION(HtmlTree.H2(Text.of(msgs.getString(\"serial.serialized-form\")))).setClass(\"serial-form\");\n+            section.add(getResultGlyph(sfPos)).add(buildMissingInfo(sfPos));\n+            addSerialVersionUID(section);\n+            addSerializedFields(section);\n+            addSerializationMethods(section);\n+            return section;\n+        }\n+\n+        private void addSerialVersionUID(HtmlTree section) {\n+            Position uPos = Position.of(pageKey).serialVersionUID();\n+            APIMap<?> values = apiMaps.get(uPos);\n+\n+            \/\/ TODO: weave in the text from serialized-form.html\n+\n+            section.add(HtmlTree.H3(Text.of(\"serialVersionUID\")));\n+            section.add(getResultGlyph(uPos));\n+            if (differentValues.containsKey(uPos)) {\n+                APIMap<Content> alternatives = APIMap.of();\n+                values.forEach((api, v) -> alternatives.put(api, Text.of(String.valueOf(v))));\n+                section.add(new DiffBuilder().build(alternatives));\n+            } else {\n+                section.add(Text.of(String.valueOf(values.values().iterator().next())));\n+            }\n+\n+\/\/ TODO: The serialVersion info appears in two places, which should provide the same value.\n+\/\/    It should appear in the source or class file, and it should appear in the serialized form,\n+\/\/    available via the SerializedFormDocs object\n+\n+\/\/            Content c = buildAPIDescriptions(uPos);\n+\/\/            if (c != Content.empty) {\n+\/\/                \/\/ TODO: show the check\/cross\/etc glyph if any description present\n+\/\/                \/\/       implies need for reporter.comparing(oPos, map) with a map of descriptions\n+\/\/                section.add(c);\n+\/\/            }\n+        }\n+\n+        private void addSerializedFields(HtmlTree tree) {\n+            RelativePosition<?> oPos = Position.of(pageKey).serializationOverview();\n+            Content c = buildAPIDescriptions(oPos);\n+            if (c != Content.empty) {\n+                \/\/ TODO: show the check\/cross\/etc glyph if any overview present\n+                \/\/       implies need for reporter.comparing(oPos, map) with a map of descriptions\n+                HtmlTree section = HtmlTree.SECTION().setClass(\"enclosed\");\n+                section.add(HtmlTree.H3(Text.of(msgs.getString(\"serial.serialization-overview\"))));\n+                section.add(c);\n+                tree.add(section);\n+            }\n+\n+            Set<RelativePosition<?>> fields = results.keySet().stream()\n+                    .filter(Position::isRelative)\n+                    .map(p -> (RelativePosition<?>) p)\n+                    .filter(p -> p.kind == RelativePosition.Kind.SERIALIZED_FIELD)\n+                    .collect(Collectors.toCollection(() -> new TreeSet<>(Position.stringIndexComparator)));\n+\n+            if (!fields.isEmpty()) {\n+                HtmlTree section = HtmlTree.SECTION().setClass(\"enclosed\");\n+                section.add(HtmlTree.H3(Text.of(msgs.getString(\"serial.serialized-fields\"))));\n+                HtmlTree ul = HtmlTree.UL();\n+                for (RelativePosition<?> pos : fields) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    RelativePosition<String> fPos = (RelativePosition<String>) pos;\n+                    HtmlTree li = HtmlTree.LI(buildSerializedField(fPos));\n+                    ul.add(li);\n+                }\n+                section.add(ul);\n+                tree.add(section);\n+            }\n+        }\n+\n+        private Content buildSerializedField(RelativePosition<String> fPos) {\n+            @SuppressWarnings(\"unchecked\")\n+            APIMap<SerializedForm.Field> fMap = (APIMap<SerializedForm.Field>) apiMaps.get(fPos);\n+            Content glyph = getResultGlyph(fPos);\n+\n+            Content type;\n+            APIMap<? extends TypeMirror> types;\n+            \/\/ differentTypes for a serializedField position is somewhat different than usual\n+            \/\/ in that a type of NONE represents an unresolved type\n+            \/\/ (Ideally, the representation would use ERROR instead of NONE, but that is not possible.)\n+            if ((types = differentTypes.get(fPos)) != null) {\n+                if (types.values().stream().allMatch(t -> t.getKind() != TypeKind.NONE)) {\n+                    \/\/ no unresolved types, use standard type builder\n+                    type = buildType(fPos, () -> types.values().iterator().next());\n+                } else {\n+                    \/\/ some unresolved types, use custom DiffBuilder\n+                    type = new DiffBuilder().build(fMap, this::buildFieldType);\n+                }\n+            } else {\n+                \/\/ types all equal: build the archetype\n+                SerializedForm.Field archetype = fMap.values().iterator().next();\n+                type = buildFieldType(archetype);\n+            }\n+\n+            Content signature = HtmlTree.DIV(type, Entity.NBSP, Text.of(fPos.index)).setClass(\"signature\");\n+            Content docComments = buildDocComments(fPos);\n+            Content descriptions = buildAPIDescriptions(fPos);\n+\n+            return HtmlTree.DIV(glyph, buildMissingInfo(fPos),\n+                    signature, docComments, descriptions)\n+                    .setClass(\"element\");\n+        }\n+\n+        private Content buildFieldType(SerializedForm.Field f) {\n+            TypeMirror t = f.getType();\n+            if (t.getKind() == TypeKind.NONE) {\n+                return HtmlTree.SPAN(Text.of(f.getSignature()))\n+                        .setClass(\"unresolved\")\n+                        .setTitle(\"name could not be resolved\"); \/\/ TODO: L10N\n+            } else {\n+                return TypePageReporter.this.buildType(t);\n+            }\n+        }\n+\n+        private void addSerializationMethods(HtmlTree tree) {\n+            Set<RelativePosition<?>> methods = results.keySet().stream()\n+                    .filter(p -> p instanceof RelativePosition)\n+                    .map(p -> (RelativePosition<?>) p)\n+                    .filter(p -> p.kind == RelativePosition.Kind.SERIALIZATION_METHOD)\n+                    .collect(Collectors.toCollection(() -> new TreeSet<>(Position.stringIndexComparator)));\n+\n+            if (!methods.isEmpty()) {\n+                HtmlTree section = HtmlTree.SECTION().setClass(\"enclosed\");\n+                section.add(HtmlTree.H3(Text.of(msgs.getString(\"serial.serialization-methods\"))));\n+                HtmlTree ul = HtmlTree.UL();\n+                for (Position pos : methods) {\n+                    HtmlTree li = HtmlTree.LI(buildSerializedMethod(pos));\n+                    ul.add(li);\n+                }\n+                section.add(ul);\n+                tree.add(section);\n+            }\n+        }\n+\n+        private Content buildSerializedMethod(Position mPos) {\n+            return new ExecutableBuilder(mPos).build();\n+        }\n+\n+    }\n+}\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/TypePageReporter.java","additions":1124,"deletions":0,"binary":false,"changes":1124,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Classes used to generate an HTML report of the differences between\n+ * a set of APIs.\n+ *\/\n+\n+\/**\n+ * Classes used to generate HTML reports of the differences\n+ * in a series of API.\n+ *\/\n+package jdk.codetools.apidiff.report.html;\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/package-info.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,476 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* Global\/default settings. *\/\n+\n+body {\n+    font-family:'DejaVu Sans', Arial, Helvetica, sans-serif;\n+    font-size:14px;\n+    margin: 0;\n+    padding: 0;\n+}\n+\n+\/* Headings. *\/\n+\n+h1 {\n+    font-size:20px;\n+}\n+h2 {\n+    font-size:18px;\n+}\n+h3 {\n+    font-size:16px;\n+    font-style:italic;\n+}\n+h4 {\n+    font-size:13px;\n+}\n+h5 {\n+    font-size:12px;\n+}\n+h6 {\n+    font-size:11px;\n+}\n+\n+\/* Links. *\/\n+\n+a:link, a:visited {\n+    text-decoration:none;\n+    color:#4A6782;\n+}\n+a[href]:hover, a[href]:focus {\n+    text-decoration:none;\n+    color:#bb7a2a;\n+}\n+\n+\/* Header, footer and navigation. *\/\n+\n+header > div,\n+footer > div {\n+    padding: 1em;\n+}\n+\n+header > div.info,\n+footer > div.info {\n+    font-size: smaller;\n+}\n+\n+.bar {\n+    background-color:#4D7A97;\n+    color:#FFFFFF;\n+}\n+\n+.bar nav ul {\n+    display: inline;\n+    margin: 0;\n+    padding: 0;\n+    list-style-type: none;\n+}\n+\n+.bar nav li {\n+    display: inline;\n+    margin: 0 1em 0 0;\n+    text-transform: uppercase;\n+}\n+\n+.bar nav a,\n+.bar nav a:link,\n+.bar nav a:visited,\n+.bar nav a:active {\n+    color:#FFFFFF;\n+    text-decoration:none;\n+}\n+\n+.bar nav a:hover,\n+.bar nav a:focus {\n+    color:#bb7a2a;\n+}\n+\n+.bar div.info {\n+    float: right;\n+}\n+\n+\/* Main. *\/\n+\n+main {\n+    margin: 1em;\n+}\n+\n+\n+\/* Page heading: the <h1> and preceding text. *\/\n+\n+div.pageHeading {\n+    border-bottom: 1px solid black;\n+    margin-bottom: 2em;\n+}\n+\n+.pageHeading .label {\n+    font-weight: bold;\n+}\n+\n+.pageHeading h1 {\n+    color:#2c4557;\n+}\n+\n+\/* The signature block. *\/\n+\n+div.signature {\n+    margin-top: 5px;\n+    font-family:'DejaVu Sans Mono', monospace;\n+    font-size:14px;\n+}\n+\n+.signature .keyword {\n+    font-weight: bold;\n+}\n+\n+.signature div.superclass,\n+.signature div.superinterfaces,\n+.signature div.permitted-subclasses {\n+    margin-left:2em;\n+}\n+\n+.signature span.diffs, .serial-form span.diffs {\n+    display: inline-block;\n+    background-color: lightgrey;\n+    border: 1px solid grey;\n+    border-radius: 5px;\n+    margin: 2px;\n+    padding: 4px 1px;\n+    list-style: none;\n+}\n+\n+.signature span.diffs > span, .serial-form span.diffs > span {\n+    display: inline;\n+    background-color: white;\n+    border: 1px solid grey;\n+    border-radius: 5px;\n+    margin: 0 1px;\n+    padding: 2px;\n+}\n+\n+.signature span.unresolved {\n+    color: gray;\n+}\n+\n+\/* Elements. *\/\n+\n+.doc-files span.diff,   .element span.diff,   .enclosed span.diff,   .serial-form span.diff,\n+.doc-files span.same,   .element span.same,   .enclosed span.same,   .serial-form span.same,\n+.doc-files span.single, .element span.single, .enclosed span.single, .serial-form span.single {\n+    display: inline-block;\n+    width: 2em;\n+    margin-right: 0.5ex;\n+    text-align: center;\n+    font-weight: bold;\n+}\n+\n+.doc-files span.diff, .element span.diff, .enclosed span.diff, .serial-form span.diff {\n+    background: #fdd;\n+    color: #800;\n+}\n+\n+.doc-files span.same, .element span.same, .enclosed span.same, .serial-form span.same {\n+    background: #dfd;\n+    color: #080;\n+}\n+\n+.doc-files span.single, .element span.single, .enclosed span.single, .serial-form span.single {\n+    background: #ddf;\n+    color: #008;\n+}\n+\n+.doc-files span.missing, .element span.missing, .enclosed span.missing, .serial-form span.missing,\n+.element span.notes {\n+    margin-right: 10px;\n+    font-style: italic;\n+}\n+\n+.doc-files table.details {\n+  margin: 10px 0;\n+}\n+\n+.doc-files table.details,\n+.doc-files table.details thead,\n+.doc-files table.details tbody,\n+.doc-files table.details tfoot {\n+  border: 1px solid black;\n+  border-collapse: collapse;\n+}\n+\n+.doc-files table.details caption {\n+  padding-bottom: 2px;\n+}\n+\n+.doc-files table.details thead,\n+.doc-files table.details tfoot {\n+  background-color: #ddd\n+}\n+\n+.doc-files table.details tbody tr:nth-child(even) {\n+  background-color: #eee\n+}\n+\n+.doc-files table.details th,\n+.doc-files table.details td {\n+  padding: 2px 5px;\n+}\n+\n+.doc-files table.details thead th,\n+.doc-files table.details tfoot th {\n+  border: 1px solid black;\n+}\n+\n+.doc-files table.details td {\n+  border-left: 1px solid black;\n+  text-align: center;\n+}\n+\n+.doc-files table.details tbody th {\n+  font-weight: normal;\n+}\n+\n+.doc-files table.details tbody th,\n+.doc-files table.details tfoot th {\n+  text-align:left;\n+}\n+\n+\/* Side-by-side diffs. *\/\n+\n+div.sdiffs {\n+    display: grid;\n+    grid-template-columns: auto auto;\n+    grid-column-gap: 10px;\n+    margin: 2px 10px;\n+    padding: 2px 2px;\n+    border: 1px solid grey;\n+}\n+\n+.sdiffs div.sdiffs-ref {\n+    grid-column: 1;\n+    overflow-x: auto;\n+}\n+\n+.sdiffs div.sdiffs-mod {\n+    grid-column: 2;\n+    overflow-x: auto;\n+}\n+\n+.sdiffs div.sdiffs-title {\n+    padding-left: 2em;\n+    text-weight: bold;\n+    background-color: #eee;\n+    border-bottom: 1px solid grey;\n+    margin-bottom: 5px;\n+}\n+\n+.sdiffs span.sdiffs-changed {\n+    color: blue;\n+}\n+\n+span.sdiffs-lines-inserted, span.sdiffs-lines-changed, span.sdiffs-lines-deleted {\n+    background-color: hsl(200,100%,95%);\n+}\n+\n+span.sdiffs-chars-inserted, span.sdiffs-chars-changed, span.sdiffs-chars-deleted {\n+    background-color: hsl(200,100%,85%);\n+}\n+\n+\/* HTML diffs *\/\n+\n+div.hdiffs {\n+    margin: 2px 10px;\n+    padding: 2px 2px;\n+    border: 1px solid grey;\n+}\n+\n+div.hdiffs-title {\n+    padding-left: 2em;\n+    text-weight: bold;\n+    background-color: #eee;\n+    border-bottom: 1px solid grey;\n+    margin-bottom: 5px;\n+}\n+\n+.hdiffs span.diff-html-added { background-color: #bfb }\n+.hdiffs span.diff-html-changed { background-color: #ffb; }\n+.hdiffs span.diff-html-removed { background-color: #fbb; }\n+\n+\/* No diffs *\/\n+\n+div.xdiffs {\n+    margin: 2px 10px;\n+    padding: 2px 2px;\n+    border: 1px solid grey;\n+}\n+\n+div.xdiffs-title {\n+    padding-left: 2em;\n+    text-weight: bold;\n+    background-color: #eee;\n+    border-bottom: 1px solid grey;\n+    margin-bottom: 5px;\n+}\n+\n+\/* Tooltip container *\/\n+.hdiffs .diff-html-changed {\n+  position: relative;\n+}\n+\n+\/* Tooltip text *\/\n+.hdiffs .diff-html-changed .hdiffs-tooltip {\n+  display:block;\n+  visibility: hidden;\n+  width: 300px;\n+  background-color: #fafad2;\n+  padding: 5px 10px;\n+  border: 1px solid black;\n+  text-align: left;\n+  border-radius: 6px;\n+\n+  color: black;\n+  font-size: small;\n+  font-style-normal;\n+  font-weight: normal;\n+  white-space: normal;\n+\n+  \/* Position the tooltip text *\/\n+  position: absolute;\n+  z-index: 1;\n+  top: 125%;\n+  left: 50%;\n+  margin-left: -150px;\n+\n+  \/* Fade in tooltip *\/\n+  opacity: 0;\n+  transition: opacity 0.3s;\n+}\n+\n+\/* Tooltip arrow *\/\n+.hdiffs .diff-html-changed .hdiffs-tooltip::after {\n+  content: \" \";\n+  position: absolute;\n+  bottom: 100%;\n+  left: 50%;\n+  margin-left: -5px;\n+  border-width: 5px;\n+  border-style: solid;\n+  border-color: transparent transparent black transparent;\n+}\n+\n+\/* Show the tooltip text when you mouse over the tooltip container *\/\n+.hdiffs .diff-html-changed:hover .hdiffs-tooltip {\n+  visibility: visible;\n+  opacity: 1;\n+}\n+\n+.hdiffs span.hdiffs-tip-ul { display:block; list-style: outside }\n+.hdiffs span.hdiffs-tip-li { display:list-item;  margin-left: 1em; padding-left: 0.1em; }\n+\n+\/* The summary table *\/\n+\n+section.summary {\n+  border-top: 1px solid black;\n+  margin-top: 2em;\n+}\n+\n+table.summary,\n+table.summary thead,\n+table.summary tbody,\n+table.summary tfoot {\n+  border: 1px solid black;\n+  border-collapse: collapse;\n+}\n+\n+table.summary caption {\n+  padding-bottom: 2px;\n+}\n+\n+table.summary thead,\n+table.summary tfoot {\n+  background-color: #ddd\n+}\n+\n+table.summary tbody tr:nth-child(even) {\n+  background-color: #eee\n+}\n+\n+table.summary th,\n+table.summary td {\n+  padding: 2px 5px;\n+}\n+\n+table.summary thead th,\n+table.summary tfoot th {\n+  border: 1px solid black;\n+}\n+\n+table.summary thead th.allZero {\n+  color: gray;\n+}\n+\n+table.summary td {\n+  border-left: 1px solid black;\n+  text-align: center;\n+}\n+\n+table.summary tbody th {\n+  font-weight: normal;\n+}\n+\n+table.summary tbody th,\n+table.summary tfoot th {\n+  text-align:left;\n+}\n+\n+\/* The debug section. *\/\n+\n+.todo {\n+    display: inline-block;\n+    border: 1px solid blue;\n+    border-radius: 5px;\n+    padding: 1px 2px;\n+}\n+\n+ section.debug {\n+    border: 1px solid grey;\n+    border-radius: 5px;\n+    border-color: blue;\n+    margin: 2em 1em;\n+    padding: 2px 5px;\n+ }\n+\n+ .debug table {\n+     border: 1px solid grey;\n+     border-collapse: collapse;\n+ }\n+\n+ .debug td, .debug th {\n+     padding 2px 5px;\n+     border-left: 1px solid grey;\n+     border-top: 1px solid lightgrey;\n+ }\n+\n+\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/resources\/apidiff.css","additions":476,"deletions":0,"binary":false,"changes":476,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+# Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+# Content to be put in the generated report\n+\n+docfile.details.caption.api=\\\n+  API File Details for {0}\n+\n+docfile.details.caption.source=\\\n+  Source File Details for {0}\n+\n+docfile.details.th.api=\\\n+  API\n+\n+docfile.details.th.size=\\\n+  File Size\n+\n+docfile.details.th.checksum=\\\n+  Checksum\n+\n+element.onlyInMissingIn=\\\n+  Only in: {0}; not in: {1}.\n+\n+heading.annotation-type=\\\n+  Annotation Type\n+\n+heading.class=\\\n+  Class\n+\n+heading.constructors=\\\n+  Constructors\n+\n+heading.elements=\\\n+  Elements\n+\n+heading.enum=\\\n+  Enum\n+\n+heading.enum-constants=\\\n+  Enum Constants\n+\n+heading.exports=\\\n+  Exports\n+\n+heading.fields=\\\n+  Fields\n+\n+heading.file=\\\n+  File\n+\n+heading.files=\\\n+  Additional Files\n+\n+heading.interface=\\\n+  Interface\n+\n+heading.methods=\\\n+  Methods\n+\n+heading.mixed=\\\n+  (Various)\n+\n+heading.module=\\\n+  Module\n+\n+heading.modules=\\\n+  Modules\n+\n+heading.nested-types=\\\n+  Nested Types\n+\n+heading.opens=\\\n+  Opens\n+\n+heading.package=\\\n+  Package\n+\n+heading.packages=\\\n+  Packages\n+\n+heading.provides=\\\n+  Provides\n+\n+heading.record=\\\n+  Record\n+\n+heading.requires=\\\n+  Requires\n+\n+heading.types=\\\n+  Types\n+\n+heading.unknown=\\\n+  Unknown\n+\n+heading.uses=\\\n+  Uses\n+\n+htmldiffs.comparing=\\\n+  Comparing {0} and {1}\n+\n+htmldiffs.not-in-only-in=\\\n+  Not in {0}; only in {1}\n+\n+htmldiffs.only-in-not-in=\\\n+  Only in {0}; not i {1}\n+\n+notes.heading=\\\n+  Notes\n+\n+notes.prefix=\\\n+  Notes:\n+\n+overview.heading.apis=\\\n+  APIs\n+\n+overview.name=\\\n+  Overview\n+\n+overview.title=\\\n+  Overview\n+\n+serial.serialization-methods=\\\n+  Serialization Methods\n+\n+serial.serialization-overview=\\\n+  Serialization Overview\n+\n+serial.serialized-fields=\\\n+  Serialized Fields\n+\n+serial.serialized-form=\\\n+  Serialized Form\n+\n+summary.heading=\\\n+  Summary\n+\n+summary.caption=\\\n+  Differences\n+\n+summary.elements=\\\n+  Elements\n+\n+summary.comments=\\\n+  Comments\n+\n+summary.descriptions=\\\n+  Descriptions\n+\n+summary.changed=\\\n+  Changed\n+\n+summary.added=\\\n+  Added\n+\n+summary.no-differences=\\\n+  No differences.\n+\n+summary.removed=\\\n+  Removed\n+\n+summary.total=\\\n+  Total\n+\n+\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/html\/resources\/report.properties","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2018,2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Classes for reporting the results of comparing elements in two or more APIs.\n+ *\/\n+package jdk.codetools.apidiff.report;\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/report\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,153 @@\n+# Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+# Resources for command-line help\n+\n+opt.arg.access=public|protected|package|private\n+opt.arg.api=<name>\n+opt.arg.api-directory=<api-directory>\n+opt.arg.boolean=true|yes|on|false|no|off\n+opt.arg.class-path=<class-path>\n+opt.arg.source-path=<source-path>\n+opt.arg.directory=<directory>\n+opt.arg.file=<file>\n+opt.arg.file-or-directory=<file-or-directory>\n+opt.arg.html-text=<html>\n+opt.arg.info-text=<place>=<html>\n+opt.arg.jdk-build=<jdk-build>\n+opt.arg.jdk-docs=<name>\n+opt.arg.jdk-version=<jdk-version>\n+opt.arg.jdk-home=<jdk-install-dir>\n+opt.arg.module-path=<module-path>\n+opt.arg.module-source-path=<module-source-path>\n+opt.arg.patch-module=<module-name>=<path>\n+opt.arg.pattern=<pattern>\n+opt.arg.plain-text=<text>\n+opt.arg.verbose=<flag>[,<flag>]*\n+\n+opt.desc.access=\\\n+    Specifies the access for elements to be compared.\n+\n+opt.desc.api=\\\n+    Provides a name for an API to be compared and set the current API\\n\\\n+    for API-specific options that immediately follow on the command line.\n+\n+opt.desc.api-directory=\\\n+    Specifies the location of the documentation generated by javadoc for an API.\n+\n+opt.desc.class-path=\\\n+    Specifies the class path for an API.\n+\n+opt.desc.compare-api-descriptions=\\\n+    Compares API descriptions (in files generated by javadoc) for elements found in each API.\n+\n+opt.desc.compare-api-descriptions-as-text=\\\n+    Compares the HTML for the API descriptions (in files generated by javadoc) as plain text\\n\\\n+    for elements found in each API.\n+\n+opt.desc.compare-doc-comments=\\\n+    Compares documentation comments (in source files) for elements found in each API.\n+\n+opt.desc.description=\\\n+    Provides a short description to be included in the report.\n+\n+opt.desc.enable-preview=\\\n+    Enables preview features for an API.\n+\n+opt.desc.exclude=\\\n+    Specifies a pattern to match elements to be excluded from the comparison.\n+\n+opt.desc.extra-stylesheet=\\\n+    Specifies an additional stylesheet to use in the generated report.\n+\n+opt.desc.help=\\\n+    Shows this information.\n+\n+opt.desc.include=\\\n+    Specifies a pattern to match elements to be included in the comparison.\n+\n+opt.desc.info-text=\\\n+    Specifies text to be included at different positions in the report.\\n\\\n+    Positions include: 'top', 'header', 'footer', 'bottom'.\n+\n+opt.desc.jdk-build=\\\n+    Specifies the location of a JDK build from which to infer detailed\\n\\\n+    options for an API. The directory should contain a \"configuration\" as\\n\\\n+    understood by the ''configure'' and ''make'' commands used to build JDK.\n+\n+opt.desc.jdk-docs=\\\n+    Specifies the name of the docs bundle to use for an API,\\n\\\n+    in conjunction with the --jdk-build option.\n+\n+opt.desc.label=\\\n+    Specifies a short string to identify an API in reports.\n+\n+opt.desc.main-stylesheet=\\\n+    Specifies a alternative primary stylesheet to use in the generated report,\\n\\\n+    instead of the system default\n+\n+opt.desc.module-path=\\\n+    Specifies the module path for an API.\n+\n+opt.desc.module-source-path=\\\n+    Specifies the module source path for an API.\n+\n+opt.desc.notes=\\\n+    Specifies a file providing notes to be added into the report.\n+\n+opt.desc.output-directory=\\\n+    Specifies the directory in which to write the report.\n+\n+opt.desc.patch-module=\\\n+    Specifies the path to patch a module for an API.\n+\n+opt.desc.release=\\\n+    Specifies the Java SE release to be used for the platform classes for an API.\n+\n+opt.desc.resource-files=\\\n+    Specifies resource files to be copied from an API directory\n+\n+opt.desc.source=\\\n+    Specifies the version of the platform for an API.\n+\n+opt.desc.source-path=\\\n+    Specifies the source path for an API.\n+\n+opt.desc.system=\\\n+    Specifies the system classes for an API.\n+\n+opt.desc.title=\\\n+    Specifies a title for the report.\n+\n+opt.desc.verbose=\\\n+    Specifies level of verbose output.\\n\\\n+    Supported flags are all, none, or one of the following,\\n\\\n+    optionally preceded by -: {0}\n+\n+opt.desc.version=\\\n+    Shows the version of the tool.\n+\n+options.usage.header=\\\n+    Usage:\\n\\\n+    \\    apidiff <options>\\n\\\n+    where <options> include:\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/resources\/help.properties","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,242 @@\n+# Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+htmldiffs.err.exception-in-diff=\\\n+    internal exception occurred while determining differences: {0}\n+\n+htmldiffs.warn.unknown-attribute-name=\\\n+    unknown attribute ''{1}'' in ''{0}'' element\n+\n+htmldiffs.warn.unknown-tag-name=\\\n+    unknown tag ''{0}''\n+\n+jdkbuild.ioerror-finding-docs=\\\n+    Error while looking for docs: {0}\n+\n+jdkbuild.err.no-docs=\\\n+    No directories matching ''*docs*'' found in {0}\n+\n+jdkbuild.err.multiple-docs=\\\n+    Multiple docs directories found in {0}: {1}\\n\\\n+    Use --jdk-docs NAME to specify the one to use\n+\n+jdkbuild.err.cannot-find-docs=\\\n+    Cannot find specified docs ({0}) in {1}\n+\n+jdkbuild.err.error-reading-release-file=\\\n+    Error reading JDK release file {0}: {1}\n+\n+jdkbuild.err.error-reading-src.zip=\\\n+    Error reading src.zip file {0}: {1}\n+\n+log.errors = {0,choice,1<{0} error|{0} errors}\n+log.warnings = {0,choice,1<{0} warning|{0} warnings}\n+\n+log.err-prefix = Error:\n+log.note-prefix = Note:\n+log.warn-prefix = Warning:\n+\n+logReport.comparing=\\\n+    Comparing: {0}\n+\n+logReport.completed=\\\n+    Completed: {0}: {1,choice,0#different|0<equal}\n+\n+logReport.different-annotations=\\\n+    Different annotations for {0}\n+\n+logReport.different-annotation-values=\\\n+    Different annotation values for {0}\n+\n+logReport.different-api-descriptions=\\\n+    Different API descriptions for {0}\n+\n+logReport.different-directives=\\\n+    Different directives for {0}\n+\n+logReport.different-doc-files=\\\n+    Different files for {0}\n+\n+logReport.different-kinds=\\\n+    Different kinds for {0}\n+\n+logReport.different-names=\\\n+    Different names for {0}\n+\n+logReport.different-modifiers=\\\n+    Different modifiers for {0}\n+\n+logReport.different-raw-doc-comments=\\\n+    Different raw doc comments for {0}\n+\n+logReport.different-superinterfaces=\\\n+    Different superinterfaces for {0}\n+\n+logReport.different-permitted-subclasses=\\\n+    Different permitted subclasses for {0}\n+\n+logReport.different-thrown-types=\\\n+    Different thrown types for {0}\n+\n+logReport.different-types=\\\n+    Different types for {0}\n+\n+logReport.different-type-parameters=\\\n+    Different type parameters for {0}\n+\n+logReport.different-values=\\\n+    Different values for {0}\n+\n+logReport.finished=\\\n+    Completed: {0,choice,0#different|0<equal}\n+\n+logReport.item-not-found=\\\n+    Item not found in API ''{0}'': {1}\n+\n+main.elapsed = Time: {0,choice,0#|0<{0,number}h }{1,choice,0#|0<{1,number}m }{2,number}s\n+\n+main.err.bad-@file=\\\n+    Error reading @-files: {0}\n+\n+main.err.cant-create-output-directory=\\\n+    Cannot create output directory: {0}\n+\n+main.err.cant-read-notes=\\\n+    Cannot read notes file {0}: {1}\n+\n+notes.err.bad-line=\\\n+    bad line: {0}\n+\n+notes.err.bad-signature=\\\n+    bad signature: {0}\n+\n+notes.err.bad-uri=\\\n+    bad uri: {0}\n+\n+notes.err.no-current-uri=\\\n+    no current URI and description\n+\n+options.did-you-mean=\\\n+    Did you mean: {0}\n+\n+options.did-you-mean-one-of=\\\n+    Did you mean one of: {0}\n+\n+options.for-more-details-see-usage=\\\n+    For more details on available options, use --help\n+\n+options.err.bad-access=\\\n+    bad value for option: {0}; should be one of public, protected, package or private\n+\n+options.err.bad.argument=\\\n+    bad argument: ''{0)''\n+\n+options.err.bad-file=\\\n+    bad filename: {0}\n+\n+options.err.bad-jdk-build-dir=\\\n+    bad value for JDK build directory for API ''{0}'': {1}\\n\\\n+    (expected to find marker file spec.gmk)\n+\n+options.err.bad-module-name=\\\n+    bad module name in pattern: {0}\n+\n+options.err.bad-package-name=\\\n+    bad package name in pattern: {0}\n+\n+options.err.bad-source=\\\n+    bad value for source version: {0}\n+\n+options.err.compare-api-but-missing-dir=\\\n+    --compare-api-descriptions specified, but the API directory is not specified for some APIs\n+\n+options.err.empty-module-name=\\\n+    empty module name in pattern: {0}\n+\n+options.err.empty-package-name=\\\n+    empty package name in pattern: {0}\n+\n+options.err.file-not-found=\\\n+    file not found: {0}\n+\n+options.err.invalid-arg-for-verbose=\\\n+    invalid argument for --verbose: ''{0}''\n+\n+options.err.invalid-boolean=\\\n+    invalid value; must be one of: true, yes, on, false, no, off\n+\n+options.err.invalid.info.text=\\\n+    invalid argument for --info-text\n+\n+options.err.invalid-info-text-kind=\\\n+    invalid kind of --info-text: ''{0}''\n+\n+options.err.missing-module-name=\\\n+    no module name in pattern: {0}\n+\n+options.err.missing-value-for-option=\\\n+    no value given for option {0}\n+\n+options.err.no-api-for-option=\\\n+    current API not set for API-specific option: {0}\n+\n+options.err.no-images-in-jdk-build-dir=\\\n+    no images directory in JDK build directory for API ''{0}'': {1}\n+\n+options.err.no-include-options=\\\n+    no modules or packages specified with -include\n+\n+options.err.resource-file-not-found=\\\n+    resource file not found: {0}\n+\n+options.err.resource-file-not-found-in-api-dirs=\\\n+    resource file not found in any api directory: {0}\n+\n+options.err.unexpected-module-name=\\\n+    unexpected module name in pattern: {0}\n+\n+options.err.unexpected-value-for-option=\\\n+    unexpected value for option {0}: ''{1}''\n+\n+options.err.unknown-option=\\\n+    unknown option: ''{0}''\n+\n+report.err.cant-create-directory=\\\n+    cannot create directory {0}: {1}\n+\n+report.err.error-finding-resource-files=\\\n+    error finding resource files in {0}: {1}\n+\n+report.err.error-writing-file=\\\n+    error writing file {0}: {1}\n+\n+version.msg.info=\\\n+    {0}, version {1} {2} {3}\\n\\\n+    Installed in {4}\\n\\\n+    Running on platform version {5} from {6}.\\n\\\n+    Built with {7} on {8}.\n+\n+version.msg.unknown=\\\n+    unknown\n+\n+\n","filename":"src\/share\/classes\/jdk\/codetools\/apidiff\/resources\/log.properties","additions":242,"deletions":0,"binary":false,"changes":242,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+API Comparison Utility: apidiff\n+\n+\n+Introduction\n+\n+...\n+\n+Release Notes.\n+\n+...\n+\n+\n+System Requirements\n+\n+The following sections provide the recommended system requirements for running\n+apidiff.\n+\n+- Java platform\n+    A platform equivalent to JDK 17 or later is required.\n+\n+\n+\n+Files and Directories\n+\n+Name            Description\n+README          This file\n+COPYRIGHT       Copyright information\n+LICENSE         License file\n+doc\/            Documentation files\n+legal\/          Copyright and license files\n+lib\/            Directory containing the JAR files needed to run apidiff\n+bin\/            Miscellaneous utility script for use on Linux, macOS, Solaris\n+                and for Cygwin on Microsoft Windows platforms\n+\n","filename":"src\/share\/doc\/README","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+body {\n+  margin: 2em 2em;\n+  font-family: DejaVu Sans, Bitstream Vera Sans, Luxi Sans, Verdana, Arial, Helvetica;\n+  font-size: 10pt;\n+  line-height: 1.4;\n+}\n+\n+pre, code, tt {\n+  font-family: DejaVu Sans Mono, Bitstream Vera Sans Mono, Luxi Mono,\n+    Courier New, monospace;\n+}\n+\n+blockquote {\n+  margin: 1.5ex 0em 1.5ex 2em;\n+}\n+\n+p {\n+  padding: 0pt;\n+  margin: 1ex 0em;\n+}\n+\n+p:first-child, pre:first-child { margin-top: 0pt; }\n+\n+h1 {\n+  font-weight: bold;\n+  padding: 0pt;\n+  margin: 2ex .5ex 1ex 0pt;\n+}\n+\n+h1:first-child, h2:first-child {\n+  margin-top: 0ex;\n+}\n+\n+h2 {\n+  font-weight: bold;\n+  padding: 0pt;\n+  margin: 2ex 0pt 1ex 0pt;\n+}\n+\n+h3 {\n+  font-weight: bold;\n+  padding: 0pt;\n+  margin: 1.5ex 0pt 1ex 0pt;\n+}\n+\n+h4 {\n+  font-weight: bold;\n+  padding: 0pt;\n+  margin: 1.5ex 0pt 1ex 0pt;\n+}\n+\n+a:link {\n+  color: #4A6782;\n+}\n+\n+a:visited {\n+  color: #666666;\n+}\n+\n+a[href]:hover {\n+  color: #e76f00;\n+}\n+\n+a img {\n+  border-width: 0px;\n+}\n+\n+img {\n+  background: white;\n+}\n+\n+table {\n+  border-collapse: collapse;\n+  margin-left: 15px;\n+  margin-right: 15px;\n+}\n+\n+th, td {\n+  padding: 3px;\n+  vertical-align: top;\n+}\n+\n+table, th, td {\n+  border: 1px solid black;\n+}\n+\n+caption  {\n+  text-align: left;\n+  font-style: italic;\n+  text-indent: 15px;\n+  margin-bottom:10px;\n+}\n+\n+tr:nth-child(even), tr:nth-child(even) th[scope=row] {\n+  background: #E3E3E3;\n+}\n+\n+tr:nth-child(odd), tr:nth-child(odd) th[scope=row] {\n+  background: #FFF;\n+}\n+\n+th {\n+  background: #DDF;\n+}\n+\n+table.centered {\n+  margin-left: auto;\n+  margin-right: auto;\n+}\n+table.centered td {\n+  text-align: left;\n+}\n+.centered {\n+  text-align: center;\n+}\n+\n+li > p + ul {\n+  margin-top: -1ex;\n+  margin-bottom: 1ex;\n+}\n\\ No newline at end of file\n","filename":"src\/share\/doc\/apidiff.css","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,481 @@\n+---\n+#\n+# Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+title: 'APIDIFF(1) 0.1 | CodeTools'\n+date: 2021\n+lang: en\n+---\n+\n+<b style=\"color:red\">WORK IN PROGRESS<\/b>\n+\n+## Name\n+\n+apidiff - compare different versions of an API\n+\n+## Synopsis\n+\n+\n+`apidiff` \\[*options*\\]\n+\n+*options*\n+:   Command-line options\n+\n+## Description\n+\n+The `apidiff` command reads source, class and HTML files that provide different versions\n+of an API, compares corresponding files in the different versions and writes out\n+an HTML report.  The comparison includes:\n+\n+* structural changes, such as whether an element was added, changed or removed,\n+  using information in source or class files\n+* documentation contained in documentation comments,\n+  using information in source files\n+* generated API documentation,\n+  using information found in documentation generated by the `javadoc` tool\n+\n+## Options\n+\n+`apidiff` provides different groups of options, to specify\n+the [APIs](#the-apis) and\n+the [elements in those APIs](#the-elements-to-be-compared) to be compared,\n+[output options](#output-options) for the report to be generated, and\n+[other options](#other-options).\n+\n+### The APIs\n+\n+To specify each of the APIs to be compared, use the `--api` _name_ option\n+followed by a series of options that apply to that API. Most of the options are the\n+same as the corresponding _javac_ option; see the _javac_ documentation for more details\n+about those options.\n+\n+<a id=\"option-api\">`--api` _name_<\/a>\n+:   Specifies a name for the API and sets the [current API](#the-current-api) for\n+    use by the API-specific options that immediately follow this option.\n+    The option, and the API-specific options that follow, should be provided for each API\n+    to be compared.\n+    The order in which the `--api` options first appear on the command line determines\n+    the order in which any differences are reported.  It is recommended to specify the\n+    options in chronological order, from the oldest version of the API to the most recent\n+    version of the API.\n+\n+<a id=\"option-api-directory\">`--api-directory` *directory*<\/a>\n+:   Specifies where to find the generated API documentation for the [current API](#the-current-api).\n+    If given, it should be the top-level directory of the documentation generated by\n+    the `javadoc` command for the API.\n+\n+<a id=\"option-class-path\">`--class-path` *path*, `-classpath` *path*, or `-cp` *path*<\/a>\n+:   Specifies where to find files for the class path for the [current API](#the-current-api).\n+\n+<a id=\"option-enable-preview\">`--enable-preview`<\/a>\n+:   Enables preview language features for the [current API](#the-current-api).\n+\n+<a id=\"option-jdk-build\">`--jdk-build` *directory*<\/a>\n+:   Specifies a directory containing a JDK build from which to infer values for\n+    various options. For example, *repository*`\/build\/`*configuration-name*\n+\n+<a id=\"option-label\">`--label` *text*<\/a>\n+:   Specifies a short plain-text label for the API, to be included in the generated\n+    reports. For example, the full version string for the instance of the API being compared.\n+\n+<a id=\"option-module-path\">`--module-path`<\/a> *path* or `-p` *path*<\/a>\n+:   Specifies where to find application modules for the [current API](#the-current-api).\n+\n+<a id=\"option-module-source-path\">`--module-source-path` *module-source-path*<\/a>\n+:   Specifies where to find source files for the [current API](#the-current-api) when comparing code\n+    in multiple modules.\n+\n+<a id=\"option-patch-module\">`--patch-module` *module*`=`*path*<\/a>\n+:   Overrides or augments a module in the [current API](#the-current-api) with classes and resources\n+    in JAR files or directories.\n+\n+<a id=\"option-release\">`--release` *release*<\/a>\n+:   Specifies the release version for the [current API](#the-current-api) for any source and class\n+    files that may be read.\n+\n+<a id=\"option-source\">`--source` *release* or `-source` *release*<\/a>\n+:   Specifies the source version for the [current API](#the-current-api) for any source files that\n+    may be read.\n+\n+<a id=\"option-source-path\">`--source-path` *path* or `-sourcepath` *path*<\/a>\n+:   Specifies where to find source files for the [current API](#the-current-api).\n+    Note that, unlike `javac`, you cannot use this option to specify where to find\n+    the source code for a single module. Use the `--module-source-path` option instead,\n+    possibly using the _module-specific form_ of that option.\n+\n+<a id=\"option-system\">`--system` *jdk* \\| `none`<\/a>\n+:   Overrides the location of system modules for the [current API](#the-current-api).\n+\n+By convention, the APIs should be defined on the command in chronological order: oldest first,\n+newest last. When comparing documentation comments or API descriptions, the APIs will be compared\n+pairwise, with each of the older instances being compared against the newest instance.\n+\n+### The Elements to be Compared\n+\n+<a id=\"option-access\">`--access` `public|protected|package|private`<\/a>\n+:   Specifies the access of the declarations to be compared. The default is `protected`.\n+\n+    * `public`: public declarations only\n+    * `protected`: public and protected declarations\n+    * `package`: public, protected and package-private declarations\n+    * `private`: all declarations\n+\n+    Note: this option does not apply to the parts of the serialized form\n+    of a serializable class, even if those parts are provided by private\n+    methods and fields.\n+\n+<a id=\"option-exclude\">`--exclude` *pattern*<\/a>\n+:   Specifies the patterns for modules or packages to be excluded from the\n+    comparison.\n+\n+<a id=\"option-include\">`--include` *pattern*<\/a>\n+:   Specifies the patterns for modules or packages to be included from the\n+    comparison.\n+\n+<a id=\"option-compare-api-descriptions\">`--compare-api-descriptions` *boolean*<\/a>\n+:   Specifies that the API descriptions (as generated by javadoc) should be compared\n+    for each element being compared.\n+    The option defaults to `true` if documentation comments are not to be compared\n+    and if an API directory is given for each instance of the API to be\n+    compared. (See `--compare-doc-comments`).\n+    When the option is enabled, either explicitly or by default,\n+    the API directory must be specified for each instance of the API\n+    to be compared, and set to the location of the files generated by `javadoc`\n+    that corresponds to the source and class files being compared.\n+    The API directory for an API can be specified explicitly, with the `--api-directory`\n+    option, or indirectly, with the `--jdk-build` and `--jdk-docs` options.\n+\n+<a id=\"option-compare-api-descriptions-as-text\">`--compare-api-descriptions-as-text` *boolean*<\/a>\n+:   Specifies that the HTML for the API descriptions (as generated by javadoc)\n+    should be compared as plain text for each element being compared. If the argument is `true`,\n+    this option also implies `--compare-api-descriptions true`.\n+\n+<a id=\"option-compare-doc-comments\">`--compare-doc-comments` *boolean*<\/a>\n+:   Specifies that the documentation comments should be compared for each element\n+    being compared. This implies that the source files should be available for each\n+    instance of the API being compared; if they are not available, the documentation\n+    comments will not be compared.\n+    The option defaults to `false` if the API descriptions are to be compared,\n+    and `true` otherwise. (See `--compare-api-descriptions`).\n+\n+<a id=\"option-jdk-docs\">`--jdk-docs` *name*<\/a>\n+:   In conjunction with the `--jdk-build` option, specifies the name of the\n+    documentation bundle to use when more than one is available.\n+    For example, `docs`, `javase-docs`, `reference-docs`.\n+\n+### Output Options\n+\n+<a id=\"option-output-directory\">`--output-directory` _directory_  or  `-d` _directory_<\/a>\n+:   Specifies the directory in which to write the report about the comparison.\n+    The directory will be created if it does not already exist.\n+\n+<a id=\"option-title\">`--title` _text_<\/a>\n+:   Specifies a title for the report, to be used in each generated page.\n+\n+<a id=\"option-description\">`--description` _html_<\/a>\n+:   Specifies a short description for the report, to be used on the top level summary page.\n+\n+<a id=\"option-info-text\">`--info-text` _name_`=`_html_<\/a>\n+:   Specifies information to be included in different positions on each page.\n+    _name_ can be one of:\n+\n+    * `top`: at the top of each page; this may be used to indicate the status\n+        of the pages.\n+    * `header`: in the header bar on each page; if not specified, a default value\n+        is generated, based on the names of the APIs being compared.\n+    * `footer`: in the footer bar on each page; if not specified, a default value\n+        is generated, based on the names of the APIs being compared.\n+    * `bottom`: at the bottom of each page; this may be used to indicate\n+        copyright and license information,\n+\n+<a id=\"option-notes\">`--notes` _file_<\/a>\n+:   Specifies a file containing [notes] to be added for various elements.\n+\n+<a id=\"option-main-stylesheet\">`--main-stylesheet` _file_<\/a>\n+:   Specifies an alternate stylesheet to use in the generated report\n+    instead of the system default.\n+\n+<a id=\"option-extra-stylesheet\">`--extra-stylesheet` _file_<\/a>\n+:   Specifies an additional stylesheet to use in the generated report.\n+    <p class=\"note\">This option may be useful when comparing HTML documentation that\n+    contains references to custom styles.<\/p>\n+\n+<a id=\"option-resource-files\">`--resource-files` _file-or-directory_<\/a>\n+:   Specifies resource files to be copied from one or more API directories.\n+    <p class=\"note\">This option may be useful when comparing HTML documentation that\n+    depend on some non-HTML resource files.<\/p>\n+\n+### Other Options\n+\n+<a id=\"option-help\">`--help`, `-help`, `-h`, `-?`<\/a>\n+:   Displays command-line help.\n+\n+<a id=\"option-version\">`--version`, `-v`<\/a>\n+:   Displays the version of the tool.\n+\n+<a id=\"option-verbose\">`--verbose` _flag_[`,`_flag_]*<\/a>\n+:   Specifies the kinds of verbose output. _flag_ may be one of\n+    `all`, `none`, or one of the following, optionally preceded by `-`:\n+    `module`, `package`, `type`, `time`.\n+\n+<a id=\"option-at\">`@`*filename*<\/a>\n+:   Reads options from a file. To shorten or simplify the `apidiff` command, you can specify\n+    one or more files that contain arguments for the `apidiff` command. This lets you to create\n+    `apidiff` commands of any length on any operating system.\n+\n+\n+## The Current API\n+\n+The current API is the API specified by the most recent `--api` option on the command line,\n+and is the API for which any API-specific options will apply.\n+\n+The \"current API\" is cancelled when any option is given that is not specific to\n+any one API. Additional options for an API can be given by repeating the `--api`\n+option to set the API as the current API again.\n+\n+\n+## Patterns\n+\n+Patterns provide a way to specify groups of similarly-named modules,\n+packages and types to be included or excluded from the comparison.\n+\n+A pattern consists of a _module-part_ and\/or a _type_part_.\n+\n+_module-part_:\n+:\n+    | _qualified-identifier_ `\/`\n+    | _qualified-identifier_.*  `\/`\n+\n+_type-part_:\n+:\n+    | `**`\n+    | _qualified-identifier_\n+    | _qualified-identifier_`.*`\n+    | _qualified-identifier_`.**`\n+\n+A _module-part_ that is just a qualified identifier matches the\n+named module.\n+A _module-part_ that ends in a wildcard matches all module names that begin\n+with the given qualified identifier.\n+\n+A _type-part_ that is just a qualified identifier matches the named type.\n+A _type-part_ that ends in a single `*` matches all types in the package\n+with the given qualified identifier.\n+A _type-part_ that ends in `**` matches all types in all packages that begin\n+with the given qualified identifier.\n+A _type-part_ of `**` can only be used in conjunction with a non-empty\n+module part.\n+\n+`apidiff` cannot compare a combination of types in named modules and types\n+in the unnamed module, and so either all patterns must include a module part,\n+or none must.\n+\n+## Notes\n+\n+A \"notes\" file is used to specify links to be injected into the generated report\n+for some elements.\n+\n+The file is a plain text file. Blank lines and lines beginning with `#` are ignored.\n+The remaining lines are interpreted as a series of blocks, each of which must start\n+with a line containing a URL and a short plain-text description, followed by\n+a series of lines, each containing a signature describing an element or set of elements.\n+For each block, a link based on the URL and description, will be added to any\n+element appearing in the generated report that matches any of the corresponding\n+signatures.\n+\n+The following signatures are supported:\n+\n+*   _module_\n+*   _module_ `\/*`\n+*   [ _module_ `\/` ] _package_\n+*   [ _module_ `\/` ] _package_ `.*`\n+*   [ _module_ `\/` ] _package_ `.` _type_\n+*   [ _module_ `\/` ] _package_ `.` _type_ `.*`\n+*   [ _module_ `\/` ] _package_ `.` _type_ `#` _field_\n+*   [ _module_ `\/` ] _package_ `.` _type_ `#` `<init>` `(` _parameters_ `)`\n+*   [ _module_ `\/` ] _package_ `.` _type_ `#` _method_ `(` _parameters_ `)`\n+\n+Signatures should not contain any white-space characters.\n+Signatures ending in `\/*` or `.*` match the specified item, and any enclosed elements down\n+to the level of a type element.\n+For methods and constructors, _parameters_ is a comma-separated list of parameter types,\n+omitting any type parameters, and using just the simple name of any declared types.\n+\n+For example,\n+\n+*   `java.base\/*` matches the `java.base` module, all packages in `java.base`,\n+    and all types in those packages.\n+*   `java.base\/java.lang.*` matches the `java.lang` package in the `java.base` module,\n+    and all types in that package.\n+    Note that it does not include subpackages, such as `java.lang.reflect`,\n+    or any types in those subpackages.\n+*   `java.base\/java.lang.String` just matches the type `java.lang.String`.\n+*   `java.base\/java.lang.String#equals(Object)` just matches the `equals(Object)`.\n+\n+## Configuring the APIs to be compared\n+\n+At a minimum, the source or class files must be provided for each instance\n+of the API to be compared.\n+If the API does not provide or is not part of a module, use the `--source-path`\n+and `--class-path` options.\n+If the API provides or is part of one or more modules, use the\n+`--source-path`, `--module-source-path`, `--module-path` and related options.\n+\n+If you want to compare the content of documentation comments, you must provide\n+source files for all the elements to be compared; any dependencies of those source\n+files can be specified as either source or class files.\n+\n+If you want to compare the API descriptions, you must provide the locations\n+of the directories generated by the `javadoc` tool for each of the instances\n+of the API being compared. This is often a directory whose path ends in `api`,\n+although that is not a requirement.\n+\n+### Configuring instances of JDK to be compared\n+\n+`apidiff` can be used to compare different instances of JDK, but that can be\n+tricky to set up, depending on the kind of comparison that is required.\n+That being said, there is a \"convenience\" option to specify a JDK build,\n+as generated by the standard JDK makefiles.\n+\n+* If you want to compare the files in two separate JDK builds, for each instance\n+  use the following:\n+\n+    * the `--api` option to introduce the set of API-specific options that follow\n+    * the `--jdk-build` option to specify the location of the build containing\n+      the files to be compared, such as `build\/macosx-x64`,\n+      `build\/linux-x86_64-server-release`, or the path for any directory that is\n+      used for a custom configuration.\n+\n+  The directory specified with `--jdk-build` should contain the following files:\n+\n+    * the \"marker\" file `spec.gmk`,\n+    * the JDK image, in `images\/jdk`,\n+    * one or more documentation bundles, in `images\/*docs*`, if API descriptions\n+      should be compared, and\n+    * the source code, in `support\/src.zip`, if documentation comments should\n+      be compared\n+\n+  In conjunction with this option, use the `jdk-docs` option to specify the name\n+  of the docs bundle to be compared, when there is more than one. Note this option\n+  applies to all instances to be compared, and is not specific to the\n+  [current API](#the-current-api). Use the `--compare-doc-comments` and\n+  `--compare-api-descriptions` as needed to indicate the comparisons to be included\n+  in the report.  If neither are specified, `--compare-api-descriptions` is\n+  the default.\n+\n+* If you just want to compare some or all of the declarations in different\n+  instances of JDK, without comparing the documentation comments or API documentation,\n+  for each instance use the following:\n+\n+    * the `--api` option to introduce the set of API-specific options that follow\n+    * the `--system` option to point to the instance of JDK\n+\n+* If you want to compare the declarations and the corresponding API descriptions\n+  generated by `javadoc`, for each instance of JDK use the following:\n+\n+    * the `--api` option to introduce the set of API-specific options that follow\n+    * the `--system` option to point to the instance of JDK\n+    * the `--api-directory` option to point to the corresponding documentation\n+    generated by the `javadoc` tool\n+\n+* If you want to compare the declarations and the corresponding documentation\n+  comments, it is recommended to use the following:\n+\n+    * the `--api` option to introduce the set of API-specific options that follow\n+    * the `--system` option to point to the instance of JDK\n+    * a series of `--patch-module` options to specify the location of the\n+      source for each of the modules to be compared\n+\n+When using `--patch-module`, you do not need to specify all the source directories\n+for the module: you just need to specify the source directories containing\n+the classes whose documentation comments are to be compared.  Any supporting\n+declarations will be found in the JDK specified by the `--system` option.\n+\n+If the list of `--patch-module` options is large, it may be convenient to\n+place them in a file and use the `@`_file_ option to specify the location\n+of the file. You might also choose to put all the options for an API in\n+an API-specific `@`_file_.\n+\n+If you want to compare the API descriptions as well as the documentation comments,\n+you can combine the recommended options for the two modes, specifying both\n+`--patch-module` options for the source files and `--api-directory` for the\n+generated documentation.\n+\n+### Comparing different releases of JDK\n+\n+When comparing any generated API documentation, the comparison is sensitive to any\n+variations caused by the version of `javadoc` used to generate the documentation.\n+Therefore, it is highly recommended to use the same version of `javadoc` to generate\n+all the versions of the documentation to be compared.  When building JDK, although\n+the standard `docs` and `docs-jdk` targets will use the version of `javadoc` in the\n+same repository, you can specify the version of JDK to be used for targets like\n+`docs-reference-api` with the `--with-docs-reference-jdk` option to `configure`,\n+allowing you to specify the same version of JDK and hence the same version of\n+`javadoc` to be used to generate the API documentation for each build to be compared.\n+Generally, the JDK version used to generate the documentation should be at least as\n+recent as the latest version to be compared.\n+\n+When comparing recent API changes in JDK, such as when creating a report for a\n+CSR request, when there is no change in `javadoc` in the versions being compared,\n+it is reasonable to use the standard `docs` or `docs-jdk` targets to generate the API\n+documentation to be compared.\n+\n+### Comparing documentation comments or API descriptions\n+\n+As well as comparing the declarations found in source files or compiled class files,\n+`apidiff` can compare documentation comments and\/or the API documentation generated\n+by `javadoc` and the Standard Doclet.\n+\n+* Comparing documentation comments is easy, and does not require API documentation\n+  to have been generated. However, it is just a simple text comparison of the text of\n+  the documentation comments, and so does not take into account any of the analysis\n+  and processing that is done by the Standard Doclet. Most notably, it does not\n+  take `{@inheritDoc}` into account, and so might miss some differences in any\n+  inherited documentation.\n+\n+* Comparing API descriptions is better for comparing the documentation as generated\n+  by the Standard Doclet, and as seen by the end user reading the API specification.\n+  However, it does require that API documentation needs to be generated beforehand,\n+  and generally using the same version of `javadoc` for all the versions of the API\n+  that are being compared.\n+\n+## Operation\n+\n+The tool operates by creating an instance of the Java compiler front-end\n+(as found in the [`jdk.compiler`][jdk.compiler] module)\n+from which it can obtain the selected elements to be compared,\n+using the [Java Language Model API] and [Compiler Tree API].\n+\n+_Note: Because the compiler is reading the source and class files for each instance of\n+the API being compared, the release of the JDK platform used to run `apidiff` must be\n+at least as recent as each of the releases used to compile the instances to be compared._\n+\n+When comparing the API descriptions for each selected element, the tool attempts to find\n+the relevant content in the API documentation that is provided using the\n+<a href=\"#option-api-directory\">`--api-directory`<\/a> or\n+<a href=\"#option-jdk-build\">`--jdk-build`<\/a> options.\n+The tool does _not_ attempt to run `javadoc` locally to generate the page on the fly.\n+\n+[jdk.compiler]: https:\/\/docs.oracle.com\/en\/java\/javase\/17\/docs\/api\/jdk.compiler\/module-summary.html\n+[Java Language Model API]: https:\/\/docs.oracle.com\/en\/java\/javase\/17\/docs\/api\/java.compiler\/javax\/lang\/model\/package-summary.html\n+[Compiler Tree API]: https:\/\/docs.oracle.com\/en\/java\/javase\/17\/docs\/api\/jdk.compiler\/com\/sun\/source\/doctree\/package-summary.html\n","filename":"src\/share\/doc\/apidiff.md","additions":481,"deletions":0,"binary":false,"changes":481,"status":"added"},{"patch":"@@ -0,0 +1,284 @@\n+module:java.base\n+java.io\n+java.lang\n+java.lang.annotation\n+java.lang.constant\n+java.lang.invoke\n+java.lang.module\n+java.lang.ref\n+java.lang.reflect\n+java.lang.runtime\n+java.math\n+java.net\n+java.net.spi\n+java.nio\n+java.nio.channels\n+java.nio.channels.spi\n+java.nio.charset\n+java.nio.charset.spi\n+java.nio.file\n+java.nio.file.attribute\n+java.nio.file.spi\n+java.security\n+java.security.cert\n+java.security.interfaces\n+java.security.spec\n+java.text\n+java.text.spi\n+java.time\n+java.time.chrono\n+java.time.format\n+java.time.temporal\n+java.time.zone\n+java.util\n+java.util.concurrent\n+java.util.concurrent.atomic\n+java.util.concurrent.locks\n+java.util.function\n+java.util.jar\n+java.util.random\n+java.util.regex\n+java.util.spi\n+java.util.stream\n+java.util.zip\n+javax.crypto\n+javax.crypto.interfaces\n+javax.crypto.spec\n+javax.net\n+javax.net.ssl\n+javax.security.auth\n+javax.security.auth.callback\n+javax.security.auth.login\n+javax.security.auth.spi\n+javax.security.auth.x500\n+javax.security.cert\n+module:java.compiler\n+javax.annotation.processing\n+javax.lang.model\n+javax.lang.model.element\n+javax.lang.model.type\n+javax.lang.model.util\n+javax.tools\n+module:java.datatransfer\n+java.awt.datatransfer\n+module:java.desktop\n+java.applet\n+java.awt\n+java.awt.color\n+java.awt.desktop\n+java.awt.dnd\n+java.awt.event\n+java.awt.font\n+java.awt.geom\n+java.awt.im\n+java.awt.im.spi\n+java.awt.image\n+java.awt.image.renderable\n+java.awt.print\n+java.beans\n+java.beans.beancontext\n+javax.accessibility\n+javax.imageio\n+javax.imageio.event\n+javax.imageio.metadata\n+javax.imageio.plugins.bmp\n+javax.imageio.plugins.jpeg\n+javax.imageio.plugins.tiff\n+javax.imageio.spi\n+javax.imageio.stream\n+javax.print\n+javax.print.attribute\n+javax.print.attribute.standard\n+javax.print.event\n+javax.sound.midi\n+javax.sound.midi.spi\n+javax.sound.sampled\n+javax.sound.sampled.spi\n+javax.swing\n+javax.swing.border\n+javax.swing.colorchooser\n+javax.swing.event\n+javax.swing.filechooser\n+javax.swing.plaf\n+javax.swing.plaf.basic\n+javax.swing.plaf.metal\n+javax.swing.plaf.multi\n+javax.swing.plaf.nimbus\n+javax.swing.plaf.synth\n+javax.swing.table\n+javax.swing.text\n+javax.swing.text.html\n+javax.swing.text.html.parser\n+javax.swing.text.rtf\n+javax.swing.tree\n+javax.swing.undo\n+module:java.instrument\n+java.lang.instrument\n+module:java.logging\n+java.util.logging\n+module:java.management\n+java.lang.management\n+javax.management\n+javax.management.loading\n+javax.management.modelmbean\n+javax.management.monitor\n+javax.management.openmbean\n+javax.management.relation\n+javax.management.remote\n+javax.management.timer\n+module:java.management.rmi\n+javax.management.remote.rmi\n+module:java.naming\n+javax.naming\n+javax.naming.directory\n+javax.naming.event\n+javax.naming.ldap\n+javax.naming.ldap.spi\n+javax.naming.spi\n+module:java.net.http\n+java.net.http\n+module:java.prefs\n+java.util.prefs\n+module:java.rmi\n+java.rmi\n+java.rmi.dgc\n+java.rmi.registry\n+java.rmi.server\n+javax.rmi.ssl\n+module:java.scripting\n+javax.script\n+module:java.se\n+module:java.security.jgss\n+javax.security.auth.kerberos\n+org.ietf.jgss\n+module:java.security.sasl\n+javax.security.sasl\n+module:java.smartcardio\n+javax.smartcardio\n+module:java.sql\n+java.sql\n+javax.sql\n+module:java.sql.rowset\n+javax.sql.rowset\n+javax.sql.rowset.serial\n+javax.sql.rowset.spi\n+module:java.transaction.xa\n+javax.transaction.xa\n+module:java.xml\n+javax.xml\n+javax.xml.catalog\n+javax.xml.datatype\n+javax.xml.namespace\n+javax.xml.parsers\n+javax.xml.stream\n+javax.xml.stream.events\n+javax.xml.stream.util\n+javax.xml.transform\n+javax.xml.transform.dom\n+javax.xml.transform.sax\n+javax.xml.transform.stax\n+javax.xml.transform.stream\n+javax.xml.validation\n+javax.xml.xpath\n+org.w3c.dom\n+org.w3c.dom.bootstrap\n+org.w3c.dom.events\n+org.w3c.dom.ls\n+org.w3c.dom.ranges\n+org.w3c.dom.traversal\n+org.w3c.dom.views\n+org.xml.sax\n+org.xml.sax.ext\n+org.xml.sax.helpers\n+module:java.xml.crypto\n+javax.xml.crypto\n+javax.xml.crypto.dom\n+javax.xml.crypto.dsig\n+javax.xml.crypto.dsig.dom\n+javax.xml.crypto.dsig.keyinfo\n+javax.xml.crypto.dsig.spec\n+module:jdk.accessibility\n+com.sun.java.accessibility.util\n+module:jdk.attach\n+com.sun.tools.attach\n+com.sun.tools.attach.spi\n+module:jdk.charsets\n+module:jdk.compiler\n+com.sun.source.doctree\n+com.sun.source.tree\n+com.sun.source.util\n+com.sun.tools.javac\n+module:jdk.crypto.cryptoki\n+module:jdk.crypto.ec\n+module:jdk.dynalink\n+jdk.dynalink\n+jdk.dynalink.beans\n+jdk.dynalink.linker\n+jdk.dynalink.linker.support\n+jdk.dynalink.support\n+module:jdk.editpad\n+module:jdk.hotspot.agent\n+module:jdk.httpserver\n+com.sun.net.httpserver\n+com.sun.net.httpserver.spi\n+module:jdk.incubator.foreign\n+jdk.incubator.foreign\n+module:jdk.incubator.vector\n+jdk.incubator.vector\n+module:jdk.jartool\n+com.sun.jarsigner\n+jdk.security.jarsigner\n+module:jdk.javadoc\n+jdk.javadoc.doclet\n+module:jdk.jcmd\n+module:jdk.jconsole\n+com.sun.tools.jconsole\n+module:jdk.jdeps\n+module:jdk.jdi\n+com.sun.jdi\n+com.sun.jdi.connect\n+com.sun.jdi.connect.spi\n+com.sun.jdi.event\n+com.sun.jdi.request\n+module:jdk.jdwp.agent\n+module:jdk.jfr\n+jdk.jfr\n+jdk.jfr.consumer\n+module:jdk.jlink\n+module:jdk.jpackage\n+module:jdk.jshell\n+jdk.jshell\n+jdk.jshell.execution\n+jdk.jshell.spi\n+jdk.jshell.tool\n+module:jdk.jsobject\n+netscape.javascript\n+module:jdk.jstatd\n+module:jdk.localedata\n+module:jdk.management\n+com.sun.management\n+module:jdk.management.agent\n+module:jdk.management.jfr\n+jdk.management.jfr\n+module:jdk.naming.dns\n+module:jdk.naming.rmi\n+module:jdk.net\n+jdk.net\n+jdk.nio\n+module:jdk.nio.mapmode\n+jdk.nio.mapmode\n+module:jdk.sctp\n+com.sun.nio.sctp\n+module:jdk.security.auth\n+com.sun.security.auth\n+com.sun.security.auth.callback\n+com.sun.security.auth.login\n+com.sun.security.auth.module\n+module:jdk.security.jgss\n+com.sun.security.jgss\n+module:jdk.xml.dom\n+org.w3c.dom.css\n+org.w3c.dom.html\n+org.w3c.dom.stylesheets\n+org.w3c.dom.xpath\n+module:jdk.zipfs\n\\ No newline at end of file\n","filename":"src\/share\/doc\/jdk17.api\/element-list","additions":284,"deletions":0,"binary":false,"changes":284,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+<!doctype html>\n+<html>\n+<head>\n+<title>APIDiff: Overview<\/title>\n+<style>\n+dd p:first-child {\n+  margin-top: 0\n+}\n+<\/style>\n+<\/head>\n+<body>\n+<h1>APIDiff: Overview<\/h1>\n+\n+<p>\n+<code>APIDiff<\/code> is an API-comparison utility, comparing elements in\n+different versions of an API, as represented by some combination of source files, class files,\n+and generated documentation.\n+\n+<p>\n+The tool operates by creating an instance of the Java compiler front-end\n+(as found in the\n+<a href=\"https:\/\/docs.oracle.com\/en\/java\/javase\/17\/docs\/api\/jdk.compiler\/module-summary.html\"><code>jdk.compiler<\/code><\/a> module)\n+from which it can obtain the selected elements to be compared,\n+using the\n+<a href=\"https:\/\/docs.oracle.com\/en\/java\/javase\/17\/docs\/api\/java.compiler\/javax\/lang\/model\/package-summary.html\">Java Language Model API<\/a>\n+and\n+<a href=\"https:\/\/docs.oracle.com\/en\/java\/javase\/17\/docs\/api\/jdk.compiler\/com\/sun\/source\/doctree\/package-summary.html\">Compiler Tree API<\/a>.\n+\n+<dl>\n+<dt>{@link jdk.codetools.apidiff.model Comparing declarations}\n+<dd><p style=\"margin-top:0\">\n+Elements, type mirrors and names obtained from different instances of the\n+compiler front-end cannot be compared referentially or by using {@link java.lang.Object#equals(Object) equals}.\n+Instead, API-specific items can be represented in an API-independent manner\n+using  <em>keys<\/em> for {@link jdk.codetools.apidiff.model.ElementKey elements} and\n+{@link jdk.codetools.apidiff.model.TypeMirrorKey types};\n+they can be identified within an API by means of {@link jdk.codetools.apidiff.model.Position positions};\n+and corresponding items in different instances of an API can be associated together using\n+{@link jdk.codetools.apidiff.model.APIMap API maps}, and which can be compared structurally,\n+using a series of custom \"comparator\" classes.\n+\n+<p>\n+When comparing the API descriptions for each selected element, the tool attempts to find\n+the relevant content in the API documentation, provided by the\n+<code>--api-directory<\/code> option.\n+The content is extracted from the generated pages using one of two classes:\n+{@link jdk.codetools.apidiff.model.APIReader APIReader} and\n+{@link jdk.codetools.apidiff.model.SerializedFormReader SerializedFormReader},\n+for reading general declaration pages and the \"Serialized Form\" pages respectively.\n+\n+<dt>{@link jdk.codetools.apidiff.report Reporting differences}\n+<dd><p style=\"margin-top:0\">\n+Differences between corresponding elements in different versions of the API\n+are reported using the {@link jdk.codetools.apidiff.report.Reporter Reporter}\n+interface. This interface is the primary means of communication between the\n+front-end, comparing declarations, and the back-end, generating reports.\n+\n+<dt>{@link jdk.codetools.apidiff.report Generating reports}\n+<dd><p style=\"margin-top:0\">\n+The primary reporter is {@link jdk.codetools.apidiff.report.html.HtmlReporter HtmlReporter}.\n+This reporter dispatches the reports of any differences to handlers that collect\n+the information for the individual pages that will be generated once all the\n+information for each page has been collected.\n+\n+<\/dl>\n+\n+<\/body>\n+<\/html>\n","filename":"src\/share\/doc\/overview.html","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,393 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Toolkit;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.TreeMap;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JSplitPane;\n+import javax.swing.JTextArea;\n+import javax.swing.text.JTextComponent;\n+\n+import jdk.codetools.apidiff.html.Content;\n+import jdk.codetools.apidiff.html.HtmlAttr;\n+import jdk.codetools.apidiff.html.HtmlTag;\n+import jdk.codetools.apidiff.html.HtmlTree;\n+import org.outerj.daisy.diff.HtmlCleaner;\n+import org.outerj.daisy.diff.html.HTMLDiffer;\n+import org.outerj.daisy.diff.html.HtmlSaxDiffOutput;\n+import org.outerj.daisy.diff.html.TextNodeComparator;\n+import org.outerj.daisy.diff.html.dom.DomTreeBuilder;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.ContentHandler;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.helpers.AttributesImpl;\n+\n+public class DaisyDiffViewer {\n+    public static void main(String... args) {\n+        new DaisyDiffViewer().run(args);\n+    }\n+\n+    public void run(String... args) {\n+\n+        JTextArea leftArea = new JTextArea(10, 40);\n+        leftArea.setLineWrap(true);\n+\n+        JTextArea rightArea = new JTextArea(10, 40);\n+        rightArea.setLineWrap(true);\n+\n+        JSplitPane leftRight = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,\n+                new JScrollPane(leftArea,\n+                        JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                        JScrollPane.HORIZONTAL_SCROLLBAR_NEVER),\n+                new JScrollPane(rightArea,\n+                        JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                        JScrollPane.HORIZONTAL_SCROLLBAR_NEVER));\n+\n+        JTextArea diffArea = new JTextArea();\n+        diffArea.setLineWrap(true);\n+\n+        Toolkit tk = Toolkit.getDefaultToolkit();\n+        Dimension screenSize = tk.getScreenSize();\n+        int prefWidth = (int) (screenSize.width * .8);\n+        int prefHeight = screenSize.height \/ 2;\n+        diffArea.setPreferredSize(new Dimension(prefWidth, prefHeight));\n+\n+        JSplitPane topBottom = new JSplitPane(JSplitPane.VERTICAL_SPLIT,\n+                leftRight,\n+                new JScrollPane(diffArea,\n+                        JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n+                        JScrollPane.HORIZONTAL_SCROLLBAR_NEVER)\n+                );\n+\n+        JPanel body = new JPanel(new BorderLayout());\n+        body.add(topBottom, BorderLayout.CENTER);\n+\n+        JButton goBtn = new JButton(\"Go\");\n+        goBtn.addActionListener(ev -> go(leftArea, rightArea, diffArea));\n+        JPanel btnPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 10, 5));\n+        btnPanel.add(goBtn);\n+        body.add(btnPanel, BorderLayout.SOUTH);\n+\n+        JFrame frame = new JFrame();\n+        frame.getContentPane().add(body);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    void go(JTextArea leftArea, JTextArea rightArea, JTextComponent result) {\n+        System.err.println(\"go\");\n+        String leftText = leftArea.getText();\n+        String rightText = rightArea.getText();\n+        try {\n+            String diff = diffHtml(leftText, rightText);\n+            result.setText(diff);\n+        } catch (Exception e) {\n+            result.setText(e.toString());\n+        }\n+    }\n+\n+\n+    String diffHtml(String oldText, String newText) {\n+        try {\n+            Reader oldStream = new StringReader(oldText);\n+            Reader newStream = new StringReader(newText);\n+            Handler handler = new Handler();\n+            diffHtml(oldStream, newStream, handler);\n+            StringWriter sw = new StringWriter();\n+            handler.doc.write(sw);\n+            return sw.toString();\n+        } catch (IOException | SAXException e) {\n+            return \"Exception: \" + e;\n+        }\n+    }\n+\n+    \/\/ This method is an extract from the DaisyDiff main program, lines 120-157,\n+    \/\/ the body of \"if (htmlDiff) { ... }\". It runs the HtmlCleaner on the input\n+    \/\/ text prior to calling HtmlDiffer.\n+    void diffHtml(Reader oldStream, Reader newStream, ContentHandler postProcess)\n+            throws IOException, SAXException {\n+\n+        Locale locale = Locale.getDefault();\n+        String prefix = \"diff\";\n+\n+        HtmlCleaner cleaner = new HtmlCleaner();\n+\n+        InputSource oldSource = new InputSource(oldStream);\n+        InputSource newSource = new InputSource(newStream);\n+\n+        DomTreeBuilder oldHandler = new DomTreeBuilder();\n+        cleaner.cleanAndParse(oldSource, oldHandler);\n+        System.out.print(\".\");\n+        TextNodeComparator leftComparator = new TextNodeComparator(\n+                oldHandler, locale);\n+\n+        DomTreeBuilder newHandler = new DomTreeBuilder();\n+        cleaner.cleanAndParse(newSource, newHandler);\n+        System.out.print(\".\");\n+        TextNodeComparator rightComparator = new TextNodeComparator(\n+                newHandler, locale);\n+\n+        postProcess.startDocument();\n+        postProcess.startElement(\"\", \"diffreport\", \"diffreport\",\n+                new AttributesImpl());\n+\/\/        doCSS(css, postProcess);\n+        postProcess.startElement(\"\", \"diff\", \"diff\",\n+                new AttributesImpl());\n+        HtmlSaxDiffOutput output = new HtmlSaxDiffOutput(postProcess,\n+                prefix);\n+\n+        HTMLDiffer differ = new HTMLDiffer(output);\n+        differ.diff(leftComparator, rightComparator);\n+        System.out.print(\".\");\n+        postProcess.endElement(\"\", \"diff\", \"diff\");\n+        postProcess.endElement(\"\", \"diffreport\", \"diffreport\");\n+        postProcess.endDocument();\n+    }\n+\n+    class Handler implements ContentHandler {\n+        Stack<HtmlTree> stack;\n+        StringBuilder text;\n+        HtmlTree doc;\n+\n+        Handler() {\n+            stack = new Stack<>();\n+            text = new StringBuilder();\n+        }\n+\n+        Content toContent() {\n+            return stack.peek();\n+        }\n+\n+\n+        @Override\n+        public void setDocumentLocator(Locator locator) {\n+            \/\/ should not happen\n+        }\n+\n+        @Override\n+        public void startDocument() {\n+            stack.push(new HtmlTree(HtmlTag.DIV));\n+        }\n+\n+        @Override\n+        public void endDocument() {\n+            doc = stack.pop();\n+        }\n+\n+        @Override\n+        public void startPrefixMapping(String prefix, String uri) {\n+            \/\/ should not happen\n+        }\n+\n+        @Override\n+        public void endPrefixMapping(String prefix) {\n+            \/\/ should not happen\n+        }\n+\n+        @Override\n+        public void startElement(String uri, String localName, String qName, Attributes atts) {\n+            flushText();\n+            switch (localName) {\n+                \/\/ ignore possibility of <html>, <head>, <body> etc for now\n+                case \"diffreport\":\n+                case \"diff\":\n+                    return;\n+            }\n+            try {\n+                HtmlTag tag = HtmlTag.valueOf(localName.toUpperCase(Locale.US));\n+                HtmlTree tree = new HtmlTree(tag);\n+                for (int i = 0; i < atts.getLength(); i++) {\n+                    String name = atts.getLocalName(i);\n+                    String value = atts.getValue(i);\n+                    if (tag == HtmlTag.SPAN) {\n+                        \/\/ if changeId is found, we might want to ignore id as well,\n+                        \/\/ to avoid duplicate ids across different diff blocks\n+                        switch (name) {\n+                            case \"changes\":\n+                            case \"changeId\":\n+                            case \"next\":\n+                            case \"previous\":\n+                                System.err.println(\"!! \" + name + \" '\" + value + \"'\");\n+                                continue;\n+                        }\n+                    }\n+                    try {\n+                        HtmlAttr a = HtmlAttr.valueOf(name.toUpperCase(Locale.US));\n+                        tree.set(a, value);\n+                    } catch (IllegalArgumentException e) {\n+                        System.err.println(\"unknown attribute name: \" + localName + \"; \" + e);\n+                    }\n+                }\n+                stack.peek().add(tree);\n+                stack.push(tree);\n+            } catch (IllegalArgumentException e) {\n+                System.err.println(\"unknown element name: \" + localName + \"; \" + e);\n+            }\n+        }\n+\n+        @Override\n+        public void endElement(String uri, String localName, String qName) {\n+            flushText();\n+            switch (localName) {\n+                \/\/ ignore possibility of <html>, <head>, <body> etc for now\n+                case \"diffreport\":\n+                case \"diff\":\n+                    return;\n+            }\n+            HtmlTree tree = stack.pop();\n+            if (!tree.tag.name().equals(localName.toUpperCase(Locale.US))) {\n+                System.err.println(\"popping unbalanced tree node: expect: \" + localName + \", found \" + tree.tag);\n+            }\n+        }\n+\n+        @Override\n+        public void characters(char[] ch, int start, int length) {\n+            text.append(ch, start, length);\n+        }\n+\n+        @Override\n+        public void ignorableWhitespace(char[] ch, int start, int length) {\n+            text.append(ch, start, length);\n+        }\n+\n+        @Override\n+        public void processingInstruction(String target, String data) {\n+            \/\/ should not happen\n+        }\n+\n+        @Override\n+        public void skippedEntity(String name) {\n+            \/\/ should not happen\n+            \/\/ Note:\n+            \/\/ known entities are translated into the equivalent character; e.g. &lt; to <\n+            \/\/ unknown entities are handled as literal strings; e.g. &foo; remains as &foo;\n+        }\n+\n+        private void flushText() {\n+            if (text.length() > 0) {\n+                stack.peek().add(text.toString());\n+                text.setLength(0);\n+            }\n+        }\n+    }\n+\n+    class Handler2 implements ContentHandler {\n+        List<String> info = new ArrayList<>();\n+\n+        Handler2() { }\n+\n+        java.util.List<String> toList() {\n+            return info;\n+        }\n+\n+\n+        @Override\n+        public void setDocumentLocator(Locator locator) {\n+            info.add(\"setDocumentLocator: \" + locator);\n+        }\n+\n+        @Override\n+        public void startDocument() {\n+            info.add(\"startDocument\");\n+        }\n+\n+        @Override\n+        public void endDocument() {\n+            info.add(\"startDocument\");\n+        }\n+\n+        @Override\n+        public void startPrefixMapping(String prefix, String uri) {\n+            info.add(\"startPrefixMapping \" + prefix + \" \" + uri);\n+\n+        }\n+\n+        @Override\n+        public void endPrefixMapping(String prefix) {\n+            info.add(\"endPrefixMapping \" + prefix);\n+        }\n+\n+        @Override\n+        public void startElement(String uri, String localName, String qName, Attributes atts) {\n+            Map<String,String> map = new TreeMap<>();\n+            for (int i = 0; i < atts.getLength(); i++) {\n+                String name = atts.getLocalName(i);\n+                String value = atts.getValue(i);\n+                map.put(name, value);\n+            }\n+            info.add(\"startElement \" + uri + \" \"  + localName + \" \" + qName + \" \" + map);\n+        }\n+\n+        @Override\n+        public void endElement(String uri, String localName, String qName) {\n+            info.add(\"endElement \" + uri + \" \" + localName + \" \" + qName);\n+        }\n+\n+        @Override\n+        public void characters(char[] ch, int start, int length) {\n+            String s = new String(ch, start, length);\n+            if (s.length() > 30) {\n+                s = s.substring(0, 10) + \"...\" + s.substring(s.length() - 10);\n+            }\n+            info.add(\"characters \" + s);\n+        }\n+\n+        @Override\n+        public void ignorableWhitespace(char[] ch, int start, int length) {\n+            String s = new String(ch, start, length);\n+            if (s.length() > 30) {\n+                s = s.substring(0, 10) + \"...\" + s.substring(s.length() - 10);\n+            }\n+            info.add(\"ignorableWhitespace '\" + s + \"' (\" + length + \")\");\n+        }\n+\n+        @Override\n+        public void processingInstruction(String target, String data) {\n+            info.add(\"processingInstruction \" + target + \" \" + data);\n+        }\n+\n+        @Override\n+        public void skippedEntity(String name) {\n+            info.add(\"skippedEntity \" + name);\n+        }\n+    }\n+\n+}\n","filename":"test\/daisydiff\/src\/DaisyDiffViewer.java","additions":393,"deletions":0,"binary":false,"changes":393,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+#\n+# Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+JUnitTests.files := $(shell find $(TESTDIR)\/junit -type f -name \\*.java)\n+\n+JUnitTest.add-exports =  \\\n+\t\t--add-modules jdk.jdeps \\\n+\t\t--add-exports jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED \\\n+\t\t--add-exports jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED \\\n+\t\t--add-exports jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED\n+\n+JUnitTest.classpath = \\\n+\t\t$(BUILDTESTDIR)\/JUnitTests\/classes:$(APIDIFF_IMAGEDIR)\/lib\/apidiff.jar:$(JAVADIFFUTILS_JAR):$(DAISYDIFF_JAR):$(HTMLCLEANER_JAR)\n+\n+$(BUILDTESTDIR)\/JUnitTests.ok: \\\n+\t\t$(BUILDTESTDIR)\/JUnitTests.classes.ok\n+\t$(RM) $(@:%.ok=%\/work) $(@:%.ok=%\/report)\n+\t$(MKDIR) -p $(@:%.ok=%\/work) $(@:%.ok=%\/report)\n+\tcd $(@:%.ok=%\/work) ; \\\n+\tset -o pipefail ; \\\n+\t$(JAVA) \\\n+\t\t$(JUnitTest.add-exports) \\\n+\t\t-jar $(JUNIT_JAR) \\\n+\t\t-classpath $(JUnitTest.classpath) \\\n+\t\t\t--reports-dir=$(@:%.ok=%\/report) \\\n+\t\t\t--select-package=apitest \\\n+\t\t\t2>&1 | tee $(@:%.ok=%\/log)\n+\techo $@ passed at `date` > $@\n+\n+$(BUILDTESTDIR)\/JUnitTests.classes.ok: \\\n+\t\t$(JUnitTests.files) \\\n+\t\t$(APIDIFF_IMAGEDIR)\/lib\/apidiff.jar \\\n+\t\t$(JUNIT_JAR)\n+\t$(JAVAC) \\\n+\t\t-d $(BUILDTESTDIR)\/JUnitTests\/classes \\\n+\t\t--class-path $(JUNIT_JAR):$(JUnitTest.classpath) \\\n+\t\t$(JUnitTest.add-exports) \\\n+\t\t$(JUnitTests.files)\n+\techo $@ compiled at `date` > $@\n+\n+# ignore exit code from $(TIDY) until we resolve the duplicate-id problem\n+$(BUILDTESTDIR)\/JUnitTests.tidy.ok:\n+\t-$(TIDY) -q -e --gnu-emacs true `$(FIND) $(@:%.tidy.ok=%\/work) -name \\*.html`\n+\techo files checked by tidy at `date` > $@\n+\n+TESTS += \\\n+\t$(BUILDTESTDIR)\/JUnitTests.ok \\\n+\t$(BUILDTESTDIR)\/JUnitTests.tidy.ok\n","filename":"test\/junit\/JUnitTests.gmk","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,448 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.function.BiConsumer;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import jdk.codetools.apidiff.Log;\n+import jdk.codetools.apidiff.model.APIDocs;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import apitest.lib.APITester;\n+import toolbox.JavadocTask;\n+import toolbox.ModuleBuilder;\n+import toolbox.Task;\n+\n+\/**\n+ * A test for the ability to extract documentation from API documentation\n+ * generated by <i>javadoc<\/i>.\n+ *\/\n+\/\/ TODO: either here or in a JUnit-free class, we could have a main program\n+\/\/       that reads a file, and prints out the resulting APIDocs in a stylized\n+\/\/       HTML format, that makes it easy to see the text that is extracted.\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class APIReaderTest extends APITester {\n+    private Log log;\n+    private Path api;\n+\n+    \/**\n+     * Generates sample API documentation from sample API.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @BeforeAll\n+    public void generateAPIDocs() throws IOException {\n+        Path base = getScratchDir();\n+        super.log.println(base);\n+\n+        Path src = base.resolve(\"src\");\n+        generateSampleAPI(src);\n+\n+        \/\/ Run javadoc on sample API\n+        api = Files.createDirectories(base.resolve(\"api\"));\n+        Task.Result r = new JavadocTask(tb)\n+                .sourcepath(src.resolve(\"mA\"))\n+                .outdir(api)\n+                .options(\"-noindex\", \"-quiet\", \"--module\", \"mA\")\n+                .run();\n+        r.writeAll();\n+\n+        PrintWriter out = new PrintWriter(System.out) {\n+            @Override\n+            public void close() {\n+                flush();\n+            }\n+        };\n+        PrintWriter err = new PrintWriter(System.err, true){\n+            @Override\n+            public void close() {\n+                flush();\n+            }\n+        };\n+\n+        log = new Log(out, err);\n+    }\n+\n+    \/**\n+     * Flushes any output that has been written to the log streams.\n+     *\/\n+    @AfterEach\n+    public void flushLog() {\n+        log.out.flush();\n+        log.err.flush();\n+    }\n+\n+    void generateSampleAPI(Path dir) throws IOException {\n+        new ModuleBuilder(tb, \"mA\")\n+                .comment(\"This is module mA. This is more text for mA.\\n@see \\\"See Text\\\"\")\n+                .exports(\"p\")\n+                .classes(\"\/** This is package p. This is more text for p.\\n@see \\\"See Text\\\" *\/ package p;\")\n+                .classes(\"\"\"\n+                        package p;\n+                        \/**\n+                         * This is anno-type A. This is more text for A.\n+                         * @see \"See Text\"\n+                         *\/\n+                        public @interface A {\n+                            \/**\n+                             * This is required element r1. This is more text for r1.\n+                             * @return dummy.\n+                             * @see \"See Text\"\n+                             *\/\n+                            int r1();\n+                            \/**\n+                             * This is required element r2. This is more text for r2.\n+                             * @return dummy.\n+                             * @see \"See Text\"\n+                             *\/\n+                            int r2();\n+                            \/**\n+                             * This is optional element o1. This is more text for o1.\n+                             * @return dummy.\n+                             * @see \"See Text\"\n+                             *\/\n+                            int o1() default 0;\n+                            \/**\n+                             * This is optional element o2. This is more text for o2.\n+                             * @return dummy.\n+                             * @see \"See Text\"\n+                             *\/\n+                            int o2() default 0;\n+                        }\"\"\")\n+                .classes(\"\"\"\n+                        package p;\n+                        \/**\n+                         * This is enum E; This is more text for E.\n+                         * @see \"See Text\"\n+                         *\/\n+                        public enum E {\n+                            \/**\n+                             * This is enum constant E1. This is more text for E1.\n+                             * @see \"See Text\"\n+                             *\/\n+                            E1,\n+                            \/**\n+                             * This is enum constant E2. This is more text for E2.\n+                             * @see \"See Text\"\n+                             *\/\n+                            E2;\n+                            \/**\n+                             * This is field f1. This is more text for f1.\n+                             * @see \"See Text\"\n+                             *\/\n+                            public int f1;\n+                            \/**\n+                             * This is field f2. This is more text for f2.\n+                             * @see \"See Text\"\n+                             *\/\n+                            public int f2;\n+                            \/**\n+                             * This is method m1. This is more text for m1.\n+                             * @see \"See Text\"\n+                             *\/\n+                            public void m1() { }\n+                            \/**\n+                             * This is method m2. This is more text for m2.\n+                             * @see \"See Text\"\n+                             *\/\n+                            public void m2() { }\n+                            \/**\n+                             * This is nested class N. This is more test for N.\n+                             * @see \"See Text\"\n+                             *\/\n+                            public class N {\n+                                \/**\n+                                 * This is field f1 in nested class N.\n+                                 *\/\n+                                public int f1;\n+                            }\n+                        }\"\"\")\n+                .classes(\"\"\"\n+                        package p;\n+                        \/**\n+                         * This is class C; This is more text for C.\n+                         * @see \"See Text\"\n+                         *\/\n+                        public class C {\n+                            \/**\n+                             * This is field f1. This is more text for f1.\n+                             * @see \"See Text\"\n+                             *\/\n+                            public int f1;\n+                            \/**\n+                             * This is field f2. This is more text for f2.\n+                             * @see \"See Text\"\n+                             *\/\n+                            public int f2;\n+                            \/**\n+                             * This is the no-args constructor. This is more text for the no-args constructor.\n+                             * @see \"See Text\"\n+                             *\/\n+                            public C() { }\n+                            \/**\n+                             * This is the 1-arg constructor. This is more text for the 1-arg constructor.\n+                             * @param i the arg\n+                             * @see \"See Text\"\n+                             *\/\n+                            public C(int i) { }\n+                            \/**\n+                             * This is method m1. This is more text for m1.\n+                             * @see \"See Text\"\n+                             *\/\n+                            public void m1() { }\n+                            \/**\n+                             * This is method m2. This is more text for m2.\n+                             * @see \"See Text\"\n+                             *\/\n+                            public void m2() { }\n+                            \/**\n+                             * This is nested class N. This is more test for N.\n+                             * @see \"See Text\"\n+                             *\/\n+                            public class N {\n+                                \/**\n+                                 * This is field f1 in nested class N.\n+                                *\/\n+                                public int f1;\n+                            }\n+                        }\"\"\")\n+                .classes(\"\"\"\n+                        package p;\n+                        \/**\n+                         * This is interface I; This is more text for I.\n+                         * @see \"See Text\"\n+                         *\/\n+                        public interface I {\n+                            \/**\n+                             * This is field f1. This is more text for f1.\n+                             * @see \"See Text\"\n+                             *\/\n+                            static final int f1 = 0;\n+                            \/**\n+                             * This is field f2. This is more text for f2.\n+                             * @see \"See Text\"\n+                             *\/\n+                            static final int f2 = 0;\n+                            \/**\n+                             * This is method m1. This is more text for m1.\n+                             * @see \"See Text\"\n+                             *\/\n+                            void m1();\n+                            \/**\n+                             * This is method m2. This is more text for m2.\n+                             * @see \"See Text\"\n+                             *\/\n+                            void m2();\n+                            \/**\n+                             * This is nested class N. This is more test for N.\n+                             * @see \"See Text\"\n+                             *\/\n+                            public class N {\n+                                \/**\n+                                 * This is field f1 in nested class N.\n+                                 *\/\n+                                 public int f1;\n+                            }\n+                        }\"\"\")\n+                .write(dir);\n+    }\n+\n+    \/**\n+     * Find all the files that are in the <i>api<\/i> directory.\n+     *\n+     * @return the files\n+     * @see #checkFile(Path)\n+     *\/\n+    public Stream<Arguments> findFiles() {\n+        List<Object[]> files = new ArrayList<>();\n+        try {\n+            walkFileTree(api, log, (log, file) -> files.add(new Object[] { file }));\n+        } catch (IOException e) {\n+            Assertions.fail(\"problem finding files\", e);\n+        }\n+        return files.stream().map(Arguments::of);\n+    }\n+\n+    private static void walkFileTree(Path dir, Log log, BiConsumer<Log, Path> f) throws IOException {\n+        Pattern p = Pattern.compile(\"(module-summary|package-summary|[A-Z].*)\\\\.html\");\n+        Files.walkFileTree(dir, new SimpleFileVisitor<>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n+                if (p.matcher(file.getFileName().toString()).matches()) {\n+                    System.err.println(\"file: \" + file);\n+                    f.accept(log, file);\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+\n+            @Override\n+            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n+                System.err.println(\"dir: \" + dir);\n+                return switch (dir.getFileName().toString()) {\n+                    case \"jquery\", \"resources\" -> FileVisitResult.SKIP_SUBTREE;\n+                    default -> FileVisitResult.CONTINUE;\n+                };\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Tests the content of a file.\n+     *\n+     * @param file the file\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"findFiles\")\n+    public void checkFile(Path file) {\n+        \/\/ TestNG oddity: the test works as expecting when using the following call,\n+        \/\/ but not if the next 5 source lines are removed, causing the body of the\n+        \/\/ method to be executed directly; in that case, the test is only executed\n+        \/\/ once, for the first file, with no indication of why other data values\n+        \/\/ are not used.\n+        checkFile(log, file);\n+    }\n+\n+    \/\/ TODO: add more checks for content of members\n+    private void checkFile(Log log, Path file) {\n+        APIDocs docs = APIDocs.read(log, file);\n+        showDocs(log, file, docs);\n+\n+        switch (file.getFileName().toString()) {\n+            case \"module-summary.html\" -> {\n+                checkDescription(docs.getDescription(), \"module-description\", null, \"This is module m[A-Z]. This is more\");\n+                checkMemberDescriptions(docs.getMemberDescriptions());\n+            }\n+\n+            case \"package-summary.html\" -> {\n+                checkDescription(docs.getDescription(), \"package-description\", null, \"This is package p. This is more\");\n+                checkMemberDescriptions(docs.getMemberDescriptions());\n+            }\n+\n+            case \"A.html\" -> {\n+                checkDescription(docs.getDescription(), null, null, \"This is anno-type A. This is more\");\n+                checkMemberDescriptions(docs.getMemberDescriptions(), \"r1()\", \"r2()\", \"o1()\", \"o2()\");\n+            }\n+\n+            case \"C.html\" -> {\n+                checkDescription(docs.getDescription(), null, null, \"This is class C. This is more\");\n+                checkMemberDescriptions(docs.getMemberDescriptions(), \"<init>()\", \"<init>(int)\", \"f1\", \"f2\", \"m1()\", \"m2()\");\n+                checkDescription(docs.getDescription(\"<init>()\"),\n+                        \"<init>()\", \"C\", \"This is the no-args constructor. This is more\");\n+            }\n+\n+            case \"C.N.html\",\n+                 \"E.N.html\",\n+                 \"I.N.html\" -> {\n+                checkDescription(docs.getDescription(), null, null, \"This is nested class N. This is more\");\n+                checkMemberDescriptions(docs.getMemberDescriptions(), \"<init>()\", \"f1\");\n+            }\n+\n+            case \"E.html\" -> {\n+                checkDescription(docs.getDescription(), null, null, \"This is enum E. This is more\");\n+                checkMemberDescriptions(docs.getMemberDescriptions(), \"E1\", \"E2\", \"f1\", \"f2\", \"m1()\", \"m2()\", \"values()\", \"valueOf(java.lang.String)\");\n+            }\n+\n+            case \"I.html\" -> {\n+                checkDescription(docs.getDescription(), null, null, \"This is interface I. This is more\");\n+                checkMemberDescriptions(docs.getMemberDescriptions(), \"f1\", \"f2\", \"m1()\", \"m2()\");\n+            }\n+\n+            default -> Assertions.fail(file.toString());\n+        }\n+    }\n+\n+    private void checkDescription(String desc, String id, String heading, String body) {\n+        if (id != null && !desc.contains(\"id=\\\"\" + escape(id) + \"\\\"\")) {\n+            Assertions.fail(\"expected id not found: \" + id);\n+        }\n+        if (heading != null && !Pattern.compile(\"<h[34][^>]*>\\\\Q\" + heading + \"\\\\E<\/h[34]\").matcher(desc).find()) {\n+            Assertions.fail(\"expected heading not found: \" + heading);\n+        }\n+\n+        if (!Pattern.compile(body).matcher(desc).find()) {\n+            Assertions.fail(\"expected body not found: \" + body);\n+        }\n+    }\n+\n+    private void checkMemberDescriptions(Map<String, String> descriptions, String... ids) {\n+        Assertions.assertEquals(Set.of(ids), descriptions.keySet());\n+    }\n+\n+    void showFile(Log log, Path file) {\n+        APIDocs docs = APIDocs.read(log, file);\n+        log.out.println(\"File: \" + file);\n+        log.out.println(\"Description: \");\n+        printDescription(log, docs.getDescription());\n+        new TreeMap<>(docs.getMemberDescriptions()).forEach((id, d) -> {\n+            log.out.println(\"Member: \" + id);\n+            printDescription(log, docs.getDescription());\n+\n+        });\n+    }\n+\n+    void showDocs(Log log, Path file, APIDocs docs) {\n+        log.out.println(\"File: \" + file);\n+        log.out.println(\"Description: \");\n+        printDescription(log, docs.getDescription());\n+        new TreeMap<>(docs.getMemberDescriptions()).forEach((id, d) -> {\n+            log.out.println(\"Member: \" + id);\n+            printDescription(log, docs.getDescription(id));\n+        });\n+    }\n+\n+    private void printDescription(Log log, String s) {\n+        if (s == null) {\n+            log.out.println(\"<null>\");\n+        } else {\n+            s.lines().forEach(l -> log.out.println(\"| \" + l));\n+        }\n+    }\n+\n+    private String escape(String s) {\n+        return s.replace(\"&\", \"&amp;\")\n+                .replace(\"<\", \"&lt;\")\n+                .replace(\">\", \"&gt;\");\n+    }\n+}\n","filename":"test\/junit\/apitest\/APIReaderTest.java","additions":448,"deletions":0,"binary":false,"changes":448,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+\n+public class AddRemoveElementTest extends APITester {\n+\n+    @Test\n+    public void testAddDecls() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        Path src = base.resolve(\"src\");\n+        List<String> options = new ArrayList<>();\n+        int apiCount = 3;\n+        generateAPI(src, apiCount);\n+\n+        for (int a = 0; a < apiCount; a++) {\n+            options.addAll(List.of(\n+                    \"--api\", \"api\" + a,\n+                    \"--module-source-path\", src.resolve(\"api\" + a).toString()));\n+        }\n+        for (int a = 0; a < apiCount; a++) {\n+            String moduleName = \"m\" + a;\n+            options.addAll(List.of(\"--include\", moduleName + \"\/**\"));\n+        }\n+        options.addAll(List.of(\"-d\", base.resolve(\"out\").toString()));\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+        outMap.forEach((k, s) -> {\n+            log.println(\"[\" + k + \"]\");\n+            log.println(s);\n+        });\n+    }\n+\n+    void generateAPI(Path base, int count) throws IOException {\n+        for (int a = 0; a < count ; a++) {\n+            Path apiDir = Files.createDirectories(base.resolve(\"api\" + a));\n+            for (int m = a; m < count; m++) {\n+                String moduleName = \"m\" + m;\n+                Path moduleDir = Files.createDirectories(apiDir.resolve(moduleName));\n+                StringBuilder moduleSrc = new StringBuilder();\n+                moduleSrc.append(\"module m\").append(m).append(\" {\\n\");\n+                for (int p = m; p < count; p++) {\n+                    moduleSrc.append(\"  exports p\").append(p).append(\";\\n\");\n+                    Path packageDir = Files.createDirectories(moduleDir.resolve(\"p\" + p));\n+                    for (int t = p; t < count; t++) {\n+                        StringBuilder typeSrc = new StringBuilder();\n+                        typeSrc.append(\"package p\").append(p).append(\";\\n\")\n+                                .append(\"public class C\" + t + \" {\\n\");\n+                        for (int f = t; f < count; f++) {\n+                            typeSrc.append(\"    public int f\" + f + \";\\n\");\n+                        }\n+                        typeSrc.append(\"}\\n\");\n+                        Files.writeString(packageDir.resolve(\"C\" + t +\".java\"), typeSrc);\n+                    }\n+                }\n+                moduleSrc.append(\"}\\n\");\n+                Files.writeString(moduleDir.resolve(\"module-info.java\"), moduleSrc);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/junit\/apitest\/AddRemoveElementTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import apitest.lib.APITester;\n+import toolbox.ModuleBuilder;\n+\n+\/**\n+ * Tests for the ability to compare annotations.\n+ *\/\n+public class AnnoTest extends APITester {\n+\n+    \/**\n+     * Tests different default values.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testDefaultValues() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testAnnos(base, i -> {\n+            String dv = (i == 0) ? \"\" : \" default 1\";\n+            return \"int v()\" + dv + \";\";\n+        });\n+    }\n+\n+    private void testAnnos(Path base, Function<Integer,String> f) throws IOException {\n+        List<String> options = new ArrayList<>();\n+\n+        for (int i = 0; i < 2; i++) {\n+            String apiName = \"api\" + i;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            String mods = (i == 0) ? \"public\" : \"protected\";\n+            Path p = new ModuleBuilder(tb, \"mA\")\n+                    .exports(\"p\")\n+                    .classes(\"package p; public @interface Anno {\\n\" + f.apply(i) + \"\\n}\\n\")\n+                    .write(apiDir);\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    public static Stream<Arguments> provideOptions() {\n+        return Stream.of(\n+                Arguments.of(null, false),\n+                Arguments.of(\"public\", false),\n+                Arguments.of(\"protected\", false),\n+                Arguments.of(\"package\", true),\n+                Arguments.of(\"private\", true)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideOptions\")\n+    public void testDocumentedMix(String accessKind, boolean expectNotDoc) throws IOException {\n+        String name = (accessKind == null) ? \"none\" : accessKind;\n+        Path base = getScratchDir(name);\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        for (int i = 0; i < 2; i++) {\n+            String apiName = \"api\" + i;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            String mods = (i == 0) ? \"public\" : \"protected\";\n+            Path p = new ModuleBuilder(tb, \"mA\")\n+                    .exports(\"p\")\n+                    .classes(\"package p; import java.lang.annotation.*; public @Documented @interface Doc    { }\\n\")\n+                    .classes(\"package p; public @interface NotDoc { }\\n\")\n+                    .classes(\"package p; public @Doc @NotDoc class  C { }\\n\")\n+                    .write(apiDir);\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+\n+        if (accessKind != null) {\n+            options.addAll(List.of(\"--access\", accessKind));\n+        }\n+\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+\n+        String c_html = Files.readString(base.resolve(\"out\").resolve(\"mA\").resolve(\"p\").resolve(\"C.html\"));\n+        checkContains(c_html, \"<span class=\\\"annotation\\\">@Doc<\/span>\", true);\n+        checkContains(c_html, \"<span class=\\\"annotation\\\">@NotDoc<\/span>\", expectNotDoc);\n+    }\n+\n+    private void checkContains(String full, String s, boolean expect) {\n+        if (full.contains(s)) {\n+            if (!expect) {\n+                throw new AssertionError(\"string found unexpectedly\");\n+            }\n+        } else {\n+            if (expect) {\n+                throw new AssertionError(\"expected string not found\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/junit\/apitest\/AnnoTest.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.codetools.apidiff.Options.Option;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+public class CheckManPage {\n+    @Test\n+    public void checkManPage() throws Exception {\n+        Path base = findBaseDir();\n+        Path manPage = base.resolve(\"src\/share\/doc\/apidiff.md\".replace(\"\/\", File.separator));\n+        if (!Files.exists(manPage)) {\n+            throw new  Error(\"man page not found: \" + manPage);\n+        }\n+\n+        Set<String> documented = new TreeSet<>();\n+        Pattern p = Pattern.compile(\"<[a-z]+[^>]* id=\\\"option-([a-z0-9-]+)\\\"\");\n+        for (String line : Files.readAllLines(manPage)) {\n+            Matcher m = p.matcher(line);\n+            while (m.find()) {\n+                documented.add(m.group(1));\n+            }\n+        }\n+        System.err.println(\"documented: \" + documented);\n+\n+        Set<String> declared = Stream.of(Option.values())\n+                .map(o -> o.getNames().get(0).replaceFirst(\"^-+\", \"\"))\n+                .collect(Collectors.toCollection(TreeSet::new));\n+        declared.add(\"at\"); \/\/ special case for @file\n+        System.err.println(\"declared: \" + declared);\n+\n+        if (!documented.equals(declared)) {\n+            Set<String> s1 = new TreeSet<>(declared);\n+            s1.removeAll(documented);\n+            if (!s1.isEmpty()) {\n+                System.err.println(\"declared but not documented:\");\n+                s1.stream().forEach(s -> System.err.println(\"  \" + s));\n+            }\n+            Set<String> s2 = new TreeSet<>(documented);\n+            s2.removeAll(declared);\n+            if (!s2.isEmpty()) {\n+                System.err.println(\"documented but not declared:\");\n+                s2.stream().forEach(s -> System.err.println(\"  \" + s));\n+            }\n+            Assertions.fail(\"discrepancies found\");\n+        }\n+    }\n+\n+    private Path findBaseDir() {\n+        Path d = Path.of(\".\").toAbsolutePath().normalize();\n+        while (d != null) {\n+            if (Files.isDirectory(d.resolve(\"src\"))) {\n+                return d;\n+            }\n+            d = d.getParent();\n+        }\n+        throw new Error(\"can't find base directory\");\n+    }\n+}\n","filename":"test\/junit\/apitest\/CheckManPage.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,297 @@\n+\/*\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.ResourceBundle;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardLocation;\n+import javax.tools.ToolProvider;\n+\n+import com.sun.tools.classfile.ClassFile;\n+import com.sun.tools.classfile.ConstantPool;\n+import com.sun.tools.classfile.ConstantPoolException;\n+\n+import jdk.codetools.apidiff.Main;\n+import jdk.codetools.apidiff.Main.Result;\n+import jdk.codetools.apidiff.report.html.HtmlReporter;\n+\n+import org.junit.jupiter.api.Test;\n+\n+\/**\n+ * Compare string constants in apidiff classes against keys in apidiff resource bundles.\n+ *\/\n+public class CheckResourceKeys {\n+    \/**\n+     * Main program.\n+     * Options:\n+     * --find-unused-keys\n+     *      look for keys in resource bundles that are no longer required\n+     * --find-missing-keys\n+     *      look for keys in resource bundles that are missing\n+     *\n+     * @param args commnd-line arguments\n+     * @throws Exception if invoked by jtreg and errors occur\n+     *\/\n+    public static void main(String... args) throws Exception {\n+        CheckResourceKeys c = new CheckResourceKeys();\n+        if (!c.run(args)) {\n+            System.exit(1);\n+        }\n+    }\n+\n+    private PrintStream log = System.out;\n+\n+    \/**\n+     * Main entry point.\n+     *\/\n+    boolean run(String... args) throws Exception {\n+        boolean findUnusedKeys = false;\n+        boolean findMissingKeys = false;\n+\n+        if (args.length == 0) {\n+            System.err.println(\"Usage: java CheckResourceKeys <options>\");\n+            System.err.println(\"where options include\");\n+            System.err.println(\"  --find-unused-keys    find keys in resource bundles which are no longer required\");\n+            System.err.println(\"  --find-missing-keys   find keys in resource bundles that are required but missing\");\n+            return true;\n+        } else {\n+            for (String arg: args) {\n+                if (arg.equalsIgnoreCase(\"--find-unused-keys\"))\n+                    findUnusedKeys = true;\n+                else if (arg.equalsIgnoreCase(\"--find-missing-keys\"))\n+                    findMissingKeys = true;\n+                else\n+                    error(\"bad option: \" + arg);\n+            }\n+        }\n+\n+        if (errors > 0)\n+            return false;\n+\n+        Set<String> codeKeys = getCodeKeys();\n+        Set<String> resourceKeys = getResourceKeys();\n+\n+        System.err.println(\"found \" + codeKeys.size() + \" keys in code\");\n+        System.err.println(\"found \" + resourceKeys.size() + \" keys in resource bundles\");\n+\n+        if (findUnusedKeys)\n+            findUnusedKeys(codeKeys, resourceKeys);\n+\n+        if (findMissingKeys)\n+            findMissingKeys(codeKeys, resourceKeys);\n+\n+        usageTests();\n+\n+        return (errors == 0);\n+    }\n+\n+    @Test\n+    public void checkResourceKeys() throws Exception {\n+        boolean ok = run(\"--find-unused-keys\", \"--find-missing-keys\");\n+        if (!ok) {\n+            throw new Exception(\"Check failed\");\n+        }\n+    }\n+\n+    void usageTests() {\n+        String[] argarray = { \"--help\" };\n+        StringWriter sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw);\n+        if (new Main(pw, pw).run(\"--help\") == Result.OK) {\n+            pw.flush();\n+            String s = sw.toString();\n+            if (s.isEmpty()) {\n+                error(\"no output from apidiff\");\n+                return;\n+            }\n+            if (sw.toString().contains(\"WARNING: missing resource\")) {\n+                log.println(s);\n+                error(\"missing resources in output ?\");\n+            }\n+        } else {\n+            error(\"failed to execute apidiff\");\n+        }\n+    }\n+\n+    \/**\n+     * Find keys in resource bundles which are probably no longer required.\n+     * A key is required if there is a string in the code that is a resource key,\n+     * or if the key is well-known according to various pragmatic rules.\n+     *\/\n+    void findUnusedKeys(Set<String> codeKeys, Set<String> resourceKeys) {\n+        for (String rk: resourceKeys) {\n+            \/\/ ignore these synthesized keys, tested by usageTests\n+            if (rk.startsWith(\"apidiff.usage.\"))\n+                continue;\n+            \/\/ ignore these synthesized keys, tested by usageTests\n+            if (rk.matches(\"opt\\\\.(arg|desc)\\\\.[-a-z]+\"))\n+                continue;\n+            if (codeKeys.contains(rk))\n+                continue;\n+\n+            error(\"Resource key not found in code: '\" + rk + '\"');\n+        }\n+    }\n+\n+    \/**\n+     * For all strings in the code that look like they might be\n+     * a resource key, verify that a key exists.\n+     *\/\n+    void findMissingKeys(Set<String> codeKeys, Set<String> resourceKeys) {\n+        for (String ck: codeKeys) {\n+            \/\/ ignore keys that are defined in a resource file\n+            if (resourceKeys.contains(ck))\n+                continue;\n+            error(\"No resource for \\\"\" + ck + \"\\\"\");\n+        }\n+    }\n+\n+    \/**\n+     * Get the set of strings from the apidiff classfiles.\n+     *\/\n+    Set<String> getCodeKeys() throws IOException {\n+        Set<String> results = new TreeSet<>();\n+        JavaCompiler c = ToolProvider.getSystemJavaCompiler();\n+        try (JavaFileManager fm = c.getStandardFileManager(null, null, null)) {\n+            List<String> pkgs = List.of(\"jdk.codetools.apidiff\");\n+            for (String pkg: pkgs) {\n+                for (JavaFileObject fo: fm.list(StandardLocation.CLASS_PATH,\n+                        pkg, EnumSet.of(JavaFileObject.Kind.CLASS), true)) {\n+                    String name = fo.getName();\n+                    \/\/ ignore resource files\n+                    if (name.matches(\".*resources.[A-Za-z_0-9]+\\\\.class.*\"))\n+                        continue;\n+                    scan(fo, results);\n+                }\n+            }\n+        }\n+\n+        return results;\n+    }\n+\n+    \/\/ depending on how the test is run, javadoc may be on bootclasspath or classpath\n+    JavaFileManager.Location findJavadocLocation(JavaFileManager fm) {\n+        JavaFileManager.Location[] locns =\n+                { StandardLocation.PLATFORM_CLASS_PATH, StandardLocation.CLASS_PATH };\n+        try {\n+            for (JavaFileManager.Location l: locns) {\n+                JavaFileObject fo = fm.getJavaFileForInput(l,\n+                        \"jdk.javadoc.internal.tool.Main\", JavaFileObject.Kind.CLASS);\n+                if (fo != null) {\n+                    System.err.println(\"found javadoc in \" + l);\n+                    return l;\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new Error(e);\n+        }\n+        throw new IllegalStateException(\"Cannot find javadoc\");\n+    }\n+\n+    \/**\n+     * Get the set of strings from a class file.\n+     * Only strings that look like they might be a resource key are returned.\n+     *\/\n+    void scan(JavaFileObject fo, Set<String> results) throws IOException {\n+        \/\/System.err.println(\"scan \" + fo.getName());\n+        try (InputStream in = fo.openInputStream()) {\n+            ClassFile cf = ClassFile.read(in);\n+            for (ConstantPool.CPInfo cpinfo : cf.constant_pool.entries()) {\n+                if (cpinfo.getTag() == ConstantPool.CONSTANT_Utf8) {\n+                    String v = ((ConstantPool.CONSTANT_Utf8_info) cpinfo).value;\n+                    \/\/ ignore SourceFile attribute values\n+                    if (v.matches(\"[A-Za-z][A-Za-z0-9-]*\\\\.java\")) {\n+                        continue;\n+                    }\n+                    \/\/ ignore system names\n+                    if (v.matches(\"(java|jdk)\\\\..*\")) {\n+                        continue;\n+                    }\n+                    \/\/ ignore standard javadoc file names\n+                    if (v.matches(\"((module|package)-summary|serialized-form)\\\\.html\")) {\n+                        continue;\n+                    }\n+                    \/\/ ignore standard javadoc CSS class names\n+                    if (v.matches(\"(module|package).description\")) {\n+                        continue;\n+                    }\n+                    \/\/ ignore standard apidiff file names\n+                    if (v.equals(\"index.html\") || v.equals(HtmlReporter.DEFAULT_STYLESHEET)) {\n+                        continue;\n+                    }\n+                    \/\/  ignore names used by --jdk-build\n+                    if (v.equals(\"apidiff.tmp\") || v.equals(\"src.zip\")|| v.equals(\"spec.gmk\")) {\n+                        continue;\n+                    }\n+                    \/\/ ignore debug options\n+                    if (v.startsWith(\"debug.\")) {\n+                        continue;\n+                    }\n+                    if (v.matches(\"[A-Za-z][A-Za-z0-9-]+\\\\.[A-Za-z0-9-_@.]+\"))\n+                        results.add(v);\n+                }\n+            }\n+        } catch (ConstantPoolException ignore) {\n+        }\n+    }\n+\n+    \/**\n+     * Get the set of keys from the apidiff resource bundles.\n+     *\/\n+    Set<String> getResourceKeys() {\n+        String[] names = {\n+                \"jdk.codetools.apidiff.resources.help\",\n+                \"jdk.codetools.apidiff.resources.log\",\n+                \"jdk.codetools.apidiff.report.html.resources.report\"\n+        };\n+        Set<String> results = new TreeSet<>();\n+        for (String name : names) {\n+            ResourceBundle b = ResourceBundle.getBundle(name);\n+            results.addAll(b.keySet());\n+        }\n+        return results;\n+    }\n+\n+    \/**\n+     * Report an error.\n+     *\/\n+    void error(String msg) {\n+        System.err.println(\"Error: \" + msg);\n+        errors++;\n+    }\n+\n+    int errors;\n+}\n","filename":"test\/junit\/apitest\/CheckResourceKeys.java","additions":297,"deletions":0,"binary":false,"changes":297,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+import toolbox.JavadocTask;\n+import toolbox.Task;\n+\n+public class CompareOptionsTest extends APITester {\n+    @Test\n+    public void testCompareAPIDescriptions() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        Path outDir = run(base, \"--compare-api-descriptions=true\");\n+        checkOutput(outDir.resolve(\"p\/C.html\"),\n+                \"abc. <span class=\\\"diff-html-removed\\\">BEFORE<\/span><span class=\\\"diff-html-added\\\">AFTER<\/span>. def.\");\n+    }\n+\n+    @Test\n+    public void testCompareAPIDescriptionsAsText() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        Path outDir = run(base, \"--compare-api-descriptions-as-text=true\");\n+        checkOutput(outDir.resolve(\"p\/C.html\"),\n+                \"\"\"\n+                      7 <span class=\"sdiffs-lines-changed\"> abc. <\/span><span class=\"sdiffs-chars-changed\">BEFORE<\/span><span class=\"sdiffs-lines-changed\">. def.<\/span>\n+                    \"\"\",\n+                \"\"\"\n+                      7 <span class=\"sdiffs-lines-changed\"> abc. <\/span><span class=\"sdiffs-chars-changed\">AFTER<\/span><span class=\"sdiffs-lines-changed\">. def.<\/span>\n+                    \"\"\");\n+    }\n+\n+    @Test\n+    public void testCompareDocComments() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        Path outDir = run(base, \"--compare-doc-comments=true\");\n+        checkOutput(outDir.resolve(\"p\/C.html\"),\n+                \"\"\"\n+                      2 <span class=\"sdiffs-lines-changed\"> abc. <\/span><span class=\"sdiffs-chars-changed\">BEFORE<\/span><span class=\"sdiffs-lines-changed\">. def.<\/span>\n+                    \"\"\",\n+                \"\"\"\n+                      2 <span class=\"sdiffs-lines-changed\"> abc. <\/span><span class=\"sdiffs-chars-changed\">AFTER<\/span><span class=\"sdiffs-lines-changed\">. def.<\/span>\n+                    \"\"\");\n+    }\n+\n+    Path run(Path base, String... compareOpts) throws IOException {\n+        var options = new ArrayList<String>();\n+        for (var phase : List.of(\"before\", \"after\")) {\n+            Path src = base.resolve(phase).resolve(\"src\");\n+            tb.writeJavaFiles(src,\n+                    \"\"\"\n+                        package p;\n+                        \/**\n+                         * First sentence.\n+                         * abc. #PHASE#. def.\n+                         * Tail.\n+                         *\/\n+                        public class C { }\n+                        \"\"\".replace(\"#PHASE#\", phase.toUpperCase(Locale.ROOT)));\n+\n+            Path api = base.resolve(phase).resolve(\"api\");\n+            Files.createDirectories(api);\n+            Task.Result r = new JavadocTask(tb)\n+                    .sourcepath(src)\n+                    .outdir(api)\n+                    .options(\"p\")\n+                    .run();\n+            r.writeAll();\n+\n+            options.addAll(List.of(\n+                    \"--api\", phase,\n+                    \"--source-path\", src.toString(),\n+                    \"--api-directory\", api.toString()));\n+        }\n+\n+        Path outDir = base.resolve(\"out\");\n+        options.addAll(List.of(\"--output-directory\", outDir.toString()));\n+        options.addAll(List.of(compareOpts));\n+        options.addAll(List.of(\"--include\", \"p.*\"));\n+\n+        log.println(options);\n+\n+        var outMap = run(options);\n+\n+        return outDir;\n+\n+    }\n+}\n","filename":"test\/junit\/apitest\/CompareOptionsTest.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,289 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import jdk.codetools.apidiff.Main.Result;\n+import jdk.codetools.apidiff.Options;\n+import jdk.codetools.apidiff.Options.Mode;\n+\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import apitest.lib.APITester;\n+import toolbox.JavadocTask;\n+import toolbox.ModuleBuilder;\n+import toolbox.Task;\n+\n+public class DocFilesTest extends APITester {\n+    interface DocFilesWriter {\n+        void write(Path src, int i) throws IOException;\n+    }\n+\n+    public static Stream<Arguments> getModes() {\n+        return Stream.of(\n+                Arguments.of(Mode.PACKAGE, Mode.PACKAGE),\n+                Arguments.of(Mode.MODULE, Mode.PACKAGE),\n+                \/\/ module doc-files are not supported before JDK 13, and only partially supported in JDK 13.\n+                \/\/ In JDK 13, non-HTML files are OK, HTML files cause a crash.\n+                \/\/ The tests will automatically skip as needed.\n+                Arguments.of(Mode.MODULE, Mode.MODULE)\n+        );\n+    }\n+\n+    private void requireVersion(int v, String msg) {\n+        Assumptions.assumeTrue(Runtime.version().feature() >= v, msg);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getModes\")\n+    public void testAddHtml(Mode sourceMode, Mode docFileKind) throws IOException {\n+        if (sourceMode == Mode.MODULE && docFileKind == Mode.MODULE) {\n+            requireVersion(14, \"HTML module doc files not supported in this version of JDK\");\n+        }\n+\n+        Path base = getScratchDir(sourceMode + \"-\" + docFileKind);\n+        log.println(base);\n+\n+        testDocFiles(base, sourceMode, docFileKind, (dir, i) -> {\n+            if (i > 0) {\n+                tb.writeFile(dir.resolve(\"added.html\"),\n+                        \"\"\"\n+                                <!DOCTYPE html>\n+                                <html>\n+                                <head><title>info<\/title><\/head>\n+                                <body>\n+                                First line.<br>\n+                                Last line.<br>\n+                                <\/body>\n+                                <\/html>\n+                                \"\"\");\n+            }\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getModes\")\n+    public void testChangeHtml(Mode sourceMode, Mode docFileKind) throws IOException {\n+        if (sourceMode == Mode.MODULE && docFileKind == Mode.MODULE) {\n+            requireVersion(14, \"HTML module doc files not supported in this version of JDK\");\n+        }\n+        Path base = getScratchDir(sourceMode + \"-\" + docFileKind);\n+        log.println(base);\n+\n+        testDocFiles(base, sourceMode, docFileKind, (dir, i) ->\n+            tb.writeFile(dir.resolve(\"changed.html\"),\n+                    \"<!DOCTYPE html>\\n\"\n+                            + \"<html>\\n\"\n+                            + \"<head><title>info<\/title><\/head>\\n\"\n+                            + \"<body>\\n\"\n+                            + \"First line.<br>\\n\"\n+                            + \"Before the change \" + (i == 0 ? \"old\" : \"new\") + \" after the change.<br>\\n\"\n+                            + \"Last line.<br>\\n\"\n+                            + \"<\/body>\\n\"\n+                            + \"<\/html>\\n\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getModes\")\n+    public void testAddText(Mode sourceMode, Mode docFileKind) throws IOException {\n+        if (sourceMode == Mode.MODULE && docFileKind == Mode.MODULE) {\n+            requireVersion(13, \"Module doc files not supported in this version of JDK\");\n+        }\n+        Path base = getScratchDir(sourceMode + \"-\" + docFileKind);\n+        log.println(base);\n+\n+        testDocFiles(base, sourceMode, docFileKind, (dir, i) -> {\n+            if (i > 0) {\n+                tb.writeFile(dir.resolve(\"added.txt\"),\n+                        \"\"\"\n+                                First line.\n+                                Last line.\n+                                \"\"\");\n+            }\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getModes\")\n+    public void testChangeText(Mode sourceMode, Mode docFileKind) throws IOException {\n+        if (sourceMode == Mode.MODULE && docFileKind == Mode.MODULE) {\n+            requireVersion(13, \"Module doc files not supported in this version of JDK\");\n+        }\n+        Path base = getScratchDir(sourceMode + \"-\" + docFileKind);\n+        log.println(base);\n+\n+        testDocFiles(base, sourceMode, docFileKind, (dir, i) ->\n+            tb.writeFile(dir.resolve(\"changed.txt\"),\n+                    \"First line.\\n\"\n+                            + \"Before the change \" + (i == 0 ? \"old\" : \"new\") + \" after the change.\\n\"\n+                            + \"Last line.\\n\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getModes\")\n+    public void testMulti(Mode sourceMode, Mode docFileKind) throws IOException {\n+        if (sourceMode == Mode.MODULE && docFileKind == Mode.MODULE) {\n+            requireVersion(14, \"HTML module doc files not supported in this version of JDK\");\n+        }\n+        Path base = getScratchDir(sourceMode + \"-\" + docFileKind);\n+        log.println(base);\n+\n+        testDocFiles(base, sourceMode, docFileKind, (dir, i) -> {\n+            tb.writeFile(dir.resolve(\"changed.html\"),\n+                    \"<!DOCTYPE html>\\n\"\n+                            + \"<html>\\n\"\n+                            + \"<head><title>info<\/title><\/head>\\n\"\n+                            + \"<body>\\n\"\n+                            + \"First line.<br>\\n\"\n+                            + \"Before the change \" + (i == 0 ? \"old\" : \"new\") + \" after the change.<br>\\n\"\n+                            + \"Last line.<br>\\n\"\n+                            + \"<\/body>\\n\"\n+                            + \"<\/html>\\n\");\n+\n+            tb.writeFile(dir.resolve(\"changed.txt\"),\n+                    \"First line.\\n\"\n+                            + \"Before the change \" + (i == 0 ? \"old\" : \"new\") + \" after the change.\\n\"\n+                            + \"Last line.\\n\");\n+\n+            tb.writeFile(dir.resolve(\"same.html\"),\n+                    \"\"\"\n+                            <!DOCTYPE html>\n+                            <html>\n+                            <head><title>info<\/title><\/head>\n+                            <body>\n+                            First line.<br>\n+                            Last line.<br>\n+                            <\/body>\n+                            <\/html>\n+                            \"\"\");\n+\n+            tb.writeFile(dir.resolve(\"same.txt\"),\n+                    \"\"\"\n+                            First line.\n+                            Last line.\n+                            \"\"\");\n+\n+            if (i > 0) {\n+                tb.writeFile(dir.resolve(\"added.html\"),\n+                        \"\"\"\n+                                <!DOCTYPE html>\n+                                <html>\n+                                <head><title>info<\/title><\/head>\n+                                <body>\n+                                First line.<br>\n+                                Last line.<br>\n+                                <\/body>\n+                                <\/html>\n+                                \"\"\");\n+\n+                tb.writeFile(dir.resolve(\"added.txt\"),\n+                        \"\"\"\n+                                First line.\n+                                Last line.\n+                                \"\"\");\n+            }\n+        });\n+    }\n+\n+    void testDocFiles(Path base, Options.Mode sourceMode, Mode docFileKind, DocFilesWriter docFilesWriter) throws IOException {\n+        List<String> options = new ArrayList<>();\n+\n+        String apidiffIncludes;\n+        String apidiffSourcePathOption;\n+        switch (sourceMode) {\n+            case MODULE -> {\n+                apidiffIncludes = \"m\/**\";\n+                apidiffSourcePathOption = \"--module-source-path\";\n+            }\n+\n+            case PACKAGE -> {\n+                apidiffIncludes = \"p.**\";\n+                apidiffSourcePathOption = \"--source-path\";\n+            }\n+\n+            default -> throw new Error();\n+        }\n+\n+        for (int i = 0; i < 2; i++) {\n+            String apiName = \"api\" + i;\n+            Path src = base.resolve(apiName).resolve(\"src\");\n+            Path pkgSrc;\n+            List<String> javadocOptions = new ArrayList<>();\n+            javadocOptions.addAll(List.of(\"-noindex\", \"-quiet\"));\n+            switch (sourceMode) {\n+                case MODULE -> {\n+                    new ModuleBuilder(tb, \"m\")\n+                            .exports(\"p\")\n+                            .write(src);\n+                    pkgSrc = src.resolve(\"m\");\n+                    javadocOptions.addAll(List.of(\"--module\", \"m\"));\n+                }\n+\n+                case PACKAGE -> {\n+                    pkgSrc = src;\n+                    javadocOptions.add(\"p\");\n+                }\n+\n+                default -> throw new Error();\n+            }\n+            tb.writeJavaFiles(pkgSrc, \"package p; public class C { }\\n\");\n+            Path dfDir = ((docFileKind == Mode.MODULE) ? pkgSrc : pkgSrc.resolve(\"p\")).resolve(\"doc-files\");\n+            docFilesWriter.write(dfDir, i);\n+\n+            Path api = base.resolve(apiName).resolve(\"api\");\n+            Files.createDirectories(api);\n+            Task.Result r = new JavadocTask(tb)\n+                    .sourcepath(pkgSrc)\n+                    .outdir(api)\n+                    .options(javadocOptions)\n+                    .run();\n+            r.writeAll();\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    apidiffSourcePathOption, src.toString(),\n+                    \"--api-directory\", api.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"--include\", apidiffIncludes,\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+        Map<OutputKind,String> outMap = run(options, EnumSet.of(Result.DIFFS));\n+    }\n+}\n","filename":"test\/junit\/apitest\/DocFilesTest.java","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+import toolbox.JavadocTask;\n+import toolbox.Task;\n+\n+public class EntityTest extends APITester {\n+    @Test\n+    public void testEntities() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        Path outDir = run(base);\n+        checkOutput(outDir.resolve(\"p\/C.html\"),\n+                \"entities aacute '\\u00e1' agrave '\\u00e0' nbsp '\\u00A0' @-dec '@' at-hex '@' Tail.\");\n+    }\n+\n+    Path run(Path base, String... extraOpts) throws IOException {\n+        var options = new ArrayList<String>();\n+        for (var phase : List.of(\"before\", \"after\")) {\n+            Path src = base.resolve(phase).resolve(\"src\");\n+            tb.writeJavaFiles(src,\n+                    \"\"\"\n+                        package p;\n+                        \/**\n+                         * First sentence.\n+                         * abc. #PHASE#. def.\n+                         * entities aacute '&aacute;' agrave '&agrave;' nbsp '&nbsp;' @-dec '&#64;' at-hex '&#x40;'\n+                         * Tail.\n+                         *\/\n+                        public class C { }\n+                        \"\"\".replace(\"#PHASE#\", phase.toUpperCase(Locale.ROOT)));\n+\n+            Path api = base.resolve(phase).resolve(\"api\");\n+            Files.createDirectories(api);\n+            Task.Result r = new JavadocTask(tb)\n+                    .sourcepath(src)\n+                    .outdir(api)\n+                    .options(\"-quiet\", \"p\")\n+                    .run();\n+            r.writeAll();\n+\n+            options.addAll(List.of(\n+                    \"--api\", phase,\n+                    \"--source-path\", src.toString(),\n+                    \"--api-directory\", api.toString()));\n+        }\n+\n+        Path outDir = base.resolve(\"out\");\n+        options.addAll(List.of(\"--output-directory\", outDir.toString()));\n+        options.addAll(List.of(extraOpts));\n+        options.addAll(List.of(\"--include\", \"p.*\"));\n+\n+        log.println(options);\n+\n+        var outMap = run(options);\n+\n+        return outDir;\n+\n+    }\n+}\n","filename":"test\/junit\/apitest\/EntityTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+import toolbox.ModuleBuilder;\n+\n+\/**\n+ * Tests for the ability to compare {@code enum}s.\n+ *\/\n+public class EnumTest extends APITester {\n+\n+    \/**\n+     * Tests field modifiers.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testFieldMods() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testFields(base, i -> {\n+            String mods = (i == 0) ? \"public\" : \"protected\";\n+            return mods + \" int f;\";\n+        });\n+    }\n+\n+    \/**\n+     * Tests field types.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testFieldTypes() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testFields(base, i -> (i == 0)\n+                ? \"public int f;\"\n+                : \"public float f;\"\n+\n+        );\n+    }\n+\n+    private void testFields(Path base, Function<Integer,String> f) throws IOException {\n+        List<String> options = new ArrayList<>();\n+\n+        for (int i = 0; i < 2; i++) {\n+            String apiName = \"api\" + i;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            String mods = (i == 0) ? \"public\" : \"protected\";\n+            Path p = new ModuleBuilder(tb, \"mA\")\n+                    .exports(\"p\")\n+                    .classes(\"package p; public enum E {\\n  A,  B,  C;\\n\" + f.apply(i) + \"\\n}\\n\")\n+                    .write(apiDir);\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+}\n","filename":"test\/junit\/apitest\/EnumTest.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+import toolbox.ModuleBuilder;\n+\n+\/**\n+ * Tests for the ability to compare fields.\n+ *\/\n+public class FieldTest extends APITester {\n+\n+    \/**\n+     * Tests equal fields.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testSame() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testFields(base, i -> \"public int f;\" );\n+    }\n+\n+    \/**\n+     * Tests fields with different modifiers.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testModifiers() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testFields(base, i -> {\n+            String mods = (i == 0) ? \"public\" : \"protected\";\n+            return mods + \" int f;\";\n+        });\n+    }\n+\n+    \/**\n+     * Tests fields with different types.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testType() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testFields(base, i -> (i == 0)\n+                ? \"public int f;\"\n+                : \"public float f;\"\n+        );\n+    }\n+\n+    \/**\n+     * Tests fields with different constant values.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    void testValues() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testFields(base, i ->\n+                \"public final int i = \" + i + \";\\n\"\n+                + \"public final char c = '\" + ((char)('0' + i)) + \"';\\n\"\n+                + \"public final String s = \\\"\" + i + \"\\\";\\n\"\n+                + \"public final boolean b = \" + (i == 0 ? \"false\" : \"true\") + \";\");\n+    }\n+\n+    \/**\n+     * Tests fields with annotations with different values.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    void testSimpleAnnotations() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testFields(base, i ->\n+                \"@SuppressWarnings(\\\"none\\\")\\n\"\n+                + \"@Deprecated(since=\\\"\" + i + \"\\\")\\n\"\n+                + \"public final int i;\\n\");\n+    }\n+\n+    \/**\n+     * Tests characters with \"special\" values.\n+     * It is not so much the whether differences are detected as whether values are written correctly,\n+     * and with no exception occurring on output.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    void testSpecialCharValues() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testFields(base, i ->\n+                \"public static final char c0 = 0;\"\n+                + \"public static final char cn = '\\\\n';\"\n+                + \"public static final char c31 = (char) 0x1f;\"\n+                + \"public static final char cs = ' ';\"\n+                + \"public static final char cq = '\\\\'';\"\n+                + \"public static final char cMinLS = Character.MIN_LOW_SURROGATE;\"\n+                + \"public static final char cMaxLS = Character.MAX_LOW_SURROGATE;\"\n+                + \"public static final char cMinHS = Character.MIN_HIGH_SURROGATE;\"\n+                + \"public static final char cMaxHS = Character.MAX_HIGH_SURROGATE;\");\n+    }\n+\n+    \/**\n+     * Tests fields with different doc comments.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testRawDocComments() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testFields(base, i  -> {\n+            String cs = \"\/**\\n * This is 'same'.\\n * Unchanged.\\n * More.\\n **\/\\n\";\n+            String ci = \"\/**\\n * This is 'insert'.\\n\" + (i == 1 ? \" * Inserted.\\n\" : \"\") + \" * More.\\n **\/\\n\";\n+            String cr = \"\/**\\n * This is 'remove'.\\n\" + (i == 0 ? \" * Removed.\\n\" : \"\") + \" * More.\\n **\/\\n\";\n+            String cc = \"\/**\\n * This is 'change'.\\n * API \" + i + \"\\n * More.\\n **\/\\n\";\n+            return cs + \"public int same;\\n\" +\n+                    ci + \"public int insert;\\n\" +\n+                    cr + \"public int remove;\\n\" +\n+                    cc + \"public int change;\\n\";\n+        });\n+\n+    }\n+\n+    private void testFields(Path base, Function<Integer,String> f) throws IOException {\n+        List<String> options = new ArrayList<>();\n+\n+        for (int i = 0; i < 2; i++) {\n+            String apiName = \"api\" + i;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            String mods = (i == 0) ? \"public\" : \"protected\";\n+            Path p = new ModuleBuilder(tb, \"mA\")\n+                    .exports(\"p\")\n+                    .classes(\"package p; public class C {\\n\" + f.apply(i) + \"\\n}\\n\")\n+                    .write(apiDir);\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+}\n","filename":"test\/junit\/apitest\/FieldTest.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.ObjectStreamClass;\n+import java.io.PrintWriter;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.lang.model.element.TypeElement;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+\n+import com.sun.source.util.DocTrees;\n+import com.sun.source.util.JavacTask;\n+\n+import jdk.codetools.apidiff.model.SerializedForm;\n+import jdk.codetools.apidiff.model.SerializedFormFactory;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import apitest.lib.APITester;\n+\n+public class GetSerialVersionUIDTest extends APITester {\n+\n+    ToolProvider javac = ToolProvider.findFirst(\"javac\").orElseThrow(() -> new Error(\"can't find javac\"));\n+\n+    public static Stream<Arguments> provideLocalClasses() {\n+        return Stream.of(\n+                Arguments.of(\"\", \"\"),\n+                Arguments.of(\"\", \"int i;\"),\n+                Arguments.of(\"\", \"Object o;\"),\n+                Arguments.of(\"\", \"byte[] ba;\"),\n+                Arguments.of(\"\", \"String[] sa;\"),\n+                Arguments.of(\"\", \"int i; Object o;\"),\n+                Arguments.of(\"\", \"int i; static Object o;\"),\n+                Arguments.of(\"\", \"int i; transient Object o;\"),\n+                Arguments.of(\"\", \"byte b; static int i;\"),\n+                Arguments.of(\"\", \"byte b; static int i0 = 42;\"),\n+                Arguments.of(\"\", \"byte b; static final int i1 = 42;\"),\n+                Arguments.of(\"\", \"byte b; static int i2 = Integer.parseInt(\\\"1\\\");\"),\n+                Arguments.of(\"\", \"byte b; static Object o1 = null;\"),\n+                Arguments.of(\"\", \"byte b; static final Object o2 = null;\"),\n+                Arguments.of(\"\", \"byte b1; static { System.out.println(\\\"HW\\\"); }\"),\n+                Arguments.of(\"\", \"\"\"\n+                        int i;\n+                        \/** @serialField i int an int field *\/\n+                        private static final ObjectStreamField[] serialPersistentFields = {\n+                            new ObjectStreamField(\"i\", int.class)\n+                        };\"\"\"),\n+                Arguments.of(\"\", \"int i; static final long serialVersionUID = 123;\"),\n+                Arguments.of(\"Runnable\", \"String[] sa; public void run() { }\"),\n+                Arguments.of(\"Runnable, java.util.concurrent.Callable\",\n+                        \"String[] sa; public void run() { } public Object call() { return null; }\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideLocalClasses\")\n+    public void testLocal(String interfaces, String members) throws Exception {\n+        log.printf(\"interfaces: %s; members: %s%n\", interfaces, members);\n+        Path base = getScratchDir().resolve(getDirectory(interfaces, members));\n+        log.println(base);\n+\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"package p;\\n\")\n+                .append(\"import java.io.*;\\n\")\n+                .append(\"public class C implements Serializable\");\n+        if (!interfaces.isEmpty()) {\n+            sb.append(\", \").append(interfaces);\n+        }\n+        sb.append(\" {\\n\");\n+        if (!members.isEmpty()) {\n+            Stream.of(members.split(\";\\\\s*\")).forEach(s -> sb.append(\"    \").append(s).append(\";\\n\"));\n+        }\n+        sb.append(\"}\\n\");\n+        tb.writeJavaFiles(src, sb.toString());\n+\n+        Path classes = base.resolve(\"classes\");\n+        List<String> options = new ArrayList<>();\n+        options.addAll(List.of(\"-d\", classes.toString()));\n+        Arrays.stream(tb.findJavaFiles(src)).map(Object::toString).forEach(options::add);\n+        javac.run(log, log, options.toArray(new String[0]));\n+\n+        long platformSerialVersionUID = getPlatformSerialVersionUID(classes, \"p.C\");\n+        log.println(\"platform \" + platformSerialVersionUID);\n+\n+        long sourceSerialVersionUID = getSourceSerialVersionUID(src, \"p.C\");\n+        log.println(\"source   \" + sourceSerialVersionUID);\n+\n+        long classSerialVersionUID = getClassSerialVersionUID(classes, \"p.C\");\n+        log.println(\"class    \" + classSerialVersionUID);\n+\n+        Assertions.assertEquals(platformSerialVersionUID, sourceSerialVersionUID, \"serialVersionUID from source\");\n+        Assertions.assertEquals(platformSerialVersionUID, classSerialVersionUID, \"serialVersionUID from class\");\n+    }\n+\n+    public static Stream<Arguments> provideSystemClasses() {\n+        return Stream.of(\n+                Arguments.of(\"java.lang.Exception\"),\n+                Arguments.of(\"java.io.IOException\"),\n+                Arguments.of(\"java.awt.Component\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideSystemClasses\")\n+    public void testSystemClass(String name) throws Exception {\n+        log.println(name);\n+\n+        Path base = getScratchDir();\n+        Path classes = Files.createDirectories(base.resolve(\"classes\"));\n+\n+        long platformSerialVersionUID = getPlatformSerialVersionUID(classes, name);\n+        log.println(\"platform \" + platformSerialVersionUID);\n+\n+        long classSerialVersionUID = getClassSerialVersionUID(classes, name);\n+        log.println(\"class    \" + classSerialVersionUID);\n+\n+        Assertions.assertEquals(platformSerialVersionUID, classSerialVersionUID, \"serialVersionUID from class\");\n+    }\n+\n+    Path getDirectory(String interfaces, String members) {\n+        String i = Stream.of(interfaces.split(\"\\\\s+\"))\n+                .map(s -> s.substring(s.lastIndexOf(\".\") + 1))\n+                .collect(Collectors.joining(\"-\"));\n+        String m = Stream.of(members.split(\";\\\\s*\"))\n+                .map(s -> s.replaceAll(\"=.*\", \"\"))\n+                .map(s -> s.substring(s.lastIndexOf(\" \") + 1))\n+                .collect(Collectors.joining(\"-\"));\n+        String sep = i.isEmpty() || m.isEmpty() ? \"\" : \"-\";\n+        return Path.of(i + sep + m);\n+    }\n+\n+    long getPlatformSerialVersionUID(Path classes, String name) throws Exception {\n+        URLClassLoader cl = new URLClassLoader(new URL[] { classes.toUri().toURL()});\n+        Class<?> c = cl.loadClass(name);\n+        ObjectStreamClass osc = ObjectStreamClass.lookup(c);\n+        return osc.getSerialVersionUID();\n+    }\n+\n+    long getSourceSerialVersionUID(Path src, String name) throws Exception {\n+        JavaCompiler javac = javax.tools.ToolProvider.getSystemJavaCompiler();\n+        List<String> options = List.of(\"-proc:only\", \"--source-path\", src.toString());\n+        List<String> classes = List.of(name);\n+        List<JavaFileObject> files = List.of();\n+        PrintWriter out = new PrintWriter(log, true);\n+        JavacTask task = (JavacTask) javac.getTask(out, null, null, options, classes, files);\n+        task.analyze();\n+        SerializedFormFactory sff = getSerializedFormFactory(task);\n+        TypeElement te = task.getElements().getTypeElement(name);\n+        SerializedForm sf = sff.get(te);\n+        return sf.getSerialVersionUID();\n+    }\n+\n+    long getClassSerialVersionUID(Path classes, String name) throws Exception {\n+        JavaCompiler javac = javax.tools.ToolProvider.getSystemJavaCompiler();\n+        List<String> options = List.of(\"-proc:only\", \"--class-path\", classes.toString());\n+        List<String> classes2 = List.of(name);\n+        List<JavaFileObject> files = List.of();\n+        PrintWriter out = new PrintWriter(log, true);\n+        JavacTask task = (JavacTask) javac.getTask(out, null, null, options, classes2, files);\n+        task.analyze();\n+        SerializedFormFactory sff = getSerializedFormFactory(task);\n+        TypeElement te = task.getElements().getTypeElement(name);\n+        SerializedForm sf = sff.get(te);\n+        return sf.getSerialVersionUID();\n+    }\n+\n+    private SerializedFormFactory getSerializedFormFactory(JavacTask task) {\n+        return new SerializedFormFactory(task.getElements(), task.getTypes(), DocTrees.instance(task));\n+    }\n+}\n","filename":"test\/junit\/apitest\/GetSerialVersionUIDTest.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,309 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import jdk.codetools.apidiff.Log;\n+import jdk.codetools.apidiff.Messages;\n+import jdk.codetools.apidiff.html.Content;\n+import jdk.codetools.apidiff.html.HtmlTree;\n+import jdk.codetools.apidiff.html.TagName;\n+import jdk.codetools.apidiff.html.Text;\n+import jdk.codetools.apidiff.model.APIMap;\n+import jdk.codetools.apidiff.report.html.HtmlDiffBuilder;\n+import jdk.codetools.apidiff.report.html.ResultTable.CountKind;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+\n+\/**\n+ * Unit tests for the {@code TextDiffBuilder} class.\n+ *\/\n+public class HtmlDiffBuilderTest extends APITester {\n+    \/**\n+     * Tests the behavior when the two sets of input are equal.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testEqual() throws IOException {\n+        List<String> list1 = lines(10);\n+        List<String> list2 = new ArrayList<>(list1);\n+        test(getScratchDir(), list1, list2);\n+    }\n+\n+    \/**\n+     * Tests the behavior when a line is inserted into the \"modified\" set.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testSimpleInsert() throws IOException {\n+        List<String> list1 = lines(10);\n+        List<String> list2 = new ArrayList<>(list1);\n+        list2.add(5, \"inserted line\");\n+        test(getScratchDir(), list1, list2);\n+    }\n+\n+    \/**\n+     * Tests the behavior when a line is removed from the \"modified\" set.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testSimpleDelete() throws IOException {\n+        List<String> list1 = lines(10);\n+        List<String> list2 = new ArrayList<>(list1);\n+        list2.remove(5);\n+        test(getScratchDir(), list1, list2);\n+    }\n+\n+    \/**\n+     * Tests the behavior when a line is changed in the \"modified\" set.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testSimpleChange() throws IOException {\n+        List<String> list1 = lines(20);\n+        List<String> list2 = new ArrayList<>(list1);\n+        list2.set(5, \"changed line\");\n+        test(getScratchDir(), list1, list2);\n+    }\n+\n+    \/**\n+     * Tests the behavior when multiple changes are made in the \"modified\" set.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testMultiple() throws IOException {\n+        List<String> list1 = lines(20, 32);\n+        List<String> list2 = new ArrayList<>(list1);\n+        list2.add(3, \"inserted line\");\n+        list2.set(10, \"changed line\");\n+        list2.remove(15);\n+        test(getScratchDir(), list1, list2);\n+    }\n+\n+    \/**\n+     * Tests the behavior when changes are made in different parts of the modified set,\n+     * such that they are presented as disjoint differences.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testDisjoint() throws IOException {\n+        List<String> list1 = IntStream.range(1, 50)\n+                .mapToObj(i -> (\"line:\" + i))\n+                .collect(Collectors.toList());\n+        List<String> list2 = new ArrayList<>(list1);\n+        list2.add(10, \"insert\");\n+        list2.set(20, \"change\");\n+        list2.remove(30);\n+        test(getScratchDir(), list1, list2);\n+    }\n+\n+    \/**\n+     * Tests the behavior if a style is added.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testStyleAdded() throws IOException {\n+        List<String> list1 = lines(20);\n+        List<String> list2 = new ArrayList<>(list1);\n+        list2.set(5, list2.get(5).replaceAll(\"^(\\\\S+\\\\s+)(\\\\S+)(.*)\", \"$1<i>$2<\/i>$3\"));\n+        test(getScratchDir(), list1, list2);\n+    }\n+\n+    \/**\n+     * Tests the behavior if the change is just to the HTML style.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testStyleChange() throws IOException {\n+        List<String> list1 = lines(20);\n+        List<String> list2 = new ArrayList<>(list1);\n+        list1.set(5, list1.get(5).replaceAll(\"^(\\\\S+\\\\s+)(\\\\S+)(.*)\", \"$1<b>$2<\/b>$3\"));\n+        list2.set(5, list2.get(5).replaceAll(\"^(\\\\S+\\\\s+)(\\\\S+)(.*)\", \"$1<i>$2<\/i>$3\"));\n+        test(getScratchDir(), list1, list2);\n+    }\n+\n+    \/**\n+     * Tests the behavior if a style is removed.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testStyleRemoved() throws IOException {\n+        List<String> list1 = lines(20);\n+        List<String> list2 = new ArrayList<>(list1);\n+        list1.set(5, list1.get(5).replaceAll(\"^(\\\\S+\\\\s+)(\\\\S+)(.*)\", \"$1<i>$2<\/i>$3\"));\n+        test(getScratchDir(), list1, list2);\n+    }\n+\n+    \/**\n+     * Tests the behavior if a block element, like a heading, is changed.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testHeadingChanged() throws IOException {\n+        List<String> list1 = lines(20);\n+        List<String> list2 = new ArrayList<>(list1);\n+        list1.set(3, \"<h3>\" + list1.get(3) + \"<\/h3>\");\n+        list2.set(3, \"<h4>\" + list2.get(3) + \"<\/h4>\");\n+        test(getScratchDir(), list1, list2);\n+    }\n+\n+    \/**\n+     * Tests the behavior if a link is changed.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testLinkChanged() throws IOException {\n+        List<String> list1 = lines(20);\n+        List<String> list2 = new ArrayList<>(list1);\n+        list1.set(3, \"<a href=\\\"old.html\\\">\" + list1.get(3) + \"<\/a>\");\n+        list2.set(3, \"<a href=\\\"new.html\\\">\" + list2.get(3) + \"<\/a>\");\n+        test(getScratchDir(), list1, list2);\n+    }\n+\n+    void test(Path dir, List<String> list1, List<String> list2) throws IOException {\n+        test(dir, String.join(\"<br>\\n\", list1), String.join(\"<br>\\n\", list2));\n+    }\n+\n+    void test(Path dir, String html1, String html2) throws IOException {\n+        try (PrintWriter out = wrap(System.out); PrintWriter err = wrap(System.err)) {\n+            APIMap<String> apiMap = APIMap.of();\n+            apiMap.put(new TestAPI(\"api1\"), html1);\n+            apiMap.put(new TestAPI(\"api2\"), html1);\n+            Log log = new Log(out, err);\n+            Messages msgs = Messages.instance(\"jdk.codetools.apidiff.report.html.resources.report\");\n+            HtmlDiffBuilder b = new HtmlDiffBuilder(apiMap.keySet(), log, msgs);\n+            Map<CountKind, Integer> counts = new EnumMap<>(CountKind.class);\n+            List<Content> c = b.build(apiMap, ck -> counts.put(ck, counts.computeIfAbsent(ck, ck_ -> 0) + 1));\n+            try (Writer w = Files.newBufferedWriter(dir.resolve(\"out.html\"))) {\n+                HtmlTree head = HtmlTree.HEAD(\"utf-8\", \"test\")\n+                        .add(new HtmlTree(TagName.STYLE, new Text(style)));\n+                HtmlTree body = HtmlTree.BODY(c);\n+                HtmlTree html = new HtmlTree(TagName.HTML, head, body);\n+                html.write(w);\n+            }\n+            log.out.println(\"Counts: \" + counts);\n+        }\n+    }\n+\n+    PrintWriter wrap(PrintStream out) {\n+        return new PrintWriter(out) {\n+            @Override\n+            public void close() {\n+                flush();\n+            }\n+        };\n+    }\n+\n+    List<String> lines(int size) {\n+        return lines(size, 64);\n+    }\n+\n+    List<String> lines(int lineCount, int lineLength) {\n+        List<String> lines = new ArrayList<>();\n+        StringBuilder sb = new StringBuilder();\n+        Pattern ws = Pattern.compile(\"\\\\s\");\n+        Matcher m = ws.matcher(lorem_ipsum);\n+        int start = 0;\n+        while (m.find()) {\n+            \/\/ wrap long lines\n+            if (sb.length() + (m.start() - start) > lineLength) {\n+                lines.add(sb.toString());\n+                if (lines.size() > lineCount) {\n+                    return lines;\n+                }\n+                sb = new StringBuilder();\n+            }\n+\n+            \/\/ append word\n+            if (sb.length() > 0) {\n+                sb.append(\" \");\n+            }\n+            sb.append(lorem_ipsum, start, m.start());\n+\n+            \/\/ handle explicit newline\n+            if (m.group().equals(\"\\n\")) {\n+                lines.add(sb.toString());\n+                if (lines.size() > lineCount) {\n+                    return lines;\n+                }\n+                sb = new StringBuilder();\n+            }\n+\n+            start = m.end();\n+        }\n+        sb.append(lorem_ipsum.substring(start));\n+        lines.add(sb.toString());\n+        System.err.println(lines);\n+        return lines;\n+    }\n+\n+    \/\/ TODO: consider using apidiff.css either by linking to it\n+    \/\/       or copying it inline.\n+    private static final String style = \"\"\"\n+            div.hdiffs {\n+                margin: 2px 10px;\n+                padding: 2px 2px;\n+                border: 1px solid grey;\n+            }\n+\n+            div.hdiffs-title {\n+                padding-left: 2em;\n+                text-weight: bold;\n+                background-color: #eee;\n+                border-bottom: 1px solid grey;\n+                margin-bottom: 5px;}\n+            .hdiffs span.diff-html-added { background-color: #bfb }\n+            .hdiffs span.diff-html-changed { background-color: #ffb }\n+            .hdiffs span.diff-html-removed { background-color: #fbb; }\n+            \"\"\";\n+\n+    private static final String lorem_ipsum = LoremIpsum.text;\n+}\n","filename":"test\/junit\/apitest\/HtmlDiffBuilderTest.java","additions":309,"deletions":0,"binary":false,"changes":309,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import jdk.codetools.apidiff.model.HtmlParser;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+\n+public class HtmlParserTest extends APITester {\n+    @Test\n+    public void testSimple() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        test(base, \"<tag>content<\/tag>\",\n+                \"Start: tag {} false\",\n+                \"Content: content\",\n+                \"End: tag\");\n+    }\n+\n+    @Test\n+    public void testAttr() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        test(base, \"<tag a1=\\\"value\\\" a2='value' a3=value>\",\n+                \"Start: tag {a1=value, a2=value, a3=value} false\");\n+    }\n+\n+    @Test\n+    public void testMultilineContent() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        test(base, \"<tag>line 1\\nline 2<\/tag>\",\n+                \"Start: tag {} false\",\n+                \"Content: line 1\\\\n\",\n+                \"Content: line 2\",\n+                \"End: tag\");\n+    }\n+\n+    @Test\n+    public void testComment() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        test(base, \"<tag>before<!--comment-->after<\/tag>\",\n+                \"Start: tag {} false\",\n+                \"Content: before\",\n+                \"Comment: comment\",\n+                \"Content: after\",\n+                \"End: tag\");\n+    }\n+\n+    @Test\n+    public void testDocType() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        test(base,\"<!doctype html><head>\",\n+                \"DocType: doctype html\",\n+                \"Start: head {} false\");\n+    }\n+\n+    @Test\n+    public void testSample() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        test(base,\"<html><head><title>This is the title<\/title><\/head><body>This is content<a href=\\\"#foo\\\">link<\/a><\/body><\/html>\",\n+                \"Start: html {} false\",\n+                \"Start: head {} false\",\n+                \"Start: title {} false\",\n+                \"Content: This is the title\",\n+                \"End: title\",\n+                \"End: head\",\n+                \"Start: body {} false\",\n+                \"Content: This is content\",\n+                \"Start: a {href=#foo} false\",\n+                \"Content: link\",\n+                \"End: a\",\n+                \"End: body\",\n+                \"End: html\");\n+    }\n+\n+    private void test(Path base, String html, String... expect) throws IOException {\n+        \/\/ avoid using .html extension, to avoid 'tidy' errors\n+        Path file = base.resolve(\"test.htmlx\");\n+        Files.writeString(file, html);\n+        List<String> list = new ArrayList<>();\n+        HtmlParser p = new HtmlParser() {\n+            @Override\n+            public void startElement(String name, Map<String, String> attrs, boolean selfClosing) {\n+                record(\"Start: \" + name + \" \" + attrs + \" \" + selfClosing);\n+            }\n+\n+            @Override\n+            public void endElement(String name) {\n+                record(\"End: \" + name);\n+\n+            }\n+\n+            @Override\n+            public void content(Supplier<String> content) {\n+                record(\"Content: \" + content.get().replace(\"\\n\", \"\\\\n\"));\n+            }\n+\n+            @Override\n+            public void comment(Supplier<String> comment) {\n+                record(\"Comment: \" + comment.get().replace(\"\\n\", \"\\\\n\"));\n+            }\n+\n+            @Override\n+            public void doctype(Supplier<String> doctype) {\n+                record(\"DocType: \" + doctype.get().replace(\"\\n\", \"\\\\n\"));\n+            }\n+\n+            @Override\n+            protected void error(Path file, int lineNumber, String message) {\n+                System.err.println(\"Error: \" + file + \":\" + lineNumber + \":\" + message);\n+            }\n+\n+            @Override\n+            protected void error(Path file, int lineNumber, Throwable t) {\n+                System.err.println(\"Error: \" + file + \":\" + lineNumber + \":\" + t);\n+\n+            }\n+\n+            private void record(String msg) {\n+                System.out.println(msg);\n+                list.add(msg);\n+            }\n+        };\n+\n+        p.read(file);\n+        Assertions.assertEquals(List.of(expect), list);\n+    }\n+}\n","filename":"test\/junit\/apitest\/HtmlParserTest.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+\/**\n+ * A class to provide a chunk of \"lorem ipsum\" text,\n+ * and to encapsulate the spelling errors inherent therein!\n+ *\/\n+public class LoremIpsum {\n+    static final String text;\n+\n+    static {\n+        text = \"\"\"\n+            Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et \\\n+            dolore magna aliqua. Dolor sed viverra ipsum nunc aliquet bibendum enim. In massa tempor nec feugiat. \\\n+            Nunc aliquet bibendum enim facilisis gravida. Nisl nunc mi ipsum faucibus vitae aliquet nec ullamcorper. \\\n+            Amet luctus venenatis lectus magna fringilla. Volutpat maecenas volutpat blandit aliquam etiam erat \\\n+            velit scelerisque in. Egestas egestas fringilla phasellus faucibus scelerisque eleifend. Sagittis orci \\\n+            a scelerisque purus semper eget duis. Nulla pharetra diam sit amet nisl suscipit. Sed adipiscing diam \\\n+            donec adipiscing tristique risus nec feugiat in. Fusce ut placerat orci nulla. Pharetra vel turpis nunc \\\n+            eget lorem dolor. Tristique senectus et netus et malesuada.\\\n+            \\\n+            Etiam tempor orci eu lobortis elementum nibh tellus molestie. Neque egestas congue quisque egestas. \\\n+            Egestas integer eget aliquet nibh praesent tristique. Vulputate mi sit amet mauris. Sodales neque \\\n+            sodales ut etiam sit. Dignissim suspendisse in est ante in. Volutpat commodo sed egestas egestas. \\\n+            Felis donec et odio pellentesque diam. Pharetra vel turpis nunc eget lorem dolor sed viverra. \\\n+            Porta nibh venenatis cras sed felis eget. Aliquam ultrices sagittis orci a. Dignissim diam quis enim \\\n+            lobortis. Aliquet porttitor lacus luctus accumsan. Dignissim convallis aenean et tortor at risus \\\n+            viverra adipiscing at.\"\"\";\n+    }\n+\n+    private LoremIpsum() { }\n+}\n","filename":"test\/junit\/apitest\/LoremIpsum.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.codetools.apidiff.Main;\n+import jdk.codetools.apidiff.Main.Result;\n+import jdk.codetools.apidiff.Messages;\n+import jdk.codetools.apidiff.Options;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+import toolbox.ModuleBuilder;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * Basic tests for the main program.\n+ *\/\n+public class MainTest extends APITester {\n+\n+    \/**\n+     * Tests the {@code --help} option.\n+     *\n+     * The test verifies that all the necessary resources are defined\n+     * and that the corresponding value appears in the output generated\n+     * by the option.\n+     *\/\n+    @Test\n+    public void testHelp() {\n+        for (String help : Options.Option.HELP.getNames()) {\n+            Map<OutputKind, String> outMap = run(List.of(help));\n+            String out = outMap.get(OutputKind.OUT);\n+            for (Options.Option option : Options.Option.values()) {\n+                option.getNames().forEach(name -> assertTrue(out.contains(name)));\n+            }\n+            assertFalse(out.contains(\"opt.desc.\"));\n+            assertFalse(out.contains(\"opt.arg.\"));\n+            Messages messages = Messages.instance(\"jdk.codetools.apidiff.resources.help\");\n+            for (String key : messages.getKeys()) {\n+                if (key.startsWith(\"opt.arg\")) {\n+                    assertTrue(out.contains(messages.getString(key)));\n+                }\n+                if (key.startsWith(\"opt.desc\")) {\n+                    messages.getString(key).lines().forEach(line ->\n+                            assertTrue(line.contains(\"{0}\") || out.contains(line)));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testBadOption() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            new ModuleBuilder(tb, false, \"mA\")\n+                    .exports(\"p\")\n+                    .classes(\"package p; public class C { }\\n\")\n+                    .write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-notAnOption\",\n+                \"--help\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options, EnumSet.of(Main.Result.BAD_ARGS));\n+\n+        String err = outMap.get(OutputKind.ERR);\n+        assertTrue(err.contains(\"unknown option\"));\n+\n+        \/\/ verify processing stopped after detecting a bad option\n+        String out = outMap.get(OutputKind.OUT);\n+        assertFalse(out.contains(\"help\"));\n+        assertFalse(out.contains(\"Completed comparison:\"));\n+    }\n+\n+    @Test\n+    public void testMakeOutputDirectory() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            new ModuleBuilder(tb, false, \"mA\")\n+                    .exports(\"p\")\n+                    .classes(\"package p; public class C { }\\n\")\n+                    .write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+\n+        assertTrue(Files.exists(base.resolve(\"out\")));\n+    }\n+\n+    @Test\n+    public void testSyntaxError() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            new ModuleBuilder(tb, false, \"mA\")\n+                    .exports(\"p\")\n+                    .classes(\"package p; public class C \" + (a == 0 ? \"{ }\" : \"\") +\"\\n\")\n+                    .write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options, EnumSet.of(Result.FAULT));\n+\n+        String err = outMap.get(OutputKind.ERR);\n+        assertTrue(err.contains(\"1 error\"));\n+\n+        String out = outMap.get(OutputKind.ERR);\n+        assertFalse(out.contains(\"Completed comparison:\"));\n+    }\n+}\n","filename":"test\/junit\/apitest\/MainTest.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+import toolbox.ModuleBuilder;\n+\n+\/**\n+ * Tests for the ability to compare methods.\n+ *\/\n+public class MethodTest extends APITester {\n+\n+    \/**\n+     * Tests methods with different modifiers.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testModifiers() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testMethods(base, i -> {\n+            String mods = (i == 0) ? \"public\" : \"protected\";\n+            return mods + \" void m() { }\";\n+        });\n+    }\n+\n+    \/**\n+     * Tests methods with different return types.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testReturnType() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testMethods(base, i -> (i == 0)\n+                ? \"public void m() { }\"\n+                : \"public int m() { return 0; }\"\n+\n+        );\n+    }\n+\n+    \/**\n+     * Tests methods with different receiver types.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testReceiverType() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testMethods(base, i -> (i == 0)\n+                ? \"public void m(int m) { }\"\n+                : \"public void m(@Anno C this, int m) { }\"\n+\n+        );\n+    }\n+\n+    \/**\n+     * Tests methods with different annotations on parameters.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testParameterAnnos() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testMethods(base, i -> (i == 0)\n+                ? \"public void m(int m) { }\"\n+                : \"public void m(@Anno int m) { }\"\n+\n+        );\n+    }\n+\n+    \/**\n+     * Tests methods with different modifiers on annotations.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testParameterModifiers() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testMethods(base, i -> (i == 0)\n+                ? \"public void m(int m) { }\"\n+                : \"public void m(final int m) { }\"\n+\n+        );\n+    }\n+\n+    \/**\n+     * Tests methods with different names of parameters.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testParameterNames() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testMethods(base, i -> (i == 0)\n+                ? \"public void m(int m0) { }\"\n+                : \"public void m(int m1) { }\"\n+\n+        );\n+    }\n+\n+    \/**\n+     * Tests methods with different exceptions declared to be thrown.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testThrows() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testMethods(base, i  -> new StringBuilder()\n+                .append(\"public void m1()\")\n+                .append(i == 0 ? \"\" : \" throws Exception\")\n+                .append(\" { }\")\n+                .append(\"public void m2() throws \")\n+                .append(i == 0 ? \"Exception\" : \"Error\")\n+                .append(\" { }\")\n+                .toString());\n+    }\n+\n+    \/**\n+     * Tests methods with different doc comments.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testRawDocComments() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        testMethods(base, i  -> {\n+            String cs1 = \"\/**\\n * This is 'same()'.\\n * Unchanged.\\n * More.\\n **\/\\n\";\n+            String ci1 = \"\/**\\n * This is 'insert1()'.\\n\" + (i == 1 ? \" * Inserted.\\n\" : \"\") + \" * More.\\n **\/\\n\";\n+            String ci2 = \"\/**\\n * This is 'insert2()'.\"\n+                    + (i == 1 ? \" Inserted 1\\n * Inserted 2\\n * Inserted 3\" : \"\") + \" rest of line\\n * More.\\n **\/\\n\";\n+            String ci3 = \"\/**\\n * This is 'insert3()'.\"\n+                    + (i == 1 ? \" Inserted.\" : \"\") + \" rest of line\\n * More.\\n **\/\\n\";\n+            String cr1 = \"\/**\\n * This is 'remove1()'.\\n\" + (i == 0 ? \" * Removed.\\n\" : \"\") + \" * More.\\n **\/\\n\";\n+            String cr2 = \"\/**\\n * This is 'remove2()'.\"\n+                    + (i == 0 ? \" Removed 1\\n * Removed 2\\n * Removed 3\" : \"\") + \" rest of line\\n * More.\\n **\/\\n\";\n+            String cr3 = \"\/**\\n * This is 'remove3()'.\"\n+                    + (i == 0 ? \" Removed.\" : \"\") + \" rest of line\\n * More.\\n **\/\\n\";\n+            String cc1 = \"\/**\\n * This is 'change()'.\\n * API \" + i + \"\\n * More.\\n **\/\\n\";\n+            return    cs1 + \"public void same() { }\\n\"\n+                    + ci1 + \"public void insert1() { }\\n\"\n+                    + ci2 + \"public void insert2() { }\\n\"\n+                    + ci3 + \"public void insert3() { }\\n\"\n+                    + cr1 + \"public void remove1() { }\\n\"\n+                    + cr2 + \"public void remove2() { }\\n\"\n+                    + cr3 + \"public void remove3() { }\\n\"\n+                    + cc1 + \"public void change() { }\\n\";\n+        });\n+    }\n+\n+    private void testMethods(Path base, Function<Integer,String> f) throws IOException {\n+        List<String> options = new ArrayList<>();\n+\n+        for (int i = 0; i < 2; i++) {\n+            String apiName = \"api\" + i;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            String mods = (i == 0) ? \"public\" : \"protected\";\n+            new ModuleBuilder(tb, \"mA\")\n+                    .exports(\"p\")\n+                    .classes(\"package p; import java.lang.annotation.*; \"\n+                            + \"@Target({ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE_USE}) \"\n+                            + \"@interface Anno { }\")\n+                    .classes(\"package p; public class C {\\n\" + f.apply(i) + \"\\n}\\n\")\n+                    .write(apiDir);\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+}\n","filename":"test\/junit\/apitest\/MethodTest.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+import toolbox.ModuleBuilder;\n+\n+\/**\n+ * Tests for the ability to detect missing items.\n+ *\/\n+public class MissingTest extends APITester {\n+    @Test\n+    public void testMissingModule() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+        for (int a = 0; a < 3; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            for (int i = 0; i < 3; i++) {\n+                if (a != 1 || i != 1) {\n+                    new ModuleBuilder(tb, \"m.\" + (char)('A' + i))\n+                            .exports(\"p\" + i)\n+                            .classes(\"package p\" + i + \"; public class C { }\")\n+                    .write(apiDir);\n+                }\n+            }\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"-XDshow-debug-summary\",\n+                \"-XDtrace-reporter\",\n+                \"--include\", \"m.*\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    @Test\n+    public void testMissingPackage() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+        for (int a = 0; a < 3; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            ModuleBuilder mb = new ModuleBuilder(tb, \"m\");\n+            for (int i = 0; i < 3; i++) {\n+                if (a != 1 || i != 1) {\n+                    mb.exports(\"p\" + i).classes(\"package p\" + i + \"; public class C { }\");\n+                }\n+            }\n+            mb.write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"-XDshow-debug-summary\",\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    @Test\n+    public void testMissingType() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+        for (int a = 0; a < 3; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            ModuleBuilder mb = new ModuleBuilder(tb, \"m\");\n+            mb.exports(\"p\");\n+            for (int i = 0; i < 3; i++) {\n+                if (a != 1 || i != 1) {\n+                    mb.classes(\"package p; public class C\" + i + \" { }\");\n+                }\n+            }\n+            mb.write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"-XDshow-debug-summary\",\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    @Test\n+    public void testMissingField() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+        for (int a = 0; a < 3; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            ModuleBuilder mb = new ModuleBuilder(tb, \"m\");\n+            mb.exports(\"p\");\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 0; i < 3; i++) {\n+                if (a != 1 || i != 1) {\n+                    sb.append(\"public int f\" + i + \"; \");\n+                }\n+            }\n+            mb.classes(\"package p; public class C { \" + sb + \"}\");\n+            mb.write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"-XDshow-debug-summary\",\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    @Test\n+    public void testMissingMethod() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+        for (int a = 0; a < 3; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            ModuleBuilder mb = new ModuleBuilder(tb, \"m\");\n+            mb.exports(\"p\");\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 0; i < 3; i++) {\n+                if (a != 1 || i != 1) {\n+                    sb.append(\"public void m\" + i + \"(); \");\n+                }\n+            }\n+            mb.classes(\"package p; public class C { \" + sb + \"}\");\n+            mb.write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"-XDshow-debug-summary\",\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+}\n","filename":"test\/junit\/apitest\/MissingTest.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -0,0 +1,431 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+import toolbox.ModuleBuilder;\n+\n+\/**\n+ * Tests for the ability to compare modules.\n+ *\/\n+public class ModuleTest extends APITester {\n+    \/**\n+     * Tests handling of missing modules.\n+     * Three APIs are generated.\n+     * <ul>\n+     * <li>all APIs contain equal definitions of module mA\n+     * <li>two APIs contain equal definitions of mB\n+     * <li>only one API contains a definition of mC\n+     * <\/ul>\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testMissingModules() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 3;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            for (int m = 0; m <= a; m++) {\n+                new ModuleBuilder(tb, \"m%m%\".replace(\"%m%\", String.valueOf((char) ('A' + m))))\n+                        .exports(\"p%m%\".replace(\"%m%\", String.valueOf(m)))\n+                        .classes(\"package p%m%; public class C%m% { }\\n\".replace(\"%m%\", String.valueOf(m)))\n+                        .write(apiDir);\n+            }\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"--include\", \"mB\/**\",\n+                \"--include\", \"mC\/**\",\n+                \"-d\", base.resolve(\"out\").toString(),\n+                \"--verbose\", \"missing\"));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+        long notFound = outMap.get(OutputKind.ERR).lines()\n+                .filter(l -> l.contains(\"Item not found\"))\n+                .count();\n+        Assertions.assertEquals(3, notFound);\n+\n+    }\n+\n+    \/**\n+     * Tests handling of modules with different modifiers.\n+     * Two APIs are generated, containing four modules.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testDifferentModifiers() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            for (int m = 0; m < 4; m++) {\n+                boolean open = (m & (1 << a)) != 0;\n+                new ModuleBuilder(tb, open, \"m%m%\".replace(\"%m%\", String.valueOf((char) ('A' + m))))\n+                        .exports(\"p%m%\".replace(\"%m%\", String.valueOf(m)))\n+                        .classes(\"package p%m%; public class C%m% { }\\n\".replace(\"%m%\", String.valueOf(m)))\n+                        .write(apiDir);\n+            }\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"--include\", \"mB\/**\",\n+                \"--include\", \"mC\/**\",\n+                \"--include\", \"mD\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+\n+    }\n+\n+    \/**\n+     * Tests handling of modules with different doc comments.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testRawDocComments() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            String cs = \"\/**\\n * This is 'm.same'.\\n * Unchanged.\\n * More.\\n **\/\\n\";\n+            String ci = \"\/**\\n * This is 'm.insert'.\\n\" + (a == 1 ? \" * Inserted.\\n\" : \"\") + \" * More.\\n **\/\\n\";\n+            String cr = \"\/**\\n * This is 'm.remove'.\\n\" + (a == 0 ? \" * Removed.\\n\" : \"\") + \" * More.\\n **\/\\n\";\n+            String cc = \"\/**\\n * This is 'm.change'.\\n * API \" + a + \"\\n * More.\\n **\/\\n\";\n+\n+            new ModuleBuilder(tb, \"m.same\")\n+                    .comment(cs)\n+                    .classes(\"package p; public class C { }\")\n+                    .write(apiDir);\n+\n+            new ModuleBuilder(tb, \"m.insert\")\n+                    .comment(ci)\n+                    .classes(\"package p; public class C { }\")\n+                    .write(apiDir);\n+\n+            new ModuleBuilder(tb, \"m.remove\")\n+                    .comment(cr)\n+                    .classes(\"package p; public class C { }\")\n+                    .write(apiDir);\n+\n+            new ModuleBuilder(tb, \"m.change\")\n+                    .comment(cc)\n+                    .classes(\"package p; public class C { }\")\n+                    .write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"m.same\/**\",\n+                \"--include\", \"m.insert\/**\",\n+                \"--include\", \"m.remove\/**\",\n+                \"--include\", \"m.change\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+\n+    }\n+\n+    @Test\n+    public void testDifferentRequiresModule() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            new ModuleBuilder(tb, false, \"mA\")\n+                    .requires(a == 0 ? \"java.compiler\" : \"jdk.compiler\")\n+                    .exports(\"p\")\n+                    .classes(\"package p; public class C { }\\n\")\n+                    .write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+\n+    }\n+\n+    @Test\n+    public void testDifferentRequiresStatic() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            boolean isStatic = (a != 0);\n+            new ModuleBuilder(tb, false, \"mA\")\n+                    .requires(\"java.compiler\", isStatic, false)\n+                    .exports(\"p\")\n+                    .classes(\"package p; public class C { }\\n\")\n+                    .write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+\n+    }\n+\n+    @Test\n+    public void testDifferentRequiresTransitive() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            boolean isTransitive = (a != 0);\n+            new ModuleBuilder(tb, false, \"mA\")\n+                    .requires(\"java.compiler\", false, isTransitive)\n+                    .exports(\"p\")\n+                    .classes(\"package p; public class C { }\\n\")\n+                    .write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    @Test\n+    public void testDifferentExportTargets() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            new ModuleBuilder(tb, false, \"m\")\n+                    .exports(\"p1\")\n+                    .exportsTo(\"p2\",\n+                            \"mX\", \"m%a%\".replace(\"%a%\", String.valueOf((char) ('A' + a))), \"mZ\")\n+                    .classes(\"package p1; public class C { }\\n\")\n+                    .classes(\"package p2; public class C { }\\n\")\n+                    .write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"-XDshow-debug-summary\",\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    @Test\n+    public void testDifferentOpenTargets() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            new ModuleBuilder(tb, false, \"m\")\n+                    .opens(\"p1\")\n+                    .opensTo(\"p2\",\n+                            \"mX\", \"m%a%\".replace(\"%a%\", String.valueOf((char) ('A' + a))), \"mZ\")\n+                    .classes(\"package p1; public class C { }\\n\")\n+                    .classes(\"package p2; public class C { }\\n\")\n+                    .write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"-XDshow-debug-summary\",\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    @Test\n+    public void testDifferentProvides() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            new ModuleBuilder(tb, false, \"m\")\n+                    .exports(\"p\")\n+                    .provides(\"p.S\",\n+                            \"p.I0\", \"p.I%a%\".replace(\"%a%\", String.valueOf(a + 1)), \"p.I3\")\n+                    .classes(\"package p; public class S { }\\n\")\n+                    .classes(\"package p; public class I0 extends S { }\\n\")\n+                    .classes(\"package p; public class I1 extends S { }\\n\")\n+                    .classes(\"package p; public class I2 extends S { }\\n\")\n+                    .classes(\"package p; public class I3 extends S { }\\n\")\n+                    .write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"-XDshow-debug-summary\",\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    @Test\n+    public void testDifferentUses() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            new ModuleBuilder(tb, false, \"m\")\n+                    .exports(\"p\")\n+                    .uses(\"p.S0\")\n+                    .uses(\"p.S%a%\".replace(\"%a%\", String.valueOf(a + 1)))\n+                    .uses(\"p.S3\")\n+                    .classes(\"package p; public class S0 { }\\n\")\n+                    .classes(\"package p; public class S1 { }\\n\")\n+                    .classes(\"package p; public class S2 { }\\n\")\n+                    .classes(\"package p; public class S3 { }\\n\")\n+                    .write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"-XDshow-debug-summary\",\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+}\n","filename":"test\/junit\/apitest\/ModuleTest.java","additions":431,"deletions":0,"binary":false,"changes":431,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+\n+public class NoArgConstructorTest extends APITester {\n+    @Test\n+    public void addNoArgConstructor() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        Path srcA = Files.createDirectories(base.resolve(\"srcA\"));\n+        tb.writeJavaFiles(srcA,\n+                \"package p;\\n\"\n+                + \"public class C { }\");\n+\n+        Path srcB = Files.createDirectories(base.resolve(\"srcB\"));\n+        tb.writeJavaFiles(srcB,\n+                \"\"\"\n+                        package p;\n+                        public class C {\n+                          \/** Explicit no-args constructor. *\/\n+                          public C() { }\n+                        }\"\"\");\n+\n+        List<String> options = List.of(\n+                \"--api\", \"A\",\n+                \"--source-path\", srcA.toString(),\n+                \"--api\", \"B\",\n+                \"--source-path\", srcB.toString(),\n+                \"--include\", \"p.*\",\n+                \"-d\",  base.resolve(\"out\").toString(),\n+                \"--verbose\", \"differences\");\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+        long differences = outMap.get(OutputKind.ERR).lines()\n+                .filter(l -> l.contains(\"Different raw doc comments for constructor p.C#C()\"))\n+                .count();\n+        Assertions.assertEquals(1, differences);\n+    }\n+\n+    @Test\n+    public void addPrivateNoArgConstructor() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        Path srcA = Files.createDirectories(base.resolve(\"srcA\"));\n+        tb.writeJavaFiles(srcA, \"\"\"\n+                package p;\n+                public class C { }\"\"\");\n+\n+        Path srcB = Files.createDirectories(base.resolve(\"srcB\"));\n+        tb.writeJavaFiles(srcB,\"\"\"\n+                package p;\n+                public class C {\n+                  \/** Private no-args constructor. *\/\n+                  private C() { }\n+                }\"\"\");\n+\n+        List<String> options = List.of(\n+                \"--api\", \"A\",\n+                \"--source-path\", srcA.toString(),\n+                \"--api\", \"B\",\n+                \"--source-path\", srcB.toString(),\n+                \"--include\", \"p.*\",\n+                \"-d\",  base.resolve(\"out\").toString(),\n+                \"--verbose\", \"missing\");\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+        long notFound = outMap.get(OutputKind.ERR).lines()\n+                .filter(l -> l.contains(\"Item not found in API 'B': constructor p.C#C()\"))\n+                .count();\n+        Assertions.assertEquals(1, notFound);\n+\n+    }\n+}\n","filename":"test\/junit\/apitest\/NoArgConstructorTest.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,450 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.Elements;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.StandardLocation;\n+import javax.tools.ToolProvider;\n+\n+import com.sun.source.util.JavacTask;\n+\n+import jdk.codetools.apidiff.Log;\n+import jdk.codetools.apidiff.Notes;\n+import jdk.codetools.apidiff.Notes.Entry;\n+import jdk.codetools.apidiff.model.ElementKey;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+import toolbox.ModuleBuilder;\n+\n+public class NotesTest extends APITester {\n+    @Test\n+    public void testGetEntries() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        String text =\"\"\"\n+                # this is a comment\n+\n+                http:\/\/openjdk.java.net\/jeps\/0 JEP 0\n+                  mA\n+                  mA\/*\n+                  mA\/p\n+                  mA\/p.*\n+                  mA\/p.C.*\n+                  mA\/p.C\n+                  mA\/p.C#f1\n+                  mA\/p.C#m1(int)\n+                \"\"\";\n+        readNotes(base, text);\n+\n+        Path src = base.resolve(\"src\");\n+        for (int i = 0; i < 2; i++){\n+            ModuleBuilder mb = new ModuleBuilder(tb, \"m\" + (char)('A' + i));\n+            mb.classes(\"\"\"\n+                    package p; public class C {\n+                      public static class Nested { }\n+                      public int f1;\n+                      public int f2;\n+                      public void m1(String s) { }\n+                      public void m1(int i) { }\n+                      public void m2(String s) { }\n+                      public void m2(int i) { }\n+                    }\"\"\",\n+                    \"package p;\")\n+                .write(src);\n+        }\n+\n+        JavaCompiler c = ToolProvider.getSystemJavaCompiler();\n+        StandardJavaFileManager fm = c.getStandardFileManager(null, null, null);\n+        fm.setLocationFromPaths(StandardLocation.MODULE_SOURCE_PATH, List.of(src));\n+        List<String> options = List.of(\"-proc:only\");\n+        Iterable<? extends JavaFileObject> files = fm.getJavaFileObjects(tb.findFiles(\".java\", src));\n+        JavacTask t = (JavacTask) c.getTask(new PrintWriter(log, true), fm, null, options, null, files);\n+        t.analyze();\n+\n+        Elements elements = t.getElements();\n+        ModuleElement mA = elements.getModuleElement(\"mA\");\n+        checkEntries(mA,\n+                \"Entry[name=mA,uri=http:\/\/openjdk.java.net\/jeps\/0,description=JEP 0,recursive=false]\",\n+                \"Entry[name=mA,uri=http:\/\/openjdk.java.net\/jeps\/0,description=JEP 0,recursive=true]\");\n+\n+        PackageElement p = elements.getPackageElement(mA, \"p\");\n+        checkEntries(p,\n+                \"Entry[name=mA,uri=http:\/\/openjdk.java.net\/jeps\/0,description=JEP 0,recursive=true]\",\n+                \"Entry[name=mA\/p,uri=http:\/\/openjdk.java.net\/jeps\/0,description=JEP 0,recursive=false]\",\n+                \"Entry[name=mA\/p,uri=http:\/\/openjdk.java.net\/jeps\/0,description=JEP 0,recursive=true]\");\n+\n+        TypeElement pC = elements.getTypeElement(mA, \"p.C\");\n+        checkEntries(pC,\n+                \"Entry[name=mA,uri=http:\/\/openjdk.java.net\/jeps\/0,description=JEP 0,recursive=true]\",\n+                \"Entry[name=mA\/p,uri=http:\/\/openjdk.java.net\/jeps\/0,description=JEP 0,recursive=true]\",\n+                \"Entry[name=mA\/p.C,uri=http:\/\/openjdk.java.net\/jeps\/0,description=JEP 0,recursive=true]\",\n+                \"Entry[name=mA\/p.C,uri=http:\/\/openjdk.java.net\/jeps\/0,description=JEP 0,recursive=false]\");\n+\n+        TypeElement pCN = elements.getTypeElement(mA, \"p.C.Nested\");\n+        checkEntries(pCN,\n+                \"Entry[name=mA,uri=http:\/\/openjdk.java.net\/jeps\/0,description=JEP 0,recursive=true]\",\n+                \"Entry[name=mA\/p,uri=http:\/\/openjdk.java.net\/jeps\/0,description=JEP 0,recursive=true]\",\n+                \"Entry[name=mA\/p.C,uri=http:\/\/openjdk.java.net\/jeps\/0,description=JEP 0,recursive=true]\");\n+\n+        VariableElement f1 = getField(pC, \"f1\");\n+        checkEntries(f1,\n+                \"Entry[name=mA\/p.C#f1,uri=http:\/\/openjdk.java.net\/jeps\/0,description=JEP 0,recursive=false]\");\n+        VariableElement f2 = getField(pC, \"f2\");\n+        checkEntries(f2);\n+\n+        ExecutableElement m1_int = getMethod(pC, \"m1\", \"int\");\n+        checkEntries(m1_int,\n+                \"Entry[name=mA\/p.C#m1(int),uri=http:\/\/openjdk.java.net\/jeps\/0,description=JEP 0,recursive=false]\");\n+\n+        ExecutableElement m1_String = getMethod(pC, \"m1\", \"java.lang.String\");\n+        checkEntries(m1_String);\n+        checkEntries(f2);\n+\n+        ExecutableElement m2_int = getMethod(pC, \"m2\", \"int\");\n+        checkEntries(m2_int);\n+    }\n+\n+    @Test\n+    public void testBadLine() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        String text = \"\"\"\n+                # this is a comment\n+\n+                http:jeps\/0 JEP 0\n+                  m\/p\/C stuff\n+                \"\"\";\n+        readNotes(base, text);\n+        checkError(\"notes.txt:4: bad line:   m\/p\/C stuff\");\n+    }\n+\n+    @Test\n+    public void testBadSignature() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        String text = \"\"\"\n+                # this is a comment\n+\n+                http:jeps\/0 JEP 0\n+                  m\/p\/C\n+                \"\"\";\n+        readNotes(base, text);\n+        checkError(\"notes.txt:4: bad signature: m\/p\/C\");\n+    }\n+\n+    @Test\n+    public void testBadURI() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        String text = \"\"\"\n+                # this is a comment\n+\n+                http: JEP 0\n+                  m\/p.C\n+                \"\"\";\n+        readNotes(base, text);\n+        checkError(\"notes.txt:3: bad uri: http:\");\n+    }\n+\n+    @Test\n+    public void testNoCurrentURI() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        String text = \"\"\"\n+                # this is a comment\n+\n+                  m\/p.C\n+                \"\"\";\n+        readNotes(base, text);\n+        checkError(\"notes.txt:3: no current URI and description\");\n+    }\n+\n+    @Test\n+    public void testModule() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        Path notes = base.resolve(\"notes.txt\");\n+        Files.writeString(notes,\"\"\"\n+                http:\/\/example.com\/module example-module-A\n+                  mA\n+                http:\/\/example.com\/module example-module-B\n+                  mB\n+                \"\"\");\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            for (int m = 0; m <= a; m++) {\n+                new ModuleBuilder(tb, \"m%m%\".replace(\"%m%\", String.valueOf((char) ('A' + m))))\n+                        .exports(\"p%m%\".replace(\"%m%\", String.valueOf(m)))\n+                        .classes(\"package p%m%; public class C%m% { }\\n\".replace(\"%m%\", String.valueOf(m)))\n+                        .write(apiDir);\n+            }\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--notes\", notes.toString(),\n+                \"--include\", \"mA\/**\",\n+                \"--include\", \"mB\/**\",\n+                \"--include\", \"mC\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    @Test\n+    public void testPackage() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        Path notes = base.resolve(\"notes.txt\");\n+        Files.writeString(notes, \"\"\"\n+                http:\/\/example.com\/module example-module-A\n+                  mA\/*\n+                http:\/\/example.com\/module example-module-A-p0\n+                  mA\/p0\n+                http:\/\/example.com\/module example-module-B\n+                  mB\/*\n+                \"\"\");\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            for (int m = 0; m <= a; m++) {\n+                new ModuleBuilder(tb, \"m%m%\".replace(\"%m%\", String.valueOf((char) ('A' + m))))\n+                        .exports(\"p%m%\".replace(\"%m%\", String.valueOf(m)))\n+                        .classes(\"package p%m%; public class C%m% { }\\n\".replace(\"%m%\", String.valueOf(m)))\n+                        .write(apiDir);\n+            }\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--notes\", notes.toString(),\n+                \"--include\", \"mA\/**\",\n+                \"--include\", \"mB\/**\",\n+                \"--include\", \"mC\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    @Test\n+    public void testMethod() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        Path notes = base.resolve(\"notes.txt\");\n+        Files.writeString(notes, \"\"\"\n+                http:\/\/example.com\/module example-module-A\n+                  mA\/*\n+                http:\/\/example.com\/module example-module-A-p0\n+                  mA\/p0\n+                http:\/\/example.com\/module example-module-A-p0-C0-m\n+                  mA\/p0.C0#m()\n+                http:\/\/example.com\/module example-module-B\n+                  mB\/*\n+                \"\"\");\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            for (int m = 0; m <= a; m++) {\n+                new ModuleBuilder(tb, \"m%m%\".replace(\"%m%\", String.valueOf((char) ('A' + m))))\n+                        .exports(\"p%m%\".replace(\"%m%\", String.valueOf(m)))\n+                        .classes(\"package p%m%; public class C%m% { public void m() { } }\\n\".replace(\"%m%\", String.valueOf(m)))\n+                        .write(apiDir);\n+            }\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--notes\", notes.toString(),\n+                \"--include\", \"mA\/**\",\n+                \"--include\", \"mB\/**\",\n+                \"--include\", \"mC\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    @Test\n+    public void testConstructor() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+        Path notes = base.resolve(\"notes.txt\");\n+        Files.writeString(notes, \"\"\"\n+                http:\/\/example.com\/module example-module-A\n+                  mA\/*\n+                http:\/\/example.com\/module example-module-A-p0\n+                  mA\/p0\n+                http:\/\/example.com\/module example-module-A-p0-C0-init\n+                  mA\/p0.C0#<init>()\n+                http:\/\/example.com\/module example-module-B\n+                  mB\/*\n+                \"\"\");\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            for (int m = 0; m <= a; m++) {\n+                new ModuleBuilder(tb, \"m%m%\".replace(\"%m%\", String.valueOf((char) ('A' + m))))\n+                        .exports(\"p%m%\".replace(\"%m%\", String.valueOf(m)))\n+                        .classes(\"package p%m%; public class C%m% { public C%m%() { } }\\n\".replace(\"%m%\", String.valueOf(m)))\n+                        .write(apiDir);\n+            }\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--notes\", notes.toString(),\n+                \"--include\", \"mA\/**\",\n+                \"--include\", \"mB\/**\",\n+                \"--include\", \"mC\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    private String notesErr;\n+    private Notes notes;\n+\n+    private void readNotes(Path base, String text) throws IOException {\n+        Path file = writeNotes(base.resolve(\"notes.txt\"), text);\n+        StringWriter notesOutSW = new StringWriter();\n+        StringWriter notesErrSW = new StringWriter();\n+        Log log = new Log(new PrintWriter(notesOutSW), new PrintWriter(notesErrSW));\n+        try {\n+            notes = Notes.read(file, log);\n+        } finally {\n+            String notesOut = notesOutSW.toString();\n+            if (!notesOut.isEmpty()) {\n+                NotesTest.this.log.println(\"out:\\n\" + notesOut);\n+            }\n+            notesErr = notesErrSW.toString();\n+            if (!notesErr.isEmpty()) {\n+                NotesTest.this.log.println(\"err:\\n\" + notesErr);\n+            }\n+        }\n+    }\n+\n+\n+    private void checkEntries(Element e, String... expect) {\n+        log.println(\"Check entries for \" + e);\n+        Objects.requireNonNull(e);\n+        ElementKey eKey = ElementKey.of(e);\n+        Set<Entry> entries = notes.getEntries(eKey).keySet();\n+        Set<String> found = entries.stream().map(Notes.Entry::toString).collect(Collectors.toSet());\n+        Assertions.assertEquals(Set.of(expect), found);\n+    }\n+\n+    private void checkError(String msg) {\n+        if (!notesErr.contains(msg)) {\n+            Assertions.fail(\"expected message not found: \" + msg);\n+        }\n+    }\n+\n+    private Path writeNotes(Path file, String text) throws IOException {\n+        Files.createDirectories((file.getParent()));\n+        Files.writeString(file, text);\n+        return file;\n+    }\n+\n+    VariableElement getField(TypeElement te, String name) {\n+        return te.getEnclosedElements().stream()\n+                .filter(e -> e.getKind() == ElementKind.FIELD && e.getSimpleName().contentEquals(name))\n+                .map(e -> (VariableElement) e)\n+                .findFirst()\n+                .orElse(null);\n+    }\n+\n+    ExecutableElement getMethod(TypeElement te, String name, String... paramTypes) {\n+        return te.getEnclosedElements().stream()\n+                .filter(e -> e.getKind() == ElementKind.METHOD\n+                        && e.getSimpleName().contentEquals(name))\n+                .map(e -> (ExecutableElement) e)\n+                .filter(e -> hasParams(e, paramTypes))\n+                .findFirst()\n+                .orElse(null);\n+    }\n+\n+    private boolean hasParams(ExecutableElement e, String... paramTypes) {\n+        List<String> et = e.getParameters().stream()\n+                .map(p -> p.asType().toString())\n+                .collect(Collectors.toList());\n+        return Objects.equals(List.of(paramTypes), et);\n+    }\n+}\n","filename":"test\/junit\/apitest\/NotesTest.java","additions":450,"deletions":0,"binary":false,"changes":450,"status":"added"},{"patch":"@@ -0,0 +1,262 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+import toolbox.JavadocTask;\n+import toolbox.ModuleBuilder;\n+import toolbox.Task;\n+\n+\/**\n+ * Tests for the ability to compare packages.\n+ *\/\n+public class PackageTest extends APITester {\n+    \/**\n+     * Tests handling of missing packages.\n+     * Three APIs are generated.\n+     * <ul>\n+     * <li>all APIs contain equal definitions of package p1\n+     * <li>two APIs contain equal definitions of package p2\n+     * <li>only one API contains a definition of package p3\n+     * <\/ul>\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testMissingPackages() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 3;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            for (int p = 0; p <= a; p++) {\n+                tb.writeJavaFiles(apiDir,\n+                        \"package p.p%p%; public class C%p% { }\\n\".replace(\"%p%\", String.valueOf(p)));\n+            }\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"-XDshow-debug-summary\",\n+                \"-XDtrace-reporter\",\n+                \"--include\", \"p.**\",\n+                \"-d\", base.resolve(\"out\").toString(),\n+                \"--verbose\", \"missing\"));\n+\n+        log.println(\"Options: \" + options);\n+        \/\/ TODO: Main needs resource for bad option\n+        \/\/ TODO: Main needs to check for output dir\n+        \/\/ TODO: handle compilation errors in source\n+        Map<OutputKind,String> outMap = run(options);\n+        long notFound = outMap.get(OutputKind.ERR).lines()\n+                .filter(l -> l.contains(\"Item not found\"))\n+                .count();\n+        Assertions.assertEquals(3, notFound);\n+    }\n+\n+    \/**\n+     * Tests handling of missing packages.\n+     * Three APIs are generated, all containing module mA\n+     * <ul>\n+     * <li>all APIs contain equal definitions of package p1\n+     * <li>two APIs contain equal definitions of package p2\n+     * <li>only one API contains a definition of package p3\n+     * <\/ul>\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testMissingPackagesInModules() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 3;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            ModuleBuilder mb = new ModuleBuilder(tb, \"mA\");\n+            for (int p = 0; p <= a; p++) {\n+                mb.classes(\"package p%p%; public class C%p% { }\\n\".replace(\"%p%\", String.valueOf(p)));\n+            }\n+            mb.write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString(),\n+                    \"--access\", \"private\"));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString(),\n+                \"--verbose\", \"missing\"));\n+\n+        log.println(\"Options: \" + options);\n+        \/\/ TODO: Main needs resource for bad option\n+        \/\/ TODO: Main needs to check for output dir\n+        \/\/ TODO: handle compilation errors in source\n+        Map<OutputKind,String> outMap = run(options);\n+        long notFound = outMap.get(OutputKind.ERR).lines()\n+                .filter(l -> l.contains(\"Item not found\"))\n+                .count();\n+        Assertions.assertEquals(3, notFound);\n+    }\n+\n+    \/**\n+     * Tests handling of different doc comments.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testRawDocComments() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            String cs = \"\/**\\n * This is 'p.same'.\\n * Unchanged.\\n * More.\\n **\/\\n\";\n+            String ci = \"\/**\\n * This is 'p.insert'.\\n\" + (a == 1 ? \" * Inserted.\\n\" : \"\") + \" * More.\\n **\/\\n\";\n+            String cr = \"\/**\\n * This is 'p.remove'.\\n\" + (a == 0 ? \" * Removed.\\n\" : \"\") + \" * More.\\n **\/\\n\";\n+            String cc = \"\/**\\n * This is 'p.change'.\\n * API \" + a + \"\\n * More.\\n **\/\\n\";\n+\n+            ModuleBuilder mb = new ModuleBuilder(tb, \"mA\");\n+            mb.classes(cs + \"package p.same;\\n\",\n+                    ci + \"package p.insert;\\n\",\n+                    cr + \"package p.remove;\\n\",\n+                    cc + \"package p.change;\\n\");\n+            mb.write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+\n+    }\n+\n+    @Test\n+    public void testPackageHtml() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            String cs = \"This is 'p.same'.\\nUnchanged.\\nMore.\\n\";\n+            String ci = \"This is 'p.insert'.\\n\" + (a == 1 ? \"Inserted.\\n\" : \"\") + \"More.\\n\";\n+            String cr = \"This is 'p.remove'.\\n\" + (a == 0 ? \" Removed.\\n\" : \"\") + \"More.\\n\";\n+            String cc = \"This is 'p.change'.\\nAPI \" + a + \"\\nMore.\\n\";\n+\n+            new ModuleBuilder(tb, \"m\")\n+                    .exports(\"p.same\")\n+                    .exports(\"p.insert\")\n+                    .exports(\"p.remove\")\n+                    .exports(\"p.change\")\n+                    .classes(\"package p.same; public class Same { }\\n\",\n+                            \"package p.insert; public class Insert { }\\n\",\n+                            \"package p.remove; public class Remove { }\\n\",\n+                            \"package p.change; public class Change { }\\n\")\n+                    .write(apiDir);\n+            writePackageHtml(apiDir, \"m\", \"p.same\",   cs);\n+            writePackageHtml(apiDir, \"m\", \"p.insert\", ci);\n+            writePackageHtml(apiDir, \"m\", \"p.remove\", cr);\n+            writePackageHtml(apiDir, \"m\", \"p.change\", cc);\n+\n+            Path api = base.resolve(apiName).resolve(\"api\");\n+            Files.createDirectories(api);\n+            List<String> javadocOptions = List.of(\n+                    \"-noindex\", \"-quiet\",\n+                    \"--module\", \"m\");\n+            Task.Result r = new JavadocTask(tb)\n+                    .sourcepath(apiDir.resolve(\"m\"))\n+                    .outdir(api)\n+                    .options(javadocOptions)\n+                    .run();\n+            r.writeAll();\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--api-directory\", api.toString(),\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"m\/**\",\n+                \"--compare-doc-comments\", \"yes\",\n+                \"--compare-api-descriptions\", \"yes\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    private void writePackageHtml(Path dir, String mName, String pName, String body)\n+            throws IOException {\n+        tb.writeFile(dir.resolve(mName)\n+                .resolve(pName.replace(\".\", File.separator))\n+                .resolve(\"package.html\"),\n+                \"<!DOCTYPE html>\\n\"\n+                        + \"<html>\\n\"\n+                        + \"<title>pName<\/title>\\n\"\n+                        + \"<body>\\n\"\n+                        + body\n+                        + \"\\n<\/body>\\n\"\n+                        + \"<\/html>\\n\");\n+    }\n+}\n","filename":"test\/junit\/apitest\/PackageTest.java","additions":262,"deletions":0,"binary":false,"changes":262,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+\n+public class RecordTest extends APITester {\n+    final Runtime.Version version;\n+    final boolean enablePreview;\n+\n+    RecordTest() {\n+        version = Runtime.version();\n+        Assumptions.assumeTrue(version.feature() >= 14, \"records not supported in JDK \" + version);\n+\n+        enablePreview = switch (version.feature()) {\n+            case 14, 15 -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    @Test\n+    public void changeKind() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        Path srcA = Files.createDirectories(base.resolve(\"srcA\"));\n+        tb.writeJavaFiles(srcA, \"\"\"\n+                package p;\n+                public class C {\n+                    private final int c;\n+                    public C(int c) { this.c = c; }\n+                    public int c() { return c; }\n+                }\"\"\");\n+\n+        Path srcB = Files.createDirectories(base.resolve(\"srcB\"));\n+        tb.writeJavaFiles(srcB, \"\"\"\n+                package p;\n+                public record C(int c) {\n+                }\"\"\");\n+\n+        Map<OutputKind,String> outMap = run(base, srcA, srcB);\n+        long differences = outMap.get(OutputKind.ERR).lines()\n+                .filter(l -> l.contains(\"Different\"))\n+                .count();\n+        Assertions.assertEquals(3, differences);\n+\n+    }\n+\n+    @Test\n+    public void changeNames() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        Path srcA = Files.createDirectories(base.resolve(\"srcA\"));\n+        tb.writeJavaFiles(srcA, \"\"\"\n+                package p;\n+                public record C(int c1) {\n+                }\"\"\");\n+\n+        Path srcB = Files.createDirectories(base.resolve(\"srcB\"));\n+        tb.writeJavaFiles(srcB, \"\"\"\n+                package p;\n+                public record C(int c2) {\n+                }\"\"\");\n+\n+        Map<OutputKind,String> outMap = run(base, srcA, srcB);\n+        List<String> found = outMap.get(OutputKind.ERR).lines()\n+                .filter(l -> l.contains(\"Item not found\") | l.contains(\"Different\"))\n+                .sorted()\n+                .collect(Collectors.toList());\n+\n+        List<String> expect = List.of(\n+                \"Different names for record p.C, record component 0\",\n+                \"Item not found in API 'A': method p.C#c2()\",\n+                \"Item not found in API 'B': method p.C#c1()\"\n+        );\n+\n+        tb.checkEqual(expect, found);\n+    }\n+\n+    @Test\n+    public void changeType() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        Path srcA = Files.createDirectories(base.resolve(\"srcA\"));\n+        tb.writeJavaFiles(srcA, \"\"\"\n+                package p;\n+                public record C(int c) {\n+                }\"\"\");\n+\n+        Path srcB = Files.createDirectories(base.resolve(\"srcB\"));\n+        tb.writeJavaFiles(srcB, \"\"\"\n+                package p;\n+                public record C(long c) {\n+                }\"\"\");\n+\n+        Map<OutputKind,String> outMap = run(base, srcA, srcB);\n+        List<String> found = outMap.get(OutputKind.ERR).lines()\n+                .filter(l -> l.contains(\"Item not found\") || l.contains(\"Different\"))\n+                .sorted()\n+                .collect(Collectors.toList());\n+\n+        List<String> expect = List.of(\n+                \"Different types for method p.C#c() return type\",\n+                \"Different types for record p.C, record component 0\",\n+                \"Item not found in API 'A': constructor p.C#C(long)\",\n+                \"Item not found in API 'B': constructor p.C#C(int)\"\n+        );\n+\n+        tb.checkEqual(expect, found);\n+    }\n+\n+    @Test\n+    public void addComponent() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        Path srcA = Files.createDirectories(base.resolve(\"srcA\"));\n+        tb.writeJavaFiles(srcA, \"\"\"\n+                package p;\n+                public record C(int c1) {\n+                }\"\"\");\n+\n+        Path srcB = Files.createDirectories(base.resolve(\"srcB\"));\n+        tb.writeJavaFiles(srcB, \"\"\"\n+                package p;\n+                public record C(int c1, int c2) {\n+                }\"\"\");\n+\n+        Map<OutputKind,String> outMap = run(base, srcA, srcB);\n+        List<String> found = outMap.get(OutputKind.ERR).lines()\n+                .filter(l -> l.contains(\"Item not found\"))\n+                .sorted()\n+                .collect(Collectors.toList());\n+\n+        List<String> expect = List.of(\n+                \"Item not found in API 'A': constructor p.C#C(int,int)\",\n+                \"Item not found in API 'A': method p.C#c2()\",\n+                \"Item not found in API 'A': record p.C, record component 1\",\n+                \"Item not found in API 'B': constructor p.C#C(int)\"\n+        );\n+\n+        tb.checkEqual(expect, found);\n+    }\n+\n+    private Map<OutputKind,String> run(Path base, Path srcA, Path srcB) {\n+\n+        List<String> options = new ArrayList<>();\n+        for (String api : List.of(\"A\", \"B\")) {\n+            options.addAll(List.of(\n+                    \"--api\", api,\n+                    \"--source-path\", (api.equals(\"A\") ? srcA : srcB).toString()));\n+            if (enablePreview) {\n+                options.add(\"--enable-preview\");\n+                options.addAll(List.of(\"--source\", String.valueOf(version.feature())));\n+            }\n+        }\n+\n+        options.addAll(List.of(\n+                \"--include\", \"p.*\",\n+                \"-d\",  base.resolve(\"out\").toString(),\n+                \"--verbose\", \"differences,missing\"));\n+\n+        log.println(\"Options: \" + options);\n+\n+        return run(options);\n+    }\n+\n+}\n","filename":"test\/junit\/apitest\/RecordTest.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+import toolbox.JavadocTask;\n+\n+public class ResourceFileTest extends APITester {\n+\n+    @Test\n+    public void testSingleFile() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        Path srcA = setup(base, \"A\", \"\", \"test-resource-files\/test.txt\");\n+        Path srcB = setup(base, \"B\", \"public void m() { }\");\n+\n+        Path out = base.resolve(\"out\");\n+\n+        Map<OutputKind,String> outMap = run(base,\n+                srcA, base.resolve(\"apiA\"),\n+                srcB, base.resolve(\"apiB\"),\n+                out,\n+                \"--resource-files\", \"test-resource-files\/test.txt\");\n+\n+        List<String> found = outMap.get(OutputKind.ERR).lines()\n+                .filter(l -> l.contains(\"Item not found\") | l.contains(\"Different\"))\n+                .sorted().toList();\n+\n+        checkResourceFiles(out, \"test-resource-files\/test.txt\");\n+    }\n+\n+    @Test\n+    public void testDirectory() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        Path srcA = setup(base, \"A\", \"\",\n+                \"test-resource-files\/test1.txt\",\n+                \"test-resource-files\/test2.txt\");\n+        Path srcB = setup(base, \"B\", \"public void m() { }\");\n+\n+        Path out = base.resolve(\"out\");\n+\n+        Map<OutputKind,String> outMap = run(base,\n+                srcA, base.resolve(\"apiA\"),\n+                srcB, base.resolve(\"apiB\"),\n+                out,\n+                \"--resource-files\", \"test-resource-files\");\n+\n+        List<String> found = outMap.get(OutputKind.ERR).lines()\n+                .filter(l -> l.contains(\"Item not found\") | l.contains(\"Different\"))\n+                .sorted().toList();\n+\n+        checkResourceFiles(out,\n+                \"test-resource-files\/test1.txt\",\n+                \"test-resource-files\/test2.txt\");\n+    }\n+\n+    @Test\n+    public void testStandard() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        Path srcA = setup(base, \"A\", \"\",\n+                \"test.svg\",\n+                \"testA.svg\",\n+                \"resource-files\/test.txt\",\n+                \"resource-files\/testA.txt\");\n+        Path srcB = setup(base, \"B\", \"public void m() { }\",\n+                \"test.svg\",\n+                \"testB.svg\",\n+                \"resource-files\/test.txt\",\n+                \"resource-files\/testB.txt\");\n+\n+        Path out = base.resolve(\"out\");\n+\n+        Map<OutputKind,String> outMap = run(base,\n+                srcA, base.resolve(\"apiA\"),\n+                srcB, base.resolve(\"apiB\"),\n+                out);\n+\n+        List<String> found = outMap.get(OutputKind.ERR).lines()\n+                .filter(l -> l.contains(\"Item not found\") | l.contains(\"Different\"))\n+                .sorted().toList();\n+\n+        String FS = File.separator;\n+        Predicate<String> apiA = s -> s.contains(FS + \"apiA\" + FS);\n+        Predicate<String> apiB = s -> s.contains(FS + \"apiB\" + FS);\n+\n+        checkResourceFiles(out,\n+                new RFInfo(\"test.svg\", apiB),\n+                new RFInfo(\"testA.svg\", apiA),\n+                new RFInfo(\"testB.svg\", apiB),\n+                new RFInfo(\"resource-files\/test.txt\", apiB),\n+                new RFInfo(\"resource-files\/testA.txt\", apiA),\n+                new RFInfo(\"resource-files\/testB.txt\", apiB));\n+\n+    }\n+\n+    Path setup(Path base, String id, String s, String... resFiles) throws IOException {\n+        Path src = base.resolve(\"src\" + id);\n+        tb.writeJavaFiles(src,\n+                \"package p;\\n\"\n+                        + \"public class C{\\n\"\n+                        + s + \"\\n\"\n+                        + \"}\");\n+        Path api = base.resolve(\"api\" + id);\n+        javadoc(src, api);\n+        for (var resFile : resFiles) {\n+            addResourceFile(api, Path.of(resFile));\n+        }\n+        return src;\n+    }\n+\n+    private void javadoc(Path src, Path out) throws IOException {\n+        Files.createDirectories(out);\n+        JavadocTask t = new JavadocTask(tb);\n+        t.sourcepath(src)\n+                .outdir(out)\n+                .options(\"-quiet\", \"p\")\n+                .run()\n+                .writeAll();\n+    }\n+\n+    private void addResourceFile(Path api, Path resFile) throws IOException {\n+        var p = api.resolve(resFile);\n+        Files.createDirectories(p.getParent());\n+        Files.writeString(p, \"dummy resource: \" + p);\n+    }\n+\n+    private void checkResourceFiles(Path out, String... files) {\n+        for (String s : files) {\n+            if (Files.exists(out.resolve(s))) {\n+                log.println(\"found \" + s);\n+            } else {\n+                Assertions.fail(\"resource file not found: \" + s);\n+            }\n+        }\n+    }\n+\n+    private record RFInfo(String file, Predicate<String> test) { }\n+    private void checkResourceFiles(Path out, RFInfo... infos) {\n+        for (var info : infos) {\n+            if (Files.exists(out.resolve(info.file))) {\n+                try {\n+                    String s = Files.readString(out.resolve(info.file));\n+                    Assertions.assertTrue(info.test.test(s), \"found \" + info.file + \" but failed check\");\n+                } catch (IOException e) {\n+                    Assertions.fail(\"exception \" + e);\n+                }\n+            } else {\n+                Assertions.fail(\"resource file not found: \" + info.file);\n+            }\n+        }\n+    }\n+\n+    private Map<OutputKind,String> run(Path base, Path srcA, Path apiA, Path srcB, Path apiB, Path out, String...opts) {\n+\n+        List<String> options = new ArrayList<>();\n+        for (String api : List.of(\"A\", \"B\")) {\n+            options.addAll(List.of(\n+                    \"--api\", api,\n+                    \"--source-path\", (api.equals(\"A\") ? srcA : srcB).toString(),\n+                    \"--api-directory\", (api.equals(\"A\") ? apiA : apiB).toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"--include\", \"p.*\",\n+                \"-d\",  out.toString()));\n+        options.addAll(List.of(opts));\n+\n+        log.println(\"Options: \" + options);\n+\n+        return run(options);\n+    }\n+}\n","filename":"test\/junit\/apitest\/ResourceFileTest.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+\n+public class SealedTest extends APITester {\n+    final Runtime.Version version;\n+    final boolean enablePreview;\n+\n+    SealedTest() {\n+        version = Runtime.version();\n+        Assumptions.assumeTrue(version.feature() >= 15, \"sealed classes not supported in JDK \" + version);\n+\n+        enablePreview = switch (version.feature()) {\n+            case 15, 16 -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    @Test\n+    public void addSealedModifier() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        Path srcA = Files.createDirectories(base.resolve(\"srcA\"));\n+        tb.writeJavaFiles(srcA, \"\"\"\n+                package p; public class C {\n+                    public class C1 { }\n+                    public final class C2 extends C1 { }\n+                }\"\"\");\n+\n+        Path srcB = Files.createDirectories(base.resolve(\"srcB\"));\n+        tb.writeJavaFiles(srcB, \"\"\"\n+                package p; public class C {\n+                    public sealed class C1 { }\n+                    public final class C2 extends C1 { }\n+                }\"\"\");\n+\n+        Map<OutputKind,String> outMap = run(base, srcA, srcB, getClassMethodName());\n+        long differences = outMap.get(OutputKind.ERR).lines()\n+                .filter(l -> l.contains(\"Different\"))\n+                .count();\n+        Assertions.assertEquals(3, differences);\n+\n+    }\n+\n+    @Test\n+    public void addNonSealedModifier() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        Path srcA = Files.createDirectories(base.resolve(\"srcA\"));\n+        tb.writeJavaFiles(srcA, \"\"\"\n+                package p; public class C {\n+                    public sealed class C1 { }\n+                    public final class C2 extends C1 { }\n+                }\"\"\");\n+\n+        Path srcB = Files.createDirectories(base.resolve(\"srcB\"));\n+        tb.writeJavaFiles(srcB, \"\"\"\n+                package p; public class C {\n+                    public sealed class C1 { }\n+                    public non-sealed class C2 extends C1 { }\n+                }\"\"\");\n+\n+        Map<OutputKind,String> outMap = run(base, srcA, srcB, getClassMethodName());\n+        long differences = outMap.get(OutputKind.ERR).lines()\n+                .filter(l -> l.contains(\"Different\"))\n+                .count();\n+        Assertions.assertEquals(1, differences);\n+\n+    }\n+\n+    @Test\n+    public void addPermits() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        Path srcA = Files.createDirectories(base.resolve(\"srcA\"));\n+        tb.writeJavaFiles(srcA, \"\"\"\n+                package p; public class C {\n+                    public sealed class C1 { }\n+                    public final class C2 extends C1 { }\n+                }\"\"\");\n+\n+        Path srcB = Files.createDirectories(base.resolve(\"srcB\"));\n+        tb.writeJavaFiles(srcB, \"\"\"\n+                package p; public class C {\n+                    public sealed class C1 permits C2 { }\n+                    public final class C2 extends C1 { }\n+                }\"\"\");\n+\n+        Map<OutputKind,String> outMap = run(base, srcA, srcB, getClassMethodName());\n+        long differences = outMap.get(OutputKind.ERR).lines()\n+                .filter(l -> l.contains(\"Different\"))\n+                .count();\n+        Assertions.assertEquals(0, differences);\n+\n+    }\n+\n+    @Test\n+    public void changePermits() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        Path srcA = Files.createDirectories(base.resolve(\"srcA\"));\n+        tb.writeJavaFiles(srcA, \"\"\"\n+                package p; public class C {\n+                    public sealed class C1 permits C2 { }\n+                    public final class C2 extends C1 { }\n+                    public final class C3 { }\n+                }\"\"\");\n+\n+        Path srcB = Files.createDirectories(base.resolve(\"srcB\"));\n+        tb.writeJavaFiles(srcB, \"\"\"\n+                package p; public class C {\n+                    public sealed class C1 permits C3 { }\n+                    public final class C2 { }\n+                    public final class C3 extends C1 { }\n+                }\"\"\");\n+\n+        Map<OutputKind,String> outMap = run(base, srcA, srcB, getClassMethodName());\n+        long differences = outMap.get(OutputKind.ERR).lines()\n+                .filter(l -> l.contains(\"Different\"))\n+                .count();\n+        Assertions.assertEquals(5, differences);\n+\n+    }\n+\n+    private Map<OutputKind,String> run(Path base, Path srcA, Path srcB, String description) {\n+\n+        List<String> options = new ArrayList<>();\n+        for (String api : List.of(\"A\", \"B\")) {\n+            options.addAll(List.of(\n+                    \"--api\", api,\n+                    \"--source-path\", (api.equals(\"A\") ? srcA : srcB).toString()));\n+            if (enablePreview) {\n+                options.add(\"--enable-preview\");\n+                options.addAll(List.of(\"--source\", String.valueOf(version.feature())));\n+            }\n+        }\n+\n+        options.addAll(List.of(\n+                \"--description\", description,\n+                \"--include\", \"p.*\",\n+                \"-d\",  base.resolve(\"out\").toString(),\n+                \"--verbose\", \"differences,missing\"));\n+\n+        log.println(\"Options: \" + options);\n+\n+        return run(options);\n+    }\n+\n+}\n","filename":"test\/junit\/apitest\/SealedTest.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import jdk.codetools.apidiff.model.Selector;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class SelectorTest {\n+\n+    public static Stream<Arguments> provideCases() {\n+        \/\/ The names here are just example strings; they are not interpreted as actual element names\n+        return Stream.of(\n+                Arguments.of(\n+                    \/\/ module, all packages and types in the module; no excludes\n+                    List.of(\"java.base\/**\"),\n+                    List.of(),\n+                    Map.of(\"java.base\/java.lang\", true,\n+                            \"java.base\/java.lang.String\", true,\n+                            \"java.se\/java.io.IOException\", false)\n+                ),\n+                Arguments.of(\n+                    \/\/ module, one package; no excludes\n+                    List.of(\"java.base\/java.lang.*\"),\n+                    List.of(),\n+                    Map.of(\"java.base\/java.lang\", true,\n+                            \"java.base\/java.lang.String\", true,\n+                            \"java.base\/java.lang.reflect.Method\", false,\n+                            \"java.base\/java.util.Map\", false,\n+                            \"java.se\/java.io.IOException\", false)\n+                ),\n+                Arguments.of(\n+                    \/\/ module, all packages and types in the module; subpackage excluded\n+                    List.of(\"java.base\/**\"),\n+                    List.of(\"java.base\/java.lang.reflect.*\"),\n+                    Map.of(\"java.base\/java.lang.String\", true,\n+                            \"java.lang.String\", false,\n+                            \"java.base\/java.lang.reflect.Method\", false,\n+                            \"java.se\/java.io.IOException\", false)\n+                ),\n+                Arguments.of(\n+                        List.of(\"java.lang.**\"),\n+                        List.of(\"java.lang.reflect.*\"),\n+                        Map.of(\"java.base\/java.lang.String\", false,\n+                                \"java.lang.String\", true,\n+                                \"java.lang.reflect.Method\", false,\n+                                \"java.se.IOException\", false)\n+                )\n+        );\n+    }\n+\n+    \/\/ optional module, package, optional capitalized type\n+    Pattern pattern = Pattern.compile(\"((?<m>[A-Za-z0-9.]+)\/)?(?<p>[a-z0-9.]+)(\\\\.(?<t>[A-Z][A-Za-z0-9.]*))?\");\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideCases\")\n+    public void test(List<String> includes, List<String> excludes, Map<String, Boolean> cases) {\n+        System.out.println(\"includes: \" + includes);\n+        System.out.println(\"excludes: \" + excludes);\n+        Selector s = new Selector(includes, excludes);\n+        boolean ok = true;\n+        for (var e : cases.entrySet()) {\n+            String c = e.getKey();\n+            boolean expect = e.getValue();\n+\n+            Matcher m = pattern.matcher(c);\n+            if (!m.matches()) {\n+                throw new IllegalArgumentException(c);\n+            }\n+\n+            String mdl = m.group(\"m\");\n+            String pkg = m.group(\"p\");\n+            String typ = m.group(\"t\");\n+            System.out.println(\"  m:\" + mdl + \" p:\" + pkg + \" t:\" + typ);\n+\n+            boolean found = typ == null\n+                    ? s.acceptsPackage(mdl, pkg)\n+                    : s.acceptsType(mdl, pkg, typ);\n+            if (found == expect) {\n+                System.out.println(\"  OK\");\n+            } else {\n+                System.out.println(\"  expect: \" + expect + \", found: \" + found);\n+                ok = false;\n+            }\n+        }\n+        Assertions.assertTrue(ok);\n+    }\n+}\n","filename":"test\/junit\/apitest\/SelectorTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+import toolbox.JavadocTask;\n+import toolbox.ModuleBuilder;\n+import toolbox.Task;\n+\n+public class SerialCommentsTest  extends APITester {\n+    @Test\n+    public void testSerialVersionUID() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        test(base, i ->\n+                \"private static final long serialVersionUID = \" + ((i == 0) ? \"123L\" : \"456L\") + \";\\n\");\n+    }\n+\n+    @Test\n+    public void testOverview() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        test(base, i ->\n+                \"\/**\\n\"\n+                + \" * This is \" + ((i == 0) ? \"a\" : \"an updated\") + \" overview.\\n\"\n+                + \" *\/\\n\"\n+                + \"private static final ObjectStreamField[] serialPersistentFields = null;\\n\");\n+    }\n+\n+    @Test\n+    public void testDefaultField() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        test(base, i ->\n+                \"\/**\\n\"\n+                + \" * This is \" + ((i == 0) ? \"a\" : \"an updated\") + \" field.\\n\"\n+                + \"*\/\\n\"\n+                + \"private int i;\\n\");\n+    }\n+\n+    @Test\n+    public void testSerialPersistentField() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        test(base, i ->\n+                \"\/**\\n\"\n+                + \" * @serialField i int This is \" + ((i == 0) ? \"a\" : \"an updated\") + \" field.\\n\"\n+                + \" *\/\\n\"\n+                + \"private static final ObjectStreamField[] serialPersistentFields = null;\\n\");\n+    }\n+\n+    @Test\n+    public void testMethod() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        test(base, i ->\n+                \"\/**\\n\"\n+                + \" * This is \" + ((i == 0) ? \"a\" : \"an updated\") + \" method.\\n\"\n+                + \" * @param in the input stream\"\n+                + \"*\/\\n\"\n+                + \"private void readObject(ObjectInputStream in) { }\\n\");\n+\n+    }\n+\n+    private void test(Path base, Function<Integer, String> f) throws IOException {\n+        List<String> options = new ArrayList<>();\n+\n+        for (int i = 0; i < 2; i++) {\n+            String apiName = \"api\" + i;\n+            Path src = base.resolve(apiName).resolve(\"src\");\n+\n+            String mods = (i == 0) ? \"public\" : \"protected\";\n+            new ModuleBuilder(tb, \"m\")\n+                    .exports(\"p\")\n+                    .classes(\"package p;\\n\"\n+                            + \"import java.io.*;\\n\"\n+                            + \"public class C implements Serializable {\\n\"\n+                            + f.apply(i)\n+                            + \"}\\n\")\n+                    .write(src);\n+\n+            Path api = base.resolve(apiName).resolve(\"api\");\n+            Files.createDirectories(api);\n+            Task.Result r = new JavadocTask(tb)\n+                    .sourcepath(src.resolve(\"m\"))\n+                    .outdir(api)\n+                    .options(\"-noindex\", \"-quiet\", \"--module\", \"m\")\n+                    .run();\n+            r.writeAll();\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", src.toString(),\n+                    \"--api-directory\", api.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+\n+    }\n+}\n","filename":"test\/junit\/apitest\/SerialCommentsTest.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import apitest.lib.APITester;\n+import toolbox.ModuleBuilder;\n+\n+public class SerialFieldsTest extends APITester {\n+\n+    public static Stream<Arguments> provideSimpleFields() {\n+        return Stream.of(\n+                Arguments.of(\"none\", \"\", \"\"),\n+                Arguments.of(\"add\",  \"\", \"int i;\"),\n+                Arguments.of(\"remove\", \"int i;\", \"\"),\n+                Arguments.of(\"changeName\", \"int i;\", \"int j;\"), \/\/ effectively, delete and add\n+                Arguments.of(\"changeType\", \"int i;\", \"long i;\"),\n+                Arguments.of(\"changeMods1\", \"private int i;\", \"public int i;\"),\n+                Arguments.of(\"changeMods2\", \"int i;\", \"static int i;\") \/\/ effectively, delete\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideSimpleFields\")\n+    public void testSimpleFields(String name, String api0, String api1) throws IOException {\n+        log.printf(\"Test %s: %s | %s%n\", name, api0, api1);\n+        Path base = getScratchDir(name);\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        for (int api = 0; api < 2; api++) {\n+            String apiName = \"api\" + api;\n+            Path src = Files.createDirectories(base.resolve(apiName) .resolve(\"src\"));\n+            String s = \"package p;\\n\"\n+                    + \"import java.io.*;\\n\"\n+                    + \"public class C implements Serializable {\\n\"\n+                    + \"    \" + (api == 0 ? api0 : api1) + \"\\n\"\n+                    + \"}\\n\";\n+            new ModuleBuilder(tb, \"m\")\n+                    .exports(\"p\")\n+                    .classes(s)\n+                    .write(src);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", src.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        options.add(\"-XDshow-debug-summary\");\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    public static Stream<Arguments> provideDocComments() {\n+        return Stream.of(\n+                Arguments.of(\"changeMain\",\n+                        \"This is a comment\",\n+                        \"This is a different comment\"),\n+                Arguments.of(\"changeSerial\",\n+                        \"This is a comment.\\n@serial This is a description\",\n+                        \"This is a comment.\\n@serial This is a different description\"),\n+                Arguments.of(\"changeBoth\",\n+                        \"This is a comment.\\n@serial This is a description\",\n+                        \"This is a different comment.\\n@serial This is a different description\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideDocComments\")\n+    public void testDocComments(String name, String c0, String c1) throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        for (int api = 0; api < 2; api++) {\n+            String apiName = \"api\" + api;\n+            Path src = Files.createDirectories(base.resolve(apiName) .resolve(\"src\"));\n+            String s = \"package p;\\n\"\n+                    + \"import java.io.*;\\n\"\n+                    + \"public class C implements Serializable {\\n\"\n+                    + \"    \" + (api == 0 ? toComment(c0) : toComment(c1)) + \"\\n\"\n+                    + \"    int i;\\n\"\n+                    + \"}\\n\";\n+            new ModuleBuilder(tb, \"m\")\n+                    .exports(\"p\")\n+                    .classes(s)\n+                    .write(src);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", src.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        options.add(\"-XDshow-debug-summary\");\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    String toComment(String s) {\n+        return \"\/**\\n *\" + s.replace(\"\\n\", \"\\n *\") + \" *\/\";\n+    }\n+}\n","filename":"test\/junit\/apitest\/SerialFieldsTest.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import apitest.lib.APITester;\n+import toolbox.ModuleBuilder;\n+\n+public class SerialPersistentFieldsTest extends APITester {\n+\n+    public static Stream<Arguments> provideSingleFields() {\n+        return Stream.of(\n+                Arguments.of(\"boolean\"),\n+                Arguments.of(\"byte\"),\n+                Arguments.of(\"char\"),\n+                Arguments.of(\"double\"),\n+                Arguments.of(\"float\"),\n+                Arguments.of(\"int\"),\n+                Arguments.of(\"long\"),\n+                Arguments.of(\"short\"),\n+                Arguments.of(\"java.lang.Object\"),\n+                Arguments.of(\"java.util.Hashtable\"),\n+                Arguments.of(\"Object\"),\n+                Arguments.of(\"String\"),\n+                Arguments.of(\"Hashtable\"),\n+                Arguments.of(\"int[]\"),\n+                Arguments.of(\"String[]\"),\n+                Arguments.of(\"UNKNOWN\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideSingleFields\")\n+    public void testSingleFields(String type) throws IOException {\n+        String name = type.toLowerCase().replaceAll(\"[^A-Za-z0-9]+\", \"_\");\n+        log.printf(\"Test %s: %s%n\", name, type);\n+        Path base = getScratchDir(name);\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        for (int api = 0; api < 2; api++) {\n+            String apiName = \"api\" + api;\n+            Path src = Files.createDirectories(base.resolve(apiName) .resolve(\"src\"));\n+            String s = \"package p;\\n\"\n+                    + \"import java.io.*;\\n\"\n+                    + \"import java.util.*;\\n\"\n+                    + \"public class C implements Serializable {\\n\"\n+                    + \"    \/**\\n\"\n+                    + \"     * A field.\\n\"\n+                    + \"     * @serialField f \" + type + \" a description\\n\"\n+                    + \"     *\/\\n\"\n+                    + \"    private static final ObjectStreamField[] serialPersistentFields = { };\\n\"\n+                    + \"}\\n\";\n+            new ModuleBuilder(tb, \"m\")\n+                    .exports(\"p\")\n+                    .classes(s)\n+                    .write(src);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", src.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"--info-text\", \"header=\" + name,\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        options.add(\"-XDshow-debug-summary\");\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+\n+    }\n+}\n","filename":"test\/junit\/apitest\/SerialPersistentFieldsTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import apitest.lib.APITester;\n+import toolbox.ModuleBuilder;\n+\n+public class SerialVersionUIDTest extends APITester {\n+    enum Kind {\n+        IMPLICIT(null),\n+        DEFAULT(-6240593132596067277L),  \/\/ from serialver\n+        EXPLICIT(123L);\n+        final Long value;\n+        Kind(Long value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    public static Stream<Arguments> provideSUIDs() {\n+        List<Arguments> list = new ArrayList<>();\n+        for (Kind k1 : Kind.values()) {\n+            for (Kind k2 : Kind.values()) {\n+                list.add(Arguments.of(k1.name().toLowerCase() + \"-\" + k2.name().toLowerCase(), k1.value, k2.value));\n+            }\n+        }\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideSUIDs\")\n+    public void testSUIDs(String name, Long api0, Long api1) throws IOException {\n+        log.printf(\"Test %s: %s | %s%n\", name, api0, api1);\n+        Path base = getScratchDir(name);\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        for (int api = 0; api < 2; api++) {\n+            String apiName = \"api\" + api;\n+            Path src = Files.createDirectories(base.resolve(apiName) .resolve(\"src\"));\n+            Long v = (api == 0) ? api0 : api1;\n+            String f = v == null ? \"\" : \"    private static final long serialVersionUID = \" + v + \"L;\\n\";\n+            String c = \"package p;\\n\"\n+                    + \"import java.io.*;\\n\"\n+                    + \"public class C implements Serializable {\\n\"\n+                    + f\n+                    + \"    int i;\"\n+                    + \"}\\n\";\n+            new ModuleBuilder(tb, \"m\")\n+                    .exports(\"p\")\n+                    .classes(c)\n+                    .write(src);\n+            tb.writeJavaFiles(src, \"module m { exports p; }\", c);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", src.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        options.add(\"-XDshow-debug-summary\");\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+\n+    }\n+}\n","filename":"test\/junit\/apitest\/SerialVersionUIDTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.codetools.apidiff.Main;\n+\n+import org.junit.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import apitest.lib.APITester;\n+import toolbox.ModuleBuilder;\n+\n+public class SerializationMethodsTest extends APITester {\n+\n+    public static Stream<Arguments> getMethods() {\n+        return Stream.of(\n+                Arguments.of(\"none\", \"Serializable\", List.<String>of()),\n+                Arguments.of(\"serSingle\", \"Serializable\",\n+                        List.of(\"private void readObject(ObjectInputStream in) { }\")),\n+                Arguments.of(\"serMulti\", \"Serializable\",\n+                        List.of(\"private void readObject(ObjectInputStream in) { }\",\n+                                \"private Object readResolve() { return null; }\")),\n+                Arguments.of(\"extMin\", \"Externalizable\",\n+                        List.of(\"public void readExternal(ObjectInput in) { }\",\n+                                \"public void writeExternal(ObjectOutput out) { }\")),\n+                Arguments.of(\"extOpt\", \"Externalizable\",\n+                        List.of(\"public void readExternal(ObjectInput in) { }\",\n+                                \"public void writeExternal(ObjectOutput out) { }\",\n+                                \"private Object readResolve() { return null; }\"))\n+                );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getMethods\")\n+    public void testEqualMethods(String name, String intf, List<String> methods) throws IOException {\n+        log.printf(\"Test %s: %s %s%n\", name, intf, methods);\n+        Path base = getScratchDir(name);\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        for (int api = 0; api < 2; api++) {\n+            String apiName = \"api\" + api;\n+            Path src = Files.createDirectories(base.resolve(apiName) .resolve(\"src\"));\n+            String s = \"package p;\\n\"\n+                    + \"import java.io.*;\\n\"\n+                    + \"public class C implements \" + intf + \" {\\n\"\n+                    + methods.stream().map(m -> \"    \" + m + \"\\n\").collect((Collectors.joining()))\n+                    + \"}\\n\";\n+            new ModuleBuilder(tb, \"m\")\n+                    .exports(\"p\")\n+                    .classes(s)\n+                    .write(src);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", src.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"--info-text\", \"header=\" + name,\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        options.add(\"-XDshow-debug-summary\");\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options, EnumSet.of(Main.Result.OK));\n+\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getMethods\")\n+    public void testAddMethod(String name, String intf, List<String> methods) throws IOException {\n+        log.printf(\"Test %s: %s %s%n\", name, intf, methods);\n+        Path base = getScratchDir(name);\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        for (int api = 0; api < 2; api++) {\n+            String apiName = \"api\" + api;\n+            Path src = Files.createDirectories(base.resolve(apiName) .resolve(\"src\"));\n+            String s = \"package p;\\n\"\n+                    + \"import java.io.*;\\n\"\n+                    + \"public class C implements \" + intf + \" {\\n\"\n+                    + methods.stream().map(m -> \"    \" + m + \"\\n\").collect((Collectors.joining()))\n+                    + (api == 0 ? \"\" : \"    private Object writeReplace() { return this; }\\n\")\n+                    + \"}\\n\";\n+            new ModuleBuilder(tb, \"m\")\n+                    .exports(\"p\")\n+                    .classes(s)\n+                    .write(src);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", src.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"--info-text\", \"header=\" + name,\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        options.add(\"-XDshow-debug-summary\");\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options, EnumSet.of(Main.Result.DIFFS));\n+\n+    }\n+\n+    @Test\n+    public void testAddThrows() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        String m = \"private void readObject(ObjectInputStream in) { };\";\n+\n+        for (int api = 0; api < 2; api++) {\n+            String apiName = \"api\" + api;\n+            Path src = Files.createDirectories(base.resolve(apiName) .resolve(\"src\"));\n+            String s = \"package p;\\n\"\n+                    + \"import java.io.*;\\n\"\n+                    + \"public class C implements Serializable {\\n\"\n+                    + \"    \" + ((api == 0) ? m : m.replace(\") {\", \") throws IOException {\")) + \"\\n\"\n+                    + \"}\\n\";\n+            new ModuleBuilder(tb, \"m\")\n+                    .exports(\"p\")\n+                    .classes(s)\n+                    .write(src);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", src.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"--info-text\", \"header=testAddThrows\",\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        options.add(\"-XDshow-debug-summary\");\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options, EnumSet.of(Main.Result.DIFFS));\n+\n+    }\n+}\n","filename":"test\/junit\/apitest\/SerializationMethodsTest.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+\n+import jdk.codetools.apidiff.Log;\n+import jdk.codetools.apidiff.model.SerializedFormDocs;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+\n+import apitest.lib.APITester;\n+import toolbox.JavadocTask;\n+import toolbox.ModuleBuilder;\n+import toolbox.Task;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class SerializedFormReaderTest extends APITester {\n+    private Log log;\n+    private Path api;\n+\n+    \/**\n+     * Generates sample API documentation from sample API.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @BeforeAll\n+    public void generateAPIDocs() throws IOException {\n+        Path base = getScratchDir();\n+        super.log.println(base);\n+\n+        Path src = base.resolve(\"src\");\n+        generateSampleAPI(src);\n+\n+        \/\/ Run javadoc on sample API\n+        api = Files.createDirectories(base.resolve(\"api\"));\n+        Task.Result r = new JavadocTask(tb)\n+                .sourcepath(src.resolve(\"m\"))\n+                .outdir(api)\n+                .options(\"-noindex\", \"-quiet\", \"--module\", \"m\")\n+                .run();\n+        r.writeAll();\n+\n+        PrintWriter out = new PrintWriter(System.out) {\n+            @Override\n+            public void close() {\n+                flush();\n+            }\n+        };\n+        PrintWriter err = new PrintWriter(System.err, true){\n+            @Override\n+            public void close() {\n+                flush();\n+            }\n+        };\n+\n+        log = new Log(out, err);\n+    }\n+\n+    void generateSampleAPI(Path dir) throws IOException {\n+        new ModuleBuilder(tb, \"m\")\n+                .exports(\"p\")\n+                .classes(\"package p; import java.io.*; public class NoFields implements Serializable { }\")\n+                .classes(\"package p; import java.io.*; public class OneDefaultFieldNoComments  implements Serializable { int i; }\")\n+                .classes(\"package p; import java.io.*; public class TwoDefaultFieldsNoComments implements Serializable { int i; int j; }\")\n+                .classes(\"\"\"\n+                        package p;\n+                        import java.io.*;\n+                        public class TwoDefaultFieldsWithComments implements Serializable {\n+                            \/**\n+                             * This is the main description for {@code i}. This is more description for {@code i}.\n+                             * @serial This is the serial description for {@code i}.\n+                             *\/\n+                            int i;\n+                            \/**\n+                             * This is the main description for {@code j}. This is more description for {@code j}.\n+                             * @serial This is the serial description for {@code j}.\n+                             *\/\n+                            int j;\n+                        }\n+                        \"\"\")\n+                .classes(\"\"\"\n+                        package p;\n+                        import java.io.*;\n+                        public class OnePersistentField implements Serializable {\n+                            \/**\n+                             * @serialField i int This is {@code i}.\n+                             *\/\n+                            private static final ObjectStreamField[] serialPersistentFields = null;\n+                        }\n+                        \"\"\")\n+                .classes(\"\"\"\n+                        package p;\n+                        import java.io.*;\n+                        public class TwoPersistentFields implements Serializable {\n+                            \/**\n+                             * @serialField i int This is {@code i}.\n+                             * @serialField j int This is {@code j}.\n+                             *\/\n+                            private static final ObjectStreamField[] serialPersistentFields = null;\n+                        }\n+                        \"\"\")\n+                .classes(\"\"\"\n+                        package p;\n+                        import java.io.*;\n+                        public class SVUID implements Serializable {\n+                            private static final long serialVersionUID = 123L;\n+                        }\n+                        \"\"\")\n+                .classes(\"\"\"\n+                        package p;\n+                        import java.io.*;\n+                        public class Overview implements Serializable {\n+                            \/**\n+                             * This is the serialization overview.\n+                             *\/\n+                            private static final ObjectStreamField[] serialPersistentFields = null;\n+                        }\n+                        \"\"\")\n+                .classes(\"\"\"\n+                        package p;\n+                        import java.io.*;\n+                        public class ReadObject implements Serializable {\n+                            \/**\n+                             * This is {@code readObject}. This is more about {@code readObject}.\n+                             * @param in the input stream\n+                             *\/\n+                            private void readObject(ObjectInputStream in) { }\n+                        }\n+                        \"\"\")\n+                .classes(\"\"\"\n+                        package p;\n+                        import java.io.*;\n+                        public class WriteObject implements Serializable {\n+                            \/**\n+                             * This is {@code writeObject}. This is more about {@code writeObject}.\n+                             * @param out the output stream\n+                             * @serialData This is the serial data description.\n+                             *\/\n+                            private void writeObject(ObjectOutputStream out) { }\n+                        }\n+                        \"\"\")\n+                .classes(\"\"\"\n+                        package p;\n+                        import java.io.*;\n+                        public class ReadWriteObject implements Serializable {\n+                            \/**\n+                             * This is {@code readObject}. This is more about {@code readObject}.\n+                             * @param in the input stream\n+                             *\/\n+                            private void readObject(ObjectInputStream in) { }\n+                            \/**\n+                             * This is {@code writeObject}. This is more about {@code writeObject}.\n+                             * @param out the output stream\n+                             * @serialData This is the serial data description.\n+                             *\/\n+                            private void writeObject(ObjectOutputStream out) { }\n+                        }\n+                        \"\"\")\n+                .write(dir);\n+    }\n+\n+    @Test\n+    public void checkAPI() {\n+        Map<String, SerializedFormDocs> serializedFormDocs = SerializedFormDocs.read(log, api.resolve(\"serialized-form.html\"));\n+\n+        serializedFormDocs.forEach((name, docs) -> {\n+            log.flush();\n+            super.log.println(\"Type \" + name);\n+            if (docs.getSerialVersionUID() != null) {\n+                super.log.println(\"  serialVersionUID: \" + docs.getSerialVersionUID());\n+            }\n+            if (docs.getOverview() != null) {\n+                super.log.println(\"  overview: \" + docs.getOverview());\n+            }\n+            docs.getFieldDescriptions().forEach((f, d) -> {\n+                super.log.println(\"  \" + f + \": \" + d);\n+            });\n+            docs.getMethodDescriptions().forEach((m, d) -> {\n+                super.log.println(\"  \" + m + \": \" + d);\n+            });\n+            super.log.println();\n+        });\n+    }\n+}\n","filename":"test\/junit\/apitest\/SerializedFormReaderTest.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+import toolbox.ModuleBuilder;\n+\n+public class SerializedFormTest extends APITester {\n+\n+    @Test()\n+    public void testAddSuperclass() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        for (int api = 0; api < 2; api++) {\n+            String apiName = \"api\" + api;\n+            Path src = Files.createDirectories(base.resolve(apiName) .resolve(\"src\"));\n+            String c = \"package p;\\n\"\n+                    + \"import java.io.*;\\n\"\n+                    + \"public class C\" + (api == 0 ? \"\" : \" implements Serializable\") + \" {\\n\"\n+                    + \"}\\n\";\n+            new ModuleBuilder(tb, \"m\")\n+                    .exports(\"p\")\n+                    .classes(c)\n+                    .write(src);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", src.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        options.add(\"-XDshow-debug-summary\");\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    @Test()\n+    public void testClassExclude() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        for (int api = 0; api < 2; api++) {\n+            String apiName = \"api\" + api;\n+            Path src = Files.createDirectories(base.resolve(apiName) .resolve(\"src\"));\n+            String c = \"package p;\\n\"\n+                    + \"import java.io.*;\\n\"\n+                    + (api == 0 ? \"\" : \"\/** Sentence.\\n * @serial exclude\\n *\/\\n\")\n+                    + \"public class C implements Serializable {\\n\"\n+                    + \"}\\n\";\n+            new ModuleBuilder(tb, \"m\")\n+                    .exports(\"p\")\n+                    .classes(c)\n+                    .write(src);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", src.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        options.add(\"-XDshow-debug-summary\");\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    @Test()\n+    public void testPackageExclude() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        for (int api = 0; api < 2; api++) {\n+            String apiName = \"api\" + api;\n+            Path src = Files.createDirectories(base.resolve(apiName) .resolve(\"src\"));\n+            String p =\n+                    (api == 0 ? \"\" : \"\/** Sentence.\\n * @serial exclude\\n *\/\\n\")\n+                    + \"package p;\";\n+            String c = \"\"\"\n+                    package p;\n+                    import java.io.*;\n+                    public class C implements Serializable {\n+                    }\n+                    \"\"\";\n+            new ModuleBuilder(tb, \"m\")\n+                    .exports(\"p\")\n+                    .classes(p, c)\n+                    .write(src);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", src.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        options.add(\"-XDshow-debug-summary\");\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    @Test()\n+    public void testPackageExcludeClassInclude() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        for (int api = 0; api < 2; api++) {\n+            String apiName = \"api\" + api;\n+            Path src = Files.createDirectories(base.resolve(apiName) .resolve(\"src\"));\n+            String p =\n+                    (api == 0 ? \"\" : \"\/** Sentence.\\n * @serial exclude\\n *\/\\n\")\n+                            + \"package p;\";\n+            String c = \"package p;\\n\"\n+                    + \"import java.io.*;\\n\"\n+                    + (api == 0 ? \"\" : \"\/** Sentence.\\n * @serial include\\n *\/\\n\")\n+                    + \"public class C implements Serializable {\\n\"\n+                    + \"}\\n\";\n+            new ModuleBuilder(tb, \"m\")\n+                    .exports(\"p\")\n+                    .classes(p, c)\n+                    .write(src);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", src.toString()));\n+        }\n+\n+        options.addAll(List.of(\n+                \"--include\", \"m\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        options.add(\"-XDshow-debug-summary\");\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+}\n","filename":"test\/junit\/apitest\/SerializedFormTest.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.util.Elements;\n+import javax.lang.model.util.Types;\n+import javax.tools.JavaFileObject;\n+\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.util.DocTrees;\n+import jdk.codetools.apidiff.Options;\n+import jdk.codetools.apidiff.model.API;\n+import jdk.codetools.apidiff.model.SerializedForm;\n+\n+\/**\n+ * A dummy API for use in testing. It has a name. All methods return null.\n+ * Create subclasses to provide additional, specific properties.\n+ *\/\n+public class TestAPI extends API {\n+    TestAPI(String name) {\n+        super(new Options.APIOptions(name), null, null, null);\n+    }\n+\n+    @Override\n+    public Set<PackageElement> getPackageElements() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Set<ModuleElement> getModuleElements() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Set<PackageElement> getPackageElements(ModuleElement m) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Set<PackageElement> getExportedPackageElements(ModuleElement m) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Set<TypeElement> getTypeElements(PackageElement p) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Map<? extends ExecutableElement, ? extends AnnotationValue> getAnnotationValuesWithDefaults(AnnotationMirror am) {\n+        return null;\n+    }\n+\n+    @Override\n+    public SerializedForm getSerializedForm(TypeElement e) {\n+        return null;\n+    }\n+\n+    @Override\n+    public DocCommentTree getDocComment(Element e) {\n+        return null;\n+    }\n+\n+    @Override\n+    public DocCommentTree getDocComment(JavaFileObject fo) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getApiDescription(Element e) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getApiDescription(JavaFileObject fo) {\n+        return null;\n+    }\n+\n+    @Override\n+    public byte[] getAllBytes(JavaFileObject fo) {\n+        return null;\n+    }\n+\n+    @Override\n+    public List<JavaFileObject> listFiles(LocationKind kind, Element e, String subdirectory, Set<JavaFileObject.Kind> kinds, boolean recurse) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Elements getElements() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Types getTypes() {\n+        return null;\n+    }\n+\n+    @Override\n+    public DocTrees getTrees() {\n+        return null;\n+    }\n+}\n","filename":"test\/junit\/apitest\/TestAPI.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import jdk.codetools.apidiff.Log;\n+import jdk.codetools.apidiff.html.Content;\n+import jdk.codetools.apidiff.html.HtmlTree;\n+import jdk.codetools.apidiff.html.TagName;\n+import jdk.codetools.apidiff.html.Text;\n+import jdk.codetools.apidiff.report.html.TextDiffBuilder;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+\n+\/**\n+ * Unit tests for the {@code TextDiffBuilder} class.\n+ *\/\n+public class TextDiffBuilderTest extends APITester {\n+    \/**\n+     * Tests the behavior when the two sets of input are equal.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testEqual() throws IOException {\n+        List<String> list1 = lines(10);\n+        List<String> list2 = new ArrayList<>(list1);\n+        test(getScratchDir(), list1, list2);\n+    }\n+\n+    \/**\n+     * Tests the behavior when a line is inserted into the \"modified\" set.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testSimpleInsert() throws IOException {\n+        List<String> list1 = lines(10);\n+        List<String> list2 = new ArrayList<>(list1);\n+        list2.add(5, \"inserted line\");\n+        test(getScratchDir(), list1, list2);\n+    }\n+\n+    \/**\n+     * Tests the behavior when a line is removed from the \"modified\" set.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testSimpleDelete() throws IOException {\n+        List<String> list1 = lines(10);\n+        List<String> list2 = new ArrayList<>(list1);\n+        list2.remove(5);\n+        test(getScratchDir(), list1, list2);\n+    }\n+\n+    \/**\n+     * Tests the behavior when a line is changed in the \"modified\" set.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testSimpleChange() throws IOException {\n+        List<String> list1 = lines(20);\n+        List<String> list2 = new ArrayList<>(list1);\n+        list2.set(5, \"changed line\");\n+        test(getScratchDir(), list1, list2);\n+    }\n+\n+    \/**\n+     * Tests the behavior when multiple changes are made in the \"modified\" set.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testMultiple() throws IOException {\n+        List<String> list1 = lines(20, 32);\n+        List<String> list2 = new ArrayList<>(list1);\n+        list2.add(3, \"inserted line\");\n+        list2.set(10, \"changed line\");\n+        list2.remove(15);\n+        test(getScratchDir(), list1, list2);\n+    }\n+\n+    \/**\n+     * Tests the behavior when changes are made in different parts of the modified set,\n+     * such that they are presented as disjoint differences.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testDisjoint() throws IOException {\n+        List<String> list1 = IntStream.range(1, 50)\n+                .mapToObj(i -> (\"line:\" + i))\n+                .collect(Collectors.toList());\n+        List<String> list2 = new ArrayList<>(list1);\n+        list2.add(10, \"insert\");\n+        list2.set(20, \"change\");\n+        list2.remove(30);\n+        test(getScratchDir(), list1, list2);\n+    }\n+\n+    void test(Path dir, List<String> list1, List<String> list2) throws IOException {\n+        try (PrintWriter out = wrap(System.out); PrintWriter err = wrap(System.err)) {\n+            Log log = new Log(out, err);\n+            TextDiffBuilder.SDiffs sd = new TextDiffBuilder.SDiffs();\n+            Content c = sd\n+                    .setReference(\"Reference Text\", list1)\n+                    .setModified(\"Modified Text\", list2)\n+                    .setContextSize(3)\n+                    .setShowLineNumbers(true)\n+                    .build(log);\n+\n+            try (Writer w = Files.newBufferedWriter(dir.resolve(\"out.html\"))) {\n+                HtmlTree head = HtmlTree.HEAD(\"utf-8\", \"test\")\n+                        .add(new HtmlTree(TagName.STYLE, new Text(style)));\n+                HtmlTree body = HtmlTree.BODY(List.of(c));\n+                HtmlTree html = new HtmlTree(TagName.HTML, head, body);\n+                html.write(w);\n+            }\n+        }\n+    }\n+\n+    PrintWriter wrap(PrintStream out) {\n+        return new PrintWriter(out) {\n+            @Override\n+            public void close() {\n+                flush();\n+            }\n+        };\n+    }\n+\n+    List<String> lines(int size) {\n+        return lines(size, 64);\n+    }\n+\n+    List<String> lines(int lineCount, int lineLength) {\n+        List<String> lines = new ArrayList<>();\n+        StringBuilder sb = new StringBuilder();\n+        Pattern ws = Pattern.compile(\"\\\\s\");\n+        Matcher m = ws.matcher(lorem_ipsum);\n+        int start = 0;\n+        while (m.find()) {\n+            if (sb.length() + (m.start() - start) > lineLength || m.group().equals(\"\\n\")) {\n+                lines.add(sb.toString());\n+                if (lines.size() > lineCount) {\n+                    return lines;\n+                }\n+                sb = new StringBuilder();\n+            }\n+            if (sb.length() > 0) {\n+                sb.append(\" \");\n+            }\n+            sb.append(lorem_ipsum, start, m.start());\n+            start = m.end();\n+        }\n+        sb.append(lorem_ipsum.substring(start));\n+        lines.add(sb.toString());\n+        System.err.println(lines);\n+        return lines;\n+    }\n+\n+    private static final String style = \"\"\"\n+            div.sdiffs {\n+                display: grid;\n+                grid-template-columns: auto auto;\n+                grid-column-gap: 10px;\n+                margin: 2px 10px;\n+                padding: 2px 2px;\n+                border: 1px solid grey;\n+            }\n+            .sdiffs div.sdiffs-ref { grid-column: 1; overflow-x: auto }\n+            .sdiffs div.sdiffs-mod { grid-column: 2; overflow-x: auto }\n+            .sdiffs span.sdiffs-title { margin-left:2em; text-weight: bold }\n+            .sdiffs span.sdiffs-changed { color: blue }\n+            \"\"\";\n+\n+    private static final String lorem_ipsum = LoremIpsum.text;\n+}\n","filename":"test\/junit\/apitest\/TextDiffBuilderTest.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -0,0 +1,405 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import apitest.lib.APITester;\n+import toolbox.JavacTask;\n+import toolbox.JavadocTask;\n+import toolbox.ModuleBuilder;\n+\n+\/**\n+ * Tests the ability to compare types.\n+ *\/\n+public class TypeTest extends APITester {\n+    \/**\n+     * Tests handling of missing types.\n+     * Three APIs are generated, all containing module mA, package p\n+     * <ul>\n+     * <li>all APIs contain equal definitions of class p.C1\n+     * <li>two APIs contain equal definitions of class p.C2\n+     * <li>only one API contains a definition of class p.C3\n+     * <\/ul>\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testMissingTypes() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 3;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            ModuleBuilder mb = new ModuleBuilder(tb, \"mA\").exports(\"p\");\n+            for (int c = 0; c <= a; c++) {\n+                mb.classes(\"package p; public class C%c% { }\\n\".replace(\"%c%\", String.valueOf(c)));\n+            }\n+            mb.write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString(),\n+                \"--verbose\", \"missing\"));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+        long notFound = outMap.get(OutputKind.ERR).lines()\n+                .filter(l -> l.contains(\"Item not found\"))\n+                .count();\n+        Assertions.assertEquals(3, notFound);\n+\n+    }\n+\n+    \/**\n+     * Tests handling of different kinds of types.\n+     * Four APIs are generated, all containing module mA, package p.\n+     * Each API declares a class T of a different kind.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testDifferentKinds() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 4;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            ModuleBuilder mb = new ModuleBuilder(tb, \"mA\").exports(\"p\");\n+            String t = switch (a) {\n+                case 0 -> \"@interface T { }\";\n+                case 1 -> \"class T { }\";\n+                case 2 -> \"enum T { V }\";\n+                case 3 -> \"interface T { }\";\n+                default -> throw new IllegalStateException(String.valueOf(a));\n+            };\n+            mb.classes(\"package p; public \" + t + \"\\n\");\n+            mb.write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+\n+    }\n+    \/**\n+     * Tests handling of different kinds of types with supertypes.\n+     * Two APIs are generated, both containing module mA, package p.\n+     * One API contains class T which implements Runnable,\n+     * the other contains interface T which extends Runnable.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testDifferentKindsWithSupertype() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            ModuleBuilder mb = new ModuleBuilder(tb, \"mA\").exports(\"p\");\n+            String t = switch (a) {\n+                case 0 -> \"abstract class T implements Runnable { }\";\n+                case 1 -> \"interface T extends Runnable { }\";\n+                default -> throw new IllegalStateException(String.valueOf(a));\n+            };\n+            mb.classes(\"package p; public \" + t + \"\\n\");\n+            mb.write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+\n+    }\n+\n+    \/**\n+     * Tests handling of different kinds of types.\n+     * Two APIs are generated, all containing module mA, package p.\n+     * Each API declares a class C with a different superclass,\n+     * and a class D which does or does not have an explicit superclass.\n+     *\n+     * Note that only CLASS kinds can have an explicit superclass, and\n+     * all classes except {@code java.lang.Object} will have a superclass.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testDifferentSuperclasses() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            ModuleBuilder mb = new ModuleBuilder(tb, \"mA\").exports(\"p\");\n+            String scc = \"extends \" + ((char) ('A' + a));\n+            String scd = (a == 0) ? \"\" : \"extends A\";\n+            mb.classes(\n+                    \"package p; public class A { }\\n\",\n+                    \"package p; public class B { }\\n\",\n+                    \"package p; public class C \" + scc + \" { }\\n\",\n+                    \"package p; public class D \" + scd + \" { }\\n\");\n+            mb.write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    \/**\n+     * Tests handling of different kinds of types.\n+     * Two APIs are generated, all containing module mA, package p.\n+     * Each API declares a class C with a different superclass,\n+     * and a class D which does or does not have an explicit superclass.\n+     *\n+     * Note that only CLASS kinds can have an explicit superclass, and\n+     * all classes except {@code java.lang.Object} will have a superclass.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testDifferentSuperinterfaces() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            ModuleBuilder mb = new ModuleBuilder(tb, \"mA\").exports(\"p\");\n+            String scc = \"implements \" + ((char) ('A' + a));\n+            String scd = (a == 0) ? \"\" : \"implements A\";\n+            String sce = \"implements java.util.List<\" + ((char) ('A' + a)) + \">\";\n+            mb.classes(\n+                    \"package p; public interface A { }\\n\",\n+                    \"package p; public interface B { }\\n\",\n+                    \"package p; public class C \" + scc + \" { }\\n\",\n+                    \"package p; public class D \" + scd + \" { }\\n\",\n+                    \"package p; public class E \" + sce + \" { }\\n\");\n+            mb.write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    \/**\n+     * Tests handling of type parameters.\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    @Test\n+    public void testTypeParameters() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            ModuleBuilder mb = new ModuleBuilder(tb, \"mA\").exports(\"p\");\n+            String tpeC = a == 0 ? \"\" : \"<T>\";\n+            String tpeD = a == 0 ? \"<T>\" : \"<U>\";\n+            String tpeE = a == 0 ? \"<T>\" : \"<T,U>\";\n+            mb.classes(\n+                    \"package p; public interface A<T> { }\\n\",\n+                    \"package p; public interface B<T,U> { }\\n\",\n+                    \"package p; public interface C\" + tpeC + \" { }\\n\",\n+                    \"package p; public interface D\" + tpeD + \" { }\\n\",\n+                    \"package p; public interface E\" + tpeE+ \" { }\\n\");\n+            mb.write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    @Test\n+    public void testDifferentRawDocComments() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path apiDir = base.resolve(apiName).resolve(\"src\");\n+\n+            ModuleBuilder mb = new ModuleBuilder(tb, \"mA\").exports(\"p\");\n+            String cs = \"\/**\\n * This is Same.\\n * Unchanged.\\n * More.\\n **\/\";\n+            String ci = \"\/**\\n * This is Insert.\\n\" + (a == 1 ? \" * Inserted.\\n\" : \"\") + \" * More.\\n **\/\";\n+            String cr = \"\/**\\n * This is Remove.\\n\" + (a == 0 ? \" * Removed.\\n\" : \"\") + \" * More.\\n **\/\";\n+            String cc = \"\/**\\n * This is Change.\\n * API \" + apiName + \"\\n * More.\\n **\/\";\n+            mb.classes(\n+                    \"package p; \" + cs + \"public class Same { }\\n\",\n+                    \"package p; \" + ci + \"public class Insert { }\\n\",\n+                    \"package p; \" + cr + \"public class Remove { }\\n\",\n+                    \"package p; \" + cc + \"public class Change { }\\n\"\n+                    );\n+            mb.write(apiDir);\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-source-path\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+\n+    @Test\n+    public void testDifferentAPIDescriptions() throws IOException {\n+        Path base = getScratchDir();\n+        log.println(base);\n+\n+        List<String> options = new ArrayList<>();\n+\n+        int APIS = 2;\n+        for (int a = 0; a < APIS; a++) {\n+            String apiName = \"api\" + a;\n+            Path srcDir = base.resolve(apiName).resolve(\"src\");\n+\n+            ModuleBuilder mb = new ModuleBuilder(tb, \"mA\").exports(\"p\");\n+            String cs = \"\/**\\n * This is Same.\\n * Unchanged.\\n * More.\\n **\/\";\n+            String ci = \"\/**\\n * This is Insert.\\n\" + (a == 1 ? \" * Inserted.\\n\" : \"\") + \" * More.\\n **\/\";\n+            String cr = \"\/**\\n * This is Remove.\\n\" + (a == 0 ? \" * Removed.\\n\" : \"\") + \" * More.\\n **\/\";\n+            String cc = \"\/**\\n * This is Change.\\n * API \" + apiName + \"\\n * More.\\n **\/\";\n+            mb.classes(\n+                    \"package p; \" + cs + \"public class Same { }\\n\",\n+                    \"package p; \" + ci + \"public class Insert { }\\n\",\n+                    \"package p; \" + cr + \"public class Remove { }\\n\",\n+                    \"package p; \" + cc + \"public class Change { }\\n\"\n+            );\n+            mb.write(srcDir);\n+\n+            Path modulesDir = Files.createDirectories(base.resolve(apiName).resolve(\"modules\"));\n+            new JavacTask(tb)\n+                    .outdir(modulesDir)\n+                    .options(\"--module-source-path\", srcDir.toString())\n+                    .files(tb.findJavaFiles(srcDir))\n+                    .run();\n+\n+            Path apiDir = Files.createDirectories(base.resolve(apiName).resolve(\"api\"));\n+            new JavadocTask(tb)\n+                    .outdir(apiDir)\n+                    .options(\"--module-source-path\", srcDir.toString(),\n+                            \"--module\", \"mA\")\n+                    .run();\n+\n+            options.addAll(List.of(\n+                    \"--api\", apiName,\n+                    \"--module-path\", modulesDir.toString(),\n+                    \"--api-directory\", apiDir.toString()));\n+        }\n+        options.addAll(List.of(\n+                \"--include\", \"mA\/**\",\n+                \"-d\", base.resolve(\"out\").toString()));\n+\n+        log.println(\"Options: \" + options);\n+\n+        Map<OutputKind,String> outMap = run(options);\n+    }\n+}\n","filename":"test\/junit\/apitest\/TypeTest.java","additions":405,"deletions":0,"binary":false,"changes":405,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package apitest.lib;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.StackWalker.StackFrame;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import jdk.codetools.apidiff.Main;\n+import jdk.codetools.apidiff.Main.Result;\n+import toolbox.ToolBox;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * A base class providing utility methods for test classes.\n+ *\/\n+public class APITester {\n+    private static final String lineSeparator = System.lineSeparator();\n+    Path base = Paths.get(\"build\/test\"); \/\/ TODO: better if injected\n+\n+    \/** A toolbox. *\/\n+    protected final ToolBox tb = new ToolBox();\n+\n+    \/** A stream for logging messages. *\/\n+    protected final PrintStream log = System.out;\n+\n+    \/** The kind of output. *\/\n+    public enum OutputKind {\n+        \/** Output written to the standard output stream. *\/\n+        OUT,\n+        \/** Output written to the standard error stream. *\/\n+        ERR\n+    }\n+\n+    public Map<OutputKind, String> run(List<String> options) throws Error {\n+        return run(options, EnumSet.of(Result.OK, Result.DIFFS));\n+    }\n+\n+    \/**\n+     * Executes a new instance of <i>apidiff<\/i> with  a given set of options,\n+     * returning the output that is written to the standard output and error\n+     * stream.\n+     *\n+     * @param options the options\n+     * @return the output\n+     *\/\n+    public Map<OutputKind, String> run(List<String> options, Set<Result> expectResult) {\n+        Main.Result r;\n+        StringWriter outSW = new StringWriter();\n+        StringWriter errSW = new StringWriter();\n+        try (PrintWriter out = new PrintWriter(outSW); PrintWriter err = new PrintWriter(errSW)) {\n+            Main m = new Main(out, err);\n+            r = m.run(options);\n+        }\n+        Map<OutputKind, String> map = new EnumMap<>(OutputKind.class);\n+\n+        String out = outSW.toString();\n+        log.println(\"stdout:\");\n+        log.println(out);\n+        map.put(OutputKind.OUT, out);\n+\n+        String err = errSW.toString();\n+        log.println(\"stderr:\");\n+        log.println(err);\n+        map.put(OutputKind.ERR, err);\n+\n+        \/\/ defer this check until stdout and stderr have been written out\n+        if (!expectResult.contains(r)) {\n+            throw new AssertionError(\"unexpected result: \" + r + \"; expected: \" + expectResult);\n+        }\n+\n+        return map;\n+    }\n+\n+    \/**\n+     * Returns an empty scratch directory based on the name of the class and method\n+     * calling this method.\n+     *\n+     * @return the path of a clean scratch directory\n+     * @throws IOException if there is a problem creating the directory\n+     *\/\n+    protected Path getScratchDir() throws IOException {\n+        StackFrame caller = StackWalker.getInstance()\n+                .walk(s -> s.filter(f -> !f.getClassName().equals(APITester.class.getName()))\n+                        .findFirst()\n+                        .orElseThrow());\n+\n+        Path dir = Files.createDirectories(base\n+                .resolve(\"work\")\n+                .resolve(caller.getClassName().replace(\".\", File.separator))\n+                .resolve(caller.getMethodName()));\n+        tb.cleanDirectory(dir);\n+        return dir;\n+    }\n+\n+    \/**\n+     * Returns an empty scratch directory based on the name of the class and method\n+     * calling this method, and a given subdirectory name.\n+     *\n+     * @param subDir the name of the subdirectory\n+     *\n+     * @return the path of a clean scratch directory\n+     * @throws IOException if there is a problem creating the directory\n+     *\/\n+    protected Path getScratchDir(String subDir) throws IOException {\n+        StackFrame caller = StackWalker.getInstance()\n+                .walk(s -> s.filter(f -> !f.getClassName().equals(APITester.class.getName()))\n+                        .findFirst()\n+                        .orElseThrow());\n+\n+        Path dir = Files.createDirectories(base\n+                .resolve(\"work\")\n+                .resolve(caller.getClassName().replace(\".\", File.separator))\n+                .resolve(caller.getMethodName())\n+                .resolve(subDir));\n+        tb.cleanDirectory(dir);\n+        return dir;\n+    }\n+\n+    protected String getClassMethodName() {\n+        StackFrame caller = StackWalker.getInstance()\n+                .walk(s -> s.filter(f -> !f.getClassName().equals(APITester.class.getName()))\n+                        .findFirst()\n+                        .orElseThrow());\n+        return caller.getClassName().replaceAll(\"^.*\\\\.\", \"\") + \".\" + caller.getMethodName();\n+    }\n+\n+    public void checkOutput(Path p, String... expect) throws IOException {\n+        String s = Files.readString(p);\n+        for (String e : expect) {\n+            assertTrue(s.contains(e), \"expected content not found: \" + e);\n+        }\n+    }\n+}\n","filename":"test\/junit\/apitest\/lib\/APITester.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Library and support code for testing the \"apidiff\" tool.\n+ *\/\n+package apitest.lib;\n","filename":"test\/junit\/apitest\/lib\/package-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Tests for the \"apidiff\" tool.\n+ *\/\n+package apitest;\n","filename":"test\/junit\/apitest\/package-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,300 @@\n+\/*\n+ * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package toolbox;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Path;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import static toolbox.ToolBox.lineSeparator;\n+\n+\/**\n+ * A utility base class to simplify the implementation of tasks.\n+ * Provides support for running the task in a process and for\n+ * capturing output written by the task to stdout, stderr and\n+ * other writers where applicable.\n+ * @param <T> the implementing subclass\n+ *\/\n+abstract class AbstractTask<T extends AbstractTask<T>> implements Task {\n+    protected final ToolBox toolBox;\n+    protected final Mode mode;\n+    private final Map<OutputKind, String> redirects = new EnumMap<>(OutputKind.class);\n+    private final Map<String, String> envVars = new HashMap<>();\n+    private Expect expect = Expect.SUCCESS;\n+    int expectedExitCode = 0;\n+\n+    \/**\n+     * Create a task that will execute in the specified mode.\n+     * @param mode the mode\n+     *\/\n+    protected AbstractTask(ToolBox tb, Mode mode) {\n+        toolBox = tb;\n+        this.mode = mode;\n+    }\n+\n+    \/**\n+     * Sets the expected outcome of the task and calls {@code run()}.\n+     * @param expect the expected outcome\n+     * @return the result of calling {@code run()}\n+     *\/\n+    public Result run(Expect expect) {\n+        expect(expect, Integer.MIN_VALUE);\n+        return run();\n+    }\n+\n+    \/**\n+     * Sets the expected outcome of the task and calls {@code run()}.\n+     * @param expect the expected outcome\n+     * @param exitCode the expected exit code if the expected outcome\n+     *      is {@code FAIL}\n+     * @return the result of calling {@code run()}\n+     *\/\n+    public Result run(Expect expect, int exitCode) {\n+        expect(expect, exitCode);\n+        return run();\n+    }\n+\n+    \/**\n+     * Sets the expected outcome and expected exit code of the task.\n+     * The exit code will not be checked if the outcome is\n+     * {@code Expect.SUCCESS} or if the exit code is set to\n+     * {@code Integer.MIN_VALUE}.\n+     * @param expect the expected outcome\n+     * @param exitCode the expected exit code\n+     *\/\n+    protected void expect(Expect expect, int exitCode) {\n+        this.expect = expect;\n+        this.expectedExitCode = exitCode;\n+    }\n+\n+    \/**\n+     * Checks the exit code contained in a {@code Result} against the\n+     * expected outcome and exit value\n+     * @param result the result object\n+     * @return the result object\n+     * @throws TaskError if the exit code stored in the result object\n+     *      does not match the expected outcome and exit code.\n+     *\/\n+    protected Result checkExit(Result result) throws TaskError {\n+        switch (expect) {\n+            case SUCCESS:\n+                if (result.exitCode != 0) {\n+                    result.writeAll();\n+                    throw new TaskError(\"Task \" + name() + \" failed: rc=\" + result.exitCode);\n+                }\n+                break;\n+\n+            case FAIL:\n+                if (result.exitCode == 0) {\n+                    result.writeAll();\n+                    throw new TaskError(\"Task \" + name() + \" succeeded unexpectedly\");\n+                }\n+\n+                if (expectedExitCode != Integer.MIN_VALUE\n+                        && result.exitCode != expectedExitCode) {\n+                    result.writeAll();\n+                    throw new TaskError(\"Task \" + name() + \"failed with unexpected exit code \"\n+                        + result.exitCode + \", expected \" + expectedExitCode);\n+                }\n+                break;\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Sets an environment variable to be used by this task.\n+     * @param name the name of the environment variable\n+     * @param value the value for the environment variable\n+     * @return this task object\n+     * @throws IllegalStateException if the task mode is not {@code EXEC}\n+     *\/\n+    public T envVar(String name, String value) {\n+        if (mode != Mode.EXEC)\n+            throw new IllegalStateException();\n+        envVars.put(name, value);\n+        return (T) this;\n+    }\n+\n+    \/**\n+     * Redirects output from an output stream to a file.\n+     * @param outputKind the name of the stream to be redirected.\n+     * @param path the file\n+     * @return this task object\n+     * @throws IllegalStateException if the task mode is not {@code EXEC}\n+     *\/\n+    public T redirect(OutputKind outputKind, String path) {\n+        if (mode != Mode.EXEC)\n+            throw new IllegalStateException();\n+        redirects.put(outputKind, path);\n+        return (T) this;\n+    }\n+\n+    \/**\n+     * Returns a {@code ProcessBuilder} initialized with any\n+     * redirects and environment variables that have been set.\n+     * @return a {@code ProcessBuilder}\n+     *\/\n+    protected ProcessBuilder getProcessBuilder() {\n+        if (mode != Mode.EXEC)\n+            throw new IllegalStateException();\n+        ProcessBuilder pb = new ProcessBuilder();\n+        if (redirects.get(OutputKind.STDOUT) != null)\n+            pb.redirectOutput(Path.of(redirects.get(OutputKind.STDOUT)).toFile());\n+        if (redirects.get(OutputKind.STDERR) != null)\n+            pb.redirectError(Path.of(redirects.get(OutputKind.STDERR)).toFile());\n+        pb.environment().putAll(envVars);\n+        return pb;\n+    }\n+\n+    \/**\n+     * Collects the output from a process and saves it in a {@code Result}.\n+     * @param tb the {@code ToolBox} containing the task {@code t}\n+     * @param t the task initiating the process\n+     * @param p the process\n+     * @return a Result object containing the output from the process and its\n+     *      exit value.\n+     * @throws InterruptedException if the thread is interrupted\n+     *\/\n+    protected Result runProcess(ToolBox tb, Task t, Process p) throws InterruptedException {\n+        if (mode != Mode.EXEC)\n+            throw new IllegalStateException();\n+        ProcessOutput sysOut = new ProcessOutput(p.getInputStream()).start();\n+        ProcessOutput sysErr = new ProcessOutput(p.getErrorStream()).start();\n+        sysOut.waitUntilDone();\n+        sysErr.waitUntilDone();\n+        int rc = p.waitFor();\n+        Map<OutputKind, String> outputMap = new EnumMap<>(OutputKind.class);\n+        outputMap.put(OutputKind.STDOUT, sysOut.getOutput());\n+        outputMap.put(OutputKind.STDERR, sysErr.getOutput());\n+        return checkExit(new Result(toolBox, t, rc, outputMap));\n+    }\n+\n+    \/**\n+     * Thread-friendly class to read the output from a process until the stream\n+     * is exhausted.\n+     *\/\n+    static class ProcessOutput implements Runnable {\n+        ProcessOutput(InputStream from) {\n+            in = new BufferedReader(new InputStreamReader(from));\n+            out = new StringBuilder();\n+        }\n+\n+        ProcessOutput start() {\n+            new Thread(this).start();\n+            return this;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                String line;\n+                while ((line = in.readLine()) != null) {\n+                    out.append(line).append(lineSeparator);\n+                }\n+            } catch (IOException e) {\n+            }\n+            synchronized (this) {\n+                done = true;\n+                notifyAll();\n+            }\n+        }\n+\n+        synchronized void waitUntilDone() throws InterruptedException {\n+            boolean interrupted = false;\n+\n+            \/\/ poll interrupted flag, while waiting for copy to complete\n+            while (!(interrupted = Thread.interrupted()) && !done)\n+                wait(1000);\n+\n+            if (interrupted)\n+                throw new InterruptedException();\n+        }\n+\n+        String getOutput() {\n+            return out.toString();\n+        }\n+\n+        private final BufferedReader in;\n+        private final StringBuilder out;\n+        private boolean done;\n+    }\n+\n+    \/**\n+     * Utility class to simplify the handling of temporarily setting a\n+     * new stream for System.out or System.err.\n+     *\/\n+    static class StreamOutput {\n+        \/\/ Functional interface to set a stream.\n+        \/\/ Expected use: System::setOut, System::setErr\n+        interface Initializer {\n+            void set(PrintStream s);\n+        }\n+\n+        private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        private final PrintStream ps = new PrintStream(baos);\n+        private final PrintStream prev;\n+        private final Initializer init;\n+\n+        StreamOutput(PrintStream s, Initializer init) {\n+            prev = s;\n+            init.set(ps);\n+            this.init = init;\n+        }\n+\n+        \/**\n+         * Closes the stream and returns the contents that were written to it.\n+         * @return the contents that were written to it.\n+         *\/\n+        String close() {\n+            init.set(prev);\n+            ps.close();\n+            return baos.toString();\n+        }\n+    }\n+\n+    \/**\n+     * Utility class to simplify the handling of creating an in-memory PrintWriter.\n+     *\/\n+    static class WriterOutput {\n+        private final StringWriter sw = new StringWriter();\n+        final PrintWriter pw = new PrintWriter(sw);\n+\n+        \/**\n+         * Closes the stream and returns the contents that were written to it.\n+         * @return the contents that were written to it.\n+         *\/\n+        String close() {\n+            pw.close();\n+            return sw.toString();\n+        }\n+    }\n+}\n","filename":"test\/junit\/toolbox\/AbstractTask.java","additions":300,"deletions":0,"binary":false,"changes":300,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package toolbox;\n+\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Simple facility for unconditional assertions.\n+ * The methods in this class are described in terms of equivalent assert\n+ * statements, assuming that assertions have been enabled.\n+ *\/\n+public class Assert {\n+    \/** Equivalent to\n+     *   assert cond;\n+     *\/\n+    public static void check(boolean cond) {\n+        if (!cond)\n+            error();\n+    }\n+\n+    \/** Equivalent to\n+     *   assert (o == null);\n+     *\/\n+    public static void checkNull(Object o) {\n+        if (o != null)\n+            error();\n+    }\n+\n+    \/** Equivalent to\n+     *   assert (t != null); return t;\n+     *\/\n+    public static <T> T checkNonNull(T t) {\n+        if (t == null)\n+            error();\n+        return t;\n+    }\n+\n+    \/** Equivalent to\n+     *   assert cond : value;\n+     *\/\n+    public static void check(boolean cond, int value) {\n+        if (!cond)\n+            error(String.valueOf(value));\n+    }\n+\n+    \/** Equivalent to\n+     *   assert cond : value;\n+     *\/\n+    public static void check(boolean cond, long value) {\n+        if (!cond)\n+            error(String.valueOf(value));\n+    }\n+\n+    \/** Equivalent to\n+     *   assert cond : value;\n+     *\/\n+    public static void check(boolean cond, Object value) {\n+        if (!cond)\n+            error(String.valueOf(value));\n+    }\n+\n+    \/** Equivalent to\n+     *   assert cond : msg;\n+     *\/\n+    public static void check(boolean cond, String msg) {\n+        if (!cond)\n+            error(msg);\n+    }\n+\n+    \/** Equivalent to\n+     *   assert cond : msg.get();\n+     *  Note: message string is computed lazily.\n+     *\/\n+    public static void check(boolean cond, Supplier<String> msg) {\n+        if (!cond)\n+            error(msg.get());\n+    }\n+\n+    \/** Equivalent to\n+     *   assert (o == null) : value;\n+     *\/\n+    public static void checkNull(Object o, Object value) {\n+        if (o != null)\n+            error(String.valueOf(value));\n+    }\n+\n+    \/** Equivalent to\n+     *   assert (o == null) : msg;\n+     *\/\n+    public static void checkNull(Object o, String msg) {\n+        if (o != null)\n+            error(msg);\n+    }\n+\n+    \/** Equivalent to\n+     *   assert (o == null) : msg.get();\n+     *  Note: message string is computed lazily.\n+     *\/\n+    public static void checkNull(Object o, Supplier<String> msg) {\n+        if (o != null)\n+            error(msg.get());\n+    }\n+\n+    \/** Equivalent to\n+     *   assert (o != null) : msg;\n+     *\/\n+    public static <T> T checkNonNull(T t, String msg) {\n+        if (t == null)\n+            error(msg);\n+        return t;\n+    }\n+\n+    \/** Equivalent to\n+     *   assert (o != null) : msg.get();\n+     *  Note: message string is computed lazily.\n+     *\/\n+    public static <T> T checkNonNull(T t, Supplier<String> msg) {\n+        if (t == null)\n+            error(msg.get());\n+        return t;\n+    }\n+\n+    \/** Equivalent to\n+     *   assert false;\n+     *\/\n+    public static void error() {\n+        throw new AssertionError();\n+    }\n+\n+    \/** Equivalent to\n+     *   assert false : msg;\n+     *\/\n+    public static void error(String msg) {\n+        throw new AssertionError(msg);\n+    }\n+\n+    \/** Prevent instantiation. *\/\n+    private Assert() { }\n+}\n","filename":"test\/junit\/toolbox\/Assert.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package toolbox;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/**\n+ * A task to configure and run a general command.\n+ *\/\n+public class ExecTask extends AbstractTask<ExecTask> {\n+    private final String command;\n+    private List<String> args;\n+\n+    \/**\n+     * Create a task to execute a given command, to be run using {@code EXEC} mode.\n+     * @param toolBox the {@code ToolBox} to use\n+     * @param command the command to be executed\n+     *\/\n+    public ExecTask(ToolBox toolBox, String command) {\n+        super(toolBox, Task.Mode.EXEC);\n+        this.command = command;\n+    }\n+\n+    \/**\n+     * Create a task to execute a given command, to be run using {@code EXEC} mode.\n+     * @param toolBox the {@code ToolBox} to use\n+     * @param command the command to be executed\n+     *\/\n+    public ExecTask(ToolBox toolBox, Path command) {\n+        super(toolBox, Task.Mode.EXEC);\n+        this.command = command.toString();\n+    }\n+\n+    \/**\n+     * Sets the arguments for the command to be executed\n+     * @param args the arguments\n+     * @return this task object\n+     *\/\n+    public ExecTask args(String... args) {\n+        this.args = Arrays.asList(args);\n+        return this;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @return the name \"exec\"\n+     *\/\n+    @Override\n+    public String name() {\n+        return \"exec\";\n+    }\n+\n+    \/**\n+     * Calls the command with the arguments as currently configured.\n+     * @return a Result object indicating the outcome of the task\n+     * and the content of any output written to stdout or stderr.\n+     * @throws TaskError if the outcome of the task is not as expected.\n+     *\/\n+    @Override\n+    public Task.Result run() {\n+        List<String> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(command);\n+        if (args != null)\n+            cmdArgs.addAll(args);\n+        ProcessBuilder pb = getProcessBuilder();\n+        pb.command(cmdArgs);\n+        try {\n+            return runProcess(toolBox, this, pb.start());\n+        } catch (IOException | InterruptedException e) {\n+            throw new Error(e);\n+        }\n+    }\n+}\n","filename":"test\/junit\/toolbox\/ExecTask.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,423 @@\n+\/*\n+ * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package toolbox;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOError;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.jar.Attributes;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.jar.Manifest;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.tools.FileObject;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import static toolbox.ToolBox.currDir;\n+\n+\/**\n+ * A task to configure and run the jar file utility.\n+ *\/\n+public class JarTask extends AbstractTask<JarTask> {\n+    private Path jar;\n+    private Manifest manifest;\n+    private String classpath;\n+    private String mainClass;\n+    private Path baseDir;\n+    private List<Path> paths;\n+    private Set<FileObject> fileObjects;\n+\n+    \/**\n+     * Creates a task to write jar files, using API mode.\n+     * @param toolBox the {@code ToolBox} to use\n+     *\/\n+    public JarTask(ToolBox toolBox) {\n+        super(toolBox, Task.Mode.API);\n+        paths = Collections.emptyList();\n+        fileObjects = new LinkedHashSet<>();\n+    }\n+\n+    \/**\n+     * Creates a JarTask for use with a given jar file.\n+     * @param toolBox the {@code ToolBox} to use\n+     * @param path the file\n+     *\/\n+    public JarTask(ToolBox toolBox, String path) {\n+        this(toolBox);\n+        jar = Paths.get(path);\n+    }\n+\n+    \/**\n+     * Creates a JarTask for use with a given jar file.\n+     * @param toolBox the {@code ToolBox} to use\n+     * @param path the file\n+     *\/\n+    public JarTask(ToolBox toolBox, Path path) {\n+        this(toolBox);\n+        jar = path;\n+    }\n+\n+    \/**\n+     * Sets a manifest for the jar file.\n+     * @param manifest the manifest\n+     * @return this task object\n+     *\/\n+    public JarTask manifest(Manifest manifest) {\n+        this.manifest = manifest;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets a manifest for the jar file.\n+     * @param manifest a string containing the contents of the manifest\n+     * @return this task object\n+     * @throws IOException if there is a problem creating the manifest\n+     *\/\n+    public JarTask manifest(String manifest) throws IOException {\n+        this.manifest = new Manifest(new ByteArrayInputStream(manifest.getBytes()));\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the classpath to be written to the {@code Class-Path}\n+     * entry in the manifest.\n+     * @param classpath the classpath\n+     * @return this task object\n+     *\/\n+    public JarTask classpath(String classpath) {\n+        this.classpath = classpath;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the class to be written to the {@code Main-Class}\n+     * entry in the manifest..\n+     * @param mainClass the name of the main class\n+     * @return this task object\n+     *\/\n+    public JarTask mainClass(String mainClass) {\n+        this.mainClass = mainClass;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the base directory for files to be written into the jar file.\n+     * @param baseDir the base directory\n+     * @return this task object\n+     *\/\n+    public JarTask baseDir(String baseDir) {\n+        this.baseDir = Paths.get(baseDir);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the base directory for files to be written into the jar file.\n+     * @param baseDir the base directory\n+     * @return this task object\n+     *\/\n+    public JarTask baseDir(Path baseDir) {\n+        this.baseDir = baseDir;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the files to be written into the jar file.\n+     * @param files the files\n+     * @return this task object\n+     *\/\n+    public JarTask files(String... files) {\n+        this.paths = Stream.of(files)\n+                .map(file -> Paths.get(file))\n+                .collect(Collectors.toList());\n+        return this;\n+    }\n+\n+    \/**\n+     * Adds a set of file objects to be written into the jar file, by copying them\n+     * from a Location in a JavaFileManager.\n+     * The file objects to be written are specified by a series of paths;\n+     * each path can be in one of the following forms:\n+     * <ul>\n+     * <li>The name of a class. For example, java.lang.Object.\n+     * In this case, the corresponding .class file will be written to the jar file.\n+     * <li>the name of a package followed by {@code .*}. For example, {@code java.lang.*}.\n+     * In this case, all the class files in the specified package will be written to\n+     * the jar file.\n+     * <li>the name of a package followed by {@code .**}. For example, {@code java.lang.**}.\n+     * In this case, all the class files in the specified package, and any subpackages\n+     * will be written to the jar file.\n+     * <\/ul>\n+     *\n+     * @param fm the file manager in which to find the file objects\n+     * @param l  the location in which to find the file objects\n+     * @param paths the paths specifying the file objects to be copied\n+     * @return this task object\n+     * @throws IOException if errors occur while determining the set of file objects\n+     *\/\n+    public JarTask files(JavaFileManager fm, JavaFileManager.Location l, String... paths)\n+            throws IOException {\n+        for (String p : paths) {\n+            if (p.endsWith(\".**\"))\n+                addPackage(fm, l, p.substring(0, p.length() - 3), true);\n+            else if (p.endsWith(\".*\"))\n+                addPackage(fm, l, p.substring(0, p.length() - 2), false);\n+            else\n+                addFile(fm, l, p);\n+        }\n+        return this;\n+    }\n+\n+    private void addPackage(JavaFileManager fm, JavaFileManager.Location l, String pkg, boolean recurse)\n+            throws IOException {\n+        for (JavaFileObject fo : fm.list(l, pkg, EnumSet.allOf(JavaFileObject.Kind.class), recurse)) {\n+            fileObjects.add(fo);\n+        }\n+    }\n+\n+    private void addFile(JavaFileManager fm, JavaFileManager.Location l, String path) throws IOException {\n+        JavaFileObject fo = fm.getJavaFileForInput(l, path, JavaFileObject.Kind.CLASS);\n+        fileObjects.add(fo);\n+    }\n+\n+    \/**\n+     * Provides limited jar command-like functionality.\n+     * The supported commands are:\n+     * <ul>\n+     * <li> jar cf jarfile -C dir files...\n+     * <li> jar cfm jarfile manifestfile -C dir files...\n+     * <\/ul>\n+     * Any values specified by other configuration methods will be ignored.\n+     * @param args arguments in the style of those for the jar command\n+     * @return a Result object containing the results of running the task\n+     *\/\n+    public Task.Result run(String... args) {\n+        if (args.length < 2)\n+            throw new IllegalArgumentException();\n+\n+        ListIterator<String> iter = Arrays.asList(args).listIterator();\n+        String first = iter.next();\n+        switch (first) {\n+            case \"cf\":\n+                jar = Paths.get(iter.next());\n+                break;\n+            case \"cfm\":\n+                jar = Paths.get(iter.next());\n+                try (InputStream in = Files.newInputStream(Paths.get(iter.next()))) {\n+                    manifest = new Manifest(in);\n+                } catch (IOException e) {\n+                    throw new IOError(e);\n+                }\n+                break;\n+        }\n+\n+        if (iter.hasNext()) {\n+            if (iter.next().equals(\"-C\"))\n+                baseDir = Paths.get(iter.next());\n+            else\n+                iter.previous();\n+        }\n+\n+        paths = new ArrayList<>();\n+        while (iter.hasNext())\n+            paths.add(Paths.get(iter.next()));\n+\n+        return run();\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @return the name \"jar\"\n+     *\/\n+    @Override\n+    public String name() {\n+        return \"jar\";\n+    }\n+\n+    \/**\n+     * Creates a jar file with the arguments as currently configured.\n+     * @return a Result object indicating the outcome of the compilation\n+     * and the content of any output written to stdout, stderr, or the\n+     * main stream by the compiler.\n+     * @throws TaskError if the outcome of the task is not as expected.\n+     *\/\n+    @Override\n+    public Task.Result run() {\n+        Manifest m = (manifest == null) ? new Manifest() : manifest;\n+        Attributes mainAttrs = m.getMainAttributes();\n+        if (mainClass != null)\n+            mainAttrs.put(Attributes.Name.MAIN_CLASS, mainClass);\n+        if (classpath != null)\n+            mainAttrs.put(Attributes.Name.CLASS_PATH, classpath);\n+\n+        AbstractTask.StreamOutput sysOut = new AbstractTask.StreamOutput(System.out, System::setOut);\n+        AbstractTask.StreamOutput sysErr = new AbstractTask.StreamOutput(System.err, System::setErr);\n+\n+        Map<Task.OutputKind, String> outputMap = new HashMap<>();\n+\n+        try (OutputStream os = Files.newOutputStream(jar);\n+                JarOutputStream jos = openJar(os, m)) {\n+            writeFiles(jos);\n+            writeFileObjects(jos);\n+        } catch (IOException e) {\n+            error(\"Exception while opening \" + jar, e);\n+        } finally {\n+            outputMap.put(Task.OutputKind.STDOUT, sysOut.close());\n+            outputMap.put(Task.OutputKind.STDERR, sysErr.close());\n+        }\n+        return checkExit(new Task.Result(toolBox, this, (errors == 0) ? 0 : 1, outputMap));\n+    }\n+\n+    private JarOutputStream openJar(OutputStream os, Manifest m) throws IOException {\n+        if (m == null || m.getMainAttributes().isEmpty() && m.getEntries().isEmpty()) {\n+            return new JarOutputStream(os);\n+        } else {\n+            if (m.getMainAttributes().get(Attributes.Name.MANIFEST_VERSION) == null)\n+                m.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n+            return new JarOutputStream(os, m);\n+        }\n+    }\n+\n+    private void writeFiles(JarOutputStream jos) throws IOException {\n+            Path base = (baseDir == null) ? currDir : baseDir;\n+            for (Path path : paths) {\n+                Files.walkFileTree(base.resolve(path), new SimpleFileVisitor<Path>() {\n+                    @Override\n+                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n+                        try {\n+                        String p = base.relativize(file)\n+                                .normalize()\n+                                .toString()\n+                                .replace(File.separatorChar, '\/');\n+                        JarEntry e = new JarEntry(p);\n+                            jos.putNextEntry(e);\n+                        try {\n+                            jos.write(Files.readAllBytes(file));\n+                        } finally {\n+                            jos.closeEntry();\n+                        }\n+                            return FileVisitResult.CONTINUE;\n+                        } catch (IOException e) {\n+                        error(\"Exception while adding \" + file + \" to jar file\", e);\n+                            return FileVisitResult.TERMINATE;\n+                        }\n+                    }\n+                });\n+            }\n+    }\n+\n+    private void writeFileObjects(JarOutputStream jos) throws IOException {\n+        for (FileObject fo : fileObjects) {\n+            String p = guessPath(fo);\n+            JarEntry e = new JarEntry(p);\n+            jos.putNextEntry(e);\n+            try {\n+                byte[] buf = new byte[1024];\n+                try (BufferedInputStream in = new BufferedInputStream(fo.openInputStream())) {\n+                    int n;\n+                    while ((n = in.read(buf)) > 0)\n+                        jos.write(buf, 0, n);\n+                } catch (IOException ex) {\n+                    error(\"Exception while adding \" + fo.getName() + \" to jar file\", ex);\n+                }\n+        } finally {\n+                jos.closeEntry();\n+        }\n+        }\n+    }\n+\n+    \/*\n+     * A jar: URL is of the form  jar:URL!\/<entry>  where URL is a URL for the .jar file itself.\n+     * In Symbol files (i.e. ct.sym) the underlying entry is prefixed META-INF\/sym\/<base>.\n+     *\/\n+    private final Pattern jarEntry = Pattern.compile(\".*!\/(?:META-INF\/sym\/[^\/]+\/)?(.*)\");\n+\n+    \/*\n+     * A jrt: URL is of the form  jrt:\/modules\/<module>\/<package>\/<file>\n+     *\/\n+    private final Pattern jrtEntry = Pattern.compile(\"\/modules\/([^\/]+)\/(.*)\");\n+\n+    \/*\n+     * A file: URL is of the form  file:\/path\/to\/{modules,patches}\/<module>\/<package>\/<file>\n+     *\/\n+    private final Pattern fileEntry = Pattern.compile(\".*\/(?:modules|patches)\/([^\/]+)\/(.*)\");\n+\n+    private String guessPath(FileObject fo) {\n+        URI u = fo.toUri();\n+        switch (u.getScheme()) {\n+            case \"jar\": {\n+                Matcher m = jarEntry.matcher(u.getSchemeSpecificPart());\n+                if (m.matches()) {\n+                    return m.group(1);\n+                }\n+                break;\n+            }\n+            case \"jrt\": {\n+                Matcher m = jrtEntry.matcher(u.getSchemeSpecificPart());\n+                if (m.matches()) {\n+                    return m.group(2);\n+                }\n+                break;\n+            }\n+            case \"file\": {\n+                Matcher m = fileEntry.matcher(u.getSchemeSpecificPart());\n+                if (m.matches()) {\n+                    return m.group(2);\n+                }\n+                break;\n+            }\n+        }\n+        throw new IllegalArgumentException(fo.getName() + \"--\" + fo.toUri());\n+    }\n+\n+    private void error(String message, Throwable t) {\n+        toolBox.out.println(\"Error: \" + message + \": \" + t);\n+        errors++;\n+    }\n+\n+    private int errors;\n+}\n","filename":"test\/junit\/toolbox\/JarTask.java","additions":423,"deletions":0,"binary":false,"changes":423,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package toolbox;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/**\n+ * A task to configure and run the Java launcher.\n+ *\/\n+public class JavaTask extends AbstractTask<JavaTask> {\n+    boolean includeStandardOptions = true;\n+    private String classpath;\n+    private List<String> vmOptions;\n+    private String className;\n+    private List<String> classArgs;\n+\n+    \/**\n+     * Create a task to run the Java launcher, using {@code EXEC} mode.\n+     * @param toolBox the {@code ToolBox} to use\n+     *\/\n+    public JavaTask(ToolBox toolBox) {\n+        super(toolBox, Task.Mode.EXEC);\n+    }\n+\n+    \/**\n+     * Sets the classpath.\n+     * @param classpath the classpath\n+     * @return this task object\n+     *\/\n+    public JavaTask classpath(String classpath) {\n+        this.classpath = classpath;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the VM options.\n+     * @param vmOptions the options\n+     * @return this task object\n+     *\/\n+    public JavaTask vmOptions(String... vmOptions) {\n+        this.vmOptions = Arrays.asList(vmOptions);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the VM options.\n+     * @param vmOptions the options\n+     * @return this task object\n+     *\/\n+    public JavaTask vmOptions(List<String> vmOptions) {\n+        this.vmOptions = vmOptions;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the name of the class to be executed.\n+     * @param className the name of the class\n+     * @return this task object\n+     *\/\n+    public JavaTask className(String className) {\n+        this.className = className;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the arguments for the class to be executed.\n+     * @param classArgs the arguments\n+     * @return this task object\n+     *\/\n+    public JavaTask classArgs(String... classArgs) {\n+        this.classArgs = Arrays.asList(classArgs);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the arguments for the class to be executed.\n+     * @param classArgs the arguments\n+     * @return this task object\n+     *\/\n+    public JavaTask classArgs(List<String> classArgs) {\n+        this.classArgs = classArgs;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets whether or not the standard VM and java options for the test should be passed\n+     * to the new VM instance. If this method is not called, the default behavior is that\n+     * the options will be passed to the new VM instance.\n+     *\n+     * @param includeStandardOptions whether or not the standard VM and java options for\n+     *                               the test should be passed to the new VM instance.\n+     * @return this task object\n+     *\/\n+    public JavaTask includeStandardOptions(boolean includeStandardOptions) {\n+        this.includeStandardOptions = includeStandardOptions;\n+        return this;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @return the name \"java\"\n+     *\/\n+    @Override\n+    public String name() {\n+        return \"java\";\n+    }\n+\n+    \/**\n+     * Calls the Java launcher with the arguments as currently configured.\n+     * @return a Result object indicating the outcome of the task\n+     * and the content of any output written to stdout or stderr.\n+     * @throws TaskError if the outcome of the task is not as expected.\n+     *\/\n+    @Override\n+    public Task.Result run() {\n+        List<String> args = new ArrayList<>();\n+        args.add(toolBox.getJDKTool(\"java\").toString());\n+        if (includeStandardOptions) {\n+            args.addAll(toolBox.split(System.getProperty(\"test.vm.opts\"), \" +\"));\n+            args.addAll(toolBox.split(System.getProperty(\"test.java.opts\"), \" +\"));\n+        }\n+        if (classpath != null) {\n+            args.add(\"-classpath\");\n+            args.add(classpath);\n+        }\n+        if (vmOptions != null)\n+            args.addAll(vmOptions);\n+        if (className != null)\n+            args.add(className);\n+        if (classArgs != null)\n+            args.addAll(classArgs);\n+        ProcessBuilder pb = getProcessBuilder();\n+        pb.command(args);\n+        try {\n+            return runProcess(toolBox, this, pb.start());\n+        } catch (IOException | InterruptedException e) {\n+            throw new Error(e);\n+        }\n+    }\n+}\n","filename":"test\/junit\/toolbox\/JavaTask.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,450 @@\n+\/*\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package toolbox;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.StandardLocation;\n+\n+import com.sun.tools.javac.api.JavacTaskImpl;\n+import com.sun.tools.javac.api.JavacTool;\n+\n+\/**\n+ * A task to configure and run the Java compiler, javac.\n+ *\/\n+public class JavacTask extends AbstractTask<JavacTask> {\n+    private boolean includeStandardOptions;\n+    private List<Path> classpath;\n+    private List<Path> sourcepath;\n+    private Path outdir;\n+    private List<String> options;\n+    private List<String> classes;\n+    private List<String> files;\n+    private List<JavaFileObject> fileObjects;\n+    private JavaFileManager fileManager;\n+    private Consumer<com.sun.source.util.JavacTask> callback;\n+\n+    private JavaCompiler compiler;\n+    private StandardJavaFileManager internalFileManager;\n+\n+    \/**\n+     * Creates a task to execute {@code javac} using API mode.\n+     * @param toolBox the {@code ToolBox} to use\n+     *\/\n+    public JavacTask(ToolBox toolBox) {\n+        super(toolBox, Task.Mode.API);\n+    }\n+\n+    \/**\n+     * Creates a task to execute {@code javac} in a specified mode.\n+     * @param toolBox the {@code ToolBox} to use\n+     * @param mode the mode to be used\n+     *\/\n+    public JavacTask(ToolBox toolBox, Task.Mode mode) {\n+        super(toolBox, mode);\n+    }\n+\n+    \/**\n+     * Sets the classpath.\n+     * @param classpath the classpath\n+     * @return this task object\n+     *\/\n+    public JavacTask classpath(String classpath) {\n+        this.classpath = Stream.of(classpath.split(File.pathSeparator))\n+                .filter(s -> !s.isEmpty())\n+                .map(s -> Paths.get(s))\n+                .collect(Collectors.toList());\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the classpath.\n+     * @param classpath the classpath\n+     * @return this task object\n+     *\/\n+    public JavacTask classpath(Path... classpath) {\n+        this.classpath = Arrays.asList(classpath);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the classpath.\n+     * @param classpath the classpath\n+     * @return this task object\n+     *\/\n+    public JavacTask classpath(List<Path> classpath) {\n+        this.classpath = classpath;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the sourcepath.\n+     * @param sourcepath the sourcepath\n+     * @return this task object\n+     *\/\n+    public JavacTask sourcepath(String sourcepath) {\n+        this.sourcepath = Stream.of(sourcepath.split(File.pathSeparator))\n+                .filter(s -> !s.isEmpty())\n+                .map(s -> Paths.get(s))\n+                .collect(Collectors.toList());\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the sourcepath.\n+     * @param sourcepath the sourcepath\n+     * @return this task object\n+     *\/\n+    public JavacTask sourcepath(Path... sourcepath) {\n+        this.sourcepath = Arrays.asList(sourcepath);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the sourcepath.\n+     * @param sourcepath the sourcepath\n+     * @return this task object\n+     *\/\n+    public JavacTask sourcepath(List<Path> sourcepath) {\n+        this.sourcepath = sourcepath;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the output directory.\n+     * @param outdir the output directory\n+     * @return this task object\n+     *\/\n+    public JavacTask outdir(String outdir) {\n+        this.outdir = Paths.get(outdir);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the output directory.\n+     * @param outdir the output directory\n+     * @return this task object\n+     *\/\n+    public JavacTask outdir(Path outdir) {\n+        this.outdir = outdir;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the options.\n+     * @param options the options\n+     * @return this task object\n+     *\/\n+    public JavacTask options(String... options) {\n+        this.options = Arrays.asList(options);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the options.\n+     * @param spaceSeparatedOption the space separated options\n+     * @return this task object\n+     *\/\n+    public JavacTask spaceSeparatedOptions(String spaceSeparatedOption) {\n+        this.options = Arrays.asList(spaceSeparatedOption.split(\"\\\\s+\"));\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the options.\n+     * @param options the options\n+     * @return this task object\n+     *\/\n+    public JavacTask options(List<String> options) {\n+        this.options = options;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the classes to be analyzed.\n+     * @param classes the classes\n+     * @return this task object\n+     *\/\n+    public JavacTask classes(String... classes) {\n+        this.classes = Arrays.asList(classes);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the files to be compiled or analyzed.\n+     * @param files the files\n+     * @return this task object\n+     *\/\n+    public JavacTask files(String... files) {\n+        this.files = Arrays.asList(files);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the files to be compiled or analyzed.\n+     * @param files the files\n+     * @return this task object\n+     *\/\n+    public JavacTask files(Path... files) {\n+        this.files = Stream.of(files)\n+                .map(Path::toString)\n+                .collect(Collectors.toList());\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the files to be compiled or analyzed.\n+     * @param files the files\n+     * @return this task object\n+     *\/\n+    public JavacTask files(List<Path> files) {\n+        this.files = files.stream()\n+                .map(Path::toString)\n+                .collect(Collectors.toList());\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the sources to be compiled or analyzed.\n+     * Each source string is converted into an in-memory object that\n+     * can be passed directly to the compiler.\n+     * @param sources the sources\n+     * @return this task object\n+     *\/\n+    public JavacTask sources(String... sources) {\n+        fileObjects = Stream.of(sources)\n+                .map(s -> new ToolBox.JavaSource(s))\n+                .collect(Collectors.toList());\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the file manager to be used by this task.\n+     * @param fileManager the file manager\n+     * @return this task object\n+     *\/\n+    public JavacTask fileManager(JavaFileManager fileManager) {\n+        this.fileManager = fileManager;\n+        return this;\n+    }\n+\n+    \/**\n+     * Set a callback to be used by this task.\n+     * @param callback the callback\n+     * @return this task object\n+     *\/\n+    public JavacTask callback(Consumer<com.sun.source.util.JavacTask> callback) {\n+        this.callback = callback;\n+        return this;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @return the name \"javac\"\n+     *\/\n+    @Override\n+    public String name() {\n+        return \"javac\";\n+    }\n+\n+    \/**\n+     * Calls the compiler with the arguments as currently configured.\n+     * @return a Result object indicating the outcome of the compilation\n+     * and the content of any output written to stdout, stderr, or the\n+     * main stream by the compiler.\n+     * @throws TaskError if the outcome of the task is not as expected.\n+     *\/\n+    @Override\n+    public Task.Result run() {\n+        if (mode == Task.Mode.EXEC)\n+            return runExec();\n+\n+        AbstractTask.WriterOutput direct = new AbstractTask.WriterOutput();\n+        \/\/ The following are to catch output to System.out and System.err,\n+        \/\/ in case these are used instead of the primary (main) stream\n+        AbstractTask.StreamOutput sysOut = new AbstractTask.StreamOutput(System.out, System::setOut);\n+        AbstractTask.StreamOutput sysErr = new AbstractTask.StreamOutput(System.err, System::setErr);\n+        int rc;\n+        Map<Task.OutputKind, String> outputMap = new HashMap<>();\n+        try {\n+            switch (mode == null ? Task.Mode.API : mode) {\n+                case API:\n+                    rc = runAPI(direct.pw);\n+                    break;\n+                case CMDLINE:\n+                    if (fileManager != null) {\n+                        throw new IllegalStateException(\"file manager set in CMDLINE mode\");\n+                    }\n+                    if (callback != null) {\n+                        throw new IllegalStateException(\"callback set in CMDLINE mode\");\n+                    }\n+                    rc = runCommand(direct.pw);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"unknown mode \" + mode);\n+            }\n+        } catch (IOException e) {\n+            toolBox.out.println(\"Exception occurred: \" + e);\n+            rc = 99;\n+        } finally {\n+            outputMap.put(Task.OutputKind.STDOUT, sysOut.close());\n+            outputMap.put(Task.OutputKind.STDERR, sysErr.close());\n+            outputMap.put(Task.OutputKind.DIRECT, direct.close());\n+        }\n+        return checkExit(new Task.Result(toolBox, this, rc, outputMap));\n+    }\n+\n+    private int runAPI(PrintWriter pw) throws IOException {\n+        try {\n+\/\/                if (compiler == null) {\n+                \/\/ TODO: allow this to be set externally\n+\/\/                    compiler = ToolProvider.getSystemJavaCompiler();\n+                compiler = JavacTool.create();\n+\/\/                }\n+\n+            if (fileManager == null)\n+                fileManager = internalFileManager = compiler.getStandardFileManager(null, null, null);\n+            if (outdir != null)\n+                setLocationFromPaths(StandardLocation.CLASS_OUTPUT, Collections.singletonList(outdir));\n+            if (classpath != null)\n+                setLocationFromPaths(StandardLocation.CLASS_PATH, classpath);\n+            if (sourcepath != null)\n+                setLocationFromPaths(StandardLocation.SOURCE_PATH, sourcepath);\n+            List<String> allOpts = new ArrayList<>();\n+            if (options != null)\n+                allOpts.addAll(options);\n+\n+            Iterable<? extends JavaFileObject> allFiles = joinFiles(files, fileObjects);\n+            JavaCompiler.CompilationTask task = compiler.getTask(pw,\n+                    fileManager,\n+                    null,  \/\/ diagnostic listener; should optionally collect diags\n+                    allOpts,\n+                    classes,\n+                    allFiles);\n+            JavacTaskImpl taskImpl = (JavacTaskImpl) task;\n+            if (callback != null) {\n+                callback.accept(taskImpl);\n+            }\n+            return taskImpl.doCall().exitCode;\n+        } finally {\n+            if (internalFileManager != null)\n+                internalFileManager.close();\n+        }\n+    }\n+\n+    private void setLocationFromPaths(StandardLocation location, List<Path> files) throws IOException {\n+        if (!(fileManager instanceof StandardJavaFileManager))\n+            throw new IllegalStateException(\"not a StandardJavaFileManager\");\n+        ((StandardJavaFileManager) fileManager).setLocationFromPaths(location, files);\n+    }\n+\n+    private int runCommand(PrintWriter pw) {\n+        List<String> args = getAllArgs();\n+        String[] argsArray = args.toArray(new String[args.size()]);\n+        return com.sun.tools.javac.Main.compile(argsArray, pw);\n+    }\n+\n+    private Task.Result runExec() {\n+        List<String> args = new ArrayList<>();\n+        Path javac = toolBox.getJDKTool(\"javac\");\n+        args.add(javac.toString());\n+        if (includeStandardOptions) {\n+            args.addAll(toolBox.split(System.getProperty(\"test.tool.vm.opts\"), \" +\"));\n+            args.addAll(toolBox.split(System.getProperty(\"test.compiler.opts\"), \" +\"));\n+        }\n+        args.addAll(getAllArgs());\n+\n+        String[] argsArray = args.toArray(new String[args.size()]);\n+        ProcessBuilder pb = getProcessBuilder();\n+        pb.command(argsArray);\n+        try {\n+            return runProcess(toolBox, this, pb.start());\n+        } catch (IOException | InterruptedException e) {\n+            throw new Error(e);\n+        }\n+    }\n+\n+    private List<String> getAllArgs() {\n+        List<String> args = new ArrayList<>();\n+        if (options != null)\n+            args.addAll(options);\n+        if (outdir != null) {\n+            args.add(\"-d\");\n+            args.add(outdir.toString());\n+        }\n+        if (classpath != null) {\n+            args.add(\"-classpath\");\n+            args.add(toSearchPath(classpath));\n+        }\n+        if (sourcepath != null) {\n+            args.add(\"-sourcepath\");\n+            args.add(toSearchPath(sourcepath));\n+        }\n+        if (classes != null)\n+            args.addAll(classes);\n+        if (files != null)\n+            args.addAll(files);\n+\n+        return args;\n+    }\n+\n+    private String toSearchPath(List<Path> files) {\n+        return files.stream()\n+            .map(Path::toString)\n+            .collect(Collectors.joining(File.pathSeparator));\n+    }\n+\n+    private Iterable<? extends JavaFileObject> joinFiles(\n+            List<String> files, List<JavaFileObject> fileObjects) {\n+        if (files == null)\n+            return fileObjects;\n+        if (internalFileManager == null)\n+            internalFileManager = compiler.getStandardFileManager(null, null, null);\n+        Iterable<? extends JavaFileObject> filesAsFileObjects =\n+                internalFileManager.getJavaFileObjectsFromStrings(files);\n+        if (fileObjects == null)\n+            return filesAsFileObjects;\n+        List<JavaFileObject> combinedList = new ArrayList<>();\n+        for (JavaFileObject o : filesAsFileObjects)\n+            combinedList.add(o);\n+        combinedList.addAll(fileObjects);\n+        return combinedList;\n+    }\n+}\n","filename":"test\/junit\/toolbox\/JavacTask.java","additions":450,"deletions":0,"binary":false,"changes":450,"status":"added"},{"patch":"@@ -0,0 +1,418 @@\n+\/*\n+ * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package toolbox;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.tools.DocumentationTool.DocumentationTask;\n+import javax.tools.DocumentationTool;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileManager.Location;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.StandardLocation;\n+import javax.tools.ToolProvider;\n+\n+\/**\n+ * A task to configure and run the documentation tool, javadoc.\n+ *\/\n+public class JavadocTask extends AbstractTask<JavadocTask> {\n+    private boolean includeStandardOptions;\n+    private List<Path> classpath;\n+    private List<Path> sourcepath;\n+    private Path outdir;\n+    private List<String> options;\n+    private List<String> classes;\n+    private List<String> files;\n+    private List<JavaFileObject> fileObjects;\n+    private JavaFileManager fileManager;\n+\n+    private DocumentationTool jdtool;\n+    private StandardJavaFileManager internalFileManager;\n+    private Class<?> docletClass = null; \/\/ use the standard doclet by default\n+\n+    \/**\n+     * Creates a task to execute {@code javadoc} using API mode.\n+     * @param toolBox the {@code ToolBox} to use\n+     *\/\n+    public JavadocTask(ToolBox toolBox) {\n+        super(toolBox, Task.Mode.API);\n+    }\n+\n+    \/**\n+     * Creates a task to execute {@code javadoc} in a specified mode.\n+     * @param toolBox the {@code ToolBox} to use\n+     * @param mode the mode to be used\n+     *\/\n+    public JavadocTask(ToolBox toolBox, Task.Mode mode) {\n+        super(toolBox, mode);\n+    }\n+\n+    \/**\n+     * Sets the classpath.\n+     * @param classpath the classpath\n+     * @return this task object\n+     *\/\n+    public JavadocTask classpath(String classpath) {\n+        this.classpath = Stream.of(classpath.split(File.pathSeparator))\n+                .filter(s -> !s.isEmpty())\n+                .map(s -> Paths.get(s))\n+                .collect(Collectors.toList());\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the classpath.\n+     * @param classpath the classpath\n+     * @return this task object\n+     *\/\n+    public JavadocTask classpath(Path... classpath) {\n+        this.classpath = Arrays.asList(classpath);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the classpath.\n+     * @param classpath the classpath\n+     * @return this task object\n+     *\/\n+    public JavadocTask classpath(List<Path> classpath) {\n+        this.classpath = classpath;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the sourcepath.\n+     * @param sourcepath the sourcepath\n+     * @return this task object\n+     *\/\n+    public JavadocTask sourcepath(String sourcepath) {\n+        this.sourcepath = Stream.of(sourcepath.split(File.pathSeparator))\n+                .filter(s -> !s.isEmpty())\n+                .map(s -> Paths.get(s))\n+                .collect(Collectors.toList());\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the sourcepath.\n+     * @param sourcepath the sourcepath\n+     * @return this task object\n+     *\/\n+    public JavadocTask sourcepath(Path... sourcepath) {\n+        this.sourcepath = Arrays.asList(sourcepath);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the sourcepath.\n+     * @param sourcepath the sourcepath\n+     * @return this task object\n+     *\/\n+    public JavadocTask sourcepath(List<Path> sourcepath) {\n+        this.sourcepath = sourcepath;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the output directory.\n+     * @param outdir the output directory\n+     * @return this task object\n+     *\/\n+    public JavadocTask outdir(String outdir) {\n+        this.outdir = Paths.get(outdir);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the output directory.\n+     * @param outdir the output directory\n+     * @return this task object\n+     *\/\n+    public JavadocTask outdir(Path outdir) {\n+        this.outdir = outdir;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the options.\n+     * @param options the options\n+     * @return this task object\n+     *\/\n+    public JavadocTask options(String... options) {\n+        this.options = Arrays.asList(options);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the options.\n+     * @param options the options\n+     * @return this task object\n+     *\/\n+    public JavadocTask options(List<String> options) {\n+        this.options = options;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the files to be documented.\n+     * @param files the files\n+     * @return this task object\n+     *\/\n+    public JavadocTask files(String... files) {\n+        this.files = Arrays.asList(files);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the files to be documented.\n+     * @param files the files\n+     * @return this task object\n+     *\/\n+    public JavadocTask files(Path... files) {\n+        this.files = Stream.of(files)\n+                .map(Path::toString)\n+                .collect(Collectors.toList());\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the files to be documented.\n+     * @param files the files\n+     * @return this task object\n+     *\/\n+    public JavadocTask files(List<Path> files) {\n+        this.files = files.stream()\n+                .map(Path::toString)\n+                .collect(Collectors.toList());\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the sources to be documented.\n+     * Each source string is converted into an in-memory object that\n+     * can be passed directly to the tool.\n+     * @param sources the sources\n+     * @return this task object\n+     *\/\n+    public JavadocTask sources(String... sources) {\n+        fileObjects = Stream.of(sources)\n+                .map(s -> new ToolBox.JavaSource(s))\n+                .collect(Collectors.toList());\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the file manager to be used by this task.\n+     * @param fileManager the file manager\n+     * @return this task object\n+     *\/\n+    public JavadocTask fileManager(JavaFileManager fileManager) {\n+        this.fileManager = fileManager;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the doclet class to be invoked by javadoc.\n+     * Note: this is applicable only in API mode.\n+     * @param docletClass the user specified doclet\n+     * @return this task object\n+     *\/\n+    public JavadocTask docletClass(Class<?> docletClass) {\n+        this.docletClass = docletClass;\n+        return this;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @return the name \"javadoc\"\n+     *\/\n+    @Override\n+    public String name() {\n+        return \"javadoc\";\n+    }\n+\n+    \/**\n+     * Calls the javadoc tool with the arguments as currently configured.\n+     * @return a Result object indicating the outcome of the execution\n+     * and the content of any output written to stdout, stderr, or the\n+     * main stream by the tool.\n+     *\/\n+    @Override\n+    public Task.Result run() {\n+        if (mode == Task.Mode.EXEC)\n+            return runExec();\n+\n+        AbstractTask.WriterOutput direct = new AbstractTask.WriterOutput();\n+        \/\/ The following are to catch output to System.out and System.err,\n+        \/\/ in case these are used instead of the primary (main) stream\n+        AbstractTask.StreamOutput sysOut = new AbstractTask.StreamOutput(System.out, System::setOut);\n+        AbstractTask.StreamOutput sysErr = new AbstractTask.StreamOutput(System.err, System::setErr);\n+        int rc;\n+        Map<Task.OutputKind, String> outputMap = new HashMap<>();\n+        try {\n+            switch (mode == null ? Task.Mode.API : mode) {\n+                case API:\n+                    rc = runAPI(direct.pw);\n+                    break;\n+                case CMDLINE:\n+                    rc = runCommand(direct.pw);\n+                    break;\n+                default:\n+                    throw new IllegalStateException();\n+            }\n+        } catch (IOException e) {\n+            toolBox.out.println(\"Exception occurred: \" + e);\n+            rc = 99;\n+        } finally {\n+            outputMap.put(Task.OutputKind.STDOUT, sysOut.close());\n+            outputMap.put(Task.OutputKind.STDERR, sysErr.close());\n+            outputMap.put(Task.OutputKind.DIRECT, direct.close());\n+        }\n+        return checkExit(new Task.Result(toolBox, this, rc, outputMap));\n+    }\n+\n+    private int runAPI(PrintWriter pw) throws IOException {\n+        try {\n+            jdtool = ToolProvider.getSystemDocumentationTool();\n+\n+            if (fileManager == null)\n+                fileManager = internalFileManager = jdtool.getStandardFileManager(null, null, null);\n+            if (outdir != null)\n+                setLocationFromPaths(DocumentationTool.Location.DOCUMENTATION_OUTPUT,\n+                        Collections.singletonList(outdir));\n+            if (classpath != null)\n+                setLocationFromPaths(StandardLocation.CLASS_PATH, classpath);\n+            if (sourcepath != null)\n+                setLocationFromPaths(StandardLocation.SOURCE_PATH, sourcepath);\n+            List<String> allOpts = new ArrayList<>();\n+            if (options != null)\n+                allOpts.addAll(options);\n+\n+            Iterable<? extends JavaFileObject> allFiles = joinFiles(files, fileObjects);\n+            DocumentationTask task = jdtool.getTask(pw,\n+                    fileManager,\n+                    null,  \/\/ diagnostic listener; should optionally collect diags\n+                    docletClass,\n+                    allOpts,\n+                    allFiles);\n+            return task.call() ? 0 : 1;\n+        } finally {\n+            if (internalFileManager != null)\n+                internalFileManager.close();\n+        }\n+    }\n+\n+    private void setLocationFromPaths(Location location, List<Path> files) throws IOException {\n+        if (!(fileManager instanceof StandardJavaFileManager))\n+            throw new IllegalStateException(\"not a StandardJavaFileManager\");\n+        ((StandardJavaFileManager) fileManager).setLocationFromPaths(location, files);\n+    }\n+\n+    private int runCommand(PrintWriter pw) {\n+        List<String> args = getAllArgs();\n+        String[] argsArray = args.toArray(new String[args.size()]);\n+        java.util.spi.ToolProvider jdTool = java.util.spi.ToolProvider.findFirst(\"javadoc\")\n+                .orElseThrow(() -> new Error(\"can't find javadoc\"));\n+        return jdTool.run(pw, pw, argsArray);\n+    }\n+\n+    private Task.Result runExec() {\n+        List<String> args = new ArrayList<>();\n+        Path javadoc = toolBox.getJDKTool(\"javadoc\");\n+        args.add(javadoc.toString());\n+        if (includeStandardOptions) {\n+            args.addAll(toolBox.split(System.getProperty(\"test.tool.vm.opts\"), \" +\"));\n+        }\n+        args.addAll(getAllArgs());\n+\n+        String[] argsArray = args.toArray(new String[args.size()]);\n+        ProcessBuilder pb = getProcessBuilder();\n+        pb.command(argsArray);\n+        try {\n+            return runProcess(toolBox, this, pb.start());\n+        } catch (IOException | InterruptedException e) {\n+            throw new Error(e);\n+        }\n+    }\n+\n+    private List<String> getAllArgs() {\n+        List<String> args = new ArrayList<>();\n+        if (options != null)\n+            args.addAll(options);\n+        if (outdir != null) {\n+            args.add(\"-d\");\n+            args.add(outdir.toString());\n+        }\n+        if (classpath != null) {\n+            args.add(\"-classpath\");\n+            args.add(toSearchPath(classpath));\n+        }\n+        if (sourcepath != null) {\n+            args.add(\"-sourcepath\");\n+            args.add(toSearchPath(sourcepath));\n+        }\n+        if (classes != null)\n+            args.addAll(classes);\n+        if (files != null)\n+            args.addAll(files);\n+\n+        return args;\n+    }\n+\n+    private String toSearchPath(List<Path> files) {\n+        return files.stream()\n+            .map(Path::toString)\n+            .collect(Collectors.joining(File.pathSeparator));\n+    }\n+\n+    private Iterable<? extends JavaFileObject> joinFiles(\n+            List<String> files, List<JavaFileObject> fileObjects) {\n+        if (files == null)\n+            return fileObjects;\n+        if (internalFileManager == null)\n+            internalFileManager = jdtool.getStandardFileManager(null, null, null);\n+        Iterable<? extends JavaFileObject> filesAsFileObjects =\n+                internalFileManager.getJavaFileObjectsFromStrings(files);\n+        if (fileObjects == null)\n+            return filesAsFileObjects;\n+        List<JavaFileObject> combinedList = new ArrayList<>();\n+        for (JavaFileObject o : filesAsFileObjects)\n+            combinedList.add(o);\n+        combinedList.addAll(fileObjects);\n+        return combinedList;\n+    }\n+}\n","filename":"test\/junit\/toolbox\/JavadocTask.java","additions":418,"deletions":0,"binary":false,"changes":418,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package toolbox;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * A task to configure and run the disassembler tool, javap.\n+ *\/\n+public class JavapTask extends AbstractTask<JavapTask> {\n+    private String classpath;\n+    private List<String> options;\n+    private List<String> classes;\n+\n+    \/**\n+     * Create a task to execute {@code javap} using {@code CMDLINE} mode.\n+     * @param toolBox the {@code ToolBox} to use\n+     *\/\n+    public JavapTask(ToolBox toolBox) {\n+        super(toolBox, Task.Mode.CMDLINE);\n+    }\n+\n+    \/**\n+     * Sets the classpath.\n+     * @param classpath the classpath\n+     * @return this task object\n+     *\/\n+    public JavapTask classpath(String classpath) {\n+        this.classpath = classpath;\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the options.\n+     * @param options the options\n+     * @return this task object\n+     *\/\n+    public JavapTask options(String... options) {\n+        this.options = Arrays.asList(options);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the classes to be analyzed.\n+     * @param classes the classes\n+     * @return this task object\n+     *\/\n+    public JavapTask classes(String... classes) {\n+        this.classes = Arrays.asList(classes);\n+        return this;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @return the name \"javap\"\n+     *\/\n+    @Override\n+    public String name() {\n+        return \"javap\";\n+    }\n+\n+    \/**\n+     * Calls the javap tool with the arguments as currently configured.\n+     * @return a Result object indicating the outcome of the task\n+     * and the content of any output written to stdout, stderr, or the\n+     * main stream.\n+     * @throws TaskError if the outcome of the task is not as expected.\n+     *\/\n+    @Override\n+    public Task.Result run() {\n+        List<String> args = new ArrayList<>();\n+        if (options != null)\n+            args.addAll(options);\n+        if (classpath != null) {\n+            args.add(\"-classpath\");\n+            args.add(classpath);\n+        }\n+        if (classes != null)\n+            args.addAll(classes);\n+\n+        AbstractTask.WriterOutput direct = new AbstractTask.WriterOutput();\n+        \/\/ These are to catch output to System.out and System.err,\n+        \/\/ in case these are used instead of the primary streams\n+        AbstractTask.StreamOutput sysOut = new AbstractTask.StreamOutput(System.out, System::setOut);\n+        AbstractTask.StreamOutput sysErr = new AbstractTask.StreamOutput(System.err, System::setErr);\n+\n+        int rc;\n+        Map<Task.OutputKind, String> outputMap = new HashMap<>();\n+        try {\n+            String[] argsArray = args.toArray(new String[args.size()]);\n+            java.util.spi.ToolProvider javapTool = java.util.spi.ToolProvider.findFirst(\"javap\")\n+                    .orElseThrow(() -> new Error(\"can't find javap\"));\n+            rc = javapTool.run(direct.pw, direct.pw, argsArray);\n+        } finally {\n+            outputMap.put(Task.OutputKind.STDOUT, sysOut.close());\n+            outputMap.put(Task.OutputKind.STDERR, sysErr.close());\n+            outputMap.put(Task.OutputKind.DIRECT, direct.close());\n+        }\n+        return checkExit(new Task.Result(toolBox, this, rc, outputMap));\n+    }\n+}\n","filename":"test\/junit\/toolbox\/JavapTask.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,306 @@\n+\/*\n+ * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package toolbox;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Builder for module declarations.\n+ *\/\n+public class ModuleBuilder {\n+\n+    private final ToolBox tb;\n+    private final String name;\n+    private String comment = \"\";\n+    private boolean open;\n+    private List<String> requires = new ArrayList<>();\n+    private List<String> exports = new ArrayList<>();\n+    private List<String> opens = new ArrayList<>();\n+    private List<String> uses = new ArrayList<>();\n+    private List<String> provides = new ArrayList<>();\n+    private List<String> content = new ArrayList<>();\n+    private Set<Path> modulePath = new LinkedHashSet<>();\n+\n+    \/**\n+     * Creates a builder for a module.\n+     * @param tb a Toolbox that can be used to compile the module declaration\n+     * @param name the name of the module to be built\n+     *\/\n+    public ModuleBuilder(ToolBox tb, String name) {\n+        this(tb, false, name);\n+    }\n+\n+    \/**\n+     * Creates a builder for a module.\n+     * @param tb a Toolbox that can be used to compile the module declaration\n+     * @param open whether or not this is an open module\n+     * @param name the name of the module to be built\n+     *\/\n+    public ModuleBuilder(ToolBox tb, boolean open, String name) {\n+        this.tb = tb;\n+        this.open = open;\n+        this.name = name;\n+    }\n+\n+    \/**\n+     * Sets the doc comment for the declaration.\n+     * @param comment the content of the comment, excluding the initial\n+     *  '\/**', leading whitespace and asterisks, and the final trailing '&#02a;\/'.\n+     * @return this builder\n+     *\/\n+    public ModuleBuilder comment(String comment) {\n+        this.comment = comment;\n+        return this;\n+    }\n+\n+    \/**\n+     * Adds a \"requires\" directive to the declaration.\n+     * @param module the name of the module that is required\n+     * @param modulePath a path in which to locate the modules\n+     *    if the declaration is compiled\n+     * @return this builder\n+     *\/\n+    public ModuleBuilder requires(String module, Path... modulePath) {\n+        addDirective(requires, \"requires \" + module + \";\");\n+        this.modulePath.addAll(Arrays.asList(modulePath));\n+        return this;\n+\n+    }\n+\n+    \/**\n+     * Adds a \"requires\" directive to the declaration.\n+     * @param module the name of the module that is required\n+     * @param isStatic indicates a static dependency\n+     * @param isTransitive indicates a transitive dependency\n+     * @param modulePath a path in which to locate the modules\n+     *    if the declaration is compiled\n+     * @return this builder\n+     *\/\n+    public ModuleBuilder requires(String module, boolean isStatic, boolean isTransitive, Path... modulePath) {\n+        addDirective(requires, \"requires \"\n+                + (isStatic ? \"static \" : \"\")\n+                + (isTransitive ? \"transitive \" : \"\")\n+                + module + \";\");\n+        this.modulePath.addAll(Arrays.asList(modulePath));\n+        return this;\n+\n+    }\n+\n+    \/**\n+     * Adds a \"requires static\" directive to the declaration.\n+     * @param module the name of the module that is required\n+     * @param modulePath a path in which to locate the modules\n+     *    if the declaration is compiled\n+     * @return this builder\n+     *\/\n+    public ModuleBuilder requiresStatic(String module, Path... modulePath) {\n+        addDirective(requires, \"requires static \" + module + \";\");\n+        this.modulePath.addAll(Arrays.asList(modulePath));\n+        return this;\n+    }\n+\n+    \/**\n+     * Adds a \"requires transitive\" directive to the declaration.\n+     * @param module the name of the module that is required\n+     * @param modulePath a path in which to locate the modules\n+     *    if the declaration is compiled\n+     * @return this builder\n+     *\/\n+    public ModuleBuilder requiresTransitive(String module, Path... modulePath) {\n+        addDirective(requires, \"requires transitive \" + module + \";\");\n+        this.modulePath.addAll(Arrays.asList(modulePath));\n+        return this;\n+    }\n+\n+    \/**\n+     * Adds a \"requires static transitive\" directive to the declaration.\n+     * @param module the name of the module that is required\n+     * @param modulePath a path in which to locate the modules\n+     *    if the declaration is compiled\n+     * @return this builder\n+     *\/\n+    public ModuleBuilder requiresStaticTransitive(String module, Path... modulePath) {\n+        addDirective(requires, \"requires static transitive \" + module + \";\");\n+        this.modulePath.addAll(Arrays.asList(modulePath));\n+        return this;\n+    }\n+\n+    \/**\n+     * Adds an unqualified \"exports\" directive to the declaration.\n+     * @param pkg the name of the package to be exported\n+     * @return this builder\n+     *\/\n+    public ModuleBuilder exports(String pkg) {\n+        return addDirective(exports, \"exports \" + pkg + \";\");\n+    }\n+\n+    \/**\n+     * Adds a qualified \"exports\" directive to the declaration.\n+     * @param pkg the name of the package to be exported\n+     * @param modules the names of the modules to which it is to be exported\n+     * @return this builder\n+     *\/\n+    public ModuleBuilder exportsTo(String pkg, String... modules) {\n+        return addDirective(exports, \"exports \" + pkg\n+                + (modules.length == 0 ? \"\" : \" to \" + String.join(\", \", modules) + \";\"));\n+    }\n+\n+    \/**\n+     * Adds an unqualified \"opens\" directive to the declaration.\n+     * @param pkg the name of the package to be opened\n+     * @return this builder\n+     *\/\n+    public ModuleBuilder opens(String pkg) {\n+        return addDirective(opens, \"opens \" + pkg + \";\");\n+    }\n+\n+    \/**\n+     * Adds a qualified \"opens\" directive to the declaration.\n+     * @param pkg the name of the package to be opened\n+     * @param modules the names of the modules to which it is to be opened\n+     * @return this builder\n+     *\/\n+    public ModuleBuilder opensTo(String pkg, String... modules) {\n+        return addDirective(opens, \"opens \" + pkg\n+                + (modules.length == 0 ? \"\" : \" to \" + String.join(\", \", modules) + \";\"));\n+    }\n+\n+    \/**\n+     * Adds a \"uses\" directive to the declaration.\n+     * @param service the name of the service type\n+     * @return this builder\n+     *\/\n+    public ModuleBuilder uses(String service) {\n+        return addDirective(uses, \"uses \" + service + \";\");\n+    }\n+\n+    \/**\n+     * Adds a \"provides\" directive to the declaration.\n+     * @param service the name of the service type\n+     * @param implementations the names of the implementation types\n+     * @return this builder\n+     *\/\n+    public ModuleBuilder provides(String service, String... implementations) {\n+        return addDirective(provides, \"provides \" + service\n+                + (implementations.length == 0 ? \"\" : \" with \" + String.join(\", \", implementations) + \";\"));\n+    }\n+\n+    private ModuleBuilder addDirective(List<String> directives, String directive) {\n+        directives.add(directive);\n+        return this;\n+    }\n+\n+    \/**\n+     * Adds type definitions to the module.\n+     * @param content a series of strings, each representing the content of\n+     *  a compilation unit to be included with the module\n+     * @return this builder\n+     *\/\n+    public ModuleBuilder classes(String... content) {\n+        this.content.addAll(Arrays.asList(content));\n+        return this;\n+    }\n+\n+    \/**\n+     * Writes the module declaration and associated additional compilation\n+     * units to a module directory within a given directory.\n+     *\n+     * @param srcDir the directory in which a directory will be created\n+     *  to contain the source files for the module\n+     * @return the directory containing the source files for the module\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    public Path write(Path srcDir) throws IOException {\n+        Files.createDirectories(srcDir);\n+        List<String> sources = new ArrayList<>();\n+        StringBuilder sb = new StringBuilder();\n+        if (!comment.isEmpty()) {\n+            if (comment.startsWith(\"\/**\")) {\n+                sb.append(comment);\n+            } else {\n+                sb.append(\"\/**\\n * \")\n+                        .append(comment.replace(\"\\n\", \"\\n * \"))\n+                        .append(\"\\n *\/\\n\");\n+            }\n+        }\n+        if (open) {\n+            sb.append(\"open \");\n+        }\n+        sb.append(\"module \").append(name).append(\" {\\n\");\n+        requires.forEach(r -> sb.append(\"    \" + r + \"\\n\"));\n+        exports.forEach(e -> sb.append(\"    \" + e + \"\\n\"));\n+        opens.forEach(o -> sb.append(\"    \" + o + \"\\n\"));\n+        uses.forEach(u -> sb.append(\"    \" + u + \"\\n\"));\n+        provides.forEach(p -> sb.append(\"    \" + p + \"\\n\"));\n+        sb.append(\"}\");\n+        sources.add(sb.toString());\n+        sources.addAll(content);\n+        Path moduleSrc = srcDir.resolve(name);\n+        tb.writeJavaFiles(moduleSrc, sources.toArray(new String[]{}));\n+        return moduleSrc;\n+    }\n+\n+    \/**\n+     * Writes the source files for the module to an interim directory,\n+     * and then compiles them to a given directory.\n+     * @param modules the directory in which a directory will be created\n+     *    to contain the compiled class files for the module\n+     * @throws IOException if an error occurs while compiling the files\n+     *\/\n+    public void build(Path modules) throws IOException {\n+        build(Paths.get(modules + \"Src\"), modules);\n+    }\n+\n+    \/**\n+     * Writes the source files for the module to a specified directory,\n+     * and then compiles them to a given directory.\n+     * @param src the directory in which a directory will be created\n+     *  to contain the source files for the module\n+     * @param modules the directory in which a directory will be created\n+     *    to contain the compiled class files for the module\n+     * @throws IOException if an error occurs while compiling the files\n+     *\/\n+    public void build(Path src, Path modules) throws IOException {\n+        Path moduleSrc = write(src);\n+        String mp = modulePath.stream()\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        new JavacTask(tb)\n+                .outdir(Files.createDirectories(modules.resolve(name)))\n+                .options(\"--module-path\", mp)\n+                .files(tb.findJavaFiles(moduleSrc))\n+                .run()\n+                .writeAll();\n+    }\n+}\n","filename":"test\/junit\/toolbox\/ModuleBuilder.java","additions":306,"deletions":0,"binary":false,"changes":306,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package toolbox;\n+\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import static toolbox.ToolBox.lineSeparator;\n+\n+\/**\n+ * The supertype for tasks.\n+ * Complex operations are modeled by building and running a \"Task\" object.\n+ * Tasks are typically configured in a fluent series of calls.\n+ *\/\n+public interface Task {\n+    \/**\n+     * Returns the name of the task.\n+     * @return the name of the task\n+     *\/\n+    String name();\n+\n+    \/**\n+     * Executes the task as currently configured.\n+     * @return a Result object containing the results of running the task\n+     * @throws TaskError if the outcome of the task was not as expected\n+     *\/\n+    Result run() throws TaskError;\n+\n+    \/**\n+     * Exception thrown by {@code Task.run} when the outcome is not as\n+     * expected.\n+     *\/\n+    public static class TaskError extends Error {\n+        private static final long serialVersionUID = 0;\n+\n+        \/**\n+         * Creates a TaskError object with the given message.\n+         * @param message the message\n+         *\/\n+        public TaskError(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    \/**\n+     * An enum to indicate the mode a task should use it is when executed.\n+     *\/\n+    public enum Mode {\n+        \/**\n+         * The task should use the interface used by the command\n+         * line launcher for the task.\n+         * For example, for javac: com.sun.tools.javac.Main.compile\n+         *\/\n+        CMDLINE,\n+        \/**\n+         * The task should use a publicly defined API for the task.\n+         * For example, for javac: javax.tools.JavaCompiler\n+         *\/\n+        API,\n+        \/**\n+         * The task should use the standard launcher for the task.\n+         * For example, $JAVA_HOME\/bin\/javac\n+         *\/\n+        EXEC\n+    }\n+\n+    \/**\n+     * An enum to indicate the expected success or failure of executing a task.\n+     *\/\n+    public enum Expect {\n+        \/** It is expected that the task will complete successfully. *\/\n+        SUCCESS,\n+        \/** It is expected that the task will not complete successfully. *\/\n+        FAIL\n+    }\n+\n+    \/**\n+     * An enum to identify the streams that may be written by a {@code Task}.\n+     *\/\n+    public enum OutputKind {\n+        \/** Identifies output written to {@code System.out} or {@code stdout}. *\/\n+        STDOUT,\n+        \/** Identifies output written to {@code System.err} or {@code stderr}. *\/\n+        STDERR,\n+        \/** Identifies output written to a stream provided directly to the task. *\/\n+        DIRECT\n+    };\n+\n+    \/**\n+     * The results from running a {@link Task}.\n+     * The results contain the exit code returned when the tool was invoked,\n+     * and a map containing the output written to any streams during the\n+     * execution of the tool.\n+     * All tools support \"stdout\" and \"stderr\".\n+     * Tools that take an explicit PrintWriter save output written to that\n+     * stream as \"main\".\n+     *\/\n+    public static class Result {\n+        final ToolBox toolBox;\n+        final Task task;\n+        final int exitCode;\n+        final Map<OutputKind, String> outputMap;\n+\n+        Result(ToolBox toolBox, Task task, int exitCode, Map<OutputKind, String> outputMap) {\n+            this.toolBox = toolBox;\n+            this.task = task;\n+            this.exitCode = exitCode;\n+            this.outputMap = outputMap;\n+        }\n+\n+        \/**\n+         * Returns the content of a specified stream.\n+         * @param outputKind the kind of the selected stream\n+         * @return the content that was written to that stream when the tool\n+         *  was executed.\n+         *\/\n+        public String getOutput(OutputKind outputKind) {\n+            return outputMap.get(outputKind);\n+        }\n+\n+        \/**\n+         * Returns the content of named streams as a list of lines.\n+         * @param outputKinds the kinds of the selected streams\n+         * @return the content that was written to the given streams when the tool\n+         *  was executed.\n+         *\/\n+        public List<String> getOutputLines(OutputKind... outputKinds) {\n+            List<String> result = new ArrayList<>();\n+            for (OutputKind outputKind : outputKinds) {\n+                result.addAll(Arrays.asList(outputMap.get(outputKind).split(lineSeparator)));\n+            }\n+            return result;\n+        }\n+\n+        \/**\n+         * Writes the content of the specified stream to the log.\n+         * @param kind the kind of the selected stream\n+         * @return this Result object\n+         *\/\n+        public Result write(OutputKind kind) {\n+            PrintStream out = toolBox.out;\n+            String text = getOutput(kind);\n+            if (text == null || text.isEmpty())\n+                out.println(\"[\" + task.name() + \":\" + kind + \"]: empty\");\n+            else {\n+                out.println(\"[\" + task.name() + \":\" + kind + \"]:\");\n+                out.print(text);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Writes the content of all streams with any content to the log.\n+         * @return this Result object\n+         *\/\n+        public Result writeAll() {\n+            PrintStream out = toolBox.out;\n+            outputMap.forEach((name, text) -> {\n+                if (!text.isEmpty()) {\n+                    out.println(\"[\" + name + \"]:\");\n+                    out.print(text);\n+                }\n+            });\n+            return this;\n+        }\n+    }\n+}\n+\n","filename":"test\/junit\/toolbox\/Task.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,740 @@\n+\/*\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package toolbox;\n+\n+import java.io.BufferedWriter;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FilterOutputStream;\n+import java.io.FilterWriter;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.net.URI;\n+import java.nio.charset.Charset;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import javax.tools.FileObject;\n+import javax.tools.ForwardingJavaFileManager;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+\/**\n+ * Utility methods and classes for writing jtreg tests for\n+ * javac, javap, and sjavac.\n+ * (For javadoc support, see JavadocTester.)\n+ *\n+ * <p>There is support for common file operations similar to\n+ * shell commands like cat, cp, diff, mv, rm, grep.\n+ *\n+ * <p>There is also support for invoking various tools, like\n+ * javac, javap, jar, java and other JDK tools.\n+ *\n+ * <p><em>File separators<\/em>: for convenience, many operations accept strings\n+ * to represent file names. On all platforms on which JDK is supported,\n+ * \"\/\" is a legal filename component separator. In particular, even\n+ * on Windows, where the official file separator is \"\\\", \"\/\" is a legal\n+ * alternative. It is therefore recommended that any client code using\n+ * strings to specify file names should use \"\/\".\n+ *\n+ * @author Vicente Romero (original)\n+ * @author Jonathan Gibbons (revised)\n+ *\/\n+public class ToolBox {\n+    \/** The platform line separator. *\/\n+    public static final String lineSeparator = System.getProperty(\"line.separator\");\n+    \/** The platform OS name. *\/\n+    public static final String osName = System.getProperty(\"os.name\");\n+\n+    \/** The location of the class files for this test, or null if not set. *\/\n+    public static final String testClasses = System.getProperty(\"test.classes\");\n+    \/** The location of the source files for this test, or null if not set. *\/\n+    public static final String testSrc = System.getProperty(\"test.src\");\n+    \/** The location of the test JDK for this test, or null if not set. *\/\n+    public static final String testJDK = System.getProperty(\"test.jdk\");\n+\n+    \/** The current directory. *\/\n+    public static final Path currDir = Paths.get(\".\");\n+\n+    \/** The stream used for logging output. *\/\n+    public PrintStream out = System.err;\n+\n+    \/**\n+     * Checks if the host OS is some version of Windows.\n+     * @return true if the host OS is some version of Windows\n+     *\/\n+    public boolean isWindows() {\n+        return osName.toLowerCase(Locale.ENGLISH).startsWith(\"windows\");\n+    }\n+\n+    \/**\n+     * Splits a string around matches of the given regular expression.\n+     * If the string is empty, an empty list will be returned.\n+     * @param text the string to be split\n+     * @param sep  the delimiting regular expression\n+     * @return the strings between the separators\n+     *\/\n+    public List<String> split(String text, String sep) {\n+        if (text.isEmpty())\n+            return Collections.emptyList();\n+        return Arrays.asList(text.split(sep));\n+    }\n+\n+    \/**\n+     * Checks if two lists of strings are equal.\n+     * @param l1 the first list of strings to be compared\n+     * @param l2 the second list of strings to be compared\n+     * @throws Error if the lists are not equal\n+     *\/\n+    public void checkEqual(List<String> l1, List<String> l2) throws Error {\n+        if (!Objects.equals(l1, l2)) {\n+            \/\/ l1 and l2 cannot both be null\n+            if (l1 == null)\n+                throw new Error(\"comparison failed: l1 is null\");\n+            if (l2 == null)\n+                throw new Error(\"comparison failed: l2 is null\");\n+            \/\/ report first difference\n+            for (int i = 0; i < Math.min(l1.size(), l2.size()); i++) {\n+                String s1 = l1.get(i);\n+                String s2 = l2.get(i);\n+                if (!Objects.equals(s1, s2)) {\n+                    throw new Error(\"comparison failed, index \" + i +\n+                            \", (\" + s1 + \":\" + s2 + \")\");\n+                }\n+            }\n+            throw new Error(\"comparison failed: l1.size=\" + l1.size() + \", l2.size=\" + l2.size());\n+        }\n+    }\n+\n+    \/**\n+     * Filters a list of strings according to the given regular expression.\n+     * @param regex the regular expression\n+     * @param lines the strings to be filtered\n+     * @return the strings matching the regular expression\n+     *\/\n+    public List<String> grep(String regex, List<String> lines) {\n+        return grep(Pattern.compile(regex), lines);\n+    }\n+\n+    \/**\n+     * Filters a list of strings according to the given regular expression.\n+     * @param pattern the regular expression\n+     * @param lines the strings to be filtered\n+     * @return the strings matching the regular expression\n+     *\/\n+    public List<String> grep(Pattern pattern, List<String> lines) {\n+        return lines.stream()\n+                .filter(s -> pattern.matcher(s).find())\n+                .collect(Collectors.toList());\n+    }\n+\n+    \/**\n+     * Copies a file.\n+     * If the given destination exists and is a directory, the copy is created\n+     * in that directory.  Otherwise, the copy will be placed at the destination,\n+     * possibly overwriting any existing file.\n+     * <p>Similar to the shell \"cp\" command: {@code cp from to}.\n+     * @param from the file to be copied\n+     * @param to where to copy the file\n+     * @throws IOException if any error occurred while copying the file\n+     *\/\n+    public void copyFile(String from, String to) throws IOException {\n+        copyFile(Paths.get(from), Paths.get(to));\n+    }\n+\n+    \/**\n+     * Copies a file.\n+     * If the given destination exists and is a directory, the copy is created\n+     * in that directory.  Otherwise, the copy will be placed at the destination,\n+     * possibly overwriting any existing file.\n+     * <p>Similar to the shell \"cp\" command: {@code cp from to}.\n+     * @param from the file to be copied\n+     * @param to where to copy the file\n+     * @throws IOException if an error occurred while copying the file\n+     *\/\n+    public void copyFile(Path from, Path to) throws IOException {\n+        if (Files.isDirectory(to)) {\n+            to = to.resolve(from.getFileName());\n+        } else {\n+            Files.createDirectories(to.getParent());\n+        }\n+        Files.copy(from, to, StandardCopyOption.REPLACE_EXISTING);\n+    }\n+\n+    \/**\n+     * Creates one of more directories.\n+     * For each of the series of paths, a directory will be created,\n+     * including any necessary parent directories.\n+     * <p>Similar to the shell command: {@code mkdir -p paths}.\n+     * @param paths the directories to be created\n+     * @throws IOException if an error occurred while creating the directories\n+     *\/\n+    public void createDirectories(String... paths) throws IOException {\n+        if (paths.length == 0)\n+            throw new IllegalArgumentException(\"no directories specified\");\n+        for (String p : paths)\n+            Files.createDirectories(Paths.get(p));\n+    }\n+\n+    \/**\n+     * Creates one or more directories.\n+     * For each of the series of paths, a directory will be created,\n+     * including any necessary parent directories.\n+     * <p>Similar to the shell command: {@code mkdir -p paths}.\n+     * @param paths the directories to be created\n+     * @throws IOException if an error occurred while creating the directories\n+     *\/\n+    public void createDirectories(Path... paths) throws IOException {\n+        if (paths.length == 0)\n+            throw new IllegalArgumentException(\"no directories specified\");\n+        for (Path p : paths)\n+            Files.createDirectories(p);\n+    }\n+\n+    \/**\n+     * Deletes one or more files.\n+     * Any directories to be deleted must be empty.\n+     * <p>Similar to the shell command: {@code rm files}.\n+     * @param files the files to be deleted\n+     * @throws IOException if an error occurred while deleting the files\n+     *\/\n+    public void deleteFiles(String... files) throws IOException {\n+        if (files.length == 0)\n+            throw new IllegalArgumentException(\"no files specified\");\n+        for (String file : files)\n+            Files.delete(Paths.get(file));\n+    }\n+\n+    \/**\n+     * Deletes all content of a directory (but not the directory itself).\n+     * @param root the directory to be cleaned\n+     * @throws IOException if an error occurs while cleaning the directory\n+     *\/\n+    public Path cleanDirectory(Path root) throws IOException {\n+        if (!Files.isDirectory(root)) {\n+            throw new IOException(root + \" is not a directory\");\n+        }\n+        Files.walkFileTree(root, new SimpleFileVisitor<>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes a) throws IOException {\n+                Files.delete(file);\n+                return FileVisitResult.CONTINUE;\n+            }\n+\n+            @Override\n+            public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {\n+                if (e != null) {\n+                    throw e;\n+                }\n+                if (!dir.equals(root)) {\n+                    Files.delete(dir);\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+        });\n+        return root;\n+    }\n+\n+    \/**\n+     * Moves a file.\n+     * If the given destination exists and is a directory, the file will be moved\n+     * to that directory.  Otherwise, the file will be moved to the destination,\n+     * possibly overwriting any existing file.\n+     * <p>Similar to the shell \"mv\" command: {@code mv from to}.\n+     * @param from the file to be moved\n+     * @param to where to move the file\n+     * @throws IOException if an error occurred while moving the file\n+     *\/\n+    public void moveFile(String from, String to) throws IOException {\n+        moveFile(Paths.get(from), Paths.get(to));\n+    }\n+\n+    \/**\n+     * Moves a file.\n+     * If the given destination exists and is a directory, the file will be moved\n+     * to that directory.  Otherwise, the file will be moved to the destination,\n+     * possibly overwriting any existing file.\n+     * <p>Similar to the shell \"mv\" command: {@code mv from to}.\n+     * @param from the file to be moved\n+     * @param to where to move the file\n+     * @throws IOException if an error occurred while moving the file\n+     *\/\n+    public void moveFile(Path from, Path to) throws IOException {\n+        if (Files.isDirectory(to)) {\n+            to = to.resolve(from.getFileName());\n+        } else {\n+            Files.createDirectories(to.getParent());\n+        }\n+        Files.move(from, to, StandardCopyOption.REPLACE_EXISTING);\n+    }\n+\n+    \/**\n+     * Reads the lines of a file.\n+     * The file is read using the default character encoding.\n+     * @param path the file to be read\n+     * @return the lines of the file\n+     * @throws IOException if an error occurred while reading the file\n+     *\/\n+    public List<String> readAllLines(String path) throws IOException {\n+        return readAllLines(path, null);\n+    }\n+\n+    \/**\n+     * Reads the lines of a file.\n+     * The file is read using the default character encoding.\n+     * @param path the file to be read\n+     * @return the lines of the file\n+     * @throws IOException if an error occurred while reading the file\n+     *\/\n+    public List<String> readAllLines(Path path) throws IOException {\n+        return readAllLines(path, null);\n+    }\n+\n+    \/**\n+     * Reads the lines of a file using the given encoding.\n+     * @param path the file to be read\n+     * @param encoding the encoding to be used to read the file\n+     * @return the lines of the file.\n+     * @throws IOException if an error occurred while reading the file\n+     *\/\n+    public List<String> readAllLines(String path, String encoding) throws IOException {\n+        return readAllLines(Paths.get(path), encoding);\n+    }\n+\n+    \/**\n+     * Reads the lines of a file using the given encoding.\n+     * @param path the file to be read\n+     * @param encoding the encoding to be used to read the file\n+     * @return the lines of the file\n+     * @throws IOException if an error occurred while reading the file\n+     *\/\n+    public List<String> readAllLines(Path path, String encoding) throws IOException {\n+        return Files.readAllLines(path, getCharset(encoding));\n+    }\n+\n+    private Charset getCharset(String encoding) {\n+        return (encoding == null) ? Charset.defaultCharset() : Charset.forName(encoding);\n+    }\n+\n+    \/**\n+     * Find .java files in one or more directories.\n+     * <p>Similar to the shell \"find\" command: {@code find paths -name \\*.java}.\n+     * @param paths the directories in which to search for .java files\n+     * @return the .java files found\n+     * @throws IOException if an error occurred while searching for files\n+     *\/\n+    public Path[] findJavaFiles(Path... paths) throws IOException {\n+        return findFiles(\".java\", paths);\n+    }\n+\n+    \/**\n+     * Find files matching the file extension, in one or more directories.\n+     * <p>Similar to the shell \"find\" command: {@code find paths -name \\*.ext}.\n+     * @param fileExtension the extension to search for\n+     * @param paths the directories in which to search for files\n+     * @return the files matching the file extension\n+     * @throws IOException if an error occurred while searching for files\n+     *\/\n+    public Path[] findFiles(String fileExtension, Path... paths) throws IOException {\n+        Set<Path> files = new TreeSet<>();  \/\/ use TreeSet to force a consistent order\n+        for (Path p : paths) {\n+            Files.walkFileTree(p, new SimpleFileVisitor<>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n+                    if (file.getFileName().toString().endsWith(fileExtension)) {\n+                        files.add(file);\n+                    }\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        return files.toArray(new Path[0]);\n+    }\n+\n+    \/**\n+     * Writes a file containing the given content.\n+     * Any necessary directories for the file will be created.\n+     * @param path where to write the file\n+     * @param content the content for the file\n+     * @throws IOException if an error occurred while writing the file\n+     *\/\n+    public void writeFile(String path, String content) throws IOException {\n+        writeFile(Paths.get(path), content);\n+    }\n+\n+    \/**\n+     * Writes a file containing the given content.\n+     * Any necessary directories for the file will be created.\n+     * @param path where to write the file\n+     * @param content the content for the file\n+     * @throws IOException if an error occurred while writing the file\n+     *\/\n+    public void writeFile(Path path, String content) throws IOException {\n+        Path dir = path.getParent();\n+        if (dir != null)\n+            Files.createDirectories(dir);\n+        try (BufferedWriter w = Files.newBufferedWriter(path)) {\n+            w.write(content);\n+        }\n+    }\n+\n+    \/**\n+     * Writes one or more files containing Java source code.\n+     * For each file to be written, the filename will be inferred from the\n+     * given base directory, the package declaration (if present) and from the\n+     * the name of the first class, interface or enum declared in the file.\n+     * <p>For example, if the base directory is \/my\/dir\/ and the content\n+     * contains \"package p; class C { }\", the file will be written to\n+     * \/my\/dir\/p\/C.java.\n+     * <p>Note: the content is analyzed using regular expressions;\n+     * errors can occur if any contents have initial comments that might trip\n+     * up the analysis.\n+     * @param dir the base directory\n+     * @param contents the contents of the files to be written\n+     * @throws IOException if an error occurred while writing any of the files.\n+     *\/\n+    public void writeJavaFiles(Path dir, String... contents) throws IOException {\n+        if (contents.length == 0)\n+            throw new IllegalArgumentException(\"no content specified for any files\");\n+        for (String c : contents) {\n+            new JavaSource(c).write(dir);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the path for the binary of a JDK tool within {@link #testJDK}.\n+     * @param tool the name of the tool\n+     * @return the path of the tool\n+     *\/\n+    public Path getJDKTool(String tool) {\n+        return Paths.get(testJDK, \"bin\", tool);\n+    }\n+\n+    \/**\n+     * Returns a string representing the contents of an {@code Iterable} as a list.\n+     * @param <T> the type parameter of the {@code Iterable}\n+     * @param items the iterable\n+     * @return the string\n+     *\/\n+    <T> String toString(Iterable<T> items) {\n+        return StreamSupport.stream(items.spliterator(), false)\n+                .map(Objects::toString)\n+                .collect(Collectors.joining(\",\", \"[\", \"]\"));\n+    }\n+\n+\n+    \/**\n+     * An in-memory Java source file.\n+     * It is able to extract the file name from simple source text using\n+     * regular expressions.\n+     *\/\n+    public static class JavaSource extends SimpleJavaFileObject {\n+        private final String source;\n+\n+        \/**\n+         * Creates a in-memory file object for Java source code.\n+         * @param className the name of the class\n+         * @param source the source text\n+         *\/\n+        public JavaSource(String className, String source) {\n+            super(URI.create(className), JavaFileObject.Kind.SOURCE);\n+            this.source = source;\n+        }\n+\n+        \/**\n+         * Creates a in-memory file object for Java source code.\n+         * The name of the class will be inferred from the source code.\n+         * @param source the source text\n+         *\/\n+        public JavaSource(String source) {\n+            super(URI.create(getJavaFileNameFromSource(source)),\n+                    JavaFileObject.Kind.SOURCE);\n+            this.source = source;\n+        }\n+\n+        \/**\n+         * Writes the source code to a file in the current directory.\n+         * @throws IOException if there is a problem writing the file\n+         *\/\n+        public void write() throws IOException {\n+            write(currDir);\n+        }\n+\n+        \/**\n+         * Writes the source code to a file in a specified directory.\n+         * @param dir the directory\n+         * @throws IOException if there is a problem writing the file\n+         *\/\n+        public void write(Path dir) throws IOException {\n+            Path file = dir.resolve(getJavaFileNameFromSource(source));\n+            Files.createDirectories(file.getParent());\n+            try (BufferedWriter out = Files.newBufferedWriter(file)) {\n+                out.write(source.replace(\"\\n\", lineSeparator));\n+            }\n+        }\n+\n+        @Override\n+        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+            return source;\n+        }\n+\n+        private static Pattern commentPattern =\n+                Pattern.compile(\"(?s)(\\\\s+\/\/.*?\\n|\/\\\\*.*?\\\\*\/)\");\n+        private static Pattern modulePattern =\n+                Pattern.compile(\"module\\\\s+((?:\\\\w+\\\\.)*)\");\n+        private static Pattern packagePattern =\n+                Pattern.compile(\"package\\\\s+(((?:\\\\w+\\\\.)*)(?:\\\\w+))\");\n+        private static Pattern classPattern =\n+                Pattern.compile(\"(?:class|enum|interface|record)\\\\s+(\\\\w+)\");\n+\n+        \/**\n+         * Extracts the Java file name from the class declaration.\n+         * This method is intended for simple files and uses regular expressions.\n+         * Comments in the source are stripped before looking for the\n+         * declarations from which the name is derived.\n+         *\/\n+        static String getJavaFileNameFromSource(String source) {\n+            StringBuilder sb = new StringBuilder();\n+            Matcher matcher = commentPattern.matcher(source);\n+            int start = 0;\n+            while (matcher.find()) {\n+                sb.append(source, start, matcher.start());\n+                start = matcher.end();\n+            }\n+            sb.append(source.substring(start));\n+            source = sb.toString();\n+\n+            String packageName = null;\n+\n+            matcher = modulePattern.matcher(source);\n+            if (matcher.find())\n+                return \"module-info.java\";\n+\n+            matcher = packagePattern.matcher(source);\n+            if (matcher.find())\n+                packageName = matcher.group(1).replace(\".\", \"\/\");\n+\n+            matcher = classPattern.matcher(source);\n+            if (matcher.find()) {\n+                String className = matcher.group(1) + \".java\";\n+                return (packageName == null) ? className : packageName + \"\/\" + className;\n+            } else if (packageName != null) {\n+                return packageName + \"\/package-info.java\";\n+            } else {\n+                throw new Error(\"Could not extract the java class \" +\n+                        \"name from the provided source\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Extracts the Java file name from the class declaration.\n+     * This method is intended for simple files and uses regular expressions,\n+     * so comments matching the pattern can make the method fail.\n+     * @deprecated This is a legacy method for compatibility with ToolBox v1.\n+     *      Use {@link JavaSource#getName JavaSource.getName} instead.\n+     * @param source the source text\n+     * @return the Java file name inferred from the source\n+     *\/\n+    @Deprecated\n+    public static String getJavaFileNameFromSource(String source) {\n+        return JavaSource.getJavaFileNameFromSource(source);\n+    }\n+\n+    \/**\n+     * A memory file manager, for saving generated files in memory.\n+     * The file manager delegates to a separate file manager for listing and\n+     * reading input files.\n+     *\/\n+    public static class MemoryFileManager extends ForwardingJavaFileManager<JavaFileManager> {\n+        private interface Content {\n+            byte[] getBytes();\n+            String getString();\n+        }\n+\n+        \/**\n+         * Maps binary class names to generated content.\n+         *\/\n+        private final Map<Location, Map<String, Content>> files;\n+\n+        \/**\n+         * Construct a memory file manager which stores output files in memory,\n+         * and delegates to a default file manager for input files.\n+         *\/\n+        public MemoryFileManager() {\n+            this(ToolProvider.getSystemJavaCompiler().getStandardFileManager(null, null, null));\n+        }\n+\n+        \/**\n+         * Construct a memory file manager which stores output files in memory,\n+         * and delegates to a specified file manager for input files.\n+         * @param fileManager the file manager to be used for input files\n+         *\/\n+        public MemoryFileManager(JavaFileManager fileManager) {\n+            super(fileManager);\n+            files = new HashMap<>();\n+        }\n+\n+        @Override\n+        public JavaFileObject getJavaFileForOutput(Location location,\n+                                                   String name,\n+                                                   JavaFileObject.Kind kind,\n+                                                   FileObject sibling)\n+        {\n+            return new MemoryFileObject(location, name, kind);\n+        }\n+\n+        \/**\n+         * Returns the set of names of files that have been written to a given\n+         * location.\n+         * @param location the location\n+         * @return the set of file names\n+         *\/\n+        public Set<String> getFileNames(Location location) {\n+            Map<String, Content> filesForLocation = files.get(location);\n+            return (filesForLocation == null)\n+                ? Collections.emptySet() : filesForLocation.keySet();\n+        }\n+\n+        \/**\n+         * Returns the content written to a file in a given location,\n+         * or null if no such file has been written.\n+         * @param location the location\n+         * @param name the name of the file\n+         * @return the content as an array of bytes\n+         *\/\n+        public byte[] getFileBytes(Location location, String name) {\n+            Content content = getFile(location, name);\n+            return (content == null) ? null : content.getBytes();\n+        }\n+\n+        \/**\n+         * Returns the content written to a file in a given location,\n+         * or null if no such file has been written.\n+         * @param location the location\n+         * @param name the name of the file\n+         * @return the content as a string\n+         *\/\n+        public String getFileString(Location location, String name) {\n+            Content content = getFile(location, name);\n+            return (content == null) ? null : content.getString();\n+        }\n+\n+        private Content getFile(Location location, String name) {\n+            Map<String, Content> filesForLocation = files.get(location);\n+            return (filesForLocation == null) ? null : filesForLocation.get(name);\n+        }\n+\n+        private void save(Location location, String name, Content content) {\n+            Map<String, Content> filesForLocation = files.computeIfAbsent(location, k -> new HashMap<>());\n+            filesForLocation.put(name, content);\n+        }\n+\n+        \/**\n+         * A writable file object stored in memory.\n+         *\/\n+        private class MemoryFileObject extends SimpleJavaFileObject {\n+            private final Location location;\n+            private final String name;\n+\n+            \/**\n+             * Constructs a memory file object.\n+             * @param name binary name of the class to be stored in this file object\n+             *\/\n+            MemoryFileObject(Location location, String name, JavaFileObject.Kind kind) {\n+                super(URI.create(\"mfm:\/\/\/\" + name.replace('.','\/') + kind.extension),\n+                      Kind.CLASS);\n+                this.location = location;\n+                this.name = name;\n+            }\n+\n+            @Override\n+            public OutputStream openOutputStream() {\n+                return new FilterOutputStream(new ByteArrayOutputStream()) {\n+                    @Override\n+                    public void close() throws IOException {\n+                        out.close();\n+                        byte[] bytes = ((ByteArrayOutputStream) out).toByteArray();\n+                        save(location, name, new Content() {\n+                            @Override\n+                            public byte[] getBytes() {\n+                                return bytes;\n+                            }\n+                            @Override\n+                            public String getString() {\n+                                return new String(bytes);\n+                            }\n+\n+                        });\n+                    }\n+                };\n+            }\n+\n+            @Override\n+            public Writer openWriter() {\n+                return new FilterWriter(new StringWriter()) {\n+                    @Override\n+                    public void close() throws IOException {\n+                        out.close();\n+                        String text = out.toString();\n+                        save(location, name, new Content() {\n+                            @Override\n+                            public byte[] getBytes() {\n+                                return text.getBytes();\n+                            }\n+                            @Override\n+                            public String getString() {\n+                                return text;\n+                            }\n+\n+                        });\n+                    }\n+                };\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/junit\/toolbox\/ToolBox.java","additions":740,"deletions":0,"binary":false,"changes":740,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Utilities to assist in writing tests that generate and compile code,\n+ * and related tasks.\n+ *\/\n+package toolbox;\n","filename":"test\/junit\/toolbox\/package-info.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,22 @@\n+# APIDiff `showDocs`\n+\n+`showDocs` is a utility to generate HTML files that show the parts of\n+API documentation files that are extracted by the `APIReader` component of APIDiff.\n+\n+The utility can be built by the rules in `showDocs.gmk`, to generate `showDocs.jar`.\n+\n+## show-demo-docs\n+\n+The utility can be run on the classes in `demo-src` by the rules in `showDocs.gmk`.\n+The rules require that the makefile variable `JDK`_N_`HOME` variable must be set\n+for any JDK for which the output is to be generated.\n+\n+`show-demo-docs.sh` is a demonstration script to show how the `JDK`_N_`HOME`\n+variables can be set up and the makefile rules invoked.\n+\n+## show-jdk-docs\n+\n+`show-jdk-docs.sh` is a script to run `showDocs` on JDK API documentation\n+for specified versions of JDK.  The documentation must be provided in an\n+enclosing directory, containing subdirectories which each contain the\n+documentation for a version of JDK.\n\\ No newline at end of file\n","filename":"test\/showDocs\/README.md","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * This is module {@code m}.\n+ * This is additional information.\n+ * @since 1.0\n+ *\/\n+module m {\n+    exports p;\n+}\n\\ No newline at end of file\n","filename":"test\/showDocs\/demo-src\/m\/module-info.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p;\n+\n+\/**\n+ * This is class {@code C}.\n+ * This is additional information.\n+ * @since 1.0\n+ *\/\n+public class C {\n+    \/**\n+     * This is field {@code f}.\n+     * This is additional information.\n+     * @since 1.0\n+     *\/\n+    public int f;\n+\n+    \/**\n+     * This is method {@code m1}.\n+     * This is additional information.\n+     * @since 1.0\n+     *\/\n+    public void m1() { }\n+\n+    \/**\n+     * This is method {@code m2}.\n+     * This is additional information.\n+     * @param a an argument\n+     * @return a result\n+     * @since 1.0\n+     *\/\n+    public int m2(int a) { return a; }\n+}\n\\ No newline at end of file\n","filename":"test\/showDocs\/demo-src\/m\/p\/C.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p;\n+\n+\/**\n+ * This is class {@code E}.\n+ * This is additional information.\n+ * @since 1.0\n+ *\/\n+public class E extends Exception {\n+    private static final long serialVersionUID = 123;\n+\n+    \/**\n+     * This is private field {@code f1};\n+     * This is additional information.\n+     * @since 1.0\n+     *\/\n+    private int f1;\n+\n+    \/**\n+     * This is private transient field {@code f2};\n+     * It is not part of the serial form.\n+     * @since 1.0\n+     *\/\n+    private transient int f2;\n+}\n\\ No newline at end of file\n","filename":"test\/showDocs\/demo-src\/m\/p\/E.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+\/**\n+ * This is class {@code S}.\n+ * This is additional information.\n+ * @since 1.0\n+ *\/\n+public class S implements Serializable {\n+    private static final long serialVersionUID = 456;\n+\n+    \/**\n+     * This is private field {@code f1};\n+     * This is additional information.\n+     * @since 1.0\n+     *\/\n+    private int f1;\n+\n+    \/**\n+     * This is private transient field {@code f2};\n+     * It is not part of the serial form.\n+     * @since 1.0\n+     *\/\n+    private transient int f2;\n+\n+    \/**\n+     * This is private method {@code readObject}.\n+     * @param stream the serial input stream\n+     * @throws IOException if an IO exception occurs\n+     * @throws ClassNotFoundException if a class cannot be found\n+     * @serialData This is a description of the serial data provided in {@code readObject}.\n+     *  This is additional information.\n+     * @since 1.0\n+     *\/\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+\n+    }\n+\n+    \/**\n+     * This is private method {@code writeObject}.\n+     * @param stream the serial input stream\n+     * @throws IOException if an IO exception occurs\n+     * @serialData This is a description of the serial data provided in {@code writeObject}.\n+     *  This is additional information.\n+     * @since 1.0\n+     *\/\n+    private void writeObject(ObjectOutputStream stream)\n+            throws IOException {\n+\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/showDocs\/demo-src\/m\/p\/S.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * This is package {@code p}.\n+ * This is additional information.\n+ * @since 1.0\n+ *\/\n+package p;\n","filename":"test\/showDocs\/demo-src\/m\/p\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+#!\/bin\/bash\n+\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+\n+mydir=\"$(dirname ${BASH_SOURCE[0]})\"\n+BUILDDIR=${mydir}\/..\/..\/build\n+\n+WORK=$HOME\/Work\n+JDK=${WORK}\/jdk\n+\n+sh ${BUILDDIR}\/make.sh showDocs-demo \\\n+  JDK11HOME=${JDK}\/jdk-11.jdk\/Contents\/Home\/ \\\n+  JDK12HOME=${JDK}\/jdk-12.jdk\/Contents\/Home\/ \\\n+  JDK13HOME=${JDK}\/jdk-13.jdk\/Contents\/Home\/ \\\n+  JDK14HOME=${JDK}\/jdk-14.jdk\/Contents\/Home\/ \\\n+  JDK15HOME=${JDK}\/jdk-15.jdk\/Contents\/Home\/ \\\n+  JDK16HOME=${JDK}\/jdk-16.jdk\/Contents\/Home\/ \\\n+  JDK17HOME=${JDK}\/jdk-17.jdk\/Contents\/Home\/ \\\n+  JDK18HOME=${JDK}\/jdk-18.jdk\/Contents\/Home\/ \\\n+  JDK19HOME=${JDK}\/jdk-19.jdk\/Contents\/Home\/ \\\n+  JDK20HOME=${JDK}\/jdk-20.jdk\/Contents\/Home\/ \\\n+  JDK21HOME=${JDK}\/jdk-21.jdk\/Contents\/Home\/ \\\n+  JDK22HOME=${JDK}\/jdk.ref\/build\/macosx-aarch64\/images\/jdk\/ \\\n+  JDKHOME=${JDK}\/jdk-17.jdk\/Contents\/Home\/\n+\n","filename":"test\/showDocs\/show-demo-docs.sh","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+#!\/bin\/bash\n+\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+# Analyses JDK docs with APIReader and generates a hierarchy of\n+# pages displaying the API descriptions read from declaration\n+# and serialized-form pages.\n+\n+mydir=\"$(dirname ${BASH_SOURCE[0]})\"\n+BUILDDIR=${mydir}\/..\/..\/build\n+\n+WORK=${WORK:-${HOME}\/Work}\n+JDK=${JDK:-${WORK}\/jdk}\n+\n+# used to run the showDocs tool\n+JDKHOME=${JDKHOME:-${JDK}\/jdk-17.jdk\/Contents\/Home}\n+\n+# where to find the docs to analyze;\n+# the directory must be populated with the API docs for the desired JDK versions\n+JDKDOCS=${JDK}\/docs\n+\n+OUTDIR=${OUTDIR:-${BUILDDIR}\/show-jdk-docs}\n+\n+showdocs() {\n+   $JDKHOME\/bin\/java -jar ${BUILDDIR}\/showDocs.jar $*\n+}\n+\n+for v in 11 12 13 14 15 16 17 18 19 20 21 jdk.ref; do\n+  echo $v\n+  rm -rf ${OUTDIR}\/$v\n+  showdocs -d ${OUTDIR}\/$v $JDKDOCS\/$v\/docs\/api\n+done\n","filename":"test\/showDocs\/show-jdk-docs.sh","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+#\n+# Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# Invoke with a command like the following:\n+#\n+#\tmake -C make show-demo-docs \\\n+#\t  JDK11HOME=${JDK}\/jdk-11.jdk\/Contents\/Home\/ \\\n+#\t  JDK12HOME=${JDK}\/jdk-12.jdk\/Contents\/Home\/ \\\n+#\t  JDK13HOME=${JDK}\/jdk-13.jdk\/Contents\/Home\/ \\\n+#\t  JDK14HOME=${JDK}\/jdk-14.jdk\/Contents\/Home\/ \\\n+#\t  JDK15HOME=${JDK}\/jdk-15.jdk\/Contents\/Home\/ \\\n+#\t  JDK16HOME=${JDK}\/jdk-16.jdk\/Contents\/Home\/ \\\n+#\t  JDK17HOME=${JDK}\/jdk-17.jdk\/Contents\/Home\/ \\\n+#\t  JDK18HOME=${JDK}\/jdk-18.jdk\/Contents\/Home\/ \\\n+#\t  JDK19HOME=${JDK}\/jdk-19.jdk\/Contents\/Home\/ \\\n+#\t  JDK20HOME=${JDK}\/jdk-20.jdk\/Contents\/Home\/ \\\n+#\t  JDK21HOME=${JDK}\/jdk-21.jdk\/Contents\/Home\/ \\\n+#\t  JDK22HOME=${JDK}\/jdk.ref\/build\/macosx-aarch64\/images\/jdk\/ \\\n+#\t  JDKHOME=${JDK}\/jdk-17.jdk\/Contents\/Home\/\n+\n+FILES.showdocs = $(shell $(FIND) $(TESTDIR)\/showDocs\/src -type f -print)\n+\n+$(BUILDTESTDIR)\/showDocs\/showDocs.jar: \\\n+\t\t$(FILES.showdocs) \\\n+\t\t$(BUILDDIR)\/images\/apidiff\/lib\/apidiff.jar\n+\techo $(FILES.showdocs)\n+\t$(JAVAC) \\\n+\t\t-d $(BUILDTESTDIR)\/showDocs\/classes \\\n+\t\t-sourcepath $(TESTDIR)\/showDocs\/src \\\n+\t\t-classpath $(BUILDDIR)\/classes \\\n+\t\t$(TESTDIR)\/showDocs\/src\/jdk\/codetools\/showdocs\/Main.java\n+\t$(CP) $(TESTDIR)\/showDocs\/src\/jdk\/codetools\/showdocs\/showDocs.css $(BUILDTESTDIR)\/showDocs\/classes\/jdk\/codetools\/showdocs\/\n+\t$(JAR) \\\n+\t\t--create \\\n+\t\t--file=$@ \\\n+\t\t--main-class=jdk.codetools.showdocs.Main \\\n+\t\t-C $(BUILDTESTDIR)\/showDocs\/classes . \\\n+\t\t-C $(BUILDDIR)\/classes .\n+\n+#--------------------------\n+#\n+# Create demo output for demo source files\n+\n+FILES.demofiles = $(shell $(FIND) $(TESTDIR)\/showDocs\/demo-src -type f -print)\n+\n+# Setup rule to run javadoc from JDK<N> to generate API output for demo src\n+# \t$1: simple version number\n+# \t$2: JDK home for version $(1)\n+define SETUP_JAVADOC_DEMO_DOCS\n+$$(BUILDTESTDIR)\/show-demo-docs\/$(1)\/api\/index.html: $$(FILES.demofiles)\n+\t$(2)\/bin\/javadoc \\\n+\t\t-quiet \\\n+\t\t-Xdoclint:none \\\n+\t\t-d $$(@D) \\\n+\t\t--module-source-path $$(TESTDIR)\/showDocs\/demo-src \\\n+\t\t--module m\n+endef\n+\n+# Setup rule to run showDocs to generate demo output from demo API files generated by javadoc\n+# and add targets into show-demo-docs\n+# \t$1: simple version number\n+# \t$2: 'text', 'html' or 'mixed''\n+define SETUP_SHOW_DEMO_DOCS\n+$$(BUILDTESTDIR)\/show-demo-docs\/$(1)\/$(2)\/index.html: \\\n+\t\t$$(BUILDTESTDIR)\/show-demo-docs\/$(1)\/api\/index.html \\\n+\t\t$$(BUILDTESTDIR)\/showDocs\/showDocs.jar\n+\t$$(JDKHOME)\/bin\/java -jar $$(BUILDTESTDIR)\/showDocs\/showDocs.jar \\\n+\t\t-d $$(@D) \\\n+\t\t--$(2) \\\n+\t\t$$(BUILDTESTDIR)\/show-demo-docs\/$(1)\/api\/\n+\n+show-demo-docs: \\\n+\t$$(BUILDTESTDIR)\/show-demo-docs\/$(1)\/$(2)\/index.html\n+endef\n+\n+# Setup rules to run javadoc for a given version, and then run showDocs\n+# to generate demo text and html output.\n+# \t$1: simple version number\n+define SETUP_FULL_SHOW_DEMO_DOCS\n+ifdef $(1)\n+$(eval $(call SETUP_JAVADOC_DEMO_DOCS,$(1),$(JDK$(1)HOME)) )\n+$(eval $(call SETUP_SHOW_DEMO_DOCS,$(1),text) )\n+$(eval $(call SETUP_SHOW_DEMO_DOCS,$(1),html) )\n+$(eval $(call SETUP_SHOW_DEMO_DOCS,$(1),mixed) )\n+endif\n+endef\n+\n+# for each version for which JDK<N>HOME is defined:\n+# - run JDK<N>HOME\/bin\/javadoc to generate demo API dir\n+# - run showDocs to generate text version of extracts from API files\n+# - run showDocs to generate html version of extracts from API files\n+VERSIONS = 11 12 13 14 15 16 17 18 19 20 21 22\n+$(foreach v,$(VERSIONS),$(eval $(call SETUP_FULL_SHOW_DEMO_DOCS,$(v))))\n+\n+show-demo-docs:\n+\t${JDKHOME}\/bin\/java $(TESTDIR)\/showDocs\/src\/jdk\/codetools\/showdocs\/GenerateIndex.java \\\n+\t    $(BUILDTESTDIR)\/show-demo-docs \\\n+\t    > $(BUILDTESTDIR)\/show-demo-docs\/index.html\n+\n+\n+\n+\n+\n","filename":"test\/showDocs\/showDocs.gmk","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.showdocs;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+public class GenerateIndex {\n+    public static void main(String... args) throws IOException {\n+        new GenerateIndex().run(args);\n+    }\n+\n+    public void run(String... args) throws IOException {\n+        Path dir = Path.of(args[0]);\n+        run(dir, System.out);\n+    }\n+\n+    public void run(Path dir, PrintStream out) throws IOException {\n+        String title = dir.toString();\n+        out.println(\"<!doctype html>\");\n+        out.println(\"<html>\");\n+        out.println(\"<head>\");\n+        out.println(\"<title>\" + title + \"<\/title>\");\n+        out.println(\"<\/head>\");\n+        out.println(\"<body>\");\n+        out.println(\"<h1>\" + title + \"<\/h1>\");\n+\n+        listFiles(dir, dir, out);\n+\n+        out.println(\"<\/body>\");\n+        out.println(\"<\/html>\");\n+    }\n+\n+    void listFiles(Path root, Path dir, PrintStream out) {\n+        Map<String, Path> dirs = new TreeMap<>();\n+        Map<String, Path> files = new TreeMap<>();\n+\n+        try (var ds = Files.newDirectoryStream(dir)) {\n+            for (var p : ds) {\n+                String fn = p.getFileName().toString();\n+                if (Files.isDirectory(p)) {\n+                    dirs.put(fn, p);\n+                } else {\n+                    if (fn.endsWith(\".html\") && !p.equals(root.resolve(\"index.html\"))) {\n+                        files.put(p.getFileName().toString(), p);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            System.err.println(\"Error in listFiles: root=\" + root + \" dir=\" + dir + \": \" + e);\n+        }\n+\n+        dirs.forEach((fn, p) -> {\n+            out.println(\"<li><details>\");\n+            out.println(\"<summary>\" + fn + \"<\/summary>\");\n+            out.println(\"<ul>\");\n+            listFiles(root, p, out);\n+            out.println(\"<\/ul>\");\n+            out.println(\"<\/details>\");\n+        });\n+\n+        files.forEach((fn, p) ->\n+                out.println(\"<li><a href=\\\"\" + root.relativize(p) + \"\\\">\" + fn + \"<\/a>\"));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/showDocs\/src\/jdk\/codetools\/showdocs\/GenerateIndex.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,371 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.codetools.showdocs;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintWriter;\n+import java.io.UncheckedIOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import jdk.codetools.apidiff.Log;\n+import jdk.codetools.apidiff.html.Content;\n+import jdk.codetools.apidiff.html.HtmlAttr;\n+import jdk.codetools.apidiff.html.HtmlTree;\n+import jdk.codetools.apidiff.html.RawHtml;\n+import jdk.codetools.apidiff.html.TagName;\n+import jdk.codetools.apidiff.html.Text;\n+import jdk.codetools.apidiff.model.APIDocs;\n+import jdk.codetools.apidiff.model.SerializedFormDocs;\n+\n+\/**\n+ * A utility program to display the descriptions of the primary element and\n+ * member elements in a page of API documentation generated by javadoc.\n+ *\n+ *\/\n+public class Main {\n+    \/**\n+     * The command-line entry point.\n+     *\n+     * @param args the command-line arguments\n+     * @throws Exception if an error occurred while running the program.\n+     *\/\n+    public static void main(String... args) throws Exception {\n+        new Main().run(args);\n+    }\n+\n+    enum Mode { HTML, TEXT, MIXED }\n+    private Mode mode = Mode.MIXED; \/\/ default\n+    boolean verbose = false;\n+\n+    \/**\n+     * Execute the program.\n+     *\n+     * @param args the command-line arguments\n+     * @throws Exception if an error occurred while running the program.\n+     *\/\n+    public void run(String... args) throws Exception {\n+        Path inDir = null;\n+        Path outDir = null;\n+\n+        for (int i = 0; i < args.length; i++) {\n+            String arg = args[i];\n+            if (arg.equals(\"-d\")) {\n+                if (++i < args.length) {\n+                    outDir = Path.of(args[i]);\n+                } else {\n+                    throw new Exception(\"no arg for -d\");\n+                }\n+            } else if (arg.equals(\"-h\") || arg.equals(\"--html\")) {\n+                mode = Mode.HTML;\n+            } else if (arg.equals(\"-t\") || arg.equals(\"--text\")) {\n+                mode = Mode.TEXT;\n+            } else if (arg.equals(\"--mixed\")) {\n+                mode = Mode.MIXED;\n+            } else if (arg.equals(\"-v\") || arg.equals(\"--verbose\")) {\n+                verbose = true;\n+            } else if (arg.startsWith(\"-\")) {\n+                throw new Exception(\"unknown option: \" + arg);\n+            } else if (inDir == null) {\n+                inDir = Path.of(arg);\n+            } else {\n+                throw new Exception(\"unknown argument: \" + arg);\n+            }\n+        }\n+\n+        if (inDir == null) {\n+            throw new Exception(\"no input directory specified\");\n+        }\n+\n+        if (outDir == null) {\n+            throw new Exception(\"no output directory specified\");\n+        }\n+\n+        PrintWriter out = new PrintWriter(System.out) {\n+            @Override\n+            public void close() {\n+                flush();\n+            }\n+        };\n+        PrintWriter err = new PrintWriter(System.err, true){\n+            @Override\n+            public void close() {\n+                flush();\n+            }\n+        };\n+\n+        Log log = new Log(out, err);\n+        try {\n+            showDocs(log, inDir, outDir);\n+        } finally {\n+            log.out.flush();\n+            log.err.flush();\n+        }\n+\n+    }\n+\n+    Map<String, SerializedFormDocs> allSerialFormDocs;\n+\n+    void showDocs(Log log, Path inFile, Path outDir) throws IOException {\n+        if (Files.isDirectory(inFile)) {\n+            Path sfFile = inFile.resolve(\"serialized-form.html\");\n+            if (Files.exists(sfFile)) {\n+                allSerialFormDocs = SerializedFormDocs.read(log, sfFile);\n+            }\n+        }\n+\n+        Pattern p = Pattern.compile(\"(module-summary|package-summary|[A-Z].*|serialized-form)\\\\.html\");\n+        Files.walkFileTree(inFile, new SimpleFileVisitor<>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n+                if (p.matcher(file.getFileName().toString()).matches()) {\n+                    if (verbose) {\n+                        log.err.println(\"file: \" + file);\n+                    }\n+                    Path relFile = file.equals(inFile) ? file.getFileName() : inFile.relativize(file);\n+                    String title = relFile.toString();\n+                    Path pathToRoot = pathToRoot(relFile);\n+                    Path outFile = outDir.resolve(relFile);\n+                    try {\n+                        if (file.getFileName().toString().equals(\"serialized-form.html\")) {\n+                            showSerializedFormFile(log, file, outFile, \"Serialized Forms\", pathToRoot);\n+                        } else {\n+                            showAPIFile(log, file, outFile, title, pathToRoot);\n+                        }\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+\n+            @Override\n+            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n+                if (verbose) {\n+                    log.err.println(\"dir: \" + dir);\n+                }\n+                switch (dir.getFileName().toString()) {\n+                    case \"jquery\":\n+                    case \"resources\":\n+                        return FileVisitResult.SKIP_SUBTREE;\n+                    default:\n+                        return FileVisitResult.CONTINUE;\n+                }\n+            }\n+        });\n+\n+        copyResource(\"showDocs.css\", outDir);\n+    }\n+\n+\n+    private void copyResource(String name, Path dir) {\n+        try (InputStream in = getClass().getResourceAsStream(name)) {\n+            Files.createDirectories(dir);\n+            Files.copy(in, dir.resolve(name), StandardCopyOption.REPLACE_EXISTING);\n+        } catch (IOException e) {\n+            System.err.println(\"Error writing stylesheet: \" + e);\n+        }\n+    }\n+\n+    void showAPIFile(Log log, Path inFile, Path outFile, String title, Path pathToRoot) throws IOException {\n+        APIDocs apiDocs = APIDocs.read(log, inFile);\n+\n+        if (verbose) {\n+            log.err.println(\"APIDocs: \" + shortText(apiDocs.getDescription()));\n+            log.err.println(\"APIDocs: \" + apiDocs.getMemberDescriptions().keySet());\n+            apiDocs.getMemberDescriptions().forEach((k, v) -> log.err.println(shortText(k) + \": \" + shortText(v)));\n+        }\n+\n+        Path stylesheet = pathToRoot.resolve(\"showDocs.css\");\n+        Files.createDirectories(outFile.getParent());\n+        try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(outFile))) {\n+            HtmlTree head = HtmlTree.HEAD(\"UTF-8\", title)\n+                    \/\/ TODO: stylesheet link should allow stylesheet name to be overridden\n+                    .add(HtmlTree.LINK(\"stylesheet\", stylesheet.toString()))\n+                    .add(HtmlTree.META(\"generator\", \"showDocs\"));\n+\n+            Map<String, String> declNames = apiDocs.getDeclarationNames();\n+            String decl = declNames.entrySet().stream()\n+                    .map(e -> e.getKey() + \": \" + e.getValue())\n+                    .collect(Collectors.joining(\", \", \"Declaration: \", \"\"));\n+\n+            HtmlTree dl = HtmlTree.DL().setClass(\"api-descriptions\");\n+            dl.add(HtmlTree.DT(Text.of(\"Main Description\")));\n+            String desc = apiDocs.getDescription();\n+            dl.add(HtmlTree.DD(desc == null\n+                        ? HtmlTree.SPAN(Text.of(\"(not found)\")).set(HtmlAttr.STYLE, \"color:gray\")\n+                        : getContent(desc)));\n+            TreeMap<String,String> members = new TreeMap<>(apiDocs.getMemberDescriptions());\n+            for (Map.Entry<String,String> e : members.entrySet()) {\n+                dl.add(HtmlTree.DT(Text.of(e.getKey())));\n+                dl.add(HtmlTree.DD(getContent(e.getValue())));\n+            }\n+\n+            HtmlTree body = HtmlTree.BODY()\n+                    .add(HtmlTree.H1(Text.of(title)))\n+                    .add(HtmlTree.P().add(new Text(decl)))\n+                    .add(dl);\n+\n+            if (allSerialFormDocs != null && declNames.containsKey(\"class\")) {\n+                StringBuilder sb = new StringBuilder();\n+                String pkg = declNames.get(\"package\");\n+                if (pkg != null) {\n+                    sb.append(pkg).append(\".\");\n+                }\n+                sb.append(declNames.get(\"class\"));\n+                SerializedFormDocs sfDocs = allSerialFormDocs.get(sb.toString());\n+                if (sfDocs != null) {\n+                    body.add(new HtmlTree(TagName.HR).setClass(\"serialized-form-rule\"))\n+                            .add(HtmlTree.H2(new Text(\"Serialized Form\")))\n+                            .add(buildSerializedForm(sfDocs));\n+                }\n+            }\n+\n+            HtmlTree html = new HtmlTree(TagName.HTML, head, body).set(HtmlAttr.LANG, \"en_US\");\n+            html.write(out);\n+        }\n+    }\n+\n+    void showSerializedFormFile(Log log, Path inFile, Path outFile, String title, Path pathToRoot) throws IOException {\n+        Map<String, SerializedFormDocs> allSerialFormDocs = SerializedFormDocs.read(log, inFile);\n+        showSerializedFormFile(log, allSerialFormDocs, outFile, title, pathToRoot);\n+    }\n+\n+    void showSerializedFormFile(Log log, Map<String, SerializedFormDocs> allSerialFormDocs,\n+                                Path outFile, String title, Path pathToRoot) throws IOException {\n+\n+        if (verbose) {\n+            allSerialFormDocs.forEach((k, v) -> {\n+                List<String> list = new ArrayList<>();\n+                if (v.getOverview() != null) {\n+                    list.add(\"overview\");\n+                }\n+                if (v.getSerialVersionUID() != null) {\n+                    list.add(\"svuid\");\n+                }\n+                list.addAll(v.getFieldDescriptions().keySet());\n+                list.addAll(v.getMethodDescriptions().keySet());\n+                log.err.println(k + \": \" + shortText(String.join(\",\", list)));\n+            });\n+        }\n+\n+        Path stylesheet = pathToRoot.resolve(\"showDocs.css\");\n+        Files.createDirectories(outFile.getParent());\n+        try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(outFile))) {\n+            HtmlTree head = HtmlTree.HEAD(\"UTF-8\", title)\n+                    \/\/ TODO: stylesheet link should allow stylesheet name to be overridden\n+                    .add(HtmlTree.LINK(\"stylesheet\", stylesheet.toString()))\n+                    .add(HtmlTree.META(\"generator\", \"showDocs\"));\n+\n+            HtmlTree dl = HtmlTree.DL().setClass(\"all-serialized-forms\");\n+            for (Map.Entry<String, SerializedFormDocs> entry : allSerialFormDocs.entrySet()) {\n+                String typeName = entry.getKey();\n+                SerializedFormDocs sfDocs = entry.getValue();\n+                dl.add(HtmlTree.DT(Text.of(typeName)));\n+                dl.add(HtmlTree.DD(buildSerializedForm(sfDocs)));\n+            }\n+            HtmlTree body = HtmlTree.BODY()\n+                    .add(HtmlTree.H1(Text.of(title)))\n+                    .add(dl);\n+            HtmlTree html = new HtmlTree(TagName.HTML, head, body).set(HtmlAttr.LANG, \"en_US\");\n+            html.write(out);\n+        }\n+    }\n+\n+    private HtmlTree buildSerializedForm(SerializedFormDocs sfDocs) {\n+        HtmlTree dl = HtmlTree.DL().setClass(\"serialized-form-descriptions\");\n+        String overview = sfDocs.getOverview();\n+        if (overview != null) {\n+            dl.add(HtmlTree.DT(Text.of(\"Overview\")))\n+                    .add(HtmlTree.DD(getContent(overview)));\n+        }\n+        String svuid = sfDocs.getSerialVersionUID();\n+        if (svuid != null) {\n+            dl.add(HtmlTree.DT(Text.of(\"SerialVersionUID\")))\n+                    .add(HtmlTree.DD(getContent(svuid)));\n+        }\n+        sfDocs.getFieldDescriptions().forEach((f, description) -> {\n+            dl.add(HtmlTree.DT(Text.of(f)))\n+                    .add(HtmlTree.DD(getContent(description)));\n+\n+        });\n+        sfDocs.getMethodDescriptions().forEach((m, description) -> {\n+            dl.add(HtmlTree.DT(Text.of(m)))\n+                    .add(HtmlTree.DD(getContent(description)));\n+\n+        });\n+        return dl;\n+    }\n+\n+    private Content getContent(String desc) {\n+        switch (mode) {\n+            case HTML:\n+                return HtmlTree.DIV(new RawHtml(desc)).setClass(\"html\");\n+\n+            case TEXT:\n+                return HtmlTree.PRE(Text.of(desc)).setClass(\"text\");\n+\n+            case MIXED:\n+                return HtmlTree.DIV(List.of(\n+                        HtmlTree.DIV(new RawHtml(desc)).setClass(\"html\"),\n+                        HtmlTree.DETAILS(\n+                                HtmlTree.SUMMARY(Text.of(\"Source\")),\n+                                HtmlTree.PRE(Text.of(desc)).setClass(\"text\")\n+                        )\n+\n+                ));\n+            default:\n+                throw new IllegalStateException();\n+        }\n+    }\n+\n+\n+    private Path pathToRoot(Path relFile) {\n+        if (relFile.getParent() == null) {\n+            return Path.of(\".\");\n+        } else {\n+            return Path.of(relFile.getParent().toString().replaceAll(\"[^\/\\\\\\\\]+\", \"..\"));\n+        }\n+    }\n+\n+    private String shortText(String s) {\n+        if (s == null)\n+            return null;\n+        else if (s.length() < 10)\n+            return s;\n+        else\n+            return s.substring(0,10);\n+    }\n+}\n","filename":"test\/showDocs\/src\/jdk\/codetools\/showdocs\/Main.java","additions":371,"deletions":0,"binary":false,"changes":371,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * A simple utility to generate a hierarchy of pages,\n+ * each showing the descriptions derived from the pages\n+ * in a corresponding input hierarchy.\n+ *\/\n+package jdk.codetools.showdocs;\n","filename":"test\/showDocs\/src\/jdk\/codetools\/showdocs\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/* Global\/default settings. *\/\n+\n+body {\n+    font-family:'DejaVu Sans', Arial, Helvetica, sans-serif;\n+    font-size:14px;\n+}\n+\n+\/* Headings. *\/\n+\n+h1 {\n+    font-size:20px;\n+}\n+h2 {\n+    font-size:18px;\n+}\n+h3 {\n+    font-size:16px;\n+    font-style:italic;\n+}\n+h4 {\n+    font-size:13px;\n+}\n+h5 {\n+    font-size:12px;\n+}\n+h6 {\n+    font-size:11px;\n+}\n+\n+\/* Links. *\/\n+\n+a:link, a:visited {\n+    text-decoration:none;\n+    color:#4A6782;\n+}\n+a[href]:hover, a[href]:focus {\n+    text-decoration:none;\n+    color:#bb7a2a;\n+}\n+\n+dl.all-serialized-forms > dt {\n+    font-size: larger;\n+    font-weight: bold;\n+    margin-top: 1em;\n+    border-top: 1px solid gray;\n+    padding-top: 1em;\n+}\n+\n+dl.api-descriptions > dt,\n+dl.serialized-form-descriptions > dt {\n+    font-weight: bold;\n+}\n+\n+div.html {\n+    border: 1px solid blue;\n+    border-radius: 5px;\n+    margin-top: 1em;\n+    margin-bottom: 1em;\n+    padding: 5px;\n+}\n+\n+pre.text {\n+    border: 1px solid magenta;\n+    border-radius: 5px;\n+    margin-top: 1em;\n+    margin-bottom: 1em;\n+    padding: 5px;\n+    white-space: pre-wrap;\n+}\n+\n+hr.serialized-form-rule {\n+    margin-top: 2em;\n+    color: gray;\n+}\n+\n+dd > div > details {\n+    margin-bottom: 2em;\n+}\n","filename":"test\/showDocs\/src\/jdk\/codetools\/showdocs\/showDocs.css","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+\n+$(BUILDTESTDIR)\/ToolProviderTest_List.ok: \\\n+\t\t$(BUILDDIR)\/images\/apidiff\/lib\/apidiff.jar\n+\t$(JAVA) \\\n+\t\t--class-path $< \\\n+\t\t$(TESTDIR)\/toolProvider\/ToolProviderTest.java > $(@:%.ok=%.out)\n+\t$(GREP) apidiff $(@:%.ok=%.out)\n+\techo $@ passed at `date` > $@\n+\n+$(BUILDTESTDIR)\/ToolProviderTest_Version.ok: \\\n+\t\t$(BUILDDIR)\/images\/apidiff\/lib\/apidiff.jar\n+\t$(JAVA) \\\n+\t\t--class-path $< \\\n+\t\t$(TESTDIR)\/toolProvider\/ToolProviderTest.java apidiff --version > $(@:%.ok=%.out)\n+\t$(GREP) \"apidiff.*version\" $(@:%.ok=%.out)\n+\techo $@ passed at `date` > $@\n+\n+TESTS += \\\n+\t$(BUILDTESTDIR)\/ToolProviderTest_List.ok \\\n+\t$(BUILDTESTDIR)\/ToolProviderTest_Version.ok\n\\ No newline at end of file\n","filename":"test\/toolProvider\/ToolProviderTest.gmk","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.ServiceLoader;\n+import java.util.spi.ToolProvider;\n+\n+public class ToolProviderTest {\n+    public static void main(String... args) throws Exception {\n+        if (args.length == 0) {\n+            ServiceLoader<ToolProvider> sl = ServiceLoader.load(ToolProvider.class);\n+            Iterator<ToolProvider> iter = sl.iterator();\n+            while (iter.hasNext()) {\n+                ToolProvider tp = iter.next();\n+                System.out.println(tp.name() + \": \" + tp.getClass());\n+            }\n+        } else {\n+            String toolName = args[0];\n+            String[] toolArgs = Arrays.copyOfRange(args, 1, args.length);\n+            ToolProvider tool = ToolProvider.findFirst(toolName).orElseThrow();\n+            int rc = tool.run(System.out, System.err, toolArgs);\n+            if (rc != 0) {\n+                throw new Exception(\"unexpected exit: \" + rc);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/toolProvider\/ToolProviderTest.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"}]}