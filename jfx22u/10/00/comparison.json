{"files":[{"patch":"@@ -2019,1 +2019,1 @@\n-        \/\/ FontStrike supports LCD, SRC_OVER CompositeMode and Paint is a COLOR\n+        \/\/ FontStrike supports LCD, SRC_OVER CompositeMode and Paint is an opaque COLOR\n@@ -2022,0 +2022,1 @@\n+                               textColor.getAlpha() == 1.0 &&\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/impl\/ps\/BaseShaderGraphics.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -663,1 +663,2 @@\n-                (this.paint.getType() == Paint.Type.COLOR) &&\n+                this.paint instanceof Color c &&\n+                c.getAlpha() == 1.0f &&\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/sw\/SWGraphics.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.robot.javafx.scene;\n+\n+import com.sun.javafx.PlatformUtil;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import javafx.application.ConditionalFeature;\n+import javafx.application.Platform;\n+import javafx.scene.Scene;\n+import javafx.scene.image.Image;\n+import javafx.scene.layout.Pane;\n+import javafx.scene.paint.Color;\n+import javafx.scene.robot.Robot;\n+import javafx.scene.text.Font;\n+import javafx.scene.text.FontSmoothingType;\n+import javafx.scene.text.FontWeight;\n+import javafx.scene.text.Text;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import test.util.Util;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assumptions.assumeFalse;\n+import static org.junit.jupiter.api.Assumptions.assumeTrue;\n+\n+\/**\n+ * Test that renders transparent text with LDC rendering selected.\n+ * Prior to the fix for JDK-8311492 the color of the text was wrong.\n+ * This test verifies that the color is correct and that we fall back to\n+ * gray scale AA.\n+ *\n+ * @test\n+ * @bug 8311492\n+ *\/\n+public class TransparentLCDTest {\n+\n+    private static final boolean DEBUG = false;\n+\n+    private static final int WIDTH = 400;\n+    private static final int HEIGHT = 300;\n+\n+    \/\/ We use a very tight color tolerance, which requires some extra care.\n+    \/\/ We force a screen scale of 1, stay away from the edges of the window,\n+    \/\/ and only sample outside the text, where we expect to read the background\n+    \/\/ color, or in the middle of the text fill area, where we expect to find\n+    \/\/ the unadjusted text color.\n+    private static final double TOLERANCE = 2.5 \/ 255.0;\n+\n+    private static final int TEXT_X_LEFT = 5;\n+    private static final int TEXT_Y_BOTTOM = 30;\n+\n+    \/\/ The following are chosen to test before the first part of the 'V', after\n+    \/\/ the first part of the 'V', and in the middle of the first part of the 'V'\n+    private static final int SAMPLE_X_START = TEXT_X_LEFT;\n+    private static final int SAMPLE_Y = 11;\n+    private static final int TEST_WIDTH = 12;\n+    private static final int TEST_X_LEFT = 0;\n+    private static final int TEST_X_RIGHT = TEST_WIDTH - 1;\n+    private static final int TEST_X_MID = TEST_WIDTH \/ 2;\n+\n+    private static final Color TRANSP_COLOR = Color.color(0.5, 0.5, 0.5, 0.6);\n+    private static final Color OPAQUE_COLOR = makeOpaque(TRANSP_COLOR);\n+\n+    private Robot robot;\n+    private Stage testStage;\n+    private Scene testScene;\n+\n+    \/**\n+     * Derive an opaque color from the given transparent color. The opaque\n+     * color will be the same color as the transparent color is when rendered\n+     * on a pure white background.\n+     *\n+     * @param c the transparent color\n+     * @return  the equivalent opaque color\n+     *\/\n+    private static Color makeOpaque(Color c) {\n+        double a = c.getOpacity();\n+        double r = c.getRed() * a + (1.0 - a);\n+        double g = c.getGreen() * a + (1.0 - a);\n+        double b = c.getBlue() * a + (1.0 - a);\n+        return Color.color(r, g, b);\n+    }\n+\n+    private boolean isGrayScale(List<Color> colors) {\n+        long nonGrayCount = colors.stream()\n+                .filter(c -> c.getRed() != c.getGreen() || c.getRed() != c.getBlue())\n+                .count();\n+        return nonGrayCount == 0;\n+    }\n+\n+   private void assertColorEquals(Color expected, Color actual) {\n+        if (!testColorEquals(expected, actual, TOLERANCE)) {\n+            fail(\"expected:\" + expected + \" but was:\" + actual);\n+        }\n+    }\n+\n+    private boolean testColorEquals(Color expected, Color actual, double delta) {\n+        double deltaRed = Math.abs(expected.getRed() - actual.getRed());\n+        double deltaGreen = Math.abs(expected.getGreen() - actual.getGreen());\n+        double deltaBlue = Math.abs(expected.getBlue() - actual.getBlue());\n+        double deltaOpacity = Math.abs(expected.getOpacity() - actual.getOpacity());\n+        return (deltaRed <= delta && deltaGreen <= delta && deltaBlue <= delta && deltaOpacity <= delta);\n+    }\n+\n+    private List<Color> getColors(Scene scene, int x, int y, int width) {\n+        x += scene.getX() + scene.getWindow().getX();\n+        y += scene.getY() + scene.getWindow().getY();\n+        Image image = robot.getScreenCapture(null, x, y, width, 1);\n+        List<Color> colors = new ArrayList<>(width);\n+        for (int i = 0; i < width; i++) {\n+            colors.add(image.getPixelReader().getColor(i, 0));\n+        }\n+        return colors;\n+    }\n+\n+    \/\/ This must be called on the FX app thread\n+    private Stage createStage() {\n+        Stage stage = new Stage();\n+        stage.initStyle(StageStyle.UNDECORATED);\n+        stage.setAlwaysOnTop(true);\n+        return stage;\n+    }\n+\n+    @BeforeAll\n+    public static void doSetupOnce() {\n+        System.setProperty(\"prism.lcdText\", \"true\");\n+        System.setProperty(\"glass.win.uiScale\", \"1\");\n+        System.setProperty(\"glass.gtk.uiScale\", \"1\");\n+\n+        Platform.setImplicitExit(false);\n+        final CountDownLatch launchLatch = new CountDownLatch(1);\n+        Util.startup(launchLatch, launchLatch::countDown);\n+        assertEquals(0, launchLatch.getCount());\n+    }\n+\n+    @AfterAll\n+    public static void doTeardownOnce() {\n+        Util.shutdown();\n+    }\n+\n+    @BeforeEach\n+    public void doSetup() {\n+        \/\/ LCD text is disabled on macOS\n+        assumeFalse(PlatformUtil.isMac());\n+\n+        \/\/ Test is not valid for SW pipeline. We don't have a utility to\n+        \/\/ check the GraphicsPipeline, so we check for 3D support instead.\n+        assumeTrue(Platform.isSupported(ConditionalFeature.SCENE3D));\n+\n+        Util.runAndWait(() -> robot = new Robot());\n+        Util.parkCursor(robot);\n+    }\n+\n+    @AfterEach\n+    public void doTeardown() {\n+        Util.runAndWait(() -> {\n+            if (testStage != null) {\n+                testStage.hide();\n+            }\n+        });\n+    }\n+\n+    \/\/ Called by the test methods to run the test either using an opaque color,\n+    \/\/ which should use LCD, or a transparent color, which should not.\n+    private void runTest(boolean opaque) {\n+        final Color textColor = opaque ? OPAQUE_COLOR : TRANSP_COLOR;\n+\n+        Font font = Font.font(\"System\", FontWeight.BOLD, 36);\n+\n+        CountDownLatch latch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            testStage = createStage();\n+\n+            Pane root = new Pane();\n+            testScene = new Scene(root, WIDTH, HEIGHT);\n+\n+            Text text = new Text(\"V\");\n+            text.setFont(font);\n+            text.setFill(textColor);\n+            text.setFontSmoothingType(FontSmoothingType.LCD);\n+            text.setLayoutX(TEXT_X_LEFT);\n+            text.setLayoutY(TEXT_Y_BOTTOM);\n+            root.getChildren().add(text);\n+\n+            testStage.setOnShowing(e -> Platform.runLater(latch::countDown));\n+            testStage.setScene(testScene);\n+            testStage.show();\n+        });\n+\n+        \/\/ Wait until stage is showing and scene is rendered\n+        Util.waitForLatch(latch, 5, \"Timeout showing stage\");\n+        Util.waitForIdle(testScene);\n+        Util.sleep(500);\n+\n+        Util.runAndWait(() -> {\n+            List<Color> colors = getColors(testScene, SAMPLE_X_START, SAMPLE_Y, TEST_WIDTH);\n+\n+            if (DEBUG) {\n+                System.err.println(\"TRANSP_COLOR = \" + TRANSP_COLOR);\n+                System.err.println(\"OPAQUE_COLOR = \" + OPAQUE_COLOR);\n+                System.err.println(\"\");\n+                colors.stream()\n+                        .map(Color::toString)\n+                        .forEach(System.err::println);\n+            }\n+\n+            \/\/ Verify the colors outside and in the middle of the text\n+            Color cLeft = colors.get(TEST_X_LEFT);\n+            Color cRight = colors.get(TEST_X_RIGHT);\n+            Color cMid = colors.get(TEST_X_MID);\n+\n+            assertColorEquals(Color.WHITE, cLeft);\n+            assertColorEquals(Color.WHITE, cRight);\n+            assertColorEquals(OPAQUE_COLOR, cMid);\n+\n+            \/\/ Check whether LCD or GRAY scale AA is used\n+            boolean isGray = isGrayScale(colors);\n+            if (opaque) {\n+                assertFalse(isGray, \"opaque color should use LCD antialiasing\");\n+            } else {\n+                assertTrue(isGray, \"transparent color should use GRAY scale antialiasing\");\n+            }\n+\n+        });\n+    }\n+\n+    @Test\n+    @Timeout(15)\n+    public void testTransparentLCD() {\n+        runTest(false);\n+    }\n+\n+    @Test\n+    @Timeout(15)\n+    public void testOpaqueLCD() {\n+        runTest(true);\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/scene\/TransparentLCDTest.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"}]}