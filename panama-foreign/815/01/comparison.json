{"files":[{"patch":"@@ -108,0 +108,11 @@\n+    \/**\n+     * Returns an address layout with the same carrier, alignment constraint, name and order as this address layout,\n+     * but without any specified target layout.\n+     * <p>\n+     * This can be useful to compare two address layouts that have different target layouts, but are otherwise equal.\n+     *\n+     * @return an address layout with same characteristics as this layout, but with no target layout.\n+     * @see #targetLayout()\n+     *\/\n+    AddressLayout withoutTargetLayout();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -350,0 +350,5 @@\n+        }\n+\n+        @Override\n+        public AddressLayout withoutTargetLayout() {\n+            return new OfAddressImpl(order(), bitSize(), bitAlignment(), null, name());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+                .withoutTargetLayout()\n@@ -130,0 +131,1 @@\n+        assertTrue(v2.withoutTargetLayout().targetLayout().isEmpty());\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutTypeRetentionTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}