{"files":[{"patch":"@@ -692,45 +692,0 @@\n-    \/**\n-     * Creates a value layout of given Java carrier and byte order. The type of resulting value layout is determined\n-     * by the carrier provided:\n-     * <ul>\n-     *     <li>{@link ValueLayout.OfBoolean}, for {@code boolean.class}<\/li>\n-     *     <li>{@link ValueLayout.OfByte}, for {@code byte.class}<\/li>\n-     *     <li>{@link ValueLayout.OfShort}, for {@code short.class}<\/li>\n-     *     <li>{@link ValueLayout.OfChar}, for {@code char.class}<\/li>\n-     *     <li>{@link ValueLayout.OfInt}, for {@code int.class}<\/li>\n-     *     <li>{@link ValueLayout.OfFloat}, for {@code float.class}<\/li>\n-     *     <li>{@link ValueLayout.OfLong}, for {@code long.class}<\/li>\n-     *     <li>{@link ValueLayout.OfDouble}, for {@code double.class}<\/li>\n-     *     <li>{@link ValueLayout.OfAddress}, for {@code MemorySegment.class}<\/li>\n-     * <\/ul>\n-     * @param carrier the value layout carrier.\n-     * @param order the value layout's byte order.\n-     * @return a value layout with the given Java carrier and byte-order.\n-     * @throws IllegalArgumentException if the carrier type is not supported.\n-     *\/\n-    static ValueLayout valueLayout(Class<?> carrier, ByteOrder order) {\n-        Objects.requireNonNull(carrier);\n-        Objects.requireNonNull(order);\n-        if (carrier == boolean.class) {\n-            return ValueLayouts.OfBooleanImpl.of(order);\n-        } else if (carrier == char.class) {\n-            return ValueLayouts.OfCharImpl.of(order);\n-        } else if (carrier == byte.class) {\n-            return ValueLayouts.OfByteImpl.of(order);\n-        } else if (carrier == short.class) {\n-            return ValueLayouts.OfShortImpl.of(order);\n-        } else if (carrier == int.class) {\n-            return ValueLayouts.OfIntImpl.of(order);\n-        } else if (carrier == float.class) {\n-            return ValueLayouts.OfFloatImpl.of(order);\n-        } else if (carrier == long.class) {\n-            return ValueLayouts.OfLongImpl.of(order);\n-        } else if (carrier == double.class) {\n-            return ValueLayouts.OfDoubleImpl.of(order);\n-        } else if (carrier == MemorySegment.class) {\n-            return ValueLayouts.OfAddressImpl.of(order);\n-        } else {\n-            throw new IllegalArgumentException(\"Unsupported carrier: \" + carrier.getName());\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -458,4 +458,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(MemorySegment.class, ByteOrder.nativeOrder());\n-     * }\n@@ -468,4 +464,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(byte.class, ByteOrder.nativeOrder());\n-     * }\n@@ -478,4 +470,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(boolean.class, ByteOrder.nativeOrder());\n-     * }\n@@ -488,4 +476,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(char.class, ByteOrder.nativeOrder());\n-     * }\n@@ -498,4 +482,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(short.class, ByteOrder.nativeOrder());\n-     * }\n@@ -508,4 +488,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(int.class, ByteOrder.nativeOrder());\n-     * }\n@@ -518,4 +494,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(long.class, ByteOrder.nativeOrder());\n-     * }\n@@ -528,4 +500,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(float.class, ByteOrder.nativeOrder()).withBitAlignment(32);\n-     * }\n@@ -538,4 +506,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(double.class, ByteOrder.nativeOrder());\n-     * }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -374,0 +374,44 @@\n+    \/**\n+     * Creates a value layout of given Java carrier and byte order. The type of resulting value layout is determined\n+     * by the carrier provided:\n+     * <ul>\n+     *     <li>{@link ValueLayout.OfBoolean}, for {@code boolean.class}<\/li>\n+     *     <li>{@link ValueLayout.OfByte}, for {@code byte.class}<\/li>\n+     *     <li>{@link ValueLayout.OfShort}, for {@code short.class}<\/li>\n+     *     <li>{@link ValueLayout.OfChar}, for {@code char.class}<\/li>\n+     *     <li>{@link ValueLayout.OfInt}, for {@code int.class}<\/li>\n+     *     <li>{@link ValueLayout.OfFloat}, for {@code float.class}<\/li>\n+     *     <li>{@link ValueLayout.OfLong}, for {@code long.class}<\/li>\n+     *     <li>{@link ValueLayout.OfDouble}, for {@code double.class}<\/li>\n+     *     <li>{@link ValueLayout.OfAddress}, for {@code MemorySegment.class}<\/li>\n+     * <\/ul>\n+     * @param carrier the value layout carrier.\n+     * @param order the value layout's byte order.\n+     * @return a value layout with the given Java carrier and byte-order.\n+     * @throws IllegalArgumentException if the carrier type is not supported.\n+     *\/\n+    public static ValueLayout valueLayout(Class<?> carrier, ByteOrder order) {\n+        Objects.requireNonNull(carrier);\n+        Objects.requireNonNull(order);\n+        if (carrier == boolean.class) {\n+            return ValueLayouts.OfBooleanImpl.of(order);\n+        } else if (carrier == char.class) {\n+            return ValueLayouts.OfCharImpl.of(order);\n+        } else if (carrier == byte.class) {\n+            return ValueLayouts.OfByteImpl.of(order);\n+        } else if (carrier == short.class) {\n+            return ValueLayouts.OfShortImpl.of(order);\n+        } else if (carrier == int.class) {\n+            return ValueLayouts.OfIntImpl.of(order);\n+        } else if (carrier == float.class) {\n+            return ValueLayouts.OfFloatImpl.of(order);\n+        } else if (carrier == long.class) {\n+            return ValueLayouts.OfLongImpl.of(order);\n+        } else if (carrier == double.class) {\n+            return ValueLayouts.OfDoubleImpl.of(order);\n+        } else if (carrier == MemorySegment.class) {\n+            return ValueLayouts.OfAddressImpl.of(order);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported carrier: \" + carrier.getName());\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -143,1 +144,1 @@\n-                    FunctionDescriptor.ofVoid(MemoryLayout.valueLayout(char.class, ByteOrder.nativeOrder()).withBitAlignment(32)),\n+                    FunctionDescriptor.ofVoid(ValueLayout.JAVA_CHAR.withBitAlignment(32)),\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -294,12 +294,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadValueCarrier() {\n-        \/\/ Strings have no value layout\n-        MemoryLayout.valueLayout(String.class, ByteOrder.LITTLE_ENDIAN);\n-    }\n-\n-    @Test(dataProvider = \"validCarriers\")\n-    public void testValueLayout(Class<?> carrier) {\n-        ValueLayout layout = MemoryLayout.valueLayout(carrier, ByteOrder.nativeOrder());\n-        assertEquals(layout.carrier(), carrier);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @modules java.base\/jdk.internal.foreign.layout\n@@ -33,1 +34,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -35,0 +35,2 @@\n+\n+import jdk.internal.foreign.layout.ValueLayouts;\n@@ -49,1 +51,1 @@\n-        ValueLayout newLayout = MemoryLayout.valueLayout(layout.carrier(), layout.order());\n+        ValueLayout newLayout = ValueLayouts.valueLayout(layout.carrier(), layout.order());\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLayoutEquality.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @modules java.base\/jdk.internal.foreign.layout\n@@ -50,1 +51,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -52,0 +52,2 @@\n+\n+import jdk.internal.foreign.layout.ValueLayouts;\n@@ -172,1 +174,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(MemoryLayout.valueLayout(carrier, ByteOrder.nativeOrder()));\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayouts.valueLayout(carrier, ByteOrder.nativeOrder()));\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}