{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.RecordComponent;\n@@ -29,0 +30,1 @@\n+import java.util.function.Function;\n@@ -73,0 +75,184 @@\n+\n+    \/**\n+     * A mapper that can produce instances of type {@code T} given\n+     * a MemorySegment and an offset in the segment.\n+     *\n+     * @param <T> the type of instances produced\n+     * @since 22\n+     *\/\n+    @FunctionalInterface\n+    interface TypeMapper<T> extends Function<MemorySegment, T> {\n+\n+        \/**\n+         * {@return an instance of type {@code T} that takes its state from the\n+         * provided {@code segment} at the provided {@code offset}}\n+         *\n+         * @param segment from which the state shall be retrieved\n+         * @param offset  in the segment (non-negative)\n+         * @throws IllegalArgumentException if the provided offset is negative or if an instance\n+         *                                  cannot be produced, for example, if the provided segment\n+         *                                  is too small or the provided offset is too large.\n+         *\/\n+        T apply(MemorySegment segment, long offset);\n+\n+        \/**\n+         * {@return an instance of type T that takes its state from the\n+         * provided {@code segment} at the offset zero}\n+         *\n+         * @param segment from which the state shall be retrieved\n+         * @throws IllegalArgumentException if an instance cannot be produced, for\n+         *                                  example, if the provided segment is too small.\n+         *\/\n+        @Override\n+        default T apply(MemorySegment segment) {\n+            return apply(segment, 0L);\n+        }\n+    }\n+\n+    \/**\n+     * {@return a {@link Function} that can project {@linkplain MemorySegment MemorySegments} into new\n+     * instances of the provided {@link Record} {@code type} by means of matching the names of the\n+     * record components with the names of the member layouts in this group layout}\n+     * <p>\n+     * In short, the method finds, for each record component, a corresponding member layout with the same\n+     * name in this group layout. There are some restrictions on the record component type and the\n+     * corresponding member layout type (e.g. a record component of type {@code int} can only be matched\n+     * with a member layout having a carrier type of {@code int.class} (such as {@link ValueLayout#JAVA_INT}).\n+     * <p>\n+     * Using the member layouts (e.g. observing offsets and {@link java.nio.ByteOrder byte ordering}, a\n+     * number of extraction methods are then identified for all the record components and are stored\n+     * internally in the returned function.\n+     * <p>\n+     * Upon invoking the function, the canonical constructor of the record is invoked with the result of all\n+     * the extraction methods.\n+     * <p>\n+     * More formally:\n+     * A mapper {@code M} between a record type {@code R}, a memory layout {@code L} and an {@code offset}\n+     * (which is zero for the initial invocation of this method) is defined as follows {@code M(type, layout, offset)};\n+     * <p>\n+     * Let {@code R} be a record type with its constituent components:\n+     * {@code C1, C2}, ..., CN}, where {@code N} is the (non-negative) number of components of {@code R}.\n+     * <p>\n+     * Let {@code Fa(MemorySegment ms)} be a function that takes\n+     * a {@link MemorySegment} {@code ms} and produces a value for {@code Ca}.\n+     * <p>\n+     * Let {@code L} be a group layout with the member layouts {@code ML1, ML2, ..., MLM}, where {@code M >= N}.\n+     * <p>\n+     * Let {@code offsetOf(GroupLayout L, MemoryLayout LL)} be a function that, via\n+     * the method {@link MemoryLayout#byteOffset(PathElement...)}, can compute the offset from the\n+     * {@code layout L} to the sub-layout {@code LL}.\n+     * <p>\n+     * Then, for each {@code Ca, a <= N}, there must be a corresponding distinct\n+     * {@code MLb} such that the {@link RecordComponent#getName()} () name} of {@code Ca}\n+     * and the {@link MemoryLayout#name() name} of {@code MLb} are the same, and:\n+     * <ul>\n+     *    <li>\n+     *        <h4>If {@code MLb} is a {@link ValueLayout };<\/h4>\n+     *        then {@code Ca} must be of the exact type of {@code MLb}'s {@link ValueLayout#carrier() carrier()}<br>\n+     *        whereby {@code Ca = Fa(MemorySegment ms) = ms.get(MLb, offset + offsetOf(layout, MLb))}.<br>\n+     *    <\/li>\n+     *    <li>\n+     *        <h4>If {@code MLb} is a {@link GroupLayout };<\/h4>\n+     *        then {@code Ca} must be of another {@link Record} type {@code R2}\n+     *        (such that {@code R2 != R}) that can be mapped to {@code Ca} via\n+     *        another resulting mapper {@code M2 = M(R2, MLb, offset + offsetOf(layout, MLb))} recursively\n+     *        whereby {@code Ca} = {@code Fa(MemorySegment ms) = M2.apply(ms)}<br>\n+     *    <\/li>\n+     *    <li>\n+     *        <h4>If {@code MLb} is a {@link SequenceLayout };<\/h4>\n+     *        then {@code Ca} must be an array {@code C[]^D} (an array of depth {@code D}\n+     *        and with an array component type {@code C}) that can be mapped to {@code Cb} via a resulting\n+     *        \"array mapper\" {@code A2} obtained via recursively pealing off nested sequence layouts in {@code MLb}\n+     *        and then (after {@code D} pealing operations)\n+     *        finally determining the leaf element layout {@code LL = } {@link SequenceLayout#elementLayout() elementLayout()}\n+     *        and subsequently obtaining an array mapper {@code AM(MemorySegment ms, long componentOffset)} with\n+     *        a leaf mapper {@code LM}:\n+     *        <ul>\n+     *            <li>\n+     *            if {@code LL} is a {@link ValueLayout}:\n+     *            {@code LM} = {@link MemorySegment#get(ValueLayout.OfInt, long) ms -> ms.get(LL, offset + offsetOf(layout, MLb))}\n+     *            <\/li>\n+     *\n+     *            <li>\n+     *            if {@code LL} is a {@link GroupLayout}:\n+     *            {@code LM} = M(C.type, LL, offset + offsetOf(layout, MLb)} recursively.\n+     *            <\/li>\n+     *        <\/ul>\n+     *        whereby {@code Ca} = {@code Fa(MemorySegment ms)} will be extracted by\n+     *        applying {@code AM} which, in turn, will apply {@code LM} recursively at\n+     *        a memory segment slice at the applicable multidimensional array offset(s).<br>\n+     *        Note: boolean arrays are not supported despite the above and if an attempt is made to map\n+     *        a boolean array, an {@link IllegalArgumentException} will be thrown.\n+     *    <\/li>\n+     *    <li>\n+     *        <h4>Otherwise;<\/h4>\n+     *        the method will throw an {@link IllegalArgumentException} as {@code MLb} cannot\n+     *        be projected onto {@code Ca}.  An example of this is trying to match a record component\n+     *        of type {@link String} or trying to map a {@link PaddingLayout} element.<br>\n+     *    <\/li>\n+     * <\/ul>\n+     * <p>\n+     * If the above is true, the returned mapper {@code M(type, this, 0L)} will, when invoked,\n+     * subsequently invoke the record type's canonical constructor {@code R::new} using a composition\n+     * of the above mapping functions:\n+     * <p>\n+     * {@code ms -> new R(F1(ms), F2(ms), ..., FN(ms))}\n+     * <p>\n+     * Unnamed elements in this group will be ignored.\n+     * Unmatched elements (with respect to the name) in this group layout will be ignored.\n+     * <p>\n+     * The returned function will respect the byte orderings and alignment constraints of this\n+     * group layout.\n+     * <p>\n+     * The returned Function may throw an {@link IllegalArgumentException} if it, for any reason, fails\n+     * to extract a {@link Record}.  An example of such a failure is if the applied memory segment is too\n+     * small for the layout at hand.\n+     * <p>\n+     * The example below shows how to extract an instance of a public {@code Point} record class\n+     * from a {@link MemorySegment}:\n+     * {@snippet lang = java:\n+     *     MemorySegment segment = MemorySegment.ofArray(new int[]{3, 4});\n+     *\n+     *     public record Point(int x, int y){}\n+     *\n+     *     var pointLayout = MemoryLayout.structLayout(\n+     *         JAVA_INT.withName(\"x\"),\n+     *         JAVA_INT.withName(\"y\")\n+     *     );\n+     *\n+     *     Function<MemorySegment, Point> pointExtractor = pointLayout.recordMapper(Point.class);\n+     *\n+     *     \/\/ Extracts a new Point from the provided MemorySegment\n+     *     Point point = pointExtractor.apply(segment); \/\/ Point[x=3, y=4]\n+     * }\n+     * <p>\n+     * Boxing, widening and narrowing must be explicitly handled by user code.  In the following example, the above\n+     * {@code Point} (using primitive {@code int x} and {@code int y} coordinates) are explicitly mapped to\n+     * a narrowed point type (instead using primitive {@code byte x} and {@code byte y} coordinates):\n+     * <p>\n+     * {@snippet lang = java:\n+     *     public record NarrowedPoint(byte x, byte y) {\n+     *\n+     *         static NarrowedPoint fromPoint(Point p) {\n+     *             return new NarrowedPoint((byte) p.x, (byte) p.y);\n+     *         }\n+     *     }\n+     *\n+     *     Function<MemorySegment, NarrowedPoint> narrowedPointExtractor =\n+     *             pointLayout.recordMapper(Point.class)\n+     *                     .andThen(NarrowedPoint::fromPoint);\n+     *\n+     *     \/\/ Extracts a new NarrowedPoint from the provided MemorySegment\n+     *     NarrowedPoint narrowedPoint = narrowedPointExtractor.apply(segment); \/\/ NarrowedPoint[x=3, y=4]\n+     * }\n+     *\n+     * @param <R> record type\n+     * @param type the type (Class) of the record\n+     * @throws IllegalArgumentException if the provided record {@code type} is the class {@link Record} or contains\n+     *                                  components for which there are no exact mapping (of names and types) in\n+     *                                  this group layout or if the provided {@code type} is not public or\n+     *                                  if the method is otherwise unable to create a record mapper as specified above.\n+     * @since 22\n+     *\/\n+    <R extends Record> TypeMapper<R> recordMapper(Class<R> type);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -173,0 +173,26 @@\n+ * <h2 id=\"record-mapping\">Record mapping<\/h2>\n+ * <p>A {@linkplain GroupLayout group layout} can provide mapping capabilities from memory segments to Java\n+ * {@linkplain Record Records} (Record Classes being specified in Section {@jls 8.10} of\n+ * <cite>The Java Language Specification<\/cite>) by means of matching named elements in the group layout\n+ * with component names in a record class.\n+ * <p>\n+ * For instance:\n+ * <p>\n+ * {@snippet lang=java:\n+ *     MemorySegment segment = MemorySegment.ofArray(new int[]{3, 4});\n+ *\n+ *     public record Point(int x, int y){}\n+ *\n+ *     var pointLayout = MemoryLayout.structLayout(\n+ *         JAVA_INT.withName(\"x\"),\n+ *         JAVA_INT.withName(\"y\")\n+ *     );\n+ *\n+ *     Function<MemorySegment, Point> pointExtractor = pointLayout.recordMapper(Point.class);\n+ *\n+ *     \/\/ Extracts a new Point from the provided MemorySegment\n+ *     Point point = pointExtractor.apply(segment); \/\/ Point[x=3, y=4]\n+ * }\n+ *\n+ * The mapping capability provides an easy-to-use bridge from native memory to Java objects.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,623 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.ValueBased;\n+import jdk.internal.util.ArraysSupport;\n+\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.RecordComponent;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * A record mapper that is matching components of a record with elements in a GroupLayout.\n+ *\n+ * @param <T> the Record type\n+ *\/\n+@ValueBased\n+public final class LayoutRecordMapper<T>\n+        implements GroupLayout.TypeMapper<T> {\n+\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+    private static final MethodHandles.Lookup PUBLIC_LOOKUP = MethodHandles.publicLookup();\n+\n+    private final Class<T> type;\n+    private final GroupLayout layout;\n+    private final long offset;\n+    private final int depth;\n+    private final MethodHandles.Lookup lookup;\n+    private final MethodHandle ctor;\n+\n+    public static <T> LayoutRecordMapper<T> create(Class<T> type,\n+                                                   GroupLayout layout) {\n+        return new LayoutRecordMapper<>(type, layout);\n+    }\n+\n+    private LayoutRecordMapper(Class<T> type,\n+                              GroupLayout layout) {\n+        this(type, layout, 0L, 0, PUBLIC_LOOKUP);\n+    }\n+\n+    private LayoutRecordMapper(Class<T> type,\n+                               GroupLayout layout,\n+                               long offset,\n+                               int depth,\n+                               MethodHandles.Lookup lookup) {\n+\n+        if (!type.isRecord() || Record.class.equals(type)) {\n+            throw new IllegalArgumentException(type + \" is not a Record\");\n+        }\n+\n+        this.type = type;\n+        this.layout = layout;\n+        this.offset = offset;\n+        this.depth = depth;\n+        this.lookup = lookup;\n+\n+        assertMappingsCorrect();\n+\n+        \/\/ For each component, find an f(a) = MethodHandle(MemorySegment) that returns the component type\n+        var handles = Arrays.stream(type.getRecordComponents())\n+                .map(this::methodHandle)\n+                .toList();\n+\n+        Class<?>[] ctorParameterTypes = Arrays.stream(type.getRecordComponents())\n+                .map(RecordComponent::getType)\n+                .toArray(Class<?>[]::new);\n+\n+        try {\n+            var ctor = lookup.findConstructor(type, MethodType.methodType(void.class, ctorParameterTypes));\n+            for (int i = 0; i < handles.size(); i++) {\n+                \/\/ Insert the respective handler for the constructor\n+                ctor = MethodHandles.filterArguments(ctor, i, handles.get(i));\n+            }\n+\n+            var mt = MethodType.methodType(type, MemorySegment.class);\n+            \/\/ Fold the many identical MemorySegment arguments into a single argument\n+            ctor = MethodHandles.permuteArguments(ctor, mt, new int[handles.size()]);\n+            if (depth == 0) {\n+                \/\/ This is the base level mh so, we need to cast to Object as the final\n+                \/\/ apply() method will do the final cast\n+                ctor = ctor.asType(MethodType.methodType(Object.class, MemorySegment.class));\n+            }\n+            \/\/ The constructor MethodHandle is now of type (MemorySegment)T unless it is the one\n+            \/\/ of depth zero when it is (MemorySegment)Object\n+            this.ctor = ctor;\n+        } catch (IllegalAccessException | NoSuchMethodException e) {\n+            throw new IllegalArgumentException(\"There is no public constructor in '\" + type.getName() +\n+                    \"' for \" + Arrays.toString(ctorParameterTypes) + \" using lookup \" + lookup, e);\n+        }\n+    }\n+\n+    private MethodHandle methodHandle(RecordComponent component) {\n+\n+        var pathElement = MemoryLayout.PathElement.groupElement(component.getName());\n+        var componentLayout = layout.select(pathElement);\n+        var byteOffset = layout.byteOffset(pathElement) + offset;\n+        try {\n+            return switch (componentLayout) {\n+                case ValueLayout vl -> methodHandle(vl, component, byteOffset);\n+                case GroupLayout gl -> methodHandle(gl, component, byteOffset);\n+                case SequenceLayout sl -> methodHandle(sl, component, byteOffset);\n+                case PaddingLayout __ -> throw fail(component, componentLayout);\n+            };\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    private MethodHandle methodHandle(ValueLayout vl,\n+                                      RecordComponent component,\n+                                      long byteOffset) throws NoSuchMethodException, IllegalAccessException {\n+\n+        assertTypesMatch(component, component.getType(), vl);\n+        var mt = MethodType.methodType(vl.carrier(), topValueLayoutType(vl), long.class);\n+        var mh = LOOKUP.findVirtual(MemorySegment.class, \"get\", mt);\n+        \/\/ (MemorySegment, OfX, long) -> (MemorySegment, long)\n+        mh = MethodHandles.insertArguments(mh, 1, vl);\n+        \/\/ (MemorySegment, long) -> (MemorySegment)\n+        return MethodHandles.insertArguments(mh, 1, byteOffset);\n+    }\n+\n+    private MethodHandle methodHandle(GroupLayout gl,\n+                                      RecordComponent component,\n+                                      long byteOffset) throws NoSuchMethodException, IllegalAccessException {\n+        if (type.equals(component.getType())) {\n+            throw new IllegalArgumentException(\n+                    \"A type may not use a component of the same type: \" + type + \" in \" + gl);\n+        }\n+        \/\/ Simply return the raw MethodHandle of the recursively computed record mapper\n+        return recordMapper(component.getType(), gl, byteOffset).ctor;\n+    }\n+\n+    private MethodHandle methodHandle(SequenceLayout sl,\n+                                      RecordComponent component,\n+                                      long byteOffset) throws NoSuchMethodException, IllegalAccessException {\n+\n+        String name = component.getName();\n+        var componentType = component.getType();\n+        if (!componentType.isArray()) {\n+            throw new IllegalArgumentException(\"Unable to map '\" + sl +\n+                    \"' because the component '\" + componentType.getName() + \" \" + name + \"' is not an array\");\n+        }\n+\n+        MultidimensionalSequenceLayoutInfo info = MultidimensionalSequenceLayoutInfo.of(sl, componentType);\n+\n+        if (info.elementLayout() instanceof ValueLayout.OfBoolean) {\n+            throw new IllegalArgumentException(\"Arrays of booleans (\" + info.elementLayout() + \") are not supported\");\n+        }\n+\n+        if (dimensionOf(componentType) != info.sequences().size()) {\n+            throw new IllegalArgumentException(\"Unable to map '\" + sl + \"'\" +\n+                    \" of dimension \" + info.sequences().size() +\n+                    \" because the component '\" + componentType.getName() + \" \" + name + \"'\" +\n+                    \" has a dimension of \" + dimensionOf(componentType));\n+        }\n+\n+        \/\/ Handle multi-dimensional arrays\n+        if (info.sequences().size() > 1) {\n+            var mh = LOOKUP.findStatic(LayoutRecordMapper.class, \"toMultiArrayFunction\",\n+                    MethodType.methodType(Object.class, MemorySegment.class, MultidimensionalSequenceLayoutInfo.class, long.class, Class.class, Function.class));\n+            \/\/ (MemorySegment, MultidimensionalSequenceLayoutInfo, long offset, Class leafType, Function mapper) ->\n+            \/\/ (MemorySegment, long offset, Class leafType, Function mapper)\n+            mh = MethodHandles.insertArguments(mh, 1, info);\n+            \/\/ (MemorySegment, long offset, Class leafType, Function mapper) ->\n+            \/\/ (MemorySegment, Class leafType, Function mapper)\n+            mh = MethodHandles.insertArguments(mh, 1, byteOffset);\n+\n+            switch (info.elementLayout()) {\n+                case ValueLayout vl -> {\n+                    \/\/ (MemorySegment, Class leafType, Function mapper) ->\n+                    \/\/ (MemorySegment, Function mapper)\n+                    mh = MethodHandles.insertArguments(mh, 1, vl.carrier());\n+                    Function<MemorySegment, Object> leafArrayMapper =\n+                            switch (vl) {\n+                                case ValueLayout.OfByte ofByte -> ms -> ms.toArray(ofByte);\n+                                case ValueLayout.OfBoolean ofBoolean ->\n+                                        throw new UnsupportedOperationException(\"boolean arrays not supported: \" + ofBoolean);\n+                                case ValueLayout.OfShort ofShort -> ms -> ms.toArray(ofShort);\n+                                case ValueLayout.OfChar ofChar -> ms -> ms.toArray(ofChar);\n+                                case ValueLayout.OfInt ofInt -> ms -> ms.toArray(ofInt);\n+                                case ValueLayout.OfLong ofLong -> ms -> ms.toArray(ofLong);\n+                                case ValueLayout.OfFloat ofFloat -> ms -> ms.toArray(ofFloat);\n+                                case ValueLayout.OfDouble ofDouble -> ms -> ms.toArray(ofDouble);\n+                                case AddressLayout addressLayout -> ms -> ms.elements(addressLayout)\n+                                        .map(s -> s.get(addressLayout, 0))\n+                                        .toArray(MemorySegment[]::new);\n+                            };\n+                    \/\/ (MemorySegment, Function mapper) ->\n+                    \/\/ (MemorySegment)\n+                    mh = MethodHandles.insertArguments(mh, 1, leafArrayMapper);\n+                    return castReturnType(mh, component.getType());\n+                }\n+                case GroupLayout gl -> {\n+                    var arrayComponentType = info.type();\n+                    \/\/ The \"local\" byteOffset for the record component mapper is zero\n+                    var componentMapper = recordMapper(arrayComponentType, gl, 0);\n+                    \/\/ Change the return type to Object so that we may use Array.set() below\n+                    var mapperCtor = componentMapper.ctor\n+                            .asType(MethodType.methodType(Object.class, MemorySegment.class));\n+\n+                    Function<MemorySegment, Object> leafArrayMapper = ms ->\n+                            toArray(ms, gl, arrayComponentType, mapperCtor);\n+\n+                    \/\/ (MemorySegment, Class leafType, Function mapper) ->\n+                    \/\/ (MemorySegment, Function mapper)\n+                    mh = MethodHandles.insertArguments(mh, 1, arrayComponentType);\n+                    \/\/ (MemorySegment, Function mapper) ->\n+                    \/\/ (MemorySegment)\n+                    mh = MethodHandles.insertArguments(mh, 1, leafArrayMapper);\n+                    return castReturnType(mh, component.getType());\n+                }\n+                case SequenceLayout __ -> {\n+                    throw new InternalError(\"Should not reach here\");\n+                }\n+                case PaddingLayout __ -> throw fail(component, sl);\n+            }\n+        }\n+\n+        \/\/ Faster single-dimensional arrays\n+        switch (info.elementLayout()) {\n+            case ValueLayout vl -> {\n+                assertTypesMatch(component, info.type(), vl);\n+                var mt = MethodType.methodType(vl.carrier().arrayType(),\n+                        MemorySegment.class, topValueLayoutType(vl), long.class, long.class);\n+                var mh = LOOKUP.findStatic(LayoutRecordMapper.class, \"toArray\", mt);\n+                \/\/ (MemorySegment, OfX, long offset, long count) -> (MemorySegment, OfX, long offset)\n+                mh = MethodHandles.insertArguments(mh, 3, info.sequences().getFirst().elementCount());\n+                \/\/ (MemorySegment, OfX, long offset) -> (MemorySegment, long offset)\n+                mh = MethodHandles.insertArguments(mh, 1, vl);\n+                \/\/ (MemorySegment, long offset) -> (MemorySegment)\n+                return castReturnType(MethodHandles.insertArguments(mh, 1, byteOffset), component.getType());\n+            }\n+            case GroupLayout gl -> {\n+                \/\/ The \"local\" byteOffset for the record component mapper is zero\n+                var componentMapper = recordMapper(info.type(), gl, 0);\n+                try {\n+                    var mt = MethodType.methodType(Object.class.arrayType(),\n+                            MemorySegment.class, GroupLayout.class, long.class, long.class, Class.class, MethodHandle.class);\n+                    var mh = LOOKUP.findStatic(LayoutRecordMapper.class, \"toArray\", mt);\n+                    var mapper = componentMapper.ctor.asType(MethodType.methodType(Object.class, MemorySegment.class));\n+                    \/\/ (MemorySegment, GroupLayout, long offset, long count, Class, MethodHandle) ->\n+                    \/\/ (MemorySegment, GroupLayout, long offset, long count, Class)\n+                    mh = MethodHandles.insertArguments(mh, 5, mapper);\n+                    \/\/ (MemorySegment, GroupLayout, long offset, long count, Class) ->\n+                    \/\/ (MemorySegment, GroupLayout, long offset, long count)\n+                    mh = MethodHandles.insertArguments(mh, 4, componentMapper.type);\n+                    \/\/ (MemorySegment, GroupLayout, long offset, long count) ->\n+                    \/\/ (MemorySegment, GroupLayout, long offset)\n+                    mh = MethodHandles.insertArguments(mh, 3, info.sequences().getFirst().elementCount());\n+                    \/\/ (MemorySegment, GroupLayout, long offset) ->\n+                    \/\/ (MemorySegment, long offset)\n+                    mh = MethodHandles.insertArguments(mh, 1, gl);\n+                    \/\/ (MemorySegment, long offset) -> (MemorySegment)Record[]\n+                    mh = MethodHandles.insertArguments(mh, 1, byteOffset);\n+                    \/\/ (MemorySegment, long offset)Record[] -> (MemorySegment)componentType\n+                    return MethodHandles.explicitCastArguments(mh, MethodType.methodType(component.getType(), MemorySegment.class));\n+                } catch (NoSuchMethodException | IllegalAccessException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            case SequenceLayout __ ->  throw new InternalError(\"Should not reach here\");\n+            case PaddingLayout __ -> throw fail(component, sl);\n+        }\n+    }\n+\n+    private IllegalArgumentException fail(RecordComponent component,\n+                                          MemoryLayout layout) {\n+        throw new IllegalArgumentException(\n+                \"Unable to map \" + layout + \" to \" + type.getName() + \".\" + component.getName());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public T apply(MemorySegment segment) {\n+        try {\n+            return (T) ctor.invokeExact(segment);\n+        } catch (Throwable e) {\n+            throw new IllegalArgumentException(\n+                    \"Unable to invoke the canonical constructor of \" + type.getName() +\n+                            \" using \" + segment, e);\n+        }\n+    }\n+\n+    @Override\n+    public T apply(MemorySegment segment, long offset) {\n+        return offset == 0\n+                ? apply(segment)\n+                : apply(segment.asSlice(offset));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"LayoutRecordMapper{\" +\n+                \"type=\" + type.getName() + \", \" +\n+                \"layout=\" + layout + \", \" +\n+                \"offset=\" + offset + \"}\";\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return o instanceof LayoutRecordMapper<?> that &&\n+                offset == that.offset &&\n+                depth == that.depth &&\n+                Objects.equals(type, that.type) &&\n+                Objects.equals(layout, that.layout);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(type, layout, offset, depth);\n+    }\n+\n+    static Class<? extends ValueLayout> topValueLayoutType(ValueLayout vl) {\n+        \/\/ All the permitted implementations OfXImpl of the ValueLayout interfaces declare\n+        \/\/ its main top interface OfX as the sole interface (e.g. OfIntImpl implements only OfInt directly)\n+        return vl.getClass().getInterfaces()[0].asSubclass(ValueLayout.class);\n+    }\n+\n+    void assertTypesMatch(RecordComponent component,\n+                          Class<?> recordComponentType,\n+                          ValueLayout vl) {\n+\n+        if (!(recordComponentType == vl.carrier())) {\n+            throw new IllegalArgumentException(\"Unable to match types because the component '\" +\n+                    component.getName() + \"' (in \" + type.getName() + \") has the type of '\" + component.getType() +\n+                    \"' but the layout carrier is '\" + vl.carrier() + \"' (in \" + layout + \")\");\n+        }\n+    }\n+\n+    void assertMappingsCorrect() {\n+        var nameMappingCounts = layout.memberLayouts().stream()\n+                .map(MemoryLayout::name)\n+                .flatMap(Optional::stream)\n+                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+\n+        \/\/ Make sure we have all components distinctly mapped\n+        for (RecordComponent component : type.getRecordComponents()) {\n+            String name = component.getName();\n+            switch (nameMappingCounts.getOrDefault(name, 0L).intValue()) {\n+                case 0 -> throw new IllegalArgumentException(\"No mapping for \" +\n+                        type.getName() + \".\" + component.getName() +\n+                        \" in layout \" + layout);\n+                case 1 -> { \/* Happy path *\/ }\n+                default -> throw new IllegalArgumentException(\"Duplicate mappings for \" +\n+                        type.getName() + \".\" + component.getName() +\n+                        \" in layout \" + layout);\n+            }\n+        }\n+    }\n+\n+    private <R> LayoutRecordMapper<R> recordMapper(Class<R> componentType,\n+                                                   GroupLayout gl,\n+                                                   long byteOffset) {\n+\n+        return new LayoutRecordMapper<>(componentType, gl, byteOffset, depth + 1, lookup);\n+    }\n+\n+    record MultidimensionalSequenceLayoutInfo(List<SequenceLayout> sequences,\n+                                              MemoryLayout elementLayout,\n+                                              Class<?> type){\n+\n+        int[] dimensions() {\n+            return sequences().stream()\n+                    .mapToLong(SequenceLayout::elementCount)\n+                    .mapToInt(Math::toIntExact)\n+                    .toArray();\n+        }\n+\n+        int firstDimension() {\n+           return (int) sequences().getFirst().elementCount();\n+        }\n+\n+        int lastDimension() {\n+            return (int) sequences().getLast().elementCount();\n+        }\n+\n+        long layoutByteSize() {\n+            return sequences()\n+                    .getFirst()\n+                    .byteSize();\n+        }\n+\n+        MultidimensionalSequenceLayoutInfo removeFirst() {\n+            var removed = new ArrayList<>(sequences);\n+            removed.removeFirst();\n+            return new MultidimensionalSequenceLayoutInfo(removed, elementLayout, type);\n+        }\n+\n+        static MultidimensionalSequenceLayoutInfo of(SequenceLayout sequenceLayout,\n+                                                     Class<?> arrayComponent) {\n+            MemoryLayout current = sequenceLayout;\n+            List<SequenceLayout> sequences = new ArrayList<>();\n+            while(true) {\n+                if (current instanceof SequenceLayout element) {\n+                    long count = element.elementCount();\n+                    if (count > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n+                        throw new IllegalArgumentException(\"Unable to accommodate '\" + element + \"' in an array.\");\n+                    }\n+                    current = element.elementLayout();\n+                    sequences.add(element);\n+                } else {\n+                    return new MultidimensionalSequenceLayoutInfo(\n+                            List.copyOf(sequences), current, deepArrayComponentType(arrayComponent));\n+                }\n+            }\n+        }\n+\n+        private static Class<?> deepArrayComponentType(Class<?> arrayType) {\n+            Class<?> recordComponentType = arrayType;\n+            while (recordComponentType.isArray()) {\n+                recordComponentType = Objects.requireNonNull(recordComponentType.componentType());\n+            }\n+            return recordComponentType;\n+        }\n+\n+    }\n+\n+    \/\/ Provide widening and boxing magic\n+    static MethodHandle castReturnType(MethodHandle mh,\n+                                       Class<?> to) {\n+        var from = mh.type().returnType();\n+        if (from == to) {\n+            \/\/ We are done as it is\n+            return mh;\n+        }\n+\n+        if (!to.isPrimitive() && !to.isArray()) {\n+            throw new IllegalArgumentException(\"Cannot convert '\" + from + \"' to '\" + to.getName());\n+        }\n+\n+        return MethodHandles.explicitCastArguments(mh, MethodType.methodType(to, MemorySegment.class));\n+    }\n+\n+    static int dimensionOf(Class<?> arrayClass) {\n+        return (int) Stream.<Class<?>>iterate(arrayClass, Class::isArray, Class::componentType)\n+                .count();\n+    }\n+\n+    \/\/ Wrapper to create an array of Records\n+\n+    static <R> R[] toArray(MemorySegment segment,\n+                           GroupLayout elementLayout,\n+                           long offset,\n+                           long count,\n+                           Class<R> type,\n+                           MethodHandle mapper) {\n+\n+        var slice = slice(segment, elementLayout, offset, count);\n+        return toArray(slice, elementLayout, type, mapper);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <R> R[] toArray(MemorySegment segment,\n+                           GroupLayout elementLayout,\n+                           Class<R> type,\n+                           MethodHandle mapper) {\n+\n+        return segment.elements(elementLayout)\n+                .map(s -> {\n+                    try {\n+                     return (R) mapper.invokeExact(s);\n+                    } catch (Throwable t) {\n+                        throw new IllegalArgumentException(t);\n+                    }\n+\n+                })\n+                .toArray(s -> (R[]) Array.newInstance(type, Math.toIntExact(s)));\n+    }\n+\n+    \/\/ Below are `MemorySegment::toArray` wrapper methods that is also taking an offset\n+    \/\/ Begin: Reflectively used methods\n+\n+    static byte[] toArray(MemorySegment segment,\n+                          ValueLayout.OfByte elementLayout,\n+                          long offset,\n+                          long count) {\n+\n+        return slice(segment, elementLayout, offset, count).toArray(elementLayout);\n+    }\n+\n+    static short[] toArray(MemorySegment segment,\n+                           ValueLayout.OfShort elementLayout,\n+                           long offset,\n+                           long count) {\n+\n+        return slice(segment, elementLayout, offset, count).toArray(elementLayout);\n+    }\n+\n+    static char[] toArray(MemorySegment segment,\n+                          ValueLayout.OfChar elementLayout,\n+                          long offset,\n+                          long count) {\n+\n+        return slice(segment, elementLayout, offset, count).toArray(elementLayout);\n+    }\n+\n+    static int[] toArray(MemorySegment segment,\n+                         ValueLayout.OfInt elementLayout,\n+                         long offset,\n+                         long count) {\n+\n+        return slice(segment, elementLayout, offset, count).toArray(elementLayout);\n+    }\n+\n+    static long[] toArray(MemorySegment segment,\n+                          ValueLayout.OfLong elementLayout,\n+                          long offset,\n+                          long count) {\n+\n+        return slice(segment, elementLayout, offset, count).toArray(elementLayout);\n+    }\n+\n+    static float[] toArray(MemorySegment segment,\n+                           ValueLayout.OfFloat elementLayout,\n+                           long offset,\n+                           long count) {\n+\n+        return slice(segment, elementLayout, offset, count).toArray(elementLayout);\n+    }\n+\n+    static double[] toArray(MemorySegment segment,\n+                            ValueLayout.OfDouble elementLayout,\n+                            long offset,\n+                            long count) {\n+\n+        return slice(segment, elementLayout, offset, count).toArray(elementLayout);\n+    }\n+\n+    static MemorySegment[] toArray(MemorySegment segment,\n+                                   AddressLayout elementLayout,\n+                                   long offset,\n+                                   long count) {\n+\n+        return slice(segment, elementLayout, offset, count)\n+                .elements(elementLayout)\n+                .map(s -> s.get(elementLayout, 0))\n+                .toArray(MemorySegment[]::new);\n+    }\n+\n+    \/\/ End: Reflectively used methods\n+\n+    private static MemorySegment slice(MemorySegment segment,\n+                                       MemoryLayout elementLayout,\n+                                       long offset,\n+                                       long count) {\n+\n+        return segment.asSlice(offset, elementLayout.byteSize() * count);\n+    }\n+\n+    static Object toMultiArrayFunction(MemorySegment segment,\n+                                       MultidimensionalSequenceLayoutInfo info,\n+                                       long offset,\n+                                       Class<?> leafType,\n+                                       Function<MemorySegment, Object> leafArrayConstructor) {\n+\n+        int[] dimensions = info.dimensions();\n+        \/\/ Create the array to return\n+        Object result = Array.newInstance(leafType, dimensions);\n+\n+        int firstDimension = info.firstDimension();\n+\n+        var infoFirstRemoved = info.removeFirst();\n+        int secondDimension = infoFirstRemoved.firstDimension();\n+        long chunkByteSize = infoFirstRemoved.layoutByteSize();\n+\n+        for (int i = 0; i < firstDimension; i++) {\n+            Object part;\n+            if (dimensions.length == 2) {\n+                \/\/ Trivial case: Just extract the array from the memory segment\n+                var slice = slice(segment, info.elementLayout(), offset + i * chunkByteSize, secondDimension);\n+                part = leafArrayConstructor.apply(slice);\n+            } else {\n+                \/\/ Recursively convert to arrays of (dimension - 1)\n+                var slice = segment.asSlice(i * chunkByteSize);\n+                part = toMultiArrayFunction(slice, infoFirstRemoved, offset, leafType, leafArrayConstructor);\n+            }\n+            Array.set(result, i, part);\n+        }\n+        return result;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutRecordMapper.java","additions":623,"deletions":0,"binary":false,"changes":623,"status":"added"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.internal.foreign.LayoutRecordMapper;\n+\n+import java.lang.foreign.GroupLayout;\n@@ -29,0 +32,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -32,0 +36,1 @@\n+import java.util.function.Function;\n@@ -116,0 +121,5 @@\n+    public final <R extends Record> GroupLayout.TypeMapper<R> recordMapper(Class<R> recordType) {\n+        Objects.requireNonNull(recordType);\n+        return LayoutRecordMapper.create(recordType, (GroupLayout) this);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractGroupLayout.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,1020 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED TestRecordMapper\n+ *\/\n+\n+import org.junit.jupiter.api.*;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public final class TestRecordMapper {\n+\n+    private static final boolean EXACT = true;\n+\n+    private static final GroupLayout POINT_LAYOUT = MemoryLayout.structLayout(\n+            JAVA_INT.withName(\"x\"),\n+            JAVA_INT.withName(\"y\"));\n+\n+    private static final GroupLayout LINE_LAYOUT = MemoryLayout.structLayout(\n+            POINT_LAYOUT.withName(\"begin\"),\n+            POINT_LAYOUT.withName(\"end\"));\n+\n+    private static final MemorySegment POINT_SEGMENT = MemorySegment.ofArray(new int[]{\n+            3, 4,\n+            6, 0,\n+            0, 0});\n+\n+    \/\/ Records\n+\n+    public record Point(int x, int y) {\n+    }\n+\n+    public record FlippedPoint(int y, int x) {\n+    }\n+\n+    public record PointUnion(Point normal, FlippedPoint flipped) {\n+        static final GroupLayout LAYOUT = MemoryLayout.unionLayout(\n+                POINT_LAYOUT.withName(\"normal\"),\n+                POINT_LAYOUT.withName(\"flipped\")\n+        );\n+    }\n+\n+    public record PointUnionUnion(PointUnion left, PointUnion right) {\n+        static final GroupLayout LAYOUT = MemoryLayout.unionLayout(\n+                PointUnion.LAYOUT.withName(\"left\"),\n+                PointUnion.LAYOUT.withName(\"right\")\n+        );\n+    }\n+\n+\n+    public record LongPoint(long x, long y) {\n+    }\n+\n+    public record Line(Point begin, Point end) {\n+    }\n+\n+    \/\/ Manually declared function\n+\n+    static class PointMapper implements GroupLayout.TypeMapper<Point> {\n+\n+        @Override\n+        public Point apply(MemorySegment segment, long offset) {\n+            return new Point(segment.get(JAVA_INT, offset), segment.get(JAVA_INT, offset + 4L));\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testCustomPoint() {\n+        test(POINT_SEGMENT, new PointMapper(), new Point(3, 4));\n+    }\n+\n+    @Test\n+    public void testPointMapper() {\n+        test(POINT_SEGMENT, POINT_LAYOUT.recordMapper(Point.class), new Point(3, 4));\n+    }\n+\n+    @Test\n+    public void testPointMapperUnderflow() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+                POINT_LAYOUT.recordMapper(Point.class)\n+                        .apply(MemorySegment.ofArray(new int[]{1})));\n+    }\n+\n+    public record StringPoint(String x, String y){}\n+\n+    @Test\n+    public void testLongPointTypeMismatch() {\n+        \/\/ This should fail as the types `int` and `String` cannot be mapped\n+        assertThrows(IllegalArgumentException.class, () -> {\n+                    POINT_LAYOUT.recordMapper(StringPoint.class);\n+                }\n+        );\n+    }\n+\n+    public record Empty() {}\n+\n+    @Test\n+    public void testEmptyRecord() {\n+        var mapper = POINT_LAYOUT.recordMapper(Empty.class);\n+        Empty empty = mapper.apply(POINT_SEGMENT);\n+        assertEquals(new Empty(), empty);\n+    }\n+\n+    public record Unmatched(int foo){}\n+\n+    @Test\n+    public void noMapping() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+                POINT_LAYOUT.recordMapper(Unmatched.class)\n+        );\n+    }\n+\n+    @Test\n+    public void testFlippedPointMapper() {\n+        test(POINT_SEGMENT, POINT_LAYOUT.recordMapper(FlippedPoint.class), new FlippedPoint(4, 3));\n+    }\n+\n+    \/\/ Line\n+\n+    @Test\n+    public void testLineMapper() {\n+        test(POINT_SEGMENT, LINE_LAYOUT.recordMapper(Line.class), new Line(new Point(3, 4), new Point(6, 0)));\n+    }\n+\n+    \/\/ Union\n+    @Test\n+    public void testUnion() {\n+        test(POINT_SEGMENT, PointUnion.LAYOUT.recordMapper(PointUnion.class),\n+                new PointUnion(\n+                        new Point(3, 4),\n+                        new FlippedPoint(4, 3))\n+        );\n+    }\n+\n+    \/\/ Union of Union\n+    @Test\n+    public void testUnionUnion() {\n+        test(POINT_SEGMENT, PointUnionUnion.LAYOUT.recordMapper(PointUnionUnion.class),\n+                new PointUnionUnion(\n+                        new PointUnion(\n+                                new Point(3, 4),\n+                                new FlippedPoint(4, 3)),\n+                        new PointUnion(\n+                                new Point(3, 4),\n+                                new FlippedPoint(4, 3))\n+                ));\n+    }\n+\n+    \/\/ Test Padding\n+    @Test\n+    public void testPadding() {\n+        GroupLayout paddedPointLayout = MemoryLayout.structLayout(\n+                MemoryLayout.paddingLayout(Integer.BYTES * 2).withName(\"padding\"),\n+                JAVA_INT.withName(\"x\"),\n+                JAVA_INT.withName(\"y\"));\n+        test(POINT_SEGMENT, paddedPointLayout.recordMapper(Point.class), new Point(6, 0));\n+    }\n+\n+    @Test\n+    public void testStream() {\n+\n+        List<Point> points = POINT_SEGMENT.elements(POINT_LAYOUT)\n+                .map(POINT_LAYOUT.recordMapper(Point.class))\n+                .toList();\n+\n+        assertEquals(List.of(new Point(3, 4), new Point(6, 0), new Point(0, 0)), points);\n+    }\n+\n+\n+    \/\/ A lot of types\n+\n+    public record Types(byte by, boolean bo, short sh, char ch, int in, long lo, float fl, double dl) {\n+    }\n+\n+    @Test\n+    public void testTypes() {\n+\n+        \/\/ Test wrappers Integer etc.\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_BYTE.withName(\"by\"),\n+                JAVA_BOOLEAN.withName(\"bo\"),\n+                JAVA_SHORT.withName(\"sh\"),\n+                JAVA_CHAR.withName(\"ch\"),\n+                JAVA_INT_UNALIGNED.withName(\"in\"),\n+                JAVA_LONG_UNALIGNED.withName(\"lo\"),\n+                JAVA_FLOAT_UNALIGNED.withName(\"fl\"),\n+                JAVA_DOUBLE_UNALIGNED.withName(\"dl\")\n+        );\n+\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(layout);\n+\n+            layout.varHandle(PathElement.groupElement(\"by\")).set(segment, (byte) 1);\n+            layout.varHandle(PathElement.groupElement(\"bo\")).set(segment, true);\n+            layout.varHandle(PathElement.groupElement(\"sh\")).set(segment, (short) 1);\n+            layout.varHandle(PathElement.groupElement(\"ch\")).set(segment, 'a');\n+            layout.varHandle(PathElement.groupElement(\"in\")).set(segment, 1);\n+            layout.varHandle(PathElement.groupElement(\"lo\")).set(segment, 1L);\n+            layout.varHandle(PathElement.groupElement(\"fl\")).set(segment, 1f);\n+            layout.varHandle(PathElement.groupElement(\"dl\")).set(segment, 1d);\n+\n+            var mapper = layout.recordMapper(Types.class);\n+            Types types = mapper.apply(segment);\n+            assertEquals(new Types(\n+                    (byte) 1,\n+                    true,\n+                    (short) 1,\n+                    'a',\n+                    1,\n+                    1L,\n+                    1.0f,\n+                    1.0d\n+            ), types);\n+        }\n+    }\n+\n+    \/\/ Float80, From https:\/\/github.com\/graalvm\/sulong\/blob\/db830610d6ffbdab9678eef359a9f915e6ad2ee8\/projects\/com.oracle.truffle.llvm.types\/src\/com\/oracle\/truffle\/llvm\/types\/floating\/LLVM80BitFloat.java\n+\n+    public record Float80(short exponent, long fraction){}\n+\n+    @Test\n+    public void testFloat80() {\n+\n+        short exponent = (short) 3;\n+        long fraction = 23423423L;\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_SHORT.withName(\"exponent\"),\n+                JAVA_LONG_UNALIGNED.withName(\"fraction\")\n+        );\n+\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(layout);\n+\n+            layout.varHandle(PathElement.groupElement(\"exponent\")).set(segment, exponent);\n+            layout.varHandle(PathElement.groupElement(\"fraction\")).set(segment, fraction);\n+\n+            var mapper = layout.recordMapper(Float80.class);\n+            Float80 float80 = mapper.apply(segment);\n+            assertEquals(new Float80(exponent, fraction), float80);\n+        }\n+    }\n+\n+    @Test\n+    public void testToString() {\n+        var toString = POINT_LAYOUT.recordMapper(Point.class).toString();\n+        assertTrue(toString.contains(\"type=\" + Point.class.getName()));\n+        assertTrue(toString.contains(\"layout=\" + POINT_LAYOUT));\n+    }\n+\n+    public record BytePoint(byte x, byte y) {}\n+    @Test\n+    public void testByte() {\n+        testPointType(new BytePoint((byte)3, (byte)4), new byte[]{3, 4}, JAVA_BYTE);\n+    }\n+\n+    public record BooleanPoint(boolean x, boolean y) {}\n+    @Test\n+    public void testBoolean() {\n+        testPointType(new BooleanPoint(false, true), new byte[]{0, 1}, JAVA_BOOLEAN);\n+    }\n+\n+    public record ShortPoint(short x, short y) {}\n+    @Test\n+    public void testShort() {\n+        testPointType(new ShortPoint((short)3, (short)4), new short[]{3, 4}, JAVA_SHORT);\n+    }\n+\n+    public record CharPoint(char x, char y) {}\n+    @Test\n+    public void testChar() {\n+        testPointType(new CharPoint('d', 'e'), new char[]{'d', 'e'}, JAVA_CHAR);\n+    }\n+\n+    public record IntPoint(int x, int y) {}\n+    @Test\n+    public void testInt() {\n+        testPointType(new IntPoint(3, 4), new int[]{3, 4}, JAVA_INT);\n+    }\n+\n+    @Test\n+    public void testLong() {\n+        testPointType(new LongPoint(3L, 4L), new long[]{3L, 4L}, JAVA_LONG);\n+    }\n+\n+    public record FloatPoint(float x, float y) {}\n+    @Test\n+    public void testFloat() {\n+        testPointType(new FloatPoint(3.0f, 4.0f), new float[]{3.0f, 4.0f}, JAVA_FLOAT);\n+    }\n+\n+    public record DoublePoint(double x, double y){}\n+    @Test\n+    public void testDouble() {\n+        testPointType(new DoublePoint(3.0d, 4.0d), new double[]{3.0d, 4.0d}, JAVA_DOUBLE);\n+    }\n+\n+\n+    public record SequenceBox(int before, int[] ints, int after) {\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof SequenceBox other &&\n+                    before == other.before &&\n+                    Arrays.equals(ints, other.ints) &&\n+                    after == other.after;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SequenceBox[before=\" + before +\n+                    \", ints=\" + Arrays.toString(ints) +\n+                    \", after=\" + after + \"]\";\n+        }\n+    }\n+\n+    @Test\n+    public void testSequenceBox() {\n+\n+        var segment = MemorySegment.ofArray(IntStream.rangeClosed(0, 3).toArray());\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"before\"),\n+                MemoryLayout.sequenceLayout(2, JAVA_INT).withName(\"ints\"),\n+                JAVA_INT.withName(\"after\")\n+        );\n+\n+        var mapper = layout.recordMapper(SequenceBox.class);\n+\n+        SequenceBox sequenceBox = mapper.apply(segment);\n+\n+        assertEquals(new SequenceBox(0, new int[]{1, 2}, 3), sequenceBox);\n+    }\n+\n+    public record SequenceBox2(int before, int[][] ints, int after) {\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof SequenceBox2 other &&\n+                    before == other.before &&\n+                    Arrays.deepEquals(ints, other.ints) &&\n+                    after == other.after;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SequenceBox2[before=\" + before +\n+                    \", ints=\" + Arrays.deepToString(ints) +\n+                    \", after=\" + after + \"]\";\n+        }\n+    }\n+\n+    @Test\n+    public void testSequenceBox2WrongDimension() {\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"before\"),\n+                MemoryLayout.sequenceLayout(2,\n+                                MemoryLayout.sequenceLayout(2, JAVA_INT).withName(\"whatever\"))\n+                        .withName(\"ints\"),\n+                JAVA_INT.withName(\"after\")\n+        );\n+\n+        assertThrows(IllegalArgumentException.class, () ->\n+                \/\/ SequenceBox.ints is of dimension 1 whereas the layout is of dimension 2\n+            layout.recordMapper(SequenceBox.class)\n+        );\n+    }\n+\n+    @Test\n+    public void testSequenceBox2() {\n+\n+        var segment = MemorySegment.ofArray(IntStream.rangeClosed(0, 7).toArray());\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"before\"),\n+                MemoryLayout.sequenceLayout(2,\n+                                MemoryLayout.sequenceLayout(3, JAVA_INT).withName(\"whatever\"))\n+                        .withName(\"ints\"),\n+                JAVA_INT.withName(\"after\")\n+        );\n+\n+        var mapper = layout.recordMapper(SequenceBox2.class);\n+\n+        SequenceBox2 sequenceBox2 = mapper.apply(segment);\n+\n+        assertEquals(new SequenceBox2(0, new int[][]{{1, 2, 3}, {4, 5, 6}}, 7), sequenceBox2);\n+    }\n+\n+    public record SequenceBox3(int before, int[][][] ints, int after) {\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof SequenceBox3 other &&\n+                    before == other.before &&\n+                    Arrays.deepEquals(ints, other.ints) &&\n+                    after == other.after;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SequenceBox3[before=\" + before +\n+                    \", ints=\" + Arrays.deepToString(ints) +\n+                    \", after=\" + after + \"]\";\n+        }\n+    }\n+\n+    @Test\n+    public void testSequenceBox3() {\n+\n+        var segment = MemorySegment.ofArray(IntStream.rangeClosed(0, 2 + (2 * 3 * 4)).toArray());\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"before\"),\n+                MemoryLayout.sequenceLayout(2,\n+                                MemoryLayout.sequenceLayout(3,\n+                                        MemoryLayout.sequenceLayout(4, JAVA_INT).withName(\"whatever2\")\n+                                ).withName(\"whatever\")\n+                        )\n+                        .withName(\"ints\"),\n+                JAVA_INT.withName(\"after\")\n+        );\n+\n+        var mapper = layout.recordMapper(SequenceBox3.class);\n+\n+        SequenceBox3 sequenceBox3 = mapper.apply(segment);\n+\n+        assertEquals(new SequenceBox3(0, new int[][][]{\n+                {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}},\n+                {{13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24}}\n+        }, 25), sequenceBox3);\n+    }\n+\n+    public record LongSequenceBox3(long before, long[][][] longs, long after) {\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof LongSequenceBox3 other &&\n+                    before == other.before &&\n+                    Arrays.deepEquals(longs, other.longs) &&\n+                    after == other.after;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"LongSequenceBox3[before=\" + before +\n+                    \", longs=\" + Arrays.deepToString(longs) +\n+                    \", after=\" + after+ \"]\";\n+        }\n+    }\n+\n+    @Test\n+    public void testLongSequenceBox3() {\n+\n+        var segment = MemorySegment.ofArray(LongStream.rangeClosed(0, 2 + (2 * 3 * 4)).toArray());\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_LONG.withName(\"before\"),\n+                MemoryLayout.sequenceLayout(2,\n+                                MemoryLayout.sequenceLayout(3,\n+                                        MemoryLayout.sequenceLayout(4, JAVA_LONG).withName(\"whatever2\")\n+                                ).withName(\"whatever\")\n+                        )\n+                        .withName(\"longs\"),\n+                JAVA_LONG.withName(\"after\")\n+        );\n+\n+        var mapper = layout.recordMapper(LongSequenceBox3.class);\n+\n+        LongSequenceBox3 sequenceBox3 = mapper.apply(segment);\n+\n+        assertEquals(new LongSequenceBox3(0, new long[][][]{\n+                {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}},\n+                {{13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24}}\n+        }, 25), sequenceBox3);\n+    }\n+\n+    public record PureArray(int[] ints) {\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof PureArray other &&\n+                    Arrays.equals(ints, other.ints);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"PureArray[ints=\" + Arrays.toString(ints) + \"]\";\n+        }\n+    }\n+\n+    @Test\n+    public void testPureArray() {\n+        GroupLayout layout =\n+                MemoryLayout.structLayout(\n+                        MemoryLayout.sequenceLayout(8, JAVA_INT)\n+                                .withName(\"ints\"));\n+\n+        var segment = MemorySegment.ofArray(IntStream.range(0, 8).toArray());\n+\n+        var mapper = layout.recordMapper(PureArray.class);\n+\n+        PureArray pureArray = mapper.apply(segment);\n+\n+        assertEquals(new PureArray(new int[]{0, 1, 2, 3, 4, 5, 6, 7}), pureArray);\n+    }\n+\n+    public record SequenceOfPoints(int before, Point[] points, int after) {\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof SequenceOfPoints other &&\n+                    before == other.before &&\n+                    Arrays.equals(points, other.points) &&\n+                    after == other.after;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SequenceOfPoints[before=\" + before +\n+                    \", points=\" + Arrays.toString(points) +\n+                    \", after=\" + after + \"]\";\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSequenceOfPoints() {\n+\n+        var segment = MemorySegment.ofArray(IntStream.rangeClosed(0, 5).toArray());\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"before\"),\n+                MemoryLayout.sequenceLayout(2, POINT_LAYOUT).withName(\"points\"),\n+                JAVA_INT.withName(\"after\")\n+        );\n+\n+        var mapper = layout.recordMapper(SequenceOfPoints.class);\n+\n+        SequenceOfPoints sequenceOfPoints = mapper.apply(segment);\n+\n+        assertEquals(new SequenceOfPoints(0, new Point[]{new Point(1, 2), new Point(3,4)}, 5), sequenceOfPoints);\n+\n+    }\n+\n+    public record MultiSequenceOfPoints(int before, Point[][] points, int after) {\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof MultiSequenceOfPoints other &&\n+                    before == other.before &&\n+                    Arrays.deepEquals(points, other.points) &&\n+                    after == other.after;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"MultiSequenceOfPoints[before=\" + before +\n+                    \", points=\" + Arrays.deepToString(points) +\n+                    \", after=\" + after + \"]\";\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testMultiSequenceOfPoints() {\n+\n+        var segment = MemorySegment.ofArray(IntStream.rangeClosed(0, 13).toArray());\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"before\"),\n+                MemoryLayout.sequenceLayout(2,\n+                                MemoryLayout.sequenceLayout(3, POINT_LAYOUT))\n+                        .withName(\"points\"),\n+                JAVA_INT.withName(\"after\")\n+        );\n+\n+        var mapper = layout.recordMapper(MultiSequenceOfPoints.class);\n+\n+        MultiSequenceOfPoints actual = mapper.apply(segment);\n+\n+        var expected = new MultiSequenceOfPoints(0,\n+                new Point[][]{\n+                        {new Point(1, 2), new Point(3, 4), new Point(5, 6)},\n+                        {new Point(7, 8), new Point(9, 10), new Point(11, 12)}},\n+                13);\n+\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void streaming() {\n+        var segment = MemorySegment.ofArray(new int[]{-1, 2, 3, 4, 5, -2});\n+        var s2 = segment.asSlice(4, 16);\n+        var mapper = POINT_LAYOUT.recordMapper(Point.class);\n+\n+        var list = s2.elements(POINT_LAYOUT)\n+                .map(mapper)\n+                .toList();\n+\n+        assertEquals(List.of(new Point(2, 3), new Point(4, 5)), list);\n+    }\n+\n+    @Test\n+    public void testPointSequence() {\n+\n+        var segment = MemorySegment.ofArray(new int[]{-1, 2, 3, 4, 5, -2});\n+\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"before\"),\n+                MemoryLayout.sequenceLayout(2, POINT_LAYOUT).withName(\"points\"),\n+                JAVA_INT.withName(\"after\")\n+        );\n+\n+        var mapper = layout.recordMapper(SequenceOfPoints.class);\n+\n+        SequenceOfPoints sequenceOfPoints = mapper.apply(segment);\n+\n+        assertEquals(new SequenceOfPoints(-1, new Point[]{new Point(2, 3), new Point(4, 5)}, -2), sequenceOfPoints);\n+    }\n+\n+    private record Foo(int x){}\n+    @Test\n+    public void testConstructorAccessibility() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+                POINT_LAYOUT.recordMapper(Foo.class)\n+        );\n+    }\n+\n+    @Test\n+    public void testMhComposition() throws Throwable {\n+        var lookup = MethodHandles.lookup();\n+        var ctor = lookup.findConstructor(Point.class, MethodType.methodType(void.class, int.class, int.class));\n+\n+        var extractorType = MethodType.methodType(int.class, ValueLayout.OfInt.class, long.class);\n+\n+        var xVh = lookup.findVirtual(MemorySegment.class, \"get\", extractorType);\n+        \/\/ (MemorySegment, OfInt, long) -> (MemorySegment, long)\n+        var xVh2 = MethodHandles.insertArguments(xVh, 1, JAVA_INT);\n+        \/\/ (MemorySegment, long) -> (MemorySegment)\n+        var xVh3 = MethodHandles.insertArguments(xVh2, 1, 0L);\n+\n+        var yVh = lookup.findVirtual(MemorySegment.class, \"get\", extractorType);\n+        \/\/ (MemorySegment, OfInt, long) -> (MemorySegment, long)\n+        var yVh2 = MethodHandles.insertArguments(yVh, 1, JAVA_INT);\n+        \/\/ (MemorySegment, long) -> (MemorySegment)\n+        var yVh3 = MethodHandles.insertArguments(yVh2, 1, 4L);\n+\n+        assertEquals(3, (int) xVh3.invokeExact(POINT_SEGMENT));\n+        assertEquals(4, (int) yVh3.invokeExact(POINT_SEGMENT));\n+\n+        var expected = new Point(3, 4);\n+\n+        var p = ctor.invokeWithArguments((int) xVh3.invokeExact(POINT_SEGMENT), (int) yVh3.invokeExact(POINT_SEGMENT));\n+        assertEquals(expected, p);\n+\n+        var ctorFilter = MethodHandles.filterArguments(ctor, 0, xVh3);\n+        var ctorFilter2 = MethodHandles.filterArguments(ctorFilter, 1, yVh3);\n+\n+        var pf = (Point) ctorFilter2.invokeExact(POINT_SEGMENT, POINT_SEGMENT);\n+        assertEquals(expected, pf);\n+\n+        var mt = MethodType.methodType(Point.class, MemorySegment.class);\n+        var mh = MethodHandles.permuteArguments(ctorFilter2, mt, 0, 0);\n+\n+        \/\/ Finally, we have a MethodHandle MemorySegment -> Point\n+        Point point = (Point) mh.invokeExact(POINT_SEGMENT);\n+        assertEquals(expected, point);\n+    }\n+\n+\n+    public record BoxedPoint(Integer x, Integer y) {}\n+\n+    @Test\n+    public void testIntegerBoxing() {\n+        if (EXACT) return;\n+        var mapper = POINT_LAYOUT.recordMapper(BoxedPoint.class);\n+        var boxedPoint = mapper.apply(POINT_SEGMENT);\n+        assertEquals(new BoxedPoint(3, 4), boxedPoint);\n+    }\n+\n+    public record WidenedPoint(long x, long y) {}\n+\n+    @Test\n+    public void testWidening() {\n+        if (EXACT) return;\n+        var mapper = POINT_LAYOUT.recordMapper(WidenedPoint.class);\n+        var widenedPoint = mapper.apply(POINT_SEGMENT);\n+        assertEquals(new WidenedPoint(3, 4L), widenedPoint);\n+    }\n+\n+    public record NarrowedPoint(byte x, byte y) {}\n+\n+    @Test\n+    public void testNarrowingExplicit() {\n+\n+        Function<MemorySegment, NarrowedPoint> narrowingMapper =\n+                POINT_LAYOUT.recordMapper(Point.class)\n+                        .andThen(p -> new NarrowedPoint((byte) p.x, (byte) p.y));\n+\n+        NarrowedPoint narrowedPoint = narrowingMapper.apply(POINT_SEGMENT);\n+        assertEquals(new NarrowedPoint((byte) 3, (byte) 4), narrowedPoint);\n+    }\n+\n+    @Test\n+    public void testNarrowing() {\n+        if (EXACT) return;\n+        var mapper = POINT_LAYOUT.recordMapper(NarrowedPoint.class);\n+        var narrowedPoint = mapper.apply(POINT_SEGMENT);\n+        assertEquals(new NarrowedPoint((byte) 3, (byte) 4), narrowedPoint);\n+    }\n+\n+    @Test\n+    public void inspectPoint() {\n+        String view = POINT_LAYOUT\n+                .recordMapper(Point.class)\n+                .apply(POINT_SEGMENT)\n+                .toString();\n+\n+        assertEquals(\"Point[x=3, y=4]\", view);\n+    }\n+\n+    @Test\n+    public void inspectMemory() {\n+        try (var arena = Arena.ofConfined()) {\n+            MemorySegment memorySegment = arena.allocate(64 + 4);\n+            memorySegment.setUtf8String(0, \"The quick brown fox jumped over the lazy dog\\nSecond line\\t:here\");\n+            HexFormat format = HexFormat.ofDelimiter(\" \").withUpperCase();\n+            String hex = format.formatHex(memorySegment.toArray(JAVA_BYTE));\n+\n+            String expected = \"54 68 65 20 71 75 69 63 6B 20 62 72 6F 77 6E 20 66 6F 78 20 6A 75 6D 70 65 64 20 6F 76 65 72 20 74 68 65 20 6C 61 7A 79 20 64 6F 67 0A 53 65 63 6F 6E 64 20 6C 69 6E 65 09 3A 68 65 72 65 00 00 00 00 00 00\";\n+            assertEquals(expected, hex);\n+        }\n+    }\n+\n+    @Test\n+    public void recordClassItself() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+                POINT_LAYOUT.recordMapper(Record.class)\n+        );\n+    }\n+\n+    public record LinkedNode(MemorySegment next, int value){\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof LinkedNode(var next, var value) &&\n+                    this.next == next &&\n+                    this.value == value;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(next, value);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void linkedNode() {\n+\n+        var rawLayout = MemoryLayout.structLayout(ADDRESS, JAVA_INT);\n+\n+        var layout = MemoryLayout.structLayout(\n+                ADDRESS.withName(\"next\").withTargetLayout(rawLayout),\n+                JAVA_INT.withName(\"value\")\n+        );\n+\n+        VarHandle next = layout.varHandle(PathElement.groupElement(\"next\"));\n+        VarHandle value = layout.varHandle(PathElement.groupElement(\"value\"));\n+\n+        MemorySegment first;\n+        MemorySegment second;\n+        try (var arena = Arena.ofConfined()) {\n+            first = arena.allocate(layout);\n+            value.set(first, 41);\n+            second = arena.allocate(layout);\n+            value.set(second, 42);\n+            next.set(first, second);\n+\n+            var mapper = layout.recordMapper(LinkedNode.class);\n+\n+            LinkedNode actualFirst = mapper.apply(first);\n+            assertEquals(41, actualFirst.value());\n+            assertEquals(second, actualFirst.next());\n+\n+            LinkedNode actualSecond = mapper.apply(actualFirst.next());\n+            assertEquals(42, actualSecond.value());\n+            assertEquals(MemorySegment.NULL, actualSecond.next());\n+        }\n+\n+    }\n+\n+    public record TreeNode(MemorySegment[] children, int value){\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof TreeNode(var children, var value) &&\n+                    Arrays.equals(this.children, children) &&\n+                    this.value == value;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Arrays.hashCode(children) + value;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"TreeNode[children=\" + Arrays.toString(children) + \", value=\" + value + \"]\";\n+        }\n+    }\n+\n+    @Test\n+    public void TreeNode() {\n+\n+        var rawLayout = MemoryLayout.structLayout(\n+                MemoryLayout.sequenceLayout(3, ADDRESS),\n+                JAVA_INT\n+        );\n+\n+        var layout = MemoryLayout.structLayout(\n+                MemoryLayout.sequenceLayout(\n+                        3,\n+                        ADDRESS.withTargetLayout(rawLayout)\n+                ).withName(\"children\"),\n+                JAVA_INT.withName(\"value\")\n+        );\n+\n+        VarHandle child = layout.varHandle(PathElement.groupElement(\"children\"), PathElement.sequenceElement());\n+        VarHandle value = layout.varHandle(PathElement.groupElement(\"value\"));\n+\n+        MemorySegment root;\n+        MemorySegment firstChild;\n+        MemorySegment secondChild;\n+        try (var arena = Arena.ofConfined()) {\n+            root = arena.allocate(layout);\n+            value.set(root, 100);\n+            firstChild = arena.allocate(layout);\n+            value.set(firstChild, 41);\n+            secondChild = arena.allocate(layout);\n+            value.set(secondChild, 42);\n+            child.set(root, 0, firstChild);\n+            child.set(root, 1, secondChild);\n+\n+            var mapper = layout.recordMapper(TreeNode.class);\n+\n+            TreeNode actualRoot = mapper.apply(root);\n+            assertEquals(100, actualRoot.value());\n+\n+            TreeNode actualFirstChild = mapper.apply(actualRoot.children()[0]);\n+            TreeNode actualSecondChild = mapper.apply(actualRoot.children()[1]);\n+\n+            assertEquals(firstChild, actualRoot.children()[0]);\n+            assertEquals(secondChild, actualRoot.children()[1]);\n+            assertEquals(MemorySegment.NULL, actualRoot.children()[2]);\n+\n+            assertEquals(41, actualFirstChild.value());\n+            for (int i = 0; i < 3; i++) {\n+                assertEquals(MemorySegment.NULL, actualFirstChild.children()[i]);\n+            }\n+            assertEquals(42, actualSecondChild.value());\n+            for (int i = 0; i < 3; i++) {\n+                assertEquals(MemorySegment.NULL, actualSecondChild.children()[i]);\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void paddingLayout() {\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"x\"),\n+                MemoryLayout.paddingLayout(Integer.SIZE).withName(\"y\")\n+        );\n+\n+        assertThrows(IllegalArgumentException.class, () ->\n+                layout.recordMapper(Point.class)\n+        );\n+\n+    }\n+\n+    public record SingleValue(int x) {}\n+\n+    @Test\n+    public void nonDistinctUnusedNames() {\n+        \/\/ Tests that a name must not be unique in the MemoryLayout if it is unused\n+        \/\/ by any record component\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"z\"), \/\/ Not used\n+                JAVA_INT.withName(\"z\"), \/\/ Not used\n+                JAVA_INT.withName(\"x\"), \/\/ Used\n+                JAVA_INT.withName(\"y\")  \/\/ Used\n+        );\n+\n+        var mapper = layout.recordMapper(Point.class);\n+\n+        Point point = mapper.apply(POINT_SEGMENT);\n+        assertEquals(new Point(6, 0), point);\n+    }\n+\n+    @Test\n+    public void nonDistinctUsedNames() {\n+        \/\/ Tests that a name must be unique in the MemoryLayout if it is used\n+        \/\/ by a record component\n+        var layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"x\"), \/\/ Used\n+                JAVA_INT.withName(\"x\")  \/\/ Used\n+        );\n+\n+        assertThrows(IllegalArgumentException.class, () ->\n+                layout.recordMapper(SingleValue.class)\n+        );\n+    }\n+\n+    public record Recurse(Recurse recurse){}\n+    @Test\n+    public void recursiveDefinition() {\n+        var layout = MemoryLayout.structLayout(\n+                MemoryLayout.structLayout(\n+                        MemoryLayout.structLayout(\n+                                MemoryLayout.structLayout(JAVA_INT)\n+                        ).withName(\"recurse\")\n+                ).withName(\"recurse\")\n+        );\n+\n+        try {\n+            layout.recordMapper(Recurse.class);\n+            fail(\"No IllegalArgumentException detected\");\n+        } catch (IllegalArgumentException e) {\n+            assertTrue(e.getMessage().contains(\"same type\"));\n+        }\n+    }\n+\n+    static public <R extends Record> void testPointType(R expected,\n+                                                 Object array,\n+                                                 ValueLayout valueLayout) {\n+        testType(expected, array, valueLayout, \"x\", \"y\");\n+    }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        static public <R extends Record> void testType(R expected,\n+                                                       Object array,\n+                                                       ValueLayout valueLayout,\n+                                                       String... names) {\n+\n+        MemorySegment segment = switch (array) {\n+            case byte[] a -> MemorySegment.ofArray(a);\n+            case short[] a -> MemorySegment.ofArray(a);\n+            case char[] a -> MemorySegment.ofArray(a);\n+            case int[] a -> MemorySegment.ofArray(a);\n+            case long[] a -> MemorySegment.ofArray(a);\n+            case float[] a -> MemorySegment.ofArray(a);\n+            case double[] a -> MemorySegment.ofArray(a);\n+            default -> throw new IllegalArgumentException(\"Unknown array type: \" + array);\n+        };\n+\n+        StructLayout layout = MemoryLayout.structLayout(Arrays.stream(names)\n+                .map(valueLayout::withName)\n+                .toArray(MemoryLayout[]::new));\n+\n+        Class<R> type = (Class<R>) expected.getClass();\n+        GroupLayout.TypeMapper<R> mapper = layout.recordMapper(type);\n+        R actual = mapper.apply(segment);\n+        assertEquals(expected, actual);\n+    }\n+\n+\n+    public <T> void test(MemorySegment segment,\n+                         GroupLayout.TypeMapper<T> mapper,\n+                         T expected) {\n+\n+        T actual = mapper.apply(segment);\n+        assertEquals(expected, actual);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestRecordMapper.java","additions":1020,"deletions":0,"binary":false,"changes":1020,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n+public class LayoutRecordMapper {\n+\n+    private static final GroupLayout POINT_LAYOUT =\n+            MemoryLayout.structLayout(\n+                    JAVA_INT.withName(\"x\"),\n+                    JAVA_INT.withName(\"y\"));\n+\n+    private static final int ARRAY_SIZE = 8;\n+\n+    private static final GroupLayout ARRAY_LAYOUT =\n+            MemoryLayout.structLayout(\n+                    MemoryLayout.sequenceLayout(ARRAY_SIZE, JAVA_INT)\n+                            .withName(\"ints\"));\n+\n+    public record Point(int x, int y){}\n+\n+    public record Array(int[] ints) {}\n+\n+    private static final Function<MemorySegment, Point> POINT_MAPPER = POINT_LAYOUT.recordMapper(Point.class);\n+    private static final Function<MemorySegment, Point> POINT_EXPLICIT_MAPPER = ms ->\n+            new Point(ms.get(JAVA_INT, 0L), ms.get(JAVA_INT, 4));\n+    private static final MethodHandle POINT_MH = methodHandle();\n+\n+    private static final Function<MemorySegment, Array> ARRAY_MAPPER = ARRAY_LAYOUT.recordMapper(Array.class);\n+    private static final Function<MemorySegment, Array> ARRAY_EXPLICIT_MAPPER = ms -> new Array(ms.toArray(JAVA_INT));\n+\n+    Arena arena;\n+    MemorySegment pointSegment;\n+    MemorySegment arraySegment;\n+\n+    @Setup\n+    public void setup() {\n+        arena = Arena.ofConfined();\n+        pointSegment = arena.allocate(POINT_LAYOUT);\n+        pointSegment.set(JAVA_INT, 0, 3);\n+        pointSegment.set(JAVA_INT, 4, 4);\n+\n+        \/\/ Use native memory\n+        arraySegment = arena.allocate(ARRAY_LAYOUT);\n+        for (int i = 0; i < ARRAY_SIZE; i++) {\n+            arraySegment.setAtIndex(JAVA_INT, i, i);\n+        }\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    public void pointMapper(Blackhole bh) {\n+        bh.consume(POINT_MAPPER.apply(pointSegment));\n+    }\n+\n+    @Benchmark\n+    public void pointExplicitMapper(Blackhole bh) {\n+        bh.consume(POINT_EXPLICIT_MAPPER.apply(pointSegment));\n+    }\n+\n+    @Benchmark\n+    public void pointMhMapper(Blackhole bh) {\n+        try {\n+            bh.consume((Point) POINT_MH.invokeExact(pointSegment));\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void arrayMapper(Blackhole bh) {\n+        bh.consume(ARRAY_MAPPER.apply(arraySegment));\n+    }\n+\n+    @Benchmark\n+    public void arrayExplicitMapper(Blackhole bh) {\n+        bh.consume(ARRAY_EXPLICIT_MAPPER.apply(arraySegment));\n+    }\n+\n+    static MethodHandle methodHandle() {\n+        try {\n+            var lookup = MethodHandles.lookup();\n+            var ctor = lookup.findConstructor(Point.class, MethodType.methodType(void.class, int.class, int.class));\n+\n+            var extractorType = MethodType.methodType(int.class, ValueLayout.OfInt.class, long.class);\n+\n+            var xVh = lookup.findVirtual(MemorySegment.class, \"get\", extractorType);\n+            \/\/ (MemorySegment, OfInt, long) -> (MemorySegment, long)\n+            var xVh2 = MethodHandles.insertArguments(xVh, 1, JAVA_INT);\n+            \/\/ (MemorySegment, long) -> (MemorySegment)\n+            var xVh3 = MethodHandles.insertArguments(xVh2, 1, 0L);\n+\n+            var yVh = lookup.findVirtual(MemorySegment.class, \"get\", extractorType);\n+            \/\/ (MemorySegment, OfInt, long) -> (MemorySegment, long)\n+            var yVh2 = MethodHandles.insertArguments(yVh, 1, JAVA_INT);\n+            \/\/ (MemorySegment, long) -> (MemorySegment)\n+            var yVh3 = MethodHandles.insertArguments(yVh2, 1, 4L);\n+\n+            var ctorFilter = MethodHandles.filterArguments(ctor, 0, xVh3);\n+            var ctorFilter2 = MethodHandles.filterArguments(ctorFilter, 1, yVh3);\n+\n+            var mt = MethodType.methodType(Point.class, MemorySegment.class);\n+\n+            return MethodHandles.permuteArguments(ctorFilter2, mt, 0, 0);\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LayoutRecordMapper.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"}]}