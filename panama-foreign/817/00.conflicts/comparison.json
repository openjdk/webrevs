{"files":[{"patch":"@@ -27,1 +27,0 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -29,0 +28,2 @@\n+import jdk.internal.foreign.abi.BindingInterpreter.LoadFunc;\n+import jdk.internal.foreign.abi.BindingInterpreter.StoreFunc;\n@@ -30,5 +31,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.*;\n@@ -202,93 +199,0 @@\n-    \/**\n-     * A binding context is used as an helper to carry out evaluation of certain bindings; for instance,\n-     * it helps {@link Allocate} bindings, by providing the {@link SegmentAllocator} that should be used for\n-     * the allocation operation, or {@link BoxAddress} bindings, by providing the {@link SegmentScope} that\n-     * should be used to create an unsafe struct from a memory address.\n-     *\/\n-    class Context implements AutoCloseable {\n-        private final SegmentAllocator allocator;\n-        private final SegmentScope scope;\n-\n-        private Context(SegmentAllocator allocator, SegmentScope scope) {\n-            this.allocator = allocator;\n-            this.scope = scope;\n-        }\n-\n-        public SegmentAllocator allocator() {\n-            return allocator;\n-        }\n-\n-        public SegmentScope scope() {\n-            return scope;\n-        }\n-\n-        @Override\n-        public void close() {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        \/**\n-         * Create a binding context from given native scope.\n-         *\/\n-        public static Context ofBoundedAllocator(long size) {\n-            Arena arena = Arena.openConfined();\n-            return new Context(SegmentAllocator.slicingAllocator(MemorySegment.allocateNative(size, arena.scope())), arena.scope()) {\n-                @Override\n-                public void close() {\n-                    arena.close();\n-                }\n-            };\n-        }\n-\n-        \/**\n-         * Create a binding context from given segment allocator. The resulting context will throw when\n-         * the context's scope is accessed.\n-         *\/\n-        public static Context ofAllocator(SegmentAllocator allocator) {\n-            return new Context(allocator, null) {\n-                @Override\n-                public SegmentScope scope() {\n-                    throw new UnsupportedOperationException();\n-                }\n-            };\n-        }\n-\n-        \/**\n-         * Create a binding context from given scope. The resulting context will throw when\n-         * the context's allocator is accessed.\n-         *\/\n-        public static Context ofScope() {\n-            Arena arena = Arena.openConfined();\n-            return new Context(null, arena.scope()) {\n-                @Override\n-                public SegmentAllocator allocator() { throw new UnsupportedOperationException(); }\n-\n-                @Override\n-                public void close() {\n-                    arena.close();\n-                }\n-            };\n-        }\n-\n-        \/**\n-         * Dummy binding context. Throws exceptions when attempting to access scope, return a throwing allocator, and has\n-         * an idempotent {@link #close()}.\n-         *\/\n-        public static final Context DUMMY = new Context(null, null) {\n-            @Override\n-            public SegmentAllocator allocator() {\n-                return SharedUtils.THROWING_ALLOCATOR;\n-            }\n-\n-            @Override\n-            public SegmentScope scope() {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            @Override\n-            public void close() {\n-                \/\/ do nothing\n-            }\n-        };\n-    }\n-\n@@ -312,2 +216,2 @@\n-    void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                   BindingInterpreter.LoadFunc loadFunc, Context context);\n+    void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                   LoadFunc loadFunc, SegmentAllocator allocator);\n@@ -370,2 +274,2 @@\n-    static BoxAddress boxAddressRaw(long size) {\n-        return new BoxAddress(size, false);\n+    static BoxAddress boxAddressRaw(long size, long align) {\n+        return new BoxAddress(size, align, false);\n@@ -375,1 +279,1 @@\n-        return new BoxAddress(layout.byteSize(), true);\n+        return new BoxAddress(layout.byteSize(), layout.byteAlignment(), true);\n@@ -379,1 +283,1 @@\n-        return new BoxAddress(byteSize, true);\n+        return new BoxAddress(byteSize, 1, true);\n@@ -481,2 +385,2 @@\n-        public Binding.Builder boxAddressRaw(long size) {\n-            bindings.add(Binding.boxAddressRaw(size));\n+        public Binding.Builder boxAddressRaw(long size, long align) {\n+            bindings.add(Binding.boxAddressRaw(size, align));\n@@ -530,2 +434,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -553,2 +457,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -585,2 +489,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -646,0 +550,1 @@\n+<<<<<<< HEAD\n@@ -648,0 +553,4 @@\n+=======\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n@@ -691,2 +600,2 @@\n-        private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment, Context context) {\n-            return context.allocator().allocate(size, alignment)\n+        private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment, SegmentAllocator allocator) {\n+            return allocator.allocate(size, alignment)\n@@ -709,2 +618,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -712,1 +621,1 @@\n-            MemorySegment copy = copyBuffer(operand, size, alignment, context);\n+            MemorySegment copy = copyBuffer(operand, size, alignment, allocator);\n@@ -722,2 +631,2 @@\n-        private static MemorySegment allocateBuffer(long size, long alignment, Context context) {\n-            return context.allocator().allocate(size, alignment);\n+        private static MemorySegment allocateBuffer(long size, long alignment, SegmentAllocator allocator) {\n+            return allocator.allocate(size, alignment);\n@@ -737,3 +646,3 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n-            stack.push(allocateBuffer(size, alignment, context));\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n+            stack.push(allocateBuffer(size, alignment, allocator));\n@@ -764,3 +673,3 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n-            stack.push(((MemorySegment)stack.pop()).address());\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n+            stack.push(SharedUtils.unboxSegment((MemorySegment)stack.pop()));\n@@ -775,1 +684,1 @@\n-    record BoxAddress(long size, boolean needsScope) implements Binding {\n+    record BoxAddress(long size, long align, boolean needsScope) implements Binding {\n@@ -790,5 +699,7 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n-            SegmentScope scope = needsScope ?\n-                    context.scope() : SegmentScope.global();\n-            stack.push(NativeMemorySegmentImpl.makeNativeSegmentUnchecked((long) stack.pop(), size, scope));\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n+            MemorySegment segment = Utils.longToAddress((long) stack.pop(), size, align);\n+            if (needsScope) {\n+                segment = segment.reinterpret((Arena) allocator, null);\n+            }\n+            stack.push(segment);\n@@ -817,2 +728,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -832,2 +743,2 @@\n-            public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                                  BindingInterpreter.LoadFunc loadFunc, Context context) {\n+            public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                                  LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -877,2 +788,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":49,"deletions":138,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker.UpcallStubFactory;\n@@ -34,0 +35,1 @@\n+import jdk.internal.foreign.abi.fallback.FallbackLinker;\n@@ -39,0 +41,2 @@\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.Arena;\n@@ -44,1 +48,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.MemorySegment.Scope;\n@@ -46,1 +50,0 @@\n-import java.lang.foreign.VaList;\n@@ -57,1 +60,0 @@\n-import java.util.NoSuchElementException;\n@@ -59,1 +61,0 @@\n-import java.util.function.Consumer;\n@@ -78,0 +79,22 @@\n+    public static final MethodHandle MH_CHECK_SYMBOL;\n+\n+    public static final AddressLayout C_POINTER = ADDRESS\n+            .withBitAlignment(64)\n+            .withTargetLayout(MemoryLayout.sequenceLayout(JAVA_BYTE));\n+\n+    public static final Arena DUMMY_ARENA = new Arena() {\n+        @Override\n+        public Scope scope() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void close() {\n+            \/\/ do nothing\n+        }\n+    };\n@@ -88,0 +111,2 @@\n+            MH_CHECK_SYMBOL = lookup.findStatic(SharedUtils.class, \"checkSymbol\",\n+                    methodType(void.class, MemorySegment.class));\n@@ -140,1 +165,1 @@\n-    public static MethodHandle adaptUpcallForIMR(MethodHandle target, boolean dropReturn) {\n+    private static MethodHandle adaptUpcallForIMR(MethodHandle target, boolean dropReturn) {\n@@ -157,0 +182,21 @@\n+    public static UpcallStubFactory arrangeUpcallHelper(MethodType targetType, boolean isInMemoryReturn, boolean dropReturn,\n+                                                        ABIDescriptor abi, CallingSequence callingSequence) {\n+        if (isInMemoryReturn) {\n+            \/\/ simulate the adaptation to get the type\n+            MethodHandle fakeTarget = MethodHandles.empty(targetType);\n+            targetType = adaptUpcallForIMR(fakeTarget, dropReturn).type();\n+        }\n+\n+        UpcallStubFactory factory = UpcallLinker.makeFactory(targetType, abi, callingSequence);\n+\n+        if (isInMemoryReturn) {\n+            final UpcallStubFactory finalFactory = factory;\n+            factory = (target, scope) -> {\n+                target = adaptUpcallForIMR(target, dropReturn);\n+                return finalFactory.makeStub(target, scope);\n+            };\n+        }\n+\n+        return factory;\n+    }\n+\n@@ -195,0 +241,2 @@\n+            case FALLBACK -> FallbackLinker.getInstance();\n+            case UNSUPPORTED -> throw new UnsupportedOperationException(\"Platform does not support native linker\");\n@@ -246,1 +294,1 @@\n-    static MethodHandle swapArguments(MethodHandle mh, int firstArg, int secondArg) {\n+    public static MethodHandle swapArguments(MethodHandle mh, int firstArg, int secondArg) {\n@@ -264,1 +312,1 @@\n-    static void handleUncaughtException(Throwable t) {\n+    public static void handleUncaughtException(Throwable t, Thread.UncaughtExceptionHandler handler) {\n@@ -266,2 +314,10 @@\n-            t.printStackTrace();\n-            JLA.exit(1);\n+            try {\n+                Thread currentThread = Thread.currentThread();\n+                if (handler == null) {\n+                     handler = currentThread.getUncaughtExceptionHandler();\n+                }\n+                handler.uncaughtException(currentThread, t);\n+            } finally {\n+                System.err.println(\"Unrecoverable uncaught exception encountered. The VM will now exit\");\n+                JLA.exit(1);\n+            }\n@@ -300,33 +356,0 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n-        return switch (CABI.current()) {\n-            case WIN_64 -> Windowsx64Linker.newVaList(actions, scope);\n-            case SYS_V -> SysVx64Linker.newVaList(actions, scope);\n-            case LINUX_AARCH_64 -> LinuxAArch64Linker.newVaList(actions, scope);\n-            case MAC_OS_AARCH_64 -> MacOsAArch64Linker.newVaList(actions, scope);\n-            case LINUX_RISCV_64 -> LinuxRISCV64Linker.newVaList(actions, scope);\n-            case WIN_AARCH_64 -> WindowsAArch64Linker.newVaList(actions, scope);\n-        };\n-    }\n-\n-    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n-        return switch (CABI.current()) {\n-            case WIN_64 -> Windowsx64Linker.newVaListOfAddress(address, scope);\n-            case SYS_V -> SysVx64Linker.newVaListOfAddress(address, scope);\n-            case LINUX_AARCH_64 -> LinuxAArch64Linker.newVaListOfAddress(address, scope);\n-            case MAC_OS_AARCH_64 -> MacOsAArch64Linker.newVaListOfAddress(address, scope);\n-            case LINUX_RISCV_64 -> LinuxRISCV64Linker.newVaListOfAddress(address, scope);\n-            case WIN_AARCH_64 -> WindowsAArch64Linker.newVaListOfAddress(address, scope);\n-        };\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return switch (CABI.current()) {\n-            case WIN_64 -> Windowsx64Linker.emptyVaList();\n-            case SYS_V -> SysVx64Linker.emptyVaList();\n-            case LINUX_AARCH_64 -> LinuxAArch64Linker.emptyVaList();\n-            case MAC_OS_AARCH_64 -> MacOsAArch64Linker.emptyVaList();\n-            case LINUX_RISCV_64 -> LinuxRISCV64Linker.emptyVaList();\n-            case WIN_AARCH_64 -> WindowsAArch64Linker.emptyVaList();\n-        };\n-    }\n-\n@@ -350,0 +373,1 @@\n+<<<<<<< HEAD\n@@ -352,0 +376,43 @@\n+=======\n+    public static Arena newBoundedArena(long size) {\n+        return new Arena() {\n+            final Arena arena = Arena.ofConfined();\n+            final SegmentAllocator slicingAllocator = SegmentAllocator.slicingAllocator(arena.allocate(size));\n+\n+            @Override\n+            public Scope scope() {\n+                return arena.scope();\n+            }\n+\n+            @Override\n+            public void close() {\n+                arena.close();\n+            }\n+\n+            @Override\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                return slicingAllocator.allocate(byteSize, byteAlignment);\n+            }\n+        };\n+    }\n+\n+    public static Arena newEmptyArena() {\n+        return new Arena() {\n+            final Arena arena = Arena.ofConfined();\n+\n+            @Override\n+            public Scope scope() {\n+                return arena.scope();\n+            }\n+\n+            @Override\n+            public void close() {\n+                arena.close();\n+            }\n+\n+            @Override\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n@@ -368,53 +435,0 @@\n-    public static final class EmptyVaList implements VaList {\n-\n-        private final MemorySegment address;\n-\n-        public EmptyVaList(MemorySegment address) {\n-            this.address = address;\n-        }\n-\n-        private static UnsupportedOperationException uoe() {\n-            return new UnsupportedOperationException(\"Empty VaList\");\n-        }\n-\n-        @Override\n-        public int nextVarg(ValueLayout.OfInt layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public long nextVarg(ValueLayout.OfLong layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public double nextVarg(ValueLayout.OfDouble layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public void skip(MemoryLayout... layouts) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public VaList copy() {\n-            return this;\n-        }\n-\n-        @Override\n-        public MemorySegment segment() {\n-            return address;\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":109,"deletions":95,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -33,0 +34,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker.UpcallStubFactory;\n@@ -46,0 +48,1 @@\n+<<<<<<< HEAD\n@@ -47,0 +50,2 @@\n+=======\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n@@ -53,1 +58,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n@@ -84,1 +88,1 @@\n-    \/\/ r2-7 and v4-7 so they are omitted here.\n+    \/\/ r2-7 and v4-7 so, they are omitted here.\n@@ -160,1 +164,1 @@\n-            csb.addArgumentBindings(MemorySegment.class, AArch64.C_POINTER,\n+            csb.addArgumentBindings(MemorySegment.class, SharedUtils.C_POINTER,\n@@ -192,8 +196,6 @@\n-    public MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope session) {\n-        Bindings bindings = getBindings(mt, cDesc, true);\n-\n-        if (bindings.isInMemoryReturn) {\n-            target = SharedUtils.adaptUpcallForIMR(target, true \/* drop return, since we don't have bindings for it *\/);\n-        }\n-\n-        return UpcallLinker.make(abiDescriptor(), target, bindings.callingSequence, session);\n+    public UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc,\n+                                                          LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, true, options);\n+        final boolean dropReturn = true; \/* drop return, since we don't have bindings for it *\/\n+        return SharedUtils.arrangeUpcallHelper(mt, bindings.isInMemoryReturn, dropReturn, abiDescriptor(),\n+                bindings.callingSequence);\n@@ -434,0 +436,1 @@\n+<<<<<<< HEAD\n@@ -435,0 +438,3 @@\n+=======\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, SharedUtils.C_POINTER);\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n@@ -469,1 +475,1 @@\n-                .boxAddressRaw(Long.MAX_VALUE)\n+                .boxAddressRaw(Long.MAX_VALUE, 1)\n@@ -493,0 +499,1 @@\n+<<<<<<< HEAD\n@@ -494,0 +501,3 @@\n+=======\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, SharedUtils.C_POINTER);\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n@@ -498,0 +508,1 @@\n+<<<<<<< HEAD\n@@ -499,0 +510,4 @@\n+=======\n+                    AddressLayout addressLayout = (AddressLayout) layout;\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, addressLayout);\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n@@ -500,1 +515,1 @@\n-                            .boxAddressRaw(Utils.pointeeSize(layout));\n+                            .boxAddressRaw(Utils.pointeeByteSize(addressLayout), Utils.pointeeByteAlign(addressLayout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -25,0 +25,4 @@\n+<<<<<<< HEAD\n+=======\n+import java.lang.foreign.AddressLayout;\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n@@ -33,0 +37,1 @@\n+<<<<<<< HEAD\n@@ -34,0 +39,2 @@\n+=======\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n@@ -124,1 +131,2 @@\n-    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n+    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64)\n+            .withTargetLayout(MemoryLayout.sequenceLayout(C_CHAR));\n@@ -161,1 +169,1 @@\n-            return LINKER.upcallStub(target, descriptor, SegmentScope.auto());\n+            return LINKER.upcallStub(target, descriptor, Arena.ofAuto());\n@@ -212,0 +220,1 @@\n+<<<<<<< HEAD\n@@ -213,0 +222,3 @@\n+=======\n+        } else if (layout instanceof AddressLayout) {\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n@@ -290,0 +302,1 @@\n+<<<<<<< HEAD\n@@ -291,0 +304,3 @@\n+=======\n+        return LINKER.upcallStub(target, fd, arena);\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -42,5 +42,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.*;\n@@ -66,0 +62,1 @@\n+<<<<<<< HEAD\n@@ -67,0 +64,3 @@\n+=======\n+        try (Arena arena = Arena.ofShared()) {\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n@@ -70,1 +70,1 @@\n-                    SegmentAllocator.nativeAllocator(arena.scope()) :\n+                    arena :\n","filename":"test\/jdk\/java\/foreign\/TestDowncallScope.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+<<<<<<< HEAD\n@@ -59,0 +60,3 @@\n+=======\n+        try (Arena arena = Arena.ofShared()) {\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n","filename":"test\/jdk\/java\/foreign\/TestDowncallStack.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        try (Arena arena = Arena.openShared()) {\n+        try (Arena arena = Arena.ofShared()) {\n@@ -73,0 +73,1 @@\n+<<<<<<< HEAD\n@@ -74,0 +75,3 @@\n+=======\n+            MemorySegment callback = LINKER.upcallStub(mh, callbackDesc, arena);\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+<<<<<<< HEAD\n@@ -78,0 +79,3 @@\n+=======\n+        try (Arena arena = Arena.ofConfined()) {\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+<<<<<<< HEAD\n@@ -60,0 +61,3 @@\n+=======\n+        try (Arena arena = Arena.ofConfined()) {\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+<<<<<<< HEAD\n@@ -61,0 +62,3 @@\n+=======\n+        try (Arena arena = Arena.ofConfined()) {\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+<<<<<<< HEAD\n@@ -81,0 +82,11 @@\n+=======\n+        List<Arg> args = makeArgs(paramTypes, fields);\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            MethodHandle checker = MethodHandles.insertArguments(MH_CHECK, 2, args);\n+            MemorySegment writeBack = LINKER.upcallStub(checker, FunctionDescriptor.ofVoid(C_INT, C_POINTER), arena);\n+            Arena scope1 = arena;\n+            MemorySegment callInfo = scope1.allocate(CallInfo.LAYOUT);;\n+            MemoryLayout layout = MemoryLayout.sequenceLayout(args.size(), C_INT);\n+            MemorySegment argIDs = arena.allocate(layout);;\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n@@ -168,0 +180,1 @@\n+<<<<<<< HEAD\n@@ -169,0 +182,3 @@\n+=======\n+            TestValue testValue = genTestValue(layout, Arena.ofAuto());\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n@@ -181,0 +197,1 @@\n+<<<<<<< HEAD\n@@ -183,0 +200,5 @@\n+=======\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment seg = ptr.asSlice(0, layout)\n+                    .reinterpret(arena, null);\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+<<<<<<< HEAD\n@@ -81,0 +82,3 @@\n+=======\n+        try (Arena arena = Arena.ofConfined()) {\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n","filename":"test\/jdk\/java\/foreign\/arraystructs\/TestArrayStructs.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,4 @@\n+<<<<<<< HEAD\n+=======\n+ * @compile platform\/PlatformLayouts.java\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n@@ -53,1 +57,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.AArch64.*;\n@@ -57,0 +60,1 @@\n+import static platform.PlatformLayouts.AArch64.*;\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestMacOsAArch64CallArranger.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+<<<<<<< HEAD\n@@ -59,0 +60,3 @@\n+=======\n+        try (Arena arena = Arena.ofConfined()) {\n+>>>>>>> 097817f49f1b1bfa61e120c3b4a3d0cb24a4abc6\n","filename":"test\/jdk\/java\/foreign\/nested\/TestNested.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}