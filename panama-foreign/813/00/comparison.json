{"files":[{"patch":"@@ -373,13 +373,0 @@\n-\n-        \/**\n-         * {@return a linker option that can be used to specify the uncaught exception handler that should be executed\n-         *          if an exception is thrown, but not caught, during an upcall}\n-         *\n-         * @apiNote using a custom exception handler will not prevent the VM from exiting in the case of an uncaught\n-         * exception during an upcall.\n-         *\n-         * @param handler the handler\n-         *\/\n-        static Option uncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler) {\n-            return new LinkerOptions.UncaughtExceptionHandler(Objects.requireNonNull(handler));\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    private static final String HANDLE_UNCAUGHT_EXCEPTION_DESC = methodType(void.class, Throwable.class, Thread.UncaughtExceptionHandler.class).descriptorString();\n+    private static final String HANDLE_UNCAUGHT_EXCEPTION_DESC = methodType(void.class, Throwable.class).descriptorString();\n@@ -169,4 +169,1 @@\n-            Thread.UncaughtExceptionHandler uncaughtExceptionHandler = callingSequence.uncaughtExceptionHandler();\n-            MethodHandles.Lookup defineClassLookup = uncaughtExceptionHandler != null\n-                ? MethodHandles.lookup().defineHiddenClassWithClassData(bytes, uncaughtExceptionHandler, true)\n-                : MethodHandles.lookup().defineHiddenClass(bytes, true);\n+            MethodHandles.Lookup defineClassLookup = MethodHandles.lookup().defineHiddenClass(bytes, true);\n@@ -412,5 +409,0 @@\n-            if (callingSequence.uncaughtExceptionHandler() != null) {\n-                emitConst(CLASS_DATA_CONDY);\n-            } else {\n-                emitConst(null);\n-            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -198,4 +198,0 @@\n-    public Thread.UncaughtExceptionHandler uncaughtExceptionHandler() {\n-        return linkerOptions.uncaughtExceptionHandler();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -101,5 +101,0 @@\n-    public Thread.UncaughtExceptionHandler uncaughtExceptionHandler() {\n-        UncaughtExceptionHandler ueh = getOption(UncaughtExceptionHandler.class);\n-        return ueh != null ? ueh.handler() : null;\n-    }\n-\n@@ -119,1 +114,1 @@\n-            permits CaptureCallState, FirstVariadicArg, IsTrivial, UncaughtExceptionHandler {\n+            permits CaptureCallState, FirstVariadicArg, IsTrivial {\n@@ -153,7 +148,0 @@\n-\n-    public record UncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler) implements LinkerOptionImpl {\n-        @Override\n-        public void validateForUpcall(FunctionDescriptor descriptor) {\n-            \/\/ always allowed\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-    public static void handleUncaughtException(Throwable t, Thread.UncaughtExceptionHandler handler) {\n+    public static void handleUncaughtException(Throwable t) {\n@@ -314,10 +314,3 @@\n-            try {\n-                Thread currentThread = Thread.currentThread();\n-                if (handler == null) {\n-                     handler = currentThread.getUncaughtExceptionHandler();\n-                }\n-                handler.uncaughtException(currentThread, t);\n-            } finally {\n-                System.err.println(\"Unrecoverable uncaught exception encountered. The VM will now exit\");\n-                JLA.exit(1);\n-            }\n+            t.printStackTrace();\n+            System.err.println(\"Unrecoverable uncaught exception encountered. The VM will now exit\");\n+            JLA.exit(1);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-            SharedUtils.handleUncaughtException(t, invData.callingSequence().uncaughtExceptionHandler());\n+            SharedUtils.handleUncaughtException(t);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-            return LibFallback.createClosure(cif, target, options.uncaughtExceptionHandler(), scope);\n+            return LibFallback.createClosure(cif, target, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -124,2 +124,1 @@\n-    static MemorySegment createClosure(MemorySegment cif, MethodHandle target,\n-                                       Thread.UncaughtExceptionHandler handler, Arena arena)\n+    static MemorySegment createClosure(MemorySegment cif, MethodHandle target, Arena arena)\n@@ -132,2 +131,1 @@\n-        UpcallData upcallData = new UpcallData(target, handler);\n-        checkStatus(createClosure(cif.address(), upcallData, ptrs));\n+        checkStatus(createClosure(cif.address(), target, ptrs));\n@@ -141,2 +139,0 @@\n-    private record UpcallData(MethodHandle target, Thread.UncaughtExceptionHandler handler) {}\n-\n@@ -144,1 +140,1 @@\n-    private static void doUpcall(long retPtr, long argPtrs, UpcallData data) {\n+    private static void doUpcall(long retPtr, long argPtrs, MethodHandle target) {\n@@ -146,1 +142,1 @@\n-            data.target().invokeExact(MemorySegment.ofAddress(retPtr), MemorySegment.ofAddress(argPtrs));\n+            target.invokeExact(MemorySegment.ofAddress(retPtr), MemorySegment.ofAddress(argPtrs));\n@@ -148,1 +144,1 @@\n-            SharedUtils.handleUncaughtException(t, data.handler());\n+            SharedUtils.handleUncaughtException(t);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-static const char* LibFallback_doUpcall_sig = \"(JJLjdk\/internal\/foreign\/abi\/fallback\/LibFallback$UpcallData;)V\";\n+static const char* LibFallback_doUpcall_sig = \"(JJLjava\/lang\/invoke\/MethodHandle;)V\";\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,7 +66,0 @@\n-    @Test(dataProvider = \"upcallOnlyOptions\",\n-          expectedExceptions = IllegalArgumentException.class,\n-          expectedExceptionsMessageRegExp = \".*Not supported for downcall.*\")\n-    public void testIllegalDowncallOptions(Linker.Option upcallOnlyOption) {\n-        ABI.downcallHandle(DUMMY_TARGET, FunctionDescriptor.ofVoid(), upcallOnlyOption);\n-    }\n-\n@@ -100,7 +93,0 @@\n-    @DataProvider\n-    public static Object[][] upcallOnlyOptions() {\n-        return new Object[][]{\n-            { Linker.Option.uncaughtExceptionHandler((thread, ex) -> {}) }\n-        };\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -84,36 +84,0 @@\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    @Test(dataProvider = \"uncaughtHandlerCases\")\n-    public void testUncaughtExceptionHandlerOption(Class<?> target) throws InterruptedException, IOException {\n-        runInNewProcess(target, true)\n-                .assertStdOutContains(\"From uncaught exception handler\");\n-    }\n-\n-    @DataProvider\n-    public static Object[][] uncaughtHandlerCases() {\n-        return new Object[][]{\n-            { UncaughtHandlerOptionRunner.class },\n-            { UncaughtHandlerThreadRunner.class }\n-        };\n-    }\n-\n-    public static class UncaughtHandlerOptionRunner extends VoidUpcallRunner {\n-        public static void main(String[] args) throws Throwable {\n-            try (Arena arena = Arena.ofConfined()) {\n-                MemorySegment stub = Linker.nativeLinker().upcallStub(VOID_TARGET, FunctionDescriptor.ofVoid(),\n-                        arena, Linker.Option.uncaughtExceptionHandler(UNCAUGHT_EXCEPTION_HANDLER));\n-                downcallVoid.invoke(stub);\n-            }\n-        }\n-    }\n-\n-    public static class UncaughtHandlerThreadRunner extends VoidUpcallRunner {\n-        public static void main(String[] args) throws Throwable {\n-            Thread.currentThread().setUncaughtExceptionHandler(UNCAUGHT_EXCEPTION_HANDLER);\n-            try (Arena arena = Arena.ofConfined()) {\n-                MemorySegment stub = Linker.nativeLinker().upcallStub(VOID_TARGET, FunctionDescriptor.ofVoid(), arena);\n-                downcallVoid.invoke(stub);\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"}]}