{"files":[{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.util.function.Consumer;\n@@ -63,0 +64,50 @@\n+ *\n+ * <h2 id=\"native-linker\">Calling native functions<\/h2>\n+ *\n+ * The {@linkplain #nativeLinker() native linker} can be used to link against functions\n+ * defined in C libraries (native functions). Suppose we wish to downcall from Java to the {@code strlen} function\n+ * defined in the standard C library:\n+ * {@snippet lang = c:\n+ * size_t strlen(const char *s);\n+ * }\n+ * A downcall method handle that exposes {@code strlen} is obtained, using the native linker, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * Linker linker = Linker.nativeLinker();\n+ * MethodHandle strlen = linker.downcallHandle(\n+ *     linker.defaultLookup().find(\"strlen\").get(),\n+ *     FunctionDescriptor.of(JAVA_LONG, ADDRESS)\n+ * );\n+ * }\n+ *\n+ * Note how the native linker also provides access, via its {@linkplain #defaultLookup() default lookup},\n+ * to the native functions defined by the C libraries loaded with the Java runtime. Above, the default lookup\n+ * is used to search the address of the {@code strlen} native function. That address is then passed, along with\n+ * a <em>platform-dependent description<\/em> of the signature of the function expressed as a\n+ * {@link FunctionDescriptor} (more on that below) to the native linker's\n+ * {@link #downcallHandle(MemorySegment, FunctionDescriptor, Option...)} method.\n+ * The obtained downcall method handle is then invoked as follows:\n+ *\n+ * {@snippet lang = java:\n+ * try (Arena arena = Arena.openConfined()) {\n+ *     MemorySegment str = arena.allocateUtf8String(\"Hello\");\n+ *     long len          = strlen.invoke(str);  \/\/ 5\n+ * }\n+ * }\n+ * <h3 id=\"describing-c-sigs\">Describing C signatures<\/h3>\n+ *\n+ * When interacting with the native linker, clients must provide a platform-dependent description of the signature\n+ * of the C function they wish to link against. This description, a {@link FunctionDescriptor function descriptor},\n+ * defines the layouts associated with the parameter types and return type (if any) of the C function.\n+ * <p>\n+ * Scalar C types such as {@code bool}, {@code int} are modelled as {@linkplain ValueLayout value layouts}\n+ * of a suitable carrier. The mapping between a scalar type and its corresponding layout is dependent on the ABI\n+ * implemented by the native linker. For instance, the C type {@code long} maps to the layout constant\n+ * {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on\n+ * Windows\/x64. Similarly, the C type {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n+ * on 64-bit platforms, but maps to the layout constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * <p>\n+ * Composite types are modelled as {@linkplain GroupLayout group layouts}. More specifically, a C {@code struct} type\n+ * maps to a {@linkplain StructLayout struct layout}, whereas a C {@code union} type maps to a {@link UnionLayout union\n+ * layout}. Depending on the ABI implemented by the native linker, additional {@linkplain MemoryLayout#paddingLayout(long) padding}\n+ * member layouts might be required to conform to the size and alignment constraint of a composite type definition in C.\n@@ -64,3 +115,86 @@\n- * The {@link #nativeLinker()} method provides a linker for the ABI associated with the OS and processor where the Java runtime\n- * is currently executing. This linker also provides access, via its {@linkplain #defaultLookup() default lookup},\n- * to the native libraries loaded with the Java runtime.\n+ * Finally, pointer types such as {@code int**} and {@code int(*)(size_t*, size_t*)} are modelled as\n+ * {@linkplain AddressLayout address layouts}. When the spatial bounds of the pointer type are known statically,\n+ * the address layout can be associated with a {@linkplain AddressLayout#targetLayout() target layout}. For instance,\n+ * a pointer that is known to point to a C {@code int[2]} array can be modelled as an address layout whose\n+ * target layout is a sequence layout whose element count is 2, and whose element type is {@link ValueLayout#JAVA_INT}.\n+ * <p>\n+ * The following table shows some examples of how C types are modelled in Linux\/x64:\n+ *\n+ * <blockquote><table class=\"plain\">\n+ * <caption style=\"display:none\">Mapping C types<\/caption>\n+ * <thead>\n+ * <tr>\n+ *     <th scope=\"col\">C type<\/th>\n+ *     <th scope=\"col\">Layout<\/th>\n+ *     <th scope=\"col\">Java type<\/th>\n+ * <\/tr>\n+ * <\/thead>\n+ * <tbody>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code bool}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_BOOLEAN}<\/td>\n+ *     <td style=\"text-align:center;\">{@code boolean}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_BYTE}<\/td>\n+ *     <td style=\"text-align:center;\">{@code byte}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_SHORT}<\/td>\n+ *     <td style=\"text-align:center;\">{@code short}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_INT}<\/td>\n+ *     <td style=\"text-align:center;\">{@code int}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_LONG}<\/td>\n+ *     <td style=\"text-align:center;\">{@code long}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_LONG}<\/td>\n+ *     <td style=\"text-align:center;\">{@code long}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code float}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_FLOAT}<\/td>\n+ *     <td style=\"text-align:center;\">{@code float}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code double}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_DOUBLE}<\/td>\n+ *     <td style=\"text-align:center;\">{@code double}<\/td>\n+ <tr><th scope=\"row\" style=\"font-weight:normal\">{@code size_t}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_LONG}<\/td>\n+ *     <td style=\"text-align:center;\">{@code long}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char*}, {@code int**}, {@code struct Point*}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#ADDRESS}<\/td>\n+ *     <td style=\"text-align:center;\">{@link MemorySegment}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int (*foo)[10]}<\/th>\n+ *     <td style=\"text-align:left;\">\n+ * <pre>\n+ * ValueLayout.ADDRESS.withTargetLayout(\n+ *     MemoryLayout.sequenceLayout(10,\n+ *         ValueLayout.JAVA_INT)\n+ * );\n+ * <\/pre>\n+ *     <td style=\"text-align:center;\">{@link MemorySegment}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\"><code>struct Point { int x; long y; };<\/code><\/th>\n+ *     <td style=\"text-align:left;\">\n+ * <pre>\n+ * MemoryLayout.structLayout(\n+ *     ValueLayout.JAVA_INT.withName(\"x\"),\n+ *     MemoryLayout.paddingLayout(32),\n+ *     ValueLayout.JAVA_LONG.withName(\"y\")\n+ * );\n+ * <\/pre>\n+ *     <\/td>\n+ *     <td style=\"text-align:center;\">{@link MemorySegment}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\"><code>union Choice { float a; int b; }<\/code><\/th>\n+ *     <td style=\"text-align:left;\">\n+ * <pre>\n+ * MemoryLayout.unionLayout(\n+ *     ValueLayout.JAVA_FLOAT.withName(\"a\"),\n+ *     ValueLayout.JAVA_INT.withName(\"b\")\n+ * );\n+ * <\/pre>\n+ *     <\/td>\n+ *     <td style=\"text-align:center;\">{@link MemorySegment}<\/td>\n+ * <\/tbody>\n+ * <\/table><\/blockquote>\n+ *\n+ * <h3 id=\"function-pointers\">Function pointers<\/h3>\n+ *\n+ * Sometimes, it is useful to pass Java code as a function pointer to some native function; this is achieved by using\n+ * an {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...) upcall stub}. To demonstrate this,\n+ * let's consider the following function from the C standard library:\n@@ -68,1 +202,4 @@\n- * <h2 id=\"downcall-method-handles\">Downcall method handles<\/h2>\n+ * {@snippet lang = c:\n+ * void qsort(void *base, size_t nmemb, size_t size,\n+ *            int (*compar)(const void *, const void *));\n+ * }\n@@ -70,3 +207,14 @@\n- * {@linkplain #downcallHandle(FunctionDescriptor, Option...) Linking a foreign function} is a process which requires a function descriptor,\n- * a set of memory layouts which, together, specify the signature of the foreign function to be linked, and returns,\n- * when complete, a downcall method handle, that is, a method handle that can be used to invoke the target foreign function.\n+ * The {@code qsort} function can be used to sort the contents of an array, using a custom comparator function which is\n+ * passed as a function pointer (the {@code compar} parameter). To be able to call {@code qsort} function from Java,\n+ * we must first create a downcall method handle for it, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * Linker linker = Linker.nativeLinker();\n+ * MethodHandle qsort = linker.downcallHandle(\n+ *     linker.defaultLookup().find(\"qsort\").get(),\n+ *         FunctionDescriptor.ofVoid(ADDRESS, JAVA_LONG, JAVA_LONG, ADDRESS)\n+ * );\n+ * }\n+ *\n+ * As before, we use {@link ValueLayout#JAVA_LONG} to map the C type {@code size_t} type, and {@link ValueLayout#ADDRESS}\n+ * for both the first pointer parameter (the array pointer) and the last parameter (the function pointer).\n@@ -74,11 +222,44 @@\n- * The Java {@linkplain java.lang.invoke.MethodType method type} associated with the returned method handle is\n- * {@linkplain FunctionDescriptor#toMethodType() derived} from the argument and return layouts in the function descriptor.\n- * The downcall method handle type, might then be decorated by additional leading parameters, in the given order if both are present:\n- * <ul>\n- * <li>If the downcall method handle is created {@linkplain #downcallHandle(FunctionDescriptor, Option...) without specifying a target address},\n- * the downcall method handle type features a leading parameter of type {@link MemorySegment}, from which the\n- * address of the target foreign function can be derived.<\/li>\n- * <li>If the function descriptor's return layout is a group layout, the resulting downcall method handle accepts\n- * an additional leading parameter of type {@link SegmentAllocator}, which is used by the linker runtime to allocate the\n- * memory region associated with the struct returned by the downcall method handle.<\/li>\n- * <\/ul>\n+ * To invoke the {@code qsort} downcall handle obtained above, we need a function pointer to be passed as the last\n+ * parameter. That is, we need to create a function pointer out of an existing method handle. First, let's write a\n+ * Java method that can compare two int elements passed as pointers (i.e. as {@linkplain MemorySegment memory segments}):\n+ *\n+ * {@snippet lang = java:\n+ * class Qsort {\n+ *     static int qsortCompare(MemorySegment elem1, MemorySegmet elem2) {\n+ *         return Integer.compare(elem1.get(JAVA_INT, 0), elem2.get(JAVA_INT, 0));\n+ *     }\n+ * }\n+ * }\n+ *\n+ * Now let's create a method handle for the comparator method defined above:\n+ *\n+ * {@snippet lang = java:\n+ * FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT,\n+ *                                                       ADDRESS.withTargetLayout(JAVA_INT),\n+ *                                                       ADDRESS.withTargetLayout(JAVA_INT));\n+ * MethodHandle comparHandle = MethodHandles.lookup()\n+ *                                          .findStatic(Qsort.class, \"qsortCompare\",\n+ *                                                      comparDesc.toMethodType());\n+ * }\n+ *\n+ * First, we create a function descriptor for the function pointer type. Since we know that the parameters passed to\n+ * the comparator method will be pointers to elements of a C {@code int[]} array, we can specify {@link ValueLayout#JAVA_INT}\n+ * as the target layout for the address layouts of both parameters. This will allow the comparator method to access\n+ * the contents of the array elements to be compared. We then {@linkplain FunctionDescriptor#toMethodType() turn}\n+ * that function descriptor into a suitable {@linkplain java.lang.invoke.MethodType method type} which we then use to look up\n+ * the comparator method handle. We can now create an upcall stub which points to that method, and pass it, as a function\n+ * pointer, to the {@code qsort} downcall handle, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * try (Arena arena = Arena.ofConfined()) {\n+ *     MemorySegment comparFunc = linker.upcallStub(comparHandle, comparDesc, arena);\n+ *     MemorySegment array = session.allocateArray(0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+ *     qsort.invokeExact(array, 10L, 4L, comparFunc);\n+ *     int[] sorted = array.toArray(JAVA_INT); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n+ * }\n+ * }\n+ *\n+ * This code creates an off-heap array, copies the contents of a Java array into it, and then passes the array to the\n+ * {@code qsort} method handle along with the comparator function we obtained from the native linker. After the invocation, the contents\n+ * of the off-heap array will be sorted according to our comparator function, written in Java. We then extract a\n+ * new Java array from the segment, which contains the sorted elements.\n@@ -86,1 +267,1 @@\n- * <h2 id=\"upcall-stubs\">Upcall stubs<\/h2>\n+ * <h3 id=\"by-ref\">Functions returning pointers<\/h3>\n@@ -88,3 +269,19 @@\n- * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...) Creating an upcall stub} requires a method\n- * handle and a function descriptor; in this case, the set of memory layouts in the function descriptor\n- * specify the signature of the function pointer associated with the upcall stub.\n+ * When interacting with native functions, it is common for those functions to allocate a region of memory and return\n+ * a pointer to that region. Let's consider the following function from the C standard library:\n+ *\n+ * {@snippet lang = c:\n+ * void *malloc(size_t size);\n+ * }\n+ *\n+ * The {@code malloc} function allocates a region of memory of given size,\n+ * and returns a pointer to that region of memory, which is later deallocated using another function from\n+ * the C standard library:\n+ *\n+ * {@snippet lang = c:\n+ * void free(void *ptr);\n+ * }\n+ *\n+ * The {@code free} function takes a pointer to a region of memory and deallocates that region. In this section we\n+ * will show how to interact with these native functions, with the aim of providing a <em>safe<\/em> allocation\n+ * API (the approach outlined below can of course be generalized to allocation functions other than {@code malloc}\n+ * and {@code free}).\n@@ -92,2 +289,63 @@\n- * The type of the provided method handle's type has to match the method type associated with the upcall stub,\n- * which is {@linkplain FunctionDescriptor#toMethodType() derived} from the provided function descriptor.\n+ * First, we need to create the downcall method handles for {@code malloc} and {@code free}, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * Linker linker = Linker.nativeLinker();\n+ *\n+ * MethodHandle malloc = linker.downcallHandle(\n+ *     linker.defaultLookup().find(\"malloc\").get(),\n+ *     FunctionDescriptor.of(ADDRESS, JAVA_LONG)\n+ * );\n+ *\n+ * MethodHandle free = linker.downcallHandle(\n+ *     linker.defaultLookup().find(\"free\").get(),\n+ *     FunctionDescriptor.ofVoid(ADDRESS)\n+ * );\n+ * }\n+ *\n+ * When interacting with a native functions returning a pointer (such as {@code malloc}), the Java runtime has no insight\n+ * into the size or the lifetime of the returned pointer. Consider the following code:\n+ *\n+ * {@snippet lang = java:\n+ * MemorySegment segment = (MemorySegment)malloc.invokeExact(100);\n+ * }\n+ *\n+ * The size of the segment returned by the {@code malloc} downcall method handle is\n+ * <a href=\"MemorySegment.html#wrapping-addresses\">zero<\/a>. Moreover, the scope of the\n+ * returned segment is a fresh scope that is always alive. To provide safe access to the segment, we must,\n+ * unsafely, resize the segment to the desired size (100, in this case). It might also be desirable to\n+ * attach the segment to some existing {@linkplain Arena arena}, so that the lifetime of the region of memory\n+ * backing the segment can be managed automatically, as for any other native segment created directly from Java code.\n+ * Both these operations are accomplished using the restricted {@link MemorySegment#reinterpret(long, Arena, Consumer)}\n+ * method, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * MemorySegment allocateMemory(long byteSize, Arena arena) {\n+ *     MemorySegment segment = (MemorySegment)malloc.invokeExact(byteSize);   \/\/ size = byteSize, scope = always alive\n+ *     return segment.reinterpret(size, arena, s -> free.invokeExact(s));     \/\/ size = byteSize, scope = arena.scope()\n+ * }\n+ * }\n+ *\n+ * The {@code allocateMemory} method defined above accepts two parameters: a size and an arena. The method calls the\n+ * {@code malloc} downcall method handle, and unsafely reinterprets the returned segment, by giving it a new size\n+ * (the size passed to the {@code allocateMemory} method) and a new scope (the scope of the provided arena).\n+ * The method also specifies a <em>cleanup action<\/em> to be executed when the provided arena is closed. Unsurprisingly,\n+ * the cleanup action passes the segment to the {@code free} downcall method handle, to deallocate the underlying\n+ * region of memory. We can use the {@code allocateMemory} method as follows:\n+ *\n+ * {@snippet lang = java:\n+ * try (Arena arena = Arena.ofConfined()) {\n+ *     MemorySegment segment = allocateMemory(100, arena);\n+ * } \/\/ 'free' called here\n+ * }\n+ *\n+ * Note how the segment obtained from {@code allocateMemory} acts as any other segment managed by the confined arena. More\n+ * specifically, the obtained segment has the desired size, can only be accessed by a single thread (the thread which created\n+ * the confined arena), and its lifetime is tied to the surrounding <em>try-with-resources<\/em> block.\n+ *\n+ * <h3 id=\"variadic-funcs\">Variadic functions<\/h3>\n+ *\n+ * Variadic functions (e.g. a C function declared with a trailing ellipses {@code ...} at the end of the formal parameter\n+ * list or with an empty formal parameter list) are not supported directly by the native linker. However, it is still possible\n+ * to link a variadic function by using a <em>specialized<\/em> function descriptor, together with a\n+ * {@linkplain Linker.Option#firstVariadicArg(int) a linker option} which indicates the position of the first variadic argument\n+ * in that specialized descriptor.\n@@ -95,3 +353,37 @@\n- * Upcall stubs are modelled by instances of type {@link MemorySegment}; upcall stubs can be passed by reference to other\n- * downcall method handles. An upcall stub can be released by {@linkplain Arena#close() closing} the arena which was used\n- * to create it.\n+ * A well-known variadic function is the {@code printf} function, defined in the C standard library:\n+ *\n+ * {@snippet lang = c:\n+ * int printf(const char *format, ...);\n+ * }\n+ *\n+ * This function takes a format string, and a number of additional arguments (the number of such arguments is\n+ * dictated by the format string). Consider the following variadic call:\n+ *\n+ * {@snippet lang = c:\n+ * printf(\"%d plus %d equals %d\", 2, 2, 4);\n+ * }\n+ *\n+ * To perform an equivalent call using a downcall method handle we must create a function descriptor which\n+ * describes the specialized signature of the C function we want to call. This descriptor must include layouts for any\n+ * additional variadic argument we intend to provide. In this case, the specialized signature of the C\n+ * function is {@code (char*, int, int, int)} as the format string accepts three integer parameters. Then, we need to use\n+ * a linker option to specify the position of the first variadic layout in the provided function descriptor (starting from 0).\n+ * In this case, since the first parameter is the format string (a non-variadic argument), the first variadic index\n+ * needs to be set to 1, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * Linker linker = Linker.nativeLinker();\n+ * MethodHandle printf = linker.downcallHandle(\n+ *     linker.defaultLookup().lookup(\"printf\").get(),\n+ *         FunctionDescriptor.of(JAVA_INT, ADDRESS, JAVA_INT, JAVA_INT, JAVA_INT),\n+ *         Linker.Option.firstVariadicArg(1) \/\/ first int is variadic\n+ * );\n+ * }\n+ *\n+ * We can then call the specialized downcall handle as usual:\n+ *\n+ * {@snippet lang = java:\n+ * try (Arena arena = Arena.ofConfined()) {\n+ *     int res = (int)printf.invokeExact(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n+ * }\n+ * }\n@@ -105,16 +397,1 @@\n- * the result of such interaction is unspecified and can lead to JVM crashes. On downcall handle invocation,\n- * the linker runtime guarantees the following for any argument {@code A} of type {@link MemorySegment} whose corresponding\n- * layout is {@link ValueLayout#ADDRESS}:\n- * <ul>\n- *     <li>{@code A.scope().isAlive() == true}. Otherwise, the invocation throws {@link IllegalStateException};<\/li>\n- *     <li>The invocation occurs in a thread {@code T} such that {@code A.isAccessibleBy(T) == true}.\n- *     Otherwise, the invocation throws {@link WrongThreadException}; and<\/li>\n- *     <li>{@code A} is kept alive during the invocation. For instance, if {@code A} has been obtained using a\n- *     {@linkplain Arena#ofConfined() confined arena}, any attempt to {@linkplain Arena#close() close}\n- *     the confined arena while the downcall method handle is executing will result in a {@link IllegalStateException}.<\/li>\n- *<\/ul>\n- * A downcall method handle created from a function descriptor whose return layout is an\n- * {@linkplain AddressLayout address layout} returns a native segment associated with\n- * a fresh scope that is always alive. Under normal conditions, the size of the returned segment is {@code 0}.\n- * However, if the return address layout has a {@linkplain AddressLayout#targetLayout()} {@code T}, then the size of the returned segment\n- * is set to {@code T.byteSize()}.\n+ * the result of such interaction is unspecified and can lead to JVM crashes.\n@@ -129,6 +406,0 @@\n- * <p>\n- * An upcall stub argument whose corresponding layout is an {@linkplain AddressLayout address layout}\n- * is a native segment associated with a fresh scope that is always alive.\n- * Under normal conditions, the size of this segment argument is {@code 0}.\n- * However, if the address layout has a {@linkplain AddressLayout#targetLayout()} {@code T}, then the size of the\n- * segment argument is set to {@code T.byteSize()}.\n@@ -147,29 +418,0 @@\n-     * <p>\n-     * When interacting with the returned linker, clients must describe the signature of a foreign function using a\n-     * {@link FunctionDescriptor function descriptor} whose argument and return layouts are specified as follows:\n-     * <ul>\n-     *     <li>Scalar types are modelled by a {@linkplain ValueLayout value layout} instance of a suitable carrier. Example\n-     *     of scalar types in C are {@code int}, {@code long}, {@code size_t}, etc. The mapping between a scalar type\n-     *     and its corresponding layout is dependent on the ABI of the returned linker;\n-     *     <li>Composite types are modelled by a {@linkplain GroupLayout group layout}. Depending on the ABI of the\n-     *     returned linker, additional {@linkplain MemoryLayout#paddingLayout(long) padding} member layouts might be required to conform\n-     *     to the size and alignment constraint of a composite type definition in C (e.g. using {@code struct} or {@code union}); and<\/li>\n-     *     <li>Pointer types are modelled by a {@linkplain ValueLayout value layout} instance with carrier {@link MemorySegment}.\n-     *     Examples of pointer types in C are {@code int**} and {@code int(*)(size_t*, size_t*)};<\/li>\n-     * <\/ul>\n-     * <p>\n-     * Any layout not listed above is <em>unsupported<\/em>; function descriptors containing unsupported layouts\n-     * will cause an {@link IllegalArgumentException} to be thrown, when used to create a\n-     * {@link #downcallHandle(MemorySegment, FunctionDescriptor, Option...) downcall method handle} or an\n-     * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...) upcall stub}.\n-     * <p>\n-     * Variadic functions (e.g. a C function declared with a trailing ellipses {@code ...} at the end of the formal parameter\n-     * list or with an empty formal parameter list) are not supported directly. However, it is possible to link a\n-     * variadic function by using {@linkplain Linker.Option#firstVariadicArg(int) a linker option} to indicate\n-     * the start of the list of variadic arguments, together with a specialized function descriptor describing a\n-     * given variable arity callsite.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n@@ -182,1 +424,1 @@\n-     * @return a linker for the ABI associated with the OS and processor where the Java runtime is currently executing.\n+     * @return a linker for the ABI associated with the underlying native platform.\n@@ -193,5 +435,1 @@\n-     * Creates a method handle which can be used to call a foreign function with the given signature and address.\n-     * <p>\n-     * If the provided method type's return type is {@code MemorySegment}, then the resulting method handle features\n-     * an additional prefix parameter, of type {@link SegmentAllocator}, which will be used by the linker to allocate\n-     * structs returned by-value.\n+     * Creates a method handle which is used to call a foreign function with the given signature and address.\n@@ -218,4 +456,1 @@\n-     * Creates a method handle which can be used to call a foreign function with the given signature.\n-     * The resulting method handle features a prefix parameter (as the first parameter) corresponding to the foreign function\n-     * entry point, of type {@link MemorySegment}, which is used to specify the address of the target function\n-     * to be called.\n+     * Creates a method handle which is used to call a foreign function with the given signature.\n@@ -223,3 +458,6 @@\n-     * If the provided function descriptor's return layout is a {@link GroupLayout}, then the resulting method handle features an\n-     * additional prefix parameter (inserted immediately after the address parameter), of type {@link SegmentAllocator}),\n-     * which will be used by the linker to allocate structs returned by-value.\n+     * The Java {@linkplain java.lang.invoke.MethodType method type} associated with the returned method handle is\n+     * {@linkplain FunctionDescriptor#toMethodType() derived} from the argument and return layouts in the function descriptor,\n+     * but features an additional leading parameter of type {@link MemorySegment}, from which the address of the target\n+     * foreign function is derived. Moreover, if the function descriptor's return layout is a group layout, the resulting\n+     * downcall method handle accepts an additional leading parameter of type {@link SegmentAllocator}, which is used by\n+     * the linker runtime to allocate the memory region associated with the struct returned by the downcall method handle.\n@@ -227,2 +465,20 @@\n-     * The returned method handle will throw an {@link IllegalArgumentException} if the {@link MemorySegment} parameter passed to it is\n-     * associated with the {@link MemorySegment#NULL} address, or a {@link NullPointerException} if that parameter is {@code null}.\n+     * Upon invoking a downcall method handle, the linker runtime will guarantee the following for any argument\n+     * {@code A} of type {@link MemorySegment} whose corresponding layout is an {@linkplain AddressLayout address layout}:\n+     * <ul>\n+     *     <li>{@code A.scope().isAlive() == true}. Otherwise, the invocation throws {@link IllegalStateException};<\/li>\n+     *     <li>The invocation occurs in a thread {@code T} such that {@code A.isAccessibleBy(T) == true}.\n+     *     Otherwise, the invocation throws {@link WrongThreadException}; and<\/li>\n+     *     <li>{@code A} is kept alive during the invocation. For instance, if {@code A} has been obtained using a\n+     *     {@linkplain Arena#ofConfined() confined arena}, any attempt to {@linkplain Arena#close() close}\n+     *     the confined arena while the downcall method handle is executing will result in a {@link IllegalStateException}.<\/li>\n+     *<\/ul>\n+     * <p>\n+     * Moreover, if the provided function descriptor's return layout is an {@linkplain AddressLayout address layout},\n+     * invoking the returned method handle will return a native segment associated with\n+     * a fresh scope that is always alive. Under normal conditions, the size of the returned segment is {@code 0}.\n+     * However, if the function descriptor's return layout has a {@linkplain AddressLayout#targetLayout()} {@code T},\n+     * then the size of the returned segment is set to {@code T.byteSize()}.\n+     * <p>\n+     * Finally, the returned method handle will throw an {@link IllegalArgumentException} if the {@link MemorySegment}\n+     * parameter passed to it is associated with the {@link MemorySegment#NULL} address, or a {@link NullPointerException}\n+     * if that parameter is {@code null}.\n@@ -249,0 +505,6 @@\n+     * An upcall stub argument whose corresponding layout is an {@linkplain AddressLayout address layout}\n+     * is a native segment associated with a fresh scope that is always alive.\n+     * Under normal conditions, the size of this segment argument is {@code 0}.\n+     * However, if the address layout has a {@linkplain AddressLayout#targetLayout()} {@code T}, then the size of the\n+     * segment argument is set to {@code T.byteSize()}.\n+     * <p>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":356,"deletions":94,"binary":false,"changes":450,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,5 +34,7 @@\n- * models a contiguous region of memory, residing either inside or outside the Java heap. The contents of a memory\n- * segment can be described using a {@link java.lang.foreign.MemoryLayout memory layout}, which provides\n- * basic operations to query sizes, offsets and alignment constraints. Memory layouts also provide\n- * an alternate, more abstract way, to <a href=MemorySegment.html#segment-deref>access memory segments<\/a>\n- * using {@linkplain java.lang.foreign.MemoryLayout#varHandle(java.lang.foreign.MemoryLayout.PathElement...) var handles},\n+ * models a contiguous region of memory, residing either inside or outside the Java heap. Memory segments are\n+ * typically allocated using an {@link java.lang.foreign.Arena}, which controls the lifetime of the regions of memory\n+ * backing the segments it allocates. The contents of a memory segment can be described using a\n+ * {@link java.lang.foreign.MemoryLayout memory layout}, which provides basic operations to query sizes, offsets and\n+ * alignment constraints. Memory layouts also provide an alternate, more abstract way, to\n+ * <a href=MemorySegment.html#segment-deref>access memory segments<\/a> using\n+ * {@linkplain java.lang.foreign.MemoryLayout#varHandle(java.lang.foreign.MemoryLayout.PathElement...) var handles},\n@@ -45,34 +47,0 @@\n- * MemorySegment segment = Arena.ofAuto().allocate(10 * 4, 1);\n- * for (int i = 0 ; i < 10 ; i++) {\n- *     segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n- * }\n- *}\n- *\n- * This code creates a <em>native<\/em> memory segment, that is, a memory segment backed by\n- * off-heap memory; the size of the segment is 40 bytes, enough to store 10 values of the primitive type {@code int}.\n- * Native segments are allocated using an {@link Arena}. An arena controls the lifetime of all the segments allocated\n- * from it. In this case, as the segment is allocated using an {@linkplain java.lang.foreign.Arena#ofAuto() automatic arena}. This\n- * means that the off-heap region of memory backing the segment is managed, automatically, by the garbage collector.\n- * As such, the off-heap memory backing the native segment will be released at some unspecified\n- * point <em>after<\/em> the segment becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n- * This is similar to what happens with direct buffers created via {@link java.nio.ByteBuffer#allocateDirect(int)}.\n- * It is also possible to manage the lifecycle of allocated native segments more directly, as shown in a later section.\n- * <p>\n- * Inside a loop, we then initialize the contents of the memory segment; note how the\n- * {@linkplain java.lang.foreign.MemorySegment#setAtIndex(ValueLayout.OfInt, long, int) access method}\n- * accepts a {@linkplain java.lang.foreign.ValueLayout value layout}, which specifies the size, alignment constraint,\n- * byte order as well as the Java type ({@code int}, in this case) associated with the access operation. More specifically,\n- * if we view the memory segment as a set of 10 adjacent slots, {@code s[i]}, where {@code 0 <= i < 10},\n- * where the size of each slot is exactly 4 bytes, the initialization logic above will set each slot\n- * so that {@code s[i] = i}, again where {@code 0 <= i < 10}.\n- *\n- * <h3 id=\"deallocation\">Deterministic deallocation<\/h3>\n- *\n- * When writing code that manipulates memory segments, especially if backed by memory which resides outside the Java heap, it is\n- * often crucial that the resources associated with a memory segment are released when the segment is no longer in use,\n- * and in a timely fashion. For this reason, there might be cases where waiting for the garbage collector to determine that a segment\n- * is <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a> is not optimal.\n- * Clients that operate under these assumptions might want to programmatically release the memory backing a memory segment.\n- * This can be done, using a <em>confined arena<\/em>, as shown below:\n- *\n- * {@snippet lang = java:\n@@ -85,9 +53,1 @@\n- *}\n- *\n- * A confined arena can be {@linkplain java.lang.foreign.Arena#close() closed}. When a confined\n- * arena is closed, all the segments allocated by it are invalidated, and become inaccessible.\n- * Note the use of the <em>try-with-resources<\/em> construct: this idiom ensures\n- * that the off-heap region of memory backing the native segment will be released at the end of the block, according to\n- * the semantics described in Section {@jls 14.20.3} of <cite>The Java Language Specification<\/cite>.\n- *\n- * <h3 id=\"safety\">Safety<\/h3>\n+ * }\n@@ -95,1 +55,10 @@\n- * This API provides strong safety guarantees when it comes to memory access. First, when dereferencing a memory segment,\n+ * This code creates a <em>native<\/em> memory segment, that is, a memory segment backed by\n+ * off-heap memory; the size of the segment is 40 bytes, enough to store 10 values of the primitive type {@code int}.\n+ * The native segment is allocated using a {@linkplain java.lang.foreign.Arena#ofConfined() confined arena}.\n+ * As such, access to the native segment is restricted to the current thread (the thread that created the arena).\n+ * Moreover, when the arena is closed, the native segment is invalidated, and its backing region of memory is\n+ * deallocated. Note the use of the <em>try-with-resources<\/em> construct: this idiom ensures that the off-heap region\n+ * of memory backing the native segment will be released at the end of the block, according to the semantics described\n+ * in Section {@jls 14.20.3} of <cite>The Java Language Specification<\/cite>.\n+ * <p>\n+ * Memory segments provide strong safety guarantees when it comes to memory access. First, when accessing a memory segment,\n@@ -101,4 +70,6 @@\n- * Since memory segments created with an arena can become invalid (see above), segments are also validated (upon access) to make sure that\n- * the arena from which the segment has been obtained has not been closed.\n- * We call this guarantee <em>temporal safety<\/em>. Together, spatial and temporal safety ensure that each memory access\n- * operation either succeeds - and accesses a valid location within the region of memory backing the memory segment - or fails.\n+ * Additionally, to prevent a region of memory from being accessed <em>after<\/em> it has been deallocated\n+ * (i.e. <em>use-after-free<\/em>), a segment is also validated (upon access) to make sure that the arena from which it\n+ * has been obtained has not been closed. We call this guarantee <em>temporal safety<\/em>.\n+ * <p>\n+ * Together, spatial and temporal safety ensure that each memory access operation either succeeds - and accesses a valid\n+ * location within the region of memory backing the memory segment - or fails.\n@@ -114,1 +85,1 @@\n- * For example, to compute the length of a string using the C standard library function {@code strlen} on a Linux x64 platform,\n+ * For example, to compute the length of a string using the C standard library function {@code strlen} on a Linux\/x64 platform,\n@@ -127,1 +98,1 @@\n- *     long len = (long)strlen.invoke(cString); \/\/ 5\n+ *     long len = (long)strlen.invokeExact(cString); \/\/ 5\n@@ -132,2 +103,2 @@\n- * to {@linkplain java.lang.foreign.SymbolLookup#find(java.lang.String) look up} the {@code strlen} symbol in the\n- * standard C library; a <em>downcall method handle<\/em> targeting said symbol is subsequently\n+ * to {@linkplain java.lang.foreign.SymbolLookup#find(java.lang.String) look up} the {@code strlen} function in the\n+ * standard C library; a <em>downcall method handle<\/em> targeting said function is subsequently\n@@ -138,1 +109,1 @@\n- * the method handle invocation (here performed using {@link java.lang.invoke.MethodHandle#invoke(java.lang.Object...)})\n+ * the method handle invocation (here performed using {@link java.lang.invoke.MethodHandle#invokeExact(java.lang.Object...)})\n@@ -145,52 +116,0 @@\n- * <h3 id=\"upcalls\">Upcalls<\/h3>\n- * The {@link java.lang.foreign.Linker} interface also allows clients to turn an existing method handle (which might point\n- * to a Java method) into a memory segment, so that Java code can effectively be passed to other foreign functions.\n- * For instance, we can write a method that compares two integer values, as follows:\n- *\n- * {@snippet lang=java :\n- * class IntComparator {\n- *     static int intCompare(MemorySegment addr1, MemorySegment addr2) {\n- *         return addr1.get(ValueLayout.JAVA_INT, 0) -\n- *                addr2.get(ValueLayout.JAVA_INT, 0);\n- *\n- *     }\n- * }\n- * }\n- *\n- * The above method accesses two foreign memory segments containing an integer value, and performs a simple comparison\n- * by returning the difference between such values. We can then obtain a method handle which targets the above static\n- * method, as follows:\n- *\n- * {@snippet lang = java:\n- * FunctionDescriptor intCompareDescriptor = FunctionDescriptor.of(ValueLayout.JAVA_INT,\n- *                                                                 ValueLayout.ADDRESS.asUnbounded(),\n- *                                                                 ValueLayout.ADDRESS.asUnbounded());\n- * MethodHandle intCompareHandle = MethodHandles.lookup().findStatic(IntComparator.class,\n- *                                                 \"intCompare\",\n- *                                                 intCompareDescriptor.toMethodType());\n- *}\n- *\n- * As before, we need to create a {@link java.lang.foreign.FunctionDescriptor} instance, this time describing the signature\n- * of the function pointer we want to create. The descriptor can be used to\n- * {@linkplain java.lang.foreign.FunctionDescriptor#toMethodType() derive} a method type\n- * that can be used to look up the method handle for {@code IntComparator.intCompare}.\n- * <p>\n- * Now that we have a method handle instance, we can turn it into a fresh function pointer,\n- * using the {@link java.lang.foreign.Linker} interface, as follows:\n- *\n- * {@snippet lang = java:\n- * Arena arena = ...\n- * MemorySegment comparFunc = Linker.nativeLinker().upcallStub(\n- *     intCompareHandle, intCompareDescriptor, arena);\n- * );\n- *}\n- *\n- * The {@link java.lang.foreign.FunctionDescriptor} instance created in the previous step is then used to\n- * {@linkplain java.lang.foreign.Linker#upcallStub(java.lang.invoke.MethodHandle, FunctionDescriptor, Arena, Linker.Option...) create}\n- * a new upcall stub; the layouts in the function descriptors allow the linker to determine the sequence of steps which\n- * allow foreign code to call the stub for {@code intCompareHandle} according to the rules specified by the ABI of the\n- * underlying platform.\n- * The lifecycle of the upcall stub is tied to the {@linkplain java.lang.foreign.Arena arena}\n- * provided when the upcall stub is created. If the provided arena is a confined arena,\n- * the upcall stub will be deallocated when the confined arena is {@linkplain java.lang.foreign.Arena#close() closed}.\n- *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":30,"deletions":111,"binary":false,"changes":141,"status":"modified"}]}