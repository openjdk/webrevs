{"files":[{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import jdk.internal.foreign.abi.fallback.FallbackLinker;\n+import jdk.internal.vm.ForeignLinkerSupport;\n+\n@@ -37,0 +40,1 @@\n+<<<<<<< HEAD\n@@ -38,0 +42,5 @@\n+=======\n+    LINUX_RISCV_64,\n+    FALLBACK,\n+    UNSUPPORTED;\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -39,4 +48,1 @@\n-    private static final CABI ABI;\n-    private static final String ARCH;\n-    private static final String OS;\n-    private static final long ADDRESS_SIZE;\n+    private static final CABI CURRENT = computeCurrent();\n@@ -44,0 +50,1 @@\n+<<<<<<< HEAD\n@@ -75,0 +82,37 @@\n+=======\n+    private static CABI computeCurrent() {\n+        String abi = privilegedGetProperty(\"jdk.internal.foreign.CABI\");\n+        if (abi != null) {\n+            return CABI.valueOf(abi);\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n+        }\n+\n+        if (ForeignLinkerSupport.isSupported()) {\n+            \/\/ figure out the ABI based on the platform\n+            String arch = privilegedGetProperty(\"os.arch\");\n+            String os = privilegedGetProperty(\"os.name\");\n+            long addressSize = ADDRESS.bitSize();\n+            \/\/ might be running in a 32-bit VM on a 64-bit platform.\n+            \/\/ addressSize will be correctly 32\n+            if ((arch.equals(\"amd64\") || arch.equals(\"x86_64\")) && addressSize == 64) {\n+                if (os.startsWith(\"Windows\")) {\n+                    return WIN_64;\n+                } else {\n+                    return SYS_V;\n+                }\n+            } else if (arch.equals(\"aarch64\")) {\n+                if (os.startsWith(\"Mac\")) {\n+                    return MAC_OS_AARCH_64;\n+                } else if (os.startsWith(\"Windows\")) {\n+                    return WIN_AARCH_64;\n+                } else {\n+                    \/\/ The Linux ABI follows the standard AAPCS ABI\n+                    return LINUX_AARCH_64;\n+                }\n+            } else if (arch.equals(\"riscv64\")) {\n+                if (os.startsWith(\"Linux\")) {\n+                    return LINUX_RISCV_64;\n+                }\n+            }\n+        } else if (FallbackLinker.isSupported()) {\n+            return FALLBACK; \/\/ fallback linker\n@@ -76,0 +120,2 @@\n+\n+        return UNSUPPORTED;\n@@ -79,5 +125,1 @@\n-        if (ABI == null) {\n-            throw new UnsupportedOperationException(\n-                    \"Unsupported os, arch, or address size: \" + OS + \", \" + ARCH + \", \" + ADDRESS_SIZE);\n-        }\n-        return ABI;\n+        return CURRENT;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":52,"deletions":10,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.*;\n@@ -50,1 +48,4 @@\n-    private static final SymbolLookup FALLBACK_LOOKUP = name -> Optional.empty();\n+    private static final SymbolLookup FALLBACK_LOOKUP = name -> {\n+        Objects.requireNonNull(name);\n+        return Optional.empty();\n+    };\n@@ -60,0 +61,1 @@\n+<<<<<<< HEAD\n@@ -64,0 +66,7 @@\n+=======\n+            if (Utils.IS_WINDOWS) {\n+                return makeWindowsLookup();\n+            } else {\n+                return libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n+            }\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -87,3 +96,2 @@\n-            int numSymbols = WindowsFallbackSymbols.values().length;\n-            MemorySegment funcs = MemorySegment.ofAddress(fallbackLibLookup.find(\"funcs\").orElseThrow().address(),\n-                ADDRESS.byteSize() * numSymbols, SegmentScope.global());\n+            MemorySegment funcs = fallbackLibLookup.find(\"funcs\").orElseThrow()\n+                    .reinterpret(WindowsFallbackSymbols.LAYOUT.byteSize());\n@@ -92,1 +100,1 @@\n-                .map(symbol -> MemorySegment.ofAddress(funcs.getAtIndex(ADDRESS, symbol.ordinal()).address(), 0L, SegmentScope.global()));\n+                .map(symbol -> funcs.getAtIndex(ADDRESS, symbol.ordinal()));\n@@ -95,1 +103,4 @@\n-            lookup = name -> finalLookup.find(name).or(() -> fallbackLookup.apply(name));\n+            lookup = name -> {\n+                Objects.requireNonNull(name);\n+                return finalLookup.find(name).or(() -> fallbackLookup.apply(name));\n+            };\n@@ -109,1 +120,1 @@\n-                        Optional.of(MemorySegment.ofAddress(addr, 0, SegmentScope.global()));\n+                        Optional.of(MemorySegment.ofAddress(addr));\n@@ -121,0 +132,1 @@\n+<<<<<<< HEAD\n@@ -125,0 +137,3 @@\n+=======\n+        String lib = Utils.IS_WINDOWS ? \"bin\" : \"lib\";\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -205,0 +220,3 @@\n+\n+        static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(\n+                values().length, ADDRESS);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":28,"deletions":10,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+<<<<<<< HEAD\n+=======\n+import jdk.internal.foreign.abi.fallback.FallbackLinker;\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -38,1 +42,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -48,0 +52,1 @@\n+<<<<<<< HEAD\n@@ -49,0 +54,9 @@\n+=======\n+                                                                      SysVx64Linker, WindowsAArch64Linker,\n+                                                                      Windowsx64Linker, LinuxRISCV64Linker,\n+                                                                      FallbackLinker {\n+\n+    public interface UpcallStubFactory {\n+        MemorySegment makeStub(MethodHandle target, Arena arena);\n+    }\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -52,0 +66,1 @@\n+    private final SoftReferenceCache<LinkRequest, UpcallStubFactory> UPCALL_CACHE = new SoftReferenceCache<>();\n@@ -71,2 +86,2 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, SegmentScope scope) {\n-        Objects.requireNonNull(scope);\n+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, Arena arena, Linker.Option... options) {\n+        Objects.requireNonNull(arena);\n@@ -77,0 +92,1 @@\n+        LinkerOptions optionSet = LinkerOptions.forUpcall(function, options);\n@@ -82,1 +98,4 @@\n-        return arrangeUpcall(target, target.type(), function, scope);\n+\n+        UpcallStubFactory factory = UPCALL_CACHE.get(new LinkRequest(function, optionSet), linkRequest ->\n+            arrangeUpcall(type, linkRequest.descriptor(), linkRequest.options()));\n+        return factory.makeStub(target, arena);\n@@ -85,2 +104,1 @@\n-    protected abstract MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType,\n-                                                   FunctionDescriptor function, SegmentScope scope);\n+    protected abstract UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -29,3 +29,0 @@\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.StructLayout;\n-import java.util.Comparator;\n@@ -36,0 +33,1 @@\n+import java.util.function.BiConsumer;\n@@ -48,1 +46,10 @@\n-        Map<Class<?>, LinkerOptionImpl> optionMap = new HashMap<>();\n+        return forShared(LinkerOptionImpl::validateForDowncall, desc, options);\n+    }\n+\n+    public static LinkerOptions forUpcall(FunctionDescriptor desc, Linker.Option[] options) {\n+        return forShared(LinkerOptionImpl::validateForUpcall, desc, options);\n+    }\n+\n+    private static LinkerOptions forShared(BiConsumer<LinkerOptionImpl, FunctionDescriptor> validator,\n+                                           FunctionDescriptor desc, Linker.Option... options) {\n+       Map<Class<?>, LinkerOptionImpl> optionMap = new HashMap<>();\n@@ -55,1 +62,1 @@\n-            opImpl.validateForDowncall(desc);\n+            validator.accept(opImpl, desc);\n@@ -76,1 +83,1 @@\n-        return getOption(CaptureCallStateImpl.class) != null;\n+        return getOption(CaptureCallState.class) != null;\n@@ -80,1 +87,1 @@\n-        CaptureCallStateImpl stl = getOption(CaptureCallStateImpl.class);\n+        CaptureCallState stl = getOption(CaptureCallState.class);\n@@ -89,0 +96,13 @@\n+<<<<<<< HEAD\n+=======\n+    public boolean isTrivial() {\n+        IsTrivial it = getOption(IsTrivial.class);\n+        return it != null;\n+    }\n+\n+    public Thread.UncaughtExceptionHandler uncaughtExceptionHandler() {\n+        UncaughtExceptionHandler ueh = getOption(UncaughtExceptionHandler.class);\n+        return ueh != null ? ueh.handler() : null;\n+    }\n+\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -102,2 +122,1 @@\n-                                             permits FirstVariadicArg,\n-                                                     CaptureCallStateImpl {\n+            permits CaptureCallState, FirstVariadicArg, IsTrivial, UncaughtExceptionHandler {\n@@ -107,0 +126,4 @@\n+\n+        default void validateForUpcall(FunctionDescriptor descriptor) {\n+            throw new IllegalArgumentException(\"Not supported for upcall: \" + this);\n+        }\n@@ -118,2 +141,1 @@\n-    public record CaptureCallStateImpl(Set<CapturableState> saved) implements LinkerOptionImpl, Linker.Option.CaptureCallState {\n-\n+    public record CaptureCallState(Set<CapturableState> saved) implements LinkerOptionImpl {\n@@ -124,0 +146,4 @@\n+    }\n+\n+    public record IsTrivial() implements LinkerOptionImpl {\n+        public static IsTrivial INSTANCE = new IsTrivial();\n@@ -126,7 +152,2 @@\n-        public StructLayout layout() {\n-            return MemoryLayout.structLayout(\n-                saved.stream()\n-                      .sorted(Comparator.comparingInt(CapturableState::ordinal))\n-                      .map(CapturableState::layout)\n-                      .toArray(MemoryLayout[]::new)\n-            );\n+        public void validateForDowncall(FunctionDescriptor descriptor) {\n+            \/\/ always allowed\n@@ -136,0 +157,6 @@\n+    public record UncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler) implements LinkerOptionImpl {\n+        @Override\n+        public void validateForUpcall(FunctionDescriptor descriptor) {\n+            \/\/ always allowed\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":45,"deletions":18,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker.UpcallStubFactory;\n@@ -34,0 +35,4 @@\n+<<<<<<< HEAD\n+=======\n+import jdk.internal.foreign.abi.fallback.FallbackLinker;\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -39,0 +44,1 @@\n+import java.lang.foreign.Arena;\n@@ -44,1 +50,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.MemorySegment.Scope;\n@@ -46,1 +52,0 @@\n-import java.lang.foreign.VaList;\n@@ -53,0 +58,1 @@\n+import java.nio.ByteOrder;\n@@ -56,1 +62,0 @@\n-import java.util.NoSuchElementException;\n@@ -58,1 +63,0 @@\n-import java.util.function.Consumer;\n@@ -77,0 +81,22 @@\n+    public static final MethodHandle MH_CHECK_SYMBOL;\n+\n+    public static final ValueLayout.OfAddress C_POINTER = ADDRESS\n+            .withBitAlignment(64)\n+            .withTargetLayout(MemoryLayout.sequenceLayout(JAVA_BYTE));\n+\n+    public static final Arena DUMMY_ARENA = new Arena() {\n+        @Override\n+        public Scope scope() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void close() {\n+            \/\/ do nothing\n+        }\n+    };\n@@ -87,0 +113,2 @@\n+            MH_CHECK_SYMBOL = lookup.findStatic(SharedUtils.class, \"checkSymbol\",\n+                    methodType(void.class, MemorySegment.class));\n@@ -139,1 +167,1 @@\n-    public static MethodHandle adaptUpcallForIMR(MethodHandle target, boolean dropReturn) {\n+    private static MethodHandle adaptUpcallForIMR(MethodHandle target, boolean dropReturn) {\n@@ -156,0 +184,21 @@\n+    public static UpcallStubFactory arrangeUpcallHelper(MethodType targetType, boolean isInMemoryReturn, boolean dropReturn,\n+                                                        ABIDescriptor abi, CallingSequence callingSequence) {\n+        if (isInMemoryReturn) {\n+            \/\/ simulate the adaptation to get the type\n+            MethodHandle fakeTarget = MethodHandles.empty(targetType);\n+            targetType = adaptUpcallForIMR(fakeTarget, dropReturn).type();\n+        }\n+\n+        UpcallStubFactory factory = UpcallLinker.makeFactory(targetType, abi, callingSequence);\n+\n+        if (isInMemoryReturn) {\n+            final UpcallStubFactory finalFactory = factory;\n+            factory = (target, scope) -> {\n+                target = adaptUpcallForIMR(target, dropReturn);\n+                return finalFactory.makeStub(target, scope);\n+            };\n+        }\n+\n+        return factory;\n+    }\n+\n@@ -161,0 +210,4 @@\n+        return primitiveLayoutForSize(size, useFloat).carrier();\n+    }\n+\n+    public static ValueLayout primitiveLayoutForSize(long size, boolean useFloat) {\n@@ -163,1 +216,1 @@\n-                return float.class;\n+                return JAVA_FLOAT;\n@@ -165,1 +218,1 @@\n-                return double.class;\n+                return JAVA_DOUBLE;\n@@ -169,1 +222,1 @@\n-                return byte.class;\n+                return JAVA_BYTE;\n@@ -171,1 +224,1 @@\n-                return short.class;\n+                return JAVA_SHORT;\n@@ -173,1 +226,1 @@\n-                return int.class;\n+                return JAVA_INT;\n@@ -175,1 +228,1 @@\n-                return long.class;\n+                return JAVA_LONG;\n@@ -179,1 +232,1 @@\n-        throw new IllegalArgumentException(\"No type for size: \" + size + \" isFloat=\" + useFloat);\n+        throw new IllegalArgumentException(\"No layout for size: \" + size + \" isFloat=\" + useFloat);\n@@ -190,0 +243,2 @@\n+            case FALLBACK -> FallbackLinker.getInstance();\n+            case UNSUPPORTED -> throw new UnsupportedOperationException(\"Platform does not support native linker\");\n@@ -241,1 +296,1 @@\n-    static MethodHandle swapArguments(MethodHandle mh, int firstArg, int secondArg) {\n+    public static MethodHandle swapArguments(MethodHandle mh, int firstArg, int secondArg) {\n@@ -259,1 +314,1 @@\n-    static void handleUncaughtException(Throwable t) {\n+    public static void handleUncaughtException(Throwable t, Thread.UncaughtExceptionHandler handler) {\n@@ -261,2 +316,10 @@\n-            t.printStackTrace();\n-            JLA.exit(1);\n+            try {\n+                Thread currentThread = Thread.currentThread();\n+                if (handler == null) {\n+                     handler = currentThread.getUncaughtExceptionHandler();\n+                }\n+                handler.uncaughtException(currentThread, t);\n+            } finally {\n+                System.err.println(\"Unrecoverable uncaught exception encountered. The VM will now exit\");\n+                JLA.exit(1);\n+            }\n@@ -295,0 +358,1 @@\n+<<<<<<< HEAD\n@@ -328,0 +392,2 @@\n+=======\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -335,2 +401,2 @@\n-    public static NoSuchElementException newVaListNSEE(MemoryLayout layout) {\n-        return new NoSuchElementException(\"No such element: \" + layout);\n+    public static boolean isPowerOfTwo(int width) {\n+        return Integer.bitCount(width) == 1;\n@@ -339,12 +405,4 @@\n-    public static final class SimpleVaArg {\n-        public final MemoryLayout layout;\n-        public final Object value;\n-\n-        public SimpleVaArg(MemoryLayout layout, Object value) {\n-            this.layout = layout;\n-            this.value = value;\n-        }\n-\n-        public VarHandle varHandle() {\n-            return layout.varHandle();\n-        }\n+    static long pickChunkOffset(long chunkOffset, long byteWidth, int chunkWidth) {\n+        return ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN\n+                ? byteWidth - chunkWidth - chunkOffset\n+                : chunkOffset;\n@@ -353,3 +411,4 @@\n-    public static final class EmptyVaList implements VaList {\n-\n-        private final MemorySegment address;\n+    public static Arena newBoundedArena(long size) {\n+        return new Arena() {\n+            final Arena arena = Arena.ofConfined();\n+            final SegmentAllocator slicingAllocator = SegmentAllocator.slicingAllocator(arena.allocate(size));\n@@ -357,3 +416,4 @@\n-        public EmptyVaList(MemorySegment address) {\n-            this.address = address;\n-        }\n+            @Override\n+            public Scope scope() {\n+                return arena.scope();\n+            }\n@@ -361,3 +421,4 @@\n-        private static UnsupportedOperationException uoe() {\n-            return new UnsupportedOperationException(\"Empty VaList\");\n-        }\n+            @Override\n+            public void close() {\n+                arena.close();\n+            }\n@@ -365,4 +426,6 @@\n-        @Override\n-        public int nextVarg(ValueLayout.OfInt layout) {\n-            throw uoe();\n-        }\n+            @Override\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                return slicingAllocator.allocate(byteSize, byteAlignment);\n+            }\n+        };\n+    }\n@@ -370,4 +433,3 @@\n-        @Override\n-        public long nextVarg(ValueLayout.OfLong layout) {\n-            throw uoe();\n-        }\n+    public static Arena newEmptyArena() {\n+        return new Arena() {\n+            final Arena arena = Arena.ofConfined();\n@@ -375,4 +437,4 @@\n-        @Override\n-        public double nextVarg(ValueLayout.OfDouble layout) {\n-            throw uoe();\n-        }\n+            @Override\n+            public Scope scope() {\n+                return arena.scope();\n+            }\n@@ -380,4 +442,4 @@\n-        @Override\n-        public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-            throw uoe();\n-        }\n+            @Override\n+            public void close() {\n+                arena.close();\n+            }\n@@ -385,4 +447,6 @@\n-        @Override\n-        public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n-            throw uoe();\n-        }\n+            @Override\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+    }\n@@ -390,4 +454,3 @@\n-        @Override\n-        public void skip(MemoryLayout... layouts) {\n-            throw uoe();\n-        }\n+    public static final class SimpleVaArg {\n+        public final MemoryLayout layout;\n+        public final Object value;\n@@ -395,3 +458,3 @@\n-        @Override\n-        public VaList copy() {\n-            return this;\n+        public SimpleVaArg(MemoryLayout layout, Object value) {\n+            this.layout = layout;\n+            this.value = value;\n@@ -400,3 +463,2 @@\n-        @Override\n-        public MemorySegment segment() {\n-            return address;\n+        public VarHandle varHandle() {\n+            return layout.varHandle();\n@@ -430,1 +492,1 @@\n-    static void write(MemorySegment ptr, Class<?> type, Object o) {\n+    static void write(MemorySegment ptr, long offset, Class<?> type, Object o) {\n@@ -432,1 +494,1 @@\n-            ptr.set(JAVA_LONG_UNALIGNED, 0, (long) o);\n+            ptr.set(JAVA_LONG_UNALIGNED, offset, (long) o);\n@@ -434,1 +496,1 @@\n-            ptr.set(JAVA_INT_UNALIGNED, 0, (int) o);\n+            ptr.set(JAVA_INT_UNALIGNED, offset, (int) o);\n@@ -436,1 +498,1 @@\n-            ptr.set(JAVA_SHORT_UNALIGNED, 0, (short) o);\n+            ptr.set(JAVA_SHORT_UNALIGNED, offset, (short) o);\n@@ -438,1 +500,1 @@\n-            ptr.set(JAVA_CHAR_UNALIGNED, 0, (char) o);\n+            ptr.set(JAVA_CHAR_UNALIGNED, offset, (char) o);\n@@ -440,1 +502,1 @@\n-            ptr.set(JAVA_BYTE, 0, (byte) o);\n+            ptr.set(JAVA_BYTE, offset, (byte) o);\n@@ -442,1 +504,1 @@\n-            ptr.set(JAVA_FLOAT_UNALIGNED, 0, (float) o);\n+            ptr.set(JAVA_FLOAT_UNALIGNED, offset, (float) o);\n@@ -444,1 +506,1 @@\n-            ptr.set(JAVA_DOUBLE_UNALIGNED, 0, (double) o);\n+            ptr.set(JAVA_DOUBLE_UNALIGNED, offset, (double) o);\n@@ -446,1 +508,1 @@\n-            ptr.set(JAVA_BOOLEAN, 0, (boolean) o);\n+            ptr.set(JAVA_BOOLEAN, offset, (boolean) o);\n@@ -452,1 +514,1 @@\n-    static Object read(MemorySegment ptr, Class<?> type) {\n+    static Object read(MemorySegment ptr, long offset, Class<?> type) {\n@@ -454,1 +516,1 @@\n-            return ptr.get(JAVA_LONG_UNALIGNED, 0);\n+            return ptr.get(JAVA_LONG_UNALIGNED, offset);\n@@ -456,1 +518,1 @@\n-            return ptr.get(JAVA_INT_UNALIGNED, 0);\n+            return ptr.get(JAVA_INT_UNALIGNED, offset);\n@@ -458,1 +520,1 @@\n-            return ptr.get(JAVA_SHORT_UNALIGNED, 0);\n+            return ptr.get(JAVA_SHORT_UNALIGNED, offset);\n@@ -460,1 +522,1 @@\n-            return ptr.get(JAVA_CHAR_UNALIGNED, 0);\n+            return ptr.get(JAVA_CHAR_UNALIGNED, offset);\n@@ -462,1 +524,1 @@\n-            return ptr.get(JAVA_BYTE, 0);\n+            return ptr.get(JAVA_BYTE, offset);\n@@ -464,1 +526,1 @@\n-            return ptr.get(JAVA_FLOAT_UNALIGNED, 0);\n+            return ptr.get(JAVA_FLOAT_UNALIGNED, offset);\n@@ -466,1 +528,1 @@\n-            return ptr.get(JAVA_DOUBLE_UNALIGNED, 0);\n+            return ptr.get(JAVA_DOUBLE_UNALIGNED, offset);\n@@ -468,1 +530,1 @@\n-            return ptr.get(JAVA_BOOLEAN, 0);\n+            return ptr.get(JAVA_BOOLEAN, offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":150,"deletions":88,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker.UpcallStubFactory;\n@@ -46,1 +47,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.ValueLayout;\n@@ -52,1 +53,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n@@ -68,0 +68,1 @@\n+    private static final int MAX_COPY_SIZE = 8;\n@@ -82,0 +83,1 @@\n+<<<<<<< HEAD\n@@ -83,0 +85,3 @@\n+=======\n+    \/\/ r2-7 and v4-7 so, they are omitted here.\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -158,1 +163,1 @@\n-            csb.addArgumentBindings(MemorySegment.class, AArch64.C_POINTER,\n+            csb.addArgumentBindings(MemorySegment.class, SharedUtils.C_POINTER,\n@@ -190,0 +195,1 @@\n+<<<<<<< HEAD\n@@ -198,0 +204,8 @@\n+=======\n+    public UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc,\n+                                                          LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, true, options);\n+        final boolean dropReturn = true; \/* drop return, since we don't have bindings for it *\/\n+        return SharedUtils.arrangeUpcallHelper(mt, bindings.isInMemoryReturn, dropReturn, abiDescriptor(),\n+                bindings.callingSequence);\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -220,2 +234,2 @@\n-        void alignStack(long alignment) {\n-            stackOffset = Utils.alignUp(stackOffset, alignment);\n+        private boolean hasRegister(int type) {\n+            return hasEnoughRegisters(type, 1);\n@@ -224,3 +238,12 @@\n-        VMStorage stackAlloc(long size, long alignment) {\n-            assert forArguments : \"no stack returns\";\n-            long alignedStackOffset = Utils.alignUp(stackOffset, alignment);\n+        private boolean hasEnoughRegisters(int type, int count) {\n+            return nRegs[type] + count <= MAX_REGISTER_ARGUMENTS;\n+        }\n+\n+        private static Class<?> adjustCarrierForStack(Class<?> carrier) {\n+            if (carrier == float.class) {\n+                carrier = int.class;\n+            } else if (carrier == double.class) {\n+                carrier = long.class;\n+            }\n+            return carrier;\n+        }\n@@ -228,2 +251,38 @@\n-            short encodedSize = (short) size;\n-            assert (encodedSize & 0xFFFF) == size;\n+        record StructStorage(long offset, Class<?> carrier, int byteWidth, VMStorage storage) {}\n+\n+        \/*\n+        In the simplest case structs are copied in chunks. i.e. the fields don't matter, just the size.\n+        The struct is split into 8-byte chunks, and those chunks are either passed in registers and\/or on the stack.\n+\n+        Homogeneous float aggregates (HFAs) can be copied in a field-wise manner, i.e. the struct is split into it's\n+        fields and those fields are the chunks which are passed. For HFAs the rules are more complicated and ABI based:\n+\n+                        | enough registers | some registers, but not enough  | no registers\n+        ----------------+------------------+---------------------------------+-------------------------\n+        Linux           | FW in regs       | CW on the stack                 | CW on the stack\n+        MacOs, non-VA   | FW in regs       | FW on the stack                 | FW on the stack\n+        MacOs, VA       | FW in regs       | CW on the stack                 | CW on the stack\n+        Windows, non-VF | FW in regs       | CW on the stack                 | CW on the stack\n+        Windows, VF     | FW in regs       | CW split between regs and stack | CW on the stack\n+        (where FW = Field-wise copy, CW = Chunk-wise copy, VA is a variadic argument, and VF is a variadic function)\n+\n+        For regular structs, the rules are as follows:\n+\n+                        | enough registers | some registers, but not enough  | no registers\n+        ----------------+------------------+---------------------------------+-------------------------\n+        Linux           | CW in regs       | CW on the stack                 | CW on the stack\n+        MacOs           | CW in regs       | CW on the stack                 | CW on the stack\n+        Windows, non-VF | CW in regs       | CW on the stack                 | CW on the stack\n+        Windows, VF     | CW in regs       | CW split between regs and stack | CW on the stack\n+         *\/\n+        StructStorage[] structStorages(GroupLayout layout, boolean forHFA) {\n+            int numChunks = (int)Utils.alignUp(layout.byteSize(), MAX_COPY_SIZE) \/ MAX_COPY_SIZE;\n+\n+            int regType = StorageType.INTEGER;\n+            List<MemoryLayout> scalarLayouts = null;\n+            int requiredStorages = numChunks;\n+            if (forHFA) {\n+                regType = StorageType.VECTOR;\n+                scalarLayouts = TypeClass.scalarLayouts(layout);\n+                requiredStorages = scalarLayouts.size();\n+            }\n@@ -231,4 +290,60 @@\n-            VMStorage storage =\n-                AArch64Architecture.stackStorage(encodedSize, (int)alignedStackOffset);\n-            stackOffset = alignedStackOffset + size;\n-            return storage;\n+            boolean hasEnoughRegisters = hasEnoughRegisters(regType, requiredStorages);\n+\n+            \/\/ For the ABI variants that pack arguments spilled to the\n+            \/\/ stack, HFA arguments are spilled as if their individual\n+            \/\/ fields had been allocated separately rather than as if the\n+            \/\/ struct had been spilled as a whole.\n+            boolean useFieldWiseSpill = requiresSubSlotStackPacking() && !forVarArgs;\n+            boolean isFieldWise = forHFA && (hasEnoughRegisters || useFieldWiseSpill);\n+            if (!isFieldWise) {\n+                requiredStorages = numChunks;\n+            }\n+\n+            boolean spillPartially = forVariadicFunction && spillsVariadicStructsPartially();\n+            boolean furtherAllocationFromTheStack = !hasEnoughRegisters && !spillPartially;\n+            if (furtherAllocationFromTheStack) {\n+                \/\/ Any further allocations for this register type must\n+                \/\/ be from the stack.\n+                nRegs[regType] = MAX_REGISTER_ARGUMENTS;\n+            }\n+\n+            if (requiresSubSlotStackPacking() && !isFieldWise) {\n+                \/\/ Pad to the next stack slot boundary instead of packing\n+                \/\/ additional arguments into the unused space.\n+                alignStack(STACK_SLOT_SIZE);\n+            }\n+\n+            StructStorage[] structStorages = new StructStorage[requiredStorages];\n+            long offset = 0;\n+            for (int i = 0; i < structStorages.length; i++) {\n+                ValueLayout copyLayout;\n+                long copySize;\n+                if (isFieldWise) {\n+                    \/\/ We should only get here for HFAs, which can't have padding\n+                    copyLayout = (ValueLayout) scalarLayouts.get(i);\n+                    copySize = Utils.byteWidthOfPrimitive(copyLayout.carrier());\n+                } else {\n+                    \/\/ chunk-wise copy\n+                    copySize = Math.min(layout.byteSize() - offset, MAX_COPY_SIZE);\n+                    boolean useFloat = false; \/\/ never use float for chunk-wise copies\n+                    copyLayout = SharedUtils.primitiveLayoutForSize(copySize, useFloat);\n+                }\n+\n+                VMStorage storage = nextStorage(regType, copyLayout);\n+                Class<?> carrier = copyLayout.carrier();\n+                if (isFieldWise && storage.type() == StorageType.STACK) {\n+                    \/\/ copyLayout is a field of an HFA\n+                    \/\/ Don't use floats on the stack\n+                    carrier = adjustCarrierForStack(carrier);\n+                }\n+                structStorages[i] = new StructStorage(offset, carrier, (int) copySize, storage);\n+                offset += copyLayout.byteSize();\n+            }\n+\n+            if (requiresSubSlotStackPacking() && !isFieldWise) {\n+                \/\/ Pad to the next stack slot boundary instead of packing\n+                \/\/ additional arguments into the unused space.\n+                alignStack(STACK_SLOT_SIZE);\n+            }\n+\n+            return structStorages;\n@@ -237,1 +352,17 @@\n-        VMStorage stackAlloc(MemoryLayout layout) {\n+        private void alignStack(long alignment) {\n+            stackOffset = Utils.alignUp(stackOffset, alignment);\n+        }\n+\n+        \/\/ allocate a single ValueLayout, either in a register or on the stack\n+        VMStorage nextStorage(int type, ValueLayout layout) {\n+            return hasRegister(type) ? regAlloc(type) : stackAlloc(layout);\n+        }\n+\n+        private VMStorage regAlloc(int type) {\n+            ABIDescriptor abiDescriptor = abiDescriptor();\n+            VMStorage[] source = (forArguments ? abiDescriptor.inputStorage : abiDescriptor.outputStorage)[type];\n+            return source[nRegs[type]++];\n+        }\n+\n+        private VMStorage stackAlloc(ValueLayout layout) {\n+            assert forArguments : \"no stack returns\";\n@@ -241,2 +372,1 @@\n-            return stackAlloc(layout.byteSize(), stackSlotAlignment);\n-        }\n+            long alignedStackOffset = Utils.alignUp(stackOffset, stackSlotAlignment);\n@@ -244,0 +374,1 @@\n+<<<<<<< HEAD\n@@ -320,0 +451,8 @@\n+=======\n+            short encodedSize = (short) layout.byteSize();\n+            assert (encodedSize & 0xFFFF) == layout.byteSize();\n+\n+            VMStorage storage = AArch64Architecture.stackStorage(encodedSize, (int)alignedStackOffset);\n+            stackOffset = alignedStackOffset + layout.byteSize();\n+            return storage;\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -336,0 +475,1 @@\n+<<<<<<< HEAD\n@@ -391,0 +531,2 @@\n+=======\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -422,1 +564,1 @@\n-                case STRUCT_REGISTER: {\n+                case STRUCT_REGISTER, STRUCT_HFA -> {\n@@ -424,0 +566,1 @@\n+<<<<<<< HEAD\n@@ -447,0 +590,13 @@\n+=======\n+                    boolean forHFA = argumentClass == TypeClass.STRUCT_HFA;\n+                    StorageCalculator.StructStorage[] structStorages\n+                            = storageCalculator.structStorages((GroupLayout) layout, forHFA);\n+\n+                    for (int i = 0; i < structStorages.length; i++) {\n+                        StorageCalculator.StructStorage structStorage = structStorages[i];\n+                        if (i < structStorages.length - 1) {\n+                            bindings.dup();\n+                        }\n+                        bindings.bufferLoad(structStorage.offset(), structStorage.carrier(), structStorage.byteWidth())\n+                                .vmStore(structStorage.storage(), structStorage.carrier());\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -448,1 +604,0 @@\n-                    break;\n@@ -450,1 +605,1 @@\n-                case STRUCT_REFERENCE: {\n+                case STRUCT_REFERENCE -> {\n@@ -454,2 +609,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(\n-                        StorageType.INTEGER, AArch64.C_POINTER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, SharedUtils.C_POINTER);\n@@ -457,24 +611,0 @@\n-                    break;\n-                }\n-                case STRUCT_HFA: {\n-                    assert carrier == MemorySegment.class;\n-                    GroupLayout group = (GroupLayout)layout;\n-                    VMStorage[] regs = storageCalculator.nextStorageForHFA(group);\n-                    if (regs != null) {\n-                        long offset = 0;\n-                        for (int i = 0; i < group.memberLayouts().size(); i++) {\n-                            VMStorage storage = regs[i];\n-                            final long size = group.memberLayouts().get(i).byteSize();\n-                            boolean useFloat = storage.type() == StorageType.VECTOR;\n-                            Class<?> type = SharedUtils.primitiveCarrierForSize(size, useFloat);\n-                            if (i + 1 < group.memberLayouts().size()) {\n-                                bindings.dup();\n-                            }\n-                            bindings.bufferLoad(offset, type)\n-                                    .vmStore(storage, type);\n-                            offset += size;\n-                        }\n-                    } else {\n-                        spillStructUnbox(bindings, layout);\n-                    }\n-                    break;\n@@ -482,1 +612,1 @@\n-                case POINTER: {\n+                case POINTER -> {\n@@ -484,2 +614,1 @@\n-                    VMStorage storage =\n-                        storageCalculator.nextStorage(StorageType.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, (ValueLayout) layout);\n@@ -487,1 +616,0 @@\n-                    break;\n@@ -489,3 +617,2 @@\n-                case INTEGER: {\n-                    VMStorage storage =\n-                        storageCalculator.nextStorage(StorageType.INTEGER, layout);\n+                case INTEGER -> {\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, (ValueLayout) layout);\n@@ -493,1 +620,0 @@\n-                    break;\n@@ -495,3 +621,6 @@\n-                case FLOAT: {\n-                    VMStorage storage =\n-                        storageCalculator.nextStorage(StorageType.VECTOR, layout);\n+                case FLOAT -> {\n+                    boolean forVariadicFunctionArgs = forArguments && forVariadicFunction;\n+                    boolean useIntReg = forVariadicFunctionArgs && useIntRegsForVariadicFloatingPointArgs();\n+\n+                    int type = useIntReg ? StorageType.INTEGER : StorageType.VECTOR;\n+                    VMStorage storage = storageCalculator.nextStorage(type, (ValueLayout) layout);\n@@ -499,1 +628,0 @@\n-                    break;\n@@ -501,2 +629,1 @@\n-                default:\n-                    throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n+                default -> throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n@@ -517,1 +644,1 @@\n-                .boxAddressRaw(Long.MAX_VALUE)\n+                .boxAddressRaw(Long.MAX_VALUE, 1)\n@@ -526,1 +653,1 @@\n-                case STRUCT_REGISTER -> {\n+                case STRUCT_REGISTER, STRUCT_HFA -> {\n@@ -528,0 +655,1 @@\n+                    boolean forHFA = argumentClass == TypeClass.STRUCT_HFA;\n@@ -529,17 +657,7 @@\n-                    VMStorage[] regs = storageCalculator.regAlloc(\n-                            StorageType.INTEGER, layout);\n-                    if (regs != null) {\n-                        int regIndex = 0;\n-                        long offset = 0;\n-                        while (offset < layout.byteSize()) {\n-                            final long copy = Math.min(layout.byteSize() - offset, 8);\n-                            VMStorage storage = regs[regIndex++];\n-                            bindings.dup();\n-                            boolean useFloat = storage.type() == StorageType.VECTOR;\n-                            Class<?> type = SharedUtils.primitiveCarrierForSize(copy, useFloat);\n-                            bindings.vmLoad(storage, type)\n-                                    .bufferStore(offset, type);\n-                            offset += copy;\n-                        }\n-                    } else {\n-                        spillStructBox(bindings, layout);\n+                    StorageCalculator.StructStorage[] structStorages\n+                            = storageCalculator.structStorages((GroupLayout) layout, forHFA);\n+\n+                    for (StorageCalculator.StructStorage structStorage : structStorages) {\n+                        bindings.dup();\n+                        bindings.vmLoad(structStorage.storage(), structStorage.carrier())\n+                                .bufferStore(structStorage.offset(), structStorage.carrier(), structStorage.byteWidth());\n@@ -550,2 +668,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(\n-                            StorageType.INTEGER, AArch64.C_POINTER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, SharedUtils.C_POINTER);\n@@ -555,21 +672,0 @@\n-                case STRUCT_HFA -> {\n-                    assert carrier == MemorySegment.class;\n-                    bindings.allocate(layout);\n-                    GroupLayout group = (GroupLayout) layout;\n-                    VMStorage[] regs = storageCalculator.nextStorageForHFA(group);\n-                    if (regs != null) {\n-                        long offset = 0;\n-                        for (int i = 0; i < group.memberLayouts().size(); i++) {\n-                            VMStorage storage = regs[i];\n-                            final long size = group.memberLayouts().get(i).byteSize();\n-                            boolean useFloat = storage.type() == StorageType.VECTOR;\n-                            Class<?> type = SharedUtils.primitiveCarrierForSize(size, useFloat);\n-                            bindings.dup()\n-                                    .vmLoad(storage, type)\n-                                    .bufferStore(offset, type);\n-                            offset += size;\n-                        }\n-                    } else {\n-                        spillStructBox(bindings, layout);\n-                    }\n-                }\n@@ -577,2 +673,2 @@\n-                    VMStorage storage =\n-                            storageCalculator.nextStorage(StorageType.INTEGER, layout);\n+                    ValueLayout.OfAddress addressLayout = (ValueLayout.OfAddress)layout;\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, addressLayout);\n@@ -580,1 +676,1 @@\n-                            .boxAddressRaw(Utils.pointeeSize(layout));\n+                            .boxAddressRaw(Utils.pointeeByteSize(addressLayout), Utils.pointeeByteAlign(addressLayout));\n@@ -583,2 +679,1 @@\n-                    VMStorage storage =\n-                            storageCalculator.nextStorage(StorageType.INTEGER, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, (ValueLayout) layout);\n@@ -588,2 +683,1 @@\n-                    VMStorage storage =\n-                            storageCalculator.nextStorage(StorageType.VECTOR, layout);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.VECTOR, (ValueLayout) layout);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":204,"deletions":110,"binary":false,"changes":314,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+<<<<<<< HEAD\n@@ -40,0 +41,4 @@\n+=======\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -61,0 +66,1 @@\n+<<<<<<< HEAD\n@@ -79,1 +85,8 @@\n-}\n\\ No newline at end of file\n+}\n+=======\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return  CallArranger.WINDOWS.arrangeUpcall(targetType, function, options);\n+    }\n+\n+}\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @compile platform\/PlatformLayouts.java\n@@ -53,1 +54,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.AArch64.*;\n@@ -57,0 +57,1 @@\n+import static platform.PlatformLayouts.AArch64.*;\n@@ -429,0 +430,53 @@\n+<<<<<<< HEAD\n+=======\n+\n+    @Test\n+    public void testFloatArrayStruct() {\n+        \/\/ should be classified as HFA\n+        StructLayout S10 = MemoryLayout.structLayout(\n+                MemoryLayout.sequenceLayout(4, C_DOUBLE)\n+        );\n+        MethodType mt = MethodType.methodType(MemorySegment.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.of(S10, S10);\n+        FunctionDescriptor fdExpected = FunctionDescriptor.of(S10, ADDRESS, ADDRESS, S10); \/\/ uses return buffer\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        \/\/ This is identical to the non-variadic calling sequence\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { dup(),\n+                bufferLoad(0, double.class),\n+                vmStore(v0, double.class),\n+              dup(),\n+                bufferLoad(8, double.class),\n+                vmStore(v1, double.class),\n+              dup(),\n+                bufferLoad(16, double.class),\n+                vmStore(v2, double.class),\n+                bufferLoad(24, double.class),\n+                vmStore(v3, double.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{\n+            allocate(S10),\n+              dup(),\n+                 vmLoad(v0, double.class),\n+                 bufferStore(0, double.class),\n+              dup(),\n+                 vmLoad(v1, double.class),\n+                 bufferStore(8, double.class),\n+              dup(),\n+                 vmLoad(v2, double.class),\n+                 bufferStore(16, double.class),\n+              dup(),\n+                 vmLoad(v3, double.class),\n+                 bufferStore(24, double.class),\n+        });\n+    }\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLinuxAArch64CallArranger.java","additions":56,"deletions":2,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+<<<<<<< HEAD\n@@ -3,0 +4,3 @@\n+=======\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -28,0 +32,5 @@\n+<<<<<<< HEAD\n+=======\n+ * @requires sun.arch.data.model == \"64\"\n+ * @compile platform\/PlatformLayouts.java\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -52,0 +61,1 @@\n+<<<<<<< HEAD\n@@ -56,0 +66,6 @@\n+=======\n+import static jdk.internal.foreign.abi.Binding.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.Regs.*;\n+import static platform.PlatformLayouts.AArch64.*;\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -283,0 +299,112 @@\n+<<<<<<< HEAD\n+=======\n+\n+    \/\/ structs that are passed field-wise should not have padding after them\n+    @Test\n+    public void testMacArgsOnStack5() {\n+        StructLayout struct = MemoryLayout.structLayout(\n+            C_FLOAT\n+        );\n+        MethodType mt = MethodType.methodType(void.class,\n+                long.class, long.class, long.class, long.class,\n+                long.class, long.class, long.class, long.class,\n+                double.class, double.class, double.class, double.class,\n+                double.class, double.class, double.class, double.class,\n+                MemorySegment.class, int.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                struct, C_INT, C_POINTER);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, long.class) },\n+            { vmStore(r1, long.class) },\n+            { vmStore(r2, long.class) },\n+            { vmStore(r3, long.class) },\n+            { vmStore(r4, long.class) },\n+            { vmStore(r5, long.class) },\n+            { vmStore(r6, long.class) },\n+            { vmStore(r7, long.class) },\n+            { vmStore(v0, double.class) },\n+            { vmStore(v1, double.class) },\n+            { vmStore(v2, double.class) },\n+            { vmStore(v3, double.class) },\n+            { vmStore(v4, double.class) },\n+            { vmStore(v5, double.class) },\n+            { vmStore(v6, double.class) },\n+            { vmStore(v7, double.class) },\n+            {\n+                bufferLoad(0, int.class),\n+                vmStore(stackStorage((short) 4, 0), int.class),\n+            },\n+            { vmStore(stackStorage((short) 4, 4), int.class) },\n+            { unboxAddress(), vmStore(stackStorage((short) 8, 8), long.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    \/\/ structs that are passed chunk-wise should have padding before them, as well as after\n+    @Test\n+    public void testMacArgsOnStack6() {\n+        StructLayout struct = MemoryLayout.structLayout(\n+            C_INT\n+        );\n+        MethodType mt = MethodType.methodType(void.class,\n+                long.class, long.class, long.class, long.class,\n+                long.class, long.class, long.class, long.class,\n+                double.class, double.class, double.class, double.class,\n+                double.class, double.class, double.class, double.class,\n+                int.class, MemorySegment.class, double.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_INT, struct, C_DOUBLE, C_POINTER);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, long.class) },\n+            { vmStore(r1, long.class) },\n+            { vmStore(r2, long.class) },\n+            { vmStore(r3, long.class) },\n+            { vmStore(r4, long.class) },\n+            { vmStore(r5, long.class) },\n+            { vmStore(r6, long.class) },\n+            { vmStore(r7, long.class) },\n+            { vmStore(v0, double.class) },\n+            { vmStore(v1, double.class) },\n+            { vmStore(v2, double.class) },\n+            { vmStore(v3, double.class) },\n+            { vmStore(v4, double.class) },\n+            { vmStore(v5, double.class) },\n+            { vmStore(v6, double.class) },\n+            { vmStore(v7, double.class) },\n+            { vmStore(stackStorage((short) 4, 0), int.class) },\n+            {\n+                bufferLoad(0, int.class),\n+                vmStore(stackStorage((short) 4, 8), int.class),\n+            },\n+            { vmStore(stackStorage((short) 8, 16), double.class) },\n+            { unboxAddress(), vmStore(stackStorage((short) 8, 24), long.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestMacOsAArch64CallArranger.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+<<<<<<< HEAD\n@@ -3,0 +4,3 @@\n+=======\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -28,0 +32,4 @@\n+<<<<<<< HEAD\n+=======\n+ * @compile platform\/PlatformLayouts.java\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -37,0 +45,1 @@\n+<<<<<<< HEAD\n@@ -38,0 +47,2 @@\n+=======\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n@@ -52,0 +63,1 @@\n+<<<<<<< HEAD\n@@ -56,0 +68,6 @@\n+=======\n+import static jdk.internal.foreign.abi.Binding.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.Regs.*;\n+import static platform.PlatformLayouts.AArch64.*;\n+>>>>>>> 82e8c9df442806ea440b6106b4d50281232061cb\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsAArch64CallArranger.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}