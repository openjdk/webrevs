{"files":[{"patch":"@@ -85,0 +85,1 @@\n+<li><a href=\"#attributes\" id=\"toc-attributes\">Attributes<\/a><\/li>\n@@ -1060,0 +1061,25 @@\n+<h3 id=\"attributes\">Attributes<\/h3>\n+<p>The use of some attributes (<a\n+href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2761.pdf\">n2761<\/a>)\n+(listed below) is permitted. (Note that some of the attributes defined\n+in that paper didn't make it into the final specification.)<\/p>\n+<p>Attributes are syntactically permitted in a broad set of locations,\n+but specific attributes are only permitted in a subset of those\n+locations. In some cases an attribute that appertains to a given element\n+may be placed in any of several locations with the same meaning. In\n+those cases HotSpot has a preferred location.<\/p>\n+<ul>\n+<li>An attribute that appertains to a function is placed at the\n+beginning of the function's declaration, rather than between the\n+function name and the parameter list.<\/li>\n+<\/ul>\n+<p>Only the following attributes are permitted:<\/p>\n+<ul>\n+<li><code>[[noreturn]]<\/code><\/li>\n+<\/ul>\n+<p>The following attributes are expressly forbidden:<\/p>\n+<ul>\n+<li><code>[[carries_dependency]]<\/code> - Related to\n+<code>memory_order_consume<\/code>.<\/li>\n+<li><code>[[deprecated]]<\/code> - Not relevant in HotSpot code.<\/li>\n+<\/ul>\n@@ -1152,3 +1178,0 @@\n-<li><p><code>[[deprecated]]<\/code> attribute (<a\n-href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2013\/n3760.html\">n3760<\/a>)\n-— Not relevant in HotSpot code.<\/p><\/li>\n@@ -1174,2 +1197,0 @@\n-<li><p><code>[[noreturn]]<\/code> attribute (<a\n-href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2761.pdf\">n2761<\/a>)<\/p><\/li>\n","filename":"doc\/hotspot-style.html","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1057,0 +1057,26 @@\n+### Attributes\n+\n+The use of some attributes\n+([n2761](http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2761.pdf))\n+(listed below) is permitted.  (Note that some of the attributes defined in\n+that paper didn't make it into the final specification.)\n+\n+Attributes are syntactically permitted in a broad set of locations, but\n+specific attributes are only permitted in a subset of those locations.  In\n+some cases an attribute that appertains to a given element may be placed in\n+any of several locations with the same meaning.  In those cases HotSpot has a\n+preferred location.\n+\n+* An attribute that appertains to a function is placed at the beginning of the\n+function's declaration, rather than between the function name and the parameter\n+list.\n+\n+Only the following attributes are permitted:\n+\n+* `[[noreturn]]`\n+\n+The following attributes are expressly forbidden:\n+\n+* `[[carries_dependency]]` - Related to `memory_order_consume`.\n+* `[[deprecated]]` - Not relevant in HotSpot code.\n+\n@@ -1156,4 +1182,0 @@\n-* `[[deprecated]]` attribute\n-([n3760](http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2013\/n3760.html)) &mdash;\n-Not relevant in HotSpot code.\n-\n@@ -1184,3 +1206,0 @@\n-* `[[noreturn]]` attribute\n-([n2761](http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2761.pdf))\n-\n","filename":"doc\/hotspot-style.md","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -581,0 +581,1 @@\n+<h4 id=\"system-key-shortcuts\">System key shortcuts<\/h4>\n@@ -586,1 +587,1 @@\n-<h4 id=\"macos\">MacOS<\/h4>\n+<h5 id=\"macos\">macOS<\/h5>\n@@ -597,1 +598,1 @@\n-<h4 id=\"linux\">Linux<\/h4>\n+<h5 id=\"linux\">Linux<\/h5>\n@@ -601,1 +602,1 @@\n-<h4 id=\"windows\">Windows<\/h4>\n+<h5 id=\"windows\">Windows<\/h5>\n@@ -608,0 +609,24 @@\n+<h4 id=\"robot-api\">Robot API<\/h4>\n+<p>Most automated Client UI tests use <code>Robot<\/code> API to control\n+the UI. Usually, the default operating system settings need to be\n+adjusted for Robot to work correctly. The detailed steps how to access\n+and update these settings for different platforms are provided\n+below.<\/p>\n+<h5 id=\"macos-1\">macOS<\/h5>\n+<p><code>Robot<\/code> is not permitted to control your Mac by default\n+since macOS 10.15. To allow it, choose Apple menu -&gt; System Settings,\n+click Privacy &amp; Security; then click Accessibility and ensure the\n+following apps are allowed to control your computer: <em>Java<\/em> and\n+<em>Terminal<\/em>. If the tests are run from an IDE, the IDE should be\n+granted this permission too.<\/p>\n+<h5 id=\"windows-1\">Windows<\/h5>\n+<p>On Windows if Cygwin terminal is used to run the tests, there is a\n+delay in focus transfer. Usually it causes automated UI test failure. To\n+disable the delay, type <code>regedit<\/code> in the Search and then\n+select Registry Editor; navigate to the following key:\n+<code>HKEY_CURRENT_USER\\Control Panel\\Desktop<\/code>; make sure the\n+<code>ForegroundLockTimeout<\/code> value is set to 0.<\/p>\n+<p>Additional information about Client UI tests configuration for\n+various operating systems can be obtained at <a\n+href=\"https:\/\/wiki.openjdk.org\/display\/ClientLibs\/Automated+client+GUI+testing+system+set+up+requirements\">Automated\n+client GUI testing system set up requirements<\/a><\/p>\n","filename":"doc\/testing.html","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -609,0 +609,2 @@\n+#### System key shortcuts\n+\n@@ -614,1 +616,1 @@\n-#### MacOS\n+##### macOS\n@@ -627,1 +629,1 @@\n-#### Linux\n+##### Linux\n@@ -632,1 +634,1 @@\n-#### Windows\n+##### Windows\n@@ -641,0 +643,27 @@\n+#### Robot API\n+\n+Most automated Client UI tests use `Robot` API to control the UI. Usually,\n+the default operating system settings need to be adjusted for Robot\n+to work correctly. The detailed steps how to access and update these settings\n+for different platforms are provided below.\n+\n+##### macOS\n+\n+`Robot` is not permitted to control your Mac by default since\n+macOS 10.15. To allow it, choose Apple menu -> System Settings, click\n+Privacy & Security; then click Accessibility and ensure the following apps are\n+allowed to control your computer: *Java* and *Terminal*. If the tests are run\n+from an IDE, the IDE should be granted this permission too.\n+\n+##### Windows\n+\n+On Windows if Cygwin terminal is used to run the tests, there is a delay in\n+focus transfer. Usually it causes automated UI test failure. To disable the\n+delay, type `regedit` in the Search and then select Registry Editor; navigate\n+to the following key: `HKEY_CURRENT_USER\\Control Panel\\Desktop`; make sure\n+the `ForegroundLockTimeout` value is set to 0.\n+\n+Additional information about Client UI tests configuration for various operating\n+systems can be obtained at [Automated client GUI testing system set up\n+requirements](https:\/\/wiki.openjdk.org\/display\/ClientLibs\/Automated+client+GUI+testing+system+set+up+requirements)\n+\n","filename":"doc\/testing.md","additions":32,"deletions":3,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,7 @@\n+$(eval $(call SetupCopyFiles,COPY_CLDRCONVERTER_PROPERTIES, \\\n+    SRC := $(TOPDIR)\/make\/jdk\/src\/classes\/build\/tools\/cldrconverter, \\\n+    DEST := $(BUILDTOOLS_OUTPUTDIR)\/jdk_tools_classes\/build\/tools\/cldrconverter, \\\n+    FILES := $(wildcard $(TOPDIR)\/make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/*.properties)))\n+\n+TARGETS += $(COPY_CLDRCONVERTER_PROPERTIES)\n+\n","filename":"make\/CompileToolsJdk.gmk","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+  $(call info-file-item, \"JAVA_RUNTIME_VERSION\", \"$(VERSION_STRING)\")\n","filename":"make\/ReleaseFile.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1086,1 +1086,1 @@\n-        linux_aarch64: \"gcc11.2.0-OL7.6+1.0\",\n+        linux_aarch64: input.build_cpu == \"x64\" ? \"gcc11.2.0-OL7.6+1.1\" : \"gcc11.2.0-OL7.6+1.0\",\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -479,0 +479,5 @@\n+# alias for GB18030 is generated at runtime\n+charset GB18030 GB18030\n+    package sun.nio.cs\n+    type    source\n+\n@@ -566,5 +571,0 @@\n-charset GB18030 GB18030\n-    package sun.nio.cs.ext\n-    type    template\n-    alias   gb18030-2000\n-\n","filename":"make\/data\/charsetmapping\/charsets","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -10,1 +10,0 @@\n-GB18030\n","filename":"make\/data\/charsetmapping\/stdcs-aix","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -14,1 +14,0 @@\n-GB18030\n","filename":"make\/data\/charsetmapping\/stdcs-linux","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,26 +0,0 @@\n-#\n-#   generate these charsets into sun.nio.cs\n-#\n-Big5\n-Big5_Solaris\n-Big5_HKSCS        # always together with Big5\n-EUC_CN\n-EUC_KR\n-EUC_JP\n-EUC_JP_LINUX\n-EUC_JP_Open\n-EUC_TW\n-GBK\n-GB18030\n-ISO_8859_11\n-ISO_8859_3\n-ISO_8859_6\n-ISO_8859_8\n-Johab\n-PCK\n-TIS_620\n-JIS_X_0201\n-JIS_X_0208\n-JIS_X_0212\n-JIS_X_0208_Solaris\n-JIS_X_0212_Solaris\n","filename":"make\/data\/charsetmapping\/stdcs-solaris","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -5,1 +5,0 @@\n-GB18030\n","filename":"make\/data\/charsetmapping\/stdcs-windows","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+#\tcoverageLevels.txt\n+#\tCopyright © 2022 Unicode, Inc.\n+#\tCLDR data files are interpreted according to the LDML specification (http:\/\/unicode.org\/reports\/tr35\/)\n+#\tFor terms of use, see http:\/\/www.unicode.org\/copyright.html\n+#\n+#\tProvides the Coverage Level of locales at Basic or Above.\n+#\tFor more info,see the Locale Coverage Chart for this version.\n+#\tGenerated by ShowLocaleCoverage.\n+#\n+#Locale ;\tLevel\n+af ;\tmodern\n+am ;\tmodern\n+ar ;\tmodern\n+as ;\tmodern\n+ast ;\tbasic\n+az ;\tmodern\n+be ;\tmodern\n+bg ;\tmodern\n+bgc ;\tbasic\n+bho ;\tbasic\n+bn ;\tmodern\n+br ;\tmoderate\n+brx ;\tbasic\n+bs ;\tmodern\n+bs_Cyrl ;\tbasic\n+ca ;\tmodern\n+ceb ;\tmoderate\n+chr ;\tmodern\n+cs ;\tmodern\n+cv ;\tmoderate\n+cy ;\tmodern\n+da ;\tmodern\n+de ;\tmodern\n+doi ;\tbasic\n+dsb ;\tmodern\n+el ;\tmodern\n+en ;\tmodern\n+es ;\tmodern\n+et ;\tmodern\n+eu ;\tmodern\n+fa ;\tmodern\n+ff_Adlm ;\tbasic\n+fi ;\tmodern\n+fil ;\tmodern\n+fo ;\tbasic\n+fr ;\tmodern\n+ga ;\tmodern\n+gd ;\tmodern\n+gl ;\tmodern\n+gu ;\tmodern\n+ha ;\tmodern\n+he ;\tmodern\n+hi ;\tmodern\n+hi_Latn ;\tmodern\n+hr ;\tmodern\n+hsb ;\tmodern\n+hu ;\tmodern\n+hy ;\tmodern\n+ia ;\tbasic\n+id ;\tmodern\n+ig ;\tmodern\n+is ;\tmodern\n+it ;\tmodern\n+ja ;\tmodern\n+jv ;\tmodern\n+ka ;\tmodern\n+kea ;\tbasic\n+kgp ;\tbasic\n+kk ;\tmodern\n+km ;\tmodern\n+kn ;\tmodern\n+ko ;\tmodern\n+kok ;\tmodern\n+ks ;\tbasic\n+ks_Deva ;\tbasic\n+ky ;\tmodern\n+lo ;\tmodern\n+lt ;\tmodern\n+lv ;\tmodern\n+mai ;\tbasic\n+mi ;\tbasic\n+mk ;\tmodern\n+ml ;\tmodern\n+mn ;\tmodern\n+mni ;\tbasic\n+mr ;\tmodern\n+ms ;\tmodern\n+my ;\tmodern\n+ne ;\tmodern\n+nl ;\tmodern\n+nn ;\tmodern\n+no ;\tmodern\n+or ;\tmodern\n+pa ;\tmodern\n+pcm ;\tmodern\n+pl ;\tmodern\n+ps ;\tmodern\n+pt ;\tmodern\n+qu ;\tmoderate\n+raj ;\tbasic\n+rm ;\tbasic\n+ro ;\tmodern\n+ru ;\tmodern\n+sa ;\tbasic\n+sat ;\tbasic\n+sc ;\tmoderate\n+sd ;\tmodern\n+sd_Deva ;\tbasic\n+si ;\tmodern\n+sk ;\tmodern\n+sl ;\tmodern\n+so ;\tmodern\n+sq ;\tmodern\n+sr ;\tmodern\n+su ;\tbasic\n+sv ;\tmodern\n+sw ;\tmodern\n+ta ;\tmodern\n+te ;\tmodern\n+tg ;\tbasic\n+th ;\tmodern\n+ti ;\tbasic\n+tk ;\tmodern\n+to ;\tbasic\n+tr ;\tmodern\n+tt ;\tbasic\n+uk ;\tmodern\n+ur ;\tmodern\n+uz ;\tmodern\n+uz_Cyrl ;\tbasic\n+vi ;\tmodern\n+wo ;\tbasic\n+xh ;\tmoderate\n+yo ;\tmodern\n+yrl ;\tbasic\n+yue ;\tmodern\n+yue_Hans ;\tmodern\n+zh ;\tmodern\n+zh_Hant ;\tmodern\n+zu ;\tmodern\n+#EOF\n","filename":"make\/data\/cldr\/common\/properties\/coverageLevels.txt","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,12 +53,13 @@\n-                                .stream()\n-                                .filter(cs -> cs.pkgName.equals(\"sun.nio.cs.ext\") &&\n-                                              !cs.isInternal &&\n-                                              (cs.os == null || cs.os.equals(os)))\n-                                .forEach( cs -> {\n-                            out.printf(\"        charset(\\\"%s\\\", \\\"%s\\\",%n\", cs.csName, cs.clzName);\n-                            out.printf(\"                new String[] {%n\");\n-                            for (String alias : cs.aliases) {\n-                                out.printf(\"                    \\\"%s\\\",%n\", alias);\n-                            }\n-                            out.printf(\"                });%n%n\");\n-                        });\n+                            .stream()\n+                            .filter(cs -> cs.pkgName.equals(\"sun.nio.cs.ext\") &&\n+                                          !cs.isInternal &&\n+                                          (cs.os == null || cs.os.equals(os)))\n+                            .forEach( cs -> {\n+                                out.printf(\"        charset(\\\"%s\\\", \\\"%s\\\",%n\", cs.csName, cs.clzName);\n+                                out.printf(\"                new String[] {%n\");\n+                                for (String alias : cs.aliases) {\n+                                    out.printf(\"                    \\\"%s\\\",%n\",\n+                                            alias);\n+                                }\n+                                out.printf(\"                });%n%n\");\n+                            });\n@@ -96,2 +97,9 @@\n-                                 out.printf(\"    static String[] aliases_%s() { return null; }%n%n\",\n-                                            cs.clzName);\n+                                 if (cs.csName.equals(\"GB18030\")) {\n+                                     out.printf(\"    static String[] aliases_GB18030() { return new String[] {%n\");\n+                                     out.printf(\"            GB18030.IS_2000 ? \\\"gb18030-2000\\\" : \\\"gb18030-2022\\\"%n\");\n+                                     out.printf(\"        };%n\");\n+                                     out.printf(\"    }%n%n\");\n+                                 } else {\n+                                     out.printf(\"    static String[] aliases_%s() { return null; }%n%n\",\n+                                             cs.clzName);\n+                                 }\n","filename":"make\/jdk\/src\/classes\/build\/tools\/charsetmapping\/SPI.java","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+    private static String COVERAGELEVELS_FILE;\n@@ -261,0 +262,1 @@\n+        COVERAGELEVELS_FILE = CLDR_BASE + \"\/properties\/coverageLevels.txt\";\n@@ -362,0 +364,1 @@\n+        var coverageMap = coverageLevelsMap();\n@@ -368,1 +371,5 @@\n-                    StringBuilder sb = getCandLocales(cldrLoc);\n+                    List<Locale> candList = getCandidateLocales(cldrLoc);\n+                    if (!\"root\".equals(id) && candList.stream().noneMatch(coverageMap::containsKey)) {\n+                        continue;\n+                    }\n+                    StringBuilder sb = getCandLocales(candList);\n@@ -513,2 +520,1 @@\n-    private static StringBuilder getCandLocales(Locale cldrLoc) {\n-        List<Locale> candList = getCandidateLocales(cldrLoc);\n+    private static StringBuilder getCandLocales(List<Locale> candList) {\n@@ -1198,0 +1204,20 @@\n+    private static Map<Locale, String> coverageLevelsMap() throws Exception {\n+        \/\/ First, parse `coverageLevels.txt` file\n+        var covMap = Files.readAllLines(Path.of(COVERAGELEVELS_FILE)).stream()\n+            .filter(line -> !line.isBlank() && !line.startsWith(\"#\"))\n+            .map(line -> line.split(\"[\\s\\t]*;[\\s\\t]*\", 3))\n+            .filter(a -> a[1].matches(\"basic|moderate|modern|comprehensive\"))\n+            .collect(Collectors.toMap(\n+                    a -> Locale.forLanguageTag(a[0].replaceAll(\"_\", \"-\")),\n+                    a -> a[1],\n+                    (v1, v2) -> v2, \/\/ should never happen\n+                    HashMap::new));\n+\n+        \/\/ Add other common (non-seed) locales (below `basic` coverage level) as of v42\n+        ResourceBundle.getBundle(CLDRConverter.class.getPackageName() + \".OtherCommonLocales\")\n+            .keySet()\n+            .forEach(k -> covMap.put(Locale.forLanguageTag(k), \"\"));\n+\n+        return covMap;\n+    }\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/CLDRConverter.java","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+#\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# Other common (non-seed) locales that are below `Basic` coverage level\n+# as of CLDR v42 (Extracted from\n+# https:\/\/github.com\/unicode-org\/cldr-staging\/blob\/main\/docs\/charts\/42\/tsv\/locale-coverage.tsv)\n+\n+agq=Aghem\n+ak=Akan\n+ann=Obolo\n+asa=Asu\n+az-Cyrl=Azerbaijani (Cyrillic)\n+bas=Basaa\n+bem=Bemba\n+bez=Bena\n+bm=Bambara\n+bo=Tibetan\n+ccp=Chakma\n+ce=Chechen\n+cgg=Chiga\n+ckb=Central Kurdish\n+dav=Taita\n+dje=Zarma\n+dua=Duala\n+dyo=Jola-Fonyi\n+dz=Dzongkha\n+ebu=Embu\n+ee=Ewe\n+eo=Esperanto\n+ewo=Ewondo\n+ff=Fula\n+frr=Northern Frisian\n+fur=Friulian\n+fy=Western Frisian\n+gsw=Swiss German\n+guz=Gusii\n+gv=Manx\n+haw=Hawaiian\n+ii=Sichuan Yi\n+jgo=Ngomba\n+jmc=Machame\n+kab=Kabyle\n+kam=Kamba\n+kde=Makonde\n+khq=Koyra Chiini\n+ki=Kikuyu\n+kkj=Kako\n+kl=Kalaallisut\n+kln=Kalenjin\n+ksb=Shambala\n+ksf=Bafia\n+ksh=Colognian\n+ku=Kurdish\n+kw=Cornish\n+lag=Langi\n+lb=Luxembourgish\n+lg=Ganda\n+lkt=Lakota\n+ln=Lingala\n+lrc=Northern Luri\n+lu=Luba-Katanga\n+luo=Luo\n+luy=Luyia\n+mas=Masai\n+mdf=Moksha\n+mer=Meru\n+mfe=Morisyen\n+mg=Malagasy\n+mgh=Makhuwa-Meetto\n+mgo=Meta��\n+mt=Maltese\n+mua=Mundang\n+mzn=Mazanderani\n+naq=Nama\n+nd=North Ndebele\n+nds=Low German\n+nmg=Kwasio\n+nnh=Ngiemboon\n+nus=Nuer\n+nyn=Nyankole\n+oc=Occitan\n+om=Oromo\n+os=Ossetic\n+pa-Arab=Punjabi (Arabic)\n+pis=Pijin\n+rn=Rundi\n+rof=Rombo\n+rw=Kinyarwanda\n+rwk=Rwa\n+sah=Yakut\n+saq=Samburu\n+sbp=Sangu\n+se=Northern Sami\n+seh=Sena\n+ses=Koyraboro Senni\n+sg=Sango\n+shi=Tachelhit\n+shi-Latn=Tachelhit (Latin)\n+smn=Inari Sami\n+sms=Skolt Sami\n+sn=Shona\n+teo=Teso\n+tok=Toki Pona\n+twq=Tasawaq\n+tzm=Central Atlas Tamazight\n+ug=Uyghur\n+uz-Arab=Uzbek (Arabic)\n+vai=Vai\n+vai-Latn=Vai (Latin)\n+vun=Vunjo\n+wae=Walser\n+xog=Soga\n+yav=Yangben\n+yi=Yiddish\n+zgh=Standard Moroccan Tamazight\n+\n+# Not listed, but existed\n+sr-Latn=Serbian (Latin)\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/OtherCommonLocales.properties","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.source.tree.PrimitiveTypeTree;\n@@ -143,0 +144,2 @@\n+        Path internalAPIDigestFile;\n+        Map<String, String> internalAPI = new HashMap<>();\n@@ -144,0 +147,2 @@\n+        Context context = ((BasicJavacTask) jt).getContext();\n+        JavaCompiler compiler = JavaCompiler.instance(context);\n@@ -145,1 +150,0 @@\n-            Context context = ((BasicJavacTask) jt).getContext();\n@@ -160,2 +164,12 @@\n-            Path internalAPIDigestFile = Paths.get(internalAPIPath);\n-            JavaCompiler compiler = JavaCompiler.instance(context);\n+            internalAPIDigestFile = Paths.get(internalAPIPath);\n+            if (Files.isReadable(internalAPIDigestFile)) {\n+                try {\n+                    Files.readAllLines(internalAPIDigestFile, StandardCharsets.UTF_8)\n+                         .forEach(line -> {\n+                             String[] keyAndValue = line.split(\"=\");\n+                             internalAPI.put(keyAndValue[0], keyAndValue[1]);\n+                         });\n+                } catch (IOException ex) {\n+                    throw new IllegalStateException(ex);\n+                }\n+            }\n@@ -172,1 +186,1 @@\n-                                                                         internalAPIDigestFile,\n+                                                                         internalAPI,\n@@ -216,1 +230,11 @@\n-                if (te.getKind() == Kind.COMPILATION && !noApiChange.get()) {\n+                if (te.getKind() == Kind.COMPILATION && !noApiChange.get() &&\n+                    compiler.errorCount() == 0) {\n+                    try (OutputStream out = Files.newOutputStream(internalAPIDigestFile)) {\n+                        String hashes = internalAPI.entrySet()\n+                                                   .stream()\n+                                                   .map(e -> e.getKey() + \"=\" + e.getValue())\n+                                                   .collect(Collectors.joining(\"\\n\"));\n+                        out.write(hashes.getBytes(StandardCharsets.UTF_8));\n+                    } catch (IOException ex) {\n+                        throw new IllegalStateException(ex);\n+                    }\n@@ -261,1 +285,1 @@\n-            Path internalAPIDigestFile, AtomicBoolean noApiChange,\n+            Map<String, String> internalAPI, AtomicBoolean noApiChange,\n@@ -263,12 +287,0 @@\n-        Map<String, String> internalAPI = new LinkedHashMap<>();\n-        if (Files.isReadable(internalAPIDigestFile)) {\n-            try {\n-                Files.readAllLines(internalAPIDigestFile, StandardCharsets.UTF_8)\n-                     .forEach(line -> {\n-                         String[] keyAndValue = line.split(\"=\");\n-                         internalAPI.put(keyAndValue[0], keyAndValue[1]);\n-                     });\n-            } catch (IOException ex) {\n-                throw new IllegalStateException(ex);\n-            }\n-        }\n@@ -292,1 +304,0 @@\n-\n@@ -304,9 +315,0 @@\n-            try (OutputStream out = Files.newOutputStream(internalAPIDigestFile)) {\n-                String hashes = internalAPI.entrySet()\n-                                           .stream()\n-                                           .map(e -> e.getKey() + \"=\" + e.getValue())\n-                                           .collect(Collectors.joining(\"\\n\"));\n-                out.write(hashes.getBytes(StandardCharsets.UTF_8));\n-            } catch (IOException ex) {\n-                throw new IllegalStateException(ex);\n-            }\n@@ -838,1 +840,1 @@\n-                default -> throw new IllegalStateException(\"Unexpected tree kind: \" + m.getKind());\n+                default -> false;\n@@ -881,0 +883,6 @@\n+        @Override\n+        public Void visitPrimitiveType(PrimitiveTypeTree node, Void p) {\n+            update(node.getPrimitiveTypeKind().name());\n+            return super.visitPrimitiveType(node, p);\n+        }\n+\n@@ -887,1 +895,1 @@\n-        private final Path internalAPIDigestFile;\n+        private final Map<String, String> internalAPI;\n@@ -893,1 +901,1 @@\n-                                         Path internalAPIDigestFile,\n+                                         Map<String, String> internalAPI,\n@@ -898,1 +906,1 @@\n-            this.internalAPIDigestFile = internalAPIDigestFile;\n+            this.internalAPI = internalAPI;\n@@ -910,1 +918,1 @@\n-                                                internalAPIDigestFile,\n+                                                internalAPI,\n","filename":"make\/jdk\/src\/classes\/build\/tools\/depend\/Depend.java","additions":41,"deletions":33,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.io.Writer;\n@@ -57,0 +58,2 @@\n+        test.testPrimitiveTypeChanges();\n+        test.testWithErrors();\n@@ -305,0 +308,21 @@\n+        doOrdinaryTest(\"package test; public record Test (int x) { }\",\n+                       \"package test; public record Test (long x) { unresolved f; }\", \/\/erroneous record member, should not crash\n+                       false);\n+    }\n+\n+    public void testPrimitiveTypeChanges() throws Exception {\n+        doOrdinaryTest(\"package test; public record Test (int x) { }\",\n+                       \"package test; public record Test (long x) { }\",\n+                       true);\n+        doOrdinaryTest(\"package test; public record Test (int x) { }\",\n+                       \"package test; public record Test (Integer x) { }\",\n+                       true);\n+        doOrdinaryTest(\"package test; public record Test (Integer x) { }\",\n+                       \"package test; public record Test (int x) { }\",\n+                       true);\n+    }\n+\n+    public void testWithErrors() throws Exception {\n+        doOrdinaryTest(\"package test; public record Test (int x) { }\",\n+                       \"package test; public record Test (long x) { static unresolved f; }\",\n+                       false); \/\/the API change should not be recorded for code with errors\n@@ -313,0 +337,1 @@\n+    private Path modifiedFiles;\n@@ -331,0 +356,1 @@\n+        modifiedFiles = scratch.resolve(\"modified-files\");\n@@ -338,0 +364,4 @@\n+        try (Writer out = Files.newBufferedWriter(modifiedFiles)) {\n+            out.append(\"module-info.java\\n\");\n+            out.append(\"test.Test.java\\n\");\n+        }\n@@ -341,2 +371,3 @@\n-                              \"-Xplugin:depend \" + apiHash.toString() + \" \" + treeHash.toString(),\n-                              \"-XDmodifiedInputs=build-all\");\n+                              \"-Xplugin:depend \" + apiHash.toString(),\n+                              \"-XDinternalAPIPath=\" + treeHash.toString(),\n+                              \"-XDmodifiedInputs=\" + modifiedFiles.toString());\n@@ -372,0 +403,7 @@\n+        try (Writer out = Files.newBufferedWriter(modifiedFiles)) {\n+            out.append(\"module-info.java\\n\");\n+            out.append(\"test.Test1.java\\n\");\n+            out.append(\"test.Test2.java\\n\");\n+            out.append(\"test.TestImpl1.java\\n\");\n+            out.append(\"test.TestImpl2.java\\n\");\n+        }\n@@ -376,1 +414,2 @@\n-                              \"-XDmodifiedInputs=build-all\");\n+                              \"-XDinternalAPIPath=\" + treeHash.toString(),\n+                              \"-XDmodifiedInputs=\" + modifiedFiles.toString());\n@@ -409,0 +448,1 @@\n+        private final String className;\n@@ -413,0 +453,1 @@\n+            this.className = className;\n@@ -421,0 +462,5 @@\n+        @Override\n+        public String getName() {\n+            return className + \".java\";\n+        }\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/depend\/DependTest.java","additions":49,"deletions":3,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -67,3 +67,1 @@\n-        LIBS := advapi32.lib Secur32.lib netapi32.lib kernel32.lib user32.lib \\\n-            gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib \\\n-            ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib wsock32.lib, \\\n+        LIBS := advapi32.lib Secur32.lib kernel32.lib ws2_32.lib, \\\n","filename":"make\/modules\/java.security.jgss\/Lib.gmk","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8940,2 +8940,1 @@\n-\/\/ This section is generated from aarch64_ad_cas.m4\n-\n+\/\/ This section is generated from cas.m4\n@@ -8947,1 +8946,0 @@\n-\n@@ -8966,1 +8964,0 @@\n-\n@@ -8985,1 +8982,0 @@\n-\n@@ -9003,1 +8999,0 @@\n-\n@@ -9021,1 +9016,0 @@\n-\n@@ -9167,1 +9161,0 @@\n-\n@@ -9187,1 +9180,0 @@\n-\n@@ -9207,1 +9199,0 @@\n-\n@@ -9227,1 +9218,0 @@\n-\n@@ -9247,1 +9237,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -22,1 +22,1 @@\n-dnl \n+dnl\n@@ -36,2 +36,1 @@\n-\/\/ This section is generated from aarch64_ad_cas.m4\n-\n+\/\/ This section is generated from cas.m4\n@@ -39,0 +38,4 @@\n+dnl Return Arg1 with two spaces before it. We need this because m4\n+dnl strips leading spaces from macro args.\n+define(`INDENT', `  $1')dnl\n+dnl\n@@ -44,3 +47,4 @@\n-  ifelse($1$6,PAcq,'predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));`,\n-         $1,P,'predicate(n->as_LoadStore()->barrier_data() == 0);`,\n-         $6,Acq,'predicate(needs_acquiring_load_exclusive(n));`)\n+ifelse($1$6,PAcq,INDENT(predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));),\n+       $1,P,INDENT(predicate(n->as_LoadStore()->barrier_data() == 0);),\n+       $6,Acq,INDENT(predicate(needs_acquiring_load_exclusive(n));),\n+       `dnl')\n@@ -48,1 +52,1 @@\n-  ifelse($6,Acq,'ins_cost(VOLATILE_REF_COST);`,'  ins_cost(2 * VOLATILE_REF_COST);`)\n+  ifelse($6,Acq,'ins_cost(VOLATILE_REF_COST);`,'ins_cost(2 * VOLATILE_REF_COST);`)\n@@ -65,1 +69,1 @@\n-  ifelse($7,Acq,'predicate(needs_acquiring_load_exclusive(n));`)\n+ifelse($7,Acq,INDENT(predicate(needs_acquiring_load_exclusive(n));),`dnl')\n@@ -67,1 +71,1 @@\n-  ifelse($7,Acq,'ins_cost(VOLATILE_REF_COST);`,'  ins_cost(2 * VOLATILE_REF_COST);`)\n+  ifelse($7,Acq,'ins_cost(VOLATILE_REF_COST);`,'ins_cost(2 * VOLATILE_REF_COST);`)\n@@ -99,1 +103,1 @@\n-  ifelse($6,Acq,'  predicate(needs_acquiring_load_exclusive(n));`)\n+ifelse($6,Acq,INDENT(predicate(needs_acquiring_load_exclusive(n));),`dnl')\n@@ -101,1 +105,1 @@\n-  ifelse($6,Acq,'ins_cost(VOLATILE_REF_COST);`,'  ins_cost(2 * VOLATILE_REF_COST);`)\n+  ifelse($6,Acq,'ins_cost(VOLATILE_REF_COST);`,'ins_cost(2 * VOLATILE_REF_COST);`)\n@@ -120,3 +124,4 @@\n-  ifelse($1$6,PAcq,'predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));`,\n-         $1,P,'predicate(n->as_LoadStore()->barrier_data() == 0);`,\n-         $6,Acq,'predicate(needs_acquiring_load_exclusive(n));`)\n+ifelse($1$6,PAcq,INDENT(predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));),\n+       $1,P,INDENT(predicate(n->as_LoadStore()->barrier_data() == 0);),\n+       $6,Acq,INDENT(predicate(needs_acquiring_load_exclusive(n));),\n+       `dnl')\n@@ -124,1 +129,1 @@\n-  ifelse($6,Acq,'ins_cost(VOLATILE_REF_COST);`,'  ins_cost(2 * VOLATILE_REF_COST);`)\n+  ifelse($6,Acq,'ins_cost(VOLATILE_REF_COST);`,'ins_cost(2 * VOLATILE_REF_COST);`)\n","filename":"src\/hotspot\/cpu\/aarch64\/cas.m4","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -3971,0 +3971,58 @@\n+void MacroAssembler::kernel_crc32c_using_crypto_pmull(Register crc, Register buf,\n+        Register len, Register tmp0, Register tmp1, Register tmp2, Register tmp3) {\n+    Label CRC_by4_loop, CRC_by1_loop, CRC_less128, CRC_by128_pre, CRC_by32_loop, CRC_less32, L_exit;\n+    assert_different_registers(crc, buf, len, tmp0, tmp1, tmp2);\n+\n+    subs(tmp0, len, 384);\n+    br(Assembler::GE, CRC_by128_pre);\n+  BIND(CRC_less128);\n+    subs(len, len, 32);\n+    br(Assembler::GE, CRC_by32_loop);\n+  BIND(CRC_less32);\n+    adds(len, len, 32 - 4);\n+    br(Assembler::GE, CRC_by4_loop);\n+    adds(len, len, 4);\n+    br(Assembler::GT, CRC_by1_loop);\n+    b(L_exit);\n+\n+  BIND(CRC_by32_loop);\n+    ldp(tmp0, tmp1, Address(buf));\n+    crc32cx(crc, crc, tmp0);\n+    ldr(tmp2, Address(buf, 16));\n+    crc32cx(crc, crc, tmp1);\n+    ldr(tmp3, Address(buf, 24));\n+    crc32cx(crc, crc, tmp2);\n+    add(buf, buf, 32);\n+    subs(len, len, 32);\n+    crc32cx(crc, crc, tmp3);\n+    br(Assembler::GE, CRC_by32_loop);\n+    cmn(len, (u1)32);\n+    br(Assembler::NE, CRC_less32);\n+    b(L_exit);\n+\n+  BIND(CRC_by4_loop);\n+    ldrw(tmp0, Address(post(buf, 4)));\n+    subs(len, len, 4);\n+    crc32cw(crc, crc, tmp0);\n+    br(Assembler::GE, CRC_by4_loop);\n+    adds(len, len, 4);\n+    br(Assembler::LE, L_exit);\n+  BIND(CRC_by1_loop);\n+    ldrb(tmp0, Address(post(buf, 1)));\n+    subs(len, len, 1);\n+    crc32cb(crc, crc, tmp0);\n+    br(Assembler::GT, CRC_by1_loop);\n+    b(L_exit);\n+\n+  BIND(CRC_by128_pre);\n+    kernel_crc32_common_fold_using_crypto_pmull(crc, buf, len, tmp0, tmp1, tmp2,\n+      4*256*sizeof(juint) + 8*sizeof(juint) + 0x50);\n+    mov(crc, 0);\n+    crc32cx(crc, crc, tmp0);\n+    crc32cx(crc, crc, tmp1);\n+\n+    cbnz(len, CRC_less128);\n+\n+  BIND(L_exit);\n+}\n+\n@@ -4077,1 +4135,5 @@\n-  kernel_crc32c_using_crc32c(crc, buf, len, table0, table1, table2, table3);\n+  if (UseCryptoPmullForCRC32) {\n+    kernel_crc32c_using_crypto_pmull(crc, buf, len, table0, table1, table2, table3);\n+  } else {\n+    kernel_crc32c_using_crc32c(crc, buf, len, table0, table1, table2, table3);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":63,"deletions":1,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1432,0 +1432,3 @@\n+  void kernel_crc32c_using_crypto_pmull(Register crc, Register buf,\n+        Register len, Register tmp0, Register tmp1, Register tmp2,\n+        Register tmp3);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -305,0 +305,12 @@\n+\n+    \/\/ Constants for CRC-32C crypto pmull implementation\n+    0x6992cea2UL, 0x00000000UL,\n+    0x0d3b6092UL, 0x00000000UL,\n+    0x740eef02UL, 0x00000000UL,\n+    0x9e4addf8UL, 0x00000000UL,\n+    0x1c291d04UL, 0x00000000UL,\n+    0xd82c63daUL, 0x00000001UL,\n+    0x384aa63aUL, 0x00000001UL,\n+    0xba4fc28eUL, 0x00000000UL,\n+    0xf20c0dfeUL, 0x00000000UL,\n+    0x4cd00bd6UL, 0x00000001UL,\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -846,0 +846,4 @@\n+\/\/ MI, signed\n+#define CHHSI_ZOPC  (unsigned long)(0xe5L << 40 | 0x54L << 32)\n+#define CHSI_ZOPC   (unsigned long)(0xe5L << 40 | 0x5cL << 32)\n+#define CGHSI_ZOPC  (unsigned long)(0xe5L << 40 | 0x58L << 32)\n@@ -858,0 +862,4 @@\n+\/\/ MI, unsigned\n+#define CLHHSI_ZOPC (unsigned long)(0xe5L << 40 | 0x55L << 32)\n+#define CLFHSI_ZOPC (unsigned long)(0xe5L << 40 | 0x5dL << 32)\n+#define CLGHSI_ZOPC (unsigned long)(0xe5L << 40 | 0x59L << 32)\n@@ -1063,0 +1071,1 @@\n+#define MVCIN_ZOPC  (unsigned long)(0xe8L << 40)\n@@ -1711,1 +1720,1 @@\n-    assert(Immediate::is_uimm(x, nbits), \"unsigned constant out of range\");\n+    assert(Immediate::is_uimm(x, nbits), \"unsigned immediate \" INTPTR_FORMAT \" out of range (%d bits)\", x, nbits);\n@@ -1718,1 +1727,1 @@\n-    assert(Immediate::is_simm(x, nbits), \"value out of range\");\n+    assert(Immediate::is_simm(x, nbits), \"signed immediate \" INTPTR_FORMAT \" out of range (%d bits)\", x, nbits);\n@@ -1725,1 +1734,1 @@\n-    assert((x >> nbits) == 0 || (x >> nbits) == -1, \"value out of range\");\n+    assert((x >> nbits) == 0 || (x >> nbits) == -1, \"signed immediate \" INTPTR_FORMAT \" out of range (%d bits)\", x, nbits);\n@@ -1737,1 +1746,1 @@\n-    assert(Immediate::is_simm(ui20, 20), \"value out of range\");\n+    assert(Immediate::is_simm(ui20, 20), \"signed displacement (disp20) \" INTPTR_FORMAT \" out of range\", ui20);\n@@ -1850,0 +1859,4 @@\n+   \/\/ compare memory - immediate\n+  inline void z_chhsi(int64_t d1, Register b1, int64_t i2);              \/\/ compare (*d1(b1), i2_imm16)      ; int16\n+  inline void z_chsi( int64_t d1, Register b1, int64_t i2);              \/\/ compare (*d1(b1), i2_imm16)      ; int32\n+  inline void z_cghsi(int64_t d1, Register b1, int64_t i2);              \/\/ compare (*d1(b1), i2_imm16)      ; int64\n@@ -1865,0 +1878,4 @@\n+   \/\/ compare memory - immediate\n+  inline void z_clhhsi(int64_t d1, Register b1, int64_t i2);             \/\/ compare (*d1(b1), i2_imm16)      ; uint16\n+  inline void z_clfhsi(int64_t d1, Register b1, int64_t i2);             \/\/ compare (*d1(b1), i2_imm16)      ; uint32\n+  inline void z_clghsi(int64_t d1, Register b1, int64_t i2);             \/\/ compare (*d1(b1), i2_imm16)      ; uint64\n@@ -2438,0 +2455,1 @@\n+  inline void z_mvcin(int64_t d1, int64_t l, Register b1, int64_t d2, Register b2); \/\/ move l+1 bytes\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.hpp","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -280,1 +280,2 @@\n-inline void Assembler::z_mvc(int64_t d1, int64_t l, Register b1, int64_t d2, Register b2) { emit_48( MVC_ZOPC | uimm8(l, 8, 48) | rsmask_48(d1, b1) | rsmask_SS(d2, b2)); }\n+inline void Assembler::z_mvc(int64_t d1, int64_t l, Register b1, int64_t d2, Register b2) { emit_48( MVC_ZOPC   | uimm8(l, 8, 48) | rsmask_48(d1, b1) | rsmask_SS(d2, b2)); }\n+inline void Assembler::z_mvcin(int64_t d1, int64_t l, Register b1, int64_t d2, Register b2) { emit_48( MVCIN_ZOPC | uimm8(l, 8, 48) | rsmask_48(d1, b1) | rsmask_SS(d2, b2)); }\n@@ -650,0 +651,3 @@\n+inline void Assembler::z_chhsi(int64_t d1, Register b1, int64_t i2) { emit_48( CHHSI_ZOPC  | rsmask_48(d1, b1) | simm16(i2, 32, 48)); }\n+inline void Assembler::z_chsi( int64_t d1, Register b1, int64_t i2) { emit_48( CHSI_ZOPC   | rsmask_48(d1, b1) | simm16(i2, 32, 48)); }\n+inline void Assembler::z_cghsi(int64_t d1, Register b1, int64_t i2) { emit_48( CGHSI_ZOPC  | rsmask_48(d1, b1) | simm16(i2, 32, 48)); }\n@@ -660,0 +664,3 @@\n+inline void Assembler::z_clhhsi(int64_t d1, Register b1, int64_t i2) { emit_48( CLHHSI_ZOPC  | rsmask_48(d1, b1) | simm16(i2, 32, 48)); }\n+inline void Assembler::z_clfhsi(int64_t d1, Register b1, int64_t i2) { emit_48( CLFHSI_ZOPC  | rsmask_48(d1, b1) | simm16(i2, 32, 48)); }\n+inline void Assembler::z_clghsi(int64_t d1, Register b1, int64_t i2) { emit_48( CLGHSI_ZOPC  | rsmask_48(d1, b1) | simm16(i2, 32, 48)); }\n@@ -775,1 +782,0 @@\n-\n@@ -1381,1 +1387,1 @@\n-inline void Assembler::z_brnp(  Label& L) { z_brc( bcondNotPositive, target( L)); }\n+inline void Assembler::z_brnp(  Label& L) { z_brc(bcondNotPositive, target( L)); }\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.inline.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -1055,1 +1055,1 @@\n-\/\/ addr: Address descriptor of memory to clear index register will not be used !\n+\/\/ addr: Address descriptor of memory to clear. Index register will not be used!\n@@ -1057,0 +1057,1 @@\n+\/\/ condition code will not be preserved.\n@@ -1059,7 +1060,2 @@\n-void MacroAssembler::clear_mem(const Address& addr, unsigned size) {\n-  guarantee(size <= 256, \"MacroAssembler::clear_mem: size too large\");\n-\n-  if (size == 1) {\n-    z_mvi(addr, 0);\n-    return;\n-  }\n+void MacroAssembler::clear_mem(const Address& addr, unsigned int size) {\n+  guarantee((addr.disp() + size) <= 4096, \"MacroAssembler::clear_mem: size too large\");\n@@ -1068,1 +1064,1 @@\n-    case 2: z_mvhhi(addr, 0);\n+    case 0:\n@@ -1070,1 +1066,2 @@\n-    case 4: z_mvhi(addr, 0);\n+    case 1:\n+      z_mvi(addr, 0);\n@@ -1072,1 +1069,8 @@\n-    case 8: z_mvghi(addr, 0);\n+    case 2:\n+      z_mvhhi(addr, 0);\n+      return;\n+    case 4:\n+      z_mvhi(addr, 0);\n+      return;\n+    case 8:\n+      z_mvghi(addr, 0);\n@@ -1077,1 +1081,15 @@\n-  z_xc(addr, size, addr);\n+  \/\/ Caution: the emitter with Address operands does implicitly decrement the length\n+  if (size <= 256) {\n+    z_xc(addr, size, addr);\n+  } else {\n+    unsigned int offset = addr.disp();\n+    unsigned int incr   = 256;\n+    for (unsigned int i = 0; i <= size-incr; i += incr) {\n+      z_xc(offset, incr - 1, addr.base(), offset, addr.base());\n+      offset += incr;\n+    }\n+    unsigned int rest = size - (offset - addr.disp());\n+    if (size > 0) {\n+      z_xc(offset, rest-1, addr.base(), offset, addr.base());\n+    }\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":31,"deletions":13,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -63,2 +63,0 @@\n-\/\/ These static, partially const, variables are for the AES intrinsics.\n-\/\/ They are declared\/initialized here to make them available across function bodies.\n@@ -66,26 +64,33 @@\n-#if defined(JIT_TIMER)\n-    static const int JIT_TIMER_space      = 8;                   \/\/ extra space for JIT_TIMER data\n-#else\n-    static const int JIT_TIMER_space      = 0;\n-#endif\n-    static const int AES_parmBlk_align    = 32;                  \/\/ octoword alignment.\n-\n-    static int AES_ctrVal_len  = 0;                              \/\/ ctr init value len (in bytes), expected: length of dataBlk (16)\n-    static int AES_ctrVec_len  = 0;                              \/\/ # of ctr vector elements. That many block can be ciphered with one instruction execution\n-    static int AES_ctrArea_len = 0;                              \/\/ reserved stack space (in bytes) for ctr (= ctrVal_len * ctrVec_len)\n-\n-    static int AES_parmBlk_addspace = 0;  \/\/ Must be multiple of AES_parmblk_align.\n-                                          \/\/ Will be set by stub generator to stub specific value.\n-    static int AES_dataBlk_space    = 0;  \/\/ Must be multiple of AES_parmblk_align.\n-                                          \/\/ Will be set by stub generator to stub specific value.\n-\n-    static const int keylen_offset     =  -1;\n-    static const int fCode_offset      =  -2;\n-    static const int ctrVal_len_offset =  -4;\n-    static const int msglen_offset     =  -8;\n-    static const int unextSP_offset    = -16;\n-    static const int remmsg_len_offset = -20;\n-    static const int argsave_offset    = -2*AES_parmBlk_align;\n-    static const int localSpill_offset = argsave_offset + 24;  \/\/ arg2..arg4 are saved\n-\n-\/\/ -----------------------------------------------------------------------\n+  \/\/ These static, partially const, variables are for the AES intrinsics.\n+  \/\/ They are declared\/initialized here to make them available across function bodies.\n+\n+      static const int AES_parmBlk_align    = 32;                  \/\/ octoword alignment.\n+      static const int AES_stackSpace_incr  = AES_parmBlk_align;   \/\/ add'l stack space is allocated in such increments.\n+                                                                   \/\/ Must be multiple of AES_parmBlk_align.\n+\n+      static int AES_ctrVal_len  = 0;                              \/\/ ctr init value len (in bytes), expected: length of dataBlk (16)\n+      static int AES_ctrVec_len  = 0;                              \/\/ # of ctr vector elements. That many block can be ciphered with one instruction execution\n+      static int AES_ctrArea_len = 0;                              \/\/ reserved stack space (in bytes) for ctr (= ctrVal_len * ctrVec_len)\n+\n+      static int AES_parmBlk_addspace = 0;  \/\/ Must be multiple of AES_parmblk_align.\n+                                            \/\/ Will be set by stub generator to stub specific value.\n+      static int AES_dataBlk_space    = 0;  \/\/ Must be multiple of AES_parmblk_align.\n+                                            \/\/ Will be set by stub generator to stub specific value.\n+      static int AES_dataBlk_offset   = 0;  \/\/ offset of the local src and dst dataBlk buffers\n+                                            \/\/ Will be set by stub generator to stub specific value.\n+\n+      \/\/ These offsets are relative to the parameter block address (Register parmBlk = Z_R1)\n+      static const int keylen_offset     =  -1;\n+      static const int fCode_offset      =  -2;\n+      static const int ctrVal_len_offset =  -4;\n+      static const int msglen_offset     =  -8;\n+      static const int unextSP_offset    = -16;\n+      static const int rem_msgblk_offset = -20;\n+      static const int argsave_offset    = -2*AES_parmBlk_align;\n+      static const int regsave_offset    = -4*AES_parmBlk_align; \/\/ save space for work regs (Z_R10..13)\n+      static const int msglen_red_offset = regsave_offset + AES_parmBlk_align; \/\/ reduced len after preLoop;\n+      static const int counter_offset    = msglen_red_offset+8;  \/\/ current counter vector position.\n+      static const int localSpill_offset = argsave_offset + 24;  \/\/ arg2..arg4 are saved\n+\n+\n+      \/\/ -----------------------------------------------------------------------\n@@ -1862,1 +1867,2 @@\n-\/\/ *****************************************************************************\n+\n+  \/\/ *****************************************************************************\n@@ -1870,2 +1876,0 @@\n-  \/\/   |        | JIT_TIMER timestamp buffer, only if JIT_TIMER is defined.\n-  \/\/   +--------+\n@@ -1880,1 +1884,2 @@\n-  \/\/   |        |         Each counter is a 128bit int. Vector element i is formed by incrementing element (i-1).\n+  \/\/   |        |         Each counter is a 128bit int. Vector element [0] is a copy of iv.\n+  \/\/   |        |         Vector element [i] is formed by incrementing element [i-1].\n@@ -1923,1 +1928,11 @@\n-  \/\/    parmBlk-48 ARG4(counter value) ptr spill slot\n+  \/\/    parmBlk-48 ARG4(icv value) ptr spill slot\n+  \/\/\n+  \/\/    parmBlk-72\n+  \/\/    parmBlk-80\n+  \/\/    parmBlk-88 counter vector current position\n+  \/\/    parmBlk-96 reduced msg len (after preLoop processing)\n+  \/\/\n+  \/\/    parmBlk-104 Z_R13 spill slot (preLoop only)\n+  \/\/    parmBlk-112 Z_R12 spill slot (preLoop only)\n+  \/\/    parmBlk-120 Z_R11 spill slot (preLoop only)\n+  \/\/    parmBlk-128 Z_R10 spill slot (preLoop only)\n@@ -1994,2 +2009,3 @@\n-    for (int j = 0; j < AES_ctrVec_len; j++) {\n-      int offset = j * AES_ctrVal_len;\n+\n+    if (v0_only) {\n+      int offset = 0;\n@@ -1997,1 +2013,14 @@\n-      if (v0_only) break;\n+    } else {\n+      int j = 0;\n+      if (VM_Version::has_VectorFacility()) {\n+        bool first_call = true;\n+        for (; j < (AES_ctrVec_len - 3); j+=4) {                       \/\/ increment blocks of 4 iv elements\n+          int offset = j * AES_ctrVal_len;\n+          generate_increment128x4(counter, offset, AES_ctrVec_len, first_call);\n+          first_call = false;\n+        }\n+      }\n+      for (; j < AES_ctrVec_len; j++) {\n+        int offset = j * AES_ctrVal_len;\n+        generate_increment128(counter, offset, AES_ctrVec_len, scratch); \/\/ increment iv by # vector elements\n+      }\n@@ -2017,1 +2046,33 @@\n-  void generate_counterMode_push_Block(int dataBlk_len, int parmBlk_len, int crypto_fCode,\n+  void generate_increment128(Register counter, int offset, Register increment, Register scratch) {\n+    __ clear_reg(scratch);                                 \/\/ prepare to add carry to high-order DW\n+    __ z_alg(increment, Address(counter, offset + 8));     \/\/ increment low order DW\n+    __ z_stg(increment, Address(counter, offset + 8));     \/\/ store back\n+    __ z_alcg(scratch, Address(counter, offset));          \/\/ add carry to high-order DW\n+    __ z_stg(scratch, Address(counter, offset));           \/\/ store back\n+  }\n+\n+  \/\/ This is the vector variant of increment128, incrementing 4 ctr vector elements per call.\n+  void generate_increment128x4(Register counter, int offset, int increment, bool init) {\n+    VectorRegister Vincr      = Z_V16;\n+    VectorRegister Vctr0      = Z_V20;\n+    VectorRegister Vctr1      = Z_V21;\n+    VectorRegister Vctr2      = Z_V22;\n+    VectorRegister Vctr3      = Z_V23;\n+\n+    \/\/ Initialize the increment value only once for a series of increments.\n+    \/\/ It must be assured that the non-initializing generator calls are\n+    \/\/ immediately subsequent. Otherwise, there is no guarantee for Vincr to be unchanged.\n+    if (init) {\n+      __ z_vzero(Vincr);                                   \/\/ preset VReg with constant increment\n+      __ z_vleih(Vincr, increment, 7);                     \/\/ rightmost HW has ix = 7\n+    }\n+\n+    __ z_vlm(Vctr0, Vctr3, offset, counter);               \/\/ get the counter values\n+    __ z_vaq(Vctr0, Vctr0, Vincr);                         \/\/ increment them\n+    __ z_vaq(Vctr1, Vctr1, Vincr);\n+    __ z_vaq(Vctr2, Vctr2, Vincr);\n+    __ z_vaq(Vctr3, Vctr3, Vincr);\n+    __ z_vstm(Vctr0, Vctr3, offset, counter);              \/\/ store the counter values\n+  }\n+\n+  unsigned int generate_counterMode_push_Block(int dataBlk_len, int parmBlk_len, int crypto_fCode,\n@@ -2021,3 +2082,3 @@\n-    AES_dataBlk_space    = roundup(2*dataBlk_len, AES_parmBlk_align);\n-    AES_parmBlk_addspace = AES_parmBlk_align    \/\/ spill space (temp data)\n-                         + AES_parmBlk_align    \/\/ for argument save\/restore\n+    AES_parmBlk_addspace = AES_stackSpace_incr             \/\/ spill space (temp data)\n+                         + AES_stackSpace_incr             \/\/ for argument save\/restore\n+                         + AES_stackSpace_incr*2           \/\/ for work reg save\/restore\n@@ -2025,1 +2086,3 @@\n-    const int key_len    = parmBlk_len;         \/\/ The length of the unextended key (16, 24, 32)\n+    AES_dataBlk_space    = roundup(2*dataBlk_len, AES_parmBlk_align);\n+    AES_dataBlk_offset   = -(AES_parmBlk_addspace+AES_dataBlk_space);\n+    const int key_len    = parmBlk_len;                    \/\/ The length of the unextended key (16, 24, 32)\n@@ -2028,2 +2091,2 @@\n-    AES_ctrVal_len  = dataBlk_len;               \/\/ ctr init value len (in bytes)\n-    AES_ctrArea_len = AES_ctrVec_len * AES_ctrVal_len; \/\/ space required on stack for ctr vector\n+    AES_ctrVal_len  = dataBlk_len;                         \/\/ ctr init value len (in bytes)\n+    AES_ctrArea_len = AES_ctrVec_len * AES_ctrVal_len;     \/\/ space required on stack for ctr vector\n@@ -2033,5 +2096,4 @@\n-    const int resize_len = JIT_TIMER_space       \/\/ timestamp storage for JIT_TIMER\n-                         + AES_parmBlk_align     \/\/ room for alignment of parmBlk\n-                         + AES_parmBlk_align     \/\/ extra room for alignment\n-                         + AES_dataBlk_space     \/\/ one src and one dst data blk\n-                         + AES_parmBlk_addspace  \/\/ spill space for local data\n+    const int resize_len = AES_parmBlk_align               \/\/ room for alignment of parmBlk\n+                         + AES_parmBlk_align               \/\/ extra room for alignment\n+                         + AES_dataBlk_space               \/\/ one src and one dst data blk\n+                         + AES_parmBlk_addspace            \/\/ spill space for local data\n@@ -2039,1 +2101,1 @@\n-                         + AES_ctrArea_len       \/\/ stack space for ctr vector\n+                         + AES_ctrArea_len                 \/\/ stack space for ctr vector\n@@ -2053,0 +2115,3 @@\n+#ifdef ASSERT\n+    __ clear_mem(Address(Z_SP, (intptr_t)8), resize_len - 8);\n+#endif\n@@ -2055,1 +2120,1 @@\n-    __ add2reg(parmBlk, AES_parmBlk_addspace + (AES_parmBlk_align-1), Z_SP);\n+    __ add2reg(parmBlk, AES_parmBlk_addspace + AES_dataBlk_space + (2*AES_parmBlk_align-1), Z_SP);\n@@ -2062,0 +2127,1 @@\n+    __ z_sty(msglen, msglen_red_offset, parmBlk);          \/\/ save for main loop, may get updated in preLoop.\n@@ -2063,1 +2129,1 @@\n-    __ z_sty(msglen, remmsg_len_offset, parmBlk);\n+    __ z_sty(msglen, rem_msgblk_offset, parmBlk);\n@@ -2067,0 +2133,1 @@\n+    __ z_stmg(Z_R10, Z_R13, regsave_offset, parmBlk);      \/\/ make some regs available as work registers\n@@ -2071,0 +2138,1 @@\n+    return resize_len;\n@@ -2077,1 +2145,1 @@\n-    assert_different_registers(scratch, Z_R0);            \/\/ can't use Z_R0 for exrl.\n+    assert_different_registers(scratch, Z_R0);             \/\/ can't use Z_R0 for exrl.\n@@ -2080,2 +2148,2 @@\n-    __ z_llgc(scratch, keylen_offset, parmBlk);           \/\/ get saved (key_len-1) value (we saved just one byte!)\n-    __ z_exrl(scratch, eraser);                           \/\/ template relies on parmBlk still pointing to key on stack\n+    __ z_llgc(scratch, keylen_offset, parmBlk);            \/\/ get saved (key_len-1) value (we saved just one byte!)\n+    __ z_exrl(scratch, eraser);                            \/\/ template relies on parmBlk still pointing to key on stack\n@@ -2088,2 +2156,42 @@\n-    __ z_lgf(msglen, msglen_offset,  parmBlk);            \/\/ Restore msglen, only low order FW is valid\n-    __ z_lg(Z_SP,    unextSP_offset, parmBlk);            \/\/ trim stack back to unextended size\n+    \/\/ restore work registers\n+    __ z_lmg(Z_R10, Z_R13, regsave_offset, parmBlk);       \/\/ make some regs available as work registers\n+\n+    __ z_lgf(msglen, msglen_offset,  parmBlk);             \/\/ Restore msglen, only low order FW is valid\n+#ifdef ASSERT\n+    {\n+      Label skip2last, skip2done;\n+      \/\/ Z_RET (aka Z_R2) can be used as scratch as well. It will be set from msglen before return.\n+      __ z_lgr(Z_RET, Z_SP);                                 \/\/ save extended SP\n+      __ z_lg(Z_SP,    unextSP_offset, parmBlk);             \/\/ trim stack back to unextended size\n+      __ z_sgrk(Z_R1, Z_SP, Z_RET);\n+\n+      __ z_cghi(Z_R1, 256);\n+      __ z_brl(skip2last);\n+      __ z_xc(0, 255, Z_RET, 0, Z_RET);\n+      __ z_aghi(Z_RET, 256);\n+      __ z_aghi(Z_R1, -256);\n+\n+      __ z_cghi(Z_R1, 256);\n+      __ z_brl(skip2last);\n+      __ z_xc(0, 255, Z_RET, 0, Z_RET);\n+      __ z_aghi(Z_RET, 256);\n+      __ z_aghi(Z_R1, -256);\n+\n+      __ z_cghi(Z_R1, 256);\n+      __ z_brl(skip2last);\n+      __ z_xc(0, 255, Z_RET, 0, Z_RET);\n+      __ z_aghi(Z_RET, 256);\n+      __ z_aghi(Z_R1, -256);\n+\n+      __ bind(skip2last);\n+      __ z_lgr(Z_R0, Z_RET);\n+      __ z_aghik(Z_RET, Z_R1, -1);  \/\/ decrement for exrl\n+      __ z_brl(skip2done);\n+      __ z_lgr(parmBlk, Z_R0);      \/\/ parmBlk == Z_R1, used in eraser template\n+      __ z_exrl(Z_RET, eraser);\n+\n+      __ bind(skip2done);\n+    }\n+#else\n+    __ z_lg(Z_SP,    unextSP_offset, parmBlk);             \/\/ trim stack back to unextended size\n+#endif\n@@ -2093,1 +2201,2 @@\n-  void generate_counterMode_push_parmBlk(Register parmBlk, Register msglen, Register fCode, Register key, bool is_decipher) {\n+  int generate_counterMode_push_parmBlk(Register parmBlk, Register msglen, Register fCode, Register key, bool is_decipher) {\n+    int       resize_len = 0;\n@@ -2111,1 +2220,1 @@\n-      generate_counterMode_push_Block(VM_Version::Cipher::_AES128_dataBlk,\n+      resize_len = generate_counterMode_push_Block(VM_Version::Cipher::_AES128_dataBlk,\n@@ -2122,1 +2231,1 @@\n-      generate_counterMode_push_Block(VM_Version::Cipher::_AES192_dataBlk,\n+      resize_len = generate_counterMode_push_Block(VM_Version::Cipher::_AES192_dataBlk,\n@@ -2133,1 +2242,1 @@\n-      generate_counterMode_push_Block(VM_Version::Cipher::_AES256_dataBlk,\n+      resize_len = generate_counterMode_push_Block(VM_Version::Cipher::_AES256_dataBlk,\n@@ -2141,0 +2250,1 @@\n+    return resize_len;\n@@ -2153,29 +2263,0 @@\n-  \/\/ Resize current stack frame to make room for some register data which needs\n-  \/\/ to be spilled temporarily. All registers in the range [from..to] are spilled\n-  \/\/ automatically. The actual length of the allocated aux block is returned.\n-  \/\/ The extra spill space (if requested) is located at\n-  \/\/   [Z_SP+stackSpace-spillSpace, Z_SP+stackSpace)\n-  \/\/ Kills Z__R0 (contains fp afterwards) and Z_R1 (contains old SP afterwards).\n-  \/\/ All space in the range [SP..SP+regSpace) is reserved.\n-  \/\/ As always (here): 0(SP) - stack linkage, 8(SP) - SP before resize for easy pop.\n-  int generate_push_aux_block(Register from, Register to, unsigned int spillSpace) {\n-    int n_regs     = to->encoding() - from->encoding() + 1;\n-    int linkSpace  = 2*wordSize;\n-    int regSpace   = n_regs*wordSize;\n-    int stackSpace = roundup(linkSpace + regSpace + spillSpace, AES_parmBlk_align);\n-    BLOCK_COMMENT(err_msg(\"push aux_block (%d bytes) counterMode_AESCrypt {\", stackSpace));\n-    __ z_lgr(Z_R1, Z_SP);\n-    __ resize_frame(-stackSpace, Z_R0, true);\n-    __ z_stg(Z_R1, 8, Z_SP);\n-    __ z_stmg(from, to, linkSpace, Z_SP);\n-    BLOCK_COMMENT(err_msg(\"} push aux_block (%d bytes) counterMode_AESCrypt\", stackSpace));\n-    return stackSpace;\n-  }\n-  \/\/ Reverts everything done by generate_push_aux_block().\n-  void generate_pop_aux_block(Register from, Register to) {\n-    BLOCK_COMMENT(\"pop aux_block counterMode_AESCrypt {\");\n-    __ z_lmg(from, to, 16, Z_SP);\n-    __ z_lg(Z_SP, 8, Z_SP);\n-    BLOCK_COMMENT(\"} pop aux_block counterMode_AESCrypt\");\n-  }\n-\n@@ -2186,0 +2267,17 @@\n+    \/\/ On entry:\n+    \/\/ if there was a previous call to update(), and this previous call did not fully use\n+    \/\/ the current encrypted counter, that counter is available at arg6_Offset(Z_SP).\n+    \/\/ The index of the first unused bayte in the encrypted counter is available at arg7_Offset(Z_SP).\n+    \/\/ The index is in the range [1..AES_ctrVal_len] ([1..16]), where index == 16 indicates a fully\n+    \/\/ used previous encrypted counter.\n+    \/\/ The unencrypted counter has already been incremented and is ready to be used for the next\n+    \/\/ data block, after the unused bytes from the previous call have been consumed.\n+    \/\/ The unencrypted counter follows the \"increment-after use\" principle.\n+\n+    \/\/ On exit:\n+    \/\/ The index of the first unused byte of the encrypted counter is written back to arg7_Offset(Z_SP).\n+    \/\/ A value of AES_ctrVal_len (16) indicates there is no leftover byte.\n+    \/\/ If there is at least one leftover byte (1 <= index < AES_ctrVal_len), the encrypted counter value\n+    \/\/ is written back to arg6_Offset(Z_SP). If there is no leftover, nothing is written back.\n+    \/\/ The unencrypted counter value is written back after having been incremented.\n+\n@@ -2194,0 +2292,5 @@\n+               \/\/ encCtr   = Z_ARG6  - encrypted counter (byte array),\n+               \/\/                      address passed on stack at _z_abi(remaining_cargs) + 0 * WordSize\n+               \/\/ cvIndex  = Z_ARG7  - # used (consumed) bytes of encrypted counter,\n+               \/\/                      passed on stack at _z_abi(remaining_cargs) + 1 * WordSize\n+               \/\/                      Caution:4-byte value, right-justified in 8-byte stack word\n@@ -2197,1 +2300,1 @@\n-    const Register src     = Z_ARG1; \/\/ is Z_R2\n+    const Register src     = Z_ARG1; \/\/ is Z_R2, forms even\/odd pair with srclen\n@@ -2203,1 +2306,2 @@\n-    Label CryptoLoop, CryptoLoop_doit, CryptoLoop_end, CryptoLoop_setupAndDoLast, CryptoLoop_ctrVal_inc, allDone, Exit;\n+    Label CryptoLoop, CryptoLoop_doit, CryptoLoop_end, CryptoLoop_setupAndDoLast, CryptoLoop_ctrVal_inc;\n+    Label allDone, allDone_noInc, popAndExit, Exit;\n@@ -2205,11 +2309,3 @@\n-    \/\/ Check if there is a leftover, partially used encrypted counter from last invocation.\n-    \/\/ If so, use those leftover counter bytes first before starting the \"normal\" encryption.\n-    {\n-      Register cvIndex   = Z_R10;  \/\/ # unused bytes of last encrypted counter value\n-      Register cvUnused  = Z_R11;  \/\/ # unused bytes of last encrypted counter value\n-      Register encCtr    = Z_R12;  \/\/ encrypted counter value, points to first ununsed byte.\n-      Label no_preLoop, preLoop_end;\n-\n-      \/\/ Before pushing an aux block, check if it's necessary at all (saves some cycles).\n-      __ z_lt(Z_R0, _z_abi(remaining_cargs) + 8 + 4, Z_R0, Z_SP); \/\/ arg7: # unused bytes in encCTR.\n-      __ z_brnp(no_preLoop);                                      \/\/ no unused bytes, nothing special to do.\n+    int    arg6_Offset = _z_abi(remaining_cargs) + 0 * HeapWordSize;\n+    int    arg7_Offset = _z_abi(remaining_cargs) + 1 * HeapWordSize; \/\/ stack slot holds ptr to int value\n+    int   oldSP_Offset = 0;\n@@ -2217,3 +2313,3 @@\n-      int   oldSP_Offset  = generate_push_aux_block(Z_R10, Z_R12, 16);\n-      int   arg6_Offset   = oldSP_Offset + _z_abi(remaining_cargs);\n-      int   arg7_Offset   = oldSP_Offset + _z_abi(remaining_cargs) + 8;\n+    \/\/ Is there anything to do at all? Protect against negative len as well.\n+    __ z_ltr(msglen, msglen);\n+    __ z_brnh(Exit);\n@@ -2221,5 +2317,4 @@\n-      __ z_ltgf(cvUnused, arg7_Offset+4, Z_R0, Z_SP); \/\/ arg7: # unused bytes in encCTR. (16-arg7) is index of first unused byte.\n-      __ z_brnp(preLoop_end);                  \/\/ \"not positive\" means no unused bytes left\n-      __ z_aghik(cvIndex, cvUnused, -16);      \/\/ calculate index of first unused byte. AES_ctrVal_len undefined at this point.\n-      __ z_brnl(preLoop_end);                  \/\/ NotLow(=NotNegative): unused bytes >= 16? How that?\n-      __ z_lcgr(cvIndex, cvIndex);\n+    \/\/ Expand stack, load parm block address into parmBlk (== Z_R1), copy crypto key to parm block.\n+    oldSP_Offset = generate_counterMode_push_parmBlk(parmBlk, msglen, fCode, key, is_decipher);\n+    arg6_Offset += oldSP_Offset;\n+    arg7_Offset += oldSP_Offset;\n@@ -2227,2 +2322,2 @@\n-      __ z_lg(encCtr, arg6_Offset, Z_SP);      \/\/ arg6: encrypted counter byte array.\n-      __ z_agr(encCtr, cvIndex);               \/\/ first unused byte of encrypted ctr. Used in ctrXOR.\n+    \/\/ Check if there is a leftover, partially used encrypted counter from last invocation.\n+    \/\/ If so, use those leftover counter bytes first before starting the \"normal\" encryption.\n@@ -2230,2 +2325,9 @@\n-      __ z_cr(cvUnused, msglen);               \/\/ check if msg is long enough\n-      __ z_locr(cvUnused, msglen, Assembler::bcondHigh); \/\/ take the shorter length\n+    \/\/ We do not have access to the encrypted counter value. It is generated and used only\n+    \/\/ internally within the previous kmctr instruction. But, at the end of call to this stub,\n+    \/\/ the last encrypted couner is extracted by ciphering a 0x00 byte stream. The result is\n+    \/\/ stored at the arg6 location for use with the subsequent call.\n+    \/\/\n+    \/\/ The #used bytes of the encrypted counter (from a previous call) is provided via arg7.\n+    \/\/ It is used as index into the encrypted counter to access the first byte availabla for ciphering.\n+    \/\/ To cipher the input text, we move the number of remaining bytes in the encrypted counter from\n+    \/\/ input to output. Then we simply XOR the output bytes with the associated encrypted counter bytes.\n@@ -2233,2 +2335,2 @@\n-      __ z_aghi(cvUnused, -1);                 \/\/ decrement # unused bytes by 1 for exrl instruction\n-      __ z_brl(preLoop_end);                   \/\/ negative result means nothing to do (msglen is zero)\n+    Register cvIxAddr  = Z_R10;                  \/\/ Address of index into encCtr. Preserved for use @CryptoLoop_end.\n+    __ z_lg(cvIxAddr, arg7_Offset, Z_SP);        \/\/ arg7: addr of field encCTR_index.\n@@ -2236,0 +2338,27 @@\n+    {\n+      Register cvUnused  = Z_R11;                \/\/ # unused bytes of encrypted counter value (= 16 - cvIndex)\n+      Register encCtr    = Z_R12;                \/\/ encrypted counter value, points to first ununsed byte.\n+      Register cvIndex   = Z_R13;                \/\/ # index of first unused byte of encrypted counter value\n+      Label    preLoop_end;\n+\n+      \/\/ preLoop is necessary only if there is a partially used encrypted counter (encCtr).\n+      \/\/ Partially used means cvIndex is in [1, dataBlk_len-1].\n+      \/\/ cvIndex == 0:           encCtr is set up but not used at all. Should not occur.\n+      \/\/ cvIndex == dataBlk_len: encCtr is exhausted, all bytes used.\n+      \/\/ Using unsigned compare protects against cases where (cvIndex < 0).\n+      __ z_clfhsi(0, cvIxAddr, AES_ctrVal_len);  \/\/ check #used bytes in encCtr against ctr len.\n+      __ z_brnl(preLoop_end);                    \/\/ if encCtr is fully used, skip to normal processing.\n+      __ z_ltgf(cvIndex, 0, Z_R0, cvIxAddr);     \/\/ # used bytes in encCTR.\n+      __ z_brz(preLoop_end);                     \/\/ if encCtr has no used bytes, skip to normal processing.\n+\n+      __ z_lg(encCtr, arg6_Offset, Z_SP);        \/\/ encrypted counter from last call to update()\n+      __ z_agr(encCtr, cvIndex);                 \/\/ now points to first unused byte\n+\n+      __ add2reg(cvUnused, -AES_ctrVal_len, cvIndex); \/\/ calculate #unused bytes in encCtr.\n+      __ z_lcgr(cvUnused, cvUnused);             \/\/ previous checks ensure cvUnused in range [1, dataBlk_len-1]\n+\n+      __ z_lgf(msglen, msglen_offset, parmBlk);  \/\/ Restore msglen (jint value)\n+      __ z_cr(cvUnused, msglen);                 \/\/ check if msg can consume all unused encCtr bytes\n+      __ z_locr(cvUnused, msglen, Assembler::bcondHigh); \/\/ take the shorter length\n+      __ z_aghi(cvUnused, -1);                   \/\/ decrement # unused bytes by 1 for exrl instruction\n+                                                 \/\/ preceding checks ensure cvUnused in range [1, dataBlk_len-1]\n@@ -2239,1 +2368,5 @@\n-      __ add2reg(cvUnused, 1, cvUnused);\n+      __ z_aghi(cvUnused, 1);                    \/\/ revert decrement from above\n+      __ z_agr(cvIndex, cvUnused);               \/\/ update index into encCtr (first unused byte)\n+      __ z_st(cvIndex, 0, cvIxAddr);             \/\/ write back arg7, cvIxAddr is still valid\n+\n+      \/\/ update pointers and counters to prepare for main loop\n@@ -2242,15 +2375,4 @@\n-      __ z_sr(msglen, cvUnused);\n-      __ z_brnz(preLoop_end);                  \/\/ there is still work to do\n-\n-      \/\/ Remaining msglen is zero, i.e. all msg bytes were processed in preLoop.\n-      \/\/ Take an early exit.\n-      generate_pop_aux_block(Z_R10, Z_R12);\n-      __ z_bru(Exit);\n-\n-      \/\/-------------------------------------------\n-      \/\/---<  execution templates for preLoop  >---\n-      \/\/-------------------------------------------\n-      __ bind(fromMover);\n-      __ z_mvc(0, 0, to, 0, from);         \/\/ Template instruction to move input data to dst.\n-      __ bind(ctrXOR);\n-      __ z_xc(0,  0, to, 0, encCtr);       \/\/ Template instruction to XOR input data (now in to) with encrypted counter.\n+      __ z_sr(msglen, cvUnused);                 \/\/ #bytes not yet processed\n+      __ z_sty(msglen, msglen_red_offset, parmBlk); \/\/ save for calculations in main loop\n+      __ z_srak(Z_R0, msglen, exact_log2(AES_ctrVal_len));\/\/ # full cipher blocks that can be formed from input text.\n+      __ z_sty(Z_R0, rem_msgblk_offset, parmBlk);\n@@ -2258,2 +2380,3 @@\n-      __ bind(preLoop_end);\n-      generate_pop_aux_block(Z_R10, Z_R12);\n+      \/\/ check remaining msglen. If zero, all msg bytes were processed in preLoop.\n+      __ z_ltr(msglen, msglen);\n+      __ z_brnh(popAndExit);\n@@ -2261,1 +2384,1 @@\n-      __ bind(no_preLoop);\n+      __ bind(preLoop_end);\n@@ -2264,2 +2387,0 @@\n-    \/\/ Expand stack, load parm block address into parmBlk (== Z_R1), copy crypto key to parm block.\n-    generate_counterMode_push_parmBlk(parmBlk, msglen, fCode, key, is_decipher);\n@@ -2276,2 +2397,2 @@\n-      __ z_asi(remmsg_len_offset, parmBlk, -AES_ctrVec_len);  \/\/ decrement #remaining blocks (16 bytes each). Range: [+127..-128]\n-      __ z_brl(CryptoLoop_setupAndDoLast);                    \/\/ Handling the last iteration out-of-line\n+      __ z_asi(rem_msgblk_offset, parmBlk, -AES_ctrVec_len);  \/\/ decrement #remaining blocks (16 bytes each). Range: [+127..-128]\n+      __ z_brl(CryptoLoop_setupAndDoLast);                    \/\/ Handling the last iteration (using less than max #blocks) out-of-line\n@@ -2282,1 +2403,1 @@\n-      __ z_lt(srclen, remmsg_len_offset, Z_R0, parmBlk);      \/\/ check if this was the last iteration\n+      __ z_lt(srclen, rem_msgblk_offset, Z_R0, parmBlk);      \/\/ check if this was the last iteration\n@@ -2286,0 +2407,1 @@\n+                                                              \/\/  > 0: this is the fallthru case, need another iteration\n@@ -2293,5 +2415,11 @@\n-    \/\/ except for the last few [0..dataBlk_len) bytes. To encrypt these few bytes\n-    \/\/ we need to form an extra src and dst data block of dataBlk_len each. This\n-    \/\/ is because we can only process full blocks but we must not read or write\n-    \/\/ beyond the boundaries of the argument arrays. Here is what we do:\n-    \/\/  - The src data block is filled with the remaining \"from\" bytes, padded with 0x00's.\n+    \/\/ except for the last few [0..dataBlk_len) bytes. In addition, we know that\n+    \/\/ there are no more unused bytes in the previously generated encrypted counter.\n+    \/\/ The (unencrypted) counter, however, is ready to use (it was incremented before).\n+\n+    \/\/ To encrypt the few remaining bytes, we need to form an extra src and dst\n+    \/\/ data block of dataBlk_len each. This is because we can only process full\n+    \/\/ blocks but we must not read or write beyond the boundaries of the argument\n+    \/\/ arrays. Here is what we do:\n+    \/\/  - The ctrVector has at least one unused element. This is ensured by CryptoLoop code.\n+    \/\/  - The (first) unused element is pointed at by the counter register.\n+    \/\/  - The src data block is filled with the remaining \"from\" bytes, remainder of block undefined.\n@@ -2301,29 +2429,35 @@\n-    \/\/  - The counter value to be used is is pointed at by the counter register.\n-    \/\/  - Fortunately, the crypto instruction (kmctr) updates all related addresses such that we\n-    \/\/    know where to continue with \"from\" and \"to\" and which counter value to use next.\n-\n-    \/\/ Use speaking alias for temp register\n-    Register dataBlk = counter;\n-    __ z_stg(counter, -24, parmBlk);                      \/\/ spill address of counter array\n-    __ add2reg(dataBlk, -(AES_parmBlk_addspace + AES_dataBlk_space), parmBlk);\n-\n-    __ z_lgf(srclen, msglen_offset, parmBlk);             \/\/ full plaintext\/ciphertext len.\n-    __ z_nilf(srclen, AES_ctrVal_len - 1);                \/\/ those rightmost bits indicate the unprocessed #bytes\n-    __ z_braz(allDone);                                   \/\/ no unprocessed bytes? Then we are done.\n-\n-    __ add2reg(srclen, -1);                               \/\/ decrement for exrl\n-    __ z_stg(srclen, localSpill_offset, parmBlk);         \/\/ save for later reuse\n-    __ z_xc(0, AES_ctrVal_len - 1, dataBlk, 0, dataBlk);  \/\/ clear src block (zero padding)\n-    __ z_exrl(srclen, srcMover);                          \/\/ copy src byte stream (remaining bytes)\n-    __ load_const_optimized(srclen, AES_ctrVal_len);      \/\/ kmctr processes only complete blocks\n-\n-    __ z_lgr(src, dataBlk);                               \/\/ tmp src address for kmctr\n-    __ z_lg(counter, -24, parmBlk);                       \/\/ restore counter\n-    __ z_stg(dst, -24, parmBlk);                          \/\/ save current dst\n-    __ add2reg(dst, AES_ctrVal_len, src);                 \/\/ tmp dst is right after tmp src\n-\n-    __ kmctr(dst, counter, src);   \/\/ Cipher the remaining bytes.\n-\n-    __ add2reg(dataBlk, -AES_ctrVal_len, dst);            \/\/ tmp dst address\n-    __ z_lg(dst, -24, parmBlk);                           \/\/ real dst address\n-    __ z_lg(srclen, localSpill_offset, parmBlk);          \/\/ reuse calc from above\n+    \/\/  - The counter value to be used is pointed at by the counter register.\n+    \/\/  - Fortunately, the crypto instruction (kmctr) has updated all related addresses such that\n+    \/\/    we know where to continue with \"from\" and \"to\" and which counter value to use next.\n+\n+    Register encCtr    = Z_R12;  \/\/ encrypted counter value, points to stub argument.\n+    Register tmpDst    = Z_R12;  \/\/ addr of temp destination (for last partial block encryption)\n+\n+    __ z_lgf(srclen, msglen_red_offset, parmBlk);          \/\/ plaintext\/ciphertext len after potential preLoop processing.\n+    __ z_nilf(srclen, AES_ctrVal_len - 1);                 \/\/ those rightmost bits indicate the unprocessed #bytes\n+    __ z_stg(srclen, localSpill_offset, parmBlk);          \/\/ save for later reuse\n+    __ z_mvhi(0, cvIxAddr, 16);                            \/\/ write back arg7 (default 16 in case of allDone).\n+    __ z_braz(allDone_noInc);                              \/\/ no unprocessed bytes? Then we are done.\n+                                                           \/\/ This also means the last block of data processed was\n+                                                           \/\/ a full-sized block (AES_ctrVal_len bytes) which results\n+                                                           \/\/ in no leftover encrypted counter bytes.\n+    __ z_st(srclen, 0, cvIxAddr);                          \/\/ This will be the index of the first unused byte in the encrypted counter.\n+    __ z_stg(counter, counter_offset, parmBlk);            \/\/ save counter location for easy later restore\n+\n+    \/\/ calculate address (on stack) for final dst and src blocks.\n+    __ add2reg(tmpDst, AES_dataBlk_offset, parmBlk);       \/\/ tmp dst (on stack) is right before tmp src\n+\n+    \/\/ We have a residue of [1..15] unprocessed bytes, srclen holds the exact number.\n+    \/\/ Residue == 0 was checked just above, residue == AES_ctrVal_len would be another\n+    \/\/ full-sized block and would have been handled by CryptoLoop.\n+\n+    __ add2reg(srclen, -1);                                \/\/ decrement for exrl\n+    __ z_exrl(srclen, srcMover);                           \/\/ copy remaining bytes of src byte stream\n+    __ load_const_optimized(srclen, AES_ctrVal_len);       \/\/ kmctr processes only complete blocks\n+    __ add2reg(src, AES_ctrVal_len, tmpDst);               \/\/ tmp dst is right before tmp src\n+\n+    __ kmctr(tmpDst, counter, src);                        \/\/ Cipher the remaining bytes.\n+\n+    __ add2reg(tmpDst, -AES_ctrVal_len, tmpDst);           \/\/ restore tmp dst address\n+    __ z_lg(srclen, localSpill_offset, parmBlk);           \/\/ residual len, saved above\n+    __ add2reg(srclen, -1);                                \/\/ decrement for exrl\n@@ -2332,0 +2466,10 @@\n+    \/\/ Write back new encrypted counter\n+    __ add2reg(src, AES_dataBlk_offset, parmBlk);\n+    __ clear_mem(Address(src, RegisterOrConstant((intptr_t)0)), AES_ctrVal_len);\n+    __ load_const_optimized(srclen, AES_ctrVal_len);       \/\/ kmctr processes only complete blocks\n+    __ z_lg(encCtr, arg6_Offset, Z_SP);                    \/\/ write encrypted counter to arg6\n+    __ z_lg(counter, counter_offset, parmBlk);             \/\/ restore counter\n+    __ kmctr(encCtr, counter, src);\n+\n+    \/\/ The last used element of the counter vector contains the latest counter value that was used.\n+    \/\/ As described above, the counter value on exit must be the one to be used next.\n@@ -2333,4 +2477,7 @@\n-    __ z_llgf(srclen, msglen_offset, parmBlk);            \/\/ increment unencrypted ctr by #blocks processed.\n-    __ z_srag(srclen, srclen, exact_log2(AES_ctrVal_len));\n-    __ z_ag(srclen, 8, Z_R0, ctr);\n-    __ z_stg(srclen, 8, Z_R0, ctr);\n+    __ z_lg(counter, counter_offset, parmBlk);             \/\/ restore counter\n+    generate_increment128(counter, 0, 1, Z_R0);\n+\n+    __ bind(allDone_noInc);\n+    __ z_mvc(0, AES_ctrVal_len, ctr, 0, counter);\n+\n+    __ bind(popAndExit);\n@@ -2348,1 +2495,1 @@\n-      __ z_lgf(srclen, remmsg_len_offset, parmBlk);           \/\/ remaining #blocks in memory is < 0\n+      __ z_lgf(srclen, rem_msgblk_offset, parmBlk);           \/\/ remaining #blocks in memory is < 0\n@@ -2352,1 +2499,2 @@\n-      __ z_bru(CryptoLoop_end);\n+      __ z_bru(CryptoLoop_end);                               \/\/ There is at least one unused counter vector element.\n+                                                              \/\/ no need to increment.\n@@ -2358,0 +2506,8 @@\n+    \/\/-------------------------------------------\n+    \/\/---<  execution templates for preLoop  >---\n+    \/\/-------------------------------------------\n+    __ bind(fromMover);\n+    __ z_mvc(0, 0, to, 0, from);               \/\/ Template instruction to move input data to dst.\n+    __ bind(ctrXOR);\n+    __ z_xc(0,  0, to, 0, encCtr);             \/\/ Template instruction to XOR input data (now in to) with encrypted counter.\n+\n@@ -2364,1 +2520,1 @@\n-    __ z_mvc(0, 0, dst, 0, dataBlk);     \/\/ Template instruction to move encrypted reminder from stack to dst.\n+    __ z_mvc(0, 0, dst, 0, tmpDst);      \/\/ Template instruction to move encrypted reminder from stack to dst.\n@@ -2366,1 +2522,1 @@\n-    __ z_mvc(0, 0, dataBlk, 0, src);     \/\/ Template instruction to move reminder of source byte stream to stack.\n+    __ z_mvc(AES_ctrVal_len, 0, tmpDst, 0, src); \/\/ Template instruction to move reminder of source byte stream to stack.\n@@ -2371,1 +2527,0 @@\n-  \/\/\n@@ -2385,0 +2540,2 @@\n+    __ bind(AESCTR_short);\n+\n@@ -2387,1 +2544,0 @@\n-    __ bind(AESCTR_short);\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":342,"deletions":186,"binary":false,"changes":528,"status":"modified"},{"patch":"@@ -2026,2 +2026,2 @@\n-  } else {\n-    ::abort();\n+    \/\/ ::raise is not noreturn, even though with SIGKILL it definitely won't\n+    \/\/ return.  Hence \"fall through\" to ::abort, which is declared noreturn.\n@@ -2029,0 +2029,1 @@\n+  ::abort();\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -69,0 +69,6 @@\n+void VMError::raise_fail_fast(void* exrecord, void* context) {\n+  DWORD flags = (exrecord == nullptr) ? FAIL_FAST_GENERATE_EXCEPTION_ADDRESS : 0;\n+  RaiseFailFastException(static_cast<PEXCEPTION_RECORD>(exrecord),\n+                         static_cast<PCONTEXT>(context),\n+                         flags);\n+}\n","filename":"src\/hotspot\/os\/windows\/vmError_windows.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-\/\/ ciArrayKlass::base_element_type\n+\/\/ ciArrayKlass::make\n@@ -99,1 +99,1 @@\n-\/\/ What type is obtained when this array is indexed as many times as possible?\n+\/\/ Make an array klass of the specified element type.\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -205,2 +205,2 @@\n-  \/* Special flavor of dsqrt intrinsic to handle the \"native\" method in StrictMath. Otherwise the same as in Math. *\/   \\\n-  do_intrinsic(_dsqrt_strict,             java_lang_StrictMath,   sqrt_name,          double_double_signature,   F_SN)  \\\n+  \/* Additional dsqrt intrinsic to directly handle the sqrt method in StrictMath. Otherwise the same as in Math. *\/     \\\n+  do_intrinsic(_dsqrt_strict,             java_lang_StrictMath,   sqrt_name,          double_double_signature,   F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-\/\/ by transitioning from _thread_in_native to _thread_in_vm.\n+\/\/ by doing the commit while the thread is _thread_in_vm.\n@@ -126,2 +126,9 @@\n-  ThreadInVMfromNative transition(JavaThread::current());\n-  event.commit();\n+  JavaThread* thread = JavaThread::current();\n+  JavaThreadState state = thread->thread_state();\n+  if (state == _thread_in_native) {\n+    ThreadInVMfromNative transition(thread);\n+    event.commit();\n+  } else {\n+    assert(state == _thread_in_vm, \"coming from wrong thread state %d\", state);\n+    event.commit();\n+  }\n","filename":"src\/hotspot\/share\/compiler\/compilerEvent.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"gc\/shared\/cardTableRS.hpp\"\n+#include \"gc\/shared\/cardTable.hpp\"\n@@ -42,1 +42,1 @@\n-  size_t card_table_alignment = CardTableRS::ct_max_alignment_constraint();\n+  size_t card_table_alignment = CardTable::ct_max_alignment_constraint();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/g1\/g1FullGCResetMetadataTask.hpp\"\n@@ -120,0 +121,1 @@\n+    _has_compaction_targets(false),\n@@ -210,1 +212,2 @@\n-  phase3_adjust_pointers();\n+  if (has_compaction_targets()) {\n+    phase3_adjust_pointers();\n@@ -212,1 +215,8 @@\n-  phase4_do_compaction();\n+    phase4_do_compaction();\n+  } else {\n+    \/\/ All regions have a high live ratio thus will not be compacted.\n+    \/\/ The live ratio is only considered if do_maximal_compaction is false.\n+    log_info(gc, phases) (\"No Regions selected for compaction. Skipping Phase 3: Adjust pointers and Phase 4: Compact heap\");\n+  }\n+\n+  phase5_reset_metadata();\n@@ -325,0 +335,4 @@\n+  if (!has_compaction_targets()) {\n+    return;\n+  }\n+\n@@ -360,5 +374,0 @@\n-  if (lowest_current == (uint)-1) {\n-    \/\/ worker compaction points are empty\n-    return lowest_current;\n-  }\n-\n@@ -389,3 +398,1 @@\n-  if (start_serial >= _heap->max_reserved_regions()) {\n-    return;\n-  }\n+  assert(start_serial < _heap->max_reserved_regions(), \"Called on empty parallel compaction queues\");\n@@ -434,0 +441,7 @@\n+void G1FullCollector::phase5_reset_metadata() {\n+  \/\/ Clear region metadata that is invalid after GC for all regions.\n+  GCTraceTime(Info, gc, phases) info(\"Phase 5: Reset Metadata\", scope()->timer());\n+  G1FullGCResetMetadataTask task(this);\n+  run_task(&task);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  bool                      _has_compaction_targets;\n@@ -140,0 +141,3 @@\n+  inline void set_has_compaction_targets();\n+  inline bool has_compaction_targets() const;\n+\n@@ -152,0 +156,1 @@\n+  void phase5_reset_metadata();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,10 @@\n+void G1FullCollector::set_has_compaction_targets() {\n+  if (!_has_compaction_targets) {\n+    _has_compaction_targets = true;\n+  }\n+}\n+\n+bool G1FullCollector::has_compaction_targets() const {\n+  return _has_compaction_targets;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.inline.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,37 +37,0 @@\n-\/\/ Do work for all skip-compacting regions.\n-class G1ResetSkipCompactingClosure : public HeapRegionClosure {\n-  G1FullCollector* _collector;\n-\n-public:\n-  G1ResetSkipCompactingClosure(G1FullCollector* collector) : _collector(collector) { }\n-\n-  bool do_heap_region(HeapRegion* r) {\n-    uint region_index = r->hrm_index();\n-    \/\/ Only for skip-compaction regions; early return otherwise.\n-    if (!_collector->is_skip_compacting(region_index)) {\n-      return false;\n-    }\n-#ifdef ASSERT\n-    if (r->is_humongous()) {\n-      oop obj = cast_to_oop(r->humongous_start_region()->bottom());\n-      assert(_collector->mark_bitmap()->is_marked(obj), \"must be live\");\n-    } else if (r->is_open_archive()) {\n-      bool is_empty = (_collector->live_words(r->hrm_index()) == 0);\n-      assert(!is_empty, \"should contain at least one live obj\");\n-    } else if (r->is_closed_archive()) {\n-      \/\/ should early-return above\n-      ShouldNotReachHere();\n-    } else {\n-      assert(_collector->live_words(region_index) > _collector->scope()->region_compaction_threshold(),\n-             \"should be quite full\");\n-    }\n-#endif\n-    assert(_collector->compaction_top(r) == nullptr,\n-           \"region %u compaction_top \" PTR_FORMAT \" must not be different from bottom \" PTR_FORMAT,\n-           r->hrm_index(), p2i(_collector->compaction_top(r)), p2i(r->bottom()));\n-\n-    r->reset_skip_compacting_after_full_gc();\n-    return false;\n-  }\n-};\n-\n@@ -127,4 +90,0 @@\n-\n-  G1ResetSkipCompactingClosure hc(collector());\n-  G1CollectedHeap::heap()->heap_region_par_iterate_from_worker_offset(&hc, &_claimer, worker_id);\n-  log_task(\"Compaction task\", worker_id, start);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":1,"deletions":42,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,6 +98,0 @@\n-\n-  \/\/ Clear region metadata that is invalid after GC for all regions.\n-  {\n-    G1ResetMetadataClosure closure(collector());\n-    G1CollectedHeap::heap()->heap_region_par_iterate_from_start(&closure, &_hrclaimer);\n-  }\n@@ -114,24 +108,0 @@\n-G1FullGCPrepareTask::G1ResetMetadataClosure::G1ResetMetadataClosure(G1FullCollector* collector) :\n-  _g1h(G1CollectedHeap::heap()),\n-  _collector(collector) { }\n-\n-void G1FullGCPrepareTask::G1ResetMetadataClosure::reset_region_metadata(HeapRegion* hr) {\n-  hr->rem_set()->clear();\n-  hr->clear_cardtable();\n-}\n-\n-bool G1FullGCPrepareTask::G1ResetMetadataClosure::do_heap_region(HeapRegion* hr) {\n-  uint const region_idx = hr->hrm_index();\n-  if (!_collector->is_compaction_target(region_idx)) {\n-    assert(!hr->is_free(), \"all free regions should be compaction targets\");\n-    assert(_collector->is_skip_compacting(region_idx) || hr->is_closed_archive(), \"must be\");\n-    if (hr->needs_scrubbing_during_full_gc()) {\n-      scrub_skip_compacting_region(hr, hr->is_young());\n-    }\n-  }\n-\n-  \/\/ Reset data structures not valid after Full GC.\n-  reset_region_metadata(hr);\n-\n-  return false;\n-}\n@@ -154,28 +124,0 @@\n-\n-void G1FullGCPrepareTask::G1ResetMetadataClosure::scrub_skip_compacting_region(HeapRegion* hr, bool update_bot_for_live) {\n-  assert(hr->needs_scrubbing_during_full_gc(), \"must be\");\n-\n-  HeapWord* limit = hr->top();\n-  HeapWord* current_obj = hr->bottom();\n-  G1CMBitMap* bitmap = _collector->mark_bitmap();\n-\n-  while (current_obj < limit) {\n-    if (bitmap->is_marked(current_obj)) {\n-      oop current = cast_to_oop(current_obj);\n-      size_t size = current->size();\n-      if (update_bot_for_live) {\n-        hr->update_bot_for_block(current_obj, current_obj + size);\n-      }\n-      current_obj += size;\n-      continue;\n-    }\n-    \/\/ Found dead object, which is potentially unloaded, scrub to next\n-    \/\/ marked object.\n-    HeapWord* scrub_start = current_obj;\n-    HeapWord* scrub_end = bitmap->get_next_marked_addr(scrub_start, limit);\n-    assert(scrub_start != scrub_end, \"must advance\");\n-    hr->fill_range_with_dead_objects(scrub_start, scrub_end);\n-\n-    current_obj = scrub_end;\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":1,"deletions":59,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -93,16 +93,0 @@\n-  class G1ResetMetadataClosure : public HeapRegionClosure {\n-    G1CollectedHeap* _g1h;\n-    G1FullCollector* _collector;\n-\n-    void reset_region_metadata(HeapRegion* hr);\n-    \/\/ Scrub all runs of dead objects within the given region by putting filler\n-    \/\/ objects and updating the corresponding BOT. If update_bot_for_live is true,\n-    \/\/ also update the BOT for live objects.\n-    void scrub_skip_compacting_region(HeapRegion* hr, bool update_bot_for_live);\n-\n-  public:\n-    G1ResetMetadataClosure(G1FullCollector* collector);\n-\n-    bool do_heap_region(HeapRegion* hr);\n-  };\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+  _collector->set_has_compaction_targets();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1FullCollector.inline.hpp\"\n+#include \"gc\/g1\/g1FullGCResetMetadataTask.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+G1FullGCResetMetadataTask::G1ResetMetadataClosure::G1ResetMetadataClosure(G1FullCollector* collector) :\n+  _g1h(G1CollectedHeap::heap()),\n+  _collector(collector) { }\n+\n+void G1FullGCResetMetadataTask::G1ResetMetadataClosure::reset_region_metadata(HeapRegion* hr) {\n+  hr->rem_set()->clear();\n+  hr->clear_cardtable();\n+}\n+\n+bool G1FullGCResetMetadataTask::G1ResetMetadataClosure::do_heap_region(HeapRegion* hr) {\n+  uint const region_idx = hr->hrm_index();\n+  if (!_collector->is_compaction_target(region_idx)) {\n+    assert(!hr->is_free(), \"all free regions should be compaction targets\");\n+    assert(_collector->is_skip_compacting(region_idx) || hr->is_closed_archive(), \"must be\");\n+    if (hr->needs_scrubbing_during_full_gc()) {\n+      scrub_skip_compacting_region(hr, hr->is_young());\n+    }\n+    if (_collector->is_skip_compacting(region_idx)) {\n+      reset_skip_compacting(hr);\n+    }\n+  }\n+  \/\/ Reset data structures not valid after Full GC.\n+  reset_region_metadata(hr);\n+\n+  return false;\n+}\n+\n+void G1FullGCResetMetadataTask::G1ResetMetadataClosure::scrub_skip_compacting_region(HeapRegion* hr, bool update_bot_for_live) {\n+  assert(hr->needs_scrubbing_during_full_gc(), \"must be\");\n+\n+  HeapWord* limit = hr->top();\n+  HeapWord* current_obj = hr->bottom();\n+  G1CMBitMap* bitmap = _collector->mark_bitmap();\n+\n+  while (current_obj < limit) {\n+    if (bitmap->is_marked(current_obj)) {\n+      oop current = cast_to_oop(current_obj);\n+      size_t size = current->size();\n+      if (update_bot_for_live) {\n+        hr->update_bot_for_block(current_obj, current_obj + size);\n+      }\n+      current_obj += size;\n+      continue;\n+    }\n+    \/\/ Found dead object, which is potentially unloaded, scrub to next\n+    \/\/ marked object.\n+    HeapWord* scrub_start = current_obj;\n+    HeapWord* scrub_end = bitmap->get_next_marked_addr(scrub_start, limit);\n+    assert(scrub_start != scrub_end, \"must advance\");\n+    hr->fill_range_with_dead_objects(scrub_start, scrub_end);\n+\n+    current_obj = scrub_end;\n+  }\n+}\n+\n+void G1FullGCResetMetadataTask::G1ResetMetadataClosure::reset_skip_compacting(HeapRegion* hr) {\n+#ifdef ASSERT\n+  uint region_index = hr->hrm_index();\n+  assert(_collector->is_skip_compacting(region_index), \"Only call on is_skip_compacting regions\");\n+\n+  if (hr->is_humongous()) {\n+    oop obj = cast_to_oop(hr->humongous_start_region()->bottom());\n+    assert(_collector->mark_bitmap()->is_marked(obj), \"must be live\");\n+  } else if (hr->is_open_archive()) {\n+    bool is_empty = (_collector->live_words(hr->hrm_index()) == 0);\n+    assert(!is_empty, \"should contain at least one live obj\");\n+  } else if (hr->is_closed_archive()) {\n+    \/\/ should early-return above\n+    ShouldNotReachHere();\n+  } else {\n+    assert(_collector->live_words(region_index) > _collector->scope()->region_compaction_threshold(),\n+           \"should be quite full\");\n+  }\n+\n+  assert(_collector->compaction_top(hr) == nullptr,\n+         \"region %u compaction_top \" PTR_FORMAT \" must not be different from bottom \" PTR_FORMAT,\n+         hr->hrm_index(), p2i(_collector->compaction_top(hr)), p2i(hr->bottom()));\n+#endif\n+  hr->reset_skip_compacting_after_full_gc();\n+}\n+\n+void G1FullGCResetMetadataTask::work(uint worker_id) {\n+  Ticks start = Ticks::now();\n+  G1ResetMetadataClosure hc(collector());\n+  G1CollectedHeap::heap()->heap_region_par_iterate_from_worker_offset(&hc, &_claimer, worker_id);\n+\n+  log_task(\"Reset Metadata task\", worker_id, start);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCResetMetadataTask.cpp","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1FULLGCRESETMETADATATASK_HPP\n+#define SHARE_GC_G1_G1FULLGCRESETMETADATATASK_HPP\n+#include \"gc\/g1\/g1FullGCTask.hpp\"\n+#include \"gc\/g1\/heapRegion.hpp\"\n+\n+class G1FullGCResetMetadataTask : public G1FullGCTask {\n+  G1FullCollector* _collector;\n+  HeapRegionClaimer _claimer;\n+\n+  class G1ResetMetadataClosure : public HeapRegionClosure {\n+    G1CollectedHeap* _g1h;\n+    G1FullCollector* _collector;\n+\n+    void reset_region_metadata(HeapRegion* hr);\n+    \/\/ Scrub all runs of dead objects within the given region by putting filler\n+    \/\/ objects and updating the corresponding BOT. If update_bot_for_live is true,\n+    \/\/ also update the BOT for live objects.\n+    void scrub_skip_compacting_region(HeapRegion* hr, bool update_bot_for_live);\n+\n+    void reset_skip_compacting(HeapRegion* r);\n+\n+  public:\n+    G1ResetMetadataClosure(G1FullCollector* collector);\n+\n+    bool do_heap_region(HeapRegion* hr);\n+  };\n+\n+public:\n+  G1FullGCResetMetadataTask(G1FullCollector* collector) :\n+    G1FullGCTask(\"G1 Reset Metadata Task\", collector),\n+    _collector(collector),\n+    _claimer(collector->workers()) { }\n+\n+  void work(uint worker_id);\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1FULLGCRESETMETADATATASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCResetMetadataTask.hpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -283,4 +283,0 @@\n-  product(bool, G1VerifyRSetsDuringFullGC, false, DIAGNOSTIC,               \\\n-          \"If true, perform verification of each heap region's \"            \\\n-          \"remembered set when verifying the heap during a full GC.\")       \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -490,1 +490,0 @@\n-  bool _verify_remsets;\n@@ -594,1 +593,1 @@\n-    if (is_live && _verify_remsets) {\n+    if (is_live) {\n@@ -600,1 +599,1 @@\n-  G1VerifyLiveAndRemSetClosure(G1CollectedHeap* g1h, VerifyOption vo, bool verify_remsets) :\n+  G1VerifyLiveAndRemSetClosure(G1CollectedHeap* g1h, VerifyOption vo) :\n@@ -603,1 +602,0 @@\n-    _verify_remsets(verify_remsets),\n@@ -621,2 +619,1 @@\n-  bool verify_rem_sets = !g1h->collector_state()->in_full_gc() || G1VerifyRSetsDuringFullGC;\n-  G1VerifyLiveAndRemSetClosure cl(g1h, vo, verify_rem_sets);\n+  G1VerifyLiveAndRemSetClosure cl(g1h, vo);\n@@ -651,1 +648,1 @@\n-  return false;\n+  return (cl.num_failures() + other_failures) != 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"gc\/shared\/cardTableRS.hpp\"\n+#include \"gc\/serial\/cardTableRS.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/share\/gc\/shared\/cardTableRS.cpp","status":"renamed"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef SHARE_GC_SHARED_CARDTABLERS_HPP\n-#define SHARE_GC_SHARED_CARDTABLERS_HPP\n+#ifndef SHARE_GC_SERIAL_CARDTABLERS_HPP\n+#define SHARE_GC_SERIAL_CARDTABLERS_HPP\n@@ -100,1 +100,1 @@\n-#endif \/\/ SHARE_GC_SHARED_CARDTABLERS_HPP\n+#endif \/\/ SHARE_GC_SERIAL_CARDTABLERS_HPP\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/hotspot\/share\/gc\/shared\/cardTableRS.hpp","status":"renamed"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/serial\/cardTableRS.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"gc\/shared\/cardTableRS.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/cardTableRS.hpp\"\n+#include \"gc\/serial\/cardTableRS.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/serial\/cardTableRS.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"gc\/shared\/cardTableRS.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/serial\/cardTableRS.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"gc\/shared\/cardTableRS.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/serial\/cardTableRS.hpp\"\n@@ -72,0 +73,1 @@\n+  declare_type(CardTableRS, CardTable)                                        \\\n","filename":"src\/hotspot\/share\/gc\/serial\/vmStructs_serial.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"gc\/shared\/cardTableRS.hpp\"\n+#include \"gc\/shared\/cardTable.hpp\"\n@@ -76,1 +76,1 @@\n-  size_t alignment = CardTableRS::ct_max_alignment_constraint();\n+  size_t alignment = CardTable::ct_max_alignment_constraint();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcArguments.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/serial\/cardTableRS.hpp\"\n@@ -38,1 +39,0 @@\n-#include \"gc\/shared\/cardTableRS.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"gc\/shared\/cardTableRS.hpp\"\n+#include \"gc\/serial\/cardTableRS.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"gc\/shared\/cardTableRS.hpp\"\n+#include \"gc\/serial\/cardTableRS.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/generationSpec.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"gc\/shared\/cardTableRS.hpp\"\n+#include \"gc\/serial\/cardTableRS.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/shared\/cardTableRS.hpp\"\n@@ -172,1 +171,0 @@\n-           declare_type(CardTableRS, CardTable)                           \\\n@@ -191,1 +189,0 @@\n-  declare_toplevel_type(CardTableRS*)                                     \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-      case vmIntrinsics::_dsqrt_strict:      return native;\n+      case vmIntrinsics::_dsqrt_strict:      return java_lang_math_sqrt;\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+  JFR_LOG_TAG(jfr, system, periodic) \\\n+  JFR_LOG_TAG(jfr, periodic) \\\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrLogTagSets.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-  size_t       _num_chunks;   \/\/ number of unused chunks in pool\n@@ -60,1 +59,1 @@\n-  ChunkPool(size_t size) : _first(nullptr), _num_chunks(0), _size(size) {}\n+  ChunkPool(size_t size) : _first(nullptr), _size(size) {}\n@@ -68,1 +67,0 @@\n-      _num_chunks--;\n@@ -79,1 +77,0 @@\n-    _num_chunks++;\n@@ -84,4 +81,2 @@\n-    static const int blocksToKeep = 5;\n-    Chunk* cur = nullptr;\n-    Chunk* next;\n-    \/\/ if we have more than n chunks, free all of them\n+    \/\/ Free all chunks while in ThreadCritical lock\n+    \/\/ so NMT adjustment is stable.\n@@ -89,9 +84,3 @@\n-    if (_num_chunks > blocksToKeep) {\n-      \/\/ free chunks at end of queue, for better locality\n-      cur = _first;\n-      for (size_t i = 0; i < (blocksToKeep - 1); i++) {\n-        assert(cur != nullptr, \"counter out of sync?\");\n-        cur = cur->next();\n-      }\n-      assert(cur != nullptr, \"counter out of sync?\");\n-\n+    Chunk* cur = _first;\n+    Chunk* next = nullptr;\n+    while (cur != nullptr) {\n@@ -99,1 +88,1 @@\n-      cur->set_next(nullptr);\n+      os::free(cur);\n@@ -101,9 +90,0 @@\n-\n-      \/\/ Free all remaining chunks while in ThreadCritical lock\n-      \/\/ so NMT adjustment is stable.\n-      while(cur != nullptr) {\n-        next = cur->next();\n-        os::free(cur);\n-        _num_chunks--;\n-        cur = next;\n-      }\n@@ -111,0 +91,1 @@\n+    _first = nullptr;\n@@ -138,1 +119,1 @@\n-  enum { CleaningInterval = 5000 };      \/\/ cleaning interval in ms\n+  static const int cleaning_interval = 5000; \/\/ cleaning interval in ms\n@@ -141,1 +122,1 @@\n-   ChunkPoolCleaner() : PeriodicTask(CleaningInterval) {}\n+   ChunkPoolCleaner() : PeriodicTask(cleaning_interval) {}\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":10,"deletions":29,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -439,1 +439,0 @@\n-  assert(status != RegionNode::LoopStatus::NeverIrreducibleEntry, \"do not set this\");\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -640,8 +640,0 @@\n-  size_table_field = C->env()->Integer_klass()->get_field_by_name(ciSymbol::make(\"sizeTable\"),\n-                                                                  ciSymbols::int_array_signature(), true);\n-  if (size_table_field == NULL) {\n-    \/\/ Something wrong so give up.\n-    assert(false, \"why can't we find Integer.sizeTable?\");\n-    return;\n-  }\n-\n@@ -1171,31 +1163,1 @@\n-Node* PhaseStringOpts::fetch_static_field(GraphKit& kit, ciField* field) {\n-  const TypeInstPtr* mirror_type = TypeInstPtr::make(field->holder()->java_mirror());\n-  Node* klass_node = __ makecon(mirror_type);\n-  BasicType bt = field->layout_type();\n-  ciType* field_klass = field->type();\n-\n-  const Type *type;\n-  if( bt == T_OBJECT ) {\n-    if (!field->type()->is_loaded()) {\n-      type = TypeInstPtr::BOTTOM;\n-    } else if (field->is_static_constant()) {\n-      \/\/ This can happen if the constant oop is non-perm.\n-      ciObject* con = field->constant_value().as_object();\n-      \/\/ Do not \"join\" in the previous type; it doesn't add value,\n-      \/\/ and may yield a vacuous result if the field is of interface type.\n-      type = TypeOopPtr::make_from_constant(con, true)->isa_oopptr();\n-      assert(type != NULL, \"field singleton type must be consistent\");\n-      return __ makecon(type);\n-    } else {\n-      type = TypeOopPtr::make_from_klass(field_klass->as_klass());\n-    }\n-  } else {\n-    type = Type::get_const_basic_type(bt);\n-  }\n-\n-  return kit.make_load(NULL, kit.basic_plus_adr(klass_node, field->offset_in_bytes()),\n-                       type, T_OBJECT,\n-                       C->get_alias_index(mirror_type->add_offset(field->offset_in_bytes())),\n-                       MemNode::unordered);\n-}\n-\n+\/\/ Mirror of Integer.stringSize() method, return the count of digits in integer,\n@@ -1204,9 +1166,5 @@\n-    \/\/ Constant integer. Compute constant length using Integer.sizeTable\n-    int arg_val = arg->get_int();\n-    int count = 1;\n-    if (arg_val < 0) {\n-      \/\/ Special case for min_jint - it can't be negated.\n-      if (arg_val == min_jint) {\n-        return __ intcon(11);\n-      }\n-\n+    \/\/ Constant integer. Compute constant length\n+    jint arg_val = arg->get_int();\n+    jint d = 1;\n+    if (arg_val >= 0) {\n+      d = 0;\n@@ -1214,1 +1172,0 @@\n-      count++;\n@@ -1216,6 +1173,4 @@\n-\n-    ciArray* size_table = (ciArray*)size_table_field->constant_value().as_object();\n-    for (int i = 0; i < size_table->length(); i++) {\n-      if (arg_val <= size_table->element_value(i).as_int()) {\n-        count += i;\n-        break;\n+    jint p = -10;\n+    for (int i = 1; i < 10; i++) {\n+      if (arg_val > p) {\n+        return __ intcon(i + d);\n@@ -1223,0 +1178,1 @@\n+      p = 10 * p;\n@@ -1224,1 +1180,1 @@\n-    return __ intcon(count);\n+    return __ intcon(10 + d);\n@@ -1227,4 +1183,11 @@\n-  RegionNode *final_merge = new RegionNode(3);\n-  kit.gvn().set_type(final_merge, Type::CONTROL);\n-  Node* final_size = new PhiNode(final_merge, TypeInt::INT);\n-  kit.gvn().set_type(final_size, TypeInt::INT);\n+  \/\/ int d = 1;\n+  \/\/ if (x >= 0) {\n+  \/\/     d = 0;\n+  \/\/     x = -x;\n+  \/\/ }\n+  RegionNode* sign_merge = new RegionNode(3);\n+  kit.gvn().set_type(sign_merge, Type::CONTROL);\n+  Node* digit_cnt = new PhiNode(sign_merge, TypeInt::INT);\n+  kit.gvn().set_type(digit_cnt, TypeInt::INT);\n+  Node* val = new PhiNode(sign_merge, TypeInt::INT);\n+  kit.gvn().set_type(val, TypeInt::INT);\n@@ -1233,1 +1196,1 @@\n-                                      __ Bool(__ CmpI(arg, __ intcon(0x80000000)), BoolTest::ne),\n+                                      __ Bool(__ CmpI(arg, __ intcon(0)), BoolTest::ge),\n@@ -1235,69 +1198,18 @@\n-  Node* is_min = __ IfFalse(iff);\n-  final_merge->init_req(1, is_min);\n-  final_size->init_req(1, __ intcon(11));\n-\n-  kit.set_control(__ IfTrue(iff));\n-  if (kit.stopped()) {\n-    final_merge->init_req(2, C->top());\n-    final_size->init_req(2, C->top());\n-  } else {\n-\n-    \/\/ int size = (i < 0) ? stringSize(-i) + 1 : stringSize(i);\n-    RegionNode *r = new RegionNode(3);\n-    kit.gvn().set_type(r, Type::CONTROL);\n-    Node *phi = new PhiNode(r, TypeInt::INT);\n-    kit.gvn().set_type(phi, TypeInt::INT);\n-    Node *size = new PhiNode(r, TypeInt::INT);\n-    kit.gvn().set_type(size, TypeInt::INT);\n-    Node* chk = __ CmpI(arg, __ intcon(0));\n-    Node* p = __ Bool(chk, BoolTest::lt);\n-    IfNode* iff = kit.create_and_map_if(kit.control(), p, PROB_FAIR, COUNT_UNKNOWN);\n-    Node* lessthan = __ IfTrue(iff);\n-    Node* greaterequal = __ IfFalse(iff);\n-    r->init_req(1, lessthan);\n-    phi->init_req(1, __ SubI(__ intcon(0), arg));\n-    size->init_req(1, __ intcon(1));\n-    r->init_req(2, greaterequal);\n-    phi->init_req(2, arg);\n-    size->init_req(2, __ intcon(0));\n-    kit.set_control(r);\n-    C->record_for_igvn(r);\n-    C->record_for_igvn(phi);\n-    C->record_for_igvn(size);\n-\n-    \/\/ for (int i=0; ; i++)\n-    \/\/   if (x <= sizeTable[i])\n-    \/\/     return i+1;\n-\n-    \/\/ Add loop predicate first.\n-    kit.add_empty_predicates();\n-    C->set_has_loops(true);\n-\n-    RegionNode *loop = new RegionNode(3);\n-    loop->init_req(1, kit.control());\n-    kit.gvn().set_type(loop, Type::CONTROL);\n-\n-    Node *index = new PhiNode(loop, TypeInt::INT);\n-    index->init_req(1, __ intcon(0));\n-    kit.gvn().set_type(index, TypeInt::INT);\n-    kit.set_control(loop);\n-    Node* sizeTable = fetch_static_field(kit, size_table_field);\n-\n-    Node* value = kit.load_array_element(sizeTable, index, TypeAryPtr::INTS, \/* set_ctrl *\/ false);\n-    C->record_for_igvn(value);\n-    Node* limit = __ CmpI(phi, value);\n-    Node* limitb = __ Bool(limit, BoolTest::le);\n-    IfNode* iff2 = kit.create_and_map_if(kit.control(), limitb, PROB_MIN, COUNT_UNKNOWN);\n-    Node* lessEqual = __ IfTrue(iff2);\n-    Node* greater = __ IfFalse(iff2);\n-\n-    loop->init_req(2, greater);\n-    index->init_req(2, __ AddI(index, __ intcon(1)));\n-\n-    kit.set_control(lessEqual);\n-    C->record_for_igvn(loop);\n-    C->record_for_igvn(index);\n-\n-    final_merge->init_req(2, kit.control());\n-    final_size->init_req(2, __ AddI(__ AddI(index, size), __ intcon(1)));\n-  }\n+  sign_merge->init_req(1, __ IfTrue(iff));\n+  sign_merge->init_req(2, __ IfFalse(iff));\n+  digit_cnt->init_req(1, __ intcon(0));\n+  digit_cnt->init_req(2, __ intcon(1));\n+  val->init_req(1, __ SubI(__ intcon(0), arg));\n+  val->init_req(2, arg);\n+  kit.set_control(sign_merge);\n+\n+  \/\/ int p = -10;\n+  \/\/ for (int i = 1; i < 10; i++) {\n+  \/\/     if (x > p)\n+  \/\/         return i + d;\n+  \/\/     p = 10 * p;\n+  \/\/ }\n+  RegionNode* final_merge = new RegionNode(3);\n+  kit.gvn().set_type(final_merge, Type::CONTROL);\n+  Node* final_size = new PhiNode(final_merge, TypeInt::INT);\n+  kit.gvn().set_type(final_size, TypeInt::INT);\n@@ -1305,0 +1217,35 @@\n+  kit.add_empty_predicates();\n+  C->set_has_loops(true);\n+\n+  RegionNode* loop = new RegionNode(3);\n+  kit.gvn().set_type(loop, Type::CONTROL);\n+  Node* index = new PhiNode(loop, TypeInt::INT);\n+  kit.gvn().set_type(index, TypeInt::INT);\n+  Node* temp = new PhiNode(loop, TypeInt::INT);\n+  kit.gvn().set_type(temp, TypeInt::INT);\n+\n+  loop->init_req(1, kit.control());\n+  index->init_req(1, __ intcon(1));\n+  temp->init_req(1, __ intcon(-10));\n+  kit.set_control(loop);\n+\n+  Node* limit = __ CmpI(index, __ intcon(10));\n+  Node* limitb = __ Bool(limit, BoolTest::lt);\n+  IfNode* iff2 = kit.create_and_map_if(kit.control(), limitb, PROB_MIN, COUNT_UNKNOWN);\n+  Node* limit_less = __ IfTrue(iff2);\n+  kit.set_control(limit_less);\n+\n+  Node* cmp = __ CmpI(val, temp);\n+  Node* cmpb = __ Bool(cmp, BoolTest::gt);\n+  IfNode* iff3 = kit.create_and_map_if(kit.control(), cmpb, PROB_MIN, COUNT_UNKNOWN);\n+  Node* cmp_le = __ IfFalse(iff3);\n+  kit.set_control(cmp_le);\n+\n+  loop->init_req(2, kit.control());\n+  index->init_req(2, __ AddI(index, __ intcon(1)));\n+  temp->init_req(2, __ MulI(temp, __ intcon(10)));\n+\n+  final_merge->init_req(1, __ IfFalse(iff2));\n+  final_merge->init_req(2, __ IfTrue(iff3));\n+  final_size->init_req(1, __ AddI(digit_cnt, __ intcon(10)));\n+  final_size->init_req(2, __ AddI(digit_cnt, index));\n@@ -1306,0 +1253,4 @@\n+\n+  C->record_for_igvn(sign_merge);\n+  C->record_for_igvn(digit_cnt);\n+  C->record_for_igvn(val);\n@@ -1308,1 +1259,3 @@\n-\n+  C->record_for_igvn(loop);\n+  C->record_for_igvn(index);\n+  C->record_for_igvn(temp);\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":85,"deletions":132,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,3 +46,0 @@\n-  \/\/ Integer.sizeTable - used for int to String conversion\n-  ciField* size_table_field;\n-\n@@ -62,3 +59,0 @@\n-  \/\/ Load the value of a static field, performing any constant folding.\n-  Node* fetch_static_field(GraphKit& kit, ciField* field);\n-\n","filename":"src\/hotspot\/share\/opto\/stringopts.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2961,1 +2961,1 @@\n-      return speculative->klass();\n+      return speculative->exact_klass();\n@@ -5053,0 +5053,5 @@\n+      if (above_centerline(ptr) || ptr == Constant) {\n+        ptr = NotNull;\n+        res_xk = false;\n+        return NOT_SUBTYPE;\n+      }\n@@ -5088,1 +5093,1 @@\n-          res_xk = true;\n+        res_xk = true;\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3477,1 +3477,2 @@\n-    if (os::same_files((const char*)get_default_shared_archive_path(), ArchiveClassesAtExit)) {\n+    char* shared_archive_path = get_default_shared_archive_path();\n+    if (os::same_files(shared_archive_path, ArchiveClassesAtExit)) {\n@@ -3479,1 +3480,1 @@\n-        \"Cannot specify the default CDS archive for -XX:ArchiveClassesAtExit\", get_default_shared_archive_path());\n+        \"Cannot specify the default CDS archive for -XX:ArchiveClassesAtExit\", shared_archive_path);\n@@ -3481,0 +3482,1 @@\n+    FREE_C_HEAP_ARRAY(char, shared_archive_path);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -579,1 +579,1 @@\n-  static void infinite_sleep();\n+  [[noreturn]] static void infinite_sleep();\n@@ -604,1 +604,1 @@\n-  static void exit(int num);\n+  [[noreturn]] static void exit(int num);\n@@ -608,1 +608,1 @@\n-  static void _exit(int num);\n+  [[noreturn]] static void _exit(int num);\n@@ -615,2 +615,2 @@\n-  static void abort(bool dump_core, void *siginfo, const void *context);\n-  static void abort(bool dump_core = true);\n+  [[noreturn]] static void abort(bool dump_core, void *siginfo, const void *context);\n+  [[noreturn]] static void abort(bool dump_core = true);\n@@ -623,1 +623,1 @@\n-  static void die();\n+  [[noreturn]] static void die();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -181,0 +181,5 @@\n+template <> void DCmdArgument<char*>::destroy_value() {\n+  FREE_C_HEAP_ARRAY(char, _value);\n+  set_value(nullptr);\n+}\n+\n@@ -184,1 +189,1 @@\n-    _value = nullptr;\n+    destroy_value();\n@@ -186,1 +191,2 @@\n-    _value = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);\n+    \/\/ Use realloc as we may have a default set.\n+    _value = REALLOC_C_HEAP_ARRAY(char, _value, len + 1, mtInternal);\n@@ -193,1 +199,2 @@\n-  if (has_default() && _default_string != nullptr) {\n+  set_value(nullptr); \/\/ Must be initialized before calling parse_value\n+  if (has_default()) {\n@@ -195,5 +202,0 @@\n-    if (HAS_PENDING_EXCEPTION) {\n-     fatal(\"Default string must be parsable\");\n-    }\n-  } else {\n-    set_value(nullptr);\n@@ -203,5 +205,0 @@\n-template <> void DCmdArgument<char*>::destroy_value() {\n-  FREE_C_HEAP_ARRAY(char, _value);\n-  set_value(nullptr);\n-}\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticArgument.cpp","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -810,1 +810,2 @@\n-          output()->print_cr(\"%s\", out);\n+          \/\/ Avoid using print_cr() because length maybe longer than O_BUFLEN\n+          output()->print_raw_cr(out);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-  NMTPreInit::pre_to_post();\n+  NMTPreInit::pre_to_post(level == NMT_off);\n","filename":"src\/hotspot\/share\/services\/memTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, 2023 SAP SE. All rights reserved.\n@@ -40,4 +40,0 @@\n-\/\/ We must ensure that the start of the payload area of the nmt lookup table nodes is malloc-aligned\n-static const size_t malloc_alignment = 2 * sizeof(void*); \/\/ could we use max_align_t?\n-STATIC_ASSERT(is_aligned(sizeof(NMTPreInitAllocation), malloc_alignment));\n-\n@@ -47,5 +43,0 @@\n-static void fail_oom(size_t size) {\n-  vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, \"VM early initialization phase\");\n-}\n-\n-\/\/ --------- NMTPreInitAllocation --------------\n@@ -53,4 +44,2 @@\n-NMTPreInitAllocation* NMTPreInitAllocation::do_alloc(size_t payload_size) {\n-  const size_t outer_size = sizeof(NMTPreInitAllocation) + payload_size;\n-  guarantee(outer_size > payload_size, \"Overflow\");\n-  void* p = raw_malloc(outer_size);\n+static void* raw_checked_malloc(size_t s) {\n+  void* p = raw_malloc(s);\n@@ -58,1 +47,1 @@\n-    fail_oom(outer_size);\n+    vm_exit_out_of_memory(s, OOM_MALLOC_ERROR, \"VM early initialization phase\");\n@@ -60,2 +49,1 @@\n-  NMTPreInitAllocation* a = new(p) NMTPreInitAllocation(payload_size);\n-  return a;\n+  return p;\n@@ -64,6 +52,2 @@\n-NMTPreInitAllocation* NMTPreInitAllocation::do_reallocate(NMTPreInitAllocation* old, size_t new_payload_size) {\n-  assert(old->next == nullptr, \"unhang from map first\");\n-  \/\/ We just reallocate the old block, header and all.\n-  const size_t new_outer_size = sizeof(NMTPreInitAllocation) + new_payload_size;\n-  guarantee(new_outer_size > new_payload_size, \"Overflow\");\n-  void* p = raw_realloc(old, new_outer_size);\n+static void* raw_checked_realloc(void* old, size_t s) {\n+  void* p = raw_realloc(old, s);\n@@ -71,1 +55,1 @@\n-    fail_oom(new_outer_size);\n+    vm_exit_out_of_memory(s, OOM_MALLOC_ERROR, \"VM early initialization phase\");\n@@ -73,3 +57,1 @@\n-  \/\/ re-stamp header with new size\n-  NMTPreInitAllocation* a = new(p) NMTPreInitAllocation(new_payload_size);\n-  return a;\n+  return p;\n@@ -78,2 +60,7 @@\n-void NMTPreInitAllocation::do_free(NMTPreInitAllocation* p) {\n-  assert(p->next == nullptr, \"unhang from map first\");\n+\/\/ --------- NMTPreInitAllocation --------------\n+\n+void* NMTPreInitAllocation::operator new(size_t count) {\n+  return raw_checked_malloc(count);\n+}\n+\n+void NMTPreInitAllocation::operator delete(void* p) {\n@@ -83,0 +70,20 @@\n+NMTPreInitAllocation* NMTPreInitAllocation::do_alloc(size_t payload_size) {\n+  void* payload = raw_checked_malloc(payload_size);\n+  NMTPreInitAllocation* a = new NMTPreInitAllocation(payload_size, payload);\n+  return a;\n+}\n+\n+NMTPreInitAllocation* NMTPreInitAllocation::do_reallocate(NMTPreInitAllocation* a, size_t new_payload_size) {\n+  assert(a->next == nullptr, \"unhang from map first\");\n+  void* new_payload = raw_checked_realloc(a->payload, new_payload_size);\n+  NMTPreInitAllocation* a2 = new NMTPreInitAllocation(new_payload_size, new_payload);\n+  delete a;\n+  return a2;\n+}\n+\n+void NMTPreInitAllocation::do_free(NMTPreInitAllocation* a) {\n+  assert(a->next == nullptr, \"unhang from map first\");\n+  raw_free(a->payload);\n+  delete a;\n+}\n+\n@@ -85,0 +92,8 @@\n+void* NMTPreInitAllocationTable::operator new(size_t count) {\n+  return raw_checked_malloc(count);\n+}\n+\n+void NMTPreInitAllocationTable::operator delete(void* p) {\n+  return raw_free(p);\n+}\n+\n@@ -89,0 +104,12 @@\n+NMTPreInitAllocationTable::~NMTPreInitAllocationTable() {\n+  \/\/ clear LU entries, but let payloads live!\n+  for (int i = 0; i < table_size; i++) {\n+    NMTPreInitAllocation* a = _entries[i];\n+    while (a != nullptr) {\n+      NMTPreInitAllocation* a2 = a->next;\n+      delete a;\n+      a = a2;\n+    }\n+  }\n+}\n+\n@@ -119,1 +146,1 @@\n-      st->print( PTR_FORMAT \"(\" SIZE_FORMAT \") \", p2i(a->payload()), a->size);\n+      st->print( PTR_FORMAT \"(\" SIZE_FORMAT \") \", p2i(a->payload), a->size);\n@@ -135,1 +162,1 @@\n-      index_t i2 = index_for_key(a->payload());\n+      index_t i2 = index_for_key(a->payload);\n@@ -170,2 +197,1 @@\n-  void* p = raw_malloc(sizeof(NMTPreInitAllocationTable));\n-  _table = new(p) NMTPreInitAllocationTable();\n+  _table = new NMTPreInitAllocationTable;\n@@ -181,1 +207,2 @@\n-void NMTPreInit::pre_to_post() {\n+void NMTPreInit::pre_to_post(bool nmt_off) {\n+\n@@ -184,0 +211,13 @@\n+  if (nmt_off) {\n+    \/\/ NMT is disabled.\n+    \/\/ Since neither pre- nor post-init-allocations use headers, from now on any pre-init allocation\n+    \/\/ can be handled directly by os::realloc or os::free.\n+    \/\/ We also can get rid of the lookup table.\n+    \/\/ Note that we deliberately leak the headers (NMTPreInitAllocation) in order to speed up startup.\n+    \/\/ That may leak about 12KB of memory for ~500 surviving pre-init allocations, which is a typical\n+    \/\/ number. This is a compromise to keep the coding simple and startup time short. It could very\n+    \/\/ easily improved by keeping a header pool, similar to metaspace ChunkHeaderPool. But since NMTPreInit\n+    \/\/ had been critizised as \"too complicated\", I try to keep things short and simple.\n+    delete _table;\n+    _table = nullptr;\n+  }\n","filename":"src\/hotspot\/share\/services\/nmtPreInit.cpp","additions":74,"deletions":34,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, 2023 SAP SE. All rights reserved.\n@@ -124,1 +124,1 @@\n-  \/\/ <-- USER ALLOCATION (PAYLOAD) STARTS HERE -->\n+  void* const payload;\n@@ -126,5 +126,1 @@\n-  NMTPreInitAllocation(size_t size) : next(nullptr), size(size) {};\n-\n-  \/\/ Returns start of the user data area\n-  void* payload()             { return this + 1; }\n-  const void* payload() const { return this + 1; }\n+  NMTPreInitAllocation(size_t s, void* p) : next(nullptr), size(s), payload(p) {}\n@@ -135,2 +131,5 @@\n-  static NMTPreInitAllocation* do_reallocate(NMTPreInitAllocation* old, size_t new_payload_size);\n-  static void do_free(NMTPreInitAllocation* p);\n+  static NMTPreInitAllocation* do_reallocate(NMTPreInitAllocation* a, size_t new_payload_size);\n+  static void do_free(NMTPreInitAllocation* a);\n+\n+  void* operator new(size_t l);\n+  void  operator delete(void* p);\n@@ -173,1 +172,1 @@\n-    while ((*aa) != nullptr && (*aa)->payload() != p) {\n+    while ((*aa) != nullptr && (*aa)->payload != p) {\n@@ -176,1 +175,1 @@\n-    assert((*aa) == nullptr || p == (*aa)->payload(),\n+    assert((*aa) == nullptr || p == (*aa)->payload,\n@@ -178,1 +177,1 @@\n-           p2i(p), p2i((*aa)->payload()));\n+           p2i(p), p2i((*aa)->payload));\n@@ -185,0 +184,1 @@\n+  ~NMTPreInitAllocationTable();\n@@ -188,1 +188,1 @@\n-    void* payload = a->payload();\n+    void* payload = a->payload;\n@@ -215,0 +215,3 @@\n+\n+  void* operator new(size_t l);\n+  void  operator delete(void* p);\n@@ -228,0 +231,1 @@\n+  static void delete_table();\n@@ -257,1 +261,1 @@\n-  static void pre_to_post();\n+  static void pre_to_post(bool nmt_off);\n@@ -269,1 +273,1 @@\n-      (*rc) = a->payload();\n+      (*rc) = a->payload;\n@@ -284,27 +288,10 @@\n-    if (!MemTracker::is_initialized()) {\n-      \/\/ pre-NMT-init:\n-      \/\/ - the address must already be in the lookup table\n-      \/\/ - find the old entry, remove from table, reallocate, add to table\n-      NMTPreInitAllocation* a = find_and_remove_in_map(old_p);\n-      a = NMTPreInitAllocation::do_reallocate(a, new_size);\n-      add_to_map(a);\n-      (*rc) = a->payload();\n-      _num_reallocs_pre++;\n-      return true;\n-    } else {\n-      \/\/ post-NMT-init:\n-      \/\/ If the old block was allocated during pre-NMT-init, we must relocate it: the\n-      \/\/  new block must be allocated with \"normal\" os::malloc.\n-      \/\/ We do this by:\n-      \/\/ - look up (but not remove! lu table is read-only here.) the old entry\n-      \/\/ - allocate new memory via os::malloc()\n-      \/\/ - manually copy the old content over\n-      \/\/ - return the new memory\n-      \/\/ - The lu table is readonly so we keep the old address in the table. And we leave\n-      \/\/   the old block allocated too, to prevent the libc from returning the same address\n-      \/\/   and confusing us.\n-      const NMTPreInitAllocation* a = find_in_map(old_p);\n-      if (a != nullptr) { \/\/ this was originally a pre-init allocation\n-        void* p_new = do_os_malloc(new_size, memflags);\n-        ::memcpy(p_new, a->payload(), MIN2(a->size, new_size));\n-        (*rc) = p_new;\n+    switch (MemTracker::tracking_level()) {\n+      case NMT_unknown: {\n+        \/\/ pre-NMT-init:\n+        \/\/ - the address must already be in the lookup table\n+        \/\/ - find the old entry, remove from table, reallocate, add to table\n+        NMTPreInitAllocation* a = find_and_remove_in_map(old_p);\n+        a = NMTPreInitAllocation::do_reallocate(a, new_size);\n+        add_to_map(a);\n+        (*rc) = a->payload;\n+        _num_reallocs_pre++;\n@@ -313,0 +300,28 @@\n+      break;\n+      case NMT_off: {\n+        \/\/ post-NMT-init, NMT *disabled*:\n+        \/\/ Neither pre- nor post-init-allocation use malloc headers, therefore we can just\n+        \/\/ relegate the realloc to os::realloc.\n+        return false;\n+      }\n+      break;\n+      default: {\n+        \/\/ post-NMT-init, NMT *enabled*:\n+        \/\/ Pre-init allocation does not use malloc header, but from here on we need malloc headers.\n+        \/\/ Therefore, the new block must be allocated with os::malloc.\n+        \/\/ We do this by:\n+        \/\/ - look up (but don't remove! lu table is read-only here.) the old entry\n+        \/\/ - allocate new memory via os::malloc()\n+        \/\/ - manually copy the old content over\n+        \/\/ - return the new memory\n+        \/\/ - The lu table is readonly, so we keep the old address in the table. And we leave\n+        \/\/   the old block allocated too, to prevent the libc from returning the same address\n+        \/\/   and confusing us.\n+        const NMTPreInitAllocation* a = find_in_map(old_p);\n+        if (a != nullptr) { \/\/ this was originally a pre-init allocation\n+          void* p_new = do_os_malloc(new_size, memflags);\n+          ::memcpy(p_new, a->payload, MIN2(a->size, new_size));\n+          (*rc) = p_new;\n+          return true;\n+        }\n+      }\n@@ -323,17 +338,9 @@\n-    if (!MemTracker::is_initialized()) {\n-      \/\/ pre-NMT-init:\n-      \/\/ - the allocation must be in the hash map, since all allocations went through\n-      \/\/   NMTPreInit::handle_malloc()\n-      \/\/ - find the old entry, unhang from map, free it\n-      NMTPreInitAllocation* a = find_and_remove_in_map(p);\n-      NMTPreInitAllocation::do_free(a);\n-      _num_frees_pre++;\n-      return true;\n-    } else {\n-      \/\/ post-NMT-init:\n-      \/\/ - look up (but not remove! lu table is read-only here.) the entry\n-      \/\/ - if found, we do nothing: the lu table is readonly, so we keep the old address\n-      \/\/   in the table. We leave the block allocated to prevent the libc from returning\n-      \/\/   the same address and confusing us.\n-      \/\/ - if not found, we let regular os::free() handle this pointer\n-      if (find_in_map(p) != nullptr) {\n+    switch (MemTracker::tracking_level()) {\n+      case NMT_unknown: {\n+        \/\/ pre-NMT-init:\n+        \/\/ - the allocation must be in the hash map, since all allocations went through\n+        \/\/   NMTPreInit::handle_malloc()\n+        \/\/ - find the old entry, unhang from map, free it\n+        NMTPreInitAllocation* a = find_and_remove_in_map(p);\n+        NMTPreInitAllocation::do_free(a);\n+        _num_frees_pre++;\n@@ -342,0 +349,19 @@\n+      break;\n+      case NMT_off: {\n+        \/\/ post-NMT-init, NMT *disabled*:\n+        \/\/ Neither pre- nor post-init-allocation use malloc headers, therefore we can just\n+        \/\/ relegate the realloc to os::realloc.\n+        return false;\n+      }\n+      break;\n+      default: {\n+        \/\/ post-NMT-init, NMT *enabled*:\n+        \/\/ - look up (but don't remove! lu table is read-only here.) the entry\n+        \/\/ - if found, we do nothing: the lu table is readonly, so we keep the old address\n+        \/\/   in the table. We leave the block allocated to prevent the libc from returning\n+        \/\/   the same address and confusing us.\n+        \/\/ - if not found, we let regular os::free() handle this pointer\n+        if (find_in_map(p) != nullptr) {\n+          return true;\n+        }\n+      }\n","filename":"src\/hotspot\/share\/services\/nmtPreInit.hpp","additions":85,"deletions":59,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-void BitMap::at_put(idx_t offset, bool value) {\n+void BitMap::at_put(idx_t bit, bool value) {\n@@ -298,1 +298,1 @@\n-    set_bit(offset);\n+    set_bit(bit);\n@@ -300,1 +300,1 @@\n-    clear_bit(offset);\n+    clear_bit(bit);\n@@ -323,1 +323,1 @@\n-void BitMap::at_put_range(idx_t beg_offset, idx_t end_offset, bool value) {\n+void BitMap::at_put_range(idx_t beg, idx_t end, bool value) {\n@@ -325,1 +325,1 @@\n-    set_range(beg_offset, end_offset);\n+    set_range(beg, end);\n@@ -327,1 +327,1 @@\n-    clear_range(beg_offset, end_offset);\n+    clear_range(beg, end);\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,0 @@\n-  bm_word_t  map(idx_t word) const { return _map[word]; }\n@@ -138,0 +137,5 @@\n+  \/\/ Get a word and flip its bits according to flip.\n+  bm_word_t flipped_word(idx_t word, bm_word_t flip) const {\n+    return _map[word] ^ flip;\n+  }\n+\n@@ -215,2 +219,2 @@\n-  void at_put(idx_t index, bool value);\n-  bool par_at_put(idx_t index, bool value);\n+  void at_put(idx_t bit, bool value);\n+  bool par_at_put(idx_t bit, bool value);\n@@ -271,2 +275,2 @@\n-  idx_t get_next_one_offset(idx_t offset) const {\n-    return get_next_one_offset(offset, size());\n+  idx_t get_next_one_offset(idx_t beg) const {\n+    return get_next_one_offset(beg, size());\n@@ -274,2 +278,2 @@\n-  idx_t get_next_zero_offset(idx_t offset) const {\n-    return get_next_zero_offset(offset, size());\n+  idx_t get_next_zero_offset(idx_t beg) const {\n+    return get_next_zero_offset(beg, size());\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,2 +56,2 @@\n-inline bool BitMap::par_at(idx_t index, atomic_memory_order memory_order) const {\n-  verify_index(index);\n+inline bool BitMap::par_at(idx_t bit, atomic_memory_order memory_order) const {\n+  verify_index(bit);\n@@ -61,2 +61,2 @@\n-  const volatile bm_word_t* const addr = word_addr(index);\n-  return (load_word_ordered(addr, memory_order) & bit_mask(index)) != 0;\n+  const volatile bm_word_t* const addr = word_addr(bit);\n+  return (load_word_ordered(addr, memory_order) & bit_mask(bit)) != 0;\n@@ -169,1 +169,1 @@\n-inline BitMap::idx_t BitMap::get_next_bit_impl(idx_t l_index, idx_t r_index) const {\n+inline BitMap::idx_t BitMap::get_next_bit_impl(idx_t beg, idx_t end) const {\n@@ -171,2 +171,2 @@\n-  verify_range(l_index, r_index);\n-  assert(!aligned_right || is_aligned(r_index, BitsPerWord), \"r_index not aligned\");\n+  verify_range(beg, end);\n+  assert(!aligned_right || is_aligned(end, BitsPerWord), \"end not aligned\");\n@@ -183,1 +183,1 @@\n-  \/\/ However, callers often have a comparison with r_index, and\n+  \/\/ However, callers often have a comparison with end, and\n@@ -186,1 +186,1 @@\n-  \/\/ r_index or a value dominated by a comparison with r_index.\n+  \/\/ end or a value dominated by a comparison with end.\n@@ -191,4 +191,4 @@\n-  if (l_index < r_index) {\n-    \/\/ Get the word containing l_index, and shift out low bits.\n-    idx_t index = to_words_align_down(l_index);\n-    bm_word_t cword = (map(index) ^ flip) >> bit_in_word(l_index);\n+  if (beg < end) {\n+    \/\/ Get the word containing beg, and shift out low bits.\n+    idx_t word_index = to_words_align_down(beg);\n+    bm_word_t cword = flipped_word(word_index, flip) >> bit_in_word(beg);\n@@ -203,1 +203,1 @@\n-      return l_index;\n+      return beg;\n@@ -206,3 +206,3 @@\n-      idx_t result = l_index + count_trailing_zeros(cword);\n-      if (aligned_right || (result < r_index)) return result;\n-      \/\/ Result is beyond range bound; return r_index.\n+      idx_t result = beg + count_trailing_zeros(cword);\n+      if (aligned_right || (result < end)) return result;\n+      \/\/ Result is beyond range bound; return end.\n@@ -211,6 +211,6 @@\n-      \/\/ aligned up r_index for a non-zero flipped word.\n-      idx_t limit = aligned_right\n-        ? to_words_align_down(r_index) \/\/ Minuscule savings when aligned.\n-        : to_words_align_up(r_index);\n-      while (++index < limit) {\n-        cword = map(index) ^ flip;\n+      \/\/ aligned up end for a non-zero flipped word.\n+      idx_t word_limit = aligned_right\n+        ? to_words_align_down(end) \/\/ Minuscule savings when aligned.\n+        : to_words_align_up(end);\n+      while (++word_index < word_limit) {\n+        cword = flipped_word(word_index, flip);\n@@ -218,4 +218,4 @@\n-          idx_t result = bit_index(index) + count_trailing_zeros(cword);\n-          if (aligned_right || (result < r_index)) return result;\n-          \/\/ Result is beyond range bound; return r_index.\n-          assert((index + 1) == limit, \"invariant\");\n+          idx_t result = bit_index(word_index) + count_trailing_zeros(cword);\n+          if (aligned_right || (result < end)) return result;\n+          \/\/ Result is beyond range bound; return end.\n+          assert((word_index + 1) == word_limit, \"invariant\");\n@@ -225,1 +225,1 @@\n-      \/\/ No bits in range; return r_index.\n+      \/\/ No bits in range; return end.\n@@ -228,1 +228,1 @@\n-  return r_index;\n+  return end;\n@@ -232,2 +232,2 @@\n-BitMap::get_next_one_offset(idx_t l_offset, idx_t r_offset) const {\n-  return get_next_bit_impl<find_ones_flip, false>(l_offset, r_offset);\n+BitMap::get_next_one_offset(idx_t beg, idx_t end) const {\n+  return get_next_bit_impl<find_ones_flip, false>(beg, end);\n@@ -237,2 +237,2 @@\n-BitMap::get_next_zero_offset(idx_t l_offset, idx_t r_offset) const {\n-  return get_next_bit_impl<find_zeros_flip, false>(l_offset, r_offset);\n+BitMap::get_next_zero_offset(idx_t beg, idx_t end) const {\n+  return get_next_bit_impl<find_zeros_flip, false>(beg, end);\n@@ -242,2 +242,2 @@\n-BitMap::get_next_one_offset_aligned_right(idx_t l_offset, idx_t r_offset) const {\n-  return get_next_bit_impl<find_ones_flip, true>(l_offset, r_offset);\n+BitMap::get_next_one_offset_aligned_right(idx_t beg, idx_t end) const {\n+  return get_next_bit_impl<find_ones_flip, true>(beg, end);\n","filename":"src\/hotspot\/share\/utilities\/bitMap.inline.hpp","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -880,0 +880,2 @@\n+    ~LineNumberProgram() { delete _state; }\n+\n","filename":"src\/hotspot\/share\/utilities\/elfFile.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1445,7 +1445,0 @@\n-#if defined(_WINDOWS)\n-    \/\/ If UseOSErrorReporting we call this for each level of the call stack\n-    \/\/ while searching for the exception handler.  Only the first level needs\n-    \/\/ to be reported.\n-    if (UseOSErrorReporting && log_done) return;\n-#endif\n-\n@@ -1681,9 +1674,12 @@\n-  if (WINDOWS_ONLY(!UseOSErrorReporting) NOT_WINDOWS(true)) {\n-    \/\/ os::abort() will call abort hooks, try it first.\n-    static bool skip_os_abort = false;\n-    if (!skip_os_abort) {\n-      skip_os_abort = true;\n-      bool dump_core = should_report_bug(_id);\n-      os::abort(dump_core && CreateCoredumpOnCrash, _siginfo, _context);\n-    }\n-\n+#if defined _WINDOWS\n+  if (UseOSErrorReporting) {\n+    raise_fail_fast(_siginfo, _context);\n+  }\n+#endif \/\/ _WINDOWS\n+\n+  \/\/ os::abort() will call abort hooks, try it first.\n+  static bool skip_os_abort = false;\n+  if (!skip_os_abort) {\n+    skip_os_abort = true;\n+    bool dump_core = should_report_bug(_id);\n+    os::abort(dump_core && CreateCoredumpOnCrash, _siginfo, _context);\n@@ -1691,1 +1687,0 @@\n-    os::die();\n@@ -1693,0 +1688,1 @@\n+  os::die();\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -139,0 +139,2 @@\n+  WINDOWS_ONLY([[noreturn]] static void raise_fail_fast(void* exrecord, void* context);)\n+\n@@ -157,0 +159,2 @@\n+  [[noreturn]]\n+  ATTRIBUTE_PRINTF(6, 7)\n@@ -158,1 +162,1 @@\n-                             void* context, const char* detail_fmt, ...) ATTRIBUTE_PRINTF(6, 7);\n+                             void* context, const char* detail_fmt, ...);\n@@ -160,0 +164,2 @@\n+  [[noreturn]]\n+  ATTRIBUTE_PRINTF(3, 0)\n@@ -162,1 +168,1 @@\n-                             const char* filename, int lineno, size_t size) ATTRIBUTE_PRINTF(3, 0);\n+                             const char* filename, int lineno, size_t size);\n@@ -164,0 +170,1 @@\n+  [[noreturn]]\n@@ -167,0 +174,2 @@\n+  [[noreturn]]\n+  ATTRIBUTE_PRINTF(6, 0)\n@@ -168,1 +177,1 @@\n-                             const char* detail_fmt, va_list detail_args) ATTRIBUTE_PRINTF(6, 0);\n+                             const char* detail_fmt, va_list detail_args);\n@@ -170,0 +179,2 @@\n+  [[noreturn]]\n+  ATTRIBUTE_PRINTF(6, 0)\n@@ -172,1 +183,1 @@\n-                             va_list detail_args) ATTRIBUTE_PRINTF(6, 0);\n+                             va_list detail_args);\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -388,1 +388,4 @@\n-    CHECK_NULL(jc_KeychainStore);\n+    if (jc_KeychainStore == NULL) {\n+        goto errOut;\n+    }\n+\n@@ -391,1 +394,4 @@\n-    CHECK_NULL(jm_createTrustedCertEntry);\n+    if (jm_createTrustedCertEntry == NULL) {\n+        goto errOut;\n+    }\n+\n@@ -393,1 +399,4 @@\n-    CHECK_NULL(jc_arrayListClass);\n+    if (jc_arrayListClass == NULL) {\n+        goto errOut;\n+    }\n+\n@@ -395,1 +404,4 @@\n-    CHECK_NULL(jm_arrayListCons);\n+    if (jm_arrayListCons == NULL) {\n+        goto errOut;\n+    }\n+\n@@ -397,1 +409,3 @@\n-    CHECK_NULL(jm_listAdd);\n+    if (jm_listAdd == NULL) {\n+        goto errOut;\n+    }\n@@ -428,1 +442,4 @@\n-            CHECK_NULL(inputTrust);\n+            if (inputTrust == NULL) {\n+                CFRelease(trustSettings);\n+                goto errOut;\n+            }\n","filename":"src\/java.base\/macosx\/native\/libosxsecurity\/KeystoreImpl.m","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -141,4 +141,5 @@\n-        int l = ch | 0x20; \/\/ Lowercase using 'oldest ASCII trick in the book'\n-        if (l <= 'z' \/\/ In range a-z\n-                || (l >= 0xE0 && l <= 0xFE && l != 0xF7)) { \/\/ ..or agrave-thorn, excluding division\n-            return l;\n+        \/\/ ASCII and Latin-1 were designed to optimize case-twiddling operations\n+        int lower = ch | 0x20;\n+        if (lower <= 'z' \/\/ In range a-z\n+                || (lower >= 0xE0 && lower <= 0xFE && lower != 0xF7)) { \/\/ ..or agrave-thorn, excluding division\n+            return lower;\n@@ -153,4 +154,5 @@\n-        int U = ch & 0xDF; \/\/ Uppercase using 'oldest ASCII trick in the book'\n-        if (U <= 'Z' \/\/ In range A-Z\n-                || (U >= 0xC0 && U <= 0xDE && U != 0xD7)) { \/\/ ..or Agrave-Thorn, excluding multiplication\n-            return U;\n+        \/\/ ASCII and Latin-1 were designed to optimize case-twiddling operations\n+        int upper = ch & 0xDF;\n+        if (upper <= 'Z' \/\/ In range A-Z\n+                || (upper >= 0xC0 && upper <= 0xDE && upper != 0xD7)) { \/\/ ..or Agrave-Thorn, not multiplication\n+            return upper;\n@@ -170,0 +172,21 @@\n+    \/**\n+     * Compares two latin1 code points, ignoring case considerations\n+     *\n+     * @param b1 byte representing a latin1 code point\n+     * @param b2 another byte representing a latin1 code point\n+     * @return true if the two bytes are considered equals ignoring case in latin1\n+     *\/\n+     static boolean equalsIgnoreCase(byte b1, byte b2) {\n+         if (b1 == b2) {\n+             return true;\n+         }\n+         \/\/ ASCII and Latin-1 were designed to optimize case-twiddling operations\n+         int upper = b1 & 0xDF;\n+         if (upper < 'A') {\n+             return false;  \/\/ Low ASCII\n+         }\n+         return (upper <= 'Z' \/\/ In range A-Z\n+                 || (upper >= 0xC0 && upper <= 0XDE && upper != 0xD7)) \/\/ ..or A-grave-Thorn, not multiplication\n+                 && upper == (b2 & 0xDF); \/\/ b2 has same uppercase\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/CharacterDataLatin1.java.template","additions":31,"deletions":8,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -107,0 +107,9 @@\n+    \/**\n+     * Return a double with its high-order bits of the first argument\n+     * and the low-order bits of the second argument..\n+     *\/\n+    private static double __HI_LO(int high, int low) {\n+        return Double.longBitsToDouble(((long)high << 32) |\n+                                       (low & 0xffff_ffffL));\n+    }\n+\n@@ -507,0 +516,443 @@\n+    \/**\n+     * Return correctly rounded sqrt.\n+     *           ------------------------------------------\n+     *           |  Use the hardware sqrt if you have one |\n+     *           ------------------------------------------\n+     * Method:\n+     *   Bit by bit method using integer arithmetic. (Slow, but portable)\n+     *   1. Normalization\n+     *      Scale x to y in [1,4) with even powers of 2:\n+     *      find an integer k such that  1 <= (y=x*2^(2k)) < 4, then\n+     *              sqrt(x) = 2^k * sqrt(y)\n+     *   2. Bit by bit computation\n+     *      Let q  = sqrt(y) truncated to i bit after binary point (q = 1),\n+     *           i                                                   0\n+     *                                     i+1         2\n+     *          s  = 2*q , and      y  =  2   * ( y - q  ).         (1)\n+     *           i      i            i                 i\n+     *\n+     *      To compute q    from q , one checks whether\n+     *                  i+1       i\n+     *\n+     *                            -(i+1) 2\n+     *                      (q + 2      ) <= y.                     (2)\n+     *                        i\n+     *                                                            -(i+1)\n+     *      If (2) is false, then q   = q ; otherwise q   = q  + 2      .\n+     *                             i+1   i             i+1   i\n+     *\n+     *      With some algebraic manipulation, it is not difficult to see\n+     *      that (2) is equivalent to\n+     *                             -(i+1)\n+     *                      s  +  2       <= y                      (3)\n+     *                       i                i\n+     *\n+     *      The advantage of (3) is that s  and y  can be computed by\n+     *                                    i      i\n+     *      the following recurrence formula:\n+     *          if (3) is false\n+     *\n+     *          s     =  s  ,       y    = y   ;                    (4)\n+     *           i+1      i          i+1    i\n+     *\n+     *          otherwise,\n+     *                         -i                     -(i+1)\n+     *          s     =  s  + 2  ,  y    = y  -  s  - 2             (5)\n+     *           i+1      i          i+1    i     i\n+     *\n+     *      One may easily use induction to prove (4) and (5).\n+     *      Note. Since the left hand side of (3) contain only i+2 bits,\n+     *            it does not necessary to do a full (53-bit) comparison\n+     *            in (3).\n+     *   3. Final rounding\n+     *      After generating the 53 bits result, we compute one more bit.\n+     *      Together with the remainder, we can decide whether the\n+     *      result is exact, bigger than 1\/2ulp, or less than 1\/2ulp\n+     *      (it will never equal to 1\/2ulp).\n+     *      The rounding mode can be detected by checking whether\n+     *      huge + tiny is equal to huge, and whether huge - tiny is\n+     *      equal to huge for some floating point number \"huge\" and \"tiny\".\n+     *\n+     * Special cases:\n+     *      sqrt(+-0) = +-0         ... exact\n+     *      sqrt(inf) = inf\n+     *      sqrt(-ve) = NaN         ... with invalid signal\n+     *      sqrt(NaN) = NaN         ... with invalid signal for signaling NaN\n+     *\n+     * Other methods : see the appended file at the end of the program below.\n+     *---------------\n+     *\/\n+    static class Sqrt {\n+        private Sqrt() {throw new UnsupportedOperationException();}\n+\n+        private static final double tiny = 1.0e-300;\n+\n+        static double compute(double x) {\n+            double z = 0.0;\n+            int sign = 0x8000_0000;\n+            \/*unsigned*\/ int r, t1, s1, ix1, q1;\n+            int ix0, s0, q, m, t, i;\n+\n+            ix0 = __HI(x);  \/\/ high word of x\n+            ix1 = __LO(x);  \/\/ low word of x\n+\n+            \/\/ take care of Inf and NaN\n+            if ((ix0 & 0x7ff0_0000) == 0x7ff0_0000) {\n+                return x*x + x; \/\/ sqrt(NaN)=NaN, sqrt(+inf)=+inf, sqrt(-inf)=sNaN\n+            }\n+            \/\/ take care of zero\n+            if (ix0 <= 0) {\n+                if (((ix0 & (~sign)) | ix1) == 0)\n+                    return x; \/\/ sqrt(+-0) = +-0\n+                else if (ix0 < 0)\n+                    return (x-x)\/(x-x); \/\/ sqrt(-ve) = sNaN\n+            }\n+            \/\/ normalize x\n+            m = (ix0 >> 20);\n+            if (m == 0) { \/\/ subnormal x\n+                while (ix0 == 0) {\n+                    m -= 21;\n+                    ix0 |= (ix1 >>> 11); \/\/ unsigned shift\n+                    ix1 <<= 21;\n+                }\n+                for(i = 0; (ix0 & 0x0010_0000) == 0; i++) {\n+                    ix0 <<= 1;\n+                }\n+                m -= i-1;\n+                ix0 |= (ix1 >>> (32 - i)); \/\/ unsigned shift\n+                ix1 <<= i;\n+            }\n+            m -= 1023;      \/\/ unbias exponent *\/\n+            ix0 = (ix0 & 0x000f_ffff) | 0x0010_0000;\n+            if ((m & 1) != 0){        \/\/ odd m, double x to make it even\n+                ix0 += ix0 + ((ix1 & sign) >>> 31); \/\/ unsigned shift\n+                ix1 += ix1;\n+            }\n+            m >>= 1;        \/\/ m = [m\/2]\n+\n+            \/\/ generate sqrt(x) bit by bit\n+            ix0 += ix0 + ((ix1 & sign) >>> 31); \/\/ unsigned shift\n+            ix1 += ix1;\n+            q = q1 = s0 = s1 = 0;   \/\/ [q,q1] = sqrt(x)\n+            r = 0x0020_0000;        \/\/ r = moving bit from right to left\n+\n+            while (r != 0) {\n+                t = s0 + r;\n+                if (t <= ix0) {\n+                    s0   = t + r;\n+                    ix0 -= t;\n+                    q   += r;\n+                }\n+                ix0 += ix0 + ((ix1 & sign) >>> 31); \/\/ unsigned shift\n+                ix1 += ix1;\n+                r >>>= 1; \/\/ unsigned shift\n+            }\n+\n+            r = sign;\n+            while (r != 0) {\n+                t1 = s1 + r;\n+                t  = s0;\n+                if ((t < ix0) ||\n+                    ((t == ix0) && (Integer.compareUnsigned(t1, ix1) <= 0 ))) { \/\/ t1 <= ix1\n+                    s1 = t1 + r;\n+                    if (((t1 & sign) == sign) && (s1 & sign) == 0) {\n+                        s0 += 1;\n+                    }\n+                    ix0 -= t;\n+                    if (Integer.compareUnsigned(ix1, t1) < 0) {  \/\/ ix1 < t1\n+                        ix0 -= 1;\n+                    }\n+                    ix1 -= t1;\n+                    q1  += r;\n+                }\n+                ix0 += ix0 + ((ix1 & sign) >>> 31); \/\/ unsigned shift\n+                ix1 += ix1;\n+                r >>>= 1; \/\/ unsigned shift\n+            }\n+\n+            \/\/ use floating add to find out rounding direction\n+            if ((ix0 | ix1) != 0) {\n+                z = 1.0 - tiny; \/\/ trigger inexact flag\n+                if (z >= 1.0) {\n+                    z = 1.0 + tiny;\n+                    if (q1 == 0xffff_ffff) {\n+                        q1 = 0;\n+                        q += 1;\n+                    } else if (z > 1.0) {\n+                        if (q1 == 0xffff_fffe) {\n+                            q += 1;\n+                        }\n+                        q1 += 2;\n+                    } else {\n+                        q1 += (q1 & 1);\n+                    }\n+                }\n+            }\n+            ix0 = (q >> 1) + 0x3fe0_0000;\n+            ix1 =  q1 >>> 1; \/\/ unsigned shift\n+            if ((q & 1) == 1) {\n+                ix1 |= sign;\n+            }\n+            ix0 += (m << 20);\n+            return __HI_LO(ix0, ix1);\n+        }\n+    }\n+\n+    \/\/ The following comment is supplementary information from the FDLIBM sources.\n+\n+    \/*\n+     * Other methods  (use floating-point arithmetic)\n+     * -------------\n+     * (This is a copy of a drafted paper by Prof W. Kahan\n+     * and K.C. Ng, written in May, 1986)\n+     *\n+     *        Two algorithms are given here to implement sqrt(x)\n+     *        (IEEE double precision arithmetic) in software.\n+     *        Both supply sqrt(x) correctly rounded. The first algorithm (in\n+     *        Section A) uses newton iterations and involves four divisions.\n+     *        The second one uses reciproot iterations to avoid division, but\n+     *        requires more multiplications. Both algorithms need the ability\n+     *        to chop results of arithmetic operations instead of round them,\n+     *        and the INEXACT flag to indicate when an arithmetic operation\n+     *        is executed exactly with no roundoff error, all part of the\n+     *        standard (IEEE 754-1985). The ability to perform shift, add,\n+     *        subtract and logical AND operations upon 32-bit words is needed\n+     *        too, though not part of the standard.\n+     *\n+     * A.  sqrt(x) by Newton Iteration\n+     *\n+     *   (1)  Initial approximation\n+     *\n+     *        Let x0 and x1 be the leading and the trailing 32-bit words of\n+     *        a floating point number x (in IEEE double format) respectively\n+     *\n+     *            1    11                  52                           ...widths\n+     *           ------------------------------------------------------\n+     *        x: |s|    e     |             f                         |\n+     *           ------------------------------------------------------\n+     *              msb    lsb  msb                                 lsb ...order\n+     *\n+     *\n+     *             ------------------------        ------------------------\n+     *        x0:  |s|   e    |    f1     |    x1: |          f2           |\n+     *             ------------------------        ------------------------\n+     *\n+     *        By performing shifts and subtracts on x0 and x1 (both regarded\n+     *        as integers), we obtain an 8-bit approximation of sqrt(x) as\n+     *        follows.\n+     *\n+     *                k  := (x0>>1) + 0x1ff80000;\n+     *                y0 := k - T1[31&(k>>15)].       ... y ~ sqrt(x) to 8 bits\n+     *        Here k is a 32-bit integer and T1[] is an integer array containing\n+     *        correction terms. Now magically the floating value of y (y's\n+     *        leading 32-bit word is y0, the value of its trailing word is 0)\n+     *        approximates sqrt(x) to almost 8-bit.\n+     *\n+     *        Value of T1:\n+     *        static int T1[32]= {\n+     *        0,      1024,   3062,   5746,   9193,   13348,  18162,  23592,\n+     *        29598,  36145,  43202,  50740,  58733,  67158,  75992,  85215,\n+     *        83599,  71378,  60428,  50647,  41945,  34246,  27478,  21581,\n+     *        16499,  12183,  8588,   5674,   3403,   1742,   661,    130,};\n+     *\n+     *    (2) Iterative refinement\n+     *\n+     *        Apply Heron's rule three times to y, we have y approximates\n+     *        sqrt(x) to within 1 ulp (Unit in the Last Place):\n+     *\n+     *                y := (y+x\/y)\/2          ... almost 17 sig. bits\n+     *                y := (y+x\/y)\/2          ... almost 35 sig. bits\n+     *                y := y-(y-x\/y)\/2        ... within 1 ulp\n+     *\n+     *\n+     *        Remark 1.\n+     *            Another way to improve y to within 1 ulp is:\n+     *\n+     *                y := (y+x\/y)            ... almost 17 sig. bits to 2*sqrt(x)\n+     *                y := y - 0x00100006     ... almost 18 sig. bits to sqrt(x)\n+     *\n+     *                                2\n+     *                            (x-y )*y\n+     *                y := y + 2* ----------  ...within 1 ulp\n+     *                               2\n+     *                             3y  + x\n+     *\n+     *\n+     *        This formula has one division fewer than the one above; however,\n+     *        it requires more multiplications and additions. Also x must be\n+     *        scaled in advance to avoid spurious overflow in evaluating the\n+     *        expression 3y*y+x. Hence it is not recommended uless division\n+     *        is slow. If division is very slow, then one should use the\n+     *        reciproot algorithm given in section B.\n+     *\n+     *    (3) Final adjustment\n+     *\n+     *        By twiddling y's last bit it is possible to force y to be\n+     *        correctly rounded according to the prevailing rounding mode\n+     *        as follows. Let r and i be copies of the rounding mode and\n+     *        inexact flag before entering the square root program. Also we\n+     *        use the expression y+-ulp for the next representable floating\n+     *        numbers (up and down) of y. Note that y+-ulp = either fixed\n+     *        point y+-1, or multiply y by nextafter(1,+-inf) in chopped\n+     *        mode.\n+     *\n+     *                I := FALSE;     ... reset INEXACT flag I\n+     *                R := RZ;        ... set rounding mode to round-toward-zero\n+     *                z := x\/y;       ... chopped quotient, possibly inexact\n+     *                If(not I) then {        ... if the quotient is exact\n+     *                    if(z=y) {\n+     *                        I := i;  ... restore inexact flag\n+     *                        R := r;  ... restore rounded mode\n+     *                        return sqrt(x):=y.\n+     *                    } else {\n+     *                        z := z - ulp;   ... special rounding\n+     *                    }\n+     *                }\n+     *                i := TRUE;              ... sqrt(x) is inexact\n+     *                If (r=RN) then z=z+ulp  ... rounded-to-nearest\n+     *                If (r=RP) then {        ... round-toward-+inf\n+     *                    y = y+ulp; z=z+ulp;\n+     *                }\n+     *                y := y+z;               ... chopped sum\n+     *                y0:=y0-0x00100000;      ... y := y\/2 is correctly rounded.\n+     *                I := i;                 ... restore inexact flag\n+     *                R := r;                 ... restore rounded mode\n+     *                return sqrt(x):=y.\n+     *\n+     *    (4) Special cases\n+     *\n+     *        Square root of +inf, +-0, or NaN is itself;\n+     *        Square root of a negative number is NaN with invalid signal.\n+     *\n+     *\n+     * B.  sqrt(x) by Reciproot Iteration\n+     *\n+     *   (1)  Initial approximation\n+     *\n+     *        Let x0 and x1 be the leading and the trailing 32-bit words of\n+     *        a floating point number x (in IEEE double format) respectively\n+     *        (see section A). By performing shifs and subtracts on x0 and y0,\n+     *        we obtain a 7.8-bit approximation of 1\/sqrt(x) as follows.\n+     *\n+     *            k := 0x5fe80000 - (x0>>1);\n+     *            y0:= k - T2[63&(k>>14)].    ... y ~ 1\/sqrt(x) to 7.8 bits\n+     *\n+     *        Here k is a 32-bit integer and T2[] is an integer array\n+     *        containing correction terms. Now magically the floating\n+     *        value of y (y's leading 32-bit word is y0, the value of\n+     *        its trailing word y1 is set to zero) approximates 1\/sqrt(x)\n+     *        to almost 7.8-bit.\n+     *\n+     *        Value of T2:\n+     *        static int T2[64]= {\n+     *        0x1500, 0x2ef8, 0x4d67, 0x6b02, 0x87be, 0xa395, 0xbe7a, 0xd866,\n+     *        0xf14a, 0x1091b,0x11fcd,0x13552,0x14999,0x15c98,0x16e34,0x17e5f,\n+     *        0x18d03,0x19a01,0x1a545,0x1ae8a,0x1b5c4,0x1bb01,0x1bfde,0x1c28d,\n+     *        0x1c2de,0x1c0db,0x1ba73,0x1b11c,0x1a4b5,0x1953d,0x18266,0x16be0,\n+     *        0x1683e,0x179d8,0x18a4d,0x19992,0x1a789,0x1b445,0x1bf61,0x1c989,\n+     *        0x1d16d,0x1d77b,0x1dddf,0x1e2ad,0x1e5bf,0x1e6e8,0x1e654,0x1e3cd,\n+     *        0x1df2a,0x1d635,0x1cb16,0x1be2c,0x1ae4e,0x19bde,0x1868e,0x16e2e,\n+     *        0x1527f,0x1334a,0x11051,0xe951, 0xbe01, 0x8e0d, 0x5924, 0x1edd,};\n+     *\n+     *    (2) Iterative refinement\n+     *\n+     *        Apply Reciproot iteration three times to y and multiply the\n+     *        result by x to get an approximation z that matches sqrt(x)\n+     *        to about 1 ulp. To be exact, we will have\n+     *                -1ulp < sqrt(x)-z<1.0625ulp.\n+     *\n+     *        ... set rounding mode to Round-to-nearest\n+     *           y := y*(1.5-0.5*x*y*y)       ... almost 15 sig. bits to 1\/sqrt(x)\n+     *           y := y*((1.5-2^-30)+0.5*x*y*y)... about 29 sig. bits to 1\/sqrt(x)\n+     *        ... special arrangement for better accuracy\n+     *           z := x*y                     ... 29 bits to sqrt(x), with z*y<1\n+     *           z := z + 0.5*z*(1-z*y)       ... about 1 ulp to sqrt(x)\n+     *\n+     *        Remark 2. The constant 1.5-2^-30 is chosen to bias the error so that\n+     *        (a) the term z*y in the final iteration is always less than 1;\n+     *        (b) the error in the final result is biased upward so that\n+     *                -1 ulp < sqrt(x) - z < 1.0625 ulp\n+     *            instead of |sqrt(x)-z|<1.03125ulp.\n+     *\n+     *    (3) Final adjustment\n+     *\n+     *        By twiddling y's last bit it is possible to force y to be\n+     *        correctly rounded according to the prevailing rounding mode\n+     *        as follows. Let r and i be copies of the rounding mode and\n+     *        inexact flag before entering the square root program. Also we\n+     *        use the expression y+-ulp for the next representable floating\n+     *        numbers (up and down) of y. Note that y+-ulp = either fixed\n+     *        point y+-1, or multiply y by nextafter(1,+-inf) in chopped\n+     *        mode.\n+     *\n+     *        R := RZ;                ... set rounding mode to round-toward-zero\n+     *        switch(r) {\n+     *            case RN:            ... round-to-nearest\n+     *               if(x<= z*(z-ulp)...chopped) z = z - ulp; else\n+     *               if(x<= z*(z+ulp)...chopped) z = z; else z = z+ulp;\n+     *               break;\n+     *            case RZ:case RM:    ... round-to-zero or round-to--inf\n+     *               R:=RP;           ... reset rounding mod to round-to-+inf\n+     *               if(x<z*z ... rounded up) z = z - ulp; else\n+     *               if(x>=(z+ulp)*(z+ulp) ...rounded up) z = z+ulp;\n+     *               break;\n+     *            case RP:            ... round-to-+inf\n+     *               if(x>(z+ulp)*(z+ulp)...chopped) z = z+2*ulp; else\n+     *               if(x>z*z ...chopped) z = z+ulp;\n+     *               break;\n+     *        }\n+     *\n+     *        Remark 3. The above comparisons can be done in fixed point. For\n+     *        example, to compare x and w=z*z chopped, it suffices to compare\n+     *        x1 and w1 (the trailing parts of x and w), regarding them as\n+     *        two's complement integers.\n+     *\n+     *        ...Is z an exact square root?\n+     *        To determine whether z is an exact square root of x, let z1 be the\n+     *        trailing part of z, and also let x0 and x1 be the leading and\n+     *        trailing parts of x.\n+     *\n+     *        If ((z1&0x03ffffff)!=0) ... not exact if trailing 26 bits of z!=0\n+     *            I := 1;             ... Raise Inexact flag: z is not exact\n+     *        else {\n+     *            j := 1 - [(x0>>20)&1]       ... j = logb(x) mod 2\n+     *            k := z1 >> 26;              ... get z's 25-th and 26-th\n+     *                                            fraction bits\n+     *            I := i or (k&j) or ((k&(j+j+1))!=(x1&3));\n+     *        }\n+     *        R:= r           ... restore rounded mode\n+     *        return sqrt(x):=z.\n+     *\n+     *        If multiplication is cheaper then the foregoing red tape, the\n+     *        Inexact flag can be evaluated by\n+     *\n+     *            I := i;\n+     *            I := (z*z!=x) or I.\n+     *\n+     *        Note that z*z can overwrite I; this value must be sensed if it is\n+     *        True.\n+     *\n+     *        Remark 4. If z*z = x exactly, then bit 25 to bit 0 of z1 must be\n+     *        zero.\n+     *\n+     *                    --------------------\n+     *                z1: |        f2        |\n+     *                    --------------------\n+     *                bit 31             bit 0\n+     *\n+     *        Further more, bit 27 and 26 of z1, bit 0 and 1 of x1, and the odd\n+     *        or even of logb(x) have the following relations:\n+     *\n+     *        -------------------------------------------------\n+     *        bit 27,26 of z1         bit 1,0 of x1   logb(x)\n+     *        -------------------------------------------------\n+     *        00                      00              odd and even\n+     *        01                      01              even\n+     *        10                      10              odd\n+     *        10                      00              even\n+     *        11                      01              even\n+     *        -------------------------------------------------\n+     *\n+     *    (4) Special cases (see (4) of Section A).\n+     *\/\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":452,"deletions":0,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -532,4 +532,0 @@\n-    \/\/ Left here for compatibility reasons, see JDK-8143900.\n-    static final int [] sizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999,\n-                                      99999999, 999999999, Integer.MAX_VALUE };\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -313,1 +313,3 @@\n-    public static native double sqrt(double a);\n+    public static double sqrt(double a) {\n+        return FdLibm.Sqrt.compute(a);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -387,8 +387,3 @@\n-            char c1 = (char)(value[toffset++] & 0xff);\n-            char c2 = (char)(other[ooffset++] & 0xff);\n-            if (c1 == c2) {\n-                continue;\n-            }\n-            int u1 = CharacterDataLatin1.instance.toUpperCase(c1);\n-            int u2 = CharacterDataLatin1.instance.toUpperCase(c2);\n-            if (u1 == u2) {\n+            byte b1 = value[toffset++];\n+            byte b2 = other[ooffset++];\n+            if (CharacterDataLatin1.equalsIgnoreCase(b1, b2)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-    \/\/ Used to ensure that each spun class name is unique\n+    \/\/ Used to ensure that dumped class files for failed definitions have a unique class name\n@@ -122,1 +122,1 @@\n-    private final String lambdaClassName;            \/\/ Generated name for the generated class \"X$$Lambda$1\"\n+    private final String lambdaClassName;            \/\/ Generated name for the generated class \"X$$Lambda\"\n@@ -212,1 +212,1 @@\n-        return name.replace('.', '\/') + \"$$Lambda$\" + counter.incrementAndGet();\n+        return name.replace('.', '\/') + \"$$Lambda\";\n@@ -304,1 +304,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -365,13 +364,0 @@\n-        \/\/ If requested, dump out to a file for debugging purposes\n-        if (dumper != null) {\n-            AccessController.doPrivileged(new PrivilegedAction<>() {\n-                @Override\n-                public Void run() {\n-                    dumper.dumpClass(lambdaClassName, classBytes);\n-                    return null;\n-                }\n-            }, null,\n-            new FilePermission(\"<<ALL FILES>>\", \"read, write\"),\n-            \/\/ createDirectories may need it\n-            new PropertyPermission(\"user.dir\", \"read\"));\n-        }\n@@ -380,6 +366,23 @@\n-            Lookup lookup;\n-            if (useImplMethodHandle) {\n-                lookup = caller.defineHiddenClassWithClassData(classBytes, implementation, !disableEagerInitialization,\n-                                                               NESTMATE, STRONG);\n-            } else {\n-                lookup = caller.defineHiddenClass(classBytes, !disableEagerInitialization, NESTMATE, STRONG);\n+            Lookup lookup = null;\n+            try {\n+                if (useImplMethodHandle) {\n+                    lookup = caller.defineHiddenClassWithClassData(classBytes, implementation, !disableEagerInitialization,\n+                                                                   NESTMATE, STRONG);\n+                } else {\n+                    lookup = caller.defineHiddenClass(classBytes, !disableEagerInitialization, NESTMATE, STRONG);\n+                }\n+                return lookup.lookupClass();\n+            } finally {\n+                \/\/ If requested, dump out to a file for debugging purposes\n+                if (dumper != null) {\n+                    String name;\n+                    if (lookup != null) {\n+                        String definedName = lookup.lookupClass().getName();\n+                        int suffixIdx = definedName.lastIndexOf('\/');\n+                        assert suffixIdx != -1;\n+                        name = lambdaClassName + '.' + definedName.substring(suffixIdx + 1);\n+                    } else {\n+                        name = lambdaClassName + \".failed-\" + counter.incrementAndGet();\n+                    }\n+                    doDump(name, classBytes);\n+                }\n@@ -387,1 +390,0 @@\n-            return lookup.lookupClass();\n@@ -395,0 +397,14 @@\n+    @SuppressWarnings(\"removal\")\n+    private void doDump(final String className, final byte[] classBytes) {\n+        AccessController.doPrivileged(new PrivilegedAction<>() {\n+            @Override\n+            public Void run() {\n+                dumper.dumpClass(className, classBytes);\n+                return null;\n+            }\n+        }, null,\n+        new FilePermission(\"<<ALL FILES>>\", \"read, write\"),\n+        \/\/ createDirectories may need it\n+        new PropertyPermission(\"user.dir\", \"read\"));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":41,"deletions":25,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2336,1 +2336,1 @@\n-         * {@bytes} denotes a class in a different package than the lookup class\n+         * {@code bytes} denotes a class in a different package than the lookup class\n@@ -2354,1 +2354,1 @@\n-         * {@bytes} denotes a class in a different package than the lookup class\n+         * {@code bytes} denotes a class in a different package than the lookup class\n@@ -2375,1 +2375,1 @@\n-         * {@bytes} denotes a class in a different package than the lookup class\n+         * {@code bytes} denotes a class in a different package than the lookup class\n@@ -5185,1 +5185,1 @@\n-     * @throws IllegalArgumentException if (@code pos) is less than {@code 0} or greater than\n+     * @throws IllegalArgumentException if {@code pos} is less than {@code 0} or greater than\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -602,1 +602,1 @@\n-    public long getHeaderFieldDate(String name, long Default) {\n+    public long getHeaderFieldDate(String name, long defaultValue) {\n@@ -604,1 +604,1 @@\n-        try {\n+        if (dateString != null) {\n@@ -606,1 +606,5 @@\n-                dateString = dateString+\" GMT\";\n+                dateString = dateString + \" GMT\";\n+            }\n+            try {\n+                return Date.parse(dateString);\n+            } catch (Exception e) {\n@@ -608,2 +612,0 @@\n-            return Date.parse(dateString);\n-        } catch (Exception e) {\n@@ -611,1 +613,1 @@\n-        return Default;\n+        return defaultValue;\n","filename":"src\/java.base\/share\/classes\/java\/net\/HttpURLConnection.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.Locale;\n@@ -615,2 +614,2 @@\n-     * @param   name      the name of the header field.\n-     * @param   Default   the default value.\n+     * @param   name          the name of the header field.\n+     * @param   defaultValue  the default value.\n@@ -618,1 +617,1 @@\n-     *          {@code Default} value is returned if the field is\n+     *          {@code defaultValue} value is returned if the field is\n@@ -621,1 +620,1 @@\n-    public int getHeaderFieldInt(String name, int Default) {\n+    public int getHeaderFieldInt(String name, int defaultValue) {\n@@ -628,1 +627,1 @@\n-        return Default;\n+        return defaultValue;\n@@ -639,2 +638,2 @@\n-     * @param   name      the name of the header field.\n-     * @param   Default   the default value.\n+     * @param   name          the name of the header field.\n+     * @param   defaultValue  the default value.\n@@ -642,1 +641,1 @@\n-     *          {@code Default} value is returned if the field is\n+     *          {@code defaultValue} value is returned if the field is\n@@ -646,1 +645,1 @@\n-    public long getHeaderFieldLong(String name, long Default) {\n+    public long getHeaderFieldLong(String name, long defaultValue) {\n@@ -653,1 +652,1 @@\n-        return Default;\n+        return defaultValue;\n@@ -666,2 +665,2 @@\n-     * @param   name     the name of the header field.\n-     * @param   Default   a default value.\n+     * @param   name          the name of the header field.\n+     * @param   defaultValue  a default value.\n@@ -669,1 +668,1 @@\n-     *          {@code Default} argument is returned if the field is\n+     *          {@code defaultValue} argument is returned if the field is\n@@ -673,1 +672,1 @@\n-    public long getHeaderFieldDate(String name, long Default) {\n+    public long getHeaderFieldDate(String name, long defaultValue) {\n@@ -680,1 +679,1 @@\n-        return Default;\n+        return defaultValue;\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLConnection.java","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -190,5 +190,0 @@\n-    \/\/ Temporarily keep the long,int constructor around\n-    private Direct$Type$Buffer(long addr, int cap) {\n-        this(addr, (long)cap);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -636,1 +636,1 @@\n-     * position is greater than the file's current size then no bytes are\n+     * position is greater than or equal to the file's current size then no bytes are\n@@ -764,1 +764,1 @@\n-     * is greater than the file's current size then no bytes are read.  <\/p>\n+     * is greater than or equal to the file's current size then no bytes are read.  <\/p>\n@@ -809,1 +809,1 @@\n-     * position is greater than the file's current size then the file will be\n+     * position is greater than or equal to the file's current size then the file will be\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -529,1 +529,0 @@\n-        super();\n","filename":"src\/java.base\/share\/classes\/java\/time\/Duration.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -428,1 +428,0 @@\n-        super();\n","filename":"src\/java.base\/share\/classes\/java\/time\/Instant.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -444,1 +444,0 @@\n-        super();\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneOffset.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -263,0 +263,2 @@\n+     * @throws IllegalArgumentException if {@code s} cannot be interpreted as a\n+     * representation of a date and time.\n@@ -444,0 +446,2 @@\n+     * @throws IllegalArgumentException if {@code s} cannot be interpreted as a\n+     * representation of a date and time.\n","filename":"src\/java.base\/share\/classes\/java\/util\/Date.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import java.util.stream.Stream;\n@@ -1213,0 +1214,18 @@\n+    \/**\n+     * Returns a stream of all installed locales.\n+     * The returned stream represents the union of locales supported\n+     * by the Java runtime environment and by installed\n+     * {@link java.util.spi.LocaleServiceProvider LocaleServiceProvider}\n+     * implementations. At a minimum, the returned stream must contain a\n+     * {@code Locale} instance equal to {@link Locale#ROOT Locale.ROOT} and\n+     * a {@code Locale} instance equal to {@link Locale#US Locale.US}.\n+     *\n+     * @implNote Unlike {@code getAvailableLocales()}, this method does\n+     * not create a defensive copy of the Locale array.\n+     * @return A stream of installed locales.\n+     * @since 21\n+     *\/\n+    public static Stream<Locale> availableLocales() {\n+        return LocaleServiceProviderPool.streamAllAvailableLocales();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+@SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/LongSummaryStatistics.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -161,0 +162,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -227,0 +229,1 @@\n+    @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/PrimitiveIterator.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -662,0 +662,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -726,0 +727,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -790,0 +792,1 @@\n+    @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/Spliterator.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -911,0 +911,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -917,0 +918,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -923,0 +925,1 @@\n+        @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/Spliterators.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.lang.ref.Cleaner.Cleanable;\n@@ -49,0 +50,1 @@\n+import jdk.internal.ref.CleanerFactory;\n@@ -176,4 +178,1 @@\n-        return new FinalizableDelegatedExecutorService\n-            (new ThreadPoolExecutor(1, 1,\n-                                    0L, TimeUnit.MILLISECONDS,\n-                                    new LinkedBlockingQueue<Runnable>()));\n+        return newSingleThreadExecutor(defaultThreadFactory());\n@@ -195,1 +194,1 @@\n-        return new FinalizableDelegatedExecutorService\n+        return new AutoShutdownDelegatedExecutorService\n@@ -762,1 +761,5 @@\n-        public void shutdown() { e.shutdown(); }\n+        public void shutdown() {\n+            try {\n+                e.shutdown();\n+            } finally { reachabilityFence(this); }\n+        }\n@@ -827,1 +830,5 @@\n-    private static class FinalizableDelegatedExecutorService\n+    \/**\n+     * A DelegatedExecutorService that uses a Cleaner to shut down the underlying\n+     * ExecutorService when the wrapper becomes phantom reachable.\n+     *\/\n+    private static class AutoShutdownDelegatedExecutorService\n@@ -829,1 +836,2 @@\n-        FinalizableDelegatedExecutorService(ExecutorService executor) {\n+        private final Cleanable cleanable;\n+        AutoShutdownDelegatedExecutorService(ExecutorService executor) {\n@@ -831,0 +839,8 @@\n+            Runnable action = () -> {\n+                if (!executor.isShutdown()) {\n+                    PrivilegedAction<Void> pa = () -> { executor.shutdown(); return null; };\n+                    @SuppressWarnings(\"removal\")\n+                    var ignore = AccessController.doPrivileged(pa);\n+                }\n+            };\n+            cleanable = CleanerFactory.cleaner().register(this, action);\n@@ -832,2 +848,2 @@\n-        @SuppressWarnings(\"removal\")\n-        protected void finalize() {\n+        @Override\n+        public void shutdown() {\n@@ -835,0 +851,1 @@\n+            cleanable.clean();  \/\/ unregisters the cleanable\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Executors.java","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -317,0 +317,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -394,0 +395,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -471,0 +473,1 @@\n+    @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Node.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -585,0 +585,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -602,0 +603,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -619,0 +621,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -883,0 +886,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -897,0 +901,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -911,0 +916,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1163,0 +1169,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1172,0 +1179,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1181,0 +1189,1 @@\n+        @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Nodes.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -189,0 +189,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -206,0 +207,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -223,0 +225,1 @@\n+    @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Sink.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -723,0 +723,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -788,0 +789,1 @@\n+            @SuppressWarnings(\"overloads\")\n@@ -836,0 +838,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -902,0 +905,1 @@\n+            @SuppressWarnings(\"overloads\")\n@@ -950,0 +954,1 @@\n+    @SuppressWarnings(\"overloads\")\n@@ -1016,0 +1021,1 @@\n+            @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/SpinedBuffer.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -575,0 +575,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -584,0 +585,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -593,0 +595,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -818,0 +821,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -842,0 +846,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -866,0 +871,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1131,0 +1137,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1166,0 +1173,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -1201,0 +1209,1 @@\n+        @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/StreamSpliterators.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -807,0 +807,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -815,0 +816,1 @@\n+        @SuppressWarnings(\"overloads\")\n@@ -823,0 +825,1 @@\n+        @SuppressWarnings(\"overloads\")\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Streams.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -482,1 +482,1 @@\n-     * @returnss the {@code writeReplace} MethodHandle or {@code null} if not found\n+     * @return the {@code writeReplace} MethodHandle or {@code null} if not found\n@@ -492,1 +492,1 @@\n-     * @returns the {@code writeReplace} MethodHandle or {@code null} if not found\n+     * @return the {@code writeReplace} MethodHandle or {@code null} if not found\n@@ -503,1 +503,1 @@\n-     * @returns a MethodHandle for the method or {@code null} if not found or\n+     * @return a MethodHandle for the method or {@code null} if not found or\n@@ -570,1 +570,1 @@\n-     * @returns the eof constructor for OptionalDataException\n+     * @return the eof constructor for OptionalDataException\n@@ -734,1 +734,1 @@\n-     * @returns true if the two classes are in the same classloader and package\n+     * @return true if the two classes are in the same classloader and package\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2084,1 +2084,1 @@\n-         * Implements the @code{split()} method as\n+         * Implements the {@code split()} method as\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/random\/RandomSupport.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import java.util.concurrent.locks.Lock;\n@@ -54,1 +53,1 @@\n-    extends HashMap<KeepAliveKey, ClientVector>\n+    extends HashMap<KeepAliveKey, KeepAliveCache.ClientVector>\n@@ -246,0 +245,5 @@\n+                if (isEmpty()) {\n+                    \/\/ cache not used in the last LIFETIME - exit\n+                    keepAliveTimer = null;\n+                    break;\n+                }\n@@ -251,12 +255,6 @@\n-                    v.lock();\n-                    try {\n-                        KeepAliveEntry e = v.peekLast();\n-                        while (e != null) {\n-                            if ((currentTime - e.idleStartTime) > v.nap) {\n-                                v.pollLast();\n-                                if (closeList == null) {\n-                                    closeList = new ArrayList<>();\n-                                }\n-                                closeList.add(e.hc);\n-                            } else {\n-                                break;\n+                    KeepAliveEntry e = v.peekLast();\n+                    while (e != null) {\n+                        if ((currentTime - e.idleStartTime) > v.nap) {\n+                            v.pollLast();\n+                            if (closeList == null) {\n+                                closeList = new ArrayList<>();\n@@ -264,1 +262,3 @@\n-                            e = v.peekLast();\n+                            closeList.add(e.hc);\n+                        } else {\n+                            break;\n@@ -266,0 +266,2 @@\n+                        e = v.peekLast();\n+                    }\n@@ -267,5 +269,2 @@\n-                        if (v.isEmpty()) {\n-                            keysToRemove.add(key);\n-                        }\n-                    } finally {\n-                        v.unlock();\n+                    if (v.isEmpty()) {\n+                        keysToRemove.add(key);\n@@ -287,1 +286,1 @@\n-        } while (!isEmpty());\n+        } while (keepAliveTimer == Thread.currentThread());\n@@ -304,1 +303,0 @@\n-}\n@@ -306,7 +304,6 @@\n-\/* LIFO order for reusing HttpClients. Most recent entries at the front.\n- * If > maxConns are in use, discard oldest.\n- *\/\n-class ClientVector extends ArrayDeque<KeepAliveEntry> {\n-    @java.io.Serial\n-    private static final long serialVersionUID = -8680532108106489459L;\n-    private final ReentrantLock lock = new ReentrantLock();\n+    \/* LIFO order for reusing HttpClients. Most recent entries at the front.\n+     * If > maxConns are in use, discard oldest.\n+     *\/\n+    class ClientVector extends ArrayDeque<KeepAliveEntry> {\n+        @java.io.Serial\n+        private static final long serialVersionUID = -8680532108106489459L;\n@@ -314,2 +311,2 @@\n-    \/\/ sleep time in milliseconds, before cache clear\n-    int nap;\n+        \/\/ sleep time in milliseconds, before cache clear\n+        int nap;\n@@ -317,3 +314,3 @@\n-    ClientVector(int nap) {\n-        this.nap = nap;\n-    }\n+        ClientVector(int nap) {\n+            this.nap = nap;\n+        }\n@@ -321,4 +318,3 @@\n-    \/* return a still valid, idle HttpClient *\/\n-    HttpClient get() {\n-        lock();\n-        try {\n+        \/* return a still valid, idle HttpClient *\/\n+        HttpClient get() {\n+            assert cacheLock.isHeldByCurrentThread();\n@@ -342,2 +338,0 @@\n-        } finally {\n-            unlock();\n@@ -345,1 +339,0 @@\n-    }\n@@ -347,4 +340,3 @@\n-    HttpClient put(HttpClient h) {\n-        HttpClient staleClient = null;\n-        lock();\n-        try {\n+        HttpClient put(HttpClient h) {\n+            assert cacheLock.isHeldByCurrentThread();\n+            HttpClient staleClient = null;\n@@ -357,2 +349,2 @@\n-        } finally {\n-            unlock();\n+            \/\/ close after releasing the locks\n+            return staleClient;\n@@ -360,7 +352,0 @@\n-        \/\/ close after releasing the locks\n-        return staleClient;\n-    }\n-\n-    final void lock() {\n-        lock.lock();\n-    }\n@@ -368,11 +353,7 @@\n-    final void unlock() {\n-        lock.unlock();\n-    }\n-\n-    \/*\n-     * Do not serialize this class!\n-     *\/\n-    @java.io.Serial\n-    private void writeObject(ObjectOutputStream stream) throws IOException {\n-        throw new NotSerializableException();\n-    }\n+        \/*\n+         * Do not serialize this class!\n+         *\/\n+        @java.io.Serial\n+        private void writeObject(ObjectOutputStream stream) throws IOException {\n+            throw new NotSerializableException();\n+        }\n@@ -380,5 +361,5 @@\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream stream)\n-        throws IOException, ClassNotFoundException\n-    {\n-        throw new NotSerializableException();\n+        @java.io.Serial\n+        private void readObject(ObjectInputStream stream)\n+                throws IOException, ClassNotFoundException {\n+            throw new NotSerializableException();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/KeepAliveCache.java","additions":52,"deletions":71,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import sun.net.www.http.HttpClient;\n@@ -355,2 +354,2 @@\n-    public long getHeaderFieldDate(String name, long Default) {\n-        return delegate.getHeaderFieldDate(name, Default);\n+    public long getHeaderFieldDate(String name, long defaultValue) {\n+        return delegate.getHeaderFieldDate(name, defaultValue);\n@@ -395,2 +394,2 @@\n-    public int getHeaderFieldInt(String name, int Default) {\n-        return delegate.getHeaderFieldInt(name, Default);\n+    public int getHeaderFieldInt(String name, int defaultValue) {\n+        return delegate.getHeaderFieldInt(name, defaultValue);\n@@ -399,2 +398,2 @@\n-    public long getHeaderFieldLong(String name, long Default) {\n-        return delegate.getHeaderFieldLong(name, Default);\n+    public long getHeaderFieldLong(String name, long defaultValue) {\n+        return delegate.getHeaderFieldLong(name, defaultValue);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/https\/HttpsURLConnectionImpl.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-package $PACKAGE$;\n+package sun.nio.cs;\n@@ -37,0 +37,1 @@\n+import jdk.internal.misc.VM;\n@@ -38,0 +39,1 @@\n+import sun.security.action.GetPropertyAction;\n@@ -46,0 +48,6 @@\n+    \/\/ Assumes non-2000 standard if initialized during System.initPhase1(),\n+    \/\/ as the system property is not ready to be read in that case.\n+    static final boolean IS_2000 =\n+        VM.initLevel() >= 1 &&\n+        \"2000\".equals(GetPropertyAction.privilegedGetProperty(\"jdk.charset.GB18030\", \"\"));\n+\n@@ -47,1 +55,1 @@\n-        super(\"GB18030\", $ALIASES$);\n+        super(\"GB18030\", StandardCharsets.aliases_GB18030());\n@@ -1049,1 +1057,2 @@\n-        \"\\u1E3E\\u1E3F\\u1E40\\u1E41\\u1E42\\u1E43\\u1E44\\u1E45\"+\n+        (IS_2000 ? \"\\u1E3E\\u1E3F\\u1E40\\u1E41\\u1E42\\u1E43\\u1E44\\u1E45\" :\n+                   \"\\u1E3E\\uE7C7\\u1E40\\u1E41\\u1E42\\u1E43\\u1E44\\u1E45\")+\n@@ -2505,2 +2514,4 @@\n-        \"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\"+\n-        \"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\"+\n+        (IS_2000 ? \"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\"+\n+                   \"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\" :\n+                   \"\\uFFFD\\uE81E\\uE826\\uE82B\\uE82C\\uE832\\uE843\\uE854\"+\n+                   \"\\uE864\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\")+\n@@ -2769,2 +2780,4 @@\n-        \"\\uFE0C\\uFE0D\\uFE0E\\uFE0F\\uFE10\\uFE11\\uFE12\\uFE13\"+\n-        \"\\uFE14\\uFE15\\uFE16\\uFE17\\uFE18\\uFE19\\uFE1A\\uFE1B\"+\n+        (IS_2000 ? \"\\uFE0C\\uFE0D\\uFE0E\\uFE0F\\uFE10\\uFE11\\uFE12\\uFE13\"+\n+                   \"\\uFE14\\uFE15\\uFE16\\uFE17\\uFE18\\uFE19\\uFE1A\\uFE1B\" :\n+                   \"\\uFE0C\\uFE0D\\uFE0E\\uFE0F\\uE78D\\uE78F\\uE78E\\uE790\"+\n+                   \"\\uE791\\uE792\\uE793\\uE794\\uE795\\uE796\\uFE1A\\uFE1B\")+\n@@ -3776,4 +3789,8 @@\n-        \"\\u03C7\\u03C8\\u03C9\\uE78D\\uE78E\\uE78F\\uE790\\uE791\"+\n-        \"\\uE792\\uE793\\uFE35\\uFE36\\uFE39\\uFE3A\\uFE3F\\uFE40\"+\n-        \"\\uFE3D\\uFE3E\\uFE41\\uFE42\\uFE43\\uFE44\\uE794\\uE795\"+\n-        \"\\uFE3B\\uFE3C\\uFE37\\uFE38\\uFE31\\uE796\\uFE33\\uFE34\"+\n+        (IS_2000 ? \"\\u03C7\\u03C8\\u03C9\\uE78D\\uE78E\\uE78F\\uE790\\uE791\"+\n+                   \"\\uE792\\uE793\\uFE35\\uFE36\\uFE39\\uFE3A\\uFE3F\\uFE40\"+\n+                   \"\\uFE3D\\uFE3E\\uFE41\\uFE42\\uFE43\\uFE44\\uE794\\uE795\"+\n+                   \"\\uFE3B\\uFE3C\\uFE37\\uFE38\\uFE31\\uE796\\uFE33\\uFE34\" :\n+                   \"\\u03C7\\u03C8\\u03C9\\uFE10\\uFE12\\uFE11\\uFE13\\uFE14\"+\n+                   \"\\uFE15\\uFE16\\uFE35\\uFE36\\uFE39\\uFE3A\\uFE3F\\uFE40\"+\n+                   \"\\uFE3D\\uFE3E\\uFE41\\uFE42\\uFE43\\uFE44\\uFE17\\uFE18\"+\n+                   \"\\uFE3B\\uFE3C\\uFE37\\uFE38\\uFE31\\uFE19\\uFE33\\uFE34\")+\n@@ -3820,1 +3837,2 @@\n-        \"\\u01DC\\u00FC\\u00EA\\u0251\\uE7C7\\u0144\\u0148\\u01F9\"+\n+        (IS_2000 ? \"\\u01DC\\u00FC\\u00EA\\u0251\\uE7C7\\u0144\\u0148\\u01F9\" :\n+                   \"\\u01DC\\u00FC\\u00EA\\u0251\\u1E3F\\u0144\\u0148\\u01F9\")+\n@@ -5871,3 +5889,6 @@\n-        \"\\u3447\\u2E88\\u2E8B\\uE81E\\u359E\\u361A\\u360E\\u2E8C\"+\n-        \"\\u2E97\\u396E\\u3918\\uE826\\u39CF\\u39DF\\u3A73\\u39D0\"+\n-        \"\\uE82B\\uE82C\\u3B4E\\u3C6E\\u3CE0\\u2EA7\\uE831\\uE832\"+\n+        (IS_2000 ? \"\\u3447\\u2E88\\u2E8B\\uE81E\\u359E\\u361A\\u360E\\u2E8C\"+\n+                   \"\\u2E97\\u396E\\u3918\\uE826\\u39CF\\u39DF\\u3A73\\u39D0\"+\n+                   \"\\uE82B\\uE82C\\u3B4E\\u3C6E\\u3CE0\\u2EA7\\uE831\\uE832\" :\n+                   \"\\u3447\\u2E88\\u2E8B\\u9FB4\\u359E\\u361A\\u360E\\u2E8C\"+\n+                   \"\\u2E97\\u396E\\u3918\\u9FB5\\u39CF\\u39DF\\u3A73\\u39D0\"+\n+                   \"\\u9FB6\\u9FB7\\u3B4E\\u3C6E\\u3CE0\\u2EA7\\uE831\\u9FB8\")+\n@@ -5876,1 +5897,2 @@\n-        \"\\uE843\\uFFFD\\u4723\\u4729\\u477C\\u478D\\u2ECA\\u4947\"+\n+        (IS_2000 ? \"\\uE843\\uFFFD\\u4723\\u4729\\u477C\\u478D\\u2ECA\\u4947\" :\n+                   \"\\u9FB9\\uFFFD\\u4723\\u4729\\u477C\\u478D\\u2ECA\\u4947\")+\n@@ -5878,1 +5900,2 @@\n-        \"\\u49B7\\u49B6\\uE854\\uE855\\u4CA3\\u4C9F\\u4CA0\\u4CA1\"+\n+        (IS_2000 ? \"\\u49B7\\u49B6\\uE854\\uE855\\u4CA3\\u4C9F\\u4CA0\\u4CA1\" :\n+                   \"\\u49B7\\u49B6\\u9FBA\\uE855\\u4CA3\\u4C9F\\u4CA0\\u4CA1\")+\n@@ -5880,1 +5903,2 @@\n-        \"\\u4D19\\u4DAE\\uE864\\uE468\\uE469\\uE46A\\uE46B\\uE46C\"+\n+        (IS_2000 ? \"\\u4D19\\u4DAE\\uE864\\uE468\\uE469\\uE46A\\uE46B\\uE46C\" :\n+                   \"\\u4D19\\u4DAE\\u9FBB\\uE468\\uE469\\uE46A\\uE46B\\uE46C\")+\n@@ -6898,1 +6922,2 @@\n-        \"\\u3D1A\\u3D1B\\u3D1C\\u3D1D\\u3D1E\\u3D1F\\u3D20\\u3D21\"+\n+        (IS_2000 ? \"\\u3D1A\\u3D1B\\u3D1C\\u3D1D\\u3D1E\\u3D1F\\u3D20\\u3D21\" :\n+                   \"\\u3D1A\\u3D1B\\u3D1C\\u3D1D\\u3D1E\\u3D1F\\u3D20\\uA8BC\")+\n@@ -11057,2 +11082,4 @@\n-        \"\\u6A6D\\u6A6E\\u6A6F\\u6A70\\u6A71\\u6A72\\u6A73\\u6A74\"+\n-        \"\\u6A75\\u6A76\\u6A77\\u6A78\\u6A79\\u6A7A\\u6A7B\\u6A7C\"+\n+        (IS_2000 ? \"\\u6A6D\\u6A6E\\u6A6F\\u6A70\\u6A71\\u6A72\\u6A73\\u6A74\"+\n+                   \"\\u6A75\\u6A76\\u6A77\\u6A78\\u6A79\\u6A7A\\u6A7B\\u6A7C\" :\n+                   \"\\u6A6D\\u6A6E\\u6A6F\\u6A70\\uFE59\\uFE61\\uFE66\\uFE67\"+\n+                   \"\\uFE6D\\uFE7E\\uFE90\\uFEA0\\u6A79\\u6A7A\\u6A7B\\u6A7C\")+\n@@ -11470,2 +11497,4 @@\n-        \"\\uA6BC\\uA6BD\\uA6BE\\uA6BF\\uA6C0\\uA6D9\\uA6DA\\uA6DB\"+\n-        \"\\uA6DC\\uA6DD\\uA6DE\\uA6DF\\uA6EC\\uA6ED\\uA6F3\\uA6F6\"+\n+        (IS_2000 ? \"\\uA6BC\\uA6BD\\uA6BE\\uA6BF\\uA6C0\\uA6D9\\uA6DA\\uA6DB\"+\n+                   \"\\uA6DC\\uA6DD\\uA6DE\\uA6DF\\uA6EC\\uA6ED\\uA6F3\\uA6F6\" :\n+                   \"\\uA6BC\\uA6BD\\uA6BE\\uA6BF\\uA6C0\\u35E7\\u35E9\\u35E8\"+\n+                   \"\\u35EA\\u35EB\\u35EC\\u35ED\\u35EE\\u35EF\\u35F0\\uA6F6\")+\n@@ -11477,1 +11506,2 @@\n-        \"\\uA89A\\uA89B\\uA89C\\uA89D\\uA89E\\uA89F\\uA8A0\\uA8BC\"+\n+        (IS_2000 ? \"\\uA89A\\uA89B\\uA89C\\uA89D\\uA89E\\uA89F\\uA8A0\\uA8BC\" :\n+                   \"\\uA89A\\uA89B\\uA89C\\uA89D\\uA89E\\uA89F\\uA8A0\\u3D21\")+\n@@ -11488,4 +11518,8 @@\n-        \"\\uFE53\\u2010\\u2011\\u2012\\u2013\\u2014\\uFE59\\u2015\"+\n-        \"\\u2016\\u2017\\u2018\\u2019\\u201A\\u201B\\uFE61\\u201C\"+\n-        \"\\u201D\\u201E\\u201F\\uFE66\\uFE67\\u2020\\u2021\\u2022\"+\n-        \"\\u2023\\uFE6C\\uFE6D\\u2024\\u2025\\u2026\\u2027\\u2028\"+\n+        (IS_2000 ? \"\\uFE53\\u2010\\u2011\\u2012\\u2013\\u2014\\uFE59\\u2015\"+\n+                    \"\\u2016\\u2017\\u2018\\u2019\\u201A\\u201B\\uFE61\\u201C\"+\n+                    \"\\u201D\\u201E\\u201F\\uFE66\\uFE67\\u2020\\u2021\\u2022\"+\n+                    \"\\u2023\\uFE6C\\uFE6D\\u2024\\u2025\\u2026\\u2027\\u2028\" :\n+                    \"\\uFE53\\u2010\\u2011\\u2012\\u2013\\u2014\\u6A71\\u2015\"+\n+                    \"\\u2016\\u2017\\u2018\\u2019\\u201A\\u201B\\u6A72\\u201C\"+\n+                    \"\\u201D\\u201E\\u201F\\u6A73\\u6A74\\u2020\\u2021\\u2022\"+\n+                    \"\\u2023\\uFE6C\\u6A75\\u2024\\u2025\\u2026\\u2027\\u2028\")+\n@@ -11493,1 +11527,2 @@\n-        \"\\u2030\\u2031\\u2032\\uFE7E\\u2033\\u2034\\u2035\\u2036\"+\n+        (IS_2000 ? \"\\u2030\\u2031\\u2032\\uFE7E\\u2033\\u2034\\u2035\\u2036\" :\n+                   \"\\u2030\\u2031\\u2032\\u6A76\\u2033\\u2034\\u2035\\u2036\")+\n@@ -11495,1 +11530,2 @@\n-        \"\\u203F\\u2040\\u2041\\u2042\\uFE90\\uFE91\\u2043\\u2044\"+\n+        (IS_2000 ? \"\\u203F\\u2040\\u2041\\u2042\\uFE90\\uFE91\\u2043\\u2044\" :\n+                   \"\\u203F\\u2040\\u2041\\u2042\\u6A77\\uFE91\\u2043\\u2044\")+\n@@ -11497,1 +11533,2 @@\n-        \"\\u204D\\u204E\\u204F\\u2050\\uFEA0\\u2051\\u2052\\u2053\"+\n+        (IS_2000 ? \"\\u204D\\u204E\\u204F\\u2050\\uFEA0\\u2051\\u2052\\u2053\" :\n+                   \"\\u204D\\u204E\\u204F\\u2050\\u6A78\\u2051\\u2052\\u2053\")+\n@@ -12195,2 +12232,4 @@\n-        \"\\u24FB\\u24FC\\u24FD\\u24FE\\u24FF\\u2500\\u2501\\u2502\"+\n-        \"\\u2503\\u2504\\u2505\\u2506\\u2507\\u2508\\u2509\\u250A\"+\n+        (IS_2000 ? \"\\u24FB\\u24FC\\u24FD\\u24FE\\u24FF\\u2500\\u2501\\u2502\"+\n+                   \"\\u2503\\u2504\\u2505\\u2506\\u2507\\u2508\\u2509\\u250A\" :\n+                   \"\\uA6D9\\uA6DB\\uA6DA\\uA6DC\\uA6DD\\uA6DE\\uA6DF\\uA6EC\"+\n+                   \"\\uA6ED\\uA6F3\\u2505\\u2506\\u2507\\u2508\\u2509\\u250A\")+\n@@ -12409,2 +12448,7 @@\n-                        else if (offset > 0x4A62 && offset <= 0x82BC)\n-                            da[dp++] = (char)(offset + 0x5543);\n+                        else if (offset > 0x4A62 && offset <= 0x82BC) {\n+                            if (offset >= 0x4A71 && offset <= 0x4A78 && !IS_2000) {\n+                                da[dp++] = getChar(offset);\n+                            } else {\n+                                da[dp++] = (char)(offset + 0x5543);\n+                            }\n+                        }\n@@ -12512,2 +12556,7 @@\n-                        else if (offset > 0x4A62 && offset <= 0x82BC)\n-                            dst.put((char)(offset + 0x5543));\n+                        else if (offset > 0x4A62 && offset <= 0x82BC) {\n+                            if (offset >= 0x4A71 && offset <= 0x4A78 && !IS_2000) {\n+                                dst.put(getChar(offset));\n+                            } else {\n+                                dst.put((char)(offset + 0x5543));\n+                            }\n+                        }\n@@ -12623,1 +12672,2 @@\n-                        if (c >= 0xE000 && c < 0xF900)\n+                        if (c >= 0xE000 && c < 0xF900) {\n+                            if (IS_2000) {\n@@ -12625,0 +12675,8 @@\n+                            } else {\n+                                condensedKey = switch (c) {\n+                                    case 0xE7C7, 0xE81E, 0xE826, 0xE82B, 0xE82C, 0xE832,\n+                                        0xE843, 0xE854, 0xE864 -> condensedKey;\n+                                    default -> condensedKey + 0x82BD;\n+                                };\n+                            }\n+                        }\n@@ -12626,1 +12684,1 @@\n-                                condensedKey += 0x93A9;\n+                            condensedKey += 0x93A9;\n@@ -12629,1 +12687,1 @@\n-                             currentState = GB18030_DOUBLE_BYTE;\n+                            currentState = GB18030_DOUBLE_BYTE;\n@@ -12631,1 +12689,1 @@\n-                             currentState = GB18030_FOUR_BYTE;\n+                            currentState = GB18030_FOUR_BYTE;\n@@ -12674,1 +12732,1 @@\n-            return CoderResult.UNDERFLOW;\n+                return CoderResult.UNDERFLOW;\n@@ -12714,1 +12772,2 @@\n-                        if (c >= 0xE000 && c < 0xF900)\n+                        if (c >= 0xE000 && c < 0xF900) {\n+                            if (IS_2000) {\n@@ -12716,0 +12775,8 @@\n+                            } else {\n+                                condensedKey = switch (c) {\n+                                    case 0xE7C7, 0xE81E, 0xE826, 0xE82B, 0xE82C, 0xE832,\n+                                        0xE843, 0xE854, 0xE864 -> condensedKey;\n+                                    default -> condensedKey + 0x82BD;\n+                                };\n+                            }\n+                        }\n@@ -12717,1 +12784,1 @@\n-                                condensedKey += 0x93A9;\n+                            condensedKey += 0x93A9;\n@@ -12720,1 +12787,1 @@\n-                             currentState = GB18030_DOUBLE_BYTE;\n+                            currentState = GB18030_DOUBLE_BYTE;\n@@ -12722,1 +12789,1 @@\n-                             currentState = GB18030_FOUR_BYTE;\n+                            currentState = GB18030_FOUR_BYTE;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/GB18030.java","additions":114,"deletions":47,"binary":false,"changes":161,"previous_filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/GB18030.java.template","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,2 +61,7 @@\n-        String acn = aliasMap().get(csn);\n-        return (acn != null) ? acn : csn;\n+        if (csn.startsWith(\"gb18030-\")) {\n+            return csn.equals(\"gb18030-2022\") && !GB18030.IS_2000 ||\n+                   csn.equals(\"gb18030-2000\") && GB18030.IS_2000 ? \"gb18030\" : csn;\n+        } else {\n+            String acn = aliasMap().get(csn);\n+            return (acn != null) ? acn : csn;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/StandardCharsets.java.template","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.util.stream.Stream;\n@@ -141,1 +142,0 @@\n-\n@@ -150,0 +150,11 @@\n+    \/**\n+     * Returns a stream of the available locales for all the provider classes.\n+     * This stream is constructed from all the locales\n+     * that are provided by each provider, including the JRE.\n+     *\n+     * @return a stream of the available locales for all provider classes\n+     *\/\n+    public static Stream<Locale> streamAllAvailableLocales() {\n+        return Arrays.stream(AllAvailableLocales.allAvailableLocales);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/provider\/LocaleServiceProviderPool.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -7,1 +7,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/java.base\/share\/native\/libjava\/Continuation.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,2 +106,2 @@\n-void getDeviceString(char* buffer, int card, int device, int subdevice,\n-                     int usePlugHw, int isMidi) {\n+void getDeviceString(char* buffer, size_t bufferSize, int card, int device,\n+                     int subdevice, int usePlugHw, int isMidi) {\n@@ -109,1 +109,1 @@\n-        sprintf(buffer, \"%s:%d,%d,%d\",\n+        snprintf(buffer, bufferSize, \"%s:%d,%d,%d\",\n@@ -113,1 +113,1 @@\n-        sprintf(buffer, \"%s:%d,%d\",\n+        snprintf(buffer, bufferSize, \"%s:%d,%d\",\n@@ -120,2 +120,2 @@\n-void getDeviceStringFromDeviceID(char* buffer, UINT32 deviceID,\n-                                 int usePlugHw, int isMidi) {\n+void getDeviceStringFromDeviceID(char* buffer, size_t bufferSize,\n+                                 UINT32 deviceID, int usePlugHw, int isMidi) {\n@@ -128,1 +128,1 @@\n-        getDeviceString(buffer, card, device, subdevice, usePlugHw, isMidi);\n+        getDeviceString(buffer, bufferSize, card, device, subdevice, usePlugHw, isMidi);\n","filename":"src\/java.desktop\/linux\/native\/libjsound\/PLATFORM_API_LinuxOS_ALSA_CommonUtils.c","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -76,2 +76,2 @@\n-void getDeviceStringFromDeviceID(char* buffer, UINT32 deviceID,\n-                                 int usePlugHw, int isMidi);\n+void getDeviceStringFromDeviceID(char* buffer, size_t bufferSize,\n+                                 UINT32 deviceID, int usePlugHw, int isMidi);\n","filename":"src\/java.desktop\/linux\/native\/libjsound\/PLATFORM_API_LinuxOS_ALSA_CommonUtils.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-                sprintf(devname, ALSA_HARDWARE_CARD, card);\n+                snprintf(devname, sizeof(devname), ALSA_HARDWARE_CARD, card);\n@@ -124,1 +124,1 @@\n-            sprintf(devname, ALSA_HARDWARE_CARD, card);\n+            snprintf(devname, sizeof(devname), ALSA_HARDWARE_CARD, card);\n@@ -233,1 +233,1 @@\n-        getDeviceStringFromDeviceID(&buffer[2], deviceID, usePlugHw, ALSA_RAWMIDI);\n+        getDeviceStringFromDeviceID(&buffer[2], sizeof(buffer) - 2, deviceID, usePlugHw, ALSA_RAWMIDI);\n@@ -395,1 +395,1 @@\n-    getDeviceStringFromDeviceID(devicename, deviceID,\n+    getDeviceStringFromDeviceID(devicename, sizeof(devicename), deviceID,\n","filename":"src\/java.desktop\/linux\/native\/libjsound\/PLATFORM_API_LinuxOS_ALSA_MidiUtils.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-                sprintf(devname, ALSA_HARDWARE_CARD, card);\n+                snprintf(devname, sizeof(devname), ALSA_HARDWARE_CARD, card);\n@@ -104,1 +104,1 @@\n-        sprintf(devname, ALSA_HARDWARE_CARD, card);\n+        snprintf(devname, sizeof(devname), ALSA_HARDWARE_CARD, card);\n@@ -188,1 +188,1 @@\n-        getDeviceStringFromDeviceID(&buffer[2], deviceID, usePlugHw, ALSA_PCM);\n+        getDeviceStringFromDeviceID(&buffer[2], sizeof(buffer) - 2, deviceID, usePlugHw, ALSA_PCM);\n@@ -220,1 +220,1 @@\n-    getDeviceStringFromDeviceID(buffer, deviceID, !hardware, ALSA_PCM);\n+    getDeviceStringFromDeviceID(buffer, sizeof(buffer), deviceID, !hardware, ALSA_PCM);\n","filename":"src\/java.desktop\/linux\/native\/libjsound\/PLATFORM_API_LinuxOS_ALSA_PCMUtils.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-            sprintf(devname, ALSA_HARDWARE_CARD, card);\n+            snprintf(devname, sizeof(devname), ALSA_HARDWARE_CARD, card);\n@@ -118,1 +118,1 @@\n-    sprintf(devname, ALSA_HARDWARE_CARD, (int) mixerIndex);\n+    snprintf(devname, sizeof(devname), ALSA_HARDWARE_CARD, (int) mixerIndex);\n@@ -130,1 +130,1 @@\n-    sprintf(buffer, \" [%s]\", devname);\n+    snprintf(buffer, sizeof(buffer), \" [%s]\", devname);\n@@ -152,1 +152,1 @@\n-    sprintf(devname, ALSA_HARDWARE_CARD, (int) mixerIndex);\n+    snprintf(devname, sizeof(devname), ALSA_HARDWARE_CARD, (int) mixerIndex);\n","filename":"src\/java.desktop\/linux\/native\/libjsound\/PLATFORM_API_LinuxOS_ALSA_Ports.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-        sprintf(s, \"%s-%s:%d\", __FILE__, __FUNCTION__, __LINE__);       \\\n+        snprintf(s, sizeof(s), \"%s-%s:%d\", __FILE__, __FUNCTION__, __LINE__);       \\\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/AWTStrike.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -304,1 +304,6 @@\n-                        return doInBackground();\n+                        try {\n+                            return doInBackground();\n+                        } finally {\n+                            doneEDT();\n+                            setState(StateValue.DONE);\n+                        }\n@@ -308,7 +313,1 @@\n-        future = new FutureTask<T>(callable) {\n-                       @Override\n-                       protected void done() {\n-                           doneEDT();\n-                           setState(StateValue.DONE);\n-                       }\n-                   };\n+       future = new FutureTask<T>(callable);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/SwingWorker.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -268,1 +269,1 @@\n-        private java.util.List<SynthPainter> painters;\n+        private final List<SynthPainter> painters;\n@@ -271,1 +272,1 @@\n-            painters = new LinkedList<SynthPainter>();\n+            painters = new ArrayList<>();\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/ParsedSynthStyle.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-    sprintf(report, reportFormat, header->filename, header->linenumber, header->size, header->order);\n+    snprintf(report, sizeof(report), reportFormat, header->filename, header->linenumber, header->size, header->order);\n","filename":"src\/java.desktop\/share\/native\/common\/awt\/debug\/debug_mem.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-    vsprintf(DTraceBuffer, fmt, arglist);\n+    vsnprintf(DTraceBuffer, sizeof(DTraceBuffer), fmt, arglist);\n","filename":"src\/java.desktop\/share\/native\/common\/awt\/debug\/debug_trace.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * a call to sprintf().  See the OGLBufImgOps_CreateConvolveProgram() method\n+ * a call to snprintf().  See the OGLBufImgOps_CreateConvolveProgram() method\n@@ -144,1 +144,1 @@\n-        sprintf(edge, \"sum = vec4(0.0);\");\n+        snprintf(edge, sizeof(edge), \"sum = vec4(0.0);\");\n@@ -147,1 +147,1 @@\n-        sprintf(edge,\n+        snprintf(edge, sizeof(edge),\n@@ -153,1 +153,1 @@\n-    sprintf(finalSource, convolveShaderSource,\n+    snprintf(finalSource, sizeof(finalSource), convolveShaderSource,\n@@ -299,1 +299,1 @@\n- * simply by filling in these \"holes\" with a call to sprintf().  See the\n+ * simply by filling in these \"holes\" with a call to snprintf().  See the\n@@ -363,1 +363,1 @@\n-    sprintf(finalSource, rescaleShaderSource,\n+    snprintf(finalSource, sizeof(finalSource), rescaleShaderSource,\n@@ -505,1 +505,1 @@\n- * simply by filling in these \"holes\" with a call to sprintf().  See the\n+ * simply by filling in these \"holes\" with a call to snprintf().  See the\n@@ -595,1 +595,1 @@\n-    sprintf(finalSource, lookupShaderSource,\n+    snprintf(finalSource, sizeof(finalSource), lookupShaderSource,\n","filename":"src\/java.desktop\/share\/native\/common\/java2d\/opengl\/OGLBufImgOps.c","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -581,1 +581,1 @@\n-        sprintf(cycleCode, noCycleCode, texCoordCalcCode);\n+        snprintf(cycleCode, sizeof(cycleCode), noCycleCode, texCoordCalcCode);\n@@ -583,1 +583,1 @@\n-        sprintf(cycleCode, reflectCode, texCoordCalcCode);\n+        snprintf(cycleCode, sizeof(cycleCode), reflectCode, texCoordCalcCode);\n@@ -585,1 +585,1 @@\n-        sprintf(cycleCode, repeatCode, texCoordCalcCode);\n+        snprintf(cycleCode, sizeof(cycleCode), repeatCode, texCoordCalcCode);\n@@ -589,1 +589,1 @@\n-    sprintf(finalSource, multiGradientShaderSource,\n+    snprintf(finalSource, sizeof(finalSource), multiGradientShaderSource,\n","filename":"src\/java.desktop\/share\/native\/common\/java2d\/opengl\/OGLPaints.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n@@ -43,1 +43,1 @@\n-    LinkedList<AWTKeyStroke> strokes;\n+    private ArrayList<AWTKeyStroke> strokes;\n@@ -58,1 +58,1 @@\n-        strokes = new LinkedList<AWTKeyStroke>();\n+        strokes = new ArrayList<>();\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XEmbeddedFramePeer.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -390,1 +390,1 @@\n-    sprintf(buf, \"%d\", err->request_code);\n+    snprintf(buf, sizeof(buf), \"%d\", err->request_code);\n","filename":"src\/java.desktop\/unix\/native\/libsplashscreen\/splashscreen_sys.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        sprintf(pargs,\n+        snprintf(pargs, sizeof(pargs),\n@@ -147,1 +147,1 @@\n-    sprintf(array, \"const DWORD *%sShaders[] =\\n{\\n\", name);\n+    snprintf(array, sizeof(array), \"const DWORD *%sShaders[] =\\n{\\n\", name);\n@@ -151,1 +151,1 @@\n-            sprintf(elem, \"    NULL,\\n\");\n+            snprintf(elem, sizeof(elem), \"    NULL,\\n\");\n@@ -153,1 +153,1 @@\n-            sprintf(elem, \"    %s%d,\\n\", name, i);\n+            snprintf(elem, sizeof(elem), \"    %s%d,\\n\", name, i);\n@@ -228,1 +228,1 @@\n-    sprintf(finalSource, convolveShaderSource,\n+    snprintf(finalSource, sizeof(finalSource), convolveShaderSource,\n@@ -286,1 +286,1 @@\n-    sprintf(finalSource, rescaleShaderSource,\n+    snprintf(finalSource, sizeof(finalSource), rescaleShaderSource,\n@@ -360,1 +360,1 @@\n-    sprintf(finalSource, lookupShaderSource,\n+    snprintf(finalSource, sizeof(finalSource), lookupShaderSource,\n@@ -455,1 +455,1 @@\n-    sprintf(finalSource, basicGradientShaderSource,\n+    snprintf(finalSource, sizeof(finalSource), basicGradientShaderSource,\n@@ -668,1 +668,1 @@\n-        sprintf(cycleCode, noCycleCode, texCoordCalcCode);\n+        snprintf(cycleCode, sizeof(cycleCode), noCycleCode, texCoordCalcCode);\n@@ -670,1 +670,1 @@\n-        sprintf(cycleCode, reflectCode, texCoordCalcCode);\n+        snprintf(cycleCode, sizeof(cycleCode), reflectCode, texCoordCalcCode);\n@@ -672,1 +672,1 @@\n-        sprintf(cycleCode, repeatCode, texCoordCalcCode);\n+        snprintf(cycleCode, sizeof(cycleCode), repeatCode, texCoordCalcCode);\n@@ -676,1 +676,1 @@\n-    sprintf(finalSource, multiGradientShaderSource,\n+    snprintf(finalSource, sizeof(finalSource), multiGradientShaderSource,\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DShaderGen.c","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-        sprintf(c, \"Could not initialize COM: HRESULT=0x%08X\", hr);\n+        snprintf(c, sizeof(c), \"Could not initialize COM: HRESULT=0x%08X\", hr);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/ShellFolder2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1337,1 +1337,1 @@\n-            sprintf(szBuf, \"0x%8.8x(%s):Unknown message 0x%8.8x\\n\",\n+            snprintf(szBuf, sizeof(szBuf), \"0x%8.8x(%s):Unknown message 0x%8.8x\\n\",\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Component.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-        sprintf(name, \"%d.%d\", (midiInCaps.vDriverVersion & 0xFF00) >> 8, midiInCaps.vDriverVersion & 0xFF);\n+        snprintf(name, nameLength + 1, \"%d.%d\", (midiInCaps.vDriverVersion & 0xFF00) >> 8, midiInCaps.vDriverVersion & 0xFF);\n","filename":"src\/java.desktop\/windows\/native\/libjsound\/PLATFORM_API_WinOS_MidiIn.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-        sprintf(name, \"%d.%d\", (midiOutCaps.vDriverVersion & 0xFF00) >> 8, midiOutCaps.vDriverVersion & 0xFF);\n+        snprintf(name, nameLength + 1, \"%d.%d\", (midiOutCaps.vDriverVersion & 0xFF00) >> 8, midiOutCaps.vDriverVersion & 0xFF);\n","filename":"src\/java.desktop\/windows\/native\/libjsound\/PLATFORM_API_WinOS_MidiOut.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,2 +116,3 @@\n-        r += strlen(ret);\n-        sprintf((char*) r, \"%d\", flags);\n+        size_t usedLen = strlen(ret);\n+        r += usedLen;\n+        snprintf((char*) r, sizeof(ret) - usedLen, \"%d\", flags);\n@@ -222,2 +223,3 @@\n-        r += strlen(ret);\n-        sprintf((char*) r, \"%d\", controlState);\n+        size_t usedLen = strlen(ret);\n+        r += usedLen;\n+        snprintf((char*) r, sizeof(ret) - usedLen, \"%d\", controlState);\n@@ -362,1 +364,1 @@\n-        sprintf(description->version, \"%d.%d\", (mixerCaps.vDriverVersion & 0xFF00) >> 8, mixerCaps.vDriverVersion & 0xFF);\n+        snprintf(description->version, sizeof(description->version), \"%d.%d\", (mixerCaps.vDriverVersion & 0xFF00) >> 8, mixerCaps.vDriverVersion & 0xFF);\n","filename":"src\/java.desktop\/windows\/native\/libjsound\/PLATFORM_API_WinOS_Ports.c","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,2 @@\n- * <pre>{@code    HttpClient client = HttpClient.newBuilder()\n+ * {@snippet :\n+ *   HttpClient client = HttpClient.newBuilder()\n@@ -97,1 +98,1 @@\n- *   System.out.println(response.body());  }<\/pre>\n+ *   System.out.println(response.body());  }\n@@ -100,1 +101,2 @@\n- * <pre>{@code    HttpRequest request = HttpRequest.newBuilder()\n+ * {@snippet :\n+ *    HttpRequest request = HttpRequest.newBuilder()\n@@ -108,1 +110,1 @@\n- *        .thenAccept(System.out::println);  }<\/pre>\n+ *        .thenAccept(System.out::println);  }\n@@ -691,1 +693,2 @@\n-     * <pre>{@code    HttpClient client = HttpClient.newHttpClient();\n+     * {@snippet :\n+     *   HttpClient client = HttpClient.newHttpClient();\n@@ -693,1 +696,1 @@\n-     *           .buildAsync(URI.create(\"ws:\/\/websocket.example.com\"), listener); }<\/pre>\n+     *      .buildAsync(URI.create(\"ws:\/\/websocket.example.com\"), listener);  }\n@@ -699,1 +702,2 @@\n-     * <pre>{@code    InetSocketAddress addr = new InetSocketAddress(\"proxy.example.com\", 80);\n+     * {@snippet :\n+     *   InetSocketAddress addr = new InetSocketAddress(\"proxy.example.com\", 80);\n@@ -703,0 +707,1 @@\n+     *\n@@ -704,1 +709,1 @@\n-     *           .buildAsync(URI.create(\"ws:\/\/websocket.example.com\"), listener); }<\/pre>\n+     *           .buildAsync(URI.create(\"ws:\/\/websocket.example.com\"), listener);  }\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpClient.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,3 @@\n- * <pre>{@code    HttpClient client = HttpClient.newHttpClient();\n+ * {@snippet :\n+ *   HttpClient client = HttpClient.newHttpClient();\n+ *\n@@ -73,0 +75,1 @@\n+ *\n@@ -76,1 +79,1 @@\n- *         .join(); }<\/pre>\n+ *         .join(); }\n@@ -344,1 +347,2 @@\n-     *  <pre>{@code HttpRequest.newBuilder(request, (n, v) -> true)}<\/pre>\n+     *  {@snippet :\n+     *  HttpRequest.newBuilder(request, (n, v) -> true) }\n@@ -347,1 +351,2 @@\n-     *  <pre>{@code HttpRequest.newBuilder(request, (n, v) -> false)}<\/pre>\n+     *  {@snippet :\n+     *  HttpRequest.newBuilder(request, (n, v) -> false) }\n@@ -350,1 +355,2 @@\n-     *  <pre>{@code HttpRequest.newBuilder(request, (name, value) -> !name.equalsIgnoreCase(\"Foo-Bar\"))}<\/pre>\n+     *  {@snippet :\n+     *  HttpRequest.newBuilder(request, (name, value) -> !name.equalsIgnoreCase(\"Foo-Bar\")) }\n@@ -564,1 +570,2 @@\n-     *  <pre>{@code    \/\/ Request body from a String\n+     * {@snippet :\n+     *   \/\/ Request body from a String\n@@ -569,1 +576,1 @@\n-     *        .build();\n+     *        .build(); }\n@@ -571,0 +578,1 @@\n+     * {@snippet :\n@@ -576,1 +584,1 @@\n-     *        .build();\n+     *        .build(); }\n@@ -578,0 +586,1 @@\n+     * {@snippet :\n@@ -582,1 +591,1 @@\n-     *        .build(); }<\/pre>\n+     *        .build(); }\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpRequest.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,2 +80,3 @@\n- * <pre>{@code    HttpResponse<String> response = client\n- *     .send(request, BodyHandlers.ofString()); }<\/pre>\n+ * {@snippet :\n+ *     HttpResponse<String> response = client\n+ *       .send(request, BodyHandlers.ofString()); }\n@@ -214,1 +215,2 @@\n-     * <pre>{@code   HttpRequest request = HttpRequest.newBuilder()\n+     * {@snippet :\n+     *    HttpRequest request = HttpRequest.newBuilder()\n@@ -217,0 +219,1 @@\n+     *\n@@ -219,1 +222,1 @@\n-     *        .thenAccept(System.out::println); }<\/pre>\n+     *        .thenAccept(System.out::println); }\n@@ -227,1 +230,2 @@\n-     * <pre>{@code   HttpRequest request = HttpRequest.newBuilder()\n+     * {@snippet :\n+     *    HttpRequest request = HttpRequest.newBuilder()\n@@ -235,1 +239,1 @@\n-     *        .thenAccept(System.out::println); }<\/pre>\n+     *        .thenAccept(System.out::println); }\n@@ -275,1 +279,2 @@\n-     * <pre>{@code    \/\/ Receives the response body as a String\n+     * {@snippet :\n+     *   \/\/ Receives the response body as a String\n@@ -277,1 +282,1 @@\n-     *     .send(request, BodyHandlers.ofString());\n+     *     .send(request, BodyHandlers.ofString()); }\n@@ -279,0 +284,1 @@\n+     * {@snippet :\n@@ -281,1 +287,1 @@\n-     *     .send(request, BodyHandlers.ofFile(Paths.get(\"example.html\")));\n+     *     .send(request, BodyHandlers.ofFile(Paths.get(\"example.html\"))); }\n@@ -283,0 +289,1 @@\n+     * {@snippet :\n@@ -285,1 +292,1 @@\n-     *     .send(request, BodyHandlers.ofInputStream());\n+     *     .send(request, BodyHandlers.ofInputStream()); }\n@@ -287,0 +294,1 @@\n+     * {@snippet :\n@@ -289,1 +297,1 @@\n-     *     .send(request, BodyHandlers.discarding());  }<\/pre>\n+     *     .send(request, BodyHandlers.discarding());  }\n@@ -313,1 +321,2 @@\n-         * <pre> {@code  TextSubscriber subscriber = new TextSubscriber();\n+         * {@snippet :\n+         *  TextSubscriber subscriber = new TextSubscriber();\n@@ -316,1 +325,1 @@\n-         *  System.out.println(response.statusCode()); }<\/pre>\n+         *  System.out.println(response.statusCode()); }\n@@ -343,1 +352,2 @@\n-         * <pre> {@code  TextSubscriber subscriber = ...;  \/\/ accumulates bytes and transforms them into a String\n+         * {@snippet :\n+         *  TextSubscriber subscriber = ...;  \/\/ accumulates bytes and transforms them into a String\n@@ -346,1 +356,1 @@\n-         *  String text = response.body(); }<\/pre>\n+         *  String text = response.body(); }\n@@ -383,1 +393,2 @@\n-         * <pre> {@code  \/\/ A PrintSubscriber that implements Flow.Subscriber<String>\n+         * {@snippet :\n+         *  \/\/ A PrintSubscriber that implements Flow.Subscriber<String>\n@@ -392,1 +403,1 @@\n-         *      }); }<\/pre>\n+         *      }); }\n@@ -426,1 +437,2 @@\n-         * <pre> {@code  \/\/ A LineParserSubscriber that implements Flow.Subscriber<String>\n+         * {@snippet :\n+         *  \/\/ A LineParserSubscriber that implements Flow.Subscriber<String>\n@@ -434,1 +446,1 @@\n-         *  } }<\/pre>\n+         *  } }\n@@ -907,1 +919,2 @@\n-     * <pre>{@code    \/\/ Streams the response body to a File\n+     * {@snippet :\n+     *   \/\/ Streams the response body to a File\n@@ -909,1 +922,1 @@\n-     *     .send(request, responseInfo -> BodySubscribers.ofFile(Paths.get(\"example.html\"));\n+     *     .send(request, responseInfo -> BodySubscribers.ofFile(Paths.get(\"example.html\")); }\n@@ -911,0 +924,1 @@\n+     * {@snippet :\n@@ -913,1 +927,1 @@\n-     *     .send(request, responseInfo -> BodySubscribers.ofByteArray());\n+     *     .send(request, responseInfo -> BodySubscribers.ofByteArray()); }\n@@ -915,0 +929,1 @@\n+     * {@snippet :\n@@ -917,1 +932,1 @@\n-     *     .send(request, responseInfo -> BodySubscribers.discarding());\n+     *     .send(request, responseInfo -> BodySubscribers.discarding()); }\n@@ -919,0 +934,1 @@\n+     * {@snippet :\n@@ -922,2 +938,1 @@\n-     *        BodySubscribers.mapping(BodySubscribers.ofString(UTF_8), String::getBytes));\n-     * }<\/pre>\n+     *        BodySubscribers.mapping(BodySubscribers.ofString(UTF_8), String::getBytes)); }\n@@ -991,3 +1006,2 @@\n-         * @implNote This is equivalent to calling <pre>{@code\n-         *      fromLineSubscriber(subscriber, s -> null, StandardCharsets.UTF_8, null)\n-         * }<\/pre>\n+         * @implNote This is equivalent to calling {@snippet :\n+         *      fromLineSubscriber(subscriber, s -> null, StandardCharsets.UTF_8, null) }\n@@ -1333,1 +1347,2 @@\n-         * <pre> {@code  public static <W> BodySubscriber<Supplier<W>> asJSON(Class<W> targetType) {\n+         * {@snippet :\n+         *   public static <W> BodySubscriber<Supplier<W>> asJSON(Class<W> targetType) {\n@@ -1347,1 +1362,1 @@\n-         *  } }<\/pre>\n+         *  } }\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpResponse.java","additions":46,"deletions":31,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -261,1 +261,2 @@\n-     * <pre>{@code     WebSocket.Listener listener = new WebSocket.Listener() {\n+     * {@snippet :\n+     *        WebSocket.Listener listener = new WebSocket.Listener() {\n@@ -281,2 +282,1 @@\n-     *    ...\n-     *    } } <\/pre>\n+     *    }; }\n@@ -295,1 +295,2 @@\n-         * <pre>{@code     webSocket.request(1); }<\/pre>\n+         * {@snippet :\n+         *  webSocket.request(1); }\n@@ -311,2 +312,3 @@\n-         * <pre>{@code     webSocket.request(1);\n-         *    return null; }<\/pre>\n+         * {@snippet :\n+         *    webSocket.request(1);\n+         *    return null; }\n@@ -346,2 +348,3 @@\n-         * <pre>{@code     webSocket.request(1);\n-         *    return null; }<\/pre>\n+         * {@snippet :\n+         *    webSocket.request(1);\n+         *    return null; }\n@@ -384,2 +387,3 @@\n-         * <pre>{@code     webSocket.request(1);\n-         *    return null; }<\/pre>\n+         * {@snippet :\n+         *    webSocket.request(1);\n+         *    return null; }\n@@ -415,2 +419,3 @@\n-         * <pre>{@code     webSocket.request(1);\n-         *    return null; }<\/pre>\n+         * {@snippet :\n+         *    webSocket.request(1);\n+         *    return null; }\n@@ -459,3 +464,4 @@\n-         * <pre>{@code     public CompletionStage<?> onClose(WebSocket webSocket,\n-         *                                      int statusCode,\n-         *                                      String reason) {\n+         * {@snippet :\n+         *       public CompletionStage<?> onClose(WebSocket webSocket,\n+         *                            int statusCode,\n+         *                            String reason) {\n@@ -464,1 +470,1 @@\n-         *    } } <\/pre>\n+         *    } }\n@@ -657,2 +663,3 @@\n-     * <pre>{@code     CompletableFuture<WebSocket> webSocket = ...\n-     *    webSocket.thenCompose(ws -> ws.sendText(\"Hello, \", false))\n+     * {@snippet :\n+     *      CompletableFuture<WebSocket> webSocket = ...\n+     *      webSocket.thenCompose(ws -> ws.sendText(\"Hello, \", false))\n@@ -661,1 +668,2 @@\n-     *             .join(); }<\/pre>\n+     *             .join();\n+     * }\n@@ -669,1 +677,2 @@\n-     * <pre>{@code     MyAlarm alarm = new MyAlarm(webSocket::abort);\n+     * {@snippet :\n+     *    MyAlarm alarm = new MyAlarm(webSocket::abort);\n@@ -685,2 +694,1 @@\n-     *    webSocket.sendClose(WebSocket.NORMAL_CLOSURE, \"ok\").thenRun(startTimer);\n-     * } <\/pre>\n+     *    webSocket.sendClose(WebSocket.NORMAL_CLOSURE, \"ok\").thenRun(startTimer); }\n@@ -720,1 +728,2 @@\n-     * <pre>{@code     WebSocket.Listener listener = new WebSocket.Listener() {\n+     * {@snippet :\n+     *        WebSocket.Listener listener = new WebSocket.Listener() {\n@@ -735,2 +744,1 @@\n-     *    ...\n-     *    } } <\/pre>\n+     *    }; }\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/WebSocket.java","additions":34,"deletions":26,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,0 @@\n-import java.nio.charset.Charset;\n-import java.nio.charset.spi.CharsetProvider;\n-\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/ExtendedCharsets.java.template","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-     * Flag that marks potentially ambiguous overloads\n+     * Currently available: Bit 48.\n@@ -280,1 +280,0 @@\n-    public static final long POTENTIALLY_AMBIGUOUS = 1L<<48;\n@@ -529,1 +528,1 @@\n-        POTENTIALLY_AMBIGUOUS(Flags.POTENTIALLY_AMBIGUOUS),\n+        \/\/ Bit 48 is currently available\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3726,1 +3726,1 @@\n-     * Collect types into a new closure (using a @code{ClosureHolder})\n+     * Collect types into a new closure (using a {@code ClosureHolder})\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-         * Should {@link Attr#attribTree} use the {@ArgumentAttr} visitor instead of this one?\n+         * Should {@link Attr#attribTree} use the {@code ArgumentAttr} visitor instead of this one?\n@@ -511,1 +511,1 @@\n-         * @return true if {@ArgumentAttr} should be used.\n+         * @return true if {@code ArgumentAttr} should be used.\n@@ -5566,0 +5566,1 @@\n+            chk.checkPotentiallyAmbiguousOverloads(tree, c.type);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.util.function.BiPredicate;\n+import java.util.function.Consumer;\n@@ -32,0 +34,3 @@\n+import java.util.function.ToIntBiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n@@ -71,0 +76,1 @@\n+import static com.sun.tools.javac.code.Scope.LookupKind.RECURSIVE;\n@@ -93,0 +99,4 @@\n+    \/\/ Flag bits indicating which item(s) chosen from a pair of items\n+    private static final int FIRST = 0x01;\n+    private static final int SECOND = 0x02;\n+\n@@ -2557,2 +2567,0 @@\n-        List<MethodSymbol> potentiallyAmbiguousList = List.nil();\n-        boolean overridesAny = false;\n@@ -2563,7 +2571,0 @@\n-                if (m1 == sym) {\n-                    continue;\n-                }\n-\n-                if (!overridesAny) {\n-                    potentiallyAmbiguousList = potentiallyAmbiguousList.prepend((MethodSymbol)m1);\n-                }\n@@ -2573,5 +2574,0 @@\n-            if (m1 != sym) {\n-                overridesAny = true;\n-                potentiallyAmbiguousList = List.nil();\n-            }\n-\n@@ -2607,6 +2603,0 @@\n-\n-        if (!overridesAny) {\n-            for (MethodSymbol m: potentiallyAmbiguousList) {\n-                checkPotentiallyAmbiguousOverloads(pos, site, sym, m);\n-            }\n-        }\n@@ -2633,2 +2623,0 @@\n-                } else {\n-                    checkPotentiallyAmbiguousOverloads(pos, site, sym, (MethodSymbol)s);\n@@ -2723,0 +2711,189 @@\n+    \/** Report warnings for potentially ambiguous method declarations in the given site. *\/\n+    void checkPotentiallyAmbiguousOverloads(JCClassDecl tree, Type site) {\n+\n+        \/\/ Skip if warning not enabled\n+        if (!lint.isEnabled(LintCategory.OVERLOADS))\n+            return;\n+\n+        \/\/ Gather all of site's methods, including overridden methods, grouped by name (except Object methods)\n+        List<java.util.List<MethodSymbol>> methodGroups = methodsGroupedByName(site,\n+            new PotentiallyAmbiguousFilter(site), ArrayList::new);\n+\n+        \/\/ Build the predicate that determines if site is responsible for an ambiguity\n+        BiPredicate<MethodSymbol, MethodSymbol> responsible = buildResponsiblePredicate(site, methodGroups);\n+\n+        \/\/ Now remove overridden methods from each group, leaving only site's actual members\n+        methodGroups.forEach(list -> removePreempted(list, (m1, m2) -> m1.overrides(m2, site.tsym, types, false)));\n+\n+        \/\/ Allow site's own declared methods (only) to apply @SuppressWarnings(\"overloads\")\n+        methodGroups.forEach(list -> list.removeIf(\n+            m -> m.owner == site.tsym && !lint.augment(m).isEnabled(LintCategory.OVERLOADS)));\n+\n+        \/\/ Warn about ambiguous overload method pairs for which site is responsible\n+        methodGroups.forEach(list -> compareAndRemove(list, (m1, m2) -> {\n+\n+            \/\/ See if this is an ambiguous overload for which \"site\" is responsible\n+            if (!potentiallyAmbiguousOverload(site, m1, m2) || !responsible.test(m1, m2))\n+                return 0;\n+\n+            \/\/ Locate the warning at one of the methods, if possible\n+            DiagnosticPosition pos =\n+                m1.owner == site.tsym ? TreeInfo.diagnosticPositionFor(m1, tree) :\n+                m2.owner == site.tsym ? TreeInfo.diagnosticPositionFor(m2, tree) :\n+                tree.pos();\n+\n+            \/\/ Log the warning\n+            log.warning(LintCategory.OVERLOADS, pos,\n+                Warnings.PotentiallyAmbiguousOverload(\n+                    m1.asMemberOf(site, types), m1.location(),\n+                    m2.asMemberOf(site, types), m2.location()));\n+\n+            \/\/ Don't warn again for either of these two methods\n+            return FIRST | SECOND;\n+        }));\n+    }\n+\n+    \/** Build a predicate that determines, given two methods that are members of the given class,\n+     *  whether the class should be held \"responsible\" if the methods are potentially ambiguous.\n+     *\n+     *  Sometimes ambiguous methods are unavoidable because they're inherited from a supertype.\n+     *  For example, any subtype of Spliterator.OfInt will have ambiguities for both\n+     *  forEachRemaining() and tryAdvance() (in both cases the overloads are IntConsumer and\n+     *  Consumer&lt;? super Integer&gt;). So we only want to \"blame\" a class when that class is\n+     *  itself responsible for creating the ambiguity. We declare that a class C is \"responsible\"\n+     *  for the ambiguity between two methods m1 and m2 if there is no direct supertype T of C\n+     *  such that m1 and m2, or some overrides thereof, both exist in T and are ambiguous in T.\n+     *  As an optimization, we first check if either method is declared in C and does not override\n+     *  any other methods; in this case the class is definitely responsible.\n+     *\/\n+    BiPredicate<MethodSymbol, MethodSymbol> buildResponsiblePredicate(Type site,\n+        List<? extends Collection<MethodSymbol>> methodGroups) {\n+\n+        \/\/ Define the \"overrides\" predicate\n+        BiPredicate<MethodSymbol, MethodSymbol> overrides = (m1, m2) -> m1.overrides(m2, site.tsym, types, false);\n+\n+        \/\/ Map each method declared in site to a list of the supertype method(s) it directly overrides\n+        HashMap<MethodSymbol, ArrayList<MethodSymbol>> overriddenMethodsMap = new HashMap<>();\n+        methodGroups.forEach(list -> {\n+            for (MethodSymbol m : list) {\n+\n+                \/\/ Skip methods not declared in site\n+                if (m.owner != site.tsym)\n+                    continue;\n+\n+                \/\/ Gather all supertype methods overridden by m, directly or indirectly\n+                ArrayList<MethodSymbol> overriddenMethods = list.stream()\n+                  .filter(m2 -> m2 != m && overrides.test(m, m2))\n+                  .collect(Collectors.toCollection(ArrayList::new));\n+\n+                \/\/ Eliminate non-direct overrides\n+                removePreempted(overriddenMethods, overrides);\n+\n+                \/\/ Add to map\n+                overriddenMethodsMap.put(m, overriddenMethods);\n+            }\n+        });\n+\n+        \/\/ Build the predicate\n+        return (m1, m2) -> {\n+\n+            \/\/ Get corresponding supertype methods (if declared in site)\n+            java.util.List<MethodSymbol> overriddenMethods1 = overriddenMethodsMap.get(m1);\n+            java.util.List<MethodSymbol> overriddenMethods2 = overriddenMethodsMap.get(m2);\n+\n+            \/\/ Quick check for the case where a method was added by site itself\n+            if (overriddenMethods1 != null && overriddenMethods1.isEmpty())\n+                return true;\n+            if (overriddenMethods2 != null && overriddenMethods2.isEmpty())\n+                return true;\n+\n+            \/\/ Get each method's corresponding method(s) from supertypes of site\n+            java.util.List<MethodSymbol> supertypeMethods1 = overriddenMethods1 != null ?\n+              overriddenMethods1 : Collections.singletonList(m1);\n+            java.util.List<MethodSymbol> supertypeMethods2 = overriddenMethods2 != null ?\n+              overriddenMethods2 : Collections.singletonList(m2);\n+\n+            \/\/ See if we can blame some direct supertype instead\n+            return types.directSupertypes(site).stream()\n+              .filter(stype -> stype != syms.objectType)\n+              .map(stype -> stype.tsym.type)                \/\/ view supertype in its original form\n+              .noneMatch(stype -> {\n+                for (MethodSymbol sm1 : supertypeMethods1) {\n+                    if (!types.isSubtype(types.erasure(stype), types.erasure(sm1.owner.type)))\n+                        continue;\n+                    for (MethodSymbol sm2 : supertypeMethods2) {\n+                        if (!types.isSubtype(types.erasure(stype), types.erasure(sm2.owner.type)))\n+                            continue;\n+                        if (potentiallyAmbiguousOverload(stype, sm1, sm2))\n+                            return true;\n+                    }\n+                }\n+                return false;\n+            });\n+        };\n+    }\n+\n+    \/** Gather all of site's methods, including overridden methods, grouped and sorted by name,\n+     *  after applying the given filter.\n+     *\/\n+    <C extends Collection<MethodSymbol>> List<C> methodsGroupedByName(Type site,\n+            Predicate<Symbol> filter, Supplier<? extends C> groupMaker) {\n+        Iterable<Symbol> symbols = types.membersClosure(site, false).getSymbols(filter, RECURSIVE);\n+        return StreamSupport.stream(symbols.spliterator(), false)\n+          .map(MethodSymbol.class::cast)\n+          .collect(Collectors.groupingBy(m -> m.name, Collectors.toCollection(groupMaker)))\n+          .entrySet()\n+          .stream()\n+          .sorted(Comparator.comparing(e -> e.getKey().toString()))\n+          .map(Map.Entry::getValue)\n+          .collect(List.collector());\n+    }\n+\n+    \/** Compare elements in a list pair-wise in order to remove some of them.\n+     *  @param list mutable list of items\n+     *  @param comparer returns flag bit(s) to remove FIRST and\/or SECOND\n+     *\/\n+    <T> void compareAndRemove(java.util.List<T> list, ToIntBiFunction<? super T, ? super T> comparer) {\n+        for (int index1 = 0; index1 < list.size() - 1; index1++) {\n+            T item1 = list.get(index1);\n+            for (int index2 = index1 + 1; index2 < list.size(); index2++) {\n+                T item2 = list.get(index2);\n+                int flags = comparer.applyAsInt(item1, item2);\n+                if ((flags & SECOND) != 0)\n+                    list.remove(index2--);          \/\/ remove item2\n+                if ((flags & FIRST) != 0) {\n+                    list.remove(index1--);          \/\/ remove item1\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/** Remove elements in a list that are preempted by some other element in the list.\n+     *  @param list mutable list of items\n+     *  @param preempts decides if one item preempts another, causing the second one to be removed\n+     *\/\n+    <T> void removePreempted(java.util.List<T> list, BiPredicate<? super T, ? super T> preempts) {\n+        compareAndRemove(list, (item1, item2) -> {\n+            int flags = 0;\n+            if (preempts.test(item1, item2))\n+                flags |= SECOND;\n+            if (preempts.test(item2, item1))\n+                flags |= FIRST;\n+            return flags;\n+        });\n+    }\n+\n+    \/** Filters method candidates for the \"potentially ambiguous method\" check *\/\n+    class PotentiallyAmbiguousFilter extends ClashFilter {\n+\n+        PotentiallyAmbiguousFilter(Type site) {\n+            super(site);\n+        }\n+\n+        @Override\n+        boolean shouldSkip(Symbol s) {\n+            return s.owner.type.tsym == syms.objectType.tsym || super.shouldSkip(s);\n+        }\n+    }\n+\n@@ -2727,1 +2904,1 @@\n-      * lambda would be ambiguous).\n+      * lambda would be ambiguous). This assumes they already have the same name.\n@@ -2729,32 +2906,30 @@\n-    void checkPotentiallyAmbiguousOverloads(DiagnosticPosition pos, Type site,\n-            MethodSymbol msym1, MethodSymbol msym2) {\n-        if (msym1 != msym2 &&\n-                lint.isEnabled(LintCategory.OVERLOADS) &&\n-                (msym1.flags() & POTENTIALLY_AMBIGUOUS) == 0 &&\n-                (msym2.flags() & POTENTIALLY_AMBIGUOUS) == 0) {\n-            Type mt1 = types.memberType(site, msym1);\n-            Type mt2 = types.memberType(site, msym2);\n-            \/\/if both generic methods, adjust type variables\n-            if (mt1.hasTag(FORALL) && mt2.hasTag(FORALL) &&\n-                    types.hasSameBounds((ForAll)mt1, (ForAll)mt2)) {\n-                mt2 = types.subst(mt2, ((ForAll)mt2).tvars, ((ForAll)mt1).tvars);\n-            }\n-            \/\/expand varargs methods if needed\n-            int maxLength = Math.max(mt1.getParameterTypes().length(), mt2.getParameterTypes().length());\n-            List<Type> args1 = rs.adjustArgs(mt1.getParameterTypes(), msym1, maxLength, true);\n-            List<Type> args2 = rs.adjustArgs(mt2.getParameterTypes(), msym2, maxLength, true);\n-            \/\/if arities don't match, exit\n-            if (args1.length() != args2.length()) return;\n-            boolean potentiallyAmbiguous = false;\n-            while (args1.nonEmpty() && args2.nonEmpty()) {\n-                Type s = args1.head;\n-                Type t = args2.head;\n-                if (!types.isSubtype(t, s) && !types.isSubtype(s, t)) {\n-                    if (types.isFunctionalInterface(s) && types.isFunctionalInterface(t) &&\n-                            types.findDescriptorType(s).getParameterTypes().length() > 0 &&\n-                            types.findDescriptorType(s).getParameterTypes().length() ==\n-                            types.findDescriptorType(t).getParameterTypes().length()) {\n-                        potentiallyAmbiguous = true;\n-                    } else {\n-                        return;\n-                    }\n+    boolean potentiallyAmbiguousOverload(Type site, MethodSymbol msym1, MethodSymbol msym2) {\n+        Assert.check(msym1.name == msym2.name);\n+        if (msym1 == msym2)\n+            return false;\n+        Type mt1 = types.memberType(site, msym1);\n+        Type mt2 = types.memberType(site, msym2);\n+        \/\/if both generic methods, adjust type variables\n+        if (mt1.hasTag(FORALL) && mt2.hasTag(FORALL) &&\n+                types.hasSameBounds((ForAll)mt1, (ForAll)mt2)) {\n+            mt2 = types.subst(mt2, ((ForAll)mt2).tvars, ((ForAll)mt1).tvars);\n+        }\n+        \/\/expand varargs methods if needed\n+        int maxLength = Math.max(mt1.getParameterTypes().length(), mt2.getParameterTypes().length());\n+        List<Type> args1 = rs.adjustArgs(mt1.getParameterTypes(), msym1, maxLength, true);\n+        List<Type> args2 = rs.adjustArgs(mt2.getParameterTypes(), msym2, maxLength, true);\n+        \/\/if arities don't match, exit\n+        if (args1.length() != args2.length())\n+            return false;\n+        boolean potentiallyAmbiguous = false;\n+        while (args1.nonEmpty() && args2.nonEmpty()) {\n+            Type s = args1.head;\n+            Type t = args2.head;\n+            if (!types.isSubtype(t, s) && !types.isSubtype(s, t)) {\n+                if (types.isFunctionalInterface(s) && types.isFunctionalInterface(t) &&\n+                        types.findDescriptorType(s).getParameterTypes().length() > 0 &&\n+                        types.findDescriptorType(s).getParameterTypes().length() ==\n+                        types.findDescriptorType(t).getParameterTypes().length()) {\n+                    potentiallyAmbiguous = true;\n+                } else {\n+                    return false;\n@@ -2762,12 +2937,0 @@\n-                args1 = args1.tail;\n-                args2 = args2.tail;\n-            }\n-            if (potentiallyAmbiguous) {\n-                \/\/we found two incompatible functional interfaces with same arity\n-                \/\/this means a call site passing an implicit lambda would be ambiguous\n-                msym1.flags_field |= POTENTIALLY_AMBIGUOUS;\n-                msym2.flags_field |= POTENTIALLY_AMBIGUOUS;\n-                log.warning(LintCategory.OVERLOADS, pos,\n-                            Warnings.PotentiallyAmbiguousOverload(msym1, msym1.location(),\n-                                                                  msym2, msym2.location()));\n-                return;\n@@ -2775,0 +2938,2 @@\n+            args1 = args1.tail;\n+            args2 = args2.tail;\n@@ -2776,0 +2941,1 @@\n+        return potentiallyAmbiguous;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":233,"deletions":67,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -556,1 +556,1 @@\n-     * Collect elements into a new list (using a @code{ListBuffer})\n+     * Collect elements into a new list (using a {@code ListBuffer})\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/List.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -376,1 +376,1 @@\n-                int privateBits;\n+                int privateBits = 0;\n@@ -381,0 +381,1 @@\n+                        privateBits = getDefDHPrivateExpSize(dhParams);\n@@ -385,1 +386,0 @@\n-                    privateBits = 0;\n@@ -389,4 +389,4 @@\n-                }\n-                if (privateBits <= 0) {\n-                    \/\/ XXX find better defaults\n-                    privateBits = (keySize >= 1024) ? 768 : 512;\n+                    if (privateBits < 0) {\n+                        \/\/ invalid, override with JDK defaults\n+                        privateBits = getDefDHPrivateExpSize(dhParams);\n+                    }\n@@ -398,3 +398,5 @@\n-                privateKeyTemplate = new CK_ATTRIBUTE[]{\n-                        new CK_ATTRIBUTE(CKA_VALUE_BITS, privateBits),\n-                };\n+                privateKeyTemplate = (privateBits != 0 ?\n+                        new CK_ATTRIBUTE[]{\n+                            new CK_ATTRIBUTE(CKA_VALUE_BITS, privateBits),\n+                        } :\n+                        new CK_ATTRIBUTE[]{});\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyPairGenerator.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-    private Map<JavaThread, List<Oop>> locksMap = new HashMap<>();\n+    private final Map<JavaThread, List<Oop>> locksMap = new HashMap<>();\n@@ -45,2 +45,1 @@\n-            for (Iterator<Oop> itr = locks.iterator(); itr.hasNext();) {\n-                Oop oop = itr.next();\n+            for (Oop oop : locks) {\n@@ -74,6 +73,2 @@\n-                            List<Oop> locks = locksMap.get(thread);\n-                            if (locks == null) {\n-                                locks = new LinkedList<>();\n-                                locksMap.put(thread, locks);\n-                            }\n-                            locks.add(oop);\n+                            locksMap.computeIfAbsent(thread, t -> new ArrayList<>())\n+                                    .add(oop);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ConcurrentLocksPrinter.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import java.util.ArrayList;\n@@ -60,1 +61,0 @@\n-import java.util.LinkedList;\n@@ -167,1 +167,1 @@\n-        events = new LinkedList<Event>();\n+        events = new ArrayList<>();\n@@ -434,2 +434,1 @@\n-        final LinkedList<HttpConnection> connsToRegister =\n-                new LinkedList<HttpConnection>();\n+        final ArrayList<HttpConnection> connsToRegister = new ArrayList<>();\n@@ -460,1 +459,1 @@\n-                            events = new LinkedList<Event>();\n+                            events = new ArrayList<>();\n@@ -1020,1 +1019,1 @@\n-            LinkedList<HttpConnection> toClose = new LinkedList<HttpConnection>();\n+            ArrayList<HttpConnection> toClose = new ArrayList<>();\n@@ -1061,1 +1060,1 @@\n-            LinkedList<HttpConnection> toClose = new LinkedList<HttpConnection>();\n+            ArrayList<HttpConnection> toClose = new ArrayList<>();\n@@ -1078,1 +1077,1 @@\n-            toClose = new LinkedList<HttpConnection>();\n+            toClose = new ArrayList<>();\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ServerImpl.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -17,1 +17,1 @@\n- * @see org.jline.keymap.KeyMap\n+ * @see jdk.internal.org.jline.keymap.KeyMap\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Binding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+    private final int sort;\n@@ -34,1 +35,1 @@\n-        this(value, value, null, null, null, null, true);\n+        this(value, value, null, null, null, null, true, 0);\n@@ -47,0 +48,1 @@\n+     * @param sort the sort flag\n@@ -48,1 +50,1 @@\n-    public Candidate(String value, String displ, String group, String descr, String suffix, String key, boolean complete) {\n+    public Candidate(String value, String displ, String group, String descr, String suffix, String key, boolean complete, int sort) {\n@@ -56,0 +58,16 @@\n+        this.sort = sort;\n+    }\n+\n+    \/**\n+     * Constructs a new Candidate.\n+     *\n+     * @param value the value\n+     * @param displ the display string\n+     * @param group the group\n+     * @param descr the description\n+     * @param suffix the suffix\n+     * @param key the key\n+     * @param complete the complete flag\n+     *\/\n+    public Candidate(String value, String displ, String group, String descr, String suffix, String key, boolean complete) {\n+        this(value, displ, group, descr, suffix, key, complete, 0);\n@@ -136,0 +154,9 @@\n+    \/**\n+     * Integer used to override default sort logic.\n+     * @return the sort int\n+     *\/\n+    public int sort() {\n+        return sort;\n+    }\n+\n+\n@@ -138,1 +165,19 @@\n-        return value.compareTo(o.value);\n+        \/\/ If both candidates have same sort, use default behavior\n+        if( sort == o.sort() ) {\n+            return value.compareTo(o.value);\n+        } else {\n+            return Integer.compare(sort, o.sort());\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        Candidate candidate = (Candidate) o;\n+        return Objects.equals(value, candidate.value);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Candidate.java","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n- * of the {@link org.jline.reader.Parser} that produced it, knows if and how a completion candidate\n+ * of the {@link jdk.internal.org.jline.reader.Parser} that produced it, knows if and how a completion candidate\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/CompletingParsedLine.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-     * @return a map of candidates that completion matcher matches\n+     * @return a list of candidates that completion matcher matches\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/CompletionMatcher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author or authors.\n@@ -17,0 +17,6 @@\n+    \/**\n+     * Highlight buffer\n+     * @param reader LineReader\n+     * @param buffer the buffer to be highlighted\n+     * @return highlighted buffer\n+     *\/\n@@ -18,2 +24,17 @@\n-    public void setErrorPattern(Pattern errorPattern);\n-    public void setErrorIndex(int errorIndex);\n+\n+    \/**\n+     * Refresh highlight configuration\n+     *\/\n+    default void refresh(LineReader reader) {}\n+\n+    \/**\n+     * Set error pattern to be highlighted\n+     * @param errorPattern error pattern to be highlighted\n+     *\/\n+    void setErrorPattern(Pattern errorPattern);\n+\n+    \/**\n+     * Set error index to be highlighted\n+     * @param errorIndex error index to be highlighted\n+     *\/\n+    void setErrorIndex(int errorIndex);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Highlighter.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -64,1 +64,2 @@\n-     * Read history from the file. If incremental only the events that are not contained within the internal list are added.\n+     * Read history from the file. If checkDuplicates is <code>true<\/code> only the events that\n+     * are not contained within the internal list are added.\n@@ -66,1 +67,1 @@\n-     * @param  incremental If true incremental read operation is performed.\n+     * @param  checkDuplicates If <code>true<\/code>, duplicate history entries will be discarded\n@@ -69,1 +70,1 @@\n-    void read(Path file, boolean incremental) throws IOException;\n+    void read(Path file, boolean checkDuplicates) throws IOException;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/History.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -355,1 +355,1 @@\n-     * Columns separated list of patterns that will not be saved in history.\n+     * Colon separated list of patterns that will not be saved in history.\n@@ -470,0 +470,3 @@\n+\n+        \/** Disable the undo feature *\/\n+        DISABLE_UNDO\n@@ -702,1 +705,1 @@\n-     * Read a mouse event when the {@link org.jline.utils.InfoCmp.Capability#key_mouse} sequence\n+     * Read a mouse event when the {@link jdk.internal.org.jline.utils.InfoCmp.Capability#key_mouse} sequence\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/LineReader.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -121,0 +121,6 @@\n+\n+        String appName = this.appName;\n+        if (null == appName) {\n+            appName = terminal.getName();\n+        }\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/LineReaderBuilder.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author or authors.\n@@ -15,2 +15,2 @@\n-    static final String REGEX_VARIABLE = \"[a-zA-Z_]{1,}[a-zA-Z0-9_-]*\";\n-    static final String REGEX_COMMAND = \"[:]{0,1}[a-zA-Z]{1,}[a-zA-Z0-9_-]*\";\n+    String REGEX_VARIABLE = \"[a-zA-Z_]+[a-zA-Z0-9_-]*\";\n+    String REGEX_COMMAND = \"[:]?[a-zA-Z]+[a-zA-Z0-9_-]*\";\n@@ -37,1 +37,1 @@\n-        String out = \"\";\n+        String out;\n@@ -71,1 +71,1 @@\n-         * May throw EOFError in which case we have incomplete input.\n+         * We should tolerate and ignore errors.\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Parser.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        return !matching.isEmpty() ? matching.entrySet().stream().flatMap(e -> e.getValue().stream()).collect(Collectors.toList())\n+        return !matching.isEmpty() ? matching.entrySet().stream().flatMap(e -> e.getValue().stream()).distinct().collect(Collectors.toList())\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/CompletionMatcherImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,21 @@\n+    public static class BlockCommentDelims {\n+        private final String start;\n+        private final String end;\n+        public BlockCommentDelims(String start, String end) {\n+            if (start == null || end == null\n+              || start.isEmpty() || end.isEmpty() || start.equals(end)) {\n+                throw new IllegalArgumentException(\"Bad block comment delimiter!\");\n+            }\n+            this.start = start;\n+            this.end = end;\n+        }\n+\n+        public String getStart() {\n+            return start;\n+        }\n+\n+        public String getEnd() {\n+            return end;\n+        }\n+    }\n+\n@@ -42,0 +63,4 @@\n+    private String[] lineCommentDelims = null;\n+\n+    private BlockCommentDelims blockCommentDelims = null;\n+\n@@ -50,0 +75,10 @@\n+    public DefaultParser lineCommentDelims(final String[] lineCommentDelims) {\n+        this.lineCommentDelims = lineCommentDelims;\n+        return this;\n+    }\n+\n+    public DefaultParser blockCommentDelims(final BlockCommentDelims blockCommentDelims) {\n+        this.blockCommentDelims = blockCommentDelims;\n+        return this;\n+    }\n+\n@@ -110,0 +145,16 @@\n+    public void setLineCommentDelims(String[] lineCommentDelims) {\n+        this.lineCommentDelims = lineCommentDelims;\n+    }\n+\n+    public String[] getLineCommentDelims() {\n+        return this.lineCommentDelims;\n+    }\n+\n+    public void setBlockCommentDelims(BlockCommentDelims blockCommentDelims) {\n+        this.blockCommentDelims = blockCommentDelims;\n+    }\n+\n+    public BlockCommentDelims getBlockCommentDelims() {\n+        return blockCommentDelims;\n+    }\n+\n@@ -228,0 +279,5 @@\n+        boolean lineCommented = false;\n+        boolean blockCommented = false;\n+        boolean blockCommentInRightOrder = true;\n+        final String blockCommentEnd = blockCommentDelims == null ? null : blockCommentDelims.end;\n+        final String blockCommentStart = blockCommentDelims == null ? null : blockCommentDelims.start;\n@@ -240,1 +296,1 @@\n-            if (quoteStart < 0 && isQuoteChar(line, i)) {\n+            if (quoteStart < 0 && isQuoteChar(line, i) && !lineCommented && !blockCommented) {\n@@ -261,6 +317,3 @@\n-                \/\/ Delimiter\n-                if (current.length() > 0) {\n-                    words.add(current.toString());\n-                    current.setLength(0); \/\/ reset the arg\n-                    if (rawWordCursor >= 0 && rawWordLength < 0) {\n-                        rawWordLength = i - rawWordStart;\n+                if (lineCommented) {\n+                    if (isCommentDelim(line, i, System.lineSeparator())) {\n+                        lineCommented = false;\n@@ -268,0 +321,8 @@\n+                } else if (blockCommented) {\n+                    if (isCommentDelim(line, i, blockCommentEnd)) {\n+                        blockCommented = false;\n+                    }\n+                } else {\n+                    \/\/ Delimiter\n+                    rawWordLength = handleDelimiterAndGetRawWordLength(current, words, rawWordStart, rawWordCursor, rawWordLength, i);\n+                    rawWordStart = i + 1;\n@@ -269,1 +330,0 @@\n-                rawWordStart = i + 1;\n@@ -271,1 +331,20 @@\n-                if (!isEscapeChar(line, i)) {\n+                if (quoteStart < 0 && !blockCommented && (lineCommented || isLineCommentStarted(line, i))) {\n+                    lineCommented = true;\n+                } else if (quoteStart < 0 && !lineCommented\n+                        && (blockCommented || isCommentDelim(line, i, blockCommentStart))) {\n+                    if (blockCommented) {\n+                        if (blockCommentEnd != null && isCommentDelim(line, i, blockCommentEnd)) {\n+                            blockCommented = false;\n+                            i += blockCommentEnd.length() - 1;\n+                        }\n+                    } else {\n+                        blockCommented = true;\n+                        rawWordLength = handleDelimiterAndGetRawWordLength(current, words, rawWordStart, rawWordCursor, rawWordLength, i);\n+                        i += blockCommentStart == null ? 0 : blockCommentStart.length() - 1;\n+                        rawWordStart = i + 1;\n+                    }\n+                } else if (quoteStart < 0 && !lineCommented\n+                        && isCommentDelim(line, i, blockCommentEnd)) {\n+                    current.append(line.charAt(i));\n+                    blockCommentInRightOrder = false;\n+                } else if (!isEscapeChar(line, i)) {\n@@ -304,0 +383,8 @@\n+            if (blockCommented) {\n+                throw new EOFError(-1, -1, \"Missing closing block comment delimiter\",\n+                        \"add: \" + blockCommentEnd);\n+            }\n+            if (!blockCommentInRightOrder) {\n+                throw new EOFError(-1, -1, \"Missing opening block comment delimiter\",\n+                        \"missing: \" + blockCommentStart);\n+            }\n@@ -336,0 +423,11 @@\n+    private int handleDelimiterAndGetRawWordLength(StringBuilder current, List<String> words, int rawWordStart, int rawWordCursor, int rawWordLength, int pos) {\n+        if (current.length() > 0) {\n+            words.add(current.toString());\n+            current.setLength(0); \/\/ reset the arg\n+            if (rawWordCursor >= 0 && rawWordLength < 0) {\n+                return pos - rawWordStart;\n+            }\n+        }\n+        return rawWordLength;\n+    }\n+\n@@ -354,0 +452,30 @@\n+    private boolean isCommentDelim(final CharSequence buffer, final int pos, final String pattern) {\n+        if (pos < 0) {\n+            return false;\n+        }\n+\n+        if (pattern != null) {\n+            final int length = pattern.length();\n+            if (length <= buffer.length() - pos) {\n+                for (int i = 0; i < length; i++) {\n+                    if (pattern.charAt(i) != buffer.charAt(pos + i)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean isLineCommentStarted(final CharSequence buffer, final int pos) {\n+        if (lineCommentDelims != null) {\n+            for (String comment: lineCommentDelims) {\n+                if (isCommentDelim(buffer, pos, comment)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/DefaultParser.java","additions":137,"deletions":9,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2022, the original author or authors.\n@@ -284,1 +284,1 @@\n-        this(terminal, null, null);\n+        this(terminal, terminal.getName(), null);\n@@ -636,1 +636,2 @@\n-                undo.newState(buf.copy());\n+                if (!isSet(Option.DISABLE_UNDO))\n+                    undo.newState(buf.copy());\n@@ -682,1 +683,1 @@\n-                    if (!isUndo && copy != null && buf.length() <= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)\n+                    if (!isSet(Option.DISABLE_UNDO) && !isUndo && copy != null && buf.length() <= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)\n@@ -742,0 +743,1 @@\n+                startedReading.set(false);\n@@ -743,1 +745,0 @@\n-            startedReading.set(false);\n@@ -1085,1 +1086,1 @@\n-        Constructor<?> ctor = Class.forName(\"org.jline.builtins.Nano\").getConstructor(Terminal.class, File.class);\n+        Constructor<?> ctor = Class.forName(\"jdk.internal.org.jline.builtins.Nano\").getConstructor(Terminal.class, File.class);\n@@ -1090,5 +1091,6 @@\n-        BufferedReader br = new BufferedReader(new FileReader(file));\n-        String line;\n-        commandsBuffer.clear();\n-        while ((line = br.readLine()) != null) {\n-            commandsBuffer.add(line);\n+        try (BufferedReader br = new BufferedReader(new FileReader(file))) {\n+            String line;\n+            commandsBuffer.clear();\n+            while ((line = br.readLine()) != null) {\n+                commandsBuffer.add(line);\n+            }\n@@ -1096,1 +1098,0 @@\n-        br.close();\n@@ -3598,3 +3599,3 @@\n-            FileWriter writer = new FileWriter(file);\n-            writer.write(buf.toString());\n-            writer.close();\n+            try (FileWriter writer = new FileWriter(file)) {\n+                writer.write(buf.toString());\n+            }\n@@ -3799,0 +3800,3 @@\n+                if (terminal.getType().startsWith(AbstractWindowsTerminal.TYPE_WINDOWS)) {\n+                    status.resize();\n+                }\n@@ -3950,1 +3954,2 @@\n-                     || c == '$' || c == '.' || c == '?' || c == '+') {\n+                     || c == '$' || c == '.' || c == '?' || c == '+' || c == '|' || c == '<' || c == '>' || c == '!'\n+                     || c == '-') {\n@@ -4523,1 +4528,1 @@\n-    private CompletingParsedLine wrap(ParsedLine line) {\n+    protected static CompletingParsedLine wrap(ParsedLine line) {\n@@ -4628,0 +4633,5 @@\n+    private int visibleDisplayRows() {\n+        Status status = Status.getStatus(terminal, false);\n+        return terminal.getSize().getRows() - (status != null ? status.size() : 0);\n+    }\n+\n@@ -5073,0 +5083,1 @@\n+        boolean customOrder = possible.stream().anyMatch(c -> c.sort() != 0);\n@@ -5075,1 +5086,1 @@\n-            Map<String, Map<String, Candidate>> sorted;\n+            Map<String, Map<Object, Candidate>> sorted;\n@@ -5082,1 +5093,1 @@\n-                        .put(cand.value(), cand);\n+                        .put((customOrder ? cand.sort() : cand.value()), cand);\n@@ -5084,1 +5095,1 @@\n-            for (Map.Entry<String, Map<String, Candidate>> entry : sorted.entrySet()) {\n+            for (Map.Entry<String, Map<Object, Candidate>> entry : sorted.entrySet()) {\n@@ -5099,1 +5110,1 @@\n-            TreeMap<String, Candidate> sorted = new TreeMap<>();\n+            TreeMap<Object, Candidate> sorted = new TreeMap<>();\n@@ -5105,1 +5116,1 @@\n-                sorted.put(cand.value(), cand);\n+                sorted.put((customOrder ? cand.sort() : cand.value()), cand);\n@@ -5132,1 +5143,1 @@\n-            while (endLine.length() + (first ? startPos : 0) > width) {\n+            while (endLine.length() + (first ? startPos : 0) > width && width > 0) {\n@@ -5210,1 +5221,1 @@\n-                    && listSize < Math.min(getInt(MENU_LIST_MAX, DEFAULT_MENU_LIST_MAX), displayRows() - promptLines())) {\n+                    && listSize < Math.min(getInt(MENU_LIST_MAX, DEFAULT_MENU_LIST_MAX), visibleDisplayRows() - promptLines())) {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/LineReaderImpl.java","additions":35,"deletions":24,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @deprecated use <code>org.jline.builtins.Completers$FileNameCompleter<\/code> instead\n+ * @deprecated use <code>jdk.internal.org.jline.builtins.Completers$FileNameCompleter<\/code> instead\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/FileNameCompleter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-            } else if (aliasCommand.containsKey(cmd)) {\n+            } else {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/SystemCompleter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    public void read(Path file, boolean incremental) throws IOException {\n+    public void read(Path file, boolean checkDuplicates) throws IOException {\n@@ -107,1 +107,1 @@\n-                        reader.lines().forEach(line -> addHistoryLine(path, line, incremental));\n+                        reader.lines().forEach(line -> addHistoryLine(path, line, checkDuplicates));\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/history\/DefaultHistory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2020, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author or authors.\n@@ -19,0 +19,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -20,0 +21,4 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n@@ -24,0 +29,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -27,0 +34,1 @@\n+import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;\n@@ -28,7 +36,1 @@\n-import jdk.internal.org.jline.terminal.impl.ExecPty;\n-import jdk.internal.org.jline.terminal.impl.ExternalTerminal;\n-import jdk.internal.org.jline.terminal.impl.PosixPtyTerminal;\n-import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n-import jdk.internal.org.jline.terminal.spi.JansiSupport;\n-import jdk.internal.org.jline.terminal.spi.JnaSupport;\n-import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -55,0 +57,5 @@\n+    public static final String PROP_OUTPUT = \"org.jline.terminal.output\";\n+    public static final String PROP_OUTPUT_OUT = \"out\";\n+    public static final String PROP_OUTPUT_ERR = \"err\";\n+    public static final String PROP_OUTPUT_OUT_ERR = \"out-err\";\n+    public static final String PROP_OUTPUT_ERR_OUT = \"err-out\";\n@@ -64,0 +71,10 @@\n+    \/\/\n+    \/\/ Terminal output control\n+    \/\/\n+    public enum SystemOutput {\n+        SysOut,\n+        SysErr,\n+        SysOutOrSysErr,\n+        SysErrOrSysOut\n+    }\n+\n@@ -100,0 +117,1 @@\n+    private SystemOutput systemOutput;\n@@ -131,0 +149,14 @@\n+    \/**\n+     * Indicates which standard stream should be used when displaying to the terminal.\n+     * The default is to use the system output stream.\n+     * Building a system terminal will fail if one of the stream specified is not linked\n+     * to the controlling terminal.\n+     *\n+     * @param systemOutput The mode to choose the output stream.\n+     * @return The builder.\n+     *\/\n+    public TerminalBuilder systemOutput(SystemOutput systemOutput) {\n+        this.systemOutput = systemOutput;\n+        return this;\n+    }\n+\n@@ -301,5 +333,12 @@\n-        int codepage = this.codepage;\n-        if (codepage <= 0) {\n-            String str = System.getProperty(PROP_CODEPAGE);\n-            if (str != null) {\n-                codepage = Integer.parseInt(str);\n+        if (encoding == null) {\n+            int codepage = this.codepage;\n+            if (codepage <= 0) {\n+                String str = System.getProperty(PROP_CODEPAGE);\n+                if (str != null) {\n+                    codepage = Integer.parseInt(str);\n+                }\n+            }\n+            if (codepage >= 0) {\n+                encoding = getCodepageCharset(codepage);\n+            } else {\n+                encoding = StandardCharsets.UTF_8;\n@@ -331,0 +370,32 @@\n+        IllegalStateException exception = new IllegalStateException(\"Unable to create a terminal\");\n+        List<TerminalProvider> providers = new ArrayList<>();\n+        if (jna) {\n+            try {\n+                TerminalProvider provider = TerminalProvider.load(\"jna\");\n+                providers.add(provider);\n+            }  catch (Throwable t) {\n+                Log.debug(\"Unable to load JNA support: \", t);\n+                exception.addSuppressed(t);\n+            }\n+        }\n+        if (jansi) {\n+            try {\n+                TerminalProvider provider = TerminalProvider.load(\"jansi\");\n+                providers.add(provider);\n+            }  catch (Throwable t) {\n+                Log.debug(\"Unable to load JANSI support: \", t);\n+                exception.addSuppressed(t);\n+            }\n+        }\n+        if (exec)\n+        {\n+            try {\n+                TerminalProvider provider = TerminalProvider.load(\"exec\");\n+                providers.add(provider);\n+            }  catch (Throwable t) {\n+                Log.debug(\"Unable to load EXEC support: \", t);\n+                exception.addSuppressed(t);\n+            }\n+        }\n+\n+        Terminal terminal = null;\n@@ -332,1 +403,2 @@\n-            if (system != null && ((in != null && !in.equals(System.in)) ||  (out != null && !out.equals(System.out)))) {\n+            if (system != null && ((in != null && !in.equals(System.in)) ||\n+                    (out != null && !out.equals(System.out) && !out.equals(System.err)))) {\n@@ -335,4 +407,33 @@\n-            Terminal terminal = null;\n-            IllegalStateException exception = new IllegalStateException(\"Unable to create a system terminal\");\n-            TerminalBuilderSupport tbs = new TerminalBuilderSupport(jna, jansi);\n-            if (tbs.isConsoleInput() && tbs.isConsoleOutput()) {\n+            if (attributes != null || size != null) {\n+                Log.warn(\"Attributes and size fields are ignored when creating a system terminal\");\n+            }\n+            if (out != null) {\n+                if (out.equals(System.out)) {\n+                    systemOutput = SystemOutput.SysOut;\n+                } else if (out.equals(System.err)) {\n+                    systemOutput = SystemOutput.SysErr;\n+                }\n+            }\n+            if (systemOutput == null) {\n+                String str = System.getProperty(PROP_OUTPUT);\n+                if (str != null) {\n+                    switch (str.trim().toLowerCase(Locale.ROOT)) {\n+                        case PROP_OUTPUT_OUT: systemOutput = SystemOutput.SysOut; break;\n+                        case PROP_OUTPUT_ERR: systemOutput = SystemOutput.SysErr; break;\n+                        case PROP_OUTPUT_OUT_ERR: systemOutput = SystemOutput.SysOutOrSysErr; break;\n+                        case PROP_OUTPUT_ERR_OUT: systemOutput = SystemOutput.SysErrOrSysOut; break;\n+                        default:\n+                            Log.debug(\"Unsupported value for \" + PROP_OUTPUT + \": \" + str + \". Supported values are: \"\n+                                    + String.join(\", \", PROP_OUTPUT_OUT, PROP_OUTPUT_ERR, PROP_OUTPUT_OUT_ERR,PROP_OUTPUT_ERR_OUT)\n+                                    + \".\");\n+                    }\n+                }\n+            }\n+            if (systemOutput == null) {\n+                systemOutput = SystemOutput.SysOutOrSysErr;\n+            }\n+            Map<TerminalProvider.Stream, Boolean> system = Stream.of(TerminalProvider.Stream.values())\n+                    .collect(Collectors.toMap(stream -> stream, stream -> providers.stream().anyMatch(p -> p.isSystemStream(stream))));\n+            TerminalProvider.Stream console = select(system, systemOutput);\n+\n+            if (system.get(TerminalProvider.Stream.Input) && console != null) {\n@@ -342,64 +443,9 @@\n-                if (OSUtils.IS_WINDOWS) {\n-                    if (!OSUtils.IS_CYGWIN && !OSUtils.IS_MSYSTEM) {\n-                        boolean ansiPassThrough = OSUtils.IS_CONEMU;\n-                        if (tbs.hasJnaSupport()) {\n-                            try {\n-                                terminal = tbs.getJnaSupport().winSysTerminal(name, type, ansiPassThrough, encoding, codepage\n-                                        , nativeSignals, signalHandler, paused, inputStreamWrapper);\n-                            } catch (Throwable t) {\n-                                Log.debug(\"Error creating JNA based terminal: \", t.getMessage(), t);\n-                                exception.addSuppressed(t);\n-                            }\n-                        }\n-                        if (terminal == null && tbs.hasJansiSupport()) {\n-                            try {\n-                                terminal = tbs.getJansiSupport().winSysTerminal(name, type, ansiPassThrough, encoding, codepage\n-                                        , nativeSignals, signalHandler, paused);\n-                            } catch (Throwable t) {\n-                                Log.debug(\"Error creating JANSI based terminal: \", t.getMessage(), t);\n-                                exception.addSuppressed(t);\n-                            }\n-                        }\n-                    } else if (exec) {\n-                        \/\/\n-                        \/\/ Cygwin support\n-                        \/\/\n-                        try {\n-                            \/\/ Cygwin defaults to XTERM, but actually supports 256 colors,\n-                            \/\/ so if the value comes from the environment, change it to xterm-256color\n-                            if (\"xterm\".equals(type) && this.type == null && System.getProperty(PROP_TYPE) == null) {\n-                                type = \"xterm-256color\";\n-                            }\n-                            Pty pty = tbs.getExecPty();\n-                            terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n-                        } catch (IOException e) {\n-                            \/\/ Ignore if not a tty\n-                            Log.debug(\"Error creating EXEC based terminal: \", e.getMessage(), e);\n-                            exception.addSuppressed(e);\n-                        }\n-                    }\n-                    if (terminal == null && !jna && !jansi && (dumb == null || !dumb)) {\n-                        throw new IllegalStateException(\"Unable to create a system terminal. On windows, either \"\n-                                + \"JNA or JANSI library is required.  Make sure to add one of those in the classpath.\");\n-                    }\n-                } else {\n-                    if (tbs.hasJnaSupport()) {\n-                        try {\n-                            Pty pty = tbs.getJnaSupport().current();\n-                            terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n-                        } catch (Throwable t) {\n-                            \/\/ ignore\n-                            Log.debug(\"Error creating JNA based terminal: \", t.getMessage(), t);\n-                            exception.addSuppressed(t);\n-                        }\n-                    }\n-                    if (terminal == null && tbs.hasJansiSupport()) {\n-                        try {\n-                            Pty pty = tbs.getJansiSupport().current();\n-                            terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n-                        } catch (Throwable t) {\n-                            Log.debug(\"Error creating JANSI based terminal: \", t.getMessage(), t);\n-                            exception.addSuppressed(t);\n-                        }\n-                    }\n-                    if (terminal == null && exec) {\n+                boolean ansiPassThrough = OSUtils.IS_CONEMU;\n+                \/\/ Cygwin defaults to XTERM, but actually supports 256 colors,\n+                \/\/ so if the value comes from the environment, change it to xterm-256color\n+                if ((OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM)  && \"xterm\".equals(type)\n+                        && this.type == null && System.getProperty(PROP_TYPE) == null) {\n+                    type = \"xterm-256color\";\n+                }\n+                for ( TerminalProvider provider : providers) {\n+                    if (terminal == null) {\n@@ -407,2 +453,2 @@\n-                            Pty pty = tbs.getExecPty();\n-                            terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n+                            terminal = provider.sysTerminal(name, type, ansiPassThrough, encoding,\n+                                    nativeSignals, signalHandler, paused, console, inputStreamWrapper);\n@@ -410,2 +456,1 @@\n-                            \/\/ Ignore if not a tty\n-                            Log.debug(\"Error creating EXEC based terminal: \", t.getMessage(), t);\n+                            Log.debug(\"Error creating \" + provider.name() + \" based terminal: \", t.getMessage(), t);\n@@ -416,11 +461,15 @@\n-                if (terminal instanceof AbstractTerminal) {\n-                    AbstractTerminal t = (AbstractTerminal) terminal;\n-                    if (SYSTEM_TERMINAL.compareAndSet(null, t)) {\n-                        t.setOnClose(() -> SYSTEM_TERMINAL.compareAndSet(t, null));\n-                    } else {\n-                        exception.addSuppressed(new IllegalStateException(\"A system terminal is already running. \" +\n-                                \"Make sure to use the created system Terminal on the LineReaderBuilder if you're using one \" +\n-                                \"or that previously created system Terminals have been correctly closed.\"));\n-                        terminal.close();\n-                        terminal = null;\n-                    }\n+                if (terminal == null && OSUtils.IS_WINDOWS &&  !jna && !jansi && (dumb == null || !dumb)) {\n+                    throw new IllegalStateException(\"Unable to create a system terminal. On windows, either \"\n+                            + \"JNA or JANSI library is required.  Make sure to add one of those in the classpath.\");\n+                }\n+            }\n+            if (terminal instanceof AbstractTerminal) {\n+                AbstractTerminal t = (AbstractTerminal) terminal;\n+                if (SYSTEM_TERMINAL.compareAndSet(null, t)) {\n+                    t.setOnClose(() -> SYSTEM_TERMINAL.compareAndSet(t, null));\n+                } else {\n+                    exception.addSuppressed(new IllegalStateException(\"A system terminal is already running. \" +\n+                            \"Make sure to use the created system Terminal on the LineReaderBuilder if you're using one \" +\n+                            \"or that previously created system Terminals have been correctly closed.\"));\n+                    terminal.close();\n+                    terminal = null;\n@@ -436,1 +485,2 @@\n-                        color = System.getenv(\"INSIDE_EMACS\") != null;\n+                        String emacs = System.getenv(\"INSIDE_EMACS\");\n+                        color = emacs != null && emacs.contains(\"comint\");\n@@ -444,1 +494,1 @@\n-                        color = tbs.isConsoleOutput() && System.getenv(\"TERM\") != null;\n+                        color = system.get(TerminalProvider.Stream.Output) && System.getenv(\"TERM\") != null;\n@@ -448,2 +498,3 @@\n-                            Log.warn(\"input is tty: {}\", tbs.isConsoleInput());\n-                            Log.warn(\"output is tty: {}\", tbs.isConsoleOutput());\n+                            Log.warn(\"input is tty: {}\", system.get(TerminalProvider.Stream.Input));\n+                            Log.warn(\"output is tty: {}\", system.get(TerminalProvider.Stream.Output));\n+                            Log.warn(\"error is tty: {}\", system.get(TerminalProvider.Stream.Error));\n@@ -457,2 +508,2 @@\n-                        inputStreamWrapper.apply(new FileInputStream(FileDescriptor.in)),\n-                        new FileOutputStream(FileDescriptor.out),\n+                        new FileInputStream(FileDescriptor.in),\n+                        new FileOutputStream(console == TerminalProvider.Stream.Output ? FileDescriptor.out : FileDescriptor.err),\n@@ -461,4 +512,0 @@\n-            if (terminal == null) {\n-                throw exception;\n-            }\n-            return terminal;\n@@ -466,6 +513,8 @@\n-            if (jna) {\n-                try {\n-                    Pty pty = load(JnaSupport.class).open(attributes, size);\n-                    return new PosixPtyTerminal(name, type, pty, inputStreamWrapper.apply(in), out, encoding, signalHandler, paused);\n-                } catch (Throwable t) {\n-                    Log.debug(\"Error creating JNA based terminal: \", t.getMessage(), t);\n+            for ( TerminalProvider provider : providers) {\n+                if (terminal == null) {\n+                    try {\n+                        terminal = provider.newTerminal(name, type, inputStreamWrapper.apply(in), out, encoding, signalHandler, paused, attributes, size);\n+                    } catch (Throwable t) {\n+                        Log.debug(\"Error creating \" + provider.name() + \" based terminal: \", t.getMessage(), t);\n+                        exception.addSuppressed(t);\n+                    }\n@@ -474,7 +523,25 @@\n-            if (jansi) {\n-                try {\n-                    Pty pty = load(JansiSupport.class).open(attributes, size);\n-                    return new PosixPtyTerminal(name, type, pty, inputStreamWrapper.apply(in), out, encoding, signalHandler, paused);\n-                } catch (Throwable t) {\n-                    Log.debug(\"Error creating JANSI based terminal: \", t.getMessage(), t);\n-                }\n+        }\n+        if (terminal == null) {\n+            throw exception;\n+        }\n+        return terminal;\n+    }\n+\n+    private TerminalProvider.Stream select(Map<TerminalProvider.Stream, Boolean> system, SystemOutput systemOutput) {\n+        switch (systemOutput) {\n+            case SysOut:\n+                return select(system, TerminalProvider.Stream.Output);\n+            case SysErr:\n+                return select(system, TerminalProvider.Stream.Error);\n+            case SysOutOrSysErr:\n+                return select(system, TerminalProvider.Stream.Output, TerminalProvider.Stream.Error);\n+            case SysErrOrSysOut:\n+                return select(system, TerminalProvider.Stream.Error, TerminalProvider.Stream.Output);\n+        }\n+        return null;\n+    }\n+\n+    private static TerminalProvider.Stream select(Map<TerminalProvider.Stream, Boolean> system, TerminalProvider.Stream... streams) {\n+        for (TerminalProvider.Stream s : streams) {\n+            if (system.get(s)) {\n+                return s;\n@@ -482,1 +549,0 @@\n-            return new ExternalTerminal(name, type, inputStreamWrapper.apply(in), out, encoding, signalHandler, paused, attributes, size);\n@@ -484,0 +550,1 @@\n+        return null;\n@@ -515,0 +582,18 @@\n+    private static final int UTF8_CODE_PAGE = 65001;\n+\n+    private static Charset getCodepageCharset(int codepage) {\n+        \/\/http:\/\/docs.oracle.com\/javase\/6\/docs\/technotes\/guides\/intl\/encoding.doc.html\n+        if (codepage == UTF8_CODE_PAGE) {\n+            return StandardCharsets.UTF_8;\n+        }\n+        String charsetMS = \"ms\" + codepage;\n+        if (Charset.isSupported(charsetMS)) {\n+            return Charset.forName(charsetMS);\n+        }\n+        String charsetCP = \"cp\" + codepage;\n+        if (Charset.isSupported(charsetCP)) {\n+            return Charset.forName(charsetCP);\n+        }\n+        return Charset.defaultCharset();\n+    }\n+\n@@ -524,1 +609,1 @@\n-     * is necessary to override the {@link Terminal} used by the REPL to\n+     * is necessary to override the {@link Terminal} used by the the REPL to\n@@ -548,75 +633,0 @@\n-    private static class TerminalBuilderSupport {\n-        private JansiSupport jansiSupport = null;\n-        private JnaSupport jnaSupport = null;\n-        private Pty pty = null;\n-        private boolean consoleOutput;\n-\n-        TerminalBuilderSupport(boolean jna, boolean jansi) {\n-            if (jna) {\n-                try {\n-                    jnaSupport = load(JnaSupport.class);\n-                    consoleOutput = jnaSupport.isConsoleOutput();\n-                } catch (Throwable e) {\n-                    jnaSupport = null;\n-                    Log.debug(\"jnaSupport.isConsoleOutput(): \", e);\n-                }\n-            }\n-            if (jansi) {\n-                try {\n-                    jansiSupport = load(JansiSupport.class);\n-                    consoleOutput = jansiSupport.isConsoleOutput();\n-                } catch (Throwable e) {\n-                    jansiSupport = null;\n-                    Log.debug(\"jansiSupport.isConsoleOutput(): \", e);\n-                }\n-            }\n-            if (jnaSupport == null && jansiSupport == null) {\n-                try {\n-                    pty = ExecPty.current();\n-                    consoleOutput = true;\n-                } catch (Exception e) {\n-                    Log.debug(\"ExecPty.current(): \", e);\n-                }\n-            }\n-        }\n-\n-        public boolean isConsoleOutput() {\n-            return consoleOutput;\n-        }\n-\n-        public boolean isConsoleInput() {\n-            if (pty != null) {\n-                return true;\n-            } else if (hasJnaSupport()) {\n-                return jnaSupport.isConsoleInput();\n-            } else if (hasJansiSupport()) {\n-                return jansiSupport.isConsoleInput();\n-            } else {\n-                return false;\n-            }\n-        }\n-\n-        public boolean hasJnaSupport() {\n-            return jnaSupport != null;\n-        }\n-\n-        public boolean hasJansiSupport() {\n-            return jansiSupport != null;\n-        }\n-\n-        public JnaSupport getJnaSupport() {\n-            return jnaSupport;\n-        }\n-\n-        public JansiSupport getJansiSupport() {\n-            return jansiSupport;\n-        }\n-\n-        public Pty getExecPty() throws IOException {\n-            if (pty == null) {\n-                pty = ExecPty.current();\n-            }\n-            return pty;\n-        }\n-\n-    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/TerminalBuilder.java","additions":207,"deletions":197,"binary":false,"changes":404,"status":"modified"},{"patch":"@@ -89,5 +89,0 @@\n-        @Override\n-        public int readBuffered(byte[] b) throws IOException {\n-            return in.read(b);\n-        }\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractPty.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,2 +84,2 @@\n-    public AbstractWindowsTerminal(Writer writer, String name, String type, Charset encoding, int codepage, boolean nativeSignals, SignalHandler signalHandler, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        super(name, type, selectCharset(encoding, codepage), signalHandler);\n+    public AbstractWindowsTerminal(Writer writer, String name, String type, Charset encoding, boolean nativeSignals, SignalHandler signalHandler, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        super(name, type, encoding, signalHandler);\n@@ -119,29 +119,0 @@\n-    private static Charset selectCharset(Charset encoding, int codepage) {\n-        if (encoding != null) {\n-            return encoding;\n-        }\n-\n-        if (codepage >= 0) {\n-            return getCodepageCharset(codepage);\n-        }\n-\n-        \/\/ Use UTF-8 as default\n-        return StandardCharsets.UTF_8;\n-    }\n-\n-    private static Charset getCodepageCharset(int codepage) {\n-        \/\/http:\/\/docs.oracle.com\/javase\/6\/docs\/technotes\/guides\/intl\/encoding.doc.html\n-        if (codepage == UTF8_CODE_PAGE) {\n-            return StandardCharsets.UTF_8;\n-        }\n-        String charsetMS = \"ms\" + codepage;\n-        if (Charset.isSupported(charsetMS)) {\n-            return Charset.forName(charsetMS);\n-        }\n-        String charsetCP = \"cp\" + codepage;\n-        if (Charset.isSupported(charsetCP)) {\n-            return Charset.forName(charsetCP);\n-        }\n-        return Charset.defaultCharset();\n-    }\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractWindowsTerminal.java","additions":2,"deletions":31,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl;\n+\n+import java.io.PrintStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ServiceLoader;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ForkJoinTask;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+public class Diag {\n+\n+    public static void main(String[] args) {\n+        diag(System.out);\n+    }\n+\n+    static void diag(PrintStream out) {\n+        out.println(\"System properties\");\n+        out.println(\"=================\");\n+        out.println(\"os.name =         \" + System.getProperty(\"os.name\"));\n+        out.println(\"OSTYPE =          \" + System.getenv(\"OSTYPE\"));\n+        out.println(\"MSYSTEM =         \" + System.getenv(\"MSYSTEM\"));\n+        out.println(\"PWD =             \" + System.getenv(\"PWD\"));\n+        out.println(\"ConEmuPID =       \" + System.getenv(\"ConEmuPID\"));\n+        out.println(\"WSL_DISTRO_NAME = \" + System.getenv(\"WSL_DISTRO_NAME\"));\n+        out.println(\"WSL_INTEROP =     \" + System.getenv(\"WSL_INTEROP\"));\n+        out.println();\n+\n+        out.println(\"OSUtils\");\n+        out.println(\"=================\");\n+        out.println(\"IS_WINDOWS = \" + OSUtils.IS_WINDOWS);\n+        out.println(\"IS_CYGWIN =  \" + OSUtils.IS_CYGWIN);\n+        out.println(\"IS_MSYSTEM = \" + OSUtils.IS_MSYSTEM);\n+        out.println(\"IS_WSL =     \" + OSUtils.IS_WSL);\n+        out.println(\"IS_WSL1 =    \" + OSUtils.IS_WSL1);\n+        out.println(\"IS_WSL2 =    \" + OSUtils.IS_WSL2);\n+        out.println(\"IS_CONEMU =  \" + OSUtils.IS_CONEMU);\n+        out.println(\"IS_OSX =     \" + OSUtils.IS_OSX);\n+        out.println();\n+\n+        out.println(\"JnaSupport\");\n+        out.println(\"=================\");\n+        try {\n+            TerminalProvider provider = TerminalProvider.load(\"jna\");\n+            testProvider(out, provider);\n+        } catch (Throwable t) {\n+            out.println(\"JNA support not available: \" + t);\n+        }\n+        out.println();\n+\n+        out.println(\"JansiSupport\");\n+        out.println(\"=================\");\n+        try {\n+            TerminalProvider provider = TerminalProvider.load(\"jansi\");\n+            testProvider(out, provider);\n+        } catch (Throwable t) {\n+            out.println(\"Jansi support not available: \" + t);\n+        }\n+        out.println();\n+\n+        \/\/ Exec\n+        out.println(\"Exec Support\");\n+        out.println(\"=================\");\n+        try {\n+            TerminalProvider provider = TerminalProvider.load(\"exec\");\n+            testProvider(out, provider);\n+        } catch (Throwable t) {\n+            out.println(\"Exec support not available: \" + t);\n+        }\n+    }\n+\n+    private static void testProvider(PrintStream out, TerminalProvider provider) {\n+        try {\n+            out.println(\"StdIn stream =    \" + provider.isSystemStream(TerminalProvider.Stream.Input));\n+            out.println(\"StdOut stream =   \" + provider.isSystemStream(TerminalProvider.Stream.Output));\n+            out.println(\"StdErr stream =   \" + provider.isSystemStream(TerminalProvider.Stream.Error));\n+        } catch (Throwable t2) {\n+            out.println(\"Unable to check stream: \" + t2);\n+        }\n+        try {\n+            out.println(\"StdIn stream name =     \" + provider.systemStreamName(TerminalProvider.Stream.Input));\n+            out.println(\"StdOut stream name =    \" + provider.systemStreamName(TerminalProvider.Stream.Output));\n+            out.println(\"StdErr stream name =    \" + provider.systemStreamName(TerminalProvider.Stream.Error));\n+        } catch (Throwable t2) {\n+            out.println(\"Unable to check stream names: \" + t2);\n+        }\n+        try (Terminal terminal = provider.sysTerminal(\"diag\", \"xterm\", false, StandardCharsets.UTF_8,\n+                false, Terminal.SignalHandler.SIG_DFL, false, TerminalProvider.Stream.Output, input -> input) ) {\n+            if (terminal != null) {\n+                Attributes attr = terminal.enterRawMode();\n+                try {\n+                    out.println(\"Terminal size: \" + terminal.getSize());\n+                    ForkJoinTask<Integer> t = new ForkJoinPool(1).submit(() -> terminal.reader().read(1) );\n+                    int r = t.get(1000, TimeUnit.MILLISECONDS);\n+                    StringBuilder sb = new StringBuilder();\n+                    sb.append(\"The terminal seems to work: \");\n+                    sb.append(\"terminal \").append(terminal.getClass().getName());\n+                    if (terminal instanceof AbstractPosixTerminal) {\n+                        sb.append(\" with pty \").append(((AbstractPosixTerminal) terminal).getPty().getClass().getName());\n+                    }\n+                    out.println(sb);\n+                } catch (Throwable t3) {\n+                    out.println(\"Unable to read from terminal: \" + t3);\n+                    t3.printStackTrace();\n+                } finally {\n+                    terminal.setAttributes(attr);\n+                }\n+            } else {\n+                out.println(\"Not supported by provider\");\n+            }\n+        } catch (Throwable t2) {\n+            out.println(\"Unable to open terminal: \" + t2);\n+            t2.printStackTrace();\n+        }\n+    }\n+\n+    static <S> S load(Class<S> clazz) {\n+        return ServiceLoader.load(clazz, clazz.getClassLoader()).iterator().next();\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/Diag.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -37,1 +38,1 @@\n-    private final boolean system;\n+    private final TerminalProvider.Stream console;\n@@ -39,1 +40,1 @@\n-    public static Pty current() throws IOException {\n+    public static Pty current(TerminalProvider.Stream console) throws IOException {\n@@ -42,1 +43,4 @@\n-            return new ExecPty(result.trim(), true);\n+            if (console != TerminalProvider.Stream.Output && console != TerminalProvider.Stream.Error) {\n+                throw new IllegalArgumentException(\"console should be Output or Error: \" + console);\n+            }\n+            return new ExecPty(result.trim(), console);\n@@ -48,1 +52,1 @@\n-    protected ExecPty(String name, boolean system) {\n+    protected ExecPty(String name, TerminalProvider.Stream console) {\n@@ -50,1 +54,1 @@\n-        this.system = system;\n+        this.console = console;\n@@ -73,1 +77,1 @@\n-        return system\n+        return console != null\n@@ -80,1 +84,1 @@\n-        return system\n+        return console == TerminalProvider.Stream.Output\n@@ -82,1 +86,3 @@\n-                : new FileOutputStream(getName());\n+                : console == TerminalProvider.Stream.Error\n+                    ? new FileOutputStream(FileDescriptor.err)\n+                    : new FileOutputStream(getName());\n@@ -96,1 +102,1 @@\n-            if (!system) {\n+            if (console == null) {\n@@ -100,13 +106,1 @@\n-            try {\n-                exec(system, commands.toArray(new String[commands.size()]));\n-            } catch (IOException e) {\n-                \/\/ Handle partial failures with GNU stty, see #97\n-                if (e.toString().contains(\"unable to perform all requested operations\")) {\n-                    commands = getFlagsToSet(attr, getAttr());\n-                    if (!commands.isEmpty()) {\n-                        throw new IOException(\"Could not set the following flags: \" + String.join(\", \", commands), e);\n-                    }\n-                } else {\n-                    throw e;\n-                }\n-            }\n+            exec(console != null, commands.toArray(new String[0]));\n@@ -174,1 +168,1 @@\n-        return system\n+        return console != null\n@@ -283,1 +277,1 @@\n-        if (system) {\n+        if (console != null) {\n@@ -299,1 +293,1 @@\n-        return \"ExecPty[\" + getName() + (system ? \", system]\" : \"]\");\n+        return \"ExecPty[\" + getName() + (console != null ? \", system]\" : \"]\");\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ExecPty.java","additions":19,"deletions":25,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -18,1 +18,0 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -146,1 +145,1 @@\n-    private class InputStreamWrapper extends NonBlockingInputStream {\n+    private static class InputStreamWrapper extends NonBlockingInputStream {\n@@ -149,1 +148,1 @@\n-        private final AtomicBoolean closed = new AtomicBoolean();\n+        private volatile boolean closed;\n@@ -157,1 +156,1 @@\n-            if (closed.get()) {\n+            if (closed) {\n@@ -165,1 +164,1 @@\n-            closed.set(true);\n+            closed = true;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/PosixPtyTerminal.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -19,0 +19,1 @@\n+import java.util.function.Function;\n@@ -37,2 +38,3 @@\n-    public PosixSysTerminal(String name, String type, Pty pty, InputStream in, OutputStream out, Charset encoding,\n-                            boolean nativeSignals, SignalHandler signalHandler) throws IOException {\n+    public PosixSysTerminal(String name, String type, Pty pty, Charset encoding,\n+                            boolean nativeSignals, SignalHandler signalHandler,\n+                            Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n@@ -40,2 +42,2 @@\n-        this.input = NonBlocking.nonBlocking(getName(), in);\n-        this.output = out;\n+        this.input = NonBlocking.nonBlocking(getName(), inputStreamWrapper.apply(pty.getSlaveInput()));\n+        this.output = pty.getSlaveOutput();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/PosixSysTerminal.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.exec;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.nio.charset.Charset;\n+import java.util.function.Function;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.impl.ExecPty;\n+import jdk.internal.org.jline.terminal.impl.ExternalTerminal;\n+import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.ExecHelper;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+public class ExecTerminalProvider implements TerminalProvider\n+{\n+\n+    public String name() {\n+        return \"exec\";\n+    }\n+\n+    public Pty current(Stream consoleStream) throws IOException {\n+        return ExecPty.current(consoleStream);\n+    }\n+\n+    @Override\n+    public Terminal sysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        if (OSUtils.IS_WINDOWS) {\n+            return winSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n+        } else {\n+            return posixSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n+        }\n+    }\n+\n+    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                    boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                    Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper ) throws IOException {\n+        if (OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM) {\n+            Pty pty = current(consoleStream);\n+            return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Terminal posixSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                     boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                     Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        Pty pty = current(consoleStream);\n+        return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n+    }\n+\n+    @Override\n+    public Terminal newTerminal(String name, String type, InputStream in, OutputStream out,\n+                                Charset encoding, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Attributes attributes, Size size) throws IOException\n+    {\n+        return new ExternalTerminal(name, type, in, out, encoding, signalHandler, paused, attributes, size);\n+    }\n+\n+    @Override\n+    public boolean isSystemStream(Stream stream) {\n+        try {\n+            return isWindowsSystemStream(stream) || isPosixSystemStream(stream);\n+        } catch (Throwable t) {\n+            return false;\n+        }\n+    }\n+\n+    public boolean isWindowsSystemStream(Stream stream) {\n+        return systemStreamName( stream ) != null;\n+    }\n+\n+    public boolean isPosixSystemStream(Stream stream) {\n+        try {\n+            Process p = new ProcessBuilder(OSUtils.TEST_COMMAND, \"-t\", Integer.toString(stream.ordinal()))\n+                    .inheritIO().start();\n+            return p.waitFor() == 0;\n+        } catch (Throwable t) {\n+            \/\/ ignore\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public String systemStreamName(Stream stream) {\n+        try {\n+            ProcessBuilder.Redirect input = stream == Stream.Input\n+                                ? ProcessBuilder.Redirect.INHERIT\n+                                : getRedirect(stream == Stream.Output ? FileDescriptor.out : FileDescriptor.err);\n+            Process p = new ProcessBuilder(OSUtils.TTY_COMMAND).redirectInput(input).start();\n+            String result = ExecHelper.waitAndCapture(p);\n+            if (p.exitValue() == 0) {\n+                return result.trim();\n+            }\n+        } catch (Throwable t) {\n+            \/\/ ignore\n+        }\n+        return null;\n+    }\n+\n+    private ProcessBuilder.Redirect getRedirect(FileDescriptor fd) throws ReflectiveOperationException {\n+        \/\/ This is not really allowed, but this is the only way to redirect the output or error stream\n+        \/\/ to the input.  This is definitely not something you'd usually want to do, but in the case of\n+        \/\/ the `tty` utility, it provides a way to get\n+        Class<?> rpi = Class.forName(\"java.lang.ProcessBuilder$RedirectPipeImpl\");\n+        Constructor<?> cns = rpi.getDeclaredConstructor();\n+        cns.setAccessible(true);\n+        ProcessBuilder.Redirect input = (ProcessBuilder.Redirect) cns.newInstance();\n+        Field f = rpi.getDeclaredField(\"fd\");\n+        f.setAccessible(true);\n+        f.set(input, fd);\n+        return input;\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/exec\/ExecTerminalProvider.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.spi;\n-\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.Terminal;\n-\n-import java.io.IOException;\n-import java.nio.charset.Charset;\n-\n-public interface JansiSupport {\n-\n-    Pty current() throws IOException;\n-\n-    Pty open(Attributes attributes, Size size) throws IOException;\n-\n-    Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler) throws IOException;\n-\n-    Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused) throws IOException;\n-\n-    boolean isWindowsConsole();\n-\n-    boolean isConsoleOutput();\n-\n-    boolean isConsoleInput();\n-}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/JansiSupport.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.spi;\n-\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.Terminal;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.charset.Charset;\n-import java.util.function.Function;\n-\n-public interface JnaSupport {\n-\n-    Pty current() throws IOException;\n-\n-    Pty open(Attributes attributes, Size size) throws IOException;\n-\n-    Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler) throws IOException;\n-\n-    Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused) throws IOException;\n-\n-    Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused, Function<InputStream, InputStream> inputStreamWrapper) throws IOException;\n-\n-    boolean isWindowsConsole();\n-\n-    boolean isConsoleOutput();\n-\n-    boolean isConsoleInput();\n-}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/JnaSupport.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2022, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.spi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.Properties;\n+import java.util.ServiceLoader;\n+import java.util.function.Function;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.impl.exec.ExecTerminalProvider;\n+\n+public interface TerminalProvider\n+{\n+\n+    enum Stream {\n+        Input,\n+        Output,\n+        Error\n+    }\n+\n+    String name();\n+\n+    Terminal sysTerminal(String name, String type, boolean ansiPassThrough,\n+                         Charset encoding, boolean nativeSignals,\n+                         Terminal.SignalHandler signalHandler, boolean paused,\n+                         Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException;\n+\n+    Terminal newTerminal(String name, String type,\n+                         InputStream masterInput, OutputStream masterOutput,\n+                         Charset encoding, Terminal.SignalHandler signalHandler,\n+                         boolean paused, Attributes attributes, Size size) throws IOException;\n+\n+    boolean isSystemStream(Stream stream);\n+\n+    String systemStreamName(Stream stream);\n+\n+    static TerminalProvider load(String name) throws IOException {\n+        switch (name) {\n+            case \"exec\": return new ExecTerminalProvider();\n+            case \"jna\": {\n+                try {\n+                    return (TerminalProvider) Class.forName(\"jdk.internal.org.jline.terminal.impl.jna.JnaTerminalProvider\").getConstructor().newInstance();\n+                } catch (ReflectiveOperationException t) {\n+                    throw new IOException(t);\n+                }\n+            }\n+        }\n+        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n+        if (cl == null) {\n+            cl = ClassLoader.getSystemClassLoader();\n+        }\n+        InputStream is = cl.getResourceAsStream( \"META-INF\/services\/org\/jline\/terminal\/provider\/\" + name);\n+        if (is != null) {\n+            Properties props = new Properties();\n+            try {\n+                props.load(is);\n+                String className = props.getProperty(\"class\");\n+                if (className == null) {\n+                    throw new IOException(\"No class defined in terminal provider file \" + name);\n+                }\n+                Class<?> clazz = cl.loadClass( className );\n+                return (TerminalProvider) clazz.getConstructor().newInstance();\n+            } catch ( Exception e ) {\n+                throw new IOException(\"Unable to load terminal provider \" + name, e);\n+            }\n+        } else {\n+            throw new IOException(\"Unable to find terminal provider \" + name);\n+        }\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/TerminalProvider.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -537,1 +537,1 @@\n-            throw new IllegalArgumentException(\"h outside assumed range 0..360: \" + Double.toString(h));\n+            throw new IllegalArgumentException(\"h outside assumed range 0..360: \" + h);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Colors.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-import java.util.Stack;\n+import java.util.ArrayDeque;\n@@ -24,2 +24,2 @@\n-    private static Object[] sv = new Object[26];\n-    private static Object[] dv = new Object[26];\n+    private static final Object[] sv = new Object[26];\n+    private static final Object[] dv = new Object[26];\n@@ -71,1 +71,1 @@\n-        Stack<Object> stack = new Stack<>();\n+        ArrayDeque<Object> stack = new ArrayDeque<>();\n@@ -200,1 +200,1 @@\n-                                int v = Integer.valueOf(str.substring(start, index - 1));\n+                                int v = Integer.parseInt(str.substring(start, index - 1));\n@@ -473,1 +473,1 @@\n-            return Integer.valueOf(pop.toString());\n+            return Integer.parseInt(pop.toString());\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Curses.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-        int numLines = Math.max(oldLines.size(), newLines.size());\n+        int numLines = Math.min(rows, Math.max(oldLines.size(), newLines.size()));\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Display.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-                    .map(Map.Entry::getValue)\n+                    .map(Map.Entry::getKey)\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/InfoCmp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,7 +98,3 @@\n-            boolean isInfinite = (timeout <= 0L);\n-            while (!bytes.hasRemaining() && (isInfinite || timeout > 0L)) {\n-                long start = 0;\n-                if (!isInfinite) {\n-                    start = System.currentTimeMillis();\n-                }\n-                int c = reader.read(timeout);\n+            Timeout t = new Timeout(timeout);\n+            while (!bytes.hasRemaining() && !t.elapsed()) {\n+                int c = reader.read(t.timeout());\n@@ -120,3 +116,0 @@\n-                if (!isInfinite) {\n-                    timeout -= System.currentTimeMillis() - start;\n-                }\n@@ -154,2 +147,2 @@\n-            this.bytes = ByteBuffer.allocate(4);\n-            this.chars = CharBuffer.allocate(2);\n+            this.bytes = ByteBuffer.allocate(2048);\n+            this.chars = CharBuffer.allocate(1024);\n@@ -162,7 +155,3 @@\n-            boolean isInfinite = (timeout <= 0L);\n-            while (!chars.hasRemaining() && (isInfinite || timeout > 0L)) {\n-                long start = 0;\n-                if (!isInfinite) {\n-                    start = System.currentTimeMillis();\n-                }\n-                int b = input.read(timeout);\n+            Timeout t = new Timeout(timeout);\n+            while (!chars.hasRemaining() && !t.elapsed()) {\n+                int b = input.read(t.timeout());\n@@ -184,4 +173,0 @@\n-\n-                if (!isInfinite) {\n-                    timeout -= System.currentTimeMillis() - start;\n-                }\n@@ -201,1 +186,1 @@\n-        public int readBuffered(char[] b) throws IOException {\n+        public int readBuffered(char[] b, int off, int len, long timeout) throws IOException {\n@@ -204,1 +189,3 @@\n-            } else if (b.length == 0) {\n+            } else if (off < 0 || len < 0 || off + len < b.length) {\n+                throw new IllegalArgumentException();\n+            } else if (len == 0) {\n@@ -206,0 +193,4 @@\n+            } else if (chars.hasRemaining()) {\n+                int r = Math.min(len, chars.remaining());\n+                chars.get(b, off, r);\n+                return r;\n@@ -207,32 +198,10 @@\n-                if (chars.hasRemaining()) {\n-                    int r = Math.min(b.length, chars.remaining());\n-                    chars.get(b);\n-                    return r;\n-                } else {\n-                    byte[] buf = new byte[b.length];\n-                    int l = input.readBuffered(buf);\n-                    if (l < 0) {\n-                        return l;\n-                    } else {\n-                        ByteBuffer currentBytes;\n-                        if (bytes.hasRemaining()) {\n-                            int transfer = bytes.remaining();\n-                            byte[] newBuf = new byte[l + transfer];\n-                            bytes.get(newBuf, 0, transfer);\n-                            System.arraycopy(buf, 0, newBuf, transfer, l);\n-                            currentBytes = ByteBuffer.wrap(newBuf);\n-                            bytes.position(0);\n-                            bytes.limit(0);\n-                        } else {\n-                            currentBytes = ByteBuffer.wrap(buf, 0, l);\n-                        }\n-                        CharBuffer chars = CharBuffer.wrap(b);\n-                        decoder.decode(currentBytes, chars, false);\n-                        chars.flip();\n-                        if (currentBytes.hasRemaining()) {\n-                            int pos = bytes.position();\n-                            bytes.limit(bytes.limit() + currentBytes.remaining());\n-                            bytes.put(currentBytes);\n-                            bytes.position(pos);\n-                        }\n-                        return chars.remaining();\n+                Timeout t = new Timeout(timeout);\n+                while (!chars.hasRemaining() && !t.elapsed()) {\n+                    if (!bytes.hasRemaining()) {\n+                        bytes.position(0);\n+                        bytes.limit(0);\n+                    }\n+                    int nb = input.readBuffered(bytes.array(), bytes.limit(),\n+                                            bytes.capacity() - bytes.limit(), t.timeout());\n+                    if (nb < 0) {\n+                        return nb;\n@@ -240,0 +209,4 @@\n+                    bytes.limit(bytes.limit() + nb);\n+                    chars.clear();\n+                    decoder.decode(bytes, chars, false);\n+                    chars.flip();\n@@ -241,0 +214,3 @@\n+                int nb = Math.min(len, chars.remaining());\n+                chars.get(b, off, nb);\n+                return nb;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlocking.java","additions":33,"deletions":57,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -82,0 +82,8 @@\n+        return readBuffered(b, 0L);\n+    }\n+\n+    public int readBuffered(byte[] b, long timeout) throws IOException {\n+        return readBuffered(b, 0, b.length, timeout);\n+    }\n+\n+    public int readBuffered(byte[] b, int off, int len, long timeout) throws IOException {\n@@ -84,1 +92,3 @@\n-        } else if (b.length == 0) {\n+        } else if (off < 0 || len < 0 || off + len < b.length) {\n+            throw new IllegalArgumentException();\n+        } else if (len == 0) {\n@@ -87,1 +97,13 @@\n-            return super.read(b, 0, b.length);\n+            Timeout t = new Timeout(timeout);\n+            int nb = 0;\n+            while (!t.elapsed()) {\n+                int r = read(nb > 0 ? 1 : t.timeout());\n+                if (r < 0) {\n+                    return nb > 0 ? nb : r;\n+                }\n+                b[off + nb++] = (byte) r;\n+                if (nb >= len || t.isInfinite()) {\n+                    break;\n+                }\n+            }\n+            return nb;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingInputStream.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -126,2 +126,0 @@\n-            boolean isInfinite = (timeout <= 0L);\n-\n@@ -132,3 +130,2 @@\n-            while (isInfinite || timeout > 0L)  {\n-                long start = System.currentTimeMillis ();\n-\n+            Timeout t = new Timeout(timeout);\n+            while (!t.elapsed())  {\n@@ -139,1 +136,1 @@\n-                    wait(timeout);\n+                    wait(t.timeout());\n@@ -158,4 +155,0 @@\n-\n-                if (!isInfinite) {\n-                    timeout -= System.currentTimeMillis() - start;\n-                }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingInputStreamImpl.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -48,6 +48,2 @@\n-        boolean isInfinite = (timeout <= 0L);\n-        long end = 0;\n-        if (!isInfinite) {\n-            end = System.currentTimeMillis() + timeout;\n-        }\n-        while (!closed && !buffer.hasRemaining() && (isInfinite || timeout > 0L)) {\n+        Timeout t = new Timeout(timeout);\n+        while (!closed && !buffer.hasRemaining() && !t.elapsed()) {\n@@ -57,1 +53,1 @@\n-                wait(timeout);\n+                wait(t.timeout());\n@@ -63,3 +59,0 @@\n-            if (!isInfinite) {\n-                timeout = end - System.currentTimeMillis();\n-            }\n@@ -110,7 +103,15 @@\n-    public synchronized int readBuffered(byte[] b) throws IOException {\n-        checkIoException();\n-        int res = wait(readBuffer, 0L);\n-        if (res >= 0) {\n-            res = 0;\n-            while (res < b.length && readBuffer.hasRemaining()) {\n-                b[res++] = (byte) (readBuffer.get() & 0x00FF);\n+    public synchronized int readBuffered(byte[] b, int off, int len, long timeout) throws IOException {\n+        if (b == null) {\n+            throw new NullPointerException();\n+        } else if (off < 0 || len < 0 || off + len < b.length) {\n+            throw new IllegalArgumentException();\n+        } else if (len == 0) {\n+            return 0;\n+        } else {\n+            checkIoException();\n+            int res = wait(readBuffer, timeout);\n+            if (res >= 0) {\n+                res = 0;\n+                while (res < len && readBuffer.hasRemaining()) {\n+                    b[off + res++] = (byte) (readBuffer.get() & 0x00FF);\n+                }\n@@ -118,0 +119,2 @@\n+            rewind(readBuffer, writeBuffer);\n+            return res;\n@@ -119,2 +122,0 @@\n-        rewind(readBuffer, writeBuffer);\n-        return res;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingPumpInputStream.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-    public int readBuffered(char[] b) throws IOException {\n+    public int readBuffered(char[] b, int off, int len, long timeout) throws IOException {\n@@ -112,1 +112,3 @@\n-        } else if (b.length == 0) {\n+        } else if (off < 0 || len < 0 || off + len < b.length) {\n+            throw new IllegalArgumentException();\n+        } else if (len == 0) {\n@@ -120,1 +122,7 @@\n-                        notEmpty.await();\n+                        if (timeout > 0) {\n+                            if (!notEmpty.await(timeout, TimeUnit.MILLISECONDS)) {\n+                                throw new IOException( \"Timeout reading\" );\n+                            }\n+                        } else {\n+                            notEmpty.await();\n+                        }\n@@ -130,1 +138,1 @@\n-                    int r = Math.min(b.length, count);\n+                    int r = Math.min(len, count);\n@@ -132,1 +140,1 @@\n-                        b[i] = buffer[read++];\n+                        b[off + i] = buffer[read++];\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingPumpReader.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -88,1 +88,9 @@\n-    public abstract int readBuffered(char[] b) throws IOException;\n+    public int readBuffered(char[] b) throws IOException {\n+        return readBuffered(b, 0L);\n+    }\n+\n+    public int readBuffered(char[] b, long timeout) throws IOException {\n+        return readBuffered(b, 0, b.length, timeout);\n+    }\n+\n+    public abstract int readBuffered(char[] b, int off, int len, long timeout) throws IOException;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingReader.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-    public int readBuffered(char[] b) throws IOException {\n+    public int readBuffered(char[] b, int off, int len, long timeout) throws IOException {\n@@ -97,1 +97,3 @@\n-        } else if (b.length == 0) {\n+        } else if (off < 0 || len < 0 || off + len < b.length) {\n+            throw new IllegalArgumentException();\n+        } else if (len == 0) {\n@@ -108,2 +110,2 @@\n-        } else if (!threadIsReading) {\n-            return in.read(b);\n+        } else if (!threadIsReading && timeout <= 0) {\n+            return in.read(b, off, len);\n@@ -111,1 +113,2 @@\n-            int c = read(-1, false);\n+            \/\/ TODO: rework implementation to read as much as possible\n+            int c = read(timeout, false);\n@@ -113,1 +116,1 @@\n-                b[0] = (char) c;\n+                b[off] = (char) c;\n@@ -116,1 +119,1 @@\n-                return -1;\n+                return c;\n@@ -161,2 +164,0 @@\n-            boolean isInfinite = (timeout <= 0L);\n-\n@@ -167,3 +168,2 @@\n-            while (isInfinite || timeout > 0L)  {\n-                long start = System.currentTimeMillis ();\n-\n+            Timeout t = new Timeout(timeout);\n+            while (!t.elapsed())  {\n@@ -174,1 +174,1 @@\n-                    wait(timeout);\n+                    wait(t.timeout());\n@@ -193,4 +193,0 @@\n-\n-                if (!isInfinite) {\n-                    timeout -= System.currentTimeMillis() - start;\n-                }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingReaderImpl.java","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -31,0 +31,6 @@\n+    public static final boolean IS_WSL = System.getenv(\"WSL_DISTRO_NAME\") != null;\n+\n+    public static final boolean IS_WSL1 = IS_WSL && System.getenv(\"WSL_INTEROP\") == null;\n+\n+    public static final boolean IS_WSL2 = IS_WSL && !IS_WSL1;\n+\n@@ -41,0 +47,1 @@\n+    public static String TEST_COMMAND;\n@@ -47,0 +54,1 @@\n+        String test;\n@@ -48,2 +56,2 @@\n-            tty = \"tty.exe\";\n-            stty = \"stty.exe\";\n+            tty = null;\n+            stty = null;\n@@ -51,1 +59,2 @@\n-            infocmp = \"infocmp.exe\";\n+            infocmp = null;\n+            test = null;\n@@ -65,0 +74,3 @@\n+                    if (test == null && new File(p, \"test.exe\").exists()) {\n+                        test = new File(p, \"test.exe\").getAbsolutePath();\n+                    }\n@@ -67,0 +79,12 @@\n+            if (tty == null) {\n+                tty = \"tty.exe\";\n+            }\n+            if (stty == null) {\n+                stty = \"stty.exe\";\n+            }\n+            if (infocmp == null) {\n+                infocmp = \"infocmp.exe\";\n+            }\n+            if (test == null) {\n+                test = \"test.exe\";\n+            }\n@@ -69,1 +93,2 @@\n-            stty = \"stty\";\n+            stty = IS_OSX ? \"\/bin\/stty\" : \"stty\";\n+            sttyfopt = IS_OSX ? \"-f\" : \"-F\";\n@@ -71,6 +96,1 @@\n-            if (IS_OSX) {\n-                sttyfopt = \"-f\";\n-            }\n-            else {\n-                sttyfopt = \"-F\";\n-            }\n+            test = \"\/bin\/test\";\n@@ -82,0 +102,1 @@\n+        TEST_COMMAND = test;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/OSUtils.java","additions":31,"deletions":10,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-        char[] buf = new char[bufferSize];\n+        char[] buf = new char[Math.max(bufferSize, 2)];\n@@ -56,3 +56,11 @@\n-    private boolean wait(CharBuffer buffer) throws InterruptedIOException {\n-        if (closed) {\n-            return false;\n+    \/**\n+     * Blocks until more input is available, even if {@link #readBuffer} already\n+     * contains some chars; or until the reader is closed.\n+     *\n+     * @return true if more input is available, false if no additional input is\n+     *              available and the reader is closed\n+     * @throws InterruptedIOException If {@link #wait()} is interrupted\n+     *\/\n+    private boolean waitForMoreInput() throws InterruptedIOException {\n+        if (!writeBuffer.hasRemaining()) {\n+            throw new AssertionError(\"No space in write buffer\");\n@@ -61,2 +69,8 @@\n-        while (!buffer.hasRemaining()) {\n-            \/\/ Wake up waiting readers\/writers\n+        int oldRemaining = readBuffer.remaining();\n+\n+        do {\n+            if (closed) {\n+                return false;\n+            }\n+\n+            \/\/ Wake up waiting writers\n@@ -70,0 +84,4 @@\n+        } while (readBuffer.remaining() <= oldRemaining);\n+\n+        return true;\n+    }\n@@ -71,0 +89,9 @@\n+    \/**\n+     * Waits until {@code buffer.hasRemaining() == true}, or it is false and\n+     * the reader is {@link #closed}.\n+     *\n+     * @return true if {@code buffer.hasRemaining() == true}; false otherwise\n+     *         when reader is closed\n+     *\/\n+    private boolean wait(CharBuffer buffer) throws InterruptedIOException {\n+        while (!buffer.hasRemaining()) {\n@@ -74,0 +101,9 @@\n+\n+            \/\/ Wake up waiting readers\/writers\n+            notifyAll();\n+\n+            try {\n+                wait();\n+            } catch (InterruptedException e) {\n+                throw new InterruptedIOException();\n+            }\n@@ -80,1 +116,1 @@\n-     * Blocks until more input is available or the reader is closed.\n+     * Blocks until input is available or the reader is closed.\n@@ -82,1 +118,1 @@\n-     * @return true if more input is available, false if the reader is closed\n+     * @return true if input is available, false if no input is available and the reader is closed\n@@ -97,1 +133,2 @@\n-        if (!wait(writeBuffer)) {\n+        \/\/ Check `closed` to throw even if writer buffer has space available\n+        if (!wait(writeBuffer) || closed) {\n@@ -125,1 +162,3 @@\n-        return rewind(readBuffer, writeBuffer) && readBuffer.hasRemaining();\n+        boolean rw = rewind(readBuffer, writeBuffer) && readBuffer.hasRemaining();\n+        notifyAll();\n+        return rw;\n@@ -134,0 +173,1 @@\n+        notifyAll();\n@@ -205,0 +245,1 @@\n+        int oldPos = output.position();\n@@ -206,2 +247,18 @@\n-        if (rewindReadBuffer() && result.isUnderflow()) {\n-            encoder.encode(readBuffer, output, false);\n+        int encodedCount = output.position() - oldPos;\n+\n+        if (result.isUnderflow()) {\n+            boolean hasMoreInput = rewindReadBuffer();\n+            boolean reachedEndOfInput = false;\n+\n+            \/\/ If encoding did not make any progress must block for more input\n+            if (encodedCount == 0 && !hasMoreInput) {\n+                reachedEndOfInput = !waitForMoreInput();\n+            }\n+\n+            result = encoder.encode(readBuffer, output, reachedEndOfInput);\n+            if (result.isError()) {\n+                result.throwException();\n+            }\n+            if (!reachedEndOfInput && output.position() - oldPos == 0) {\n+                throw new AssertionError(\"Failed to encode any chars\");\n+            }\n@@ -209,0 +266,6 @@\n+        } else if (result.isOverflow()) {\n+            if (encodedCount == 0) {\n+                throw new AssertionError(\"Output buffer has not enough space\");\n+            }\n+        } else {\n+            result.throwException();\n@@ -337,1 +400,1 @@\n-            this.buffer = ByteBuffer.allocate((int) Math.ceil(encoder.maxBytesPerChar()));\n+            this.buffer = ByteBuffer.allocate((int) Math.ceil(encoder.maxBytesPerChar() * 2));\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/PumpReader.java","additions":76,"deletions":13,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-            String name = spec.substring(1, spec.length());\n+            String name = spec.substring(1);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/StyleResolver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2002-2018, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.utils;\n+\n+\/**\n+ * Helper class ti use during I\/O operations with an eventual timeout.\n+ *\/\n+public class Timeout {\n+\n+    private final long timeout;\n+    private long cur = 0;\n+    private long end = Long.MAX_VALUE;\n+\n+    public Timeout(long timeout) {\n+        this.timeout = timeout;\n+    }\n+\n+    public boolean isInfinite() {\n+        return timeout <= 0;\n+    }\n+\n+    public boolean isFinite() {\n+        return timeout > 0;\n+    }\n+\n+    public boolean elapsed() {\n+        if (timeout > 0) {\n+            cur = System.currentTimeMillis();\n+            if (end == Long.MAX_VALUE) {\n+                end = cur + timeout;\n+            }\n+            return cur >= end;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public long timeout() {\n+        return timeout > 0 ? Math.max(1, end - cur) : timeout;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Timeout.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -73,0 +73,1 @@\n+                                (ucs >= 0x1f000 && ucs <= 0x1feee) ||\n@@ -126,2 +127,2 @@\n-            new Interval( 0x1D242, 0x1D244 ), new Interval( 0xE0001, 0xE0001 ), new Interval( 0xE0020, 0xE007F ),\n-            new Interval( 0xE0100, 0xE01EF )\n+            new Interval( 0x1D242, 0x1D244 ), new Interval( 0x1F3FB, 0x1F3FF ), new Interval( 0xE0001, 0xE0001 ),\n+            new Interval( 0xE0020, 0xE007F ), new Interval( 0xE0100, 0xE01EF )\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/WCWidth.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-\tcr=^M, cub=\\E[%p1%dD, cub1=\\E[D, cud=\\E[%p1%dB, cud1=\\E[B,\n+\tcr=^M, cub=\\E[%p1%dD, cub1=\\E[D, cud=\\E[%p1%dB, cud1=\\n,\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/windows-vtp.caps","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,2 +51,0 @@\n-    uses jdk.internal.org.jline.terminal.spi.JnaSupport;\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/module-info.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## JLine v3.20.0\n+## JLine v3.22.0\n@@ -44,4 +44,4 @@\n-org.fusesource.jansi version 1.17.1\n-org.apache.sshd 2.1 to 3\n-org.apache.felix.gogo.runtime 1.1.2\n-org.apache.felix.gogo.jline 1.1.4\n+org.fusesource.jansi version 2.4.0\n+org.apache.sshd 2.9.2\n+org.apache.felix.gogo.runtime 1.1.6\n+org.apache.felix.gogo.jline 1.1.8\n@@ -265,1 +265,1 @@\n-Copyright (c) 2004-2017 QOS.ch\n+Copyright (c) 2004-2023 QOS.ch\n","filename":"src\/jdk.internal.le\/share\/legal\/jline.md","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2019, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.terminal.impl.jna;\n-\n-import jdk.internal.org.jline.terminal.Attributes;\n-import jdk.internal.org.jline.terminal.Size;\n-import jdk.internal.org.jline.terminal.Terminal;\n-import jdk.internal.org.jline.terminal.impl.jna.win.JnaWinSysTerminal;\n-import jdk.internal.org.jline.terminal.spi.JnaSupport;\n-import jdk.internal.org.jline.terminal.spi.Pty;\n-import jdk.internal.org.jline.utils.OSUtils;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.charset.Charset;\n-import java.util.function.Function;\n-\n-public class JnaSupportImpl implements JnaSupport {\n-    @Override\n-    public Pty current() throws IOException {\n-\/\/        return JnaNativePty.current();\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public Pty open(Attributes attributes, Size size) throws IOException {\n-\/\/        return JnaNativePty.open(attributes, size);\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler) throws IOException {\n-        return winSysTerminal(name, type, ansiPassThrough, encoding, codepage, nativeSignals, signalHandler, false);\n-    }\n-\n-    @Override\n-    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused) throws IOException {\n-        return winSysTerminal(name, type, ansiPassThrough, encoding, codepage, nativeSignals, signalHandler, paused, input -> input);\n-    }\n-\n-    @Override\n-    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        return JnaWinSysTerminal.createTerminal(name, type, ansiPassThrough, encoding, codepage, nativeSignals, signalHandler, paused, inputStreamWrapper);\n-    }\n-\n-    @Override\n-    public boolean isWindowsConsole() {\n-        return JnaWinSysTerminal.isWindowsConsole();\n-    }\n-\n-    @Override\n-    public boolean isConsoleOutput() {\n-        if (OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM) {\n-            throw new UnsupportedOperationException();\n-        } else if (OSUtils.IS_WINDOWS) {\n-            return JnaWinSysTerminal.isConsoleOutput();\n-        }\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public boolean isConsoleInput() {\n-        if (OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM) {\n-            throw new UnsupportedOperationException();\n-        } else if (OSUtils.IS_WINDOWS) {\n-            return JnaWinSysTerminal.isConsoleInput();\n-        }\n-        throw new UnsupportedOperationException();\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JnaSupportImpl.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2002-2020, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.impl.PosixPtyTerminal;\n+import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n+import jdk.internal.org.jline.terminal.impl.jna.win.JnaWinSysTerminal;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.util.function.Function;\n+\n+public class JnaTerminalProvider implements TerminalProvider\n+{\n+    @Override\n+    public String name() {\n+        return \"jna\";\n+    }\n+\n+\/\/    public Pty current(TerminalProvider.Stream console) throws IOException {\n+\/\/        return JnaNativePty.current(console);\n+\/\/    }\n+\/\/\n+\/\/    public Pty open(Attributes attributes, Size size) throws IOException {\n+\/\/        return JnaNativePty.open(attributes, size);\n+\/\/    }\n+\n+    @Override\n+    public Terminal sysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        if (OSUtils.IS_WINDOWS) {\n+            return winSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                   boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                   Stream console, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        return JnaWinSysTerminal.createTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, console, inputStreamWrapper);\n+    }\n+\n+\/\/    public Terminal posixSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+\/\/                                     boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+\/\/                                     Stream consoleStream) throws IOException {\n+\/\/        Pty pty = current(consoleStream);\n+\/\/        return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler);\n+\/\/    }\n+\n+    @Override\n+    public Terminal newTerminal(String name, String type, InputStream in, OutputStream out,\n+                                Charset encoding, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Attributes attributes, Size size) throws IOException\n+    {\n+\/\/        Pty pty = open(attributes, size);\n+\/\/        return new PosixPtyTerminal(name, type, pty, in, out, encoding, signalHandler, paused);\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isSystemStream(Stream stream) {\n+        try {\n+            if (OSUtils.IS_WINDOWS) {\n+                return isWindowsSystemStream(stream);\n+            } else {\n+\/\/                return isPosixSystemStream(stream);\n+                return false;\n+            }\n+        } catch (Throwable t) {\n+            return false;\n+        }\n+    }\n+\n+    public boolean isWindowsSystemStream(Stream stream) {\n+        return JnaWinSysTerminal.isWindowsSystemStream(stream);\n+    }\n+\n+\/\/    public boolean isPosixSystemStream(Stream stream) {\n+\/\/        return JnaNativePty.isPosixSystemStream(stream);\n+\/\/    }\n+\n+    @Override\n+    public String systemStreamName(Stream stream) {\n+\/\/        if (OSUtils.IS_WINDOWS) {\n+            return null;\n+\/\/        } else {\n+\/\/            return JnaNativePty.posixSystemStreamName(stream);\n+\/\/        }\n+    }\n+}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JnaTerminalProvider.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -20,1 +20,1 @@\n-    private final Pointer consoleHandle;\n+    private final Pointer console;\n@@ -23,2 +23,2 @@\n-    JnaWinConsoleWriter(Pointer consoleHandle) {\n-        this.consoleHandle = consoleHandle;\n+    JnaWinConsoleWriter(Pointer console) {\n+        this.console = console;\n@@ -30,1 +30,1 @@\n-            Kernel32.INSTANCE.WriteConsoleW(this.consoleHandle, text, len, this.writtenChars, null);\n+            Kernel32.INSTANCE.WriteConsoleW(this.console, text, len, this.writtenChars, null);\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/JnaWinConsoleWriter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author or authors.\n@@ -22,1 +22,0 @@\n-\n@@ -25,1 +24,0 @@\n-import jdk.internal.org.jline.terminal.Terminal;\n@@ -27,0 +25,1 @@\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -34,0 +33,1 @@\n+    private static final Pointer consoleErr = Kernel32.INSTANCE.GetStdHandle(Kernel32.STD_ERROR_HANDLE);\n@@ -35,1 +35,12 @@\n-    public static JnaWinSysTerminal createTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, SignalHandler signalHandler, boolean paused, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+    public static JnaWinSysTerminal createTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, boolean nativeSignals, SignalHandler signalHandler, boolean paused, TerminalProvider.Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        Pointer console;\n+        switch (consoleStream) {\n+            case Output:\n+                console = JnaWinSysTerminal.consoleOut;\n+                break;\n+            case Error:\n+                console = JnaWinSysTerminal.consoleErr;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unsupport stream for console: \" + consoleStream);\n+        }\n@@ -41,1 +52,1 @@\n-            writer = new JnaWinConsoleWriter(consoleOut);\n+            writer = new JnaWinConsoleWriter(console);\n@@ -44,1 +55,1 @@\n-            Kernel32.INSTANCE.GetConsoleMode(consoleOut, mode);\n+            Kernel32.INSTANCE.GetConsoleMode(console, mode);\n@@ -46,1 +57,1 @@\n-                Kernel32.INSTANCE.SetConsoleMode(consoleOut, mode.getValue() | AbstractWindowsTerminal.ENABLE_VIRTUAL_TERMINAL_PROCESSING);\n+                Kernel32.INSTANCE.SetConsoleMode(console, mode.getValue() | AbstractWindowsTerminal.ENABLE_VIRTUAL_TERMINAL_PROCESSING);\n@@ -50,1 +61,1 @@\n-                writer = new JnaWinConsoleWriter(consoleOut);\n+                writer = new JnaWinConsoleWriter(console);\n@@ -56,1 +67,1 @@\n-                    writer = new JnaWinConsoleWriter(consoleOut);\n+                    writer = new JnaWinConsoleWriter(console);\n@@ -61,1 +72,1 @@\n-                    writer = new WindowsAnsiWriter(new BufferedWriter(new JnaWinConsoleWriter(consoleOut)), consoleOut);\n+                    writer = new WindowsAnsiWriter(new BufferedWriter(new JnaWinConsoleWriter(console)), console);\n@@ -65,1 +76,1 @@\n-        JnaWinSysTerminal terminal = new JnaWinSysTerminal(writer, name, type, encoding, codepage, nativeSignals, signalHandler, inputStreamWrapper);\n+        JnaWinSysTerminal terminal = new JnaWinSysTerminal(writer, name, type, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n@@ -73,12 +84,1 @@\n-    public static boolean isWindowsConsole() {\n-        try {\n-            IntByReference mode = new IntByReference();\n-            Kernel32.INSTANCE.GetConsoleMode(consoleOut, mode);\n-            Kernel32.INSTANCE.GetConsoleMode(consoleIn, mode);\n-            return true;\n-        } catch (LastErrorException e) {\n-            return false;\n-        }\n-    }\n-\n-    public static boolean isConsoleOutput() {\n+    public static boolean isWindowsSystemStream(TerminalProvider.Stream stream) {\n@@ -87,11 +87,8 @@\n-            Kernel32.INSTANCE.GetConsoleMode(consoleOut, mode);\n-            return true;\n-        } catch (LastErrorException e) {\n-            return false;\n-        }\n-    }\n-\n-    public static boolean isConsoleInput() {\n-        try {\n-            IntByReference mode = new IntByReference();\n-            Kernel32.INSTANCE.GetConsoleMode(consoleIn, mode);\n+            Pointer console;\n+            switch (stream) {\n+                case Input: console = consoleIn; break;\n+                case Output: console = consoleOut; break;\n+                case Error: console = consoleErr; break;\n+                default: return false;\n+            }\n+            Kernel32.INSTANCE.GetConsoleMode(console, mode);\n@@ -104,2 +101,3 @@\n-    JnaWinSysTerminal(Writer writer, String name, String type, Charset encoding, int codepage, boolean nativeSignals, SignalHandler signalHandler, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n-        super(writer, name, type, encoding, codepage, nativeSignals, signalHandler, inputStreamWrapper);\n+    JnaWinSysTerminal(Writer writer, String name, String type, Charset encoding, boolean nativeSignals, SignalHandler signalHandler,\n+            Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        super(writer, name, type, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/JnaWinSysTerminal.java","additions":34,"deletions":36,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    private static final int MAX_ESCAPE_SEQUENCE_LENGTH = 100;\n+    private final static int MAX_ESCAPE_SEQUENCE_LENGTH = 100;\n@@ -96,1 +96,1 @@\n-        if( negative ) {\n+        if (negative) {\n@@ -112,1 +112,1 @@\n-        if( negative ) {\n+        if (negative) {\n@@ -119,1 +119,1 @@\n-        \/\/ Swap the Foreground and Background bits.\n+        \/\/ Swap the the Foreground and Background bits.\n@@ -186,1 +186,1 @@\n-        info.dwCursorPosition.Y -= (short)count;\n+        info.dwCursorPosition.Y -= (short) count;\n@@ -193,1 +193,1 @@\n-        info.dwCursorPosition.Y += (short)count;\n+        info.dwCursorPosition.Y += (short) count;\n@@ -199,1 +199,1 @@\n-        info.dwCursorPosition.X -= (short)count;\n+        info.dwCursorPosition.X -= (short) count;\n@@ -205,1 +205,1 @@\n-        info.dwCursorPosition.X += (short)count;\n+        info.dwCursorPosition.X += (short) count;\n@@ -213,1 +213,1 @@\n-            info.dwCursorPosition.Y += (short)count;\n+            info.dwCursorPosition.Y += (short) count;\n@@ -229,1 +229,1 @@\n-        info.dwCursorPosition.Y -= (short)count;\n+        info.dwCursorPosition.Y -= (short) count;\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/WindowsAnsiWriter.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,27 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-provides jdk.internal.org.jline.terminal.spi.JnaSupport with jdk.internal.org.jline.terminal.impl.jna.JnaSupportImpl;\n","filename":"src\/jdk.internal.le\/windows\/classes\/module-info.java.extra","additions":0,"deletions":27,"binary":false,"changes":27,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-     * \"jdk.vm.ci.runtime.test.TypeUniverse$$Lambda$1\/869601985\").\n+     * \"jdk.vm.ci.runtime.test.TypeUniverse$$Lambda\/869601985\").\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/MetaUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include <inttypes.h>\n@@ -34,4 +35,0 @@\n-#if defined(_WIN32)\n-  #define PRId64 \"I64d\"\n-#endif\n-\n","filename":"src\/jdk.jdi\/share\/native\/libdt_shmem\/shmemBase.c","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,8 @@\n- * Event field annotation, specifies that the value is a boolean flag, a {@code true} or\n- * {@code false} value.\n+ * Event field annotation, specifies that the value is a boolean flag, a\n+ * {@code true} or {@code false} value.\n+ * <p>\n+ * The following example shows how the {@code BooleanFlag} annotation can be\n+ * used to describe that a setting is a boolean value. This information can be\n+ * used by a graphical user interface to display the setting as a checkbox.\n+ *\n+ * {@snippet class = \"Snippets\" region = \"BooleanFlagOverview\"}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/BooleanFlag.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,5 @@\n+ * <p>\n+ * The following example shows how the {@code Configuration} class can be used\n+ * to list available configurations and how to pass a configuration object to a\n+ * {@code Recording}.\n+ * {@snippet class = \"Snippets\" region = \"ConfigurationxsOverview\"}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Configuration.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,5 @@\n+ * <p>\n+ * The following example shows how the {@code DataAmount} annotation can be used to\n+ * set the units {@code BITS} and {@code BYTES} to event fields.\n+ *\n+ * {@snippet class=\"Snippets\" region=\"DataAmountOverview\"}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/DataAmount.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,13 @@\n- * If an event doesn't have the annotation, then by default the event is enabled.\n+ * If an event doesn't have the annotation, then by default the event is\n+ * enabled.\n+ * <p>\n+ * The following example shows how the {@code Enabled} annotation can be used to\n+ * create a disabled event. A disabled event will at most have the overhead of\n+ * an allocation, or none if the runtime JIT compiler is able to eliminate it.\n+ *\n+ * {@snippet class = \"Snippets\" region = \"EnabledOverview\"}\n+ *\n+ * The event can be enabled programmatically, or on command line when needed,\n+ * for example:\n+ *\n+ * {@snippet class = \"Snippets\" region = \"EnabledOverviewCommandLine\"}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Enabled.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -43,0 +43,5 @@\n+ * <p>\n+ * The following example shows how the {@code EventType} class can\n+ * be used to print metadata about an event.\n+ *\n+ * {@snippet class=\"Snippets\" region=\"EventTypeOverview\"}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventType.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,5 @@\n+ * <p>\n+ * The following example shows how the {@code Period} annotation can be used\n+ * to emit events at different intervals.\n+ *\n+ * {@snippet class = \"Snippets\" region = \"PeriodOverview\"}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Period.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+ * <p>\n+ * The following example shows how the {@code ValueDescriptor} class can\n+ * be used to list field information of all types.\n+ *\n+ * {@snippet class=\"Snippets\" region=\"ValueDescriptorOverview\"}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/ValueDescriptor.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,8 @@\n+    \/**\n+     *  Covers periodic task work (for Hotspot developer)\n+     *\/\n+    JFR_SYSTEM_PERIODIC(9),\n+    \/**\n+     *  Covers periodic event work (for users of the JDK)\n+     *\/\n+    JFR_PERIODIC(10),\n@@ -76,1 +84,1 @@\n-    JFR_METADATA(9),\n+    JFR_METADATA(11),\n@@ -80,1 +88,1 @@\n-    JFR_EVENT(10),\n+    JFR_EVENT(12),\n@@ -84,1 +92,1 @@\n-    JFR_SETTING(11),\n+    JFR_SETTING(13),\n@@ -88,1 +96,1 @@\n-    JFR_DCMD(12),\n+    JFR_DCMD(14),\n@@ -92,1 +100,1 @@\n-    JFR_START(13);\n+    JFR_START(15);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/LogTag.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.Date;\n@@ -265,1 +266,5 @@\n-        m.dst = tz.getDSTSavings();\n+        if (tz.inDaylightTime(new Date())) {\n+            m.dst = tz.getDSTSavings();\n+        } else {\n+            m.dst = 0;\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataDescriptor.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -482,1 +482,1 @@\n-                \"Dump running recording when JVM shuts down\",\n+                \"Minimum time before flushing buffers, measured in (s)econds, e.g. 4 s, or 0 for flushing when a recording ends\",\n@@ -485,1 +485,1 @@\n-                \"Minimum time before flushing buffers, measured in (s)econds, e.g. 4 s, or 0 for flushing when a recording ends\",\n+                \"Dump running recording when JVM shuts down\",\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStart.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-                \"Recording text,.e.g \\\\\\\"My Recording\\\\\\\"\",\n+                \"Recording name, e.g. \\\\\\\"My Recording\\\\\\\"\",\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStop.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+        Logger.log(LogTag.JFR_SYSTEM_PERIODIC, LogLevel.DEBUG, \"Grouping tasks into batches. Iteration \" + iteration);\n@@ -110,1 +111,1 @@\n-        if (!Logger.shouldLog(LogTag.JFR, LogLevel.TRACE)) {\n+        if (!Logger.shouldLog(LogTag.JFR_SYSTEM_PERIODIC, LogLevel.TRACE)) {\n@@ -113,1 +114,0 @@\n-        String prefix = \"Periodic task: settings iteration: \" + iteration + \", batch period: \";\n@@ -115,1 +115,0 @@\n-            String batchPrefix = prefix + batch.getPeriod();\n@@ -117,1 +116,1 @@\n-                logTrace(batchPrefix + \", period: \" + task.getPeriod() + \", task: \" + task.getName());\n+                logTrace(\"Batched task [0..\" + task.getPeriod() + \"] step \" + batch.getPeriod() + \" \" + task.getName());\n@@ -123,1 +122,1 @@\n-       Logger.log(LogTag.JFR_SYSTEM, LogLevel.TRACE, text);\n+       Logger.log(LogTag.JFR_SYSTEM_PERIODIC, LogLevel.DEBUG, text);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/BatchManager.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-        super(lookupKey, eventType.getLogName());\n+        super(lookupKey, \"event \" + eventType.getLogName());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/EventTask.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        super(new LookupKey(new Object()), \"JFR: Flush Task\");\n+        super(new LookupKey(new Object()), \"flush task\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/FlushTask.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n@@ -135,0 +138,1 @@\n+        Logger.log(LogTag.JFR_PERIODIC, LogLevel.DEBUG,\"Periodic work started\");\n@@ -181,0 +185,1 @@\n+        Logger.log(LogTag.JFR_PERIODIC, LogLevel.DEBUG,\"Periodic work ended\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/PeriodicEvents.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -92,0 +92,7 @@\n+            if (Logger.shouldLog(LogTag.JFR_PERIODIC, LogLevel.DEBUG)) {\n+                boolean trace = Logger.shouldLog(LogTag.JFR_PERIODIC, LogLevel.TRACE);\n+                boolean run = shouldRun();\n+                if (trace || run) {\n+                    logInterval(trace, run ? \"Run\" : \"Skip\");\n+                }\n+            }\n@@ -117,0 +124,3 @@\n+        if (periodicType != PeriodicType.INTERVAL) {\n+            logChunk(periodicType);\n+        }\n@@ -121,1 +131,9 @@\n-            Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, \"Exception occurred during execution of period task for \" + name);\n+            Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, \"Exception occurred during execution of \" + name);\n+        }\n+    }\n+\n+    private void logChunk(PeriodicType periodicType) {\n+        if (Logger.shouldLog(LogTag.JFR_PERIODIC, LogLevel.DEBUG)) {\n+            String action = periodicType == PeriodicType.BEGIN_CHUNK ? \"beginChunk\" : \"endChunk\";\n+            String message = \"Run \" + action + \" \" + getName();\n+            Logger.log(LogTag.JFR_PERIODIC, LogLevel.DEBUG, message);\n@@ -123,2 +141,10 @@\n-        if (Logger.shouldLog(LogTag.JFR_SYSTEM, LogLevel.DEBUG)) {\n-            Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"Executed periodic task for \" + name);\n+    }\n+\n+    private void logInterval(boolean trace, String action) {\n+        String message = action + \" periodic \" + getName();\n+        if (trace) {\n+            \/\/ Makes the counter run on x\/x instead of 0\/x which looks strange.\n+            long a =  counter == 0 ? period : counter;\n+            Logger.log(LogTag.JFR_PERIODIC, LogLevel.TRACE, message + (\" \" + a + \"\/\" + period));\n+        } else {\n+            Logger.log(LogTag.JFR_PERIODIC, LogLevel.DEBUG, message);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/PeriodicTask.java","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.jfr.BooleanFlag;\n@@ -30,0 +31,1 @@\n+import jdk.jfr.EventType;\n@@ -33,0 +35,1 @@\n+import jdk.jfr.DataAmount;\n@@ -34,0 +37,1 @@\n+import jdk.jfr.Enabled;\n@@ -42,0 +46,1 @@\n+import jdk.jfr.consumer.RecordingStream;\n@@ -56,0 +61,1 @@\n+import java.util.LinkedHashMap;\n@@ -57,0 +63,1 @@\n+import java.util.Map;\n@@ -58,0 +65,2 @@\n+import java.util.StringJoiner;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -59,1 +68,0 @@\n-import java.util.stream.Collectors;\n@@ -86,0 +94,71 @@\n+    \/\/ @start region=\"BooleanFlagOverview\"\n+    @BooleanFlag\n+    @Name(\"example.Rollback\")\n+    @Label(\"Rollback\")\n+    @Description(\"Include transactions that are rollbacked\")\n+    public static class RollbackSetting extends SettingControl {\n+        private boolean value = true;\n+\n+        @Override\n+        public String combine(Set<String> values) {\n+            return values.contains(\"true\") ? \"true\" : \"false\";\n+        }\n+\n+        @Override\n+        public void setValue(String settingValue) {\n+            value = \"true\".equals(settingValue);\n+        }\n+\n+        @Override\n+        public String getValue() {\n+            return Boolean.toString(value);\n+        }\n+\n+        public boolean shouldEmit() {\n+            return value;\n+        }\n+    }\n+\n+    @Name(\"example.Transaction\")\n+    public static class TransactionEvent extends Event {\n+        @Label(\"Context\")\n+        String context;\n+\n+        @Label(\"Rollback\")\n+        boolean rollback;\n+\n+        @SettingDefinition\n+        @Name(\"rollback\")\n+        public boolean rollback(RollbackSetting rollbackSetting) {\n+            return rollback && rollbackSetting.shouldEmit();\n+        }\n+    }\n+    \/\/ @end\n+\n+    static class ConfigurationOverview {\n+    \/\/ @start region=\"ConfigurationxsOverview\"\n+    public static void main(String... args) throws Exception {\n+        if (args.length == 0) {\n+            System.out.println(\"Configurations:\");\n+            for (Configuration c : Configuration.getConfigurations()) {\n+                System.out.println(\"Name: \" + c.getName());\n+                System.out.println(\"Label: \" + c.getLabel());\n+                System.out.println(\"Description: \" + c.getDescription());\n+                System.out.println(\"Provider: \" + c.getProvider());\n+                System.out.println();\n+            }\n+        } else {\n+            String name = args[0];\n+            Configuration c = Configuration.getConfiguration(name);\n+            try (Recording r = new Recording(c)) {\n+                System.out.println(\"Starting recording with settings:\");\n+                for (Map.Entry<String, String> setting : c.getSettings().entrySet()) {\n+                    System.out.println(setting.getKey() + \" = \" + setting.getValue());\n+                }\n+                r.start();\n+            }\n+        }\n+    }\n+    \/\/ @end\n+    }\n+\n@@ -164,0 +243,41 @@\n+    \/\/ @start region=\"DataAmountOverview\"\n+    @Name(\"com.example.ImageRender\")\n+    @Label(\"Image Render\")\n+    public class ImageRender extends Event {\n+        @Label(\"Height\")\n+        long height;\n+\n+        @Label(\"Width\")\n+        long width;\n+\n+        @Label(\"Color Depth\")\n+        @DataAmount(DataAmount.BITS)\n+        int colorDepth;\n+\n+        @Label(\"Memory Size\")\n+        @DataAmount \/\/ bytes by default\n+        long memorySize;\n+    }\n+    \/\/ @end\n+\n+    \/\/ @start region=\"EnabledOverview\"\n+    @Name(\"StopWatch\")\n+    @Label(\"Stop Watch\")\n+    @Category(\"Debugging\")\n+    @StackTrace(false)\n+    @Enabled(false)\n+    static public class StopWatchEvent extends Event {\n+    }\n+\n+    public void update() {\n+        StopWatchEvent e = new StopWatchEvent();\n+        e.begin();\n+        code: \/\/ @replace regex='code:' replacement=\"...\"\n+        e.commit();\n+    }\n+    \/\/ @end\n+    \/*\n+    \/\/ @start region=\"EnabledOverviewCommandLine\"\n+    java -XX:StartFlightRecording:StopWatch#enabled=true ...\n+    \/\/ @end\n+    *\/\n@@ -208,10 +328,34 @@\n-        Recording r = new Recording();\n-        r.enable(\"jdk.CPULoad\")\n-         .withPeriod(Duration.ofSeconds(1));\n-        r.enable(\"jdk.FileWrite\")\n-         .withoutStackTrace()\n-         .withThreshold(Duration.ofNanos(10));\n-        r.start();\n-        Thread.sleep(10_000);\n-        r.stop();\n-        r.dump(Files.createTempFile(\"recording\", \".jfr\"));\n+        try (Recording r = new Recording()) {\n+            r.enable(\"jdk.CPULoad\")\n+             .withPeriod(Duration.ofSeconds(1));\n+            r.enable(\"jdk.FileWrite\")\n+             .withoutStackTrace()\n+             .withThreshold(Duration.ofNanos(10));\n+            r.start();\n+            Thread.sleep(10_000);\n+            r.stop();\n+            r.dump(Files.createTempFile(\"recording\", \".jfr\"));\n+        }\n+        \/\/ @end\n+    }\n+    void EventTypeOverview() {\n+        \/\/ @start region=\"EventTypeOverview\"\n+        for (EventType eventType : FlightRecorder.getFlightRecorder().getEventTypes()) {\n+            System.out.println(\"Event Type: \" + eventType.getName());\n+            if (eventType.getLabel() != null) {\n+                System.out.println(\"Label: \" + eventType.getLabel());\n+            }\n+            if (eventType.getDescription() != null) {\n+                System.out.println(\"Description: \" + eventType.getDescription());\n+            }\n+            StringJoiner s = new StringJoiner(\" \/ \");\n+            for (String category : eventType.getCategoryNames()) {\n+                s.add(category);\n+            }\n+            System.out.println(\"Category: \" + s);\n+            System.out.println(\"Fields: \" + eventType.getFields().size());\n+            System.out.println(\"Annotations: \" + eventType.getAnnotationElements().size());\n+            System.out.println(\"Settings: \" + eventType.getSettingDescriptors().size());\n+            System.out.println(\"Enabled: \" + eventType.isEnabled());\n+            System.out.println();\n+        }\n@@ -264,0 +408,48 @@\n+    void PeriodOverview() {\n+        \/\/ @start region = \"PeriodOverview\"\n+        @Period(\"1 s\")\n+        @Name(\"Counter\")\n+        class CountEvent extends Event {\n+            int count;\n+        }\n+        @Period(\"3 s\")\n+        @Name(\"Fizz\")\n+        class FizzEvent extends Event {\n+        }\n+        @Period(\"5 s\")\n+        @Name(\"Buzz\")\n+        class BuzzEvent extends Event {\n+        }\n+\n+        var counter = new AtomicInteger();\n+        FlightRecorder.addPeriodicEvent(CountEvent.class, () -> {\n+            CountEvent event = new CountEvent();\n+            event.count = counter.incrementAndGet();\n+            event.commit();\n+        });\n+        FlightRecorder.addPeriodicEvent(FizzEvent.class, () -> {\n+            new FizzEvent().commit();\n+        });\n+        FlightRecorder.addPeriodicEvent(BuzzEvent.class, () -> {\n+            new BuzzEvent().commit();\n+        });\n+\n+        var sb = new StringBuilder();\n+        var last = new AtomicInteger();\n+        var current = new AtomicInteger();\n+        try (var r = new RecordingStream()) {\n+            r.onEvent(\"Counter\", e -> current.set(e.getValue(\"count\")));\n+            r.onEvent(\"Fizz\", e -> sb.append(\"Fizz\"));\n+            r.onEvent(\"Buzz\", e -> sb.append(\"Buzz\"));\n+            r.onFlush(() -> {\n+                if (current.get() != last.get()) {\n+                    System.out.println(sb.isEmpty() ? current : sb);\n+                    last.set(current.get());\n+                    sb.setLength(0);\n+                }\n+            });\n+            r.start();\n+        }\n+        \/\/ @end\n+    }\n+\n@@ -306,6 +498,7 @@\n-     Recording r = new Recording(c);\n-     r.start();\n-     System.gc();\n-     Thread.sleep(5000);\n-     r.stop();\n-     r.dump(Files.createTempFile(\"my-recording\", \".jfr\"));\n+     try (Recording r = new Recording(c)) {\n+         r.start();\n+         System.gc();\n+         Thread.sleep(5000);\n+         r.stop();\n+         r.dump(Files.createTempFile(\"my-recording\", \".jfr\"));\n+     }\n@@ -413,0 +606,38 @@\n+\n+ static class ValueDsecriptorOverview {\n+     \/\/ @start region=\"ValueDescriptorOverview\"\n+     void printTypes() {\n+         Map<String, List<ValueDescriptor>> typeMap = new LinkedHashMap<>();\n+         for (EventType eventType : FlightRecorder.getFlightRecorder().getEventTypes()) {\n+             findTypes(typeMap, eventType.getName(), eventType.getFields());\n+         }\n+         for (String type : typeMap.keySet()) {\n+             System.out.println(\"Type: \" + type);\n+             for (ValueDescriptor field : typeMap.get(type)) {\n+                 System.out.println(\" Field: \" + field.getName());\n+                 String arrayBrackets = field.isArray() ? \"[]\" : \"\";\n+                 System.out.println(\"  Type: \" + field.getTypeName() + arrayBrackets);\n+                 if (field.getLabel() != null) {\n+                     System.out.println(\"  Label: \" + field.getLabel());\n+                 }\n+                 if (field.getDescription() != null) {\n+                     System.out.println(\"  Description: \" + field.getDescription());\n+                 }\n+                 if (field.getContentType() != null) {\n+                     System.out.println(\"  Content Types: \" + field.getContentType());\n+                 }\n+             }\n+             System.out.println();\n+         }\n+     }\n+\n+     void findTypes(Map<String, List<ValueDescriptor>> typeMap, String typeName, List<ValueDescriptor> fields) {\n+         if (!typeMap.containsKey(typeName)) {\n+             typeMap.put(typeName, fields);\n+             for (ValueDescriptor subField : fields) {\n+                 findTypes(typeMap, subField.getTypeName(), subField.getFields());\n+             }\n+         }\n+     }\n+     \/\/ @end\n+ }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/snippet-files\/Snippets.java","additions":248,"deletions":17,"binary":false,"changes":265,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,0 +95,1 @@\n+                    System.err.println(getMessage(\"compress.warn.argumentdeprecated\", LEVEL_0));\n@@ -99,0 +100,1 @@\n+                    System.err.println(getMessage(\"compress.warn.argumentdeprecated\", LEVEL_1));\n@@ -102,0 +104,1 @@\n+                    System.err.println(getMessage(\"compress.warn.argumentdeprecated\", LEVEL_2));\n@@ -105,0 +108,7 @@\n+                    if (level.length() == 5 && level.startsWith(\"zip-\")) {\n+                        try {\n+                            int zipLevel = Integer.parseInt(level.substring(4));\n+                            zip = new ZipPlugin(resFilter, zipLevel);\n+                            break;\n+                        } catch (NumberFormatException ignored) {}\n+                    }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/DefaultCompressPlugin.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,3 @@\n+    private static final int DEFAULT_COMPRESSION = 6;\n+    private final int compressionLevel;\n+\n@@ -57,0 +60,4 @@\n+        this(predicate, DEFAULT_COMPRESSION);\n+    }\n+\n+    ZipPlugin(Predicate<String> predicate, int compressionLevel) {\n@@ -59,0 +66,1 @@\n+        this.compressionLevel = compressionLevel;\n@@ -76,2 +84,2 @@\n-    static byte[] compress(byte[] bytesIn) {\n-        Deflater deflater = new Deflater();\n+    static byte[] compress(byte[] bytesIn, int compressionLevel) {\n+        Deflater deflater = new Deflater(compressionLevel);\n@@ -107,1 +115,1 @@\n-                compressed = compress(resource.contentBytes());\n+                compressed = compress(resource.contentBytes(), this.compressionLevel);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/ZipPlugin.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-compress.argument=<0|1|2>[:filter=<pattern-list>]\n+compress.argument=<zip-[0-9]>[:filter=<pattern-list>]\n@@ -64,7 +64,1 @@\n-compress.description=\\\n-Compress all resources in the output image.\\n\\\n-Level 0: No compression\\n\\\n-Level 1: Constant string sharing\\n\\\n-Level 2: ZIP.\\n\\\n-An optional <pattern-list> filter can be specified to list the pattern of\\n\\\n-files to be included.\n+compress.description= Compression to use in compressing resources.\n@@ -73,21 +67,9 @@\n-\\  --compress <0|1|2>[:filter=<pattern-list>]\\n\\\n-\\                            Compress all resources in the output image.\\n\\\n-\\                            Level 0: No compression\\n\\\n-\\                            Level 1: Constant string sharing\\n\\\n-\\                            Level 2: ZIP.\\n\\\n-\\                            An optional <pattern-list> filter can be\\n\\\n-\\                            specified to list the pattern of \\n\\\n-\\                            files to be included.\n-\n-compact-cp.argument=<resource paths>\n-\n-compact-cp.description=Constant Pool strings sharing.\\n\\\n-By default, all resources are compressed. You can express the set \\n\\\n-of resources to compress or not compress (use ^ for negation).\n-\n-compact-cp.usage=\\\n-\\ --compact-cp <resource paths>\\n\\\n-\\                             Constant Pool strings sharing.\\n\\\n-\\                             By default, all resources are compressed.\\n\\\n-\\                             You can express the set of resources to\\n\\\n-\\                             compress or not compress (use ^ for negation).\n+\\  --compress <compress>     Compression to use in compressing resources:\\n\\\n+\\                            Accepted values are:\\n\\\n+\\                            zip-[0-9], where zip-0 provides no compression,\\n\\\n+\\                            and zip-9 provides the best compression.\\n\\\n+\\                            Default is zip-6.\n+\n+compress.warn.argumentdeprecated=\\\n+Warning: The {0} argument for --compress is deprecated and may be removed in a future release\n+\n@@ -326,4 +308,9 @@\n-\\  -c, --compress=<0|1|2>                Enable compression of resources:\\n\\\n-\\                                          Level 0: No compression\\n\\\n-\\                                          Level 1: Constant string sharing\\n\\\n-\\                                          Level 2: ZIP\n+\\      --compress <compress>             Compression to use in compressing resources:\\n\\\n+\\                                        Accepted values are:\\n\\\n+\\                                        zip-[0-9], where zip-0 provides no compression,\\n\\\n+\\                                        and zip-9 provides the best compression.\\n\\\n+\\                                        Default is zip-6.\\n\\\n+\\                                        Deprecated values to be removed in a future release:\\n\\\n+\\                                        0:  No compression. Equivalent to zip-0.\\n\\\n+\\                                        1:  Constant String Sharing\\n\\\n+\\                                        2:  Equivalent to zip-6.\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/plugins.properties","additions":20,"deletions":33,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-\n","filename":"src\/jdk.jlink\/share\/classes\/module-info.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include <cstddef>\n@@ -44,0 +45,3 @@\n+    JniObjWithEnv(const std::nullptr_t ptr) : env(ptr), obj(ptr) {\n+    }\n+\n@@ -52,0 +56,8 @@\n+    bool operator == (const std::nullptr_t ptr) const {\n+        return env == ptr || obj == ptr;\n+    }\n+\n+    bool operator != (const std::nullptr_t ptr) const {\n+        return env != ptr && obj != ptr;\n+    }\n+\n","filename":"src\/jdk.jpackage\/windows\/native\/libjpackage\/JniUtils.h","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-    const NMTPreInitAllocation* a = table.find(allocations[i]->payload());\n+    const NMTPreInitAllocation* a = table.find(allocations[i]->payload);\n@@ -89,1 +89,1 @@\n-    NMTPreInitAllocation* a2 = table.find_and_remove(a1->payload());\n+    NMTPreInitAllocation* a2 = table.find_and_remove(a1->payload);\n@@ -100,1 +100,1 @@\n-    const NMTPreInitAllocation* a = table.find(allocations[i]->payload());\n+    const NMTPreInitAllocation* a = table.find(allocations[i]->payload);\n@@ -106,1 +106,1 @@\n-    NMTPreInitAllocation* a = table.find_and_remove(allocations[i]->payload());\n+    NMTPreInitAllocation* a = table.find_and_remove(allocations[i]->payload);\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmtpreinitmap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -167,3 +167,0 @@\n-vmTestbase\/nsk\/stress\/strace\/strace002.java 8288912 macosx-x64,windows-x64\n-vmTestbase\/nsk\/stress\/strace\/strace003.java 8297824 macosx-x64,windows-x64\n-vmTestbase\/nsk\/stress\/strace\/strace004.java 8297824 macosx-x64,windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -150,0 +150,1 @@\n+  compiler\/memoryinitialization\/ZeroTLABTest.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Objects;\n+\n+\/*\n+ * @test\n+ * @summary C2: optimize long range checks in long counted loops\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.irTests.TestTypeSpeculation\n+ *\/\n+\n+public class TestTypeSpeculation {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:TypeProfileLevel=222\");\n+    }\n+\n+    private static final Integer[] testIntegerArray = new Integer[] {42};\n+    private static final Long[] testLongArray = new Long[] {42L};\n+    private static final Double[] testDoubleArray = new Double[] {42.0D};\n+    private static final Integer testInteger = 42;\n+    private static final Long testLong = 42L;\n+    private static final Double testDouble = 42.0D;\n+\n+\n+    @DontInline\n+    public void test1_no_inline() {\n+    }\n+\n+    public void test1_helper(Number[] arg) {\n+        if (arg instanceof Long[]) {\n+            test1_no_inline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CALL, \"= 2\", IRNode.CLASS_CHECK_TRAP, \"= 1\", IRNode.NULL_CHECK_TRAP, \"= 1\"})\n+    public void test1(Number[] array) {\n+        test1_helper(array);\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(10000)\n+    public void test1_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            \/\/ pollute profile\n+            test1_helper(testLongArray);\n+            test1_helper(testDoubleArray);\n+        }\n+        test1(testIntegerArray);\n+    }\n+\n+    @DontInline\n+    public void test2_no_inline() {\n+    }\n+\n+    public void test2_helper(Number arg) {\n+        if (arg instanceof Long) {\n+            test2_no_inline();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.CALL, \"= 2\", IRNode.CLASS_CHECK_TRAP, \"= 1\", IRNode.NULL_CHECK_TRAP, \"= 1\"})\n+    public void test2(Number array) {\n+        test2_helper(array);\n+    }\n+\n+    @Run(test = \"test2\")\n+    @Warmup(10000)\n+    public void test2_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            \/\/ pollute profile\n+            test2_helper(testLong);\n+            test2_helper(testDouble);\n+        }\n+        test2(testInteger);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestTypeSpeculation.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,257 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key randomness\n+ * @bug 8299817\n+ * @summary AES-CTR cipher failure with multiple short (< 16 bytes) update calls.\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbatch\n+ * -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * compiler.codegen.aes.Test8299817\n+ *\/\n+\n+package compiler.codegen.aes;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.whitebox.code.Compiler;\n+import jdk.test.lib.Utils;\n+import jtreg.SkippedException;\n+\n+public class Test8299817 {\n+    private static final String ALGO = \"AES\/CTR\/NoPadding\";\n+    private static final int LOOPS        = 20000;\n+    private static final int WARMUP_LOOPS = 10000;\n+    private static final int LEN_INC   = 5;\n+    private static final int LEN_STEPS = 13;\n+    private static final int LEN_MAX   = LEN_INC*LEN_STEPS;\n+    private static final int SEG_INC   = 3;\n+    private static final int SEG_MAX   = 11;\n+    private static final int SHOW_ARRAY_LIMIT = 72;\n+    private static final boolean DEBUG_MODE = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!DEBUG_MODE) {\n+            if (!Compiler.isIntrinsicAvailable(CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION,\n+                                               \"com.sun.crypto.provider.CounterMode\", \"implCrypt\",\n+                                                byte[].class, int.class, int.class, byte[].class, int.class)\n+               ) {\n+                throw new SkippedException(\"AES-CTR intrinsic is not available\");\n+            }\n+        }\n+\n+        Random random = Utils.getRandomInstance();\n+\n+        \/\/ Create secret key\n+        byte[] keyBytes = new byte[32];\n+        random.nextBytes(keyBytes);\n+        SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n+\n+        \/\/ Create initial counter\n+        byte[] ivBytes = new byte[16];\n+        random.nextBytes(ivBytes);\n+        if (DEBUG_MODE) {\n+            for (int i = 0; i < 16; i++) {\n+                ivBytes[i] = (byte)0;\n+            }\n+            ivBytes[15] = (byte)1;\n+        }\n+        IvParameterSpec iv = new IvParameterSpec(ivBytes);\n+\n+        \/\/ Create cipher objects and initialize\n+        Cipher encryptCipher = Cipher.getInstance(ALGO);\n+        Cipher decryptCipher = Cipher.getInstance(ALGO);\n+\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, key, iv);\n+        decryptCipher.init(Cipher.DECRYPT_MODE, key, iv);\n+\n+        \/\/ Create plaintext, ciphertext, and encrypted counter (reference copy)\n+        byte[] original           = new byte[LEN_MAX];\n+        byte[] original_encrypted = new byte[LEN_MAX];\n+        byte[] counter_encrypted  = new byte[LEN_MAX];\n+        \/\/ Retrieve the encrypted counter\n+        if (DEBUG_MODE) {\n+            for (int i = 0; i < LEN_MAX; i++) {\n+                original[i] = (byte)0;\n+            }\n+            encryptCipher.doFinal(original, 0, LEN_MAX, counter_encrypted);\n+        }\n+        \/\/ Create the encrypted message reference (no JIT, no intrinsic involved)\n+        if (DEBUG_MODE) {\n+            for (int i = 0; i < LEN_MAX; i++) {\n+                original[i] = (byte)i;\n+            }\n+            encryptCipher.doFinal(original, 0, LEN_MAX, original_encrypted);\n+        }\n+        if (DEBUG_MODE) {\n+            showArray(original,           original.length,           \"original:           \");\n+            showArray(original_encrypted, original_encrypted.length, \"original_encrypted: \");\n+            showArray(counter_encrypted,  counter_encrypted.length,  \"counter_encrypted:  \");\n+        }\n+\n+        \/\/ Warmup to have everything compiled\n+        System.out.println(\"Warming up, \" + WARMUP_LOOPS + \" iterations...\");\n+        byte[] work_encrypted = new byte[LEN_MAX];\n+        byte[] work_decrypted = new byte[LEN_MAX];\n+        byte[] varlen         = new byte[LEN_MAX*2];\n+\n+        for (int i = 0; i < WARMUP_LOOPS; i++) {\n+            boolean failed = false;\n+            if (!DEBUG_MODE) {\n+                random.nextBytes(original);\n+            }\n+            encryptCipher.doFinal(original, 0, LEN_MAX, work_encrypted);\n+\n+            random.nextBytes(varlen);\n+            for (int j = 0; j < LEN_MAX; j++) {\n+                int len1 = (varlen[2*j] & 0x0f) + 1;\n+                decryptCipher.update(work_encrypted,   0, len1,         work_decrypted,  0);\n+                for (int k = 0; k < len1; k++) {\n+                    if (original[k] != work_decrypted[k]) {\n+                        if (!failed) {\n+                            failed = true;\n+                            System.out.println(\"-------------------\");\n+                        }\n+                        System.out.println(\"Decrypt failure (warmup, update): LEN(\" +\n+                                           LEN_MAX + \"), iteration (\" + i + \"), k = \" + k);\n+                    }\n+                }\n+                int len2 = (varlen[2*j+1] & 0x0f) + 1;\n+                decryptCipher.update(work_encrypted, len1, len2,         work_decrypted, len1);\n+                for (int k = len1; k < len1+len2; k++) {\n+                    if (original[k] != work_decrypted[k]) {\n+                        if (!failed) {\n+                            failed = true;\n+                            System.out.println(\"-------------------\");\n+                        }\n+                        System.out.println(\"Decrypt failure (warmup, update): LEN(\" +\n+                                           LEN_MAX + \"), iteration (\" + i + \"), k = \" + k);\n+                    }\n+                }\n+                decryptCipher.doFinal(work_encrypted, len1+len2, LEN_MAX-len1-len2, work_decrypted, len1+len2);\n+                for (int k = len1+len2; k < LEN_MAX; k++) {\n+                    if (original[k] != work_decrypted[k]) {\n+                        if (!failed) {\n+                            failed = true;\n+                            System.out.println(\"-------------------\");\n+                        }\n+                        System.out.println(\"Decrypt failure (warmup, doFinal): LEN(\" +\n+                                           LEN_MAX + \"), iteration (\" + i + \"), k = \" + k);\n+                    }\n+                }\n+            }\n+            if (!compareArrays(work_decrypted, original, false)) {\n+                System.out.println(\"Warmup encrypt\/decrypt failure during iteration \" + i + \" of LEN \" + LEN_MAX);\n+                compareArrays(work_decrypted, original, true);\n+                showArray(work_encrypted,    work_encrypted.length,    \"encrypted:\");\n+                showArray(counter_encrypted, counter_encrypted.length, \"ctr_enc:  \");\n+                if (!DEBUG_MODE) {\n+                    System.exit(1);\n+                }\n+            }\n+        }\n+\n+        System.out.println(\"Testing, \" + LOOPS + \" iterations...\");\n+        for (int LEN = 1; LEN < LEN_MAX; LEN += LEN_INC) {\n+            work_encrypted = new byte[LEN];\n+            work_decrypted = new byte[LEN];\n+\n+            for (int i = 0; i < LOOPS; i++) {\n+                boolean failed = false;\n+                random.nextBytes(original);\n+                encryptCipher.doFinal(original, 0, LEN, work_encrypted);\n+\n+                int ix = 0;\n+                for (int SEG = 0; (SEG < SEG_MAX) && (ix + SEG_INC < LEN); SEG++) {\n+                    decryptCipher.update(work_encrypted, ix, SEG_INC, work_decrypted, ix);\n+                    for (int k = ix; k < ix + SEG_INC; k++) {\n+                        if (original[k] != work_decrypted[k]) {\n+                            if (!failed) {\n+                                failed = true;\n+                                System.out.println(\"-------------------\");\n+                            }\n+                            System.out.println(\"Decrypt failure (update): LEN(\" + LEN + \"), iteration \" +\n+                                               i + \", SEG(\" + SEG + \"), SEG_INC(\" + SEG_INC + \"), k = \" + k);\n+                        }\n+                    }\n+                    ix += SEG_INC;\n+                }\n+\n+                decryptCipher.doFinal(work_encrypted, ix, LEN - ix, work_decrypted, ix);\n+                if (!compareArrays(work_decrypted, original, false)) {\n+                    if (!failed) {\n+                        failed = true;\n+                        System.out.println(\"-------------------\");\n+                    }\n+                    System.out.println(\"While decrypting the remaining \" + (LEN - ix) +\n+                                       \"(\" + LEN + \") bytes of CT, iteration \" + i);\n+                    System.out.println(\"Decrypt failure (doFinal): LEN(\" + LEN +\n+                                       \"), SEG_INC(\" + SEG_INC + \"), SEG_MAX(\" + SEG_MAX + \")\");\n+                    showArray(work_encrypted, work_encrypted.length, \"encrypted:\");\n+                    compareArrays(work_decrypted, original, true);\n+                    if (!DEBUG_MODE) {\n+                        System.exit(1);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void showArray(byte b[], int len, String name) {\n+        System.out.format(\"%s [%d]: \", name, b.length);\n+        for (int i = 0; i < Math.min(len, SHOW_ARRAY_LIMIT); i++) {\n+            System.out.format(\"%02x \", b[i] & 0xff);\n+        }\n+        System.out.println();\n+    }\n+\n+    static boolean compareArrays(byte b[], byte exp[], boolean print) {\n+        boolean equal = true;\n+        int len = (b.length <= exp.length) ? b.length : exp.length;\n+        for (int i = 0; i < len; i++) {\n+            equal &= b[i] == exp[i];\n+            if (!equal) {\n+                if (print) {\n+                    System.out.format(\"encrypt\/decrypt error at index %d: got %02x, expected %02x\\n\",\n+                                      i, b[i] & 0xff, exp[i] & 0xff);\n+                    showArray(b,   len, \"result:   \");\n+                    showArray(exp, len, \"expected: \");\n+                }\n+                return equal;\n+            }\n+        }\n+        return equal;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/aes\/Test8299817.java","additions":257,"deletions":0,"binary":false,"changes":257,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,6 @@\n- * @run main\/othervm -Xint compiler.jsr292.methodHandleExceptions.TestAMEnotNPE\n- * @run main\/othervm -Xcomp compiler.jsr292.methodHandleExceptions.TestAMEnotNPE\n+ * @run main\/othervm -Xint\n+ *                   compiler.jsr292.methodHandleExceptions.TestAMEnotNPE\n+ * @run main\/othervm -Xcomp\n+ *                   -XX:CompileCommand=compileonly,p.*::*\n+ *                   -XX:CompileCommand=compileonly,q.*::*\n+ *                   compiler.jsr292.methodHandleExceptions.TestAMEnotNPE\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/methodHandleExceptions\/TestAMEnotNPE.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,0 +58,26 @@\n+    \/\/ Please verify new CPU features before adding them. If we allow non-existent features\n+    \/\/ on this list, we will ignore tests and never execute them. Consult CPU_FEATURE_FLAGS\n+    \/\/ in corresponding vm_version_.hpp file to find correct cpu feature's name.\n+    private static final List<String> verifiedCPUFeatures = new ArrayList<String>( Arrays.asList(\n+        \/\/ x86\n+        \"fma\",\n+        \/\/ Intel SSE\n+        \"sse\",\n+        \"sse2\",\n+        \"sse3\",\n+        \"ssse3\",\n+        \"sse4.1\",\n+        \/\/ Intel AVX\n+        \"avx\",\n+        \"avx2\",\n+        \"avx512\",\n+        \"avx512bw\",\n+        \"avx512dq\",\n+        \"avx512vl\",\n+        \"avx512f\",\n+        \/\/ AArch64\n+        \"sha3\",\n+        \"asimd\",\n+        \"sve\"\n+    ));\n+\n@@ -242,0 +268,5 @@\n+        if (!verifiedCPUFeatures.contains(feature)) {\n+            TestFormat.failNoThrow(\"Provided CPU feature is not in verified list: \" + feature + failAt());\n+            return false;\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class TestInlinedSplitFallInIrreducibleLoopStatus\n+{\n+    public Method \"<init>\":\"()V\"\n+    stack 2 locals 1\n+    {\n+        aload_0;\n+        invokespecial  Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    static Method test_inner:\"(III)V\"\n+    stack 20 locals 10\n+    {\n+        iload_0;\n+        ifeq LEND; \/\/ skip everything at runtime\n+\n+        \/\/ Some knarly construct to have two fall-in edges for LOOP\n+        iconst_1;\n+        ifeq ENTRY1; \/\/ eventually collapses\n+        goto ENTRY2;\n+    ENTRY1:\n+        iconst_0;\n+        ifeq LOOP;\n+    ENTRY2:\n+        iload      1;\n+        ifge LOOP;\n+        goto ENTRY1;\n+\n+    LOOP:\n+        \/\/ split_fall_in happens at this Region\n+        iconst_0;\n+        iflt LOOP;\n+        iload      2;\n+        ifeq LEND;\n+        goto LOOP;\n+\n+    LEND:\n+        return;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestInlinedSplitFallInIrreducibleLoopStatus.jasm","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8303045\n+ * @compile TestInlinedSplitFallInIrreducibleLoopStatus.jasm\n+ * @summary Regions that are inlined are by default tagged as NeverIrreducibleEntry.\n+ *          Test that if a split_fall_in happens to such a region, we do not throw\n+ *          a spurious assert.\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,TestInlinedSplitFallInIrreducibleLoopStatus::test*\n+ *      -XX:CompileCommand=compileonly,TestInlinedSplitFallInIrreducibleLoopStatusMain::test*\n+ *      -Xbatch -XX:PerMethodTrapLimit=0\n+ *      TestInlinedSplitFallInIrreducibleLoopStatusMain\n+ *\/\n+\n+public class TestInlinedSplitFallInIrreducibleLoopStatusMain {\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 10_000; i++) {\n+            test_outer(0, 0, 0);\n+        }\n+    }\n+    static void test_outer(int v0, int v1, int v2) {\n+        \/\/ inline method test_inner\n+        TestInlinedSplitFallInIrreducibleLoopStatus.test_inner(v0, v1, v2);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestInlinedSplitFallInIrreducibleLoopStatusMain.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8301630\n+ * @summary C2: 8297933 broke type speculation in some cases\n+ *\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n+ *                   -XX:TypeProfileLevel=222 -XX:CompileOnly=TestSpeculationBrokenWithIntArrays::testHelper\n+ *                   -XX:CompileOnly=TestSpeculationBrokenWithIntArrays::testHelper2\n+ *                   -XX:CompileOnly=TestSpeculationBrokenWithIntArrays::test TestSpeculationBrokenWithIntArrays\n+ *\n+ *\/\n+\n+public class TestSpeculationBrokenWithIntArrays {\n+    static int[] int_array = new int[10];\n+    static short[] short_array = new short[10];\n+    static byte[] byte_array = new byte[10];\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            testHelper(int_array);\n+            testHelper2(short_array);\n+        }\n+        for (int i = 0; i < 20_000; i++) {\n+            test(int_array);\n+            test(short_array);\n+            test(byte_array);\n+        }\n+    }\n+\n+    private static void test(Object o) {\n+        testHelper(o);\n+        if (o instanceof short[]) {\n+            testHelper2(o);\n+        }\n+    }\n+\n+    private static void testHelper(Object o) {\n+    }\n+\n+    private static void testHelper2(Object o) {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestSpeculationBrokenWithIntArrays.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -305,1 +305,1 @@\n-    @IR(counts = {IRNode.AND_V, \"1\"}, applyIfCPUFeatureOr = {\"sve1\", \"true\", \"avx512\", \"true\"})\n+    @IR(counts = {IRNode.AND_V, \"1\"}, applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx512\", \"true\"})\n@@ -326,1 +326,1 @@\n-    @IR(counts = {IRNode.AND_V, \"1\"}, applyIfCPUFeatureOr = {\"sve1\", \"true\", \"avx512\", \"true\"})\n+    @IR(counts = {IRNode.AND_V, \"1\"}, applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx512\", \"true\"})\n@@ -347,1 +347,1 @@\n-    @IR(counts = {IRNode.AND_V, \"1\"}, applyIfCPUFeatureOr = {\"sve1\", \"true\", \"avx512\", \"true\"})\n+    @IR(counts = {IRNode.AND_V, \"1\"}, applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx512\", \"true\"})\n@@ -569,1 +569,1 @@\n-    @IR(counts = {IRNode.OR_V, \"1\"}, applyIfCPUFeatureOr = {\"sve1\", \"true\", \"avx512\", \"true\"})\n+    @IR(counts = {IRNode.OR_V, \"1\"}, applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx512\", \"true\"})\n@@ -590,1 +590,1 @@\n-    @IR(counts = {IRNode.OR_V, \"1\"}, applyIfCPUFeatureOr = {\"sve1\", \"true\", \"avx512\", \"true\"})\n+    @IR(counts = {IRNode.OR_V, \"1\"}, applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx512\", \"true\"})\n@@ -611,1 +611,1 @@\n-    @IR(counts = {IRNode.OR_V, \"1\"}, applyIfCPUFeatureOr = {\"sve1\", \"true\", \"avx512\", \"true\"})\n+    @IR(counts = {IRNode.OR_V, \"1\"}, applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx512\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorLogicalOpIdentityTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- *   -XX:+G1VerifyRSetsDuringFullGC -XX:+G1VerifyHeapRegionCodeRoots\n+ *   -XX:+G1VerifyHeapRegionCodeRoots\n@@ -57,1 +57,1 @@\n- *   -XX:+G1VerifyRSetsDuringFullGC -XX:+G1VerifyHeapRegionCodeRoots\n+ *   -XX:+G1VerifyHeapRegionCodeRoots\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestVerificationInConcurrentCycle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,4 @@\n+ * @comment Testing compressed class pointers without compressed oops is not possible\n+ *          on MacOS because the heap is given an arbitrary address that occasionally\n+ *          collides with where we would ideally have placed the compressed class space.\n+ * @requires os.family != \"mac\"\n@@ -329,14 +333,6 @@\n-        if (!Platform.isOSX()) {\n-            \/\/ Testing compressed class pointers without compressed oops.\n-            \/\/ This is only possible if the platform supports it. Notably,\n-            \/\/ on macOS, when compressed oops is disabled and the heap is\n-            \/\/ given an arbitrary address, that address occasionally collides\n-            \/\/ with where we would ideally have placed the compressed class\n-            \/\/ space. Therefore, macOS is omitted for now.\n-            smallHeapTestNoCoop();\n-            smallHeapTestWith1GNoCoop();\n-            largeHeapTestNoCoop();\n-            largePagesTestNoCoop();\n-            heapBaseMinAddressTestNoCoop();\n-            sharingTestNoCoop();\n-        }\n+        smallHeapTestNoCoop();\n+        smallHeapTestWith1GNoCoop();\n+        largeHeapTestNoCoop();\n+        largePagesTestNoCoop();\n+        heapBaseMinAddressTestNoCoop();\n+        sharingTestNoCoop();\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassPointers.java","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,7 @@\n+    pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\", \"scale=\"});\n+    output = new OutputAnalyzer(pb.start());\n+    output.shouldContain(\"Incorrect scale value:\");\n+\n+    pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\", \"scale\"});\n+    output = new OutputAnalyzer(pb.start());\n+    output.shouldContain(\"Incorrect scale value: (null)\");\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/JcmdScale.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -176,40 +176,40 @@\n-        String regex = \".*entries: (\\\\d+).*sum bytes: (\\\\d+).*longest chain length: (\\\\d+).*\";\n-        output.shouldMatch(regex);\n-        String line = output.firstMatch(regex, 0);\n-        if (line == null) {\n-            throw new RuntimeException(\"expected: \" + regex);\n-        }\n-        System.out.println(line);\n-        Pattern p = Pattern.compile(regex);\n-        Matcher mat = p.matcher(line);\n-        mat.matches();\n-        int entries = Integer.parseInt(mat.group(1));\n-        int sum_bytes = Integer.parseInt(mat.group(2));\n-        int longest_chain = Integer.parseInt(mat.group(3));\n-        System.out.println(\"found: \" + entries + \" - \" + sum_bytes + longest_chain + \".\");\n-\n-        \/\/ Now we test the state of the internal lookup table, and through our assumptions about\n-        \/\/   early pre-NMT-init allocations:\n-        \/\/ The normal allocation count of surviving pre-init allocations is around 300-500, with the sum of allocated\n-        \/\/   bytes of a few dozen KB. We check these boundaries (with a very generous overhead) to see if the numbers are\n-        \/\/   way off. If they are, we may either have a leak or just a lot more allocations than we thought before\n-        \/\/   NMT initialization. Both cases should be investigated. Even if the allocations are valid, too many of them\n-        \/\/   stretches the limits of the lookup map, and therefore may cause slower lookup. We should then either change\n-        \/\/   the coding, reducing the number of allocations. Or enlarge the lookup table.\n-\n-        \/\/ Apply some sensible assumptions\n-        if (entries > testMode.num_command_line_args + 2000) { \/\/ Note: normal baseline is 400-500\n-            throw new RuntimeException(\"Suspiciously high number of pre-init allocations.\");\n-        }\n-        if (sum_bytes > 128 * 1024 * 1024) { \/\/ Note: normal baseline is ~30-40KB\n-            throw new RuntimeException(\"Suspiciously high pre-init memory usage.\");\n-        }\n-        if (longest_chain > testMode.expected_max_chain_len) {\n-            \/\/ Under normal circumstances, load factor of the map should be about 0.1. With a good hash distribution, we\n-            \/\/ should rarely see even a chain > 1. Warn if we see exceedingly long bucket chains, since this indicates\n-            \/\/ either that the hash algorithm is inefficient or we have a bug somewhere.\n-            throw new RuntimeException(\"Suspiciously long bucket chains in lookup table.\");\n-        }\n-\n-        \/\/ Finally, check that we see our final NMT report:\n-        if (nmtMode != NMTMode.off) {\n+        if (nmtMode != NMTMode.off) { \/\/ in OFF mode LU table is deleted after VM initialization, nothing to see there\n+            String regex = \".*entries: (\\\\d+).*sum bytes: (\\\\d+).*longest chain length: (\\\\d+).*\";\n+            output.shouldMatch(regex);\n+            String line = output.firstMatch(regex, 0);\n+            if (line == null) {\n+                throw new RuntimeException(\"expected: \" + regex);\n+            }\n+            System.out.println(line);\n+            Pattern p = Pattern.compile(regex);\n+            Matcher mat = p.matcher(line);\n+            mat.matches();\n+            int entries = Integer.parseInt(mat.group(1));\n+            int sum_bytes = Integer.parseInt(mat.group(2));\n+            int longest_chain = Integer.parseInt(mat.group(3));\n+            System.out.println(\"found: \" + entries + \" - \" + sum_bytes + longest_chain + \".\");\n+\n+            \/\/ Now we test the state of the internal lookup table, and through our assumptions about\n+            \/\/   early pre-NMT-init allocations:\n+            \/\/ The normal allocation count of surviving pre-init allocations is around 300-500, with the sum of allocated\n+            \/\/   bytes of a few dozen KB. We check these boundaries (with a very generous overhead) to see if the numbers are\n+            \/\/   way off. If they are, we may either have a leak or just a lot more allocations than we thought before\n+            \/\/   NMT initialization. Both cases should be investigated. Even if the allocations are valid, too many of them\n+            \/\/   stretches the limits of the lookup map, and therefore may cause slower lookup. We should then either change\n+            \/\/   the coding, reducing the number of allocations. Or enlarge the lookup table.\n+\n+            \/\/ Apply some sensible assumptions\n+            if (entries > testMode.num_command_line_args + 2000) { \/\/ Note: normal baseline is 400-500\n+                throw new RuntimeException(\"Suspiciously high number of pre-init allocations.\");\n+            }\n+            if (sum_bytes > 128 * 1024 * 1024) { \/\/ Note: normal baseline is ~30-40KB\n+                throw new RuntimeException(\"Suspiciously high pre-init memory usage.\");\n+            }\n+            if (longest_chain > testMode.expected_max_chain_len) {\n+                \/\/ Under normal circumstances, load factor of the map should be about 0.1. With a good hash distribution, we\n+                \/\/ should rarely see even a chain > 1. Warn if we see exceedingly long bucket chains, since this indicates\n+                \/\/ either that the hash algorithm is inefficient or we have a bug somewhere.\n+                throw new RuntimeException(\"Suspiciously long bucket chains in lookup table.\");\n+            }\n+\n+            \/\/ Finally, check that we see our final NMT report:\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/NMTInitializationTest.java","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-            output.shouldMatch(\"Skipping.LambdaContainsOldInfApp[$][$]Lambda[$].*0x.*:.*Old.class.has.been.linked\");\n+            output.shouldMatch(\"Skipping.LambdaContainsOldInfApp[$][$]Lambda.*0x.*:.*Old.class.has.been.linked\");\n@@ -80,1 +80,1 @@\n-                  .shouldMatch(\".class.load. LambdaContainsOldInfApp[$][$]Lambda[$].*\/0x.*source:.*LambdaContainsOldInf\");\n+                  .shouldMatch(\".class.load. LambdaContainsOldInfApp[$][$]Lambda.*\/0x.*source:.*LambdaContainsOldInf\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LambdaContainsOldInf.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-        \".class.load. java.util.stream.Collectors[$][$]Lambda[$].*\/0x.*source:.*java.*util.*stream.*Collectors\";\n+        \".class.load. java.util.stream.Collectors[$][$]Lambda.*\/0x.*source:.*java.*util.*stream.*Collectors\";\n@@ -67,1 +67,1 @@\n-        \".class.load. java.util.stream.Collectors[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\";\n+        \".class.load. java.util.stream.Collectors[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LambdaEagerInit.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-              .shouldMatch(\".class.load. LambdaWithOldClassApp[$][$]Lambda[$].*\/0x.*source:.*shared objects file\")\n+              .shouldMatch(\".class.load. LambdaWithOldClassApp[$][$]Lambda.*\/0x.*source:.*shared objects file\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LambdaWithOldClass.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-        String lambdaInArchive = \"klasses.*=.*app.*Hello[$][$]Lambda[$].*hidden\";\n+        String lambdaInArchive = \"klasses.*=.*app.*Hello[$][$]Lambda.*hidden\";\n@@ -54,1 +54,1 @@\n-        String lambdaLoadFromHello = \".class.load. Hello[$][$]Lambda[$].*\/0x.*source.*Hello\";\n+        String lambdaLoadFromHello = \".class.load. Hello[$][$]Lambda.*\/0x.*source.*Hello\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SignedJar.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-             .shouldMatch(\"class.load.*LambHello[$][$]Lambda[$].*0x.*source:.shared.objects.file\")\n+             .shouldMatch(\"class.load.*LambHello[$][$]Lambda.*0x.*source:.shared.objects.file\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/StaticArchiveWithLambda.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-                output.shouldContain(\"Archiving hidden BasicLambdaApp$$Lambda$\")\n+                output.shouldContain(\"Archiving hidden BasicLambdaApp$$Lambda\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/BasicLambdaTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-                          .shouldMatch(\"Skipping.LambdaContainsOldInfApp[$][$]Lambda[$].*0x.*:.*Old.class.has.been.linked\")\n+                          .shouldMatch(\"Skipping.LambdaContainsOldInfApp[$][$]Lambda.*0x.*:.*Old.class.has.been.linked\")\n@@ -81,1 +81,1 @@\n-                          .shouldMatch(\".class.load. LambdaContainsOldInfApp[$][$]Lambda[$].*\/0x.*source:.*LambdaContainsOldInf\")\n+                          .shouldMatch(\".class.load. LambdaContainsOldInfApp[$][$]Lambda.*\/0x.*source:.*LambdaContainsOldInf\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/LambdaContainsOldInf.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-                output.shouldMatch(\"Skipping.LambHello[$][$]Lambda[$].*0x.*:.Hidden.class\")\n+                output.shouldMatch(\"Skipping.LambHello[$][$]Lambda.*0x.*:.Hidden.class\")\n@@ -62,1 +62,1 @@\n-                output.shouldMatch(\"class.load.*LambHello[$][$]Lambda[$].*0x.*source:.LambHello\")\n+                output.shouldMatch(\"class.load.*LambHello[$][$]Lambda.*0x.*source:.LambHello\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/LambdaCustomLoader.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-                       .shouldMatch(\"Archiving hidden SimpleApp[$][$]Lambda[$][\\\\d+]*\");\n+                       .shouldMatch(\"Archiving hidden SimpleApp[$][$]Lambda\");\n@@ -93,1 +93,1 @@\n-                       .shouldMatch(\".class.load. SimpleApp[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\");\n+                       .shouldMatch(\".class.load. SimpleApp[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file.*(top)\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/LambdaForClassInBaseArchive.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-                       .shouldMatch(\"Archiving hidden LambdaContainsOldInfApp[$][$]Lambda[$][\\\\d+]*\");\n+                       .shouldMatch(\"Archiving hidden LambdaContainsOldInfApp[$][$]Lambda*\");\n@@ -94,1 +94,1 @@\n-                       .shouldMatch(\".class.load. LambdaContainsOldInfApp[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\");\n+                       .shouldMatch(\".class.load. LambdaContainsOldInfApp[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file.*(top)\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/LambdaForOldInfInBaseArchive.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,2 +86,2 @@\n-                      .shouldMatch(\"class.load.*LambHello[$][$]Lambda[$].*0x.*source:.shared.objects.file\")\n-                      .shouldNotMatch(\"class.load.*LambHello[$][$]Lambda[$].*0x.*source:.shared.objects.file.*(top)\");\n+                      .shouldMatch(\"class.load.*LambHello[$][$]Lambda.*0x.*source:.shared.objects.file\")\n+                      .shouldNotMatch(\"class.load.*LambHello[$][$]Lambda.*0x.*source:.shared.objects.file.*(top)\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/LambdaInBaseArchive.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-                output.shouldMatch(\"Skipping.LambdaHello_0x.*[$][$]Lambda[$].*:.Hidden.class\")\n+                output.shouldMatch(\"Skipping.LambdaHello_0x.*[$][$]Lambda.*:.Hidden.class\")\n@@ -71,1 +71,1 @@\n-                      .shouldMatch(\"class.load.*LambdaHello_0x.*[$][$]Lambda[$].*source.*LambdaProxyCallerIsHiddenApp\")\n+                      .shouldMatch(\"class.load.*LambdaHello_0x.*[$][$]Lambda.*source.*LambdaProxyCallerIsHiddenApp\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/LambdaProxyCallerIsHidden.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-                      .shouldMatch(\"class.load.*Outer[$]Inner[$][$]Lambda[$].*0x.*source:.Outer\")\n+                      .shouldMatch(\"class.load.*Outer[$]Inner[$][$]Lambda.*0x.*source:.Outer\")\n@@ -82,1 +82,1 @@\n-                      .shouldMatch(\"class.load.*Outer[$]Inner[$][$]Lambda[$].*0x.*source:.Outer\")\n+                      .shouldMatch(\"class.load.*Outer[$]Inner[$][$]Lambda.*0x.*source:.Outer\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/LambdaProxyDuringShutdown.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-                      .shouldMatch(\".class.load. ChildOldInf[$]InnerChild[$][$]Lambda[$].*\/0x.*source:.ChildOldInf\");\n+                      .shouldMatch(\".class.load. ChildOldInf[$]InnerChild[$][$]Lambda.*\/0x.*source:.ChildOldInf\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/NestHostOldInf.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-                output.shouldContain(\"Archiving hidden NestApp$InnerA$InnerInnerA$$Lambda$\")\n+                output.shouldContain(\"Archiving hidden NestApp$InnerA$InnerInnerA$$Lambda\")\n@@ -72,1 +72,1 @@\n-                output.shouldMatch(\".class.load.* NestApp[$]InnerA[$]InnerInnerA[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\")\n+                output.shouldMatch(\".class.load.* NestApp[$]InnerA[$]InnerInnerA[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file.*(top)\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/NestTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-            \/\/ [info ][class,load] jdk.internal.module.DefaultRoots$$Lambda$1\/0x00007f80c4512048 source: jdk.internal.module.DefaultRoots\n+            \/\/ [info ][class,load] jdk.internal.module.DefaultRoots$$Lambda\/0x00007f80c4512048 source: jdk.internal.module.DefaultRoots\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/NoClassToArchive.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-                output.shouldContain(\"Archiving hidden ParallelLambdaLoad$$Lambda$\")\n+                output.shouldContain(\"Archiving hidden ParallelLambdaLoad$$Lambda\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ParallelLambdaLoadTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-                output.shouldContain(\"Archiving hidden PredicateApp$$Lambda$\")\n+                output.shouldContain(\"Archiving hidden PredicateApp$$Lambda\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/PredicateTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-                              .shouldMatch(\"Skipping.SimpleLambda[$][$]Lambda[$].*0x.*:.*Old.class.has.been.linked\");\n+                              .shouldMatch(\"Skipping.SimpleLambda[$][$]Lambda.*0x.*:.*Old.class.has.been.linked\");\n@@ -97,1 +97,1 @@\n-                          .shouldMatch(\".class.load. SimpleLambda[$][$]Lambda[$].*\/0x.*source:.*SimpleLambda\");\n+                          .shouldMatch(\".class.load. SimpleLambda[$][$]Lambda.*\/0x.*source:.*SimpleLambda\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/RedefineCallerClassTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-                output.shouldContain(\"Archiving hidden HelloStaticInner$InnerHello$$Lambda$\")\n+                output.shouldContain(\"Archiving hidden HelloStaticInner$InnerHello$$Lambda\")\n@@ -66,1 +66,1 @@\n-                      .shouldMatch(\".class.load. HelloStaticInner[$]InnerHello[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\");\n+                      .shouldMatch(\".class.load. HelloStaticInner[$]InnerHello[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file.*(top)\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/StaticInnerTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-                output.shouldContain(\"Archiving hidden UsedAllArchivedLambdasApp$$Lambda$\")\n+                output.shouldContain(\"Archiving hidden UsedAllArchivedLambdasApp$$Lambda\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/UsedAllArchivedLambdas.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-        \".class.load. test.java.lang.invoke.$i[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\";\n+        \".class.load. test.java.lang.invoke.$i[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file.*(top)\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/CDSMHTest_generate.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        \".class.load. test.java.lang.invoke.MethodHandlesAsCollectorTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\";\n+        \".class.load. test.java.lang.invoke.MethodHandlesAsCollectorTest[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file.*(top)\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesAsCollectorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        \".class.load. test.java.lang.invoke.MethodHandlesCastFailureTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\";\n+        \".class.load. test.java.lang.invoke.MethodHandlesCastFailureTest[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file.*(top)\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesCastFailureTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        \".class.load. test.java.lang.invoke.MethodHandlesGeneralTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\";\n+        \".class.load. test.java.lang.invoke.MethodHandlesGeneralTest[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file.*(top)\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesGeneralTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        \".class.load. test.java.lang.invoke.MethodHandlesInvokersTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\";\n+        \".class.load. test.java.lang.invoke.MethodHandlesInvokersTest[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file.*(top)\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesInvokersTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        \".class.load. test.java.lang.invoke.MethodHandlesPermuteArgumentsTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\";\n+        \".class.load. test.java.lang.invoke.MethodHandlesPermuteArgumentsTest[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file.*(top)\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesPermuteArgumentsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        \".class.load. test.java.lang.invoke.MethodHandlesSpreadArgumentsTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file.*(top)\";\n+        \".class.load. test.java.lang.invoke.MethodHandlesSpreadArgumentsTest[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file.*(top)\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/methodHandles\/MethodHandlesSpreadArgumentsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-        \/\/ jdk.internal.loader.BuiltinClassLoader$$Lambda$1\/1816757085\n+        \/\/ jdk.internal.loader.BuiltinClassLoader$$Lambda\/1816757085\n@@ -73,1 +73,1 @@\n-        String class_pattern = \".*Lambda([a-z0-9$]+)\/([0-9]+).*\";\n+        String class_pattern = \".*Lambda\/([0-9]+).*\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/AnonVmClassesDuringDump.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-        output.shouldMatch(\".class.load. test.java.lang.invoke.$i[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.$i[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/CDSMHTest_generate.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesAsCollectorTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesAsCollectorTest[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesAsCollectorTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesCastFailureTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesCastFailureTest[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesCastFailureTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesGeneralTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesGeneralTest[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesGeneralTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesInvokersTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesInvokersTest[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesInvokersTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesPermuteArgumentsTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesPermuteArgumentsTest[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesPermuteArgumentsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesSpreadArgumentsTest[$][$]Lambda[$].*\/0x.*source:.*shared.*objects.*file\")\n+        output.shouldMatch(\".class.load. test.java.lang.invoke.MethodHandlesSpreadArgumentsTest[$][$]Lambda.*\/0x.*source:.*shared.*objects.*file\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/methodHandles\/MethodHandlesSpreadArgumentsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-\/\/    at pkg2.Child$$Lambda$1\/0x0000000800c01000.accept(Unknown Source)\n+\/\/    at pkg2.Child$$Lambda\/0x0000000800c01000.accept(Unknown Source)\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/pkg2\/Child.jcod","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-    \/\/ |--DcmdTestClass$$Lambda$1\/4081552\/0xa529fbb0\n+    \/\/ |--DcmdTestClass$$Lambda\/4081552\/0xa529fbb0\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/ClassHierarchyTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,1 @@\n-                if (name.contains(\"$$Lambda$\") && name.contains(\"App\")) {\n+                if (name.contains(\"$$Lambda\") && name.contains(\"App\")) {\n@@ -196,1 +196,1 @@\n-        \/\/ ModifyAnonymous$InstanceMethodCallSiteApp$$Lambda$18\n+        \/\/ ModifyAnonymous$InstanceMethodCallSiteApp$$Lambda\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/ModifyAnonymous.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-      \/\/ Example: {\"Ljava\/lang\/VirtualThread$VThreadContinuation$$Lambda$31.0x0000000800098340;\"\n+      \/\/ Example: {\"Ljava\/lang\/VirtualThread$VThreadContinuation$$Lambda.0x0000000800098340;\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/get_stack_trace.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-    {\"Ljava\/lang\/VirtualThread$VThreadContinuation$$Lambda$31.0x0000000800098810;\", \"run\", \"()V\"},\n+    {\"Ljava\/lang\/VirtualThread$VThreadContinuation$$Lambda.0x0000000800098810;\", \"run\", \"()V\"},\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr03\/libgetstacktr03.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    \/\/ The IR check should not be applied, since the CPU feature does not exist.\n+    \/\/ The IR check should not be applied, since asimd is aarch64 and sse intel.\n@@ -50,1 +50,1 @@\n-    @IR(applyIfCPUFeature = {\"this-feature-does-not-exist-at-all\", \"true\"},\n+    @IR(applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sse\", \"true\"},\n@@ -54,1 +54,1 @@\n-    \/\/ The IR check should not be applied, since the CPU feature does not exist.\n+    \/\/ The IR check should not be applied, since asimd is aarch64 and sse intel.\n@@ -56,1 +56,1 @@\n-    @IR(applyIfCPUFeature = {\"this-feature-does-not-exist-at-all\", \"true\"},\n+    @IR(applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sse\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPreconditions.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,4 @@\n+    private void complain(String str) {\n+        log.complain(\"EventHandler> \" + str);\n+    }\n+\n@@ -200,1 +204,1 @@\n-                log.complain(\"Exception occured in eventHandler thread: \" + e.getMessage());\n+                complain(\"Exception occured in eventHandler thread: \" + e.getMessage());\n@@ -261,1 +265,1 @@\n-                        log.complain(\"EventHandler>  Unexpected event: \" + event.getClass().getName());\n+                        complain(\"Unexpected event: \" + event);\n@@ -307,1 +311,1 @@\n-                        if (event instanceof VMDisconnectEvent ) {\n+                        if (event instanceof VMDisconnectEvent) {\n@@ -323,1 +327,1 @@\n-         * This listener catches uncaught exceptions and print a message.\n+         * This listener catches uncaught exceptions and prints a message.\n@@ -325,1 +329,1 @@\n-        addListener( new EventListener() {\n+        addListener(new EventListener() {\n@@ -329,10 +333,5 @@\n-                if (event instanceof ExceptionEvent &&\n-                    defaultExceptionRequest != null &&\n-                    defaultExceptionRequest.equals(event.request())) {\n-\n-                    if (EventFilters.filtered(event) == false) {\n-                        log.complain(\"EventHandler>  Unexpected Debuggee Exception: \" +\n-                                     (ExceptionEvent)event);\n-                        defaultExceptionCaught = true;\n-                    }\n-\n+                if (event instanceof ExceptionEvent\n+                        && defaultExceptionRequest != null\n+                        && defaultExceptionRequest.equals(event.request())) {\n+                    complain(\"Unexpected Debuggee Exception: \" + event);\n+                    defaultExceptionCaught = true;\n@@ -371,0 +370,4 @@\n+    private class EventNotification {\n+        volatile Event event;\n+        volatile EventSet set;\n+    }\n@@ -373,1 +376,1 @@\n-     * Returns an event which is received for any of given requests.\n+     * Returns an event which was received for one of the specified requests.\n@@ -375,6 +378,3 @@\n-    public Event waitForRequestedEvent( final EventRequest[] requests,\n-            long timeout,\n-            boolean shouldRemoveListeners) {\n-        class EventNotification {\n-            volatile Event event = null;\n-        }\n+    private EventNotification waitForRequestedEventCommon(final EventRequest[] requests,\n+                                                          long timeout,\n+                                                          boolean shouldRemoveListeners) {\n@@ -383,0 +383,3 @@\n+        \/*\n+         * This listener searches for an Event that matches one of the EventRequests.\n+         *\/\n@@ -384,0 +387,4 @@\n+            public void eventSetReceived(EventSet set) {\n+                en.set = set; \/\/ Save for retrieval when eventReceived() is called.\n+            }\n+\n@@ -385,0 +392,2 @@\n+                EventSet set = en.set;\n+                en.set = null; \/\/ We'll reset it below if the event matches a request.\n@@ -387,1 +396,1 @@\n-                    if (!request.isEnabled())\n+                    if (!request.isEnabled()) {\n@@ -389,0 +398,1 @@\n+                    }\n@@ -390,1 +400,2 @@\n-                        display(\"waitForRequestedEvent: Received event(\" + event + \") for request(\" + request + \")\");\n+                        display(\"waitForRequestedEventCommon: Received event(\" + event +\n+                                \") for request(\" + request + \")\");\n@@ -393,0 +404,1 @@\n+                            en.set = set;\n@@ -402,1 +414,1 @@\n-            display(\"waitForRequestedEvent: enabling remove of listener \" + listener);\n+            display(\"waitForRequestedEventCommon: enabling remove of listener \" + listener);\n@@ -410,0 +422,13 @@\n+        \/*\n+         * This listener logs each EventSet received.\n+         *\/\n+        EventListener eventLogListener = new EventListener() {\n+            public void eventSetReceived(EventSet set) {\n+                display(\"waitForRequestedEventCommon: Received event set: \" + set);\n+            }\n+        };\n+        addListener(eventLogListener);\n+\n+        \/*\n+         * Wait until expected event is recieved.\n+         *\/\n@@ -414,1 +439,1 @@\n-                display(\"waitForRequestedEvent: vm.resume called\");\n+                display(\"waitForRequestedEventCommon: vm.resume called\");\n@@ -417,1 +442,1 @@\n-                while (!isDisconnected() && en.event == null && timeLeft > 0) {\n+                while (!isDisconnected() && en.set == null && timeLeft > 0) {\n@@ -430,0 +455,13 @@\n+        removeListener(eventLogListener);\n+        return en;\n+    }\n+\n+    \/**\n+     * Returns an event which was received for one of the specified requests.\n+     *\/\n+    public Event waitForRequestedEvent(final EventRequest[] requests,\n+                                       long timeout,\n+                                       boolean shouldRemoveListeners)\n+    {\n+        EventNotification en =\n+            waitForRequestedEventCommon(requests, timeout, shouldRemoveListeners);\n@@ -437,1 +475,1 @@\n-     * Returns an event set which is received for any of given requests.\n+     * Returns an event set which was received for one of the specified requests.\n@@ -439,68 +477,6 @@\n-    public EventSet waitForRequestedEventSet( final EventRequest[] requests,\n-            long timeout,\n-            boolean shouldRemoveListeners) {\n-        class EventNotification {\n-            volatile EventSet set = null;\n-        }\n-        final EventNotification en = new EventNotification();\n-\n-        EventListener listener = new EventListener() {\n-            public void eventSetReceived(EventSet set) {\n-\n-                EventIterator eventIterator = set.eventIterator();\n-\n-                while (eventIterator.hasNext()) {\n-\n-                    Event event = eventIterator.nextEvent();\n-\n-                    for (int i = 0; i < requests.length; i++) {\n-                        EventRequest request = requests[i];\n-                        if (!request.isEnabled())\n-                            continue;\n-\n-                        if (request.equals(event.request())) {\n-                            display(\"waitForRequestedEventSet: Received event set for request: \" + request);\n-                            synchronized (EventHandler.this) {\n-                                en.set = set;\n-                                EventHandler.this.notifyAll();\n-                            }\n-                            return;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            public boolean eventReceived(Event event) {\n-                return (en.set != null);\n-            }\n-        };\n-\n-        if (shouldRemoveListeners) {\n-            display(\"waitForRequestedEventSet: enabling remove of listener \" + listener);\n-            listener.enableRemovingThisListener();\n-        }\n-        for (int i = 0; i < requests.length; i++) {\n-            requests[i].enable();\n-        }\n-        addListener(listener);\n-\n-        try {\n-            long timeToFinish = System.currentTimeMillis() + timeout;\n-            long timeLeft = timeout;\n-            synchronized (EventHandler.this) {\n-                display(\"waitForRequestedEventSet: vm.resume called\");\n-                vm.resume();\n-\n-                while (!isDisconnected() && en.set == null && timeLeft > 0) {\n-                    EventHandler.this.wait(timeLeft);\n-                    timeLeft = timeToFinish - System.currentTimeMillis();\n-                }\n-            }\n-        } catch (InterruptedException e) {\n-            return null;\n-        }\n-        if (shouldRemoveListeners && !isDisconnected()) {\n-            for (int i = 0; i < requests.length; i++) {\n-                requests[i].disable();\n-            }\n-        }\n+    public EventSet waitForRequestedEventSet(final EventRequest[] requests,\n+                                             long timeout,\n+                                             boolean shouldRemoveListeners)\n+    {\n+        EventNotification en =\n+            waitForRequestedEventCommon(requests, timeout, shouldRemoveListeners);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/EventHandler.java","additions":73,"deletions":97,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package nsk.stress.strace;\n+\n+public class StraceBase {\n+\n+    private static final String[] EXPECTED_SYSTEM_CLASSES = {\n+            \"java.lang.ClassLoader\",\n+            \"java.lang.System\",\n+            \"java.lang.Object\",\n+            \"java.lang.Thread\",\n+            \"jdk.internal.event.Event\",\n+            \"jdk.internal.event.ThreadSleepEvent\",\n+            \"jdk.internal.misc.Blocker\",\n+            \"jdk.internal.misc.VM\",\n+            \"jdk.internal.vm.StackableScope\",\n+    };\n+\n+    \/**\n+     *   Method verifies that StackTraceElement is sane and might be expected in the current stack.\n+     *\/\n+    final static boolean checkElement(StackTraceElement element) {\n+        String className = element.getClassName();\n+        String methodName = element.getMethodName();\n+        if (className.matches(\"nsk.stress.strace.strace\\\\d\\\\d\\\\dThread\")) {\n+            if (methodName.matches(\"recursiveMethod\\\\d?\")\n+                    || methodName.equals(\"run\")) {\n+                return true;\n+            }\n+            return false;\n+        }\n+        for (var systemClassName : EXPECTED_SYSTEM_CLASSES) {\n+            if (className.equals(systemClassName))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/StraceBase.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,3 +60,1 @@\n- * correct stack frames. Each stack frame must be corresponded to one of the following\n- * methods defined by the <code>EXPECTED_METHODS<\/code> array.<\/p>\n- * <p>These checking are performed <code>REPEAT_COUNT<\/code> times.<\/p>\n+ * correct stack frames.<\/p>\n@@ -64,1 +62,1 @@\n-public class strace001 {\n+public class strace001 extends StraceBase {\n@@ -69,18 +67,0 @@\n-    static final String[] EXPECTED_METHODS = {\n-            \"java.lang.System.arraycopy\",\n-            \"java.lang.Object.wait\",\n-            \"java.lang.Object.wait0\",\n-            \"java.lang.Thread.exit\",\n-            \"java.lang.Thread.yield\",\n-            \"java.lang.Thread.yield0\",\n-            \"java.lang.Thread.clearReferences\",\n-            \"java.lang.Thread.currentCarrierThread\",\n-            \"java.lang.Thread.currentThread\",\n-            \"java.lang.Thread.threadContainer\",\n-            \"jdk.internal.misc.Blocker.begin\",\n-            \"jdk.internal.misc.Blocker.currentCarrierThread\",\n-            \"jdk.internal.misc.Blocker.end\",\n-            \"nsk.stress.strace.strace001Thread.run\",\n-            \"nsk.stress.strace.strace001Thread.recursiveMethod\"\n-    };\n-\n@@ -228,9 +208,0 @@\n-    boolean checkElement(StackTraceElement element) {\n-        String name = element.getClassName() + \".\" + element.getMethodName();\n-        for (int i = 0; i < EXPECTED_METHODS.length; i++) {\n-            if (name.startsWith(EXPECTED_METHODS[i]))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace001.java","additions":3,"deletions":32,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,2 +66,1 @@\n- * correct stack frames. Each stack frame must be corresponded to one of the following\n- * methods defined by the <code>EXPECTED_METHODS<\/code> array.<\/p>\n+ * correct stack frames.<\/p>\n@@ -70,1 +69,1 @@\n-public class strace002 {\n+public class strace002 extends StraceBase {\n@@ -75,18 +74,0 @@\n-    static final String[] EXPECTED_METHODS = {\n-            \"java.lang.System.arraycopy\",\n-            \"java.lang.Object.wait\",\n-            \"java.lang.Object.wait0\",\n-            \"java.lang.Thread.exit\",\n-            \"java.lang.Thread.yield\",\n-            \"java.lang.Thread.yield0\",\n-            \"java.lang.Thread.clearReferences\",\n-            \"java.lang.Thread.currentCarrierThread\",\n-            \"java.lang.Thread.currentThread\",\n-            \"java.lang.Thread.threadContainer\",\n-            \"jdk.internal.misc.Blocker.begin\",\n-            \"jdk.internal.misc.Blocker.currentCarrierThread\",\n-            \"jdk.internal.misc.Blocker.end\",\n-            \"nsk.stress.strace.strace002Thread.run\",\n-            \"nsk.stress.strace.strace002Thread.recursiveMethod\"\n-    };\n-\n@@ -235,9 +216,0 @@\n-    boolean checkElement(StackTraceElement element) {\n-        String name = element.getClassName() + \".\" + element.getMethodName();\n-        for (int i = 0; i < EXPECTED_METHODS.length; i++) {\n-            if (name.startsWith(EXPECTED_METHODS[i]))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace002.java","additions":3,"deletions":31,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -61,3 +61,1 @@\n- * correct stack frames. Each stack frame must be corresponded to one of the following\n- * methods defined by the <code>EXPECTED_METHODS<\/code> array.<\/p>\n- * <p>These checking are performed <code>REPEAT_COUNT<\/code> times.<\/p>\n+ * correct stack frames. <\/p>\n@@ -65,1 +63,1 @@\n-public class strace003 {\n+public class strace003 extends StraceBase {\n@@ -70,22 +68,0 @@\n-    static final String[] EXPECTED_METHODS = {\n-            \"java.lang.System.arraycopy\",\n-            \"java.lang.Object.wait\",\n-            \"java.lang.Object.wait0\",\n-            \"java.lang.System$2.headStackableScope\",\n-            \"java.lang.Thread.headStackableScopes\",\n-            \"java.lang.Thread.exit\",\n-            \"java.lang.Thread.yield\",\n-            \"java.lang.Thread.yield0\",\n-            \"java.lang.Thread.clearReferences\",\n-            \"java.lang.Thread.currentCarrierThread\",\n-            \"java.lang.Thread.currentThread\",\n-            \"java.lang.Thread.threadContainer\",\n-            \"jdk.internal.misc.Blocker.begin\",\n-            \"jdk.internal.misc.Blocker.currentCarrierThread\",\n-            \"jdk.internal.misc.Blocker.end\",\n-            \"jdk.internal.vm.StackableScope.head\",\n-            \"jdk.internal.vm.StackableScope.popAll\",\n-            \"nsk.stress.strace.strace003Thread.run\",\n-            \"nsk.stress.strace.strace003Thread.recursiveMethod\"\n-    };\n-\n@@ -232,9 +208,0 @@\n-    boolean checkElement(StackTraceElement element) {\n-        String name = element.getClassName() + \".\" + element.getMethodName();\n-        for (int i = 0; i < EXPECTED_METHODS.length; i++) {\n-            if (name.startsWith(EXPECTED_METHODS[i]))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace003.java","additions":2,"deletions":35,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -62,3 +62,1 @@\n- * correct stack frames. Each stack frame must be corresponded to one of the following\n- * methods defined by the <code>EXPECTED_METHODS<\/code> array.<\/p>\n- * <p>These checking are performed <code>REPEAT_COUNT<\/code> times.<\/p>\n+ * correct stack frames. <\/p>\n@@ -66,1 +64,1 @@\n-public class strace004 {\n+public class strace004 extends StraceBase {\n@@ -71,22 +69,0 @@\n-    static final String[] EXPECTED_METHODS = {\n-            \"java.lang.System.arraycopy\",\n-            \"java.lang.Object.wait\",\n-            \"java.lang.Object.wait0\",\n-            \"java.lang.System$2.headStackableScope\",\n-            \"java.lang.Thread.headStackableScopes\",\n-            \"java.lang.Thread.exit\",\n-            \"java.lang.Thread.yield\",\n-            \"java.lang.Thread.yield0\",\n-            \"java.lang.Thread.clearReferences\",\n-            \"java.lang.Thread.currentCarrierThread\",\n-            \"java.lang.Thread.currentThread\",\n-            \"java.lang.Thread.threadContainer\",\n-            \"jdk.internal.misc.Blocker.begin\",\n-            \"jdk.internal.misc.Blocker.currentCarrierThread\",\n-            \"jdk.internal.misc.Blocker.end\",\n-            \"jdk.internal.vm.StackableScope.head\",\n-            \"jdk.internal.vm.StackableScope.popAll\",\n-            \"nsk.stress.strace.strace004Thread.run\",\n-            \"nsk.stress.strace.strace004Thread.recursiveMethod\"\n-    };\n-\n@@ -234,9 +210,0 @@\n-    boolean checkElement(StackTraceElement element) {\n-        String name = element.getClassName() + \".\" + element.getMethodName();\n-        for (int i = 0; i < EXPECTED_METHODS.length; i++) {\n-            if (name.startsWith(EXPECTED_METHODS[i]))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace004.java","additions":2,"deletions":35,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,3 +125,1 @@\n- * correct stack frames. Each stack frame must be corresponded to one of the following\n- * methods defined by the <code>EXPECTED_METHODS<\/code> array.<\/p>\n- * <p>These checking are performed <code>REPEAT_COUNT<\/code> times.<\/p>\n+ * correct stack frames.<\/p>\n@@ -129,1 +127,1 @@\n-public class strace005 {\n+public class strace005 extends StraceBase {\n@@ -134,20 +132,0 @@\n-    static final String[] EXPECTED_METHODS = {\n-            \"java.lang.System.arraycopy\",\n-            \"java.lang.Object.wait\",\n-            \"java.lang.Object.wait0\",\n-            \"java.lang.System$2.headStackableScope\",\n-            \"java.lang.Thread.headStackableScopes\",\n-            \"java.lang.Thread.exit\",\n-            \"java.lang.Thread.yield\",\n-            \"java.lang.Thread.yield0\",\n-            \"java.lang.Thread.clearReferences\",\n-            \"java.lang.Thread.currentCarrierThread\",\n-            \"java.lang.Thread.currentThread\",\n-            \"java.lang.Thread.threadContainer\",\n-            \"jdk.internal.vm.StackableScope.head\",\n-            \"jdk.internal.vm.StackableScope.popAll\",\n-            \"nsk.stress.strace.strace005Thread.run\",\n-            \"nsk.stress.strace.strace005Thread.recursiveMethod1\",\n-            \"nsk.stress.strace.strace005Thread.recursiveMethod2\"\n-    };\n-\n@@ -305,9 +283,0 @@\n-    boolean checkElement(StackTraceElement element) {\n-        String name = element.getClassName() + \".\" + element.getMethodName();\n-        for (int i = 0; i < EXPECTED_METHODS.length; i++) {\n-            if (name.startsWith(EXPECTED_METHODS[i]))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace005.java","additions":3,"deletions":34,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,2 +65,1 @@\n- * correct stack frames. Each stack frame must be corresponded to one of the following\n- * methods defined by the <code>expectedMethod<\/code> array.<\/p>\n+ * correct stack frames.<\/p>\n@@ -69,1 +68,1 @@\n-public class strace006 {\n+public class strace006 extends StraceBase {\n@@ -74,19 +73,0 @@\n-    static final String[] EXPECTED_METHODS = {\n-            \"java.lang.System.arraycopy\",\n-            \"java.lang.Object.wait\",\n-            \"java.lang.Object.wait0\",\n-            \"java.lang.System$2.headStackableScope\",\n-            \"java.lang.Thread.headStackableScopes\",\n-            \"java.lang.Thread.exit\",\n-            \"java.lang.Thread.yield\",\n-            \"java.lang.Thread.yield0\",\n-            \"java.lang.Thread.clearReferences\",\n-            \"java.lang.Thread.currentCarrierThread\",\n-            \"java.lang.Thread.currentThread\",\n-            \"java.lang.Thread.threadContainer\",\n-            \"jdk.internal.vm.StackableScope.head\",\n-            \"jdk.internal.vm.StackableScope.popAll\",\n-            \"nsk.stress.strace.strace006Thread.run\",\n-            \"nsk.stress.strace.strace006Thread.recursiveMethod1\",\n-            \"nsk.stress.strace.strace006Thread.recursiveMethod2\"\n-    };\n@@ -247,11 +227,0 @@\n-    boolean checkElement(StackTraceElement element) {\n-        if (element.getClassName().equals(\"java.lang.ClassLoader\"))\n-            return true;\n-        String name = element.getClassName() + \".\" + element.getMethodName();\n-        for (int i = 0; i < EXPECTED_METHODS.length; i++) {\n-            if (name.startsWith(EXPECTED_METHODS[i]))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace006.java","additions":3,"deletions":34,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,4 +63,0 @@\n- * <p>\n- * <p>It is expected that these methods return the same stack traces. Each stack frame\n- * for both stack traces must be corresponded to invocation of one of the methods\n- * defined by the <code>EXPECTED_METHODS<\/code> array.<\/p>\n@@ -68,1 +64,1 @@\n-public class strace007 {\n+public class strace007 extends StraceBase {\n@@ -73,12 +69,0 @@\n-    static final String[] EXPECTED_METHODS = {\n-            \"java.lang.Thread.sleep\",\n-            \"java.lang.Thread.sleep0\",\n-            \"jdk.internal.event.ThreadSleepEvent.<clinit>\",\n-            \"jdk.internal.event.ThreadSleepEvent.isTurnedOn\",\n-            \"jdk.internal.event.ThreadSleepEvent.isEnabled\",\n-            \"java.lang.Thread.currentCarrierThread\",\n-            \"java.lang.Thread.currentThread\",\n-            \"nsk.stress.strace.strace007Thread.run\",\n-            \"nsk.stress.strace.strace007Thread.recursiveMethod\"\n-    };\n-\n@@ -210,9 +194,0 @@\n-    static boolean checkElement(StackTraceElement element) {\n-        String name = element.getClassName() + \".\" + element.getMethodName();\n-        for (int i = 0; i < EXPECTED_METHODS.length; i++) {\n-            if (name.startsWith(EXPECTED_METHODS[i]))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace007.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,3 +67,0 @@\n- * It is expected that these methods return the same stack traces. Each stack frame\n- * for both stack traces must be corresponded to invocation of one of the methods\n- * defined by the <code>EXPECTED_METHODS<\/code> array.<\/p>\n@@ -71,1 +68,1 @@\n-public class strace008 {\n+public class strace008 extends StraceBase {\n@@ -77,11 +74,0 @@\n-    static final String[] EXPECTED_METHODS = {\n-            \"java.lang.Thread.sleep\",\n-            \"java.lang.Thread.sleep0\",\n-            \"jdk.internal.event.ThreadSleepEvent.<clinit>\",\n-            \"jdk.internal.event.ThreadSleepEvent.isTurnedOn\",\n-            \"jdk.internal.event.ThreadSleepEvent.isEnabled\",\n-            \"java.lang.Thread.currentCarrierThread\",\n-            \"java.lang.Thread.currentThread\",\n-            \"nsk.stress.strace.strace008Thread.run\",\n-            \"nsk.stress.strace.strace008Thread.recursiveMethod\"\n-    };\n@@ -214,9 +200,0 @@\n-    static boolean checkElement(StackTraceElement element) {\n-        String name = element.getClassName() + \".\" + element.getMethodName();\n-        for (int i = 0; i < EXPECTED_METHODS.length; i++) {\n-            if (name.startsWith(EXPECTED_METHODS[i]))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace008.java","additions":2,"deletions":25,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,4 +65,0 @@\n- * <p>\n- * It is expected that these methods return the same stack traces. Each stack frame\n- * for both stack traces must be corresponded to invocation of one of the methods\n- * defined by the <code>EXPECTED_METHODS<\/code> array.<\/p>\n@@ -70,1 +66,1 @@\n-public class strace009 {\n+public class strace009 extends StraceBase {\n@@ -76,12 +72,0 @@\n-    static final String[] EXPECTED_METHODS = {\n-            \"java.lang.Thread.sleep\",\n-            \"java.lang.Thread.sleep0\",\n-            \"jdk.internal.event.ThreadSleepEvent.<clinit>\",\n-            \"jdk.internal.event.ThreadSleepEvent.isTurnedOn\",\n-            \"jdk.internal.event.ThreadSleepEvent.isEnabled\",\n-            \"java.lang.Thread.currentCarrierThread\",\n-            \"java.lang.Thread.currentThread\",\n-            \"nsk.stress.strace.strace009Thread.run\",\n-            \"nsk.stress.strace.strace009Thread.recursiveMethod1\",\n-            \"nsk.stress.strace.strace009Thread.recursiveMethod2\"\n-    };\n@@ -214,9 +198,0 @@\n-    static boolean checkElement(StackTraceElement element) {\n-        String name = element.getClassName() + \".\" + element.getMethodName();\n-        for (int i = 0; i < EXPECTED_METHODS.length; i++) {\n-            if (name.startsWith(EXPECTED_METHODS[i]))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace009.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,4 +63,0 @@\n- * <p>\n- * <p>It is expected that these methods return the same stack traces. Each stack frame\n- * for both stack traces must be corresponded to invocation of one of the methods\n- * defined by the <code>EXPECTED_METHODS<\/code> array.<\/p>\n@@ -68,1 +64,1 @@\n-public class strace010 {\n+public class strace010 extends StraceBase {\n@@ -72,11 +68,0 @@\n-    static final String[] EXPECTED_METHODS = {\n-            \"java.lang.Thread.sleep\",\n-            \"java.lang.Thread.sleep0\",\n-            \"jdk.internal.event.ThreadSleepEvent.<clinit>\",\n-            \"jdk.internal.event.ThreadSleepEvent.isTurnedOn\",\n-            \"jdk.internal.event.ThreadSleepEvent.isEnabled\",\n-            \"java.lang.Thread.currentCarrierThread\",\n-            \"java.lang.Thread.currentThread\",\n-            \"nsk.stress.strace.strace010Thread.run\",\n-            \"nsk.stress.strace.strace010Thread.recursiveMethod\"\n-    };\n@@ -232,9 +217,0 @@\n-    boolean checkElement(StackTraceElement element) {\n-        String name = element.getClassName() + \".\" + element.getMethodName();\n-        for (int i = 0; i < EXPECTED_METHODS.length; i++) {\n-            if (name.startsWith(EXPECTED_METHODS[i]))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace010.java","additions":2,"deletions":26,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,3 +65,0 @@\n- * <p>It is expected that these methods return the same stack traces. Each stack frame\n- * for both stack traces must be corresponded to invocation of one of the methods\n- * defined by the <code>EXPECTED_METHODS<\/code> array.<\/p>\n@@ -69,1 +66,1 @@\n-public class strace011 {\n+public class strace011 extends StraceBase {\n@@ -73,11 +70,0 @@\n-    static final String[] EXPECTED_METHODS = {\n-            \"java.lang.Thread.sleep\",\n-            \"java.lang.Thread.sleep0\",\n-            \"jdk.internal.event.ThreadSleepEvent.<clinit>\",\n-            \"jdk.internal.event.ThreadSleepEvent.isTurnedOn\",\n-            \"jdk.internal.event.ThreadSleepEvent.isEnabled\",\n-            \"java.lang.Thread.currentCarrierThread\",\n-            \"java.lang.Thread.currentThread\",\n-            \"nsk.stress.strace.strace011Thread.run\",\n-            \"nsk.stress.strace.strace011Thread.recursiveMethod\"\n-    };\n@@ -233,9 +219,0 @@\n-    boolean checkElement(StackTraceElement element) {\n-        String name = element.getClassName() + \".\" + element.getMethodName();\n-        for (int i = 0; i < EXPECTED_METHODS.length; i++) {\n-            if (name.startsWith(EXPECTED_METHODS[i]))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace011.java","additions":2,"deletions":25,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,4 +67,0 @@\n- * <p>\n- * <p>It is expected that these methods return the same stack traces. Each stack frame\n- * for both stack traces must be corresponded to invocation of one of the methods\n- * defined by the <code>EXPECTED_METHODS<\/code> array.<\/p>\n@@ -72,1 +68,1 @@\n-public class strace012 {\n+public class strace012 extends StraceBase {\n@@ -76,12 +72,0 @@\n-    static final String[] EXPECTED_METHODS = {\n-            \"java.lang.Thread.sleep\",\n-            \"java.lang.Thread.sleep0\",\n-            \"jdk.internal.event.ThreadSleepEvent.<clinit>\",\n-            \"jdk.internal.event.ThreadSleepEvent.isTurnedOn\",\n-            \"jdk.internal.event.ThreadSleepEvent.isEnabled\",\n-            \"java.lang.Thread.currentCarrierThread\",\n-            \"java.lang.Thread.currentThread\",\n-            \"nsk.stress.strace.strace012Thread.run\",\n-            \"nsk.stress.strace.strace012Thread.recursiveMethod1\",\n-            \"nsk.stress.strace.strace012Thread.recursiveMethod2\"\n-    };\n@@ -237,9 +221,0 @@\n-    boolean checkElement(StackTraceElement element) {\n-        String name = element.getClassName() + \".\" + element.getMethodName();\n-        for (int i = 0; i < EXPECTED_METHODS.length; i++) {\n-            if (name.startsWith(EXPECTED_METHODS[i]))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace012.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,8 +58,0 @@\n- * <p>\n- * <p>It is expected that these methods return the same stack traces. Each stack frame\n- * for both stack traces correspond to invocation of one of the methods\n- * defined by the <code>EXPECTED_METHODS<\/code> array.<\/p>\n- *\n- * There is some leeway in the expected stack depth as a thread may not have\n- * reached the native wait0() call when the stacktrace is taken. So we allow\n- * a difference of 3 for the methods: wait(), wait(0), and wait0(0)\n@@ -67,1 +59,1 @@\n-public class strace013 {\n+public class strace013 extends StraceBase {\n@@ -71,6 +63,0 @@\n-    static final String[] EXPECTED_METHODS = {\n-            \"java.lang.Object.wait\", \/\/ two variants\n-            \"java.lang.Object.wait0\",\n-            \"nsk.stress.strace.strace013Thread.run\",\n-            \"nsk.stress.strace.strace013Thread.recursiveMethod\"\n-    };\n@@ -219,9 +205,0 @@\n-    boolean checkElement(StackTraceElement element) {\n-        String name = element.getClassName() + \".\" + element.getMethodName();\n-        for (int i = 0; i < EXPECTED_METHODS.length; i++) {\n-            if (name.startsWith(EXPECTED_METHODS[i]))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace013.java","additions":2,"deletions":25,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,4 +64,0 @@\n- * <p>\n- * <p>It is expected that these methods return the same stack traces. Each stack frame\n- * for both stack traces must be corresponded to invocation of one of the methods\n- * defined by the <code>EXPECTED_METHODS<\/code> array.<\/p>\n@@ -69,1 +65,1 @@\n-public class strace014 {\n+public class strace014 extends StraceBase {\n@@ -73,6 +69,0 @@\n-    static final String[] EXPECTED_METHODS = {\n-            \"java.lang.Object.wait\",\n-            \"java.lang.Object.wait0\",\n-            \"nsk.stress.strace.strace014Thread.run\",\n-            \"nsk.stress.strace.strace014Thread.recursiveMethod\"\n-    };\n@@ -223,9 +213,0 @@\n-    boolean checkElement(StackTraceElement element) {\n-        String name = element.getClassName() + \".\" + element.getMethodName();\n-        for (int i = 0; i < EXPECTED_METHODS.length; i++) {\n-            if (name.startsWith(EXPECTED_METHODS[i]))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace014.java","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,4 +66,0 @@\n- * <p>\n- * <p>It is expected that these methods return the same stack traces. Each stack frame\n- * for both stack traces must be corresponded to invocation of one of the methods\n- * defined by the <code>EXPECTED_METHODS<\/code> array.<\/p>\n@@ -71,1 +67,1 @@\n-public class strace015 {\n+public class strace015 extends StraceBase {\n@@ -75,8 +71,0 @@\n-    static final String[] EXPECTED_METHODS = {\n-            \"java.lang.Object.wait\",\n-            \"java.lang.Object.wait0\",\n-            \"nsk.stress.strace.strace015Thread.run\",\n-            \"nsk.stress.strace.strace015Thread.recursiveMethod1\",\n-            \"nsk.stress.strace.strace015Thread.recursiveMethod2\"\n-    };\n-\n@@ -224,9 +212,0 @@\n-    boolean checkElement(StackTraceElement element) {\n-        String name = element.getClassName() + \".\" + element.getMethodName();\n-        for (int i = 0; i < EXPECTED_METHODS.length; i++) {\n-            if (name.startsWith(EXPECTED_METHODS[i]))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace015.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -742,1 +742,0 @@\n-jdk\/jfr\/event\/os\/TestThreadContextSwitches.java                 8247776 windows-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8193660 8303476\n+ * @summary Check SOURCE line and JAVA_RUNTIME_VERSION in \"release\" file\n+ * @run main CheckReleaseFile\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class CheckReleaseFile {\n+\n+    public static final String SRC_HASH_REGEXP = \":((hg)|(git)):[a-z0-9]*\\\\+?\";\n+\n+    private final boolean isOpenJDK;\n+    CheckReleaseFile(String dataFile, boolean isOpenJDK) {\n+        this.isOpenJDK = isOpenJDK;\n+        \/\/ Read data files\n+        readFile(dataFile);\n+    }\n+\n+    private void readFile(String fileName) {\n+        String fishForSOURCE = null;\n+        String implementor = null;\n+        String runtimeVersion = null;\n+\n+        File file = new File(fileName);\n+\n+        \/\/ open the stream to read in for Entries\n+        try (BufferedReader buffRead =\n+            new BufferedReader(new FileReader(fileName))) {\n+\n+            \/\/ this is the string read\n+            String readIn;\n+\n+            \/\/ let's read some strings!\n+            while ((readIn = buffRead.readLine()) != null) {\n+                readIn = readIn.trim();\n+\n+                \/\/ throw out blank lines\n+                if (readIn.length() == 0)\n+                    continue;\n+\n+                \/\/ grab SOURCE line\n+                if (readIn.startsWith(\"SOURCE=\")) {\n+                    fishForSOURCE = readIn;\n+                    continue;\n+                }\n+\n+                \/\/ grab IMPLEMENTOR line\n+                if (readIn.startsWith(\"IMPLEMENTOR=\")) {\n+                    implementor = readIn;\n+                    continue;\n+                }\n+\n+                \/\/ grab JAVA_RUNTIME_VERSION line\n+                if (readIn.startsWith(\"JAVA_RUNTIME_VERSION=\")) {\n+                    runtimeVersion = readIn;\n+                    continue;\n+                }\n+            }\n+        } catch (FileNotFoundException fileExcept) {\n+            throw new RuntimeException(\"File \" + fileName +\n+                                       \" not found reading data!\", fileExcept);\n+        } catch (IOException ioExcept) {\n+            throw new RuntimeException(\"Unexpected problem reading data!\",\n+                                       ioExcept);\n+        }\n+\n+        \/\/ was SOURCE even found?\n+        if (fishForSOURCE == null) {\n+            throw new RuntimeException(\"SOURCE line was not found!\");\n+        }\n+\n+        \/\/ Check if implementor is Oracle\n+        boolean isOracle = (implementor != null) && implementor.contains(\"Oracle Corporation\");\n+        checkSource(fishForSOURCE, isOracle);\n+\n+        if (runtimeVersion == null) {\n+            throw new RuntimeException(\"JAVA_RUNTIME_VERSION line was not found!\");\n+        }\n+        String expected = \"JAVA_RUNTIME_VERSION=\\\"\" + Runtime.version() + \"\\\"\";\n+        if (!expected.equals(runtimeVersion)) {\n+            throw new RuntimeException(\"Mismatched runtime version: \" +\n+                    runtimeVersion + \" expected: \" + expected);\n+        }\n+    }\n+\n+    private void checkSource(String fishForSOURCE, boolean isOracle) {\n+\n+        System.out.println(\"The source string found: \" + fishForSOURCE);\n+\n+        \/\/ Extract the value of SOURCE=\n+        Pattern valuePattern = Pattern.compile(\"SOURCE=\\\"(.*)\\\"\");\n+        Matcher valueMatcher = valuePattern.matcher(fishForSOURCE);\n+        if (!valueMatcher.matches()) {\n+            throw new RuntimeException(\"SOURCE string has bad format, should be SOURCE=\\\"<value>\\\"\");\n+        }\n+        String valueString = valueMatcher.group(1);\n+\n+\n+        String[] values = valueString.split(\" \");\n+\n+        \/\/ First value MUST start with \".:\" regardless of Oracle or OpenJDK\n+        String rootRegexp = \"\\\\.\" + SRC_HASH_REGEXP;\n+        if (!values[0].matches(rootRegexp)) {\n+            throw new RuntimeException(\"The test failed, first element did not match regexp: \" + rootRegexp);\n+        }\n+\n+        \/\/ If it's an Oracle build, it can be either OpenJDK or OracleJDK. Other\n+        \/\/ builds may have any number of additional elements in any format.\n+        if (isOracle) {\n+            if (isOpenJDK) {\n+                if (values.length != 1) {\n+                    throw new RuntimeException(\"The test failed, wrong number of elements in SOURCE list.\" +\n+                            \" Should be 1 for Oracle built OpenJDK.\");\n+                }\n+            } else {\n+                if (values.length != 2) {\n+                    throw new RuntimeException(\"The test failed, wrong number of elements in SOURCE list.\" +\n+                            \" Should be 2 for OracleJDK.\");\n+                }\n+                \/\/ Second value MUST start with \"open:\" for OracleJDK\n+                String openRegexp = \"open\" + SRC_HASH_REGEXP;\n+                if (!values[1].matches(openRegexp)) {\n+                    throw new RuntimeException(\"The test failed, second element did not match regexp: \" + openRegexp);\n+                }\n+            }\n+        }\n+\n+        \/\/ Everything was fine\n+        System.out.println(\"The test passed!\");\n+    }\n+\n+    public static void main(String args[]) {\n+        String jdkPath = System.getProperty(\"test.jdk\");\n+        String runtime = System.getProperty(\"java.runtime.name\");\n+\n+        System.out.println(\"JDK Path : \" + jdkPath);\n+        System.out.println(\"Runtime Name : \" + runtime);\n+\n+        new CheckReleaseFile(jdkPath + \"\/release\", runtime.contains(\"OpenJDK\"));\n+    }\n+}\n","filename":"test\/jdk\/build\/releaseFile\/CheckReleaseFile.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -1,149 +0,0 @@\n-\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8193660\n- * @summary Check SOURCE line in \"release\" file for closedjdk\n- * @run main CheckSource\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.File;\n-import java.io.FileReader;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-public class CheckSource {\n-\n-    public static final String SRC_HASH_REGEXP = \":((hg)|(git)):[a-z0-9]*\\\\+?\";\n-\n-    CheckSource(String dataFile, boolean isOpenJDK) {\n-        \/\/ Read data files\n-        readFile(dataFile, isOpenJDK);\n-    }\n-\n-    private void readFile(String fileName, boolean isOpenJDK) {\n-        String fishForSOURCE = null;\n-        String implementor = null;\n-\n-        File file = new File(fileName);\n-\n-        \/\/ open the stream to read in for Entries\n-        try (BufferedReader buffRead =\n-            new BufferedReader(new FileReader(fileName))) {\n-\n-            \/\/ this is the string read\n-            String readIn;\n-\n-            \/\/ let's read some strings!\n-            while ((readIn = buffRead.readLine()) != null) {\n-                readIn = readIn.trim();\n-\n-                \/\/ throw out blank lines\n-                if (readIn.length() == 0)\n-                    continue;\n-\n-                \/\/ grab SOURCE line\n-                if (readIn.startsWith(\"SOURCE=\")) {\n-                    fishForSOURCE = readIn;\n-                    continue;\n-                }\n-\n-                \/\/ grab IMPLEMENTOR line\n-                if (readIn.startsWith(\"IMPLEMENTOR=\")) {\n-                    implementor = readIn;\n-                    continue;\n-                }\n-            }\n-        } catch (FileNotFoundException fileExcept) {\n-            throw new RuntimeException(\"File \" + fileName +\n-                                       \" not found reading data!\", fileExcept);\n-        } catch (IOException ioExcept) {\n-            throw new RuntimeException(\"Unexpected problem reading data!\",\n-                                       ioExcept);\n-        }\n-\n-        \/\/ was SOURCE even found?\n-        if (fishForSOURCE == null) {\n-            throw new RuntimeException(\"SOURCE line was not found!\");\n-        }\n-        System.out.println(\"The source string found: \" + fishForSOURCE);\n-\n-        \/\/ Extract the value of SOURCE=\n-        Pattern valuePattern = Pattern.compile(\"SOURCE=\\\"(.*)\\\"\");\n-        Matcher valueMatcher = valuePattern.matcher(fishForSOURCE);\n-        if (!valueMatcher.matches()) {\n-            throw new RuntimeException(\"SOURCE string has bad format, should be SOURCE=\\\"<value>\\\"\");\n-        }\n-        String valueString = valueMatcher.group(1);\n-\n-        \/\/ Check if implementor is Oracle\n-        boolean isOracle = (implementor != null) && implementor.contains(\"Oracle Corporation\");\n-\n-        String[] values = valueString.split(\" \");\n-\n-        \/\/ First value MUST start with \".:\" regardless of Oracle or OpenJDK\n-        String rootRegexp = \"\\\\.\" + SRC_HASH_REGEXP;\n-        if (!values[0].matches(rootRegexp)) {\n-            throw new RuntimeException(\"The test failed, first element did not match regexp: \" + rootRegexp);\n-        }\n-\n-        \/\/ If it's an Oracle build, it can be either OpenJDK or OracleJDK. Other\n-        \/\/ builds may have any number of additional elements in any format.\n-        if (isOracle) {\n-            if (isOpenJDK) {\n-                if (values.length != 1) {\n-                    throw new RuntimeException(\"The test failed, wrong number of elements in SOURCE list.\" +\n-                            \" Should be 1 for Oracle built OpenJDK.\");\n-                }\n-            } else {\n-                if (values.length != 2) {\n-                    throw new RuntimeException(\"The test failed, wrong number of elements in SOURCE list.\" +\n-                            \" Should be 2 for OracleJDK.\");\n-                }\n-                \/\/ Second value MUST start with \"open:\" for OracleJDK\n-                String openRegexp = \"open\" + SRC_HASH_REGEXP;\n-                if (!values[1].matches(openRegexp)) {\n-                    throw new RuntimeException(\"The test failed, second element did not match regexp: \" + openRegexp);\n-                }\n-            }\n-        }\n-\n-        \/\/ Everything was fine\n-        System.out.println(\"The test passed!\");\n-    }\n-\n-    public static void main(String args[]) {\n-        String jdkPath = System.getProperty(\"test.jdk\");\n-        String runtime = System.getProperty(\"java.runtime.name\");\n-\n-        System.out.println(\"JDK Path : \" + jdkPath);\n-        System.out.println(\"Runtime Name : \" + runtime);\n-\n-        new CheckSource(jdkPath + \"\/release\", runtime.contains(\"OpenJDK\"));\n-    }\n-}\n","filename":"test\/jdk\/build\/releaseFile\/CheckSource.java","additions":0,"deletions":149,"binary":false,"changes":149,"status":"deleted"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.foreign.GroupLayout;\n@@ -38,0 +39,2 @@\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -50,0 +53,1 @@\n+import static org.testng.Assert.*;\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -522,1 +522,1 @@\n-                if (serialClass.getName().contains(\"$$Lambda$\")) {\n+                if (serialClass.getName().contains(\"$$Lambda\")) {\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build Tests\n+ * @run main SqrtTests\n+ * @bug 8302040\n+ * @summary Tests for {Math, StrictMath}.sqrt\n+ *\/\n+\n+public class SqrtTests {\n+    private SqrtTests(){}\n+\n+    public static void main(String... argv) {\n+        int failures = 0;\n+\n+        failures += testSqrt();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing sqrt incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static final double InfinityD = Double.POSITIVE_INFINITY;\n+    private static final double NaNd      = Double.NaN;\n+\n+    \/**\n+     * \"Returns the correctly rounded positive square root of a double value. Special cases:\n+     *\n+     * If the argument is NaN or less than zero, then the result is NaN.\n+     *\n+     * If the argument is positive infinity, then the result is positive infinity.\n+     *\n+     * If the argument is positive zero or negative zero, then the\n+     * result is the same as the argument.\n+     *\n+     * Otherwise, the result is the double value closest to the true\n+     * mathematical square root of the argument value.\"\n+     *\/\n+    private static int testSqrt() {\n+        int failures = 0;\n+\n+        for(double nan : Tests.NaNs) {\n+            failures += testSqrtCase(nan, NaNd);\n+        }\n+\n+        double [][] testCases = {\n+            {InfinityD,               InfinityD},\n+\n+            {-Double.MIN_VALUE,       NaNd},\n+            {-Double.MIN_NORMAL,      NaNd},\n+            {-Double.MAX_VALUE,       NaNd},\n+            {-InfinityD,              NaNd},\n+\n+            {+0.0,                   +0.0},\n+            {-0.0,                   -0.0},\n+\n+            \/\/ Test some notable perfect squares\n+            {+0.25,                   +0.5},\n+            {+1.0,                    +1.0},\n+            {+4.0,                    +2.0},\n+            {+9.0,                    +3.0},\n+            {+0x1.ffffff0000002p1023, +0x1.ffffff8p511}\n+        };\n+\n+        for(int i = 0; i < testCases.length; i++) {\n+            failures += testSqrtCase(testCases[i][0], testCases[i][1]);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testSqrtCase(double input, double expected) {\n+        int failures=0;\n+\n+        failures+=Tests.test(\"Math.sqrt\",        input, Math::sqrt,        expected);\n+        failures+=Tests.test(\"StrictMath.sqrt\",  input, StrictMath::sqrt,  expected);\n+\n+        return failures;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Math\/SqrtTests.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-        if (cn.contains(\"$$Lambda$\")) {\n+        if (cn.contains(\"$$Lambda\")) {\n","filename":"test\/jdk\/java\/lang\/StackWalker\/HiddenFrames.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,1 +131,1 @@\n-            \"2: VerifyStackTrace$$Lambda$1\/0x0000000801001848.run(Unknown Source)\\n\" +\n+            \"2: VerifyStackTrace$$Lambda\/0x0000000801001848.run(Unknown Source)\\n\" +\n","filename":"test\/jdk\/java\/lang\/StackWalker\/VerifyStackTrace.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8301833 8302026 8301444 8302028\n+ * @bug 8301833 8302026 8301444 8302028 8302040\n@@ -69,1 +69,5 @@\n-         \/\/ new UnaryTestCase(\"sqrt\",  FdlibmTranslit::sqrt,  StrictMath::sqrt,  DEFAULT_SHIFT),\n+            \/\/ Since sqrt is correctly rounded and thus for each input\n+            \/\/ there is one well-defined correct result, additional\n+            \/\/ comparison of the transliteration sqrt or StrictMath\n+            \/\/ sqrt could be made against Math::sqrt.\n+            new UnaryTestCase(\"sqrt\",  FdlibmTranslit::sqrt,  StrictMath::sqrt,  DEFAULT_SHIFT),\n","filename":"test\/jdk\/java\/lang\/StrictMath\/ExhaustingTests.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -93,0 +93,4 @@\n+    public static double sqrt(double x) {\n+        return Sqrt.compute(x);\n+    }\n+\n@@ -507,0 +511,172 @@\n+    \/**\n+     * Return correctly rounded sqrt.\n+     *           ------------------------------------------\n+     *           |  Use the hardware sqrt if you have one |\n+     *           ------------------------------------------\n+     * Method:\n+     *   Bit by bit method using integer arithmetic. (Slow, but portable)\n+     *   1. Normalization\n+     *      Scale x to y in [1,4) with even powers of 2:\n+     *      find an integer k such that  1 <= (y=x*2^(2k)) < 4, then\n+     *              sqrt(x) = 2^k * sqrt(y)\n+     *   2. Bit by bit computation\n+     *      Let q  = sqrt(y) truncated to i bit after binary point (q = 1),\n+     *           i                                                   0\n+     *                                     i+1         2\n+     *          s  = 2*q , and      y  =  2   * ( y - q  ).         (1)\n+     *           i      i            i                 i\n+     *\n+     *      To compute q    from q , one checks whether\n+     *                  i+1       i\n+     *\n+     *                            -(i+1) 2\n+     *                      (q + 2      ) <= y.                     (2)\n+     *                        i\n+     *                                                            -(i+1)\n+     *      If (2) is false, then q   = q ; otherwise q   = q  + 2      .\n+     *                             i+1   i             i+1   i\n+     *\n+     *      With some algebraic manipulation, it is not difficult to see\n+     *      that (2) is equivalent to\n+     *                             -(i+1)\n+     *                      s  +  2       <= y                      (3)\n+     *                       i                i\n+     *\n+     *      The advantage of (3) is that s  and y  can be computed by\n+     *                                    i      i\n+     *      the following recurrence formula:\n+     *          if (3) is false\n+     *\n+     *          s     =  s  ,       y    = y   ;                    (4)\n+     *           i+1      i          i+1    i\n+     *\n+     *          otherwise,\n+     *                         -i                     -(i+1)\n+     *          s     =  s  + 2  ,  y    = y  -  s  - 2             (5)\n+     *           i+1      i          i+1    i     i\n+     *\n+     *      One may easily use induction to prove (4) and (5).\n+     *      Note. Since the left hand side of (3) contain only i+2 bits,\n+     *            it does not necessary to do a full (53-bit) comparison\n+     *            in (3).\n+     *   3. Final rounding\n+     *      After generating the 53 bits result, we compute one more bit.\n+     *      Together with the remainder, we can decide whether the\n+     *      result is exact, bigger than 1\/2ulp, or less than 1\/2ulp\n+     *      (it will never equal to 1\/2ulp).\n+     *      The rounding mode can be detected by checking whether\n+     *      huge + tiny is equal to huge, and whether huge - tiny is\n+     *      equal to huge for some floating point number \"huge\" and \"tiny\".\n+     *\n+     * Special cases:\n+     *      sqrt(+-0) = +-0         ... exact\n+     *      sqrt(inf) = inf\n+     *      sqrt(-ve) = NaN         ... with invalid signal\n+     *      sqrt(NaN) = NaN         ... with invalid signal for signaling NaN\n+     *\n+     * Other methods : see the appended file at the end of the program below.\n+     *---------------\n+     *\/\n+    static class Sqrt {\n+        private static final double    one     = 1.0, tiny=1.0e-300;\n+\n+        public static double compute(double x) {\n+            double z = 0.0;\n+            int     sign = (int)0x80000000;\n+            \/*unsigned*\/ int r,t1,s1,ix1,q1;\n+            int ix0,s0,q,m,t,i;\n+\n+            ix0 = __HI(x);                  \/* high word of x *\/\n+            ix1 = __LO(x);          \/* low word of x *\/\n+\n+            \/* take care of Inf and NaN *\/\n+            if((ix0&0x7ff00000)==0x7ff00000) {\n+                return x*x+x;               \/* sqrt(NaN)=NaN, sqrt(+inf)=+inf\n+                                               sqrt(-inf)=sNaN *\/\n+            }\n+            \/* take care of zero *\/\n+            if(ix0<=0) {\n+                if(((ix0&(~sign))|ix1)==0) return x;\/* sqrt(+-0) = +-0 *\/\n+                else if(ix0<0)\n+                    return (x-x)\/(x-x);             \/* sqrt(-ve) = sNaN *\/\n+            }\n+            \/* normalize x *\/\n+            m = (ix0>>20);\n+            if(m==0) {                              \/* subnormal x *\/\n+                while(ix0==0) {\n+                    m -= 21;\n+                    ix0 |= (ix1>>>11); ix1 <<= 21; \/\/ unsigned shift\n+                }\n+                for(i=0;(ix0&0x00100000)==0;i++) ix0<<=1;\n+                m -= i-1;\n+                ix0 |= (ix1>>>(32-i)); \/\/ unsigned shift\n+                ix1 <<= i;\n+            }\n+            m -= 1023;      \/* unbias exponent *\/\n+            ix0 = (ix0&0x000fffff)|0x00100000;\n+            if((m&1) != 0){        \/* odd m, double x to make it even *\/\n+                ix0 += ix0 + ((ix1&sign)>>>31); \/\/ unsigned shift\n+                ix1 += ix1;\n+            }\n+            m >>= 1;        \/* m = [m\/2] *\/\n+\n+            \/* generate sqrt(x) bit by bit *\/\n+            ix0 += ix0 + ((ix1&sign)>>>31); \/\/ unsigned shift\n+            ix1 += ix1;\n+            q = q1 = s0 = s1 = 0;   \/* [q,q1] = sqrt(x) *\/\n+            r = 0x00200000;         \/* r = moving bit from right to left *\/\n+\n+            while(r!=0) {\n+                t = s0+r;\n+                if(t<=ix0) {\n+                    s0   = t+r;\n+                    ix0 -= t;\n+                    q   += r;\n+                }\n+                ix0 += ix0 + ((ix1&sign)>>>31); \/\/ unsigned shift\n+                ix1 += ix1;\n+                r>>>=1; \/\/ unsigned shift\n+            }\n+\n+            r = sign;\n+            while(r!=0) {\n+                t1 = s1+r;\n+                t  = s0;\n+                if((t<ix0)||((t==ix0)&&(Integer.compareUnsigned(t1, ix1) <= 0 ))) { \/\/ t1<=ix1\n+                    s1  = t1+r;\n+                    if(((t1&sign)==sign)&&(s1&sign)==0) s0 += 1;\n+                    ix0 -= t;\n+                    if (Integer.compareUnsigned(ix1, t1) < 0) ix0 -= 1; \/\/ ix1 < t1\n+                    ix1 -= t1;\n+                    q1  += r;\n+                }\n+                ix0 += ix0 + ((ix1&sign)>>>31); \/\/ unsigned shift\n+                ix1 += ix1;\n+                r>>>=1; \/\/ unsigned shift\n+            }\n+\n+            \/* use floating add to find out rounding direction *\/\n+            if((ix0|ix1)!=0) {\n+                z = one-tiny; \/* trigger inexact flag *\/\n+                if (z>=one) {\n+                    z = one+tiny;\n+                    if (q1==0xffffffff) { q1=0; q += 1;}\n+                    else if (z>one) {\n+                        if (q1==0xfffffffe) q+=1;\n+                        q1+=2;\n+                    } else\n+                        q1 += (q1&1);\n+                }\n+            }\n+            ix0 = (q>>1)+0x3fe00000;\n+            ix1 =  q1>>>1; \/\/ unsigned shift\n+            if ((q&1)==1) ix1 |= sign;\n+            ix0 += (m <<20);\n+            \/\/ __HI(z) = ix0;\n+            z = __HI(z, ix0);\n+            \/\/ __LO(z) = ix1;\n+            z = __LO(z, ix1);\n+            return z;\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StrictMath\/FdlibmTranslit.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302040\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @build Tests\n+ * @build FdlibmTranslit\n+ * @build SqrtTests\n+ * @run main SqrtTests\n+ * @summary Tests for StrictMath.sqrt\n+ *\/\n+import jdk.test.lib.RandomFactory;\n+\n+\/**\n+ * The tests in ..\/Math\/SqrtTests.java test properties that should\n+ * hold for any sqrt implementation, including the FDLIBM-based one\n+ * required for StrictMath.sqrt.  Therefore, the test cases in\n+ * ..\/Math\/SqrtTests.java are run against both the Math and\n+ * StrictMath versions of sqrt.  The role of this test is to verify\n+ * that the FDLIBM sqrt algorithm is being used by running golden\n+ * file tests on values that may vary from one conforming sqrt\n+ * implementation to another.\n+ *\/\n+\n+public class SqrtTests {\n+    private SqrtTests(){}\n+\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testAgainstTranslit();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing sqrt incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    \/\/ Initialize shared random number generator\n+    private static java.util.Random random = RandomFactory.getRandom();\n+\n+    \/**\n+     * Test StrictMath.sqrt against transliteration port of sqrt.\n+     *\/\n+    private static int testAgainstTranslit() {\n+        int failures = 0;\n+        double x;\n+\n+        \/\/ Test just above subnormal threshold...\n+        x = Double.MIN_NORMAL;\n+        failures += testRange(x, Math.ulp(x), 1000);\n+\n+        \/\/ ... and just below subnormal threshold ...\n+        x = Math.nextDown(Double.MIN_NORMAL);\n+        failures += testRange(x, -Math.ulp(x), 1000);\n+\n+        \/\/ ... and near 1.0 ...\n+        failures += testRangeMidpoint(1.0, Math.ulp(x), 2000);\n+        \/\/ (Note: probes every-other value less than 1.0 due to\n+        \/\/ change in the size of an ulp at 1.0.\n+\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+            Double.MIN_VALUE,\n+            Double.MAX_VALUE,\n+        };\n+\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000);\n+        }\n+\n+        x = Tests.createRandomDouble(random);\n+\n+        \/\/ Make the increment twice the ulp value in case the random\n+        \/\/ value is near an exponent threshold. Don't worry about test\n+        \/\/ elements overflowing to infinity if the starting value is\n+        \/\/ near Double.MAX_VALUE.\n+        failures += testRange(x, 2.0 * Math.ulp(x), 1000);\n+\n+        return failures;\n+    }\n+\n+    private static int testRange(double start, double increment, int count) {\n+        int failures = 0;\n+        double x = start;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testSqrtCase(x, FdlibmTranslit.sqrt(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testRangeMidpoint(double midpoint, double increment, int count) {\n+        int failures = 0;\n+        double x = midpoint - increment*(count \/ 2) ;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testSqrtCase(x, FdlibmTranslit.sqrt(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testSqrtCase(double input, double expected) {\n+        return Tests.test(\"StrictMath.sqrt(double)\", input,\n+                          StrictMath::sqrt, expected);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/StrictMath\/SqrtTests.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n@@ -31,1 +33,1 @@\n- * @bug 8077559 8248655\n+ * @bug 8077559 8248655 8302871\n@@ -78,0 +80,27 @@\n+\n+    \/**\n+     * Exhaustively check that all 256x256 latin1 code point pairs are equalsIgnoreCased\n+     * in a manner consistent with Character.toLowerCase(Character.toUpperCase(c));\n+     *\/\n+    @Test\n+    public void checkConsistencyWithCharacterUppercaseLowerCase() {\n+        for (char a = 0; a < 256; a++) {\n+            for (char b = 0; b < 256; b++) {\n+\n+                int caseFoldA = Character.toLowerCase(Character.toUpperCase(a));\n+                int caseFoldB = Character.toLowerCase(Character.toUpperCase(b));\n+\n+                String astr = Character.toString(a);\n+                String bstr = Character.toString(b);\n+\n+                \/\/ If characters fold to the same lowercase, their strings should equalsIgnoreCase:\n+                if (caseFoldA == caseFoldB) {\n+                    assertTrue(astr.equalsIgnoreCase(bstr),\n+                            \"Expected %s to equalsIgnoreCase %s\".formatted(astr, bstr));\n+                } else {\n+                    assertFalse(astr.equalsIgnoreCase(bstr),\n+                            \"Expected %s to not equalsIgnoreCase %s\".formatted(astr, bstr));\n+                }\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/String\/CompactString\/EqualsIgnoreCase.java","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,1 +165,1 @@\n-            assertTrue(cn.startsWith(LambdaTest.class.getName() + \"$$Lambda$\"), caller + \" should be a lambda proxy class\");\n+            assertTrue(cn.startsWith(LambdaTest.class.getName() + \"$$Lambda\"), caller + \" should be a lambda proxy class\");\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/csm\/jdk\/test\/MethodInvokeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,1 +139,1 @@\n-                \"A$I$$Lambda$*.class\")) {\n+                \"A$I$$Lambda.*.class\")) {\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaAsm.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-            \/\/  at LambdaStackTrace$$Lambda$1\/1937396743.run(<Unknown>:1000000)\n+            \/\/  at LambdaStackTrace$$Lambda\/1937396743.run(<Unknown>:1000000)\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaStackTrace.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @run main\/othervm DatagramSocketMulticasting\n- * @run main\/othervm -Djava.net.preferIPv4Stack=true DatagramSocketMulticasting\n+ * @run junit\/othervm DatagramSocketMulticasting\n+ * @run junit\/othervm -Djava.net.preferIPv4Stack=true DatagramSocketMulticasting\n@@ -51,0 +51,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -60,0 +61,3 @@\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.assumeTrue;\n+\n@@ -62,0 +66,1 @@\n+    static final int MAX_TRIES = 3;\n@@ -63,2 +68,3 @@\n-    public static void main(String[] args) throws IOException {\n-        IPSupport.throwSkippedExceptionIfNonOperational();\n+    @Test\n+    public void main() throws IOException {\n+        assumeTrue(IPSupport.currentConfigurationIsValid(), \"Invalid networking configuration\");\n@@ -135,1 +141,1 @@\n-        assertTrue(s.getOption(IP_MULTICAST_IF) == null);\n+        assertNull(s.getOption(IP_MULTICAST_IF));\n@@ -141,1 +147,1 @@\n-        assertTrue(s.getOption(IP_MULTICAST_IF) == null);\n+        assertNull(s.getOption(IP_MULTICAST_IF));\n@@ -158,1 +164,1 @@\n-        assertTrue(s.getOption(IP_MULTICAST_IF) == null);\n+        assertNull(s.getOption(IP_MULTICAST_IF));\n@@ -235,1 +241,1 @@\n-        assertTrue(s.getOption(IP_MULTICAST_IF) == null);\n+        assertNull(s.getOption(IP_MULTICAST_IF));\n@@ -254,1 +260,1 @@\n-        assertTrue(s.getOption(IP_MULTICAST_TTL) == 1);\n+        assertEquals(1, s.getOption(IP_MULTICAST_TTL));\n@@ -259,1 +265,1 @@\n-            assertTrue(s.getOption(IP_MULTICAST_TTL) == ttl);\n+            assertEquals(ttl, s.getOption(IP_MULTICAST_TTL));\n@@ -276,1 +282,1 @@\n-        assertTrue(s.getOption(IP_MULTICAST_LOOP) == true);\n+        assertTrue(s.getOption(IP_MULTICAST_LOOP));\n@@ -282,1 +288,1 @@\n-        assertTrue(s.getOption(IP_MULTICAST_LOOP) == false);\n+        assertFalse(s.getOption(IP_MULTICAST_LOOP));\n@@ -284,1 +290,1 @@\n-        assertTrue(s.getOption(IP_MULTICAST_LOOP) == true);\n+        assertTrue(s.getOption(IP_MULTICAST_LOOP));\n@@ -301,1 +307,1 @@\n-        assertTrue(s.getOption(IP_MULTICAST_IF) != null);\n+        assertNotNull(s.getOption(IP_MULTICAST_IF));\n@@ -304,1 +310,2 @@\n-        byte[] message = \"hello\".getBytes(\"UTF-8\");\n+        String message = \"testSendReceive\";\n+        byte[] messageBytes = message.getBytes(\"UTF-8\");\n@@ -307,1 +314,1 @@\n-        DatagramPacket p = new DatagramPacket(message, message.length);\n+        DatagramPacket p = new DatagramPacket(messageBytes, messageBytes.length);\n@@ -311,1 +318,1 @@\n-        \/\/ receive message\n+        \/\/ receive message with retry in case of stray messages\n@@ -313,2 +320,15 @@\n-        p = new DatagramPacket(new byte[1024], 100);\n-        s.receive(p);\n+        for (int i = 1; i <= MAX_TRIES; i++) {\n+            p = new DatagramPacket(new byte[1024], 100);\n+            s.receive(p);\n+            String messageReceived = new String(p.getData(), 0, p.getLength(), \"UTF-8\");\n+\n+            System.out.format(\n+                    \"TestSendReceive iteration [%s], Received DatagramPacket [%s] from [%s]%n\",\n+                    i, messageReceived, s.getLocalSocketAddress());\n+\n+            if (s.getLocalPort() == p.getPort()) {\n+                assertEquals(message, messageReceived,\n+                        String.format(\"expected message %s, instead received %s%n\",\n+                                message, messageReceived));\n+                break;\n+            }\n@@ -316,2 +336,2 @@\n-        assertTrue(p.getLength() == message.length);\n-        assertTrue(p.getPort() == s.getLocalPort());\n+            assertNotEquals(MAX_TRIES, i, \"testSendReceive: too many retries\");\n+        }\n@@ -329,1 +349,1 @@\n-        assertTrue(s.getOption(IP_MULTICAST_IF) != null);\n+        assertNotNull(s.getOption(IP_MULTICAST_IF));\n@@ -333,1 +353,1 @@\n-        String text = nano + \": hello\";\n+        String text = nano + \": testSendNoReceive\";\n@@ -350,1 +370,3 @@\n-                    System.out.format(\"Received unexpected message from %s%n\", p.getSocketAddress());\n+                    String messageReceived = new String(p.getData(), 0, p.getLength(), \"UTF-8\");\n+                    System.out.format(\"Received unexpected message %s from %s%n\",\n+                            messageReceived, p.getSocketAddress());\n@@ -357,20 +379,0 @@\n-\n-\n-    static void assertTrue(boolean e) {\n-        if (!e) throw new RuntimeException();\n-    }\n-\n-    interface ThrowableRunnable {\n-        void run() throws Exception;\n-    }\n-\n-    static void assertThrows(Class<?> exceptionClass, ThrowableRunnable task) {\n-        try {\n-            task.run();\n-            throw new RuntimeException(\"Exception not thrown\");\n-        } catch (Exception e) {\n-            if (!exceptionClass.isInstance(e)) {\n-                throw new RuntimeException(\"expected: \" + exceptionClass + \", actual: \" + e);\n-            }\n-        }\n-    }\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/DatagramSocketMulticasting.java","additions":47,"deletions":45,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -695,2 +697,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -702,3 +703,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -714,1 +713,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -720,1 +719,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractThrowingPublishers.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -708,1 +709,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -714,1 +715,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractThrowingPushPromises.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,0 +79,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -686,2 +688,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -693,3 +694,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -705,1 +704,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -711,1 +710,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractThrowingSubscribers.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -89,0 +89,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -820,4 +822,1 @@\n-        InetSocketAddress loopback = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        HttpServer http1 = HttpServer.create(loopback, 0);\n-        http1TestServer = HttpTestServer.of(http1);\n+        http1TestServer = HttpTestServer.create(HTTP_1_1);\n@@ -827,3 +826,1 @@\n-        HttpsServer https1 = HttpsServer.create(loopback, 0);\n-        https1.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        https1TestServer = HttpTestServer.of(https1);\n+        https1TestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -834,1 +831,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -838,1 +835,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/AggregateRequestBodyTest.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -319,3 +321,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -324,3 +324,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -330,1 +328,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -333,1 +331,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n@@ -379,1 +377,1 @@\n-                if (t.getExchangeVersion() == HttpClient.Version.HTTP_1_1) {\n+                if (t.getExchangeVersion() == HTTP_1_1) {\n","filename":"test\/jdk\/java\/net\/httpclient\/AsyncExecutorShutdown.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -47,0 +47,3 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+\n@@ -90,1 +93,1 @@\n-    Executor executor = Executors.newCachedThreadPool();\n+    ExecutorService executor = Executors.newCachedThreadPool();\n@@ -122,3 +125,1 @@\n-            HttpServer server1 = HttpServer.create(sa, 0);\n-            server1.setExecutor(executor);\n-            http1Server = HttpTestServer.of(server1);\n+            http1Server = HttpTestServer.create(HTTP_1_1, null, executor);\n@@ -141,2 +142,1 @@\n-            http2Server = HttpTestServer.of(\n-                    new Http2TestServer(\"localhost\", false, 0));\n+            http2Server = HttpTestServer.create(HTTP_2);\n@@ -149,2 +149,1 @@\n-            https2Server = HttpTestServer.of(\n-                    new Http2TestServer(\"localhost\", true, 0));\n+            https2Server = HttpTestServer.create(HTTP_2, SSLContext.getDefault());\n","filename":"test\/jdk\/java\/net\/httpclient\/AuthFilterCacheTest.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -212,3 +214,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -217,3 +217,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -223,1 +221,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -226,1 +224,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/BasicRedirectTest.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -90,0 +90,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -596,2 +598,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -601,3 +602,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -610,1 +609,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -614,1 +613,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/CancelRequestTest.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -86,0 +86,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -346,2 +348,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -351,3 +352,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -360,1 +359,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -364,1 +363,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/CancelStreamedBodyTest.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -116,4 +118,4 @@\n-                { httpURI, HttpClient.Version.HTTP_1_1  },\n-                { httpsURI, HttpClient.Version.HTTP_1_1  },\n-                { httpDummy, HttpClient.Version.HTTP_1_1 },\n-                { httpsDummy, HttpClient.Version.HTTP_1_1 },\n+                { httpURI, HTTP_1_1  },\n+                { httpsURI, HTTP_1_1  },\n+                { httpDummy, HTTP_1_1 },\n+                { httpsDummy, HTTP_1_1 },\n@@ -190,3 +192,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -195,3 +195,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -201,1 +199,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -204,1 +202,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n@@ -210,0 +208,1 @@\n+        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n@@ -277,1 +276,1 @@\n-                if (t.getExchangeVersion() == HttpClient.Version.HTTP_1_1) {\n+                if (t.getExchangeVersion() == HTTP_1_1) {\n@@ -305,1 +304,1 @@\n-                    if (version == HttpClient.Version.HTTP_1_1 || upgraded) {\n+                    if (version == HTTP_1_1 || upgraded) {\n","filename":"test\/jdk\/java\/net\/httpclient\/CookieHeaderTest.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -91,0 +91,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -583,2 +585,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -590,3 +591,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -602,1 +601,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -608,1 +607,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/DependentActionsTest.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -668,1 +669,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -674,1 +675,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/DependentPromiseActionsTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -263,2 +265,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -270,3 +271,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -282,1 +281,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -288,1 +287,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n@@ -295,0 +294,1 @@\n+        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n","filename":"test\/jdk\/java\/net\/httpclient\/EncodedCharsInURI.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -282,3 +284,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -287,3 +287,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -293,1 +291,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -296,1 +294,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n@@ -342,1 +340,1 @@\n-                if (t.getExchangeVersion() == HttpClient.Version.HTTP_1_1) {\n+                if (t.getExchangeVersion() == HTTP_1_1) {\n","filename":"test\/jdk\/java\/net\/httpclient\/ExecutorShutdown.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -88,1 +90,0 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n@@ -91,1 +92,1 @@\n-        http1TestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        http1TestServer = HttpTestServer.create(HTTP_1_1);\n@@ -103,2 +104,1 @@\n-        http2TestServer = HttpTestServer.of(\n-                new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -249,1 +249,1 @@\n-                { getUri,   postUri, hangUri, HttpClient.Version.HTTP_1_1 },\n+                { getUri,   postUri, hangUri, HTTP_1_1 },\n","filename":"test\/jdk\/java\/net\/httpclient\/ExpectContinueTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -313,4 +315,1 @@\n-        InetSocketAddress sa =\n-                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        httpTestServer = HttpServerAdapters.HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpServerAdapters.HttpTestServer.create(HTTP_1_1);\n@@ -321,3 +320,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpServerAdapters.HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpServerAdapters.HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -328,2 +325,1 @@\n-        http2TestServer = HttpServerAdapters.HttpTestServer.of(\n-                new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_2);\n@@ -334,2 +330,1 @@\n-        https2TestServer = HttpServerAdapters.HttpTestServer.of(\n-                new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/FilePublisher\/FilePublisherPermsTest.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -66,0 +66,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -202,1 +204,1 @@\n-        httpTestServer = HttpServerAdapters.HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpServerAdapters.HttpTestServer.create(HTTP_1_1);\n@@ -206,3 +208,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpServerAdapters.HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpServerAdapters.HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -212,2 +212,1 @@\n-        http2TestServer = HttpServerAdapters.HttpTestServer.of(\n-                new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_2);\n@@ -217,2 +216,1 @@\n-        https2TestServer = HttpServerAdapters.HttpTestServer.of(\n-                new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/FilePublisher\/FilePublisherTest.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -334,3 +336,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -340,3 +340,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -346,1 +344,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -349,1 +347,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/ForbiddenHeadTest.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -545,2 +547,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -551,3 +552,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -559,1 +558,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -564,1 +563,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/GZIPInputStreamTest.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -87,2 +89,2 @@\n-                { httpURI, \"GET\", HTTP_NOT_MODIFIED, HttpClient.Version.HTTP_1_1  },\n-                { httpsURI, \"GET\", HTTP_NOT_MODIFIED, HttpClient.Version.HTTP_1_1  },\n+                { httpURI, \"GET\", HTTP_NOT_MODIFIED, HTTP_1_1  },\n+                { httpsURI, \"GET\", HTTP_NOT_MODIFIED, HTTP_1_1  },\n@@ -91,2 +93,2 @@\n-                { httpURI, \"HEAD\", HTTP_OK, HttpClient.Version.HTTP_1_1  },\n-                { httpsURI, \"HEAD\", HTTP_OK, HttpClient.Version.HTTP_1_1  },\n+                { httpURI, \"HEAD\", HTTP_OK, HTTP_1_1  },\n+                { httpsURI, \"HEAD\", HTTP_OK, HTTP_1_1  },\n@@ -95,2 +97,2 @@\n-                { httpURI + \"transfer\/\", \"GET\", HTTP_NOT_MODIFIED, HttpClient.Version.HTTP_1_1  },\n-                { httpsURI + \"transfer\/\", \"GET\", HTTP_NOT_MODIFIED, HttpClient.Version.HTTP_1_1  },\n+                { httpURI + \"transfer\/\", \"GET\", HTTP_NOT_MODIFIED, HTTP_1_1  },\n+                { httpsURI + \"transfer\/\", \"GET\", HTTP_NOT_MODIFIED, HTTP_1_1  },\n@@ -99,2 +101,2 @@\n-                { httpURI + \"transfer\/\", \"HEAD\", HTTP_OK, HttpClient.Version.HTTP_1_1  },\n-                { httpsURI + \"transfer\/\", \"HEAD\", HTTP_OK, HttpClient.Version.HTTP_1_1  },\n+                { httpURI + \"transfer\/\", \"HEAD\", HTTP_OK, HTTP_1_1  },\n+                { httpsURI + \"transfer\/\", \"HEAD\", HTTP_OK, HTTP_1_1  },\n@@ -159,1 +161,1 @@\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -162,3 +164,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -168,1 +168,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -171,1 +171,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, 0));\n+        https2TestServer = HttpTestServer.create(HTTP_2, SSLContext.getDefault());\n","filename":"test\/jdk\/java\/net\/httpclient\/HeadTest.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -110,3 +112,1 @@\n-        final var sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-        final int backlog = 0;\n-        http1_1_Server = HttpServerAdapters.HttpTestServer.of(HttpServer.create(sa, backlog));\n+        http1_1_Server = HttpServerAdapters.HttpTestServer.create(HTTP_1_1);\n@@ -118,3 +118,1 @@\n-        final HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        https_1_1_Server = HttpServerAdapters.HttpTestServer.of(httpsServer);\n+        https_1_1_Server = HttpServerAdapters.HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -127,1 +125,1 @@\n-        http2_Server = HttpServerAdapters.HttpTestServer.of(new Http2TestServer(sa.getHostString(), false, null));\n+        http2_Server = HttpServerAdapters.HttpTestServer.create(HTTP_2);\n@@ -133,1 +131,1 @@\n-        https2_Server = HttpServerAdapters.HttpTestServer.of(new Http2TestServer(sa.getHostString(), true, sslContext));\n+        https2_Server = HttpServerAdapters.HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientLocalAddrTest.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -166,3 +168,1 @@\n-            HttpServer server1 = HttpServer.create(sa, 0);\n-            server1.setExecutor(executor);\n-            http1Server = HttpTestServer.of(server1);\n+            http1Server = HttpTestServer.create(HTTP_1_1, null, executor);\n@@ -186,2 +186,1 @@\n-            http2Server = HttpTestServer.of(\n-                    new Http2TestServer(\"localhost\", false, 0));\n+            http2Server = HttpTestServer.create(HTTP_2);\n@@ -194,2 +193,1 @@\n-            https2Server = HttpTestServer.of(\n-                    new Http2TestServer(\"localhost\", true, 0));\n+            https2Server = HttpTestServer.create(HTTP_2, SSLContext.getDefault());\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRedirectTest.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,0 +55,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -130,3 +132,1 @@\n-            HttpServer server1 = HttpServer.create(sa, 0);\n-            server1.setExecutor(executor);\n-            http1Server = HttpTestServer.of(server1);\n+            http1Server = HttpTestServer.create(HTTP_1_1, null, executor);\n@@ -148,2 +148,1 @@\n-            http2Server = HttpTestServer.of(\n-                    new Http2TestServer(\"localhost\", false, 0));\n+            http2Server = HttpTestServer.create(HTTP_2);\n@@ -155,2 +154,1 @@\n-            https2Server = HttpTestServer.of(\n-                    new Http2TestServer(\"localhost\", true, 0));\n+            https2Server = HttpTestServer.create(HTTP_2, SSLContext.getDefault());\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpSlowServerTest.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -105,3 +107,0 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-        HttpsServer server1 = HttpsServer.create(sa, 0);\n-        server1.setHttpsConfigurator(new HttpsConfigurator(context));\n@@ -109,1 +108,1 @@\n-                HttpTestServer.of(server1);\n+                HttpTestServer.create(HTTP_1_1, context);\n@@ -112,2 +111,1 @@\n-        HttpTestServer http2Server = HttpTestServer.of(\n-                new Http2TestServer(\"localhost\", true, 0));\n+        HttpTestServer http2Server = HttpTestServer.create(HTTP_2, SSLContext.getDefault());\n@@ -157,1 +155,1 @@\n-            if (response.version() != Version.HTTP_1_1) {\n+            if (response.version() != HTTP_1_1) {\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpsTunnelTest.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -415,2 +417,1 @@\n-        HttpServer http1 = HttpServer.create(loopback, 0);\n-        http1TestServer = HttpServerAdapters.HttpTestServer.of(http1);\n+        http1TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_1_1);\n@@ -420,3 +421,1 @@\n-        HttpsServer https1 = HttpsServer.create(loopback, 0);\n-        https1.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        https1TestServer = HttpServerAdapters.HttpTestServer.of(https1);\n+        https1TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -427,1 +426,1 @@\n-        http2TestServer = HttpServerAdapters.HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_2);\n@@ -431,1 +430,1 @@\n-        https2TestServer = HttpServerAdapters.HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/ISO_8859_1_Test.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -231,1 +233,1 @@\n-                            && response.version() == HttpClient.Version.HTTP_1_1) {\n+                            && response.version() == HTTP_1_1) {\n@@ -281,1 +283,1 @@\n-                        && response.get().version() == HttpClient.Version.HTTP_1_1) {\n+                        && response.get().version() == HTTP_1_1) {\n@@ -449,2 +451,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -456,3 +457,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -468,1 +467,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -474,1 +473,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/InvalidInputStreamSubscriptionRequest.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -179,1 +181,1 @@\n-                        && response.version() == HttpClient.Version.HTTP_1_1) {\n+                        && response.version() == HTTP_1_1) {\n@@ -223,1 +225,1 @@\n-                        && response.get().version() == HttpClient.Version.HTTP_1_1) {\n+                        && response.get().version() == HTTP_1_1) {\n@@ -382,2 +384,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -389,3 +390,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -401,1 +400,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -407,1 +406,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/InvalidSubscriptionRequest.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -1003,3 +1005,1 @@\n-            HttpServer server1 = HttpServer.create(sa, 0);\n-            server1.setExecutor(executor);\n-            http1Server = HttpTestServer.of(server1);\n+            http1Server = HttpTestServer.create(HTTP_1_1, null, executor);\n@@ -1021,2 +1021,1 @@\n-            http2Server = HttpTestServer.of(\n-                    new Http2TestServer(\"localhost\", false, 0));\n+            http2Server = HttpTestServer.create(HTTP_2);\n@@ -1028,2 +1027,1 @@\n-            https2Server = HttpTestServer.of(\n-                    new Http2TestServer(\"localhost\", true, 0));\n+            https2Server = HttpTestServer.create(HTTP_2, SSLContext.getDefault());\n","filename":"test\/jdk\/java\/net\/httpclient\/LargeHandshakeTest.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,0 +55,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -128,3 +130,1 @@\n-            HttpServer server1 = HttpServer.create(sa, 0);\n-            server1.setExecutor(executor);\n-            http1Server = HttpTestServer.of(server1);\n+            http1Server = HttpTestServer.create(HTTP_1_1, null, executor);\n@@ -146,2 +146,1 @@\n-            http2Server = HttpTestServer.of(\n-                    new Http2TestServer(\"localhost\", false, 0));\n+            http2Server = HttpTestServer.create(HTTP_2);\n@@ -153,2 +152,1 @@\n-            https2Server = HttpTestServer.of(\n-                    new Http2TestServer(\"localhost\", true, 0));\n+            https2Server = HttpTestServer.create(HTTP_2, SSLContext.getDefault());\n","filename":"test\/jdk\/java\/net\/httpclient\/LargeResponseTest.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -673,2 +675,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0),\n+        httpTestServer = HttpTestServer.create(HTTP_1_1, null,\n@@ -679,3 +680,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer,\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext,\n@@ -686,1 +685,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -690,1 +689,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/LineBodyHandlerTest.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -199,2 +201,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -204,3 +205,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -210,1 +209,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -214,1 +213,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/NonAsciiCharsInURI.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -200,4 +202,1 @@\n-        InetSocketAddress sa =\n-                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        httpTestServer = HttpServerAdapters.HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpServerAdapters.HttpTestServer.create(HTTP_1_1);\n@@ -207,3 +206,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpServerAdapters.HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpServerAdapters.HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -213,2 +210,1 @@\n-        http2TestServer = HttpServerAdapters.HttpTestServer.of(\n-                new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_2);\n@@ -218,2 +214,1 @@\n-        https2TestServer = HttpServerAdapters.HttpTestServer.of(\n-                new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/PathSubscriber\/BodyHandlerOfFileDownloadTest.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -206,4 +208,1 @@\n-        InetSocketAddress sa =\n-                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        httpTestServer = HttpServerAdapters.HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpServerAdapters.HttpTestServer.create(HTTP_1_1);\n@@ -213,3 +212,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpServerAdapters.HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpServerAdapters.HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -219,2 +216,1 @@\n-        http2TestServer = HttpServerAdapters.HttpTestServer.of(\n-                new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_2);\n@@ -224,2 +220,1 @@\n-        https2TestServer = HttpServerAdapters.HttpTestServer.of(\n-                new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/PathSubscriber\/BodyHandlerOfFileTest.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -84,0 +84,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -243,4 +245,1 @@\n-        InetSocketAddress sa =\n-                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        httpTestServer = HttpServerAdapters.HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpServerAdapters.HttpTestServer.create(HTTP_1_1);\n@@ -250,3 +249,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpServerAdapters.HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpServerAdapters.HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -256,2 +253,1 @@\n-        http2TestServer = HttpServerAdapters.HttpTestServer.of(\n-                new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_2);\n@@ -261,2 +257,1 @@\n-        https2TestServer = HttpServerAdapters.HttpTestServer.of(\n-                new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpServerAdapters.HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/PathSubscriber\/BodySubscriberOfFileTest.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -212,1 +214,1 @@\n-                { Schemes.HTTP,  HttpClient.Version.HTTP_1_1, httpURI,   true},\n+                { Schemes.HTTP,  HTTP_1_1, httpURI,   true},\n@@ -214,1 +216,1 @@\n-                { Schemes.HTTPS, HttpClient.Version.HTTP_1_1, httpsURI,  true},\n+                { Schemes.HTTPS, HTTP_1_1, httpsURI,  true},\n@@ -216,1 +218,1 @@\n-                { Schemes.HTTP,  HttpClient.Version.HTTP_1_1, httpURI,   false},\n+                { Schemes.HTTP,  HTTP_1_1, httpURI,   false},\n@@ -218,1 +220,1 @@\n-                { Schemes.HTTPS, HttpClient.Version.HTTP_1_1, httpsURI,  false},\n+                { Schemes.HTTPS, HTTP_1_1, httpsURI,  false},\n@@ -325,3 +327,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -330,1 +330,1 @@\n-        proxyHttpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        proxyHttpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -334,1 +334,1 @@\n-        authProxyHttpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        authProxyHttpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -339,3 +339,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -345,1 +343,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -348,1 +346,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/ProxySelectorTest.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -189,3 +191,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -197,3 +197,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -205,1 +203,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -211,1 +209,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/RedirectMethodChange.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -151,3 +153,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -156,3 +156,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -162,1 +160,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -165,1 +163,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/RedirectWithCookie.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -85,1 +86,1 @@\n-        http2Server = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2Server = HttpTestServer.create(HTTP_2);\n@@ -103,2 +104,1 @@\n-        https2Server = HttpTestServer.of(new Http2TestServer(\"localhost\",\n-                true, sslContext));\n+        https2Server = HttpTestServer.create(HTTP_2, sslContext);\n@@ -365,1 +365,1 @@\n-                .version(HttpClient.Version.HTTP_2)\n+                .version(HTTP_2)\n@@ -377,1 +377,1 @@\n-            Assert.assertEquals(response.version(), HttpClient.Version.HTTP_2,\n+            Assert.assertEquals(response.version(), HTTP_2,\n@@ -393,1 +393,1 @@\n-                .version(HttpClient.Version.HTTP_2)\n+                .version(HTTP_2)\n@@ -433,1 +433,1 @@\n-                .version(HttpClient.Version.HTTP_2)\n+                .version(HTTP_2)\n@@ -452,1 +452,1 @@\n-                .version(HttpClient.Version.HTTP_2)\n+                .version(HTTP_2)\n","filename":"test\/jdk\/java\/net\/httpclient\/Response1xxTest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -273,1 +274,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -277,1 +278,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/Response204V2Test.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -402,2 +404,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -409,3 +410,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -421,1 +420,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -427,1 +426,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/ResponsePublisher.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -151,3 +153,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -156,3 +156,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -162,1 +160,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -165,1 +163,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n@@ -211,1 +209,1 @@\n-                if (t.getExchangeVersion() == HttpClient.Version.HTTP_1_1) {\n+                if (t.getExchangeVersion() == HTTP_1_1) {\n","filename":"test\/jdk\/java\/net\/httpclient\/RetryWithCookie.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n@@ -561,2 +562,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -566,3 +566,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -572,1 +570,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -576,1 +574,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/SpecialHeadersTest.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -91,2 +91,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-        httpTestServer = HttpServerAdapters.HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpServerAdapters.HttpTestServer.create(Version.HTTP_1_1);\n","filename":"test\/jdk\/java\/net\/httpclient\/StreamCloseTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -119,3 +121,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -125,3 +125,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -131,1 +129,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -134,1 +132,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/StreamingBody.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -66,0 +66,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -191,3 +193,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -196,3 +196,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -202,1 +200,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -205,1 +203,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n","filename":"test\/jdk\/java\/net\/httpclient\/UnauthorizedTest.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -81,0 +81,2 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n@@ -114,8 +116,8 @@\n-                { httpURI, HttpClient.Version.HTTP_1_1  },\n-                { httpsURI, HttpClient.Version.HTTP_1_1  },\n-                { httpDummy, HttpClient.Version.HTTP_1_1 },\n-                { httpsDummy, HttpClient.Version.HTTP_1_1 },\n-                { httpURI, HttpClient.Version.HTTP_2  },\n-                { httpsURI, HttpClient.Version.HTTP_2  },\n-                { httpDummy, HttpClient.Version.HTTP_2 },\n-                { httpsDummy, HttpClient.Version.HTTP_2 },\n+                { httpURI, HTTP_1_1  },\n+                { httpsURI, HTTP_1_1  },\n+                { httpDummy, HTTP_1_1 },\n+                { httpsDummy, HTTP_1_1 },\n+                { httpURI, HTTP_2  },\n+                { httpsURI, HTTP_2  },\n+                { httpDummy, HTTP_2 },\n+                { httpsDummy, HTTP_2 },\n@@ -195,3 +197,1 @@\n-        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n-\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n@@ -200,3 +200,1 @@\n-        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n@@ -206,1 +204,1 @@\n-        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n@@ -209,1 +207,1 @@\n-        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n@@ -213,1 +211,1 @@\n-\n+        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n@@ -282,1 +280,1 @@\n-                if (t.getExchangeVersion() == HttpClient.Version.HTTP_1_1) {\n+                if (t.getExchangeVersion() == HTTP_1_1) {\n@@ -302,1 +300,1 @@\n-            boolean upgraded = version == HttpClient.Version.HTTP_2\n+            boolean upgraded = version == HTTP_2\n@@ -310,1 +308,1 @@\n-                    if (version == HttpClient.Version.HTTP_1_1 || upgraded) {\n+                    if (version == HTTP_1_1 || upgraded) {\n","filename":"test\/jdk\/java\/net\/httpclient\/UserCookieTest.java","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n@@ -61,0 +63,2 @@\n+import javax.net.ssl.SSLContext;\n+\n@@ -553,0 +557,84 @@\n+        \/**\n+         * Creates a {@link HttpTestServer} which supports the {@code serverVersion}. The server\n+         * will only be available on {@code http} protocol. {@code https} will not be supported\n+         * by the returned server\n+         *\n+         * @param serverVersion The HTTP version of the server\n+         * @return The newly created server\n+         * @throws IllegalArgumentException if {@code serverVersion} is not supported by this method\n+         * @throws IOException if any exception occurs during the server creation\n+         *\/\n+        public static HttpTestServer create(Version serverVersion) throws IOException {\n+            Objects.requireNonNull(serverVersion);\n+            return create(serverVersion, null);\n+        }\n+\n+        \/**\n+         * Creates a {@link HttpTestServer} which supports the {@code serverVersion}. If the\n+         * {@code sslContext} is null, then only {@code http} protocol will be supported by the\n+         * server. Else, the server will be configured with the {@code sslContext} and will support\n+         * {@code https} protocol.\n+         *\n+         * @param serverVersion The HTTP version of the server\n+         * @param sslContext    The SSLContext to use. Can be null\n+         * @return The newly created server\n+         * @throws IllegalArgumentException if {@code serverVersion} is not supported by this method\n+         * @throws IOException if any exception occurs during the server creation\n+         *\/\n+        public static HttpTestServer create(Version serverVersion, SSLContext sslContext)\n+                throws IOException {\n+            Objects.requireNonNull(serverVersion);\n+            return create(serverVersion, sslContext, null);\n+        }\n+\n+        \/**\n+         * Creates a {@link HttpTestServer} which supports the {@code serverVersion}. If the\n+         * {@code sslContext} is null, then only {@code http} protocol will be supported by the\n+         * server. Else, the server will be configured with the {@code sslContext} and will support\n+         * {@code https} protocol.\n+         *\n+         * @param serverVersion The HTTP version of the server\n+         * @param sslContext    The SSLContext to use. Can be null\n+         * @param executor      The executor to be used by the server. Can be null\n+         * @return The newly created server\n+         * @throws IllegalArgumentException if {@code serverVersion} is not supported by this method\n+         * @throws IOException if any exception occurs during the server creation\n+         *\/\n+        public static HttpTestServer create(Version serverVersion, SSLContext sslContext,\n+                                            ExecutorService executor) throws IOException {\n+            Objects.requireNonNull(serverVersion);\n+            switch (serverVersion) {\n+                case HTTP_2 -> {\n+                    Http2TestServer underlying;\n+                    try {\n+                        underlying = sslContext == null\n+                                ? new Http2TestServer(\"localhost\", false, 0, executor, null) \/\/ HTTP\n+                                : new Http2TestServer(\"localhost\", true, 0, executor, sslContext); \/\/ HTTPS\n+                    } catch (IOException ioe) {\n+                        throw ioe;\n+                    } catch (Exception e) {\n+                        throw new IOException(e);\n+                    }\n+                    return HttpTestServer.of(underlying);\n+                }\n+                case HTTP_1_1 ->  {\n+                    InetSocketAddress sa = new InetSocketAddress(\n+                            InetAddress.getLoopbackAddress(), 0);\n+                    HttpServer underlying;\n+                    if (sslContext == null) {\n+                        underlying = HttpServer.create(sa, 0); \/\/ HTTP\n+                    } else {\n+                        HttpsServer https = HttpsServer.create(sa, 0); \/\/ HTTPS\n+                        https.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+                        underlying = https;\n+                    }\n+                    if (executor != null) {\n+                        underlying.setExecutor(executor);\n+                    }\n+                    return HttpTestServer.of(underlying);\n+                }\n+                default -> throw new IllegalArgumentException(\"Unsupported HTTP version \"\n+                        + serverVersion);\n+            }\n+        }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/HttpServerAdapters.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-        6911753 8071447 8186751 8242541 8260265\n+        6911753 8071447 8186751 8242541 8260265 8301119\n@@ -29,0 +29,2 @@\n+ * @run main RegisteredCharsets\n+ * @run main\/othervm -Djdk.charset.GB18030=2000 RegisteredCharsets\n@@ -254,0 +256,1 @@\n+                \"2000\".equals(System.getProperty(\"jdk.charset.GB18030\")) ?\n@@ -256,0 +259,3 @@\n+                } :\n+                new String[] {\n+                    \"gb18030-2022\"\n","filename":"test\/jdk\/java\/nio\/charset\/Charset\/RegisteredCharsets.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @summary Test the implementation\n+ * of Locale.availableLocales()\n+ * @bug 8282319\n+ * @run junit StreamAvailableLocales\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+import org.junit.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.Arguments;\n+\n+public class StreamAvailableLocales {\n+\n+    \/**\n+     * Test to validate that the methods: Locale.getAvailableLocales()\n+     * and Locale.availableLocales() contain the same underlying elements\n+     *\/\n+    @Test\n+    public void testStreamEqualsArray() {\n+        Locale[] arrayLocales = Locale.getAvailableLocales();\n+        Stream<Locale> streamedLocales = Locale.availableLocales();\n+        Locale[] convertedLocales = streamedLocales.toArray(Locale[]::new);\n+        if (Arrays.equals(arrayLocales, convertedLocales)) {\n+            System.out.println(\"$$$ Passed: The underlying elements\" +\n+                    \" of getAvailableLocales() and availableLocales() are the same!\");\n+        } else {\n+            throw new RuntimeException(\"$$$ Error: The underlying elements\" +\n+                    \" of getAvailableLocales() and availableLocales()\" +\n+                    \" are not the same.\");\n+        }\n+    }\n+\n+    \/**\n+     * Test to validate that the stream has the required\n+     * Locale.ROOT and Locale.US.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"requiredLocaleProvider\")\n+    public void testStreamRequirements(Locale requiredLocale, String localeName) {\n+        if (Locale.availableLocales().anyMatch(loc -> (loc.equals(requiredLocale)))) {\n+            System.out.printf(\"$$$ Passed: Stream has %s!%n\", localeName);\n+        } else {\n+            throw new RuntimeException(String.format(\"$$$ Error:\" +\n+                    \" Stream is missing %s!\", localeName));\n+        }\n+    }\n+\n+    \/\/ Data provider for testStreamRequirements\n+    private static Stream<Arguments> requiredLocaleProvider() {\n+        return Stream.of(\n+                Arguments.of(Locale.ROOT, \"Root locale\"),\n+                Arguments.of(Locale.US, \"US locale\")\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/StreamAvailableLocales.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,5 +26,5 @@\n- * @bug 6399443\n- * @summary Check for auto-shutdown and gc of singleThreadExecutors\n- * @library \/test\/lib\n- * @run main\/othervm\/timeout=1000 AutoShutdown\n- * @author Martin Buchholz\n+ * @bug 6399443 8302899\n+ * @summary Test that Executors.newSingleThreadExecutor wraps an ExecutorService that\n+ *    automatically shuts down and terminates when the wrapper is GC'ed\n+ * @modules java.base\/java.util.concurrent:+open\n+ * @run junit AutoShutdown\n@@ -33,2 +33,9 @@\n-import static java.util.concurrent.Executors.defaultThreadFactory;\n-import static java.util.concurrent.Executors.newSingleThreadExecutor;\n+import java.lang.reflect.Field;\n+import java.time.Duration;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import java.util.stream.IntStream;\n@@ -36,1 +43,5 @@\n-import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.Arguments;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -38,7 +49,1 @@\n-import java.lang.ref.WeakReference;\n-import java.util.Arrays;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.TimeUnit;\n-import jdk.test.lib.Utils;\n+class AutoShutdown {\n@@ -46,2 +51,6 @@\n-public class AutoShutdown {\n-    static final long LONG_DELAY_MS = Utils.adjustTimeout(10_000);\n+    private static Stream<Supplier<ExecutorService>> executors() {\n+        return Stream.of(\n+            () -> Executors.newSingleThreadExecutor(),\n+            () -> Executors.newSingleThreadExecutor(Executors.defaultThreadFactory())\n+        );\n+    }\n@@ -49,3 +58,4 @@\n-    static void await(CountDownLatch latch) throws InterruptedException {\n-        if (!latch.await(LONG_DELAY_MS, MILLISECONDS))\n-            throw new AssertionError(\"timed out waiting for latch\");\n+    private static Stream<Arguments> executorAndQueuedTaskCounts() {\n+        int[] queuedTaskCounts = { 0, 1, 2 };\n+        return executors().flatMap(s -> IntStream.of(queuedTaskCounts)\n+                .mapToObj(i -> Arguments.of(s, i)));\n@@ -54,39 +64,42 @@\n-    private static void realMain(String[] args) throws Throwable {\n-        final Executor[] executors = {\n-            newSingleThreadExecutor(),\n-            newSingleThreadExecutor(defaultThreadFactory()),\n-            \/\/ TODO: should these executors also auto-shutdown?\n-            \/\/newFixedThreadPool(1),\n-            \/\/newSingleThreadScheduledExecutor(),\n-            \/\/newSingleThreadScheduledExecutor(defaultThreadFactory()),\n-        };\n-        final ConcurrentLinkedQueue<WeakReference<Thread>> poolThreads\n-            = new ConcurrentLinkedQueue<>();\n-        final CountDownLatch threadStarted\n-            = new CountDownLatch(executors.length);\n-        final CountDownLatch pleaseProceed\n-            = new CountDownLatch(1);\n-        Runnable task = new Runnable() { public void run() {\n-            try {\n-                poolThreads.add(new WeakReference<>(Thread.currentThread()));\n-                threadStarted.countDown();\n-                await(pleaseProceed);\n-            } catch (Throwable t) { unexpected(t); }\n-        }};\n-        for (Executor executor : executors)\n-            executor.execute(task);\n-        await(threadStarted);\n-        pleaseProceed.countDown();\n-        Arrays.fill(executors, null);   \/\/ make executors unreachable\n-        boolean done = false;\n-        for (long timeout = 1L; !done && timeout <= 128L; timeout *= 2) {\n-            System.gc();\n-            done = true;\n-            for (WeakReference<Thread> ref : poolThreads) {\n-                Thread thread = ref.get();\n-                if (thread != null) {\n-                    TimeUnit.SECONDS.timedJoin(thread, timeout);\n-                    if (thread.isAlive())\n-                        done = false;\n-                }\n-            }\n+    \/**\n+     * SingleThreadExecutor with no worker threads.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testNoWorker(Supplier<ExecutorService> supplier) throws Exception {\n+        ExecutorService executor = supplier.get();\n+        ExecutorService delegate = getDelegate(executor);\n+        executor = null;\n+        gcAndAwaitTermination(delegate);\n+    }\n+\n+    \/**\n+     * SingleThreadExecutor with an idle worker thread.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testIdleWorker(Supplier<ExecutorService> supplier) throws Exception {\n+        ExecutorService executor = supplier.get();\n+        \/\/ submit a task to get a worker to start\n+        executor.submit(() -> null).get();\n+        ExecutorService delegate = getDelegate(executor);\n+        executor = null;\n+        gcAndAwaitTermination(delegate);\n+    }\n+\n+    \/**\n+     * SingleThreadExecutor with an active worker and queued tasks.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executorAndQueuedTaskCounts\")\n+    void testActiveWorker(Supplier<ExecutorService> supplier,int queuedTaskCount) throws Exception {\n+        ExecutorService executor = supplier.get();\n+        \/\/ the worker will execute one task, the other tasks will be queued\n+        int ntasks = 1 + queuedTaskCount;\n+        AtomicInteger completedTaskCount = new AtomicInteger();\n+        for (int i = 0; i < ntasks; i++) {\n+            executor.submit(() -> {\n+                Thread.sleep(Duration.ofMillis(500));\n+                completedTaskCount.incrementAndGet();\n+                return null;\n+            });\n@@ -94,2 +107,15 @@\n-        if (!done)\n-            throw new AssertionError(\"pool threads did not terminate\");\n+        ExecutorService delegate = getDelegate(executor);\n+        executor = null;\n+        gcAndAwaitTermination(delegate);\n+        assertEquals(ntasks, completedTaskCount.get());\n+    }\n+\n+    \/**\n+     * Returns the delegate for the given ExecutorService. The given ExecutorService\n+     * must be a Executors$DelegatedExecutorService.\n+     *\/\n+    private ExecutorService getDelegate(ExecutorService executor) throws Exception {\n+        Field eField = Class.forName(\"java.util.concurrent.Executors$DelegatedExecutorService\")\n+                .getDeclaredField(\"e\");\n+        eField.setAccessible(true);\n+        return (ExecutorService) eField.get(executor);\n@@ -98,13 +124,11 @@\n-    \/\/--------------------- Infrastructure ---------------------------\n-    static volatile int passed = 0, failed = 0;\n-    static void pass() {passed++;}\n-    static void fail() {failed++; Thread.dumpStack();}\n-    static void fail(String msg) {System.out.println(msg); fail();}\n-    static void unexpected(Throwable t) {failed++; t.printStackTrace();}\n-    static void equal(Object x, Object y) {\n-        if (x == null ? y == null : x.equals(y)) pass();\n-        else fail(x + \" not equal to \" + y);}\n-    public static void main(String[] args) throws Throwable {\n-        try {realMain(args);} catch (Throwable t) {unexpected(t);}\n-        System.out.printf(\"%nPassed = %d, failed = %d%n%n\", passed, failed);\n-        if (failed > 0) throw new AssertionError(\"Some tests failed\");}\n+    \/**\n+     * Invokes System.gc and waits for the given ExecutorService to terminate.\n+     *\/\n+    private void gcAndAwaitTermination(ExecutorService executor) throws Exception {\n+        System.err.println(executor);\n+        boolean terminated = false;\n+        while (!terminated) {\n+            System.gc();\n+            terminated = executor.awaitTermination(100, TimeUnit.MILLISECONDS);\n+        }\n+    }\n@@ -112,0 +136,1 @@\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/Executors\/AutoShutdown.java","additions":100,"deletions":75,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8081474\n+ * @summary  Verifies if SwingWorker calls 'done'\n+ *           before the 'doInBackground' is finished\n+ * @run main TestDoneBeforeDoInBackground\n+ *\/\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeEvent;\n+import javax.swing.SwingWorker;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class TestDoneBeforeDoInBackground {\n+\n+    private static final int WAIT_TIME = 200;\n+    private static final long CLEANUP_TIME = 1000;\n+\n+    private static final AtomicBoolean doInBackgroundStarted = new AtomicBoolean(false);\n+    private static final AtomicBoolean doInBackgroundFinished = new AtomicBoolean(false);\n+    private static final AtomicBoolean doneFinished = new AtomicBoolean(false);\n+    private static final CountDownLatch doneLatch = new CountDownLatch(1);\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        SwingWorker<String, String> worker = new SwingWorker<>() {\n+            @Override\n+            protected String doInBackground() throws Exception {\n+                try {\n+                    while (!Thread.currentThread().isInterrupted()) {\n+                        System.out.println(\"Working...\");\n+                        Thread.sleep(WAIT_TIME);\n+                    }\n+                } catch (InterruptedException ex) {\n+                    System.out.println(\"Got interrupted!\");\n+                }\n+\n+                try {\n+                    doInBackgroundStarted.set(true);\n+                    System.out.println(\"Cleaning up\");\n+                    Thread.sleep(CLEANUP_TIME);\n+                    System.out.println(\"Done cleaning\");\n+                    doInBackgroundFinished.set(true);\n+                } catch (InterruptedException ex) {\n+                    System.out.println(\"Got interrupted second time!\");\n+                }\n+\n+                return null;\n+            }\n+\n+            @Override\n+            protected void done() {\n+                if (!doInBackgroundFinished.get()) {\n+                    throw new RuntimeException(\"done called before \" +\n+                                               \"doInBackground is finished\");\n+                }\n+                System.out.println(\"Done\");\n+                doneFinished.set(true);\n+                doneLatch.countDown();\n+            }\n+        };\n+\n+        worker.addPropertyChangeListener(\n+            new PropertyChangeListener() {\n+                public void propertyChange(PropertyChangeEvent evt) {\n+                    System.out.println(\"doInBackgroundStarted: \" +\n+                                        doInBackgroundStarted.get() +\n+                                        \" doInBackgroundFinished: \" +\n+                                        doInBackgroundFinished.get() +\n+                                        \" done: \" + doneFinished.get() +\n+                                        \" state: \" + worker.getState());\n+                    \/\/ Before doInBackground method is invoked,\n+                    \/\/ SwingWorker notifies PropertyChangeListeners about the\n+                    \/\/ property change to StateValue.STARTED\n+                    if (doInBackgroundStarted.get()\n+                        && worker.getState() == SwingWorker.StateValue.STARTED) {\n+                        throw new RuntimeException(\n+                               \"PropertyChangeListeners called with \" +\n+                               \"state STARTED after doInBackground is invoked\");\n+                    }\n+\n+                    \/\/ Ensure DONE state is notified AFTER\n+                    \/\/ doInBackground is finished AND done is invoked\n+                    if (doInBackgroundFinished.get() && !doneFinished.get()\n+                        && worker.getState() == SwingWorker.StateValue.DONE) {\n+                        throw new RuntimeException(\n+                              \"done method is NOT executed but state is DONE\");\n+                    }\n+\n+                    \/\/ After the doInBackground method is finished\n+                    \/\/ SwingWorker notifies PropertyChangeListeners\n+                    \/\/ property change to StateValue.DONE\n+                    if (worker.getState() != SwingWorker.StateValue.DONE\n+                        && doInBackgroundFinished.get()) {\n+                        throw new RuntimeException(\n+                            \"PropertyChangeListeners called after \" +\n+                            \"doInBackground is finished but before State changed to DONE\");\n+                    }\n+                }\n+            });\n+        worker.execute();\n+        Thread.sleep(WAIT_TIME * 3);\n+\n+        final long start = System.currentTimeMillis();\n+        worker.cancel(true);\n+        final long end = System.currentTimeMillis();\n+\n+        if ((end - start) > 100) {\n+            throw new RuntimeException(\"Cancel took too long: \"\n+                                       + ((end - start) \/ 1000.0d) + \" s\");\n+        }\n+        if (!doneLatch.await(CLEANUP_TIME + 1000L, TimeUnit.MILLISECONDS)) {\n+            throw new RuntimeException(\"done didn't complete in time\");\n+        }\n+        System.out.println(\"doInBackground \" + doInBackgroundFinished.get() +\n+                           \" getState \" + worker.getState());\n+        if (worker.getState() != SwingWorker.StateValue.DONE\n+            && doInBackgroundFinished.get()) {\n+            throw new RuntimeException(\"doInBackground is finished \" +\n+                                       \"but State is not DONE\");\n+        }\n+    }\n+}\n+\n+\n","filename":"test\/jdk\/javax\/swing\/SwingWorker\/TestDoneBeforeDoInBackground.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -59,1 +59,1 @@\n-        var t = new AbstractWindowsTerminal(out, \"test\", \"vt100\", null, -1, false, SignalHandler.SIG_DFL, isWrapper) {\n+        var t = new AbstractWindowsTerminal(out, \"test\", \"vt100\", null, false, SignalHandler.SIG_DFL, isWrapper) {\n","filename":"test\/jdk\/jdk\/internal\/jline\/AbstractWindowsTerminalTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                                    0, true, SignalHandler.SIG_DFL, in -> in) {\n+                                    true, SignalHandler.SIG_DFL, in -> in) {\n","filename":"test\/jdk\/jdk\/internal\/jline\/KeyConversionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    public static void main(String... args) throws Exception  {\n+    public static void main(String... args) {\n@@ -64,0 +64,3 @@\n+            } catch (Exception e) {\n+                System.out.println(\"Exception: \" + e.getMessage());\n+                System.out.println(\"Retrying...\");\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/streaming\/TestJVMCrash.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,1 +58,2 @@\n-    if (std::string(\"Hello!\") != env->GetStringUTFChars(msg, NULL)) {\n+    const char* chars = env->GetStringUTFChars(msg, nullptr);\n+    if (std::string(\"Hello!\") != chars) {\n@@ -61,0 +62,1 @@\n+    env->ReleaseStringUTFChars(msg, chars);\n","filename":"test\/jdk\/jni\/nullCaller\/exeNullCallerTest.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @bug 8023093 8138748 8142398\n+ * @bug 8023093 8138748 8142398 8303102\n","filename":"test\/jdk\/sun\/management\/jmxremote\/startstop\/JMXStatusTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1233,1 +1233,1 @@\n-            Class clientVectorClass = Class.forName(\"sun.net.www.http.ClientVector\");\n+            Class clientVectorClass = Class.forName(\"sun.net.www.http.KeepAliveCache$ClientVector\");\n","filename":"test\/jdk\/sun\/net\/www\/http\/HttpClient\/KeepAliveTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 8211382\n+ * @bug 8211382 8301119\n@@ -28,0 +28,2 @@\n+ * @run main TestGB18030\n+ * @run main\/othervm -Djdk.charset.GB18030=2000 TestGB18030\n@@ -30,1 +32,0 @@\n-import java.io.*;\n@@ -33,0 +34,1 @@\n+import java.util.Set;\n@@ -35,0 +37,1 @@\n+    private static final Charset cs = Charset.forName(\"GB18030\");\n@@ -38,1 +41,0 @@\n-            Charset cs = Charset.forName(\"GB18030\");\n@@ -78,0 +80,10 @@\n+\n+    static void checkAlias() {\n+        var IS_2000 = \"2000\".equals(System.getProperty(\"jdk.charset.GB18030\"));\n+        var expected = IS_2000 ? Set.of(\"gb18030-2000\") : Set.of(\"gb18030-2022\");\n+        var found = cs.aliases();\n+        System.out.printf(\"checkAlias(): IS_2000: %s, expected: %s, found: %s\\n\", IS_2000, expected, found);\n+        if (!cs.aliases().equals(expected)) {\n+            throw new RuntimeException(\"Result mismatch\");\n+        }\n+    }\n@@ -81,0 +93,1 @@\n+        checkAlias();\n","filename":"test\/jdk\/sun\/nio\/cs\/TestGB18030.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-   @bug 4691554 6221056 6380723 6404504 6419565 6529796\n+   @bug 4691554 6221056 6380723 6404504 6419565 6529796 8301119\n@@ -28,0 +28,2 @@\n+   @run main CoderTest\n+   @run main\/othervm -Djdk.charset.GB18030=2000 CoderTest\n@@ -59,0 +61,3 @@\n+    private static final boolean IS_2000 =\n+            \"2000\".equals(System.getProperty(\"jdk.charset.GB18030\"));\n+\n@@ -469,1 +474,6 @@\n-            File f = testFile(encoding, mode);\n+            var fileName = encoding;\n+            if (fileName.equals(\"GB18030\") && IS_2000) {\n+                \/\/ tweak the map file name\n+                fileName = \"GB18030_2000\";\n+            }\n+            File f = testFile(fileName, mode);\n","filename":"test\/jdk\/sun\/nio\/cs\/mapping\/CoderTest.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+# based on GB18030-2022 mapping\n@@ -7744,1 +7745,1 @@\n-8135F437\t1E3F\n+A8BC\t1E3F\n@@ -40885,8 +40886,8 @@\n-82359037\t9FB4\n-82359038\t9FB5\n-82359039\t9FB6\n-82359130\t9FB7\n-82359131\t9FB8\n-82359132\t9FB9\n-82359133\t9FBA\n-82359134\t9FBB\n+82359037\tE81E\n+82359038\tE826\n+82359039\tE82B\n+82359130\tE82C\n+82359131\tE832\n+82359132\tE843\n+82359133\tE854\n+82359134\tE864\n@@ -57230,10 +57231,10 @@\n-A6D9\tE78D\n-A6DA\tE78E\n-A6DB\tE78F\n-A6DC\tE790\n-A6DD\tE791\n-A6DE\tE792\n-A6DF\tE793\n-A6EC\tE794\n-A6ED\tE795\n-A6F3\tE796\n+A6D9\tFE10\n+A6DA\tFE12\n+A6DB\tFE11\n+A6DC\tFE13\n+A6DD\tFE14\n+A6DE\tFE15\n+A6DF\tFE16\n+A6EC\tFE17\n+A6ED\tFE18\n+A6F3\tFE19\n@@ -57288,1 +57289,1 @@\n-A8BC\tE7C7\n+8135F437\tE7C7\n@@ -57375,1 +57376,1 @@\n-FE59\tE81E\n+FE59\t9FB4\n@@ -57383,1 +57384,1 @@\n-FE61\tE826\n+FE61\t9FB5\n@@ -57388,2 +57389,2 @@\n-FE66\tE82B\n-FE67\tE82C\n+FE66\t9FB6\n+FE67\t9FB7\n@@ -57395,1 +57396,1 @@\n-FE6D\tE832\n+FE6D\t9FB8\n@@ -57412,1 +57413,1 @@\n-FE7E\tE843\n+FE7E\t9FB9\n@@ -57429,1 +57430,1 @@\n-FE90\tE854\n+FE90\t9FBA\n@@ -57445,1 +57446,1 @@\n-FEA0\tE864\n+FEA0\t9FBB\n@@ -62993,10 +62994,10 @@\n-84318236\tFE10\n-84318237\tFE11\n-84318238\tFE12\n-84318239\tFE13\n-84318330\tFE14\n-84318331\tFE15\n-84318332\tFE16\n-84318333\tFE17\n-84318334\tFE18\n-84318335\tFE19\n+84318236\tE78D\n+84318237\tE78F\n+84318238\tE78E\n+84318239\tE790\n+84318330\tE791\n+84318331\tE792\n+84318332\tE793\n+84318333\tE794\n+84318334\tE795\n+84318335\tE796\n@@ -63487,2 +63488,2 @@\n-#8431A438\tFFFE\n-#8431A439\tFFFF\n+8431A438\tFFFE\n+8431A439\tFFFF\n","filename":"test\/jdk\/sun\/nio\/cs\/mapping\/GB18030.b2c","additions":41,"deletions":40,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -1,3 +1,1 @@\n-# GB18030.java is NOT generated from this mapping right now. This\n-# map is here for testing only.\n-#\n+# based on GB18030-2000 mapping\n","filename":"test\/jdk\/sun\/nio\/cs\/mapping\/GB18030_2000.b2c","additions":1,"deletions":3,"binary":false,"changes":4,"previous_filename":"make\/data\/charsetmapping\/GB18030.map","status":"renamed"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.Provider;\n+import java.security.PrivateKey;\n+import javax.crypto.spec.DHParameterSpec;\n+import javax.crypto.interfaces.DHPrivateKey;\n+import sun.security.util.SecurityProviderConstants;\n+import sun.security.provider.ParameterCache;\n+\n+\/**\n+ * @test\n+ * @bug 8295425\n+ * @modules java.base\/sun.security.provider java.base\/sun.security.util\n+ * @library \/test\/lib ..\n+ * @run main TestDefaultDHPrivateExpSize\n+ * @summary This test verifies the DH private exponent size for SunPKCS11\n+ *         provider.\n+ *\/\n+\n+public class TestDefaultDHPrivateExpSize extends PKCS11Test {\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        System.out.println(\"Testing \" + p.getName());\n+\n+        if (p.getService(\"KeyPairGenerator\", \"DH\") == null) {\n+            System.out.println(\"Skip, no support for DH KeyPairGenerator\");\n+            return;\n+        }\n+\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"DH\", p);\n+        \/\/ try common DH key sizes with built-in primes\n+        int[] cachedSizes = { 2048, 3072, 4096, 6144, 8192 };\n+        for (int ks : cachedSizes) {\n+            \/\/ use keysize which uses JDK default parameters w\/ JDK\n+            \/\/ default lSize\n+            kpg.initialize(ks);\n+            int expectedL = SecurityProviderConstants.getDefDHPrivateExpSize\n+                    (ParameterCache.getCachedDHParameterSpec(ks));\n+            System.out.println(\"Test against built-in DH \" + ks +\n+                    \"-bit parameters, expectedL = \" + expectedL);\n+            DHParameterSpec spec = generateAndCheck(kpg, ks, expectedL);\n+\n+            \/\/ use custom DH parameters w\/o lSize\n+            DHParameterSpec spec2 = new DHParameterSpec(spec.getP(),\n+                    spec.getG());\n+            kpg.initialize(spec2);\n+            System.out.println(\"Test against user DH \" + ks +\n+                    \"-bit parameters, expectedL = \" + spec2.getL());\n+\n+            generateAndCheck(kpg, ks, spec2.getL());\n+\n+            \/\/ use custom DH parameters w\/ lSize\n+            expectedL += 2;\n+            spec2 = new DHParameterSpec(spec.getP(), spec.getG(), expectedL);\n+            kpg.initialize(spec2);\n+            System.out.println(\"Test against user DH \" + ks +\n+                    \"-bit parameters, expectedL = \" + spec2.getL());\n+            generateAndCheck(kpg, ks, expectedL);\n+        }\n+    }\n+\n+    \/\/ initialize the specified 'kpg' with 'initParam', then check\n+    \/\/ the parameters associated with the generated key against 'initParam'\n+    \/\/ and return the actual private exponent length.\n+    private static DHParameterSpec generateAndCheck(KeyPairGenerator kpg,\n+            int expKeySize, int expL) {\n+\n+        DHPrivateKey dhPriv = (DHPrivateKey) kpg.generateKeyPair().getPrivate();\n+        DHParameterSpec generated = dhPriv.getParams();\n+        \/\/ check the params associated with the key as that's what we\n+        \/\/ have control over\n+        if ((generated.getP().bitLength() != expKeySize) ||\n+                generated.getL()!= expL) {\n+            new RuntimeException(\"Error: size check failed, got \" +\n+                    generated.getP().bitLength() + \" and \" + generated.getL());\n+        }\n+\n+        \/\/ Known NSS Issue\/limitation: NSS ignores the supplied L value when\n+        \/\/ generating the DH private key\n+        int actualL = dhPriv.getX().bitLength();\n+        System.out.println(\"INFO: actual L = \" + actualL);\n+        \/*\n+        if (expLSize != 0 && actualL != expLSize) {\n+            throw new RuntimeException(\"ERROR: actual L mismatches, got \"\n+                    + actualL + \" vs expect \" + expLSize);\n+        }\n+        *\/\n+        return generated;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestDefaultDHPrivateExpSize(), args);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyPairGenerator\/TestDefaultDHPrivateExpSize.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -312,0 +312,9 @@\n+        \/\/ Unix style compression arguments\n+        {\n+            testCompress(helper, \"compresscmdcompositezip6\", \"--compress\", \"zip-6\");\n+        }\n+\n+        {\n+            testCompress(helper, \"compresscmdcompositezip0\", \"--compress\", \"zip-0\");\n+        }\n+\n@@ -329,0 +338,17 @@\n+        \/\/ compress zip-0 with filter\n+        {\n+            testCompress(helper, \"compresszip0filtercmdcomposite2\",\n+                    \"--compress=zip-0:filter=^\/java.base\/java\/lang\/*\");\n+        }\n+\n+        \/\/ compress zip-6 with filter\n+        {\n+            testCompress(helper, \"compresszip6filtercmdcomposite2\",\n+                    \"--compress=zip-6:filter=^\/java.base\/java\/lang\/*\");\n+        }\n+\n+        \/\/ compress zip-9 with filter\n+        {\n+            testCompress(helper, \"compresszip9filtercmdcomposite2\",\n+                    \"--compress=zip-9:filter=^\/java.base\/java\/lang\/*\");\n+        }\n","filename":"test\/jdk\/tools\/jlink\/JLinkTest.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,0 +149,61 @@\n+\n+        \/\/ compress level zip-0 == no compression\n+        Properties optionsZip0 = new Properties();\n+        DefaultCompressPlugin compressPluginZip0 = new DefaultCompressPlugin();\n+        optionsZip0.setProperty(compressPluginZip0.getName(), \"zip-0\");\n+        checkCompress(classes, compressPluginZip0,\n+                optionsZip0,\n+                new ResourceDecompressorFactory[]{\n+                });\n+\n+        \/\/ compress level zip-[1-9] == varied compression levels\n+        for(int i = 1; i < 10; i++) {\n+            Properties optionsZip = new Properties();\n+            compressPlugin = new DefaultCompressPlugin();\n+            optionsZip.setProperty(compressPlugin.getName(), \"zip-\" + i);\n+            checkCompress(classes, compressPlugin,\n+                    optionsZip,\n+                    new ResourceDecompressorFactory[]{\n+                            new ZipDecompressorFactory(),\n+                    });\n+        }\n+\n+        \/\/ compress level zip-[1-9] == varied compression levels + filter\n+        for(int i = 1; i < 10; i++) {\n+            Properties optionsZip = new Properties();\n+            compressPlugin = new DefaultCompressPlugin();\n+            optionsZip.setProperty(DefaultCompressPlugin.FILTER, \"**Exception.class\");\n+            optionsZip.setProperty(compressPlugin.getName(), \"zip-\" + i);\n+            checkCompress(classes, compressPlugin,\n+                    optionsZip,\n+                    new ResourceDecompressorFactory[]{\n+                            new ZipDecompressorFactory(),\n+                    }, Collections.singletonList(\".*Exception.class\"));\n+        }\n+\n+        testBadCompressProps(classes, \"zip-10\");\n+        testBadCompressProps(classes, \"zip-badarg\");\n+        testBadCompressProps(classes, \"zip-10000000\");\n+\n+    }\n+\n+    private void testBadCompressProps(ResourcePool classes, String compressArg) throws Exception {\n+        Properties badProps = new Properties();\n+        DefaultCompressPlugin compressPlugin = new DefaultCompressPlugin();\n+        badProps.setProperty(compressPlugin.getName(), compressArg);\n+        try {\n+            checkCompress(classes, compressPlugin,\n+                    badProps,\n+                    new ResourceDecompressorFactory[]{\n+                            new ZipDecompressorFactory(),\n+                    });\n+        } catch (IllegalArgumentException e) {\n+            if (e.getMessage().contains(\"Invalid compression level\")) {\n+                return;\n+            } else {\n+                throw e;\n+            }\n+        }\n+\n+        throw new Exception(\"Expected compression IAE with \" + compressArg + \" but didn't get one.\");\n+\n","filename":"test\/jdk\/tools\/jlink\/plugins\/CompressorPluginTest.java","additions":62,"deletions":1,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ *          jdk.internal.le\/jdk.internal.org.jline.terminal.spi\n@@ -38,0 +39,1 @@\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n@@ -40,2 +42,2 @@\n-    public ExecPtyGetFlagsToSetTest(String name, boolean system) {\n-        super(name, system);\n+    public ExecPtyGetFlagsToSetTest(String name, TerminalProvider.Stream stream) {\n+        super(name, stream);\n@@ -51,1 +53,1 @@\n-            new ExecPtyGetFlagsToSetTest(\"stty\", true);\n+            new ExecPtyGetFlagsToSetTest(\"stty\", TerminalProvider.Stream.Output);\n","filename":"test\/langtools\/jdk\/jshell\/ExecPtyGetFlagsToSetTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -134,3 +134,1 @@\n-        OutputStream out = new FileOutputStream(jar);\n-        try {\n-            JarOutputStream jos = new JarOutputStream(out);\n+        try (JarOutputStream jos = new JarOutputStream(new FileOutputStream(jar))) {\n@@ -141,3 +139,0 @@\n-            jos.close();\n-        } finally {\n-            out.close();\n","filename":"test\/langtools\/tools\/javac\/4241573\/T4241573.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -94,4 +94,3 @@\n-        OutputStream out = new BufferedOutputStream(new FileOutputStream(jar));\n-        JarOutputStream j = new JarOutputStream(out, m);\n-        add(j, base, files);\n-        j.close();\n+        try (JarOutputStream j = new JarOutputStream(new BufferedOutputStream(new FileOutputStream(jar)), m)) {\n+            add(j, base, files);\n+        }\n@@ -127,7 +126,9 @@\n-        BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n-        int offset = 0;\n-        while (offset < buf.length) {\n-            int n = in.read(buf, offset, buf.length - offset);\n-            if (n < 0)\n-                throw new EOFException();\n-            offset += n;\n+        try (BufferedInputStream in = new BufferedInputStream(new FileInputStream(f))) {\n+            int offset = 0;\n+            while (offset < buf.length) {\n+                int n = in.read(buf, offset, buf.length - offset);\n+                if (n < 0)\n+                    throw new EOFException();\n+                offset += n;\n+            }\n+            return buf;\n@@ -135,1 +136,0 @@\n-        return buf;\n","filename":"test\/langtools\/tools\/javac\/6400872\/T6400872.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -67,4 +67,1 @@\n-        FileOutputStream fos = null;\n-        try {\n-            fos = new FileOutputStream(TEST_JAVA);\n-            PrintStream ps = new PrintStream(fos);\n+        try (PrintStream ps = new PrintStream(new FileOutputStream(TEST_JAVA))) {\n@@ -72,2 +69,0 @@\n-        } finally {\n-            fos.close();\n@@ -88,13 +83,3 @@\n-        RandomAccessFile raf = null;\n-        FileChannel wfc = null;\n-\n-        FileInputStream fis = null;\n-        FileChannel rfc = null;\n-\n-        try {\n-            raf =  new RandomAccessFile(f, \"rw\");\n-            wfc = raf.getChannel();\n-\n-            fis = new FileInputStream(tfile);\n-            rfc = fis.getChannel();\n-\n+        try (\n+          FileChannel wfc = new RandomAccessFile(f, \"rw\").getChannel();\n+          FileChannel rfc = new FileInputStream(tfile).getChannel()) {\n@@ -106,5 +91,0 @@\n-        } finally {\n-            wfc.close();\n-            raf.close();\n-            rfc.close();\n-            fis.close();\n@@ -116,4 +96,1 @@\n-        FileOutputStream fos = null;\n-        try {\n-            fos = new FileOutputStream(TEST2_JAVA);\n-            PrintStream ps = new PrintStream(fos);\n+        try (PrintStream ps = new PrintStream(new FileOutputStream(TEST2_JAVA))) {\n@@ -123,2 +100,0 @@\n-        } finally {\n-            fos.close();\n","filename":"test\/langtools\/tools\/javac\/6567415\/T6567415.java","additions":5,"deletions":30,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1,4 +1,4 @@\n-T8230827.java:27:17: compiler.warn.potentially.ambiguous.overload: ambiguousMethod1(java.lang.Object,T8230827.I1), T8230827, ambiguousMethod1(java.lang.Object,T8230827.I2), T8230827\n-T8230827.java:32:17: compiler.warn.potentially.ambiguous.overload: ambiguousMethod2(T8230827.I1,java.lang.Object), T8230827, ambiguousMethod2(T8230827.I2,java.lang.Object), T8230827\n-T8230827.java:37:17: compiler.warn.potentially.ambiguous.overload: ambiguousMethod3(T8230827.I1,T8230827.I1), T8230827, ambiguousMethod3(T8230827.I2,T8230827.I1), T8230827\n-T8230827.java:42:17: compiler.warn.potentially.ambiguous.overload: ambiguousMethod4(java.lang.Object,T8230827.I1,java.lang.String), T8230827, ambiguousMethod4(java.lang.String,T8230827.I2,java.lang.Object), T8230827\n+T8230827.java:29:17: compiler.warn.potentially.ambiguous.overload: ambiguousMethod1(java.lang.Object,T8230827.I2), T8230827, ambiguousMethod1(java.lang.Object,T8230827.I1), T8230827\n+T8230827.java:34:17: compiler.warn.potentially.ambiguous.overload: ambiguousMethod2(T8230827.I2,java.lang.Object), T8230827, ambiguousMethod2(T8230827.I1,java.lang.Object), T8230827\n+T8230827.java:39:17: compiler.warn.potentially.ambiguous.overload: ambiguousMethod3(T8230827.I2,T8230827.I1), T8230827, ambiguousMethod3(T8230827.I1,T8230827.I1), T8230827\n+T8230827.java:44:17: compiler.warn.potentially.ambiguous.overload: ambiguousMethod4(java.lang.String,T8230827.I2,java.lang.Object), T8230827, ambiguousMethod4(java.lang.Object,T8230827.I1,java.lang.String), T8230827\n@@ -7,1 +7,1 @@\n-4 warnings\n\\ No newline at end of file\n+4 warnings\n","filename":"test\/langtools\/tools\/javac\/8230827\/T8230827.out","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.io.InputStream;\n@@ -113,1 +114,4 @@\n-                byte[] data = file.openInputStream().readAllBytes();\n+                byte[] data;\n+                try (InputStream input = file.openInputStream()) {\n+                    data = input.readAllBytes();\n+                }\n","filename":"test\/langtools\/tools\/javac\/ConditionalExpressionResolvePending.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -105,2 +105,1 @@\n-        InputStream in = fo.openInputStream();\n-        try {\n+        try (InputStream in = fo.openInputStream()) {\n@@ -122,2 +121,0 @@\n-        } finally {\n-            in.close();\n","filename":"test\/langtools\/tools\/javac\/NoStringToLower.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -109,4 +109,3 @@\n-        OutputStream out = new BufferedOutputStream(new FileOutputStream(jar));\n-        JarOutputStream j = new JarOutputStream(out, m);\n-        add(j, base, files);\n-        j.close();\n+        try (JarOutputStream j = new JarOutputStream(new BufferedOutputStream(new FileOutputStream(jar)), m)) {\n+            add(j, base, files);\n+        }\n@@ -147,7 +146,9 @@\n-        BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n-        int offset = 0;\n-        while (offset < buf.length) {\n-            int n = in.read(buf, offset, buf.length - offset);\n-            if (n < 0)\n-                throw new EOFException();\n-            offset += n;\n+        try (BufferedInputStream in = new BufferedInputStream(new FileInputStream(f))) {\n+            int offset = 0;\n+            while (offset < buf.length) {\n+                int n = in.read(buf, offset, buf.length - offset);\n+                if (n < 0)\n+                    throw new EOFException();\n+                offset += n;\n+            }\n+            return buf;\n@@ -155,1 +156,0 @@\n-        return buf;\n","filename":"test\/langtools\/tools\/javac\/Paths\/6638501\/JarFromManifestFailure.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -66,3 +66,3 @@\n-        PrintStream s = new PrintStream(new FileOutputStream(f));\n-        s.println(contents);\n-        s.close();\n+        try (PrintStream s = new PrintStream(new FileOutputStream(f))) {\n+            s.println(contents);\n+        }\n","filename":"test\/langtools\/tools\/javac\/Paths\/TestCompileJARInClassPath.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -87,2 +87,1 @@\n-                    try {\n-                        Writer out = filer.createSourceFile(te.getSimpleName() + \"Wrapper\").openWriter();\n+                    try (Writer out = filer.createSourceFile(te.getSimpleName() + \"Wrapper\").openWriter()) {\n@@ -90,1 +89,0 @@\n-                        out.close();\n","filename":"test\/langtools\/tools\/javac\/T6403466.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,7 +81,2 @@\n-            try {\n-                Writer w = processingEnv.getFiler().createSourceFile(\"p.Generated\").openWriter();\n-                try {\n-                    w.write(\"package p; public class Generated { public static void m() { } }\");\n-                } finally {\n-                    w.close();\n-                }\n+            try (Writer w = processingEnv.getFiler().createSourceFile(\"p.Generated\").openWriter()) {\n+                w.write(\"package p; public class Generated { public static void m() { } }\");\n","filename":"test\/langtools\/tools\/javac\/T7159016.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.io.InputStream;\n@@ -181,1 +182,5 @@\n-                analyzeClassFile(ClassFile.read(file.openInputStream()));\n+                ClassFile classFile;\n+                try (InputStream input = file.openInputStream()) {\n+                    classFile = ClassFile.read(input);\n+                }\n+                analyzeClassFile(classFile);\n","filename":"test\/langtools\/tools\/javac\/T8003967\/DetectMutableStaticFields.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -86,3 +86,3 @@\n-        FileOutputStream output  = new FileOutputStream(f);\n-        output.write(hexToByte(hexString));\n-        output.close();\n+        try (FileOutputStream output = new FileOutputStream(f)) {\n+            output.write(hexToByte(hexString));\n+        }\n","filename":"test\/langtools\/tools\/javac\/T8071847\/T8071847.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,2 +63,3 @@\n-        OutputStream outputStream = new FileOutputStream(file);\n-        outputStream.write(\"enum Foo {AA(10), BB, CC { void m() {} }; void m() {};}\".getBytes());\n+        try (OutputStream outputStream = new FileOutputStream(file)) {\n+            outputStream.write(\"enum Foo {AA(10), BB, CC { void m() {} }; void m() {};}\".getBytes());\n+        }\n@@ -70,2 +71,3 @@\n-        outputStream = new FileOutputStream(file);\n-        outputStream.write((obj.PrettyPrint((JCTree)thisTree)).getBytes());\n+        try (OutputStream outputStream = new FileOutputStream(file)) {\n+            outputStream.write((obj.PrettyPrint((JCTree)thisTree)).getBytes());\n+        }\n","filename":"test\/langtools\/tools\/javac\/T8152616.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -61,3 +61,1 @@\n-        OutputStream out = new FileOutputStream(f);\n-        try {\n-            JarOutputStream jar = new JarOutputStream(out);\n+        try (JarOutputStream jar = new JarOutputStream(new FileOutputStream(f))) {\n@@ -66,3 +64,0 @@\n-            jar.close();\n-        } finally {\n-            out.close();\n","filename":"test\/langtools\/tools\/javac\/api\/T6483788.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -117,2 +117,8 @@\n-            byte[] uriData = read(urlconn.getInputStream());\n-            byte[] foData = read(fo.openInputStream());\n+            byte[] uriData;\n+            byte[] foData;\n+            try (InputStream input = urlconn.getInputStream()) {\n+                uriData = read(input);\n+            }\n+            try (InputStream input = fo.openInputStream()) {\n+                foData = read(input);\n+            }\n@@ -177,3 +183,1 @@\n-        OutputStream out = new FileOutputStream(jar);\n-        try {\n-            JarOutputStream jos = new JarOutputStream(out);\n+        try (JarOutputStream jos = new JarOutputStream(new FileOutputStream(jar))) {\n@@ -184,3 +188,0 @@\n-            jos.close();\n-        } finally {\n-            out.close();\n","filename":"test\/langtools\/tools\/javac\/api\/T6877206.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.io.Reader;\n@@ -48,4 +49,4 @@\n-                try {\n-                    \/\/ 6427274: FileObject.openReader throws exception\n-                    \/\/ 6347778: getSource() returns null for notes\n-                    diagnostic.getSource().openReader(true).getClass();\n+                \/\/ 6427274: FileObject.openReader throws exception\n+                \/\/ 6347778: getSource() returns null for notes\n+                try (Reader reader = diagnostic.getSource().openReader(true)) {\n+                    reader.getClass();\n@@ -69,1 +70,1 @@\n-        fm.getFileForInput(StandardLocation.PLATFORM_CLASS_PATH,\n+        try (Reader reader = fm.getFileForInput(StandardLocation.PLATFORM_CLASS_PATH,\n@@ -71,1 +72,3 @@\n-                           \"Object.class\").openReader(true).getClass();\n+                           \"Object.class\").openReader(true)) {\n+            reader.getClass();\n+        }\n","filename":"test\/langtools\/tools\/javac\/api\/guide\/Test.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.io.InputStream;\n@@ -69,1 +70,4 @@\n-                    ClassFile classFile = ClassFile.read(file.openInputStream());\n+                    ClassFile classFile;\n+                    try (InputStream input = file.openInputStream()) {\n+                        classFile = ClassFile.read(input);\n+                    }\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/LineNumberTable\/LineNumberTestBase.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.InputStream;\n@@ -87,1 +88,5 @@\n-            assertAttributePresent(ClassFile.read(classes.get(className).openInputStream()), fileName);\n+            ClassFile classFile;\n+            try (InputStream input = classes.get(className).openInputStream()) {\n+                classFile = ClassFile.read(input);\n+            }\n+            assertAttributePresent(classFile, fileName);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/SourceFile\/SourceFileTestBase.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -202,2 +202,1 @@\n-        DataInputStream in = new DataInputStream(new FileInputStream(f));\n-        try {\n+        try (DataInputStream in = new DataInputStream(new FileInputStream(f))) {\n@@ -205,2 +204,0 @@\n-        } finally {\n-            in.close();\n","filename":"test\/langtools\/tools\/javac\/diags\/CheckExamples.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -492,2 +492,1 @@\n-        InputStream in = fo.openInputStream();\n-        try {\n+        try (InputStream in = fo.openInputStream()) {\n@@ -503,2 +502,0 @@\n-        } finally {\n-            in.close();\n","filename":"test\/langtools\/tools\/javac\/diags\/CheckResourceKeys.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -432,2 +432,1 @@\n-        DataInputStream in = new DataInputStream(new FileInputStream(f));\n-        try {\n+        try (DataInputStream in = new DataInputStream(new FileInputStream(f))) {\n@@ -435,2 +434,0 @@\n-        } finally {\n-            in.close();\n","filename":"test\/langtools\/tools\/javac\/diags\/Example.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -383,2 +383,1 @@\n-        DataInputStream in = new DataInputStream(new FileInputStream(f));\n-        try {\n+        try (DataInputStream in = new DataInputStream(new FileInputStream(f))) {\n@@ -386,2 +385,0 @@\n-        } finally {\n-            in.close();\n","filename":"test\/langtools\/tools\/javac\/diags\/MessageInfo.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -264,2 +264,1 @@\n-            DataInputStream in = new DataInputStream(new FileInputStream(f));\n-            try {\n+            try (DataInputStream in = new DataInputStream(new FileInputStream(f))) {\n@@ -267,2 +266,0 @@\n-            } finally {\n-                in.close();\n","filename":"test\/langtools\/tools\/javac\/diags\/RunExamples.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,3 +39,3 @@\n-                Writer out = fo.openWriter();\n-                out.write(\"class Gen { }\");\n-                out.close();\n+                try (Writer out = fo.openWriter()) {\n+                    out.write(\"class Gen { }\");\n+                }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ProcFileCreateLastRound\/processors\/AnnoProc.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,3 +40,3 @@\n-                Writer out = fo1.openWriter();\n-                out.write(\"Hello World!\");\n-                out.close();\n+                try (Writer out = fo1.openWriter()) {\n+                    out.write(\"Hello World!\");\n+                }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ProcFileReopening\/processors\/AnnoProc.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,3 +40,3 @@\n-                Writer out = fo1.openWriter();\n-                out.write(\"Hello World!\");\n-                out.close();\n+                try (Writer out = fo1.openWriter()) {\n+                    out.write(\"Hello World!\");\n+                }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ProcIllegalFileName\/processors\/AnnoProc.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,3 +40,3 @@\n-                Writer out = fo.openWriter();\n-                out.write(\"class Gen { }\");\n-                out.close();\n+                try (Writer out = fo.openWriter()) {\n+                    out.write(\"class Gen { }\");\n+                }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ProcTypeRecreate\/processors\/AnnoProc.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,3 +39,3 @@\n-                Writer out = fo.openWriter();\n-                out.write(\"class Gen { }\");\n-                out.close();\n+                try (Writer out = fo.openWriter()) {\n+                    out.write(\"class Gen { }\");\n+                }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ProcUseImplicit\/processors\/AnnoProc.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,3 +39,3 @@\n-                Writer out = fo.openWriter();\n-                out.write(\"class Gen { }\");\n-                out.close();\n+                try (Writer out = fo.openWriter()) {\n+                    out.write(\"class Gen { }\");\n+                }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ProcUseProcOrImplicit\/processors\/AnnoProc.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-            String expected = getExpected(htmlFo.openReader(true));\n+            String expected = getExpectedAndClose(htmlFo.openReader(true));\n@@ -242,1 +242,1 @@\n-                        expected = getExpected(jfo.openReader(true));\n+                        expected = getExpectedAndClose(jfo.openReader(true));\n@@ -300,1 +300,1 @@\n-            String expected = getExpected(otherFo.openReader(true));\n+            String expected = getExpectedAndClose(otherFo.openReader(true));\n@@ -326,2 +326,1 @@\n-    String getExpected(Reader inrdr) throws IOException {\n-        BufferedReader rdr = new BufferedReader(inrdr);\n+    String getExpectedAndClose(Reader inrdr) throws IOException {\n@@ -329,4 +328,6 @@\n-        String line = rdr.readLine();\n-        while (line != null) {\n-            lines.add(line);\n-            line = rdr.readLine();\n+        try (BufferedReader rdr = new BufferedReader(inrdr)) {\n+            String line = rdr.readLine();\n+            while (line != null) {\n+                lines.add(line);\n+                line = rdr.readLine();\n+            }\n","filename":"test\/langtools\/tools\/javac\/doctree\/dcapi\/DocCommentTreeApiTester.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -121,2 +121,1 @@\n-            try {\n-                Writer w = filer.createSourceFile(\"p.C\").openWriter();\n+            try (Writer w = filer.createSourceFile(\"p.C\").openWriter()) {\n@@ -124,1 +123,0 @@\n-                w.close();\n","filename":"test\/langtools\/tools\/javac\/file\/T7068437.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -154,3 +154,2 @@\n-            try {\n-                String body = \"package p; public class C { public static void \" + m + \"() {} }\";\n-                Writer w = filer.createSourceFile(\"p.C\").openWriter();\n+            String body = \"package p; public class C { public static void \" + m + \"() {} }\";\n+            try (Writer w = filer.createSourceFile(\"p.C\").openWriter()) {\n@@ -158,1 +157,0 @@\n-                w.close();\n","filename":"test\/langtools\/tools\/javac\/file\/T7068451.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -82,5 +82,1 @@\n-        FileInputStream fis = null;\n-        BufferedInputStream bis = null;\n-        try {\n-            fis = new FileInputStream(inFile);\n-            bis = new BufferedInputStream(fis);\n+        try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFile))) {\n@@ -92,3 +88,0 @@\n-        } finally {\n-            Utils.close(bis);\n-            Utils.close(fis);\n@@ -112,5 +105,3 @@\n-        ZipOutputStream zos = null;\n-        BufferedOutputStream bos = null;\n-        FileInputStream fis = null;\n-        try {\n-            zos = new ZipOutputStream(new FileOutputStream(jarFile));\n+        try (\n+          ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(jarFile));\n+          BufferedOutputStream bos = new BufferedOutputStream(zos)) {\n@@ -119,1 +110,0 @@\n-            bos = new BufferedOutputStream(zos);\n@@ -135,2 +125,3 @@\n-            fis = new FileInputStream(classFile);\n-            Utils.copyStream(fis, bos);\n+            try (FileInputStream fis = new FileInputStream(classFile)) {\n+                Utils.copyStream(fis, bos);\n+            }\n@@ -139,4 +130,0 @@\n-        } finally {\n-            Utils.close(bos);\n-            Utils.close(zos);\n-            Utils.close(fis);\n@@ -151,2 +138,0 @@\n-        ZipOutputStream zos = null;\n-        FileInputStream fis = null;\n@@ -155,2 +140,1 @@\n-        try {\n-            zos = new ZipOutputStream(new FileOutputStream(jarFile));\n+        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(jarFile))) {\n@@ -173,2 +157,3 @@\n-            fis = new FileInputStream(classFile);\n-            Utils.copyStream(fis, zos);\n+            try (FileInputStream fis = new FileInputStream(classFile)) {\n+                Utils.copyStream(fis, zos);\n+            }\n@@ -176,5 +161,3 @@\n-            Utils.close(zos);\n-            Utils.close(fis);\n-        \/\/ deleted to prevent accidental linkage\n-        new File(Utils.getClassFileName(javaFile)).delete();\n-    }\n+            \/\/ deleted to prevent accidental linkage\n+            new File(Utils.getClassFileName(javaFile)).delete();\n+        }\n","filename":"test\/langtools\/tools\/javac\/file\/zip\/T6836682.java","additions":14,"deletions":31,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-        PrintStream ps = null;\n@@ -75,3 +74,1 @@\n-        try {\n-            FileOutputStream fos = new FileOutputStream(outFile);\n-            ps = new PrintStream(fos);\n+        try (PrintStream ps = new PrintStream(new FileOutputStream(outFile))) {\n@@ -79,2 +76,0 @@\n-        } finally {\n-            close(ps);\n@@ -119,11 +114,5 @@\n-        BufferedInputStream bis = null;\n-        BufferedOutputStream bos = null;\n-        FileOutputStream fos = null;\n-        try {\n-            fos = new FileOutputStream(output);\n-            bos = new BufferedOutputStream(fos);\n-            for (File x : files) {\n-                FileInputStream fis = new FileInputStream(x);\n-                bis = new BufferedInputStream(fis);\n-                copyStream(bis, bos);\n-                Utils.close(bis);\n+        try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(output))) {\n+            for (File file : files) {\n+                try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file))) {\n+                    copyStream(bis, bos);\n+                }\n@@ -131,4 +120,0 @@\n-        } finally {\n-            Utils.close(bis);\n-            Utils.close(bos);\n-            Utils.close(fos);\n","filename":"test\/langtools\/tools\/javac\/file\/zip\/Utils.java","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * @bug 8024947\n+ * @bug 8024947 8026369\n@@ -73,0 +73,70 @@\n+\n+\/\/ The test cases below are from JDK-8026369\n+\n+    interface I6 {\n+        void foo(Consumer<Integer> c);\n+    }\n+\n+    interface I7 {\n+        void foo(IntConsumer c);\n+    }\n+\n+    \/\/a warning should be fired, I8 is provoking the issue\n+    interface I8 extends I6, I7 { }\n+\n+    \/\/no warning here, the issue is introduced in I8\n+    interface I9 extends I8 { }\n+\n+    \/\/no warning here\n+    interface I10<T> {\n+        void foo(Consumer<Integer> c);\n+        void foo(T c);\n+    }\n+\n+    \/\/a warning should be fired, I11 is provoking the issue\n+    interface I11 extends I10<IntConsumer> { }\n+\n+    \/\/ No warning should be fired here\n+    interface I12<T> extends Consumer<T>, IntSupplier {\n+        \/\/ A warning should be fired here\n+        interface OfInt extends I12<Integer>, IntConsumer {\n+            @Override\n+            void accept(int value);\n+            default void accept(Integer i) { }\n+        }\n+        @Override\n+        default int getAsInt() { return 0; }\n+    }\n+\n+    \/\/ No warning should be fired here\n+    abstract static class C6<T> implements I12.OfInt { }\n+\n+    default <U> Object foo() {\n+        \/\/ No warning should be fired here\n+        return new C6<U>() {\n+            @Override\n+            public void accept(int value) { }\n+        };\n+    }\n+\n+    \/\/ Overrides should not trigger warnings\n+    interface I13 extends I8 {\n+        @Override\n+        void foo(Consumer<Integer> c);\n+        @Override\n+        void foo(IntConsumer c);\n+    }\n+    interface I14 extends I8 {\n+        @Override\n+        void foo(IntConsumer c);\n+    }\n+\n+    \/\/ Verify we can suppress warnings at the class level\n+    @SuppressWarnings(\"overloads\")\n+    interface I15 extends I8 { }        \/\/ would normally trigger a warning\n+\n+    \/\/ Verify we can suppress warnings at the method level\n+    interface I16 extends I2 {\n+        @SuppressWarnings(\"overloads\")\n+        void foo(IntConsumer c);        \/\/ would normally trigger a warning\n+    }\n","filename":"test\/langtools\/tools\/javac\/lambda\/T8024947\/PotentiallyAmbiguousWarningTest.java","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-PotentiallyAmbiguousWarningTest.java:15:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.I1, foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.I1\n-PotentiallyAmbiguousWarningTest.java:21:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.C1, foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.C1\n+PotentiallyAmbiguousWarningTest.java:16:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.I1, foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.I1\n+PotentiallyAmbiguousWarningTest.java:22:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.C1, foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.C1\n@@ -6,1 +6,4 @@\n-PotentiallyAmbiguousWarningTest.java:71:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.J2, foo(T), PotentiallyAmbiguousWarningTest.I5\n+PotentiallyAmbiguousWarningTest.java:71:14: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.J2, foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.I5\n+PotentiallyAmbiguousWarningTest.java:85:5: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.I7, foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.I6\n+PotentiallyAmbiguousWarningTest.java:97:5: compiler.warn.potentially.ambiguous.overload: foo(java.util.function.IntConsumer), PotentiallyAmbiguousWarningTest.I10, foo(java.util.function.Consumer<java.lang.Integer>), PotentiallyAmbiguousWarningTest.I10\n+PotentiallyAmbiguousWarningTest.java:102:9: compiler.warn.potentially.ambiguous.overload: andThen(java.util.function.IntConsumer), java.util.function.IntConsumer, andThen(java.util.function.Consumer<? super java.lang.Integer>), java.util.function.Consumer\n@@ -9,1 +12,1 @@\n-6 warnings\n+9 warnings\n","filename":"test\/langtools\/tools\/javac\/lambda\/T8024947\/PotentiallyAmbiguousWarningTest.out","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import java.io.InputStream;\n@@ -138,1 +139,4 @@\n-            ClassFile cf = ClassFile.read(output.openInputStream());\n+            ClassFile cf;\n+            try (InputStream input = output.openInputStream()) {\n+                cf = ClassFile.read(input);\n+            }\n","filename":"test\/langtools\/tools\/javac\/lambda\/deduplication\/DeduplicationTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -78,17 +78,5 @@\n-        FileInputStream fis = null;\n-        try {\n-            try {\n-                fis = new FileInputStream(file);\n-                byte[] bytes = new byte[fis.available()];\n-                int read = fis.read(bytes);\n-                if (read != bytes.length) {\n-                    return null;\n-                }\n-                if (preprocessors != null) {\n-                    for (ClassFilePreprocessor cfp : preprocessors) {\n-                        bytes = cfp.preprocess(name, bytes);\n-                    }\n-                 }\n-                return defineClass(name, bytes, 0, bytes.length);\n-            } finally {\n-                fis.close();\n+        try (FileInputStream fis = new FileInputStream(file)) {\n+            byte[] bytes = new byte[fis.available()];\n+            int read = fis.read(bytes);\n+            if (read != bytes.length) {\n+                return null;\n@@ -96,0 +84,6 @@\n+            if (preprocessors != null) {\n+                for (ClassFilePreprocessor cfp : preprocessors) {\n+                    bytes = cfp.preprocess(name, bytes);\n+                }\n+             }\n+            return defineClass(name, bytes, 0, bytes.length);\n","filename":"test\/langtools\/tools\/javac\/lambdaShapes\/org\/openjdk\/tests\/separate\/DirectedClassLoader.java","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -97,2 +97,1 @@\n-            Writer out = fo.openWriter();\n-            try {\n+            try (Writer out = fo.openWriter()) {\n@@ -100,2 +99,0 @@\n-            } finally {\n-                out.close();\n","filename":"test\/langtools\/tools\/javac\/options\/T7022337.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -93,2 +93,1 @@\n-        DataInputStream in = new DataInputStream(new FileInputStream(f));\n-        try {\n+        try (DataInputStream in = new DataInputStream(new FileInputStream(f))) {\n@@ -97,2 +96,0 @@\n-        } finally {\n-            in.close();\n","filename":"test\/langtools\/tools\/javac\/parser\/ExtraSemiTest.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.io.InputStream;\n@@ -407,1 +408,3 @@\n-                        cf = ClassFile.read(testClass.openInputStream());\n+                        try (InputStream input = testClass.openInputStream()) {\n+                            cf = ClassFile.read(input);\n+                        }\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewErrors.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-            try {\n-                Writer pw = filer.createSourceFile(\"HelloWorld\").openWriter();\n+            try (Writer pw = filer.createSourceFile(\"HelloWorld\").openWriter()) {\n@@ -59,1 +58,0 @@\n-                OutputStream os = filer.createClassFile(\"HelloWorldAP\").openOutputStream();\n@@ -61,5 +59,4 @@\n-                InputStream is = getClass().getResourceAsStream(\"HelloWorldAP.class\");\n-                copy(is, os);\n-                is.close();\n-                os.flush();\n-                os.close();\n+                try (OutputStream os = filer.createClassFile(\"HelloWorldAP\").openOutputStream();\n+                     InputStream is = getClass().getResourceAsStream(\"HelloWorldAP.class\")) {\n+                    copy(is, os);\n+                }\n","filename":"test\/langtools\/tools\/javac\/processing\/6350124\/HelloWorldAP.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -56,5 +56,5 @@\n-                Writer sub = filer.createSourceFile(sup.getSimpleName() + \"_GENERATED\").openWriter();\n-                sub.write(String.format(\"class %s_GENERATED extends %s {}\",\n-                                        sup.getSimpleName(),\n-                                        ((TypeElement)sup).getQualifiedName()));\n-                sub.close();\n+                try (Writer sub = filer.createSourceFile(sup.getSimpleName() + \"_GENERATED\").openWriter()) {\n+                    sub.write(String.format(\"class %s_GENERATED extends %s {}\",\n+                                            sup.getSimpleName(),\n+                                            ((TypeElement)sup).getQualifiedName()));\n+                }\n","filename":"test\/langtools\/tools\/javac\/processing\/6413690\/T6413690.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -81,3 +81,1 @@\n-        DataInputStream in = null;\n-        try {\n-            in = new DataInputStream(new FileInputStream(pkgInfo));\n+        try (DataInputStream in = new DataInputStream(new FileInputStream(pkgInfo))) {\n@@ -87,8 +85,0 @@\n-        } finally {\n-            if(in != null) {\n-                try {\n-                    in.close();\n-                } catch (IOException e) {\n-                    error(\"InputStream closing failed: \" + e);\n-                }\n-            }\n@@ -97,6 +87,3 @@\n-        OutputStream out = null;\n-        try {\n-            if (kind.equals(\"java\"))\n-                out = filer.createSourceFile(\"foo.package-info\").openOutputStream();\n-            else\n-                out = filer.createClassFile(\"foo.package-info\").openOutputStream();\n+        try (OutputStream out = kind.equals(\"java\") ?\n+              filer.createSourceFile(\"foo.package-info\").openOutputStream() :\n+              filer.createClassFile(\"foo.package-info\").openOutputStream()) {\n@@ -106,8 +93,0 @@\n-        } finally {\n-            if(out != null) {\n-                try {\n-                    out.close();\n-                } catch (IOException e) {\n-                    error(\"OutputStream closing failed: \" + e);\n-                }\n-            }\n","filename":"test\/langtools\/tools\/javac\/processing\/6499119\/ClassProcessor.java","additions":4,"deletions":25,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-                PrintWriter pw = new PrintWriter(filer.createSourceFile(\"foo.WrittenAfterProcessing\").openWriter());\n-                try {\n+                try (PrintWriter pw = new PrintWriter(filer.createSourceFile(\"foo.WrittenAfterProcessing\").openWriter())) {\n@@ -64,2 +63,0 @@\n-                 } finally {\n-                     pw.close();\n@@ -68,2 +65,1 @@\n-                pw = new PrintWriter(filer.createSourceFile(\"foo.package-info\").openWriter());\n-                try {\n+                try (PrintWriter pw = new PrintWriter(filer.createSourceFile(\"foo.package-info\").openWriter())) {\n@@ -72,2 +68,0 @@\n-                 } finally {\n-                     pw.close();\n","filename":"test\/langtools\/tools\/javac\/processing\/6634138\/T6634138.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -87,2 +87,1 @@\n-        try {\n-            Writer out = filer.createSourceFile(\"Foo\").openWriter();\n+        try (Writer out = filer.createSourceFile(\"Foo\").openWriter()) {\n@@ -90,1 +89,0 @@\n-            out.close();\n","filename":"test\/langtools\/tools\/javac\/processing\/T6439826.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -409,3 +409,1 @@\n-            DataInputStream in = null;\n-            try {\n-                in = new DataInputStream(new FileInputStream(file));\n+            try (DataInputStream in = new DataInputStream(new FileInputStream(file))) {\n@@ -415,8 +413,0 @@\n-            } finally {\n-                if (in != null) {\n-                    try {\n-                        in.close();\n-                    } catch (IOException e) {\n-                        error(\"Error closing file: \" + e);\n-                    }\n-                }\n@@ -429,3 +419,1 @@\n-            OutputStream out = null;\n-            try {\n-                out = file.openOutputStream();\n+            try (OutputStream out = file.openOutputStream()) {\n@@ -435,8 +423,0 @@\n-            } finally {\n-                if (out != null) {\n-                    try {\n-                        out.close();\n-                    } catch (IOException e) {\n-                        error(\"Error closing file: \" + e);\n-                    }\n-                }\n","filename":"test\/langtools\/tools\/javac\/processing\/T6920317.java","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -325,2 +325,1 @@\n-            Writer out = fo.openWriter();\n-            try {\n+            try (Writer out = fo.openWriter()) {\n@@ -331,2 +330,0 @@\n-            } finally {\n-                out.close();\n","filename":"test\/langtools\/tools\/javac\/processing\/TestWarnErrorCount.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -235,3 +235,3 @@\n-                Writer out = fo.openWriter();\n-                out.write(text);\n-                out.close();\n+                try (Writer out = fo.openWriter()) {\n+                    out.write(text);\n+                }\n","filename":"test\/langtools\/tools\/javac\/processing\/errors\/TestSuppression.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,4 +68,4 @@\n-                    PrintWriter pw =\n-                        new PrintWriter(filer.createResource(CLASS_OUTPUT, PKG, RESOURCE_NAME).openWriter());\n-                    pw.print(CONTENTS);\n-                    pw.close();\n+                    try (PrintWriter pw =\n+                        new PrintWriter(filer.createResource(CLASS_OUTPUT, PKG, RESOURCE_NAME).openWriter())) {\n+                        pw.print(CONTENTS);\n+                    }\n","filename":"test\/langtools\/tools\/javac\/processing\/filer\/TestGetResource.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,3 +49,3 @@\n-                Writer out = fo.openWriter();\n-                out.write(\"class LastRound { }\");\n-                out.close();\n+                try (Writer out = fo.openWriter()) {\n+                    out.write(\"class LastRound { }\");\n+                }\n","filename":"test\/langtools\/tools\/javac\/processing\/filer\/TestLastRound.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,2 +64,1 @@\n-            Writer out = fo.openWriter();\n-            try {\n+            try (Writer out = fo.openWriter()) {\n@@ -86,2 +85,0 @@\n-            } finally {\n-                out.close();\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestMissingElement2\/Generator.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,3 +79,2 @@\n-            try {\n-                \/\/ Force another round with a new context\n-                PrintWriter pw = new PrintWriter(filer.createSourceFile(\"Foo\").openWriter());\n+            \/\/ Force another round with a new context\n+            try (PrintWriter pw = new PrintWriter(filer.createSourceFile(\"Foo\").openWriter())) {\n@@ -83,1 +82,0 @@\n-                pw.close();\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestNames.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,11 +68,9 @@\n-            try {\n-                PrintWriter pw = new PrintWriter(filer.createSourceFile(\"ConstantTest\").openWriter());\n-                try {\n-                    Boolean[]   booleans = {true, false};\n-                    Byte[]      bytes    = {Byte.MIN_VALUE,    -1,  0, 1,  Byte.MAX_VALUE};\n-                    Short[]     shorts   = {Short.MIN_VALUE,   -1,  0, 1,  Short.MAX_VALUE};\n-                    Integer[]   ints     = {Integer.MIN_VALUE, -1,  0, 1,  Integer.MAX_VALUE};\n-                    Long[]      longs    = {Long.MIN_VALUE,    -1L, 0L,1L, Long.MAX_VALUE};\n-                    Character[] chars    = {Character.MIN_VALUE, ' ', '\\t', 'a', 'b', 'c', '~', Character.MAX_VALUE};\n-                    Float[]     floats   = {Float.NaN,  Float.NEGATIVE_INFINITY,  -1.0f, -0.0f, 0.0f, 1.0f, Float.POSITIVE_INFINITY};\n-                    Double[]    doubles  = {Double.NaN, Double.NEGATIVE_INFINITY, -1.0,  -0.0,  0.0,  1.0,  Double.POSITIVE_INFINITY};\n+            try (PrintWriter pw = new PrintWriter(filer.createSourceFile(\"ConstantTest\").openWriter())) {\n+                Boolean[]   booleans = {true, false};\n+                Byte[]      bytes    = {Byte.MIN_VALUE,    -1,  0, 1,  Byte.MAX_VALUE};\n+                Short[]     shorts   = {Short.MIN_VALUE,   -1,  0, 1,  Short.MAX_VALUE};\n+                Integer[]   ints     = {Integer.MIN_VALUE, -1,  0, 1,  Integer.MAX_VALUE};\n+                Long[]      longs    = {Long.MIN_VALUE,    -1L, 0L,1L, Long.MAX_VALUE};\n+                Character[] chars    = {Character.MIN_VALUE, ' ', '\\t', 'a', 'b', 'c', '~', Character.MAX_VALUE};\n+                Float[]     floats   = {Float.NaN,  Float.NEGATIVE_INFINITY,  -1.0f, -0.0f, 0.0f, 1.0f, Float.POSITIVE_INFINITY};\n+                Double[]    doubles  = {Double.NaN, Double.NEGATIVE_INFINITY, -1.0,  -0.0,  0.0,  1.0,  Double.POSITIVE_INFINITY};\n@@ -80,21 +78,18 @@\n-                    pw.println(\"class ConstantTest {\");\n-                    pw.println(String.format(\"  private static boolean[] booleans = {%s};\",\n-                                             printConstants(booleans)));\n-                    pw.println(String.format(\"  private static byte[] bytes = {%s};\",\n-                                             printConstants(bytes)));\n-                    pw.println(String.format(\"  private static short[] shorts = {%s};\",\n-                                             printConstants(shorts)));\n-                    pw.println(String.format(\"  private static int[] ints = {%s};\",\n-                                             printConstants(ints)));\n-                    pw.println(String.format(\"  private static long[] longs = {%s};\",\n-                                             printConstants(longs)));\n-                    pw.println(String.format(\"  private static char[] chars = {%s};\",\n-                                             printConstants(chars)));\n-                    pw.println(String.format(\"  private static float[] floats = {%s};\",\n-                                             printConstants(floats)));\n-                    pw.println(String.format(\"  private static double[] doubles = {%s};\",\n-                                             printConstants(doubles)));\n-                    pw.println(\"}\");\n-                } finally {\n-                    pw.close();\n-                }\n+                pw.println(\"class ConstantTest {\");\n+                pw.println(String.format(\"  private static boolean[] booleans = {%s};\",\n+                                         printConstants(booleans)));\n+                pw.println(String.format(\"  private static byte[] bytes = {%s};\",\n+                                         printConstants(bytes)));\n+                pw.println(String.format(\"  private static short[] shorts = {%s};\",\n+                                         printConstants(shorts)));\n+                pw.println(String.format(\"  private static int[] ints = {%s};\",\n+                                         printConstants(ints)));\n+                pw.println(String.format(\"  private static long[] longs = {%s};\",\n+                                         printConstants(longs)));\n+                pw.println(String.format(\"  private static char[] chars = {%s};\",\n+                                         printConstants(chars)));\n+                pw.println(String.format(\"  private static float[] floats = {%s};\",\n+                                         printConstants(floats)));\n+                pw.println(String.format(\"  private static double[] doubles = {%s};\",\n+                                         printConstants(doubles)));\n+                pw.println(\"}\");\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/TestGetConstantExpression.java","additions":27,"deletions":32,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -192,2 +192,1 @@\n-                Writer out = fo.openWriter();\n-                try {\n+                try (Writer out = fo.openWriter()) {\n@@ -195,2 +194,0 @@\n-                } finally {\n-                    out.close();\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/doccomments\/TestDocComments.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,9 +60,2 @@\n-\n-        \/\/ avoid try-with-resources so test can be run on older builds\n-        try {\n-            Writer out = filer.createSourceFile(name).openWriter();\n-            try {\n-                out.write(text);\n-            } finally {\n-                out.close();\n-            }\n+        try (Writer out = filer.createSourceFile(name).openWriter()) {\n+            out.write(text);\n","filename":"test\/langtools\/tools\/javac\/processing\/options\/testPrintProcessorInfo\/Test.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n-            out.close();\n","filename":"test\/langtools\/tools\/javac\/processing\/rounds\/BaseClassesNotReRead.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,3 +50,3 @@\n-                Writer out = fo.openWriter();\n-                out.write(\"import java.util.*; class Gen { List l; }\");\n-                out.close();\n+                try (Writer out = fo.openWriter()) {\n+                    out.write(\"import java.util.*; class Gen { List l; }\");\n+                }\n","filename":"test\/langtools\/tools\/javac\/processing\/werror\/WErrorGen.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,3 +48,3 @@\n-        PrintStream s = new PrintStream(new FileOutputStream(f));\n-        s.println(contents);\n-        s.close();\n+        try (PrintStream s = new PrintStream(new FileOutputStream(f))) {\n+            s.println(contents);\n+        }\n","filename":"test\/langtools\/tools\/javac\/sealed\/ValidateJarWithSealedAndRecord.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.io.InputStream;\n@@ -114,1 +115,4 @@\n-                byte[] data = file.openInputStream().readAllBytes();\n+                byte[] data;\n+                try (InputStream input = file.openInputStream()) {\n+                    data = input.readAllBytes();\n+                }\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/SwitchExpressionNoValue.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -123,2 +123,1 @@\n-            Writer out = fo.openWriter();\n-            try {\n+            try (Writer out = fo.openWriter()) {\n@@ -126,2 +125,0 @@\n-            } finally {\n-                out.close();\n","filename":"test\/langtools\/tools\/javac\/tree\/TreePosRoundsTest.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ * This benchmark naively explores String::regionMatches, ignoring case\n+ *\/\n+\n+public class RegionMatchesIC {\n+\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @State(Scope.Benchmark)\n+    @Warmup(iterations = 5, time = 1)\n+    @Measurement(iterations = 5, time = 1)\n+    @Fork(value = 3)\n+    public static class Latin1 {\n+\n+        @Param({\"1024\"})\n+        public int size;\n+\n+        @Param({\"ascii-match\",\n+                \"ascii-mismatch\",\n+                \"number-match\",\n+                \"number-mismatch\",\n+                \"lat1-match\",\n+                \"lat1-mismatch\"})\n+        String codePoints;\n+        private String leftString;\n+        private String rightString;\n+\n+        @Setup\n+        public void setup() {\n+\n+            switch (codePoints) {\n+                case \"ascii-match\" -> {\n+                    leftString  = \"a\".repeat(size);\n+                    rightString = \"A\".repeat(size);\n+                }\n+                case \"ascii-mismatch\" -> {\n+                    leftString  = \"a\".repeat(size);\n+                    rightString = \"b\".repeat(size);\n+                }\n+                case \"number-match\" -> {\n+                    leftString  = \"7\".repeat(size);\n+                    rightString = \"7\".repeat(size);\n+                }\n+                case \"number-mismatch\" -> {\n+                    leftString  = \"7\".repeat(size);\n+                    rightString = \"9\".repeat(size);\n+                }\n+                case \"lat1-match\" -> {\n+                    leftString  = \"\\u00e5\".repeat(size);\n+                    rightString = \"\\u00c5\".repeat(size);\n+                }\n+                case \"lat1-mismatch\" -> {\n+                    leftString  = \"\\u00e5\".repeat(size);\n+                    rightString = \"\\u00c6\".repeat(size);\n+                }\n+                default -> throw new IllegalArgumentException(\"Unsupported coding: \" + codePoints);\n+            }\n+            \/\/ Make sure strings do not String.equals by adding a prefix\n+            leftString = \"l\" + leftString;\n+            rightString = \"r\" + rightString;\n+        }\n+\n+        @Benchmark\n+        public boolean regionMatchesIC() {\n+            return leftString.regionMatches(true, 1, rightString, 1, size);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/RegionMatchesIC.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.Main;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/**\n+ * Exploration of vectorized latin1 equalsIgnoreCase taking advantage of the fact\n+ * that ASCII and Latin1 were designed to optimize case-twiddling operations.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class EqualsIgnoreCaseBenchmark {\n+    static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_PREFERRED;\n+    private byte[] a;\n+    private byte[] b;\n+    private int len;\n+    @Param({\"16\", \"32\", \"64\", \"128\", \"1024\"})\n+    private int size;\n+\n+    @Setup\n+    public void setup() {\n+        a = (\"a\\u00e5\".repeat(size\/2) + \"A\").getBytes(StandardCharsets.ISO_8859_1);\n+        b = (\"A\\u00c5\".repeat(size\/2) + \"B\").getBytes(StandardCharsets.ISO_8859_1);\n+        len = a.length;\n+    }\n+\n+    @Benchmark\n+    public boolean scalar() {\n+        return scalarEqualsIgnoreCase(a, b, len);\n+    }\n+\n+    @Benchmark\n+    public boolean vectorized() {\n+        return vectorizedEqualsIgnoreCase(a, b, len);\n+    }\n+\n+    private boolean vectorizedEqualsIgnoreCase(byte[] a, byte[] b, int len) {\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(b.length); i += SPECIES.length()) {\n+            ByteVector va = ByteVector.fromArray(SPECIES, a, i);\n+            ByteVector vb = ByteVector.fromArray(SPECIES, b, i);\n+            VectorMask<Byte> equal = va.eq(vb);\n+\n+            \/\/ If all bytes are equal, we can skip ahead early\n+            if (equal.allTrue()) {\n+                continue;\n+            }\n+\n+            \/\/ ASCII and Latin-1 were designed to optimize case-twiddling operations\n+            ByteVector upperA = va.and((byte) 0xDF);\n+\n+            \/\/ Determine which bytes represent ASCII or Latin-1 letters:\n+            VectorMask<Byte> asciiLetter = upperA.compare(GT, (byte) '@')\n+                    .and(upperA.compare(LT, (byte) '['));\n+\n+            VectorMask<Byte> lat1Letter = upperA\n+                    .compare(LT, (byte) 0xDF)  \/\/ <= Thorn\n+                    .and(upperA.compare(GT, (byte) 0XBF)) \/\/ >= A-grave\n+                    .and(upperA.compare(EQ, (byte) 0xD7).not()); \/\/ Excluding multiplication\n+\n+            VectorMask<Byte> letter = asciiLetter.or(lat1Letter);\n+\n+            \/\/ Uppercase b\n+            ByteVector upperB = vb.and((byte) 0xDF);\n+\n+            \/\/ va equalsIgnoreCase vb if:\n+            \/\/ 1: all bytes are equal, or\n+            \/\/ 2: all bytes are letters in the ASCII or latin1 ranges\n+            \/\/    AND their uppercase is the same\n+            VectorMask<Byte> equalsIgnoreCase = equal\n+                    .or(letter.and(upperA.eq(upperB)));\n+\n+            if (equalsIgnoreCase.allTrue()) {\n+                continue;\n+            } else {\n+                return false;\n+            }\n+        }\n+        \/\/ Process the tail\n+        while (i < len) {\n+            byte b1 = a[i];\n+            byte b2 = b[i];\n+            if (equalsIgnoreCase(b1, b2)) {\n+                i++;\n+                continue;\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public boolean scalarEqualsIgnoreCase(byte[] a, byte[] b, int len) {\n+        int i = 0;\n+        while (i < len) {\n+            byte b1 = a[i];\n+            byte b2 = b[i];\n+            if (equalsIgnoreCase(b1, b2)) {\n+                i++;\n+                continue;\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    static boolean equalsIgnoreCase(byte b1, byte b2) {\n+        if (b1 == b2) {\n+            return true;\n+        }\n+        \/\/ ASCII and Latin-1 were designed to optimize case-twiddling operations\n+        int upper = b1 & 0xDF;\n+        if (upper < 'A') {\n+            return false;  \/\/ Low ASCII\n+        }\n+        return (upper <= 'Z' \/\/ In range A-Z\n+                || (upper >= 0xC0 && upper <= 0XDE && upper != 0xD7)) \/\/ ..or A-grave-Thorn, excl. multiplication\n+                && upper == (b2 & 0xDF); \/\/ b2 has same uppercase\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/EqualsIgnoreCaseBenchmark.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"}]}