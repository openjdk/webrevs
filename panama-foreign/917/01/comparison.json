{"files":[{"patch":"@@ -7,1 +7,1 @@\n-error=author,committer,reviewers,merge,executable,symlink,message,hg-tag,whitespace,problemlists\n+error=author,committer,reviewers,merge,executable,symlink,message,hg-tag,whitespace,problemlists,copyright\n@@ -33,0 +33,5 @@\n+\n+[checks \"copyright\"]\n+files=^(?!LICENSE|license\\.txt|.*\\.bin|.*\\.gif|.*\\.jpg|.*\\.png|.*\\.icon|.*\\.tiff|.*\\.dat|.*\\.patch|.*\\.wav|.*\\.class|.*-header|.*\\.jar|).*\n+oracle_locator=.*Copyright \\(c\\)(.*)Oracle and\/or its affiliates\\. All rights reserved\\.\n+oracle_validator=.*Copyright \\(c\\) (\\d{4})(?:, (\\d{4}))?, Oracle and\/or its affiliates\\. All rights reserved\\.\n","filename":".jcheck\/conf","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1313,1 +1313,4 @@\n-all-images: product-images static-jdk-image test-image all-docs-images\n+all-images: product-images test-image all-docs-images\n+ifeq ($(call isTargetOs, linux macosx windows), true)\n+  all-images: static-jdk-image\n+endif\n","filename":"make\/Main.gmk","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-          -Wunused-result -Wunused-value\"\n+          -Wunused-result -Wunused-value -Wtype-limits -Wuninitialized\"\n@@ -757,4 +757,3 @@\n-    FLAGS_SETUP_GCC6_COMPILER_FLAGS($1, $3)\n-    $1_TOOLCHAIN_CFLAGS=\"${$1_GCC6_CFLAGS}\"\n-\n-    $1_WARNING_CFLAGS_JVM=\"-Wno-format-zero-length -Wtype-limits -Wuninitialized\"\n+    # This flag is required since GCC 6 as undefined behavior in OpenJDK code\n+    # runs afoul of the more aggressive versions of this optimization.\n+    $1_TOOLCHAIN_CFLAGS=\"-fno-lifetime-dse\"\n@@ -922,14 +921,0 @@\n-# FLAGS_SETUP_GCC6_COMPILER_FLAGS([PREFIX])\n-# Arguments:\n-# $1 - Prefix for each variable defined.\n-# $2 - Prefix for compiler variables (either BUILD_ or nothing).\n-AC_DEFUN([FLAGS_SETUP_GCC6_COMPILER_FLAGS],\n-[\n-  # This flag is required for GCC 6 builds as undefined behavior in OpenJDK code\n-  # runs afoul of the more aggressive versions of this optimization.\n-  NO_LIFETIME_DSE_CFLAG=\"-fno-lifetime-dse\"\n-  FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [$NO_LIFETIME_DSE_CFLAG],\n-      PREFIX: $2, IF_FALSE: [NO_LIFETIME_DSE_CFLAG=\"\"])\n-  $1_GCC6_CFLAGS=\"${NO_LIFETIME_DSE_CFLAG}\"\n-])\n-\n","filename":"make\/autoconf\/flags-cflags.m4","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -783,1 +783,1 @@\n-                \"boot_jdk\", \"devkit\", \"graphviz\", \"pandoc\", buildJdkDep,\n+                \"autoconf\", \"boot_jdk\", \"devkit\", \"graphviz\", \"pandoc\", buildJdkDep,\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    empty-body implicit-fallthrough int-in-bool-context \\\n+    empty-body format-zero-length implicit-fallthrough int-in-bool-context \\\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -449,1 +449,1 @@\n-        public Void visitRecordComponent(@SuppressWarnings(\"preview\")RecordComponentElement e, Void p) {\n+        public Void visitRecordComponent(RecordComponentElement e, Void p) {\n","filename":"make\/jdk\/src\/classes\/build\/tools\/depend\/Depend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -231,1 +231,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -4637,1 +4636,0 @@\n-    @SuppressWarnings(\"unchecked\")\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import java.util.Map.Entry;\n@@ -90,0 +91,1 @@\n+        FACTORY_METHOD_BODY_LINT(\"factory.decl.method.body.lint\"),\n@@ -91,0 +93,1 @@\n+        FACTORY_FIELD_LINT(\"factory.decl.field.lint\"),\n@@ -92,1 +95,2 @@\n-        SUPPRESS_WARNINGS(\"suppress.warnings\");\n+        SUPPRESS_WARNINGS(\"suppress.warnings\"),\n+        LINT_CATEGORY(\"lint.category\");\n@@ -117,0 +121,1 @@\n+        LINT_WARN(\"warn\", \"LintWarning\", \"LintWarnings\"),\n@@ -139,1 +144,3 @@\n-        static FactoryKind parseFrom(String prefix) {\n+        static FactoryKind of(Entry<String, Message> messageEntry) {\n+            String prefix = messageEntry.getKey().split(\"\\\\.\")[1];\n+            FactoryKind selected = null;\n@@ -142,1 +149,2 @@\n-                    return k;\n+                    selected = k;\n+                    break;\n@@ -145,1 +153,9 @@\n-            return null;\n+            if (selected == WARN) {\n+                for (MessageLine line : messageEntry.getValue().getLines(false)) {\n+                    if (line.isLint()) {\n+                        selected = LINT_WARN;\n+                        break;\n+                    }\n+                }\n+            }\n+            return selected;\n@@ -158,1 +174,1 @@\n-                                        e -> FactoryKind.parseFrom(e.getKey().split(\"\\\\.\")[1]),\n+                                        FactoryKind::of,\n@@ -168,1 +184,1 @@\n-                    .flatMap(e -> generateFactoryMethodsAndFields(e.getKey(), e.getValue()).stream())\n+                    .flatMap(e -> generateFactoryMethodsAndFields(entry.getKey(), e.getKey(), e.getValue()).stream())\n@@ -233,1 +249,1 @@\n-    List<String> generateFactoryMethodsAndFields(String key, Message msg) {\n+    List<String> generateFactoryMethodsAndFields(FactoryKind k, String key, Message msg) {\n@@ -241,1 +257,5 @@\n-        FactoryKind k = FactoryKind.parseFrom(keyParts[1]);\n+        String lintCategory = lines.stream()\n+                .filter(MessageLine::isLint)\n+                .map(MessageLine::lintCategory)\n+                .findFirst().orElse(null);\n+        \/\/System.out.println(\"category for \" + key + \" = \" + lintCategory);\n@@ -245,4 +265,13 @@\n-            String factoryField = StubKind.FACTORY_FIELD.format(k.keyClazz, factoryName,\n-                    \"\\\"\" + keyParts[0] + \"\\\"\",\n-                    \"\\\"\" + Stream.of(keyParts).skip(2).collect(Collectors.joining(\".\")) + \"\\\"\",\n-                    javadoc);\n+            String factoryField;\n+            if (lintCategory == null) {\n+                factoryField = StubKind.FACTORY_FIELD.format(k.keyClazz, factoryName,\n+                        \"\\\"\" + keyParts[0] + \"\\\"\",\n+                        \"\\\"\" + Stream.of(keyParts).skip(2).collect(Collectors.joining(\".\")) + \"\\\"\",\n+                        javadoc);\n+            } else {\n+                factoryField = StubKind.FACTORY_FIELD_LINT.format(k.keyClazz, factoryName,\n+                        StubKind.LINT_CATEGORY.format(\"\\\"\" + lintCategory + \"\\\"\"),\n+                        \"\\\"\" + keyParts[0] + \"\\\"\",\n+                        \"\\\"\" + Stream.of(keyParts).skip(2).collect(Collectors.joining(\".\")) + \"\\\"\",\n+                        javadoc);\n+            }\n@@ -258,0 +287,13 @@\n+                String methodBody;\n+                if (lintCategory == null) {\n+                    methodBody = StubKind.FACTORY_METHOD_BODY.format(k.keyClazz,\n+                            \"\\\"\" + keyParts[0] + \"\\\"\",\n+                            \"\\\"\" + Stream.of(keyParts).skip(2).collect(Collectors.joining(\".\")) + \"\\\"\",\n+                            argNames.stream().collect(Collectors.joining(\", \")));\n+                } else {\n+                    methodBody = StubKind.FACTORY_METHOD_BODY_LINT.format(k.keyClazz,\n+                            StubKind.LINT_CATEGORY.format(\"\\\"\" + lintCategory + \"\\\"\"),\n+                            \"\\\"\" + keyParts[0] + \"\\\"\",\n+                            \"\\\"\" + Stream.of(keyParts).skip(2).collect(Collectors.joining(\".\")) + \"\\\"\",\n+                            argNames.stream().collect(Collectors.joining(\", \")));\n+                }\n@@ -260,4 +302,1 @@\n-                        indent(StubKind.FACTORY_METHOD_BODY.format(k.keyClazz,\n-                                \"\\\"\" + keyParts[0] + \"\\\"\",\n-                                \"\\\"\" + Stream.of(keyParts).skip(2).collect(Collectors.joining(\".\")) + \"\\\"\",\n-                                argNames.stream().collect(Collectors.joining(\", \"))), 1),\n+                        indent(methodBody, 1),\n","filename":"make\/langtools\/tools\/propertiesparser\/gen\/ClassGenerator.java","additions":55,"deletions":16,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -52,0 +52,3 @@\n+            if (l != null && l.isLint()) {\n+                l = l.prev;\n+            }\n@@ -74,1 +77,1 @@\n-            if (l.prev != null && l.prev.isInfo())\n+            if (l.prev != null && (l.prev.isInfo() || l.prev.isLint()))\n","filename":"make\/langtools\/tools\/propertiesparser\/parser\/Message.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.regex.Matcher;\n@@ -40,0 +41,1 @@\n+    static final Pattern lintPattern = Pattern.compile(\"# lint: ([a-z\\\\-]+)\");\n@@ -57,0 +59,13 @@\n+    public boolean isLint() {\n+        return lintPattern.matcher(text).matches();\n+    }\n+\n+    public String lintCategory() {\n+        Matcher matcher = lintPattern.matcher(text);\n+        if (matcher.matches()) {\n+            return matcher.group(1);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n","filename":"make\/langtools\/tools\/propertiesparser\/parser\/MessageLine.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+    import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\\n\\\n@@ -34,0 +35,1 @@\n+    import com.sun.tools.javac.code.Lint.LintCategory;\\n\\\n@@ -61,0 +63,3 @@\n+factory.decl.method.body.lint=\\\n+    return new {0}({1}, {2}, {3}, {4});\n+\n@@ -67,0 +72,6 @@\n+factory.decl.field.lint=\\\n+    \/**\\n\\\n+    ' '* {5}\\n\\\n+    ' '*\/\\n\\\n+    public static final {0} {1} = new {0}({2}, {3}, {4});\n+\n@@ -73,0 +84,2 @@\n+lint.category=\\\n+  LintCategory.get({0}).get()\n","filename":"make\/langtools\/tools\/propertiesparser\/resources\/templates.properties","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -286,1 +286,1 @@\n-      EXTRA_HEADER_DIRS := libfreetype\/include, \\\n+      EXTRA_HEADER_DIRS := java.base:libjava libfreetype\/include, \\\n","filename":"make\/modules\/java.desktop\/lib\/ClientLibraries.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+MICROBENCHMARK_GENSRC := $(MICROBENCHMARK_OUTPUT)\/gensrc\n@@ -107,1 +108,2 @@\n-        -processor org.openjdk.jmh.generators.BenchmarkProcessor, \\\n+        -processor org.openjdk.jmh.generators.BenchmarkProcessor \\\n+        -s $(MICROBENCHMARK_GENSRC), \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/c2_init_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-\/\/ Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+\/\/ Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/ppc\/vtableStubs_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-          __ zero_extend(t1, t1, shift);\n+          __ zext(t1, t1, shift);\n@@ -81,1 +81,1 @@\n-          __ zero_extend(t0, t0, shift);\n+          __ zext(t0, t0, shift);\n@@ -208,1 +208,1 @@\n-            __ zero_extend(t0, t0, shift);\n+            __ zext(t0, t0, shift);\n@@ -227,1 +227,1 @@\n-            __ zero_extend(t1, t1, shift);\n+            __ zext(t1, t1, shift);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_arith_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -955,1 +955,1 @@\n-      __ zero_extend(dest->as_register(), src->as_register(), 16); break;\n+      __ zext(dest->as_register(), src->as_register(), 16); break;\n@@ -957,1 +957,1 @@\n-      __ sign_extend(dest->as_register_lo(), src->as_register(), 32); break;\n+      __ sext(dest->as_register_lo(), src->as_register(), 32); break;\n@@ -959,1 +959,1 @@\n-      __ sign_extend(dest->as_register(), src->as_register(), 16); break;\n+      __ sext(dest->as_register(), src->as_register(), 16); break;\n@@ -961,1 +961,1 @@\n-      __ sign_extend(dest->as_register(), src->as_register(), 8); break;\n+      __ sext(dest->as_register(), src->as_register(), 8); break;\n@@ -963,1 +963,1 @@\n-      __ sign_extend(dest->as_register(), src->as_register_lo(), 32); break;\n+      __ sext(dest->as_register(), src->as_register_lo(), 32); break;\n@@ -1291,1 +1291,1 @@\n-        __ sign_extend(Rdst, Rdst, 32);\n+        __ sext(Rdst, Rdst, 32);\n@@ -1612,1 +1612,1 @@\n-  __ zero_extend(crc, crc, 32);\n+  __ zext(crc, crc, 32);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -790,1 +790,2 @@\n-  ctzc_bit(trailing_char, match_mask, isL, ch1, result);\n+  \/\/ count bits of trailing zero chars\n+  ctzc_bits(trailing_char, match_mask, isL, ch1, result);\n@@ -1030,1 +1031,1 @@\n-    andi(tmp6, tmp6, 0xff); \/\/ pattern[m-4], 0x0000000d\n+    zext(tmp6, tmp6, 8); \/\/ pattern[m-4], 0x0000000d\n@@ -1539,1 +1540,2 @@\n-    ctzc_bit(result, tmp3, isLL); \/\/ count zero from lsb to msb\n+    \/\/ count bits of trailing zero chars\n+    ctzc_bits(result, tmp3, isLL);\n@@ -1543,2 +1545,2 @@\n-      andi(tmp1, tmp1, 0xFF);\n-      andi(tmp2, tmp2, 0xFF);\n+      zext(tmp1, tmp1, 8);\n+      zext(tmp2, tmp2, 8);\n@@ -1546,2 +1548,2 @@\n-      andi(tmp1, tmp1, 0xFFFF);\n-      andi(tmp2, tmp2, 0xFFFF);\n+      zext(tmp1, tmp1, 16);\n+      zext(tmp2, tmp2, 16);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-  sign_extend(result, result, 8);\n+  sext(result, result, 8);\n@@ -79,1 +79,1 @@\n-  zero_extend(result, result, 16);\n+  zext(result, result, 16);\n@@ -83,1 +83,1 @@\n-  sign_extend(result, result, 16);\n+  sext(result, result, 16);\n@@ -86,1 +86,1 @@\n-  sign_extend(result, result, 32);\n+  sext(result, result, 32);\n@@ -279,1 +279,1 @@\n-  sign_extend(r, r, 32);\n+  sext(r, r, 32);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1539,3 +1539,0 @@\n-static const int64_t right_32_bits = right_n_bits(32);\n-static const int64_t right_8_bits = right_n_bits(8);\n-\n@@ -1558,1 +1555,1 @@\n-  andi(val, val, right_8_bits);\n+  zext(val, val, 8);\n@@ -1588,1 +1585,1 @@\n-  andi(tmp1, v, right_8_bits);\n+  zext(tmp1, v, 8);\n@@ -2089,1 +2086,5 @@\n-  mv(tmp5, right_32_bits);\n+\n+  \/\/ tmp5 = 0xffffffff\n+  notr(tmp5, zr);\n+  srli(tmp5, tmp5, 32);\n+\n@@ -2113,1 +2114,1 @@\n-    andi(tmp2, tmp1, right_8_bits);\n+    zext(tmp2, tmp1, 8);\n@@ -2637,1 +2638,1 @@\n-  sign_extend(Rd, Rd, 32);\n+  sext(Rd, Rd, 32);\n@@ -2642,1 +2643,1 @@\n-  sign_extend(Rd, Rd, 32);\n+  sext(Rd, Rd, 32);\n@@ -2647,1 +2648,1 @@\n-  sign_extend(Rd, Rd, 32);\n+  sext(Rd, Rd, 32);\n@@ -2835,1 +2836,1 @@\n-  andi(tmp1, Rs, 0xFF);\n+  zext(tmp1, Rs, 8);\n@@ -2839,1 +2840,1 @@\n-    andi(tmp2, tmp2, 0xFF);\n+    zext(tmp2, tmp2, 8);\n@@ -2844,1 +2845,1 @@\n-  andi(Rd, Rd, 0xFF);\n+  zext(Rd, Rd, 8);\n@@ -2846,1 +2847,1 @@\n-  sign_extend(Rd, Rd, 32);\n+  sext(Rd, Rd, 32);\n@@ -2858,1 +2859,1 @@\n-  andi(tmp1, Rs, 0xFF);\n+  zext(tmp1, Rs, 8);\n@@ -2862,1 +2863,1 @@\n-    andi(tmp2, tmp2, 0xFF);\n+    zext(tmp2, tmp2, 8);\n@@ -2867,1 +2868,1 @@\n-  andi(Rd, Rd, 0xFF);\n+  zext(Rd, Rd, 8);\n@@ -3240,1 +3241,1 @@\n-    zero_extend(dst, src, 32);\n+    zext(dst, src, 32);\n@@ -3693,1 +3694,1 @@\n-      zero_extend(dst, dst, 32);\n+      zext(dst, dst, 32);\n@@ -3734,1 +3735,1 @@\n-    zero_extend(mask, mask, 16);\n+    zext(mask, mask, 16);\n@@ -3811,1 +3812,1 @@\n-      sign_extend(result, result, 8);\n+      sext(result, result, 8);\n@@ -3814,1 +3815,1 @@\n-      sign_extend(result, result, 16);\n+      sext(result, result, 16);\n@@ -4008,1 +4009,1 @@\n-  zero_extend(prev, prev, 32);                                                       \\\n+  zext(prev, prev, 32);                                                       \\\n@@ -4028,1 +4029,1 @@\n-      zero_extend(prev, prev, 32);\n+      zext(prev, prev, 32);\n@@ -4617,1 +4618,1 @@\n-  zero_extend(dst, dst, 32);\n+  zext(dst, dst, 32);\n@@ -4630,1 +4631,1 @@\n-  zero_extend(dst, dst, 32);\n+  zext(dst, dst, 32);\n@@ -4905,1 +4906,1 @@\n-  zero_extend(k, k, 32);\n+  zext(k, k, 32);\n@@ -5397,4 +5398,6 @@\n-\/\/ Count bits of trailing zero chars from lsb to msb until first non-zero element.\n-\/\/ For LL case, one byte for one element, so shift 8 bits once, and for other case,\n-\/\/ shift 16 bits once.\n-void MacroAssembler::ctzc_bit(Register Rd, Register Rs, bool isLL, Register tmp1, Register tmp2) {\n+\/\/ Count bits of trailing zero chars from lsb to msb until first non-zero\n+\/\/ char seen. For the LL case, shift 8 bits once as there is only one byte\n+\/\/ per each char. For other cases, shift 16 bits once.\n+void MacroAssembler::ctzc_bits(Register Rd, Register Rs, bool isLL,\n+                               Register tmp1, Register tmp2) {\n+  int step = isLL ? 8 : 16;\n@@ -5402,2 +5405,0 @@\n-    assert_different_registers(Rd, Rs, tmp1);\n-    int step = isLL ? 8 : 16;\n@@ -5405,2 +5406,1 @@\n-    andi(tmp1, Rd, step - 1);\n-    sub(Rd, Rd, tmp1);\n+    andi(Rd, Rd, -step);\n@@ -5410,1 +5410,1 @@\n-  assert_different_registers(Rd, Rs, tmp1, tmp2);\n+  assert_different_registers(Rd, tmp1, tmp2);\n@@ -5412,2 +5412,0 @@\n-  int step = isLL ? 8 : 16;\n-  mv(Rd, -step);\n@@ -5415,0 +5413,1 @@\n+  mv(Rd, -step);\n@@ -5418,1 +5417,1 @@\n-  andi(tmp1, tmp2, ((1 << step) - 1));\n+  zext(tmp1, tmp2, step);\n@@ -5439,1 +5438,1 @@\n-  andi(tmp2, Rs, 0xFF); \/\/ last byte mask at lower word\n+  zext(tmp2, Rs, 8); \/\/ last byte mask at lower word\n@@ -5841,1 +5840,1 @@\n-void MacroAssembler::zero_extend(Register dst, Register src, int bits) {\n+void MacroAssembler::zext(Register dst, Register src, int bits) {\n@@ -5856,5 +5855,2 @@\n-      if (UseZbb) {\n-        zext_b(dst, src);\n-        return;\n-      }\n-      break;\n+      zext_b(dst, src);\n+      return;\n@@ -5864,0 +5860,1 @@\n+\n@@ -5868,1 +5865,1 @@\n-void MacroAssembler::sign_extend(Register dst, Register src, int bits) {\n+void MacroAssembler::sext(Register dst, Register src, int bits) {\n@@ -5888,0 +5885,1 @@\n+\n@@ -5980,1 +5978,1 @@\n-      sign_extend(dst.first()->as_Register(), src.first()->as_Register(), 32);\n+      sext(dst.first()->as_Register(), src.first()->as_Register(), 32);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":46,"deletions":48,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1365,1 +1365,2 @@\n-  void ctzc_bit(Register Rd, Register Rs, bool isLL = false, Register tmp1 = t0, Register tmp2 = t1);\n+  void ctzc_bits(Register Rd, Register Rs, bool isLL = false,\n+                 Register tmp1 = t0, Register tmp2 = t1);\n@@ -1521,1 +1522,1 @@\n-        zero_extend(Rt, Rt, 16);\n+        zext(Rt, Rt, 16);\n@@ -1524,1 +1525,1 @@\n-        sign_extend(Rt, Rt, 8);\n+        sext(Rt, Rt, 8);\n@@ -1527,1 +1528,1 @@\n-        sign_extend(Rt, Rt, 16);\n+        sext(Rt, Rt, 16);\n@@ -1530,1 +1531,1 @@\n-        sign_extend(Rt, Rt, 32);\n+        sext(Rt, Rt, 32);\n@@ -1545,2 +1546,2 @@\n-  void zero_extend(Register dst, Register src, int bits);\n-  void sign_extend(Register dst, Register src, int bits);\n+  void zext(Register dst, Register src, int bits);\n+  void sext(Register dst, Register src, int bits);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1629,1 +1629,1 @@\n-            __ zero_extend(as_Register(Matcher::_regEncode[dst_lo]), as_Register(Matcher::_regEncode[src_lo]), 32);\n+            __ zext(as_Register(Matcher::_regEncode[dst_lo]), as_Register(Matcher::_regEncode[src_lo]), 32);\n@@ -8082,1 +8082,1 @@\n-    __ sign_extend(as_Register($dst$$reg), as_Register($src$$reg), 32);\n+    __ sext(as_Register($dst$$reg), as_Register($src$$reg), 32);\n@@ -8094,1 +8094,1 @@\n-    __ sign_extend(as_Register($dst$$reg), as_Register($src$$reg), 32);\n+    __ sext(as_Register($dst$$reg), as_Register($src$$reg), 32);\n@@ -8106,1 +8106,1 @@\n-  format %{ \"zero_extend $dst, $src, 32\\t# i2ul, #@convI2UL_reg_reg\" %}\n+  format %{ \"zext $dst, $src, 32\\t# i2ul, #@convI2UL_reg_reg\" %}\n@@ -8109,1 +8109,1 @@\n-    __ zero_extend(as_Register($dst$$reg), as_Register($src$$reg), 32);\n+    __ zext(as_Register($dst$$reg), as_Register($src$$reg), 32);\n@@ -8286,1 +8286,1 @@\n-  format %{ \"zero_extend $dst, $src, 32\\t# ptr -> int, #@convP2I\" %}\n+  format %{ \"zext $dst, $src, 32\\t# ptr -> int, #@convP2I\" %}\n@@ -8289,1 +8289,1 @@\n-    __ zero_extend($dst$$Register, $src$$Register, 32);\n+    __ zext($dst$$Register, $src$$Register, 32);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  __ sign_extend(c_rarg1, j_rarg0, 32);\n+  __ sext(c_rarg1, j_rarg0, 32);\n","filename":"src\/hotspot\/cpu\/riscv\/runtime_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2556,1 +2556,1 @@\n-    __ andi(t1, t0, 0b0000011);\n+    __ andi(t1, t0, 0b1111111);\n@@ -2560,1 +2560,1 @@\n-    __ andi(t1, t1, 0b00000);\n+    __ andi(t1, t1, 0b11111);\n@@ -2563,1 +2563,1 @@\n-    __ andi(t1, t1, 0b110);\n+    __ andi(t1, t1, 0b111);\n@@ -2567,0 +2567,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1646,2 +1646,2 @@\n-    __ zero_extend(src_pos, src_pos, 32);\n-    __ zero_extend(dst_pos, dst_pos, 32);\n+    __ zext(src_pos, src_pos, 32);\n+    __ zext(dst_pos, dst_pos, 32);\n@@ -1770,1 +1770,1 @@\n-    __ sign_extend(t0, src_pos, 32);\n+    __ sext(t0, src_pos, 32);\n@@ -1777,1 +1777,1 @@\n-    __ sign_extend(t0, dst_pos, 32);\n+    __ sext(t0, dst_pos, 32);\n@@ -1786,1 +1786,1 @@\n-    __ sign_extend(scratch_length, length, 32);    \/\/ length (elements count, 32-bits value)\n+    __ sext(scratch_length, length, 32); \/\/ length (elements count, 32-bits value)\n@@ -1882,1 +1882,1 @@\n-    __ sign_extend(count, scratch_length, 32); \/\/ length\n+    __ sext(count, scratch_length, 32); \/\/ length\n@@ -1888,1 +1888,1 @@\n-    __ sign_extend(count, scratch_length, 32); \/\/ length\n+    __ sext(count, scratch_length, 32); \/\/ length\n@@ -1896,1 +1896,1 @@\n-    __ sign_extend(count, scratch_length, 32); \/\/ length\n+    __ sext(count, scratch_length, 32); \/\/ length\n@@ -1905,1 +1905,1 @@\n-      __ sign_extend(lh, lh, 32);\n+      __ sext(lh, lh, 32);\n@@ -1915,1 +1915,1 @@\n-    __ sign_extend(count, scratch_length, 32); \/\/ length\n+    __ sext(count, scratch_length, 32); \/\/ length\n@@ -1935,1 +1935,1 @@\n-    __ sign_extend(count, scratch_length, 32); \/\/ length\n+    __ sext(count, scratch_length, 32); \/\/ length\n@@ -1958,2 +1958,2 @@\n-      __ sign_extend(count, length, 32);      \/\/ length (reloaded)\n-      const Register sco_temp = c_rarg3;      \/\/ this register is free now\n+      __ sext(count, length, 32); \/\/ length (reloaded)\n+      const Register sco_temp = c_rarg3; \/\/ this register is free now\n@@ -2025,1 +2025,1 @@\n-        __ andi(value, value, 0xff);\n+        __ zext(value, value, 8);\n@@ -2042,1 +2042,1 @@\n-        __ andi(value, value, 0xffff);\n+        __ zext(value, value, 16);\n@@ -2102,3 +2102,2 @@\n-    __ andi(value, value, 0xffffffff);\n-    __ mv(tmp_reg, value);\n-    __ slli(tmp_reg, tmp_reg, 32);\n+    __ zext(value, value, 32);\n+    __ slli(tmp_reg, value, 32);\n@@ -2572,1 +2571,2 @@\n-      __ ctzc_bit(tmp4, tmp3);\n+      \/\/ count bits of trailing zero chars\n+      __ ctzc_bits(tmp4, tmp3);\n@@ -2575,2 +2575,2 @@\n-      __ andi(tmp1, tmp1, 0xFFFF);\n-      __ andi(tmp2, tmp2, 0xFFFF);\n+      __ zext(tmp1, tmp1, 16);\n+      __ zext(tmp2, tmp2, 16);\n@@ -2707,1 +2707,2 @@\n-      __ ctzc_bit(tmp3, tmp4, isLL); \/\/ count zero from lsb to msb\n+      \/\/ count bits of trailing zero chars\n+      __ ctzc_bits(tmp3, tmp4, isLL);\n@@ -2711,2 +2712,2 @@\n-        __ andi(tmp5, tmp5, 0xFF);\n-        __ andi(cnt1, cnt1, 0xFF);\n+        __ zext(tmp5, tmp5, 8);\n+        __ zext(cnt1, cnt1, 8);\n@@ -2714,2 +2715,2 @@\n-        __ andi(tmp5, tmp5, 0xFFFF);\n-        __ andi(cnt1, cnt1, 0xFFFF);\n+        __ zext(tmp5, tmp5, 16);\n+        __ zext(cnt1, cnt1, 16);\n@@ -2720,1 +2721,2 @@\n-      __ ctzc_bit(tmp3, tmp4, isLL); \/\/ count zero from lsb to msb\n+      \/\/ count bits of trailing zero chars\n+      __ ctzc_bits(tmp3, tmp4, isLL);\n@@ -2724,2 +2726,2 @@\n-        __ andi(tmp1, tmp1, 0xFF);\n-        __ andi(tmp2, tmp2, 0xFF);\n+        __ zext(tmp1, tmp1, 8);\n+        __ zext(tmp2, tmp2, 8);\n@@ -2727,2 +2729,2 @@\n-        __ andi(tmp1, tmp1, 0xFFFF);\n-        __ andi(tmp2, tmp2, 0xFFFF);\n+        __ zext(tmp1, tmp1, 16);\n+        __ zext(tmp2, tmp2, 16);\n@@ -2790,1 +2792,2 @@\n-    __ andi(first, ch1, needle_isL ? 0xFF : 0xFFFF, first);\n+    __ zext(first, ch1, needle_isL ? 8 : 16);\n+\n@@ -2865,1 +2868,2 @@\n-    __ ctzc_bit(trailing_zeros, match_mask, haystack_isL, ch2, tmp); \/\/ count trailing zeros\n+    \/\/ count bits of trailing zero chars\n+    __ ctzc_bits(trailing_zeros, match_mask, haystack_isL, ch2, tmp);\n@@ -2884,1 +2888,2 @@\n-    __ ctzc_bit(trailing_zeros, match_mask, haystack_isL, tmp, ch2);\n+    \/\/ count bits of trailing zero chars\n+    __ ctzc_bits(trailing_zeros, match_mask, haystack_isL, tmp, ch2);\n@@ -2903,1 +2908,2 @@\n-    __ ctzc_bit(trailing_zeros, match_mask, haystack_isL, tmp, ch2);\n+    \/\/ count bits of trailing zero chars\n+    __ ctzc_bits(trailing_zeros, match_mask, haystack_isL, tmp, ch2);\n@@ -2932,1 +2938,2 @@\n-    __ ctzc_bit(trailing_zeros, match_mask, haystack_isL, needle_len, ch2); \/\/ find next \"first\" char index\n+    \/\/ count bits of trailing zero chars\n+    __ ctzc_bits(trailing_zeros, match_mask, haystack_isL, needle_len, ch2);\n@@ -2966,1 +2973,1 @@\n-    __ sign_extend(haystack_len, haystack_len, 32);\n+    __ sext(haystack_len, haystack_len, 32);\n@@ -5047,1 +5054,1 @@\n-    __ zero_extend(cur_w, cur_w, 32);\n+    __ zext(cur_w, cur_w, 32);\n@@ -5154,1 +5161,1 @@\n-    __ zero_extend(prev_ab, a, 32);\n+    __ zext(prev_ab, a, 32);\n@@ -5158,1 +5165,1 @@\n-    __ zero_extend(prev_cd, c, 32);\n+    __ zext(prev_cd, c, 32);\n@@ -5288,1 +5295,1 @@\n-    __ zero_extend(a, a, 32);\n+    __ zext(a, a, 32);\n@@ -5292,1 +5299,1 @@\n-    __ zero_extend(c, c, 32);\n+    __ zext(c, c, 32);\n@@ -5966,1 +5973,1 @@\n-    __ zero_extend(s1, adler, 16); \/\/ s1 = (adler & 0xffff)\n+    __ zext(s1, adler, 16); \/\/ s1 = (adler & 0xffff)\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":50,"deletions":43,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -364,1 +364,1 @@\n-  __ zero_extend(c_rarg2, x11, 32);\n+  __ zext(c_rarg2, x11, 32);\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -725,1 +725,1 @@\n-  __ sign_extend(index, index, 32);\n+  __ sext(index, index, 32);\n@@ -743,1 +743,1 @@\n-  __ sign_extend(x10, x10, 32);\n+  __ sext(x10, x10, 32);\n@@ -1548,1 +1548,1 @@\n-      __ sign_extend(x10, x10, 32);\n+      __ sext(x10, x10, 32);\n@@ -1557,1 +1557,1 @@\n-      __ sign_extend(x10, x10, 8);\n+      __ sext(x10, x10, 8);\n@@ -1560,1 +1560,1 @@\n-      __ zero_extend(x10, x10, 16);\n+      __ zext(x10, x10, 16);\n@@ -1563,1 +1563,1 @@\n-      __ sign_extend(x10, x10, 16);\n+      __ sext(x10, x10, 16);\n@@ -1566,1 +1566,1 @@\n-      __ sign_extend(x10, x10, 32);\n+      __ sext(x10, x10, 32);\n@@ -1786,1 +1786,1 @@\n-  __ sign_extend(x10, x10, 32);\n+  __ sext(x10, x10, 32);\n@@ -1820,1 +1820,1 @@\n-  __ sign_extend(x10, x10, 32);\n+  __ sext(x10, x10, 32);\n@@ -2576,1 +2576,1 @@\n-  __ sign_extend(x10, x10, 32);\n+  __ sext(x10, x10, 32);\n@@ -3140,1 +3140,1 @@\n-      __ sign_extend(x10, x10, 32);\n+      __ sext(x10, x10, 32);\n@@ -3186,1 +3186,1 @@\n-      __ sign_extend(x10, x10, 32);\n+      __ sext(x10, x10, 32);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -86,3 +86,5 @@\n-unsigned int C2_MacroAssembler::string_compress(Register result, Register src, Register dst, Register cnt,\n-                                                Register tmp,    bool precise, bool toASCII) {\n-  assert_different_registers(Z_R0, Z_R1, result, src, dst, cnt, tmp);\n+unsigned int C2_MacroAssembler::string_compress(Register result, Register Rsrc, Register Rdst, Register Rcnt,\n+                                                Register tmp, bool precise, bool toASCII, VectorRegister Vtmp1, VectorRegister Vtmp2,\n+                                                VectorRegister Vmask, VectorRegister Vzero, VectorRegister Vsrc_first, VectorRegister v21,\n+                                                VectorRegister v22, VectorRegister Vsrc_last) {\n+  assert_different_registers(Z_R0, Z_R1, result, Rsrc, Rdst, Rcnt, tmp);\n@@ -107,2 +109,0 @@\n-  Register       Rsrc  = src;\n-  Register       Rdst  = dst;\n@@ -110,1 +110,0 @@\n-  Register       Rcnt  = cnt;\n@@ -172,1 +171,0 @@\n-#if 0\n@@ -181,7 +179,0 @@\n-    VectorRegister Vtmp1      = Z_V16;\n-    VectorRegister Vtmp2      = Z_V17;\n-    VectorRegister Vmask      = Z_V18;\n-    VectorRegister Vzero      = Z_V19;\n-    VectorRegister Vsrc_first = Z_V20;\n-    VectorRegister Vsrc_last  = Z_V23;\n-\n@@ -202,2 +193,2 @@\n-      z_vo(Vtmp1, Z_V20, Z_V21);\n-      z_vo(Vtmp2, Z_V22, Z_V23);\n+      z_vo(Vtmp1, Vsrc_first, v21);\n+      z_vo(Vtmp2, v22, Vsrc_last);\n@@ -211,2 +202,2 @@\n-      z_vpkh(Vtmp1, Z_V20, Z_V21);         \/\/ pack (src1, src2) -> tmp1\n-      z_vpkh(Vtmp2, Z_V22, Z_V23);         \/\/ pack (src3, src4) -> tmp2\n+      z_vpkh(Vtmp1, Vsrc_first, v21);      \/\/ pack (src1, src2) -> tmp1\n+      z_vpkh(Vtmp2, v22, Vsrc_last);       \/\/ pack (src3, src4) -> tmp2\n@@ -227,1 +218,0 @@\n-#endif\n@@ -422,1 +412,3 @@\n-unsigned int C2_MacroAssembler::string_inflate(Register src, Register dst, Register cnt, Register tmp) {\n+unsigned int C2_MacroAssembler::string_inflate(Register src, Register dst, Register cnt, Register tmp,\n+                                               VectorRegister v20, VectorRegister v21, VectorRegister v22,\n+                                               VectorRegister v23, VectorRegister v24, VectorRegister v25) {\n@@ -466,1 +458,0 @@\n-#if 0\n@@ -481,1 +472,1 @@\n-      z_vlm(Z_V20, Z_V21, 0, Rsrc);        \/\/ get next 32 characters (single-byte)\n+      z_vlm(v20, v21, 0, Rsrc);        \/\/ get next 32 characters (single-byte)\n@@ -484,5 +475,5 @@\n-      z_vuplhb(Z_V22, Z_V20);              \/\/ V2 <- (expand) V0(high)\n-      z_vupllb(Z_V23, Z_V20);              \/\/ V3 <- (expand) V0(low)\n-      z_vuplhb(Z_V24, Z_V21);              \/\/ V4 <- (expand) V1(high)\n-      z_vupllb(Z_V25, Z_V21);              \/\/ V5 <- (expand) V1(low)\n-      z_vstm(Z_V22, Z_V25, 0, Rdst);       \/\/ store next 32 bytes\n+      z_vuplhb(v22, v20);              \/\/ V2 <- (expand) V0(high)\n+      z_vupllb(v23, v20);              \/\/ V3 <- (expand) V0(low)\n+      z_vuplhb(v24, v21);              \/\/ V4 <- (expand) V1(high)\n+      z_vupllb(v25, v21);              \/\/ V5 <- (expand) V1(low)\n+      z_vstm(v22, v25, 0, Rdst);       \/\/ store next 32 bytes\n@@ -495,1 +486,0 @@\n-#endif\n@@ -614,1 +604,3 @@\n-unsigned int C2_MacroAssembler::string_inflate_const(Register src, Register dst, Register tmp, int len) {\n+unsigned int C2_MacroAssembler::string_inflate_const(Register src, Register dst, Register tmp, int len ,\n+                                                     VectorRegister v20, VectorRegister v21, VectorRegister v22,\n+                                                     VectorRegister v23, VectorRegister v24, VectorRegister v25) {\n@@ -630,1 +622,0 @@\n-#if 0\n@@ -641,6 +632,6 @@\n-      z_vlm(Z_V20, Z_V21, 0+src_off, Rsrc);  \/\/ get next 32 characters (single-byte)\n-      z_vuplhb(Z_V22, Z_V20);                \/\/ V2 <- (expand) V0(high)\n-      z_vupllb(Z_V23, Z_V20);                \/\/ V3 <- (expand) V0(low)\n-      z_vuplhb(Z_V24, Z_V21);                \/\/ V4 <- (expand) V1(high)\n-      z_vupllb(Z_V25, Z_V21);                \/\/ V5 <- (expand) V1(low)\n-      z_vstm(Z_V22, Z_V25, 0+dst_off, Rdst); \/\/ store next 32 bytes\n+      z_vlm(v20, v21, 0+src_off, Rsrc);  \/\/ get next 32 characters (single-byte)\n+      z_vuplhb(v22, v20);                \/\/ V2 <- (expand) V0(high)\n+      z_vupllb(v23, v20);                \/\/ V3 <- (expand) V0(low)\n+      z_vuplhb(v24, v21);                \/\/ V4 <- (expand) V1(high)\n+      z_vupllb(v25, v21);                \/\/ V5 <- (expand) V1(low)\n+      z_vstm(v22, v25, 0+dst_off, Rdst); \/\/ store next 32 bytes\n@@ -655,1 +646,1 @@\n-        z_vlm(Z_V20, Z_V21, 0, Rsrc);        \/\/ get next 32 characters (single-byte)\n+        z_vlm(v20, v21, 0, Rsrc);        \/\/ get next 32 characters (single-byte)\n@@ -658,5 +649,5 @@\n-        z_vuplhb(Z_V22, Z_V20);              \/\/ V2 <- (expand) V0(high)\n-        z_vupllb(Z_V23, Z_V20);              \/\/ V3 <- (expand) V0(low)\n-        z_vuplhb(Z_V24, Z_V21);              \/\/ V4 <- (expand) V1(high)\n-        z_vupllb(Z_V25, Z_V21);              \/\/ V5 <- (expand) V1(low)\n-        z_vstm(Z_V22, Z_V25, 0, Rdst);       \/\/ store next 32 bytes\n+        z_vuplhb(v22, v20);              \/\/ V2 <- (expand) V0(high)\n+        z_vupllb(v23, v20);              \/\/ V3 <- (expand) V0(low)\n+        z_vuplhb(v24, v21);              \/\/ V4 <- (expand) V1(high)\n+        z_vupllb(v25, v21);              \/\/ V5 <- (expand) V1(low)\n+        z_vstm(v22, v25, 0, Rdst);       \/\/ store next 32 bytes\n@@ -678,4 +669,4 @@\n-    z_vl(Z_V20, 0+src_off, Z_R0, Rsrc);    \/\/ get next 16 characters (single-byte)\n-    z_vuplhb(Z_V22, Z_V20);                \/\/ V2 <- (expand) V0(high)\n-    z_vupllb(Z_V23, Z_V20);                \/\/ V3 <- (expand) V0(low)\n-    z_vstm(Z_V22, Z_V23, 0+dst_off, Rdst); \/\/ store next 32 bytes\n+    z_vl(v20, 0+src_off, Z_R0, Rsrc);    \/\/ get next 16 characters (single-byte)\n+    z_vuplhb(v22, v20);                \/\/ V2 <- (expand) V0(high)\n+    z_vupllb(v23, v20);                \/\/ V3 <- (expand) V0(low)\n+    z_vstm(v22, v23, 0+dst_off, Rdst); \/\/ store next 32 bytes\n@@ -686,1 +677,0 @@\n-#endif\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.cpp","additions":37,"deletions":47,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -47,2 +47,4 @@\n-  unsigned int string_compress(Register result, Register src, Register dst, Register cnt,\n-                               Register tmp,    bool precise, bool toASCII);\n+  unsigned int string_compress(Register result, Register Rsrc, Register Rdst, Register Rcnt,\n+                               Register tmp, bool precise, bool toASCII, VectorRegister Vtmp1, VectorRegister Vtmp2,\n+                               VectorRegister Vmask, VectorRegister Vzero, VectorRegister Vsrc_first, VectorRegister v21,\n+                               VectorRegister v22, VectorRegister Vsrc_last);\n@@ -57,1 +59,2 @@\n-  unsigned int string_inflate(Register src, Register dst, Register cnt, Register tmp);\n+  unsigned int string_inflate(Register src, Register dst, Register cnt, Register tmp, VectorRegister v20, VectorRegister v21,\n+                              VectorRegister v22, VectorRegister v23, VectorRegister v24, VectorRegister v25);\n@@ -64,1 +67,2 @@\n-  unsigned int string_inflate_const(Register src, Register dst, Register tmp, int len);\n+  unsigned int string_inflate_const(Register src, Register dst, Register tmp, int len , VectorRegister v20, VectorRegister v21,\n+                                    VectorRegister v22, VectorRegister v23, VectorRegister v24, VectorRegister v25);\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -765,0 +765,50 @@\n+\/\/ class for vector register v16\n+reg_class z_vreg_16(\n+   Z_VR16, Z_VR16_H, Z_VR16_J, Z_VR16_K\n+);\n+\n+\/\/ class for vector register v17\n+reg_class z_vreg_17(\n+   Z_VR17, Z_VR17_H, Z_VR17_J, Z_VR17_K\n+);\n+\n+\/\/ class for vector register v18\n+reg_class z_vreg_18(\n+    Z_VR18, Z_VR18_H, Z_VR18_J, Z_VR18_K\n+);\n+\n+\/\/ class for vector register v19\n+reg_class z_vreg_19(\n+    Z_VR19, Z_VR19_H, Z_VR19_J, Z_VR19_K\n+);\n+\n+\/\/ class for vector register v20\n+reg_class z_vreg_20(\n+    Z_VR20, Z_VR20_H, Z_VR20_J, Z_VR20_K\n+);\n+\n+\/\/ class for vector register v21\n+reg_class z_vreg_21(\n+    Z_VR21, Z_VR21_H, Z_VR21_J, Z_VR21_K\n+);\n+\n+\/\/ class for vector register v22\n+reg_class z_vreg_22(\n+    Z_VR22, Z_VR22_H, Z_VR22_J, Z_VR22_K\n+);\n+\n+\/\/ class for vector register v23\n+reg_class z_vreg_23(\n+    Z_VR23, Z_VR23_H, Z_VR23_J, Z_VR23_K\n+);\n+\n+\/\/ class for vector register v24\n+reg_class z_vreg_24(\n+    Z_VR24, Z_VR24_H, Z_VR24_J, Z_VR24_K\n+);\n+\n+\/\/ class for vector register v25\n+reg_class z_vreg_25(\n+    Z_VR25, Z_VR25_H, Z_VR25_J, Z_VR25_K\n+);\n+\n@@ -2693,0 +2743,20 @@\n+  match(v16TempReg);\n+  match(v17TempReg);\n+  match(v18TempReg);\n+  match(v19TempReg);\n+  match(v20TempReg);\n+  match(v21TempReg);\n+  match(v22TempReg);\n+  match(v23TempReg);\n+  match(v24TempReg);\n+  match(v25TempReg);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand v16TempReg() %{\n+  constraint(ALLOC_IN_RC(z_vreg_16));\n+  match(VecX);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n@@ -2694,0 +2764,3 @@\n+operand v17TempReg() %{\n+  constraint(ALLOC_IN_RC(z_vreg_17));\n+  match(VecX);\n@@ -2698,0 +2771,55 @@\n+operand v18TempReg() %{\n+  constraint(ALLOC_IN_RC(z_vreg_18));\n+  match(VecX);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand v19TempReg() %{\n+  constraint(ALLOC_IN_RC(z_vreg_19));\n+  match(VecX);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand v20TempReg() %{\n+  constraint(ALLOC_IN_RC(z_vreg_20));\n+  match(VecX);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand v21TempReg() %{\n+  constraint(ALLOC_IN_RC(z_vreg_21));\n+  match(VecX);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand v22TempReg() %{\n+  constraint(ALLOC_IN_RC(z_vreg_22));\n+  match(VecX);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand v23TempReg() %{\n+  constraint(ALLOC_IN_RC(z_vreg_23));\n+  match(VecX);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand v24TempReg() %{\n+  constraint(ALLOC_IN_RC(z_vreg_24));\n+  match(VecX);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand v25TempReg() %{\n+  constraint(ALLOC_IN_RC(z_vreg_25));\n+  match(VecX);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n@@ -10480,1 +10608,2 @@\n-instruct string_compress(iRegP src, iRegP dst, iRegI result, iRegI len, iRegI tmp, flagsReg cr) %{\n+instruct string_compress(iRegP src, iRegP dst, iRegI result, iRegI len, iRegI tmp, v16TempReg v16, v17TempReg v17, v18TempReg v18,\n+                         v19TempReg v19, v20TempReg v20, v21TempReg v21, v22TempReg v22, v23TempReg v23, flagsReg cr) %{\n@@ -10482,1 +10611,1 @@\n-  effect(TEMP_DEF result, TEMP tmp, KILL cr); \/\/ R0, R1 are killed, too.\n+  effect(TEMP_DEF result, TEMP tmp, TEMP v16, TEMP v17, TEMP v18, TEMP v19, TEMP v20, TEMP v21, TEMP v22, TEMP v23, KILL cr); \/\/ R0, R1 are killed, too.\n@@ -10487,1 +10616,3 @@\n-                       $tmp$$Register, true, false);\n+                       $tmp$$Register, true, false, $v16$$VectorRegister, $v17$$VectorRegister, $v18$$VectorRegister,\n+                       $v19$$VectorRegister, $v20$$VectorRegister, $v21$$VectorRegister, $v22$$VectorRegister,\n+                       $v23$$VectorRegister);\n@@ -10506,1 +10637,2 @@\n-instruct string_inflate(Universe dummy, iRegP src, iRegP dst, iRegI len, iRegI tmp, flagsReg cr) %{\n+instruct string_inflate(Universe dummy, iRegP src, iRegP dst, iRegI len, iRegI tmp, v20TempReg v20, v21TempReg v21, v22TempReg v22, v23TempReg v23,\n+                        v24TempReg v24, v25TempReg v25, flagsReg cr) %{\n@@ -10508,1 +10640,1 @@\n-  effect(TEMP tmp, KILL cr); \/\/ R0, R1 are killed, too.\n+  effect(TEMP tmp, TEMP v20, TEMP v21, TEMP v22, TEMP v23, TEMP v24, TEMP v25, KILL cr); \/\/ R0, R1 are killed, too.\n@@ -10512,1 +10644,3 @@\n-    __ string_inflate($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register);\n+    __ string_inflate($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register, $v20$$VectorRegister,\n+                      $v21$$VectorRegister, $v22$$VectorRegister, $v23$$VectorRegister, $v24$$VectorRegister,\n+                      $v25$$VectorRegister);\n@@ -10518,1 +10652,2 @@\n-instruct string_inflate_const(Universe dummy, iRegP src, iRegP dst, iRegI tmp, immI len, flagsReg cr) %{\n+instruct string_inflate_const(Universe dummy, iRegP src, iRegP dst, iRegI tmp, immI len, v20TempReg v20, v21TempReg v21, v22TempReg v22, v23TempReg v23,\n+                              v24TempReg v24, v25TempReg v25, flagsReg cr) %{\n@@ -10520,1 +10655,1 @@\n-  effect(TEMP tmp, KILL cr); \/\/ R0, R1 are killed, too.\n+  effect(TEMP tmp, TEMP v20, TEMP v21, TEMP v22, TEMP v23, TEMP v24, TEMP v25, KILL cr); \/\/ R0, R1 are killed, too.\n@@ -10524,1 +10659,3 @@\n-    __ string_inflate_const($src$$Register, $dst$$Register, $tmp$$Register, $len$$constant);\n+    __ string_inflate_const($src$$Register, $dst$$Register, $tmp$$Register, $len$$constant , $v20$$VectorRegister,\n+                            $v21$$VectorRegister, $v22$$VectorRegister, $v23$$VectorRegister, $v24$$VectorRegister,\n+                            $v25$$VectorRegister);\n@@ -10542,1 +10679,2 @@\n-instruct encode_iso_array(iRegP src, iRegP dst, iRegI result, iRegI len, iRegI tmp, flagsReg cr) %{\n+instruct encode_iso_array(iRegP src, iRegP dst, iRegI result, iRegI len, iRegI tmp, v16TempReg v16, v17TempReg v17, v18TempReg v18, v19TempReg v19, v20TempReg v20, v21TempReg v21,\n+\t\t\t v22TempReg v22, v23TempReg v23, flagsReg cr) %{\n@@ -10545,1 +10683,2 @@\n-  effect(TEMP_DEF result, TEMP tmp, KILL cr); \/\/ R0, R1 are killed, too.\n+  effect(TEMP_DEF result, TEMP tmp, TEMP v16, TEMP v17, TEMP v18, TEMP v19,\n+\t       TEMP v20, TEMP v21, TEMP v22, TEMP v23, KILL cr); \/\/ R0, R1 are killed, too.\n@@ -10550,1 +10689,3 @@\n-                       $tmp$$Register, true, false);\n+                       $tmp$$Register, true, false, $v16$$VectorRegister, $v17$$VectorRegister, $v18$$VectorRegister,\n+                       $v19$$VectorRegister, $v20$$VectorRegister, $v21$$VectorRegister, $v22$$VectorRegister,\n+                       $v23$$VectorRegister);\n@@ -10556,1 +10697,2 @@\n-instruct encode_ascii_array(iRegP src, iRegP dst, iRegI result, iRegI len, iRegI tmp, flagsReg cr) %{\n+instruct encode_ascii_array(iRegP src, iRegP dst, iRegI result, iRegI len, iRegI tmp, v16TempReg v16, v17TempReg v17, v18TempReg v18, v19TempReg v19, v20TempReg v20, v21TempReg v21,\n+\t\t\t v22TempReg v22, v23TempReg v23, flagsReg cr) %{\n@@ -10559,1 +10701,2 @@\n-  effect(TEMP_DEF result, TEMP tmp, KILL cr); \/\/ R0, R1 are killed, too.\n+  effect(TEMP_DEF result, TEMP tmp, TEMP v16, TEMP v17, TEMP v18, TEMP v19,\n+\t       TEMP v20, TEMP v21, TEMP v22, TEMP v23, KILL cr); \/\/ R0, R1 are killed, too.\n@@ -10564,1 +10707,3 @@\n-                       $tmp$$Register, true, true);\n+                       $tmp$$Register, true, true, $v16$$VectorRegister, $v17$$VectorRegister, $v18$$VectorRegister,\n+                       $v19$$VectorRegister, $v20$$VectorRegister, $v21$$VectorRegister, $v22$$VectorRegister,\n+                       $v23$$VectorRegister);\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":160,"deletions":15,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"opto\/cfgnode.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/c2_intelJccErratum_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#define UNIX_PATH_MAX   sizeof(((struct sockaddr_un *)0)->sun_path)\n+#define UNIX_PATH_MAX   sizeof(sockaddr_un::sun_path)\n","filename":"src\/hotspot\/os\/aix\/attachListener_aix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2015 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/os\/aix\/osThread_aix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2013 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/os\/aix\/osThread_aix.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/os\/aix\/porting_aix.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,383 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#if defined(__APPLE__)\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"nmt\/memMapPrinter.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+#include <limits.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <libproc.h>\n+#include <unistd.h>\n+\n+#include <mach\/vm_inherit.h>\n+#include <mach\/vm_prot.h>\n+#include <mach\/mach_vm.h>\n+\n+\/\/ maximum number of mapping records returned\n+static const int MAX_REGIONS_RETURNED = 1000000;\n+\n+\/\/ ::mmap() on MacOS is a layer on top of Mach system calls, and will allocate in 128MB chunks.\n+\/\/ This code will coalesce a series of identical 128GB chunks (maybe followed by one smaller chunk\n+\/\/ with identical flags) into one.\n+\/\/ Unfortunately, two or more identically allocated contiguous sections will appear as one, if the\n+\/\/ first section is size 128MB.  vmmap(1) has the same issue.\n+static const int MACOS_PARTIAL_ALLOCATION_SIZE = 128 * M;\n+\n+class MappingInfo {\n+  proc_regioninfo _rinfo;\n+public:\n+  const char* _address;\n+  size_t _size;\n+  stringStream _share_buffer;\n+  stringStream _type_buffer;\n+  stringStream _protect_buffer;\n+  stringStream _file_name;\n+  const char* _tag_text;\n+\n+  MappingInfo() : _address(nullptr), _size(0), _tag_text(nullptr) {}\n+\n+  void reset() {\n+    _share_buffer.reset();\n+    _protect_buffer.reset();\n+    _type_buffer.reset();\n+    _file_name.reset();\n+    _tag_text = nullptr;\n+  }\n+\n+  bool canCombine(const proc_regionwithpathinfo& mem_info) {\n+    const proc_regioninfo& n = mem_info.prp_prinfo;\n+    bool cc = _rinfo.pri_size == MACOS_PARTIAL_ALLOCATION_SIZE\n+              && n.pri_address == (_rinfo.pri_address + _size)\n+              && n.pri_protection == _rinfo.pri_protection\n+              && n.pri_max_protection == _rinfo.pri_max_protection\n+              && n.pri_user_tag == _rinfo.pri_user_tag\n+              && n.pri_share_mode == _rinfo.pri_share_mode\n+              && n.pri_offset == 0;\n+    return cc;\n+  }\n+\n+  void combineWithFollowing(const proc_regionwithpathinfo& mem_info) {\n+    _size += mem_info.prp_prinfo.pri_size;\n+  }\n+\n+  void process(const proc_regionwithpathinfo& mem_info) {\n+    reset();\n+\n+    _rinfo = mem_info.prp_prinfo;\n+\n+    _address = (const char*) _rinfo.pri_address;\n+    _size = _rinfo.pri_size;\n+\n+    if (mem_info.prp_vip.vip_path[0] != '\\0') {\n+      _file_name.print_raw(mem_info.prp_vip.vip_path);\n+    }\n+    \/\/ proc_regionfilename() seems to give bad results, so we don't try to use it here.\n+\n+    char prot[4];\n+    char maxprot[4];\n+    rwbits(_rinfo.pri_protection, prot);\n+    rwbits(_rinfo.pri_max_protection, maxprot);\n+    _protect_buffer.print(\"%s\/%s\", prot, maxprot);\n+\n+    get_share_mode(_share_buffer, _rinfo);\n+    _tag_text = tagToStr(_rinfo.pri_user_tag);\n+  }\n+\n+  static void get_share_mode(outputStream& out, const proc_regioninfo& rinfo) {\n+    static const char* share_strings[] = {\n+      \"cow\", \"pvt\", \"---\", \"shr\", \"tsh\", \"p\/a\", \"s\/a\", \"lpg\"\n+    };\n+    assert(SM_COW == 1 && SM_LARGE_PAGE == (sizeof(share_strings)\/sizeof(share_strings[0])), \"share_mode contants are out of range\");  \/\/ the +1 offset is intentional; see below\n+    const bool valid_share_mode = rinfo.pri_share_mode >= SM_COW && rinfo.pri_share_mode <= SM_LARGE_PAGE;\n+    if (valid_share_mode) {\n+      int share_mode = rinfo.pri_share_mode;\n+      out.print_raw(share_strings[share_mode - 1]);\n+    } else {\n+      out.print_cr(\"invalid pri_share_mode (%d)\", rinfo.pri_share_mode);\n+      assert(valid_share_mode, \"invalid pri_share_mode (%d)\", rinfo.pri_share_mode);\n+    }\n+  }\n+\n+#define X1(TAG, DESCR) X2(TAG, DESCR)\n+#define X2(TAG, DESCRIPTION) case VM_MEMORY_ ## TAG: return # DESCRIPTION;\n+  static const char* tagToStr(uint32_t user_tag) {\n+    switch (user_tag) {\n+      case 0:\n+        return 0;\n+      X1(MALLOC, malloc);\n+      X1(MALLOC_SMALL, malloc_small);\n+      X1(MALLOC_LARGE, malloc_large);\n+      X1(MALLOC_HUGE, malloc_huge);\n+      X1(SBRK, sbrk);\n+      X1(REALLOC, realloc);\n+      X1(MALLOC_TINY, malloc_tiny);\n+      X1(MALLOC_LARGE_REUSABLE, malloc_large_reusable);\n+      X1(MALLOC_LARGE_REUSED, malloc_lage_reused);\n+      X1(ANALYSIS_TOOL, analysis_tool);\n+      X1(MALLOC_NANO, malloc_nano);\n+      X1(MALLOC_MEDIUM, malloc_medium);\n+      X1(MALLOC_PROB_GUARD, malloc_prob_guard);\n+      X1(MACH_MSG, malloc_msg);\n+      X1(IOKIT, IOKit);\n+      X1(STACK, stack);\n+      X1(GUARD, guard);\n+      X1(SHARED_PMAP, shared_pmap);\n+      X1(DYLIB, dylib);\n+      X1(UNSHARED_PMAP, unshared_pmap);\n+      X2(APPKIT, AppKit);\n+      X2(FOUNDATION, Foundation);\n+      X2(COREGRAPHICS, CoreGraphics);\n+      X2(CORESERVICES, CoreServices); \/\/ is also VM_MEMORY_CARBON\n+      X2(JAVA, Java);\n+      X2(COREDATA, CoreData);\n+      X1(COREDATA_OBJECTIDS, CodeData_objectids);\n+      X1(ATS, ats);\n+      X1(DYLD, dyld);\n+      X1(DYLD_MALLOC, dyld_malloc);\n+      X1(SQLITE, sqlite);\n+      X1(JAVASCRIPT_CORE, javascript_core);\n+      X1(JAVASCRIPT_JIT_EXECUTABLE_ALLOCATOR, javascript_jit_executable_allocator);\n+      X1(JAVASCRIPT_JIT_REGISTER_FILE, javascript_jit_register_file);\n+      X1(OPENCL, OpenCL);\n+      X2(COREIMAGE, CoreImage);\n+      X2(IMAGEIO, ImageIO);\n+      X2(COREPROFILE, CoreProfile);\n+      X1(APPLICATION_SPECIFIC_1, application_specific_1);\n+      X1(APPLICATION_SPECIFIC_16, application_specific_16);\n+      X1(OS_ALLOC_ONCE, os_alloc_once);\n+      X1(GENEALOGY, genealogy);\n+      default:\n+        static char buffer[30];\n+        snprintf(buffer, sizeof(buffer), \"user_tag=0x%x(%d)\", user_tag, user_tag);\n+        return buffer;\n+    }\n+  }\n+\n+  static void rwbits(int rw, char bits[4]) {\n+    bits[0] = rw & VM_PROT_READ ? 'r' : '-';\n+    bits[1] = rw & VM_PROT_WRITE ? 'w' : '-';\n+    bits[2] = rw & VM_PROT_EXECUTE ? 'x' : '-';\n+    bits[3] = 0;\n+  }\n+};\n+\n+class ProcSmapsSummary {\n+  unsigned _num_mappings;\n+  size_t _private;\n+  size_t _committed;    \/\/ combined committed size\n+  size_t _reserved;     \/\/ reserved but not committed\n+  size_t _shared;       \/\/ combined shared size\n+  size_t _swapped_out;  \/\/ combined amount of swapped-out memory\n+public:\n+  ProcSmapsSummary() : _num_mappings(0), _private(0),\n+                       _committed(0), _shared(0), _swapped_out(0) {}\n+\n+  void add_mapping(const proc_regioninfo& region_info) {\n+    _num_mappings++;\n+\n+    bool is_private = region_info.pri_share_mode == SM_PRIVATE\n+                   || region_info.pri_share_mode == SM_PRIVATE_ALIASED;\n+    bool is_shared = region_info.pri_share_mode == SM_SHARED\n+                   || region_info.pri_share_mode == SM_SHARED_ALIASED\n+                   || region_info.pri_share_mode == SM_TRUESHARED\n+                   || region_info.pri_share_mode == SM_COW;\n+    bool is_committed = region_info.pri_share_mode == SM_EMPTY\n+                   && region_info.pri_max_protection == VM_PROT_ALL\n+                   && ((region_info.pri_protection & VM_PROT_DEFAULT) == VM_PROT_DEFAULT);\n+    bool is_reserved = region_info.pri_share_mode == SM_EMPTY\n+                   && region_info.pri_max_protection == VM_PROT_ALL\n+                   && region_info.pri_protection == VM_PROT_NONE;\n+\n+    _private += is_private ? region_info.pri_size : 0;\n+    _shared += is_shared ? region_info.pri_size : 0;\n+    _swapped_out += region_info.pri_pages_swapped_out;\n+    _committed += is_committed ? region_info.pri_size : 0;\n+    _reserved += is_reserved ? region_info.pri_size : 0;\n+  }\n+\n+  void print_on(const MappingPrintSession& session) const {\n+    outputStream* st = session.out();\n+\n+    st->print_cr(\"Number of mappings: %u\", _num_mappings);\n+\n+    task_vm_info vm_info;\n+    mach_msg_type_number_t num_out = TASK_VM_INFO_COUNT;\n+    kern_return_t err = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t)(&vm_info), &num_out);\n+    if (err == KERN_SUCCESS) {\n+      st->print_cr(\"             vsize: %llu (%llu%s)\", vm_info.virtual_size, PROPERFMTARGS(vm_info.virtual_size));\n+      st->print_cr(\"               rss: %llu (%llu%s)\", vm_info.resident_size, PROPERFMTARGS(vm_info.resident_size));\n+      st->print_cr(\"          peak rss: %llu (%llu%s)\", vm_info.resident_size_peak, PROPERFMTARGS(vm_info.resident_size_peak));\n+      st->print_cr(\"         page size: %d (%ld%s)\", vm_info.page_size, PROPERFMTARGS((size_t)vm_info.page_size));\n+    } else {\n+      st->print_cr(\"error getting vm_info %d\", err);\n+    }\n+    st->print_cr(\"          reserved: %zu (\" PROPERFMT \")\", _reserved, PROPERFMTARGS(_reserved));\n+    st->print_cr(\"         committed: %zu (\" PROPERFMT \")\", _committed, PROPERFMTARGS(_committed));\n+    st->print_cr(\"           private: %zu (\" PROPERFMT \")\", _private, PROPERFMTARGS(_private));\n+    st->print_cr(\"            shared: %zu (\" PROPERFMT \")\", _shared, PROPERFMTARGS(_shared));\n+    st->print_cr(\"       swapped out: %zu (\" PROPERFMT \")\", _swapped_out * vm_info.page_size, PROPERFMTARGS(_swapped_out * vm_info.page_size));\n+  }\n+};\n+\n+class ProcSmapsPrinter {\n+  const MappingPrintSession& _session;\n+public:\n+  ProcSmapsPrinter(const MappingPrintSession& session) :\n+    _session(session)\n+  {}\n+\n+  void print_single_mapping(const proc_regioninfo& region_info, const MappingInfo& mapping_info) const {\n+     outputStream* st = _session.out();\n+#define INDENT_BY(n)          \\\n+  if (st->fill_to(n) == 0) {  \\\n+    st->print(\" \");           \\\n+  }\n+    st->print(\"%#014.12llx-%#014.12llx\", (uint64_t)(mapping_info._address), (uint64_t)(mapping_info._address + mapping_info._size));\n+    INDENT_BY(38);\n+    st->print(\"%12ld\", mapping_info._size);\n+    INDENT_BY(51);\n+    st->print(\"%s\", mapping_info._protect_buffer.base());\n+    INDENT_BY(59);\n+    st->print(\"%s\", mapping_info._share_buffer.base());\n+    st->print(\"%s\", mapping_info._type_buffer.base());\n+    INDENT_BY(64);\n+    st->print(\"%#11llx\", region_info.pri_offset);\n+    INDENT_BY(77);\n+    if (_session.print_nmt_info_for_region((const void*)mapping_info._address, (const void*)(mapping_info._address + mapping_info._size))) {\n+      st->print(\" \");\n+    } else {\n+      const char* tag = mapping_info._tag_text;\n+      if (tag != nullptr) {\n+        st->print(\"[%s] \", tag);\n+      }\n+    }\n+\n+    st->print_raw(mapping_info._file_name.base());\n+    st->cr();\n+\n+#undef INDENT_BY\n+  }\n+\n+  void print_legend() const {\n+    outputStream* st = _session.out();\n+    st->print_cr(\"from, to, vsize: address range and size\");\n+    st->print_cr(\"prot:    protection:\");\n+    st->print_cr(\"           rwx: read \/ write \/ execute\");\n+    st->print_cr(\"share:   share mode:\");\n+    st->print_cr(\"           cow: copy on write\");\n+    st->print_cr(\"           pvt: private\");\n+    st->print_cr(\"           shr: shared\");\n+    st->print_cr(\"           tsh: true shared\");\n+    st->print_cr(\"           p\/a: private aliased\");\n+    st->print_cr(\"           s\/a: shared aliased\");\n+    st->print_cr(\"           lpg: large page\");\n+    st->print_cr(\"offset:  offset from start of allocation block\");\n+    st->print_cr(\"vminfo:  VM information (requires NMT)\");\n+    st->print_cr(\"file:    file mapped, if mapping is not anonymous\");\n+    {\n+      streamIndentor si(st, 16);\n+      _session.print_nmt_flag_legend();\n+    }\n+    st->print_cr(\"file:            file mapped, if mapping is not anonymous\");\n+  }\n+\n+  void print_header() const {\n+    outputStream* st = _session.out();\n+    \/\/            0         1         2         3         4         5         6         7         8         9         0         1         2         3         4         5         6         7\n+    \/\/            012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/            0x000102890000-0x000102898000                32768 r--\/r-- cow       0xc000 \/Users\/simont\/dev\/openjdk\/jdk\/build\/macos-aarch64-fastdebug-shenandoah\/images\/jdk\/bin\/java\n+    st->print_cr(\"from               to                        vsize prot    share     offset  vminfo\/file\");\n+    st->print_cr(\"==================================================================================================\");\n+  }\n+};\n+\n+static bool is_interesting(const proc_regionwithpathinfo& info) {\n+   return info.prp_prinfo.pri_share_mode != SM_EMPTY\n+          || info.prp_prinfo.pri_user_tag != 0\n+          || info.prp_vip.vip_path[0] != '\\0'\n+          || info.prp_prinfo.pri_protection != 0\n+          || info.prp_prinfo.pri_max_protection != 0;\n+}\n+\n+void MemMapPrinter::pd_print_all_mappings(const MappingPrintSession& session) {\n+\n+  ProcSmapsPrinter printer(session);\n+  ProcSmapsSummary summary;\n+  outputStream* const st = session.out();\n+  const pid_t pid = getpid();\n+\n+  printer.print_legend();\n+  st->cr();\n+  printer.print_header();\n+\n+  proc_regionwithpathinfo region_info_with_path;\n+  MappingInfo mapping_info;\n+  uint64_t address = 0;\n+  int region_count = 0;\n+  while (true) {\n+    if (++region_count > MAX_REGIONS_RETURNED) {\n+      st->print_cr(\"limit of %d regions reached (results inaccurate)\", region_count);\n+      break;\n+    }\n+    ::bzero(&region_info_with_path, sizeof(region_info_with_path));\n+    int retval = proc_pidinfo(pid, PROC_PIDREGIONPATHINFO, (uint64_t)address, &region_info_with_path, sizeof(region_info_with_path));\n+    if (retval <= 0) {\n+      break;\n+    } else if (retval < (int)sizeof(region_info_with_path)) {\n+      st->print_cr(\"proc_pidinfo() returned %d\", retval);\n+      assert(false, \"proc_pidinfo() returned %d\", retval);\n+    }\n+    proc_regioninfo& region_info = region_info_with_path.prp_prinfo;\n+    if (is_interesting(region_info_with_path)) {\n+      if (mapping_info.canCombine(region_info_with_path)) {\n+        mapping_info.combineWithFollowing(region_info_with_path);\n+      } else {\n+        \/\/ print previous mapping info\n+        \/\/ avoid printing the empty info at the start\n+        if (mapping_info._size != 0) {\n+          printer.print_single_mapping(region_info, mapping_info);\n+        }\n+        summary.add_mapping(region_info);\n+        mapping_info.process(region_info_with_path);\n+      }\n+    }\n+    assert(region_info.pri_size > 0, \"size of region is 0\");\n+    address = region_info.pri_address + region_info.pri_size;\n+  }\n+  printer.print_single_mapping(region_info_with_path.prp_prinfo, mapping_info);\n+  summary.add_mapping(region_info_with_path.prp_prinfo);\n+  st->cr();\n+  summary.print_on(session);\n+  st->cr();\n+}\n+#endif \/\/ __APPLE__\n\\ No newline at end of file\n","filename":"src\/hotspot\/os\/bsd\/memMapPrinter_macosx.cpp","additions":383,"deletions":0,"binary":false,"changes":383,"status":"added"},{"patch":"@@ -46,1 +46,1 @@\n-#define UNIX_PATH_MAX   sizeof(((struct sockaddr_un *)0)->sun_path)\n+#define UNIX_PATH_MAX   sizeof(sockaddr_un::sun_path)\n@@ -79,3 +79,0 @@\n-  \/\/ reads a request from the given connected socket\n-  static PosixAttachOperation* read_request(int s);\n-\n@@ -83,7 +80,0 @@\n-  enum {\n-    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n-  };\n-  enum {\n-    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n-  };\n-\n@@ -110,3 +100,0 @@\n-  \/\/ write the given buffer to a socket\n-  static int write_fully(int s, char* buf, size_t len);\n-\n@@ -116,0 +103,39 @@\n+class SocketChannel : public AttachOperation::RequestReader, public AttachOperation::ReplyWriter {\n+private:\n+  int _socket;\n+public:\n+  SocketChannel(int socket) : _socket(socket) {}\n+  ~SocketChannel() {\n+    close();\n+  }\n+\n+  bool opened() const {\n+    return _socket != -1;\n+  }\n+\n+  void close() {\n+    if (opened()) {\n+      ::close(_socket);\n+      _socket = -1;\n+    }\n+  }\n+\n+  \/\/ RequestReader\n+  int read(void* buffer, int size) override {\n+    ssize_t n;\n+    RESTARTABLE(::read(_socket, buffer, (size_t)size), n);\n+    return checked_cast<int>(n);\n+  }\n+\n+  \/\/ ReplyWriter\n+  int write(const void* buffer, int size) override {\n+    ssize_t n;\n+    RESTARTABLE(::write(_socket, buffer, size), n);\n+    return checked_cast<int>(n);\n+  }\n+  \/\/ called after writing all data\n+  void flush() override {\n+    ::shutdown(_socket, SHUT_RDWR);\n+  }\n+};\n+\n@@ -119,1 +145,1 @@\n-  int _socket;\n+  SocketChannel _socket_channel;\n@@ -122,1 +148,1 @@\n-  void complete(jint res, bufferedStream* st);\n+  void complete(jint res, bufferedStream* st) override;\n@@ -124,2 +150,2 @@\n-  void set_socket(int s)                                { _socket = s; }\n-  int socket() const                                    { return _socket; }\n+  PosixAttachOperation(int socket) : AttachOperation(), _socket_channel(socket) {\n+  }\n@@ -127,2 +153,2 @@\n-  PosixAttachOperation(char* name) : AttachOperation(name) {\n-    set_socket(-1);\n+  bool read_request() {\n+    return AttachOperation::read_request(&_socket_channel, &_socket_channel);\n@@ -138,29 +164,0 @@\n-\/\/ Supporting class to help split a buffer into individual components\n-class ArgumentIterator : public StackObj {\n- private:\n-  char* _pos;\n-  char* _end;\n- public:\n-  ArgumentIterator(char* arg_buffer, size_t arg_size) {\n-    _pos = arg_buffer;\n-    _end = _pos + arg_size - 1;\n-  }\n-  char* next() {\n-    if (*_pos == '\\0') {\n-      \/\/ advance the iterator if possible (null arguments)\n-      if (_pos < _end) {\n-        _pos += 1;\n-      }\n-      return nullptr;\n-    }\n-    char* res = _pos;\n-    char* next_pos = strchr(_pos, '\\0');\n-    if (next_pos < _end)  {\n-      next_pos++;\n-    }\n-    _pos = next_pos;\n-    return res;\n-  }\n-};\n-\n-\n@@ -252,97 +249,0 @@\n-\/\/ Given a socket that is connected to a peer we read the request and\n-\/\/ create an AttachOperation. As the socket is blocking there is potential\n-\/\/ for a denial-of-service if the peer does not response. However this happens\n-\/\/ after the peer credentials have been checked and in the worst case it just\n-\/\/ means that the attach listener thread is blocked.\n-\/\/\n-PosixAttachOperation* PosixAttachListener::read_request(int s) {\n-  char ver_str[8];\n-  os::snprintf_checked(ver_str, sizeof(ver_str), \"%d\", ATTACH_PROTOCOL_VER);\n-\n-  \/\/ The request is a sequence of strings so we first figure out the\n-  \/\/ expected count and the maximum possible length of the request.\n-  \/\/ The request is:\n-  \/\/   <ver>0<cmd>0<arg>0<arg>0<arg>0\n-  \/\/ where <ver> is the protocol version (1), <cmd> is the command\n-  \/\/ name (\"load\", \"datadump\", ...), and <arg> is an argument\n-  int expected_str_count = 2 + AttachOperation::arg_count_max;\n-  const size_t max_len = (sizeof(ver_str) + 1) + (AttachOperation::name_length_max + 1) +\n-    AttachOperation::arg_count_max*(AttachOperation::arg_length_max + 1);\n-\n-  char buf[max_len];\n-  int str_count = 0;\n-\n-  \/\/ Read until all (expected) strings have been read, the buffer is\n-  \/\/ full, or EOF.\n-\n-  size_t off = 0;\n-  size_t left = max_len;\n-\n-  do {\n-    ssize_t n;\n-    RESTARTABLE(read(s, buf+off, left), n);\n-    assert(n <= checked_cast<ssize_t>(left), \"buffer was too small, impossible!\");\n-    buf[max_len - 1] = '\\0';\n-    if (n == -1) {\n-      return nullptr;      \/\/ reset by peer or other error\n-    }\n-    if (n == 0) {\n-      break;\n-    }\n-    for (ssize_t i=0; i<n; i++) {\n-      if (buf[off+i] == 0) {\n-        \/\/ EOS found\n-        str_count++;\n-\n-        \/\/ The first string is <ver> so check it now to\n-        \/\/ check for protocol mismatch\n-        if (str_count == 1) {\n-          if ((strlen(buf) != strlen(ver_str)) ||\n-              (atoi(buf) != ATTACH_PROTOCOL_VER)) {\n-            char msg[32];\n-            os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", ATTACH_ERROR_BADVERSION);\n-            write_fully(s, msg, strlen(msg));\n-            return nullptr;\n-          }\n-        }\n-      }\n-    }\n-    off += n;\n-    left -= n;\n-  } while (left > 0 && str_count < expected_str_count);\n-\n-  if (str_count != expected_str_count) {\n-    return nullptr;        \/\/ incomplete request\n-  }\n-\n-  \/\/ parse request\n-\n-  ArgumentIterator args(buf, (max_len)-left);\n-\n-  \/\/ version already checked\n-  char* v = args.next();\n-\n-  char* name = args.next();\n-  if (name == nullptr || strlen(name) > AttachOperation::name_length_max) {\n-    return nullptr;\n-  }\n-\n-  PosixAttachOperation* op = new PosixAttachOperation(name);\n-\n-  for (int i=0; i<AttachOperation::arg_count_max; i++) {\n-    char* arg = args.next();\n-    if (arg == nullptr) {\n-      op->set_arg(i, nullptr);\n-    } else {\n-      if (strlen(arg) > AttachOperation::arg_length_max) {\n-        delete op;\n-        return nullptr;\n-      }\n-      op->set_arg(i, arg);\n-    }\n-  }\n-\n-  op->set_socket(s);\n-  return op;\n-}\n-\n@@ -403,3 +303,3 @@\n-    PosixAttachOperation* op = read_request(s);\n-    if (op == nullptr) {\n-      ::close(s);\n+    PosixAttachOperation* op = new PosixAttachOperation(s);\n+    if (!op->read_request()) {\n+      delete op;\n@@ -413,15 +313,0 @@\n-\/\/ write the given buffer to the socket\n-int PosixAttachListener::write_fully(int s, char* buf, size_t len) {\n-  do {\n-    ssize_t n = ::write(s, buf, len);\n-    if (n == -1) {\n-      if (errno != EINTR) return -1;\n-    } else {\n-      buf += n;\n-      len -= n;\n-    }\n-  }\n-  while (len > 0);\n-  return 0;\n-}\n-\n@@ -440,13 +325,1 @@\n-  \/\/ write operation result\n-  char msg[32];\n-  os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", result);\n-  int rc = PosixAttachListener::write_fully(this->socket(), msg, strlen(msg));\n-\n-  \/\/ write any result data\n-  if (rc == 0) {\n-    PosixAttachListener::write_fully(this->socket(), (char*) st->base(), st->size());\n-    ::shutdown(this->socket(), 2);\n-  }\n-\n-  \/\/ done\n-  ::close(this->socket());\n+  write_reply(&_socket_channel, result, st);\n@@ -493,0 +366,2 @@\n+  AttachListener::set_supported_version(ATTACH_API_V2);\n+\n","filename":"src\/hotspot\/os\/posix\/attachListener_posix.cpp","additions":52,"deletions":177,"binary":false,"changes":229,"status":"modified"},{"patch":"@@ -1056,1 +1056,1 @@\n-  mapAddress = (char*)::mmap((char*)0, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n+  mapAddress = (char*)::mmap(nullptr, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n@@ -1211,1 +1211,1 @@\n-  char* mapAddress = (char*)::mmap((char*)0, size, mmap_prot, MAP_SHARED, fd, 0);\n+  char* mapAddress = (char*)::mmap(nullptr, size, mmap_prot, MAP_SHARED, fd, 0);\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-    return AttachOperation::read_request(&_pipe);\n+    return AttachOperation::read_request(&_pipe, &_pipe);\n","filename":"src\/hotspot\/os\/windows\/attachListener_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -200,0 +200,2 @@\n+    st->print_cr(\"offset:  offset from start of allocation block\");\n+    st->print_cr(\"vminfo:  VM information (requires NMT)\");\n@@ -201,1 +203,0 @@\n-    st->print_cr(\"vm info: VM information (requires NMT)\");\n","filename":"src\/hotspot\/os\/windows\/memMapPrinter_windows.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2014 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/javaThread_aix_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,0 +188,6 @@\n+    PRAGMA_DIAG_PUSH\n+    PRAGMA_NONNULL_IGNORED\n+    \/\/ Suppress false positive gcc warning, which may be an example of\n+    \/\/ https:\/\/gcc.gnu.org\/bugzilla\/show_bug.cgi?id=87489\n+    \/\/ The warning also hasn't been seen with vanilla gcc release, so may also\n+    \/\/ involve some distro-specific gcc patch.\n@@ -189,0 +195,1 @@\n+    PRAGMA_DIAG_POP\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/javaThread_linux_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/os_linux_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-#include \"compiler\/compilerDirectives.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n@@ -34,1 +33,0 @@\n-#include \"runtime\/synchronizer.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -46,2 +45,0 @@\n-#include \"runtime\/vm_version.hpp\"\n-#include \"utilities\/bitMap.inline.hpp\"\n@@ -49,1 +46,0 @@\n-#include \"utilities\/powerOfTwo.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-#include \"ci\/ciMethod.hpp\"\n-#include \"ci\/ciStreams.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_IR.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"ci\/ciInstance.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"ci\/ciMethodData.hpp\"\n@@ -33,1 +32,0 @@\n-#include \"jfr\/support\/jfrIntrinsics.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"c1\/c1_Canonicalizer.hpp\"\n@@ -28,1 +27,0 @@\n-#include \"c1\/c1_ValueMap.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-#include \"c1\/c1_Canonicalizer.hpp\"\n-#include \"c1\/c1_ValueMap.hpp\"\n@@ -33,1 +31,0 @@\n-#ifdef ASSERT\n@@ -35,1 +32,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"c1\/c1_FrameMap.hpp\"\n@@ -38,1 +37,0 @@\n-#include \"code\/pcDesc.hpp\"\n@@ -51,1 +49,0 @@\n-#include \"memory\/allocation.inline.hpp\"\n@@ -56,1 +53,0 @@\n-#include \"oops\/klass.inline.hpp\"\n@@ -70,1 +66,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/deoptimization.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"c1\/c1_Canonicalizer.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"utilities\/bitMap.inline.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -31,1 +30,0 @@\n-#include \"utilities\/bitMap.inline.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_ValueSet.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-#include \"ci\/ciConstant.hpp\"\n-#include \"ci\/ciMethodData.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_ValueType.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"memory\/memoryReserver.hpp\"\n@@ -196,1 +197,1 @@\n-    _shared_rs.release();\n+    MemoryReserver::release(_shared_rs);\n@@ -350,1 +351,3 @@\n-  ReservedSpace rs(buffer_size, MetaspaceShared::core_region_alignment(), os::vm_page_size());\n+  ReservedSpace rs = MemoryReserver::reserve(buffer_size,\n+                                             MetaspaceShared::core_region_alignment(),\n+                                             os::vm_page_size());\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#include \"memory\/reservedSpace.hpp\"\n+#include \"memory\/virtualspace.hpp\"\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-#include \"memory\/virtualspace.hpp\"\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -350,0 +350,1 @@\n+        _is_multi_release = cpe->is_multi_release_jar();\n@@ -2222,1 +2223,1 @@\n-    return \/*dumptime*\/ narrow_oop_base() + r->mapping_offset();\n+    return \/*dumptime*\/ (address)((uintptr_t)narrow_oop_base() + r->mapping_offset());\n@@ -2248,1 +2249,1 @@\n-    return \/*runtime*\/ CompressedOops::base() + r->mapping_offset();\n+    return \/*runtime*\/ (address)((uintptr_t)CompressedOops::base() + r->mapping_offset());\n@@ -2683,1 +2684,1 @@\n-      ent = ClassLoader::create_class_path_entry(THREAD, path, &st, false, false);\n+      ent = ClassLoader::create_class_path_entry(THREAD, path, &st, false, false, scpe->is_multi_release());\n@@ -2718,1 +2719,1 @@\n-  if (class_loader() != nullptr && !cpe->is_modules_image()) {\n+  if (class_loader() != nullptr && !cpe->is_modules_image() && cpe->is_multi_release_jar()) {\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+class ReservedSpace;\n@@ -67,0 +68,1 @@\n+  bool   _is_multi_release;\n@@ -74,1 +76,1 @@\n-                           _from_class_path_attr(false), _timestamp(0),\n+                           _from_class_path_attr(false), _is_multi_release(false), _timestamp(0),\n@@ -95,0 +97,1 @@\n+  bool is_multi_release()     { return _is_multi_release; }\n@@ -482,1 +485,0 @@\n-  ReservedSpace reserve_shared_memory();\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"memory\/memoryReserver.hpp\"\n@@ -285,1 +286,1 @@\n-  _symbol_rs = ReservedSpace(symbol_rs_size, mtClassShared);\n+  _symbol_rs = MemoryReserver::reserve(symbol_rs_size, mtClassShared);\n@@ -1269,1 +1270,3 @@\n-        archive_space_rs.release();\n+        MemoryReserver::release(archive_space_rs);\n+        \/\/ Mark as not reserved\n+        archive_space_rs = {};\n@@ -1441,2 +1444,4 @@\n-    archive_space_rs = ReservedSpace(archive_space_size, archive_space_alignment,\n-                                     os::vm_page_size(), (char*)base_address);\n+    archive_space_rs = MemoryReserver::reserve((char*)base_address,\n+                                               archive_space_size,\n+                                               archive_space_alignment,\n+                                               os::vm_page_size());\n@@ -1508,4 +1513,8 @@\n-      archive_space_rs = ReservedSpace(archive_space_size, archive_space_alignment,\n-                                       os::vm_page_size(), (char*)base_address);\n-      class_space_rs   = ReservedSpace(class_space_size, class_space_alignment,\n-                                       os::vm_page_size(), (char*)ccs_base);\n+      archive_space_rs = MemoryReserver::reserve((char*)base_address,\n+                                                 archive_space_size,\n+                                                 archive_space_alignment,\n+                                                 os::vm_page_size());\n+      class_space_rs   = MemoryReserver::reserve((char*)ccs_base,\n+                                                 class_space_size,\n+                                                 class_space_alignment,\n+                                                 os::vm_page_size());\n@@ -1522,2 +1531,4 @@\n-      total_space_rs = ReservedSpace(total_range_size, base_address_alignment,\n-                                     os::vm_page_size(), (char*) base_address);\n+      total_space_rs = MemoryReserver::reserve((char*) base_address,\n+                                               total_range_size,\n+                                               base_address_alignment,\n+                                               os::vm_page_size());\n@@ -1571,1 +1582,2 @@\n-    total_space_rs.release();\n+    MemoryReserver::release(total_space_rs);\n+    total_space_rs = {};\n@@ -1575,1 +1587,2 @@\n-      archive_space_rs.release();\n+      MemoryReserver::release(archive_space_rs);\n+      archive_space_rs = {};\n@@ -1579,1 +1592,2 @@\n-      class_space_rs.release();\n+      MemoryReserver::release(class_space_rs);\n+      class_space_rs = {};\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"memory\/reservedSpace.hpp\"\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"opto\/node.hpp\"\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+\/\/ The caller is required\/expected to have a ResourceMark in this case.\n@@ -52,1 +53,0 @@\n-  ResourceMark rm(THREAD);\n@@ -95,0 +95,6 @@\n+void ClassFileParser::classfile_icce_error(const char* msg,\n+                                           TRAPS) const {\n+  ResourceMark rm(THREAD);\n+  Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IncompatibleClassChangeError(), msg);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileError.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3750,0 +3750,6 @@\n+\n+  \/\/ Initialize cached modifier_flags to support Class.getModifiers().\n+  \/\/ This must follow setting inner_class attributes.\n+  int computed_modifiers = this_klass->compute_modifier_flags();\n+  this_klass->set_modifier_flags(computed_modifiers);\n+\n@@ -4067,3 +4073,7 @@\n-    if (super_ik->is_sealed() && !super_ik->has_as_permitted_subclass(this_klass)) {\n-      classfile_icce_error(\"class %s cannot inherit from sealed class %s\", super_ik, THREAD);\n-      return;\n+    if (super_ik->is_sealed()) {\n+      stringStream ss;\n+      ResourceMark rm(THREAD);\n+      if (!super_ik->has_as_permitted_subclass(this_klass, ss)) {\n+        classfile_icce_error(ss.as_string(), THREAD);\n+        return;\n+      }\n@@ -4114,6 +4124,7 @@\n-    if (k->is_sealed() && !k->has_as_permitted_subclass(this_klass)) {\n-      classfile_icce_error(this_klass->is_interface() ?\n-                             \"class %s cannot extend sealed interface %s\" :\n-                             \"class %s cannot implement sealed interface %s\",\n-                           k, THREAD);\n-      return;\n+    if (k->is_sealed()) {\n+      stringStream ss;\n+      ResourceMark rm(THREAD);\n+      if (!k->has_as_permitted_subclass(this_klass, ss)) {\n+        classfile_icce_error(ss.as_string(), THREAD);\n+        return;\n+      }\n@@ -5170,1 +5181,0 @@\n-  \/\/ The create_mirror() call will also call compute_modifiers()\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -370,0 +370,4 @@\n+  \/\/ Uses msg directly in the ICCE, with no additional content\n+  void classfile_icce_error(const char* msg,\n+                            TRAPS) const;\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-                                     bool is_boot_append, bool from_class_path_attr) : ClassPathEntry() {\n+                                     bool is_boot_append, bool from_class_path_attr, bool multi_release) : ClassPathEntry() {\n@@ -310,0 +310,1 @@\n+  _multi_release = multi_release;\n@@ -753,1 +754,2 @@\n-                                                     bool from_class_path_attr) {\n+                                                     bool from_class_path_attr,\n+                                                     bool is_multi_release) {\n@@ -766,1 +768,1 @@\n-      new_entry = new ClassPathZipEntry(zip, path, is_boot_append, from_class_path_attr);\n+      new_entry = new ClassPathZipEntry(zip, path, is_boot_append, from_class_path_attr, is_multi_release);\n@@ -799,1 +801,1 @@\n-          return new ClassPathZipEntry(zip, canonical_path, is_boot_append, false);\n+          return new ClassPathZipEntry(zip, canonical_path, is_boot_append, false, false);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+  virtual bool is_multi_release_jar() const { return false; }\n+  virtual void set_multi_release_jar() {}\n@@ -94,0 +96,1 @@\n+  bool _multi_release;       \/\/ multi-release jar\n@@ -96,0 +99,2 @@\n+  bool is_multi_release_jar() const { return _multi_release; }\n+  void set_multi_release_jar() { _multi_release = true; }\n@@ -98,1 +103,1 @@\n-  ClassPathZipEntry(jzfile* zip, const char* zip_name, bool is_boot_append, bool from_class_path_attr);\n+  ClassPathZipEntry(jzfile* zip, const char* zip_name, bool is_boot_append, bool from_class_path_attr, bool multi_release);\n@@ -263,1 +268,2 @@\n-                                                 bool from_class_path_attr);\n+                                                 bool from_class_path_attr,\n+                                                 bool is_multi_release = false);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -247,0 +247,4 @@\n+  if (strstr(manifest, \"Multi-Release: true\") != nullptr) {\n+    entry->set_multi_release_jar();\n+  }\n+\n@@ -302,0 +306,1 @@\n+  return;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1116,6 +1116,0 @@\n-  \/\/ Use this moment of initialization to cache modifier_flags also,\n-  \/\/ to support Class.getModifiers().  Instance classes recalculate\n-  \/\/ the cached flags after the class file is parsed, but before the\n-  \/\/ class is put into the system dictionary.\n-  int computed_modifiers = k->compute_modifier_flags();\n-  k->set_modifier_flags(computed_modifiers);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -745,1 +745,1 @@\n-               name() == nullptr ? UNNAMED_MODULE : name()->as_C_string(),\n+               name_as_C_string(),\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -188,0 +188,4 @@\n+  \/\/ Note caller requires ResourceMark\n+  const char* name_as_C_string() {\n+    return is_named() ? name()->as_C_string() : UNNAMED_MODULE;\n+  }\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+#ifdef COMPILER2\n+#include \"opto\/c2_globals.hpp\"\n+#endif\n@@ -34,1 +37,0 @@\n-#include \"utilities\/xmlstream.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"memory\/memoryReserver.hpp\"\n@@ -321,1 +322,1 @@\n-  ReservedCodeSpace rs = reserve_heap_memory(cache_size, ps);\n+  ReservedSpace rs = reserve_heap_memory(cache_size, ps);\n@@ -351,1 +352,1 @@\n-ReservedCodeSpace CodeCache::reserve_heap_memory(size_t size, size_t rs_ps) {\n+ReservedSpace CodeCache::reserve_heap_memory(size_t size, size_t rs_ps) {\n@@ -355,1 +356,2 @@\n-  ReservedCodeSpace rs(rs_size, rs_align, rs_ps);\n+\n+  ReservedSpace rs = CodeMemoryReserver::reserve(rs_size, rs_align, rs_ps);\n@@ -1133,1 +1135,1 @@\n-    ReservedCodeSpace rs = reserve_heap_memory(ReservedCodeCacheSize, page_size(false, min_pages));\n+    ReservedSpace rs = reserve_heap_memory(ReservedCodeCacheSize, page_size(false, min_pages));\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+class ReservedSpace;\n@@ -125,1 +126,1 @@\n-  static ReservedCodeSpace reserve_heap_memory(size_t size, size_t rs_ps); \/\/ Reserves one continuous chunk of memory for the CodeHeaps\n+  static ReservedSpace reserve_heap_memory(size_t size, size_t rs_ps); \/\/ Reserves one continuous chunk of memory for the CodeHeaps\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"opto\/c2_MacroAssembler.hpp\"\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,3 +43,0 @@\n-#ifdef COMPILER2\n-#include \"opto\/matcher.hpp\"\n-#endif\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-\n@@ -37,1 +36,0 @@\n-#include \"compiler\/compilerDefinitions.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"ci\/ciMetadata.hpp\"\n@@ -31,1 +30,0 @@\n-#include \"compiler\/compiler_globals.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+#include \"memory\/memoryReserver.hpp\"\n@@ -1215,0 +1216,10 @@\n+\n+  \/\/ When a page size is given we don't want to mix large\n+  \/\/ and normal pages. If the size is not a multiple of the\n+  \/\/ page size it will be aligned up to achieve this.\n+  size_t alignment = os::vm_allocation_granularity();\n+  if (preferred_page_size != os::vm_page_size()) {\n+    alignment = MAX2(preferred_page_size, alignment);\n+    size = align_up(size, alignment);\n+  }\n+\n@@ -1216,1 +1227,4 @@\n-  ReservedSpace rs(size, preferred_page_size);\n+  ReservedSpace rs = MemoryReserver::reserve(size,\n+                                             alignment,\n+                                             preferred_page_size);\n+\n@@ -1291,1 +1305,1 @@\n-  G1CardTable* ct = new G1CardTable(heap_rs.region());\n+  G1CardTable* ct = new G1CardTable(_reserved);\n@@ -1443,1 +1457,1 @@\n-  FullGCForwarding::initialize(heap_rs.region());\n+  FullGCForwarding::initialize(_reserved);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"memory\/virtualspace.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkBitMap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"memory\/virtualspace.hpp\"\n@@ -33,0 +32,1 @@\n+class ReservedSpace;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/shared\/partialArraySplitter.inline.hpp\"\n@@ -39,1 +40,1 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n@@ -83,2 +84,1 @@\n-    _partial_array_state_allocator(g1h->partial_array_state_manager()),\n-    _partial_array_stepper(num_workers, ParGCArrayScanChunk),\n+    _partial_array_splitter(g1h->partial_array_state_manager(), num_workers),\n@@ -172,3 +172,6 @@\n-  \/\/ Must be in the collection set--it's already been copied.\n-  oop p = task->source();\n-  assert(_g1h->is_in_cset(p), \"p=\" PTR_FORMAT, p2i(p));\n+  assert(task != nullptr, \"invariant\");\n+  \/\/ Source isn't used for processing, so not recorded in task.\n+  assert(task->source() == nullptr, \"invariant\");\n+  oop p = task->destination();\n+  assert(_g1h->is_in_reserved(p),\n+         \"task=\" PTR_FORMAT \" dest=\" PTR_FORMAT, p2i(task), p2i(p));\n@@ -225,24 +228,5 @@\n-void G1ParScanThreadState::do_partial_array(PartialArrayState* state) {\n-  oop to_obj = state->destination();\n-\n-#ifdef ASSERT\n-  oop from_obj = state->source();\n-  assert(_g1h->is_in_reserved(from_obj), \"must be in heap.\");\n-  assert(from_obj->is_forwarded(), \"must be forwarded\");\n-  assert(from_obj != to_obj, \"should not be chunking self-forwarded objects\");\n-  assert(to_obj->is_objArray(), \"must be obj array\");\n-#endif \/\/ ASSERT\n-\n-  objArrayOop to_array = objArrayOop(to_obj);\n-\n-  \/\/ Claim a chunk and get number of additional tasks to enqueue.\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n-  \/\/ Push any additional partial scan tasks needed.  Pushed before processing\n-  \/\/ the claimed chunk to allow other workers to steal while we're processing.\n-  if (step._ncreate > 0) {\n-    state->add_references(step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_on_queue(ScannerTask(state));\n-    }\n-  }\n-\n+void G1ParScanThreadState::do_partial_array(PartialArrayState* state, bool stolen) {\n+  \/\/ Access state before release by claim().\n+  objArrayOop to_array = objArrayOop(state->destination());\n+  PartialArraySplitter::Claim claim =\n+    _partial_array_splitter.claim(state, _task_queue, stolen);\n@@ -253,4 +237,2 @@\n-                              checked_cast<int>(step._index),\n-                              checked_cast<int>(step._index + _partial_array_stepper.chunk_size()));\n-  \/\/ Release reference to the state, now that we're done with it.\n-  _partial_array_state_allocator.release(state);\n+                              checked_cast<int>(claim._start),\n+                              checked_cast<int>(claim._end));\n@@ -268,1 +250,0 @@\n-\n@@ -270,19 +251,3 @@\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n-\n-  \/\/ Push any needed partial scan tasks.  Pushed before processing the\n-  \/\/ initial chunk to allow other workers to steal while we're processing.\n-  if (step._ncreate > 0) {\n-    assert(step._index < array_length, \"invariant\");\n-    assert(((array_length - step._index) % _partial_array_stepper.chunk_size()) == 0,\n-           \"invariant\");\n-    PartialArrayState* state =\n-      _partial_array_state_allocator.allocate(from_obj, to_obj,\n-                                              step._index,\n-                                              array_length,\n-                                              step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_on_queue(ScannerTask(state));\n-    }\n-  } else {\n-    assert(step._index == array_length, \"invariant\");\n-  }\n+  size_t initial_chunk_size =\n+    \/\/ The source array is unused when processing states.\n+    _partial_array_splitter.start(_task_queue, nullptr, to_array, array_length);\n@@ -299,1 +264,1 @@\n-  to_array->oop_iterate_range(&_scanner, 0, checked_cast<int>(step._index));\n+  to_array->oop_iterate_range(&_scanner, 0, checked_cast<int>(initial_chunk_size));\n@@ -303,1 +268,1 @@\n-void G1ParScanThreadState::dispatch_task(ScannerTask task) {\n+void G1ParScanThreadState::dispatch_task(ScannerTask task, bool stolen) {\n@@ -310,1 +275,1 @@\n-    do_partial_array(task.to_partial_array_state());\n+    do_partial_array(task.to_partial_array_state(), stolen);\n@@ -323,1 +288,1 @@\n-        dispatch_task(task);\n+        dispatch_task(task, false);\n@@ -327,1 +292,1 @@\n-      dispatch_task(task);\n+      dispatch_task(task, false);\n@@ -336,1 +301,1 @@\n-    dispatch_task(stolen_task);\n+    dispatch_task(stolen_task, true);\n@@ -720,0 +685,8 @@\n+#if TASKQUEUE_STATS\n+\n+PartialArrayTaskStats* G1ParScanThreadState::partial_array_task_stats() {\n+  return _partial_array_splitter.stats();\n+}\n+\n+#endif \/\/ TASKQUEUE_STATS\n+\n@@ -747,0 +720,12 @@\n+\n+#if TASKQUEUE_STATS\n+\n+void G1ParScanThreadStateSet::print_partial_array_task_stats() {\n+  auto get_stats = [&](uint i) {\n+    return state_for_worker(i)->partial_array_task_stats();\n+  };\n+  PartialArrayTaskStats::log_set(_num_workers, get_stats,\n+                                 \"Partial Array Task Stats\");\n+}\n+\n+#endif \/\/ TASKQUEUE_STATS\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":45,"deletions":60,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/partialArraySplitter.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n@@ -87,2 +87,1 @@\n-  PartialArrayStateAllocator _partial_array_state_allocator;\n-  PartialArrayTaskStepper _partial_array_stepper;\n+  PartialArraySplitter _partial_array_splitter;\n@@ -166,0 +165,4 @@\n+#if TASKQUEUE_STATS\n+  PartialArrayTaskStats* partial_array_task_stats();\n+#endif \/\/ TASKQUEUE_STATS\n+\n@@ -167,1 +170,1 @@\n-  void do_partial_array(PartialArrayState* state);\n+  void do_partial_array(PartialArrayState* state, bool stolen);\n@@ -190,1 +193,1 @@\n-  void dispatch_task(ScannerTask task);\n+  void dispatch_task(ScannerTask task, bool stolen);\n@@ -262,0 +265,3 @@\n+#if TASKQUEUE_STATS\n+  void print_partial_array_task_stats();\n+#endif \/\/ TASKQUEUE_STATS\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"memory\/virtualspace.hpp\"\n+#include \"memory\/reservedSpace.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+class ReservedSpace;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1016,0 +1016,6 @@\n+#if TASKQUEUE_STATS\n+  \/\/ Logging uses thread states, which are deleted by cleanup, so this must\n+  \/\/ be done before cleanup.\n+  per_thread_states->print_partial_array_task_stats();\n+#endif \/\/ TASKQUEUE_STATS\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"nmt\/memTracker.hpp\"\n+#include \"memory\/memoryReserver.hpp\"\n@@ -50,1 +50,1 @@\n-  ReservedSpace backing_store(bytes_to_reserve, mtGC);\n+  ReservedSpace backing_store = MemoryReserver::reserve(bytes_to_reserve, mtGC);\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/memoryReserver.hpp\"\n@@ -45,1 +46,7 @@\n-  _reserved_byte_size = align_up(raw_bytes, MAX2(page_sz, granularity));\n+  const size_t rs_align = MAX2(page_sz, granularity);\n+\n+  _reserved_byte_size = align_up(raw_bytes, rs_align);\n+\n+  ReservedSpace rs = MemoryReserver::reserve(_reserved_byte_size,\n+                                             rs_align,\n+                                             page_sz);\n@@ -47,3 +54,0 @@\n-  const size_t rs_align = page_sz == os::vm_page_size() ? 0 :\n-    MAX2(page_sz, granularity);\n-  ReservedSpace rs(_reserved_byte_size, rs_align, page_sz);\n@@ -71,1 +75,3 @@\n-    rs.release();\n+    if (rs.is_reserved()) {\n+      MemoryReserver::release(rs);\n+    }\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"memory\/reservedSpace.hpp\"\n@@ -49,1 +50,0 @@\n-#include \"nmt\/memTracker.hpp\"\n@@ -77,1 +77,1 @@\n-  PSCardTable* card_table = new PSCardTable(heap_rs.region());\n+  PSCardTable* card_table = new PSCardTable(_reserved);\n@@ -133,1 +133,1 @@\n-  FullGCForwarding::initialize(heap_rs.region());\n+  FullGCForwarding::initialize(_reserved);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+class ReservedSpace;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+class ReservedSpace;\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+#include \"memory\/memoryReserver.hpp\"\n@@ -243,1 +244,7 @@\n-  _reserved_byte_size = align_up(raw_bytes, MAX2(page_sz, granularity));\n+  const size_t rs_align = MAX2(page_sz, granularity);\n+\n+  _reserved_byte_size = align_up(raw_bytes, rs_align);\n+\n+  ReservedSpace rs = MemoryReserver::reserve(_reserved_byte_size,\n+                                             rs_align,\n+                                             page_sz);\n@@ -245,3 +252,0 @@\n-  const size_t rs_align = page_sz == os::vm_page_size() ? 0 :\n-    MAX2(page_sz, granularity);\n-  ReservedSpace rs(_reserved_byte_size, rs_align, page_sz);\n@@ -260,1 +264,4 @@\n-    rs.release();\n+    if (rs.is_reserved()) {\n+      MemoryReserver::release(rs);\n+      rs = {};\n+    }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/partialArraySplitter.inline.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n@@ -124,1 +124,1 @@\n-  TASKQUEUE_STATS_ONLY(print_taskqueue_stats());\n+  TASKQUEUE_STATS_ONLY(print_and_reset_taskqueue_stats());\n@@ -148,22 +148,0 @@\n-void\n-PSPromotionManager::print_local_stats(outputStream* const out, uint i) const {\n-  #define FMT \" \" SIZE_FORMAT_W(10)\n-  out->print_cr(\"%3u\" FMT FMT FMT FMT,\n-                i, _array_chunk_pushes, _array_chunk_steals,\n-                _arrays_chunked, _array_chunks_processed);\n-  #undef FMT\n-}\n-\n-static const char* const pm_stats_hdr[] = {\n-  \"    ----partial array----     arrays      array\",\n-  \"thr       push      steal    chunked     chunks\",\n-  \"--- ---------- ---------- ---------- ----------\"\n-};\n-\n-void PSPromotionManager::print_taskqueue_stats() {\n-  if (!log_is_enabled(Trace, gc, task, stats)) {\n-    return;\n-  }\n-  Log(gc, task, stats) log;\n-  ResourceMark rm;\n-  LogStream ls(log.trace());\n@@ -171,1 +149,2 @@\n-  stack_array_depth()->print_taskqueue_stats(&ls, \"Oop Queue\");\n+void PSPromotionManager::print_and_reset_taskqueue_stats() {\n+  stack_array_depth()->print_and_reset_taskqueue_stats(\"Oop Queue\");\n@@ -173,2 +152,5 @@\n-  const uint hlines = sizeof(pm_stats_hdr) \/ sizeof(pm_stats_hdr[0]);\n-  for (uint i = 0; i < hlines; ++i) ls.print_cr(\"%s\", pm_stats_hdr[i]);\n+  auto get_pa_stats = [&](uint i) {\n+    return manager_array(i)->partial_array_task_stats();\n+  };\n+  PartialArrayTaskStats::log_set(ParallelGCThreads, get_pa_stats,\n+                                 \"Partial Array Task Stats\");\n@@ -176,1 +158,1 @@\n-    manager_array(i)->print_local_stats(&ls, i);\n+    get_pa_stats(i)->reset();\n@@ -180,4 +162,2 @@\n-void PSPromotionManager::reset_stats() {\n-  claimed_stack_depth()->stats.reset();\n-  _array_chunk_pushes = _array_chunk_steals = 0;\n-  _arrays_chunked = _array_chunks_processed = 0;\n+PartialArrayTaskStats* PSPromotionManager::partial_array_task_stats() {\n+  return _partial_array_splitter.stats();\n@@ -185,0 +165,1 @@\n+\n@@ -189,2 +170,1 @@\n-  : _partial_array_state_allocator(_partial_array_state_manager),\n-    _partial_array_stepper(ParallelGCThreads, ParGCArrayScanChunk)\n+  : _partial_array_splitter(_partial_array_state_manager, ParallelGCThreads)\n@@ -224,2 +204,0 @@\n-\n-  TASKQUEUE_STATS_ONLY(reset_stats());\n@@ -249,1 +227,1 @@\n-        process_popped_location_depth(task);\n+        process_popped_location_depth(task, false);\n@@ -254,1 +232,1 @@\n-      process_popped_location_depth(task);\n+      process_popped_location_depth(task, false);\n@@ -282,3 +260,2 @@\n-template <class T> void PSPromotionManager::process_array_chunk_work(\n-                                                 oop obj,\n-                                                 int start, int end) {\n+template <class T>\n+void PSPromotionManager::process_array_chunk_work(oop obj, int start, int end) {\n@@ -295,16 +272,7 @@\n-void PSPromotionManager::process_array_chunk(PartialArrayState* state) {\n-  TASKQUEUE_STATS_ONLY(++_array_chunks_processed);\n-\n-  \/\/ Claim a chunk.  Push additional tasks before processing the claimed\n-  \/\/ chunk to allow other workers to steal while we're processing.\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n-  if (step._ncreate > 0) {\n-    state->add_references(step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_depth(ScannerTask(state));\n-    }\n-    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n-  }\n-  int start = checked_cast<int>(step._index);\n-  int end = checked_cast<int>(step._index + _partial_array_stepper.chunk_size());\n-  assert(start < end, \"invariant\");\n+void PSPromotionManager::process_array_chunk(PartialArrayState* state, bool stolen) {\n+  \/\/ Access before release by claim().\n+  oop new_obj = state->destination();\n+  PartialArraySplitter::Claim claim =\n+    _partial_array_splitter.claim(state, &_claimed_stack_depth, stolen);\n+  int start = checked_cast<int>(claim._start);\n+  int end = checked_cast<int>(claim._end);\n@@ -312,1 +280,1 @@\n-    process_array_chunk_work<narrowOop>(state->destination(), start, end);\n+    process_array_chunk_work<narrowOop>(new_obj, start, end);\n@@ -314,1 +282,1 @@\n-    process_array_chunk_work<oop>(state->destination(), start, end);\n+    process_array_chunk_work<oop>(new_obj, start, end);\n@@ -316,2 +284,0 @@\n-  \/\/ Release reference to state, now that we're done with it.\n-  _partial_array_state_allocator.release(state);\n@@ -325,15 +291,6 @@\n-  size_t array_length = objArrayOop(new_obj)->length();\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n-\n-  if (step._ncreate > 0) {\n-    TASKQUEUE_STATS_ONLY(++_arrays_chunked);\n-    PartialArrayState* state =\n-      _partial_array_state_allocator.allocate(old_obj, new_obj,\n-                                              step._index,\n-                                              array_length,\n-                                              step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_depth(ScannerTask(state));\n-    }\n-    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n-  }\n+  objArrayOop to_array = objArrayOop(new_obj);\n+  size_t array_length = to_array->length();\n+  size_t initial_chunk_size =\n+    \/\/ The source array is unused when processing states.\n+    _partial_array_splitter.start(&_claimed_stack_depth, nullptr, to_array, array_length);\n+  int end = checked_cast<int>(initial_chunk_size);\n@@ -341,1 +298,1 @@\n-    process_array_chunk_work<narrowOop>(new_obj, 0, checked_cast<int>(step._index));\n+    process_array_chunk_work<narrowOop>(to_array, 0, end);\n@@ -343,1 +300,1 @@\n-    process_array_chunk_work<oop>(new_obj, 0, checked_cast<int>(step._index));\n+    process_array_chunk_work<oop>(to_array, 0, end);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":35,"deletions":78,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/partialArraySplitter.hpp\"\n@@ -32,1 +33,1 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n@@ -70,9 +71,2 @@\n-  size_t                              _array_chunk_pushes;\n-  size_t                              _array_chunk_steals;\n-  size_t                              _arrays_chunked;\n-  size_t                              _array_chunks_processed;\n-\n-  void print_local_stats(outputStream* const out, uint i) const;\n-  static void print_taskqueue_stats();\n-\n-  void reset_stats();\n+  static void print_and_reset_taskqueue_stats();\n+  PartialArrayTaskStats* partial_array_task_stats();\n@@ -91,2 +85,1 @@\n-  PartialArrayStateAllocator          _partial_array_state_allocator;\n-  PartialArrayTaskStepper             _partial_array_stepper;\n+  PartialArraySplitter                _partial_array_splitter;\n@@ -108,1 +101,1 @@\n-  void process_array_chunk(PartialArrayState* state);\n+  void process_array_chunk(PartialArrayState* state, bool stolen);\n@@ -167,1 +160,1 @@\n-  inline void process_popped_location_depth(ScannerTask task);\n+  inline void process_popped_location_depth(ScannerTask task, bool stolen);\n@@ -177,2 +170,0 @@\n-  TASKQUEUE_STATS_ONLY(inline void record_steal(ScannerTask task);)\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -334,1 +334,2 @@\n-inline void PSPromotionManager::process_popped_location_depth(ScannerTask task) {\n+inline void PSPromotionManager::process_popped_location_depth(ScannerTask task,\n+                                                              bool stolen) {\n@@ -337,1 +338,1 @@\n-    process_array_chunk(task.to_partial_array_state());\n+    process_array_chunk(task.to_partial_array_state(), stolen);\n@@ -352,8 +353,0 @@\n-#if TASKQUEUE_STATS\n-void PSPromotionManager::record_steal(ScannerTask task) {\n-  if (task.is_partial_array_state()) {\n-    ++_array_chunk_steals;\n-  }\n-}\n-#endif \/\/ TASKQUEUE_STATS\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -131,2 +131,1 @@\n-      TASKQUEUE_STATS_ONLY(pm->record_steal(task));\n-      pm->process_popped_location_depth(task);\n+      pm->process_popped_location_depth(task, true);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"memory\/virtualspace.hpp\"\n+#include \"memory\/reservedSpace.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVirtualspace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"memory\/reservedSpace.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVirtualspace.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+class ReservedSpace;\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"memory\/reservedSpace.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+class ReservedSpace;\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"memory\/memoryReserver.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"nmt\/memTracker.hpp\"\n@@ -50,1 +50,1 @@\n-  ReservedSpace rs(size, mtGC);\n+  ReservedSpace rs = MemoryReserver::reserve(size, mtGC);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"memory\/reservedSpace.hpp\"\n@@ -192,1 +193,1 @@\n-  _rem_set = new CardTableRS(heap_rs.region());\n+  _rem_set = new CardTableRS(_reserved);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"memory\/virtualspace.hpp\"\n+#include \"memory\/memoryReserver.hpp\"\n@@ -83,3 +83,2 @@\n-  const size_t rs_align = _page_size == os::vm_page_size() ? 0 :\n-    MAX2(_page_size, os::vm_allocation_granularity());\n-  ReservedSpace heap_rs(_byte_map_size, rs_align, _page_size);\n+  const size_t rs_align = MAX2(_page_size, os::vm_allocation_granularity());\n+  ReservedSpace rs = MemoryReserver::reserve(_byte_map_size, rs_align, _page_size);\n@@ -87,1 +86,1 @@\n-  MemTracker::record_virtual_memory_tag((address)heap_rs.base(), mtGC);\n+  MemTracker::record_virtual_memory_tag((address)rs.base(), mtGC);\n@@ -90,2 +89,2 @@\n-                       heap_rs.base(), heap_rs.size(), _page_size);\n-  if (!heap_rs.is_reserved()) {\n+                       rs.base(), rs.size(), _page_size);\n+  if (!rs.is_reserved()) {\n@@ -100,1 +99,1 @@\n-  _byte_map = (CardValue*) heap_rs.base();\n+  _byte_map = (CardValue*) rs.base();\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"memory\/virtualspace.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"memory\/reservedSpace.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,5 @@\n-size_t OldSize = 0;\n+\/\/ If InitialHeapSize or MinHeapSize is not set on cmdline, this variable,\n+\/\/ together with NewSize, is used to derive them.\n+\/\/ Using the same value when it was a configurable flag to avoid breakage.\n+\/\/ See more in JDK-8346005\n+size_t OldSize = ScaleForWordSize(4*M);\n","filename":"src\/hotspot\/share\/gc\/shared\/genArguments.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"memory\/virtualspace.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/generationCounters.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"memory\/virtualspace.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -31,0 +31,2 @@\n+class VirtualSpace;\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/generationCounters.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shared\/partialArraySplitter.hpp\"\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+PartialArraySplitter::PartialArraySplitter(PartialArrayStateManager* manager,\n+                                           uint num_workers)\n+  : _allocator(manager),\n+    _stepper(num_workers, ParGCArrayScanChunk)\n+    TASKQUEUE_STATS_ONLY(COMMA _stats())\n+{}\n+\n+#if TASKQUEUE_STATS\n+PartialArrayTaskStats* PartialArraySplitter::stats() {\n+  return &_stats;\n+}\n+#endif \/\/ TASKQUEUE_STATS\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArraySplitter.cpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_PARTIALARRAYSPLITTER_HPP\n+#define SHARE_GC_SHARED_PARTIALARRAYSPLITTER_HPP\n+\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class outputStream;\n+\n+\/\/ Helper class for splitting the processing of a large objArray into multiple\n+\/\/ tasks, to permit multiple threads to work on different pieces of the array\n+\/\/ in parallel.\n+class PartialArraySplitter {\n+  PartialArrayStateAllocator _allocator;\n+  PartialArrayTaskStepper _stepper;\n+  TASKQUEUE_STATS_ONLY(PartialArrayTaskStats _stats;)\n+\n+public:\n+  PartialArraySplitter(PartialArrayStateManager* manager, uint num_workers);\n+  ~PartialArraySplitter() = default;\n+\n+  NONCOPYABLE(PartialArraySplitter);\n+\n+  \/\/ Setup to process an objArray in chunks.\n+  \/\/\n+  \/\/ from_array is the array found by the collector that needs processing.  It\n+  \/\/ may be null if to_array contains everything needed for processing.\n+  \/\/\n+  \/\/ to_array is an unprocessed (possibly partial) copy of from_array, or null\n+  \/\/ if a copy of from_array is not required.\n+  \/\/\n+  \/\/ length is their length in elements.\n+  \/\/\n+  \/\/ If t is a ScannerTask, queue->push(t) must be a valid expression.  The\n+  \/\/ result of that expression is ignored.\n+  \/\/\n+  \/\/ Returns the size of the initial chunk that is to be processed by the\n+  \/\/ caller.\n+  \/\/\n+  \/\/ Adds PartialArrayState ScannerTasks to the queue if needed to process the\n+  \/\/ array in chunks. This permits other workers to steal and process them\n+  \/\/ even while the caller is processing the initial chunk.  If length doesn't\n+  \/\/ exceed the chunk size then the result will be length, indicating the\n+  \/\/ caller is to process the entire array.  In this case, no tasks will have\n+  \/\/ been added to the queue.\n+  template<typename Queue>\n+  size_t start(Queue* queue,\n+               objArrayOop from_array,\n+               objArrayOop to_array,\n+               size_t length);\n+\n+  \/\/ Result type for claim(), carrying multiple values.  Provides the claimed\n+  \/\/ chunk's start and end array indices.\n+  struct Claim {\n+    size_t _start;\n+    size_t _end;\n+  };\n+\n+  \/\/ Claims a chunk from state, returning the index range for that chunk.  The\n+  \/\/ caller is expected to process that chunk.  Adds more state-based tasks to\n+  \/\/ the queue if needed, permitting other workers to steal and process them\n+  \/\/ even while the caller is processing this claim.\n+  \/\/\n+  \/\/ Releases the state. Callers must not use state after the call to this\n+  \/\/ function. The state may have been recycled and reused.\n+  \/\/\n+  \/\/ The queue has the same requirements as for start().\n+  \/\/\n+  \/\/ stolen indicates whether the state task was obtained from this queue or\n+  \/\/ stolen from some other queue.\n+  template<typename Queue>\n+  Claim claim(PartialArrayState* state, Queue* queue, bool stolen);\n+\n+  TASKQUEUE_STATS_ONLY(PartialArrayTaskStats* stats();)\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYSPLITTER_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArraySplitter.hpp","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_PARTIALARRAYSPLITTER_INLINE_HPP\n+#define SHARE_GC_SHARED_PARTIALARRAYSPLITTER_INLINE_HPP\n+\n+#include \"gc\/shared\/partialArraySplitter.hpp\"\n+\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n+#include \"gc\/shared\/taskqueue.inline.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+template<typename Queue>\n+size_t PartialArraySplitter::start(Queue* queue,\n+                                   objArrayOop source,\n+                                   objArrayOop destination,\n+                                   size_t length) {\n+  PartialArrayTaskStepper::Step step = _stepper.start(length);\n+  \/\/ Push initial partial scan tasks.\n+  if (step._ncreate > 0) {\n+    TASKQUEUE_STATS_ONLY(_stats.inc_split(););\n+    TASKQUEUE_STATS_ONLY(_stats.inc_pushed(step._ncreate);)\n+    PartialArrayState* state =\n+      _allocator.allocate(source, destination, step._index, length, step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      queue->push(ScannerTask(state));\n+    }\n+  } else {\n+    assert(step._index == length, \"invariant\");\n+  }\n+  return step._index;\n+}\n+\n+template<typename Queue>\n+PartialArraySplitter::Claim\n+PartialArraySplitter::claim(PartialArrayState* state, Queue* queue, bool stolen) {\n+#if TASKQUEUE_STATS\n+  if (stolen) _stats.inc_stolen();\n+  _stats.inc_processed();\n+#endif \/\/ TASKQUEUE_STATS\n+\n+  \/\/ Claim a chunk and get number of additional tasks to enqueue.\n+  PartialArrayTaskStepper::Step step = _stepper.next(state);\n+  \/\/ Push additional tasks.\n+  if (step._ncreate > 0) {\n+    TASKQUEUE_STATS_ONLY(_stats.inc_pushed(step._ncreate);)\n+    \/\/ Adjust reference count for tasks being added to the queue.\n+    state->add_references(step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      queue->push(ScannerTask(state));\n+    }\n+  }\n+  \/\/ Release state, decrementing refcount, now that we're done with it.\n+  _allocator.release(state);\n+  return Claim{step._index, step._index + _stepper.chunk_size()};\n+}\n+\n+#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYSPLITTER_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArraySplitter.inline.hpp","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logHandle.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+#if TASKQUEUE_STATS\n+\n+PartialArrayTaskStats::PartialArrayTaskStats()\n+  : _split(0), _pushed(0), _stolen(0), _processed(0)\n+{}\n+\n+void PartialArrayTaskStats::accumulate(const PartialArrayTaskStats& stats) {\n+  _split += stats._split;\n+  _pushed += stats._pushed;\n+  _stolen += stats._stolen;\n+  _processed += stats._processed;\n+}\n+\n+void PartialArrayTaskStats::reset() {\n+  *this = PartialArrayTaskStats();\n+}\n+\n+LogTargetHandle PartialArrayTaskStats::log_target() {\n+  LogTarget(Trace, gc, task, stats) lt;\n+  return LogTargetHandle(lt);\n+}\n+\n+bool PartialArrayTaskStats::is_log_enabled() {\n+  return log_target().is_enabled();\n+}\n+\n+static const char* const stats_hdr[] = {\n+  \"     ----partial array----      arrays      array\",\n+  \"thread       push      steal    chunked     chunks\",\n+  \"------ ---------- ---------- ---------- ----------\"\n+};\n+\n+void PartialArrayTaskStats::print_header(outputStream* s, const char* title) {\n+  s->print_cr(\"%s:\", title);\n+  for (uint i = 0; i < ARRAY_SIZE(stats_hdr); ++i) {\n+    s->print_cr(\"%s\", stats_hdr[i]);\n+  }\n+}\n+\n+void PartialArrayTaskStats::print_values_impl(outputStream* s) const {\n+  \/\/ 10 digits for each counter, matching the segments in stats_hdr.\n+  s->print_cr(\" %10zu %10zu %10zu %10zu\",\n+              _pushed, _stolen, _split, _processed);\n+}\n+\n+void PartialArrayTaskStats::print_values(outputStream* s, uint id) const {\n+  \/\/ 6 digits for thread number, matching the segement in stats_hdr.\n+  s->print(\"%6u\", id);\n+  print_values_impl(s);\n+}\n+\n+void PartialArrayTaskStats::print_total(outputStream* s) const {\n+  \/\/ 6 characters for \"total\" id, matching the segment in stats_hdr.\n+  s->print(\"%6s\", \"total\");\n+  print_values_impl(s);\n+}\n+\n+#endif \/\/ TASKQUEUE_STATS\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStats.cpp","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_PARTIALARRAYTASKSTATS_HPP\n+#define SHARE_GC_SHARED_PARTIALARRAYTASKSTATS_HPP\n+\n+#include \"logging\/logHandle.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#if TASKQUEUE_STATS\n+\n+class outputStream;\n+\n+\/\/ Repository for collecting and reporting statistics about partial array task\n+\/\/ processing.  Not thread-safe; each processing thread should have its own\n+\/\/ stats object.\n+class PartialArrayTaskStats {\n+  size_t _split;\n+  size_t _pushed;\n+  size_t _stolen;\n+  size_t _processed;\n+\n+  static LogTargetHandle log_target();\n+  static bool is_log_enabled();\n+  static void print_header(outputStream* s, const char* title);\n+  void print_values(outputStream* s, uint id) const;\n+  void print_total(outputStream* s) const;\n+  void print_values_impl(outputStream* s) const;\n+\n+  void accumulate(const PartialArrayTaskStats& stats);\n+\n+public:\n+  \/\/ All counters are initially zero.\n+  PartialArrayTaskStats();\n+\n+  \/\/ Trivially copied and destroyed.\n+\n+  \/\/ Number of arrays split into partial array tasks.\n+  size_t split() const { return _split; }\n+\n+  \/\/ Number of partial array tasks pushed onto a queue.\n+  size_t pushed() const { return _pushed; }\n+\n+  \/\/ Number of partial array tasks stolen from some other queue.\n+  size_t stolen() const { return _stolen; }\n+\n+  \/\/ Number of partial array tasks processed.\n+  size_t processed() const { return _processed; }\n+\n+  void inc_split() { _split += 1; }\n+  void inc_pushed(size_t n) { _pushed += n; }\n+  void inc_stolen() { _stolen += 1; }\n+  void inc_processed() { _processed += 1; }\n+\n+  \/\/ Set all counters to zero.\n+  void reset();\n+\n+  \/\/ Log a table of statistics, if logging is enabled (gc+task+stats=trace).\n+  \/\/\n+  \/\/ num_stats: The number of stats objects to include in the table, one row\n+  \/\/ for each.\n+  \/\/\n+  \/\/ access: A function taking a uint value < num_stats, and returning a\n+  \/\/ pointer to the corresponding stats object.\n+  \/\/\n+  \/\/ title: A string title for the table.\n+  template<typename StatsAccess>\n+  static void log_set(uint num_stats, StatsAccess access, const char* title) {\n+    if (is_log_enabled()) {\n+      LogStream ls(log_target());\n+      PartialArrayTaskStats total;\n+      print_header(&ls, title);\n+      for (uint i = 0; i < num_stats; ++i) {\n+        const PartialArrayTaskStats* stats = access(i);\n+        stats->print_values(&ls, i);\n+        total.accumulate(*stats);\n+      }\n+      total.print_total(&ls);\n+    }\n+  }\n+};\n+\n+#endif \/\/ TASKQUEUE_STATS\n+\n+#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYTASKSTATS_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStats.hpp","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -37,14 +37,0 @@\n-\/\/ Simple TaskQueue stats that are collected by default in debug builds.\n-\n-#if !defined(TASKQUEUE_STATS) && defined(ASSERT)\n-#define TASKQUEUE_STATS 1\n-#elif !defined(TASKQUEUE_STATS)\n-#define TASKQUEUE_STATS 0\n-#endif\n-\n-#if TASKQUEUE_STATS\n-#define TASKQUEUE_STATS_ONLY(code) code\n-#else\n-#define TASKQUEUE_STATS_ONLY(code)\n-#endif \/\/ TASKQUEUE_STATS\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n-#include \"runtime\/init.hpp\"\n+#include \"memory\/memoryReserver.hpp\"\n+#include \"memory\/reservedSpace.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"runtime\/init.hpp\"\n@@ -44,1 +46,1 @@\n-  const size_t rs_align = _page_size == os::vm_page_size() ? 0 : MAX2(_page_size, granularity);\n+  const size_t rs_align = MAX2(_page_size, granularity);\n@@ -46,1 +48,1 @@\n-  ReservedSpace write_space(_byte_map_size, rs_align, _page_size);\n+  ReservedSpace write_space = MemoryReserver::reserve(_byte_map_size, rs_align, _page_size);\n@@ -61,1 +63,1 @@\n-  ReservedSpace read_space(_byte_map_size, rs_align, _page_size);\n+  ReservedSpace read_space = MemoryReserver::reserve(_byte_map_size, rs_align, _page_size);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"runtime\/atomic.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"runtime\/atomic.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/virtualspace.hpp\"\n@@ -34,0 +32,3 @@\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/reservedSpace.hpp\"\n+#include \"memory\/virtualspace.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -183,1 +183,0 @@\n-  regulator_thread()->stop();\n@@ -185,0 +184,1 @@\n+  regulator_thread()->stop();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"code\/codeCache.hpp\"\n@@ -89,1 +88,1 @@\n-\n+#include \"memory\/allocation.hpp\"\n@@ -92,0 +91,1 @@\n+#include \"memory\/memoryReserver.hpp\"\n@@ -159,0 +159,13 @@\n+static ReservedSpace reserve(size_t size, size_t preferred_page_size) {\n+  \/\/ When a page size is given we don't want to mix large\n+  \/\/ and normal pages. If the size is not a multiple of the\n+  \/\/ page size it will be aligned up to achieve this.\n+  size_t alignment = os::vm_allocation_granularity();\n+  if (preferred_page_size != os::vm_page_size()) {\n+    alignment = MAX2(preferred_page_size, alignment);\n+    size = align_up(size, alignment);\n+  }\n+\n+  return MemoryReserver::reserve(size, alignment, preferred_page_size);\n+}\n+\n@@ -284,1 +297,1 @@\n-  ReservedSpace bitmap(_bitmap_size, bitmap_page_size);\n+  ReservedSpace bitmap = reserve(_bitmap_size, bitmap_page_size);\n@@ -304,1 +317,1 @@\n-    ReservedSpace verify_bitmap(_bitmap_size, bitmap_page_size);\n+    ReservedSpace verify_bitmap = reserve(_bitmap_size, bitmap_page_size);\n@@ -322,1 +335,1 @@\n-  ReservedSpace aux_bitmap(_bitmap_size, aux_bitmap_page_size);\n+  ReservedSpace aux_bitmap = reserve(_bitmap_size, aux_bitmap_page_size);\n@@ -340,1 +353,1 @@\n-  ReservedSpace region_storage(region_storage_size, region_page_size);\n+  ReservedSpace region_storage = reserve(region_storage_size, region_page_size);\n@@ -366,1 +379,1 @@\n-      cset_rs = ReservedSpace(cset_size, cset_align, cset_page_size, req_addr);\n+      cset_rs = MemoryReserver::reserve(req_addr, cset_size, cset_align, cset_page_size);\n@@ -375,1 +388,1 @@\n-      cset_rs = ReservedSpace(cset_size, cset_align, os::vm_page_size());\n+      cset_rs = MemoryReserver::reserve(cset_size, cset_align, os::vm_page_size());\n@@ -548,1 +561,0 @@\n-  _mmu_tracker(),\n@@ -642,0 +654,2 @@\n+\n+  \/\/ Schedule periodic task to report on gc thread CPU utilization\n@@ -2053,0 +2067,3 @@\n+  \/\/ Step 0a. Stop reporting on gc thread cpu utilization\n+  mmu_tracker()->stop();\n+\n@@ -2737,1 +2754,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+    assert(!thread->has_terminated(), \"Cannot get cpu time for terminated thread: \" UINTX_FORMAT, thread->osthread()->thread_id_for_printing());\n@@ -68,1 +69,0 @@\n-  _mmu_periodic_task->disenroll();\n@@ -178,0 +178,4 @@\n+void ShenandoahMmuTracker::stop() const {\n+  _mmu_periodic_task->disenroll();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -104,0 +104,4 @@\n+\n+  \/\/ Unenrolls the periodic task that collects CPU utilization for GC threads. This must happen _before_ the\n+  \/\/ gc threads are stopped and terminated.\n+  void stop() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,3 +80,0 @@\n-#ifdef COMPILER2\n-#include \"opto\/runtime.hpp\"\n-#endif\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -166,4 +166,4 @@\n-  vframeStreamCommon(RegisterMap(jt,\n-                                 RegisterMap::UpdateMap::skip,\n-                                 RegisterMap::ProcessFrames::skip,\n-                                 walk_continuation(jt))),\n+  vframeStreamCommon(jt,\n+                     RegisterMap::UpdateMap::skip,\n+                     RegisterMap::ProcessFrames::skip,\n+                     walk_continuation(jt)),\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"memory\/memoryReserver.hpp\"\n@@ -100,1 +101,3 @@\n-  _rs.release();\n+  if (_rs.is_reserved()) {\n+    MemoryReserver::release(_rs);\n+  }\n@@ -105,3 +108,3 @@\n-  _rs = ReservedSpace(reservation_size_request_bytes,\n-                      os::vm_allocation_granularity(),\n-                      os::vm_page_size());\n+  _rs = MemoryReserver::reserve(reservation_size_request_bytes,\n+                                os::vm_allocation_granularity(),\n+                                os::vm_page_size());\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrVirtualMemory.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"nmt\/memTracker.hpp\"\n+#include \"memory\/memoryReserver.hpp\"\n@@ -226,1 +226,1 @@\n-  ReservedSpace seg_rs(reserved_segments_size, mtCode);\n+  ReservedSpace seg_rs = MemoryReserver::reserve(reserved_segments_size, mtCode);\n","filename":"src\/hotspot\/share\/memory\/heap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+class ReservedSpace;\n+\n","filename":"src\/hotspot\/share\/memory\/heap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,693 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/memoryReserver.hpp\"\n+#include \"oops\/compressedOops.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+static void sanity_check_size_and_alignment(size_t size, size_t alignment) {\n+  assert(size > 0, \"Precondition\");\n+\n+  DEBUG_ONLY(const size_t granularity = os::vm_allocation_granularity());\n+  assert(is_aligned(size, granularity), \"size not aligned to os::vm_allocation_granularity()\");\n+\n+  assert(alignment >= granularity, \"Must be set\");\n+  assert(is_power_of_2(alignment), \"not a power of 2\");\n+  assert(is_aligned(alignment, granularity), \"alignment not aligned to os::vm_allocation_granularity()\");\n+}\n+\n+static void sanity_check_page_size(size_t page_size) {\n+  assert(page_size >= os::vm_page_size(), \"Invalid page size\");\n+  assert(is_power_of_2(page_size), \"Invalid page size\");\n+}\n+\n+static void sanity_check_arguments(size_t size, size_t alignment, size_t page_size) {\n+  sanity_check_size_and_alignment(size, alignment);\n+  sanity_check_page_size(page_size);\n+}\n+\n+static bool large_pages_requested() {\n+  return UseLargePages &&\n+         (!FLAG_IS_DEFAULT(UseLargePages) || !FLAG_IS_DEFAULT(LargePageSizeInBytes));\n+}\n+\n+static void log_on_large_pages_failure(char* req_addr, size_t bytes) {\n+  if (large_pages_requested()) {\n+    \/\/ Compressed oops logging.\n+    log_debug(gc, heap, coops)(\"Reserve regular memory without large pages\");\n+    \/\/ JVM style warning that we did not succeed in using large pages.\n+    char msg[128];\n+    jio_snprintf(msg, sizeof(msg), \"Failed to reserve and commit memory using large pages. \"\n+                                   \"req_addr: \" PTR_FORMAT \" bytes: \" SIZE_FORMAT,\n+                                   req_addr, bytes);\n+    warning(\"%s\", msg);\n+  }\n+}\n+\n+static bool use_explicit_large_pages(size_t page_size) {\n+  return !os::can_commit_large_page_memory() &&\n+         page_size != os::vm_page_size();\n+}\n+\n+static char* reserve_memory_inner(char* requested_address,\n+                                  size_t size,\n+                                  size_t alignment,\n+                                  bool exec,\n+                                  MemTag mem_tag) {\n+  \/\/ If the memory was requested at a particular address, use\n+  \/\/ os::attempt_reserve_memory_at() to avoid mapping over something\n+  \/\/ important.  If the reservation fails, return null.\n+  if (requested_address != nullptr) {\n+    assert(is_aligned(requested_address, alignment),\n+           \"Requested address \" PTR_FORMAT \" must be aligned to \" SIZE_FORMAT,\n+           p2i(requested_address), alignment);\n+    return os::attempt_reserve_memory_at(requested_address, size, exec, mem_tag);\n+  }\n+\n+  \/\/ Optimistically assume that the OS returns an aligned base pointer.\n+  \/\/ When reserving a large address range, most OSes seem to align to at\n+  \/\/ least 64K.\n+  char* base = os::reserve_memory(size, exec, mem_tag);\n+  if (is_aligned(base, alignment)) {\n+    return base;\n+  }\n+\n+  \/\/ Base not aligned, retry.\n+  if (!os::release_memory(base, size)) {\n+    fatal(\"os::release_memory failed\");\n+  }\n+\n+  \/\/ Map using the requested alignment.\n+  return os::reserve_memory_aligned(size, alignment, exec);\n+}\n+\n+ReservedSpace MemoryReserver::reserve_memory(char* requested_address,\n+                                             size_t size,\n+                                             size_t alignment,\n+                                             bool exec,\n+                                             MemTag mem_tag) {\n+  char* base = reserve_memory_inner(requested_address, size, alignment, exec, mem_tag);\n+\n+  if (base != nullptr) {\n+    return ReservedSpace(base, size, alignment, os::vm_page_size(), exec, false \/* special *\/);\n+  }\n+\n+  \/\/ Failed\n+  return {};\n+}\n+\n+ReservedSpace MemoryReserver::reserve_memory_special(char* requested_address,\n+                                                     size_t size,\n+                                                     size_t alignment,\n+                                                     size_t page_size,\n+                                                     bool exec) {\n+  log_trace(pagesize)(\"Attempt special mapping: size: \" SIZE_FORMAT \"%s, \"\n+                      \"alignment: \" SIZE_FORMAT \"%s\",\n+                      byte_size_in_exact_unit(size), exact_unit_for_byte_size(size),\n+                      byte_size_in_exact_unit(alignment), exact_unit_for_byte_size(alignment));\n+\n+  char* base = os::reserve_memory_special(size, alignment, page_size, requested_address, exec);\n+\n+  if (base != nullptr) {\n+    assert(is_aligned(base, alignment),\n+           \"reserve_memory_special() returned an unaligned address, \"\n+           \"base: \" PTR_FORMAT \" alignment: \" SIZE_FORMAT_X,\n+           p2i(base), alignment);\n+\n+    return ReservedSpace(base, size, alignment, page_size, exec, true \/* special *\/);\n+  }\n+\n+  \/\/ Failed\n+  return {};\n+}\n+\n+ReservedSpace MemoryReserver::reserve(char* requested_address,\n+                                      size_t size,\n+                                      size_t alignment,\n+                                      size_t page_size,\n+                                      bool executable,\n+                                      MemTag mem_tag) {\n+  sanity_check_arguments(size, alignment, page_size);\n+\n+  \/\/ Reserve the memory.\n+\n+  \/\/ There are basically three different cases that we need to handle:\n+  \/\/ 1. Mapping backed by a file\n+  \/\/ 2. Mapping backed by explicit large pages\n+  \/\/ 3. Mapping backed by normal pages or transparent huge pages\n+  \/\/ The first two have restrictions that requires the whole mapping to be\n+  \/\/ committed up front. To record this the ReservedSpace is marked 'special'.\n+\n+  \/\/ == Case 1 ==\n+  \/\/ This case is contained within the HeapReserver\n+\n+  \/\/ == Case 2 ==\n+  if (use_explicit_large_pages(page_size)) {\n+    \/\/ System can't commit large pages i.e. use transparent huge pages and\n+    \/\/ the caller requested large pages. To satisfy this request we use\n+    \/\/ explicit large pages and these have to be committed up front to ensure\n+    \/\/ no reservations are lost.\n+    do {\n+      ReservedSpace reserved = reserve_memory_special(requested_address, size, alignment, page_size, executable);\n+      if (reserved.is_reserved()) {\n+        \/\/ Successful reservation using large pages.\n+        return reserved;\n+      }\n+      page_size = os::page_sizes().next_smaller(page_size);\n+    } while (page_size > os::vm_page_size());\n+\n+    \/\/ Failed to reserve explicit large pages, do proper logging.\n+    log_on_large_pages_failure(requested_address, size);\n+    \/\/ Now fall back to normal reservation.\n+    assert(page_size == os::vm_page_size(), \"inv\");\n+  }\n+\n+  \/\/ == Case 3 ==\n+  return reserve_memory(requested_address, size, alignment, executable, mem_tag);\n+}\n+\n+ReservedSpace MemoryReserver::reserve(char* requested_address,\n+                                      size_t size,\n+                                      size_t alignment,\n+                                      size_t page_size,\n+                                      MemTag mem_tag) {\n+  return reserve(requested_address,\n+                 size,\n+                 alignment,\n+                 page_size,\n+                 !ExecMem,\n+                 mem_tag);\n+}\n+\n+\n+ReservedSpace MemoryReserver::reserve(size_t size,\n+                                      size_t alignment,\n+                                      size_t page_size,\n+                                      MemTag mem_tag) {\n+  return reserve(nullptr \/* requested_address *\/,\n+                 size,\n+                 alignment,\n+                 page_size,\n+                 mem_tag);\n+}\n+\n+ReservedSpace MemoryReserver::reserve(size_t size,\n+                                      MemTag mem_tag) {\n+  \/\/ Want to use large pages where possible. If the size is\n+  \/\/ not large page aligned the mapping will be a mix of\n+  \/\/ large and normal pages.\n+  size_t page_size = os::page_size_for_region_unaligned(size, 1);\n+  size_t alignment = os::vm_allocation_granularity();\n+\n+  return reserve(size,\n+                 alignment,\n+                 page_size,\n+                 mem_tag);\n+}\n+\n+bool MemoryReserver::release(const ReservedSpace& reserved) {\n+  assert(reserved.is_reserved(), \"Precondition\");\n+\n+  if (reserved.special()) {\n+    return os::release_memory_special(reserved.base(), reserved.size());\n+  } else {\n+    return os::release_memory(reserved.base(), reserved.size());\n+  }\n+}\n+\n+static char* map_memory_to_file(char* requested_address,\n+                                size_t size,\n+                                size_t alignment,\n+                                int fd,\n+                                MemTag mem_tag) {\n+  \/\/ If the memory was requested at a particular address, use\n+  \/\/ os::attempt_reserve_memory_at() to avoid mapping over something\n+  \/\/ important.  If the reservation fails, return null.\n+  if (requested_address != nullptr) {\n+    assert(is_aligned(requested_address, alignment),\n+           \"Requested address \" PTR_FORMAT \" must be aligned to \" SIZE_FORMAT,\n+           p2i(requested_address), alignment);\n+    return os::attempt_map_memory_to_file_at(requested_address, size, fd, mem_tag);\n+  }\n+\n+  \/\/ Optimistically assume that the OS returns an aligned base pointer.\n+  \/\/ When reserving a large address range, most OSes seem to align to at\n+  \/\/ least 64K.\n+  char* base = os::map_memory_to_file(size, fd);\n+  if (is_aligned(base, alignment)) {\n+    return base;\n+  }\n+\n+\n+  \/\/ Base not aligned, retry.\n+  if (!os::unmap_memory(base, size)) {\n+    fatal(\"os::unmap_memory failed\");\n+  }\n+\n+  \/\/ Map using the requested alignment.\n+  return os::map_memory_to_file_aligned(size, alignment, fd, mem_tag);\n+}\n+\n+ReservedSpace FileMappedMemoryReserver::reserve(char* requested_address,\n+                                                size_t size,\n+                                                size_t alignment,\n+                                                int fd,\n+                                                MemTag mem_tag) {\n+  sanity_check_size_and_alignment(size, alignment);\n+\n+  char* base = map_memory_to_file(requested_address, size, alignment, fd, mem_tag);\n+\n+  if (base != nullptr) {\n+    return ReservedSpace(base, size, alignment, os::vm_page_size(), !ExecMem, true \/* special *\/);\n+  }\n+\n+  \/\/ Failed\n+  return {};\n+}\n+\n+ReservedSpace CodeMemoryReserver::reserve(size_t size,\n+                                          size_t alignment,\n+                                          size_t page_size) {\n+  return MemoryReserver::reserve(nullptr \/* requested_address *\/,\n+                                 size,\n+                                 alignment,\n+                                 page_size,\n+                                 ExecMem,\n+                                 mtCode);\n+}\n+\n+ReservedHeapSpace HeapReserver::Instance::reserve_uncompressed_oops_heap(size_t size,\n+                                                                         size_t alignment,\n+                                                                         size_t page_size) {\n+  ReservedSpace reserved = reserve_memory(size, alignment, page_size);\n+\n+  if (reserved.is_reserved()) {\n+    return ReservedHeapSpace(reserved, 0 \/* noaccess_prefix *\/);\n+  }\n+\n+  \/\/ Failed\n+  return {};\n+}\n+\n+\n+static int maybe_create_file(const char* heap_allocation_directory) {\n+  if (heap_allocation_directory == nullptr) {\n+    return -1;\n+  }\n+\n+  int fd = os::create_file_for_heap(heap_allocation_directory);\n+  if (fd == -1) {\n+    vm_exit_during_initialization(\n+        err_msg(\"Could not create file for Heap at location %s\", heap_allocation_directory));\n+  }\n+\n+  return fd;\n+}\n+\n+HeapReserver::Instance::Instance(const char* heap_allocation_directory)\n+  : _fd(maybe_create_file(heap_allocation_directory)) {}\n+\n+HeapReserver::Instance::~Instance() {\n+  if (_fd != -1) {\n+    ::close(_fd);\n+  }\n+}\n+\n+ReservedSpace HeapReserver::Instance::reserve_memory(size_t size,\n+                                                     size_t alignment,\n+                                                     size_t page_size,\n+                                                     char* requested_address) {\n+\n+  \/\/ There are basically three different cases that we need to handle below:\n+  \/\/ 1. Mapping backed by a file\n+  \/\/ 2. Mapping backed by explicit large pages\n+  \/\/ 3. Mapping backed by normal pages or transparent huge pages\n+  \/\/ The first two have restrictions that requires the whole mapping to be\n+  \/\/ committed up front. To record this the ReservedSpace is marked 'special'.\n+\n+  \/\/ == Case 1 ==\n+  if (_fd != -1) {\n+    \/\/ When there is a backing file directory for this space then whether\n+    \/\/ large pages are allocated is up to the filesystem of the backing file.\n+    \/\/ So UseLargePages is not taken into account for this reservation.\n+    \/\/\n+    \/\/ If requested, let the user know that explicit large pages can't be used.\n+    if (use_explicit_large_pages(page_size) && large_pages_requested()) {\n+      log_debug(gc, heap)(\"Cannot allocate explicit large pages for Java Heap when AllocateHeapAt option is set.\");\n+    }\n+\n+    \/\/ Always return, not possible to fall back to reservation not using a file.\n+    return FileMappedMemoryReserver::reserve(requested_address, size, alignment, _fd, mtJavaHeap);\n+  }\n+\n+  \/\/ == Case 2 & 3 ==\n+  return MemoryReserver::reserve(requested_address, size, alignment, page_size, mtJavaHeap);\n+}\n+\n+\/\/ Compressed oop support is not relevant in 32bit builds.\n+#ifdef _LP64\n+\n+void HeapReserver::Instance::release(const ReservedSpace& reserved) {\n+  if (reserved.is_reserved()) {\n+    if (_fd == -1) {\n+      if (reserved.special()) {\n+        os::release_memory_special(reserved.base(), reserved.size());\n+      } else{\n+        os::release_memory(reserved.base(), reserved.size());\n+      }\n+    } else {\n+      os::unmap_memory(reserved.base(), reserved.size());\n+    }\n+  }\n+}\n+\n+\/\/ Tries to allocate memory of size 'size' at address requested_address with alignment 'alignment'.\n+\/\/ Does not check whether the reserved memory actually is at requested_address, as the memory returned\n+\/\/ might still fulfill the wishes of the caller.\n+\/\/ Assures the memory is aligned to 'alignment'.\n+ReservedSpace HeapReserver::Instance::try_reserve_memory(size_t size,\n+                                                         size_t alignment,\n+                                                         size_t page_size,\n+                                                         char* requested_address) {\n+  \/\/ Try to reserve the memory for the heap.\n+  log_trace(gc, heap, coops)(\"Trying to allocate at address \" PTR_FORMAT\n+                             \" heap of size \" SIZE_FORMAT_X,\n+                             p2i(requested_address),\n+                             size);\n+\n+  ReservedSpace reserved = reserve_memory(size, alignment, page_size, requested_address);\n+\n+  if (reserved.is_reserved()) {\n+    \/\/ Check alignment constraints.\n+    assert(reserved.alignment() == alignment, \"Unexpected\");\n+    assert(is_aligned(reserved.base(), alignment), \"Unexpected\");\n+    return reserved;\n+  }\n+\n+  \/\/ Failed\n+  return {};\n+}\n+\n+ReservedSpace HeapReserver::Instance::try_reserve_range(char *highest_start,\n+                                                        char *lowest_start,\n+                                                        size_t attach_point_alignment,\n+                                                        char *aligned_heap_base_min_address,\n+                                                        char *upper_bound,\n+                                                        size_t size,\n+                                                        size_t alignment,\n+                                                        size_t page_size) {\n+  const size_t attach_range = highest_start - lowest_start;\n+  \/\/ Cap num_attempts at possible number.\n+  \/\/ At least one is possible even for 0 sized attach range.\n+  const uint64_t num_attempts_possible = (attach_range \/ attach_point_alignment) + 1;\n+  const uint64_t num_attempts_to_try   = MIN2((uint64_t)HeapSearchSteps, num_attempts_possible);\n+\n+  const size_t stepsize = (attach_range == 0) ? \/\/ Only one try.\n+    (size_t) highest_start : align_up(attach_range \/ num_attempts_to_try, attach_point_alignment);\n+\n+  \/\/ Try attach points from top to bottom.\n+  for (char* attach_point = highest_start;\n+       attach_point >= lowest_start && attach_point <= highest_start;  \/\/ Avoid wrap around.\n+       attach_point -= stepsize) {\n+    ReservedSpace reserved = try_reserve_memory(size, alignment, page_size, attach_point);\n+\n+    if (reserved.is_reserved()) {\n+      if (reserved.base() >= aligned_heap_base_min_address &&\n+          size <= (uintptr_t)(upper_bound - reserved.base())) {\n+        \/\/ Got a successful reservation.\n+        return reserved;\n+      }\n+\n+      release(reserved);\n+    }\n+  }\n+\n+  \/\/ Failed\n+  return {};\n+}\n+\n+#define SIZE_64K  ((uint64_t) UCONST64(      0x10000))\n+#define SIZE_256M ((uint64_t) UCONST64(   0x10000000))\n+#define SIZE_32G  ((uint64_t) UCONST64(  0x800000000))\n+\n+\/\/ Helper for heap allocation. Returns an array with addresses\n+\/\/ (OS-specific) which are suited for disjoint base mode. Array is\n+\/\/ null terminated.\n+static char** get_attach_addresses_for_disjoint_mode() {\n+  static uint64_t addresses[] = {\n+     2 * SIZE_32G,\n+     3 * SIZE_32G,\n+     4 * SIZE_32G,\n+     8 * SIZE_32G,\n+    10 * SIZE_32G,\n+     1 * SIZE_64K * SIZE_32G,\n+     2 * SIZE_64K * SIZE_32G,\n+     3 * SIZE_64K * SIZE_32G,\n+     4 * SIZE_64K * SIZE_32G,\n+    16 * SIZE_64K * SIZE_32G,\n+    32 * SIZE_64K * SIZE_32G,\n+    34 * SIZE_64K * SIZE_32G,\n+    0\n+  };\n+\n+  \/\/ Sort out addresses smaller than HeapBaseMinAddress. This assumes\n+  \/\/ the array is sorted.\n+  uint i = 0;\n+  while (addresses[i] != 0 &&\n+         (addresses[i] < OopEncodingHeapMax || addresses[i] < HeapBaseMinAddress)) {\n+    i++;\n+  }\n+  uint start = i;\n+\n+  \/\/ Avoid more steps than requested.\n+  i = 0;\n+  while (addresses[start+i] != 0) {\n+    if (i == HeapSearchSteps) {\n+      addresses[start+i] = 0;\n+      break;\n+    }\n+    i++;\n+  }\n+\n+  return (char**) &addresses[start];\n+}\n+\n+\/\/ Create protection page at the beginning of the space.\n+static ReservedSpace establish_noaccess_prefix(const ReservedSpace& reserved, size_t noaccess_prefix) {\n+  assert(reserved.alignment() >= os::vm_page_size(), \"must be at least page size big\");\n+  assert(reserved.is_reserved(), \"should only be called on a reserved memory area\");\n+\n+  if (reserved.end() > (char *)OopEncodingHeapMax) {\n+    if (true\n+        WIN64_ONLY(&& !UseLargePages)\n+        AIX_ONLY(&& (os::Aix::supports_64K_mmap_pages() || os::vm_page_size() == 4*K))) {\n+      \/\/ Protect memory at the base of the allocated region.\n+      if (!os::protect_memory(reserved.base(), noaccess_prefix, os::MEM_PROT_NONE, reserved.special())) {\n+        fatal(\"cannot protect protection page\");\n+      }\n+      log_debug(gc, heap, coops)(\"Protected page at the reserved heap base: \"\n+                                 PTR_FORMAT \" \/ \" INTX_FORMAT \" bytes\",\n+                                 p2i(reserved.base()),\n+                                 noaccess_prefix);\n+      assert(CompressedOops::use_implicit_null_checks() == true, \"not initialized?\");\n+    } else {\n+      CompressedOops::set_use_implicit_null_checks(false);\n+    }\n+  }\n+\n+  return reserved.last_part(noaccess_prefix);\n+}\n+\n+ReservedHeapSpace HeapReserver::Instance::reserve_compressed_oops_heap(const size_t size, size_t alignment, size_t page_size) {\n+  const size_t noaccess_prefix_size = lcm(os::vm_page_size(), alignment);\n+  const size_t granularity = os::vm_allocation_granularity();\n+\n+  assert(size + noaccess_prefix_size <= OopEncodingHeapMax,  \"can not allocate compressed oop heap for this size\");\n+  assert(is_aligned(size, granularity), \"size not aligned to os::vm_allocation_granularity()\");\n+\n+  assert(alignment >= os::vm_page_size(), \"alignment too small\");\n+  assert(is_aligned(alignment, granularity), \"alignment not aligned to os::vm_allocation_granularity()\");\n+  assert(is_power_of_2(alignment), \"not a power of 2\");\n+\n+  \/\/ The necessary attach point alignment for generated wish addresses.\n+  \/\/ This is needed to increase the chance of attaching for mmap and shmat.\n+  \/\/ AIX is the only platform that uses System V shm for reserving virtual memory.\n+  \/\/ In this case, the required alignment of the allocated size (64K) and the alignment\n+  \/\/ of possible start points of the memory region (256M) differ.\n+  \/\/ This is not reflected by os_allocation_granularity().\n+  \/\/ The logic here is dual to the one in pd_reserve_memory in os_aix.cpp\n+  const size_t os_attach_point_alignment =\n+    AIX_ONLY(os::vm_page_size() == 4*K ? 4*K : 256*M)\n+    NOT_AIX(os::vm_allocation_granularity());\n+\n+  const size_t attach_point_alignment = lcm(alignment, os_attach_point_alignment);\n+\n+  char* aligned_heap_base_min_address = align_up((char*)HeapBaseMinAddress, alignment);\n+  size_t noaccess_prefix = ((aligned_heap_base_min_address + size) > (char*)OopEncodingHeapMax) ?\n+    noaccess_prefix_size : 0;\n+\n+  ReservedSpace reserved{};\n+\n+  \/\/ Attempt to alloc at user-given address.\n+  if (!FLAG_IS_DEFAULT(HeapBaseMinAddress)) {\n+    reserved = try_reserve_memory(size + noaccess_prefix, alignment, page_size, aligned_heap_base_min_address);\n+    if (reserved.base() != aligned_heap_base_min_address) { \/\/ Enforce this exact address.\n+      release(reserved);\n+      reserved = {};\n+    }\n+  }\n+\n+  \/\/ Keep heap at HeapBaseMinAddress.\n+  if (!reserved.is_reserved()) {\n+\n+    \/\/ Try to allocate the heap at addresses that allow efficient oop compression.\n+    \/\/ Different schemes are tried, in order of decreasing optimization potential.\n+    \/\/\n+    \/\/ For this, try_reserve_heap() is called with the desired heap base addresses.\n+    \/\/ A call into the os layer to allocate at a given address can return memory\n+    \/\/ at a different address than requested.  Still, this might be memory at a useful\n+    \/\/ address. try_reserve_heap() always returns this allocated memory, as only here\n+    \/\/ the criteria for a good heap are checked.\n+\n+    \/\/ Attempt to allocate so that we can run without base and scale (32-Bit unscaled compressed oops).\n+    \/\/ Give it several tries from top of range to bottom.\n+    if (aligned_heap_base_min_address + size <= (char *)UnscaledOopHeapMax) {\n+\n+      \/\/ Calc address range within we try to attach (range of possible start addresses).\n+      char* const highest_start = align_down((char *)UnscaledOopHeapMax - size, attach_point_alignment);\n+      char* const lowest_start  = align_up(aligned_heap_base_min_address, attach_point_alignment);\n+      reserved = try_reserve_range(highest_start, lowest_start, attach_point_alignment,\n+                                   aligned_heap_base_min_address, (char *)UnscaledOopHeapMax, size, alignment, page_size);\n+    }\n+\n+    \/\/ zerobased: Attempt to allocate in the lower 32G.\n+    char *zerobased_max = (char *)OopEncodingHeapMax;\n+\n+    \/\/ Give it several tries from top of range to bottom.\n+    if (aligned_heap_base_min_address + size <= zerobased_max && \/\/ Zerobased theoretical possible.\n+        ((!reserved.is_reserved()) ||                            \/\/ No previous try succeeded.\n+         (reserved.end() > zerobased_max))) {                    \/\/ Unscaled delivered an arbitrary address.\n+\n+      \/\/ Release previous reservation\n+      release(reserved);\n+\n+      \/\/ Calc address range within we try to attach (range of possible start addresses).\n+      char *const highest_start = align_down(zerobased_max - size, attach_point_alignment);\n+      \/\/ Need to be careful about size being guaranteed to be less\n+      \/\/ than UnscaledOopHeapMax due to type constraints.\n+      char *lowest_start = aligned_heap_base_min_address;\n+      uint64_t unscaled_end = UnscaledOopHeapMax - size;\n+      if (unscaled_end < UnscaledOopHeapMax) { \/\/ unscaled_end wrapped if size is large\n+        lowest_start = MAX2(lowest_start, (char*)unscaled_end);\n+      }\n+      lowest_start = align_up(lowest_start, attach_point_alignment);\n+      reserved = try_reserve_range(highest_start, lowest_start, attach_point_alignment,\n+                                   aligned_heap_base_min_address, zerobased_max, size, alignment, page_size);\n+    }\n+\n+    \/\/ Now we go for heaps with base != 0.  We need a noaccess prefix to efficiently\n+    \/\/ implement null checks.\n+    noaccess_prefix = noaccess_prefix_size;\n+\n+    \/\/ Try to attach at addresses that are aligned to OopEncodingHeapMax. Disjointbase mode.\n+    char** addresses = get_attach_addresses_for_disjoint_mode();\n+    int i = 0;\n+    while ((addresses[i] != nullptr) &&       \/\/ End of array not yet reached.\n+           ((!reserved.is_reserved()) ||      \/\/ No previous try succeeded.\n+           (reserved.end() > zerobased_max && \/\/ Not zerobased or unscaled address.\n+                                              \/\/ Not disjoint address.\n+            !CompressedOops::is_disjoint_heap_base_address((address)reserved.base())))) {\n+\n+      \/\/ Release previous reservation\n+      release(reserved);\n+\n+      char* const attach_point = addresses[i];\n+      assert(attach_point >= aligned_heap_base_min_address, \"Flag support broken\");\n+      reserved = try_reserve_memory(size + noaccess_prefix, alignment, page_size, attach_point);\n+      i++;\n+    }\n+\n+    \/\/ Last, desperate try without any placement.\n+    if (!reserved.is_reserved()) {\n+      log_trace(gc, heap, coops)(\"Trying to allocate at address null heap of size \" SIZE_FORMAT_X, size + noaccess_prefix);\n+      assert(alignment >= os::vm_page_size(), \"Unexpected\");\n+      reserved = reserve_memory(size + noaccess_prefix, alignment, page_size);\n+    }\n+  }\n+\n+  \/\/ No more reserve attempts\n+\n+  if (reserved.is_reserved()) {\n+    \/\/ Successfully found and reserved memory for the heap.\n+\n+    if (reserved.size() > size) {\n+      \/\/ We reserved heap memory with a noaccess prefix.\n+\n+      assert(reserved.size() == size + noaccess_prefix, \"Prefix should be included\");\n+      \/\/ It can happen we get a zerobased\/unscaled heap with noaccess prefix,\n+      \/\/ if we had to try at arbitrary address.\n+      reserved = establish_noaccess_prefix(reserved, noaccess_prefix);\n+      assert(reserved.size() == size, \"Prefix should be gone\");\n+      return ReservedHeapSpace(reserved, noaccess_prefix);\n+    }\n+\n+    \/\/ We reserved heap memory without a noaccess prefix.\n+    return ReservedHeapSpace(reserved, 0 \/* noaccess_prefix *\/);\n+  }\n+\n+  \/\/ Failed\n+  return {};\n+}\n+\n+#endif \/\/ _LP64\n+\n+ReservedHeapSpace HeapReserver::Instance::reserve_heap(size_t size, size_t alignment, size_t page_size) {\n+  if (UseCompressedOops) {\n+#ifdef _LP64\n+    return reserve_compressed_oops_heap(size, alignment, page_size);\n+#endif\n+  } else {\n+    return reserve_uncompressed_oops_heap(size, alignment, page_size);\n+  }\n+}\n+\n+ReservedHeapSpace HeapReserver::reserve(size_t size, size_t alignment, size_t page_size, const char* heap_allocation_directory) {\n+  sanity_check_arguments(size, alignment, page_size);\n+\n+  assert(alignment != 0, \"Precondition\");\n+  assert(is_aligned(size, alignment), \"Precondition\");\n+\n+  Instance instance(heap_allocation_directory);\n+\n+  return instance.reserve_heap(size, alignment, page_size);\n+}\n","filename":"src\/hotspot\/share\/memory\/memoryReserver.cpp","additions":693,"deletions":0,"binary":false,"changes":693,"status":"added"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_MEMORY_MEMORYRESERVER_HPP\n+#define SHARE_MEMORY_MEMORYRESERVER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/reservedSpace.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class MemoryReserver : AllStatic {\n+  static ReservedSpace reserve_memory(char* requested_address,\n+                                      size_t size,\n+                                      size_t alignment,\n+                                      bool exec,\n+                                      MemTag mem_tag);\n+\n+  static ReservedSpace reserve_memory_special(char* requested_address,\n+                                              size_t size,\n+                                              size_t alignment,\n+                                              size_t page_size,\n+                                              bool exec);\n+\n+public:\n+  \/\/ Final destination\n+  static ReservedSpace reserve(char* requested_address,\n+                               size_t size,\n+                               size_t alignment,\n+                               size_t page_size,\n+                               bool executable,\n+                               MemTag mem_tag);\n+\n+  \/\/ Convenience overloads\n+\n+  static ReservedSpace reserve(char* requested_address,\n+                               size_t size,\n+                               size_t alignment,\n+                               size_t page_size,\n+                               MemTag mem_tag = mtNone);\n+\n+  static ReservedSpace reserve(size_t size,\n+                               size_t alignment,\n+                               size_t page_size,\n+                               MemTag mem_tag = mtNone);\n+\n+  static ReservedSpace reserve(size_t size,\n+                               MemTag mem_tag);\n+\n+  \/\/ Release reserved memory\n+  static bool release(const ReservedSpace& reserved);\n+};\n+\n+class CodeMemoryReserver : AllStatic {\n+public:\n+  static ReservedSpace reserve(size_t size,\n+                              size_t alignment,\n+                              size_t page_size);\n+};\n+\n+class FileMappedMemoryReserver : AllStatic {\n+public:\n+  static ReservedSpace reserve(char* requested_address,\n+                               size_t size,\n+                               size_t alignment,\n+                               int fd,\n+                               MemTag mem_tag);\n+};\n+\n+class HeapReserver : AllStatic {\n+  class Instance {\n+    const int _fd;\n+\n+    NONCOPYABLE(Instance);\n+\n+    ReservedSpace reserve_memory(size_t size,\n+                                 size_t alignment,\n+                                 size_t page_size,\n+                                 char* requested_address = nullptr);\n+\n+    void release(const ReservedSpace& reserved);\n+\n+    \/\/ CompressedOops support\n+#ifdef _LP64\n+\n+    ReservedSpace try_reserve_memory(size_t size,\n+                                     size_t alignment,\n+                                     size_t page_size,\n+                                     char* requested_address);\n+\n+    ReservedSpace try_reserve_range(char *highest_start,\n+                                    char *lowest_start,\n+                                    size_t attach_point_alignment,\n+                                    char *aligned_heap_base_min_address,\n+                                    char *upper_bound,\n+                                    size_t size,\n+                                    size_t alignment,\n+                                    size_t page_size);\n+\n+    ReservedHeapSpace reserve_compressed_oops_heap(size_t size,\n+                                                   size_t alignment,\n+                                                   size_t page_size);\n+\n+#endif \/\/ _LP64\n+\n+    ReservedHeapSpace reserve_uncompressed_oops_heap(size_t size,\n+                                                     size_t alignment,\n+                                                     size_t page_size);\n+\n+  public:\n+    Instance(const char* heap_allocation_directory);\n+    ~Instance();\n+\n+    ReservedHeapSpace reserve_heap(size_t size,\n+                                   size_t alignment,\n+                                   size_t page_size);\n+  }; \/\/ Instance\n+\n+public:\n+  static ReservedHeapSpace reserve(size_t size,\n+                                   size_t alignment,\n+                                   size_t page_size,\n+                                   const char* heap_allocation_directory);\n+};\n+\n+#endif \/\/ SHARE_MEMORY_MEMORYRESERVER_HPP\n","filename":"src\/hotspot\/share\/memory\/memoryReserver.hpp","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"memory\/memoryReserver.hpp\"\n@@ -60,0 +61,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -64,1 +66,0 @@\n-#include \"virtualspace.hpp\"\n@@ -600,1 +601,0 @@\n-  ReservedSpace rs;\n@@ -604,2 +604,7 @@\n-    rs = ReservedSpace::space_for_range(result, size, Metaspace::reserve_alignment(),\n-                                                      os::vm_page_size(), false, false);\n+\n+    return ReservedSpace(result,\n+                         size,\n+                         Metaspace::reserve_alignment(),\n+                         os::vm_page_size(),\n+                         !ExecMem,\n+                         false \/* special *\/);\n@@ -608,1 +613,1 @@\n-    rs = ReservedSpace();\n+    return {};\n@@ -610,1 +615,0 @@\n-  return rs;\n@@ -763,2 +767,6 @@\n-      rs = ReservedSpace(size, Metaspace::reserve_alignment(),\n-                         os::vm_page_size() \/* large *\/, (char*)base);\n+\n+      rs = MemoryReserver::reserve((char*)base,\n+                                   size,\n+                                   Metaspace::reserve_alignment(),\n+                                   os::vm_page_size());\n+\n@@ -1024,1 +1032,0 @@\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"memory\/virtualspace.hpp\"\n@@ -39,0 +38,1 @@\n+class ReservedSpace;\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"memory\/virtualspace.hpp\"\n@@ -35,0 +34,1 @@\n+class ReservedSpace;\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceContext.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"memory\/memoryReserver.hpp\"\n@@ -85,1 +86,1 @@\n-    _rs = ReservedSpace(reserve_limit * BytesPerWord, Metaspace::reserve_alignment(), os::vm_page_size());\n+    _rs = MemoryReserver::reserve(reserve_limit * BytesPerWord, Metaspace::reserve_alignment(), os::vm_page_size());\n@@ -99,1 +100,1 @@\n-    _rs.release();\n+    MemoryReserver::release(_rs);\n","filename":"src\/hotspot\/share\/memory\/metaspace\/testHelpers.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"memory\/virtualspace.hpp\"\n+#include \"memory\/reservedSpace.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/testHelpers.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/memoryReserver.hpp\"\n@@ -256,3 +257,4 @@\n-  ReservedSpace rs(word_size * BytesPerWord,\n-                   Settings::virtual_space_node_reserve_alignment_words() * BytesPerWord,\n-                   os::vm_page_size());\n+\n+  ReservedSpace rs = MemoryReserver::reserve(word_size * BytesPerWord,\n+                                             Settings::virtual_space_node_reserve_alignment_words() * BytesPerWord,\n+                                             os::vm_page_size());\n@@ -289,1 +291,3 @@\n-    _rs.release();\n+    if (_rs.is_reserved()) {\n+      MemoryReserver::release(_rs);\n+    }\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceNode.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-#include \"memory\/virtualspace.hpp\"\n+#include \"memory\/reservedSpace.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceNode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/reservedSpace.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/align.hpp\"\n+\n+#ifdef ASSERT\n+void ReservedSpace::sanity_checks() {\n+  assert(is_aligned(_base, os::vm_allocation_granularity()), \"Unaligned base\");\n+  assert(is_aligned(_base, _alignment), \"Unaligned base\");\n+  assert(is_aligned(_size, os::vm_page_size()), \"Unaligned size\");\n+  assert(os::page_sizes().contains(_page_size), \"Invalid pagesize\");\n+}\n+#endif\n","filename":"src\/hotspot\/share\/memory\/reservedSpace.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_MEMORY_RESERVEDSPACE_HPP\n+#define SHARE_MEMORY_RESERVEDSPACE_HPP\n+\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ ReservedSpace is a data structure for describing a reserved contiguous address range.\n+\n+class ReservedSpace {\n+  char*  _base;\n+  size_t _size;\n+  size_t _alignment;\n+  size_t _page_size;\n+  bool   _executable;\n+  bool   _special;\n+\n+  void sanity_checks() NOT_DEBUG_RETURN;\n+\n+public:\n+  \/\/ Constructor for non-reserved memory.\n+  ReservedSpace()\n+    : _base(nullptr),\n+      _size(0),\n+      _alignment(0),\n+      _page_size(0),\n+      _executable(false),\n+      _special(false) {}\n+\n+  \/\/ Main constructor\n+  ReservedSpace(char*  base,\n+                size_t size,\n+                size_t alignment,\n+                size_t page_size,\n+                bool   executable,\n+                bool   special)\n+    : _base(base),\n+      _size(size),\n+      _alignment(alignment),\n+      _page_size(page_size),\n+      _executable(executable),\n+      _special(special) {\n+    sanity_checks();\n+  }\n+\n+  bool is_reserved() const {\n+    return _base != nullptr;\n+  }\n+\n+  char* base() const {\n+    return _base;\n+  }\n+\n+  size_t size() const {\n+    return _size;\n+  }\n+\n+  char* end() const {\n+    return _base + _size;\n+  }\n+\n+  size_t alignment() const {\n+    return _alignment;\n+  }\n+\n+  size_t page_size() const {\n+    return _page_size;\n+  }\n+\n+  bool executable() const {\n+    return _executable;\n+  }\n+\n+  bool special() const {\n+    return _special;\n+  }\n+\n+  ReservedSpace partition(size_t offset, size_t partition_size, size_t alignment) const {\n+    assert(offset + partition_size <= size(), \"partition failed\");\n+\n+    char* const partition_base = base() + offset;\n+    assert(is_aligned(partition_base, alignment), \"partition base must be aligned\");\n+\n+    return ReservedSpace(partition_base,\n+                         partition_size,\n+                         alignment,\n+                         _page_size,\n+                         _executable,\n+                         _special);\n+  }\n+\n+  ReservedSpace partition(size_t offset, size_t partition_size) const {\n+    return partition(offset, partition_size, _alignment);\n+  }\n+\n+  ReservedSpace first_part(size_t split_offset, size_t alignment) const {\n+    return partition(0, split_offset, alignment);\n+  }\n+\n+  ReservedSpace first_part(size_t split_offset) const {\n+    return first_part(split_offset, _alignment);\n+  }\n+\n+  ReservedSpace last_part (size_t split_offset, size_t alignment) const {\n+    return partition(split_offset, _size - split_offset, alignment);\n+  }\n+\n+  ReservedSpace last_part (size_t split_offset) const {\n+    return last_part(split_offset, _alignment);\n+  }\n+};\n+\n+\/\/ Class encapsulating behavior specific to memory reserved for the Java heap.\n+class ReservedHeapSpace : public ReservedSpace {\n+private:\n+  const size_t _noaccess_prefix;\n+\n+public:\n+  \/\/ Constructor for non-reserved memory.\n+  ReservedHeapSpace()\n+    : ReservedSpace(),\n+      _noaccess_prefix() {}\n+\n+  ReservedHeapSpace(const ReservedSpace& reserved, size_t noaccess_prefix)\n+    : ReservedSpace(reserved),\n+      _noaccess_prefix(noaccess_prefix) {}\n+\n+  size_t noaccess_prefix() const { return _noaccess_prefix; }\n+\n+  \/\/ Returns the base to be used for compression, i.e. so that null can be\n+  \/\/ encoded safely and implicit null checks can work.\n+  char* compressed_oop_base() const { return base() - _noaccess_prefix; }\n+};\n+\n+#endif \/\/ SHARE_MEMORY_RESERVEDSPACE_HPP\n","filename":"src\/hotspot\/share\/memory\/reservedSpace.hpp","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"memory\/memoryReserver.hpp\"\n@@ -959,1 +960,11 @@\n-  ReservedHeapSpace total_rs(total_reserved, alignment, page_size, AllocateHeapAt);\n+  ReservedHeapSpace rhs = HeapReserver::reserve(total_reserved, alignment, page_size, AllocateHeapAt);\n+\n+  if (rhs.is_reserved()) {\n+    assert(total_reserved == rhs.size(),    \"must be exactly of required size\");\n+    assert(is_aligned(rhs.base(),alignment),\"must be exactly of required alignment\");\n+\n+    assert(markWord::encode_pointer_as_mark(rhs.base()).decode_pointer() == rhs.base(),\n+           \"area must be distinguishable from marks for mark-sweep\");\n+    assert(markWord::encode_pointer_as_mark(&rhs.base()[rhs.size()]).decode_pointer() ==\n+           &rhs.base()[rhs.size()],\n+           \"area must be distinguishable from marks for mark-sweep\");\n@@ -961,3 +972,0 @@\n-  if (total_rs.is_reserved()) {\n-    assert((total_reserved == total_rs.size()) && ((uintptr_t)total_rs.base() % alignment == 0),\n-           \"must be exactly of required size and alignment\");\n@@ -971,1 +979,1 @@\n-      CompressedOops::initialize(total_rs);\n+      CompressedOops::initialize(rhs);\n@@ -974,1 +982,1 @@\n-    Universe::calculate_verify_data((HeapWord*)total_rs.base(), (HeapWord*)total_rs.end());\n+    Universe::calculate_verify_data((HeapWord*)rhs.base(), (HeapWord*)rhs.end());\n@@ -976,1 +984,1 @@\n-    return total_rs;\n+    return rhs;\n@@ -985,1 +993,0 @@\n-  return ReservedHeapSpace(0, 0, os::vm_page_size());\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/reservedSpace.hpp\"\n@@ -45,1 +46,0 @@\n-class ReservedHeapSpace;\n@@ -54,1 +54,0 @@\n-  friend class ReservedHeapSpace;\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n-#include \"logging\/log.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"memory\/reservedSpace.hpp\"\n@@ -29,7 +29,0 @@\n-#include \"nmt\/memTracker.hpp\"\n-#include \"oops\/compressedKlass.hpp\"\n-#include \"oops\/compressedOops.hpp\"\n-#include \"oops\/markWord.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/globals_extension.hpp\"\n-#include \"runtime\/java.hpp\"\n@@ -38,630 +31,2 @@\n-#include \"utilities\/formatBuffer.hpp\"\n-#include \"utilities\/powerOfTwo.hpp\"\n-\n-\/\/ ReservedSpace\n-\n-\/\/ Dummy constructor\n-ReservedSpace::ReservedSpace() : _base(nullptr), _size(0), _noaccess_prefix(0),\n-    _alignment(0), _special(false), _fd_for_heap(-1), _executable(false) {\n-}\n-\n-ReservedSpace::ReservedSpace(size_t size, MemTag mem_tag) : _fd_for_heap(-1) {\n-  \/\/ Want to use large pages where possible. If the size is\n-  \/\/ not large page aligned the mapping will be a mix of\n-  \/\/ large and normal pages.\n-  size_t page_size = os::page_size_for_region_unaligned(size, 1);\n-  size_t alignment = os::vm_allocation_granularity();\n-  initialize(size, alignment, page_size, nullptr, false, mem_tag);\n-}\n-\n-ReservedSpace::ReservedSpace(size_t size, size_t preferred_page_size) : _fd_for_heap(-1) {\n-  \/\/ When a page size is given we don't want to mix large\n-  \/\/ and normal pages. If the size is not a multiple of the\n-  \/\/ page size it will be aligned up to achieve this.\n-  size_t alignment = os::vm_allocation_granularity();\n-  if (preferred_page_size != os::vm_page_size()) {\n-    alignment = MAX2(preferred_page_size, alignment);\n-    size = align_up(size, alignment);\n-  }\n-  initialize(size, alignment, preferred_page_size, nullptr, false);\n-}\n-\n-ReservedSpace::ReservedSpace(size_t size,\n-                             size_t alignment,\n-                             size_t page_size,\n-                             char* requested_address) : _fd_for_heap(-1) {\n-  initialize(size, alignment, page_size, requested_address, false);\n-}\n-\n-ReservedSpace::ReservedSpace(char* base, size_t size, size_t alignment, size_t page_size,\n-                             bool special, bool executable) : _fd_for_heap(-1) {\n-  assert((size % os::vm_allocation_granularity()) == 0,\n-         \"size not allocation aligned\");\n-  initialize_members(base, size, alignment, page_size, special, executable);\n-}\n-\n-\/\/ Helper method\n-static char* attempt_map_or_reserve_memory_at(char* base, size_t size, int fd, bool executable, MemTag mem_tag) {\n-  if (fd != -1) {\n-    return os::attempt_map_memory_to_file_at(base, size, fd);\n-  }\n-  return os::attempt_reserve_memory_at(base, size, executable, mem_tag);\n-}\n-\n-\/\/ Helper method\n-static char* map_or_reserve_memory(size_t size, int fd, bool executable, MemTag mem_tag) {\n-  if (fd != -1) {\n-    return os::map_memory_to_file(size, fd);\n-  }\n-  return os::reserve_memory(size, executable, mem_tag);\n-}\n-\n-\/\/ Helper method\n-static char* map_or_reserve_memory_aligned(size_t size, size_t alignment, int fd, bool executable) {\n-  if (fd != -1) {\n-    return os::map_memory_to_file_aligned(size, alignment, fd);\n-  }\n-  return os::reserve_memory_aligned(size, alignment, executable);\n-}\n-\n-\/\/ Helper method\n-static void unmap_or_release_memory(char* base, size_t size, bool is_file_mapped) {\n-  if (is_file_mapped) {\n-    if (!os::unmap_memory(base, size)) {\n-      fatal(\"os::unmap_memory failed\");\n-    }\n-  } else if (!os::release_memory(base, size)) {\n-    fatal(\"os::release_memory failed\");\n-  }\n-}\n-\n-\/\/ Helper method\n-static bool failed_to_reserve_as_requested(char* base, char* requested_address) {\n-  if (base == requested_address || requested_address == nullptr) {\n-    return false; \/\/ did not fail\n-  }\n-\n-  if (base != nullptr) {\n-    \/\/ Different reserve address may be acceptable in other cases\n-    \/\/ but for compressed oops heap should be at requested address.\n-    assert(UseCompressedOops, \"currently requested address used only for compressed oops\");\n-    log_debug(gc, heap, coops)(\"Reserved memory not at requested address: \" PTR_FORMAT \" vs \" PTR_FORMAT, p2i(base), p2i(requested_address));\n-  }\n-  return true;\n-}\n-\n-static bool use_explicit_large_pages(size_t page_size) {\n-  return !os::can_commit_large_page_memory() &&\n-         page_size != os::vm_page_size();\n-}\n-\n-static bool large_pages_requested() {\n-  return UseLargePages &&\n-         (!FLAG_IS_DEFAULT(UseLargePages) || !FLAG_IS_DEFAULT(LargePageSizeInBytes));\n-}\n-\n-static void log_on_large_pages_failure(char* req_addr, size_t bytes) {\n-  if (large_pages_requested()) {\n-    \/\/ Compressed oops logging.\n-    log_debug(gc, heap, coops)(\"Reserve regular memory without large pages\");\n-    \/\/ JVM style warning that we did not succeed in using large pages.\n-    char msg[128];\n-    jio_snprintf(msg, sizeof(msg), \"Failed to reserve and commit memory using large pages. \"\n-                                   \"req_addr: \" PTR_FORMAT \" bytes: \" SIZE_FORMAT,\n-                                   req_addr, bytes);\n-    warning(\"%s\", msg);\n-  }\n-}\n-\n-static char* reserve_memory(char* requested_address, const size_t size,\n-                            const size_t alignment, int fd, bool exec, MemTag mem_tag) {\n-  char* base;\n-  \/\/ If the memory was requested at a particular address, use\n-  \/\/ os::attempt_reserve_memory_at() to avoid mapping over something\n-  \/\/ important.  If the reservation fails, return null.\n-  if (requested_address != nullptr) {\n-    assert(is_aligned(requested_address, alignment),\n-           \"Requested address \" PTR_FORMAT \" must be aligned to \" SIZE_FORMAT,\n-           p2i(requested_address), alignment);\n-    base = attempt_map_or_reserve_memory_at(requested_address, size, fd, exec, mem_tag);\n-  } else {\n-    \/\/ Optimistically assume that the OS returns an aligned base pointer.\n-    \/\/ When reserving a large address range, most OSes seem to align to at\n-    \/\/ least 64K.\n-    base = map_or_reserve_memory(size, fd, exec, mem_tag);\n-    \/\/ Check alignment constraints. This is only needed when there is\n-    \/\/ no requested address.\n-    if (!is_aligned(base, alignment)) {\n-      \/\/ Base not aligned, retry.\n-      unmap_or_release_memory(base, size, fd != -1 \/*is_file_mapped*\/);\n-      \/\/ Map using the requested alignment.\n-      base = map_or_reserve_memory_aligned(size, alignment, fd, exec);\n-    }\n-  }\n-\n-  return base;\n-}\n-\n-static char* reserve_memory_special(char* requested_address, const size_t size,\n-                                    const size_t alignment, const size_t page_size, bool exec) {\n-\n-  log_trace(pagesize)(\"Attempt special mapping: size: \" SIZE_FORMAT \"%s, \"\n-                      \"alignment: \" SIZE_FORMAT \"%s\",\n-                      byte_size_in_exact_unit(size), exact_unit_for_byte_size(size),\n-                      byte_size_in_exact_unit(alignment), exact_unit_for_byte_size(alignment));\n-\n-  char* base = os::reserve_memory_special(size, alignment, page_size, requested_address, exec);\n-  if (base != nullptr) {\n-    \/\/ Check alignment constraints.\n-    assert(is_aligned(base, alignment),\n-           \"reserve_memory_special() returned an unaligned address, base: \" PTR_FORMAT\n-           \" alignment: \" SIZE_FORMAT_X,\n-           p2i(base), alignment);\n-  }\n-  return base;\n-}\n-\n-void ReservedSpace::clear_members() {\n-  initialize_members(nullptr, 0, 0, 0, false, false);\n-}\n-\n-void ReservedSpace::initialize_members(char* base, size_t size, size_t alignment,\n-                                       size_t page_size, bool special, bool executable) {\n-  _base = base;\n-  _size = size;\n-  _alignment = alignment;\n-  _page_size = page_size;\n-  _special = special;\n-  _executable = executable;\n-  _noaccess_prefix = 0;\n-}\n-\n-void ReservedSpace::reserve(size_t size,\n-                            size_t alignment,\n-                            size_t page_size,\n-                            char* requested_address,\n-                            bool executable,\n-                            MemTag mem_tag) {\n-  assert(is_aligned(size, alignment), \"Size must be aligned to the requested alignment\");\n-\n-  \/\/ There are basically three different cases that we need to handle below:\n-  \/\/ 1. Mapping backed by a file\n-  \/\/ 2. Mapping backed by explicit large pages\n-  \/\/ 3. Mapping backed by normal pages or transparent huge pages\n-  \/\/ The first two have restrictions that requires the whole mapping to be\n-  \/\/ committed up front. To record this the ReservedSpace is marked 'special'.\n-\n-  \/\/ == Case 1 ==\n-  if (_fd_for_heap != -1) {\n-    \/\/ When there is a backing file directory for this space then whether\n-    \/\/ large pages are allocated is up to the filesystem of the backing file.\n-    \/\/ So UseLargePages is not taken into account for this reservation.\n-    char* base = reserve_memory(requested_address, size, alignment, _fd_for_heap, executable, mem_tag);\n-    if (base != nullptr) {\n-      initialize_members(base, size, alignment, os::vm_page_size(), true, executable);\n-    }\n-    \/\/ Always return, not possible to fall back to reservation not using a file.\n-    return;\n-  }\n-\n-  \/\/ == Case 2 ==\n-  if (use_explicit_large_pages(page_size)) {\n-    \/\/ System can't commit large pages i.e. use transparent huge pages and\n-    \/\/ the caller requested large pages. To satisfy this request we use\n-    \/\/ explicit large pages and these have to be committed up front to ensure\n-    \/\/ no reservations are lost.\n-    do {\n-      char* base = reserve_memory_special(requested_address, size, alignment, page_size, executable);\n-      if (base != nullptr) {\n-        \/\/ Successful reservation using large pages.\n-        initialize_members(base, size, alignment, page_size, true, executable);\n-        return;\n-      }\n-      page_size = os::page_sizes().next_smaller(page_size);\n-    } while (page_size > os::vm_page_size());\n-\n-    \/\/ Failed to reserve explicit large pages, do proper logging.\n-    log_on_large_pages_failure(requested_address, size);\n-    \/\/ Now fall back to normal reservation.\n-    assert(page_size == os::vm_page_size(), \"inv\");\n-  }\n-\n-  \/\/ == Case 3 ==\n-  char* base = reserve_memory(requested_address, size, alignment, -1, executable, mem_tag);\n-  if (base != nullptr) {\n-    \/\/ Successful mapping.\n-    initialize_members(base, size, alignment, page_size, false, executable);\n-  }\n-}\n-\n-void ReservedSpace::initialize(size_t size,\n-                               size_t alignment,\n-                               size_t page_size,\n-                               char* requested_address,\n-                               bool executable,\n-                               MemTag mem_tag) {\n-  const size_t granularity = os::vm_allocation_granularity();\n-  assert((size & (granularity - 1)) == 0,\n-         \"size not aligned to os::vm_allocation_granularity()\");\n-  assert((alignment & (granularity - 1)) == 0,\n-         \"alignment not aligned to os::vm_allocation_granularity()\");\n-  assert(alignment == 0 || is_power_of_2((intptr_t)alignment),\n-         \"not a power of 2\");\n-  assert(page_size >= os::vm_page_size(), \"Invalid page size\");\n-  assert(is_power_of_2(page_size), \"Invalid page size\");\n-\n-  clear_members();\n-\n-  if (size == 0) {\n-    return;\n-  }\n-\n-  \/\/ Adjust alignment to not be 0.\n-  alignment = MAX2(alignment, os::vm_page_size());\n-\n-  \/\/ Reserve the memory.\n-  reserve(size, alignment, page_size, requested_address, executable, mem_tag);\n-\n-  \/\/ Check that the requested address is used if given.\n-  if (failed_to_reserve_as_requested(_base, requested_address)) {\n-    \/\/ OS ignored the requested address, release the reservation.\n-    release();\n-    return;\n-  }\n-}\n-\n-ReservedSpace ReservedSpace::first_part(size_t partition_size, size_t alignment) {\n-  assert(partition_size <= size(), \"partition failed\");\n-  ReservedSpace result(base(), partition_size, alignment, page_size(), special(), executable());\n-  return result;\n-}\n-\n-ReservedSpace ReservedSpace::last_part(size_t partition_size, size_t alignment) {\n-  assert(partition_size <= size(), \"partition failed\");\n-  ReservedSpace result(base() + partition_size, size() - partition_size,\n-                       alignment, page_size(), special(), executable());\n-  return result;\n-}\n-\n-ReservedSpace ReservedSpace::partition(size_t offset, size_t partition_size, size_t alignment) {\n-  assert(offset + partition_size <= size(), \"partition failed\");\n-  ReservedSpace result(base() + offset, partition_size, alignment, page_size(), special(), executable());\n-  return result;\n-}\n-\n-void ReservedSpace::release() {\n-  if (is_reserved()) {\n-    char *real_base = _base - _noaccess_prefix;\n-    const size_t real_size = _size + _noaccess_prefix;\n-    if (special()) {\n-      if (_fd_for_heap != -1) {\n-        os::unmap_memory(real_base, real_size);\n-      } else {\n-        os::release_memory_special(real_base, real_size);\n-      }\n-    } else{\n-      os::release_memory(real_base, real_size);\n-    }\n-    clear_members();\n-  }\n-}\n-\n-\/\/ Put a ReservedSpace over an existing range\n-ReservedSpace ReservedSpace::space_for_range(char* base, size_t size, size_t alignment,\n-                                             size_t page_size, bool special, bool executable) {\n-  assert(is_aligned(base, os::vm_allocation_granularity()), \"Unaligned base\");\n-  assert(is_aligned(size, os::vm_page_size()), \"Unaligned size\");\n-  assert(os::page_sizes().contains(page_size), \"Invalid pagesize\");\n-  ReservedSpace space;\n-  space.initialize_members(base, size, alignment, page_size, special, executable);\n-  return space;\n-}\n-\n-\/\/ Compressed oop support is not relevant in 32bit builds.\n-#ifdef _LP64\n-\n-static size_t noaccess_prefix_size(size_t alignment) {\n-  return lcm(os::vm_page_size(), alignment);\n-}\n-\n-void ReservedHeapSpace::establish_noaccess_prefix() {\n-  assert(_alignment >= os::vm_page_size(), \"must be at least page size big\");\n-  _noaccess_prefix = noaccess_prefix_size(_alignment);\n-\n-  if (base() && base() + _size > (char *)OopEncodingHeapMax) {\n-    if (true\n-        WIN64_ONLY(&& !UseLargePages)\n-        AIX_ONLY(&& (os::Aix::supports_64K_mmap_pages() || os::vm_page_size() == 4*K))) {\n-      \/\/ Protect memory at the base of the allocated region.\n-      \/\/ If special, the page was committed (only matters on windows)\n-      if (!os::protect_memory(_base, _noaccess_prefix, os::MEM_PROT_NONE, _special)) {\n-        fatal(\"cannot protect protection page\");\n-      }\n-      log_debug(gc, heap, coops)(\"Protected page at the reserved heap base: \"\n-                                 PTR_FORMAT \" \/ \" INTX_FORMAT \" bytes\",\n-                                 p2i(_base),\n-                                 _noaccess_prefix);\n-      assert(CompressedOops::use_implicit_null_checks() == true, \"not initialized?\");\n-    } else {\n-      CompressedOops::set_use_implicit_null_checks(false);\n-    }\n-  }\n-\n-  _base += _noaccess_prefix;\n-  _size -= _noaccess_prefix;\n-  assert(((uintptr_t)_base % _alignment == 0), \"must be exactly of required alignment\");\n-}\n-\n-\/\/ Tries to allocate memory of size 'size' at address requested_address with alignment 'alignment'.\n-\/\/ Does not check whether the reserved memory actually is at requested_address, as the memory returned\n-\/\/ might still fulfill the wishes of the caller.\n-\/\/ Assures the memory is aligned to 'alignment'.\n-\/\/ NOTE: If ReservedHeapSpace already points to some reserved memory this is freed, first.\n-void ReservedHeapSpace::try_reserve_heap(size_t size,\n-                                         size_t alignment,\n-                                         size_t page_size,\n-                                         char* requested_address) {\n-  if (_base != nullptr) {\n-    \/\/ We tried before, but we didn't like the address delivered.\n-    release();\n-  }\n-\n-  \/\/ Try to reserve the memory for the heap.\n-  log_trace(gc, heap, coops)(\"Trying to allocate at address \" PTR_FORMAT\n-                             \" heap of size \" SIZE_FORMAT_X,\n-                             p2i(requested_address),\n-                             size);\n-\n-  reserve(size, alignment, page_size, requested_address, false, mtJavaHeap);\n-\n-  \/\/ Check alignment constraints.\n-  if (is_reserved() && !is_aligned(_base, _alignment)) {\n-    \/\/ Base not aligned, retry.\n-    release();\n-  }\n-}\n-\n-void ReservedHeapSpace::try_reserve_range(char *highest_start,\n-                                          char *lowest_start,\n-                                          size_t attach_point_alignment,\n-                                          char *aligned_heap_base_min_address,\n-                                          char *upper_bound,\n-                                          size_t size,\n-                                          size_t alignment,\n-                                          size_t page_size) {\n-  const size_t attach_range = highest_start - lowest_start;\n-  \/\/ Cap num_attempts at possible number.\n-  \/\/ At least one is possible even for 0 sized attach range.\n-  const uint64_t num_attempts_possible = (attach_range \/ attach_point_alignment) + 1;\n-  const uint64_t num_attempts_to_try   = MIN2((uint64_t)HeapSearchSteps, num_attempts_possible);\n-\n-  const size_t stepsize = (attach_range == 0) ? \/\/ Only one try.\n-    (size_t) highest_start : align_up(attach_range \/ num_attempts_to_try, attach_point_alignment);\n-\n-  \/\/ Try attach points from top to bottom.\n-  char* attach_point = highest_start;\n-  while (attach_point >= lowest_start  &&\n-         attach_point <= highest_start &&  \/\/ Avoid wrap around.\n-         ((_base == nullptr) ||\n-          (_base < aligned_heap_base_min_address || _base + size > upper_bound))) {\n-    try_reserve_heap(size, alignment, page_size, attach_point);\n-    attach_point -= stepsize;\n-  }\n-}\n-\n-#define SIZE_64K  ((uint64_t) UCONST64(      0x10000))\n-#define SIZE_256M ((uint64_t) UCONST64(   0x10000000))\n-#define SIZE_32G  ((uint64_t) UCONST64(  0x800000000))\n-\n-\/\/ Helper for heap allocation. Returns an array with addresses\n-\/\/ (OS-specific) which are suited for disjoint base mode. Array is\n-\/\/ null terminated.\n-static char** get_attach_addresses_for_disjoint_mode() {\n-  static uint64_t addresses[] = {\n-     2 * SIZE_32G,\n-     3 * SIZE_32G,\n-     4 * SIZE_32G,\n-     8 * SIZE_32G,\n-    10 * SIZE_32G,\n-     1 * SIZE_64K * SIZE_32G,\n-     2 * SIZE_64K * SIZE_32G,\n-     3 * SIZE_64K * SIZE_32G,\n-     4 * SIZE_64K * SIZE_32G,\n-    16 * SIZE_64K * SIZE_32G,\n-    32 * SIZE_64K * SIZE_32G,\n-    34 * SIZE_64K * SIZE_32G,\n-    0\n-  };\n-\n-  \/\/ Sort out addresses smaller than HeapBaseMinAddress. This assumes\n-  \/\/ the array is sorted.\n-  uint i = 0;\n-  while (addresses[i] != 0 &&\n-         (addresses[i] < OopEncodingHeapMax || addresses[i] < HeapBaseMinAddress)) {\n-    i++;\n-  }\n-  uint start = i;\n-\n-  \/\/ Avoid more steps than requested.\n-  i = 0;\n-  while (addresses[start+i] != 0) {\n-    if (i == HeapSearchSteps) {\n-      addresses[start+i] = 0;\n-      break;\n-    }\n-    i++;\n-  }\n-\n-  return (char**) &addresses[start];\n-}\n-\n-void ReservedHeapSpace::initialize_compressed_heap(const size_t size, size_t alignment, size_t page_size) {\n-  guarantee(size + noaccess_prefix_size(alignment) <= OopEncodingHeapMax,\n-            \"can not allocate compressed oop heap for this size\");\n-  guarantee(alignment == MAX2(alignment, os::vm_page_size()), \"alignment too small\");\n-\n-  const size_t granularity = os::vm_allocation_granularity();\n-  assert((size & (granularity - 1)) == 0,\n-         \"size not aligned to os::vm_allocation_granularity()\");\n-  assert((alignment & (granularity - 1)) == 0,\n-         \"alignment not aligned to os::vm_allocation_granularity()\");\n-  assert(alignment == 0 || is_power_of_2((intptr_t)alignment),\n-         \"not a power of 2\");\n-\n-  \/\/ The necessary attach point alignment for generated wish addresses.\n-  \/\/ This is needed to increase the chance of attaching for mmap and shmat.\n-  \/\/ AIX is the only platform that uses System V shm for reserving virtual memory.\n-  \/\/ In this case, the required alignment of the allocated size (64K) and the alignment\n-  \/\/ of possible start points of the memory region (256M) differ.\n-  \/\/ This is not reflected by os_allocation_granularity().\n-  \/\/ The logic here is dual to the one in pd_reserve_memory in os_aix.cpp\n-  const size_t os_attach_point_alignment =\n-    AIX_ONLY(os::vm_page_size() == 4*K ? 4*K : 256*M)\n-    NOT_AIX(os::vm_allocation_granularity());\n-\n-  const size_t attach_point_alignment = lcm(alignment, os_attach_point_alignment);\n-\n-  char *aligned_heap_base_min_address = (char *)align_up((void *)HeapBaseMinAddress, alignment);\n-  size_t noaccess_prefix = ((aligned_heap_base_min_address + size) > (char*)OopEncodingHeapMax) ?\n-    noaccess_prefix_size(alignment) : 0;\n-\n-  \/\/ Attempt to alloc at user-given address.\n-  if (!FLAG_IS_DEFAULT(HeapBaseMinAddress)) {\n-    try_reserve_heap(size + noaccess_prefix, alignment, page_size, aligned_heap_base_min_address);\n-    if (_base != aligned_heap_base_min_address) { \/\/ Enforce this exact address.\n-      release();\n-    }\n-  }\n-\n-  \/\/ Keep heap at HeapBaseMinAddress.\n-  if (_base == nullptr) {\n-\n-    \/\/ Try to allocate the heap at addresses that allow efficient oop compression.\n-    \/\/ Different schemes are tried, in order of decreasing optimization potential.\n-    \/\/\n-    \/\/ For this, try_reserve_heap() is called with the desired heap base addresses.\n-    \/\/ A call into the os layer to allocate at a given address can return memory\n-    \/\/ at a different address than requested.  Still, this might be memory at a useful\n-    \/\/ address. try_reserve_heap() always returns this allocated memory, as only here\n-    \/\/ the criteria for a good heap are checked.\n-\n-    \/\/ Attempt to allocate so that we can run without base and scale (32-Bit unscaled compressed oops).\n-    \/\/ Give it several tries from top of range to bottom.\n-    if (aligned_heap_base_min_address + size <= (char *)UnscaledOopHeapMax) {\n-\n-      \/\/ Calc address range within we try to attach (range of possible start addresses).\n-      char* const highest_start = align_down((char *)UnscaledOopHeapMax - size, attach_point_alignment);\n-      char* const lowest_start  = align_up(aligned_heap_base_min_address, attach_point_alignment);\n-      try_reserve_range(highest_start, lowest_start, attach_point_alignment,\n-                        aligned_heap_base_min_address, (char *)UnscaledOopHeapMax, size, alignment, page_size);\n-    }\n-\n-    \/\/ zerobased: Attempt to allocate in the lower 32G.\n-    char *zerobased_max = (char *)OopEncodingHeapMax;\n-\n-    \/\/ Give it several tries from top of range to bottom.\n-    if (aligned_heap_base_min_address + size <= zerobased_max &&    \/\/ Zerobased theoretical possible.\n-        ((_base == nullptr) ||                        \/\/ No previous try succeeded.\n-         (_base + size > zerobased_max))) {        \/\/ Unscaled delivered an arbitrary address.\n-\n-      \/\/ Calc address range within we try to attach (range of possible start addresses).\n-      char *const highest_start = align_down(zerobased_max - size, attach_point_alignment);\n-      \/\/ Need to be careful about size being guaranteed to be less\n-      \/\/ than UnscaledOopHeapMax due to type constraints.\n-      char *lowest_start = aligned_heap_base_min_address;\n-      uint64_t unscaled_end = UnscaledOopHeapMax - size;\n-      if (unscaled_end < UnscaledOopHeapMax) { \/\/ unscaled_end wrapped if size is large\n-        lowest_start = MAX2(lowest_start, (char*)unscaled_end);\n-      }\n-      lowest_start = align_up(lowest_start, attach_point_alignment);\n-      try_reserve_range(highest_start, lowest_start, attach_point_alignment,\n-                        aligned_heap_base_min_address, zerobased_max, size, alignment, page_size);\n-    }\n-\n-    \/\/ Now we go for heaps with base != 0.  We need a noaccess prefix to efficiently\n-    \/\/ implement null checks.\n-    noaccess_prefix = noaccess_prefix_size(alignment);\n-\n-    \/\/ Try to attach at addresses that are aligned to OopEncodingHeapMax. Disjointbase mode.\n-    char** addresses = get_attach_addresses_for_disjoint_mode();\n-    int i = 0;\n-    while ((addresses[i] != nullptr) &&                    \/\/ End of array not yet reached.\n-           ((_base == nullptr) ||                          \/\/ No previous try succeeded.\n-            (_base + size >  (char *)OopEncodingHeapMax && \/\/ Not zerobased or unscaled address.\n-             !CompressedOops::is_disjoint_heap_base_address((address)_base)))) {  \/\/ Not disjoint address.\n-      char* const attach_point = addresses[i];\n-      assert(attach_point >= aligned_heap_base_min_address, \"Flag support broken\");\n-      try_reserve_heap(size + noaccess_prefix, alignment, page_size, attach_point);\n-      i++;\n-    }\n-\n-    \/\/ Last, desperate try without any placement.\n-    if (_base == nullptr) {\n-      log_trace(gc, heap, coops)(\"Trying to allocate at address null heap of size \" SIZE_FORMAT_X, size + noaccess_prefix);\n-      initialize(size + noaccess_prefix, alignment, page_size, nullptr, false, mtJavaHeap);\n-    }\n-  }\n-}\n-\n-#endif \/\/ _LP64\n-\n-ReservedHeapSpace::ReservedHeapSpace(size_t size, size_t alignment, size_t page_size, const char* heap_allocation_directory) : ReservedSpace() {\n-\n-  if (size == 0) {\n-    return;\n-  }\n-\n-  if (heap_allocation_directory != nullptr) {\n-    _fd_for_heap = os::create_file_for_heap(heap_allocation_directory);\n-    if (_fd_for_heap == -1) {\n-      vm_exit_during_initialization(\n-        err_msg(\"Could not create file for Heap at location %s\", heap_allocation_directory));\n-    }\n-    \/\/ When there is a backing file directory for this space then whether\n-    \/\/ large pages are allocated is up to the filesystem of the backing file.\n-    \/\/ If requested, let the user know that explicit large pages can't be used.\n-    if (use_explicit_large_pages(page_size) && large_pages_requested()) {\n-      log_debug(gc, heap)(\"Cannot allocate explicit large pages for Java Heap when AllocateHeapAt option is set.\");\n-    }\n-  }\n-\n-  \/\/ Heap size should be aligned to alignment, too.\n-  guarantee(is_aligned(size, alignment), \"set by caller\");\n-\n-  if (UseCompressedOops) {\n-#ifdef _LP64\n-    initialize_compressed_heap(size, alignment, page_size);\n-    if (_size > size) {\n-      \/\/ We allocated heap with noaccess prefix.\n-      \/\/ It can happen we get a zerobased\/unscaled heap with noaccess prefix,\n-      \/\/ if we had to try at arbitrary address.\n-      establish_noaccess_prefix();\n-    }\n-#else\n-    ShouldNotReachHere();\n-#endif \/\/ _LP64\n-  } else {\n-    initialize(size, alignment, page_size, nullptr, false, mtJavaHeap);\n-  }\n-\n-  assert(markWord::encode_pointer_as_mark(_base).decode_pointer() == _base,\n-         \"area must be distinguishable from marks for mark-sweep\");\n-  assert(markWord::encode_pointer_as_mark(&_base[size]).decode_pointer() == &_base[size],\n-         \"area must be distinguishable from marks for mark-sweep\");\n-\n-  if (_fd_for_heap != -1) {\n-    ::close(_fd_for_heap);\n-  }\n-}\n-\n-MemRegion ReservedHeapSpace::region() const {\n-  return MemRegion((HeapWord*)base(), (HeapWord*)end());\n-}\n-\n-\/\/ Reserve space for code segment.  Same as Java heap only we mark this as\n-\/\/ executable.\n-ReservedCodeSpace::ReservedCodeSpace(size_t r_size,\n-                                     size_t rs_align,\n-                                     size_t rs_page_size) : ReservedSpace() {\n-  initialize(r_size, rs_align, rs_page_size, \/*requested address*\/ nullptr, \/*executable*\/ true, mtCode);\n-}\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":4,"deletions":639,"binary":false,"changes":643,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"memory\/memRegion.hpp\"\n-#include \"nmt\/memTag.hpp\"\n@@ -31,0 +29,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -33,132 +32,1 @@\n-\n-\/\/ ReservedSpace is a data structure for reserving a contiguous address range.\n-\n-class ReservedSpace {\n-  friend class VMStructs;\n- protected:\n-  char*  _base;\n-  size_t _size;\n-  size_t _noaccess_prefix;\n-  size_t _alignment;\n-  size_t _page_size;\n-  bool   _special;\n-  int    _fd_for_heap;\n- private:\n-  bool   _executable;\n-\n-  \/\/ ReservedSpace\n-  ReservedSpace(char* base, size_t size, size_t alignment,\n-                size_t page_size, bool special, bool executable);\n- protected:\n-  \/\/ Helpers to clear and set members during initialization. Two members\n-  \/\/ require special treatment:\n-  \/\/  * _fd_for_heap     - The fd is set once and should not be cleared\n-  \/\/                       even if the reservation has to be retried.\n-  \/\/  * _noaccess_prefix - Used for compressed heaps and updated after\n-  \/\/                       the reservation is initialized. Always set to\n-  \/\/                       0 during initialization.\n-  void clear_members();\n-  void initialize_members(char* base, size_t size, size_t alignment,\n-                          size_t page_size, bool special, bool executable);\n-\n-  void initialize(size_t size, size_t alignment, size_t page_size,\n-                  char* requested_address, bool executable, MemTag mem_tag = mtNone);\n-\n-  void reserve(size_t size, size_t alignment, size_t page_size,\n-               char* requested_address, bool executable, MemTag mem_tag);\n- public:\n-  \/\/ Constructor\n-  ReservedSpace();\n-  \/\/ Initialize the reserved space with the given size. Depending on the size\n-  \/\/ a suitable page size and alignment will be used.\n-  ReservedSpace(size_t size, MemTag mem_tag);\n-  \/\/ Initialize the reserved space with the given size. The preferred_page_size\n-  \/\/ is used as the minimum page size\/alignment. This may waste some space if\n-  \/\/ the given size is not aligned to that value, as the reservation will be\n-  \/\/ aligned up to the final alignment in this case.\n-  ReservedSpace(size_t size, size_t preferred_page_size);\n-  ReservedSpace(size_t size, size_t alignment, size_t page_size,\n-                char* requested_address = nullptr);\n-\n-  \/\/ Accessors\n-  char*  base()            const { return _base;      }\n-  size_t size()            const { return _size;      }\n-  char*  end()             const { return _base + _size; }\n-  size_t alignment()       const { return _alignment; }\n-  size_t page_size()       const { return _page_size; }\n-  bool   special()         const { return _special;   }\n-  bool   executable()      const { return _executable;   }\n-  size_t noaccess_prefix() const { return _noaccess_prefix;   }\n-  bool is_reserved()       const { return _base != nullptr; }\n-  void release();\n-\n-  \/\/ Splitting\n-  \/\/ This splits the space into two spaces, the first part of which will be returned.\n-  ReservedSpace first_part(size_t partition_size, size_t alignment);\n-  ReservedSpace last_part (size_t partition_size, size_t alignment);\n-  ReservedSpace partition (size_t offset, size_t partition_size, size_t alignment);\n-\n-  \/\/ These simply call the above using the default alignment.\n-  inline ReservedSpace first_part(size_t partition_size);\n-  inline ReservedSpace last_part (size_t partition_size);\n-  inline ReservedSpace partition (size_t offset, size_t partition_size);\n-\n-  bool contains(const void* p) const {\n-    return (base() <= ((char*)p)) && (((char*)p) < (base() + size()));\n-  }\n-\n-  \/\/ Put a ReservedSpace over an existing range\n-  static ReservedSpace space_for_range(char* base, size_t size, size_t alignment,\n-                                       size_t page_size, bool special, bool executable);\n-};\n-\n-ReservedSpace ReservedSpace::first_part(size_t partition_size)\n-{\n-  return first_part(partition_size, alignment());\n-}\n-\n-ReservedSpace ReservedSpace::last_part(size_t partition_size)\n-{\n-  return last_part(partition_size, alignment());\n-}\n-\n-ReservedSpace ReservedSpace::partition(size_t offset, size_t partition_size)\n-{\n-  return partition(offset, partition_size, alignment());\n-}\n-\n-\/\/ Class encapsulating behavior specific of memory space reserved for Java heap.\n-class ReservedHeapSpace : public ReservedSpace {\n- private:\n-\n-  \/\/ Compressed oop support is not relevant in 32bit builds.\n-#ifdef _LP64\n-\n-  void try_reserve_heap(size_t size, size_t alignment, size_t page_size,\n-                        char *requested_address);\n-  void try_reserve_range(char *highest_start, char *lowest_start,\n-                         size_t attach_point_alignment, char *aligned_HBMA,\n-                         char *upper_bound, size_t size, size_t alignment, size_t page_size);\n-  void initialize_compressed_heap(const size_t size, size_t alignment, size_t page_size);\n-  \/\/ Create protection page at the beginning of the space.\n-  void establish_noaccess_prefix();\n-\n-#endif \/\/ _LP64\n-\n- public:\n-  \/\/ Constructor. Tries to find a heap that is good for compressed oops.\n-  \/\/ heap_allocation_directory is the path to the backing memory for Java heap. When set, Java heap will be allocated\n-  \/\/ on the device which is managed by the file system where the directory resides.\n-  ReservedHeapSpace(size_t size, size_t forced_base_alignment, size_t page_size, const char* heap_allocation_directory = nullptr);\n-  \/\/ Returns the base to be used for compression, i.e. so that null can be\n-  \/\/ encoded safely and implicit null checks can work.\n-  char *compressed_oop_base() const { return _base - _noaccess_prefix; }\n-  MemRegion region() const;\n-};\n-\n-\/\/ Class encapsulating behavior specific memory space for Code\n-class ReservedCodeSpace : public ReservedSpace {\n- public:\n-  \/\/ Constructor\n-  ReservedCodeSpace(size_t r_size, size_t rs_align, size_t page_size);\n-};\n+class ReservedSpace;\n","filename":"src\/hotspot\/share\/memory\/virtualspace.hpp","additions":2,"deletions":134,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n@@ -175,1 +175,2 @@\n-  return range_intersects(from, to, (const void*)t->stack_end(), (const void*)t->stack_base());\n+  \/\/ Note it is possible to encounter a brand new thread that has not yet initialized its stack fields.\n+  return range_intersects(from, to, (const void*)t->stack_end(), (const void*)t->stack_base_or_null());\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -201,4 +201,0 @@\n-jint ArrayKlass::compute_modifier_flags() const {\n-  return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -121,4 +121,0 @@\n-\n-  \/\/ jvm support\n-  jint compute_modifier_flags() const;\n-\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n-    if ((address)CompressedClassSpaceBaseAddress == _base) {\n+    if (CompressedClassSpaceBaseAddress == (size_t)_base) {\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/reservedSpace.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"memory\/virtualspace.hpp\"\n@@ -69,1 +69,1 @@\n-  _heap_address_range = heap_space.region();\n+  _heap_address_range = MemRegion((HeapWord*)heap_space.base(), (HeapWord*)heap_space.end());\n","filename":"src\/hotspot\/share\/oops\/compressedOops.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -215,2 +215,4 @@\n-\/\/ Called to verify that k is a permitted subclass of this class\n-bool InstanceKlass::has_as_permitted_subclass(const InstanceKlass* k) const {\n+\/\/ Called to verify that k is a permitted subclass of this class.\n+\/\/ The incoming stringStream is used to format the messages for error logging and for the caller\n+\/\/ to use for exception throwing.\n+bool InstanceKlass::has_as_permitted_subclass(const InstanceKlass* k, stringStream& ss) const {\n@@ -224,1 +226,1 @@\n-    log_trace(class, sealed)(\"Checking for permitted subclass of %s in %s\",\n+    log_trace(class, sealed)(\"Checking for permitted subclass %s in %s\",\n@@ -230,3 +232,9 @@\n-    ResourceMark rm(current);\n-    log_trace(class, sealed)(\"Check failed for same module of permitted subclass %s and sealed class %s\",\n-                             k->external_name(), this->external_name());\n+    ss.print(\"Failed same module check: subclass %s is in module '%s' with loader %s, \"\n+             \"and sealed class %s is in module '%s' with loader %s\",\n+             k->external_name(),\n+             k->module()->name_as_C_string(),\n+             k->module()->loader_data()->loader_name_and_id(),\n+             this->external_name(),\n+             this->module()->name_as_C_string(),\n+             this->module()->loader_data()->loader_name_and_id());\n+    log_trace(class, sealed)(\" - %s\", ss.as_string());\n@@ -237,3 +245,9 @@\n-    ResourceMark rm(current);\n-    log_trace(class, sealed)(\"Check failed, subclass %s not public and not in the same package as sealed class %s\",\n-                             k->external_name(), this->external_name());\n+    ss.print(\"Failed same package check: non-public subclass %s is in package '%s' with classloader %s, \"\n+             \"and sealed class %s is in package '%s' with classloader %s\",\n+             k->external_name(),\n+             k->package() != nullptr ? k->package()->name()->as_C_string() : \"unnamed\",\n+             k->module()->loader_data()->loader_name_and_id(),\n+             this->external_name(),\n+             this->package() != nullptr ? this->package()->name()->as_C_string() : \"unnamed\",\n+             this->module()->loader_data()->loader_name_and_id());\n+    log_trace(class, sealed)(\" - %s\", ss.as_string());\n@@ -251,1 +265,4 @@\n-  log_trace(class, sealed)(\"- class is NOT a permitted subclass!\");\n+\n+  ss.print(\"Failed listed permitted subclass check: class %s is not a permitted subclass of %s\",\n+           k->external_name(), this->external_name());\n+  log_trace(class, sealed)(\" - %s\", ss.as_string());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -459,2 +459,4 @@\n-  \/\/ Called to verify that k is a permitted subclass of this class\n-  bool has_as_permitted_subclass(const InstanceKlass* k) const;\n+  \/\/ Called to verify that k is a permitted subclass of this class.\n+  \/\/ The incoming stringStream is used for logging, and for the caller to create\n+  \/\/ a detailed exception message on failure.\n+  bool has_as_permitted_subclass(const InstanceKlass* k, stringStream& ss) const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -143,0 +143,3 @@\n+\n+  \/\/ Compute modifier flags after bottom_klass and element_klass are initialized.\n+  set_modifier_flags(compute_modifier_flags());\n@@ -343,4 +346,2 @@\n-  if (element_klass() == nullptr) {\n-    assert(Universe::is_bootstrapping(), \"partial objArray only at startup\");\n-    return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;\n-  }\n+  assert (element_klass() != nullptr, \"should be initialized\");\n+\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -78,0 +78,4 @@\n+jint TypeArrayKlass::compute_modifier_flags() const {\n+  return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;\n+}\n+\n@@ -87,0 +91,3 @@\n+\n+  \/\/ Compute modifier flags.\n+  set_modifier_flags(compute_modifier_flags());\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,2 @@\n+  jint compute_modifier_flags() const;\n+\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,6 @@\n-#include \"opto\/output.hpp\"\n+\n+\/\/ Define the initial sizes for allocation of the resizable code buffer\n+enum {\n+  initial_const_capacity =   4 * 1024\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/c2compiler.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -216,7 +216,1 @@\n-  \/\/ But here we have to pay extra attention:\n-  \/\/ Do not narrow the type of range check dependent CastIINodes to\n-  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n-  \/\/ the corresponding range check is not removed.\n-  if (!_range_check_dependency) {\n-    res = widen_type(phase, res, T_INT);\n-  }\n+  res = widen_type(phase, res, T_INT);\n@@ -227,2 +221,4 @@\n-static Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, Node* control, const TypeInteger* type, ConstraintCastNode::DependencyType dependency, BasicType bt) {\n-  Node* n = ConstraintCastNode::make_cast_for_basic_type(control, parent, type, dependency, bt);\n+Node* ConstraintCastNode::find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const {\n+  Node* n = clone();\n+  n->set_req(1, parent);\n+  n->as_ConstraintCast()->set_type(type);\n@@ -242,1 +238,1 @@\n-  if (can_reshape && !_range_check_dependency && !phase->C->post_loop_opts_phase()) {\n+  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n@@ -246,1 +242,1 @@\n-  if (!_range_check_dependency) {\n+  if (!_range_check_dependency || phase->C->post_loop_opts_phase()) {\n@@ -249,0 +245,1 @@\n+  phase->C->record_for_post_loop_opts_igvn(this);\n@@ -257,7 +254,0 @@\n-  if (_range_check_dependency) {\n-    if (phase->C->post_loop_opts_phase()) {\n-      return this->in(1);\n-    } else {\n-      phase->C->record_for_post_loop_opts_igvn(this);\n-    }\n-  }\n@@ -292,0 +282,28 @@\n+void CastIINode::remove_range_check_cast(Compile* C) {\n+  if (has_range_check()) {\n+    \/\/ Range check CastII nodes feed into an address computation subgraph. Remove them to let that subgraph float freely.\n+    \/\/ For memory access or integer divisions nodes that depend on the cast, record the dependency on the cast's control\n+    \/\/ as a precedence edge, so they can't float above the cast in case that cast's narrowed type helped eliminate a\n+    \/\/ range check or a null divisor check.\n+    assert(in(0) != nullptr, \"All RangeCheck CastII must have a control dependency\");\n+    ResourceMark rm;\n+    Unique_Node_List wq;\n+    wq.push(this);\n+    for (uint next = 0; next < wq.size(); ++next) {\n+      Node* m = wq.at(next);\n+      for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n+        Node* use = m->fast_out(i);\n+        if (use->is_Mem() || use->is_div_or_mod(T_INT) || use->is_div_or_mod(T_LONG)) {\n+          use->ensure_control_or_add_prec(in(0));\n+        } else if (!use->is_CFG() && !use->is_Phi()) {\n+          wq.push(use);\n+        }\n+      }\n+    }\n+    subsume_by(in(1), C);\n+    if (outcnt() == 0) {\n+      disconnect_inputs(C);\n+    }\n+  }\n+}\n+\n@@ -492,2 +510,2 @@\n-    Node* cx = find_or_make_integer_cast(igvn, x, in(0), rx, _dependency, bt);\n-    Node* cy = find_or_make_integer_cast(igvn, y, in(0), ry, _dependency, bt);\n+    Node* cx = find_or_make_integer_cast(igvn, x, rx);\n+    Node* cy = find_or_make_integer_cast(igvn, y, ry);\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":38,"deletions":20,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+  Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const;\n@@ -124,0 +125,1 @@\n+  void remove_range_check_cast(Compile* C);\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3149,0 +3149,7 @@\n+    \/\/ If the divisor input for a Div (or Mod etc.) is not zero, then the control input of the Div is set to zero.\n+    \/\/ It could be that the divisor input is found not zero because its type is narrowed down by a CastII in the\n+    \/\/ subgraph for that input. Range check CastIIs are removed during final graph reshape. To preserve the dependency\n+    \/\/ carried by a CastII, precedence edges are added to the Div node. We need to transfer the precedence edges to the\n+    \/\/ DivMod node so the dependency is not lost.\n+    divmod->add_prec_from(n);\n+    divmod->add_prec_from(d);\n@@ -3434,0 +3441,4 @@\n+  case Op_CastII: {\n+    n->as_CastII()->remove_range_check_cast(this);\n+    break;\n+  }\n@@ -3585,10 +3596,0 @@\n-#ifdef ASSERT\n-  case Op_CastII:\n-    \/\/ Verify that all range check dependent CastII nodes were removed.\n-    if (n->isa_CastII()->has_range_check()) {\n-      n->dump(3);\n-      assert(false, \"Range check dependent CastII node was not removed\");\n-    }\n-    break;\n-#endif\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -949,4 +949,1 @@\n-  Node_Notes*       node_notes_at(int idx) {\n-    return locate_node_notes(_node_note_array, idx, false);\n-  }\n-  inline bool   set_node_notes_at(int idx, Node_Notes* value);\n+  Node_Notes*       node_notes_at(int idx);\n@@ -954,0 +951,1 @@\n+  inline bool   set_node_notes_at(int idx, Node_Notes* value);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"opto\/vectornode.hpp\"\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1751,6 +1751,2 @@\n-  Node* init = target_loop_head->init_trip();\n-  Node* stride = target_loop_head->stride();\n-  LoopNode* target_outer_loop_head = target_loop_head->skip_strip_mined();\n-  Node* target_loop_entry = target_outer_loop_head->in(LoopNode::EntryControl);\n-  CreateAssertionPredicatesVisitor create_assertion_predicates_visitor(init, stride, target_loop_entry, this,\n-                                                                       _node_in_loop_body, clone_template);\n+  CreateAssertionPredicatesVisitor create_assertion_predicates_visitor(target_loop_head, this, _node_in_loop_body,\n+                                                                       clone_template);\n@@ -1760,5 +1756,0 @@\n-  if (create_assertion_predicates_visitor.has_created_predicates()) {\n-    IfTrueNode* last_created_predicate_success_proj = create_assertion_predicates_visitor.last_created_success_proj();\n-    _igvn.replace_input_of(target_outer_loop_head, LoopNode::EntryControl, last_created_predicate_success_proj);\n-    set_idom(target_outer_loop_head, last_created_predicate_success_proj, dom_depth(target_outer_loop_head));\n-  }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1370,0 +1370,6 @@\n+  \/\/ Replace the control input of 'node' with 'new_control' and set the dom depth to the one of 'new_control'.\n+  void replace_control(Node* node, Node* new_control) {\n+    _igvn.replace_input_of(node, 0, new_control);\n+    set_idom(node, new_control, dom_depth(new_control));\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"opto\/multnode.hpp\"\n-#include \"opto\/node.hpp\"\n@@ -32,1 +30,0 @@\n-#include \"opto\/type.hpp\"\n","filename":"src\/hotspot\/share\/opto\/mathexactnode.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2897,0 +2897,9 @@\n+void Node::add_prec_from(Node* n) {\n+  for (uint i = n->req(); i < n->len(); i++) {\n+    Node* prec = n->in(i);\n+    if (prec != nullptr) {\n+      add_prec(prec);\n+    }\n+  }\n+}\n+\n@@ -2920,0 +2929,3 @@\n+bool Node::is_div_or_mod(BasicType bt) const { return Opcode() == Op_Div(bt) || Opcode() == Op_Mod(bt) ||\n+                                                      Opcode() == Op_UDiv(bt) || Opcode() == Op_UMod(bt); }\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1169,0 +1169,1 @@\n+  void add_prec_from(Node* n);\n@@ -1280,0 +1281,2 @@\n+  bool is_div_or_mod(BasicType bt) const;\n+\n@@ -2002,0 +2005,4 @@\n+inline Node_Notes* Compile::node_notes_at(int idx) {\n+  return locate_node_notes(_node_note_array, idx, false);\n+}\n+\n@@ -2059,0 +2066,4 @@\n+Op_IL(Div)\n+Op_IL(Mod)\n+Op_IL(UDiv)\n+Op_IL(UMod)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"asm\/macroAssembler.inline.hpp\"\n@@ -37,1 +36,0 @@\n-#include \"memory\/allocation.inline.hpp\"\n@@ -51,2 +49,0 @@\n-#include \"opto\/runtime.hpp\"\n-#include \"opto\/subnode.hpp\"\n@@ -54,1 +50,0 @@\n-#include \"runtime\/handles.inline.hpp\"\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,5 +57,0 @@\n-\/\/ Define the initial sizes for allocation of the resizable code buffer\n-enum {\n-  initial_const_capacity =   4 * 1024\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -881,0 +881,13 @@\n+CreateAssertionPredicatesVisitor::CreateAssertionPredicatesVisitor(CountedLoopNode* target_loop_head,\n+                                                                   PhaseIdealLoop* phase,\n+                                                                   const NodeInLoopBody& node_in_loop_body,\n+                                                                   const bool clone_template)\n+    : _init(target_loop_head->init_trip()),\n+      _stride(target_loop_head->stride()),\n+      _old_target_loop_entry(target_loop_head->skip_strip_mined()->in(LoopNode::EntryControl)),\n+      _current_predicate_chain_head(target_loop_head->skip_strip_mined()), \/\/ Initially no predicates, yet.\n+      _phase(phase),\n+      _has_hoisted_check_parse_predicates(false),\n+      _node_in_loop_body(node_in_loop_body),\n+      _clone_template(clone_template) {}\n+\n@@ -897,1 +910,6 @@\n-    _new_control = clone_template_and_replace_init_input(template_assertion_predicate);\n+    IfTrueNode* cloned_template_success_proj = clone_template_and_replace_init_input(template_assertion_predicate);\n+    initialize_from_template(template_assertion_predicate, cloned_template_success_proj);\n+    _current_predicate_chain_head = cloned_template_success_proj->in(0);\n+  } else {\n+    IfTrueNode* initialized_success_proj = initialize_from_template(template_assertion_predicate, _old_target_loop_entry);\n+    _current_predicate_chain_head = initialized_success_proj->in(0);\n@@ -899,1 +917,0 @@\n-  _new_control = initialize_from_template(template_assertion_predicate);\n@@ -904,1 +921,1 @@\n-    const TemplateAssertionPredicate& template_assertion_predicate) const {\n+    const TemplateAssertionPredicate& template_assertion_predicate, Node* new_control) const {\n@@ -909,1 +926,1 @@\n-                                                                                                   _new_control,\n+                                                                                                   new_control,\n@@ -913,0 +930,1 @@\n+  rewire_to_old_predicate_chain_head(initialized_predicate);\n@@ -920,2 +938,40 @@\n-  _phase->register_new_node(opaque_init, _new_control);\n-  return template_assertion_predicate.clone_and_replace_init(_new_control, opaque_init, _phase);\n+  _phase->register_new_node(opaque_init, _old_target_loop_entry);\n+  return template_assertion_predicate.clone_and_replace_init(_old_target_loop_entry, opaque_init, _phase);\n+}\n+\n+\/\/ Rewire the newly created predicates to the old predicate chain head (i.e. '_current_predicate_chain_head') by\n+\/\/ rewiring the current control input of '_current_predicate_chain_head' from '_old_target_loop_entry' to\n+\/\/ 'initialized_assertion_predicate_success_proj'. This is required because we walk the predicate chain from the loop\n+\/\/ up and clone Template Assertion Predicates on the fly:\n+\/\/\n+\/\/          x\n+\/\/          |                                               old target\n+\/\/  Template Assertion                                      loop entry\n+\/\/     Predicate 1             old target        clone           |    \\\n+\/\/          |                  loop entry        TAP 2           |     cloned Template Assertion\n+\/\/  Template Assertion             |            ======>          |            Predicate 2\n+\/\/     Predicate 2            target loop                        |\n+\/\/          |                                               target loop #_current_predicate_chain_head\n+\/\/     source loop\n+\/\/\n+\/\/\n+\/\/               old target                                                        old target\n+\/\/               loop entry                                                        loop entry\n+\/\/                    |    \\                                 rewire                     |\n+\/\/                    |    cloned Template Assertion         to old         cloned Template Assertion #current_predicate\n+\/\/   initialize       |           Predicate 2               predicate              Predicate 2         _chain_head (new)\n+\/\/     TAP 2          |               |                     chain head                  |\n+\/\/    ======>         |      Initialized Assertion           ======>           Initialized Assertion\n+\/\/                    |          Predicate 2                                        Predicate 2\n+\/\/                    |                                                                 |\n+\/\/               target loop #_current_predicate_chain_head                        target loop\n+\/\/\n+void CreateAssertionPredicatesVisitor::rewire_to_old_predicate_chain_head(\n+    Node* initialized_assertion_predicate_success_proj) const {\n+  if (_current_predicate_chain_head->is_Loop()) {\n+    assert(_current_predicate_chain_head->in(LoopNode::EntryControl) == _old_target_loop_entry, \"must be old loop entry\");\n+    _phase->replace_loop_entry(_current_predicate_chain_head->as_Loop(), initialized_assertion_predicate_success_proj);\n+  } else {\n+    assert(_current_predicate_chain_head->in(0) == _old_target_loop_entry, \"must be old loop entry\");\n+    _phase->replace_control(_current_predicate_chain_head, initialized_assertion_predicate_success_proj);\n+  }\n@@ -954,1 +1010,1 @@\n-    _phase->igvn().replace_input_of(new_control_out, LoopNode::EntryControl, initialized_success_proj);\n+    _phase->replace_loop_entry(new_control_out->as_Loop(), initialized_success_proj);\n@@ -956,1 +1012,1 @@\n-    _phase->igvn().replace_input_of(new_control_out, 0, initialized_success_proj);\n+    _phase->replace_control(new_control_out, initialized_success_proj);\n@@ -958,1 +1014,0 @@\n-  _phase->set_idom(new_control_out, initialized_success_proj, _phase->dom_depth(new_control_out));\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":64,"deletions":9,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -987,1 +987,1 @@\n-  Node* _new_control;\n+  Node* _current_predicate_chain_head;\n@@ -994,1 +994,3 @@\n-  IfTrueNode* initialize_from_template(const TemplateAssertionPredicate& template_assertion_predicate) const;\n+  IfTrueNode* initialize_from_template(const TemplateAssertionPredicate& template_assertion_predicate,\n+                                       Node* new_control) const;\n+  void rewire_to_old_predicate_chain_head(Node* initialized_assertion_predicate_success_proj) const;\n@@ -997,10 +999,2 @@\n-  CreateAssertionPredicatesVisitor(Node* init, Node* stride, Node* new_control, PhaseIdealLoop* phase,\n-                                   const NodeInLoopBody& node_in_loop_body, const bool clone_template)\n-      : _init(init),\n-        _stride(stride),\n-        _old_target_loop_entry(new_control),\n-        _new_control(new_control),\n-        _phase(phase),\n-        _has_hoisted_check_parse_predicates(false),\n-        _node_in_loop_body(node_in_loop_body),\n-        _clone_template(clone_template) {}\n+  CreateAssertionPredicatesVisitor(CountedLoopNode* target_loop_head, PhaseIdealLoop* phase,\n+                                   const NodeInLoopBody& node_in_loop_body, bool clone_template);\n@@ -1013,14 +1007,0 @@\n-\n-  \/\/ Did we create any new Initialized Assertion Predicates?\n-  bool has_created_predicates() const {\n-    return _new_control != _old_target_loop_entry;\n-  }\n-\n-  \/\/ Return the last created node by this visitor or the originally provided 'new_control' to the visitor if there was\n-  \/\/ no new node created (i.e. no Template Assertion Predicates found).\n-  IfTrueNode* last_created_success_proj() const {\n-    assert(has_created_predicates(), \"should only be queried if new nodes have been created\");\n-    assert(_new_control->unique_ctrl_out_or_null() == nullptr, \"no control outputs, yet\");\n-    assert(_new_control->is_IfTrue(), \"Assertion Predicates only have IfTrue on success proj\");\n-    return _new_control->as_IfTrue();\n-  }\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":6,"deletions":26,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-#include \"opto\/type.hpp\"\n-#include \"runtime\/deoptimization.hpp\"\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1389,0 +1389,1 @@\n+  \/\/ Ensure reduction operation for lanewise operation\n@@ -1390,1 +1391,1 @@\n-  if (!arch_supports_vector(sopc, num_elem, elem_bt, is_masked_op ? VecMaskUseLoad : VecMaskNotUsed)) {\n+  if (sopc == opc || !arch_supports_vector(sopc, num_elem, elem_bt, is_masked_op ? VecMaskUseLoad : VecMaskNotUsed)) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -95,4 +95,4 @@\n-    : vframeStreamCommon(RegisterMap(jt,\n-                                     RegisterMap::UpdateMap::skip,\n-                                     RegisterMap::ProcessFrames::skip,\n-                                     RegisterMap::WalkContinuation::skip)) {\n+    : vframeStreamCommon(jt,\n+                         RegisterMap::UpdateMap::skip,\n+                         RegisterMap::ProcessFrames::skip,\n+                         RegisterMap::WalkContinuation::skip) {\n","filename":"src\/hotspot\/share\/prims\/forte.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3322,2 +3322,3 @@\n-\/\/ in the safepoint protocol, thread suspension, thread interruption, or anything of that\n-\/\/ nature. JavaThreads will be \"in native\" when using this API from JDK code.\n+\/\/ in the safepoint protocol, thread suspension, thread interruption, or most things of that\n+\/\/ nature, except JavaThreads will be blocked by VM_Exit::block_if_vm_exited if the VM has\n+\/\/ shutdown. JavaThreads will be \"in native\" when using this API from JDK code.\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-  static Iterator all();\n@@ -85,0 +84,1 @@\n+  static Iterator all();\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2699,1 +2699,1 @@\n-    result = k->compute_modifier_flags();\n+    result = k->modifier_flags();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"memory\/memoryReserver.hpp\"\n@@ -302,1 +303,1 @@\n-  ReservedHeapSpace rhs(100 * granularity, granularity, os::vm_page_size());\n+  ReservedHeapSpace rhs = HeapReserver::reserve(100 * granularity, granularity, os::vm_page_size(), nullptr);\n@@ -329,1 +330,1 @@\n-  ReservedHeapSpace rhs(reserved_space_size * granularity, granularity, os::vm_page_size());\n+  ReservedHeapSpace rhs = HeapReserver::reserve(reserved_space_size * granularity, granularity, os::vm_page_size(), nullptr);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  JavaThread* _target;\n+  JavaThread* _current;\n@@ -69,2 +69,2 @@\n-    _vthread(t, t->vthread()), _target(t), _result(freeze_pinned_native), _failed(false) {\n-    assert(!_target->is_in_VTMS_transition(), \"must be\");\n+    _vthread(t, t->vthread()), _current(t), _result(freeze_pinned_native), _failed(false) {\n+    assert(!_current->is_in_VTMS_transition(), \"must be\");\n@@ -78,2 +78,2 @@\n-        JvmtiThreadState* state = _target->jvmti_thread_state();\n-        if (_target->has_pending_popframe() || (state != nullptr && state->is_earlyret_pending())) {\n+        JvmtiThreadState* state = _current->jvmti_thread_state();\n+        if (_current->has_pending_popframe() || (state != nullptr && state->is_earlyret_pending())) {\n@@ -86,1 +86,1 @@\n-      if (_target->has_async_exception_condition()) {\n+      if (_current->has_async_exception_condition()) {\n@@ -90,1 +90,1 @@\n-      _target->set_is_in_VTMS_transition(true);\n+      _current->set_is_in_VTMS_transition(true);\n@@ -95,1 +95,1 @@\n-    assert(!_target->is_suspended(), \"must be\");\n+    assert(!_current->is_suspended(), \"must be\");\n@@ -97,1 +97,1 @@\n-    assert(_target->is_in_VTMS_transition(), \"must be\");\n+    assert(_current->is_in_VTMS_transition(), \"must be\");\n@@ -109,1 +109,1 @@\n-        _target->set_is_in_VTMS_transition(false);\n+        _current->set_is_in_VTMS_transition(false);\n@@ -118,3 +118,3 @@\n-static bool is_vthread_safe_to_preempt_for_jvmti(JavaThread* target) {\n-  if (target->is_in_VTMS_transition()) {\n-    \/\/ We caught target at the end of a mount transition.\n+static bool is_vthread_safe_to_preempt_for_jvmti(JavaThread* current) {\n+  if (current->is_in_VTMS_transition()) {\n+    \/\/ We are at the end of a mount transition.\n@@ -127,1 +127,1 @@\n-static bool is_vthread_safe_to_preempt(JavaThread* target, oop vthread) {\n+static bool is_vthread_safe_to_preempt(JavaThread* current, oop vthread) {\n@@ -132,1 +132,1 @@\n-  return JVMTI_ONLY(is_vthread_safe_to_preempt_for_jvmti(target)) NOT_JVMTI(true);\n+  return JVMTI_ONLY(is_vthread_safe_to_preempt_for_jvmti(current)) NOT_JVMTI(true);\n@@ -137,6 +137,6 @@\n-static void verify_preempt_preconditions(JavaThread* target, oop continuation) {\n-  assert(target == JavaThread::current(), \"no support for external preemption\");\n-  assert(target->has_last_Java_frame(), \"\");\n-  assert(!target->preempting(), \"\");\n-  assert(target->last_continuation() != nullptr, \"\");\n-  assert(target->last_continuation()->cont_oop(target) == continuation, \"\");\n+static void verify_preempt_preconditions(JavaThread* current, oop continuation) {\n+  assert(current == JavaThread::current(), \"no support for external preemption\");\n+  assert(current->has_last_Java_frame(), \"\");\n+  assert(!current->preempting(), \"\");\n+  assert(current->last_continuation() != nullptr, \"\");\n+  assert(current->last_continuation()->cont_oop(current) == continuation, \"\");\n@@ -144,1 +144,1 @@\n-  assert(!target->has_pending_exception(), \"\");\n+  assert(!current->has_pending_exception(), \"\");\n@@ -147,2 +147,2 @@\n-freeze_result Continuation::try_preempt(JavaThread* target, oop continuation) {\n-  verify_preempt_preconditions(target, continuation);\n+freeze_result Continuation::try_preempt(JavaThread* current, oop continuation) {\n+  verify_preempt_preconditions(current, continuation);\n@@ -154,1 +154,1 @@\n-  if (!is_vthread_safe_to_preempt(target, target->vthread())) {\n+  if (!is_vthread_safe_to_preempt(current, current->vthread())) {\n@@ -158,1 +158,1 @@\n-  JVMTI_ONLY(JvmtiUnmountBeginMark jubm(target);)\n+  JVMTI_ONLY(JvmtiUnmountBeginMark jubm(current);)\n@@ -160,1 +160,1 @@\n-  freeze_result res = CAST_TO_FN_PTR(FreezeContFnT, freeze_preempt_entry())(target, target->last_Java_sp());\n+  freeze_result res = CAST_TO_FN_PTR(FreezeContFnT, freeze_preempt_entry())(current, current->last_Java_sp());\n@@ -163,0 +163,8 @@\n+\n+  if (current->has_pending_exception()) {\n+    assert(res == freeze_exception, \"expecting an exception result from freeze\");\n+    \/\/ We don't want to throw exceptions, especially when returning\n+    \/\/ from monitorenter since the compiler does not expect one. We\n+    \/\/ just ignore the exception and pin the vthread to the carrier.\n+    current->clear_pending_exception();\n+  }\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":35,"deletions":27,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -600,4 +600,5 @@\n-  ContinuationEntry* ce = current->last_continuation();\n-  if (ce != nullptr && ce->is_virtual_thread()) {\n-    assert(result != freeze_ok, \"sanity check\");\n-    current->post_vthread_pinned_event(&vthread_pinned_event, \"Contended monitor enter\", result);\n+  if (current->current_waiting_monitor() == nullptr) {\n+    ContinuationEntry* ce = current->last_continuation();\n+    if (ce != nullptr && ce->is_virtual_thread()) {\n+      current->post_vthread_pinned_event(&vthread_pinned_event, \"Contended monitor enter\", result);\n+    }\n@@ -1822,5 +1823,0 @@\n-    if (ce != nullptr && ce->is_virtual_thread()) {\n-      assert(result != freeze_ok, \"sanity check\");\n-      current->post_vthread_pinned_event(&vthread_pinned_event, \"Object.wait\", result);\n-    }\n-\n@@ -1866,0 +1862,4 @@\n+  if (ce != nullptr && ce->is_virtual_thread()) {\n+    current->post_vthread_pinned_event(&vthread_pinned_event, \"Object.wait\", result);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -1124,0 +1125,25 @@\n+void os::print_jvmti_agent_info(outputStream* st) {\n+#if INCLUDE_JVMTI\n+  const JvmtiAgentList::Iterator it = JvmtiAgentList::all();\n+  if (it.has_next()) {\n+    st->print_cr(\"JVMTI agents:\");\n+  } else {\n+    st->print_cr(\"JVMTI agents: none\");\n+  }\n+  while (it.has_next()) {\n+    const JvmtiAgent* agent = it.next();\n+    if (agent != nullptr) {\n+      const char* dyninfo = agent->is_dynamic() ? \"dynamic \" : \"\";\n+      const char* instrumentinfo = agent->is_instrument_lib() ? \"instrumentlib \" : \"\";\n+      const char* loadinfo = agent->is_loaded() ? \"loaded\" : \"not loaded\";\n+      const char* initinfo = agent->is_initialized() ? \"initialized\" : \"not initialized\";\n+      const char* optionsinfo = agent->options();\n+      const char* pathinfo = agent->os_lib_path();\n+      if (optionsinfo == nullptr) optionsinfo = \"none\";\n+      if (pathinfo == nullptr) pathinfo = \"none\";\n+      st->print_cr(\"%s path:%s, %s, %s, %s%soptions:%s\", agent->name(), pathinfo, loadinfo, initinfo, dyninfo, instrumentinfo, optionsinfo);\n+    }\n+  }\n+#endif\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -816,0 +816,1 @@\n+  static void print_jvmti_agent_info(outputStream* st);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -528,0 +528,2 @@\n+  \/\/ Needed for code that can query a new thread before the stack has been set.\n+  address stack_base_or_null() const   { return _stack_base; }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-  RegisterMap temp_map = *register_map();\n@@ -101,0 +100,2 @@\n+\n+  RegisterMap temp_map = *register_map();\n@@ -496,4 +497,4 @@\n- : vframeStreamCommon(RegisterMap(thread,\n-                                  RegisterMap::UpdateMap::include,\n-                                  RegisterMap::ProcessFrames::include,\n-                                  RegisterMap::WalkContinuation::include)) {\n+ : vframeStreamCommon(thread,\n+                      RegisterMap::UpdateMap::include,\n+                      RegisterMap::ProcessFrames::include,\n+                      RegisterMap::WalkContinuation::include) {\n@@ -517,1 +518,1 @@\n- : vframeStreamCommon(RegisterMap(continuation, RegisterMap::UpdateMap::include)) {\n+ : vframeStreamCommon(continuation) {\n@@ -533,0 +534,4 @@\n+vframeStreamCommon::vframeStreamCommon(oop continuation)\n+  : _reg_map(continuation, RegisterMap::UpdateMap::include), _cont_entry(nullptr) {\n+  _thread = _reg_map.thread();\n+}\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -284,1 +284,2 @@\n-  inline vframeStreamCommon(RegisterMap reg_map);\n+  inline vframeStreamCommon(JavaThread* thread, RegisterMap::UpdateMap update_map, RegisterMap::ProcessFrames process_frames, RegisterMap::WalkContinuation walk_cont);\n+  vframeStreamCommon(oop continuation);\n","filename":"src\/hotspot\/share\/runtime\/vframe.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,1 +37,5 @@\n-inline vframeStreamCommon::vframeStreamCommon(RegisterMap reg_map) : _reg_map(reg_map), _cont_entry(nullptr) {\n+inline vframeStreamCommon::vframeStreamCommon(JavaThread* thread,\n+                                              RegisterMap::UpdateMap update_map,\n+                                              RegisterMap::ProcessFrames process_frames,\n+                                              RegisterMap::WalkContinuation walk_cont)\n+        : _reg_map(thread, update_map, process_frames, walk_cont), _cont_entry(nullptr) {\n@@ -112,4 +116,4 @@\n-  : vframeStreamCommon(RegisterMap(thread,\n-                                   RegisterMap::UpdateMap::include,\n-                                   process_frame ? RegisterMap::ProcessFrames::include : RegisterMap::ProcessFrames::skip ,\n-                                   RegisterMap::WalkContinuation::include)) {\n+  : vframeStreamCommon(thread,\n+                       RegisterMap::UpdateMap::include,\n+                       process_frame ? RegisterMap::ProcessFrames::include : RegisterMap::ProcessFrames::skip ,\n+                       RegisterMap::WalkContinuation::include) {\n","filename":"src\/hotspot\/share\/runtime\/vframe.inline.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -46,3 +46,0 @@\n-#ifdef COMPILER2\n-#include \"opto\/runtime.hpp\"\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,4 +48,0 @@\n-#ifdef COMPILER2\n-#include \"opto\/matcher.hpp\"\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -614,6 +614,10 @@\n-  if (_vm_exited &&\n-      Thread::current_or_null() != _shutdown_thread) {\n-    \/\/ _vm_exited is set at safepoint, and the Threads_lock is never released\n-    \/\/ so we will block here until the process dies.\n-    Threads_lock->lock();\n-    ShouldNotReachHere();\n+  if (_vm_exited) {\n+    \/\/ Need to check for an unattached thread as only attached threads\n+    \/\/ can acquire the lock.\n+    Thread* current = Thread::current_or_null();\n+    if (current != nullptr && current != _shutdown_thread) {\n+      \/\/ _vm_exited is set at safepoint, and the Threads_lock is never released\n+      \/\/ so we will block here until the process dies.\n+      Threads_lock->lock();\n+      ShouldNotReachHere();\n+    }\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2032,2 +2032,0 @@\n-  declare_constant(JVM_ACC_WRITTEN_FLAGS)                                 \\\n-                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -528,1 +528,1 @@\n-int AttachOperation::RequestReader::read_uint() {\n+int AttachOperation::RequestReader::read_uint(bool may_be_empty) {\n@@ -537,1 +537,3 @@\n-        log_error(attach)(\"Failed to read int value: EOF\");\n+        if (!may_be_empty || value != 0) { \/\/ value != 0 means this is not the 1st read\n+          log_error(attach)(\"Failed to read int value: EOF\");\n+        }\n@@ -618,2 +620,5 @@\n-bool AttachOperation::read_request(RequestReader* reader) {\n-  uint ver = reader->read_uint();\n+bool AttachOperation::read_request(RequestReader* reader, ReplyWriter* error_writer) {\n+  int ver = reader->read_uint(true); \/\/ do not log error if this is \"empty\" connection\n+  if (ver < 0) {\n+    return false;\n+  }\n@@ -634,0 +639,1 @@\n+        write_reply(error_writer, ATTACH_ERROR_BADVERSION, \"v2 is unsupported or disabled\");\n@@ -655,0 +661,1 @@\n+    write_reply(error_writer, ATTACH_ERROR_BADVERSION, \"unknown version\");\n@@ -658,1 +665,16 @@\n-  return read_request_data(reader, buffer_size, min_str_count, min_read_size);\n+  bool result = read_request_data(reader, buffer_size, min_str_count, min_read_size);\n+  if (result && ver == ATTACH_API_V1) {\n+    \/\/ We know the whole request does not exceed buffer_size,\n+    \/\/ for v1 also name\/arguments should not exceed name_length_max\/arg_length_max.\n+    if (strlen(name()) > AttachOperation::name_length_max) {\n+      log_error(attach)(\"Failed to read request: operation name is too long\");\n+      return false;\n+    }\n+    for (int i = 0; i < arg_count(); i++) {\n+      if (strlen(arg(i)) > AttachOperation::arg_length_max) {\n+        log_error(attach)(\"Failed to read request: operation argument is too long\");\n+        return false;\n+      }\n+    }\n+  }\n+  return result;\n@@ -674,4 +696,7 @@\n-bool AttachOperation::write_reply(ReplyWriter* writer, jint result, bufferedStream* result_stream) {\n-  char msg[32];\n-  os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", result);\n-  if (!writer->write_fully(msg, (int)strlen(msg))) {\n+bool AttachOperation::write_reply(ReplyWriter * writer, jint result, const char* message, int message_len) {\n+  if (message_len < 0) {\n+    message_len = (int)strlen(message);\n+  }\n+  char buf[32];\n+  os::snprintf_checked(buf, sizeof(buf), \"%d\\n\", result);\n+  if (!writer->write_fully(buf, (int)strlen(buf))) {\n@@ -680,1 +705,1 @@\n-  if (!writer->write_fully(result_stream->base(), (int)result_stream->size())) {\n+  if (!writer->write_fully(message, message_len)) {\n@@ -687,0 +712,4 @@\n+bool AttachOperation::write_reply(ReplyWriter* writer, jint result, bufferedStream* result_stream) {\n+  return write_reply(writer, result, result_stream->base(), (int)result_stream->size());\n+}\n+\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":39,"deletions":10,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -73,2 +73,2 @@\n-    ATTACH_API_V1 = 1,\n-    ATTACH_API_V2 = 2\n+  ATTACH_API_V1 = 1,\n+  ATTACH_API_V2 = 2\n@@ -167,0 +167,4 @@\n+  \/\/ error codes (reported as status to clients)\n+  enum {\n+    ATTACH_ERROR_BADVERSION = 101\n+  };\n@@ -234,0 +238,2 @@\n+  class ReplyWriter; \/\/ forward declaration\n+\n@@ -242,1 +248,5 @@\n-    int read_uint();\n+    \/\/\n+    \/\/ Attach client can make sanity connect\/disconnect.\n+    \/\/ In that case we get \"premature EOF\" error.\n+    \/\/ If may_be_empty is true, the error is not logged.\n+    int read_uint(bool may_be_empty = false);\n@@ -246,1 +256,2 @@\n-  bool read_request(RequestReader* reader);\n+  \/\/ Some errors known by clients are reported to error_writer.\n+  bool read_request(RequestReader* reader, ReplyWriter* error_writer);\n@@ -259,0 +270,1 @@\n+  bool write_reply(ReplyWriter* writer, jint result, const char* message, int message_len = -1);\n","filename":"src\/hotspot\/share\/services\/attachListener.hpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n@@ -146,1 +146,1 @@\n-#endif \/\/ LINUX or WINDOWS\n+#endif \/\/ LINUX or WINDOWS or MacOS\n@@ -1161,1 +1161,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -825,1 +825,1 @@\n-#if defined(LINUX) || defined(_WIN64)\n+#if defined(LINUX) || defined(_WIN64) || defined(__APPLE__)\n@@ -832,1 +832,1 @@\n-    return \"Prints an annotated process memory map of the VM process (linux and Windows only).\";\n+    return \"Prints an annotated process memory map of the VM process (linux, Windows and MacOS only).\";\n@@ -845,1 +845,1 @@\n-    return \"Dumps an annotated process memory map to an output file (linux and Windows only).\";\n+    return \"Dumps an annotated process memory map to an output file (linux, Windows and MacOS only).\";\n@@ -851,1 +851,1 @@\n-#endif \/\/ LINUX or WINDOWS\n+#endif \/\/ LINUX, WINDOWS or MACOS\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -361,0 +361,15 @@\n+\/\/ Enable collection of TaskQueue statistics.\n+\/\/ Enabled by default in debug builds.  Otherwise, disabled by default.\n+#ifndef TASKQUEUE_STATS\n+#ifdef ASSERT\n+#define TASKQUEUE_STATS 1\n+#else\n+#define TASKQUEUE_STATS 0\n+#endif \/\/ ASSERT\n+#endif \/\/ TASKQUEUE_STATS\n+#if TASKQUEUE_STATS\n+#define TASKQUEUE_STATS_ONLY(code) code\n+#else\n+#define TASKQUEUE_STATS_ONLY(code)\n+#endif \/\/ TASKQUEUE_STATS\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2017, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2017, 2024 SAP SE. All rights reserved.\n@@ -136,1 +136,1 @@\n-  (const char *)0\n+  nullptr                       \/\/ End marker.\n@@ -1210,0 +1210,6 @@\n+#if INCLUDE_JVMTI\n+  STEP_IF(\"printing jvmti agent info\", _verbose)\n+    os::print_jvmti_agent_info(st);\n+    st->cr();\n+#endif\n+\n@@ -1388,0 +1394,5 @@\n+#if INCLUDE_JVMTI\n+  os::print_jvmti_agent_info(st);\n+  st->cr();\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -209,1 +209,0 @@\n-    @SuppressWarnings(\"deprecation\")\n@@ -242,1 +241,0 @@\n-    @SuppressWarnings(\"deprecation\")\n@@ -302,1 +300,0 @@\n-    @SuppressWarnings(\"deprecation\")\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Parameters.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-                @SuppressWarnings(\"unchecked\")\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SealedObjectForKeyProtector.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n- * cob.labelBinding(lt.label()); \/\/ @link substring=\"label\" target=\"#label\"\n+ * cob.labelBinding(lt.label()); \/\/ @link regex=\"label(?=\\()\" target=\"#label\"\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LabelTarget.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -800,1 +800,1 @@\n-         * <li>{@code n}, where {@code 0 < m < N}, the arguments {@code m..N} are passed\n+         * <li>{@code m}, where {@code 0 < m < N}, the arguments {@code m..N-1} are passed\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -572,3 +572,2 @@\n-     * <p> If the endpoint is an unresolved {@link InetSocketAddress}, or the\n-     * connection cannot be established, then the socket is closed, and an\n-     * {@link IOException} is thrown.\n+     * <p> If the connection cannot be established, then the socket is closed,\n+     * and an {@link IOException} is thrown.\n@@ -594,2 +593,2 @@\n-     * @throws  UnknownHostException if the endpoint is an unresolved\n-     *          {@link InetSocketAddress}\n+     * @throws  UnknownHostException if the connection could not be established\n+     *          because the endpoint is an unresolved {@link InetSocketAddress}\n@@ -612,3 +611,2 @@\n-     * <p> If the endpoint is an unresolved {@link InetSocketAddress}, the\n-     * connection cannot be established, or the timeout expires before the\n-     * connection is established, then the socket is closed, and an\n+     * <p> If the connection cannot be established, or the timeout expires\n+     * before the connection is established, then the socket is closed, and an\n@@ -637,2 +635,2 @@\n-     * @throws  UnknownHostException if the endpoint is an unresolved\n-     *          {@link InetSocketAddress}\n+     * @throws  UnknownHostException if the connection could not be established\n+     *          because the endpoint is an unresolved {@link InetSocketAddress}\n@@ -663,6 +661,0 @@\n-        if (epoint.isUnresolved()) {\n-            var uhe = new UnknownHostException(epoint.getHostName());\n-            closeSuppressingExceptions(uhe);\n-            throw uhe;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -118,1 +118,0 @@\n-    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/share\/classes\/java\/security\/Key.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,0 @@\n-    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/share\/classes\/java\/security\/PrivateKey.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -830,1 +830,1 @@\n-    @SuppressWarnings(\"unchecked\") \/\/ Function must actually operate over strings\n+    \/\/ Function must actually operate over strings\n@@ -850,1 +850,1 @@\n-    @SuppressWarnings(\"unchecked\") \/\/ Function must actually operate over strings\n+    \/\/ Function must actually operate over strings\n@@ -867,1 +867,1 @@\n-    @SuppressWarnings(\"unchecked\") \/\/ Function must actually operate over strings\n+    \/\/ Function must actually operate over strings\n@@ -884,1 +884,1 @@\n-    @SuppressWarnings(\"unchecked\") \/\/ Function must actually operate over strings\n+    \/\/ Function must actually operate over strings\n@@ -896,1 +896,1 @@\n-    @SuppressWarnings(\"unchecked\") \/\/ Function must actually operate over strings\n+    \/\/ Function must actually operate over strings\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,0 @@\n-    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/share\/classes\/java\/security\/PublicKey.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/DSAPrivateKey.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/DSAPublicKey.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/ECPrivateKey.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/ECPublicKey.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/RSAMultiPrimePrivateCrtKey.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/RSAPrivateCrtKey.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/RSAPrivateKey.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/share\/classes\/java\/security\/interfaces\/RSAPublicKey.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,0 @@\n-    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/SecretKey.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/interfaces\/DHPrivateKey.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/interfaces\/DHPublicKey.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/interfaces\/PBEKey.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n@@ -31,1 +33,0 @@\n-import java.nio.file.Paths;\n@@ -50,2 +51,17 @@\n-    private static final Path BOOT_MODULES_JIMAGE =\n-        Paths.get(JAVA_HOME, \"lib\", \"modules\");\n+    private static final Path BOOT_MODULES_JIMAGE;\n+\n+    static {\n+        FileSystem fs;\n+        if (ImageReaderFactory.class.getClassLoader() == null) {\n+            try {\n+                fs = (FileSystem) Class.forName(\"sun.nio.fs.DefaultFileSystemProvider\")\n+                        .getMethod(\"theFileSystem\")\n+                        .invoke(null);\n+            } catch (Exception e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+        } else {\n+            fs = FileSystems.getDefault();\n+        }\n+        BOOT_MODULES_JIMAGE = fs.getPath(JAVA_HOME, \"lib\", \"modules\");\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReaderFactory.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -158,1 +158,0 @@\n-        java.se, \/\/ for ParticipatesInPreview\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-java.launcher.opt.header  =   Verwendung: {0} [Optionen] <Hauptklasse> [args...]\\n           (zur Ausfhrung einer Klasse)\\n   oder  {0} [Optionen] -jar <JAR-Datei> [args...]\\n           (zur Ausfhrung einer JAR-Datei)\\n   oder  {0} [Optionen] -m <Modul>[\/<Hauptklasse>] [args...]\\n       {0} [Optionen] --module <Modul>[\/<Hauptklasse>] [args...]\\n            (zur Ausfhrung der Hauptklasse in einem Modul)\\n   oder  {0} [Optionen] <Quelldatei> [args]\\n           (zur Ausfhrung eines Programms mit einer Quelldatei)\\n\\n Argumente, die auf die Hauptklasse, die Quelldatei, -jar <JAR-Datei>, -m oder --module\\n <Modul>\/<Hauptklasse> folgen, werden als Argumente fr die\\nHauptklasse bergeben.\\n\\n Dabei umfasst \"Optionen\" Folgendes:\\n\\n\n+java.launcher.opt.header  =   Verwendung: {0} [Optionen] <Hauptklasse> [Argumente...]\\n           (zur Ausfhrung einer Klasse)\\n   oder {0} [Optionen] -jar <JAR-Datei>.jar [Argumente...]\\n           (zur Ausfhrung einer JAR-Datei)\\n   oder {0} [Optionen] -m <Modul>[\/<Hauptklasse>] [Argumente...]\\n       {0} [Optionen] --module <Modul>[\/<Hauptklasse>] [Argumente...]\\n            (zur Ausfhrung der Hauptklasse in einem Modul)\\n   oder {0} [Optionen] <Quelldatei>.java [Argumente]\\n           (zur Ausfhrung eines Programms mit einer Quelldatei)\\n\\n Argumente, die auf die Hauptklasse, die Quelldatei, -jar <JAR-Datei>.jar, -m oder --module\\n <Modul>\/<Hauptklasse> folgen, werden als Argumente fr die\\nHauptklasse bergeben.\\n\\n Dabei umfasst \"Optionen\" Folgendes:\\n\\n\n@@ -33,2 +33,2 @@\n-java.launcher.opt.footer = \\    -cp <Klassensuchpfad mit Verzeichnissen und ZIP-\/JAR-Dateien>\\n    -classpath <Klassensuchpfad mit Verzeichnissen und ZIP-\/JAR-Dateien>\\n    --class-path <Klassensuchpfad mit Verzeichnissen und ZIP-\/JAR-Dateien>\\n                  Eine durch {0} getrennte Liste mit Verzeichnissen, JAR-Archiven\\n                  und ZIP-Archiven, in denen nach Klassendateien gesucht wird.\\n    -p <Modulpfad>\\n    --module-path <Modulpfad>...\\n                  Eine durch {0} getrennte Liste mit Elementen, von denen jedes Element ein Dateipfad\\n                  zu einem Modul oder einem Verzeichnis mit Modulen ist. Jedes Modul ist entweder\\n                  ein modulares JAR oder ein entpacktes Modulverzeichnis.\\n    --upgrade-module-path <Modulpfad>...\\n                  Eine durch {0} getrennte Liste mit Elementen, von denen jedes Element ein Dateipfad\\n                  zu einem Modul oder einem Verzeichnis mit Modulen ist,\\n                  um upgradefhige Module im Laufzeitimage zu ersetzen. Jedes Modul ist entweder\\n                  ein modulares JAR oder ein entpacktes Modulverzeichnis.\\n    --add-modules <Modulname>[,<Modulname>...]\\n                  Root-Module, die zustzlich zum anfnglichen Modul aufgelst werden sollen.\\n                  <Modulname> kann auch wie folgt lauten: ALL-DEFAULT, ALL-SYSTEM,\\n                  ALL-MODULE-PATH.\\n    --enable-native-access <Modulname>[,<Modulname>...]\\n                  Damit kann der Code in Modulen auf Code und Daten auerhalb der JRE zugreifen.\\n                  <Modulname> kann auch ALL-UNNAMED sein, um den Code im Classpath anzugeben.\\n    --list-modules\\n                  Listet beobachtbare Module auf und beendet den Vorgang\\n    -d <Modulname>\\n    --describe-module <Modulname>\\n                  Beschreibt ein Modul und beendet den Vorgang\\n    --dry-run     Erstellt eine VM und ldt die Hauptklasse, fhrt aber nicht die Hauptmethode aus.\\n                  Die Option \"--dry-run\" kann ntzlich sein, um die\\n                  Befehlszeilenoptionen, wie die Modulsystemkonfiguration, zu validieren.\\n    --validate-modules\\n                  Validiert alle Module und beendet den Vorgang\\n                  Die Option \"--validate-modules\" kann ntzlich sein, um\\n                  Konflikte und andere Fehler mit Modulen auf dem Modulpfad zu ermitteln.\\n    -D<Name>=<Wert>\\n                  Legt eine Systemeigenschaft fest\\n    -verbose:[class|module|gc|jni]\\n                  Aktiviert die Verbose-Ausgabe fr das angegebene Subsystem\\n    -version      Gibt die Produktversion an den Fehlerstream aus und beendet den Vorgang\\n    --version      Gibt die Produktversion an den Outputstream aus und beendet den Vorgang\\n    -showversion  Gibt die Produktversion an den Fehlerstream aus und setzt den Vorgang fort\\n    --show-version\\n                  Gibt die Produktversion an den Outputstream aus und setzt den Vorgang fort\\n    --show-module-resolution\\n                  Zeigt die Modulauflsungsausgabe beim Start an\\n    -? -h -help\\n                  Gibt diese Hilfemeldung an den Fehlerstream aus\\n    --help        Gibt diese Hilfemeldung an den Outputstream aus\\n    -X            Gibt Hilfe zu zustzlichen Optionen an den Fehlerstream aus\\n    --help-extra  Gibt Hilfe zu zustzlichen Optionen an den Outputstream aus\\n    -ea[:<packagename>...|:<classname>]\\n    -enableassertions[:<packagename>...|:<classname>]\\n                  Aktiviert Assertions mit angegebener Granularitt\\n    -da[:<packagename>...|:<classname>]\\n    -disableassertions[:<packagename>...|:<classname>]\\n                  Deaktiviert Assertions mit angegebener Granularitt\\n    -esa | -enablesystemassertions\\n                  Aktiviert System-Assertions\\n    -dsa | -disablesystemassertions\\n                  Deaktiviert System-Assertions\\n    -agentlib:<libname>[=<options>]\\n                  Ldt die \\\n-native Agent Library <libname>. Beispiel: -agentlib:jdwp\\n                  siehe auch -agentlib:jdwp=help\\n    -agentpath:<pathname>[=<options>]\\n                  Ldt die native Agent Library mit dem vollstndigen Pfadnamen\\n    -javaagent:<jarpath>[=<options>]\\n                  Ldt den Java-Programmiersprachen-Agent, siehe java.lang.instrument\\n    -splash:<imagepath>\\n                  Zeigt den Startbildschirm mit einem angegebenen Bild an\\n                  Skalierte HiDPI-Bilder werden automatisch untersttzt und verwendet,\\n                  falls verfgbar. Der nicht skalierte Bilddateiname (Beispiel: image.ext)\\n                  muss immer als Argument an die Option \"-splash\" bergeben werden.\\n                  Das am besten geeignete angegebene skalierte Bild wird\\n                  automatisch ausgewhlt.\\n                  Weitere Informationen finden Sie in der Dokumentation zur SplashScreen-API\\n    @argument files\\n                  Eine oder mehrere Argumentdateien mit Optionen\\n    --disable-@files\\n                  Verhindert die weitere Erweiterung von Argumentdateien\\n    --enable-preview\\n                  Lsst zu, das Klassen von Vorschaufeatures dieses Release abhngig sind\\nUm ein Argument fr eine lange Option anzugeben, knnen Sie --<Name>=<Wert> oder\\n--<Name> <Wert> verwenden.\\n\n+java.launcher.opt.footer = \\    -cp <Klassensuchpfad mit Verzeichnissen und ZIP-\/JAR-Dateien>\\n    -classpath <Klassensuchpfad mit Verzeichnissen und ZIP-\/JAR-Dateien>\\n    --class-path <Klassensuchpfad mit Verzeichnissen und ZIP-\/JAR-Dateien>\\n                  Eine durch \"{0}\" getrennte Liste mit Verzeichnissen, JAR-Archiven\\n                  und ZIP-Archiven, in denen nach Klassendateien gesucht wird.\\n    -p <Modulpfad>\\n    --module-path <Modulpfad>...\\n                  Eine durch \"{0}\" getrennte Liste mit Elementen, von denen jedes Element ein Dateipfad ist\\n                  zu einem Modul oder einem Verzeichnis mit Modulen ist. Jedes Modul ist entweder\\n                  ein modulares JAR oder ein entpacktes Modulverzeichnis.\\n    --upgrade-module-path <Modulpfad>...\\n                  Eine durch \"{0}\" getrennte Liste mit Elementen, von denen jedes Element ein Dateipfad ist\\n                  zu einem Modul oder einem Verzeichnis mit Modulen ist,\\n                  um upgradefhige Module im Laufzeitimage zu ersetzen. Jedes Modul ist entweder\\n                  ein modulares JAR oder ein entpacktes Modulverzeichnis.\\n    --add-modules <Modulname>[,<Modulname>...]\\n                  Root-Module, die zustzlich zum anfnglichen Modul aufgelst werden sollen.\\n                  <Modulname> kann auch wie folgt lauten: ALL-DEFAULT, ALL-SYSTEM,\\n                  ALL-MODULE-PATH.\\n    --enable-native-access <Modulname>[,<Modulname>...]\\n                  Damit kann der Code in Modulen auf Code und Daten auerhalb der JRE zugreifen.\\n                  <Modulname> kann auch ALL-UNNAMED sein, um den Code im Classpath anzugeben.\\n    --illegal-native-access=<Wert>\\n                  Zugriff auf Code und Daten auerhalb der JRE\\n                  durch Code in Modulen zulassen oder verweigern, fr die der native Zugriff nicht explizit aktiviert ist.\\n                  <Wert> ist \"deny\", \"warn\" oder \"allow\". Der Standardwert ist \"warn\".\\n                  Diese Option wird in einem zuknftigen Release entfernt.\\n    --list-modules\\n                  Listet beobachtbare Module auf und beendet den Vorgang\\n    -d <Modulname>\\n    --describe-module <Modulname>\\n                  Beschreibt ein Modul und beendet den Vorgang\\n    --dry-run     Erstellt eine VM und ldt die Hauptklasse, fhrt aber nicht die Hauptmethode aus.\\n                  Die Option \"--dry-run\" kann ntzlich sein, um die\\n                  Befehlszeilenoptionen, wie die Modulsystemkonfiguration, zu validieren.\\n    --validate-modules\\n                  Validiert alle Module und beendet den Vorgang\\n                  Die Option \"--validate-modules\" kann ntzlich sein, um\\n                  Konflikte und andere Fehler mit Modulen auf dem Modulpfad zu ermitteln.\\n    -D<Name>=<Wert>\\n                  Legt eine Systemeigenschaft fest\\n    -verbose:[class|module|gc|jni]\\n                  Aktiviert die Verbose-Ausgabe fr das angegebene Subsystem\\n    -version      Gibt die Produktversion an den Fehlerstream aus und beendet den Vorgang\\n    --version      Gibt die Produktversion an den Outputstream aus und beendet den Vorgang\\n    -showversion  Gibt die Produktversion an den Fehlerstream aus und setzt den Vorgang fort\\n    --show-version\\n                  Gibt die Produktversion an den Outputstream aus und setzt den Vorgang fort\\n    --show-module-resolution\\n                  Zeigt die Modulauflsungsausgabe beim Start an\\n    -? -h -help\\n                  Gibt diese Hilfemeldung an den Fehlerstream aus\\n    --help        Gibt diese Hilfemeldung an den Outputstream aus\\n    -X            Gibt Hilfe zu zustzlichen Optionen an den Fehlerstream aus\\n    --help-extra  Gibt Hilfe zu zustzlichen Optionen an den Outputstream aus\\n    -ea[:<packagename>...|:<classname>]\\n    -enableassertions[:<packagename>...|:<classname>]\\n                  Aktiviert Assertions mit angegebener \\\n+Granularitt\\n    -da[:<packagename>...|:<classname>]\\n    -disableassertions[:<packagename>...|:<classname>]\\n                  Deaktiviert Assertions mit angegebener Granularitt\\n    -esa | -enablesystemassertions\\n                  Aktiviert System-Assertions\\n    -dsa | -disablesystemassertions\\n                  Deaktiviert System-Assertions\\n    -agentlib:<libname>[=<options>]\\n                  Ldt die native Agent Library <libname>. Beispiel: -agentlib:jdwp\\n                  siehe auch -agentlib:jdwp=help\\n    -agentpath:<pathname>[=<options>]\\n                  Ldt die native Agent Library mit dem vollstndigen Pfadnamen\\n    -javaagent:<jarpath>[=<options>]\\n                  Ldt den Java-Programmiersprachen-Agent, siehe java.lang.instrument\\n    -splash:<imagepath>\\n                  Zeigt den Startbildschirm mit einem angegebenen Bild an\\n                  Skalierte HiDPI-Bilder werden automatisch untersttzt und verwendet,\\n                  falls verfgbar. Der nicht skalierte Bilddateiname (Beispiel: image.ext)\\n                  muss immer als Argument an die Option \"-splash\" bergeben werden.\\n                  Das am besten geeignete angegebene skalierte Bild wird\\n                  automatisch ausgewhlt.\\n                  Weitere Informationen finden Sie in der Dokumentation zur SplashScreen-API\\n    @argument files\\n                  Eine oder mehrere Argumentdateien mit Optionen\\n    --disable-@files\\n                  Verhindert die weitere Erweiterung von Argumentdateien\\n    --enable-preview\\n                  Lsst zu, das Klassen von Vorschaufeatures dieses Release abhngig sind\\nUm ein Argument fr eine lange Option anzugeben, knnen Sie --<Name>=<Wert> oder\\n--<Name> <Wert> verwenden.\\n\n@@ -37,2 +37,2 @@\n-java.launcher.X.usage=\\n    -Xbatch           Deaktiviert die Hintergrundkompilierung\\n    -Xbootclasspath\/a:<durch {0} getrennte Verzeichnisse und ZIP-\/JAR-Dateien>\\n                      An das Ende des Bootstrap Classpaths anhngen\\n    -Xcheck:jni       Fhrt zustzliche Prfungen fr JNI-Funktionen aus\\n    -Xcomp            Erzwingt die Kompilierung von Methoden beim ersten Aufruf\\n    -Xdebug           Fhrt keine Aktion aus. Ist veraltet und wird in einem zuknftigen Release entfernt.\\n    -Xdiag            Zeigt zustzliche Diagnosemeldungen an\\n    -Xfuture          Aktiviert strengste Prfungen, als mglicher zuknftiger Standardwert erwartet.\\n                      Diese Option ist veraltet und kann in einem\\n                      zuknftigen Release entfernt werden.\\n    -Xint             Nur Ausfhrung im interpretierten Modus\\n    -Xinternalversion\\n                      Zeigt detailliertere JVM-Versionsinformationen an als die\\n                      Option -version\\n    -Xlog:<Optionen>      Konfiguriert oder aktiviert Logging mit dem einheitlichen Java Virtual\\n                      Machine-(JVM-)Logging-Framework. Verwenden Sie -Xlog:help\\n                      fr weitere Einzelheiten.\\n    -Xloggc:<Datei>    Protokolliert den GC-Status in einer Datei mit Zeitstempeln.\\n                      Diese Option ist veraltet und kann in einem\\n                      zuknftigen Release entfernt werden. Wird durch -Xlog:gc:<Datei> ersetzt.\\n    -Xmixed           Ausfhrung im gemischten Modus (Standard)\\n    -Xmn<Gre>        Legt die anfngliche und maximale Gre (in Byte) des Heaps\\n                      fr die Young Generation (Nursery) fest\\n    -Xms<Gre>        Legt die anfngliche Java-Heap-Gre fest\\n    -Xmx<Gre>        Legt die maximale Java-Heap-Gre fest\\n    -Xnoclassgc       Deaktiviert die Klassen-Garbage Collection\\n    -Xrs               Reduziert die Verwendung von BS-Signalen durch Java\/VM (siehe Dokumentation)\\n    -Xshare:auto      Verwendet freigegebene Klassendaten, wenn mglich (Standard)\\n    -Xshare:off       Versucht nicht, freigegebene Klassendaten zu verwenden\\n    -Xshare:on        Erfordert die Verwendung freigegebener Klassendaten, verluft sonst nicht erfolgreich.\\n                      Diese Testoption kann zeitweise zu\\n                      Fehlern fhren. Sie darf nicht in Produktionsumgebungen verwendet werden.\\n    -XshowSettings    Zeigt alle Einstellungen an und fhrt fort\\n    -XshowSettings:all\\n                      Zeigt alle Einstellungen als Verbose-Ausgabe an und fhrt fort\\n    -XshowSettings:locale\\n                      Zeigt alle gebietsschemabezogenen Einstellungen an und fhrt fort\\n    -XshowSettings:properties\\n                      Zeigt alle Eigenschaftseinstellungen an und fhrt fort\\n    -XshowSettings:vm\\n                      Zeigt alle VM-bezogenen Einstellungen an und fhrt fort\\n    -XshowSettings:security\\n                      Zeigt alle Sicherheitseinstellungen an und fhrt fort\\n    -XshowSettings:security:all\\n                      Zeigt alle Sicherheitseinstellungen an und fhrt fort\\n    -XshowSettings:security:properties\\n                      Zeigt Sicherheitseigenschaften an und fhrt fort\\n    -XshowSettings:security:providers\\n                      Zeigt statische Sicherheitsprovidereinstellungen an und fhrt fort\\n    -XshowSettings:security:tls\\n                      Zeigt TLS-bezogene Sicherheitseinstellungen an und fhrt fort\\n    -XshowSettings:system\\n                      (Nur Linux) Zeigt die Konfiguration des Hostsystems oder Containers an\\n                      und fhrt fort\\n    -Xss<Gre>        Legt die Stackgre des Java-Threads fest\\n                      Die tatschliche \\\n-Gre kann auf ein Vielfaches der\\n                      Systemseitengre aufgerundet werden, wenn fr das Betriebssystem erforderlich.\\n    -Xverify          Legt den Modus der Bytecodeverifizierung fest\\n                      Beachten Sie, dass die Option -Xverify:none veraltet ist und\\n                      in einem zuknftigen Release entfernt werden kann.\\n    --add-reads <Modul>=<Zielmodul>(,<Zielmodul>)*\\n                      Aktualisiert <Modul>, damit <Zielmodul> gelesen wird, ungeachtet\\n                      der Moduldeklaration. \\n                      <Zielmodul> kann ALL-UNNAMED sein, um alle unbenannten\\n                      Module zu lesen.\\n    --add-exports <Modul>\/<Package>=<Zielmodul>(,<Zielmodul>)*\\n                      Aktualisiert <Modul>, um <Package> in <Zielmodul> zu exportieren,\\n                      ungeachtet der Moduldeklaration.\\n                      <Zielmodul> kann ALL-UNNAMED sein, um in alle\\n                      unbenannten Module zu exportieren.\\n    --add-opens <Modul>\/<Package>=<Zielmodul>(,<Zielmodul>)*\\n                      Aktualisiert <Modul>, um <Package> in\\n                      <Zielmodul> zu ffnen, ungeachtet der Moduldeklaration.\\n    --limit-modules <Modulname>[,<Modulname>...]\\n                      Grenzt die Gesamtmenge der beobachtbaren Module ein\\n    --patch-module <Modul>=<Datei>({0}<Datei>)*\\n                      berschreibt oder erweitert ein Modul mit Klassen und Ressourcen\\n                      in JAR-Dateien oder Verzeichnissen.\\n    --source <Version>\\n                      Legt die Version der Quelle im Quelldateimodus fest.\\n    --finalization=<Wert>\\n                      Steuert, ob die JVM Objekte finalisiert.\\n                      Dabei ist <Wert> entweder \"enabled\" oder \"disabled\".\\n                      Die Finalisierung ist standardmig aktiviert.\\n    --sun-misc-unsafe-memory-access=<value>\\n                      Verwendung der nicht untersttzten API sun.misc.Unsafe zulassen oder verweigern\\n                      <value> ist \"allow\", \"warn\", \"debug\" oder \"deny\".\\n                      Der Standardwert ist \"allow\".\\n\\nDiese zustzlichen Optionen knnen jederzeit ohne vorherige Ankndigung gendert werden.\\n\n+java.launcher.X.usage=\\n    -Xbatch           Deaktiviert die Hintergrundkompilierung\\n    -Xbootclasspath\/a:<durch {0} getrennte Verzeichnisse und ZIP-\/JAR-Dateien>\\n                      An das Ende des Bootstrap Classpaths anhngen\\n    -Xcheck:jni       Fhrt zustzliche Prfungen fr JNI-Funktionen aus\\n    -Xcomp            Erzwingt die Kompilierung von Methoden beim ersten Aufruf\\n    -Xdebug           Fhrt keine Aktion aus. Ist veraltet und wird in einem zuknftigen Release entfernt.\\n    -Xdiag            Zeigt zustzliche Diagnosemeldungen an\\n    -Xint             Nur Ausfhrung im interpretierten Modus\\n    -Xinternalversion\\n                      Zeigt detailliertere JVM-Versionsinformationen an als die\\n                      Option -version\\n    -Xlog:<Optionen>      Konfiguriert oder aktiviert Logging mit dem einheitlichen Java Virtual\\n                      Machine-(JVM-)Logging-Framework. Verwenden Sie -Xlog:help\\n                      fr weitere Einzelheiten.\\n    -Xloggc:<Datei>    Protokolliert den GC-Status in einer Datei mit Zeitstempeln.\\n                      Diese Option ist veraltet und kann in einem\\n                      zuknftigen Release entfernt werden. Wird durch -Xlog:gc:<Datei> ersetzt.\\n    -Xmixed           Ausfhrung im gemischten Modus (Standard)\\n    -Xmn<Gre>        Legt die anfngliche und maximale Gre (in Byte) des Heaps\\n                      fr die Young Generation (Nursery) fest\\n    -Xms<Gre>        Legt die anfngliche Java-Heap-Gre fest\\n    -Xmx<Gre>        Legt die maximale Java-Heap-Gre fest\\n    -Xnoclassgc       Deaktiviert die Klassen-Garbage Collection\\n    -Xrs               Reduziert die Verwendung von BS-Signalen durch Java\/VM (siehe Dokumentation)\\n    -Xshare:auto      Verwendet freigegebene Klassendaten, wenn mglich (Standard)\\n    -Xshare:off       Versucht nicht, freigegebene Klassendaten zu verwenden\\n    -Xshare:on        Erfordert die Verwendung freigegebener Klassendaten, verluft sonst nicht erfolgreich.\\n                      Diese Testoption kann zeitweise zu\\n                      Fehlern fhren. Sie darf nicht in Produktionsumgebungen verwendet werden.\\n    -XshowSettings    Zeigt alle Einstellungen an und fhrt fort\\n    -XshowSettings:all\\n                      Zeigt alle Einstellungen als Verbose-Ausgabe an und fhrt fort\\n    -XshowSettings:locale\\n                      Zeigt alle gebietsschemabezogenen Einstellungen an und fhrt fort\\n    -XshowSettings:properties\\n                      Zeigt alle Eigenschaftseinstellungen an und fhrt fort\\n    -XshowSettings:vm\\n                      Zeigt alle VM-bezogenen Einstellungen an und fhrt fort\\n    -XshowSettings:security\\n                      Zeigt alle Sicherheitseinstellungen an und fhrt fort\\n    -XshowSettings:security:all\\n                      Zeigt alle Sicherheitseinstellungen an und fhrt fort\\n    -XshowSettings:security:properties\\n                      Zeigt Sicherheitseigenschaften an und fhrt fort\\n    -XshowSettings:security:providers\\n                      Zeigt statische Sicherheitsprovidereinstellungen an und fhrt fort\\n    -XshowSettings:security:tls\\n                      Zeigt TLS-bezogene Sicherheitseinstellungen an und fhrt fort\\n    -XshowSettings:system\\n                      (Nur Linux) Zeigt die Konfiguration des Hostsystems oder Containers an\\n                      und fhrt fort\\n    -Xss<Gre>        Legt die Stackgre des Java-Threads fest\\n                      Die tatschliche Gre kann auf ein Vielfaches der\\n                      Systemseitengre aufgerundet werden, wenn fr das Betriebssystem erforderlich.\\n    -Xverify          Legt den Modus der Bytecodeverifizierung fest\\n                  \\\n+    Beachten Sie, dass die Option -Xverify:none veraltet ist und\\n                      in einem zuknftigen Release entfernt werden kann.\\n    --add-reads <Modul>=<Zielmodul>(,<Zielmodul>)*\\n                      Aktualisiert <Modul>, damit <Zielmodul> gelesen wird, ungeachtet\\n                      der Moduldeklaration. \\n                      <Zielmodul> kann ALL-UNNAMED sein, um alle unbenannten\\n                      Module zu lesen.\\n    --add-exports <Modul>\/<Package>=<Zielmodul>(,<Zielmodul>)*\\n                      Aktualisiert <Modul>, um <Package> in <Zielmodul> zu exportieren,\\n                      ungeachtet der Moduldeklaration.\\n                      <Zielmodul> kann ALL-UNNAMED sein, um in alle\\n                      unbenannten Module zu exportieren.\\n    --add-opens <Modul>\/<Package>=<Zielmodul>(,<Zielmodul>)*\\n                      Aktualisiert <Modul>, um <Package> in\\n                      <Zielmodul> zu ffnen, ungeachtet der Moduldeklaration.\\n    --limit-modules <Modulname>[,<Modulname>...]\\n                      Grenzt die Gesamtmenge der beobachtbaren Module ein\\n    --patch-module <Modul>=<Datei>({0}<Datei>)*\\n                      berschreibt oder erweitert ein Modul mit Klassen und Ressourcen\\n                      in JAR-Dateien oder Verzeichnissen.\\n    --source <Version>\\n                      Legt die Version der Quelle im Quelldateimodus fest.\\n    --finalization=<Wert>\\n                      Steuert, ob die JVM Objekte finalisiert.\\n                      Dabei ist <Wert> entweder \"enabled\" oder \"disabled\".\\n                      Die Finalisierung ist standardmig aktiviert.\\n    --sun-misc-unsafe-memory-access=<value>\\n                      Verwendung der nicht untersttzten API sun.misc.Unsafe zulassen oder verweigern\\n                      <value> ist \"allow\", \"warn\", \"debug\" oder \"deny\".\\n                      Der Standardwert ist \"warn\".\\n\\nDiese zustzlichen Optionen knnen jederzeit ohne vorherige Ankndigung gendert werden.\\n\n@@ -43,0 +43,3 @@\n+# Translators please note do not translate the options themselves\n+java.launcher.opt.concise.header  =   Verwendung: java [Java-Optionen...] <Anwendung> [Anwendungsargumente...]\\n\\nDabei ist <Anwendung> einer der folgenden Werte:\\n  <Hauptklasse>                Zum Ausfhren der Hauptmethode einer kompilierten Hauptklasse\\n  -jar <JAR-Datei>.jar         Zum Ausfhren der Hauptklasse eines JAR-Archivs\\n  -m <Modul>[\/<Hauptklasse>] Zum Ausfhren der Hauptklasse eines Moduls\\n  <Quelldatei>.java          Zum Kompilieren und Ausfhren eines Quelldateiprogramms\\n\\nDabei sind die folgenden wichtigen Java-Optionen verfgbar:\\n  --class-path <Classpath>\\n    <Classpath> ist eine durch \"{0}\" getrennte Liste der Verzeichnisse und JAR-Archive, in denen nach Klassendateien gesucht werden soll\\n  --module-path <Modulpfad>\\n    <Modulpfad> ist eine durch \"{0}\" getrennte Liste der Verzeichnisse und JAR-Archive, in denen nach Modulen gesucht werden soll\\n  -version\\n    Zum Ausgeben der Produktversion in den Fehlerstream und Beenden des Vorgangs\\n\\nFr weitere Verwendungshilfe:           java --help\\nFr eine interaktive Java-Umgebung:    jshell\n+\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher_de.properties","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-java.launcher.opt.header  =   : {0} [options] <mainclass> [args...]\\n           ()\\n     {0} [options] -jar <jarfile> [args...]\\n           (jar)\\n     {0} [options] -m <module>[\/<mainclass>] [args...]\\n       {0} [options] --module <module>[\/<mainclass>] [args...]\\n           ()\\n     {0} [options] <sourcefile> [args]\\n           ()\\n\\n -jar <jarfile>\\n -m--module <module>\/<mainclass>\\n \\n\\n :\\n\\n\n+java.launcher.opt.header  =   : {0} [options] <mainclass> [args...]\\n           ()\\n     {0} [options] -jar <jarfile>.jar [args...]\\n           (jar)\\n     {0} [options] -m <module>[\/<mainclass>] [args...]\\n       {0} [options] --module <module>[\/<mainclass>] [args...]\\n           ()\\n     {0} [options] <sourcefile>.java [args]\\n           ()\\n\\n -jar <jarfile>.jar\\n-m--module <module>\/<mainclass>\\n\\n\\n :\\n\\n\n@@ -33,3 +33,3 @@\n-java.launcher.opt.footer = \\    -cp <zip\/jar>\\n    -classpath <zip\/jar>\\n    --class-path <zip\/jar>\\n                  {0}(JAR\\n                  ZIP)\\n    -p <module path>\\n    --module-path <module path>...\\n                  {0}:\\n                  :\\n                  JAR\\n    --upgrade-module-path <module path>...\\n                  {0}:\\n                  :\\n                  :\\n                  JAR\\n    --add-modules <module name>[,<module name>...]\\n                  \\n                  <module name>: ALL-DEFAULTALL-SYSTEM\\n                  ALL-MODULE-PATH.\\n    --enable-native-access <module name>[,<module name>...]\\n                  Java\\n                  <module name>ALL-UNNAMED\\n    --list-modules\\n                  \\n    -d <module name>\\n    --describe-module <module name>\\n                  \\n    --dry-run     VM\\n                  \\\n---dry-run:\\n                  \\n    --validate-modules\\n                  \\n                  --validate-modules:\\n                  \\n    -D<name>=<value>\\n                  \\n    -verbose:[class|module|gc|jni]\\n                  \\n    -version      \\n    --version     \\n    -showversion  \\n    --show-version\\n                  \\n    --show-module-resolution\\n                  \\n    -? -h -help\\n                  \\n    --help        \\n    -X            \\n    --help-extra  \\n    -ea[:<packagename>...|:<classname>]\\n    -enableassertions[:<packagename>...|:<classname>]\\n                  \\n    -da[:<packagename>...|:<classname>]\\n    -disableassertions[:<packagename>...|:<classname>]\\n                  \\n    -esa | -enablesystemassertions\\n                  \\n    -dsa | -disablesystemassertions\\n                  \\n    -agentlib:<libname>[=<options>]\\n                  <libname>: -agentlib:jdwp\\n                  -agentlib:jdwp=help\\n    -agentpath:<pathname>[=<options>]\\n                  \\\n-\\n    -javaagent:<jarpath>[=<options>]\\n                  Javajava.lang.instrument\\n    -splash:<imagepath>\\n                  \\n                  HiDPI\\n                  ()(image.ext)\\n                  -splash\\n                  \\n                  ()\\n                  SplashScreen API\\n    @argument\\n                  1\\n    --disable-@files\\n                  \\n    --enable-preview\\n                  \\n--<name>=<value>\\n--<name> <value>\\n\n+java.launcher.opt.footer = \\    -cp <zip\/jar>\\n    -classpath <zip\/jar>\\n    --class-path <zip\/jar>\\n                  \"{0}\"(JAR\\n                  ZIP)\\n    -p <module path>\\n    --module-path <module path>...\\n                  \"{0}\":\\n                  :\\n                  JAR\\n    --upgrade-module-path <module path>...\\n                  \"{0}\":\\n                  :\\n                  :\\n                  JAR\\n    --add-modules <module name>[,<module name>...]\\n                  \\n                  <module name>: ALL-DEFAULTALL-SYSTEM\\n                  ALL-MODULE-PATH.\\n    --enable-native-access <module name>[,<module name>...]\\n                  Java\\n                  <module name>ALL-UNNAMED\\n    --illegal-native-access=<value>\\n                  Java\\n                  ()\\n                  \\\n+<value>\"deny\"\"warn\"\"allow\"\"warn\"\\n                  \\n    --list-modules\\n                  \\n    -d <module name>\\n    --describe-module <module name>\\n                  \\n    --dry-run     VM\\n                  --dry-run:\\n                  \\n    --validate-modules\\n                  \\n                  --validate-modules:\\n                  \\n    -D<name>=<value>\\n                  \\n    -verbose:[class|module|gc|jni]\\n                  \\n    -version      \\n    --version     \\n    -showversion  \\n    --show-version\\n                  \\n    --show-module-resolution\\n                  \\n    -? -h -help\\n                  \\n    --help        \\n    -X            \\n    --help-extra  \\n    -ea[:<packagename>...|:<classname>]\\n    -enableassertions[:<packagename>...|:<classname>]\\n                  \\n    -da[:<packagename>...|:<classname>]\\n    \\\n+-disableassertions[:<packagename>...|:<classname>]\\n                  \\n    -esa | -enablesystemassertions\\n                  \\n    -dsa | -disablesystemassertions\\n                  \\n    -agentlib:<libname>[=<options>]\\n                  <libname>: -agentlib:jdwp\\n                  -agentlib:jdwp=help\\n    -agentpath:<pathname>[=<options>]\\n                  \\n    -javaagent:<jarpath>[=<options>]\\n                  Javajava.lang.instrument\\n    -splash:<imagepath>\\n                  \\n                  HiDPI\\n                  ()(image.ext)\\n                  -splash\\n                  \\n                  ()\\n                  SplashScreen API\\n    @argument\\n                  1\\n    --disable-@files\\n                  \\n    --enable-preview\\n                  \\n--<name>=<value>\\n--<name> <value>\\n\n@@ -38,3 +38,3 @@\n-java.launcher.X.usage=\\n    -Xbatch           \\n    -Xbootclasspath\/a:<directories and zip\/jar files separated by {0}>\\n                      \\n    -Xcheck:jni       JNI\\n    -Xcomp            \\n    -Xdebug           \\n    -Xdiag            \\n    -Xfuture          \\n                      \\n                      \\n    -Xint             \\n    -Xinternalversion\\n                      -versionJVM\\n                      \\n    -Xlog:<opts>      Java Virtual Machine (JVM)\\n                      -Xlog:help\\n                      \\n    -Xloggc:<file>    GC\\n                      \\n                      -Xlog:gc:<file>\\n    -Xmixed           ()\\n    -Xmn<size>        ()\\n                      ()\\n    -Xms<size>        Java\\n    -Xmx<size>        Java\\n    -Xnoclassgc       \\n    -Xrs              Java\/VMOS()\\n    -Xshare:auto      ()\\n    -Xshare:off       \\\n-\\n    -Xshare:on        \\n                      \\n                      \\n    -XshowSettings    \\n    -XshowSettings:all\\n                      \\n    -XshowSettings:locale\\n                      \\n    -XshowSettings:properties\\n                      \\n    -XshowSettings:vm\\n                      VM\\n    -XshowSettings:security\\n                      \\n    -XshowSettings:security:all\\n                      \\n    -XshowSettings:security:properties\\n                      \\n    -XshowSettings:security:providers\\n                      \\n    -XshowSettings:security:tls\\n                      TLS\\n    -XshowSettings:system\\n                      (Linux)\\n                      \\n    -Xss<size>        java\\n                      : \\n                      \\n    -Xverify          \\n                      -Xverify:none\\n                      \\n    --add-reads <module>=<target-module>(,<target-module>)*\\n                      <module><target-module>\\n                      \\\n- \\n                      <target-module>ALL-UNNAMED\\n                      \\n    --add-exports <module>\/<package>=<target-module>(,<target-module>)*\\n                      <module><package><target-module>\\n                      \\n                      <target-module>ALL-UNNAMED\\n                      \\n    --add-opens <module>\/<package>=<target-module>(,<target-module>)*\\n                      <module><package>\\n                      <target-module>\\n    --limit-modules <module name>[,<module name>...]\\n                      \\n    --patch-module <module>=<file>({0}<file>)*\\n                      JAR\\n                      \\n    --source <version>\\n                      \\n    --finalization=<value>\\n                      JVM\\n                      <value>\"enabled\"\"disabled\"\\n                      \\n    --sun-misc-unsafe-memory-access=<value>\\n                      API sun.misc.Unsafe\\n                      <value>\"allow\"\"warn\"\"debug\"\"deny\"\\n                      \"allow\"\\n\\n\\n\n+java.launcher.X.usage=\\n    -Xbatch           \\n    -Xbootclasspath\/a:<directories and zip\/jar files separated by {0}>\\n                      \\n    -Xcheck:jni       JNI\\n    -Xcomp            \\n    -Xdebug           \\n    -Xdiag            \\n    -Xint             \\n    -Xinternalversion\\n                      -versionJVM\\n                      \\n    -Xlog:<opts>      Java Virtual Machine (JVM)\\n                      -Xlog:help\\n                      \\n    -Xloggc:<file>    GC\\n                      \\n                      -Xlog:gc:<file>\\n    -Xmixed           ()\\n    -Xmn<size>        ()\\n                      ()\\n    -Xms<size>        Java\\n    -Xmx<size>        Java\\n    -Xnoclassgc       \\n    -Xrs              Java\/VMOS()\\n    -Xshare:auto      ()\\n    -Xshare:off       \\n    -Xshare:on        \\n                      \\\n+\\n                      \\n    -XshowSettings    \\n    -XshowSettings:all\\n                      \\n    -XshowSettings:locale\\n                      \\n    -XshowSettings:properties\\n                      \\n    -XshowSettings:vm\\n                      VM\\n    -XshowSettings:security\\n                      \\n    -XshowSettings:security:all\\n                      \\n    -XshowSettings:security:properties\\n                      \\n    -XshowSettings:security:providers\\n                      \\n    -XshowSettings:security:tls\\n                      TLS\\n    -XshowSettings:system\\n                      (Linux)\\n                      \\n    -Xss<size>        java\\n                      : \\n                      \\n    -Xverify          \\n                      -Xverify:none\\n                      \\n    --add-reads <module>=<target-module>(,<target-module>)*\\n                      <module><target-module>\\n                       \\n                      <target-module>ALL-UNNAMED\\n                      \\n    --add-exports \\\n+<module>\/<package>=<target-module>(,<target-module>)*\\n                      <module><package><target-module>\\n                      \\n                      <target-module>ALL-UNNAMED\\n                      \\n    --add-opens <module>\/<package>=<target-module>(,<target-module>)*\\n                      <module><package>\\n                      <target-module>\\n    --limit-modules <module name>[,<module name>...]\\n                      \\n    --patch-module <module>=<file>({0}<file>)*\\n                      JAR\\n                      \\n    --source <version>\\n                      \\n    --finalization=<value>\\n                      JVM\\n                      <value>\"enabled\"\"disabled\"\\n                      \\n    --sun-misc-unsafe-memory-access=<value>\\n                      API sun.misc.Unsafe\\n                      <value>\"allow\"\"warn\"\"debug\"\"deny\"\\n                      \"warn\"\\n\\n\\n\n@@ -45,0 +45,3 @@\n+# Translators please note do not translate the options themselves\n+java.launcher.opt.concise.header  =   : java [java options...] <application> [application arguments...]\\n\\n<application>:\\n  <mainclass>                \\n  -jar <jarfile>.jar         JAR\\n  -m <module>[\/<mainclass>]  \\n  <sourcefile>.java          \\n\\njava:\\n  --class-path <class path>\\n    <class path>JAR\"{0}\"\\n  --module-path <module path>\\n    <module path>JAR\"{0}\"\\n  -version\\n    \\n\\n:           java --help\\nJava:    jshell\n+\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher_ja.properties","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-java.launcher.opt.header  =   {0} [options] <mainclass> [args...]\\n           \\n     {0} [options] -jar <jarfile> [args...]\\n            jar \\n     {0} [options] -m <module>[\/<mainclass>] [args...]\\n       {0} [options] --module <module>[\/<mainclass>] [args...]\\n           \\n     {0} [options] <sourcefile> [args]\\n           \\n\\n -jar <jarfile>-m \\n --module <module>\/<mainclass> \\n \\n\\n \\n\\n\n+java.launcher.opt.header  =   {0} [options] <mainclass> [args...]\\n           \\n     {0} [options] -jar <jarfile>.jar [args...]\\n            jar \\n     {0} [options] -m <module>[\/<mainclass>] [args...]\\n       {0} [options] --module <module>[\/<mainclass>] [args...]\\n           \\n     {0} [options] <sourcefile>.java [args]\\n           \\n\\n -jar <jarfile>.jar-m \\n --module <module>\/<mainclass> \\n \\n\\n \\n\\n\n@@ -33,2 +33,2 @@\n-java.launcher.opt.footer = \\    -cp < zip\/jar >\\n    -classpath < zip\/jar >\\n    --class-path < zip\/jar >\\n                   {0} , , JAR \\n                   ZIP \\n    -p <>\\n    --module-path <>...\\n                  {0} \\n                  \\n                   JAR \\n    --upgrade-module-path <>...\\n                  {0} \\n                  \\n                  \\n                   JAR \\n    --add-modules <>[,<>...]\\n                  \\n                  <>  ALL-DEFAULT, ALL-SYSTEM,\\n                  ALL-MODULE-PATH.\\n    --enable-native-access <module name>[,<module name>...]\\n                   Java \\n                  <module name>  ALL-UNNAMED\\n    --list-modules\\n                  \\n    -d <module name>\\n    --describe-module <>\\n                  \\n    --dry-run      VM ,  main \\n                   --dry-run \\n                  \\n    --validate-modules\\n                  \\n                  --validate-modules \\n                  \\n    -D<>=<>\\n                  \\n    -verbose:[class|module|gc|jni]\\n                  \\n    -version      \\n    --version     \\n    -showversion  \\n    --show-version\\n                  \\n    --show-module-resolution\\n                  \\n    -? -h -help\\n                  \\n    --help        \\\n-\\n    -X            \\n    --help-extra  \\n    -ea[:<>...|:<>]\\n    -enableassertions[:<>...|:<>]\\n                  \\n    -da[:<>...|:<>]\\n    -disableassertions[:<>...|:<>]\\n                  \\n    -esa | -enablesystemassertions\\n                  \\n    -dsa | -disablesystemassertions\\n                  \\n    -agentlib:<>[=<>]\\n                   <>,  -agentlib:jdwp\\n                   -agentlib:jdwp=help\\n    -agentpath:<>[=<>]\\n                  \\n    -javaagent:<jar >[=<>]\\n                   Java ,  java.lang.instrument\\n    -splash:<>\\n                  \\n                   HiDPI \\n                  () (, image.ext)\\n                   -splash \\n                  \\n                  \\n                  ,  SplashScreen API \\n    @argument \\n                  \\n    --disable-@files\\n                  \\n    --enable-preview\\n                  \\n,  --<>=<> \\n--<> <>\\n\n+java.launcher.opt.footer = \\    -cp < zip\/jar >\\n    -classpath < zip\/jar >\\n    --class-path < zip\/jar >\\n                   \"{0}\" JAR \\n                   ZIP \\n    -p <>\\n    --module-path <>...\\n                   \"{0}\" \\n                  \\n                   JAR \\n    --upgrade-module-path <>...\\n                   \"{0}\" \\n                  \\n                  \\n                   JAR \\n    --add-modules <>[,<>...]\\n                  \\n                  <>  ALL-DEFAULT, ALL-SYSTEM,\\n                  ALL-MODULE-PATH.\\n    --enable-native-access <module name>[,<module name>...]\\n                   Java \\n                  <module name>  ALL-UNNAMED\\n    --illegal-native-access=<value>\\n                  \\n                   Java \\n                  <value>  \"deny\"\"warn\"  \"allow\"  \"warn\"\\n                  \\n    --list-modules\\n                  \\n    -d <module name>\\n    --describe-module <>\\n                  \\n    --dry-run      VM ,  main \\n                   --dry-run \\n                  \\n    --validate-modules\\n                  \\n                  --validate-modules \\n                  \\n    -D<>=<>\\n                  \\n    -verbose:[class|module|gc|jni]\\n                  \\n    -version      \\n    --version     \\\n+\\n    -showversion  \\n    --show-version\\n                  \\n    --show-module-resolution\\n                  \\n    -? -h -help\\n                  \\n    --help        \\n    -X            \\n    --help-extra  \\n    -ea[:<>...|:<>]\\n    -enableassertions[:<>...|:<>]\\n                  \\n    -da[:<>...|:<>]\\n    -disableassertions[:<>...|:<>]\\n                  \\n    -esa | -enablesystemassertions\\n                  \\n    -dsa | -disablesystemassertions\\n                  \\n    -agentlib:<>[=<>]\\n                   <>,  -agentlib:jdwp\\n                   -agentlib:jdwp=help\\n    -agentpath:<>[=<>]\\n                  \\n    -javaagent:<jar >[=<>]\\n                   Java ,  java.lang.instrument\\n    -splash:<>\\n                  \\n                   HiDPI \\n                  () (, image.ext)\\n                   -splash \\n                  \\n                  \\n                  ,  SplashScreen API \\n    @argument \\n                  \\n    --disable-@files\\n                  \\n    --enable-preview\\n                  \\n,  --<>=<> \\n--<> <>\\n\n@@ -37,2 +37,2 @@\n-java.launcher.X.usage=\\n    -Xbatch           \\n    -Xbootclasspath\/a:< {0}  zip\/jar >\\n                      \\n    -Xcheck:jni        JNI \\n    -Xcomp            \\n    -Xdebug           \\n    -Xdiag            \\n    -Xfuture          \\n                      \\n                      \\n    -Xint             \\n    -Xinternalversion\\n                       -version \\n                      JVM \\n    -Xlog:<opts>       Java \\n                       (Java Virtual Machine, JVM)  -Xlog:help\\n                      \\n    -Xloggc:<file>     GC \\n                      \\n                       -Xlog:gc:<file>\\n    -Xmixed           \\n    -Xmn<size>        \\n                      \\n    -Xms<size>         Java \\n    -Xmx<size>         Java \\n    -Xnoclassgc       \\n    -Xrs               Java\/VM \\n    -Xshare:auto      \\n    -Xshare:off       \\n    -Xshare:on        \\n                      \\n                      \\n    -XshowSettings    \\n    -XshowSettings:all\\n                      \\n    -XshowSettings:locale\\n                      \\n    -XshowSettings:properties\\n                      \\n    -XshowSettings:vm\\n                       vm \\n    -XshowSettings:security\\n                      \\n    -XshowSettings:security:all\\n                      \\n    -XshowSettings:security:properties\\n                     \\\n- \\n    -XshowSettings:security:providers\\n                      \\n    -XshowSettings:security:tls\\n                       TLS \\n    -XshowSettings:system\\n                       Linux\\n                      \\n    -Xss<size>         Java \\n                      \\n                      \\n    -Xverify          \\n                       -Xverify:none \\n                      \\n    --add-reads <module>=<target-module>(,<target-module>)*\\n                       <module>  <target-module>\\n                       \\n                      <target-module>  ALL-UNNAMED\\n                      \\n    --add-exports <module>\/<package>=<target-module>(,<target-module>)*\\n                       <module>  <package>  <target-module>\\n                      \\n                      <target-module>  ALL-UNNAMED\\n                      \\n    --add-opens <module>\/<package>=<target-module>(,<target-module>)*\\n                       <module>  <target-module> \\n                      <package>\\n    --limit-modules <module name>[,<module name>...]\\n                      \\n    --patch-module <module>=<file>({0}<file>)*\\n                       JAR \\n                      \\n    --source <version>\\n                      \\n    --finalization=<value>\\n                       JVM \\n                       <value>  \"enabled\"  \"disabled\" \\n                      \\n    --sun-misc-unsafe-memory-access=<value>\\n                       API sun.misc.Unsafe\\n                      <value>  \"allow\"\"warn\"\"debug\"  \"deny\" \\n                       \"allow\"\\n\\n, \\n\n+java.launcher.X.usage=\\n    -Xbatch           \\n    -Xbootclasspath\/a:< {0}  zip\/jar >\\n                      \\n    -Xcheck:jni        JNI \\n    -Xcomp            \\n    -Xdebug           \\n    -Xdiag            \\n    -Xint             \\n    -Xinternalversion\\n                       -version \\n                      JVM \\n    -Xlog:<opts>       Java \\n                       (Java Virtual Machine, JVM)  -Xlog:help\\n                      \\n    -Xloggc:<file>     GC \\n                      \\n                       -Xlog:gc:<file>\\n    -Xmixed           \\n    -Xmn<size>        \\n                      \\n    -Xms<size>         Java \\n    -Xmx<size>         Java \\n    -Xnoclassgc       \\n    -Xrs               Java\/VM \\n    -Xshare:auto      \\n    -Xshare:off       \\n    -Xshare:on        \\n                      \\n                      \\n    -XshowSettings    \\n    -XshowSettings:all\\n                      \\n    -XshowSettings:locale\\n                      \\n    -XshowSettings:properties\\n                      \\n    -XshowSettings:vm\\n                       vm \\n    -XshowSettings:security\\n                      \\n    -XshowSettings:security:all\\n                      \\n    -XshowSettings:security:properties\\n                      \\n    -XshowSettings:security:providers\\n                      \\n    -XshowSettings:security:tls\\n                       TLS \\\n+\\n    -XshowSettings:system\\n                       Linux\\n                      \\n    -Xss<size>         Java \\n                      \\n                      \\n    -Xverify          \\n                       -Xverify:none \\n                      \\n    --add-reads <module>=<target-module>(,<target-module>)*\\n                       <module>  <target-module>\\n                       \\n                      <target-module>  ALL-UNNAMED\\n                      \\n    --add-exports <module>\/<package>=<target-module>(,<target-module>)*\\n                       <module>  <package>  <target-module>\\n                      \\n                      <target-module>  ALL-UNNAMED\\n                      \\n    --add-opens <module>\/<package>=<target-module>(,<target-module>)*\\n                       <module>  <target-module> \\n                      <package>\\n    --limit-modules <module name>[,<module name>...]\\n                      \\n    --patch-module <module>=<file>({0}<file>)*\\n                       JAR \\n                      \\n    --source <version>\\n                      \\n    --finalization=<value>\\n                       JVM \\n                       <value>  \"enabled\"  \"disabled\" \\n                      \\n    --sun-misc-unsafe-memory-access=<value>\\n                       API sun.misc.Unsafe\\n                      <value>  \"allow\"\"warn\"\"debug\"  \"deny\" \\n                       \"warn\"\\n\\n, \\n\n@@ -43,0 +43,3 @@\n+# Translators please note do not translate the options themselves\n+java.launcher.opt.concise.header  =   java [java options...] <application> [application arguments...]\\n\\n<application> \\n  <mainclass>                 main \\n  -jar <jarfile>.jar          JAR \\n  -m <module>[\/<mainclass>]  \\n  <sourcefile>.java          \\n\\n java \\n  --class-path <class path>\\n    <class path>  JAR  \"{0}\" \\n  --module-path <module path>\\n    <module path>  JAR  \"{0}\" \\n  -version\\n    \\n\\n           java --help\\n Java     jshell\n+\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher_zh_CN.properties","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-    @SuppressWarnings(\"serial\")\n","filename":"src\/java.base\/share\/classes\/sun\/security\/internal\/interfaces\/TlsMasterSecret.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -152,1 +152,0 @@\n-    @SuppressWarnings(\"deprecation\")\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/ProviderConfig.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,2 +62,0 @@\n-        {\"invalid.null.AccessControlContext.provided\",\n-                \"Ung\\u00FCltiger Nullwert f\\u00FCr AccessControlContext angegeben\"},\n@@ -93,18 +91,0 @@\n-        \/\/ sun.security.provider.PolicyFile\n-\n-        {\"java.security.policy.error.parsing.policy.message\",\n-                \"java.security.policy: Fehler beim Parsen von {0}:\\n\\t{1}\"},\n-        {\"java.security.policy.error.adding.Permission.perm.message\",\n-                \"java.security.policy: Fehler beim Hinzuf\\u00FCgen von Berechtigung, {0}:\\n\\t{1}\"},\n-        {\"java.security.policy.error.adding.Entry.message\",\n-                \"java.security.policy: Fehler beim Hinzuf\\u00FCgen von Eintrag:\\n\\t{0}\"},\n-        {\"alias.name.not.provided.pe.name.\", \"Aliasname nicht angegeben ({0})\"},\n-        {\"unable.to.perform.substitution.on.alias.suffix\",\n-                \"Substitution f\\u00FCr Alias {0} kann nicht ausgef\\u00FChrt werden\"},\n-        {\"substitution.value.prefix.unsupported\",\n-                \"Substitutionswert {0} nicht unterst\\u00FCtzt\"},\n-        {\"SPACE\", \" \"},\n-        {\"LPARAM\", \"(\"},\n-        {\"RPARAM\", \")\"},\n-        {\"type.can.t.be.null\",\"Typ kann nicht null sein\"},\n-\n@@ -112,7 +92,0 @@\n-        {\"keystorePasswordURL.can.not.be.specified.without.also.specifying.keystore\",\n-                \"keystorePasswordURL kann nicht ohne Keystore angegeben werden\"},\n-        {\"expected.keystore.type\", \"Keystore-Typ erwartet\"},\n-        {\"expected.keystore.provider\", \"Keystore-Provider erwartet\"},\n-        {\"multiple.Codebase.expressions\",\n-                \"mehrere Codebase-Ausdr\\u00FCcke\"},\n-        {\"multiple.SignedBy.expressions\",\"mehrere SignedBy-Ausdr\\u00FCcke\"},\n@@ -121,6 +94,0 @@\n-        {\"SignedBy.has.empty.alias\",\"Leerer Alias in SignedBy\"},\n-        {\"can.not.specify.Principal.with.a.wildcard.class.without.a.wildcard.name\",\n-                \"Principal kann nicht mit einer Platzhalterklasse ohne Platzhalternamen angegeben werden\"},\n-        {\"expected.codeBase.or.SignedBy.or.Principal\",\n-                \"codeBase oder SignedBy oder Principal erwartet\"},\n-        {\"expected.permission.entry\", \"Berechtigungseintrag erwartet\"},\n@@ -135,2 +102,0 @@\n-        {\"null.principalClass.or.principalName\",\n-                \"principalClass oder principalName null\"},\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Resources_de.java","additions":1,"deletions":36,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,2 +62,0 @@\n-        {\"invalid.null.AccessControlContext.provided\",\n-                \"\\u7121\\u52B9\\u306Anull AccessControlContext\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u307E\\u3057\\u305F\"},\n@@ -93,18 +91,0 @@\n-        \/\/ sun.security.provider.PolicyFile\n-\n-        {\"java.security.policy.error.parsing.policy.message\",\n-                \"java.security.policy: {0}\\u306E\\u69CB\\u6587\\u89E3\\u6790\\u30A8\\u30E9\\u30FC:\\n\\t{1}\"},\n-        {\"java.security.policy.error.adding.Permission.perm.message\",\n-                \"java.security.policy: \\u30A2\\u30AF\\u30BB\\u30B9\\u6A29{0}\\u306E\\u8FFD\\u52A0\\u30A8\\u30E9\\u30FC:\\n\\t{1}\"},\n-        {\"java.security.policy.error.adding.Entry.message\",\n-                \"java.security.policy: \\u30A8\\u30F3\\u30C8\\u30EA\\u306E\\u8FFD\\u52A0\\u30A8\\u30E9\\u30FC:\\n\\t{0}\"},\n-        {\"alias.name.not.provided.pe.name.\", \"\\u5225\\u540D\\u306E\\u6307\\u5B9A\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093({0})\"},\n-        {\"unable.to.perform.substitution.on.alias.suffix\",\n-                \"\\u5225\\u540D{0}\\u306B\\u5BFE\\u3057\\u3066\\u7F6E\\u63DB\\u64CD\\u4F5C\\u304C\\u3067\\u304D\\u307E\\u305B\\u3093\"},\n-        {\"substitution.value.prefix.unsupported\",\n-                \"\\u7F6E\\u63DB\\u5024{0}\\u306F\\u30B5\\u30DD\\u30FC\\u30C8\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\"},\n-        {\"SPACE\", \" \"},\n-        {\"LPARAM\", \"(\"},\n-        {\"RPARAM\", \")\"},\n-        {\"type.can.t.be.null\",\"\\u5165\\u529B\\u3092null\\u306B\\u3059\\u308B\\u3053\\u3068\\u306F\\u3067\\u304D\\u307E\\u305B\\u3093\"},\n-\n@@ -112,7 +92,0 @@\n-        {\"keystorePasswordURL.can.not.be.specified.without.also.specifying.keystore\",\n-                \"\\u30AD\\u30FC\\u30B9\\u30C8\\u30A2\\u3092\\u6307\\u5B9A\\u3057\\u306A\\u3044\\u5834\\u5408\\u3001keystorePasswordURL\\u306F\\u6307\\u5B9A\\u3067\\u304D\\u307E\\u305B\\u3093\"},\n-        {\"expected.keystore.type\", \"\\u4E88\\u60F3\\u3055\\u308C\\u305F\\u30AD\\u30FC\\u30B9\\u30C8\\u30A2\\u30FB\\u30BF\\u30A4\\u30D7\"},\n-        {\"expected.keystore.provider\", \"\\u4E88\\u60F3\\u3055\\u308C\\u305F\\u30AD\\u30FC\\u30B9\\u30C8\\u30A2\\u30FB\\u30D7\\u30ED\\u30D0\\u30A4\\u30C0\"},\n-        {\"multiple.Codebase.expressions\",\n-                \"\\u8907\\u6570\\u306ECodebase\\u5F0F\"},\n-        {\"multiple.SignedBy.expressions\",\"\\u8907\\u6570\\u306ESignedBy\\u5F0F\"},\n@@ -121,6 +94,0 @@\n-        {\"SignedBy.has.empty.alias\",\"SignedBy\\u306F\\u7A7A\\u306E\\u5225\\u540D\\u3092\\u4FDD\\u6301\\u3057\\u307E\\u3059\"},\n-        {\"can.not.specify.Principal.with.a.wildcard.class.without.a.wildcard.name\",\n-                \"\\u30EF\\u30A4\\u30EB\\u30C9\\u30AB\\u30FC\\u30C9\\u540D\\u306E\\u306A\\u3044\\u30EF\\u30A4\\u30EB\\u30C9\\u30AB\\u30FC\\u30C9\\u30FB\\u30AF\\u30E9\\u30B9\\u3092\\u4F7F\\u7528\\u3057\\u3066\\u3001\\u30D7\\u30EA\\u30F3\\u30B7\\u30D1\\u30EB\\u3092\\u6307\\u5B9A\\u3059\\u308B\\u3053\\u3068\\u306F\\u3067\\u304D\\u307E\\u305B\\u3093\"},\n-        {\"expected.codeBase.or.SignedBy.or.Principal\",\n-                \"\\u4E88\\u60F3\\u3055\\u308C\\u305FcodeBase\\u3001SignedBy\\u307E\\u305F\\u306FPrincipal\"},\n-        {\"expected.permission.entry\", \"\\u4E88\\u60F3\\u3055\\u308C\\u305F\\u30A2\\u30AF\\u30BB\\u30B9\\u6A29\\u30A8\\u30F3\\u30C8\\u30EA\"},\n@@ -135,2 +102,0 @@\n-        {\"null.principalClass.or.principalName\",\n-                \"null\\u306EprincipalClass\\u307E\\u305F\\u306FprincipalName\"},\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Resources_ja.java","additions":1,"deletions":36,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,2 +62,0 @@\n-        {\"invalid.null.AccessControlContext.provided\",\n-                \"\\u63D0\\u4F9B\\u4E86\\u65E0\\u6548\\u7684\\u7A7A AccessControlContext\"},\n@@ -93,18 +91,0 @@\n-        \/\/ sun.security.provider.PolicyFile\n-\n-        {\"java.security.policy.error.parsing.policy.message\",\n-                \"java.security.policy: \\u89E3\\u6790{0}\\u65F6\\u51FA\\u9519:\\n\\t{1}\"},\n-        {\"java.security.policy.error.adding.Permission.perm.message\",\n-                \"java.security.policy: \\u6DFB\\u52A0\\u6743\\u9650{0}\\u65F6\\u51FA\\u9519:\\n\\t{1}\"},\n-        {\"java.security.policy.error.adding.Entry.message\",\n-                \"java.security.policy: \\u6DFB\\u52A0\\u6761\\u76EE\\u65F6\\u51FA\\u9519:\\n\\t{0}\"},\n-        {\"alias.name.not.provided.pe.name.\", \"\\u672A\\u63D0\\u4F9B\\u522B\\u540D ({0})\"},\n-        {\"unable.to.perform.substitution.on.alias.suffix\",\n-                \"\\u65E0\\u6CD5\\u5728\\u522B\\u540D {0} \\u4E0A\\u6267\\u884C\\u66FF\\u4EE3\"},\n-        {\"substitution.value.prefix.unsupported\",\n-                \"\\u66FF\\u4EE3\\u503C{0}\\u4E0D\\u53D7\\u652F\\u6301\"},\n-        {\"SPACE\", \" \"},\n-        {\"LPARAM\", \"(\"},\n-        {\"RPARAM\", \")\"},\n-        {\"type.can.t.be.null\",\"\\u7C7B\\u578B\\u4E0D\\u80FD\\u4E3A\\u7A7A\\u503C\"},\n-\n@@ -112,7 +92,0 @@\n-        {\"keystorePasswordURL.can.not.be.specified.without.also.specifying.keystore\",\n-                \"\\u4E0D\\u6307\\u5B9A\\u5BC6\\u94A5\\u5E93\\u65F6\\u65E0\\u6CD5\\u6307\\u5B9A keystorePasswordURL\"},\n-        {\"expected.keystore.type\", \"\\u5E94\\u4E3A\\u5BC6\\u94A5\\u5E93\\u7C7B\\u578B\"},\n-        {\"expected.keystore.provider\", \"\\u5E94\\u4E3A\\u5BC6\\u94A5\\u5E93\\u63D0\\u4F9B\\u65B9\"},\n-        {\"multiple.Codebase.expressions\",\n-                \"\\u591A\\u4E2A\\u4EE3\\u7801\\u5E93\\u8868\\u8FBE\\u5F0F\"},\n-        {\"multiple.SignedBy.expressions\",\"\\u591A\\u4E2A SignedBy \\u8868\\u8FBE\\u5F0F\"},\n@@ -121,6 +94,0 @@\n-        {\"SignedBy.has.empty.alias\",\"SignedBy \\u6709\\u7A7A\\u522B\\u540D\"},\n-        {\"can.not.specify.Principal.with.a.wildcard.class.without.a.wildcard.name\",\n-                \"\\u6CA1\\u6709\\u901A\\u914D\\u7B26\\u540D\\u79F0, \\u65E0\\u6CD5\\u4F7F\\u7528\\u901A\\u914D\\u7B26\\u7C7B\\u6307\\u5B9A\\u4E3B\\u7528\\u6237\"},\n-        {\"expected.codeBase.or.SignedBy.or.Principal\",\n-                \"\\u5E94\\u4E3A codeBase, SignedBy \\u6216\\u4E3B\\u7528\\u6237\"},\n-        {\"expected.permission.entry\", \"\\u5E94\\u4E3A\\u6743\\u9650\\u6761\\u76EE\"},\n@@ -135,2 +102,0 @@\n-        {\"null.principalClass.or.principalName\",\n-                \"principalClass \\u6216 principalName \\u4E3A\\u7A7A\\u503C\"},\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Resources_zh_CN.java","additions":1,"deletions":36,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-  jint result = (*VM)->AttachCurrentThreadAsDaemon(VM, (void**) &env, NULL);\n+  (*VM)->AttachCurrentThreadAsDaemon(VM, (void**) &env, NULL);\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,4 @@\n+    if (NET_PlatformInit() != 0) {\n+      return JNI_ERR;\n+    }\n+\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,0 +158,2 @@\n+int NET_PlatformInit();\n+\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,9 @@\n+\/* Perform platform specific initialization.\n+ * Returns 0 on success, non-0 on failure *\/\n+int\n+NET_PlatformInit()\n+{\n+    \/\/ Not needed on unix\n+    return 0;\n+}\n+\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.c","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -104,5 +104,1 @@\n-\/*\n- * Initialize Windows Sockets API support\n- *\/\n-BOOL WINAPI\n-DllMain(HINSTANCE hinst, DWORD reason, LPVOID reserved)\n+static void at_exit_callback(void)\n@@ -110,1 +106,2 @@\n-    WSADATA wsadata;\n+    WSACleanup();\n+}\n@@ -112,6 +109,6 @@\n-    switch (reason) {\n-        case DLL_PROCESS_ATTACH:\n-            if (WSAStartup(MAKEWORD(2,2), &wsadata) != 0) {\n-                return FALSE;\n-            }\n-            break;\n+\/* Perform platform specific initialization.\n+ * Returns 0 on success, non-0 on failure *\/\n+int\n+NET_PlatformInit()\n+{\n+    WSADATA wsadata;\n@@ -119,3 +116,1 @@\n-        case DLL_PROCESS_DETACH:\n-            WSACleanup();\n-            break;\n+    atexit(at_exit_callback);\n@@ -123,4 +118,1 @@\n-        default:\n-            break;\n-    }\n-    return TRUE;\n+    return WSAStartup(MAKEWORD(2,2), &wsadata);\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.c","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -113,0 +113,2 @@\n+    private static final int MAX_UNBALANCED_TOP_NODES = 100;\n+\n@@ -955,0 +957,1 @@\n+     *\n@@ -962,1 +965,58 @@\n-        return new AWTEventMulticaster(a, b);\n+        AWTEventMulticaster n = new AWTEventMulticaster(a, b);\n+        if (!needsRebalance(n)) {\n+            return n;\n+        }\n+\n+        EventListener[] array = getListeners(n, EventListener.class);\n+        return rebalance(array, 0, array.length - 1);\n+    }\n+\n+    \/**\n+     * Return true if the argument represents a binary tree that needs to be rebalanced.\n+     *\/\n+    private static boolean needsRebalance(AWTEventMulticaster l) {\n+        int level = 0;\n+        while (true) {\n+            \/\/ The criteria for when we need a rebalance is subjective. This method checks\n+            \/\/ up to a given threshold of the topmost nodes of a AWTEventMulticaster. If\n+            \/\/ they all include one leaf node, then this method returns true. This criteria\n+            \/\/ will be met after several consecutive iterations of `addInternal(a, b)`\n+            if (++level > MAX_UNBALANCED_TOP_NODES) {\n+                return true;\n+            }\n+            if (l.a instanceof AWTEventMulticaster aMulti) {\n+                if (l.b instanceof AWTEventMulticaster) {\n+                    \/\/ we reached a node where both children are AWTEventMulticaster: let's assume\n+                    \/\/ the current node marks the start of a well-balanced subtree\n+                    return false;\n+                }\n+                l = aMulti;\n+            } else if (l.b instanceof AWTEventMulticaster bMulti) {\n+                l = bMulti;\n+            } else {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Recursively create a balanced tree that includes a given range of EventListeners.\n+     *\n+     * @param array the array of the EventListeners to consult\n+     * @param index0 the lowest index (inclusive) that the return value must include\n+     * @param index1 the highest index (inclusive) that the return value must include.\n+     *\n+     * @return a balanced tree. If index0 equals index1 then this returns an EventListener from\n+     * the array provided. Otherwise this returns an AWTEventMulticaster.\n+     *\/\n+    private static EventListener rebalance(EventListener[] array, int index0, int index1) {\n+        if (index0 == index1) {\n+            return array[index0];\n+        }\n+        if (index0 == index1 - 1) {\n+            return new AWTEventMulticaster(array[index0], array[index1]);\n+        }\n+        int mid = (index0 + index1) \/ 2;\n+        return new AWTEventMulticaster(\n+                rebalance(array, index0, mid),\n+                rebalance(array, mid + 1, index1));\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/AWTEventMulticaster.java","additions":61,"deletions":1,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni_util.h\"\n+\n+\/*\n+ * This is needed to mark the bundled freetype library as being part of the JDK,\n+ * which means that for static builds, no additional dynamic library needs to\n+ * be loaded by System.loadLibrary(\"freetype\").\n+ *\/\n+DEF_STATIC_JNI_OnLoad\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/java_freetype.c","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-GDIHashtable::BatchDestructionManager GDIHashtable::manager;\n-\n@@ -38,1 +36,1 @@\n-    manager.decrementCounter();\n+    manager().decrementCounter();\n@@ -43,1 +41,1 @@\n-    if (!manager.isBatchingEnabled()) {\n+    if (!manager().isBatchingEnabled()) {\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/GDIHashtable.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,1 +165,1 @@\n-        manager.add(this);\n+        manager().add(this);\n@@ -169,1 +169,1 @@\n-        manager.remove(this);\n+        manager().remove(this);\n@@ -195,1 +195,1 @@\n-    INLINE static void flushAll() { manager.flushAll(); }\n+    INLINE static void flushAll() { manager().flushAll(); }\n@@ -197,1 +197,1 @@\n-    INLINE CriticalSection& getManagerLock() { return manager.getLock(); }\n+    INLINE CriticalSection& getManagerLock() { return manager().getLock(); }\n@@ -201,1 +201,2 @@\n-    static BatchDestructionManager manager;\n+    static BatchDestructionManager& manager() {\n+        static BatchDestructionManager manager;\n@@ -203,0 +204,2 @@\n+        return manager;\n+    }\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/GDIHashtable.h","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import com.sun.jmx.mbeanserver.Util;\n@@ -84,0 +83,2 @@\n+import sun.management.Util;\n+\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/interceptor\/DefaultMBeanServerInterceptor.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -284,1 +284,1 @@\n-            name = Util.newObjectName(domain + name.toString());\n+            name = sun.management.Util.newObjectName(domain + name.toString());\n@@ -441,1 +441,1 @@\n-                    addAllMatching(moiTb, result, Util.newObjectName(domain + name.getCanonicalName()));\n+                    addAllMatching(moiTb, result, sun.management.Util.newObjectName(domain + name.getCanonicalName()));\n@@ -444,1 +444,0 @@\n-\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/Repository.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,7 +46,0 @@\n-    public static ObjectName newObjectName(String string) {\n-        try {\n-            return new ObjectName(string);\n-        } catch (MalformedObjectNameException e) {\n-            throw new IllegalArgumentException(e);\n-        }\n-    }\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/Util.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import com.sun.jmx.mbeanserver.Util;\n+import sun.management.Util;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/MBeanServerDelegate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1225,1 +1225,1 @@\n-        return Util.newObjectName(name.getSerializedNameString());\n+        return sun.management.Util.newObjectName(name.getSerializedNameString());\n@@ -1816,1 +1816,1 @@\n-    public static final ObjectName WILDCARD = Util.newObjectName(\"*:*\");\n+    public static final ObjectName WILDCARD = sun.management.Util.newObjectName(\"*:*\");\n","filename":"src\/java.management\/share\/classes\/javax\/management\/ObjectName.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -43,1 +41,0 @@\n-@ParticipatesInPreview\n","filename":"src\/java.se\/share\/classes\/module-info.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -154,2 +154,1 @@\n-                        if (!(obj instanceof @SuppressWarnings(\"unchecked\")\n-                                KerberosTicket ticket)) {\n+                        if (!(obj instanceof KerberosTicket ticket)) {\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/krb5\/SubjectComber.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * The target name is the name of the permission (see below). The\n+ * The target name is the name of the permission. The\n","filename":"src\/java.sql\/share\/classes\/java\/sql\/SQLPermission.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -318,2 +318,2 @@\n-        EntityExpansionLimit=JAXP00010001: Der Parser hat mehr als {0} Entityerweiterungen in diesem Dokument gefunden. Dies ist der von JDK vorgeschriebene Grenzwert.\n-        ElementAttributeLimit=JAXP00010002: Element \"{0}\" hat mehr als {1} Attribute. \"{1}\" ist der von JDK vorgeschriebene Grenzwert.\n+        EntityExpansionLimit=JAXP00010001: Der Parser hat mehr als {0} Entityerweiterungen in diesem Dokument gefunden. Das ist der von \"{1}\" vorgeschriebene Grenzwert.\n+        ElementAttributeLimit=JAXP00010002: Element \"{0}\" hat mehr als {1} Attribute. \"{1}\" ist der von \"{2}\" vorgeschriebene Grenzwert.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages_de.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -318,2 +318,2 @@\n-        EntityExpansionLimit=JAXP00010001: \"{0}\"JDK\n-        ElementAttributeLimit=JAXP00010002: \"{0}\"\"{1}\"\"{1}\"JDK\n+        EntityExpansionLimit=JAXP00010001: \"{0}\"\"{1}\"\n+        ElementAttributeLimit=JAXP00010002: \"{0}\"\"{1}\"\"{1}\"\"{2}\"\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages_ja.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -318,2 +318,2 @@\n-        EntityExpansionLimit=JAXP00010001:  \"{0}\" ;  JDK \n-        ElementAttributeLimit=JAXP00010002:  \"{0}\"  \"{1}\" , \"{1}\"  JDK \n+        EntityExpansionLimit=JAXP00010001 \"{0}\"  \"{1}\" \n+        ElementAttributeLimit=JAXP00010002 \"{0}\"  \"{1}\" \"{1}\"  \"{2}\" \n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages_zh_CN.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+    private int ver = VERSION_1;        \/\/ updated in ctor depending on detectVersion result\n@@ -125,8 +126,12 @@\n-        \/\/ Check that we can connect to the process\n-        \/\/ - this ensures we throw the permission denied error now rather than\n-        \/\/ later when we attempt to enqueue a command.\n-        int s = socket();\n-        try {\n-            connect(s, socket_path);\n-        } finally {\n-            close(s);\n+        if (isAPIv2Enabled()) {\n+            ver = detectVersion();\n+        } else {\n+            \/\/ Check that we can connect to the process\n+            \/\/ - this ensures we throw the permission denied error now rather than\n+            \/\/ later when we attempt to enqueue a command.\n+            int s = socket();\n+            try {\n+                connect(s, socket_path);\n+            } finally {\n+                close(s);\n+            }\n@@ -147,3 +152,0 @@\n-    \/\/ protocol version\n-    private static final String PROTOCOL_VERSION = \"1\";\n-\n@@ -154,1 +156,0 @@\n-        assert args.length <= 3;                \/\/ includes null\n@@ -178,1 +179,0 @@\n-        \/\/ <ver> <cmd> <args...>\n@@ -180,10 +180,2 @@\n-            writeString(s, PROTOCOL_VERSION);\n-            writeString(s, cmd);\n-\n-            for (int i = 0; i < 3; i++) {\n-                if (i < args.length && args[i] != null) {\n-                    writeString(s, (String)args[i]);\n-                } else {\n-                    writeString(s, \"\");\n-                }\n-            }\n+            SocketOutputStream writer = new SocketOutputStream(s);\n+            writeCommand(writer, ver, cmd, args);\n@@ -205,0 +197,11 @@\n+    private static class SocketOutputStream implements AttachOutputStream {\n+        private int fd;\n+        public SocketOutputStream(int fd) {\n+            this.fd = fd;\n+        }\n+        @Override\n+        public void write(byte[] buffer, int offset, int length) throws IOException {\n+            VirtualMachineImpl.write(fd, buffer, offset, length);\n+        }\n+    }\n+\n@@ -276,14 +279,0 @@\n-    \/*\n-     * Write\/sends the given to the target VM. String is transmitted in\n-     * UTF-8 encoding.\n-     *\/\n-    private void writeString(int fd, String s) throws IOException {\n-        if (s.length() > 0) {\n-            byte[] b = s.getBytes(UTF_8);\n-            VirtualMachineImpl.write(fd, b, 0, b.length);\n-        }\n-        byte b[] = new byte[1];\n-        b[0] = 0;\n-        write(fd, b, 0, 1);\n-    }\n-\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":26,"deletions":37,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -722,1 +722,0 @@\n-        @SuppressWarnings(\"fallthrough\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ClassFinder.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-            return String.format(\"ACC_%s (0x%04x\", name(), value);\n+            return String.format(\"ACC_%s (0x%04x)\", name(), value);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Directive.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -36,0 +37,2 @@\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -37,0 +40,1 @@\n+import com.sun.tools.javac.util.Log;\n@@ -362,2 +366,8 @@\n-        static LintCategory get(String option) {\n-            return map.get(option);\n+        \/**\n+         * Get the {@link LintCategory} having the given command line option.\n+         *\n+         * @param option lint category option string\n+         * @return corresponding {@link LintCategory}, or empty if none exists\n+         *\/\n+        public static Optional<LintCategory> get(String option) {\n+            return Optional.ofNullable(map.get(option));\n@@ -388,0 +398,9 @@\n+    \/**\n+     * Helper method. Log a lint warning if its lint category is enabled.\n+     *\/\n+    public void logIfEnabled(Log log, DiagnosticPosition pos, LintWarning warning) {\n+        if (isEnabled(warning.getLintCategory())) {\n+            log.warning(pos, warning);\n+        }\n+    }\n+\n@@ -432,3 +451,2 @@\n-                LintCategory lc = LintCategory.get((String) (value.value));\n-                if (lc != null)\n-                    suppress(lc);\n+                LintCategory.get((String)value.value)\n+                  .ifPresent(this::suppress);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -38,0 +39,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -153,1 +155,3 @@\n-                .anyMatch(ed -> ed.modules.contains(m));\n+                .anyMatch(ed -> ed.modules.contains(m)) ||\n+               \/\/the specification lists the java.se module as participating in preview:\n+               m.name == names.java_se;\n@@ -178,2 +182,2 @@\n-                    Warnings.PreviewFeatureUsePlural(feature.nameFragment()) :\n-                    Warnings.PreviewFeatureUse(feature.nameFragment()));\n+                    LintWarnings.PreviewFeatureUsePlural(feature.nameFragment()) :\n+                    LintWarnings.PreviewFeatureUse(feature.nameFragment()));\n@@ -191,2 +195,2 @@\n-            log.mandatoryWarning(LintCategory.PREVIEW, null,\n-                    Warnings.PreviewFeatureUseClassfile(classfile, majorVersionToSource.get(majorVersion).name));\n+            log.mandatoryWarning(null,\n+                    LintWarnings.PreviewFeatureUseClassfile(classfile, majorVersionToSource.get(majorVersion).name));\n@@ -200,1 +204,1 @@\n-    public void reportPreviewWarning(DiagnosticPosition pos, Warning warnKey) {\n+    public void reportPreviewWarning(DiagnosticPosition pos, LintWarning warnKey) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1697,1 +1697,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -364,1 +364,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -2136,1 +2135,0 @@\n-        @SuppressWarnings(\"fallthrough\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -614,1 +614,0 @@\n-        @SuppressWarnings(\"unchecked\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Analyzer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -1941,2 +1942,2 @@\n-        if (env.info.lint.isEnabled(LintCategory.SYNCHRONIZATION) && isValueBased(tree.lock.type)) {\n-            log.warning(LintCategory.SYNCHRONIZATION, tree.pos(), Warnings.AttemptToSynchronizeOnInstanceOfValueBasedClass);\n+        if (isValueBased(tree.lock.type)) {\n+            env.info.lint.logIfEnabled(log, tree.pos(), LintWarnings.AttemptToSynchronizeOnInstanceOfValueBasedClass);\n@@ -2048,3 +2049,2 @@\n-                    chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes()) &&\n-                    env.info.lint.isEnabled(LintCategory.TRY)) {\n-                log.warning(LintCategory.TRY, pos, Warnings.TryResourceThrowsInterruptedExc(resource));\n+                    chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes())) {\n+                env.info.lint.logIfEnabled(log, pos, LintWarnings.TryResourceThrowsInterruptedExc(resource));\n@@ -4449,3 +4449,2 @@\n-                sym.overrides(syms.autoCloseableClose, sitesym.type.tsym, types, true) &&\n-                env.info.lint.isEnabled(LintCategory.TRY)) {\n-            log.warning(LintCategory.TRY, tree, Warnings.TryExplicitCloseCall);\n+                sym.overrides(syms.autoCloseableClose, sitesym.type.tsym, types, true)) {\n+            env.info.lint.logIfEnabled(log, tree, LintWarnings.TryExplicitCloseCall);\n@@ -4478,1 +4477,1 @@\n-                chk.warnStatic(tree, Warnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n+                chk.lint.logIfEnabled(log, tree, LintWarnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n@@ -4480,1 +4479,1 @@\n-                chk.warnStatic(tree, Warnings.StaticNotQualifiedByType2(sym.kind.kindName()));\n+                chk.lint.logIfEnabled(log, tree, LintWarnings.StaticNotQualifiedByType2(sym.kind.kindName()));\n@@ -4693,1 +4692,1 @@\n-                        chk.warnUnchecked(tree.pos(), Warnings.UncheckedAssignToVar(v, s));\n+                        chk.warnUnchecked(tree.pos(), LintWarnings.UncheckedAssignToVar(v, s));\n@@ -4891,1 +4890,1 @@\n-                chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedCallMbrOfRawType(sym, s));\n+                chk.warnUnchecked(env.tree.pos(), LintWarnings.UncheckedCallMbrOfRawType(sym, s));\n@@ -4941,1 +4940,1 @@\n-                chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedMethInvocationApplied(kindName(sym),\n+                chk.warnUnchecked(env.tree.pos(), LintWarnings.UncheckedMethInvocationApplied(kindName(sym),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.function.Consumer;\n@@ -53,0 +52,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -59,1 +59,1 @@\n-import com.sun.tools.javac.util.JCDiagnostic.Warning;\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -82,1 +82,0 @@\n-import javax.lang.model.element.ExecutableElement;\n@@ -85,2 +84,0 @@\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.util.ElementFilter;\n@@ -125,1 +122,1 @@\n-    private Lint lint;\n+    Lint lint;\n@@ -254,1 +251,1 @@\n-                    removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemovalModule(sym));\n+                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemovalModule(sym));\n@@ -256,1 +253,1 @@\n-                    removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemoval(sym, sym.location()));\n+                    removalHandler.report(pos, LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location()));\n@@ -261,1 +258,1 @@\n-                deprecationHandler.report(pos, Warnings.HasBeenDeprecatedModule(sym));\n+                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecatedModule(sym));\n@@ -263,1 +260,1 @@\n-                deprecationHandler.report(pos, Warnings.HasBeenDeprecated(sym, sym.location()));\n+                deprecationHandler.report(pos, LintWarnings.HasBeenDeprecated(sym, sym.location()));\n@@ -272,1 +269,1 @@\n-    public void warnPreviewAPI(DiagnosticPosition pos, Warning warnKey) {\n+    public void warnPreviewAPI(DiagnosticPosition pos, LintWarning warnKey) {\n@@ -283,1 +280,1 @@\n-            preview.reportPreviewWarning(pos, Warnings.DeclaredUsingPreview(kindName(sym), sym));\n+            preview.reportPreviewWarning(pos, LintWarnings.DeclaredUsingPreview(kindName(sym), sym));\n@@ -291,2 +288,1 @@\n-        if (lint.isEnabled(LintCategory.RESTRICTED))\n-            log.warning(LintCategory.RESTRICTED, pos, Warnings.RestrictedMethod(sym.enclClass(), sym));\n+        lint.logIfEnabled(log, pos, LintWarnings.RestrictedMethod(sym.enclClass(), sym));\n@@ -299,1 +295,1 @@\n-    public void warnUnchecked(DiagnosticPosition pos, Warning warnKey) {\n+    public void warnUnchecked(DiagnosticPosition pos, LintWarning warnKey) {\n@@ -304,21 +300,0 @@\n-    \/** Warn about unsafe vararg method decl.\n-     *  @param pos        Position to be used for error reporting.\n-     *\/\n-    void warnUnsafeVararg(DiagnosticPosition pos, Warning warnKey) {\n-        if (lint.isEnabled(LintCategory.VARARGS))\n-            log.warning(LintCategory.VARARGS, pos, warnKey);\n-    }\n-\n-    public void warnStatic(DiagnosticPosition pos, Warning warnKey) {\n-        if (lint.isEnabled(LintCategory.STATIC))\n-            log.warning(LintCategory.STATIC, pos, warnKey);\n-    }\n-\n-    \/** Warn about division by integer constant zero.\n-     *  @param pos        Position to be used for error reporting.\n-     *\/\n-    void warnDivZero(DiagnosticPosition pos) {\n-        if (lint.isEnabled(LintCategory.DIVZERO))\n-            log.warning(LintCategory.DIVZERO, pos, Warnings.DivZero);\n-    }\n-\n@@ -677,3 +652,1 @@\n-                if (lint.isEnabled(LintCategory.CAST))\n-                    log.warning(LintCategory.CAST,\n-                            tree.pos(), Warnings.RedundantCast(tree.clazz.type));\n+                lint.logIfEnabled(log, tree.pos(), LintWarnings.RedundantCast(tree.clazz.type));\n@@ -984,1 +957,1 @@\n-            warnUnsafeVararg(tree, Warnings.VarargsRedundantTrustmeAnno(\n+            lint.logIfEnabled(log, tree, LintWarnings.VarargsRedundantTrustmeAnno(\n@@ -990,1 +963,1 @@\n-            warnUnchecked(tree.params.head.pos(), Warnings.UncheckedVarargsNonReifiableType(varargElemType));\n+            warnUnchecked(tree.params.head.pos(), LintWarnings.UncheckedVarargsNonReifiableType(varargElemType));\n@@ -1077,1 +1050,1 @@\n-                warnUnchecked(env.tree.pos(), Warnings.UncheckedGenericArrayCreation(argtype));\n+                warnUnchecked(env.tree.pos(), LintWarnings.UncheckedGenericArrayCreation(argtype));\n@@ -1353,5 +1326,1 @@\n-            deferredLintHandler.report(_l -> {\n-                                           if (lint.isEnabled(LintCategory.STRICTFP)) {\n-                                               log.warning(LintCategory.STRICTFP,\n-                                                           pos, Warnings.Strictfp); }\n-                                       });\n+            deferredLintHandler.report(_ -> lint.logIfEnabled(log, pos, LintWarnings.Strictfp));\n@@ -1572,2 +1541,1 @@\n-        if (lint.isEnabled(LintCategory.RAW) &&\n-            tree.type.hasTag(CLASS) &&\n+        if (tree.type.hasTag(CLASS) &&\n@@ -1577,2 +1545,1 @@\n-            log.warning(LintCategory.RAW,\n-                    tree.pos(), Warnings.RawClassUse(tree.type, tree.type.tsym.type));\n+            lint.logIfEnabled(log, tree.pos(), LintWarnings.RawClassUse(tree.type, tree.type.tsym.type));\n@@ -1880,1 +1847,1 @@\n-                    Warnings.OverrideUncheckedRet(uncheckedOverrides(m, other), mtres, otres));\n+                    LintWarnings.OverrideUncheckedRet(uncheckedOverrides(m, other), mtres, otres));\n@@ -1896,1 +1863,1 @@\n-                          Warnings.OverrideUncheckedThrown(cannotOverride(m, other), unhandledUnerased.head));\n+                          LintWarnings.OverrideUncheckedThrown(cannotOverride(m, other), unhandledUnerased.head));\n@@ -1901,3 +1868,2 @@\n-        if ((((m.flags() ^ other.flags()) & Flags.VARARGS) != 0)\n-            && lint.isEnabled(LintCategory.OVERRIDES)) {\n-            log.warning(TreeInfo.diagnosticPositionFor(m, tree),\n+        if ((((m.flags() ^ other.flags()) & Flags.VARARGS) != 0)) {\n+            lint.logIfEnabled(log, TreeInfo.diagnosticPositionFor(m, tree),\n@@ -1905,2 +1871,2 @@\n-                        ? Warnings.OverrideVarargsMissing(varargsOverrides(m, other))\n-                        : Warnings.OverrideVarargsExtra(varargsOverrides(m, other)));\n+                        ? LintWarnings.OverrideVarargsMissing(varargsOverrides(m, other))\n+                        : LintWarnings.OverrideVarargsExtra(varargsOverrides(m, other)));\n@@ -2250,2 +2216,2 @@\n-                log.warning(LintCategory.OVERRIDES, pos,\n-                            Warnings.OverrideEqualsButNotHashcode(someClass));\n+                log.warning(pos,\n+                            LintWarnings.OverrideEqualsButNotHashcode(someClass));\n@@ -2313,1 +2279,1 @@\n-                        log.warning(Lint.LintCategory.MODULE, pos, Warnings.PoorChoiceForModuleName(componentName));\n+                        log.warning(pos, LintWarnings.PoorChoiceForModuleName(componentName));\n@@ -2784,2 +2750,2 @@\n-            log.warning(LintCategory.OVERLOADS, pos,\n-                Warnings.PotentiallyAmbiguousOverload(\n+            log.warning(pos,\n+                LintWarnings.PotentiallyAmbiguousOverload(\n@@ -3005,2 +2971,2 @@\n-                        log.warning(LintCategory.SERIAL, tree.pos(),\n-                                    Warnings.AccessToMemberFromSerializableLambda(sym));\n+                        log.warning(tree.pos(),\n+                                    LintWarnings.AccessToMemberFromSerializableLambda(sym));\n@@ -3010,1 +2976,1 @@\n-                                Warnings.AccessToMemberFromSerializableElement(sym));\n+                                LintWarnings.AccessToMemberFromSerializableElement(sym));\n@@ -3793,2 +3759,1 @@\n-            log.warning(LintCategory.DEP_ANN,\n-                    pos, Warnings.MissingDeprecatedAnnotation);\n+            log.warning(pos, LintWarnings.MissingDeprecatedAnnotation);\n@@ -3799,2 +3764,2 @@\n-                log.warning(LintCategory.DEPRECATION, pos,\n-                            Warnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));\n+                log.warning(pos,\n+                            LintWarnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));\n@@ -3860,1 +3825,1 @@\n-                    deferredLintHandler.report(_l -> warnPreviewAPI(pos, Warnings.IsPreview(s)));\n+                    deferredLintHandler.report(_l -> warnPreviewAPI(pos, LintWarnings.IsPreview(s)));\n@@ -3863,1 +3828,1 @@\n-                    deferredLintHandler.report(_l -> warnPreviewAPI(pos, Warnings.IsPreviewReflective(s)));\n+                    deferredLintHandler.report(_l -> warnPreviewAPI(pos, LintWarnings.IsPreviewReflective(s)));\n@@ -4151,1 +4116,1 @@\n-                deferredLintHandler.report(_l -> warnDivZero(pos));\n+                deferredLintHandler.report(_ -> lint.logIfEnabled(log, pos, LintWarnings.DivZero));\n@@ -4164,5 +4129,2 @@\n-            deferredLintHandler.report(_l -> {\n-                if (lint.isEnabled(LintCategory.LOSSY_CONVERSIONS))\n-                    log.warning(LintCategory.LOSSY_CONVERSIONS,\n-                            pos, Warnings.PossibleLossOfPrecision(found, req));\n-            });\n+            deferredLintHandler.report(_ ->\n+                lint.logIfEnabled(log, pos, LintWarnings.PossibleLossOfPrecision(found, req)));\n@@ -4176,3 +4138,3 @@\n-        if (tree.thenpart.hasTag(SKIP) && tree.elsepart == null &&\n-                lint.isEnabled(LintCategory.EMPTY))\n-            log.warning(LintCategory.EMPTY, tree.thenpart.pos(), Warnings.EmptyIf);\n+        if (tree.thenpart.hasTag(SKIP) && tree.elsepart == null) {\n+            lint.logIfEnabled(log, tree.thenpart.pos(), LintWarnings.EmptyIf);\n+        }\n@@ -4320,2 +4282,1 @@\n-        if (lint.isEnabled(Lint.LintCategory.AUXILIARYCLASS) &&\n-            (c.flags() & AUXILIARY) != 0 &&\n+        if ((c.flags() & AUXILIARY) != 0 &&\n@@ -4325,2 +4286,2 @@\n-            log.warning(pos,\n-                        Warnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));\n+            lint.logIfEnabled(log, pos,\n+                        LintWarnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));\n@@ -4368,5 +4329,2 @@\n-                            deferredLintHandler.report(_l -> {\n-                                if (lint.isEnabled(LintCategory.MISSING_EXPLICIT_CTOR))\n-                                   log.warning(LintCategory.MISSING_EXPLICIT_CTOR,\n-                                               pos, Warnings.MissingExplicitCtor(c, pkg, modle));\n-                                                       });\n+                            deferredLintHandler.report(_ ->\n+                                lint.logIfEnabled(log, pos, LintWarnings.MissingExplicitCtor(c, pkg, modle)));\n@@ -4401,1 +4359,1 @@\n-                    Check.this.warnUnchecked(pos(), Warnings.ProbFoundReq(diags.fragment(uncheckedKey), found, expected));\n+                    Check.this.warnUnchecked(pos(), LintWarnings.ProbFoundReq(diags.fragment(uncheckedKey), found, expected));\n@@ -4408,1 +4366,1 @@\n-                        Check.this.warnUnsafeVararg(pos(), Warnings.VarargsUnsafeUseVarargsParam(method.params.last()));\n+                        Check.this.lint.logIfEnabled(log, pos(), LintWarnings.VarargsUnsafeUseVarargsParam(method.params.last()));\n@@ -4663,1 +4621,1 @@\n-                log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessible(kindName(what), what, what.packge().modle));\n+                log.warning(pos, LintWarnings.LeaksNotAccessible(kindName(what), what, what.packge().modle));\n@@ -4672,1 +4630,1 @@\n-                log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleUnexported(kindName(what), what, what.packge().modle));\n+                log.warning(pos, LintWarnings.LeaksNotAccessibleUnexported(kindName(what), what, what.packge().modle));\n@@ -4678,1 +4636,1 @@\n-                    log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleUnexportedQualified(kindName(what), what, what.packge().modle));\n+                    log.warning(pos, LintWarnings.LeaksNotAccessibleUnexportedQualified(kindName(what), what, what.packge().modle));\n@@ -4700,1 +4658,1 @@\n-                log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleNotRequiredTransitive(kindName(what), what, what.packge().modle));\n+                log.warning(pos, LintWarnings.LeaksNotAccessibleNotRequiredTransitive(kindName(what), what, what.packge().modle));\n@@ -4706,4 +4664,2 @@\n-            deferredLintHandler.report(_l -> {\n-                if (lint.isEnabled(LintCategory.MODULE))\n-                    log.warning(LintCategory.MODULE, pos, Warnings.ModuleNotFound(msym));\n-            });\n+            deferredLintHandler.report(_ ->\n+                lint.logIfEnabled(log, pos, LintWarnings.ModuleNotFound(msym)));\n@@ -4716,4 +4672,2 @@\n-            deferredLintHandler.report(_l -> {\n-                if (lint.isEnabled(LintCategory.OPENS))\n-                    log.warning(pos, Warnings.PackageEmptyOrNotFound(packge));\n-            });\n+            deferredLintHandler.report(_ ->\n+                lint.logIfEnabled(log, pos, LintWarnings.PackageEmptyOrNotFound(packge)));\n@@ -4725,1 +4679,1 @@\n-            deferredLintHandler.report(_l -> {\n+            deferredLintHandler.report(_ -> {\n@@ -4727,3 +4681,3 @@\n-                    log.warning(pos, Warnings.RequiresTransitiveAutomatic);\n-                } else if (lint.isEnabled(LintCategory.REQUIRES_AUTOMATIC)) {\n-                    log.warning(pos, Warnings.RequiresAutomatic);\n+                    log.warning(pos, LintWarnings.RequiresTransitiveAutomatic);\n+                } else {\n+                    lint.logIfEnabled(log, pos, LintWarnings.RequiresAutomatic);\n@@ -5027,1 +4981,1 @@\n-                log.warning(LintCategory.SERIAL, p.pos(), Warnings.MissingSVUID(c));\n+                log.warning(p.pos(), LintWarnings.MissingSVUID(c));\n@@ -5054,3 +5008,3 @@\n-                                    log.warning(LintCategory.SERIAL,\n-                                                TreeInfo.diagnosticPositionFor(enclosed, tree),\n-                                                Warnings.NonSerializableInstanceField);\n+                                    log.warning(\n+                                            TreeInfo.diagnosticPositionFor(enclosed, tree),\n+                                                LintWarnings.NonSerializableInstanceField);\n@@ -5065,3 +5019,3 @@\n-                                        log.warning(LintCategory.SERIAL,\n-                                                    TreeInfo.diagnosticPositionFor(enclosed, tree),\n-                                                    Warnings.NonSerializableInstanceFieldArray(elementType));\n+                                        log.warning(\n+                                                TreeInfo.diagnosticPositionFor(enclosed, tree),\n+                                                    LintWarnings.NonSerializableInstanceFieldArray(elementType));\n@@ -5150,2 +5104,2 @@\n-                log.warning(LintCategory.SERIAL, tree.pos(),\n-                            Warnings.ExternalizableMissingPublicNoArgCtor);\n+                log.warning(tree.pos(),\n+                            LintWarnings.ExternalizableMissingPublicNoArgCtor);\n@@ -5178,2 +5132,2 @@\n-                                    log.warning(LintCategory.SERIAL, tree.pos(),\n-                                                Warnings.SerializableMissingAccessNoArgCtor(supertype.getQualifiedName()));\n+                                    log.warning(tree.pos(),\n+                                                LintWarnings.SerializableMissingAccessNoArgCtor(supertype.getQualifiedName()));\n@@ -5197,3 +5151,3 @@\n-                 log.warning(LintCategory.SERIAL,\n-                             TreeInfo.diagnosticPositionFor(svuid, tree),\n-                             Warnings.ImproperSVUID((Symbol)e));\n+                 log.warning(\n+                         TreeInfo.diagnosticPositionFor(svuid, tree),\n+                             LintWarnings.ImproperSVUID((Symbol)e));\n@@ -5204,3 +5158,3 @@\n-                 log.warning(LintCategory.SERIAL,\n-                             TreeInfo.diagnosticPositionFor(svuid, tree),\n-                             Warnings.LongSVUID((Symbol)e));\n+                 log.warning(\n+                         TreeInfo.diagnosticPositionFor(svuid, tree),\n+                             LintWarnings.LongSVUID((Symbol)e));\n@@ -5210,3 +5164,3 @@\n-                 log.warning(LintCategory.SERIAL,\n-                            TreeInfo.diagnosticPositionFor(svuid, tree),\n-                             Warnings.ConstantSVUID((Symbol)e));\n+                 log.warning(\n+                         TreeInfo.diagnosticPositionFor(svuid, tree),\n+                             LintWarnings.ConstantSVUID((Symbol)e));\n@@ -5219,3 +5173,3 @@\n-                 log.warning(LintCategory.SERIAL,\n-                             TreeInfo.diagnosticPositionFor(spf, tree),\n-                             Warnings.ImproperSPF);\n+                 log.warning(\n+                         TreeInfo.diagnosticPositionFor(spf, tree),\n+                             LintWarnings.ImproperSPF);\n@@ -5225,3 +5179,3 @@\n-                 log.warning(LintCategory.SERIAL,\n-                             TreeInfo.diagnosticPositionFor(spf, tree),\n-                             Warnings.OSFArraySPF);\n+                 log.warning(\n+                         TreeInfo.diagnosticPositionFor(spf, tree),\n+                             LintWarnings.OSFArraySPF);\n@@ -5231,3 +5185,3 @@\n-                log.warning(LintCategory.SERIAL,\n-                            TreeInfo.diagnosticPositionFor(spf, tree),\n-                            Warnings.IneffectualSerialFieldExternalizable);\n+                log.warning(\n+                        TreeInfo.diagnosticPositionFor(spf, tree),\n+                            LintWarnings.IneffectualSerialFieldExternalizable);\n@@ -5243,2 +5197,2 @@\n-                     log.warning(LintCategory.SERIAL, initExpr.pos(),\n-                                 Warnings.SPFNullInit);\n+                     log.warning(initExpr.pos(),\n+                                 LintWarnings.SPFNullInit);\n@@ -5322,3 +5276,3 @@\n-                log.warning(LintCategory.SERIAL,\n-                            TreeInfo.diagnosticPositionFor(method, tree),\n-                            Warnings.IneffectualExternalizableMethodRecord(method.getSimpleName().toString()));\n+                log.warning(\n+                        TreeInfo.diagnosticPositionFor(method, tree),\n+                            LintWarnings.IneffectualExternalizableMethodRecord(method.getSimpleName().toString()));\n@@ -5331,3 +5285,3 @@\n-                log.warning(LintCategory.SERIAL,\n-                            TreeInfo.diagnosticPositionFor(method, tree),\n-                            Warnings.SerialMethodNotPrivate(method.getSimpleName()));\n+                log.warning(\n+                        TreeInfo.diagnosticPositionFor(method, tree),\n+                            LintWarnings.SerialMethodNotPrivate(method.getSimpleName()));\n@@ -5337,3 +5291,3 @@\n-                log.warning(LintCategory.SERIAL,\n-                            TreeInfo.diagnosticPositionFor(method, tree),\n-                            Warnings.SerialMethodStatic(method.getSimpleName()));\n+                log.warning(\n+                        TreeInfo.diagnosticPositionFor(method, tree),\n+                            LintWarnings.SerialMethodStatic(method.getSimpleName()));\n@@ -5362,3 +5316,3 @@\n-                            log.warning(LintCategory.SERIAL,\n-                                        TreeInfo.diagnosticPositionFor(field, tree),\n-                                        Warnings.IneffectualSerialFieldEnum(name));\n+                            log.warning(\n+                                    TreeInfo.diagnosticPositionFor(field, tree),\n+                                        LintWarnings.IneffectualSerialFieldEnum(name));\n@@ -5371,3 +5325,3 @@\n-                            log.warning(LintCategory.SERIAL,\n-                                        TreeInfo.diagnosticPositionFor(method, tree),\n-                                        Warnings.IneffectualSerialMethodEnum(name));\n+                            log.warning(\n+                                    TreeInfo.diagnosticPositionFor(method, tree),\n+                                        LintWarnings.IneffectualSerialMethodEnum(name));\n@@ -5411,3 +5365,3 @@\n-                log.warning(LintCategory.SERIAL,\n-                            TreeInfo.diagnosticPositionFor(method, tree),\n-                            Warnings.IneffectualExternMethodEnum(method.getSimpleName().toString()));\n+                log.warning(\n+                        TreeInfo.diagnosticPositionFor(method, tree),\n+                            LintWarnings.IneffectualExternMethodEnum(method.getSimpleName().toString()));\n@@ -5443,3 +5397,3 @@\n-                            log.warning(LintCategory.SERIAL,\n-                                        TreeInfo.diagnosticPositionFor(field, tree),\n-                                        Warnings.IneffectualSerialFieldInterface);\n+                            log.warning(\n+                                    TreeInfo.diagnosticPositionFor(field, tree),\n+                                        LintWarnings.IneffectualSerialFieldInterface);\n@@ -5483,3 +5437,3 @@\n-                log.warning(LintCategory.SERIAL,\n-                            TreeInfo.diagnosticPositionFor(method, tree),\n-                            Warnings.NonPrivateMethodWeakerAccess);\n+                log.warning(\n+                        TreeInfo.diagnosticPositionFor(method, tree),\n+                            LintWarnings.NonPrivateMethodWeakerAccess);\n@@ -5493,3 +5447,3 @@\n-                log.warning(LintCategory.SERIAL,\n-                            TreeInfo.diagnosticPositionFor(method, tree),\n-                            Warnings.DefaultIneffective);\n+                log.warning(\n+                        TreeInfo.diagnosticPositionFor(method, tree),\n+                            LintWarnings.DefaultIneffective);\n@@ -5540,3 +5494,3 @@\n-                            log.warning(LintCategory.SERIAL,\n-                                        TreeInfo.diagnosticPositionFor(field, tree),\n-                                        Warnings.IneffectualSerialFieldRecord);\n+                            log.warning(\n+                                    TreeInfo.diagnosticPositionFor(field, tree),\n+                                        LintWarnings.IneffectualSerialFieldRecord);\n@@ -5564,3 +5518,3 @@\n-                                log.warning(LintCategory.SERIAL,\n-                                            TreeInfo.diagnosticPositionFor(method, tree),\n-                                            Warnings.IneffectualSerialMethodRecord(name));\n+                                log.warning(\n+                                        TreeInfo.diagnosticPositionFor(method, tree),\n+                                            LintWarnings.IneffectualSerialMethodRecord(name));\n@@ -5578,3 +5532,3 @@\n-                    log.warning(LintCategory.SERIAL,\n-                                TreeInfo.diagnosticPositionFor(method, tree),\n-                                Warnings.SerialConcreteInstanceMethod(method.getSimpleName()));\n+                    log.warning(\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                                LintWarnings.SerialConcreteInstanceMethod(method.getSimpleName()));\n@@ -5595,3 +5549,3 @@\n-                log.warning(LintCategory.SERIAL,\n-                            TreeInfo.diagnosticPositionFor(method, tree),\n-                            Warnings.SerialMethodUnexpectedReturnType(method.getSimpleName(),\n+                log.warning(\n+                        TreeInfo.diagnosticPositionFor(method, tree),\n+                            LintWarnings.SerialMethodUnexpectedReturnType(method.getSimpleName(),\n@@ -5611,3 +5565,3 @@\n-                log.warning(LintCategory.SERIAL,\n-                            TreeInfo.diagnosticPositionFor(method, tree),\n-                            Warnings.SerialMethodOneArg(method.getSimpleName(), parameters.size()));\n+                log.warning(\n+                        TreeInfo.diagnosticPositionFor(method, tree),\n+                            LintWarnings.SerialMethodOneArg(method.getSimpleName(), parameters.size()));\n@@ -5619,3 +5573,3 @@\n-                log.warning(LintCategory.SERIAL,\n-                            TreeInfo.diagnosticPositionFor(method, tree),\n-                            Warnings.SerialMethodParameterType(method.getSimpleName(),\n+                log.warning(\n+                        TreeInfo.diagnosticPositionFor(method, tree),\n+                            LintWarnings.SerialMethodParameterType(method.getSimpleName(),\n@@ -5640,3 +5594,3 @@\n-                log.warning(LintCategory.SERIAL,\n-                            TreeInfo.diagnosticPositionFor(parameters.get(0), tree),\n-                            Warnings.SerialMethodNoArgs(method.getSimpleName()));\n+                log.warning(\n+                        TreeInfo.diagnosticPositionFor(parameters.get(0), tree),\n+                            LintWarnings.SerialMethodNoArgs(method.getSimpleName()));\n@@ -5649,3 +5603,3 @@\n-                log.warning(LintCategory.SERIAL,\n-                            TreeInfo.diagnosticPositionFor(method, tree),\n-                            Warnings.IneffectualSerialMethodExternalizable(method.getSimpleName()));\n+                log.warning(\n+                        TreeInfo.diagnosticPositionFor(method, tree),\n+                            LintWarnings.IneffectualSerialMethodExternalizable(method.getSimpleName()));\n@@ -5678,3 +5632,3 @@\n-                        log.warning(LintCategory.SERIAL,\n-                                    TreeInfo.diagnosticPositionFor(method, tree),\n-                                    Warnings.SerialMethodUnexpectedException(method.getSimpleName(),\n+                        log.warning(\n+                                TreeInfo.diagnosticPositionFor(method, tree),\n+                                    LintWarnings.SerialMethodUnexpectedException(method.getSimpleName(),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":147,"deletions":193,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import com.sun.source.tree.CaseTree;\n@@ -42,0 +41,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -63,2 +63,0 @@\n-import java.util.Collections;\n-import java.util.IdentityHashMap;\n@@ -729,1 +727,0 @@\n-                    lint.isEnabled(Lint.LintCategory.FALLTHROUGH) &&\n@@ -731,3 +728,2 @@\n-                    log.warning(Lint.LintCategory.FALLTHROUGH,\n-                                l.tail.head.pos(),\n-                                Warnings.PossibleFallThroughIntoCase);\n+                    lint.logIfEnabled(log, l.tail.head.pos(),\n+                                LintWarnings.PossibleFallThroughIntoCase);\n@@ -1240,5 +1236,2 @@\n-                    if (lint.isEnabled(Lint.LintCategory.FINALLY)) {\n-                        log.warning(Lint.LintCategory.FINALLY,\n-                                TreeInfo.diagEndPos(tree.finalizer),\n-                                Warnings.FinallyCannotComplete);\n-                    }\n+                    lint.logIfEnabled(log, TreeInfo.diagEndPos(tree.finalizer),\n+                                LintWarnings.FinallyCannotComplete);\n@@ -2866,2 +2859,2 @@\n-                        log.warning(Lint.LintCategory.TRY, resVar.pos(),\n-                                    Warnings.TryResourceNotReferenced(resVar.sym));\n+                        log.warning(resVar.pos(),\n+                                    LintWarnings.TryResourceNotReferenced(resVar.sym));\n@@ -3292,1 +3285,0 @@\n-        @SuppressWarnings(\"fallthrough\")\n@@ -3313,1 +3305,0 @@\n-        @SuppressWarnings(\"fallthrough\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.code.ClassFinder;\n@@ -91,0 +90,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -1026,1 +1026,1 @@\n-        @Override @SuppressWarnings(\"unchecked\")\n+        @Override\n@@ -1278,2 +1278,2 @@\n-                        log.warning(LintCategory.OPTIONS,\n-                                Warnings.ModuleForOptionNotFound(Option.LIMIT_MODULES, msym));\n+                        log.warning(\n+                                LintWarnings.ModuleForOptionNotFound(Option.LIMIT_MODULES, msym));\n@@ -1384,1 +1384,1 @@\n-                log.warning(Warnings.IncubatingModules(incubatingModules));\n+                log.warning(LintWarnings.IncubatingModules(incubatingModules));\n@@ -1734,2 +1734,2 @@\n-                log.warning(LintCategory.OPTIONS,\n-                        Warnings.ModuleForOptionNotFound(Option.ADD_EXPORTS, msym));\n+                log.warning(\n+                        LintWarnings.ModuleForOptionNotFound(Option.ADD_EXPORTS, msym));\n@@ -1773,1 +1773,1 @@\n-                    log.warning(Warnings.ModuleForOptionNotFound(Option.ADD_READS, msym));\n+                    log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, msym));\n@@ -1793,1 +1793,1 @@\n-                            log.warning(LintCategory.OPTIONS, Warnings.ModuleForOptionNotFound(Option.ADD_READS, targetModule));\n+                            log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, targetModule));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -277,1 +277,0 @@\n-        @SuppressWarnings(\"varargs\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Operators.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5196,1 +5196,0 @@\n-        @SuppressWarnings(\"overrides\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.util.Map.Entry;\n@@ -39,1 +38,0 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -56,0 +54,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -66,1 +65,0 @@\n-import com.sun.tools.javac.util.Name;\n@@ -427,1 +425,1 @@\n-            JCDiagnostic.Warning key = Warnings.PossibleThisEscape;\n+            JCDiagnostic.Warning key = LintWarnings.PossibleThisEscape;\n@@ -431,2 +429,2 @@\n-                log.warning(Lint.LintCategory.THIS_ESCAPE, pos, key);\n-                key = Warnings.PossibleThisEscapeLocation;\n+                log.warning(pos, key);\n+                key = LintWarnings.PossibleThisEscapeLocation;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n@@ -44,1 +42,0 @@\n-import java.nio.file.Files;\n@@ -59,1 +56,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -64,0 +60,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -65,1 +62,0 @@\n-import com.sun.tools.javac.util.Abort;\n@@ -532,1 +528,1 @@\n-            log.warning(LintCategory.OUTPUT_FILE_CLASH, Warnings.OutputFileClash(path));\n+            log.warning(LintWarnings.OutputFileClash(path));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/BaseFileManager.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -82,2 +84,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -227,1 +227,1 @@\n-                        log.warning(LintCategory.PATH, Warnings.InvalidPath(s));\n+                        log.warning(LintWarnings.InvalidPath(s));\n@@ -322,2 +322,2 @@\n-                    log.warning(Lint.LintCategory.PATH,\n-                                Warnings.DirPathElementNotFound(dir));\n+                    log.warning(\n+                            LintWarnings.DirPathElementNotFound(dir));\n@@ -368,2 +368,2 @@\n-                    log.warning(Lint.LintCategory.PATH,\n-                                Warnings.PathElementNotFound(file));\n+                    log.warning(\n+                            LintWarnings.PathElementNotFound(file));\n@@ -391,2 +391,2 @@\n-                                log.warning(Lint.LintCategory.PATH,\n-                                            Warnings.UnexpectedArchiveFile(file));\n+                                log.warning(\n+                                        LintWarnings.UnexpectedArchiveFile(file));\n@@ -397,2 +397,2 @@\n-                                log.warning(Lint.LintCategory.PATH,\n-                                            Warnings.InvalidArchiveFile(file));\n+                                log.warning(\n+                                        LintWarnings.InvalidArchiveFile(file));\n@@ -1663,3 +1663,3 @@\n-                            ? Warnings.DirPathElementNotDirectory(prefix)\n-                            : Warnings.DirPathElementNotFound(prefix);\n-                    log.warning(Lint.LintCategory.PATH, key);\n+                            ? LintWarnings.DirPathElementNotDirectory(prefix)\n+                            : LintWarnings.DirPathElementNotFound(prefix);\n+                    log.warning(key);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/Locations.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -858,2 +859,2 @@\n-                        log.warning(LintCategory.CLASSFILE, (DiagnosticPosition) null,\n-                                    Warnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));\n+                        log.warning((DiagnosticPosition) null,\n+                                    LintWarnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));\n@@ -1613,1 +1614,1 @@\n-                log.warning(LintCategory.CLASSFILE, Warnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n+                log.warning(LintWarnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n@@ -2081,1 +2082,1 @@\n-                        log.warning(Warnings.AnnotationMethodNotFound(container, name));\n+                        log.warning(LintWarnings.AnnotationMethodNotFound(container, name));\n@@ -2083,1 +2084,1 @@\n-                        log.warning(Warnings.AnnotationMethodNotFoundReason(container,\n+                        log.warning(LintWarnings.AnnotationMethodNotFoundReason(container,\n@@ -2963,1 +2964,1 @@\n-            log.warning(LintCategory.CLASSFILE, Warnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n+            log.warning(LintWarnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -342,1 +342,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n@@ -445,1 +444,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/JNIWriter.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -500,1 +501,1 @@\n-                            log.warning(LintCategory.PATH, Warnings.OutdirIsInExplodedModule(outDir));\n+                            log.warning(LintWarnings.OutdirIsInExplodedModule(outDir));\n@@ -574,1 +575,1 @@\n-                        log.warning(LintCategory.OPTIONS, Warnings.SourceNoBootclasspath(source.name, releaseNote(source, targetString)));\n+                        log.warning(LintWarnings.SourceNoBootclasspath(source.name, releaseNote(source, targetString)));\n@@ -577,1 +578,1 @@\n-                        log.warning(LintCategory.OPTIONS, Warnings.SourceNoSystemModulesPath(source.name, releaseNote(source, targetString)));\n+                        log.warning(LintWarnings.SourceNoSystemModulesPath(source.name, releaseNote(source, targetString)));\n@@ -587,1 +588,1 @@\n-            log.warning(LintCategory.OPTIONS, Warnings.OptionObsoleteSource(source.name));\n+            log.warning(LintWarnings.OptionObsoleteSource(source.name));\n@@ -594,1 +595,1 @@\n-            log.warning(LintCategory.OPTIONS, Warnings.OptionObsoleteTarget(target));\n+            log.warning(LintWarnings.OptionObsoleteTarget(target));\n@@ -628,1 +629,1 @@\n-            log.warning(LintCategory.OPTIONS, Warnings.OptionObsoleteSuppression);\n+            log.warning(LintWarnings.OptionObsoleteSuppression);\n@@ -639,1 +640,1 @@\n-            log.warning(LintCategory.OPTIONS, Warnings.AddopensIgnored);\n+            log.warning(LintWarnings.AddopensIgnored);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Arguments.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,1 +223,1 @@\n-        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+        @SuppressWarnings(\"unchecked\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/AnnotationProxyMaker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -38,1 +39,0 @@\n-import com.sun.tools.javac.tree.JCTree;\n@@ -43,1 +43,0 @@\n-import java.util.Iterator;\n@@ -225,1 +224,0 @@\n-     * @param lc     lint category.\n@@ -229,1 +227,1 @@\n-    protected void lexWarning(LintCategory lc, int pos, JCDiagnostic.Warning key) {\n+    protected void lexWarning(int pos, JCDiagnostic.Warning key) {\n@@ -231,1 +229,1 @@\n-        log.warning(lc, dp, key);\n+        log.warning(dp, key);\n@@ -1078,2 +1076,2 @@\n-                            lexWarning(LintCategory.TEXT_BLOCKS, pos,\n-                                    Warnings.InconsistentWhiteSpaceIndentation);\n+                            lexWarning(pos,\n+                                    LintWarnings.InconsistentWhiteSpaceIndentation);\n@@ -1082,2 +1080,2 @@\n-                            lexWarning(LintCategory.TEXT_BLOCKS, pos,\n-                                    Warnings.TrailingWhiteSpaceWillBeRemoved);\n+                            lexWarning(pos,\n+                                    LintWarnings.TrailingWhiteSpaceWillBeRemoved);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -672,2 +673,2 @@\n-                    log.warning(Lint.LintCategory.DANGLING_DOC_COMMENTS,\n-                            pos, Warnings.DanglingDocComment);\n+                    log.warning(\n+                            pos, LintWarnings.DanglingDocComment);\n@@ -2836,1 +2837,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n@@ -2894,1 +2894,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,0 @@\n-    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/UnicodeReader.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -495,1 +496,1 @@\n-                    log.warning(Warnings.ProcSuspiciousClassName(name, extn));\n+                    log.warning(LintWarnings.ProcSuspiciousClassName(name, extn));\n@@ -711,1 +712,1 @@\n-                log.warning(Warnings.ProcIllegalFileName(name));\n+                log.warning(LintWarnings.ProcIllegalFileName(name));\n@@ -740,1 +741,1 @@\n-                log.warning(Warnings.ProcTypeRecreate(typename));\n+                log.warning(LintWarnings.ProcTypeRecreate(typename));\n@@ -744,1 +745,1 @@\n-            log.warning(Warnings.ProcTypeAlreadyExists(typename));\n+            log.warning(LintWarnings.ProcTypeAlreadyExists(typename));\n@@ -774,1 +775,1 @@\n-                log.warning(Warnings.ProcFileReopening(fileObject.getName()));\n+                log.warning(LintWarnings.ProcFileReopening(fileObject.getName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacFiler.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -651,1 +652,1 @@\n-                        log.warning(Warnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n+                        log.warning(LintWarnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n@@ -665,1 +666,1 @@\n-                    log.warning(Warnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n+                    log.warning(LintWarnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n@@ -673,1 +674,1 @@\n-                            log.warning(Warnings.ProcDuplicateOptionName(optionName,\n+                            log.warning(LintWarnings.ProcDuplicateOptionName(optionName,\n@@ -894,1 +895,1 @@\n-                log.warning(Warnings.ProcAnnotationsWithoutProcessors(unmatchedAnnotations.keySet()));\n+                log.warning(LintWarnings.ProcAnnotationsWithoutProcessors(unmatchedAnnotations.keySet()));\n@@ -1691,1 +1692,1 @@\n-            log.warning(Warnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n+            log.warning(LintWarnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -711,0 +711,1 @@\n+# lint: this-escape\n@@ -714,0 +715,1 @@\n+# lint: this-escape\n@@ -734,0 +736,1 @@\n+# lint: text-blocks\n@@ -737,0 +740,1 @@\n+# lint: text-blocks\n@@ -1594,0 +1598,1 @@\n+# lint: path\n@@ -1661,0 +1666,1 @@\n+# lint: output-file-clash\n@@ -1873,0 +1879,1 @@\n+# lint: serial\n@@ -1876,0 +1883,1 @@\n+# lint: dangling-doc-comments\n@@ -1880,0 +1888,1 @@\n+# lint: path\n@@ -1884,0 +1893,1 @@\n+# lint: path\n@@ -1888,0 +1898,1 @@\n+# lint: missing-explicit-ctor\n@@ -1891,0 +1902,1 @@\n+# lint: strictfp\n@@ -1894,0 +1906,1 @@\n+# lint: finally\n@@ -1898,0 +1911,1 @@\n+# lint: module\n@@ -1902,0 +1916,1 @@\n+# lint: incubating\n@@ -1906,0 +1921,1 @@\n+# lint: deprecation\n@@ -1910,0 +1926,1 @@\n+# lint: removal\n@@ -1914,0 +1931,1 @@\n+# lint: preview\n@@ -1923,0 +1941,1 @@\n+# lint: preview\n@@ -1927,0 +1946,1 @@\n+# lint: restricted\n@@ -1932,0 +1952,1 @@\n+# lint: deprecation\n@@ -1936,0 +1957,1 @@\n+# lint: removal\n@@ -1947,0 +1969,1 @@\n+# lint: serial\n@@ -1950,0 +1973,1 @@\n+# lint: serial\n@@ -1953,0 +1977,1 @@\n+# lint: serial\n@@ -1975,0 +2000,1 @@\n+# lint: serial\n@@ -1978,0 +2004,1 @@\n+# lint: serial\n@@ -1982,0 +2009,1 @@\n+# lint: serial\n@@ -1986,0 +2014,1 @@\n+# lint: serial\n@@ -1990,0 +2019,1 @@\n+# lint: serial\n@@ -1994,0 +2024,1 @@\n+# lint: serial\n@@ -1998,0 +2029,1 @@\n+# lint: serial\n@@ -2002,0 +2034,1 @@\n+# lint: serial\n@@ -2006,0 +2039,1 @@\n+# lint: serial\n@@ -2010,0 +2044,1 @@\n+# lint: serial\n@@ -2014,0 +2049,1 @@\n+# lint: serial\n@@ -2019,0 +2055,1 @@\n+# lint: serial\n@@ -2022,0 +2059,1 @@\n+# lint: serial\n@@ -2026,0 +2064,1 @@\n+# lint: serial\n@@ -2030,0 +2069,1 @@\n+# lint: serial\n@@ -2034,0 +2074,1 @@\n+# lint: serial\n@@ -2037,0 +2078,1 @@\n+# lint: serial\n@@ -2041,0 +2083,1 @@\n+# lint: serial\n@@ -2045,0 +2088,1 @@\n+# lint: serial\n@@ -2049,0 +2093,1 @@\n+# lint: serial\n@@ -2052,0 +2097,1 @@\n+# lint: serial\n@@ -2055,0 +2101,1 @@\n+# lint: serial\n@@ -2058,0 +2105,1 @@\n+# lint: serial\n@@ -2062,0 +2110,1 @@\n+# lint: serial\n@@ -2065,0 +2114,1 @@\n+# lint: serial\n@@ -2069,0 +2119,1 @@\n+# lint: serial\n@@ -2073,0 +2124,1 @@\n+# lint: overloads\n@@ -2077,0 +2129,1 @@\n+# lint: overrides\n@@ -2081,0 +2134,1 @@\n+# lint: overrides\n@@ -2093,0 +2147,1 @@\n+# lint: path\n@@ -2096,0 +2151,1 @@\n+# lint: fallthrough\n@@ -2100,0 +2156,1 @@\n+# lint: cast\n@@ -2117,0 +2174,1 @@\n+# lint: static\n@@ -2121,0 +2179,1 @@\n+# lint: static\n@@ -2125,0 +2184,1 @@\n+# lint: options\n@@ -2129,0 +2189,1 @@\n+# lint: options\n@@ -2153,0 +2214,1 @@\n+# lint: options\n@@ -2157,0 +2219,1 @@\n+# lint: options\n@@ -2168,0 +2231,1 @@\n+# lint: options\n@@ -2172,0 +2236,1 @@\n+# lint: classfile\n@@ -2175,0 +2240,1 @@\n+# lint: requires-automatic\n@@ -2178,0 +2244,1 @@\n+# lint: requires-transitive-automatic\n@@ -2187,0 +2254,1 @@\n+# lint: processing\n@@ -2191,0 +2259,1 @@\n+# lint: processing\n@@ -2195,0 +2264,1 @@\n+# lint: processing\n@@ -2199,0 +2269,1 @@\n+# lint: processing\n@@ -2203,0 +2274,1 @@\n+# lint: processing\n@@ -2211,0 +2283,1 @@\n+# lint: processing\n@@ -2215,0 +2288,1 @@\n+# lint: processing\n@@ -2223,0 +2297,1 @@\n+# lint: processing\n@@ -2227,0 +2302,1 @@\n+# lint: processing\n@@ -2232,0 +2308,1 @@\n+# lint: processing\n@@ -2259,0 +2336,1 @@\n+# lint: try\n@@ -2263,0 +2341,1 @@\n+# lint: try\n@@ -2267,0 +2346,1 @@\n+# lint: try\n@@ -2270,0 +2350,1 @@\n+# lint: unchecked\n@@ -2274,0 +2355,1 @@\n+# lint: unchecked\n@@ -2278,0 +2360,1 @@\n+# lint: unchecked\n@@ -2281,0 +2364,1 @@\n+# lint: unchecked\n@@ -2285,0 +2369,1 @@\n+# lint: unchecked\n@@ -2291,0 +2376,1 @@\n+# lint: unchecked\n@@ -2295,0 +2381,1 @@\n+# lint: unchecked\n@@ -2299,0 +2386,1 @@\n+# lint: varargs\n@@ -2302,0 +2390,1 @@\n+# lint: dep-ann\n@@ -2306,0 +2395,1 @@\n+# lint: deprecation\n@@ -2310,0 +2400,1 @@\n+# lint: path\n@@ -2322,0 +2413,1 @@\n+# lint: path\n@@ -2326,0 +2418,1 @@\n+# lint: path\n@@ -2333,0 +2426,1 @@\n+# lint: divzero\n@@ -2336,0 +2430,1 @@\n+# lint: empty\n@@ -2340,0 +2435,1 @@\n+# lint: classfile\n@@ -2344,0 +2440,1 @@\n+# lint: classfile\n@@ -2362,0 +2459,1 @@\n+# lint: rawtypes\n@@ -2379,0 +2477,1 @@\n+# lint: varargs\n@@ -2383,0 +2482,1 @@\n+# lint: serial\n@@ -2387,0 +2487,1 @@\n+# lint: serial\n@@ -2544,0 +2645,1 @@\n+# lint: classfile\n@@ -2550,0 +2652,1 @@\n+# lint: classfile\n@@ -2676,0 +2779,1 @@\n+# lint: unchecked\n@@ -2690,0 +2794,1 @@\n+# lint: lossy-conversions\n@@ -2865,0 +2970,1 @@\n+# lint: auxiliaryclass\n@@ -3069,0 +3175,1 @@\n+# lint: unchecked\n@@ -3074,0 +3181,1 @@\n+# lint: unchecked\n@@ -3079,0 +3187,1 @@\n+# lint: overrides\n@@ -3171,0 +3280,1 @@\n+# lint: preview\n@@ -3175,0 +3285,1 @@\n+# lint: preview\n@@ -3179,0 +3290,1 @@\n+# lint: preview\n@@ -3248,0 +3360,1 @@\n+# L10N: do not localize: transitive\n@@ -3561,0 +3674,1 @@\n+# lint: module\n@@ -3656,0 +3770,1 @@\n+# lint: opens\n@@ -3739,0 +3854,1 @@\n+# lint: options\n@@ -3754,0 +3870,1 @@\n+# lint: options\n@@ -3773,1 +3890,1 @@\n-    bad requires flag: {0}\n+    invalid flag for \"requires java.base\": {0}\n@@ -3784,0 +3901,1 @@\n+# lint: exports\n@@ -3787,0 +3905,1 @@\n+# lint: exports\n@@ -3790,0 +3909,1 @@\n+# lint: exports\n@@ -3793,0 +3913,1 @@\n+# lint: exports\n@@ -4122,0 +4243,1 @@\n+# lint: preview\n@@ -4125,0 +4247,1 @@\n+# lint: synchronization\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":124,"deletions":1,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -638,0 +638,3 @@\n+# 0: symbol\n+compiler.err.annotation.array.too.large=Annotationsarrayelement zu gro in \"{0}\"\n+\n@@ -659,3 +662,0 @@\n-# 0: name\n-compiler.err.modifier.not.allowed.here=Modifikator {0} hier nicht zulssig\n-\n@@ -784,3 +784,0 @@\n-# 0: symbol, 1: list of type, 2: type\n-compiler.misc.cant.access.inner.cls.constr=Zugriff auf Konstruktor {0}({1}) nicht mglich\\nEinschlieende Instanz vom Typ {2} ist nicht im Geltungsbereich\n-\n@@ -1151,0 +1148,4 @@\n+compiler.err.statement.not.expected=Anweisungen werden auerhalb von Methoden und Initializern nicht erwartet\n+\n+compiler.err.class.method.or.field.expected=Klasse, Schnittstelle, Annotationstyp, Enumeration, Datensatz, Methode oder Feld erwartet\n+\n@@ -1592,0 +1593,1 @@\n+\n@@ -1674,0 +1676,3 @@\n+# 0: list of annotation, 1: symbol, 2: name, 3: message segment\n+compiler.err.cant.attach.type.annotations=Typannotationen {0} knnen nicht an {1}.{2} angehngt werden:\\n{3}\n+\n@@ -1809,1 +1814,5 @@\n-compiler.misc.bad.runtime.invisible.param.annotations=Ungltiges RuntimeInvisibleParameterAnnotations-Attribut: {0}\n+# 0: file name\n+compiler.warn.runtime.visible.invisible.param.annotations.mismatch=Die Lngen der Parameter im RuntimeVisibleParameterAnnotations-Attribut und RuntimeInvisibleParameterAnnotations-Attribut in {0} stimmen nicht berein. Beide Attribute werden ignoriert\n+\n+# 0: file name\n+compiler.warn.runtime.invisible.parameter.annotations=Die Attribute RuntimeVisibleParameterAnnotations und RuntimeInvisibleParameterAnnotations in {0} knnen nicht den Parametern der Methode zugeordnet werden\n@@ -2041,0 +2050,4 @@\n+## The first argument ({0}) is a \"kindname\".\n+# 0: symbol kind, 1: symbol\n+compiler.err.local.cant.be.inst.static={0} {1} ist lokal und kann nicht aus einem statischen Kontext instanziiert werden\n+\n@@ -2289,0 +2302,3 @@\n+# L10N: do not localize: transitive\n+compiler.misc.feature.java.base.transitive=transitive Modifikator fr java.base\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler_de.properties","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -638,0 +638,3 @@\n+# 0: symbol\n+compiler.err.annotation.array.too.large=\"{0}\"\n+\n@@ -659,3 +662,0 @@\n-# 0: name\n-compiler.err.modifier.not.allowed.here={0}\n-\n@@ -784,3 +784,0 @@\n-# 0: symbol, 1: list of type, 2: type\n-compiler.misc.cant.access.inner.cls.constr={0}({1})\\n{2}\n-\n@@ -1151,0 +1148,4 @@\n+compiler.err.statement.not.expected=\n+\n+compiler.err.class.method.or.field.expected=\n+\n@@ -1592,0 +1593,1 @@\n+\n@@ -1674,0 +1676,3 @@\n+# 0: list of annotation, 1: symbol, 2: name, 3: message segment\n+compiler.err.cant.attach.type.annotations={0}{1}.{2}:\\n{3}\n+\n@@ -1809,1 +1814,5 @@\n-compiler.misc.bad.runtime.invisible.param.annotations=RuntimeInvisibleParameterAnnotations: {0}\n+# 0: file name\n+compiler.warn.runtime.visible.invisible.param.annotations.mismatch={0}RuntimeVisibleParameterAnnotationsRuntimeInvisibleParameterAnnotations\n+\n+# 0: file name\n+compiler.warn.runtime.invisible.parameter.annotations={0}RuntimeVisibleParameterAnnotationsRuntimeInvisibleParameterAnnotations\n@@ -2041,0 +2050,4 @@\n+## The first argument ({0}) is a \"kindname\".\n+# 0: symbol kind, 1: symbol\n+compiler.err.local.cant.be.inst.static={0} {1}static\n+\n@@ -2289,0 +2302,3 @@\n+# L10N: do not localize: transitive\n+compiler.misc.feature.java.base.transitive=java.base\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler_ja.properties","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -638,0 +638,3 @@\n+# 0: symbol\n+compiler.err.annotation.array.too.large=\"{0}\" \n+\n@@ -659,3 +662,0 @@\n-# 0: name\n-compiler.err.modifier.not.allowed.here={0}\n-\n@@ -784,3 +784,0 @@\n-# 0: symbol, 1: list of type, 2: type\n-compiler.misc.cant.access.inner.cls.constr= {0}({1})\\n{2}\n-\n@@ -1151,0 +1148,4 @@\n+compiler.err.statement.not.expected=\n+\n+compiler.err.class.method.or.field.expected=\n+\n@@ -1592,0 +1593,1 @@\n+\n@@ -1674,0 +1676,3 @@\n+# 0: list of annotation, 1: symbol, 2: name, 3: message segment\n+compiler.err.cant.attach.type.annotations= {0}  {1}.{2}\\n{3}\n+\n@@ -1809,1 +1814,5 @@\n-compiler.misc.bad.runtime.invisible.param.annotations= RuntimeInvisibleParameterAnnotations : {0}\n+# 0: file name\n+compiler.warn.runtime.visible.invisible.param.annotations.mismatch={0}  RuntimeVisibleParameterAnnotations  RuntimeInvisibleParameterAnnotations \n+\n+# 0: file name\n+compiler.warn.runtime.invisible.parameter.annotations={0}  RuntimeVisibleParameterAnnotations  RuntimeInvisibleParameterAnnotations \n@@ -2041,0 +2050,4 @@\n+## The first argument ({0}) is a \"kindname\".\n+# 0: symbol kind, 1: symbol\n+compiler.err.local.cant.be.inst.static= {0} {1}\n+\n@@ -2289,0 +2302,3 @@\n+# L10N: do not localize: transitive\n+compiler.misc.feature.java.base.transitive=java.base \n+\n@@ -2741,1 +2757,1 @@\n-compiler.err.record.cant.declare.field.modifiers=\n+compiler.err.record.cant.declare.field.modifiers=\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler_zh_CN.properties","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-javac.opt.Xlint.custom=Warnungen, die aktiviert oder deaktiviert werden sollen, durch Komma getrennt.\\nStellen Sie einem Schlssel \"-\" voran, um die angegebene Warnung zu deaktivieren.\\nVerwenden Sie --help-lint, um die untersttzten Schlssel zu sehen.\n+javac.opt.Xlint.custom=Warnungen, die aktiviert oder deaktiviert werden sollen, durch Komma getrennt.\\nStellen Sie einem Schlssel \"-\" voran, um die angegebene Warnung zu deaktivieren.\\nVerwenden Sie \"--help-lint\", um die untersttzten Schlssel anzuzeigen.\n@@ -190,1 +190,1 @@\n-javac.opt.Xdoclint.package.desc=Aktiviert oder deaktiviert Prfungen in bestimmten Packages. Jedes <Package> ist entweder der\\nqualifizierte Name eines Packages oder ein Packagenamensprfix, gefolgt von \".*\",\\ndas sich auf alle Subpackages des angegebenen Packages bezieht. Jedem <Package>\\nkann \"-\" vorangestellt werden, um Prfungen fr die angegebenen Packages zu deaktivieren.\n+javac.opt.Xdoclint.package.desc=Aktiviert oder deaktiviert Prfungen in bestimmten Packages. Jedes <Package> ist entweder\\nein qualifizierter Packagename oder ein Packagenamensprfix, gefolgt von \".*\",\\ndas sich auf alle Subpackages des angegebenen Packages bezieht. Jedem <Package>\\nkann \"-\" vorangestellt werden, um Prfungen fr die angegebenen Packages zu deaktivieren.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac_de.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-javac.opt.Xlint.custom=()\\n'-'\\n--help-lint\n+javac.opt.Xlint.custom=()\\n''-''\\n--help-lint\n@@ -190,1 +190,1 @@\n-javac.opt.Xdoclint.package.desc=<package>\\n'.*'\\n()<package>\\n'-'1\n+javac.opt.Xdoclint.package.desc=<package>\\n''.*''\\n()<package>\\n''-''1\n@@ -219,1 +219,1 @@\n-javac.opt.lineDocComments='\/\/\/'\n+javac.opt.lineDocComments=''\/\/\/''\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac_ja.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-javac.opt.nogj=\n+javac.opt.nogj=\n@@ -104,2 +104,2 @@\n-javac.opt.arg.Xlint=<>(,<>)*\n-javac.opt.Xlint.custom=\\n '-' \\n --help-lint \n+javac.opt.arg.Xlint=<key>(,<key>)*\n+javac.opt.Xlint.custom=\\n ''-'' \\n --help-lint \n@@ -190,1 +190,1 @@\n-javac.opt.Xdoclint.package.desc= <> \\n '.*'\\n <>\\n '-' \n+javac.opt.Xdoclint.package.desc= <> \\n ''.*''\\n <>\\n ''-'' \n@@ -219,1 +219,1 @@\n-javac.opt.lineDocComments= '\/\/\/' \n+javac.opt.lineDocComments= ''\/\/\/'' \n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac_zh_CN.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -889,1 +889,0 @@\n-        @SuppressWarnings(\"removal\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -158,3 +157,5 @@\n-    \/** Report a warning, unless suppressed by the  -nowarn option or the\n-     *  maximum number of warnings has been reached.\n-     *  @param warningKey    The key for the localized warning message.\n+    \/**\n+     * Report a lint warning, unless suppressed by the  -nowarn option or the\n+     * maximum number of warnings has been reached.\n+     *\n+     * @param warningKey The key for the localized warning message.\n@@ -163,10 +164,1 @@\n-        report(diags.warning(null, source, null, warningKey));\n-    }\n-\n-    \/** Report a lint warning, unless suppressed by the  -nowarn option or the\n-     *  maximum number of warnings has been reached.\n-     *  @param lc     The lint category for the diagnostic\n-     *  @param warningKey    The key for the localized warning message.\n-     *\/\n-    public void warning(LintCategory lc, Warning warningKey) {\n-        report(diags.warning(lc, null, null, warningKey));\n+        report(diags.warning(source, null, warningKey));\n@@ -181,11 +173,1 @@\n-        report(diags.warning(null, source, pos, warningKey));\n-    }\n-\n-    \/** Report a lint warning, unless suppressed by the  -nowarn option or the\n-     *  maximum number of warnings has been reached.\n-     *  @param lc     The lint category for the diagnostic\n-     *  @param pos    The source position at which to report the warning.\n-     *  @param warningKey    The key for the localized warning message.\n-     *\/\n-    public void warning(LintCategory lc, DiagnosticPosition pos, Warning warningKey) {\n-        report(diags.warning(lc, source, pos, warningKey));\n+        report(diags.warning(source, pos, warningKey));\n@@ -200,1 +182,1 @@\n-        report(diags.warning(null, source, wrap(pos), warningKey));\n+        report(diags.warning(source, wrap(pos), warningKey));\n@@ -208,10 +190,1 @@\n-        report(diags.mandatoryWarning(null, source, pos, warningKey));\n-    }\n-\n-    \/** Report a warning.\n-     *  @param lc     The lint category for the diagnostic\n-     *  @param pos    The source position at which to report the warning.\n-     *  @param warningKey    The key for the localized warning message.\n-     *\/\n-    public void mandatoryWarning(LintCategory lc, DiagnosticPosition pos, Warning warningKey) {\n-        report(diags.mandatoryWarning(lc, source, pos, warningKey));\n+        report(diags.mandatoryWarning(source, pos, warningKey));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/AbstractLog.java","additions":9,"deletions":36,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-            JCDiagnostic diag = create(null, EnumSet.copyOf(defaultErrorFlags), source, pos, errorKey);\n+            JCDiagnostic diag = create(EnumSet.copyOf(defaultErrorFlags), source, pos, errorKey);\n@@ -133,1 +133,1 @@\n-            return mandatoryWarning(lc, source, pos, warningKey(key, args));\n+            return mandatoryWarning(source, pos, warningKey(lc, key, args));\n@@ -138,1 +138,0 @@\n-         *  @param lc     The lint category for the diagnostic\n@@ -145,1 +144,0 @@\n-                LintCategory lc,\n@@ -147,1 +145,1 @@\n-            return create(lc, EnumSet.of(DiagnosticFlag.MANDATORY), source, pos, warningKey);\n+            return create(EnumSet.of(DiagnosticFlag.MANDATORY), source, pos, warningKey);\n@@ -161,1 +159,1 @@\n-            return warning(lc, source, pos, warningKey(key, args));\n+            return warning(source, pos, warningKey(lc, key, args));\n@@ -166,1 +164,0 @@\n-         *  @param lc     The lint category for the diagnostic\n@@ -173,2 +170,2 @@\n-                LintCategory lc, DiagnosticSource source, DiagnosticPosition pos, Warning warningKey) {\n-            return create(lc, EnumSet.noneOf(DiagnosticFlag.class), source, pos, warningKey);\n+                DiagnosticSource source, DiagnosticPosition pos, Warning warningKey) {\n+            return create(EnumSet.noneOf(DiagnosticFlag.class), source, pos, warningKey);\n@@ -194,1 +191,1 @@\n-            return create(null, EnumSet.of(DiagnosticFlag.MANDATORY), source, null, noteKey);\n+            return create(EnumSet.of(DiagnosticFlag.MANDATORY), source, null, noteKey);\n@@ -215,1 +212,1 @@\n-            return create(null, EnumSet.noneOf(DiagnosticFlag.class), source, pos, noteKey);\n+            return create(EnumSet.noneOf(DiagnosticFlag.class), source, pos, noteKey);\n@@ -232,1 +229,1 @@\n-            return create(null, EnumSet.noneOf(DiagnosticFlag.class), null, null, fragmentKey);\n+            return create(EnumSet.noneOf(DiagnosticFlag.class), null, null, fragmentKey);\n@@ -246,1 +243,1 @@\n-            return create(null, EnumSet.noneOf(DiagnosticFlag.class), source, pos, DiagnosticInfo.of(kind, prefix, key, args));\n+            return create(EnumSet.noneOf(DiagnosticFlag.class), source, pos, DiagnosticInfo.of(kind, prefix, key, args));\n@@ -261,1 +258,1 @@\n-            return create(null, EnumSet.noneOf(DiagnosticFlag.class), source, pos, DiagnosticInfo.of(kind, prefix, key, args), rewriter);\n+            return create(EnumSet.noneOf(DiagnosticFlag.class), source, pos, DiagnosticInfo.of(kind, prefix, key, args), rewriter);\n@@ -273,1 +270,1 @@\n-            return create(null, EnumSet.noneOf(DiagnosticFlag.class), source, pos, diagnosticInfo);\n+            return create(EnumSet.noneOf(DiagnosticFlag.class), source, pos, diagnosticInfo);\n@@ -288,1 +285,1 @@\n-            return create(lc, flags, source, pos, DiagnosticInfo.of(kind, prefix, key, args));\n+            return create(flags, source, pos, DiagnosticInfo.of(kind, lc, prefix, key, args));\n@@ -293,1 +290,0 @@\n-         *  @param lc          The lint category, if applicable, or null\n@@ -300,2 +296,2 @@\n-                LintCategory lc, Set<DiagnosticFlag> flags, DiagnosticSource source, DiagnosticPosition pos, DiagnosticInfo diagnosticInfo) {\n-            return new JCDiagnostic(formatter, normalize(diagnosticInfo), lc, flags, source, pos);\n+                Set<DiagnosticFlag> flags, DiagnosticSource source, DiagnosticPosition pos, DiagnosticInfo diagnosticInfo) {\n+            return new JCDiagnostic(formatter, normalize(diagnosticInfo), flags, source, pos);\n@@ -305,2 +301,2 @@\n-                LintCategory lc, Set<DiagnosticFlag> flags, DiagnosticSource source, DiagnosticPosition pos, DiagnosticInfo diagnosticInfo, UnaryOperator<JCDiagnostic> rewriter) {\n-            return new JCDiagnostic(formatter, normalize(diagnosticInfo), lc, flags, source, pos, rewriter);\n+                Set<DiagnosticFlag> flags, DiagnosticSource source, DiagnosticPosition pos, DiagnosticInfo diagnosticInfo, UnaryOperator<JCDiagnostic> rewriter) {\n+            return new JCDiagnostic(formatter, normalize(diagnosticInfo), flags, source, pos, rewriter);\n@@ -311,1 +307,3 @@\n-                return DiagnosticInfo.of(diagnosticInfo.type, diagnosticInfo.prefix, diagnosticInfo.code,\n+                LintCategory category = diagnosticInfo instanceof LintWarning lintWarning ?\n+                        lintWarning.category : null;\n+                return DiagnosticInfo.of(diagnosticInfo.type, category, diagnosticInfo.prefix, diagnosticInfo.code,\n@@ -328,2 +326,2 @@\n-        Warning warningKey(String code, Object... args) {\n-            return (Warning)DiagnosticInfo.of(WARNING, prefix, code, args);\n+        Warning warningKey(LintCategory lintCategory, String code, Object... args) {\n+            return (Warning)DiagnosticInfo.of(WARNING, lintCategory, prefix, code, args);\n@@ -359,0 +357,1 @@\n+                                      null,\n@@ -362,1 +361,0 @@\n-                              null,\n@@ -467,1 +465,0 @@\n-    private final LintCategory lintCategory;\n@@ -540,0 +537,4 @@\n+            return of(type, null, prefix, code, args);\n+        }\n+\n+        public static DiagnosticInfo of(DiagnosticType type, LintCategory lc, String prefix, String code, Object... args) {\n@@ -544,1 +545,3 @@\n-                    return new Warning(prefix, code, args);\n+                    return lc == null ?\n+                            new Warning(prefix, code, args) :\n+                            new LintWarning(lc, prefix, code, args);\n@@ -586,1 +589,1 @@\n-    public static final class Warning extends DiagnosticInfo {\n+    public static sealed class Warning extends DiagnosticInfo {\n@@ -592,0 +595,16 @@\n+    \/**\n+     * Class representing lint warning diagnostic keys.\n+     *\/\n+    public static final class LintWarning extends Warning {\n+        final LintCategory category;\n+\n+        public LintWarning(LintCategory category, String prefix, String key, Object... args) {\n+            super(prefix, key, args);\n+            this.category = category;\n+        }\n+\n+        public LintCategory getLintCategory() {\n+            return category;\n+        }\n+    }\n+\n@@ -617,1 +636,0 @@\n-     * @param lc     the lint category for the diagnostic\n@@ -623,1 +641,0 @@\n-                       LintCategory lc,\n@@ -627,1 +644,1 @@\n-        this(formatter, diagnosticInfo, lc, flags, source, pos, null);\n+        this(formatter, diagnosticInfo, flags, source, pos, null);\n@@ -634,1 +651,0 @@\n-     * @param lc     the lint category for the diagnostic\n@@ -641,1 +657,0 @@\n-                           LintCategory lc,\n@@ -651,1 +666,0 @@\n-        this.lintCategory = lc;\n@@ -690,1 +704,1 @@\n-        return (lintCategory != null);\n+        return getLintCategory() != null;\n@@ -697,1 +711,2 @@\n-        return lintCategory;\n+        return diagnosticInfo instanceof LintWarning lintWarning ?\n+                lintWarning.category : null;\n@@ -873,1 +888,0 @@\n-                  other.getLintCategory(),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/JCDiagnostic.java","additions":51,"deletions":37,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-    @SuppressWarnings({\"varargs\", \"unchecked\"})\n+    @SuppressWarnings(\"unchecked\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/List.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -129,1 +130,1 @@\n-    public void report(DiagnosticPosition pos, Warning warnKey) {\n+    public void report(DiagnosticPosition pos, LintWarning warnKey) {\n@@ -131,0 +132,1 @@\n+        Assert.check(warnKey.getLintCategory() == lintCategory);\n@@ -262,1 +264,1 @@\n-            log.mandatoryWarning(lintCategory, pos, warnKey);\n+            log.mandatoryWarning(pos, warnKey);\n@@ -264,1 +266,1 @@\n-            log.warning(lintCategory, pos, warnKey);\n+            log.warning(pos, warnKey);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/MandatoryWarningHandler.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+    public final Name java_se;\n@@ -318,0 +319,1 @@\n+        java_se = fromString(\"java.se\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -655,1 +655,0 @@\n-        @SuppressWarnings(\"fallthrough\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/RichDiagnosticFormatter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,0 @@\n-    @SuppressWarnings(\"serial\")\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11TlsPrfGenerator.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,4 +106,0 @@\n-  public long computeModifierFlags() {\n-     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ArrayKlass.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -437,40 +437,0 @@\n-  \/\/ refer to compute_modifier_flags in VM code.\n-  public long computeModifierFlags() {\n-    long access = getAccessFlags();\n-    \/\/ But check if it happens to be member class.\n-    U2Array innerClassList = getInnerClasses();\n-    int length = (innerClassList == null)? 0 : innerClassList.length();\n-    if (length > 0) {\n-       if (Assert.ASSERTS_ENABLED) {\n-          Assert.that(length % InnerClassAttributeOffset.innerClassNextOffset == 0 ||\n-                      length % InnerClassAttributeOffset.innerClassNextOffset == EnclosingMethodAttributeOffset.enclosingMethodAttributeSize,\n-                      \"just checking\");\n-       }\n-       for (int i = 0; i < length; i += InnerClassAttributeOffset.innerClassNextOffset) {\n-          if (i == length - EnclosingMethodAttributeOffset.enclosingMethodAttributeSize) {\n-              break;\n-          }\n-          int ioff = innerClassList.at(i +\n-                         InnerClassAttributeOffset.innerClassInnerClassInfoOffset);\n-          \/\/ 'ioff' can be zero.\n-          \/\/ refer to JVM spec. section 4.7.5.\n-          if (ioff != 0) {\n-             \/\/ only look at classes that are already loaded\n-             \/\/ since we are looking for the flags for our self.\n-             Symbol name = getConstants().getKlassNameAt(ioff);\n-\n-             if (name.equals(getName())) {\n-                \/\/ This is really a member class\n-                access = innerClassList.at(i +\n-                        InnerClassAttributeOffset.innerClassAccessFlagsOffset);\n-                break;\n-             }\n-          }\n-       } \/\/ for inner classes\n-    }\n-\n-    \/\/ Remember to strip ACC_SUPER bit\n-    return (access & (~JVM_ACC_SUPER)) & JVM_ACC_WRITTEN_FLAGS;\n-  }\n-\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -136,17 +136,0 @@\n-  \/\/ computed access flags - takes care of inner classes etc.\n-  \/\/ This is closer to actual source level than getAccessFlags() etc.\n-  public long computeModifierFlags() {\n-    return 0L; \/\/ Unless overridden, modifier_flags is 0.\n-  }\n-\n-  \/\/ same as JVM_GetClassModifiers\n-  public final long getClassModifiers() {\n-    \/\/ unlike the VM counterpart we never have to deal with primitive type,\n-    \/\/ because we operator on Klass and not an instance of java.lang.Class.\n-    long flags = computeModifierFlags();\n-    if (isSuper()) {\n-       flags |= JVM_ACC_SUPER;\n-    }\n-    return flags;\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Klass.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,13 +63,0 @@\n-  public long computeModifierFlags() {\n-    long elementFlags = getElementKlass().computeModifierFlags();\n-    long arrayFlags = 0L;\n-    if ((elementFlags & (JVM_ACC_PUBLIC | JVM_ACC_PROTECTED)) != 0) {\n-       \/\/ The array type is public if the component type is public or protected\n-       arrayFlags = JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;\n-    } else {\n-       \/\/ The array type is private if the component type is private\n-       arrayFlags = JVM_ACC_ABSTRACT | JVM_ACC_FINAL;\n-    }\n-    return arrayFlags;\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ObjArrayKlass.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2430,0 +2430,1 @@\n+        Objects.requireNonNull(shuffle);\n@@ -2455,1 +2456,1 @@\n-\n+        Objects.requireNonNull(shuffle);\n@@ -2871,0 +2872,4 @@\n+            case VECTOR_OP_UMIN: return (v, m) ->\n+                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (byte) VectorMath.minUnsigned(a, b)));\n+            case VECTOR_OP_UMAX: return (v, m) ->\n+                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (byte) VectorMath.maxUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2260,0 +2260,1 @@\n+        Objects.requireNonNull(shuffle);\n@@ -2285,1 +2286,1 @@\n-\n+        Objects.requireNonNull(shuffle);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2272,0 +2272,1 @@\n+        Objects.requireNonNull(shuffle);\n@@ -2297,1 +2298,1 @@\n-\n+        Objects.requireNonNull(shuffle);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2415,0 +2415,1 @@\n+        Objects.requireNonNull(shuffle);\n@@ -2440,1 +2441,1 @@\n-\n+        Objects.requireNonNull(shuffle);\n@@ -2856,0 +2857,4 @@\n+            case VECTOR_OP_UMIN: return (v, m) ->\n+                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (int) VectorMath.minUnsigned(a, b)));\n+            case VECTOR_OP_UMAX: return (v, m) ->\n+                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (int) VectorMath.maxUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2281,0 +2281,1 @@\n+        Objects.requireNonNull(shuffle);\n@@ -2306,1 +2307,1 @@\n-\n+        Objects.requireNonNull(shuffle);\n@@ -2722,0 +2723,4 @@\n+            case VECTOR_OP_UMIN: return (v, m) ->\n+                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (long) VectorMath.minUnsigned(a, b)));\n+            case VECTOR_OP_UMAX: return (v, m) ->\n+                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (long) VectorMath.maxUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2431,0 +2431,1 @@\n+        Objects.requireNonNull(shuffle);\n@@ -2456,1 +2457,1 @@\n-\n+        Objects.requireNonNull(shuffle);\n@@ -2872,0 +2873,4 @@\n+            case VECTOR_OP_UMIN: return (v, m) ->\n+                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (short) VectorMath.minUnsigned(a, b)));\n+            case VECTOR_OP_UMAX: return (v, m) ->\n+                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (short) VectorMath.maxUnsigned(a, b)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,2 +111,0 @@\n- * @param <E> the boxed version of {@code ETYPE},\n- *           the element type of a vector\n@@ -131,0 +129,3 @@\n+ *\n+ * @param <E> the boxed version of {@code ETYPE},\n+ *           the element type of a vector\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMask.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2827,0 +2827,1 @@\n+        Objects.requireNonNull(shuffle);\n@@ -2852,1 +2853,1 @@\n-\n+        Objects.requireNonNull(shuffle);\n@@ -3409,0 +3410,6 @@\n+#if[!FP]\n+            case VECTOR_OP_UMIN: return (v, m) ->\n+                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> ($type$) VectorMath.minUnsigned(a, b)));\n+            case VECTOR_OP_UMAX: return (v, m) ->\n+                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> ($type$) VectorMath.maxUnsigned(a, b)));\n+#end[!FP]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -801,2 +801,2 @@\n-            } catch (Throwable t) {\n-                resolvedHolder = null;\n+            } catch (Throwable cause) {\n+                return new UnresolvedJavaField(fieldHolder, lookupUtf8(getNameRefIndexAt(nameAndTypeIndex)), type, cause);\n@@ -805,1 +805,0 @@\n-                \/\/ There was an exception resolving the field or it returned null so return an unresolved field.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n-    public UnresolvedJavaField(JavaType holder, String name, JavaType type) {\n+    \/**\n+     * The reason field resolution failed. Can be null.\n+     *\/\n+    private final Throwable cause;\n+\n+    public UnresolvedJavaField(JavaType holder, String name, JavaType type, Throwable cause) {\n@@ -38,0 +43,12 @@\n+        this.cause = cause;\n+    }\n+\n+    public UnresolvedJavaField(JavaType holder, String name, JavaType type) {\n+        this(holder, name, type, null);\n+    }\n+\n+    \/**\n+     * Gets the exception, if any, representing the reason field resolution resulted in this object.\n+     *\/\n+    public Throwable getCause() {\n+        return cause;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/UnresolvedJavaField.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n-    public UnresolvedJavaMethod(String name, Signature signature, JavaType holder) {\n+    \/**\n+     * The reason method resolution failed. Can be null.\n+     *\/\n+    private final Throwable cause;\n+\n+    public UnresolvedJavaMethod(String name, Signature signature, JavaType holder, Throwable cause) {\n@@ -38,0 +43,12 @@\n+        this.cause = cause;\n+    }\n+\n+    public UnresolvedJavaMethod(String name, Signature signature, JavaType holder) {\n+        this(name, signature, holder, null);\n+    }\n+\n+    \/**\n+     * Gets the exception, if any, representing the reason method resolution resulted in this object.\n+     *\/\n+    public Throwable getCause() {\n+        return cause;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/UnresolvedJavaMethod.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,5 @@\n+    \/**\n+     * The reason type resolution failed. Can be null.\n+     *\/\n+    private final Throwable cause;\n+\n@@ -36,1 +41,1 @@\n-    private UnresolvedJavaType(String name) {\n+    private UnresolvedJavaType(String name, Throwable cause) {\n@@ -38,0 +43,1 @@\n+        this.cause = cause;\n@@ -45,1 +51,15 @@\n-        return new UnresolvedJavaType(name);\n+        return new UnresolvedJavaType(name, null);\n+    }\n+\n+    \/**\n+     * Creates an unresolved type for a valid {@link JavaType#getName() type name}.\n+     *\/\n+    public static UnresolvedJavaType create(String name, Throwable cause) {\n+        return new UnresolvedJavaType(name, cause);\n+    }\n+\n+    \/**\n+     * Gets the exception, if any, representing the reason type resolution resulted in this object.\n+     *\/\n+    public Throwable getCause() {\n+        return cause;\n@@ -51,1 +71,1 @@\n-            return new UnresolvedJavaType(getName().substring(1));\n+            return new UnresolvedJavaType(getName().substring(1), null);\n@@ -58,1 +78,1 @@\n-        return new UnresolvedJavaType('[' + getName());\n+        return new UnresolvedJavaType('[' + getName(), null);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/UnresolvedJavaType.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -167,0 +167,1 @@\n+        {\"history.nonexistent.entries\", \"    Warnung: Nicht vorhandene signierte Eintr\\u00E4ge: \"},\n@@ -181,0 +182,1 @@\n+        {\"nonexistent.entries.found\", \"Diese JAR-Datei enth\\u00E4lt signierte Eintr\\u00E4ge f\\u00FCr Dateien, die nicht vorhanden sind. Weitere Details finden Sie in der Verbose-Ausgabe (-verbose).\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources_de.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,0 +167,1 @@\n+        {\"history.nonexistent.entries\", \"    \\u8B66\\u544A: \\u5B58\\u5728\\u3057\\u306A\\u3044\\u7F72\\u540D\\u6E08\\u30A8\\u30F3\\u30C8\\u30EA: \"},\n@@ -181,0 +182,1 @@\n+        {\"nonexistent.entries.found\", \"\\u3053\\u306Ejar\\u306B\\u306F\\u3001\\u5B58\\u5728\\u3057\\u306A\\u3044\\u30D5\\u30A1\\u30A4\\u30EB\\u306E\\u7F72\\u540D\\u6E08\\u30A8\\u30F3\\u30C8\\u30EA\\u304C\\u542B\\u307E\\u308C\\u307E\\u3059\\u3002\\u8A73\\u7D30\\u306F\\u3001-verbose\\u51FA\\u529B\\u3092\\u53C2\\u7167\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044\\u3002\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources_ja.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,0 +167,1 @@\n+        {\"history.nonexistent.entries\", \"\\u8B66\\u544A\\uFF1A\\u4E0D\\u5B58\\u5728\\u7684\\u7B7E\\u540D\\u6761\\u76EE\\uFF1A \"},\n@@ -181,0 +182,1 @@\n+        {\"nonexistent.entries.found\", \"\\u6B64 jar \\u7684\\u6587\\u4EF6\\u5305\\u542B\\u4E0D\\u5B58\\u5728\\u7684\\u7B7E\\u540D\\u6761\\u76EE\\u3002\\u6709\\u5173\\u66F4\\u591A\\u8BE6\\u7EC6\\u4FE1\\u606F\\uFF0C\\u8BF7\\u53C2\\u89C1 -verbose \\u8F93\\u51FA\\u3002\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources_zh_CN.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,0 +134,8 @@\n+    public int classMajorVersion() {\n+        return attrs.majorVersion; \/\/ ..., 53, 54, ...\n+    }\n+\n+    public int classReleaseVersion() {\n+        return attrs.majorVersion - 44; \/\/ ..., 53 -> 9, 54 -> 10, ...\n+    }\n+\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/FingerPrint.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -155,1 +155,0 @@\n-     * nflag: Perform jar normalization at the end\n@@ -213,1 +212,1 @@\n-    static String formatMsg(String key, String arg) {\n+    static String formatMsg(String key, String... args) {\n@@ -215,10 +214,0 @@\n-        String[] args = new String[1];\n-        args[0] = arg;\n-        return MessageFormat.format(msg, (Object[]) args);\n-    }\n-\n-    static String formatMsg2(String key, String arg, String arg1) {\n-        String msg = getMsg(key);\n-        String[] args = new String[2];\n-        args[0] = arg;\n-        args[1] = arg1;\n@@ -434,2 +423,3 @@\n-                    try (InputStream in = new FileInputStream(FileDescriptor.in)) {\n-                        Files.copy(in, file.toPath());\n+                    try (InputStream in = new FileInputStream(FileDescriptor.in);\n+                         OutputStream os = Files.newOutputStream(file.toPath())) {\n+                        in.transferTo(os);\n@@ -462,1 +452,1 @@\n-            error(formatMsg2(\"error.validator.jarfile.exception\", fname, e.getMessage()));\n+            error(formatMsg(\"error.validator.jarfile.exception\", fname, e.getMessage()));\n@@ -843,1 +833,1 @@\n-                    error(formatMsg2(\"error.release.unexpected.versioned.entry\",\n+                    error(formatMsg(\"error.release.unexpected.versioned.entry\",\n@@ -1267,2 +1257,1 @@\n-            out.print(formatMsg2(\"out.size\", String.valueOf(size),\n-                        String.valueOf(csize)));\n+            out.print(formatMsg(\"out.size\", String.valueOf(size), String.valueOf(csize)));\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,0 @@\n-import static sun.tools.jar.Main.formatMsg2;\n@@ -167,1 +166,9 @@\n-\n+            \/\/ all versioned entries must be compatible with their release target number\n+            if (fp.mrversion() < fp.classReleaseVersion()) {\n+                errorAndInvalid(formatMsg(\"error.release.value.toohigh.versioned.entry\",\n+                        fp.entryName(), \/\/ META-INF\/versions\/9\/com\/foo\/Bar.class has class file version\n+                        String.valueOf(fp.classMajorVersion()), \/\/ 69, but class file version\n+                        String.valueOf(fp.mrversion() + 44), \/\/ 53 or less is required to target release\n+                        String.valueOf(fp.mrversion()))); \/\/ 9 of the Java Platform\n+                return;\n+            }\n@@ -313,1 +320,1 @@\n-        error(formatMsg2(\"error.validator.names.mismatch\",\n+        error(formatMsg(\"error.validator.names.mismatch\",\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Validator.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -93,0 +93,2 @@\n+error.release.value.toohigh.versioned.entry=\\\n+        {0} has class file version {1}, but class file version {2} or less is required to target release {3} of the Java Platform\n@@ -285,4 +287,0 @@\n-main.help.opt.create.normalize=\\\n-\\  -n, --normalize            Normalize information in the new jar archive\\n\\\n-\\                             after creation. This option is deprecated, and is\\n\\\n-\\                             planned for removal in a future JDK release\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+error.extract.multiple.dest.dir=Sie knnen die Option \"-C\" oder \"--dir\" nicht mehrmals mit der Option \"-x\" angeben\n+error.extract.pflag.not.allowed=Sie knnen nicht \"-Px\" mit der Option \"-C\" oder \"--dir\" angeben\n@@ -86,0 +88,1 @@\n+warn.option.is.ignored=Warnung: Die Option \"{0}\" ist mit der aktuellen Verwendung nicht gltig und wird ignoriert.\n@@ -97,0 +100,1 @@\n+out.kept=\\  bersprungen: {0} vorhanden\n@@ -99,0 +103,1 @@\n+out.extract.dir=Extrahieren in Verzeichnis: {0}\n@@ -100,1 +105,1 @@\n-usage.compat=Kompatibilittsschnittstelle\\nVerwendung: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files] ...\\nOptionen:\\n    -c  erstellt ein neues Archiv (einschlielich fehlender bergeordneter Verzeichnisse)\\n    -t  listet das Inhaltsverzeichnis fr das Archiv auf\\n    -x  extrahiert die benannten (oder alle) Dateien aus dem Archiv\\n    -u  aktualisiert ein vorhandenes Archiv\\n    -v  generiert Verbose-Ausgabe zur Standardausgabe\\n    -f  gibt den Archivdateinamen an\\n    -m  schliet Manifestinformationen aus der angegebenen Manifestdatei ein\\n    -e  gibt den Anwendungseinstiegspunkt fr Standalone-Anwendungen an,\\n        die in einer ausfhrbaren JAR-Datei gebndelt sind\\n    -0  speichert nur, keine ZIP-Komprimierung\\n    -P  behlt die vorangestellten Komponenten \"\/\" (absoluter Pfad) und \"..\" (bergeordnetes Verzeichnis) aus Dateinamen bei\\n    -M  generiert keine Manifestdatei fr die Eintrge\\n    -i  generiert Indexinformationen fr die angegebenen JAR-Dateien\\n    -C  wechselt zum angegebenen Verzeichnis und schliet die folgende Datei ein\\nDateien, die Verzeichnisse sind, werden rekursiv verarbeitet.\\nDie Namen der Manifestdatei, der Archivdatei und des Einstiegspunkts werden\\nin der gleichen Reihenfolge wie die Flags \"m\", \"f\" und \"e\" angegeben.\\n\\nBeispiel 1: Zwei Klassendateien in einem Archiv namens classes.jar archivieren: \\n       jar cvf classes.jar Foo.class Bar.class \\nBeispiel 2: Die vorhandene Manifestdatei \"mymanifest\" verwenden und alle\\n           Dateien im Verzeichnis \"foo\/\" in \"classes.jar\" archivieren: \\n       jar cvfm classes.jar mymanifest -C foo\/ .\\n\n+usage.compat=Kompatibilittsschnittstelle\\nVerwendung: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files] ...\\nOptionen:\\n    -c erstellt ein neues Archiv (einschlielich fehlender bergeordneter Verzeichnisse)\\n    -t listet das Inhaltsverzeichnis fr das Archiv auf\\n    -x extrahiert die benannten (oder alle) Dateien aus dem Archiv\\n    -u aktualisiert ein vorhandenes Archiv\\n    -v generiert Verbose-Ausgabe zur Standardausgabe\\n    -f gibt den Archivdateinamen an\\n    -m schliet Manifestinformationen aus der angegebenen Manifestdatei ein\\n    -e gibt den Anwendungseinstiegspunkt fr Standalone-Anwendungen an,\\n        die in einer ausfhrbaren JAR-Datei gebndelt sind\\n    -0 speichert nur, ohne ZIP-Komprimierung\\n    -P behlt die vorangestellten Komponenten \"\/\" (absoluter Pfad) und \"..\" (bergeordnetes Verzeichnis) aus Dateinamen bei\\n    -M generiert keine Manifestdatei fr die Eintrge\\n    -i generiert Indexinformationen fr die angegebenen JAR-Dateien\\n    -C wechselt zum angegebenen Verzeichnis und schliet die folgende Datei ein\\nDateien, die Verzeichnisse sind, werden rekursiv verarbeitet.\\nBei Verwendung im Extraktionsmodus wird die JAR-Datei in das angegebene Verzeichnis extrahiert\\nDie Namen der Manifestdatei, der Archivdatei und des Einstiegspunkts werden\\nin der gleichen Reihenfolge wie die Kennzeichen \"m\", \"f\" und \"e\" angegeben.\\n\\nBeispiel 1: Zwei Klassendateien in einem Archiv namens classes.jar archivieren: \\n       jar cvf classes.jar Foo.class Bar.class \\nBeispiel 2: Die vorhandene Manifestdatei \"mymanifest\" verwenden und alle\\n           Dateien im Verzeichnis \"foo\/\" in \"classes.jar\" archivieren: \\n       jar cvfm classes.jar mymanifest -C foo\/ .\\n\n@@ -111,1 +116,1 @@\n-main.help.opt.main.extract=\\  -x, --extract              Benannte (oder alle) Dateien aus dem Archiv extrahieren\n+main.help.opt.main.extract=\\  -x, --extract              Extrahiert benannte (oder alle) Dateien aus dem Archiv.\\n                             Wenn eine Datei mit demselben Namen mehrmals im\\n                             Archiv enthalten ist, wird jede Kopie extrahiert. Dabei berschreiben (ersetzen) neuere Kopien\\n                             ltere Kopien, es sei denn, \"-k\" ist angegeben.\n@@ -114,1 +119,1 @@\n-main.help.opt.any=\\ In jedem Modus gltige Vorgangsmodifikatoren:\\n\\n  -C DIR                     Zum angegebenen Verzeichnis wechseln und die folgende\\n                             Datei aufnehmen\n+main.help.opt.any=\\ In jedem Modus gltige Vorgangsmodifikatoren:\\n\\n  -C DIR                     Zum angegebenen Verzeichnis wechseln und die folgende\\n                             Datei aufnehmen. Bei Verwendung im Extraktionsmodus wird\\n                             die JAR-Datei in das angegebene Verzeichnis extrahiert\n@@ -118,1 +123,0 @@\n-main.help.opt.create.normalize=\\  -n, --normalize            Normalisiert Informationen im neuen JAR-Archiv\\n                             nach der Erstellung. Diese Option ist veraltet, und ihre\\n                             Entfernung in einem knftigen JDK-Release ist geplant\n@@ -131,0 +135,2 @@\n+main.help.opt.extract=\\ Vorgangsmodifikatoren, die nur im Extraktionsmodus gltig sind:\\n\n+main.help.opt.extract.keep-old-files=\\  -k, --keep-old-files       Vorhandene Dateien nicht berschreiben.\\n                             Wenn bereits ein JAR-Dateieintrag mit demselben Namen im\\n                             Zielverzeichnis vorhanden ist, wird die vorhandene Datei nicht berschrieben.\\n                             Wenn eine Datei also mehrmals in einem\\n                             Archiv enthalten ist, werden ltere Kopien nicht durch neuere Kopien berschrieben.\\n                             Beachten Sie zudem, dass bei einigen Dateisystemen die Gro-\/Kleinschreibung ignoriert wird.\n@@ -136,0 +142,2 @@\n+main.help.opt.extract=\\ Vorgangsmodifikatoren, die nur im Extraktionsmodus gltig sind:\\n\n+main.help.opt.extract.dir=\\  --dir                    Verzeichnis, in das die JAR-Datei extrahiert wird\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar_de.properties","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,0 @@\n-main.help.opt.create.normalize=\\  -n, --normalize            Normalizar informacin en el nuevo archivo jar\\n                             despus de la creacin\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar_es.properties","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,0 @@\n-main.help.opt.create.normalize=\\  -n, --normalize            Normaliser des informations dans la nouvelle archive JAR\\n                             aprs la cration\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar_fr.properties","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,0 @@\n-main.help.opt.create.normalize=\\  -n, --normalize            Normalizza le informazioni nel nuovo archivio jar\\n                             dopo la creazione\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar_it.properties","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+error.extract.multiple.dest.dir='-x''-C''--dir'\n+error.extract.pflag.not.allowed='-C''--dir''-Px'\n@@ -86,0 +88,1 @@\n+warn.option.is.ignored=: {0}\n@@ -97,0 +100,1 @@\n+out.kept=\\  : {0}\n@@ -99,0 +103,1 @@\n+out.extract.dir=: {0}\n@@ -100,1 +105,1 @@\n-usage.compat=:\\n: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files] ...\\n:\\n    -c  ()\\n    -t  \\n    -x  ()\\n    -u  \\n    -v  \\n    -f  \\n    -m  \\n    -e  jar \\n        \\n    -0  ZIP\\n    -P  '\/' ()\"..\" ()\\n    -M  \\n    -i  jar\\n    -C  \\n\\n\\n'm''f''e'\\n\\n1: 2classes.jar: \\n       jar cvf classes.jar Foo.class Bar.class \\n2: 'mymanifest'foo\/\\n           'classes.jar': \\n       jar cvfm classes.jar mymanifest -C foo\/ .\\n\n+usage.compat=:\\n: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files] ...\\n:\\n    -c  ()\\n    -t  \\n    -x  ()\\n    -u  \\n    -v  \\n    -f  \\n    -m  \\n    -e  jar \\n        \\n    -0  ZIP\\n    -P  '\/' ()\"..\" ()\\n    -M  \\n    -i  jar\\n    -C  \\n\\njar\\n\\n'm''f''e'\\n\\n1: 2classes.jar: \\n       jar cvf classes.jar Foo.class Bar.class \\n2: 'mymanifest'foo\/\\n           'classes.jar': \\n       jar cvfm classes.jar mymanifest -C foo\/ .\\n\n@@ -111,1 +116,1 @@\n-main.help.opt.main.extract=\\  -x--extract              ()\n+main.help.opt.main.extract=\\  -x--extract              ()\\n                             \\n                             \\n                             ()(-k)\n@@ -114,1 +119,1 @@\n-main.help.opt.any=\\ :\\n\\n  -C DIR                     \\n                             \n+main.help.opt.any=\\ :\\n\\n  -C DIR                     \\n                             jar\\n                             \n@@ -118,1 +123,0 @@\n-main.help.opt.create.normalize=\\  -n, --normalize            jar\\n                             \\n                             JDK\n@@ -131,0 +135,2 @@\n+main.help.opt.extract=\\ :\\n\n+main.help.opt.extract.keep-old-files=\\  -k--keep-old-files       \\n                             Jar\\n                             \\n                             \\n                             \\n                             \/\n@@ -136,0 +142,2 @@\n+main.help.opt.extract=\\ :\\n\n+main.help.opt.extract.dir=\\  --dir                    jar\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar_ja.properties","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,0 @@\n-main.help.opt.create.normalize=\\  -n, --normalize               jar  \\n                             .\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar_ko.properties","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,0 @@\n-main.help.opt.create.normalize=\\  -n, --normalize            Normaliza as informaes no novo arquivo compactado jar\\n                             aps a criao\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar_pt_BR.properties","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,0 @@\n-main.help.opt.create.normalize=\\  -n, --normalize            Normalisera informationen i det nya jar-arkivet\\n                             nr det har skapats\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar_sv.properties","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+error.extract.multiple.dest.dir= '-x'  '-C'  '--dir' \n+error.extract.pflag.not.allowed= '-C'  '--dir'  '-Px'\n@@ -86,0 +88,1 @@\n+warn.option.is.ignored={0} \n@@ -97,0 +100,1 @@\n+out.kept=\\  {0} \n@@ -99,0 +103,1 @@\n+out.extract.dir={0}\n@@ -100,1 +105,1 @@\n-usage.compat=\\njar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files] ...\\n\\n    -c  \\n    -t  \\n    -x  \\n    -u  \\n    -v  \\n    -f  \\n    -m  \\n    -e   jar \\n        \\n    -0   ZIP \\n    -P   '\/' \"..\"\\n    -M  \\n    -i   jar \\n    -C  \\n\\n\\n 'm', 'f'  'e' \\n\\n 1 classes.jar \\n       jar cvf classes.jar Foo.class Bar.class \\n 2 'mymanifest' \\n            foo\/  'classes.jar' \\n       jar cvfm classes.jar mymanifest -C foo\/\\n\n+usage.compat=\\njar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files] ...\\n\\n    -c  \\n    -t  \\n    -x  \\n    -u  \\n    -v  \\n    -f  \\n    -m  \\n    -e   jar \\n        \\n    -0   ZIP \\n    -P   '\/' \"..\"\\n    -M  \\n    -i   jar \\n    -C  \\n\\n jar \\n\\n 'm''f'  'e' \\n\\n 1 classes.jar \\n       jar cvf classes.jar Foo.class Bar.class \\n 2 'mymanifest' \\n            foo\/  'classes.jar' \\n       jar cvfm classes.jar mymanifest -C foo\/\\n\n@@ -111,1 +116,1 @@\n-main.help.opt.main.extract=\\  -x, --extract               () \n+main.help.opt.main.extract=\\  -x, --extract              \\n                             \\n                              -k\\n                             \n@@ -114,1 +119,1 @@\n-main.help.opt.any=\\ :\\n\\n  -C DIR                     \\n                             \n+main.help.opt.any=\\ \\n\\n  -C DIR                     \\n                             \\n                              jar \n@@ -118,1 +123,0 @@\n-main.help.opt.create.normalize=\\  -n, --normalize             jar \\n                             \\n                              JDK \n@@ -131,0 +135,2 @@\n+main.help.opt.extract=\\ \\n\n+main.help.opt.extract.keep-old-files=\\  -k, --keep-old-files       \\n                              Jar \\n                             \\n                             \\n                             \\n                             \n@@ -136,0 +142,2 @@\n+main.help.opt.extract=\\ \\n\n+main.help.opt.extract.dir=\\  --dir                    jar \n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar_zh_CN.properties","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,0 @@\n-main.help.opt.create.normalize=\\  -n, --normalize             jar \\n                             \n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar_zh_TW.properties","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-        configuration.currentTypeElement = typeElement;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassUseWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-        configuration.currentTypeElement = typeElement;\n@@ -509,1 +508,1 @@\n-    public TypeElement getCurrentPageElement() {\n+    public TypeElement getCurrentTypeElement() {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriter.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -107,5 +107,0 @@\n-    \/**\n-     * The TypeElement for the class file getting generated.\n-     *\/\n-    public TypeElement currentTypeElement = null;  \/\/ Set this TypeElement in the ClassWriter.\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1027,3 +1027,2 @@\n-     * Return the main type element of the current page or null for pages that don't have one.\n-     *\n-     * @return the type element of the current page.\n+     * {@return the type element documented by this writer if it is a {@code ClassWriter},\n+     * or null for any other kind of writer}\n@@ -1031,1 +1030,1 @@\n-    public TypeElement getCurrentPageElement() {\n+    public TypeElement getCurrentTypeElement() {\n@@ -1915,1 +1914,1 @@\n-        Element currentPageElement = getCurrentPageElement();\n+        Element currentPageElement = getCurrentTypeElement();\n@@ -1954,1 +1953,1 @@\n-                ? packageWriter.packageElement : getCurrentPageElement();\n+                ? packageWriter.packageElement : getCurrentTypeElement();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-                if (enclosing.equals(m_writer.getCurrentPageElement())) {\n+                if (enclosing.equals(m_writer.getCurrentTypeElement())) {\n@@ -297,1 +297,1 @@\n-                if (linkInfo.linkToSelf() || typeElement != m_writer.getCurrentPageElement()) {\n+                if (linkInfo.linkToSelf() || typeElement != m_writer.getCurrentTypeElement()) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlLinkFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -138,0 +138,3 @@\n+doclet.searchTag=Suchtag\n+doclet.searchTags=Tags suchen\n+doclet.searchTagsSummary=bersicht ber Suchtags\n@@ -172,0 +175,1 @@\n+doclet.DefinedIn=Definiert in\n@@ -259,0 +263,2 @@\n+# 0: link to Search Tags page\n+doclet.help.searchTags.body=Auf der Seite \"{0}\" werden die in der Dokumentation definierten Suchtags aufgelistet.\n@@ -326,1 +332,3 @@\n-doclet.RestrictedLeadingNote={0} ist eine eingeschrnkte Methode der Java-Plattform.\n+doclet.PreviewJavaSERequiresTransitiveJavaBase=Indirekte Exporte aus dem Modul <code>java.base<\/code> sind mit der Direktive <code>requires transitive java.base<\/code> verknpft. Das ist ein Vorschaufeature der Java-Sprache.<br>Programme knnen <code>requires transitive java.base<\/code> nur verwenden, wenn Vorschaufeatures aktiviert sind.<br>Vorschaufeatures knnen in einem zuknftigen Release entfernt oder zu permanenten Features der Java-Plattform hochgestuft werden.<br>\n+doclet.RestrictedMethod=eingeschrnkte Methode\n+doclet.RestrictedLeadingNote={0} ist eine {1} der Java-Plattform.\n@@ -365,1 +373,1 @@\n-doclet.usage.docfilessubdirs.description=doc-file-Unterverzeichnisse rekursiv kopieren\n+doclet.usage.docfilessubdirs.description=Ermglicht Deep Copying von \"doc-files\"-Verzeichnissen. Unterverzeichnisse und alle\\nInhalte werden rekursiv in das Ziel kopiert\n@@ -387,1 +395,1 @@\n-doclet.usage.footer.description=Footertext fr jede Seite aufnehmen\n+doclet.usage.footer.description=Diese Option wird nicht mehr untersttzt und gibt eine Warnung aus\n@@ -409,1 +417,1 @@\n-doclet.usage.excludedocfilessubdir.description=doc-files-Unterverzeichnisse mit angegebenem Namen ausschlieen.\\n\":\" kann berall im Argument als Trennzeichen verwendet werden.\n+doclet.usage.excludedocfilessubdir.description=Schlieen Sie alle \"doc-files\"-Unterverzeichnisse mit einem angegebenen Namen aus.\\n\":\" kann berall im Argument als Trennzeichen verwendet werden.\n@@ -446,1 +454,1 @@\n-doclet.usage.serialwarn.description=Warnung wegen @serial-Tag generieren\n+doclet.usage.serialwarn.description=Gibt Warnungen zur Kompilierzeit fr fehlende \"@serial\"-Tags aus\n@@ -455,1 +463,1 @@\n-doclet.usage.tag.description=Benutzerdefinierte Tags mit einem Argument angeben\n+doclet.usage.tag.description=Gibt ein benutzerdefiniertes Tag mit einem einzelnen Argument an\n@@ -471,1 +479,1 @@\n-doclet.usage.helpfile.description=Datei aufnehmen, zu der der Hilfelink verlinkt\n+doclet.usage.helpfile.description=Gibt eine Datei an, die den Text enthlt, der beim Klicken auf den\\nHilfelink in der Navigationsleiste angezeigt wird\n@@ -494,1 +502,1 @@\n-doclet.usage.allow-script-in-comments.description=JavaScript in Optionen und Kommentaren zulassen\n+doclet.usage.allow-script-in-comments.description=JavaScript in Dokumentationskommentaren und Optionen\\nzulassen, die HTML-Code enthalten\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard_de.properties","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -138,0 +138,3 @@\n+doclet.searchTag=\n+doclet.searchTags=\n+doclet.searchTagsSummary=\n@@ -172,0 +175,1 @@\n+doclet.DefinedIn=\n@@ -259,0 +263,2 @@\n+# 0: link to Search Tags page\n+doclet.help.searchTags.body={0}\n@@ -326,1 +332,3 @@\n-doclet.RestrictedLeadingNote={0}Java\n+doclet.PreviewJavaSERequiresTransitiveJavaBase=<code>java.base<\/code>Java<code>requires transitive java.base<\/code><br><code>requires transitive java.base<\/code><br>Java<br>\n+doclet.RestrictedMethod=\n+doclet.RestrictedLeadingNote={0}Java{1}\n@@ -365,1 +373,1 @@\n-doclet.usage.docfilessubdirs.description=doc-file\n+doclet.usage.docfilessubdirs.description='doc-files'\\n\n@@ -387,1 +395,1 @@\n-doclet.usage.footer.description=\n+doclet.usage.footer.description=\n@@ -409,1 +417,1 @@\n-doclet.usage.excludedocfilessubdir.description=doc-files\\n':'\n+doclet.usage.excludedocfilessubdir.description='doc-files'\\n':'\n@@ -446,1 +454,1 @@\n-doclet.usage.serialwarn.description=@serial\n+doclet.usage.serialwarn.description='@serial'\n@@ -471,1 +479,1 @@\n-doclet.usage.helpfile.description=\n+doclet.usage.helpfile.description=\\n\n@@ -494,1 +502,1 @@\n-doclet.usage.allow-script-in-comments.description=JavaScript\n+doclet.usage.allow-script-in-comments.description=html-code\\nJavaScript\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard_ja.properties","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -138,0 +138,3 @@\n+doclet.searchTag=\n+doclet.searchTags=\n+doclet.searchTagsSummary=\n@@ -172,0 +175,1 @@\n+doclet.DefinedIn=\n@@ -259,0 +263,2 @@\n+# 0: link to Search Tags page\n+doclet.help.searchTags.body={0} \n@@ -326,1 +332,3 @@\n-doclet.RestrictedLeadingNote={0}  Java \n+doclet.PreviewJavaSERequiresTransitiveJavaBase= <code>java.base<\/code>  <code>requires transitive java.base<\/code>  Java <br> <code>requires transitive java.base<\/code><br> Java <br>\n+doclet.RestrictedMethod=\n+doclet.RestrictedLeadingNote={0}  Java  {1}\n@@ -365,1 +373,1 @@\n-doclet.usage.docfilessubdirs.description=\n+doclet.usage.docfilessubdirs.description= 'doc-files' \\n\n@@ -387,1 +395,1 @@\n-doclet.usage.footer.description=\n+doclet.usage.footer.description=\n@@ -409,1 +417,1 @@\n-doclet.usage.excludedocfilessubdir.description= doc-files \\n ':' \n+doclet.usage.excludedocfilessubdir.description= 'doc-files' \\n ':' \n@@ -446,1 +454,1 @@\n-doclet.usage.serialwarn.description= @serial \n+doclet.usage.serialwarn.description= '@serial' \n@@ -455,1 +463,1 @@\n-doclet.usage.tag.description=\n+doclet.usage.tag.description=\n@@ -471,1 +479,1 @@\n-doclet.usage.helpfile.description=\n+doclet.usage.helpfile.description=\\n\n@@ -494,1 +502,1 @@\n-doclet.usage.allow-script-in-comments.description= JavaScript\n+doclet.usage.allow-script-in-comments.description= JavaScript\\n html-code\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard_zh_CN.properties","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-                        + utils.flatSignature(method, writer.getCurrentPageElement());\n+                        + utils.flatSignature(method, writer.getCurrentTypeElement());\n@@ -160,1 +160,1 @@\n-                    + utils.flatSignature(method, writer.getCurrentPageElement());\n+                    + utils.flatSignature(method, writer.getCurrentTypeElement());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/InheritDocTaglet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-            if (config.currentTypeElement != containing) {\n+            if (htmlWriter.getCurrentTypeElement() != containing) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/LinkTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-        TypeMirror returnType = utils.getReturnType(tagletWriter.getCurrentPageElement(), method);\n+        TypeMirror returnType = utils.getReturnType(tagletWriter.getCurrentTypeElement(), method);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ReturnTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -204,3 +204,1 @@\n-     * Returns the main type element of the current page or null for pages that don't have one.\n-     *\n-     * @return the type element of the current page or null.\n+     * {@return the type element documented by the current {@code HtmlDocletWriter} (may be null)}\n@@ -208,2 +206,2 @@\n-    public TypeElement getCurrentPageElement() {\n-        return htmlWriter.getCurrentPageElement();\n+    public TypeElement getCurrentTypeElement() {\n+        return htmlWriter.getCurrentTypeElement();\n@@ -414,1 +412,1 @@\n-                        + utils.flatSignature(e, htmlWriter.getCurrentPageElement());\n+                        + utils.flatSignature(e, htmlWriter.getCurrentTypeElement());\n@@ -479,1 +477,1 @@\n-            return element != getCurrentPageElement();\n+            return element != getCurrentTypeElement();\n@@ -483,1 +481,1 @@\n-            return utils.getEnclosingTypeElement(element) != getCurrentPageElement();\n+            return utils.getEnclosingTypeElement(element) != getCurrentTypeElement();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/TagletWriter.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-                    + utils.flatSignature((ExecutableElement) holder, tagletWriter.getCurrentPageElement());\n+                    + utils.flatSignature((ExecutableElement) holder, tagletWriter.getCurrentTypeElement());\n@@ -238,1 +238,1 @@\n-                tagletWriter.getCurrentPageElement(), executable);\n+                tagletWriter.getCurrentTypeElement(), executable);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ThrowsTaglet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-doclet.record_equals_doc.fullbody.tail.reference={@link java.util.Objects#equals(Object,Object) Objects::equals(Object,Object)}\n+doclet.record_equals_doc.fullbody.tail.reference={@link java.util.Objects#equals(Object,Object) Objects::equals(Object,Object)}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets_ja.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-doclet.Modifier=\n+doclet.Modifier=\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets_zh_CN.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-main.opt.show.members.desc=Gibt an, welche Mitglieder (Felder, Methoden usw.) dokumentiert\\nwerden, wobei der Wert \"public\", \"protected\",\\n\"package\" oder \"private\" lauten kann. Der Standardwert ist \"protected\"\\nund zeigt ffentliche und geschtzte Mitglieder, \"public\" zeigt nur\\nffentliche Mitglieder, \"package\" zeigt ffentliche, geschtzte und\\nPackagemitglieder, und \"private\" zeigt alle Mitglieder.\n+main.opt.show.members.desc=Gibt an, welche Member (Felder, Methoden oder Konstruktoren) dokumentiert\\nwerden, wobei der Wert \"public\", \"protected\",\\n\"package\" oder \"private\" lauten kann. Der Standardwert ist \"protected\"\\nund zeigt ffentliche und geschtzte Member an. \"public\" zeigt nur\\nffentliche Member, \"package\" zeigt ffentliche, geschtzte und\\nPackage-Member, und \"private\" zeigt alle Member an.\n@@ -59,1 +59,1 @@\n-main.opt.show.packages.desc=Gibt das Modul an, dessen Packages dokumentiert werden. Mgliche\\nWerte sind \"exported\" oder \"all\" (exportierte oder alle Packages).\n+main.opt.show.packages.desc=Gibt an, welche Modulpackages dokumentiert werden. Mgliche\\nWerte sind \"exported\" oder \"all\" (exportierte oder alle Packages).\n@@ -64,1 +64,1 @@\n-main.opt.expand.requires.arg=<Wert>\n+main.opt.expand.requires.arg=(transitive|all)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc_de.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-main.opt.show.members.desc=\"public\"\"protected\"\"package\"\"private\"\\n()\\n\"protected\"publicprotected\\n\"public\"public\"package\"\\npublicprotectedpackage\"private\"\\n\n+main.opt.show.members.desc=\"public\"\"protected\"\"package\"\"private\"\\n()\\n\"protected\"publicprotected\\n\"public\"public\"package\"\\npublicprotectedpackage\"private\"\\n\n@@ -59,1 +59,1 @@\n-main.opt.show.packages.desc=\\n\"exported\"\"all\"\n+main.opt.show.packages.desc=\\n\"exported\"\"all\"\n@@ -64,1 +64,1 @@\n-main.opt.expand.requires.arg=<value>\n+main.opt.expand.requires.arg=(transitive|all)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc_ja.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-main.opt.show.members.desc= (, ), \\n \"public\", \"protected\", \"package\"  \\n\"private\"  \"protected\", \\n, \"public\" \\n, \"package\" , \\n, \"private\" \n+main.opt.show.members.desc=\\n \"public\"\"protected\"\"package\" \\n \"private\"  \"protected\"\\n \"public\" \\n \"package\" \\n \"private\" \n@@ -59,1 +59,1 @@\n-main.opt.show.packages.desc=\\n \"exported\"  \"all\" \n+main.opt.show.packages.desc=\\n \"exported\"  \"all\" \n@@ -64,1 +64,1 @@\n-main.opt.expand.requires.arg=<>\n+main.opt.expand.requires.arg=(transitive|all)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc_zh_CN.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-main.opt.l=\\  -l                               Gibt die Zeilennummer und lokale Variablentabellen aus\n+main.opt.l=\\  -l                               Gibt die Zeilennummer und lokale Variablentabellen aus, kann zusammen mit \"-c\" verwendet werden\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/resources\/javap_de.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-main.opt.l=\\  -l                               \n+main.opt.l=\\  -l                               -c\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/resources\/javap_ja.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-main.opt.l=\\  -l                               \n+main.opt.l=\\  -l                                -c \n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/resources\/javap_zh_CN.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,0 +65,4 @@\n+main.runtime.image.linking.cap.enabled=aktiviert\n+main.runtime.image.linking.cap.disabled=deaktiviert\n+main.runtime.image.linking.cap.sect.header=Funktionen:\n+main.runtime.image.linking.cap.msg=\\      Assemblierung von Laufzeitimage {0}\n@@ -69,0 +73,5 @@\n+err.runtime.link.not.linkable.runtime=Dieses JDK untersttzt keine Assemblierung vom aktuellen Laufzeitimage\n+err.runtime.link.jdk.jlink.prohibited=Dieses JDK enthlt keine als Pakete verpackten Module und kann nicht verwendet werden, um ein anderes Image mit dem Modul jdk.jlink zu erstellen\n+err.runtime.link.packaged.mods=Dieses JDK enthlt keine als Pakete verpackten Module. \"--keep-packaged-modules\" wird nicht untersttzt\n+err.runtime.link.modified.file={0} wurde modifiziert\n+err.runtime.link.patched.module=Datei {0} nicht im Modulimage gefunden. \"--patch-module\" wird beim Verknpfen aus dem Laufzeitimage nicht untersttzt\n@@ -77,1 +86,1 @@\n-err.modulepath.must.be.specified:--module-path ist nicht angegeben, und dieses Laufzeitimage enthlt nicht das jmods-Verzeichnis.\n+err.modulepath.must.be.specified:\"--module-path\" ist nicht angegeben, und dieses Laufzeitimage enthlt kein jmods-Verzeichnis\n@@ -109,0 +118,3 @@\n+\n+runtime.link.info=Assemblierung basierend auf dem aktuellen Laufzeitimage\n+runtime.link.jprt.path.extra=(Laufzeitimage)\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink_de.properties","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -65,0 +65,4 @@\n+main.runtime.image.linking.cap.enabled=\n+main.runtime.image.linking.cap.disabled=\n+main.runtime.image.linking.cap.sect.header=:\n+main.runtime.image.linking.cap.msg=\\      {0}\n@@ -69,0 +73,5 @@\n+err.runtime.link.not.linkable.runtime=JDK\n+err.runtime.link.jdk.jlink.prohibited=JDKjdk.jlink\n+err.runtime.link.packaged.mods=JDK--keep-packaged-modules\n+err.runtime.link.modified.file={0}\n+err.runtime.link.patched.module={0}--patch-module\n@@ -77,1 +86,1 @@\n-err.modulepath.must.be.specified:--module-pathjmods\n+err.modulepath.must.be.specified:--module-pathjmods\n@@ -109,0 +118,3 @@\n+\n+runtime.link.info=\n+runtime.link.jprt.path.extra=()\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink_ja.properties","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -65,0 +65,4 @@\n+main.runtime.image.linking.cap.enabled=\n+main.runtime.image.linking.cap.disabled=\n+main.runtime.image.linking.cap.sect.header=\n+main.runtime.image.linking.cap.msg=\\       {0} \n@@ -69,0 +73,5 @@\n+err.runtime.link.not.linkable.runtime= JDK \n+err.runtime.link.jdk.jlink.prohibited= JDK  jdk.jlink \n+err.runtime.link.packaged.mods= JDK  --keep-packaged-modules\n+err.runtime.link.modified.file= {0}\n+err.runtime.link.patched.module= {0} --patch-module\n@@ -77,1 +86,1 @@\n-err.modulepath.must.be.specified: --module-path jmods \n+err.modulepath.must.be.specified: --module-path jmods \n@@ -109,0 +118,3 @@\n+\n+runtime.link.info=\n+runtime.link.jprt.path.extra=\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink_zh_CN.properties","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -99,2 +99,2 @@\n-err.compress.incorrect=--: {0}\n-err.compress.wrong.mode=--\n+err.compress.incorrect=--compress: {0}\n+err.compress.wrong.mode=--compress\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/resources\/jmod_ja.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,2 +99,2 @@\n-err.compress.incorrect=--{0}\n-err.compress.wrong.mode=--\n+err.compress.incorrect=--compress {0}\n+err.compress.wrong.mode= --compress\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/resources\/jmod_zh_CN.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-message.codesign.failed.reason.xcode.tools=Possible reason for \"codesign\" failure is missing Xcode with command line developer tools. Install Xcode with command line developer tools to see if it resolves the problem.\n+message.codesign.failed.reason.xcode.tools=Mglicher Grund fr \"codesign\"-Fehler ist fehlender Xcode mit Befehlszeilen-Entwicklertools. Installieren Sie Xcode mit Befehlszeilen-Entwicklertools, und prfen Sie, ob das Problem dadurch beseitigt wird.\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_de.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-message.codesign.failed.reason.xcode.tools=Possible reason for \"codesign\" failure is missing Xcode with command line developer tools. Install Xcode with command line developer tools to see if it resolves the problem.\n+message.codesign.failed.reason.xcode.tools=\"codesign\"XcodeXcode\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_ja.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-message.codesign.failed.reason.xcode.tools=Possible reason for \"codesign\" failure is missing Xcode with command line developer tools. Install Xcode with command line developer tools to see if it resolves the problem.\n+message.codesign.failed.reason.xcode.tools=\"codesign\"  Xcode Xcode\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_zh_CN.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-resource.wix-src-conv=XSLT stylesheet converting WiX sources from WiX v3 to WiX v4 format\n+resource.wix-src-conv=XSLT-Stylesheet zum Konvertieren von WiX-Quellen vom Format WiX v3 in WiX v4\n@@ -45,1 +45,1 @@\n-error.no-wix-tools=Can not find WiX tools. Was looking for WiX v3 light.exe and candle.exe or WiX v4\/v5 wix.exe and none was found\n+error.no-wix-tools=WiX-Tools nicht gefunden. Gesucht wurden WiX v3 light.exe und candle.exe oder WiX v4\/v5 wix.exe, aber keine der Dateien wurde gefunden\n@@ -59,1 +59,1 @@\n-error.short-path-conv-fail=Failed to get short version of \"{0}\" path\n+error.short-path-conv-fail=Kurze Version des Pfades \"{0}\" konnte nicht abgerufen werden\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_de.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-resource.wix-src-conv=XSLT stylesheet converting WiX sources from WiX v3 to WiX v4 format\n+resource.wix-src-conv=WiXWiX v3WiX v4XSLT\n@@ -45,1 +45,1 @@\n-error.no-wix-tools=Can not find WiX tools. Was looking for WiX v3 light.exe and candle.exe or WiX v4\/v5 wix.exe and none was found\n+error.no-wix-tools=WiXWiX v3 light.execandle.exeWiX v4\/v5 wix.exe\n@@ -59,1 +59,1 @@\n-error.short-path-conv-fail=Failed to get short version of \"{0}\" path\n+error.short-path-conv-fail=\"{0}\"\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_ja.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-resource.wix-src-conv=XSLT stylesheet converting WiX sources from WiX v3 to WiX v4 format\n+resource.wix-src-conv= WiX  WiX v3  WiX v4  XSLT \n@@ -45,1 +45,1 @@\n-error.no-wix-tools=Can not find WiX tools. Was looking for WiX v3 light.exe and candle.exe or WiX v4\/v5 wix.exe and none was found\n+error.no-wix-tools= WiX  WiX v3 light.exe  candle.exe  WiX v4\/v5 wix.exe\n@@ -59,1 +59,1 @@\n-error.short-path-conv-fail=Failed to get short version of \"{0}\" path\n+error.short-path-conv-fail= \"{0}\" \n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_zh_CN.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-help.usage = Verwendung:   jshell <Option>... <Ladedatei>...\\nMgliche Optionen:\\n    --class-path <Pfad>   Gibt an, wo die Benutzerklassendateien gespeichert sind\\n    --module-path <Pfad>  Gibt an, wo die Anwendungsmodule gespeichert sind\\n    --add-modules <Modul>(,<Modul>)*\\n                         Gibt aufzulsende Module oder alle Module im\\n                            Modulpfad an, wenn <Modul> ALL-MODULE-PATHs lautet\\n    --enable-native-access\\n                          Ermglicht Ausfhrung eingeschrnkter nativer Methoden durch Code\\n    --enable-preview      Code kann Vorschaufeatures in diesem Release nutzen\\n    --startup <Datei>      Ersetzung der Startdefinitionen mit einer Ausfhrung\\n    --no-startup          Startdefinitionen werden nicht ausgefhrt\\n    --feedback <Modus>     Gibt den anfnglichen Feedbackmodus an. Der Modus kann\\n                            vordefiniert (Silent, Concise, Normal oder Verbose) oder\\n                            vorab benutzerdefiniert sein\\n    -q                    Stilles Feedback. Identisch mit: --feedback concise\\n    -s                    uerst stilles Feedback. Identisch mit: --feedback silent\\n    -v                    Verbose-Feedback. Identisch mit: --feedback verbose\\n    -J<Kennzeichen>              bergibt <Kennzeichen> an das Laufzeitsystem, hat aber keine Auswirkungen\\n                            auf die Ausfhrung von Code-Snippets. Um Kennzeichen anzugeben,\\n                            die die Ausfhrung von Code-Snippets beeinflussen, verwenden Sie\\n                            -R<Kennzeichen>. Verwenden Sie alternativ dazu -J<Kennzeichen> mit\\n                            --execution local.\\n    -R<Kennzeichen>              bergibt <Kennzeichen> nur dann an das Laufzeitsystem, wenn\\n                            Code-Snippets ausgefhrt werden. Beispiel: -R-Dfoo=bar\\n                            bedeutet, dass die Ausfhrung des Snippets\\n                            System.getProperty(\"foo\") \"bar\" zurckgibt.\\n    -C<flag>              bergibt <Kennzeichen> an den Java-Compiler in JShell.\\n                            Beispiel: -C-Xlint aktiviert alle empfohlenen\\n                            LINT-Warnungen, und -C--release=<N> kompiliert fr\\n                            Java SE N, wie wenn --release N angegeben wird.\\n                            Verwenden Sie ein -C pro Compiler-Kennzeichen oder Kennzeichenargument\\n    --version             Gibt Versionsinformationen aus und beendet den Vorgang\\n    --show-version        Gibt Versionsinformationen aus und setzt den Vorgang fort\\n    --help, -?, -h        Gibt diese Zusammenfassung der Standardoptionen aus und beendet den Vorgang\\n    --help-extra, -X      Gibt Hilfetext zu Nicht-Standardoptionen aus und beendet den Vorgang\\n\\nEin Dateiargument kann ein Dateiname oder einer der vordefinierten Dateinamen sein: DEFAULT,\\nPRINTING, TOOLING oder JAVASE.\\nEine Ladedatei kann auch \"-\" zur Angabe einer Standardeingabe ohne interaktiven I\/O sein.\\n\\nWeitere Informationen zu den Auswertungskontextoptionen (--class-path,\\n--module-path und --add-modules) finden Sie unter:\\n\\t\/help context\\n\\nEin Pfad listet die zu durchsuchenden Verzeichnisse und Archive auf. Verwenden Sie unter Windows ein\\nSemikolon (;), um Elemente im Pfad zu trennen. Verwenden Sie auf anderen Plattformen einen\\nDoppelpunkt (:), um Elemente zu trennen.\\n\n+help.usage = Verwendung:   jshell <Option>... <Ladedatei>...\\nMgliche Optionen:\\n    --class-path <Pfad>   Gibt an, wo die Benutzerklassendateien gespeichert sind\\n    --module-path <Pfad>  Gibt an, wo die Anwendungsmodule gespeichert sind\\n    --add-modules <Modul>(,<Modul>)*\\n                          Gibt aufzulsende Module oder alle Module im\\n                            Modulpfad an, wenn <Modul> ALL-MODULE-PATHs lautet\\n    --enable-native-access\\n                          Ermglicht Ausfhrung eingeschrnkter nativer Methoden durch Code\\n    --enable-preview      Code kann Vorschaufeatures in diesem Release nutzen\\n    --startup <Datei>      Ersetzung der Startdefinitionen mit einer Ausfhrung\\n    --no-startup          Startdefinitionen werden nicht ausgefhrt\\n    --feedback <Modus>     Gibt den anfnglichen Feedbackmodus an. Der Modus kann\\n                            vordefiniert (Silent, Concise, Normal oder Verbose) oder\\n                            vorab benutzerdefiniert sein\\n    -q                    Stilles Feedback. Identisch mit: --feedback concise\\n    -s                    uerst stilles Feedback. Identisch mit: --feedback silent\\n    -v                    Verbose-Feedback. Identisch mit: --feedback verbose\\n    -J<Kennzeichen>              bergibt <Kennzeichen> an das Laufzeitsystem, hat aber keine Auswirkungen\\n                            auf die Ausfhrung von Code-Snippets. Um Kennzeichen anzugeben,\\n                            die die Ausfhrung von Code-Snippets beeinflussen, verwenden Sie\\n                            -R<Kennzeichen>. Verwenden Sie alternativ dazu -J<Kennzeichen> mit\\n                            --execution local.\\n    -R<Kennzeichen>              bergibt <Kennzeichen> nur dann an das Laufzeitsystem, wenn\\n                            Code-Snippets ausgefhrt werden. Beispiel: -R-Dfoo=bar\\n                            bedeutet, dass die Ausfhrung des Snippets\\n                            System.getProperty(\"foo\") \"bar\" zurckgibt.\\n    -C<Kennzeichen>              bergibt <Kennzeichen> an den Java-Compiler in JShell.\\n                            Beispiel: -C-Xlint aktiviert alle empfohlenen\\n                            LINT-Warnungen, und -C--release=<N> kompiliert fr\\n                            Java SE N, wie wenn --release N angegeben wird.\\n                            Verwenden Sie ein -C pro Compiler-Kennzeichen oder Kennzeichenargument\\n    --version             Gibt Versionsinformationen aus und beendet den Vorgang\\n    --show-version        Gibt Versionsinformationen aus und setzt den Vorgang fort\\n    --help, -?, -h        Gibt diese Zusammenfassung der Standardoptionen aus und beendet den Vorgang\\n    --help-extra, -X      Gibt Hilfetext zu Nicht-Standardoptionen aus und beendet den Vorgang\\n\\nEin Dateiargument kann ein Dateiname oder einer der vordefinierten Dateinamen sein: DEFAULT,\\nPRINTING, TOOLING oder JAVASE.\\nEine Ladedatei kann auch \"-\" zur Angabe einer Standardeingabe ohne interaktiven I\/O sein.\\n\\nWeitere Informationen zu den Auswertungskontextoptionen (--class-path,\\n--module-path und --add-modules) finden Sie unter:\\n\\t\/help context\\n\\nEin Pfad listet die zu durchsuchenden Verzeichnisse und Archive auf. Verwenden Sie unter Windows ein\\nSemikolon (;), um Elemente im Pfad zu trennen. Verwenden Sie auf anderen Plattformen einen\\nDoppelpunkt (:), um Elemente zu trennen.\\n\n@@ -204,1 +204,1 @@\n-help.open =Datei ffnen und ihren Inhalt als Snippets und Befehle lesen.\\n\\n\/open <file>\\n\\tAngegebene Datei als JShell-Tooleingabe lesen.\\n\/open <URL>\\n\\tAngegebene URL herunterladen und als JShell-Tooleingabe verwenden.\\n\\n<file> kann der Name einer Betriebssystemdatei oder einer der folgenden vordefinierten\\nDateinamen sein: DEFAULT, PRINTING, TOOLING oder JAVASE.\\nHierbei handelt es sich jeweils um: die Standardimport-Snippets (wie von -default verwendet),\\nDefinitionen der Methoden-Snippets print(), println() und printf(),\\nDefinitionen\\nvon Methoden-Snippets, die JDK-Tools ausfhren, oder Importe aller Java SE-Packages.\\n\n+help.open =Datei ffnen und ihren Inhalt als Snippets und Befehle lesen.\\n\\n\/open <Datei>\\n\\tAngegebene Datei als JShell-Tooleingabe lesen.\\n\/open <URL>\\n\\tAngegebene URL herunterladen und als JShell-Tooleingabe verwenden.\\n\\nDie <Datei> kann der Name einer Betriebssystemdatei oder einer der folgenden vordefinierten\\nDateinamen sein: DEFAULT, PRINTING, TOOLING oder JAVASE.\\nHierbei handelt es sich jeweils um: die Standardimport-Snippets (wie von -default verwendet),\\nDefinitionen der Methoden-Snippets print(), println() und printf(),\\nDefinitionen\\nvon Methoden-Snippets, die JDK-Tools ausfhren, oder Importe aller Java SE-Packages.\\n\n@@ -309,1 +309,1 @@\n-help.set.prompt = Legt die Prompts fest. Es mssen sowohl der normale als auch der Fortsetzungs-Prompt festgelegt werden:\\n\\n\\t\/set prompt <mode> \"<Prompt>\" \"<Fortsetzungs-Prompt>\"\\n\\nZeigt den normalen und den Fortsetzungs-Prompt an:\\n\\n\\t\/set prompt [<Modus>]\\n\\nDabei gilt: <Modus> ist der Name eines zuvor definierten Feedbackmodus.\\n<Prompt> und <Fortsetzungs-Prompt> sind in Anfhrungszeichen gesetzte Zeichenfolgen, die als Eingabe-Prompts ausgegeben werden.\\nOptional knnen beide \"%%s\" enthalten. Dies wird durch die nchste Snippet-ID ersetzt.\\nDer Eingabe wird unter Umstnden keine ID zugewiesen, wenn es sich z.B. um einen Fehler oder Befehl handelt.\\nDer Fortsetzungs-Prompt wird in einem mehrzeiligen Snippet in der zweiten und allen nachfolgenden Zeilen verwendet.\\n\\nBei fehlender Angabe von <Prompt> werden die aktuell festgelegten Prompts angezeigt.\\nBei Angabe des <Modus> werden nur die Prompts fr diesen Modus angezeigt.\\nBeispiel:\\n\\t\/set prompt mymode\\nZeigt die fr den Modus \"mymode\" festgelegten Prompts an\\n\n+help.set.prompt = Legt die Prompts fest. Es mssen sowohl der normale als auch der Fortsetzungs-Prompt festgelegt werden:\\n\\n\\t\/set prompt <Modus> \"<Prompt>\" \"<Fortsetzungs-Prompt>\"\\n\\nZeigt den normalen und den Fortsetzungs-Prompt an:\\n\\n\\t\/set prompt [<Modus>]\\n\\nDabei gilt: <Modus> ist der Name eines zuvor definierten Feedbackmodus.\\n<Prompt> und <Fortsetzungs-Prompt> sind in Anfhrungszeichen gesetzte Zeichenfolgen, die als Eingabe-Prompts ausgegeben werden.\\nOptional knnen beide \"%%s\" enthalten. Dies wird durch die nchste Snippet-ID ersetzt.\\nDer Eingabe wird unter Umstnden keine ID zugewiesen, wenn es sich z.B. um einen Fehler oder Befehl handelt.\\nDer Fortsetzungs-Prompt wird in einem mehrzeiligen Snippet in der zweiten und allen nachfolgenden Zeilen verwendet.\\n\\nBei fehlender Angabe von <Prompt> werden die aktuell festgelegten Prompts angezeigt.\\nBei Angabe des <Modus> werden nur die Prompts fr diesen Modus angezeigt.\\nBeispiel:\\n\\t\/set prompt mymode\\nZeigt die fr den Modus \"mymode\" festgelegten Prompts an\\n\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/resources\/l10n_de.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -183,2 +183,2 @@\n-help.usage =    jshell <option>... <load-file>...\\n\\n    --class-path <path>   \\n    --module-path <path>  \\n    --add-modules <module>(,<module>)*\\n                           <module>  \\n                            ALL-MODULE-PATHs\\n    --enable-native-access\\n                          \\n    --enable-preview      \\n    --startup <file>      \\n    --no-startup          \\n    --feedback <mode>     \\n                            silentconcisenormal  verbose\\n                            \\n    -q                    --feedback concise\\n    -s                    --feedback silent\\n    -v                    --feedback verbose\\n    -J<flag>               <flag> \\n                            \\n                            \\n                            -R<flag> -J<flag> \\n                            --execution local \\n    -R<flag>               <flag>\\n                            -R-Dfoo=bar\\n                            \\n                            System.getProperty(\"foo\")  \"bar\"\\n    -C<flag>               <flag>  JShell  Java \\n                            -C-Xlint \\n                            lint  -C--release=<N> \\n                            Java SE N  --release N\\n                             -C\\n    --version             \\n    --show-version        \\n    --help, -?, -h        \\n    --help-extra, -X      \\n\\nDEFAULT\\nPRINTINGTOOLING  JAVASE\\n \"-\" I\/O\\n\\n--class-path--module-path \\n \\\n---add-modules\\n\\t\/help context\\n\\n Windows\\n (;) \\n (:) \\n\n+help.usage =    jshell <>... <>...\\n\\n    --class-path <>   \\n    --module-path <>  \\n    --add-modules <>(,<>)*\\n                          <> \\n                            ALL-MODULE-PATHs\\n    --enable-native-access\\n                          \\n    --enable-preview      \\n    --startup <>      \\n    --no-startup          \\n    --feedback <>     \\n                            silentconcisenormal  verbose\\n                            \\n    -q                    --feedback concise\\n    -s                    --feedback silent\\n    -v                    --feedback verbose\\n    -J<>               <> \\n                            \\n                            \\n                            -R<> -J<>\\n                            --execution local \\n    -R<>               <>\\n                            -R-Dfoo=bar\\n                            \\n                            System.getProperty(\"foo\")  \"bar\"\\n    -C<>               <>  JShell  Java \\n                            -C-Xlint \\n                            lint  -C--release=<N> \\n                            Java SE N  --release N\\n                             -C\\n    --version             \\n    --show-version        \\n    --help, -?, -h        \\n    --help-extra, -X      \\n\\nDEFAULT\\nPRINTINGTOOLING  JAVASE\\n \"-\" \\\n+I\/O\\n\\n--class-path--module-path \\n --add-modules\\n\\t\/help context\\n\\n Windows\\n (;) \\n (:) \\n\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/resources\/l10n_zh_CN.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -307,1 +307,1 @@\n-    @SuppressWarnings({\"removal\", \"restricted\"})\n+    @SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpNet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"memory\/memoryReserver.hpp\"\n@@ -33,1 +34,1 @@\n-#include \"memory\/virtualspace.hpp\"\n+\n@@ -53,1 +54,1 @@\n-  ReservedSpace bot_rs(G1BlockOffsetTable::compute_size(heap.word_size()), mtGC);\n+  ReservedSpace bot_rs = MemoryReserver::reserve(G1BlockOffsetTable::compute_size(heap.word_size()), mtGC);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_freeRegionList.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"memory\/virtualspace.hpp\"\n+#include \"memory\/memoryReserver.hpp\"\n@@ -84,1 +84,3 @@\n-  ReservedSpace rs(size, os::vm_page_size());\n+  ReservedSpace rs = MemoryReserver::reserve(size,\n+                                             os::vm_allocation_granularity(),\n+                                             os::vm_page_size());\n@@ -108,2 +110,3 @@\n-  ReservedSpace rs(size, page_size);\n-\n+  ReservedSpace rs = MemoryReserver::reserve(size,\n+                                             os::vm_allocation_granularity(),\n+                                             os::vm_page_size());\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_stressCommitUncommit.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,7 +27,1 @@\n-\n-#include \"utilities\/vmassert_uninstall.hpp\"\n-#include <iomanip>\n-#include <string.h>\n-#include <sstream>\n-#include \"utilities\/vmassert_reinstall.hpp\"\n-\n+#include \"utilities\/ostream.hpp\"\n@@ -74,3 +68,4 @@\n-          std::ostringstream err_stream;\n-          err_stream << \"*** memset_with_concurrent_readers failed: set start \"\n-                     << set_start << \", set end \" << set_end << std::endl;\n+          stringStream err_stream{};\n+          err_stream.print_cr(\"*** memset_with_concurrent_readers failed: \"\n+                              \"set start %zu, set end %zu\",\n+                              set_start, set_end);\n@@ -82,9 +77,10 @@\n-              err_stream << std::dec << chunk << \",\" << line << \": \" << std::hex\n-                         << std::setw(2) << line_byte(lp, 0) << \" \"\n-                         << std::setw(2) << line_byte(lp, 1) << \"  \"\n-                         << std::setw(2) << line_byte(lp, 2) << \" \"\n-                         << std::setw(2) << line_byte(lp, 3) << \"  \"\n-                         << std::setw(2) << line_byte(lp, 4) << \" \"\n-                         << std::setw(2) << line_byte(lp, 5) << \"  \"\n-                         << std::setw(2) << line_byte(lp, 6) << \" \"\n-                         << std::setw(2) << line_byte(lp, 7) << std::endl;\n+              err_stream.print_cr(\"%u, %u: \"\n+                                  \"%02x %02x  \"\n+                                  \"%02x %02x  \"\n+                                  \"%02x %02x  \"\n+                                  \"%02x %02x\",\n+                                  chunk, line,\n+                                  line_byte(lp, 0), line_byte(lp, 1),\n+                                  line_byte(lp, 2), line_byte(lp, 3),\n+                                  line_byte(lp, 4), line_byte(lp, 5),\n+                                  line_byte(lp, 6), line_byte(lp, 7));\n@@ -96,1 +92,1 @@\n-          ASSERT_TRUE(head_clear && middle_set && tail_clear) << err_stream.str();\n+          ASSERT_TRUE(head_clear && middle_set && tail_clear) << err_stream.freeze();\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_memset_with_concurrent_readers.cpp","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"memory\/virtualspace.hpp\"\n+#include \"memory\/memoryReserver.hpp\"\n@@ -38,5 +38,1 @@\n-      if (_rs->special()) {\n-        EXPECT_TRUE(os::release_memory_special(_rs->base(), _rs->size()));\n-      } else {\n-        EXPECT_TRUE(os::release_memory(_rs->base(), _rs->size()));\n-      }\n+      EXPECT_TRUE(MemoryReserver::release(*_rs));\n@@ -67,1 +63,1 @@\n-    ReservedSpace rs(size, mtTest);\n+    ReservedSpace rs = MemoryReserver::reserve(size, mtTest);\n@@ -81,1 +77,1 @@\n-    ReservedSpace rs(size, alignment, page_size, (char *) nullptr);\n+    ReservedSpace rs = MemoryReserver::reserve(size, alignment, page_size);\n@@ -109,1 +105,1 @@\n-    ReservedSpace rs(size, alignment, page_size);\n+    ReservedSpace rs = MemoryReserver::reserve(size, alignment, page_size);\n@@ -209,1 +205,3 @@\n-      _rs->release();\n+      if (_rs->is_reserved()) {\n+        MemoryReserver::release(*_rs);\n+      }\n@@ -218,1 +216,1 @@\n-        return ReservedSpace(reserve_size_aligned, mtTest);\n+        return MemoryReserver::reserve(reserve_size_aligned, mtTest);\n@@ -221,3 +219,3 @@\n-        return ReservedSpace(reserve_size_aligned,\n-                             os::vm_allocation_granularity(),\n-                             os::vm_page_size());\n+        return MemoryReserver::reserve(reserve_size_aligned,\n+                                       os::vm_allocation_granularity(),\n+                                       os::vm_page_size());\n@@ -302,1 +300,1 @@\n-  ReservedSpace reserved(large_page_size, large_page_size, large_page_size);\n+  ReservedSpace reserved = MemoryReserver::reserve(large_page_size, large_page_size, large_page_size);\n@@ -369,4 +367,3 @@\n-    ReservedSpace rs(size,          \/\/ size\n-                     alignment,     \/\/ alignment\n-                     page_size, \/\/ page size\n-                     (char *)nullptr); \/\/ requested_address\n+    ReservedSpace rs = MemoryReserver::reserve(size,\n+                                               alignment,\n+                                               page_size);\n@@ -390,1 +387,1 @@\n-    ReservedSpace rs(size, mtTest);\n+    ReservedSpace rs = MemoryReserver::reserve(size, mtTest);\n@@ -415,1 +412,3 @@\n-    ReservedSpace rs(size, alignment, page_size);\n+    ReservedSpace rs = MemoryReserver::reserve(size,\n+                                               alignment,\n+                                               page_size);\n@@ -519,1 +518,1 @@\n-      return ReservedSpace(reserve_size_aligned, mtTest);\n+      return MemoryReserver::reserve(reserve_size_aligned, mtTest);\n@@ -522,3 +521,3 @@\n-      return ReservedSpace(reserve_size_aligned,\n-                           os::vm_allocation_granularity(),\n-                           os::vm_page_size());\n+      return MemoryReserver::reserve(reserve_size_aligned,\n+                                     os::vm_allocation_granularity(),\n+                                     os::vm_page_size());\n@@ -569,1 +568,3 @@\n-    reserved.release();\n+    if (reserved.is_reserved()) {\n+      MemoryReserver::release(reserved);\n+    }\n@@ -579,1 +580,3 @@\n-    ReservedSpace reserved(large_page_size, large_page_size, large_page_size);\n+    ReservedSpace reserved = MemoryReserver::reserve(large_page_size,\n+                                                     large_page_size,\n+                                                     large_page_size);\n@@ -591,1 +594,3 @@\n-    reserved.release();\n+    if (reserved.is_reserved()) {\n+      MemoryReserver::release(reserved);\n+    }\n","filename":"test\/hotspot\/gtest\/memory\/test_virtualspace.cpp","additions":33,"deletions":28,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"threadHelper.inline.hpp\"\n@@ -35,0 +37,2 @@\n+#include <limits>\n+\n@@ -57,1 +61,1 @@\n-void run_cmov_tests() {\n+static void run_cmov_tests() {\n@@ -110,2 +114,3 @@\n- public:\n-  typedef TESTSIZE (*cmpxchg_func)(intptr_t addr, TESTSIZE expected, TESTSIZE new_value, TESTSIZE result);\n+  \/\/ The functions expect arguments to be type represented, not C-ABI argument representation.\n+  \/\/ Hence an unsigned should be zero-extended, and the same goes for the return value.\n+  typedef int64_t (*cmpxchg_func)(intptr_t addr, int64_t expected, int64_t new_value, int64_t result);\n@@ -113,3 +118,11 @@\n-  static TESTSIZE base_cmpxchg(int variant, intptr_t addr, TESTSIZE expected, TESTSIZE new_value, TESTSIZE result, bool boolean_result = false) {\n-    BufferBlob* bb = BufferBlob::create(\"riscvTest\", 128);\n-    CodeBuffer code(bb);\n+  typedef int64_t (*cmpxchg_narrow_func)(intptr_t addr, int64_t expected, int64_t new_value, int64_t result,\n+                                          int64_t scratch0, int64_t scratch1, int64_t scratch2);\n+\n+  BufferBlob*  _bb;\n+  cmpxchg_func _func;\n+  cmpxchg_narrow_func _narrow;\n+\n+ public:\n+  CmpxchgTester(int variant, bool boolean_result) {\n+    _bb = BufferBlob::create(\"riscvTest\", 128);\n+    CodeBuffer code(_bb);\n@@ -118,1 +131,9 @@\n-    {\n+    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+        address entry = _masm.pc();\n+       _masm.cmpxchg_narrow_value(\/*addr*\/ c_rarg0, \/*expected*\/ c_rarg1, \/*new_value*\/c_rarg2,\n+                        ASMSIZE, Assembler::relaxed, Assembler::relaxed,\n+                        \/*result*\/ c_rarg3, boolean_result, c_rarg4, c_rarg5, c_rarg6); \/* Uses also t0-t1, caller saved *\/\n+      _masm.mv(c_rarg0, c_rarg3);\n+      _masm.ret();\n+      _narrow = ((cmpxchg_narrow_func)entry);\n+    } else {\n@@ -122,1 +143,1 @@\n-                        ASMSIZE, Assembler::relaxed, Assembler::relaxed,\n+                        ASMSIZE, Assembler::aq, Assembler::rl,\n@@ -129,1 +150,1 @@\n-                        ASMSIZE, Assembler::relaxed, Assembler::relaxed,\n+                        ASMSIZE, Assembler::aq, Assembler::rl,\n@@ -136,1 +157,1 @@\n-                        ASMSIZE, Assembler::relaxed, Assembler::relaxed,\n+                        ASMSIZE, Assembler::aq, Assembler::rl,\n@@ -143,1 +164,1 @@\n-                        ASMSIZE, Assembler::relaxed, Assembler::relaxed,\n+                        ASMSIZE, Assembler::aq, Assembler::rl,\n@@ -150,0 +171,1 @@\n+      _func = ((cmpxchg_func)entry);\n@@ -152,3 +174,12 @@\n-    TESTSIZE ret = ((cmpxchg_func)entry)(addr, expected, new_value, result);\n-    BufferBlob::free(bb);\n-    return ret;\n+  }\n+\n+  ~CmpxchgTester() {\n+    BufferBlob::free(_bb);\n+  }\n+\n+  TESTSIZE cmpxchg(intptr_t addr, TESTSIZE expected, TESTSIZE new_value) {\n+    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+      return _narrow(addr, expected, new_value, \/* dummy result *\/ 67, -1, -1, -1);\n+    } else {\n+      return _func(addr, expected, new_value, \/* dummy result *\/ 67);\n+    }\n@@ -159,1 +190,2 @@\n-void plain_cmpxchg_test(int variant, TESTSIZE dv, TESTSIZE ex, TESTSIZE nv, TESTSIZE eret, TESTSIZE edata, bool bv) {\n+static void plain_cmpxchg_test(int variant, TESTSIZE dv, TESTSIZE ex, TESTSIZE nv, TESTSIZE eret, TESTSIZE edata, bool bv) {\n+  CmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg(variant, bv);\n@@ -161,1 +193,1 @@\n-  TESTSIZE ret = CmpxchgTester<TESTSIZE, ASMSIZE>::base_cmpxchg(variant, (intptr_t)&data, ex, nv, \/* dummy *\/ 67, bv);\n+  TESTSIZE ret = cmpxchg.cmpxchg((intptr_t)&data, ex, nv);\n@@ -167,68 +199,73 @@\n-void run_plain_cmpxchg_tests() {\n-  \/\/ Normal\n-  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   0 \/* variant *\/ , 1337 \/* start value*\/,\n-                                        1337 \/* expected *\/,   42 \/* new value *\/,\n-                                        1337 \/* return *\/    , 42 \/* end value*\/, false \/* boolean ret*\/);\n-\n-  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   0 \/* variant *\/ , 1337 \/* start value*\/,\n-                                        1336 \/* expected *\/,   42 \/* new value *\/,\n-                                        1337 \/* return *\/  , 1337 \/* end value*\/, false \/* boolean ret*\/);\n-\n-  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   0 \/* variant *\/ , 1337 \/* start value*\/,\n-                                        1337 \/* expected *\/,   42 \/* new value *\/,\n-                                           1 \/* return *\/    , 42 \/* end value*\/, true \/* boolean ret*\/);\n-\n-  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   0 \/* variant *\/ , 1337 \/* start value*\/,\n-                                        1336 \/* expected *\/,   42 \/* new value *\/,\n-                                           0 \/* return *\/  , 1337 \/* end value*\/, true \/* boolean ret*\/);\n-\n-  \/\/ result == expected register\n-  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   1 \/* variant *\/ , 1337 \/* start value*\/,\n-                                        1337 \/* expected *\/,   42 \/* new value *\/,\n-                                        1337 \/* return *\/    , 42 \/* end value*\/, false \/* boolean ret*\/);\n-\n-  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   1 \/* variant *\/ , 1337 \/* start value*\/,\n-                                        1336 \/* expected *\/,   42 \/* new value *\/,\n-                                        1337 \/* return *\/  , 1337 \/* end value*\/, false \/* boolean ret*\/);\n-\n-  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   1 \/* variant *\/ , 1337 \/* start value*\/,\n-                                        1337 \/* expected *\/,   42 \/* new value *\/,\n-                                           1 \/* return *\/    , 42 \/* end value*\/, true \/* boolean ret*\/);\n-\n-  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   1 \/* variant *\/ , 1337 \/* start value*\/,\n-                                        1336 \/* expected *\/,   42 \/* new value *\/,\n-                                           0 \/* return *\/  , 1337 \/* end value*\/, true \/* boolean ret*\/);\n-\n-  \/\/ new_value == result register\n-  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   2 \/* variant *\/ , 1337 \/* start value*\/,\n-                                        1337 \/* expected *\/,   42 \/* new value *\/,\n-                                        1337 \/* return *\/    , 42 \/* end value*\/, false \/* boolean ret*\/);\n-\n-  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   2 \/* variant *\/ , 1337 \/* start value*\/,\n-                                        1336 \/* expected *\/,   42 \/* new value *\/,\n-                                        1337 \/* return *\/  , 1337 \/* end value*\/, false \/* boolean ret*\/);\n-\n-  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   2 \/* variant *\/ , 1337 \/* start value*\/,\n-                                        1337 \/* expected *\/,   42 \/* new value *\/,\n-                                           1 \/* return *\/    , 42 \/* end value*\/, true \/* boolean ret*\/);\n-\n-  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   2 \/* variant *\/ , 1337 \/* start value*\/,\n-                                        1336 \/* expected *\/,   42 \/* new value *\/,\n-                                           0 \/* return *\/  , 1337 \/* end value*\/, true \/* boolean ret*\/);\n-\n-  \/\/ expected == new_value register\n-  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   3 \/* variant *\/ , 1337 \/* start value*\/,\n-                                        1337 \/* expected *\/,   42 \/* new value *\/,\n-                                        1337 \/* return *\/  , 1337 \/* end value*\/, false \/* boolean ret*\/);\n-\n-  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   3 \/* variant *\/ , 1337 \/* start value*\/,\n-                                        1336 \/* expected *\/,   42 \/* new value *\/,\n-                                        1337 \/* return *\/  , 1337 \/* end value*\/, false \/* boolean ret*\/);\n-\n-  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   3 \/* variant *\/ , 1337 \/* start value*\/,\n-                                        1337 \/* expected *\/,   42 \/* new value *\/,\n-                                           1 \/* return *\/  , 1337 \/* end value*\/, true \/* boolean ret*\/);\n-\n-  plain_cmpxchg_test<TESTSIZE, ASMSIZE>(   3 \/* variant *\/ , 1337 \/* start value*\/,\n-                                        1336 \/* expected *\/,   42 \/* new value *\/,\n-                                           0 \/* return *\/  , 1337 \/* end value*\/, true \/* boolean ret*\/);\n+static void run_plain_cmpxchg_tests() {\n+  TESTSIZE max = std::numeric_limits<TESTSIZE>::max();\n+  TESTSIZE min = std::numeric_limits<TESTSIZE>::min();\n+  TESTSIZE val[] = {1337, min, max};\n+  for (int i = 0; i < 3; i++) {\n+    \/\/ Normal\n+    plain_cmpxchg_test<TESTSIZE, ASMSIZE>(     0 \/* variant *\/ , val[i] \/* start value *\/,\n+                                          val[i] \/* expected *\/,     42 \/* new value *\/,\n+                                          val[i] \/* return *\/  ,     42 \/* end value*\/, false \/* boolean ret*\/);\n+\n+    plain_cmpxchg_test<TESTSIZE, ASMSIZE>(     0 \/* variant *\/ , val[i] \/* start value *\/,\n+                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                          val[i] \/* return *\/  , val[i] \/* end value *\/, false \/* boolean ret*\/);\n+\n+    plain_cmpxchg_test<TESTSIZE, ASMSIZE>(     0 \/* variant *\/ , val[i] \/* start value *\/,\n+                                          val[i] \/* expected *\/,     42 \/* new value *\/,\n+                                               1 \/* return *\/  ,     42 \/* end value*\/, true \/* boolean ret*\/);\n+\n+    plain_cmpxchg_test<TESTSIZE, ASMSIZE>(     0 \/* variant *\/ , val[i] \/* start value *\/,\n+                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                               0 \/* return *\/  , val[i] \/* end value *\/, true \/* boolean ret*\/);\n+\n+    \/\/ result == expected register\n+    plain_cmpxchg_test<TESTSIZE, ASMSIZE>(     1 \/* variant *\/ ,  val[i] \/* start value *\/,\n+                                          val[i] \/* expected *\/,      42 \/* new value *\/,\n+                                          val[i] \/* return *\/  ,      42 \/* end value*\/, false \/* boolean ret*\/);\n+\n+    plain_cmpxchg_test<TESTSIZE, ASMSIZE>(     1 \/* variant *\/ ,  val[i] \/* start value *\/,\n+                                            1336 \/* expected *\/,      42 \/* new value *\/,\n+                                          val[i] \/* return *\/  ,  val[i] \/* end value *\/, false \/* boolean ret*\/);\n+\n+    plain_cmpxchg_test<TESTSIZE, ASMSIZE>(     1 \/* variant *\/ , val[i] \/* start value *\/,\n+                                          val[i] \/* expected *\/,     42 \/* new value *\/,\n+                                               1 \/* return *\/  ,     42 \/* end value*\/, true \/* boolean ret*\/);\n+\n+    plain_cmpxchg_test<TESTSIZE, ASMSIZE>(     1 \/* variant *\/ , val[i] \/* start value *\/,\n+                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                               0 \/* return *\/  , val[i] \/* end value *\/, true \/* boolean ret*\/);\n+\n+    \/\/ new_value == result register\n+    plain_cmpxchg_test<TESTSIZE, ASMSIZE>(     2 \/* variant *\/ , val[i] \/* start value *\/,\n+                                          val[i] \/* expected *\/,     42 \/* new value *\/,\n+                                          val[i] \/* return *\/  ,     42 \/* end value*\/, false \/* boolean ret*\/);\n+\n+    plain_cmpxchg_test<TESTSIZE, ASMSIZE>(     2 \/* variant *\/ , val[i] \/* start value *\/,\n+                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                          val[i] \/* return *\/  , val[i] \/* end value *\/, false \/* boolean ret*\/);\n+\n+    plain_cmpxchg_test<TESTSIZE, ASMSIZE>(     2 \/* variant *\/ , val[i] \/* start value *\/,\n+                                          val[i] \/* expected *\/,     42 \/* new value *\/,\n+                                               1 \/* return *\/  ,     42 \/* end value*\/, true \/* boolean ret*\/);\n+\n+    plain_cmpxchg_test<TESTSIZE, ASMSIZE>(    2 \/* variant *\/ , val[i] \/* start value *\/,\n+                                           1336 \/* expected *\/,     42 \/* new value *\/,\n+                                              0 \/* return *\/  , val[i] \/* end value *\/, true \/* boolean ret*\/);\n+\n+    \/\/ expected == new_value register\n+    plain_cmpxchg_test<TESTSIZE, ASMSIZE>(     3 \/* variant *\/ , val[i] \/* start value *\/,\n+                                          val[i] \/* expected *\/,    42 \/* new value *\/,\n+                                          val[i] \/* return *\/  , val[i] \/* end value *\/, false \/* boolean ret*\/);\n+\n+    plain_cmpxchg_test<TESTSIZE, ASMSIZE>(     3 \/* variant *\/ , val[i] \/* start value *\/,\n+                                            1336 \/* expected *\/,     42 \/* new value *\/,\n+                                          val[i] \/* return *\/  , val[i] \/* end value *\/, false \/* boolean ret*\/);\n+\n+    plain_cmpxchg_test<TESTSIZE, ASMSIZE>(     3 \/* variant *\/ , val[i] \/* start value *\/,\n+                                          val[i] \/* expected *\/,     42 \/* new value *\/,\n+                                               1 \/* return *\/  , val[i] \/* end value *\/, true \/* boolean ret*\/);\n+\n+    plain_cmpxchg_test<TESTSIZE, ASMSIZE>(    3 \/* variant *\/ , val[i] \/* start value *\/,\n+                                           1336 \/* expected *\/,     42 \/* new value *\/,\n+                                              0 \/* return *\/  , val[i] \/* end value *\/, true \/* boolean ret*\/);\n+  }\n@@ -237,1 +274,1 @@\n-TEST_VM(RiscV, cmpxchg_int64_plain_lr_sc) {\n+TEST_VM(RiscV, cmpxchg_int64_lr_sc) {\n@@ -244,1 +281,1 @@\n-TEST_VM(RiscV, cmpxchg_int64_plain_maybe_zacas) {\n+TEST_VM(RiscV, cmpxchg_int64_maybe_zacas) {\n@@ -250,1 +287,1 @@\n-TEST_VM(RiscV, cmpxchg_int32_plain_lr_sc) {\n+TEST_VM(RiscV, cmpxchg_int32_lr_sc) {\n@@ -257,1 +294,1 @@\n-TEST_VM(RiscV, cmpxchg_int32_plain_maybe_zacas) {\n+TEST_VM(RiscV, cmpxchg_int32_maybe_zacas) {\n@@ -263,5 +300,6 @@\n-template <typename TESTSIZE, Assembler::operand_size ASMSIZE>\n-class NarrowCmpxchgTester {\n- public:\n-  typedef TESTSIZE (*cmpxchg_func)(intptr_t addr, TESTSIZE expected, TESTSIZE new_value, TESTSIZE result,\n-                                   int64_t scratch0, int64_t scratch1, int64_t scratch2);\n+TEST_VM(RiscV, cmpxchg_uint32_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_plain_cmpxchg_tests<uint32_t, Assembler::uint32>();\n+  UseZacas = zacas;\n+}\n@@ -269,16 +307,3 @@\n-  static TESTSIZE narrow_cmpxchg(intptr_t addr, TESTSIZE expected, TESTSIZE new_value, TESTSIZE result, bool boolean_result = false) {\n-    BufferBlob* bb = BufferBlob::create(\"riscvTest\", 128);\n-    CodeBuffer code(bb);\n-    MacroAssembler _masm(&code);\n-    address entry = _masm.pc();\n-    {\n-       _masm.cmpxchg_narrow_value(\/*addr*\/ c_rarg0, \/*expected*\/ c_rarg1, \/*new_value*\/c_rarg2,\n-                        ASMSIZE, Assembler::relaxed, Assembler::relaxed,\n-                        \/*result*\/ c_rarg3, boolean_result, c_rarg4, c_rarg5, c_rarg6); \/* Uses also t0-t1, caller saved *\/\n-      _masm.mv(c_rarg0, c_rarg3);\n-      _masm.ret();\n-    }\n-    _masm.flush(); \/\/ icache invalidate\n-    TESTSIZE ret = ((cmpxchg_func)entry)(addr, expected, new_value, result, -1, -1, -1);\n-    BufferBlob::free(bb);\n-    return ret;\n+TEST_VM(RiscV, cmpxchg_uint32_maybe_zacas) {\n+  if (UseZacas) {\n+    run_plain_cmpxchg_tests<uint32_t, Assembler::uint32>();\n@@ -286,1 +311,1 @@\n-};\n+}\n@@ -289,1 +314,3 @@\n-void run_narrow_cmpxchg_tests() {\n+static void run_narrow_cmpxchg_tests() {\n+  CmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg(0, false);\n+  CmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg_bool(0, true);\n@@ -293,22 +320,27 @@\n-  for (int i = 0; i < 7; i++) {\n-    memset(data, -1, sizeof(data));\n-\n-    data[i] = 121;\n-    ret = NarrowCmpxchgTester<TESTSIZE, ASMSIZE>::narrow_cmpxchg((intptr_t)&data[i], 121, 42, \/* result *\/ 67, false);\n-    ASSERT_EQ(ret, 121);\n-    ASSERT_EQ(data[i], 42);\n-\n-    data[i] = 121;\n-    ret = NarrowCmpxchgTester<TESTSIZE, ASMSIZE>::narrow_cmpxchg((intptr_t)&data[i], 120, 42, \/* result *\/ 67, false);\n-    ASSERT_EQ(ret, 121);\n-    ASSERT_EQ(data[i], 121);\n-\n-    data[i] = 121;\n-    ret = NarrowCmpxchgTester<TESTSIZE, ASMSIZE>::narrow_cmpxchg((intptr_t)&data[i], 121, 42, \/* result *\/ 67, true);\n-    ASSERT_EQ(ret, 1);\n-    ASSERT_EQ(data[i], 42);\n-\n-    data[i] = 121;\n-    ret = NarrowCmpxchgTester<TESTSIZE, ASMSIZE>::narrow_cmpxchg((intptr_t)&data[i], 120, 42, \/* result *\/ 67, true);\n-    ASSERT_EQ(ret, 0);\n-    ASSERT_EQ(data[i], 121);\n+  TESTSIZE max = std::numeric_limits<TESTSIZE>::max();\n+  TESTSIZE min = std::numeric_limits<TESTSIZE>::min();\n+  TESTSIZE val[] = {121, min, max};\n+  for (int i = 0; i < 3; i++) {\n+    for (int j = 0; j < 7; j++) {\n+      \/\/ printf(\"%lu %lX\\n\", (uint64_t)val[i], (uint64_t)val[i]);\n+      memset(data, -1, sizeof(data));\n+      data[i] = val[i];\n+      ret = cmpxchg.cmpxchg((intptr_t)&data[i], val[i], 42);\n+      ASSERT_EQ(ret, val[i]);\n+      ASSERT_EQ(data[i], 42);\n+\n+      data[i] = val[i];\n+      ret = cmpxchg.cmpxchg((intptr_t)&data[i], 120, 42);\n+      ASSERT_EQ(ret, val[i]);\n+      ASSERT_EQ(data[i], val[i]);\n+\n+      data[i] = val[i];\n+      ret = cmpxchg_bool.cmpxchg((intptr_t)&data[i], val[i], 42);\n+      ASSERT_EQ(ret, 1);\n+      ASSERT_EQ(data[i], 42);\n+\n+      data[i] = val[i];\n+      ret = cmpxchg_bool.cmpxchg((intptr_t)&data[i], 120, 42);\n+      ASSERT_EQ(ret, 0);\n+      ASSERT_EQ(data[i], val[i]);\n+    }\n@@ -325,0 +357,6 @@\n+TEST_VM(RiscV, cmpxchg_int16_maybe_zacas) {\n+  if (UseZacas) {\n+    run_narrow_cmpxchg_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n@@ -332,1 +370,1 @@\n-TEST_VM(RiscV, cmpxchg_int16_maybe_zacas) {\n+TEST_VM(RiscV, cmpxchg_int8_maybe_zacas) {\n@@ -334,1 +372,1 @@\n-    run_narrow_cmpxchg_tests<int16_t, Assembler::int16>();\n+    run_narrow_cmpxchg_tests<int8_t, Assembler::int8>();\n@@ -338,1 +376,79 @@\n-TEST_VM(RiscV, cmpxchg_int8_maybe_zacas) {\n+template <typename TESTSIZE>\n+TESTSIZE next_count(TESTSIZE now, TESTSIZE add) {\n+  if ((std::numeric_limits<TESTSIZE>::max() - add) >= now) {\n+    return now + add;\n+  }\n+  TESTSIZE diff = std::numeric_limits<TESTSIZE>::max() - now;\n+  add -= diff + 1; \/\/ add one to the diff for the wrap around.\n+  return std::numeric_limits<TESTSIZE>::min() + add;\n+}\n+\n+constexpr int64_t PAR_IT_END       = 10000;\n+constexpr int64_t NUMBER_THREADS   = 4;\n+constexpr int64_t TOTAL_ITERATIONS = NUMBER_THREADS * PAR_IT_END;\n+\n+template <typename TESTSIZE, ENABLE_IF(std::numeric_limits<TESTSIZE>::max() <= (std::numeric_limits<TESTSIZE>::min() + TOTAL_ITERATIONS))>\n+constexpr TESTSIZE result_count() {\n+  int64_t range = std::numeric_limits<TESTSIZE>::max() - std::numeric_limits<TESTSIZE>::min() + 1;\n+  int64_t rest = TOTAL_ITERATIONS % range;\n+  return std::numeric_limits<TESTSIZE>::min() + rest;\n+}\n+\n+template <typename TESTSIZE, ENABLE_IF(std::numeric_limits<TESTSIZE>::max() > (std::numeric_limits<TESTSIZE>::min() + TOTAL_ITERATIONS))>\n+constexpr TESTSIZE result_count() {\n+  return std::numeric_limits<TESTSIZE>::min() + TOTAL_ITERATIONS;\n+}\n+\n+template <typename TESTSIZE, Assembler::operand_size ASMSIZE>\n+static void run_concurrent_cmpxchg_tests() {\n+  volatile TESTSIZE data = std::numeric_limits<TESTSIZE>::min();\n+  int num_threads = NUMBER_THREADS;\n+  CmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg(0, false); \/\/ variant 0, not bool ret\n+  auto incThread = [&](Thread* _current, int _id) {   \/\/ _id starts from 0..(CTHREAD-1)\n+    TESTSIZE my_oldvalue = std::numeric_limits<TESTSIZE>::min() + _id;\n+    for (int64_t i = 0; i < PAR_IT_END ; i++) {\n+      TESTSIZE newvalue = next_count<TESTSIZE>(my_oldvalue,  1);\n+      TESTSIZE ret;\n+      do {\n+        ret = cmpxchg.cmpxchg((intptr_t)&data, my_oldvalue, newvalue);\n+      } while (ret != my_oldvalue);\n+      my_oldvalue = next_count<TESTSIZE>(my_oldvalue, num_threads);\n+    }\n+  };\n+  TestThreadGroup<decltype(incThread)> ttg(incThread, num_threads);\n+  ttg.doit();\n+  ttg.join();\n+  ASSERT_EQ(data, result_count<TESTSIZE>());\n+}\n+\n+template <typename TESTSIZE, Assembler::operand_size ASMSIZE>\n+static void run_concurrent_alt_cmpxchg_tests() {\n+  volatile TESTSIZE data = std::numeric_limits<TESTSIZE>::min();\n+  int num_threads = NUMBER_THREADS;\n+  CmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg(0, false); \/\/ variant 0, not bool ret\n+  auto incThread = [&](Thread* _current, int _id) {   \/\/ _id starts from 0..(CTHREAD-1)\n+    for (int i = 0; i < PAR_IT_END; i++) {\n+      TESTSIZE oldvalue;\n+      TESTSIZE ret = 0;\n+      do {\n+        oldvalue = ret;\n+        TESTSIZE newvalue = next_count<TESTSIZE>(oldvalue, 1);\n+        ret = cmpxchg.cmpxchg((intptr_t)&data, oldvalue, newvalue);\n+      } while (ret != oldvalue);\n+    }\n+  };\n+  TestThreadGroup<decltype(incThread)> ttg(incThread, num_threads);\n+  ttg.doit();\n+  ttg.join();\n+  ASSERT_EQ(data, result_count<TESTSIZE>());\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int64_concurrent_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_concurrent_cmpxchg_tests<int64_t, Assembler::int64>();\n+  run_concurrent_alt_cmpxchg_tests<int64_t, Assembler::int64>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int64_concurrent_maybe_zacas) {\n@@ -340,1 +456,62 @@\n-    run_narrow_cmpxchg_tests<int8_t, Assembler::int8>();\n+    run_concurrent_cmpxchg_tests<int64_t, Assembler::int64>();\n+    run_concurrent_alt_cmpxchg_tests<int64_t, Assembler::int64>();\n+  }\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int32_concurrent_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_concurrent_cmpxchg_tests<int32_t, Assembler::int32>();\n+  run_concurrent_alt_cmpxchg_tests<int32_t, Assembler::int32>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int32_concurrent_maybe_zacas) {\n+  if (UseZacas) {\n+    run_concurrent_cmpxchg_tests<int32_t, Assembler::int32>();\n+    run_concurrent_alt_cmpxchg_tests<int32_t, Assembler::int32>();\n+  }\n+}\n+\n+TEST_VM(RiscV, cmpxchg_uint32_concurrent_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_concurrent_cmpxchg_tests<uint32_t, Assembler::uint32>();\n+  run_concurrent_alt_cmpxchg_tests<uint32_t, Assembler::uint32>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, cmpxchg_uint32_concurrent_maybe_zacas) {\n+  if (UseZacas) {\n+    run_concurrent_cmpxchg_tests<uint32_t, Assembler::uint32>();\n+    run_concurrent_alt_cmpxchg_tests<uint32_t, Assembler::uint32>();\n+  }\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int16_concurrent_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_concurrent_cmpxchg_tests<int16_t, Assembler::int16>();\n+  run_concurrent_alt_cmpxchg_tests<int16_t, Assembler::int16>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int16_concurrent_maybe_zacas) {\n+  if (UseZacas) {\n+    run_concurrent_cmpxchg_tests<int16_t, Assembler::int16>();\n+    run_concurrent_alt_cmpxchg_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int8_concurrent_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_concurrent_cmpxchg_tests<int8_t, Assembler::int8>();\n+  run_concurrent_alt_cmpxchg_tests<int8_t, Assembler::int8>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int8_concurrent_maybe_zacas) {\n+  if (UseZacas) {\n+    run_concurrent_cmpxchg_tests<int8_t, Assembler::int8>();\n+    run_concurrent_alt_cmpxchg_tests<int8_t, Assembler::int8>();\n@@ -346,2 +523,3 @@\n- public:\n-  typedef TESTSIZE (*cmpxchg_narrow)(intptr_t addr, TESTSIZE expected, TESTSIZE new_value, TESTSIZE result,\n+  \/\/ The functions expect arguments to be type represented, not C-ABI argument representation.\n+  \/\/ Hence an unsigned should be zero-extended, and the same goes for the return value.\n+  typedef int64_t (*weak_cmpxchg_narrow_func)(intptr_t addr, int64_t expected, int64_t new_value, int64_t result,\n@@ -350,1 +528,1 @@\n-  typedef TESTSIZE (*cmpxchg_func)(intptr_t addr, TESTSIZE expected, TESTSIZE new_value, TESTSIZE result);\n+  typedef int64_t (*weak_cmpxchg_func)(intptr_t addr, int64_t expected, int64_t new_value, int64_t result);\n@@ -352,3 +530,8 @@\n-  static TESTSIZE weak_narrow_cmpxchg(intptr_t addr, TESTSIZE expected, TESTSIZE new_value) {\n-    BufferBlob* bb = BufferBlob::create(\"riscvTest\", 128);\n-    CodeBuffer code(bb);\n+  BufferBlob*  _bb;\n+  weak_cmpxchg_narrow_func _narrow_weak;\n+  weak_cmpxchg_func _weak;\n+\n+ public:\n+  WeakCmpxchgTester() : _bb(nullptr), _narrow_weak(nullptr), _weak(nullptr) {\n+    _bb = BufferBlob::create(\"riscvTest\", 128);\n+    CodeBuffer code(_bb);\n@@ -356,2 +539,2 @@\n-    address entry = _masm.pc();\n-    {\n+    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+        address entry = _masm.pc();\n@@ -363,13 +546,3 @@\n-    }\n-    _masm.flush(); \/\/ icache invalidate\n-    TESTSIZE ret = ((cmpxchg_narrow)entry)(addr, expected, new_value, \/*result*\/ 67, -1, -1, -1);\n-    BufferBlob::free(bb);\n-    return ret;\n-  }\n-\n-  static TESTSIZE weak_cmpxchg(intptr_t addr, TESTSIZE expected, TESTSIZE new_value) {\n-    BufferBlob* bb = BufferBlob::create(\"riscvTest\", 128);\n-    CodeBuffer code(bb);\n-    MacroAssembler _masm(&code);\n-    address entry = _masm.pc();\n-    {\n+      _narrow_weak = ((weak_cmpxchg_narrow_func)entry);\n+    } else {\n+        address entry = _masm.pc();\n@@ -380,0 +553,1 @@\n+      _weak = ((weak_cmpxchg_func)entry);\n@@ -382,3 +556,12 @@\n-    TESTSIZE ret = ((cmpxchg_func)entry)(addr, expected, new_value, \/*result*\/ 67);\n-    BufferBlob::free(bb);\n-    return ret;\n+  }\n+\n+  TESTSIZE weak_cmpxchg(intptr_t addr, TESTSIZE expected, TESTSIZE new_value) {\n+    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+      return _narrow_weak(addr, expected, new_value, \/* dummy result *\/ 67, -1, -1, -1);\n+    } else {\n+      return _weak(addr, expected, new_value, \/* dummy result *\/ 67);\n+    }\n+  }\n+\n+  ~WeakCmpxchgTester() {\n+    BufferBlob::free(_bb);\n@@ -389,16 +572,54 @@\n-void run_weak_cmpxchg_narrow_value_tests() {\n-  \/\/ Assume natural aligned\n-  TESTSIZE data[8];\n-  TESTSIZE ret;\n-  for (int i = 0; i < 7; i++) {\n-    memset(data, -1, sizeof(data));\n-\n-    data[i] = 121;\n-    ret = WeakCmpxchgTester<TESTSIZE, ASMSIZE>::weak_narrow_cmpxchg((intptr_t)&data[i], 121, 42);\n-    ASSERT_EQ(ret, 1);\n-    ASSERT_EQ(data[i], 42);\n-\n-    data[i] = 121;\n-    ret = WeakCmpxchgTester<TESTSIZE, ASMSIZE>::weak_narrow_cmpxchg((intptr_t)&data[i], 120, 42);\n-    ASSERT_EQ(ret, 0);\n-    ASSERT_EQ(data[i], 121);\n+void run_weak_cmpxchg_tests() {\n+  TESTSIZE max = std::numeric_limits<TESTSIZE>::max();\n+  TESTSIZE min = std::numeric_limits<TESTSIZE>::min();\n+  TESTSIZE val[] = {121, min, max};\n+  for (int i = 0; i < 3; i++) {\n+    WeakCmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg;\n+    TESTSIZE data = val[i];\n+    TESTSIZE ret = cmpxchg.weak_cmpxchg((intptr_t)&data, val[i], 42);\n+    ASSERT_EQ(ret, (TESTSIZE)1);\n+    ASSERT_EQ(data, (TESTSIZE)42);\n+\n+    data = val[i];\n+    ret = cmpxchg.weak_cmpxchg((intptr_t)&data, 120, 42);\n+    ASSERT_EQ(ret, (TESTSIZE)0);\n+    ASSERT_EQ(data, (TESTSIZE)val[i]);\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int64_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_weak_cmpxchg_tests<int64_t, Assembler::int64>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int64_maybe_zacas) {\n+  if (UseZacas) {\n+    run_weak_cmpxchg_tests<int64_t, Assembler::int64>();\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int32_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_weak_cmpxchg_tests<int32_t, Assembler::int32>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int32_maybe_zacas) {\n+  if (UseZacas) {\n+    run_weak_cmpxchg_tests<int32_t, Assembler::int32>();\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_uint32_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_weak_cmpxchg_tests<uint32_t, Assembler::uint32>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_uint32_maybe_zacas) {\n+  if (UseZacas) {\n+    run_weak_cmpxchg_tests<uint32_t, Assembler::uint32>();\n@@ -411,1 +632,1 @@\n-  run_weak_cmpxchg_narrow_value_tests<int16_t, Assembler::int16>();\n+  run_weak_cmpxchg_tests<int16_t, Assembler::int16>();\n@@ -418,1 +639,1 @@\n-  run_weak_cmpxchg_narrow_value_tests<int8_t, Assembler::int8>();\n+  run_weak_cmpxchg_tests<int8_t, Assembler::int8>();\n@@ -424,1 +645,1 @@\n-    run_weak_cmpxchg_narrow_value_tests<int16_t, Assembler::int16>();\n+    run_weak_cmpxchg_tests<int16_t, Assembler::int16>();\n@@ -430,1 +651,1 @@\n-    run_weak_cmpxchg_narrow_value_tests<int8_t, Assembler::int8>();\n+    run_weak_cmpxchg_tests<int8_t, Assembler::int8>();\n@@ -435,5 +656,20 @@\n-void run_weak_cmpxchg_tests() {\n-  TESTSIZE data = 121;\n-  TESTSIZE ret = WeakCmpxchgTester<TESTSIZE, ASMSIZE>::weak_cmpxchg((intptr_t)&data, 121, 42);\n-  ASSERT_EQ(ret, 1);\n-  ASSERT_EQ(data, 42);\n+static void run_concurrent_weak_cmpxchg_tests() {\n+  volatile TESTSIZE data = std::numeric_limits<TESTSIZE>::min();\n+  int num_threads = NUMBER_THREADS;\n+  WeakCmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg; \/\/ not bool ret\n+  auto incThread = [&](Thread* _current, int _id) { \/\/ _id starts from 0..(CTHREAD-1)\n+    TESTSIZE my_oldvalue = std::numeric_limits<TESTSIZE>::min() + _id;\n+    for (int64_t i = 0; i < PAR_IT_END; i++) {\n+      TESTSIZE newvalue = next_count<TESTSIZE>(my_oldvalue, 1);\n+      TESTSIZE ret;\n+      do {\n+        ret = cmpxchg.weak_cmpxchg((intptr_t)&data, my_oldvalue, newvalue);\n+      } while (ret != 1);\n+      my_oldvalue = next_count<TESTSIZE>(my_oldvalue, num_threads);\n+    }\n+  };\n+  TestThreadGroup<decltype(incThread)> ttg(incThread, num_threads);\n+  ttg.doit();\n+  ttg.join();\n+  ASSERT_EQ(data, result_count<TESTSIZE>());\n+}\n@@ -441,4 +677,20 @@\n-  data = 121;\n-  ret = WeakCmpxchgTester<TESTSIZE, ASMSIZE>::weak_cmpxchg((intptr_t)&data, 120, 42);\n-  ASSERT_EQ(ret, 0);\n-  ASSERT_EQ(data, 121);\n+template <typename TESTSIZE, Assembler::operand_size ASMSIZE>\n+static void run_concurrent_alt_weak_cmpxchg_tests() {\n+  volatile TESTSIZE data = std::numeric_limits<TESTSIZE>::min();\n+  int num_threads = NUMBER_THREADS;\n+  WeakCmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg; \/\/ not bool ret\n+  auto incThread = [&](Thread* _current, int _id) { \/\/ _id starts from 0..(CTHREAD-1)\n+    for (int i = 0; i < PAR_IT_END; i++) {\n+      TESTSIZE oldvalue;\n+      TESTSIZE ret = 0;\n+      do {\n+        oldvalue = data;\n+        TESTSIZE newvalue = next_count<TESTSIZE>(oldvalue, 1);\n+        ret = cmpxchg.weak_cmpxchg((intptr_t)&data, oldvalue, newvalue);\n+      } while (ret != 1);\n+    }\n+  };\n+  TestThreadGroup<decltype(incThread)> ttg(incThread, num_threads);\n+  ttg.doit();\n+  ttg.join();\n+  ASSERT_EQ(data, result_count<TESTSIZE>());\n@@ -447,1 +699,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int64_lr_sc) {\n+TEST_VM(RiscV, weak_cmpxchg_int64_concurrent_lr_sc) {\n@@ -450,1 +702,2 @@\n-  run_weak_cmpxchg_tests<int64_t, Assembler::int64>();\n+  run_concurrent_weak_cmpxchg_tests<int64_t, Assembler::int64>();\n+  run_concurrent_alt_weak_cmpxchg_tests<int64_t, Assembler::int64>();\n@@ -454,1 +707,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int64_maybe_zacas) {\n+TEST_VM(RiscV, weak_cmpxchg_int64_concurrent_maybe_zacas) {\n@@ -456,1 +709,2 @@\n-    run_weak_cmpxchg_tests<int64_t, Assembler::int64>();\n+    run_concurrent_weak_cmpxchg_tests<int64_t, Assembler::int64>();\n+    run_concurrent_alt_weak_cmpxchg_tests<int64_t, Assembler::int64>();\n@@ -460,1 +714,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int32_lr_sc) {\n+TEST_VM(RiscV, weak_cmpxchg_int32_concurrent_lr_sc) {\n@@ -463,1 +717,2 @@\n-  run_weak_cmpxchg_tests<int32_t, Assembler::int32>();\n+  run_concurrent_weak_cmpxchg_tests<int32_t, Assembler::int32>();\n+  run_concurrent_alt_weak_cmpxchg_tests<int32_t, Assembler::int32>();\n@@ -467,1 +722,1 @@\n-TEST_VM(RiscV, weak_cmpxchg_int32_maybe_zacas) {\n+TEST_VM(RiscV, weak_cmpxchg_int32_concurrent_maybe_zacas) {\n@@ -469,1 +724,32 @@\n-    run_weak_cmpxchg_tests<int32_t, Assembler::int32>();\n+    run_concurrent_weak_cmpxchg_tests<int32_t, Assembler::int32>();\n+    run_concurrent_alt_weak_cmpxchg_tests<int32_t, Assembler::int32>();\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int16_concurrent_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_concurrent_weak_cmpxchg_tests<int16_t, Assembler::int16>();\n+  run_concurrent_alt_weak_cmpxchg_tests<int16_t, Assembler::int16>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int16_concurrent_maybe_zacas) {\n+  if (UseZacas) {\n+    run_concurrent_weak_cmpxchg_tests<int16_t, Assembler::int16>();\n+    run_concurrent_alt_weak_cmpxchg_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int8_concurrent_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_concurrent_weak_cmpxchg_tests<int8_t, Assembler::int8>();\n+  run_concurrent_alt_weak_cmpxchg_tests<int8_t, Assembler::int8>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, weak_cmpxchg_int8_concurrent_maybe_zacas) {\n+  if (UseZacas) {\n+    run_concurrent_weak_cmpxchg_tests<int8_t, Assembler::int8>();\n+    run_concurrent_alt_weak_cmpxchg_tests<int8_t, Assembler::int8>();\n","filename":"test\/hotspot\/gtest\/riscv\/test_assembler_riscv.cpp","additions":484,"deletions":198,"binary":false,"changes":682,"status":"modified"},{"patch":"@@ -34,2 +34,1 @@\n-\n-#include \"memory\/virtualspace.hpp\"\n+#include \"memory\/memoryReserver.hpp\"\n@@ -96,1 +95,1 @@\n-    ReservedSpace rs(size, mtTest);\n+    ReservedSpace rs = MemoryReserver::reserve(size, mtTest);\n@@ -170,1 +169,1 @@\n-    ReservedSpace rs(size, mtTest);\n+    ReservedSpace rs = MemoryReserver::reserve(size, mtTest);\n@@ -257,1 +256,1 @@\n-    ReservedSpace rs(size, mtTest);\n+    ReservedSpace rs = MemoryReserver::reserve(size, mtTest);\n@@ -428,1 +427,1 @@\n-    ReservedSpace rs(size, mtTest);\n+    ReservedSpace rs = MemoryReserver::reserve(size, mtTest);\n","filename":"test\/hotspot\/gtest\/runtime\/test_virtualMemoryTracker.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+vmTestbase\/vm\/mlvm\/indy\/func\/jvmti\/mergeCP_indy2manyDiff_a\/TestDescription.java 8308367 generic-all\n@@ -90,5 +91,2 @@\n-# The test first suspends a vthread and all the carriers and then it resumes the vthread expecting it\n-# to run to completion. In mainline it only works because the suspension step happens while the vthread is\n-# pinned to the carrier blocked on synchronized. So the carrier only actually suspends on the next unmount\n-# transition which in this test happens once the vthread has finished executing the expected code.\n-\n+# Fails because resume of a virtual thread is not enough to allow the virtual thread\n+# to make progress when all other threads are currently suspended.\n@@ -97,6 +95,0 @@\n-###\n-# The test sends a StopThread to a vthread expecting that is currently pinned to the carrier blocked on\n-# synchronized. Since the vthread is now unmounted StopThread returns JVMTI_ERROR_OPAQUE_FRAME error.\n-\n-vmTestbase\/nsk\/jdb\/kill\/kill001\/kill001.java 8338714 generic-all\n-\n@@ -115,0 +107,1 @@\n+runtime\/classFileParserBug\/TestEmptyBootstrapMethodsAttr.java JDK-8346442 generic-all\n@@ -116,0 +109,1 @@\n+runtime\/logging\/LoaderConstraintsTest.java JDK-8346442 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -138,2 +138,0 @@\n-serviceability\/dcmd\/vm\/SystemDumpMapTest.java 8340401 windows-all\n-serviceability\/dcmd\/vm\/SystemMapTest.java 8340401 windows-all\n@@ -176,1 +174,0 @@\n-vmTestbase\/gc\/memory\/Nio\/Nio.java 8340728 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -530,1 +530,0 @@\n- -runtime\/cds\/appcds\/javaldr\/AnonVmClassesDuringDump.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-The user can also directly specify user-defined regexes in combination with a required compile phase (there is no default compile phase known by the framework for custom regexes). If such a user-defined regex represents a not yet supported C2 IR node, it is highly encouraged to directly add a new IR node placeholder string definition to [IRNode](.\/IRNode.java) for it instead together with a static regex mapping block.\n+The user can also directly specify user-defined regexes in combination with a required compile phase (there is no default compile phase known by the framework for custom regexes). If a user-defined regex corresponds to a C2 IR node that is not yet supported, it is recommended to add a new placeholder string definition for the IR node to [IRNode](.\/IRNode.java), along with a corresponding static regex mapping block.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/README.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,309 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.verify;\n+\n+import java.util.Optional;\n+import java.lang.foreign.*;\n+\n+\/**\n+ * The {@link Verify} class provides a single {@link Verify#checkEQ} static method, which recursively\n+ * compares the two {@link Object}s by value. It deconstructs {@link Object[]}, compares boxed primitive\n+ * types, and compares the content of arrays and {@link MemorySegment}s.\n+ *\n+ * When a comparison fail, then methods print helpful messages, before throwing a {@link VerifyException}.\n+ *\/\n+public final class Verify {\n+\n+    private Verify() {}\n+\n+    \/**\n+     * Verify the content of two Objects, possibly recursively. Only limited types are implemented.\n+     *\n+     * @param a First object to be recursively compared with the second.\n+     * @param b Second object to be recursively compared with the first.\n+     * @throws VerifyException If the comparison fails.\n+     *\/\n+    public static void checkEQ(Object a, Object b) {\n+        checkEQ(a, b, \"\");\n+    }\n+\n+    \/**\n+     * Verify the content of two Objects, possibly recursively. Only limited types are implemented.\n+     *\/\n+    private static void checkEQ(Object a, Object b, String context) {\n+        \/\/ Both null\n+        if (a == null && b == null) {\n+            return;\n+        }\n+\n+        \/\/ Null mismatch\n+        if (a == null || b == null) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: null mismatch\");\n+            print(a, \"a \" + context);\n+            print(b, \"b \" + context);\n+            throw new VerifyException(\"Object array null mismatch.\");\n+        }\n+\n+        \/\/ Class mismatch\n+        Class ca = a.getClass();\n+        Class cb = b.getClass();\n+        if (ca != cb) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: class mismatch.\");\n+            System.err.println(\"       \" + ca.getName() + \" vs \" + cb.getName());\n+            print(a, \"a \" + context);\n+            print(b, \"b \" + context);\n+            throw new VerifyException(\"Object class mismatch.\");\n+        }\n+\n+        switch (a) {\n+            case Object[]  x -> checkEQimpl(x, (Object[])b,                context);\n+            case Byte      x -> checkEQimpl(x, ((Byte)b).byteValue(),      context);\n+            case Character x -> checkEQimpl(x, ((Character)b).charValue(), context);\n+            case Short     x -> checkEQimpl(x, ((Short)b).shortValue(),    context);\n+            case Integer   x -> checkEQimpl(x, ((Integer)b).intValue(),    context);\n+            case Long      x -> checkEQimpl(x, ((Long)b).longValue(),      context);\n+            case Float     x -> checkEQimpl(x, ((Float)b).floatValue(),    context);\n+            case Double    x -> checkEQimpl(x, ((Double)b).doubleValue(),  context);\n+            case byte[]    x -> checkEQimpl(x, (byte[])b,                  context);\n+            case char[]    x -> checkEQimpl(x, (char[])b,                  context);\n+            case short[]   x -> checkEQimpl(x, (short[])b,                 context);\n+            case int[]     x -> checkEQimpl(x, (int[])b,                   context);\n+            case long[]    x -> checkEQimpl(x, (long[])b,                  context);\n+            case float[]   x -> checkEQimpl(x, (float[])b,                 context);\n+            case double[]  x -> checkEQimpl(x, (double[])b,                context);\n+            case MemorySegment x -> checkEQimpl(x, (MemorySegment) b,      context);\n+            default -> {\n+                System.err.println(\"ERROR: Verify.checkEQ failed: type not supported: \" + ca.getName());\n+                print(a, \"a \" + context);\n+                print(b, \"b \" + context);\n+                throw new VerifyException(\"Object array type not supported: \" + ca.getName());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two bytes are identical.\n+     *\/\n+    private static void checkEQimpl(byte a, byte b, String context) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two chars are identical.\n+     *\/\n+    private static void checkEQimpl(char a, char b, String context) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + (int)a + \" vs \" + (int)b + \" for \" + context);\n+            throw new VerifyException(\"Value mismatch: \" + (int)a + \" vs \" + (int)b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two shorts are identical.\n+     *\/\n+    private static void checkEQimpl(short a, short b, String context) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + (int)a + \" vs \" + (int)b + \" for \" + context);\n+            throw new VerifyException(\"Value mismatch: \" + (int)a + \" vs \" + (int)b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two ints are identical.\n+     *\/\n+    private static void checkEQimpl(int a, int b, String context) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two longs are identical.\n+     *\/\n+    private static void checkEQimpl(long a, long b, String context) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two floats have identical bits.\n+     *\/\n+    private static void checkEQimpl(float a, float b, String context) {\n+        if (Float.floatToRawIntBits(a) != Float.floatToRawIntBits(b)) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch for \" + context);\n+            System.err.println(\"       Values: \" + a + \" vs \" + b);\n+            System.err.println(\"       Values: \" + Float.floatToRawIntBits(a) + \" vs \" + Float.floatToRawIntBits(b));\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two doubles have identical bits.\n+     *\/\n+    private static void checkEQimpl(double a, double b, String context) {\n+        if (Double.doubleToRawLongBits(a) != Double.doubleToRawLongBits(b)) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch for \" + context);\n+            System.err.println(\"       Values: \" + a + \" vs \" + b);\n+            System.err.println(\"       Values: \" + Double.doubleToRawLongBits(a) + \" vs \" + Double.doubleToRawLongBits(b));\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that the content of two MemorySegments is identical. Note: we do not check the\n+     * backing type, only the size and content.\n+     *\/\n+    private static void checkEQimpl(MemorySegment a, MemorySegment b, String context) {\n+        long offset = a.mismatch(b);\n+        if (offset == -1) { return; }\n+\n+        \/\/ Print some general info\n+        System.err.println(\"ERROR: Verify.checkEQ failed for: \" + context);\n+\n+        printMemorySegment(a, \"a \" + context);\n+        printMemorySegment(b, \"b \" + context);\n+\n+        \/\/ (1) Mismatch on size\n+        if (a.byteSize() != b.byteSize()) {\n+            throw new VerifyException(\"MemorySegment byteSize mismatch.\");\n+        }\n+\n+        \/\/ (2) Value mismatch\n+        System.err.println(\"  Value mismatch at byte offset: \" + offset);\n+        printMemorySegmentValue(a, offset, 16);\n+        printMemorySegmentValue(b, offset, 16);\n+        throw new VerifyException(\"MemorySegment value mismatch.\");\n+    }\n+\n+    \/**\n+     * Verify that the content of two byte arrays is identical.\n+     *\/\n+    private static void checkEQimpl(byte[] a, byte[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two char arrays is identical.\n+     *\/\n+    private static void checkEQimpl(char[] a, char[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two short arrays is identical.\n+     *\/\n+    private static void checkEQimpl(short[] a, short[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two int arrays is identical.\n+     *\/\n+    private static void checkEQimpl(int[] a, int[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two long arrays is identical.\n+     *\/\n+    private static void checkEQimpl(long[] a, long[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two float arrays is identical.\n+     *\/\n+    private static void checkEQimpl(float[] a, float[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two double arrays is identical.\n+     *\/\n+    private static void checkEQimpl(double[] a, double[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two Object arrays is identical, recursively:\n+     * every element is compared with checkEQimpl for the corresponding type.\n+     *\/\n+    private static void checkEQimpl(Object[] a, Object[] b, String context) {\n+        \/\/ (1) Length mismatch\n+        if (a.length != b.length) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: length mismatch: \" + a.length + \" vs \" + b.length);\n+            throw new VerifyException(\"Object array length mismatch.\");\n+        }\n+\n+        for (int i = 0; i < a.length; i++) {\n+            \/\/ Recursive checkEQ call.\n+            checkEQ(a[i], b[i], \"[\" + i + \"]\" + context);\n+        }\n+    }\n+\n+    private static void print(Object a, String context) {\n+        if (a == null) {\n+            System.err.println(\"  \" + context + \": null\");\n+        } else {\n+            System.err.println(\"  \" + context + \": \" + a);\n+        }\n+    }\n+\n+    private static void printMemorySegment(MemorySegment a, String context) {\n+        Optional<Object> maybeBase = a.heapBase();\n+        System.err.println(\"  \" + context + \" via MemorySegment:\");\n+        if (maybeBase.isEmpty()) {\n+            System.err.println(\"    no heap base (native).\");\n+        } else {\n+            Object base = maybeBase.get();\n+            System.err.println(\"    heap base: \" + base);\n+        }\n+        System.err.println(\"    address: \" + a.address());\n+        System.err.println(\"    byteSize: \" + a.byteSize());\n+    }\n+\n+    private static void printMemorySegmentValue(MemorySegment a, long offset, int range) {\n+        long start = Long.max(offset - range, 0);\n+        long end   = Long.min(offset + range, a.byteSize());\n+        for (long i = start; i < end; i++) {\n+            byte b = a.get(ValueLayout.JAVA_BYTE, i);\n+            System.err.print(String.format(\"%02x \", b));\n+        }\n+        System.err.println(\"\");\n+        for (long i = start; i < end; i++) {\n+            if (i == offset) {\n+                System.err.print(\"^^ \");\n+            } else {\n+                System.err.print(\"   \");\n+            }\n+        }\n+        System.err.println(\"\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/verify\/Verify.java","additions":309,"deletions":0,"binary":false,"changes":309,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.verify;\n+\n+\/**\n+ * Exception thrown in verification.\n+ *\/\n+public class VerifyException extends RuntimeException {\n+\n+    \/**\n+     * Creates a new verification exception.\n+     *\n+     * @param message Exception message for context when debugging.\n+     *\/\n+    public VerifyException(String message) {\n+        super(\"Value verification failed:\" + System.lineSeparator() + message);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/verify\/VerifyException.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,474 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8332827\n+ * @summary [REDO] C2: crash in compiled code because of dependency on removed range check CastIIs\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n+ *                   -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n+ *                   -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main\/othervm -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ *\n+ *\/\n+\n+public class TestArrayAccessAboveRCAfterRCCastIIEliminated {\n+    private static int intField;\n+    private static long longField;\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[100];\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(9, 10, 1, true);\n+            test1(9, 10, 1, false);\n+            test2(9, 10, 1, true);\n+            test2(9, 10, 1, false);\n+            test3(9, 10, 1, true);\n+            test3(9, 10, 1, false);\n+            test4(9, 10, 1, true);\n+            test4(9, 10, 1, false);\n+            test5(9, 10, 1, true);\n+            test5(9, 10, 1, false);\n+            test6(9, 10, 1, true);\n+            test6(9, 10, 1, false);\n+            test7(9, 10, 1, true);\n+            test7(9, 10, 1, false);\n+            test8(9, 10, 1, true);\n+            test8(9, 10, 1, false);\n+            test9(9, 10, 1, true);\n+            test9(9, 10, 1, false);\n+            test10(9, 10, 1, true);\n+            test10(9, 10, 1, false);\n+            test11(9, 10, 1, true);\n+            test11(9, 10, 1, false);\n+            test12(9, 10, 1, true);\n+            test12(9, 10, 1, false);\n+            test13(9, 10, 1, true);\n+            test13(9, 10, 1, false);\n+        }\n+        try {\n+            test1(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test2(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test3(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test4(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test5(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test6(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test7(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test8(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test9(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test10(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test11(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test12(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test13(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+    }\n+\n+    private static void test1(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test2(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test3(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test4(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test5(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test6(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1) + 1 \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1) + 1 \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test7(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1) + 1L \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1) + 1L \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+    private static void test8(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test9(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.divideUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.divideUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test10(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test11(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test12(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1)) +\n+                    Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1)) +\n+                    Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test13(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1)) +\n+                    Long.divideUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1)) +\n+                    Long.divideUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void notInlined(int[] array) {\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterRCCastIIEliminated.java","additions":474,"deletions":0,"binary":false,"changes":474,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8332827\n+ * @summary [REDO] C2: crash in compiled code because of dependency on removed range check CastIIs\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation TestRangeCheckCastIISplitThruPhi\n+ * @run main TestRangeCheckCastIISplitThruPhi\n+ *\n+ *\/\n+\n+import java.util.Arrays;\n+\n+public class TestRangeCheckCastIISplitThruPhi {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[100];\n+        int[] baseline = null;\n+        for (int i = 0; i < 20_000; i++) {\n+            Arrays.fill(array, 0);\n+            test1(array);\n+            if (baseline == null) {\n+                baseline = array.clone();\n+            } else {\n+                boolean failures = false;\n+                for (int j = 0; j < array.length; j++) {\n+                    if (array[j] != baseline[j]) {\n+                        System.out.println(\"XXX @\" + j + \" \" + array[j] + \" != \" + baseline[j]);\n+                       failures = true;\n+                    }\n+                }\n+                if (failures) {\n+                    throw new RuntimeException();\n+                }\n+            }\n+            test2(array, true);\n+            test2(array, false);\n+        }\n+    }\n+\n+    private static void test1(int[] array) {\n+        int[] array2 = new int[100];\n+        int j = 4;\n+        int i = 3;\n+        int k;\n+        for (k = 1; k < 2; k *= 2) {\n+\n+        }\n+        int stride = k \/ 2;\n+        do {\n+            synchronized (new Object()) {\n+            }\n+            array2[j-1] = 42;\n+            array[j+1] = 42;\n+            j = i;\n+            i -= stride;\n+        } while (i >= 0);\n+    }\n+\n+    private static void test2(int[] array, boolean flag) {\n+        int[] array2 = new int[100];\n+        int j = 4;\n+        int i = 3;\n+        int k;\n+        for (k = 1; k < 2; k *= 2) {\n+\n+        }\n+        int stride = k \/ 2;\n+        if (flag) {\n+            volatileField = 42;\n+            array[0] = 42;\n+        } else {\n+            do {\n+                synchronized (new Object()) {\n+                }\n+                array2[j - 1] = 42;\n+                array[j + 1] = 42;\n+                j = i;\n+                i -= stride;\n+            } while (i >= 0);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckCastIISplitThruPhi.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8332827\n+ * @summary [REDO] C2: crash in compiled code because of dependency on removed range check CastIIs\n+ *\n+ * @library \/test\/lib \/\n+ * @run driver TestVectorizationNegativeScale\n+ *\n+ *\/\n+\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Arrays;\n+\n+public class TestVectorizationNegativeScale {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    static byte[] array = new byte[1000];\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR , \">= 1\"})\n+    private static void test1(byte[] array, int start) {\n+        for (int i = start; i < array.length; i++) {\n+            array[array.length - i - 1] = 0x42;\n+        }\n+    }\n+\n+    @Run(test = \"test1\")\n+    private static void test1Runner() {\n+        Arrays.fill(array, (byte)0);\n+        test1(array, 0);\n+        for (int j = 0; j < array.length; j++) {\n+            if (array[j] != 0x42) {\n+                throw new RuntimeException(\"For index \" + j + \": \" + array[j]);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestVectorizationNegativeScale.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -30,0 +30,3 @@\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LambdaWithUseImplMethodHandle.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n@@ -42,0 +44,2 @@\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BulkLoaderTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchiveHeapTestClass.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary When dumping the CDS archive, try to load VM anonymous classes to make sure they\n- *          are handled properly. Note: these are not \"anonymous inner classes\" in the Java source code,\n- *          but rather classes that are not recorded in any ClassLoaderData::dictionary(),\n- *          such as classes that are generated for Lambda expressions.\n- *          See https:\/\/blogs.oracle.com\/jrose\/anonymous-classes-in-the-vm.\n- * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n- * @requires vm.cds\n- * @requires vm.jvmti\n- * @run driver AnonVmClassesDuringDump\n- *\/\n-\n-import jdk.test.lib.helpers.ClassFileInstaller;\n-\n-public class AnonVmClassesDuringDump {\n-    public static String appClasses[] = {\n-        Hello.class.getName(),\n-    };\n-    public static String agentClasses[] = {\n-        AnonVmClassesDuringDumpTransformer.class.getName(),\n-    };\n-\n-    public static String cdsDiagnosticOption = \"-XX:+AllowArchivingWithJavaAgent\";\n-\n-    public static final boolean dynamicMode =\n-        Boolean.getBoolean(System.getProperty(\"test.dynamic.cds.archive\", \"false\"));\n-\n-    public static void main(String[] args) throws Throwable {\n-        String agentJar =\n-            ClassFileInstaller.writeJar(\"AnonVmClassesDuringDumpTransformer.jar\",\n-                                        ClassFileInstaller.Manifest.fromSourceFile(\"AnonVmClassesDuringDumpTransformer.mf\"),\n-                                        agentClasses);\n-\n-        String appJar =\n-            ClassFileInstaller.writeJar(\"AnonVmClassesDuringDumpApp.jar\", appClasses);\n-\n-        TestCommon.testDump(appJar, TestCommon.list(Hello.class.getName()),\n-                            \"-javaagent:\" + agentJar,\n-                            \"-XX:+UnlockDiagnosticVMOptions\", cdsDiagnosticOption,\n-                            \/\/ Set the following property to see logs for dynamically generated classes\n-                            \/\/ in STDOUT\n-                            \"-Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=true\");\n-\n-        String prefix = \".class.load. \";\n-        \/\/ class name pattern like the following:\n-        \/\/ jdk.internal.loader.BuiltinClassLoader$$Lambda\/1816757085\n-        \/\/ java.lang.invoke.LambdaForm$MH\/1585787493\n-        String class_pattern = \".*Lambda\/([0-9]+).*\";\n-        String suffix = \".*source: shared objects file.*\";\n-        String pattern = prefix + class_pattern + suffix;\n-        \/\/ during run time, anonymous classes shouldn't be loaded from the archive\n-        TestCommon.run(\"-cp\", appJar,\n-            \"-XX:+UnlockDiagnosticVMOptions\", cdsDiagnosticOption, Hello.class.getName())\n-            .assertNormalExit(dynamicMode ?\n-                output -> output.shouldMatch(pattern) :\n-                output -> output.shouldNotMatch(pattern));\n-\n-        \/\/ inspect the archive and make sure no anonymous class is in there\n-        TestCommon.run(\"-cp\", appJar,\n-            \"-XX:+UnlockDiagnosticVMOptions\", cdsDiagnosticOption,\n-            \"-XX:+PrintSharedArchiveAndExit\", Hello.class.getName())\n-            .assertNormalExit(dynamicMode ?\n-                output -> output.shouldMatch(pattern) :\n-                output -> output.shouldNotMatch(pattern));\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/AnonVmClassesDuringDump.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-import java.lang.instrument.ClassFileTransformer;\n-import java.lang.instrument.Instrumentation;\n-import java.lang.instrument.IllegalClassFormatException;\n-import java.security.ProtectionDomain;\n-\n-public class AnonVmClassesDuringDumpTransformer implements ClassFileTransformer {\n-    public byte[] transform(ClassLoader loader, String name, Class<?> classBeingRedefined,\n-                            ProtectionDomain pd, byte[] buffer) throws IllegalClassFormatException {\n-        return null;\n-    }\n-\n-    private static Instrumentation savedInstrumentation;\n-\n-    public static void premain(String agentArguments, Instrumentation instrumentation) {\n-        System.out.println(\"ClassFileTransformer.premain() is called\");\n-        instrumentation.addTransformer(new AnonVmClassesDuringDumpTransformer(), \/*canRetransform=*\/true);\n-        savedInstrumentation = instrumentation;\n-\n-        \/\/ This will create a Lambda, which will result in some Anonymous VM Classes\n-        \/\/ being generated.\n-        \/\/\n-        \/\/ Look for something like these in the STDOUT:\n-        \/\/ ----------------\n-        \/\/ ClassFileTransformer.premain() is called\n-        \/\/ Dumping class files to DUMP_CLASS_FILES\/...\n-        \/\/ dump: DUMP_CLASS_FILES\/java\/lang\/invoke\/LambdaForm$MH000.class\n-        \/\/ dump: DUMP_CLASS_FILES\/java\/lang\/invoke\/LambdaForm$MH001.class\n-        \/\/ Invoked inside a Lambda\n-        \/\/ ----------------\n-        Runnable r = () -> {\n-            System.out.println(\"Invoked inside a Lambda\");\n-        };\n-        r.run();\n-    }\n-\n-    public static Instrumentation getInstrumentation() {\n-        return savedInstrumentation;\n-    }\n-\n-    public static void agentmain(String args, Instrumentation inst) throws Exception {\n-        premain(args, inst);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/AnonVmClassesDuringDumpTransformer.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-Manifest-Version: 1.0\n-Premain-Class: AnonVmClassesDuringDumpTransformer\n-Agent-Class: AnonVmClassesDuringDumpTransformer\n-Can-Retransform-Classes: true\n-Can-Redefine-Classes: true\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/AnonVmClassesDuringDumpTransformer.mf","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -31,0 +31,2 @@\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/AOTLinkedLambdas.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/AOTLinkedVarHandles.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,3 @@\n-            if (!e.getMessage().contains(\"cannot implement sealed interface\")) {\n+            if (!e.getMessage().equals(\"Failed same package check: non-public subclass sealedP2.C2 \" +\n+                                       \"is in package 'sealedP2' with classloader 'app', and sealed class \" +\n+                                       \"sealedP1.SuperInterface is in package 'sealedP1' with classloader 'app'\")) {\n@@ -89,1 +91,3 @@\n-            if (!e.getMessage().contains(\"cannot implement sealed interface\")) {\n+            if (!e.getMessage().equals(\"Failed same module check: subclass sealedP3.C3 is in module 'module_two' \" +\n+                                       \"with loader 'app', and sealed class sealedP1.SuperInterface is in module \" +\n+                                       \"'module_one' with loader 'app'\")) {\n","filename":"test\/hotspot\/jtreg\/runtime\/modules\/SealedInterfaceModuleTest.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,3 @@\n-            if (!e.getMessage().contains(\"cannot inherit from sealed class\")) {\n+            if (!e.getMessage().equals(\"Failed same package check: non-public subclass sealedP2.C2 \" +\n+                                       \"is in package 'sealedP2' with classloader 'app', and sealed class \" +\n+                                       \"sealedP1.SuperClass is in package 'sealedP1' with classloader 'app'\")) {\n@@ -89,1 +91,3 @@\n-            if (!e.getMessage().contains(\"cannot inherit from sealed class\")) {\n+            if (!e.getMessage().equals(\"Failed same module check: subclass sealedP3.C3 is in module 'module_two' \" +\n+                                       \"with loader 'app', and sealed class sealedP1.SuperClass is in module \" +\n+                                       \"'module_one' with loader 'app'\")) {\n","filename":"test\/hotspot\/jtreg\/runtime\/modules\/SealedModuleTest.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,1 @@\n+    \/\/ Check if the given class has the expected permitted subclasses\n@@ -95,1 +96,1 @@\n-                                          String expectedCFEMessage) throws Throwable {\n+                                          String expectedMessage) throws Throwable {\n@@ -98,1 +99,1 @@\n-            throw new RuntimeException(\"Expected ClassFormatError exception not thrown for \" + className);\n+            throw new RuntimeException(\"Expected exception \" + expectedException.getName() + \" not thrown for \" + className);\n@@ -104,1 +105,1 @@\n-            if (!cfe.getMessage().contains(expectedCFEMessage)) {\n+            if (!cfe.getMessage().contains(expectedMessage)) {\n@@ -113,1 +114,1 @@\n-            if (!icce.getMessage().contains(expectedCFEMessage)) {\n+            if (!icce.getMessage().contains(expectedMessage)) {\n@@ -138,1 +139,1 @@\n-                           \"SubClass cannot inherit from sealed class NoSubclasses\");\n+                           \"Failed listed permitted subclass check: class SubClass is not a permitted subclass of NoSubclasses\");\n","filename":"test\/hotspot\/jtreg\/runtime\/sealedClasses\/GetPermittedSubclassesTest.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8345911\n+ * @library \/test\/lib\n+ * @compile SealedSuper.java SealedSub.java\n+ * @comment Copy SealedSuper.class to the currnet directory so it will be on the bootclasspath\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller SealedSuper\n+ * @run main\/othervm -Xbootclasspath\/a:. -Xlog:class+sealed=trace SealedDifferentUnnamedModuleTest\n+ *\/\n+\n+public class SealedDifferentUnnamedModuleTest {\n+\n+    public static void main(String args[]) throws Throwable {\n+\n+        \/\/ Load the sealed superclass. It will be loaded by the boot loader and\n+        \/\/ so reside in the boot loaders un-named module.\n+        Class<?> c1 = Class.forName(\"SealedSuper\");\n+\n+        \/\/ Test loading a \"permitted\" subclass in the app classloader, which then resides\n+        \/\/ in the app loader's un-named module.\n+        \/\/ This should fail.\n+        try {\n+            Class<?> c2 = Class.forName(\"SealedSub\");\n+            throw new RuntimeException(\"Expected IncompatibleClassChangeError exception not thrown\");\n+        } catch (IncompatibleClassChangeError e) {\n+            if (!e.getMessage().equals(\"Failed same module check: subclass SealedSub is in module 'unnamed module' \" +\n+                                       \"with loader 'app', and sealed class SealedSuper is in module 'unnamed module' \" +\n+                                       \"with loader 'bootstrap'\")) {\n+                throw new RuntimeException(\"Wrong IncompatibleClassChangeError exception thrown: \" + e.getMessage());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/sealedClasses\/SealedDifferentUnnamedModuleTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+public final class SealedSub extends SealedSuper {\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/sealedClasses\/SealedSub.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public sealed class SealedSuper permits SealedSub {\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/sealedClasses\/SealedSuper.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main SealedUnnamedModuleIntfTest\n+ * @run main\/othervm SealedUnnamedModuleIntfTest\n@@ -54,1 +54,2 @@\n-            if (!e.getMessage().contains(\"cannot implement sealed interface\")) {\n+            if (!e.getMessage().equals(\"Failed listed permitted subclass check: class Pkg.NotPermitted \" +\n+                                       \"is not a permitted subclass of Pkg.SealedInterface\")) {\n@@ -65,1 +66,3 @@\n-            if (!e.getMessage().contains(\"cannot implement sealed interface\")) {\n+            if (!e.getMessage().equals(\"Failed same package check: non-public subclass otherPkg.WrongPackageNotPublic \" +\n+                                       \"is in package 'otherPkg' with classloader 'app', and sealed class Pkg.SealedInterface \" +\n+                                       \"is in package 'Pkg' with classloader 'app'\")) {\n","filename":"test\/hotspot\/jtreg\/runtime\/sealedClasses\/SealedUnnamedModuleIntfTest.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main SealedUnnamedModuleTest\n+ * @run main\/othervm SealedUnnamedModuleTest\n@@ -49,1 +49,2 @@\n-            if (!e.getMessage().contains(\"cannot inherit from sealed class\")) {\n+            if (!e.getMessage().equals(\"Failed listed permitted subclass check: class planets.Mars is \" +\n+                                       \"not a permitted subclass of planets.OuterPlanets\")) {\n@@ -60,1 +61,3 @@\n-            if (!e.getMessage().contains(\"cannot inherit from sealed class\")) {\n+            if (!e.getMessage().equals(\"Failed same package check: non-public subclass asteroids.Pluto is \" +\n+                                       \"in package 'asteroids' with classloader 'app', and sealed class \" +\n+                                       \"planets.OuterPlanets is in package 'planets' with classloader 'app'\")) {\n","filename":"test\/hotspot\/jtreg\/runtime\/sealedClasses\/SealedUnnamedModuleTest.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires (os.family == \"linux\" | os.family == \"windows\")\n+ * @requires (os.family == \"linux\" | os.family == \"windows\" | os.family == \"mac\")\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemDumpMapTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @requires (os.family == \"linux\" | os.family == \"windows\")\n+ * @requires (os.family == \"linux\" | os.family == \"windows\" | os.family == \"mac\")\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,25 +36,0 @@\n-    private static final String prot = \"[rwsxp-]+\";\n-\n-    private static final String regexBase = range + space +\n-            someSize + space +\n-            prot + space +\n-            someSize + space +\n-            someSize + space +\n-            pagesize + space;\n-\n-    private static final String regexBase_committed = regexBase + \"com.*\";\n-    private static final String regexBase_shared_and_committed = regexBase + \"shrd,com.*\";\n-\n-    \/\/ java heap is either committed, non-shared, or - in case of ZGC - committed and shared.\n-    private static final String regexBase_java_heap = regexBase + \"(shrd,)?com.*\";\n-\n-    private static final String shouldMatchUnconditionally_linux[] = {\n-        \/\/ java launcher\n-        regexBase_committed + \"\/bin\/java\",\n-        \/\/ libjvm\n-        regexBase_committed + \"\/lib\/.*\/libjvm.so\",\n-        \/\/ heap segment, should be part of all user space apps on all architectures OpenJDK supports.\n-        regexBase_committed + \"\\\\[heap\\\\]\",\n-        \/\/ we should see the hs-perf data file, and it should appear as shared as well as committed\n-        regexBase_shared_and_committed + \"hsperfdata_.*\"\n-    };\n@@ -62,10 +37,3 @@\n-    private static final String shouldMatchIfNMTIsEnabled_linux[] = {\n-        regexBase_java_heap + \"JAVAHEAP.*\",\n-        \/\/ metaspace\n-        regexBase_committed + \"META.*\",\n-        \/\/ parts of metaspace should be uncommitted\n-        regexBase + \"-\" + space + \"META.*\",\n-        \/\/ code cache\n-        regexBase_committed + \"CODE.*\",\n-        \/\/ Main thread stack\n-        regexBase_committed + \"STACK.*main.*\"\n+    interface MapPatterns {\n+        String[] shouldMatchUnconditionally();\n+        String[] shouldMatchIfNMTIsEnabled();\n@@ -74,3 +42,1 @@\n-    \/\/ windows:\n-    private static final String winprot = \"[\\\\-rwxcin]*\";\n-    private static final String wintype = \"[rc]-(img|map|pvt)\";\n+    private final MapPatterns patternProvider;\n@@ -78,1 +44,2 @@\n-    private static final String winbase = range + space + someSize + space + winprot + space;\n+    private static final boolean isWindows = Platform.isWindows();\n+    private static final boolean isMacOS = Platform.isOSX();\n@@ -80,3 +47,3 @@\n-    private static final String winimage     = winbase + \"c-img\" + space + someNumber + space;\n-    private static final String wincommitted = winbase + \"(c-pvt|c-map)\" + space + someNumber + space;\n-    private static final String winreserved  = winbase + \"r-pvt\" + space + someNumber + space;\n+    protected String[] shouldMatchUnconditionally() {\n+        return patternProvider.shouldMatchUnconditionally();\n+    }\n@@ -84,6 +51,3 @@\n-    private static final String shouldMatchUnconditionally_windows[] = {\n-        \/\/ java launcher\n-        winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\]java[.]exe\",\n-        \/\/ libjvm\n-        winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\].*[\\\\\/\\\\\\\\]jvm.dll\"\n-    };\n+    protected String[] shouldMatchIfNMTIsEnabled() {\n+        return patternProvider.shouldMatchIfNMTIsEnabled();\n+    }\n@@ -91,11 +55,9 @@\n-    private static final String shouldMatchIfNMTIsEnabled_windows[] = {\n-        wincommitted + \"JAVAHEAP.*\",\n-        \/\/ metaspace\n-        wincommitted + \"META.*\",\n-        \/\/ parts of metaspace should be uncommitted\n-        winreserved + \"META.*\",\n-        \/\/ code cache\n-        wincommitted + \"CODE.*\",\n-        \/\/ Main thread stack\n-        wincommitted + \"STACK-\\\\d+-main.*\"\n-    };\n+    protected SystemMapTestBase() {\n+        if (Platform.isWindows()) {\n+            patternProvider = new WindowsPatterns();\n+        } else if (Platform.isOSX()) {\n+            patternProvider = new MacOSPatterns();\n+        } else {\n+            patternProvider = new LinuxPatterns();\n+        }\n+    }\n@@ -103,1 +65,48 @@\n-    private static final boolean isWindows = Platform.isWindows();\n+    private static class LinuxPatterns implements MapPatterns {\n+\n+        private static final String prot = \"[rwsxp-]+\";\n+\n+        static final String regexBase = range + space +\n+                                        someSize + space +\n+                                        prot + space +\n+                                        someSize + space +\n+                                        someSize + space +\n+                                        pagesize + space;\n+\n+        static final String regexBase_committed = regexBase + \"com.*\";\n+        static final String regexBase_shared_and_committed = regexBase + \"shrd,com.*\";\n+\n+        \/\/ java heap is either committed, non-shared, or - in case of ZGC - committed and shared.\n+        static final String regexBase_java_heap = regexBase + \"(shrd,)?com.*\";\n+\n+        static final String shouldMatchUnconditionally_linux[] = {\n+            \/\/ java launcher\n+            regexBase_committed + \"\/bin\/java\",\n+            \/\/ libjvm\n+            regexBase_committed + \"\/lib\/.*\/libjvm.so\",\n+            \/\/ heap segment, should be part of all user space apps on all architectures OpenJDK supports.\n+            regexBase_committed + \"\\\\[heap\\\\]\",\n+            \/\/ we should see the hs-perf data file, and it should appear as shared as well as committed\n+            regexBase_shared_and_committed + \"hsperfdata_.*\"\n+        };\n+\n+        static final String shouldMatchIfNMTIsEnabled_linux[] = {\n+            regexBase_java_heap + \"JAVAHEAP.*\",\n+            \/\/ metaspace\n+            regexBase_committed + \"META.*\",\n+            \/\/ parts of metaspace should be uncommitted\n+            regexBase + \"-\" + space + \"META.*\",\n+            \/\/ code cache\n+            regexBase_committed + \"CODE.*\",\n+            \/\/ Main thread stack\n+            regexBase_committed + \"STACK.*main.*\"\n+        };\n+\n+        public String[] shouldMatchUnconditionally() {\n+            return shouldMatchUnconditionally_linux;\n+        }\n+\n+        public String[] shouldMatchIfNMTIsEnabled() {\n+            return shouldMatchIfNMTIsEnabled_linux;\n+        }\n+    };\n@@ -105,6 +114,38 @@\n-    protected static String[] shouldMatchUnconditionally() {\n-        return isWindows ? shouldMatchUnconditionally_windows : shouldMatchUnconditionally_linux;\n-    }\n-    protected static String[] shouldMatchIfNMTIsEnabled() {\n-        return isWindows ? shouldMatchIfNMTIsEnabled_windows : shouldMatchIfNMTIsEnabled_linux;\n-    }\n+    private static class WindowsPatterns implements MapPatterns {\n+\n+        static final String winprot = \"[\\\\-rwxcin]*\";\n+        static final String wintype = \"[rc]-(img|map|pvt)\";\n+\n+        static final String winbase = range + space + someSize + space + winprot + space;\n+\n+        static final String winimage     = winbase + \"c-img\" + space + someNumber + space;\n+        static final String wincommitted = winbase + \"(c-pvt|c-map)\" + space + someNumber + space;\n+        static final String winreserved  = winbase + \"r-pvt\" + space + someNumber + space;\n+\n+        static final String shouldMatchUnconditionally_windows[] = {\n+            \/\/ java launcher\n+            winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\]java[.]exe\",\n+            \/\/ libjvm\n+            winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\].*[\\\\\/\\\\\\\\]jvm.dll\"\n+        };\n+\n+        static final String shouldMatchIfNMTIsEnabled_windows[] = {\n+            wincommitted + \"JAVAHEAP.*\",\n+            \/\/ metaspace\n+            wincommitted + \"META.*\",\n+            \/\/ parts of metaspace should be uncommitted\n+            winreserved + \"META.*\",\n+            \/\/ code cache\n+            wincommitted + \"CODE.*\",\n+            \/\/ Main thread stack\n+            wincommitted + \"STACK-\\\\d+-main.*\"\n+        };\n+\n+        public String[] shouldMatchUnconditionally() {\n+            return shouldMatchUnconditionally_windows;\n+        }\n+\n+        public String[] shouldMatchIfNMTIsEnabled() {\n+            return shouldMatchIfNMTIsEnabled_windows;\n+        }\n+    };\n@@ -112,0 +153,40 @@\n+    private static class MacOSPatterns implements MapPatterns {\n+\n+        \/\/ macOS:\n+        static final String macprot =  \"[\\\\-rwx]*\/[\\\\-rwx]*\";\n+\n+        static final String macow = \"cow\";\n+        static final String macprivate = \"pvt\";\n+        static final String macprivate_or_shared = \"(pvt|tsh)\";\n+        static final String macprivatealiased = \"p\/a\";\n+\n+        static final String macOSbase = range + space + someSize + space + macprot + space;\n+\n+        static final String shouldMatchUnconditionally_macOS[] = {\n+            \/\/ java launcher\n+            macOSbase + macow + space + someNumber + space + \"\/.*\/bin\/java\",\n+            \/\/ libjvm\n+            macOSbase + macow + space + someNumber + space + \"\/.*\/lib\/server\/libjvm.dylib\",\n+            \/\/ we should see the hs-perf data file, and it should appear as shared as well as committed\n+            macOSbase + macprivate + space + someNumber + space + \".*\/.*\/hsperfdata_.*\"\n+        };\n+\n+        static final String shouldMatchIfNMTIsEnabled_macOS[] = {\n+            \/\/ heap is private with G1GC, shared with ZGC\n+            macOSbase + macprivate_or_shared + space + someNumber + space + \"JAVAHEAP.*\",\n+            \/\/ metaspace\n+            macOSbase + macprivate + space + someNumber + space + \"META.*\",\n+            \/\/ code cache\n+            macOSbase + macprivate + space + someNumber + space + \"CODE.*\",\n+            \/\/ Main thread stack\n+            macOSbase + macprivatealiased + space + someNumber + space + \"STACK-.*-main.*\"\n+        };\n+\n+        public String[] shouldMatchUnconditionally() {\n+            return shouldMatchUnconditionally_macOS;\n+        }\n+\n+        public String[] shouldMatchIfNMTIsEnabled() {\n+            return shouldMatchIfNMTIsEnabled_macOS;\n+        }\n+    };\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTestBase.java","additions":147,"deletions":66,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @requires os.family == \"aix\"\n@@ -39,15 +38,1 @@\n-\/*\n- * @test\n- * @bug 8308762\n- * @library \/test\/lib\n- * @summary Test that redefinition of class containing Throwable refs does not leak constant pool\n- * @requires os.family != \"aix\"\n- * @requires vm.jvmti\n- * @requires vm.flagless\n- * @modules java.base\/jdk.internal.misc\n- * @modules java.instrument\n- *          java.compiler\n- * @run main RedefineClassHelper\n- * @run main\/othervm\/timeout=6000 -javaagent:redefineagent.jar -XX:MetaspaceSize=17m -XX:MaxMetaspaceSize=17m RedefineLeakThrowable\n- *\/\n-\n+\/\/ MaxMetaspaceSize=25m allows InMemoryJavaCompiler to load even if CDS is off.\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineLeakThrowable.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Example test to show Verify.checkEQ with IR framework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver verify.examples.TestVerifyInCheckMethod\n+ *\/\n+\n+package verify.examples;\n+\n+import compiler.lib.verify.*;\n+import compiler.lib.ir_framework.*;\n+\n+\/**\n+ * Example to show the use of Verify.checkEQ in @Check method.\n+ *\/\n+public class TestVerifyInCheckMethod {\n+    public static int[] INPUT_A = new int[100];\n+    static {\n+        for (int i = 0; i < INPUT_A.length; i++) {\n+            INPUT_A[i] = i;\n+        }\n+    }\n+    public static float INPUT_B = 42;\n+\n+    \/\/ Must make sure to clone input arrays, if it is mutated in the test.\n+    public static Object GOLD = test(INPUT_A.clone(), INPUT_B);;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Setup\n+    public static Object[] setup() {\n+        \/\/ Must make sure to clone input arrays, if it is mutated in the test.\n+        return new Object[] {INPUT_A.clone(), INPUT_B};\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    public static Object test(int[] a, float b) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (int)(a[i] * b);\n+        }\n+        \/\/ Since we have more than one value, we wrap them in an Object[].\n+        return new Object[] {a, b};\n+    }\n+\n+    @Check(test = \"test\")\n+    public static void check(Object result) {\n+        Verify.checkEQ(result, GOLD);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/verify\/examples\/TestVerifyInCheckMethod.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,419 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test functionality of IntGenerator implementations.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver verify.tests.TestVerify\n+ *\/\n+\n+package verify.tests;\n+\n+import java.lang.foreign.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.verify.*;\n+\n+public class TestVerify {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        \/\/ Test consecutive memory: array, MemorySegment, etc.\n+        testArrayByte();\n+        testArrayChar();\n+        testArrayShort();\n+        testArrayInt();\n+        testArrayLong();\n+        testArrayFloat();\n+        testArrayDouble();\n+        testNativeMemorySegment();\n+\n+        \/\/ Test recursive data: Object array of values, etc.\n+        testRecursive();\n+    }\n+\n+    public static void testArrayByte() {\n+        byte[] a = new byte[1000];\n+        byte[] b = new byte[1001];\n+        byte[] c = new byte[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayShort() {\n+        short[] a = new short[1000];\n+        short[] b = new short[1001];\n+        short[] c = new short[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayChar() {\n+        char[] a = new char[1000];\n+        char[] b = new char[1001];\n+        char[] c = new char[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayInt() {\n+        int[] a = new int[1000];\n+        int[] b = new int[1001];\n+        int[] c = new int[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayLong() {\n+        long[] a = new long[1000];\n+        long[] b = new long[1001];\n+        long[] c = new long[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayFloat() {\n+        float[] a = new float[1000];\n+        float[] b = new float[1001];\n+        float[] c = new float[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayDouble() {\n+        double[] a = new double[1000];\n+        double[] b = new double[1001];\n+        double[] c = new double[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+    public static void testNativeMemorySegment() {\n+        MemorySegment a = Arena.ofAuto().allocate(1000, 1);\n+        MemorySegment b = Arena.ofAuto().allocate(1001, 1);\n+        MemorySegment c = Arena.ofAuto().allocate(1000, 1);\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        c.set(ValueLayout.JAVA_BYTE, RANDOM.nextLong(c.byteSize()), (byte)1);\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+    }\n+\n+    public static void testRecursive() {\n+        Verify.checkEQ(null, null);\n+\n+        \/\/ Null mismatch\n+        checkNE(42, null);\n+\n+        byte[] a = new byte[1000];\n+        int[]  b = new int[1000];\n+        int[]  c = new int[1001];\n+        int[]  d = new int[1000];\n+\n+        Object[] o1 = new Object[]{a, a};\n+        Object[] o2 = new Object[]{a, a, a};\n+        Object[] o3 = new Object[]{a, a, null};\n+        Object[] o4 = new Object[]{a, a, b};\n+        Object[] o5 = new Object[]{a, a, c};\n+        Object[] o6 = new Object[]{a, a, d};\n+\n+        Verify.checkEQ(o1, o1);\n+        Verify.checkEQ(o2, o2);\n+        Verify.checkEQ(o3, o3);\n+        Verify.checkEQ(o4, o6);\n+\n+        \/\/ Size mismatch\n+        checkNE(o1, o2);\n+\n+        \/\/ First level value mismatch: a vs null on position 2\n+        checkNE(o2, o3);\n+\n+        \/\/ First level class mismatch: byte[] vs int[]\n+        checkNE(o2, o4);\n+\n+        \/\/ Second level length mismatch on arrays b and c.\n+        checkNE(o4, o5);\n+\n+        d[RANDOM.nextInt(d.length)] = 1;\n+\n+        \/\/ Second level value mismatch between b and d.\n+        checkNE(o4, o6);\n+\n+        \/\/ Now test all primitive array types.\n+        byte[]   aB = new byte[100];\n+        char[]   aC = new char[100];\n+        short[]  aS = new short[100];\n+        int[]    aI = new int[100];\n+        long[]   aL = new long[100];\n+        float[]  aF = new float[100];\n+        double[] aD = new double[100];\n+\n+        Verify.checkEQ(new Object[] {aB, aC, aS, aI, aL, aF, aD}, new Object[] {aB, aC, aS, aI, aL, aF, aD});\n+\n+        \/\/ First level class mismatch: char[] vs short[]\n+        checkNE(new Object[] {aC}, new Object[] {aS});\n+\n+        \/\/ Verify MemorySegment\n+        MemorySegment mC = MemorySegment.ofArray(aC);\n+        MemorySegment mS = MemorySegment.ofArray(aS);\n+        Verify.checkEQ(new Object[] {mC}, new Object[] {mC});\n+        Verify.checkEQ(new Object[] {mS}, new Object[] {mS});\n+\n+        \/\/ Second level type mismatch: backing type short[] vs char[]\n+        checkNE(new Object[] {mC}, new Object[] {mS});\n+\n+        \/\/ Second level type mismatch: backing type int[] vs char[]\n+        MemorySegment mI = MemorySegment.ofArray(aI);\n+        checkNE(new Object[] {mI}, new Object[] {mC});\n+\n+        \/\/ Verify boxed primitives:\n+        Byte bb1 = 42;\n+        Byte bb2 = 42;\n+        Byte bb3 = 11;\n+\n+        Verify.checkEQ(new Object[] {(byte)42}, new Object[] {(byte)42});\n+        Verify.checkEQ(new Object[] {(byte)42}, new Object[] {bb1});\n+        Verify.checkEQ(new Object[] {bb1},      new Object[] {bb2});\n+\n+        \/\/ Second level value mismatch: 42 vs 11\n+        checkNE(new Object[] {bb1},      new Object[] {bb3});\n+\n+        Verify.checkEQ((byte)42,   (byte)42);\n+        Verify.checkEQ((short)42,  (short)42);\n+        Verify.checkEQ((char)42,   (char)42);\n+        Verify.checkEQ((int)42,    (int)42);\n+        Verify.checkEQ((long)42,   (long)42);\n+        Verify.checkEQ((float)42,  (float)42);\n+        Verify.checkEQ((double)42, (double)42);\n+\n+        \/\/ Boxed type mismatch: float vs int\n+        checkNE((int)42, (float)42);\n+\n+        \/\/ Boxed value mismatch.\n+        for (int i = 0; i < 10; i++) {\n+            byte v1 = (byte)RANDOM.nextInt();\n+            byte v2 = (byte)(v1 ^ (1 << RANDOM.nextInt(8)));\n+            checkNE(v1, v2);\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            char v1 = (char)RANDOM.nextInt();\n+            char v2 = (char)(v1 ^ (1 << RANDOM.nextInt(16)));\n+            checkNE(v1, v2);\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            char v1 = (char)RANDOM.nextInt();\n+            char v2 = (char)(v1 ^ (1 << RANDOM.nextInt(16)));\n+            checkNE(v1, v2);\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            int v1 = (int)RANDOM.nextInt();\n+            int v2 = (int)(v1 ^ (1 << RANDOM.nextInt(32)));\n+            checkNE(v1, v2);\n+            checkNE(Float.intBitsToFloat(v1), Float.intBitsToFloat(v2));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            long v1 = (long)RANDOM.nextLong();\n+            long v2 = (long)(v1 ^ (1L << RANDOM.nextInt(64)));\n+            checkNE(v1, v2);\n+            checkNE(Double.longBitsToDouble(v1), Double.longBitsToDouble(v2));\n+        }\n+    }\n+\n+    public static void checkNE(Object a, Object b) {\n+         try {\n+            Verify.checkEQ(a, b);\n+            throw new RuntimeException(\"Should have thrown\");\n+        } catch (VerifyException e) {}\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/verify\/tests\/TestVerify.java","additions":419,"deletions":0,"binary":false,"changes":419,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.test.lib.thread.VThreadPinner;\n@@ -155,0 +156,11 @@\n+        boolean vthreadMode = \"Virtual\".equals(System.getProperty(\"test.thread.factory\"));\n+        if (vthreadMode) {\n+            \/\/ JVMTI StopThread is only supported for mounted virtual threads. We need to\n+            \/\/ pin the virtual threads so they remain mounted.\n+            VThreadPinner.runPinned(() -> test());\n+        } else {\n+            test();\n+        }\n+    }\n+\n+    public void test() {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/kill\/kill001\/kill001a.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -140,0 +140,3 @@\n+            \/* Some jdb tests need java.library.path setup for native libraries. *\/\n+            String libpath = System.getProperty(\"java.library.path\");\n+            args.add(\"-R-Djava.library.path=\" + libpath);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Launcher.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,0 +128,5 @@\n+            if (all == null) {\n+                complain(\"No stacktrace for thread \" + threads[i].getName() +\n+                         \" was found in the set of all traces\");\n+                return false;\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace007.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,0 +132,5 @@\n+            if (all == null) {\n+                complain(\"No stacktrace for thread \" + threads[i].getName() +\n+                         \" was found in the set of all traces\");\n+                return false;\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace008.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,0 +132,5 @@\n+            if (all == null) {\n+                complain(\"No stacktrace for thread \" + threads[i].getName() +\n+                         \" was found in the set of all traces\");\n+                return false;\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace009.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,0 +148,5 @@\n+            if (all == null) {\n+                complain(\"No stacktrace for thread \" + threads[i].getName() +\n+                         \" was found in the set of all traces\");\n+                return false;\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace010.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,0 +152,5 @@\n+            if (all == null) {\n+                complain(\"No stacktrace for thread \" + threads[i].getName() +\n+                         \" was found in the set of all traces\");\n+                return false;\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace011.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,0 +154,5 @@\n+            if (all == null) {\n+                complain(\"No stacktrace for thread \" + threads[i].getName() +\n+                         \" was found in the set of all traces\");\n+                return false;\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace012.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,0 +133,5 @@\n+            if (all == null) {\n+                complain(\"No stacktrace for thread \" + threads[i].getName() +\n+                         \" was found in the set of all traces\");\n+                return false;\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace013.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -143,0 +143,5 @@\n+            if (all == null) {\n+                complain(\"No stacktrace for thread \" + threads[i].getName() +\n+                         \" was found in the set of all traces\");\n+                return false;\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace014.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,0 +141,5 @@\n+            if (all == null) {\n+                complain(\"No stacktrace for thread \" + threads[i].getName() +\n+                         \" was found in the set of all traces\");\n+                return false;\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace015.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-java\/util\/concurrent\/locks\/StampedLock\/OOMEInStampedLock.java 8345266 generic-all\n-\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -543,2 +543,0 @@\n-com\/sun\/management\/DiagnosticCommandMBean\/DcmdMBeanPermissionsTest.java 8340401 windows-all\n-\n@@ -550,3 +548,3 @@\n-sun\/management\/jdp\/JdpDefaultsTest.java                         8308807 aix-ppc64\n-sun\/management\/jdp\/JdpJmxRemoteDynamicPortTest.java             8308807 aix-ppc64\n-sun\/management\/jdp\/JdpSpecificAddressTest.java                  8308807 aix-ppc64\n+sun\/management\/jdp\/JdpDefaultsTest.java                         8308807,8241865 aix-ppc64,macosx-aarch64\n+sun\/management\/jdp\/JdpJmxRemoteDynamicPortTest.java             8308807,8241865 aix-ppc64,macosx-aarch64\n+sun\/management\/jdp\/JdpSpecificAddressTest.java                  8308807,8241865 aix-ppc64,macosx-aarch64\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        Asserts.assertEqualsByteArray(prk.getEncoded(), expectedPrk,\n+        Asserts.assertEqualsByteArray(expectedPrk, prk.getEncoded(),\n@@ -58,1 +58,1 @@\n-        Asserts.assertEqualsByteArray(okm1.getEncoded(), expectedOkm,\n+        Asserts.assertEqualsByteArray(expectedOkm, okm1.getEncoded(),\n@@ -62,1 +62,1 @@\n-        Asserts.assertEqualsByteArray(okm2.getEncoded(), expectedOkm,\n+        Asserts.assertEqualsByteArray(expectedOkm, okm2.getEncoded(),\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/HKDFBasicFunctionsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.event.ActionListener;\n+import java.awt.event.ActionEvent;\n+import java.awt.AWTEventMulticaster;\n+\n+\/*\n+ * @test\n+ * @bug 8342782\n+ * @summary Tests large AWTEventMulticasters for StackOverflowErrors\n+ * @run main LargeAWTEventMulticasterTest\n+ *\/\n+public class LargeAWTEventMulticasterTest {\n+\n+    \/**\n+     * This is an empty ActionListener that also has a numeric index.\n+     *\/\n+    static class IndexedActionListener implements ActionListener {\n+        private final int index;\n+\n+        public IndexedActionListener(int index) {\n+            this.index = index;\n+        }\n+\n+        @Override\n+        public void actionPerformed(ActionEvent e) {\n+\n+        }\n+\n+        public int getIndex() {\n+            return index;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return Integer.toString(index);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int maxA = 0;\n+        try {\n+            for (int a = 1; a < 200_000; a *= 2) {\n+                maxA = a;\n+                testAddingActionListener(a);\n+            }\n+        } finally {\n+            System.out.println(\"maximum a = \" + maxA);\n+        }\n+    }\n+\n+    private static void testAddingActionListener(int numberOfListeners) {\n+        \/\/ step 1: create the large AWTEventMulticaster\n+        ActionListener l = null;\n+        for (int a = 0; a < numberOfListeners; a++) {\n+            l = AWTEventMulticaster.add(l, new IndexedActionListener(a));\n+        }\n+\n+        \/\/ Prior to 8342782 we could CREATE a large AWTEventMulticaster, but we couldn't\n+        \/\/ always interact with it.\n+\n+        \/\/ step 2: dispatch an event\n+        \/\/ Here we're making sure we don't get a StackOverflowError when we traverse the tree:\n+        l.actionPerformed(null);\n+\n+        \/\/ step 3: make sure getListeners() returns elements in the correct order\n+        \/\/ The resolution for 8342782 introduced a `rebalance` method; we want to\n+        \/\/ double-check that the rebalanced tree preserves the appropriate order.\n+        IndexedActionListener[] array = AWTEventMulticaster.getListeners(l, IndexedActionListener.class);\n+        for (int b = 0; b < array.length; b++) {\n+            if (b != array[b].getIndex())\n+                throw new Error(\"the listeners are in the wrong order. \" + b + \" != \" + array[b].getIndex());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/event\/StressTest\/LargeAWTEventMulticasterTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,1 @@\n-            catch( NoSuchMethodException | SecurityException e) {}\n+            catch( NoSuchMethodException e) {}\n","filename":"test\/jdk\/java\/beans\/Introspector\/8132566\/OverrideUserDefPropertyInfoTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,1 +120,1 @@\n-            for (Field field : getFields(type)) {\n+            for (Field field : type.getFields()) {\n@@ -242,3 +242,0 @@\n-        catch (SecurityException exception) {\n-            log(exception);\n-        }\n@@ -248,12 +245,0 @@\n-    private static final Field[] FIELDS = {};\n-\n-    private Field[] getFields(Class type) {\n-        try {\n-            return type.getFields();\n-        }\n-        catch (SecurityException exception) {\n-            log(exception);\n-        }\n-        return FIELDS;\n-    }\n-\n","filename":"test\/jdk\/java\/beans\/XMLEncoder\/BeanValidator.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,7 +29,0 @@\n-import java.util.Vector;\n-import java.util.Stack;\n-import java.util.Hashtable;\n-import java.lang.Math;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n@@ -46,3 +39,1 @@\n- * Subclasses of AbstractObjectInputStream must define SerializablePermission\n- * \"enableAbstractSubclass\" within a security policy file or this\n- * constructor will throw a SecurityException. Implementations of this\n+ * Implementations of this\n@@ -152,7 +143,0 @@\n-     * Add the following line to the security policy file to enable\n-     * subclassing.\n-     *\n-     * <PRE>\n-     *     permission SerializablePermission \"enableAbstractSubclass\" ;\n-     * <\/PRE><p>\n-     *\n@@ -161,2 +145,0 @@\n-     * @exception SecurityException if subclass does not have SerializablePermiision\n-     *            \"enableAbstractSubclass\".\n@@ -289,1 +271,1 @@\n-    protected abstract boolean enableResolveObject(boolean enable) throws SecurityException;\n+    protected abstract boolean enableResolveObject(boolean enable);\n","filename":"test\/jdk\/java\/io\/Serializable\/subclass\/AbstractObjectInputStream.java","additions":3,"deletions":21,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -48,3 +48,1 @@\n- * Subclasses of AbstractObjectOututStream must have SerializablePermission\n- * \"enableAbstractSubclass\" or this constructor will throw a\n- * SecurityException.Implementations of this class should protect themselves\n+ * Implementations of this class should protect themselves\n@@ -145,7 +143,0 @@\n-     * Add the following line to the security policy file to enable\n-     * subclassing.\n-     *\n-     * <PRE>\n-     *     permission SerializablePermission \"enableAbstractSubclass\" ;\n-     * <\/PRE><p>\n-     *\n@@ -234,1 +225,1 @@\n-    protected abstract boolean enableReplaceObject(boolean enable) throws SecurityException;\n+    protected abstract boolean enableReplaceObject(boolean enable);\n","filename":"test\/jdk\/java\/io\/Serializable\/subclass\/AbstractObjectOutputStream.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,7 +34,0 @@\n- *          Also, would be appropriate that this program verify\n- *          that if SerializablePermission \"enableSubclassImplementation\"\n- *          is not in the security policy and security is enabled, that\n- *          a security exception is thrown when constructing the\n- *          ObjectOutputStream subclass.\n- *\n- *\n@@ -132,2 +125,0 @@\n-        boolean expectSecurityException = false;\n-\n","filename":"test\/jdk\/java\/io\/Serializable\/subclass\/SubclassTest.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,14 +76,0 @@\n-            \/\/if currentDescriptor.isAssignable(Externalizable.class) {\n-            \/\/    Object[] argList = {this};\n-            \/\/    InvokeMethod(currentObject, readExternalMethod, argList);\n-            \/\/} else {\n-            \/\/    Does currentDescriptor have a readObject method\n-            \/\/    if it does\n-            \/\/        invokeMethod(this, readObjectMethod, {this});\n-            \/\/    else\n-            \/\/        defaultReadObject();\n-            \/\/}\n-            \/\/ check for replacement on currentObject.\n-            \/\/ if toplevel readobject\n-            \/\/    doObjectValidations.\n-\n@@ -248,38 +234,0 @@\n-\n-\n-    \/****************************************************************\/\n-\n-    \/* CODE LIFTED FROM ObjectStreamClass constuctor.\n-     * ObjectStreamClass.readObjectMethod is private.\n-     *\n-     * Look for the readObject method\n-     * Set the accessible flag on it here. ObjectOutputStream\n-     * will call it as necessary.\n-     *\/\n-    public static Method getReadObjectMethod(final Class<?> cl) {\n-\n-        Method readObjectMethod =\n-            java.security.AccessController.doPrivileged\n-            (new java.security.PrivilegedAction<Method>() {\n-                public Method run() {\n-                    Method m = null;\n-                    try {\n-                        Class<?>[] args = {ObjectInputStream.class};\n-                        m = cl.getDeclaredMethod(\"readObject\", args);\n-                        int mods = m.getModifiers();\n-                        \/\/ Method must be private and non-static\n-                        if (!Modifier.isPrivate(mods) ||\n-                            Modifier.isStatic(mods)) {\n-                            m = null;\n-                        } else {\n-                            m.setAccessible(true);\n-                        }\n-                    } catch (NoSuchMethodException e) {\n-                        m = null;\n-                    }\n-                    return m;\n-                }\n-            });\n-        return readObjectMethod;\n-    }\n-\n@@ -288,36 +236,1 @@\n-    \/* taken verbatim from ObjectInputStream. *\/\n-    private static void invokeMethod(final Object obj, final Method m,\n-                                        final Object[] argList)\n-        throws IOException\n-    {\n-        try {\n-            java.security.AccessController.doPrivileged\n-                (new java.security.PrivilegedExceptionAction<Void>() {\n-                    public Void run() throws InvocationTargetException,\n-                                        java.lang.IllegalAccessException {\n-                        m.invoke(obj, argList);\n-                        return null;\n-                    }\n-                });\n-        } catch (java.security.PrivilegedActionException e) {\n-            Exception ex = e.getException();\n-            if (ex instanceof InvocationTargetException) {\n-                Throwable t =\n-                        ((InvocationTargetException)ex).getTargetException();\n-                if (t instanceof IOException)\n-                    throw (IOException)t;\n-                else if (t instanceof RuntimeException)\n-                    throw (RuntimeException) t;\n-                else if (t instanceof Error)\n-                    throw (Error) t;\n-                else\n-                    throw new Error(\"interal error\");\n-            } else {\n-                \/\/ IllegalAccessException cannot happen\n-            }\n-        }\n-    }\n-\n-    protected boolean enableResolveObject(boolean enable)\n-        throws SecurityException\n-    {\n+    protected boolean enableResolveObject(boolean enable) {\n","filename":"test\/jdk\/java\/io\/Serializable\/subclass\/XObjectInputStream.java","additions":2,"deletions":89,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -297,1 +297,1 @@\n-    \/* CODE LIFTED FROM ObjectStreamClass constuctor.\n+    \/* CODE LIFTED FROM ObjectStreamClass constructor.\n@@ -305,24 +305,15 @@\n-\n-        Method writeObjectMethod =\n-            java.security.AccessController.doPrivileged\n-            (new java.security.PrivilegedAction<Method>() {\n-                public Method run() {\n-                    Method m = null;\n-                    try {\n-                        Class<?>[] args = {ObjectOutputStream.class};\n-                        m = cl.getDeclaredMethod(\"writeObject\", args);\n-                        int mods = m.getModifiers();\n-                        \/\/ Method must be private and non-static\n-                        if (!Modifier.isPrivate(mods) ||\n-                            Modifier.isStatic(mods)) {\n-                            m = null;\n-                        } else {\n-                            m.setAccessible(true);\n-                        }\n-                    } catch (NoSuchMethodException e) {\n-                        m = null;\n-                    }\n-                    return m;\n-                }\n-            });\n-        return writeObjectMethod;\n+        try {\n+            Class<?>[] args = {ObjectOutputStream.class};\n+            Method m = cl.getDeclaredMethod(\"writeObject\", args);\n+            int mods = m.getModifiers();\n+            \/\/ Method must be private and non-static\n+            if (!Modifier.isPrivate(mods) ||\n+                Modifier.isStatic(mods)) {\n+                return null;\n+            } else {\n+                m.setAccessible(true);\n+                return m;\n+            }\n+        } catch (NoSuchMethodException e) {\n+            return null;\n+        }\n@@ -339,24 +330,13 @@\n-            java.security.AccessController.doPrivileged\n-                (new java.security.PrivilegedExceptionAction<Void>() {\n-                    public Void run() throws InvocationTargetException,\n-                                        java.lang.IllegalAccessException {\n-                        m.invoke(obj, argList);\n-                        return null;\n-                    }\n-                });\n-        } catch (java.security.PrivilegedActionException e) {\n-            Exception ex = e.getException();\n-            if (ex instanceof InvocationTargetException) {\n-                Throwable t =\n-                        ((InvocationTargetException)ex).getTargetException();\n-                if (t instanceof IOException)\n-                    throw (IOException)t;\n-                else if (t instanceof RuntimeException)\n-                    throw (RuntimeException) t;\n-                else if (t instanceof Error)\n-                    throw (Error) t;\n-                else\n-                    throw new Error(\"interal error\");\n-            } else {\n-                \/\/ IllegalAccessException cannot happen\n-            }\n+            m.invoke(obj, argList);\n+        } catch (InvocationTargetException ex) {\n+            Throwable t = ex.getTargetException();\n+            if (t instanceof IOException)\n+                throw (IOException)t;\n+            else if (t instanceof RuntimeException)\n+                throw (RuntimeException) t;\n+            else if (t instanceof Error)\n+                throw (Error) t;\n+            else\n+                throw new Error(\"intenral error\");\n+        } catch (IllegalAccessException iae) {\n+            \/\/ IllegalAccessException can not happen\n","filename":"test\/jdk\/java\/io\/Serializable\/subclass\/XObjectOutputStream.java","additions":29,"deletions":49,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=monitorenter\n+ * @bug 8345266\n+ * @summary Test OOM while trying to unmount vthread on monitorenter\n+ * @requires vm.continuations & vm.gc.G1 & vm.opt.DisableExplicitGC != \"true\"\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseG1GC -Xmx48M MonitorEnterWaitOOME false\n+ *\/\n+\n+\/*\n+ * @test id=timedwait\n+ * @summary Test OOM while trying to unmount vthread on Object.wait\n+ * @requires vm.continuations & vm.gc.G1 & vm.opt.DisableExplicitGC != \"true\"\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseG1GC -Xmx48M MonitorEnterWaitOOME true 5\n+ *\/\n+\n+\/*\n+ * @test id=untimedwait\n+ * @summary Test OOM while trying to unmount vthread on Object.wait\n+ * @requires vm.continuations & vm.gc.G1 & vm.opt.DisableExplicitGC != \"true\"\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseG1GC -Xmx48M MonitorEnterWaitOOME true 0\n+ *\/\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import jdk.test.lib.thread.VThreadRunner;\n+\n+public class MonitorEnterWaitOOME {\n+    static volatile Object data;\n+    static Thread.State dummyState = Thread.State.RUNNABLE; \/\/ load java.lang.Thread$State\n+\n+    public static void main(String[] args) throws Throwable {\n+        final boolean testWait = args.length >= 1 ? Boolean.parseBoolean(args[0]) : false;\n+        final long timeout = testWait && args.length == 2 ? Long.parseLong(args[1]) : 0L;\n+\n+        VThreadRunner.ensureParallelism(2);\n+\n+        Thread vthread;\n+        var lock = new Object();\n+        var canFillHeap = new AtomicBoolean();\n+        var heapFilled = new AtomicBoolean();\n+        var heapCollected = new AtomicBoolean();\n+        var exRef = new AtomicReference<Throwable>();\n+        synchronized (lock) {\n+            vthread = Thread.ofVirtual().start(() -> {\n+                try {\n+                    awaitTrue(canFillHeap);\n+                    data = fillHeap();\n+                    heapFilled.set(true);\n+                    synchronized (lock) {\n+                        if (testWait) {\n+                            lock.wait(timeout);\n+                        }\n+                    }\n+                    data = null;\n+                    System.gc();\n+                    heapCollected.set(true);\n+                } catch (Throwable e) {\n+                    data = null;\n+                    System.gc(); \/\/ avoid nested OOME\n+                    exRef.set(e);\n+                }\n+            });\n+            canFillHeap.set(true);\n+            awaitTrue(heapFilled);\n+            awaitState(vthread, Thread.State.BLOCKED);\n+        }\n+        if (testWait && timeout == 0) {\n+            awaitState(vthread, Thread.State.WAITING);\n+            synchronized (lock) {\n+                lock.notify();\n+            }\n+        }\n+        joinVThread(vthread, heapCollected, exRef);\n+        assert exRef.get() == null;\n+    }\n+\n+    private static Object[] fillHeap() {\n+        Object[] first = null, last = null;\n+        int size = 1 << 20;\n+        while (size > 0) {\n+            try {\n+                Object[] array = new Object[size];\n+                if (first == null) {\n+                    first = array;\n+                } else {\n+                    last[0] = array;\n+                }\n+                last = array;\n+            } catch (OutOfMemoryError oome) {\n+                size = size >>> 1;\n+            }\n+        }\n+        return first;\n+    }\n+\n+    private static void awaitTrue(AtomicBoolean ready) {\n+        \/\/ Don't call anything that might allocate from the Java heap.\n+        while (!ready.get()) {\n+            Thread.onSpinWait();\n+        }\n+    }\n+\n+    private static void awaitState(Thread thread, Thread.State expectedState) {\n+        \/\/ Don't call anything that might allocate from the Java heap.\n+        while (thread.getState() != expectedState) {\n+            Thread.onSpinWait();\n+        }\n+    }\n+\n+    private static void joinVThread(Thread vthread, AtomicBoolean ready, AtomicReference<Throwable> exRef) throws Throwable {\n+        \/\/ Don't call anything that might allocate from the Java heap until ready is set.\n+        while (!ready.get()) {\n+            Throwable ex = exRef.get();\n+            if (ex != null) {\n+                throw ex;\n+            }\n+            Thread.onSpinWait();\n+        }\n+        vthread.join();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorEnterWaitOOME.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,476 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test JFR jdk.VirtualThreadPinned event recorded for contended monitor enter\n+ *     and Object.wait when pinned\n+ * @requires vm.continuations\n+ * @modules jdk.jfr jdk.management\n+ * @library \/test\/lib\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED MonitorPinnedEvents\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordedThread;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+import jdk.test.lib.thread.VThreadPinner;\n+import jdk.test.lib.thread.VThreadRunner;   \/\/ ensureParallelism requires jdk.management\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class MonitorPinnedEvents {\n+    \/\/ log to System.err so inlined with JUnit output\n+    private static final PrintStream log = System.err;\n+\n+    \/\/ expected values for \"blockingOperation\" field in event\n+    private static final String CONTENDED_MONITOR_ENTER = \"Contended monitor enter\";\n+    private static final String OBJECT_WAIT = \"Object.wait\";\n+\n+    \/\/ expected value for \"pinnedReason\" field in event\n+    private static final String NATIVE_FRAME = \"Native or VM frame on stack\";\n+\n+    \/\/ block or wait for 2s to allow minimum event duration be tested\n+    private static final int DELAY = 2000;\n+\n+    @BeforeAll\n+    static void setup() {\n+        \/\/ need at least two carriers to test pinning\n+        VThreadRunner.ensureParallelism(2);\n+    }\n+\n+    \/**\n+     * Test jdk.VirtualThreadPinned recorded for a contended monitor enter.\n+     *\/\n+    @Test\n+    void testContentedMonitorEnter() throws Exception {\n+        try (Recording recording = new Recording()) {\n+            recording.enable(\"jdk.VirtualThreadPinned\");\n+            recording.start();\n+\n+            Thread vthread;\n+            try {\n+                Object lock = new Object();\n+\n+                synchronized (lock) {\n+                    \/\/ start virtual thread that blocks trying to acquire monitor while pinned\n+                    var ready = new AtomicBoolean();\n+                    vthread = Thread.ofVirtual().start(() -> {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready.set(true);\n+                            synchronized (lock) {   \/\/ <--- blocks here while pinned\n+                            }\n+                        });\n+                    });\n+                    await(ready, vthread, Thread.State.BLOCKED);\n+\n+                    \/\/ sleep before releasing to ensure virtual thread is blocked for >= 2s\n+                    Thread.sleep(DELAY);\n+                }\n+                vthread.join();\n+            } finally {\n+                recording.stop();\n+            }\n+\n+            \/\/ jdk.VirtualThreadPinned event should be recorded\n+            RecordedEvent event = findPinnedEvent(recording);\n+            testEvent(event, vthread, CONTENDED_MONITOR_ENTER, NATIVE_FRAME, DELAY);\n+        }\n+    }\n+\n+    \/**\n+     * Test jdk.VirtualThreadPinned recorded for a contended monitor enter where\n+     * another thread may acquire the monitor when the main thread releases it. If\n+     * the other thread acquires the monitor before the virtual thread then the event\n+     * duration should include the time blocked until the other thread releases it.\n+     *\/\n+    @Test\n+    void testContentedMonitorEnter2() throws Exception {\n+        try (Recording recording = new Recording()) {\n+            recording.enable(\"jdk.VirtualThreadPinned\");\n+            recording.start();\n+\n+            \/\/ the thread that acquires the monitor after the main thread releases it\n+            var nextOwner = new AtomicReference<Thread>();\n+\n+            Thread vthread;\n+            try {\n+                Object lock = new Object();\n+                Thread thread2;\n+                synchronized (lock) {\n+\n+                    \/\/ start virtual thread that blocks trying to acquire monitor while pinned\n+                    var ready1 = new AtomicBoolean();\n+                    vthread = Thread.ofVirtual().start(() -> {\n+                        VThreadPinner.runPinned(() -> {\n+                            ready1.set(true);\n+                            synchronized (lock) {   \/\/ <--- blocks here while pinned\n+                                nextOwner.compareAndSet(null, Thread.currentThread());\n+                            }\n+                        });\n+                    });\n+                    await(ready1, vthread, Thread.State.BLOCKED);\n+\n+                    \/\/ start platform thread that blocks trying to acquire monitor\n+                    thread2 = Thread.ofPlatform().start(() -> {\n+                        synchronized (lock) {\n+                            if (nextOwner.compareAndSet(null, Thread.currentThread())) {\n+                                \/\/ delayed release of monitor if acquired before virtual thread\n+                                try {\n+                                    Thread.sleep(DELAY);\n+                                } catch (InterruptedException e) {\n+                                }\n+                            }\n+                        }\n+                    });\n+\n+                }  \/\/ release lock, vthread or thread2 will acquire\n+\n+                vthread.join();\n+                thread2.join();\n+            } finally {\n+                recording.stop();\n+            }\n+\n+            \/\/ jdk.VirtualThreadPinned event should be recorded. If the platform thread\n+            \/\/ acquired the monitor before the virtual thread then the event duration\n+            \/\/ should be >= DELAY.\n+            RecordedEvent event = findPinnedEvent(recording);\n+            Thread winner = nextOwner.get();\n+            assertNotNull(winner);\n+            int minDuration = winner.isVirtual() ? 0 : DELAY;\n+            testEvent(event, vthread, CONTENDED_MONITOR_ENTER, NATIVE_FRAME, minDuration);\n+        }\n+    }\n+\n+    \/**\n+     * Test jdk.VirtualThreadPinned recorded for Object.wait when notified.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testObjectWaitNotify(boolean timed) throws Exception {\n+        testObjectWait(timed, false);\n+    }\n+\n+    \/**\n+     * Test jdk.VirtualThreadPinned recorded for Object.wait when interrupted.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testObjectWaitInterrupt(boolean timed) throws Exception {\n+        testObjectWait(timed, true);\n+    }\n+\n+    \/**\n+     * Test jdk.VirtualThreadPinned recorded for Object.wait.\n+     * @param timed true for a timed-wait, false for an untimed-wait\n+     * @param interrupt true to interrupt the thread, false to notify\n+     *\/\n+    private void testObjectWait(boolean timed, boolean interrupt) throws Exception {\n+        try (Recording recording = new Recording()) {\n+            recording.enable(\"jdk.VirtualThreadPinned\");\n+            recording.start();\n+\n+            Thread vthread;\n+            try {\n+                Object lock = new Object();\n+\n+                \/\/ start virtual thread that waits in Object.wait while pinned\n+                var ready = new AtomicBoolean();\n+                vthread = Thread.ofVirtual().start(() -> {\n+                    VThreadPinner.runPinned(() -> {\n+                        synchronized (lock) {\n+                            ready.set(true);\n+                            try {\n+                                \/\/ wait while pinned\n+                                if (timed) {\n+                                    lock.wait(Long.MAX_VALUE);\n+                                } else {\n+                                    lock.wait();\n+                                }\n+                            } catch (InterruptedException e) {\n+                            }\n+                        }\n+                    });\n+                });\n+                await(ready, vthread, timed ? Thread.State.TIMED_WAITING : Thread.State.WAITING);\n+\n+                \/\/ sleep to ensure virtual thread waits for >= 2s\n+                Thread.sleep(DELAY);\n+\n+                \/\/ interrupt or notify thread so it resumes execution\n+                if (interrupt) {\n+                    vthread.interrupt();\n+                } else {\n+                    synchronized (lock) {\n+                        lock.notify();\n+                    }\n+                }\n+                vthread.join();\n+            } finally {\n+                recording.stop();\n+            }\n+\n+            \/\/ jdk.VirtualThreadPinned event should be recorded\n+            RecordedEvent event = findPinnedEvent(recording);\n+            testEvent(event, vthread, OBJECT_WAIT, NATIVE_FRAME, DELAY);\n+        }\n+    }\n+\n+    \/**\n+     * Test jdk.VirtualThreadPinned recorded for Object.wait where the virtual thread\n+     * is notified but may block when attempting to reenter. One event should be\n+     * recorded. The event duration should include both the waiting time and the time\n+     * blocked to reenter.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testObjectWaitNotify2(boolean timed) throws Exception {\n+        testObjectWait2(timed, false);\n+    }\n+\n+    \/**\n+     * Test jdk.VirtualThreadPinned recorded for Object.wait where the virtual thread\n+     * is interrupted but may block when attempting to reenter. One event should be\n+     * recorded. The event duration should include both the waiting time and the time\n+     * blocked to reenter.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    void testObjectWaitInterrupt2(boolean timed) throws Exception {\n+        testObjectWait2(timed, true);\n+    }\n+\n+    \/**\n+     * Test jdk.VirtualThreadPinned recorded for Object.wait where the virtual thread\n+     * blocks when attempting to reenter.\n+     * @param timed true for a timed-wait, false for an untimed-wait\n+     * @param interrupt true to interrupt the thread, false to notify\n+     *\/\n+    private void testObjectWait2(boolean timed, boolean interrupt) throws Exception {\n+        try (Recording recording = new Recording()) {\n+            recording.enable(\"jdk.VirtualThreadPinned\");\n+            recording.start();\n+\n+            \/\/ the thread that acquires the monitor after the main thread releases it\n+            var nextOwner = new AtomicReference<Thread>();\n+\n+            Thread vthread;\n+            try {\n+                Object lock = new Object();\n+\n+                \/\/ start virtual thread that waits in Object.wait while pinned\n+                var ready1 = new AtomicBoolean();\n+                vthread = Thread.ofVirtual().start(() -> {\n+                    VThreadPinner.runPinned(() -> {\n+                        boolean notify = !interrupt;\n+                        synchronized (lock) {\n+                            ready1.set(true);\n+                            try {\n+                                \/\/ wait while pinned\n+                                if (timed) {\n+                                    lock.wait(Long.MAX_VALUE);\n+                                } else {\n+                                    lock.wait();\n+                                }\n+                                if (notify) {\n+                                    nextOwner.compareAndSet(null, Thread.currentThread());\n+                                }\n+                            } catch (InterruptedException e) {\n+                                if (interrupt) {\n+                                    nextOwner.compareAndSet(null, Thread.currentThread());\n+                                }\n+                            }\n+                        }\n+                    });\n+                });\n+                await(ready1, vthread, timed ? Thread.State.TIMED_WAITING : Thread.State.WAITING);\n+\n+                \/\/ platform thread that blocks on monitor enter\n+                Thread thread2;\n+                synchronized (lock) {\n+                    thread2 = Thread.ofPlatform().start(() -> {\n+                        synchronized (lock) {   \/\/ <--- blocks here\n+                            if (nextOwner.compareAndSet(null, Thread.currentThread())) {\n+                                \/\/ delayed release of monitor if acquired before virtual thread\n+                                try {\n+                                    Thread.sleep(DELAY);\n+                                } catch (InterruptedException e) {\n+                                }\n+                            }\n+                        }\n+                    });\n+\n+                    \/\/ interrupt\/notify and release monitor to allow one of the threads to acquire\n+                    if (interrupt) {\n+                        vthread.interrupt();\n+                    } else {\n+                        lock.notify();\n+                    }\n+                }\n+\n+                vthread.join();\n+                thread2.join();\n+\n+            } finally {\n+                recording.stop();\n+            }\n+\n+            \/\/ jdk.VirtualThreadPinned event should be recorded. If the platform thread\n+            \/\/ acquired the monitor before the virtual thread re-entered then the event\n+            \/\/ duration should be >= DELAY.\n+            RecordedEvent event = findPinnedEvent(recording);\n+            Thread winner = nextOwner.get();\n+            assertNotNull(winner);\n+            int minDuration = winner.isVirtual() ? 0 : DELAY;\n+            testEvent(event, vthread, OBJECT_WAIT, NATIVE_FRAME, minDuration);\n+        }\n+    }\n+\n+    \/**\n+     * Test that the event was recorded by the expected virtual thread, the event has a\n+     * \"carrierThread\", the \"blockingOperation\", and \"pinnedReason\" fields have the\n+     * expected values, and the event duration is >= minDuration.\n+     *\/\n+    private void testEvent(RecordedEvent event,\n+                           Thread vthread,\n+                           String expectedBlockingOp,\n+                           String expectedPinnedReason,\n+                           int minDuration) {\n+        assertTrue(vthread.isVirtual());\n+        assertEquals(vthread.threadId(), event.getThread().getId());\n+\n+        RecordedThread carrier = event.getValue(\"carrierThread\");\n+        assertFalse(carrier.isVirtual());\n+\n+        assertEquals(expectedBlockingOp, event.getString(\"blockingOperation\"));\n+        assertEquals(expectedPinnedReason, event.getString(\"pinnedReason\"));\n+\n+        long duration = event.getDuration().toMillis();\n+        assertTrue(duration >= (minDuration - 100),\n+                \"Duration \" + duration + \"ms, expected >= \" + minDuration + \"ms\");\n+    }\n+\n+    \/**\n+     * Find the expected jdk.VirtualThreadPinned event in the recording. There may be\n+     * several pinned events recorded by other parts of the system that need to be\n+     * filtered out.\n+     *\/\n+    private RecordedEvent findPinnedEvent(Recording recording) throws IOException {\n+        Map<Boolean, List<RecordedEvent>> events = find(recording, \"jdk.VirtualThreadPinned\")\n+                .collect(Collectors.partitioningBy(e -> filtered(topFrameMethod(e)), Collectors.toList()));\n+        List<RecordedEvent> filteredEvents = events.get(Boolean.TRUE);\n+        List<RecordedEvent> pinnedEvents = events.get(Boolean.FALSE);\n+        log.format(\"%d event(s) recorded%n\", filteredEvents.size() + pinnedEvents.size());\n+        log.println(\"-- filtered events --\");\n+        log.println(filteredEvents);\n+        log.println(\"-- remaining pinned events --\");\n+        log.println(pinnedEvents);\n+        assertEquals(1, pinnedEvents.size());\n+        return pinnedEvents.get(0);\n+    }\n+\n+    \/**\n+     * Pinned events recorded at the following classes\/methods should be ignored.\n+     *\/\n+    private final Set<String> FILTERED = Set.of(\n+            \"java.lang.VirtualThread.*\",\n+            \"java.lang.ref.ReferenceQueue.poll\",\n+            \"java.lang.invoke.*\",\n+            \"jdk.internal.ref.*\"\n+    );\n+\n+    \/**\n+     * Returns true if the given top-frame {@code class.method} should be ignored.\n+     *\/\n+    private boolean filtered(String topFrameMethod) {\n+        for (String s : FILTERED) {\n+            if (s.endsWith(\"*\")) {\n+                String prefix = s.substring(0, s.length()-1);\n+                if (topFrameMethod.startsWith(prefix)) {\n+                    return true;\n+                }\n+            } else if (s.equals(topFrameMethod)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns the {@code class.method} of the top frame in the event's stack trace.\n+     *\/\n+    private String topFrameMethod(RecordedEvent event) {\n+        RecordedFrame topFrame = event.getStackTrace().getFrames().get(0);\n+        RecordedMethod method = topFrame.getMethod();\n+        return method.getType().getName() + \".\" + method.getName();\n+    }\n+\n+    \/**\n+     * Returns the events with the given name in the recording.\n+     *\/\n+    private Stream<RecordedEvent> find(Recording recording, String name) throws IOException {\n+        Path recordingFile = recording.getDestination();\n+        if (recordingFile == null) {\n+            ProcessHandle h = ProcessHandle.current();\n+            recordingFile = Path.of(\"recording-\" + recording.getId() + \"-pid\" + h.pid() + \".jfr\");\n+            recording.dump(recordingFile);\n+        }\n+        return RecordingFile.readAllEvents(recordingFile)\n+                .stream()\n+                .filter(e -> e.getEventType().getName().equals(name));\n+    }\n+\n+    \/**\n+     * Waits for ready to become true, then waits for the thread to get to the given state.\n+     *\/\n+    private void await(AtomicBoolean ready,\n+                       Thread thread,\n+                       Thread.State expectedState) throws InterruptedException {\n+        while (!ready.get()) {\n+            Thread.sleep(10);\n+        }\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorPinnedEvents.java","additions":476,"deletions":0,"binary":false,"changes":476,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+    private Throwable transformerException;\n@@ -112,3 +113,5 @@\n-        \/\/ With this call here, we will see the target class once:\n-        \/\/ when it gets retransformed.\n-        \/\/addTransformerToManager(fInst, new MyObserver(), true);\n+        \/\/ check for unexpected errors (see JDK-8311534)\n+        if (transformerException != null) {\n+            transformerException.printStackTrace();\n+            throw new RuntimeException(\"Error in transformer\" + transformerException);\n+        }\n@@ -250,2 +253,14 @@\n-            System.out.println(this + \".transform() sees '\" + className\n-                + \"' of \" + classfileBuffer.length + \" bytes.\");\n+            \/\/ String concatenation can cause LinkageError or ClassCircularityError (see JDK-8311534).\n+            \/\/ Need to log it for analysis.\n+            try {\n+                System.out.println(this + \".transform() sees '\" + className\n+                    + \"' of \" + classfileBuffer.length + \" bytes.\");\n+            } catch (Throwable t) {\n+                \/\/ Try to log. Save the error for handling by main thread if the logging fails.\n+                try {\n+                    t.printStackTrace();\n+                } catch (Throwable t1) {\n+                    transformerException = t;\n+                }\n+                return null;\n+            }\n","filename":"test\/jdk\/java\/lang\/instrument\/VerifyLocalVariableTableOnRetransformTest.java","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * @test\n+ * @test id=Shenandoah\n@@ -51,3 +51,3 @@\n- * @summary Basic unit test of MemoryMXBean.getMemoryPools() and\n- *          MemoryMXBean.getMemoryManager().\n- * @requires vm.gc == \"Shenandoah\"\n+ * @summary Shenandoah has a gc mgr bean for cycles and another\n+ *          for pauses, they both have one pool.\n+ * @requires vm.gc == \"Shenandoah\" & vm.opt.ShenandoahGCMode != \"generational\"\n@@ -60,0 +60,12 @@\n+\/*\n+ * @test id=Genshen\n+ * @bug     4530538\n+ * @summary Shenandoah's generational mode has a gc mgr bean for cycles\n+ *          and another for pauses. They both reference the young and old pools.\n+ * @requires vm.gc == \"Shenandoah\" & vm.opt.ShenandoahGCMode == \"generational\"\n+ * @author  Mandy Chung\n+ *\n+ * @modules jdk.management\n+ * @run main MemoryTest 2 2\n+ *\/\n+\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/MemoryTest.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.net.Proxy;\n@@ -39,0 +40,1 @@\n+import static java.net.InetAddress.getLoopbackAddress;\n@@ -53,0 +55,2 @@\n+    \/\/ Implementation Note: Explicitly binding on the loopback address to avoid potential unstabilities.\n+\n@@ -86,1 +90,1 @@\n-            socket.bind(new InetSocketAddress(0));\n+            socket.bind(new InetSocketAddress(getLoopbackAddress(), 0));\n@@ -135,1 +139,1 @@\n-            socket.bind(new InetSocketAddress(0));\n+            socket.bind(new InetSocketAddress(getLoopbackAddress(), 0));\n@@ -164,1 +168,2 @@\n-        return List.of(socket, channelSocket);\n+        Socket noProxySocket = new Socket(Proxy.NO_PROXY);\n+        return List.of(socket, channelSocket, noProxySocket);\n","filename":"test\/jdk\/java\/net\/Socket\/ConnectFailTest.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.net.Authenticator;\n+import java.net.InetSocketAddress;\n+import java.net.PasswordAuthentication;\n+import java.net.Proxy;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketException;\n+\n+import static java.net.InetAddress.getLoopbackAddress;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8346017\n+ * @summary Verifies the `connect()` behaviour of a SOCKS proxy socket. In particular, that passing a resolvable\n+ *          unresolved address doesn't throw an exception.\n+ * @library \/test\/lib \/java\/net\/Socks\n+ * @build SocksServer\n+ * @run junit ConnectSocksProxyTest\n+ *\/\n+class ConnectSocksProxyTest {\n+\n+    \/\/ Implementation Note: Explicitly binding on the loopback address to avoid potential unstabilities.\n+\n+    private static final int DEAD_SERVER_PORT = 0xDEAD;\n+\n+    private static final InetSocketAddress REFUSING_SOCKET_ADDRESS = Utils.refusingEndpoint();\n+\n+    private static final InetSocketAddress UNRESOLVED_ADDRESS =\n+            InetSocketAddress.createUnresolved(\"no.such.host\", DEAD_SERVER_PORT);\n+\n+    private static final String PROXY_AUTH_USERNAME = \"foo\";\n+\n+    private static final String PROXY_AUTH_PASSWORD = \"bar\";\n+\n+    private static SocksServer PROXY_SERVER;\n+\n+    private static Proxy PROXY;\n+\n+    @BeforeAll\n+    static void initAuthenticator() {\n+        Authenticator.setDefault(new Authenticator() {\n+            @Override\n+            protected PasswordAuthentication getPasswordAuthentication() {\n+                return new PasswordAuthentication(PROXY_AUTH_USERNAME, PROXY_AUTH_PASSWORD.toCharArray());\n+            }\n+        });\n+    }\n+\n+    @BeforeAll\n+    static void initProxyServer() throws IOException {\n+        PROXY_SERVER = new SocksServer(getLoopbackAddress(), 0, false);\n+        PROXY_SERVER.addUser(PROXY_AUTH_USERNAME, PROXY_AUTH_PASSWORD);\n+        PROXY_SERVER.start();\n+        InetSocketAddress proxyAddress = new InetSocketAddress(getLoopbackAddress(), PROXY_SERVER.getPort());\n+        PROXY = new Proxy(Proxy.Type.SOCKS, proxyAddress);\n+    }\n+\n+    @AfterAll\n+    static void stopProxyServer() {\n+        PROXY_SERVER.close();\n+    }\n+\n+    @Test\n+    void testUnresolvedAddress() {\n+        assertTrue(UNRESOLVED_ADDRESS.isUnresolved());\n+    }\n+\n+    \/**\n+     * Verifies that an unbound socket is closed when {@code connect()} fails.\n+     *\/\n+    @Test\n+    void testUnboundSocket() throws IOException {\n+        try (Socket socket = createProxiedSocket()) {\n+            assertFalse(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that a bound socket is closed when {@code connect()} fails.\n+     *\/\n+    @Test\n+    void testBoundSocket() throws IOException {\n+        try (Socket socket = createProxiedSocket()) {\n+            socket.bind(new InetSocketAddress(getLoopbackAddress(), 0));\n+            assertTrue(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            assertThrows(IOException.class, () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+            assertTrue(socket.isClosed());\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that a connected socket is not closed when {@code connect()} fails.\n+     *\/\n+    @Test\n+    void testConnectedSocket() throws Throwable {\n+        try (Socket socket = createProxiedSocket();\n+             ServerSocket serverSocket = createEphemeralServerSocket()) {\n+            socket.connect(serverSocket.getLocalSocketAddress());\n+            try (Socket _ = serverSocket.accept()) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                SocketException exception = assertThrows(\n+                        SocketException.class,\n+                        () -> socket.connect(REFUSING_SOCKET_ADDRESS));\n+                assertEquals(\"Already connected\", exception.getMessage());\n+                assertFalse(socket.isClosed());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Delegates to {@link #testUnconnectedSocketWithUnresolvedAddress(boolean, Socket)} using an unbound socket.\n+     *\/\n+    @Test\n+    void testUnboundSocketWithUnresolvedAddress() throws IOException {\n+        try (Socket socket = createProxiedSocket()) {\n+            assertFalse(socket.isBound());\n+            assertFalse(socket.isConnected());\n+            testUnconnectedSocketWithUnresolvedAddress(false, socket);\n+        }\n+    }\n+\n+    \/**\n+     * Delegates to {@link #testUnconnectedSocketWithUnresolvedAddress(boolean, Socket)} using a bound socket.\n+     *\/\n+    @Test\n+    void testBoundSocketWithUnresolvedAddress() throws IOException {\n+        try (Socket socket = createProxiedSocket()) {\n+            socket.bind(new InetSocketAddress(getLoopbackAddress(), 0));\n+            testUnconnectedSocketWithUnresolvedAddress(true, socket);\n+        }\n+    }\n+\n+    \/**\n+     * Verifies the behaviour of an unconnected socket when {@code connect()} is invoked using an unresolved address.\n+     *\/\n+    private static void testUnconnectedSocketWithUnresolvedAddress(boolean bound, Socket socket) throws IOException {\n+        assertEquals(bound, socket.isBound());\n+        assertFalse(socket.isConnected());\n+        try (ServerSocket serverSocket = createEphemeralServerSocket()) {\n+            InetSocketAddress unresolvedAddress = InetSocketAddress.createUnresolved(\n+                    getLoopbackAddress().getHostAddress(),\n+                    serverSocket.getLocalPort());\n+            socket.connect(unresolvedAddress);\n+            try (Socket _ = serverSocket.accept()) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                assertFalse(socket.isClosed());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that a connected socket is not closed when {@code connect()} is invoked using an unresolved address.\n+     *\/\n+    @Test\n+    void testConnectedSocketWithUnresolvedAddress() throws Throwable {\n+        try (Socket socket = createProxiedSocket();\n+             ServerSocket serverSocket = createEphemeralServerSocket()) {\n+            socket.connect(serverSocket.getLocalSocketAddress());\n+            try (Socket _ = serverSocket.accept()) {\n+                assertTrue(socket.isBound());\n+                assertTrue(socket.isConnected());\n+                SocketException exception = assertThrows(\n+                        SocketException.class,\n+                        () -> socket.connect(UNRESOLVED_ADDRESS));\n+                assertEquals(\"Already connected\", exception.getMessage());\n+                assertFalse(socket.isClosed());\n+            }\n+        }\n+    }\n+\n+    private static Socket createProxiedSocket() {\n+        return new Socket(PROXY);\n+    }\n+\n+    private static ServerSocket createEphemeralServerSocket() throws IOException {\n+        return new ServerSocket(0, 0, getLoopbackAddress());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/ConnectSocksProxyTest.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @compile ..\/..\/nio\/file\/spi\/TestProvider.java AddressTest.java\n+ * @compile ..\/..\/nio\/file\/spi\/testfsp\/testfsp\/TestProvider.java AddressTest.java\n@@ -54,2 +54,2 @@\n-        TestProvider prov = new TestProvider(FileSystems.getDefault().provider());\n-        Path path = prov.getPath(URI.create(\"file:\/\"));\n+        var fsp = new testfsp.TestProvider(FileSystems.getDefault().provider());\n+        Path path = fsp.getPath(URI.create(\"file:\/\"));\n","filename":"test\/jdk\/java\/net\/UnixDomainSocketAddress\/AddressTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -26,2 +26,2 @@\n- * @bug 4313887 7006126 8142968 8178380 8183320 8210112 8266345 8263940\n- * @modules jdk.jartool\n+ * @bug 4313887 7006126 8142968 8178380 8183320 8210112 8266345 8263940 8331467\n+ * @modules jdk.jartool jdk.jlink\n@@ -29,2 +29,2 @@\n- * @build SetDefaultProvider TestProvider m\/* jdk.test.lib.process.ProcessTools\n- * @run testng\/othervm SetDefaultProvider\n+ * @build testfsp\/* testapp\/*\n+ * @run junit SetDefaultProvider\n@@ -40,0 +40,1 @@\n+import java.util.Arrays;\n@@ -46,0 +47,3 @@\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -47,5 +51,1 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-@Test\n-public class SetDefaultProvider {\n+class SetDefaultProvider {\n@@ -54,1 +54,1 @@\n-        \"-Djava.nio.file.spi.DefaultFileSystemProvider=TestProvider\";\n+        \"-Djava.nio.file.spi.DefaultFileSystemProvider=testfsp.TestProvider\";\n@@ -61,3 +61,14 @@\n-    private static Path createTempDirectory(String prefix) throws IOException {\n-        Path testDir = Paths.get(System.getProperty(\"test.dir\", \".\"));\n-        return Files.createTempDirectory(testDir, prefix);\n+    private static final String TESTFSP = \"testfsp\";\n+    private static final String TESTAPP = \"testapp\";\n+    private static final String TESTAPP_MAIN = TESTAPP + \".Main\";\n+\n+    \/\/ directory containing testfsp class files\n+    private static String TESTFSP_CLASSES;\n+\n+    \/\/ directory containing testapp class files\n+    private static String TESTAPP_CLASSES;\n+\n+    @BeforeAll\n+    static void setup() {\n+        TESTFSP_CLASSES = classes(TESTFSP);\n+        TESTAPP_CLASSES = classes(TESTAPP);\n@@ -67,2 +78,1 @@\n-     * Test override of default FileSystemProvider with the main application\n-     * on the class path.\n+     * Test file system provider exploded on the class path.\n@@ -70,6 +80,5 @@\n-    public void testClassPath() throws Exception {\n-        String moduleClasses = moduleClasses();\n-        String testClasses = System.getProperty(\"test.classes\");\n-        String classpath = moduleClasses + File.pathSeparator + testClasses;\n-        int exitValue = exec(SET_DEFAULT_FSP, \"-cp\", classpath, \"p.Main\");\n-        assertEquals(exitValue, 0);\n+    @Test\n+    void testFspOnClassPath1() throws Exception {\n+        exec(SET_DEFAULT_FSP,\n+                \"-cp\", ofClasspath(TESTFSP_CLASSES, TESTAPP_CLASSES),\n+                TESTAPP_MAIN);\n@@ -79,2 +88,1 @@\n-     * Test override of default FileSystemProvider with a\n-     * FileSystemProvider jar and the main application on the class path.\n+     * Test file system provider in JAR file on the class path.\n@@ -82,9 +90,6 @@\n-    public void testClassPathWithFileSystemProviderJar() throws Exception {\n-        String testClasses = System.getProperty(\"test.classes\");\n-        Path jar = Path.of(\"testFileSystemProvider.jar\");\n-        Files.deleteIfExists(jar);\n-        createFileSystemProviderJar(jar, Path.of(testClasses));\n-        String classpath = jar + File.pathSeparator + testClasses\n-                + File.separator + \"modules\" + File.separator + \"m\";\n-        int exitValue = exec(SET_DEFAULT_FSP, \"-cp\", classpath, \"p.Main\");\n-        assertEquals(exitValue, 0);\n+    @Test\n+    void testFspOnClassPath2() throws Exception {\n+        String jarFile = createJar(\"fsp.jar\", TESTFSP_CLASSES);\n+        exec(SET_DEFAULT_FSP,\n+                \"-cp\", ofClasspath(jarFile, TESTAPP_CLASSES),\n+                TESTAPP_MAIN);\n@@ -94,2 +99,1 @@\n-     * Creates a JAR containing the FileSystemProvider used to override the\n-     * default FileSystemProvider\n+     * Test file system provider in exploded module on the module path.\n@@ -97,1 +101,8 @@\n-    private void createFileSystemProviderJar(Path jar, Path dir) throws IOException {\n+    @Test\n+    void testFspOnModulePath1() throws Exception {\n+        exec(SET_DEFAULT_FSP,\n+                \"-p\", TESTFSP_CLASSES,\n+                \"--add-modules\", TESTFSP,\n+                \"-cp\", TESTAPP_CLASSES,\n+                TESTAPP_MAIN);\n+    }\n@@ -99,16 +110,11 @@\n-        List<String>  args = new ArrayList<>();\n-        args.add(\"--create\");\n-        args.add(\"--file=\" + jar);\n-        try (Stream<Path> stream = Files.list(dir)) {\n-            List<String> paths = stream\n-                    .map(path -> path.getFileName().toString())\n-                    .filter(f -> f.startsWith(\"TestProvider\"))\n-                    .toList();\n-            for(var p : paths) {\n-                args.add(\"-C\");\n-                args.add(dir.toString());\n-                args.add(p);\n-            }\n-        }\n-        int ret = JAR_TOOL.run(System.out, System.out, args.toArray(new String[0]));\n-        assertEquals(ret, 0);\n+    \/**\n+     * Test file system provider in modular JAR on the module path.\n+     *\/\n+    @Test\n+    void testFspOnModulePath2() throws Exception {\n+        String jarFile = createJar(\"fsp.jar\", TESTFSP_CLASSES);\n+        exec(SET_DEFAULT_FSP,\n+                \"-p\", jarFile,\n+                \"--add-modules\", TESTFSP,\n+                \"-cp\", TESTAPP_CLASSES,\n+                TESTAPP_MAIN);\n@@ -118,2 +124,1 @@\n-     * Test override of default FileSystemProvider with the main application\n-     * on the module path as an exploded module.\n+     * Test file system provider linked into run-time image.\n@@ -121,4 +126,25 @@\n-    public void testExplodedModule() throws Exception {\n-        String modulePath = System.getProperty(\"jdk.module.path\");\n-        int exitValue = exec(SET_DEFAULT_FSP, \"-p\", modulePath, \"-m\", \"m\/p.Main\");\n-        assertEquals(exitValue, 0);\n+    @Test\n+    void testFspInRuntimeImage() throws Exception {\n+        String image = \"image\";\n+\n+        ToolProvider jlink = ToolProvider.findFirst(\"jlink\").orElseThrow();\n+        String[] jlinkCmd = {\n+                \"--module-path\", TESTFSP_CLASSES,\n+                \"--add-modules\", TESTFSP,\n+                \"--output\", image\n+        };\n+        int exitCode = jlink.run(System.out, System.err, jlinkCmd);\n+        assertEquals(0, exitCode);\n+\n+        String[] javaCmd = {\n+                Path.of(image, \"bin\", \"java\").toString(),\n+                SET_DEFAULT_FSP,\n+                \"--add-modules\", TESTFSP,\n+                \"-cp\", TESTAPP_CLASSES,\n+                TESTAPP_MAIN\n+        };\n+        var pb = new ProcessBuilder(javaCmd);\n+        ProcessTools.executeProcess(pb)\n+                .outputTo(System.out)\n+                .errorTo(System.err)\n+                .shouldHaveExitValue(0);\n@@ -128,2 +154,1 @@\n-     * Test override of default FileSystemProvider with the main application\n-     * on the module path as a modular JAR.\n+     * Test file system provider on class path, application in exploded module on module path.\n@@ -131,4 +156,6 @@\n-    public void testModularJar() throws Exception {\n-        String jarFile = createModularJar();\n-        int exitValue = exec(SET_DEFAULT_FSP, \"-p\", jarFile, \"-m\", \"m\/p.Main\");\n-        assertEquals(exitValue, 0);\n+    @Test\n+    void testAppOnModulePath1() throws Exception {\n+        exec(SET_DEFAULT_FSP,\n+                \"-p\", TESTAPP_CLASSES,\n+                \"-cp\", TESTFSP_CLASSES,\n+                \"-m\", TESTAPP + \"\/\" + TESTAPP_MAIN);\n@@ -138,2 +165,1 @@\n-     * Test override of default FileSystemProvider where the main application\n-     * is a module that is patched by an exploded patch.\n+     * Test file system provider on class path, application in modular JAR on module path.\n@@ -141,1 +167,15 @@\n-    public void testExplodedModuleWithExplodedPatch() throws Exception {\n+    @Test\n+    void testAppOnModulePath2() throws Exception {\n+        String jarFile = createJar(\"testapp.jar\", TESTAPP_CLASSES);\n+        exec(SET_DEFAULT_FSP,\n+                \"-cp\", TESTFSP_CLASSES,\n+                \"-p\", jarFile,\n+                \"-m\", TESTAPP + \"\/\" + TESTAPP_MAIN);\n+    }\n+\n+    \/**\n+     * Test file system provider on class path, application in modular JAR on module path\n+     * that is patched with exploded patch.\n+     *\/\n+    @Test\n+    void testPatchedAppOnModulePath1() throws Exception {\n@@ -143,6 +183,6 @@\n-        String modulePath = System.getProperty(\"jdk.module.path\");\n-        int exitValue = exec(SET_DEFAULT_FSP,\n-                             \"--patch-module\", \"m=\" + patchdir,\n-                             \"-p\", modulePath,\n-                             \"-m\", \"m\/p.Main\");\n-        assertEquals(exitValue, 0);\n+        Files.createFile(patchdir.resolve(\"aoo.properties\"));\n+        exec(SET_DEFAULT_FSP,\n+                \"--patch-module\", TESTAPP + \"=\" + patchdir,\n+                \"-p\", TESTAPP_CLASSES,\n+                \"-cp\", TESTFSP_CLASSES,\n+                \"-m\", TESTAPP + \"\/\" + TESTAPP_MAIN);\n@@ -152,2 +192,2 @@\n-     * Test override of default FileSystemProvider where the main application\n-     * is a module that is patched by an exploded patch.\n+     * Test file system provider on class path, application in modular JAR on module path\n+     * that is patched with patch in JAR file.\n@@ -155,1 +195,2 @@\n-    public void testExplodedModuleWithJarPatch() throws Exception {\n+    @Test\n+    void testPatchedAppOnModulePath2() throws Exception {\n@@ -157,8 +198,7 @@\n-        Files.createDirectory(patchdir.resolve(\"m.properties\"));\n-        Path patch = createJarFile(patchdir);\n-        String modulePath = System.getProperty(\"jdk.module.path\");\n-        int exitValue = exec(SET_DEFAULT_FSP,\n-                             \"--patch-module\", \"m=\" + patch,\n-                             \"-p\", modulePath,\n-                             \"-m\", \"m\/p.Main\");\n-        assertEquals(exitValue, 0);\n+        Files.createFile(patchdir.resolve(\"app.properties\"));\n+        String jarFile = createJar(\"patch.jar\", patchdir.toString());\n+        exec(SET_DEFAULT_FSP,\n+                \"--patch-module\", TESTAPP + \"=\" + jarFile,\n+                \"-p\", TESTAPP_CLASSES,\n+                \"-cp\", TESTFSP_CLASSES,\n+                \"-m\", TESTAPP + \"\/\" + TESTAPP_MAIN);\n@@ -168,1 +208,1 @@\n-     * Returns the directory containing the classes for module \"m\".\n+     * Returns the directory containing the classes for the given module.\n@@ -170,1 +210,1 @@\n-    private String moduleClasses() {\n+    private static String classes(String mn) {\n@@ -172,6 +212,6 @@\n-        for (String dir : mp.split(File.pathSeparator)) {\n-            Path m = Paths.get(dir, \"m\");\n-            if (Files.exists(m)) return m.toString();\n-        }\n-        fail();\n-        return null;\n+        return Arrays.stream(mp.split(File.pathSeparator))\n+                .map(e -> Path.of(e, mn))\n+                .filter(Files::isDirectory)\n+                .findAny()\n+                .map(Path::toString)\n+                .orElseThrow();\n@@ -181,1 +221,1 @@\n-     * Creates a modular JAR containing module \"m\".\n+     * Returns a class path from the given paths.\n@@ -183,4 +223,2 @@\n-    private String createModularJar() throws Exception {\n-        Path dir = Paths.get(moduleClasses());\n-        Path jar = createJarFile(dir);\n-        return jar.toString();\n+    private String ofClasspath(String... paths) {\n+        return String.join(File.pathSeparator, paths);\n@@ -190,1 +228,1 @@\n-     * Creates a JAR file containing the entries in the given file tree.\n+     * Creates a JAR file from the contains of the given directory.\n@@ -192,4 +230,8 @@\n-    private Path createJarFile(Path dir) throws Exception {\n-        Path jar = createTempDirectory(\"tmp\").resolve(\"m.jar\");\n-        String[] args = { \"--create\", \"--file=\" + jar, \"-C\", dir.toString(), \".\" };\n-        int ret = JAR_TOOL.run(System.out, System.out, args);\n+    private String createJar(String jar, String dir) throws IOException {\n+        List<String> args = new ArrayList<>();\n+        args.add(\"--create\");\n+        args.add(\"--file=\" + jar);\n+        args.add(\"-C\");\n+        args.add(dir);\n+        args.add(\".\");\n+        int ret = JAR_TOOL.run(System.err, System.err, args.toArray(new String[0]));\n@@ -201,1 +243,1 @@\n-     * Invokes the java launcher with the given arguments, returning the exit code.\n+     * Create a temporary directory with the given prefix in the current directory.\n@@ -203,5 +245,12 @@\n-    private int exec(String... args) throws Exception {\n-       return ProcessTools.executeTestJava(args)\n-                .outputTo(System.out)\n-                .errorTo(System.out)\n-                .getExitValue();\n+    private static Path createTempDirectory(String prefix) throws IOException {\n+        return Files.createTempDirectory(Path.of(\".\"), prefix);\n+    }\n+\n+    \/**\n+     * Invokes the java launcher with the given arguments, throws if the non-0 is returned.\n+     *\/\n+    private void exec(String... args) throws Exception {\n+        ProcessTools.executeTestJava(args)\n+                .outputTo(System.err)\n+                .errorTo(System.err)\n+                .shouldHaveExitValue(0);\n","filename":"test\/jdk\/java\/nio\/file\/spi\/SetDefaultProvider.java","additions":157,"deletions":108,"binary":false,"changes":265,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n- * @build TestDelegation TestProvider\n- * @run testng\/othervm  TestDelegation\n+ * @compile testfsp\/testfsp\/TestProvider.java\n+ * @run testng TestDelegation\n@@ -58,1 +58,0 @@\n-\n@@ -185,1 +184,1 @@\n-    static class MyProvider extends TestProvider {\n+    static class MyProvider extends testfsp.TestProvider {\n","filename":"test\/jdk\/java\/nio\/file\/spi\/TestDelegation.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-module m {\n+module testapp {\n","filename":"test\/jdk\/java\/nio\/file\/spi\/testapp\/module-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/jdk\/java\/nio\/file\/spi\/m\/module-info.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package p;\n+package testapp;\n","filename":"test\/jdk\/java\/nio\/file\/spi\/testapp\/testapp\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/jdk\/java\/nio\/file\/spi\/m\/p\/Main.java","status":"renamed"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module testfsp {\n+    exports testfsp to java.base;\n+}\n","filename":"test\/jdk\/java\/nio\/file\/spi\/testfsp\/module-info.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+package testfsp;\n+\n","filename":"test\/jdk\/java\/nio\/file\/spi\/testfsp\/testfsp\/TestProvider.java","additions":3,"deletions":1,"binary":false,"changes":4,"previous_filename":"test\/jdk\/java\/nio\/file\/spi\/TestProvider.java","status":"renamed"},{"patch":"@@ -99,0 +99,1 @@\n+    @Test\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/TCKZoneId.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+        int drained = 1;\n+        while (drained < appData.length) {\n+            drained += sslIS.read(appData, drained, appData.length - drained);\n+        }\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSocket\/Tls13PacketSize.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n@@ -37,1 +39,2 @@\n-import java.awt.event.MouseEvent;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -45,0 +48,1 @@\n+    private static final CountDownLatch mousePressLatch = new CountDownLatch(1);\n@@ -55,0 +59,3 @@\n+            if (!mousePressLatch.await(2, TimeUnit.SECONDS)) {\n+                throw new RuntimeException(\"Timed out waiting for mouse press\");\n+            }\n@@ -84,0 +91,5 @@\n+        sbar.addMouseListener(new MouseAdapter() {\n+            public void mousePressed(MouseEvent e) {\n+                mousePressLatch.countDown();\n+            }\n+        });\n","filename":"test\/jdk\/javax\/swing\/JScrollBar\/4865918\/bug4865918.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+        int caret;\n@@ -64,0 +65,1 @@\n+            robo.delay(250);\n@@ -67,0 +69,1 @@\n+            robo.delay(250);\n@@ -68,14 +71,55 @@\n-            passed &= moveCaret(true) == 1;\n-            passed &= moveCaret(true) == 5;\n-            passed &= moveCaret(true) == 8;\n-            passed &= moveCaret(true) == 9;\n-            passed &= moveCaret(true) == 13;\n-            passed &= moveCaret(true) == 16;\n-            passed &= moveCaret(true) == 17;\n-            passed &= moveCaret(false) == 16;\n-            passed &= moveCaret(false) == 13;\n-            passed &= moveCaret(false) == 9;\n-            passed &= moveCaret(false) == 8;\n-            passed &= moveCaret(false) == 5;\n-            passed &= moveCaret(false) == 1;\n-            passed &= moveCaret(false) == 0;\n+            passed &= (caret = moveCaret(true)) == 1;\n+            System.out.println(\" passed \" + passed +\n+                               \" Expected position 1 actual position \" + caret);\n+\n+            passed &= (caret = moveCaret(true)) == 5;\n+            System.out.println(\" passed \" + passed +\n+                               \" Expected position 5 actual position \" + caret);\n+\n+            passed &= (caret = moveCaret(true)) == 8;\n+            System.out.println(\" passed \" + passed +\n+                               \" Expected position 8 actual position \" + caret);\n+\n+            passed &= (caret = moveCaret(true)) == 9;\n+            System.out.println(\" passed \" + passed +\n+                               \" Expected position 9 actual position \" + caret);\n+\n+            passed &= (caret = moveCaret(true)) == 13;\n+            System.out.println(\" passed \" + passed +\n+                               \" Expected position 13 actual position \" + caret);\n+\n+            passed &= (caret = moveCaret(true)) == 16;\n+            System.out.println(\" passed \" + passed +\n+                               \" Expected position 16 actual position \" + caret);\n+\n+            passed &= (caret = moveCaret(true)) == 17;\n+            System.out.println(\" passed \" + passed +\n+                               \" Expected position 17 actual position \" + caret);\n+\n+            passed &= (caret = moveCaret(false)) == 16;\n+            System.out.println(\" passed \" + passed +\n+                               \" Expected position 16 actual position \" + caret);\n+\n+            passed &= (caret = moveCaret(false)) == 13;\n+            System.out.println(\" passed \" + passed +\n+                               \" Expected position 13 actual position \" + caret);\n+\n+            passed &= (caret = moveCaret(false)) == 9;\n+            System.out.println(\" passed \" + passed +\n+                               \" Expected position 9 actual position \" + caret);\n+\n+            passed &= (caret = moveCaret(false)) == 8;\n+            System.out.println(\" passed \" + passed +\n+                               \" Expected position 8 actual position \" + caret);\n+\n+            passed &= (caret = moveCaret(false)) == 5;\n+            System.out.println(\" passed \" + passed +\n+                               \" Expected position 5 actual position \" + caret);\n+\n+            passed &= (caret = moveCaret(false)) == 1;\n+            System.out.println(\" passed \" + passed +\n+                               \" Expected position 1 actual position \" + caret);\n+\n+            passed &= (caret = moveCaret(false)) == 0;\n+            System.out.println(\" passed \" + passed +\n+                               \" Expected position 0 actual position \" + caret);\n@@ -101,0 +145,1 @@\n+        robo.delay(250);\n","filename":"test\/jdk\/javax\/swing\/text\/DefaultEditorKit\/4278839\/bug4278839.java","additions":59,"deletions":14,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -3915,0 +3915,178 @@\n+    static byte UMINReduce(byte[] a, int idx) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (byte) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMINReduceAll(byte[] a) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMINReduceByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Byte128VectorTests::UMINReduce, Byte128VectorTests::UMINReduceAll);\n+    }\n+\n+    static byte UMINReduceMasked(byte[] a, int idx, boolean[] mask) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMINReduceAllMasked(byte[] a, boolean[] mask) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void UMINReduceByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Byte128VectorTests::UMINReduceMasked, Byte128VectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static byte UMAXReduce(byte[] a, int idx) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (byte) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMAXReduceAll(byte[] a) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMAXReduceByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Byte128VectorTests::UMAXReduce, Byte128VectorTests::UMAXReduceAll);\n+    }\n+\n+    static byte UMAXReduceMasked(byte[] a, int idx, boolean[] mask) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMAXReduceAllMasked(byte[] a, boolean[] mask) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void UMAXReduceByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Byte128VectorTests::UMAXReduceMasked, Byte128VectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3915,0 +3915,178 @@\n+    static byte UMINReduce(byte[] a, int idx) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (byte) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMINReduceAll(byte[] a) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMINReduceByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Byte256VectorTests::UMINReduce, Byte256VectorTests::UMINReduceAll);\n+    }\n+\n+    static byte UMINReduceMasked(byte[] a, int idx, boolean[] mask) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMINReduceAllMasked(byte[] a, boolean[] mask) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void UMINReduceByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Byte256VectorTests::UMINReduceMasked, Byte256VectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static byte UMAXReduce(byte[] a, int idx) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (byte) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMAXReduceAll(byte[] a) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMAXReduceByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Byte256VectorTests::UMAXReduce, Byte256VectorTests::UMAXReduceAll);\n+    }\n+\n+    static byte UMAXReduceMasked(byte[] a, int idx, boolean[] mask) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMAXReduceAllMasked(byte[] a, boolean[] mask) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void UMAXReduceByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Byte256VectorTests::UMAXReduceMasked, Byte256VectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3915,0 +3915,178 @@\n+    static byte UMINReduce(byte[] a, int idx) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (byte) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMINReduceAll(byte[] a) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMINReduceByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Byte512VectorTests::UMINReduce, Byte512VectorTests::UMINReduceAll);\n+    }\n+\n+    static byte UMINReduceMasked(byte[] a, int idx, boolean[] mask) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMINReduceAllMasked(byte[] a, boolean[] mask) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void UMINReduceByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Byte512VectorTests::UMINReduceMasked, Byte512VectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static byte UMAXReduce(byte[] a, int idx) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (byte) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMAXReduceAll(byte[] a) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMAXReduceByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Byte512VectorTests::UMAXReduce, Byte512VectorTests::UMAXReduceAll);\n+    }\n+\n+    static byte UMAXReduceMasked(byte[] a, int idx, boolean[] mask) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMAXReduceAllMasked(byte[] a, boolean[] mask) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void UMAXReduceByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Byte512VectorTests::UMAXReduceMasked, Byte512VectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3915,0 +3915,178 @@\n+    static byte UMINReduce(byte[] a, int idx) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (byte) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMINReduceAll(byte[] a) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMINReduceByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Byte64VectorTests::UMINReduce, Byte64VectorTests::UMINReduceAll);\n+    }\n+\n+    static byte UMINReduceMasked(byte[] a, int idx, boolean[] mask) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMINReduceAllMasked(byte[] a, boolean[] mask) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void UMINReduceByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Byte64VectorTests::UMINReduceMasked, Byte64VectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static byte UMAXReduce(byte[] a, int idx) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (byte) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMAXReduceAll(byte[] a) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMAXReduceByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Byte64VectorTests::UMAXReduce, Byte64VectorTests::UMAXReduceAll);\n+    }\n+\n+    static byte UMAXReduceMasked(byte[] a, int idx, boolean[] mask) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMAXReduceAllMasked(byte[] a, boolean[] mask) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void UMAXReduceByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Byte64VectorTests::UMAXReduceMasked, Byte64VectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3920,0 +3920,178 @@\n+    static byte UMINReduce(byte[] a, int idx) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (byte) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMINReduceAll(byte[] a) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMINReduceByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                ByteMaxVectorTests::UMINReduce, ByteMaxVectorTests::UMINReduceAll);\n+    }\n+\n+    static byte UMINReduceMasked(byte[] a, int idx, boolean[] mask) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMINReduceAllMasked(byte[] a, boolean[] mask) {\n+        byte res = Byte.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void UMINReduceByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                ByteMaxVectorTests::UMINReduceMasked, ByteMaxVectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static byte UMAXReduce(byte[] a, int idx) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (byte) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMAXReduceAll(byte[] a) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMAXReduceByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                ByteMaxVectorTests::UMAXReduce, ByteMaxVectorTests::UMAXReduceAll);\n+    }\n+\n+    static byte UMAXReduceMasked(byte[] a, int idx, boolean[] mask) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (byte) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static byte UMAXReduceAllMasked(byte[] a, boolean[] mask) {\n+        byte res = Byte.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (byte) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void UMAXReduceByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                ByteMaxVectorTests::UMAXReduceMasked, ByteMaxVectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3959,0 +3959,178 @@\n+    static int UMINReduce(int[] a, int idx) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (int) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMINReduceAll(int[] a) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMINReduceInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Int128VectorTests::UMINReduce, Int128VectorTests::UMINReduceAll);\n+    }\n+\n+    static int UMINReduceMasked(int[] a, int idx, boolean[] mask) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (int) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMINReduceAllMasked(int[] a, boolean[] mask) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void UMINReduceInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Int128VectorTests::UMINReduceMasked, Int128VectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static int UMAXReduce(int[] a, int idx) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (int) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMAXReduceAll(int[] a) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMAXReduceInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Int128VectorTests::UMAXReduce, Int128VectorTests::UMAXReduceAll);\n+    }\n+\n+    static int UMAXReduceMasked(int[] a, int idx, boolean[] mask) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (int) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMAXReduceAllMasked(int[] a, boolean[] mask) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void UMAXReduceInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Int128VectorTests::UMAXReduceMasked, Int128VectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3959,0 +3959,178 @@\n+    static int UMINReduce(int[] a, int idx) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (int) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMINReduceAll(int[] a) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMINReduceInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Int256VectorTests::UMINReduce, Int256VectorTests::UMINReduceAll);\n+    }\n+\n+    static int UMINReduceMasked(int[] a, int idx, boolean[] mask) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (int) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMINReduceAllMasked(int[] a, boolean[] mask) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void UMINReduceInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Int256VectorTests::UMINReduceMasked, Int256VectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static int UMAXReduce(int[] a, int idx) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (int) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMAXReduceAll(int[] a) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMAXReduceInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Int256VectorTests::UMAXReduce, Int256VectorTests::UMAXReduceAll);\n+    }\n+\n+    static int UMAXReduceMasked(int[] a, int idx, boolean[] mask) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (int) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMAXReduceAllMasked(int[] a, boolean[] mask) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void UMAXReduceInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Int256VectorTests::UMAXReduceMasked, Int256VectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3959,0 +3959,178 @@\n+    static int UMINReduce(int[] a, int idx) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (int) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMINReduceAll(int[] a) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMINReduceInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Int512VectorTests::UMINReduce, Int512VectorTests::UMINReduceAll);\n+    }\n+\n+    static int UMINReduceMasked(int[] a, int idx, boolean[] mask) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (int) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMINReduceAllMasked(int[] a, boolean[] mask) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void UMINReduceInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Int512VectorTests::UMINReduceMasked, Int512VectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static int UMAXReduce(int[] a, int idx) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (int) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMAXReduceAll(int[] a) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMAXReduceInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Int512VectorTests::UMAXReduce, Int512VectorTests::UMAXReduceAll);\n+    }\n+\n+    static int UMAXReduceMasked(int[] a, int idx, boolean[] mask) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (int) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMAXReduceAllMasked(int[] a, boolean[] mask) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void UMAXReduceInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Int512VectorTests::UMAXReduceMasked, Int512VectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3959,0 +3959,178 @@\n+    static int UMINReduce(int[] a, int idx) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (int) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMINReduceAll(int[] a) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMINReduceInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Int64VectorTests::UMINReduce, Int64VectorTests::UMINReduceAll);\n+    }\n+\n+    static int UMINReduceMasked(int[] a, int idx, boolean[] mask) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (int) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMINReduceAllMasked(int[] a, boolean[] mask) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void UMINReduceInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Int64VectorTests::UMINReduceMasked, Int64VectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static int UMAXReduce(int[] a, int idx) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (int) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMAXReduceAll(int[] a) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMAXReduceInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Int64VectorTests::UMAXReduce, Int64VectorTests::UMAXReduceAll);\n+    }\n+\n+    static int UMAXReduceMasked(int[] a, int idx, boolean[] mask) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (int) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMAXReduceAllMasked(int[] a, boolean[] mask) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void UMAXReduceInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Int64VectorTests::UMAXReduceMasked, Int64VectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3964,0 +3964,178 @@\n+    static int UMINReduce(int[] a, int idx) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (int) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMINReduceAll(int[] a) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMINReduceIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                IntMaxVectorTests::UMINReduce, IntMaxVectorTests::UMINReduceAll);\n+    }\n+\n+    static int UMINReduceMasked(int[] a, int idx, boolean[] mask) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (int) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMINReduceAllMasked(int[] a, boolean[] mask) {\n+        int res = Integer.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void UMINReduceIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                IntMaxVectorTests::UMINReduceMasked, IntMaxVectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static int UMAXReduce(int[] a, int idx) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (int) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMAXReduceAll(int[] a) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMAXReduceIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                IntMaxVectorTests::UMAXReduce, IntMaxVectorTests::UMAXReduceAll);\n+    }\n+\n+    static int UMAXReduceMasked(int[] a, int idx, boolean[] mask) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (int) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static int UMAXReduceAllMasked(int[] a, boolean[] mask) {\n+        int res = Integer.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (int) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void UMAXReduceIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                IntMaxVectorTests::UMAXReduceMasked, IntMaxVectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3981,0 +3981,178 @@\n+    static long UMINReduce(long[] a, int idx) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (long) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMINReduceAll(long[] a) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMINReduceLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Long128VectorTests::UMINReduce, Long128VectorTests::UMINReduceAll);\n+    }\n+\n+    static long UMINReduceMasked(long[] a, int idx, boolean[] mask) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (long) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMINReduceAllMasked(long[] a, boolean[] mask) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void UMINReduceLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Long128VectorTests::UMINReduceMasked, Long128VectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static long UMAXReduce(long[] a, int idx) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (long) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMAXReduceAll(long[] a) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMAXReduceLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Long128VectorTests::UMAXReduce, Long128VectorTests::UMAXReduceAll);\n+    }\n+\n+    static long UMAXReduceMasked(long[] a, int idx, boolean[] mask) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (long) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMAXReduceAllMasked(long[] a, boolean[] mask) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void UMAXReduceLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Long128VectorTests::UMAXReduceMasked, Long128VectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3981,0 +3981,178 @@\n+    static long UMINReduce(long[] a, int idx) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (long) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMINReduceAll(long[] a) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMINReduceLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Long256VectorTests::UMINReduce, Long256VectorTests::UMINReduceAll);\n+    }\n+\n+    static long UMINReduceMasked(long[] a, int idx, boolean[] mask) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (long) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMINReduceAllMasked(long[] a, boolean[] mask) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void UMINReduceLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Long256VectorTests::UMINReduceMasked, Long256VectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static long UMAXReduce(long[] a, int idx) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (long) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMAXReduceAll(long[] a) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMAXReduceLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Long256VectorTests::UMAXReduce, Long256VectorTests::UMAXReduceAll);\n+    }\n+\n+    static long UMAXReduceMasked(long[] a, int idx, boolean[] mask) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (long) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMAXReduceAllMasked(long[] a, boolean[] mask) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void UMAXReduceLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Long256VectorTests::UMAXReduceMasked, Long256VectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3981,0 +3981,178 @@\n+    static long UMINReduce(long[] a, int idx) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (long) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMINReduceAll(long[] a) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMINReduceLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Long512VectorTests::UMINReduce, Long512VectorTests::UMINReduceAll);\n+    }\n+\n+    static long UMINReduceMasked(long[] a, int idx, boolean[] mask) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (long) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMINReduceAllMasked(long[] a, boolean[] mask) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void UMINReduceLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Long512VectorTests::UMINReduceMasked, Long512VectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static long UMAXReduce(long[] a, int idx) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (long) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMAXReduceAll(long[] a) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMAXReduceLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Long512VectorTests::UMAXReduce, Long512VectorTests::UMAXReduceAll);\n+    }\n+\n+    static long UMAXReduceMasked(long[] a, int idx, boolean[] mask) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (long) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMAXReduceAllMasked(long[] a, boolean[] mask) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void UMAXReduceLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Long512VectorTests::UMAXReduceMasked, Long512VectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3981,0 +3981,178 @@\n+    static long UMINReduce(long[] a, int idx) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (long) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMINReduceAll(long[] a) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMINReduceLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Long64VectorTests::UMINReduce, Long64VectorTests::UMINReduceAll);\n+    }\n+\n+    static long UMINReduceMasked(long[] a, int idx, boolean[] mask) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (long) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMINReduceAllMasked(long[] a, boolean[] mask) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void UMINReduceLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Long64VectorTests::UMINReduceMasked, Long64VectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static long UMAXReduce(long[] a, int idx) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (long) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMAXReduceAll(long[] a) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMAXReduceLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Long64VectorTests::UMAXReduce, Long64VectorTests::UMAXReduceAll);\n+    }\n+\n+    static long UMAXReduceMasked(long[] a, int idx, boolean[] mask) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (long) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMAXReduceAllMasked(long[] a, boolean[] mask) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void UMAXReduceLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Long64VectorTests::UMAXReduceMasked, Long64VectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3986,0 +3986,178 @@\n+    static long UMINReduce(long[] a, int idx) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (long) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMINReduceAll(long[] a) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMINReduceLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                LongMaxVectorTests::UMINReduce, LongMaxVectorTests::UMINReduceAll);\n+    }\n+\n+    static long UMINReduceMasked(long[] a, int idx, boolean[] mask) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (long) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMINReduceAllMasked(long[] a, boolean[] mask) {\n+        long res = Long.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void UMINReduceLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                LongMaxVectorTests::UMINReduceMasked, LongMaxVectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static long UMAXReduce(long[] a, int idx) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (long) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMAXReduceAll(long[] a) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMAXReduceLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                LongMaxVectorTests::UMAXReduce, LongMaxVectorTests::UMAXReduceAll);\n+    }\n+\n+    static long UMAXReduceMasked(long[] a, int idx, boolean[] mask) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (long) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static long UMAXReduceAllMasked(long[] a, boolean[] mask) {\n+        long res = Long.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (long) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void UMAXReduceLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                LongMaxVectorTests::UMAXReduceMasked, LongMaxVectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3906,0 +3906,178 @@\n+    static short UMINReduce(short[] a, int idx) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (short) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMINReduceAll(short[] a) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMINReduceShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Short128VectorTests::UMINReduce, Short128VectorTests::UMINReduceAll);\n+    }\n+\n+    static short UMINReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (short) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMINReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void UMINReduceShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Short128VectorTests::UMINReduceMasked, Short128VectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static short UMAXReduce(short[] a, int idx) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (short) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMAXReduceAll(short[] a) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMAXReduceShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Short128VectorTests::UMAXReduce, Short128VectorTests::UMAXReduceAll);\n+    }\n+\n+    static short UMAXReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (short) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMAXReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void UMAXReduceShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Short128VectorTests::UMAXReduceMasked, Short128VectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3906,0 +3906,178 @@\n+    static short UMINReduce(short[] a, int idx) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (short) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMINReduceAll(short[] a) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMINReduceShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Short256VectorTests::UMINReduce, Short256VectorTests::UMINReduceAll);\n+    }\n+\n+    static short UMINReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (short) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMINReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void UMINReduceShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Short256VectorTests::UMINReduceMasked, Short256VectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static short UMAXReduce(short[] a, int idx) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (short) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMAXReduceAll(short[] a) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMAXReduceShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Short256VectorTests::UMAXReduce, Short256VectorTests::UMAXReduceAll);\n+    }\n+\n+    static short UMAXReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (short) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMAXReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void UMAXReduceShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Short256VectorTests::UMAXReduceMasked, Short256VectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3906,0 +3906,178 @@\n+    static short UMINReduce(short[] a, int idx) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (short) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMINReduceAll(short[] a) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMINReduceShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Short512VectorTests::UMINReduce, Short512VectorTests::UMINReduceAll);\n+    }\n+\n+    static short UMINReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (short) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMINReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void UMINReduceShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Short512VectorTests::UMINReduceMasked, Short512VectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static short UMAXReduce(short[] a, int idx) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (short) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMAXReduceAll(short[] a) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMAXReduceShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Short512VectorTests::UMAXReduce, Short512VectorTests::UMAXReduceAll);\n+    }\n+\n+    static short UMAXReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (short) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMAXReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void UMAXReduceShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Short512VectorTests::UMAXReduceMasked, Short512VectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3906,0 +3906,178 @@\n+    static short UMINReduce(short[] a, int idx) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (short) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMINReduceAll(short[] a) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMINReduceShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Short64VectorTests::UMINReduce, Short64VectorTests::UMINReduceAll);\n+    }\n+\n+    static short UMINReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (short) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMINReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void UMINReduceShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Short64VectorTests::UMINReduceMasked, Short64VectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static short UMAXReduce(short[] a, int idx) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (short) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMAXReduceAll(short[] a) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMAXReduceShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                Short64VectorTests::UMAXReduce, Short64VectorTests::UMAXReduceAll);\n+    }\n+\n+    static short UMAXReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (short) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMAXReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void UMAXReduceShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                Short64VectorTests::UMAXReduceMasked, Short64VectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -3911,0 +3911,178 @@\n+    static short UMINReduce(short[] a, int idx) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (short) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMINReduceAll(short[] a) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.minUnsigned(res, UMINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMINReduceShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                ShortMaxVectorTests::UMINReduce, ShortMaxVectorTests::UMINReduceAll);\n+    }\n+\n+    static short UMINReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (short) VectorMath.minUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMINReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = Short.MAX_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.minUnsigned(res, UMINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void UMINReduceShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                ShortMaxVectorTests::UMINReduceMasked, ShortMaxVectorTests::UMINReduceAllMasked);\n+    }\n+\n+    static short UMAXReduce(short[] a, int idx) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = (short) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMAXReduceAll(short[] a) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.maxUnsigned(res, UMAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMAXReduceShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                ShortMaxVectorTests::UMAXReduce, ShortMaxVectorTests::UMAXReduceAll);\n+    }\n+\n+    static short UMAXReduceMasked(short[] a, int idx, boolean[] mask) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = (short) VectorMath.maxUnsigned(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static short UMAXReduceAllMasked(short[] a, boolean[] mask) {\n+        short res = Short.MIN_VALUE;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = (short) VectorMath.maxUnsigned(res, UMAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void UMAXReduceShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                ShortMaxVectorTests::UMAXReduceMasked, ShortMaxVectorTests::UMAXReduceAllMasked);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -487,0 +487,2 @@\n+gen_reduction_op_func \"UMIN\" \"(\\$type\\$) VectorMath.minUnsigned\" \"BITWISE\" \"\\$Wideboxtype\\$.\\$MaxValue\\$\"\n+gen_reduction_op_func \"UMAX\" \"(\\$type\\$) VectorMath.maxUnsigned\" \"BITWISE\" \"\\$Wideboxtype\\$.\\$MinValue\\$\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestSanityDefault.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    public MulticastSocket connectWithTimeout(int msTimeOut) throws IOException {\n+    public MulticastSocket connectWithTimeout(int msTimeout) throws IOException {\n@@ -59,1 +59,1 @@\n-        socket.setSoTimeout(msTimeOut);\n+        socket.setSoTimeout(msTimeout);\n","filename":"test\/jdk\/sun\/management\/jdp\/ClientConnection.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    private static final int MAX_RETRY_ATTEMPTS = 10;\n+    private static final int MAX_PORT_RETRY_ATTEMPTS = 10;\n@@ -57,1 +57,1 @@\n-                if (retries < MAX_RETRY_ATTEMPTS) {\n+                if (retries < MAX_PORT_RETRY_ATTEMPTS) {\n@@ -80,4 +80,0 @@\n-\n-    protected OutputAnalyzer getProcessOutpoutAnalyzer() {\n-        return output;\n-    }\n","filename":"test\/jdk\/sun\/management\/jdp\/DynamicLauncher.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-                \"-Djava.util.logging.SimpleFormatter.format='%1$tF %1$tT %4$-7s %5$s %n'\",\n+                \"-Djava.util.logging.SimpleFormatter.format=%1$tF %1$tT %4$-7s %5$s %n\",\n","filename":"test\/jdk\/sun\/management\/jdp\/JdpDefaultsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-                \"-Djava.util.logging.SimpleFormatter.format='%1$tF %1$tT %4$-7s %5$s %n'\",\n+                \"-Djava.util.logging.SimpleFormatter.format=%1$tF %1$tT %4$-7s %5$s %n\",\n","filename":"test\/jdk\/sun\/management\/jdp\/JdpJmxRemoteDynamicPortTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-    protected void onSocketTimeOut(SocketTimeoutException e) throws Exception {\n+    protected void onSocketTimeout(SocketTimeoutException e) throws Exception {\n","filename":"test\/jdk\/sun\/management\/jdp\/JdpJmxRemoteDynamicPortTestCase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-                \"-Djava.util.logging.SimpleFormatter.format='%1$tF %1$tT %4$-7s %5$s %n'\",\n+                \"-Djava.util.logging.SimpleFormatter.format=%1$tF %1$tT %4$-7s %5$s %n\",\n","filename":"test\/jdk\/sun\/management\/jdp\/JdpOffTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-    protected void onSocketTimeOut(SocketTimeoutException e) throws Exception {\n-        log.fine(\"No packages received. Test passed!\");\n+    protected void onSocketTimeout(SocketTimeoutException e) throws Exception {\n+        log.fine(\"No packets received. Test passed!\");\n@@ -80,1 +80,1 @@\n-     * The test should stop after the socket has timed out. See onSocketTimeOut {@link}.\n+     * The test should stop after the socket has timed out. See onSocketTimeout {@link}.\n","filename":"test\/jdk\/sun\/management\/jdp\/JdpOffTestCase.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-     * It is set to wait for 10 times the defined pause between Jdp packet. See JdpOnTestCase.TIME_OUT_FACTOR.\n+     * It is set to wait for a multiple of the defined pause between Jdp packets. See JdpTestCase.TIME_OUT_FACTOR.\n@@ -70,1 +70,1 @@\n-    protected void onSocketTimeOut(SocketTimeoutException e) throws Exception {\n+    protected void onSocketTimeout(SocketTimeoutException e) throws Exception {\n","filename":"test\/jdk\/sun\/management\/jdp\/JdpOnTestCase.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-                \"-Djava.util.logging.SimpleFormatter.format='%1$tF %1$tT %4$-7s %5$s %n'\",\n+                \"-Djava.util.logging.SimpleFormatter.format=%1$tF %1$tT %4$-7s %5$s %n\",\n","filename":"test\/jdk\/sun\/management\/jdp\/JdpSpecificAddressTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,5 @@\n+\n+    private static final int MAGIC = 0xC0FFEE42;              \/\/ Jdp magic number.\n+    private static final int BUFFER_LENGTH = 64 * 1024;       \/\/ max UDP size, except for IPv6 jumbograms.\n+    private static final int TIME_OUT_FACTOR = 10;            \/\/ Socket times out after a multiple of the jdp pause.\n+\n@@ -44,3 +49,0 @@\n-    final int MAGIC = 0xC0FFEE42;                       \/\/ Jdp magic number.\n-    private static final int BUFFER_LENGTH = 64 * 1024;   \/\/ max UDP size, except for IPv6 jumbograms.\n-    private final int TIME_OUT_FACTOR = 10;             \/\/ Socket times out after 10 times the jdp pause.\n@@ -77,1 +79,1 @@\n-                onSocketTimeOut(e);\n+                onSocketTimeout(e);\n@@ -120,1 +122,1 @@\n-    abstract protected void onSocketTimeOut(SocketTimeoutException e) throws Exception;\n+    abstract protected void onSocketTimeout(SocketTimeoutException e) throws Exception;\n@@ -159,1 +161,1 @@\n-     * This timeout (12 times)is slightly longer than the socket timeout (10 times) on purpose.\n+     * This timeout (12 times) is slightly longer than the socket timeout (10 times) on purpose.\n","filename":"test\/jdk\/sun\/management\/jdp\/JdpTestCase.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-        Asserts.assertEqualsByteArray(secret, expectedSecret, \"Incorrect secret value\");\n+        Asserts.assertEqualsByteArray(expectedSecret, secret, \"Incorrect secret value\");\n@@ -144,1 +144,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/jdk\/sun\/security\/ec\/ECDHPrimitive.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-                Asserts.assertEqualsByteArray(pk, toByteArray(c.get(\"pk\").asString()));\n-                Asserts.assertEqualsByteArray(sk, toByteArray(c.get(\"sk\").asString()));\n+                Asserts.assertEqualsByteArray(toByteArray(c.get(\"pk\").asString()), pk);\n+                Asserts.assertEqualsByteArray(toByteArray(c.get(\"sk\").asString()), sk);\n@@ -107,1 +107,1 @@\n-                        sig, toByteArray(c.get(\"signature\").asString()));\n+                        toByteArray(c.get(\"signature\").asString()), sig);\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/ML_DSA_Test.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,2 +73,2 @@\n-                Asserts.assertEqualsByteArray(pk, toByteArray(c.get(\"ek\").asString()));\n-                Asserts.assertEqualsByteArray(sk, toByteArray(c.get(\"dk\").asString()));\n+                Asserts.assertEqualsByteArray(toByteArray(c.get(\"ek\").asString()), pk);\n+                Asserts.assertEqualsByteArray(toByteArray(c.get(\"dk\").asString()), sk);\n@@ -100,1 +100,1 @@\n-                            enc.encapsulation(), toByteArray(c.get(\"c\").asString()));\n+                            toByteArray(c.get(\"c\").asString()), enc.encapsulation());\n@@ -102,1 +102,1 @@\n-                            enc.key().getEncoded(), toByteArray(c.get(\"k\").asString()));\n+                            toByteArray(c.get(\"k\").asString()), enc.key().getEncoded());\n@@ -115,1 +115,1 @@\n-                    Asserts.assertEqualsByteArray(k.getEncoded(), toByteArray(c.get(\"k\").asString()));\n+                    Asserts.assertEqualsByteArray(toByteArray(c.get(\"k\").asString()), k.getEncoded());\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/ML_KEM_Test.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n-                            Asserts.assertEqualsByteArray(md.digest(msg),\n-                                    toByteArray(c.get(\"md\").asString()));\n+                            Asserts.assertEqualsByteArray(\n+                                    toByteArray(c.get(\"md\").asString()), md.digest(msg));\n@@ -73,2 +73,2 @@\n-                                    Asserts.assertEqualsByteArray(MD,\n-                                            toByteArray(r.get(\"md\").asString()));\n+                                    Asserts.assertEqualsByteArray(\n+                                            toByteArray(r.get(\"md\").asString()), MD);\n@@ -91,2 +91,2 @@\n-                                    Asserts.assertEqualsByteArray(MD,\n-                                            toByteArray(r.get(\"md\").asString()));\n+                                    Asserts.assertEqualsByteArray(\n+                                            toByteArray(r.get(\"md\").asString()), MD);\n@@ -113,2 +113,2 @@\n-                        Asserts.assertEqualsByteArray(md.digest(),\n-                                toByteArray(c.get(\"md\").asString()));\n+                        Asserts.assertEqualsByteArray(\n+                                toByteArray(c.get(\"md\").asString()), md.digest());\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/SHA_Test.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,1 @@\n+import jdk.security.jarsigner.JarSigner;\n@@ -1433,1 +1434,3 @@\n-                    : jdkInfo.majorVersion >= 20 ? \"SHA-384\" : \"SHA-256\";\n+                    : jdkInfo.majorVersion >= 20\n+                        ? JarSigner.Builder.getDefaultDigestAlgorithm()\n+                        : \"SHA-256\";\n@@ -1442,1 +1445,5 @@\n-            return tsaDigestAlgorithm != null ? tsaDigestAlgorithm : \"SHA-256\";\n+            return tsaDigestAlgorithm != null\n+                    ? tsaDigestAlgorithm\n+                    : jdkInfo.majorVersion >= 20\n+                        ? JarSigner.Builder.getDefaultDigestAlgorithm()\n+                        : \"SHA-256\";\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/compatibility\/Compatibility.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-        CompilerUtils.compile(source, classes);\n+        CompilerUtils.compile(source, classes, \"--release\", \"8\");\n@@ -132,1 +132,1 @@\n-        CompilerUtils.compile(source, classes);\n+        CompilerUtils.compile(source, classes, \"--release\", \"9\");\n@@ -136,1 +136,1 @@\n-        CompilerUtils.compile(source, classes);\n+        CompilerUtils.compile(source, classes, \"--release\", \"10\");\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/multiRelease\/MVJarSigningTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.jar.JarFile;\n+import java.util.jar.JarOutputStream;\n+import java.util.jar.Manifest;\n+import java.util.zip.ZipEntry;\n+\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8345506\n+ * @summary verifies that the \"jar\" operations that are expected to work\n+ *          without the \"--file\" option work as expected\n+ * @library \/test\/lib\n+ * @run junit JarNoFileArgOperations\n+ *\/\n+public class JarNoFileArgOperations {\n+\n+    private static final Path SCRATCH_DIR = Path.of(\".\");\n+    private static final Path JAR_TOOL = Path.of(JDKToolFinder.getJDKTool(\"jar\")).toAbsolutePath();\n+    private static final String JAR_ENTRY_NAME = \"foobarhello.txt\";\n+\n+    private static Path SIMPLE_JAR;\n+\n+    private static void makeSimpleJar(final Path path) throws IOException {\n+        final Manifest manifest = new Manifest();\n+        manifest.getMainAttributes().putValue(\"Manifest-Version\", \"1.0\");\n+        try (OutputStream fos = Files.newOutputStream(path);\n+             JarOutputStream jaros = new JarOutputStream(fos, manifest)) {\n+            jaros.putNextEntry(new ZipEntry(JAR_ENTRY_NAME));\n+            jaros.write(\"foobar-8345506\".getBytes(US_ASCII));\n+            jaros.closeEntry();\n+        }\n+    }\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        final Path jarFile = Files.createTempFile(SCRATCH_DIR, \"8345506\", \".jar\");\n+        makeSimpleJar(jarFile);\n+        SIMPLE_JAR = jarFile;\n+        System.out.println(\"created JAR file \" + jarFile);\n+    }\n+\n+    \/*\n+     * Launches \"jar --validate\" by streaming the JAR file content through the \"jar\" tool\n+     * process' STDIN and expects that the command completes normally.\n+     *\/\n+    @Test\n+    public void testValidate() throws Exception {\n+        System.out.println(\"launching jar --validate\");\n+        final ProcessBuilder pb = new ProcessBuilder()\n+                .command(JAR_TOOL.toString(), \"--validate\")\n+                \/\/ stream the JAR file content to the jar command through the process' STDIN\n+                .redirectInput(SIMPLE_JAR.toFile());\n+        final OutputAnalyzer oa = ProcessTools.executeCommand(pb);\n+        oa.shouldHaveExitValue(0);\n+    }\n+\n+    \/*\n+     * Launches \"jar --list\" and \"jar -t\" by streaming the JAR file content through the \"jar\" tool\n+     * process' STDIN and expects that the command completes normally.\n+     *\/\n+    @Test\n+    public void testListing() throws Exception {\n+        for (String opt : new String[]{\"-t\", \"--list\"}) {\n+            final ProcessBuilder pb = new ProcessBuilder()\n+                    .command(JAR_TOOL.toString(), opt)\n+                    \/\/ stream the JAR file content to the jar command through the process' STDIN\n+                    .redirectInput(SIMPLE_JAR.toFile());\n+            final OutputAnalyzer oa = ProcessTools.executeCommand(pb);\n+            oa.shouldHaveExitValue(0);\n+            \/\/ verify the listing contained the JAR entry name\n+            oa.contains(JAR_ENTRY_NAME);\n+        }\n+    }\n+\n+    \/*\n+     * Launches \"jar --extract\" and \"jar -x\" by streaming the JAR file content through\n+     * the \"jar\" tool process' STDIN and expects that the command completes normally.\n+     *\/\n+    @Test\n+    public void testExtract() throws Exception {\n+        for (String opt : new String[]{\"-x\", \"--extract\"}) {\n+            final Path tmpDestDir = Files.createTempDirectory(SCRATCH_DIR, \"8345506\");\n+            final ProcessBuilder pb = new ProcessBuilder()\n+                    .command(JAR_TOOL.toString(), opt, \"--dir\", tmpDestDir.toString())\n+                    \/\/ stream the JAR file content to the jar command through the process' STDIN\n+                    .redirectInput(SIMPLE_JAR.toFile());\n+            final OutputAnalyzer oa = ProcessTools.executeCommand(pb);\n+            oa.shouldHaveExitValue(0);\n+            \/\/ verify the file content was extracted\n+            assertTrue(Files.exists(tmpDestDir.resolve(JAR_ENTRY_NAME)),\n+                    JAR_ENTRY_NAME + \" wasn't extracted to \" + tmpDestDir);\n+        }\n+    }\n+\n+    \/*\n+     * Launches \"jar --update\" and \"jar -u\" by streaming the JAR file content through\n+     * the \"jar\" tool process' STDIN and expects that the command completes normally.\n+     *\/\n+    @Test\n+    public void testUpdate() throws Exception {\n+        for (String opt : new String[]{\"-u\", \"--update\"}) {\n+            \/\/ the updated JAR will be written out to this file\n+            final Path destUpdatedJar = Files.createTempFile(SCRATCH_DIR, \"8345506\", \".jar\");\n+            \/\/ an arbitrary file that will be added to the JAR file as\n+            \/\/ part of the update operation\n+            final Path fileToAdd = Files.createTempFile(SCRATCH_DIR, \"8345506\", \".txt\");\n+            final String expectedNewEntry = fileToAdd.getFileName().toString();\n+            final ProcessBuilder pb = new ProcessBuilder()\n+                    .command(JAR_TOOL.toString(), opt, expectedNewEntry)\n+                    \/\/ stream the JAR file content to the jar command through the process' STDIN\n+                    .redirectInput(SIMPLE_JAR.toFile())\n+                    \/\/ redirect the updated JAR to a file so that its contents can be verified\n+                    \/\/ later\n+                    .redirectOutput(destUpdatedJar.toFile());\n+            final OutputAnalyzer oa = ProcessTools.executeProcess(pb);\n+            oa.shouldHaveExitValue(0);\n+            System.out.println(\"updated JAR file at \" + destUpdatedJar.toAbsolutePath());\n+            \/\/ verify, by listing the updated JAR file contents,\n+            \/\/ that the JAR file has been updated to include the new file\n+            try (final JarFile jar = new JarFile(destUpdatedJar.toFile())) {\n+                jar.stream()\n+                        .map(ZipEntry::getName)\n+                        .filter((name) -> name.equals(expectedNewEntry))\n+                        .findFirst()\n+                        .orElseThrow(\n+                                () -> new AssertionError(\"missing entry \" + expectedNewEntry\n+                                        + \" in updated JAR file \" + destUpdatedJar)\n+                        );\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jar\/JarNoFileArgOperations.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,1 @@\n+import java.util.ArrayList;\n@@ -83,1 +84,1 @@\n-        javac(source, destination);\n+        javac(source, destination, 8);\n@@ -88,1 +89,1 @@\n-        javac(source, destination);\n+        javac(source, destination, 9);\n@@ -95,7 +96,10 @@\n-    private void javac(Path source, Path destination) throws IOException {\n-        String[] args = Stream.concat(\n-                Stream.of(\"-d\", destination.toString()),\n-                Files.walk(source)\n-                        .map(Path::toString)\n-                        .filter(s -> s.endsWith(\".java\"))\n-        ).toArray(String[]::new);\n+    private void javac(Path source, Path destination, int release) throws IOException {\n+        ArrayList<Object> arguments = new ArrayList();\n+        arguments.add(\"-d\");\n+        arguments.add(destination);\n+        arguments.add(\"--release\");\n+        arguments.add(release);\n+        try (var stream = Files.walk(source)) {\n+            stream.map(Path::toString).filter(s -> s.endsWith(\".java\")).forEach(arguments::add);\n+        }\n+        String[] args = arguments.stream().map(Object::toString).toArray(String[]::new);\n@@ -113,2 +117,2 @@\n-        Files.walk(userdir, 1)\n-                .filter(p -> !p.equals(userdir))\n+        try (var stream = Files.walk(userdir, 1)) {\n+            stream.filter(p -> !p.equals(userdir))\n@@ -126,0 +130,1 @@\n+        }\n@@ -232,1 +237,1 @@\n-        javac(source, destination);\n+        javac(source, destination, 10);\n@@ -243,1 +248,1 @@\n-        javac(modinfo, Paths.get(\"test5\"));\n+        javac(modinfo, Paths.get(\"test5\"), 9);\n@@ -338,1 +343,1 @@\n-        javac(src, dst);\n+        javac(src, dst, 8);\n@@ -400,1 +405,1 @@\n-        javac(src, dst);\n+        javac(src, dst, 8);\n","filename":"test\/jdk\/tools\/jar\/mmrjar\/Basic.java","additions":21,"deletions":16,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,2 +85,2 @@\n-        compileTemplate(classes.resolve(\"base\"), base);\n-        compileTemplate(classes.resolve(\"v10\"), v10);\n+        compileTemplate(8, classes.resolve(\"base\"), base);\n+        compileTemplate(10, classes.resolve(\"v10\"), v10);\n@@ -138,2 +138,2 @@\n-        compileTemplate(classes.resolve(\"base\"), base);\n-        compileTemplate(classes.resolve(\"v10\"), v10);\n+        compileTemplate(8, classes.resolve(\"base\"), base);\n+        compileTemplate(10, classes.resolve(\"v10\"), v10);\n@@ -179,2 +179,2 @@\n-        compileTemplate(classes.resolve(\"base\"), base);\n-        compileTemplate(classes.resolve(\"v10\"), v10);\n+        compileTemplate(8, classes.resolve(\"base\"), base);\n+        compileTemplate(10, classes.resolve(\"v10\"), v10);\n@@ -211,1 +211,1 @@\n-    private void compileTemplate(Path classes, String template) throws Throwable {\n+    private void compileTemplate(int release, Path classes, String template) throws Throwable {\n@@ -216,1 +216,1 @@\n-        javac(classes, classSourceFile);\n+        javac(release, classes, classSourceFile);\n@@ -455,1 +455,1 @@\n-        javac(classes, sourceFiles);\n+        javac(9, classes, sourceFiles);\n","filename":"test\/jdk\/tools\/jar\/multiRelease\/ApiValidatorTest.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- # @bug 8186087 8196748 8212807\n+ # @bug 8186087 8196748 8212807 8268611\n@@ -129,1 +129,1 @@\n-        for (String release : List.of(\"10000\", \"09\", \"00010\", \"10\")) {\n+        for (String release : List.of(\"09\", \"00010\", \"10\")) {\n@@ -131,1 +131,1 @@\n-                    \"--release\", release, \"-C\", classes.resolve(\"v10\").toString(), \".\")\n+                    \"--release\", release, \"-C\", classes.resolve(\"v9\").toString(), \".\")\n@@ -210,0 +210,1 @@\n+        \/\/ 8268611: The following creates an invalid JAR, which gets deleted.\n@@ -214,16 +215,5 @@\n-                .shouldHaveExitValue(SUCCESS);\n-\n-        checkMultiRelease(jarfile, true);\n-\n-        names = Map.of(\n-                \"version\/Main.class\",\n-                new String[]{\"base\", \"version\", \"Main.class\"},\n-\n-                \"version\/Version.class\",\n-                new String[]{\"v9\", \"version\", \"Version.class\"},\n-\n-                \"META-INF\/versions\/9\/version\/Version.class\",\n-                new String[]{\"v10\", \"version\", \"Version.class\"}\n-        );\n-\n-        compare(jarfile, names);\n+                .shouldNotHaveExitValue(SUCCESS)\n+                .shouldContain(\"META-INF\/versions\/9\/version\/Version.class\")\n+                .shouldContain(\" has class file version 54,\")\n+                .shouldContain(\" but class file version 53 or less is required\")\n+                .shouldContain(\" to target release 9 of the Java Platform\");\n@@ -250,1 +240,1 @@\n-        javac(classes.resolve(\"v9\"), source.resolve(\"Version.java\"));\n+        javac(9, classes.resolve(\"v9\"), source.resolve(\"Version.java\"));\n@@ -272,1 +262,1 @@\n-        javac(classes.resolve(\"v9\"), source.resolve(\"Extra.java\"));\n+        javac(9, classes.resolve(\"v9\"), source.resolve(\"Extra.java\"));\n@@ -294,1 +284,1 @@\n-        javac(classes.resolve(\"v9\"), source.resolve(\"Extra.java\"));\n+        javac(9, classes.resolve(\"v9\"), source.resolve(\"Extra.java\"));\n@@ -316,1 +306,1 @@\n-        javac(classes.resolve(\"v9\"), source.resolve(\"Version.java\"));\n+        javac(9, classes.resolve(\"v9\"), source.resolve(\"Version.java\"));\n@@ -385,1 +375,1 @@\n-        javac(classes.resolve(\"base\"), source.resolve(\"Nested.java\"));\n+        javac(8, classes.resolve(\"base\"), source.resolve(\"Nested.java\"));\n@@ -389,1 +379,1 @@\n-        javac(classes.resolve(\"v9\"), source.resolve(\"Nested.java\"));\n+        javac(9, classes.resolve(\"v9\"), source.resolve(\"Nested.java\"));\n@@ -410,1 +400,1 @@\n-        javac(classes.resolve(\"base\"), source.resolve(\"Nested.java\"));\n+        javac(8, classes.resolve(\"base\"), source.resolve(\"Nested.java\"));\n@@ -417,1 +407,1 @@\n-        javac(classes.resolve(\"v9\"), source.resolve(\"Nested.java\"));\n+        javac(9, classes.resolve(\"v9\"), source.resolve(\"Nested.java\"));\n@@ -463,1 +453,1 @@\n-        javac(classes.resolve(\"base\"), source.resolve(\"Nested.java\"));\n+        javac(8, classes.resolve(\"base\"), source.resolve(\"Nested.java\"));\n@@ -467,1 +457,1 @@\n-        javac(classes.resolve(\"v9\"), source.resolve(\"Nested.java\"));\n+        javac(9, classes.resolve(\"v9\"), source.resolve(\"Nested.java\"));\n@@ -492,1 +482,1 @@\n-        javac(classes.resolve(\"base\"), source.resolve(\"Nested.java\"));\n+        javac(8, classes.resolve(\"base\"), source.resolve(\"Nested.java\"));\n@@ -496,1 +486,1 @@\n-        javac(classes.resolve(\"v10\"), source.resolve(\"Nested.java\"));\n+        javac(10, classes.resolve(\"v10\"), source.resolve(\"Nested.java\"));\n@@ -538,1 +528,1 @@\n-                \"--release\", \"9\", \"-C\", classes.resolve(\"v10\").toString(), \".\")\n+                \"--release\", \"9\", \"-C\", classes.resolve(\"v9\").toString(), \".\")\n","filename":"test\/jdk\/tools\/jar\/multiRelease\/Basic.java","additions":23,"deletions":33,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-        javac(base, source.resolve(\"Main.java\"), source.resolve(\"Version.java\"));\n+        javac(8, base, source.resolve(\"Main.java\"), source.resolve(\"Version.java\"));\n@@ -60,1 +60,1 @@\n-        javac(v9, source.resolve(\"Version.java\"));\n+        javac(9, v9, source.resolve(\"Version.java\"));\n@@ -65,1 +65,1 @@\n-        javac(v10, source.resolve(\"Version.java\"));\n+        javac(10, v10, source.resolve(\"Version.java\"));\n@@ -70,1 +70,1 @@\n-        javac(v10_1, source.resolve(\"Version.java\"));\n+        javac(10, v10_1, source.resolve(\"Version.java\"));\n","filename":"test\/jdk\/tools\/jar\/multiRelease\/Basic1.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        javac(classes, source.resolve(\"Main.java\"), source.resolve(\"Version.java\"));\n+        javac(8, classes, source.resolve(\"Main.java\"), source.resolve(\"Version.java\"));\n@@ -70,1 +70,1 @@\n-        javac(classes, source.resolve(\"Version.java\"));\n+        javac(9, classes, source.resolve(\"Version.java\"));\n@@ -75,1 +75,1 @@\n-        javac(classes, source.resolve(\"Version.java\"));\n+        javac(10, classes, source.resolve(\"Version.java\"));\n@@ -104,6 +104,1 @@\n-    void javac(Path dest, Path... sourceFiles) throws Throwable {\n-        javac(dest, List.of(), sourceFiles);\n-    }\n-\n-    void javac(Path dest, List<String> extraParameters, Path... sourceFiles) throws Throwable {\n-\n+    void javac(int release, Path dest, Path... sourceFiles) throws Throwable {\n@@ -115,0 +110,2 @@\n+        commands.add(\"--release\");\n+        commands.add(String.valueOf(release));\n@@ -117,4 +114,1 @@\n-        Stream.of(sourceFiles)\n-                .map(Object::toString)\n-                .forEach(x -> commands.add(x));\n-        commands.addAll(extraParameters);\n+        Stream.of(sourceFiles).map(Object::toString).forEach(commands::add);\n","filename":"test\/jdk\/tools\/jar\/multiRelease\/MRTestBase.java","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-        javac(classesDir, List.of(\"--release\", majorVersion), sourceFile);\n+        javac(Integer.parseInt(majorVersion), classesDir, sourceFile);\n","filename":"test\/jdk\/tools\/jar\/multiRelease\/VersionValidatorTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-                    lang.String)\"><code>testMethod(String)<\/code><\/a>.\"\"\",\n+                    lang.String)\"><code>TestClassInModuleTags.testMethod(String)<\/code><\/a>.\"\"\",\n@@ -895,1 +895,1 @@\n-                    Method(java.lang.String)\"><code>testMethod(String)<\/code><\/a>.<br>\n+                    Method(java.lang.String)\"><code>TestClassInModuleTags.testMethod(String)<\/code><\/a>.<br>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testModules\/TestModules.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- *      8182765 8196202 8202626 8261976 8323698\n+ *      8182765 8196202 8202626 8261976 8323698 8345770\n@@ -110,1 +110,4 @@\n-               <a href=\"..\/AnAbstract.html\" class=\"type-name-link\" title=\"class in pkg1\">AnAbstract<\/a>\"\"\"\n+               <a href=\"..\/AnAbstract.html\" class=\"type-name-link\" title=\"class in pkg1\">AnAbstract<\/a>\"\"\",\n+           \"\"\"\n+               Link to interface method: <a href=\"..\/UsedInterface.html#doNothing()\"><code>Use\\\n+               dInterface.doNothing()<\/code><\/a>.\"\"\"\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUseOption\/TestUseOption.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,4 @@\n+\n+\/**\n+ * Link to interface method: {@link #doNothing}.\n+ *\/\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUseOption\/pkg1\/AnAbstract.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -54,1 +55,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -133,4 +133,4 @@\n-            log.warning(Warnings.DivZero);\n-            log.warning(tree.pos, Warnings.DivZero);\n-            log.warning(tree.pos(), Warnings.DivZero);\n-            log.warning(nil, Warnings.DivZero);\n+            log.warning(LintWarnings.DivZero);\n+            log.warning(tree.pos, LintWarnings.DivZero);\n+            log.warning(tree.pos(), LintWarnings.DivZero);\n+            log.warning(nil, LintWarnings.DivZero);\n","filename":"test\/langtools\/tools\/javac\/6304921\/TestLog.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8328481 8332236 8332890\n+ * @bug 8328481 8332236 8332890 8344647\n@@ -36,1 +36,1 @@\n-*\/\n+ *\/\n@@ -832,0 +832,1 @@\n+    @Test\n@@ -922,0 +923,46 @@\n+\n+    @Test \/\/JDK-8344647\n+    public void testJavaBaseOverride(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path javaBaseClasses = current.resolve(\"javaBaseClasses\");\n+        Path javaBase = src.resolve(\"java.base\");\n+        tb.writeJavaFiles(javaBase,\n+                          \"\"\"\n+                          module java.base {\n+                             exports java.lang;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package java.lang;\n+                          public class Object {}\n+                          \"\"\");\n+\n+        Files.createDirectories(javaBaseClasses);\n+\n+        new JavacTask(tb)\n+                .options(\"--patch-module\", \"java.base=\" + src.toString())\n+                .outdir(javaBaseClasses)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        Path test = current.resolve(\"test\");\n+        tb.writeJavaFiles(test,\n+                          \"\"\"\n+                          module test {\n+                              requires java.se;\n+                          }\n+                          \"\"\");\n+\n+        Path classes = current.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+                .options(\"--patch-module\", \"java.base=\" + javaBaseClasses.toString())\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(test))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll();\n+    }\n","filename":"test\/langtools\/tools\/javac\/ImportModule.java","additions":49,"deletions":2,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -807,1 +807,1 @@\n-            \"- compiler.err.cant.access: m.module-info, (compiler.misc.bad.class.file.header: module-info.class, (compiler.misc.bad.requires.flag: ACC_TRANSITIVE (0x0020))\",\n+            \"- compiler.err.cant.access: m.module-info, (compiler.misc.bad.class.file.header: module-info.class, (compiler.misc.bad.requires.flag: ACC_TRANSITIVE (0x0020)))\",\n","filename":"test\/langtools\/tools\/javac\/modules\/AnnotationsOnModules.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @modules jdk.jdeps\/com.sun.tools.jdeps\n@@ -41,0 +40,1 @@\n+import java.io.RandomAccessFile;\n@@ -63,0 +63,9 @@\n+        \/\/ fixup classfile versions\n+        forceReleaseInClassFile(9, \"Main.class\");\n+        forceReleaseInClassFile(9, \"base\/test\/Version.class\", \"base\/p\/Foo.class\");\n+        forceReleaseInClassFile(9, \"9\/test\/NonPublic.class\", \"9\/test\/Version.class\");\n+        forceReleaseInClassFile(9, \"v9\/p\/Foo.class\", \"v9\/q\/Bar.class\");\n+        forceReleaseInClassFile(9, \"v9\/p\/Foo.class\", \"v9\/q\/Bar.class\");\n+        forceReleaseInClassFile(10, \"10\/test\/Version.class\");\n+        forceReleaseInClassFile(10, \"v10\/q\/Bar.class\", \"v10\/q\/Gee.class\");\n+\n@@ -77,0 +86,1 @@\n+        forceReleaseInClassFile(9, foo.resolve(\"module-info.class\"));\n@@ -81,0 +91,11 @@\n+    private void forceReleaseInClassFile(int release, Object... paths) {\n+        for (var path : paths) {\n+            try (var file = new RandomAccessFile(mrjar.resolve(path.toString()).toFile(), \"rw\")) {\n+                file.seek(4 + 2); \/\/ skip magic and minor\n+                file.writeShort(release + 44); \/\/ overwrite major\n+            } catch (Exception exception) {\n+                throw new RuntimeException(exception);\n+            }\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/jdeps\/MultiReleaseJar.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-    private static final String VERSION = \"13\";\n+    private static final String VERSION = String.valueOf(Runtime.version().feature());\n@@ -125,1 +125,1 @@\n-            String regex = \"\\\\s+13\/p.internal.X\\\\s+->\\\\s+q.T\\\\s+not found\";\n+            String regex = \"\\\\s+\" + VERSION + \"\/p.internal.X\\\\s+->\\\\s+q.T\\\\s+not found\";\n","filename":"test\/langtools\/tools\/jdeps\/missingDeps\/MissingDepsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-                assertTrue(CompilerUtils.compileModule(SRC_DIR, MODS_DIR, mn)));\n+                assertTrue(CompilerUtils.compileModule(SRC_DIR, MODS_DIR, mn, \"--release\", \"9\")));\n","filename":"test\/langtools\/tools\/jdeps\/multiVersion\/MultiVersionError.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.HexFormat;\n@@ -34,0 +33,1 @@\n+ * @bug 8340493\n@@ -52,0 +52,23 @@\n+    \/\/ equals() always returns true\n+    public static class Bar {\n+        private final int i;\n+        public Bar(int i) {\n+            this.i = i;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return true;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return Integer.toString(i);\n+        }\n+    }\n+\n@@ -65,0 +88,13 @@\n+\n+        testErrorMessages();\n+    }\n+\n+    public static void testErrorMessages() throws Exception {\n+        try {\n+            Asserts.assertNotEquals(new Bar(1), new Bar(2));\n+            throw new Exception(\"Should fail\");\n+        } catch (RuntimeException e) {\n+            if (!e.getMessage().contains(\"was 2\")) {\n+                throw new Exception(\"msg is \" + e.getMessage());\n+            }\n+        }\n@@ -219,2 +255,1 @@\n-    private static void expectPass(Assertion assertion, byte[] b1, byte[] b2)\n-            throws Exception {\n+    private static void expectPass(Assertion assertion, byte[] b1, byte[] b2) {\n","filename":"test\/lib-test\/jdk\/test\/lib\/AssertsTest.java","additions":38,"deletions":3,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        Asserts.assertEqualsByteArray(b1, new byte[] {1, 2});\n+        Asserts.assertEqualsByteArray(new byte[] {1, 2}, b1);\n@@ -41,1 +41,1 @@\n-        Asserts.assertEqualsByteArray(b1, new byte[] {3, 4});\n+        Asserts.assertEqualsByteArray(new byte[] {3, 4}, b1);\n@@ -44,1 +44,1 @@\n-        Asserts.assertEqualsByteArray(b1, new byte[] {5, 6});\n+        Asserts.assertEqualsByteArray(new byte[] {5, 6}, b1);\n","filename":"test\/lib-test\/jdk\/test\/lib\/security\/FixedSecureRandomTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-     * Asserts that {@code lhs} is the same byte array as {@code rhs}.\n+     * Asserts that {@code actual} has the same content as {@code expected}.\n@@ -239,2 +239,2 @@\n-     * @param lhs The left hand side of the comparison.\n-     * @param rhs The right hand side of the comparison.\n+     * @param expected The expected value\n+     * @param actual The actual value\n@@ -244,2 +244,2 @@\n-    public static void assertEqualsByteArray(byte[] lhs, byte[] rhs) {\n-        assertEqualsByteArray(lhs, rhs, null);\n+    public static void assertEqualsByteArray(byte[] expected, byte[] actual) {\n+        assertEqualsByteArray(expected, actual, null);\n@@ -249,1 +249,1 @@\n-     * Asserts that {@code lhs} is not the same byte array as {@code rhs}.\n+     * Asserts that {@code actual} does not have the same content as {@code unexpected}.\n@@ -251,2 +251,2 @@\n-     * @param lhs The left hand side of the comparison.\n-     * @param rhs The right hand side of the comparison.\n+     * @param unexpected The unexpected value\n+     * @param actual The actual value\n@@ -256,2 +256,2 @@\n-    public static void assertNotEqualsByteArray(byte[] lhs, byte[] rhs) {\n-        assertNotEqualsByteArray(lhs, rhs, null);\n+    public static void assertNotEqualsByteArray(byte[] unexpected, byte[] actual) {\n+        assertNotEqualsByteArray(unexpected, actual, null);\n@@ -261,1 +261,1 @@\n-     * Asserts that {@code lhs} is the same byte array as {@code rhs}.\n+     * Asserts that {@code actual} is the same byte array as {@code expected}.\n@@ -263,2 +263,2 @@\n-     * @param lhs The left hand side of the comparison.\n-     * @param rhs The right hand side of the comparison.\n+     * @param expected The expected value\n+     * @param actual The actual value\n@@ -268,2 +268,2 @@\n-    public static void assertEqualsByteArray(byte[] lhs, byte[] rhs, String msg) {\n-        if (!Arrays.equals(lhs, rhs)) {\n+    public static void assertEqualsByteArray(byte[] expected, byte[] actual, String msg) {\n+        if (!Arrays.equals(expected, actual)) {\n@@ -271,2 +271,2 @@\n-                    + \": expected \" + HexFormat.of().formatHex(lhs)\n-                    + \" to equal \" + HexFormat.of().formatHex(rhs);\n+                    + \": expected \" + HexFormat.of().formatHex(expected)\n+                    + \" but was \" + HexFormat.of().formatHex(actual);\n@@ -278,1 +278,1 @@\n-     * Asserts that {@code lhs} is not the same byte array as {@code rhs}.\n+     * Asserts that {@code actual} is not the same byte array as {@code unexpected}.\n@@ -280,2 +280,2 @@\n-     * @param lhs The left hand side of the comparison.\n-     * @param rhs The right hand side of the comparison.\n+     * @param unexpected The unexpected value\n+     * @param actual The actual value\n@@ -285,2 +285,2 @@\n-    public static void assertNotEqualsByteArray(byte[] lhs, byte[] rhs, String msg) {\n-        if (Arrays.equals(lhs, rhs)) {\n+    public static void assertNotEqualsByteArray(byte[] unexpected, byte[] actual, String msg) {\n+        if (Arrays.equals(unexpected, actual)) {\n@@ -288,2 +288,1 @@\n-                    + \": expected \" + HexFormat.of().formatHex(lhs)\n-                    + \" to not equal \" + HexFormat.of().formatHex(rhs);\n+                    + \": expected not equals but was \" + HexFormat.of().formatHex(actual);\n@@ -407,2 +406,2 @@\n-     * @param lhs The left hand side of the comparison.\n-     * @param rhs The right hand side of the comparison.\n+     * @param unexpected The unexpected value\n+     * @param actual The actual value\n@@ -411,2 +410,2 @@\n-    public static void assertNE(Object lhs, Object rhs) {\n-        assertNotEquals(lhs, rhs);\n+    public static void assertNE(Object unexpected, Object actual) {\n+        assertNotEquals(unexpected, actual);\n@@ -418,2 +417,2 @@\n-     * @param lhs The left hand side of the comparison.\n-     * @param rhs The right hand side of the comparison.\n+     * @param unexpected The unexpected value\n+     * @param actual The actual value\n@@ -423,2 +422,2 @@\n-    public static void assertNE(Object lhs, Object rhs, String msg) {\n-        assertNotEquals(lhs, rhs, msg);\n+    public static void assertNE(Object unexpected, Object actual, String msg) {\n+        assertNotEquals(unexpected, actual, msg);\n@@ -430,2 +429,2 @@\n-     * @param lhs The left hand side of the comparison.\n-     * @param rhs The right hand side of the comparison.\n+     * @param unexpected The unexpected value\n+     * @param actual The actual value\n@@ -434,2 +433,2 @@\n-    public static void assertNotEquals(Object lhs, Object rhs) {\n-        assertNotEquals(lhs, rhs, null);\n+    public static void assertNotEquals(Object unexpected, Object actual) {\n+        assertNotEquals(unexpected, actual, null);\n@@ -439,1 +438,1 @@\n-     * Asserts that {@code lhs} is not equal to {@code rhs}.\n+     * Asserts that {@code actual} is not equal to {@code unexpected}.\n@@ -441,2 +440,2 @@\n-     * @param lhs The left hand side of the comparison.\n-     * @param rhs The right hand side of the comparison.\n+     * @param unexpected The unexpected value\n+     * @param actual The actual value\n@@ -446,2 +445,2 @@\n-    public static void assertNotEquals(Object lhs, Object rhs, String msg) {\n-        if ((lhs == rhs) || (lhs != null && lhs.equals(rhs))) {\n+    public static void assertNotEquals(Object unexpected, Object actual, String msg) {\n+        if ((unexpected == actual) || (unexpected != null && unexpected.equals(actual))) {\n@@ -449,2 +448,1 @@\n-                    + \": expected \" + Objects.toString(lhs)\n-                    + \" to not equal \" + Objects.toString(rhs);\n+                    + \": expected not equals but was \" + Objects.toString(actual);\n","filename":"test\/lib\/jdk\/test\/lib\/Asserts.java","additions":41,"deletions":43,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    public DockerRunOptions addDockerOpts(String... opts) {\n+    public final DockerRunOptions addDockerOpts(String... opts) {\n@@ -73,1 +73,1 @@\n-    public DockerRunOptions addJavaOpts(String... opts) {\n+    public final DockerRunOptions addJavaOpts(String... opts) {\n@@ -78,1 +78,1 @@\n-    public DockerRunOptions addJavaOptsAppended(String... opts) {\n+    public final DockerRunOptions addJavaOptsAppended(String... opts) {\n@@ -83,1 +83,1 @@\n-    public DockerRunOptions addClassOptions(String... opts) {\n+    public final DockerRunOptions addClassOptions(String... opts) {\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerRunOptions.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -45,1 +46,1 @@\n-public class WriteBarrier {\n+public abstract class WriteBarrier {\n@@ -53,2 +54,0 @@\n-    private Object[] realReferencesSmall;\n-    private Object[] nullReferencesSmall;\n@@ -58,2 +57,0 @@\n-    private Object[] realReferencesLarge;\n-    private Object[] nullReferencesLarge;\n@@ -62,0 +59,3 @@\n+    private Object nullRef;\n+    private Object realRef;\n+\n@@ -87,2 +87,0 @@\n-        realReferencesSmall = new Object[NUM_REFERENCES_SMALL];\n-        nullReferencesSmall = new Object[NUM_REFERENCES_SMALL];\n@@ -92,2 +90,0 @@\n-        realReferencesLarge = new Object[NUM_REFERENCES_LARGE];\n-        nullReferencesLarge = new Object[NUM_REFERENCES_LARGE];\n@@ -102,1 +98,0 @@\n-            realReferencesSmall[i] = new Object();\n@@ -107,1 +102,0 @@\n-            realReferencesLarge[i] = new Object();\n@@ -110,0 +104,2 @@\n+        realRef = new Object();\n+\n@@ -127,0 +123,5 @@\n+    \/\/ This and the other testArrayWriteBarrierFast benchmarks below should not\n+    \/\/ be inlined into the JMH-generated harness method. If the methods were\n+    \/\/ inlined, we might spill in the main loop (on x64) depending on very\n+    \/\/ subtle conditions (such as whether LinuxPerfAsmProfiler is enabled!),\n+    \/\/ which could distort the results.\n@@ -128,0 +129,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -130,1 +132,1 @@\n-            theArraySmall[indicesSmall[NUM_REFERENCES_SMALL - i - 1]] = realReferencesSmall[indicesSmall[i]];\n+            theArraySmall[indicesSmall[NUM_REFERENCES_SMALL - i - 1]] = realRef;\n@@ -135,0 +137,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -137,1 +140,1 @@\n-            theArraySmall[indicesSmall[NUM_REFERENCES_SMALL - i - 1]] = nullReferencesSmall[indicesSmall[i]];\n+            theArraySmall[indicesSmall[NUM_REFERENCES_SMALL - i - 1]] = nullRef;\n@@ -142,0 +145,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -144,1 +148,1 @@\n-            theArrayLarge[indicesLarge[NUM_REFERENCES_LARGE - i - 1]] = realReferencesLarge[indicesLarge[i]];\n+            theArrayLarge[indicesLarge[NUM_REFERENCES_LARGE - i - 1]] = realRef;\n@@ -149,0 +153,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -151,1 +156,1 @@\n-            theArrayLarge[indicesLarge[NUM_REFERENCES_LARGE - i - 1]] = nullReferencesLarge[indicesLarge[i]];\n+            theArrayLarge[indicesLarge[NUM_REFERENCES_LARGE - i - 1]] = nullRef;\n@@ -163,0 +168,11 @@\n+\n+    \/\/ This run is useful to compare different GC barrier models without being\n+    \/\/ affected by C2 unrolling the main loop differently for each model.\n+    @Fork(value = 3, jvmArgs = {\"-XX:LoopUnrollLimit=1\"})\n+    public static class WithoutUnrolling extends WriteBarrier {}\n+\n+    \/\/ This run is useful to study the interaction of GC barriers and loop\n+    \/\/ unrolling. Check that the main loop in the testArray benchmarks is\n+    \/\/ unrolled (or not) as expected for the studied GC barrier model.\n+    @Fork(value = 3)\n+    public static class WithDefaultUnrolling extends WriteBarrier {}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/WriteBarrier.java","additions":32,"deletions":16,"binary":false,"changes":48,"status":"modified"}]}