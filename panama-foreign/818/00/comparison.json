{"files":[{"patch":"@@ -1702,0 +1702,48 @@\n+    \/**\n+     * Reads a byte from this segment at the given index, scaled by the given layout size.\n+     *\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @return a byte value read from this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code isAccessibleBy(T) == false}.\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n+     * or if the layout alignment is greater than its size.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default byte getAtIndex(ValueLayout.OfByte layout, long index) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+    }\n+\n+    \/**\n+     * Reads a boolean from this segment at the given index, scaled by the given layout size.\n+     *\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @return a boolean value read from this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code isAccessibleBy(T) == false}.\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n+     * or if the layout alignment is greater than its size.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default boolean getAtIndex(ValueLayout.OfBoolean layout, long index) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+    }\n+\n@@ -1775,0 +1823,51 @@\n+    \/**\n+     * Writes a byte into this segment at the given index, scaled by the given layout size.\n+     *\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @param value the short value to be written.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code isAccessibleBy(T) == false}.\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n+     * or if the layout alignment is greater than its size.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfByte layout, long index, byte value) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+\n+    }\n+\n+    \/**\n+     * Writes a boolean into this segment at the given index, scaled by the given layout size.\n+     *\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @param value the short value to be written.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code isAccessibleBy(T) == false}.\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n+     * or if the layout alignment is greater than its size.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfBoolean layout, long index, boolean value) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-                {\"bool\", Accessor.ofSegment(ValueLayout.JAVA_BOOLEAN, false,\n+                {\"boolean\", Accessor.ofSegment(ValueLayout.JAVA_BOOLEAN, false,\n@@ -173,0 +173,4 @@\n+                {\"short\", Accessor.ofSegment(ValueLayout.JAVA_SHORT, (short) 42,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.order(NE).getShort(pos), (bb, pos, v) -> bb.order(NE).putShort(pos, v))\n+                },\n@@ -207,0 +211,8 @@\n+                {\"byte\/index\", Accessor.ofSegment(ValueLayout.JAVA_BYTE, (byte) 42,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).get(pos), (bb, pos, v) -> bb.order(NE).put(pos, v))\n+                },\n+                {\"boolean\/index\", Accessor.ofSegment(ValueLayout.JAVA_BOOLEAN, true,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).get(pos) != 0, (bb, pos, v) -> bb.order(NE).put(pos, (byte) (v ? 1 : 0)))\n+                },\n@@ -211,0 +223,4 @@\n+                {\"short\/index\", Accessor.ofSegment(ValueLayout.JAVA_SHORT, (short) 42,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getShort(pos * 2), (bb, pos, v) -> bb.order(NE).putShort(pos * 2, v))\n+                },\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"}]}