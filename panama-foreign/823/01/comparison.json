{"files":[{"patch":"@@ -21,0 +21,3 @@\n+\/.project\n+\/.classpath\n+\/.cproject\n","filename":".gitignore","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -601,1 +601,2 @@\n-<li><code>#include &lt;type_traits&gt;<\/code>.<\/li>\n+<li><code>#include &lt;type_traits&gt;<\/code> with some restrictions,\n+listed below.<\/li>\n@@ -605,0 +606,6 @@\n+<p>Certain restrictions apply to the declarations provided by\n+<code>&lt;type_traits&gt;<\/code>.<\/p>\n+<ul>\n+<li>The <code>alignof<\/code> operator should be used rather than\n+<code>std::alignment_of&lt;&gt;<\/code>.<\/li>\n+<\/ul>\n@@ -1089,0 +1096,2 @@\n+<li><p><code>alignof<\/code> (<a\n+href=\"https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2007\/n2341.pdf\">n2341<\/a>)<\/p><\/li>\n","filename":"doc\/hotspot-style.html","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -575,1 +575,1 @@\n-* `#include <type_traits>`.\n+* `#include <type_traits>` with some restrictions, listed below.\n@@ -578,0 +578,4 @@\n+Certain restrictions apply to the declarations provided by `<type_traits>`.\n+\n+* The `alignof` operator should be used rather than `std::alignment_of<>`.\n+\n@@ -1085,0 +1089,3 @@\n+* `alignof`\n+([n2341](https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2007\/n2341.pdf))\n+\n","filename":"doc\/hotspot-style.md","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -82,0 +82,39 @@\n+<h4 id=\"eclipse-cdt\">Eclipse CDT<\/h4>\n+<p>The make system can generate an Eclipse CDT Workspace that enables\n+Eclipse indexing for the C and C++ sources throughout the entire\n+codebase, as well as registering all common make targets to be runnable\n+from the Eclipse explorer. This can be done after configuring by\n+running:<\/p>\n+<pre><code>make eclipse-native-env<\/code><\/pre>\n+<p>After this is run, simply open and import the workspace in Eclipse\n+through\n+<code>File -&gt; Import -&gt; Projects from Folder or Archive<\/code> and\n+at <code>Import source<\/code> click on the directory\n+<code>ide\\eclipse<\/code>, which can be found in the build output\n+folder.<\/p>\n+<p>If this doesn't work, you can also try\n+<code>File -&gt; Import -&gt; Existing Projects into Workspace<\/code>\n+instead.<\/p>\n+<p>Setting up an Eclipse Workspace is relatively lightweight compared to\n+other supported IDEs, but requires that your CDT installation has Cross\n+GCC support enabled at the moment, even if you aren't cross compiling.\n+The Visual C++ compiler is, at present, not supported as an indexer.<\/p>\n+<p>If desired, you can instead request make to only include indexing\n+support for just the Java Virtual Machine instead of the entire native\n+codebase, by running:<\/p>\n+<pre><code>make eclipse-hotspot-env<\/code><\/pre>\n+<p>If you think your particular Eclipse installation can handle the\n+strain, the make system also supports generating a combined Java and\n+C\/C++ Workspace for Eclipse which can then conveniently switch between\n+Java and C\/C++ natures during development by running:<\/p>\n+<pre><code>make eclipse-mixed-env<\/code><\/pre>\n+<p>Do note that this generates all features that come with both Java and\n+C\/C++ natures.<\/p>\n+<p>By default, the Eclipse Workspace is located in the ide subdirectory\n+in the build output. To share the JDK's source directory with the\n+Eclipse Workspace, you can instead run:<\/p>\n+<pre><code>make eclipse-shared-&lt;ENV&gt;-env<\/code><\/pre>\n+<p>Eclipse support in the JDK is relatively new, so do keep in mind that\n+not everything may work at the moment. As such, the resulting Workspace\n+also has compilation database parsing support enabled, so you can pass\n+Eclipse the compile commands file (see below) if all else fails.<\/p>\n@@ -108,0 +147,23 @@\n+<h4 id=\"eclipse\">Eclipse<\/h4>\n+<p>Eclipse JDT is a widely used Java IDE and has been for a very long\n+time, being a popular choice alongside IntelliJ IDEA for Java\n+development. Likewise, the JDK now includes support for developing its\n+Java sources with Eclipse, which can be achieved by setting up a Java\n+Workspace by running:<\/p>\n+<pre><code>make eclipse-java-env<\/code><\/pre>\n+<p>After the workspace has been generated you can import it in the same\n+way as you would with Eclipse CDT:<\/p>\n+<p>Follow\n+<code>File -&gt; Import -&gt; Projects from Folder or Archive<\/code> and\n+select the <code>ide\\eclipse<\/code> directory in the build output folder\n+to import the newly created Java Workspace.<\/p>\n+<p>If doing so results in an error, you can also import the JDK via\n+<code>File -&gt; Import -&gt; Existing Projects into Workspace<\/code> as\n+a last resort.<\/p>\n+<p>Alternatively, if you want a Java Workspace inside the JDK's source\n+directory, you can instead run:<\/p>\n+<pre><code>make eclipse-shared-java-env<\/code><\/pre>\n+<p>As mentioned above for Eclipse CDT, you can create a combined Java\n+and C\/C++ Workspace which can conveniently switch between Java and C\/C++\n+natures during development by running:<\/p>\n+<pre><code>make eclipse-mixed-env<\/code><\/pre>\n","filename":"doc\/ide.html","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -59,0 +59,57 @@\n+#### Eclipse CDT\n+\n+The make system can generate an Eclipse CDT Workspace that enables Eclipse\n+indexing for the C and C++ sources throughout the entire codebase, as well as\n+registering all common make targets to be runnable from the Eclipse explorer.\n+This can be done after configuring by running:\n+\n+```\n+make eclipse-native-env\n+```\n+\n+After this is run, simply open and import the workspace in Eclipse through\n+`File -> Import -> Projects from Folder or Archive` and at\n+`Import source` click on the directory `ide\\eclipse`, which can be\n+found in the build output folder.\n+\n+If this doesn't work, you can also try\n+`File -> Import -> Existing Projects into Workspace`\n+instead.\n+\n+Setting up an Eclipse Workspace is relatively lightweight compared to other\n+supported IDEs, but requires that your CDT installation has Cross GCC support\n+enabled at the moment, even if you aren't cross compiling. The Visual C++\n+compiler is, at present, not supported as an indexer.\n+\n+If desired, you can instead request make to only include indexing support for\n+just the Java Virtual Machine instead of the entire native codebase, by running:\n+\n+```\n+make eclipse-hotspot-env\n+```\n+\n+If you think your particular Eclipse installation can handle the strain, the\n+make system also supports generating a combined Java and C\/C++ Workspace for\n+Eclipse which can then conveniently switch between Java and C\/C++ natures\n+during development by running:\n+\n+```\n+make eclipse-mixed-env\n+```\n+\n+Do note that this generates all features that come with both Java and C\/C++\n+natures.\n+\n+By default, the Eclipse Workspace is located in the ide subdirectory in the\n+build output. To share the JDK's source directory with the Eclipse Workspace,\n+you can instead run:\n+\n+```\n+make eclipse-shared-<ENV>-env\n+```\n+\n+Eclipse support in the JDK is relatively new, so do keep in mind that not\n+everything may work at the moment. As such, the resulting Workspace also\n+has compilation database parsing support enabled, so you can pass Eclipse\n+the compile commands file (see below) if all else fails.\n+\n@@ -99,0 +156,37 @@\n+\n+#### Eclipse\n+\n+Eclipse JDT is a widely used Java IDE and has been for a very long time, being\n+a popular choice alongside IntelliJ IDEA for Java development. Likewise, the\n+JDK now includes support for developing its Java sources with Eclipse, which\n+can be achieved by setting up a Java Workspace by running:\n+\n+```\n+make eclipse-java-env\n+```\n+\n+After the workspace has been generated you can import it in the same way as\n+you would with Eclipse CDT:\n+\n+Follow `File -> Import -> Projects from Folder or Archive` and select the\n+`ide\\eclipse` directory in the build output folder to import the newly created\n+Java Workspace.\n+\n+If doing so results in an error, you can also import the JDK via\n+`File -> Import -> Existing Projects into Workspace`\n+as a last resort.\n+\n+Alternatively, if you want a Java Workspace inside the JDK's source directory,\n+you can instead run:\n+\n+```\n+make eclipse-shared-java-env\n+```\n+\n+As mentioned above for Eclipse CDT, you can create a combined Java and C\/C++\n+Workspace which can conveniently switch between Java and C\/C++ natures during\n+development by running:\n+\n+```\n+make eclipse-mixed-env\n+```\n","filename":"doc\/ide.md","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -452,1 +452,1 @@\n-      SUBDIR := $(JDK_BUNDLE_SUBDIR), \\\n+      SUBDIR := jdk-$(VERSION_NUMBER), \\\n","filename":"make\/Bundles.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -260,0 +260,40 @@\n+$(eval $(call SetupTarget, eclipse-java-env, \\\n+    MAKEFILE := ide\/eclipse\/CreateWorkspace, \\\n+    ARGS := --always-make WORKSPACE=java SHARED=false, \\\n+))\n+\n+$(eval $(call SetupTarget, eclipse-hotspot-env, \\\n+    MAKEFILE := ide\/eclipse\/CreateWorkspace, \\\n+    ARGS := --always-make WORKSPACE=hotspot SHARED=false, \\\n+))\n+\n+$(eval $(call SetupTarget, eclipse-native-env, \\\n+    MAKEFILE := ide\/eclipse\/CreateWorkspace, \\\n+    ARGS := --always-make WORKSPACE=native SHARED=false, \\\n+))\n+\n+$(eval $(call SetupTarget, eclipse-mixed-env, \\\n+    MAKEFILE := ide\/eclipse\/CreateWorkspace, \\\n+    ARGS := --always-make SHARED=false, \\\n+))\n+\n+$(eval $(call SetupTarget, eclipse-shared-java-env, \\\n+    MAKEFILE := ide\/eclipse\/CreateWorkspace, \\\n+    ARGS := --always-make WORKSPACE=java SHARED=true, \\\n+))\n+\n+$(eval $(call SetupTarget, eclipse-shared-hotspot-env, \\\n+    MAKEFILE := ide\/eclipse\/CreateWorkspace, \\\n+    ARGS := --always-make WORKSPACE=hotspot SHARED=true, \\\n+))\n+\n+$(eval $(call SetupTarget, eclipse-shared-native-env, \\\n+    MAKEFILE := ide\/eclipse\/CreateWorkspace, \\\n+    ARGS := --always-make WORKSPACE=native SHARED=true, \\\n+))\n+\n+$(eval $(call SetupTarget, eclipse-shared-mixed-env, \\\n+    MAKEFILE := ide\/eclipse\/CreateWorkspace, \\\n+    ARGS := --always-make SHARED=true, \\\n+))\n+\n","filename":"make\/Main.gmk","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -192,0 +192,4 @@\n+      # gcc10\/11 on ppc generate lots of abi warnings about layout of aggregates containing vectors\n+      if test \"x$OPENJDK_TARGET_CPU_ARCH\" = \"xppc\"; then\n+        DISABLED_WARNINGS=\"$DISABLED_WARNINGS psabi\"\n+      fi\n","filename":"make\/autoconf\/flags-cflags.m4","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        gtest_version=\"`$GREP GOOGLETEST_VERSION $GTEST_FRAMEWORK_SRC\/CMakeLists.txt | $SED -E -e 's\/set\\(GOOGLETEST_VERSION (.*)\\)\/\\1\/'`\"\n+        gtest_version=\"`$GREP GOOGLETEST_VERSION $GTEST_FRAMEWORK_SRC\/CMakeLists.txt | $SED -e 's\/set(GOOGLETEST_VERSION \\(.*\\))\/\\1\/'`\"\n","filename":"make\/autoconf\/lib-tests.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -889,1 +889,1 @@\n-            var jdk_subdir = (o.jdk_subdir != null ? o.jdk_subdir : \"jdk-\" + data.version);\n+            var jdk_subdir = \"jdk-\" + data.version;\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,390 @@\n+#\n+# Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+default: all\n+\n+include $(SPEC)\n+include MakeBase.gmk\n+include TextFileProcessing.gmk\n+include Utils.gmk\n+include Modules.gmk\n+\n+JVM_VARIANT := $(JVM_VARIANT_MAIN)\n+include hotspot\/HotspotCommon.gmk\n+include hotspot\/lib\/JvmFeatures.gmk\n+include hotspot\/lib\/JvmOverrideFiles.gmk\n+include hotspot\/lib\/JvmFlags.gmk\n+\n+# Random number generation, with the amount of specified digits\n+# No need to check if the parameter passed is a valid number, the shell will\n+# be more than happy to complain if it isn't ;)\n+RandomDigits = \\\n+    $(shell od -An -N8 -d \/dev\/urandom | sed -e 's| ||g' -e 's|\\(.\\{$(strip $1)\\}\\).*|\\1|')\n+\n+# Modified version of utility from JdkNativeCompilation.gmk\n+# The full path could be omitted, but it was chosen not to so wildcard\n+# can work properly for existing directories. The pathsubst below that\n+# this necessitates is a relatively small price to pay.\n+FindModuleNativeDirs = \\\n+    $(call uniq, $(wildcard \\\n+        $(TOPDIR)\/src\/$(strip $1)\/$(OPENJDK_TARGET_OS)\/native \\\n+        $(TOPDIR)\/src\/$(strip $1)\/$(OPENJDK_TARGET_OS_TYPE)\/native \\\n+        $(TOPDIR)\/src\/$(strip $1)\/share\/native))\n+\n+# Taken from JdkNativeCompilation.gmk\n+FindJavaHeaderDir = \\\n+    $(if $(strip $1),$(wildcard $(SUPPORT_OUTPUTDIR)\/headers\/$(strip $1)))\n+\n+JAVA_DIRS := $(strip $(foreach module, $(call FindAllModules), \\\n+    $(patsubst $(TOPDIR)\/%,%,$(filter-out $(OUTPUTDIR)%, \\\n+    $(call FindModuleSrcDirs, $(module))))))\n+\n+NATIVE_DIRS := $(strip $(foreach module, $(call FindAllModules), \\\n+    $(patsubst $(TOPDIR)\/%,%,$(call FindModuleNativeDirs, $(module)))))\n+\n+# Emit the defines extracted from the list of options specified in the first parameter into\n+# the language settings file, in Eclipse format.\n+EmitExtractedDefines = \\\n+    $(shell echo $(1) | grep -o \"\\-D\\s\\?\")\n+\n+################################################################################\n+# Create an Eclipse Workspace with the specified nature\n+#\n+# Parameter 1 is the name of the rule. This name is used as variable prefix,\n+# and the targets generated are listed in a variable by that name.\n+#\n+# Remaining parameter(s) are named arguments:\n+#   NATURE - Which Eclipse Workspace nature to generate for the Workspace. Can\n+#       be one of JAVA, HOTSPOT, NATIVE, or MIXED.\n+#   SHARED - Workspace will share the same directory as the JDK if true. Can be\n+#       either true or false. Defaults to false if not specified.\n+SetupEclipseWorkspace = $(NamedParamsMacroTemplate)\n+define SetupEclipseWorkspaceBody\n+\n+  $1_NATURES :=\n+  $1_BUILD_MANAGERS :=\n+  $1_LINKED_RESOURCES :=\n+\n+  ifeq ($$($1_NATURE), )\n+    $$(error No nature specified for Eclipse Workspace, cannot continue)\n+  endif\n+\n+  ifeq ($$(findstring $$($1_NATURE), JAVA HOTSPOT NATIVE MIXED), )\n+    $$(error Unrecognised nature $$($1_NATURE) specified for Eclipse Workspace)\n+  endif\n+\n+  ifeq ($$($1_SHARED), )\n+    $$(info Workspace sharing option not given, assuming non-shared Eclipse Workspace)\n+    $1_SHARED := false\n+  else ifeq ($$(findstring $$($1_SHARED), true false), )\n+    $$(error $$($1_NATURE) is not a boolean word)\n+  endif\n+\n+  ifeq ($$($1_SHARED), true)\n+    $1_CLASSPATH_FILE := $(TOPDIR)\/.classpath\n+    $1_WORKSPACE_FILE := $(TOPDIR)\/.project\n+    $1_NATIVE_FILE := $(TOPDIR)\/.cproject\n+    $1_SETTINGS_FILE := $(TOPDIR)\/.settings\/language.settings.xml\n+  else\n+    $1_IDE_OUTPUTDIR := $(OUTPUTDIR)\/ide\/eclipse\n+    $1_CLASSPATH_FILE := $$($1_IDE_OUTPUTDIR)\/.classpath\n+    $1_WORKSPACE_FILE := $$($1_IDE_OUTPUTDIR)\/.project\n+    $1_NATIVE_FILE := $$($1_IDE_OUTPUTDIR)\/.cproject\n+    $1_SETTINGS_FILE := $$($1_IDE_OUTPUTDIR)\/.settings\/language.settings.xml\n+    $$(call MakeDir, $$($1_IDE_OUTPUTDIR))\n+  endif\n+\n+  ifneq ($$(findstring $$($1_NATURE), HOTSPOT NATIVE MIXED), )\n+    ifeq ($$(call isCompiler, microsoft), true)\n+      $$(error Visual C++ is not yet supported as an indexer for Native Workspaces!)\n+    endif\n+  endif\n+\n+  ifneq ($$(findstring $$($1_NATURE), JAVA MIXED), )\n+\n+    $1_CLASSPATH :=\n+\n+    # Eclipse crashes when processing multiple module-info.java files\n+    # This is an annoying bug that has not been fixed for some time now\n+    $1_CLASSPATH += $$(foreach src,$(JAVA_DIRS), \\\n+        <classpathentry excluding=\"module-info.java|module-info.java.extra\" kind=\"src\" path=\"$$(src)\"\/>$$(NEWLINE))\n+\n+    $$(eval $$(call SetupTextFileProcessing, $1_CREATE_CLASSPATH_FILE, \\\n+        SOURCE_FILES := $(TOPDIR)\/make\/ide\/eclipse\/classpath.template, \\\n+        OUTPUT_FILE := $$($1_CLASSPATH_FILE), \\\n+        REPLACEMENTS := \\\n+            @@CLASSPATH@@ => $$($1_CLASSPATH), \\\n+    ))\n+\n+    TARGETS += $$($1_CREATE_CLASSPATH_FILE)\n+\n+    $1_NATURES += <nature>org.eclipse.jdt.core.javanature<\/nature>$$(NEWLINE)\n+\n+  endif\n+\n+  ifneq ($$(findstring $$($1_NATURE), HOTSPOT NATIVE MIXED), )\n+\n+    $1_NATIVE_SRCS :=\n+\n+    $1_BUILD_MANAGERS += \\\n+        <buildCommand> \\\n+            <name>org.eclipse.cdt.managedbuilder.core.genmakebuilder<\/name> \\\n+            <triggers>clean$$(COMMA)full$$(COMMA)incremental$$(COMMA)<\/triggers> \\\n+            <arguments> \\\n+            <\/arguments> \\\n+        <\/buildCommand> \\\n+        <buildCommand> \\\n+            <name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder<\/name> \\\n+            <triggers>full$$(COMMA)incremental$$(COMMA)<\/triggers> \\\n+            <arguments> \\\n+            <\/arguments> \\\n+        <\/buildCommand>$$(NEWLINE)\n+\n+    $1_NATURES += \\\n+        <nature>org.eclipse.cdt.core.cnature<\/nature> \\\n+        <nature>org.eclipse.cdt.core.ccnature<\/nature> \\\n+        <nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature<\/nature> \\\n+        <nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature<\/nature>$$(NEWLINE)\n+\n+    # This is always emitted, no matter which of the 3 natures were selected\n+    $1_NATIVE_SRCS += \\\n+        <entry flags=\"VALUE_WORKSPACE_PATH|RESOLVED\" kind=\"sourcePath\" name=\"src\/hotspot\"\/>$$(NEWLINE)\n+\n+    ifneq ($$(findstring $$($1_NATURE), NATIVE MIXED), )\n+      $1_NATIVE_SRCS += $$(foreach src,$(NATIVE_DIRS), \\\n+          <entry flags=\"VALUE_WORKSPACE_PATH|RESOLVED\" kind=\"sourcePath\" name=\"$$(strip $$(src))\"\/>$$(NEWLINE))\n+    endif\n+\n+    $1_WORKSPACE_MAJOR := $$(call RandomDigits, 10)\n+    $1_WORKSPACE_MINOR := $$(call RandomDigits, 9)\n+\n+    # FixPath already removes $(FIXPATH) automatically, but if we rely on FixPath\n+    # to do it for us dir won't be able to handle the converted path (if on Windows).\n+    # Reversing the order causes dir to mangle the preceeding $(FIXPATH) which breaks\n+    # the ability of FixPath to remove it, so it has to be manually removed here.\n+    #\n+    # Note that the workspace setup system currently does not support Visual C++ when\n+    # extracting compiler and\/or system headers vital to the build!\n+    $1_ENV := $$(call FixPath, $$(dir $$(patsubst $(FIXPATH), , $(CC))))\n+\n+    # Sidestep annoying issue of WSL path conversion not working properly with true\n+    # Unix paths. Eclipse can't run the WSL make by itself anyway, even if we could\n+    # properly convert the path.\n+    ifeq ($$(call isBuildOsEnv, windows.wsl1 windows.wsl2), true)\n+      $1_MAKE := wsl.exe $(MAKE)\n+    else\n+      $1_MAKE := $$(call FixPath, $(MAKE))\n+    endif\n+\n+    $1_MATCHING_MAKE_TARGETS :=\n+    $1_PLAIN_MAKE_TARGETS := update-build-docs docs gensrc gendata \\\n+        copy java launchers libs hotspot jdk product-images all-images test-image clean\n+\n+    # make reconfigure omitted since it is sensitive to which make was used\n+    ifeq ($$($1_SHARED), true)\n+      $1_PLAIN_MAKE_TARGETS += dist-clean\n+    endif\n+\n+    $1_MATCHING_MAKE_TARGETS += $$(foreach name,$$($1_PLAIN_MAKE_TARGETS), \\\n+      <target name=\"$$(strip $$(name))\" path=\"\" targetID=\"org.eclipse.cdt.build.MakeTargetBuilder\"> \\\n+          <buildCommand>$$($1_MAKE)<\/buildCommand> \\\n+          <buildArguments>-C $$(call FixPath, $(TOPDIR))<\/buildArguments> \\\n+          <buildTarget>$$(strip $$(name))<\/buildTarget> \\\n+          <stopOnError>true<\/stopOnError> \\\n+          <useDefaultCommand>false<\/useDefaultCommand> \\\n+          <runAllBuilders>true<\/runAllBuilders> \\\n+      <\/target>$$(NEWLINE))\n+\n+    $$(eval $$(call SetupTextFileProcessing, $1_CREATE_NATIVE_FILE, \\\n+        SOURCE_FILES := $(TOPDIR)\/make\/ide\/eclipse\/native.template, \\\n+        OUTPUT_FILE := $$($1_NATIVE_FILE), \\\n+        REPLACEMENTS := \\\n+            @@DIR@@ => $$(call FixPath, $(TOPDIR)) ; \\\n+            @@ENV@@ => $$($1_ENV) ; \\\n+            @@WORKSPACE@@ => $$($1_WORKSPACE_MAJOR) ; \\\n+            @@MINOR@@ =>  $$($1_WORKSPACE_MINOR) ; \\\n+            @@MAKE@@ => $$($1_MAKE) ; \\\n+            @@SRC@@ => $$($1_NATIVE_SRCS) ; \\\n+            @@MAKE_TARGETS@@ => $$($1_MATCHING_MAKE_TARGETS), \\\n+    ))\n+\n+    TARGETS += $$($1_CREATE_NATIVE_FILE)\n+\n+    ifeq ($$($1_SHARED), true)\n+      $$(call MakeDir, $(TOPDIR)\/.settings)\n+    else\n+      $$(call MakeDir, $$($1_IDE_OUTPUTDIR)\/.settings)\n+    endif\n+\n+    $1_CSETTINGS :=\n+    $1_CXXSETTINGS :=\n+\n+    ifneq ($$(findstring $$($1_NATURE), NATIVE MIXED), )\n+      $1_CSETTINGS += $$(foreach module, $$(call FindAllModules), $$(if $$(call FindJavaHeaderDir, $$(module)), \\\n+          $$(foreach dirs, $$(strip $$(patsubst $(TOPDIR)\/%,%,$$(call FindModuleNativeDirs, $$(module)))), \\\n+              <resource project-relative-path=\"$$(dirs)\"> \\\n+                  <entry flags=\"LOCAL\" kind=\"includePath\" name=\"$$(call FixPath, $$(call FindJavaHeaderDir, $$(module)))\"\/> \\\n+                  $$(if $$(findstring jdk.sctp,$$(module)),    <entry flags=\"LOCAL\" kind=\"includePath\" name=\"$$(call FixPath, $$(call FindJavaHeaderDir, java.base))\"\/>) \\\n+              <\/resource>$$(NEWLINE))))\n+\n+      # main.c source file used for generic launchers\n+      $1_CSETTINGS += \\\n+          <resource project-relative-path=\"src\/java.base\/share\/native\/launcher\/main.c\"> \\\n+              <entry kind=\"macro\" name=\"LAUNCHER_NAME\" value=\"&quot;$(LAUNCHER_NAME)&quot;\"\/> \\\n+          <\/resource>$$(NEWLINE)\n+    endif\n+\n+    # HotSpot first\n+    $1_CXXSETTINGS += <resource project-relative-path=\"src\/hotspot\">$$(NEWLINE)\n+\n+    # If only the Java Virtual Machine sources were requested, headers from other parts of\n+    # the native source that it needs will not be available. Add them as include paths here\n+    # instead.\n+    ifeq ($$($1_NATURE), HOTSPOT)\n+      $1_CXXSETTINGS += $$(foreach src, $$(strip $$(patsubst %,%\/include,$$(call FindModuleNativeDirs, java.base))), \\\n+          $(X)    $(X)<entry flags=\"LOCAL\" kind=\"includePath\" name=\"$$(call FixPath, $$(src))\"\/>$$(NEWLINE))\n+      $1_CXXSETTINGS += $(X)    $(X)<entry flags=\"LOCAL\" kind=\"includePath\" name=\"$$(call FixPath, $(TOPDIR)\/src\/java.base\/share\/native\/libjimage)\"\/>$$(NEWLINE)\n+    endif\n+\n+    $1_CXXSETTINGS += $(X)    $(X)<entry flags=\"LOCAL\" kind=\"includePath\" name=\"$$(call FixPath, $(JVM_VARIANT_OUTPUTDIR)\/gensrc)\"\/>$$(NEWLINE)\n+\n+    ifeq ($$(call check-jvm-feature, compiler2), true)\n+      $1_CXXSETTINGS += $(X)    $(X)<entry flags=\"LOCAL\" kind=\"includePath\" name=\"$$(call FixPath, $(JVM_VARIANT_OUTPUTDIR)\/gensrc\/adfiles)\"\/>$$(NEWLINE)\n+    endif\n+\n+    $1_CXXSETTINGS += <\/resource>$$(NEWLINE)\n+\n+    $1_CXXSETTINGS += \\\n+        <resource project-relative-path=\"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp\"> \\\n+            <entry kind=\"macro\" name=\"HOTSPOT_VERSION_STRING\" value=\"&quot;$(VERSION_STRING)&quot;\"\/> \\\n+            <entry kind=\"macro\" name=\"DEBUG_LEVEL\" value=\"&quot;$(DEBUG_LEVEL)&quot;\"\/> \\\n+            <entry kind=\"macro\" name=\"HOTSPOT_BUILD_USER\" value=\"&quot;$(USERNAME)&quot;\"\/> \\\n+            <entry kind=\"macro\" name=\"HOTSPOT_VM_DISTRO\" value=\"&quot;$(HOTSPOT_VM_DISTRO)&quot;\"\/> \\\n+            <entry kind=\"macro\" name=\"CPU\" value=\"&quot;$(OPENJDK_TARGET_CPU_VM_VERSION)&quot;\"\/> \\\n+            <entry kind=\"macro\" name=\"HOTSPOT_BUILD_TIME\" value=\"&quot;$(if $(HOTSPOT_BUILD_TIME),$(HOTSPOT_BUILD_TIME),$(call EpochToISO8601,$(shell $(DATE) +\"%s\")))&quot;\"\/> \\\n+        <\/resource> \\\n+        <resource project-relative-path=\"src\/hotspot\/share\/runtime\/arguments.cpp\"> \\\n+            <entry kind=\"macro\" name=\"HOTSPOT_VERSION_STRING\" value=\"&quot;$(VERSION_STRING)&quot;\"\/> \\\n+            <entry kind=\"macro\" name=\"DEBUG_LEVEL\" value=\"&quot;$(DEBUG_LEVEL)&quot;\"\/> \\\n+            <entry kind=\"macro\" name=\"HOTSPOT_BUILD_USER\" value=\"&quot;$(USERNAME)&quot;\"\/> \\\n+            <entry kind=\"macro\" name=\"HOTSPOT_VM_DISTRO\" value=\"&quot;$(HOTSPOT_VM_DISTRO)&quot;\"\/> \\\n+            <entry kind=\"macro\" name=\"CPU\" value=\"&quot;$(OPENJDK_TARGET_CPU_VM_VERSION)&quot;\"\/> \\\n+            <entry kind=\"macro\" name=\"HOTSPOT_BUILD_TIME\" value=\"&quot;$(if $(HOTSPOT_BUILD_TIME),$(HOTSPOT_BUILD_TIME),$(call EpochToISO8601,$(shell $(DATE) +\"%s\")))&quot;\"\/> \\\n+        <\/resource>$$(NEWLINE)\n+\n+    # Now the rest of the C++ sources in the codebase\n+    ifneq ($$(findstring $$($1_NATURE), NATIVE MIXED), )\n+      $1_CXXSETTINGS += $$(foreach module, $$(call FindAllModules), $$(if $$(call FindJavaHeaderDir, $$(module)), \\\n+          $$(foreach dirs, $$(strip $$(patsubst $(TOPDIR)\/%,%,$$(call FindModuleNativeDirs, $$(module)))), \\\n+              <resource project-relative-path=\"$$(dirs)\"> \\\n+                  <entry flags=\"LOCAL\" kind=\"includePath\" name=\"$$(call FixPath, $$(call FindJavaHeaderDir, $$(module)))\"\/> \\\n+              <\/resource>$$(NEWLINE))))\n+    endif\n+\n+    $$(eval $$(call SetupTextFileProcessing, $1_CREATE_SETTINGS_FILE, \\\n+        SOURCE_FILES := $(TOPDIR)\/make\/ide\/eclipse\/settings.template, \\\n+        OUTPUT_FILE := $$($1_SETTINGS_FILE), \\\n+        REPLACEMENTS := \\\n+            @@WORKSPACE@@ => $$($1_WORKSPACE_MAJOR) ; \\\n+            @@CSETTINGS@@ => $$($1_CSETTINGS) ; \\\n+            @@CXXSETTINGS@@ => $$($1_CXXSETTINGS), \\\n+    ))\n+\n+    TARGETS += $$($1_CREATE_SETTINGS_FILE)\n+\n+  endif\n+\n+  ifeq ($$($1_SHARED), false)\n+    ifneq ($$(findstring $$($1_NATURE), JAVA MIXED), )\n+      $1_LINKED_RESOURCES += $$(foreach src,$(JAVA_DIRS), \\\n+          <link> \\\n+              <name>$$(strip $$(src))<\/name> \\\n+              <type>2<\/type> \\\n+              <location>$$(subst \\\\,\/,$$(call FixPath, $(TOPDIR)\/$$(src)))<\/location> \\\n+          <\/link>$$(NEWLINE))\n+    endif\n+\n+    ifneq ($$(findstring $$($1_NATURE), HOTSPOT NATIVE MIXED), )\n+      # CDT includes a Makefile editor, so if CDT support was indicated there's no harm in\n+      # including the make sources as well, since the cost of indexing them is miniscule\n+      $1_LINKED_RESOURCES += \\\n+          <link> \\\n+              <name>make<\/name> \\\n+              <type>2<\/type> \\\n+              <location>$$(subst \\\\,\/,$$(call FixPath, $(TOPDIR)\/make))<\/location> \\\n+          <\/link> \\\n+          <link> \\\n+              <name>src\/hotspot<\/name> \\\n+              <type>2<\/type> \\\n+              <location>$$(subst \\\\,\/,$$(call FixPath, $(TOPDIR)\/src\/hotspot))<\/location> \\\n+          <\/link>$$(NEWLINE)\n+    endif\n+\n+    ifneq ($$(findstring $$($1_NATURE), NATIVE MIXED), )\n+      $1_LINKED_RESOURCES += $$(foreach src,$(NATIVE_DIRS), \\\n+          <link> \\\n+              <name>$$(strip $$(src))<\/name> \\\n+              <type>2<\/type> \\\n+              <location>$$(subst \\\\,\/,$$(call FixPath, $(TOPDIR)\/$$(src)))<\/location> \\\n+          <\/link>$$(NEWLINE))\n+    endif\n+  endif\n+\n+  $$(eval $$(call SetupTextFileProcessing, $1_CREATE_WORKSPACE_FILE, \\\n+      SOURCE_FILES := $(TOPDIR)\/make\/ide\/eclipse\/workspace.template, \\\n+      OUTPUT_FILE := $$($1_WORKSPACE_FILE), \\\n+      REPLACEMENTS := \\\n+          @@BUILD_MANAGERS@@ => $$($1_BUILD_MANAGERS) ; \\\n+          @@NATURES@@ => $$($1_NATURES) ; \\\n+          @@LINKED_RESOURCES@@ => $$($1_LINKED_RESOURCES), \\\n+  ))\n+\n+  TARGETS += $$($1_CREATE_WORKSPACE_FILE)\n+\n+endef\n+\n+ifeq ($(WORKSPACE), java)\n+  $(eval $(call SetupEclipseWorkspace, SETUP_WORKSPACE, \\\n+      NATURE := JAVA, \\\n+      SHARED := $(SHARED), \\\n+  ))\n+else ifeq ($(WORKSPACE), hotspot)\n+  $(eval $(call SetupEclipseWorkspace, SETUP_WORKSPACE, \\\n+      NATURE := HOTSPOT, \\\n+      SHARED := $(SHARED), \\\n+  ))\n+else ifeq ($(WORKSPACE), native)\n+  $(eval $(call SetupEclipseWorkspace, SETUP_WORKSPACE, \\\n+      NATURE := NATIVE, \\\n+      SHARED := $(SHARED), \\\n+  ))\n+else\n+  $(eval $(call SetupEclipseWorkspace, SETUP_WORKSPACE, \\\n+      NATURE := MIXED, \\\n+      SHARED := $(SHARED), \\\n+  ))\n+endif\n+\n+all: $(TARGETS)\n","filename":"make\/ide\/eclipse\/CreateWorkspace.gmk","additions":390,"deletions":0,"binary":false,"changes":390,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<classpath>\n+    @@CLASSPATH@@\n+<\/classpath>\n","filename":"make\/ide\/eclipse\/classpath.template","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<?fileVersion 4.0.0?><cproject storage_type_id=\"org.eclipse.cdt.core.XmlProjectDescriptionStorage\">\n+    <storageModule moduleId=\"org.eclipse.cdt.core.language.mapping\">\n+        <project-mappings>\n+            <content-type-mapping configuration=\"\" content-type=\"org.eclipse.cdt.core.cHeader\" language=\"org.eclipse.cdt.core.c\"\/>\n+            <content-type-mapping configuration=\"\" content-type=\"org.eclipse.cdt.core.cSource\" language=\"org.eclipse.cdt.core.c\"\/>\n+            <content-type-mapping configuration=\"\" content-type=\"org.eclipse.cdt.core.cxxHeader\" language=\"org.eclipse.cdt.core.c++\"\/>\n+            <content-type-mapping configuration=\"\" content-type=\"org.eclipse.cdt.core.cxxSource\" language=\"org.eclipse.cdt.core.c++\"\/>\n+        <\/project-mappings>\n+    <\/storageModule>\n+\n+    <storageModule moduleId=\"scannerConfiguration\">\n+        <autodiscovery enabled=\"true\" problemReportingEnabled=\"true\" selectedProfileId=\"\"\/>\n+    <\/storageModule>\n+\n+    <storageModule moduleId=\"org.eclipse.cdt.core.LanguageSettingsProviders\"\/>\n+\n+    <storageModule moduleId=\"org.eclipse.cdt.core.settings\">\n+        <cconfiguration id=\"cdt.managedbuild.toolchain.gnu.cross.base.@@WORKSPACE@@\">\n+            <storageModule moduleId=\"org.eclipse.cdt.core.externalSettings\"\/>\n+\n+            <storageModule buildSystemId=\"org.eclipse.cdt.managedbuilder.core.configurationDataProvider\" id=\"cdt.managedbuild.toolchain.gnu.cross.base.@@WORKSPACE@@\" moduleId=\"org.eclipse.cdt.core.settings\" name=\"C\/C++\">\n+                <externalSettings\/>\n+                <extensions>\n+                    <extension id=\"org.eclipse.cdt.core.ELF\" point=\"org.eclipse.cdt.core.BinaryParser\"\/>\n+                    <extension id=\"org.eclipse.cdt.core.GASErrorParser\" point=\"org.eclipse.cdt.core.ErrorParser\"\/>\n+                    <extension id=\"org.eclipse.cdt.core.GmakeErrorParser\" point=\"org.eclipse.cdt.core.ErrorParser\"\/>\n+                    <extension id=\"org.eclipse.cdt.core.GLDErrorParser\" point=\"org.eclipse.cdt.core.ErrorParser\"\/>\n+                    <extension id=\"org.eclipse.cdt.core.CWDLocator\" point=\"org.eclipse.cdt.core.ErrorParser\"\/>\n+                    <extension id=\"org.eclipse.cdt.core.GCCErrorParser\" point=\"org.eclipse.cdt.core.ErrorParser\"\/>\n+                <\/extensions>\n+            <\/storageModule>\n+\n+            <storageModule moduleId=\"cdtBuildSystem\" version=\"4.0.0\">\n+                <configuration buildProperties=\"\" description=\"\" id=\"cdt.managedbuild.toolchain.gnu.cross.base.@@WORKSPACE@@\" name=\"C\/C++\" parent=\"org.eclipse.cdt.build.core.emptycfg\">\n+                    <folderInfo id=\"cdt.managedbuild.toolchain.gnu.cross.base.@@WORKSPACE@@.@@MINOR@@\" name=\"\/\" resourcePath=\"\">\n+                        <toolChain id=\"cdt.managedbuild.toolchain.gnu.cross.base.@@MINOR@@\" name=\"Cross GCC\" superClass=\"cdt.managedbuild.toolchain.gnu.cross.base\">\n+                            <option id=\"cdt.managedbuild.option.gnu.cross.path.@@MINOR@@\" name=\"Path\" superClass=\"cdt.managedbuild.option.gnu.cross.path\" value=\"@@ENV@@\" valueType=\"string\"\/>\n+                            <targetPlatform archList=\"all\" binaryParser=\"\" id=\"cdt.managedbuild.targetPlatform.gnu.cross.@@WORKSPACE@@\" isAbstract=\"false\" osList=\"all\" superClass=\"cdt.managedbuild.targetPlatform.gnu.cross\"\/>\n+                            <builder command=\"@@MAKE@@\" arguments=\"-C @@DIR@@\" id=\"cdt.managedbuild.builder.gnu.cross.@@MINOR@@\" incrementalBuildTarget=\"jdk\" keepEnvironmentInBuildfile=\"false\" managedBuildOn=\"false\" name=\"Gnu Make Builder\" parallelBuildOn=\"false\" superClass=\"cdt.managedbuild.builder.gnu.cross\"\/>\n+                        <\/toolChain>\n+                    <\/folderInfo>\n+                    <sourceEntries>\n+                        @@SRC@@\n+                    <\/sourceEntries>\n+                <\/configuration>\n+            <\/storageModule>\n+        <\/cconfiguration>\n+    <\/storageModule>\n+\n+    <storageModule moduleId=\"org.eclipse.cdt.make.core.buildtargets\">\n+        <buildTargets>\n+            @@MAKE_TARGETS@@\n+        <\/buildTargets>\n+    <\/storageModule>\n+<\/cproject>\n","filename":"make\/ide\/eclipse\/native.template","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,22 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<project>\n+    <configuration id=\"cdt.managedbuild.toolchain.gnu.cross.base.@@WORKSPACE@@\" name=\"C\/C++\">\n+        <extension point=\"org.eclipse.cdt.core.LanguageSettingsProvider\">\n+            <provider build-parser-id=\"\" cdb-modified-time=\"\" class=\"org.eclipse.cdt.managedbuilder.internal.language.settings.providers.CompilationDatabaseParser\" id=\"org.eclipse.cdt.managedbuilder.core.CompilationDatabaseParser\" name=\"Compilation Database Parser\" prefer-non-shared=\"true\" store-entries-with-project=\"true\"\/>\n+            <provider class=\"org.eclipse.cdt.managedbuilder.language.settings.providers.GCCBuildCommandParser\" id=\"org.eclipse.cdt.managedbuilder.core.GCCBuildCommandParser\" keep-relative-paths=\"false\" name=\"CDT GCC Build Output Parser\" parameter=\"([^\/\\\\\\\\]*)((g?cc)|([gc]\\+\\+)|(clang))\" prefer-non-shared=\"true\" store-entries-with-project=\"true\"\/>\n+            <provider class=\"org.eclipse.cdt.internal.build.crossgcc.CrossGCCBuiltinSpecsDetector\" console=\"true\" env-hash=\"\" id=\"org.eclipse.cdt.build.crossgcc.CrossGCCBuiltinSpecsDetector\" keep-relative-paths=\"false\" name=\"CDT Cross GCC Built-in Compiler Settings\" parameter=\"${COMMAND} ${FLAGS} -E -P -v -dD &quot;${INPUTS}&quot;\" prefer-non-shared=\"true\" store-entries-with-project=\"true\">\n+                <language-scope id=\"org.eclipse.cdt.core.c\"\/>\n+                <language-scope id=\"org.eclipse.cdt.core.c++\"\/>\n+            <\/provider>\n+            <provider class=\"org.eclipse.cdt.core.language.settings.providers.LanguageSettingsGenericProvider\" id=\"org.eclipse.cdt.ui.UserLanguageSettingsProvider\" name=\"CDT User Setting Entries\" prefer-non-shared=\"true\" store-entries-with-project=\"true\">\n+                <language id=\"org.eclipse.cdt.core.c\">\n+                    @@CSETTINGS@@\n+                <\/language>\n+\n+                <language id=\"org.eclipse.cdt.core.c++\">\n+                    @@CXXSETTINGS@@\n+                <\/language>\n+           <\/provider>\n+        <\/extension>\n+    <\/configuration>\n+<\/project>\n","filename":"make\/ide\/eclipse\/settings.template","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<projectDescription>\n+    <name>jdk<\/name>\n+    <comment>The HotSpot Virtual Machine, Runtime Environment, and Development Kit<\/comment>\n+    <projects>\n+    <\/projects>\n+    <buildSpec>\n+        @@BUILD_MANAGERS@@\n+    <\/buildSpec>\n+    <natures>\n+        @@NATURES@@\n+    <\/natures>\n+    <linkedResources>\n+        @@LINKED_RESOURCES@@\n+    <\/linkedResources>\n+<\/projectDescription>\n","filename":"make\/ide\/eclipse\/workspace.template","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -50,2 +50,0 @@\n-    DISABLED_WARNINGS_microsoft_NetworkInterface.c := 4133, \\\n-    DISABLED_WARNINGS_microsoft_NetworkInterface_winXP.c := 4133, \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -454,1 +454,1 @@\n-     HARFBUZZ_CFLAGS += -DHAVE_INTEL_ATOMIC_PRIMITIVES\n+     HARFBUZZ_CFLAGS += -DHAVE_INTEL_ATOMIC_PRIMITIVES -DHB_NO_VISIBILITY\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+JAVAC_FLAGS += --enable-preview\n+DISABLED_WARNINGS_java += preview\n","filename":"make\/modules\/jdk.jartool\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-    SRC := $(TEST_LIB_SOURCE_DIR)\/sun $(TEST_LIB_SOURCE_DIR)\/jdk\/test\/whitebox\/parser, \\\n+    SRC := $(TEST_LIB_SOURCE_DIR)\/jdk\/test\/whitebox\/parser, \\\n@@ -42,1 +42,2 @@\n-    DISABLED_WARNINGS := deprecation removal, \\\n+    DISABLED_WARNINGS := deprecation removal preview, \\\n+    JAVAC_FLAGS := --enable-preview, \\\n@@ -54,1 +55,2 @@\n-    DISABLED_WARNINGS := try deprecation rawtypes unchecked serial cast removal, \\\n+    DISABLED_WARNINGS := try deprecation rawtypes unchecked serial cast removal preview, \\\n+    JAVAC_FLAGS := --enable-preview, \\\n","filename":"make\/test\/BuildTestLib.gmk","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1909,1 +1909,1 @@\n-    __ cmgt($dst$$FloatRegister, __ T2D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ cm(Assembler::GT, $dst$$FloatRegister, __ T2D, $src1$$FloatRegister, $src2$$FloatRegister);\n@@ -1996,1 +1996,1 @@\n-    __ cmgt($dst$$FloatRegister, __ T2D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ cm(Assembler::GT, $dst$$FloatRegister, __ T2D, $src1$$FloatRegister, $src2$$FloatRegister);\n@@ -5131,0 +5131,1 @@\n+    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)$cond$$constant);\n@@ -5134,2 +5135,1 @@\n-                    $src2$$FloatRegister, (int)($cond$$constant),\n-                    \/* isQ *\/ length_in_bytes == 16);\n+                    $src2$$FloatRegister, condition, \/* isQ *\/ length_in_bytes == 16);\n@@ -5201,0 +5201,1 @@\n+    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)$cond$$constant);\n@@ -5205,1 +5206,1 @@\n-                   $src2$$FloatRegister, (int)($cond$$constant));\n+                   $src2$$FloatRegister, condition);\n@@ -5217,0 +5218,1 @@\n+    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)$cond$$constant);\n@@ -5219,1 +5221,1 @@\n-                   $src2$$FloatRegister, (int)($cond$$constant));\n+                   $src2$$FloatRegister, condition);\n@@ -5879,0 +5881,1 @@\n+    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)$cond$$constant);\n@@ -5883,2 +5886,1 @@\n-                    $src2$$FloatRegister, (int)($cond$$constant),\n-                    \/* isQ *\/ length_in_bytes == 16);\n+                    $src2$$FloatRegister, condition, \/* isQ *\/ length_in_bytes == 16);\n@@ -5900,0 +5902,1 @@\n+    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)$cond$$constant);\n@@ -5903,1 +5906,1 @@\n-                   $src2$$FloatRegister, (int)($cond$$constant));\n+                   $src2$$FloatRegister, condition);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1004,1 +1004,1 @@\n-    __ cmgt($dst$$FloatRegister, __ T2D, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ cm(Assembler::GT, $dst$$FloatRegister, __ T2D, $src1$$FloatRegister, $src2$$FloatRegister);\n@@ -3547,0 +3547,1 @@\n+    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)$cond$$constant);\n@@ -3550,2 +3551,1 @@\n-                    $src2$$FloatRegister, (int)($cond$$constant),\n-                    \/* isQ *\/ length_in_bytes == 16);\n+                    $src2$$FloatRegister, condition, \/* isQ *\/ length_in_bytes == 16);\n@@ -3598,0 +3598,1 @@\n+    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)$cond$$constant);\n@@ -3602,1 +3603,1 @@\n-                   $src2$$FloatRegister, (int)($cond$$constant));\n+                   $src2$$FloatRegister, condition);\n@@ -3614,0 +3615,1 @@\n+    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)$cond$$constant);\n@@ -3616,1 +3618,1 @@\n-                   $src2$$FloatRegister, (int)($cond$$constant));\n+                   $src2$$FloatRegister, condition);\n@@ -4232,0 +4234,1 @@\n+    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)$cond$$constant);\n@@ -4236,2 +4239,1 @@\n-                    $src2$$FloatRegister, (int)($cond$$constant),\n-                    \/* isQ *\/ length_in_bytes == 16);\n+                    $src2$$FloatRegister, condition, \/* isQ *\/ length_in_bytes == 16);\n@@ -4253,0 +4255,1 @@\n+    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)$cond$$constant);\n@@ -4256,1 +4259,1 @@\n-                   $src2$$FloatRegister, (int)($cond$$constant));\n+                   $src2$$FloatRegister, condition);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2623,5 +2623,0 @@\n-  INSN(cmeq,   1, 0b100011, true);  \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n-  INSN(cmgt,   0, 0b001101, true);  \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n-  INSN(cmge,   0, 0b001111, true);  \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n-  INSN(cmhi,   1, 0b001101, true);  \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n-  INSN(cmhs,   1, 0b001111, true);  \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n@@ -2733,3 +2728,0 @@\n-  INSN(fcmeq, 0, 0, 0b111001);\n-  INSN(fcmgt, 1, 1, 0b111001);\n-  INSN(fcmge, 1, 0, 0b111001);\n@@ -2740,0 +2732,40 @@\n+  \/\/ AdvSIMD vector compare\n+  void cm(Condition cond, FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) {\n+    starti;\n+    assert(T != T1Q && T != T1D, \"incorrect arrangement\");\n+    int cond_op;\n+    switch (cond) {\n+      case EQ: cond_op = 0b110001; break;\n+      case GT: cond_op = 0b000110; break;\n+      case GE: cond_op = 0b000111; break;\n+      case HI: cond_op = 0b100110; break;\n+      case HS: cond_op = 0b100111; break;\n+      default:\n+        ShouldNotReachHere();\n+        break;\n+    }\n+\n+    f(0, 31), f((int)T & 1, 30), f((cond_op >> 5) & 1, 29);\n+    f(0b01110, 28, 24), f((int)T >> 1, 23, 22), f(1, 21), rf(Vm, 16);\n+    f(cond_op & 0b11111, 15, 11), f(1, 10), rf(Vn, 5), rf(Vd, 0);\n+  }\n+\n+  \/\/ AdvSIMD Floating-point vector compare\n+  void fcm(Condition cond, FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) {\n+    starti;\n+    assert(T == T2S || T == T4S || T == T2D, \"invalid arrangement\");\n+    int cond_op;\n+    switch (cond) {\n+      case EQ: cond_op = 0b00; break;\n+      case GT: cond_op = 0b11; break;\n+      case GE: cond_op = 0b10; break;\n+      default:\n+        ShouldNotReachHere();\n+        break;\n+    }\n+\n+    f(0, 31), f((int)T & 1, 30), f((cond_op >> 1) & 1, 29);\n+    f(0b01110, 28, 24), f(cond_op & 1, 23), f(T == T2D ? 1 : 0, 22);\n+    f(1, 21), rf(Vm, 16), f(0b111001, 15, 10), rf(Vn, 5), rf(Vd, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":40,"deletions":8,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -921,1 +921,1 @@\n-                                     FloatRegister src2, int cond, bool isQ) {\n+                                     FloatRegister src2, Condition cond, bool isQ) {\n@@ -923,16 +923,14 @@\n-  if (bt == T_FLOAT || bt == T_DOUBLE) {\n-    switch (cond) {\n-      case BoolTest::eq: fcmeq(dst, size, src1, src2); break;\n-      case BoolTest::ne: {\n-        fcmeq(dst, size, src1, src2);\n-        notr(dst, isQ ? T16B : T8B, dst);\n-        break;\n-      }\n-      case BoolTest::ge: fcmge(dst, size, src1, src2); break;\n-      case BoolTest::gt: fcmgt(dst, size, src1, src2); break;\n-      case BoolTest::le: fcmge(dst, size, src2, src1); break;\n-      case BoolTest::lt: fcmgt(dst, size, src2, src1); break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n+  FloatRegister zn = src1, zm = src2;\n+  bool needs_negation = false;\n+  switch (cond) {\n+    case LT: cond = GT; zn = src2; zm = src1; break;\n+    case LE: cond = GE; zn = src2; zm = src1; break;\n+    case LO: cond = HI; zn = src2; zm = src1; break;\n+    case LS: cond = HS; zn = src2; zm = src1; break;\n+    case NE: cond = EQ; needs_negation = true; break;\n+    default:\n+      break;\n+  }\n+\n+  if (is_floating_point_type(bt)) {\n+    fcm(cond, dst, size, zn, zm);\n@@ -940,19 +938,5 @@\n-    switch (cond) {\n-      case BoolTest::eq: cmeq(dst, size, src1, src2); break;\n-      case BoolTest::ne: {\n-        cmeq(dst, size, src1, src2);\n-        notr(dst, isQ ? T16B : T8B, dst);\n-        break;\n-      }\n-      case BoolTest::ge: cmge(dst, size, src1, src2); break;\n-      case BoolTest::gt: cmgt(dst, size, src1, src2); break;\n-      case BoolTest::le: cmge(dst, size, src2, src1); break;\n-      case BoolTest::lt: cmgt(dst, size, src2, src1); break;\n-      case BoolTest::uge: cmhs(dst, size, src1, src2); break;\n-      case BoolTest::ugt: cmhi(dst, size, src1, src2); break;\n-      case BoolTest::ult: cmhi(dst, size, src2, src1); break;\n-      case BoolTest::ule: cmhs(dst, size, src2, src1); break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n+    cm(cond, dst, size, zn, zm);\n+  }\n+\n+  if (needs_negation) {\n+    notr(dst, isQ ? T16B : T8B, dst);\n@@ -1128,1 +1112,1 @@\n-                                    FloatRegister zn, FloatRegister zm, int cond) {\n+                                    FloatRegister zn, FloatRegister zm, Condition cond) {\n@@ -1131,2 +1115,0 @@\n-  \/\/ Convert the original BoolTest condition to Assembler::condition.\n-  Condition condition;\n@@ -1134,6 +1116,4 @@\n-    case BoolTest::eq: condition = Assembler::EQ; break;\n-    case BoolTest::ne: condition = Assembler::NE; break;\n-    case BoolTest::le: z1 = zm; z2 = zn; condition = Assembler::GE; break;\n-    case BoolTest::ge: condition = Assembler::GE; break;\n-    case BoolTest::lt: z1 = zm; z2 = zn; condition = Assembler::GT; break;\n-    case BoolTest::gt: condition = Assembler::GT; break;\n+    case LE: z1 = zm; z2 = zn; cond = GE; break;\n+    case LT: z1 = zm; z2 = zn; cond = GT; break;\n+    case LO: z1 = zm; z2 = zn; cond = HI; break;\n+    case LS: z1 = zm; z2 = zn; cond = HS; break;\n@@ -1141,2 +1121,1 @@\n-      assert(false, \"unsupported compare condition\");\n-      ShouldNotReachHere();\n+      break;\n@@ -1146,2 +1125,2 @@\n-  if (bt == T_FLOAT || bt == T_DOUBLE) {\n-    sve_fcm(condition, pd, size, pg, z1, z2);\n+  if (is_floating_point_type(bt)) {\n+    sve_fcm(cond, pd, size, pg, z1, z2);\n@@ -1150,1 +1129,1 @@\n-    sve_cmp(condition, pd, size, pg, z1, z2);\n+    sve_cmp(cond, pd, size, pg, z1, z2);\n@@ -1982,1 +1961,1 @@\n-  cmhs(tmp3, T, tmp3, tmp2);\n+  cm(HS, tmp3, T, tmp3, tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":30,"deletions":51,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-                    FloatRegister src2, int cond, bool isQ);\n+                    FloatRegister src2, Condition cond, bool isQ);\n@@ -86,1 +86,1 @@\n-                   FloatRegister zn, FloatRegister zm, int cond);\n+                   FloatRegister zn, FloatRegister zm, Condition cond);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,2 @@\n-static const int native_invoker_code_size = 1024;\n+static const int native_invoker_code_base_size = 256;\n+static const int native_invoker_size_per_arg = 8;\n@@ -105,4 +106,4 @@\n-                                                int captured_state_mask,\n-                                                bool needs_transition) {\n-  int locs_size = 64;\n-  CodeBuffer code(\"nep_invoker_blob\", native_invoker_code_size, locs_size);\n+                                                int captured_state_mask) {\n+  int code_size = native_invoker_code_base_size + (num_args * native_invoker_size_per_arg);\n+  int locs_size = 1; \/\/ must be non-zero\n+  CodeBuffer code(\"nep_invoker_blob\", code_size, locs_size);\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,2 +148,1 @@\n-    \/\/ Not supported on SVE yet.\n-    return !UseSVE;\n+    return true;\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -794,1 +794,0 @@\n-  __ flush();\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -6415,4 +6415,4 @@\n-    __ cmhi(decH0, arrangement, decL0, v27);\n-    __ cmhi(decH1, arrangement, decL1, v27);\n-    __ cmhi(decH2, arrangement, decL2, v27);\n-    __ cmhi(decH3, arrangement, decL3, v27);\n+    __ cm(Assembler::HI, decH0, arrangement, decL0, v27);\n+    __ cm(Assembler::HI, decH1, arrangement, decL1, v27);\n+    __ cm(Assembler::HI, decH2, arrangement, decL2, v27);\n+    __ cm(Assembler::HI, decH3, arrangement, decL3, v27);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -149,2 +149,0 @@\n-  if (!InlineIntrinsics) return NULL; \/\/ Generate a vanilla entry\n-\n@@ -304,6 +302,1 @@\n-  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n-  if (!VM_Version::supports_float16() ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat) ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16)) {\n-    return nullptr;\n-  }\n+  assert(VM_Version::supports_float16(), \"this intrinsic is not supported\");\n@@ -326,6 +319,1 @@\n-  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n-  if (!VM_Version::supports_float16() ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat) ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16)) {\n-    return nullptr;\n-  }\n+  assert(VM_Version::supports_float16(), \"this intrinsic is not supported\");\n@@ -966,2 +954,2 @@\n-  if (UseCRC32Intrinsics) {\n-    address entry = __ pc();\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n@@ -969,3 +957,3 @@\n-    \/\/ rmethod: Method*\n-    \/\/ r19_sender_sp: senderSP must preserved for slow path\n-    \/\/ esp: args\n+  \/\/ rmethod: Method*\n+  \/\/ r19_sender_sp: senderSP must preserved for slow path\n+  \/\/ esp: args\n@@ -973,3 +961,3 @@\n-    Label slow_path;\n-    \/\/ If we need a safepoint check, generate full interpreter entry.\n-    __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  Label slow_path;\n+  \/\/ If we need a safepoint check, generate full interpreter entry.\n+  __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n@@ -977,2 +965,2 @@\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n@@ -980,4 +968,4 @@\n-    \/\/ Load parameters\n-    const Register crc = c_rarg0;  \/\/ crc\n-    const Register val = c_rarg1;  \/\/ source java byte value\n-    const Register tbl = c_rarg2;  \/\/ scratch\n+  \/\/ Load parameters\n+  const Register crc = c_rarg0;  \/\/ crc\n+  const Register val = c_rarg1;  \/\/ source java byte value\n+  const Register tbl = c_rarg2;  \/\/ scratch\n@@ -985,3 +973,3 @@\n-    \/\/ Arguments are reversed on java expression stack\n-    __ ldrw(val, Address(esp, 0));              \/\/ byte value\n-    __ ldrw(crc, Address(esp, wordSize));       \/\/ Initial CRC\n+  \/\/ Arguments are reversed on java expression stack\n+  __ ldrw(val, Address(esp, 0));              \/\/ byte value\n+  __ ldrw(crc, Address(esp, wordSize));       \/\/ Initial CRC\n@@ -989,3 +977,3 @@\n-    uint64_t offset;\n-    __ adrp(tbl, ExternalAddress(StubRoutines::crc_table_addr()), offset);\n-    __ add(tbl, tbl, offset);\n+  uint64_t offset;\n+  __ adrp(tbl, ExternalAddress(StubRoutines::crc_table_addr()), offset);\n+  __ add(tbl, tbl, offset);\n@@ -993,3 +981,3 @@\n-    __ mvnw(crc, crc); \/\/ ~crc\n-    __ update_byte_crc32(crc, val, tbl);\n-    __ mvnw(crc, crc); \/\/ ~crc\n+  __ mvnw(crc, crc); \/\/ ~crc\n+  __ update_byte_crc32(crc, val, tbl);\n+  __ mvnw(crc, crc); \/\/ ~crc\n@@ -997,1 +985,1 @@\n-    \/\/ result in c_rarg0\n+  \/\/ result in c_rarg0\n@@ -999,2 +987,2 @@\n-    __ andr(sp, r19_sender_sp, -16);\n-    __ ret(lr);\n+  __ andr(sp, r19_sender_sp, -16);\n+  __ ret(lr);\n@@ -1002,6 +990,4 @@\n-    \/\/ generate a vanilla native entry as the slow path\n-    __ bind(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n-    return entry;\n-  }\n-  return NULL;\n+  \/\/ generate a vanilla native entry as the slow path\n+  __ bind(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n+  return entry;\n@@ -1016,2 +1002,2 @@\n-  if (UseCRC32Intrinsics) {\n-    address entry = __ pc();\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n@@ -1019,32 +1005,32 @@\n-    \/\/ rmethod,: Method*\n-    \/\/ r19_sender_sp: senderSP must preserved for slow path\n-\n-    Label slow_path;\n-    \/\/ If we need a safepoint check, generate full interpreter entry.\n-    __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n-\n-    \/\/ Load parameters\n-    const Register crc = c_rarg0;  \/\/ crc\n-    const Register buf = c_rarg1;  \/\/ source java byte array address\n-    const Register len = c_rarg2;  \/\/ length\n-    const Register off = len;      \/\/ offset (never overlaps with 'len')\n-\n-    \/\/ Arguments are reversed on java expression stack\n-    \/\/ Calculate address of start element\n-    if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) {\n-      __ ldr(buf, Address(esp, 2*wordSize)); \/\/ long buf\n-      __ ldrw(off, Address(esp, wordSize)); \/\/ offset\n-      __ add(buf, buf, off); \/\/ + offset\n-      __ ldrw(crc,   Address(esp, 4*wordSize)); \/\/ Initial CRC\n-    } else {\n-      __ ldr(buf, Address(esp, 2*wordSize)); \/\/ byte[] array\n-      __ add(buf, buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n-      __ ldrw(off, Address(esp, wordSize)); \/\/ offset\n-      __ add(buf, buf, off); \/\/ + offset\n-      __ ldrw(crc,   Address(esp, 3*wordSize)); \/\/ Initial CRC\n-    }\n-    \/\/ Can now load 'len' since we're finished with 'off'\n-    __ ldrw(len, Address(esp, 0x0)); \/\/ Length\n+  \/\/ rmethod,: Method*\n+  \/\/ r19_sender_sp: senderSP must preserved for slow path\n+\n+  Label slow_path;\n+  \/\/ If we need a safepoint check, generate full interpreter entry.\n+  __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n+\n+  \/\/ Load parameters\n+  const Register crc = c_rarg0;  \/\/ crc\n+  const Register buf = c_rarg1;  \/\/ source java byte array address\n+  const Register len = c_rarg2;  \/\/ length\n+  const Register off = len;      \/\/ offset (never overlaps with 'len')\n+\n+  \/\/ Arguments are reversed on java expression stack\n+  \/\/ Calculate address of start element\n+  if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) {\n+    __ ldr(buf, Address(esp, 2*wordSize)); \/\/ long buf\n+    __ ldrw(off, Address(esp, wordSize)); \/\/ offset\n+    __ add(buf, buf, off); \/\/ + offset\n+    __ ldrw(crc,   Address(esp, 4*wordSize)); \/\/ Initial CRC\n+  } else {\n+    __ ldr(buf, Address(esp, 2*wordSize)); \/\/ byte[] array\n+    __ add(buf, buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n+    __ ldrw(off, Address(esp, wordSize)); \/\/ offset\n+    __ add(buf, buf, off); \/\/ + offset\n+    __ ldrw(crc,   Address(esp, 3*wordSize)); \/\/ Initial CRC\n+  }\n+  \/\/ Can now load 'len' since we're finished with 'off'\n+  __ ldrw(len, Address(esp, 0x0)); \/\/ Length\n@@ -1052,1 +1038,1 @@\n-    __ andr(sp, r19_sender_sp, -16); \/\/ Restore the caller's SP\n+  __ andr(sp, r19_sender_sp, -16); \/\/ Restore the caller's SP\n@@ -1054,2 +1040,2 @@\n-    \/\/ We are frameless so we can just jump to the stub.\n-    __ b(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32()));\n+  \/\/ We are frameless so we can just jump to the stub.\n+  __ b(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32()));\n@@ -1057,6 +1043,4 @@\n-    \/\/ generate a vanilla native entry as the slow path\n-    __ bind(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n-    return entry;\n-  }\n-  return NULL;\n+  \/\/ generate a vanilla native entry as the slow path\n+  __ bind(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n+  return entry;\n@@ -1073,10 +1057,2 @@\n-  if (UseCRC32CIntrinsics) {\n-    address entry = __ pc();\n-\n-    \/\/ Prepare jump to stub using parameters from the stack\n-    const Register crc = c_rarg0; \/\/ initial crc\n-    const Register buf = c_rarg1; \/\/ source java byte array address\n-    const Register len = c_rarg2; \/\/ len argument to the kernel\n-\n-    const Register end = len; \/\/ index of last element to process\n-    const Register off = crc; \/\/ offset\n+  assert(UseCRC32CIntrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n@@ -1084,11 +1060,19 @@\n-    __ ldrw(end, Address(esp)); \/\/ int end\n-    __ ldrw(off, Address(esp, wordSize)); \/\/ int offset\n-    __ sub(len, end, off);\n-    __ ldr(buf, Address(esp, 2*wordSize)); \/\/ byte[] buf | long buf\n-    __ add(buf, buf, off); \/\/ + offset\n-    if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) {\n-      __ ldrw(crc, Address(esp, 4*wordSize)); \/\/ long crc\n-    } else {\n-      __ add(buf, buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n-      __ ldrw(crc, Address(esp, 3*wordSize)); \/\/ long crc\n-    }\n+  \/\/ Prepare jump to stub using parameters from the stack\n+  const Register crc = c_rarg0; \/\/ initial crc\n+  const Register buf = c_rarg1; \/\/ source java byte array address\n+  const Register len = c_rarg2; \/\/ len argument to the kernel\n+\n+  const Register end = len; \/\/ index of last element to process\n+  const Register off = crc; \/\/ offset\n+\n+  __ ldrw(end, Address(esp)); \/\/ int end\n+  __ ldrw(off, Address(esp, wordSize)); \/\/ int offset\n+  __ sub(len, end, off);\n+  __ ldr(buf, Address(esp, 2*wordSize)); \/\/ byte[] buf | long buf\n+  __ add(buf, buf, off); \/\/ + offset\n+  if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) {\n+    __ ldrw(crc, Address(esp, 4*wordSize)); \/\/ long crc\n+  } else {\n+    __ add(buf, buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n+    __ ldrw(crc, Address(esp, 3*wordSize)); \/\/ long crc\n+  }\n@@ -1096,1 +1080,1 @@\n-    __ andr(sp, r19_sender_sp, -16); \/\/ Restore the caller's SP\n+  __ andr(sp, r19_sender_sp, -16); \/\/ Restore the caller's SP\n@@ -1098,2 +1082,2 @@\n-    \/\/ Jump to the stub.\n-    __ b(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32C()));\n+  \/\/ Jump to the stub.\n+  __ b(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32C()));\n@@ -1101,3 +1085,1 @@\n-    return entry;\n-  }\n-  return NULL;\n+  return entry;\n@@ -1745,0 +1727,5 @@\n+\/\/ Not supported\n+address TemplateInterpreterGenerator::generate_Float_intBitsToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToRawIntBits_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_longBitsToDouble_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_doubleToRawLongBits_entry() { return nullptr; }\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":103,"deletions":116,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,0 +117,3 @@\n+static const int upcall_stub_code_base_size = 1024;\n+static const int upcall_stub_size_per_arg = 16;\n+\n@@ -126,1 +129,2 @@\n-  CodeBuffer buffer(\"upcall_stub\", \/* code_size = *\/ 2048, \/* locs_size = *\/ 1024);\n+  int code_size = upcall_stub_code_base_size + (total_in_args * upcall_stub_size_per_arg);\n+  CodeBuffer buffer(\"upcall_stub\", code_size, \/* locs_size = *\/ 1);\n@@ -328,0 +332,2 @@\n+  buffer.log_section_sizes(name);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/upcallLinker_aarch64.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -648,1 +648,0 @@\n-  __ flush();\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -125,2 +125,0 @@\n-  if (!InlineIntrinsics) return nullptr; \/\/ Generate a vanilla entry\n-\n@@ -783,0 +781,1 @@\n+address TemplateInterpreterGenerator::generate_currentThread() { return nullptr; }\n@@ -786,0 +785,4 @@\n+address TemplateInterpreterGenerator::generate_Float_intBitsToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToRawIntBits_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_longBitsToDouble_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_doubleToRawLongBits_entry() { return nullptr; }\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -560,0 +560,2 @@\n+  \/\/ Prevent assertion if f gets deoptimized right away before it's fully initialized\n+  f.mark_not_fully_initialized();\n","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n@@ -355,0 +355,7 @@\n+#ifdef ASSERT\n+  enum special_backlink_values : uint64_t {\n+    NOT_FULLY_INITIALIZED = 0xBBAADDF9\n+  };\n+  bool is_fully_initialized()       const { return (uint64_t)_fp != NOT_FULLY_INITIALIZED; }\n+#endif \/\/ ASSERT\n+\n@@ -382,0 +389,3 @@\n+  \/\/ Mark a frame as not fully initialized. Must not be used for frames in the valid back chain.\n+  void mark_not_fully_initialized() const { DEBUG_ONLY(own_abi()->callers_sp = NOT_FULLY_INITIALIZED;)  }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2015 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n@@ -80,1 +80,3 @@\n-  assert(_on_heap || (is_aligned(_sp, alignment_in_bytes) || is_interpreted_frame()) && is_aligned(_fp, alignment_in_bytes),\n+  assert(_on_heap ||\n+         (is_aligned(_sp, alignment_in_bytes) || is_interpreted_frame()) &&\n+         (is_aligned(_fp, alignment_in_bytes) || !is_fully_initialized()),\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1749,3 +1749,3 @@\n-  if (UseCRC32Intrinsics) {\n-    address start = __ pc();  \/\/ Remember stub start address (is rtn value).\n-    Label slow_path;\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address start = __ pc();  \/\/ Remember stub start address (is rtn value).\n+  Label slow_path;\n@@ -1753,3 +1753,3 @@\n-    \/\/ Safepoint check\n-    const Register sync_state = R11_scratch1;\n-    __ safepoint_poll(slow_path, sync_state, false \/* at_return *\/, false \/* in_nmethod *\/);\n+  \/\/ Safepoint check\n+  const Register sync_state = R11_scratch1;\n+  __ safepoint_poll(slow_path, sync_state, false \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -1757,3 +1757,3 @@\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we not even call stub code (we generate the code inline)\n-    \/\/ and there is no safepoint on this path.\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we not even call stub code (we generate the code inline)\n+  \/\/ and there is no safepoint on this path.\n@@ -1761,6 +1761,6 @@\n-    \/\/ Load java parameters.\n-    \/\/ R15_esp is callers operand stack pointer, i.e. it points to the parameters.\n-    const Register argP    = R15_esp;\n-    const Register crc     = R3_ARG1;  \/\/ crc value\n-    const Register data    = R4_ARG2;\n-    const Register table   = R5_ARG3;  \/\/ address of crc32 table\n+  \/\/ Load java parameters.\n+  \/\/ R15_esp is callers operand stack pointer, i.e. it points to the parameters.\n+  const Register argP    = R15_esp;\n+  const Register crc     = R3_ARG1;  \/\/ crc value\n+  const Register data    = R4_ARG2;\n+  const Register table   = R5_ARG3;  \/\/ address of crc32 table\n@@ -1768,1 +1768,1 @@\n-    BLOCK_COMMENT(\"CRC32_update {\");\n+  BLOCK_COMMENT(\"CRC32_update {\");\n@@ -1770,1 +1770,1 @@\n-    \/\/ Arguments are reversed on java expression stack\n+  \/\/ Arguments are reversed on java expression stack\n@@ -1772,2 +1772,2 @@\n-    int data_offs = 0+1*wordSize;      \/\/ (stack) address of byte value. Emitter expects address, not value.\n-                                       \/\/ Being passed as an int, the single byte is at offset +0.\n+  int data_offs = 0+1*wordSize;      \/\/ (stack) address of byte value. Emitter expects address, not value.\n+                                     \/\/ Being passed as an int, the single byte is at offset +0.\n@@ -1775,2 +1775,2 @@\n-    int data_offs = 3+1*wordSize;      \/\/ (stack) address of byte value. Emitter expects address, not value.\n-                                       \/\/ Being passed from java as an int, the single byte is at offset +3.\n+  int data_offs = 3+1*wordSize;      \/\/ (stack) address of byte value. Emitter expects address, not value.\n+                                     \/\/ Being passed from java as an int, the single byte is at offset +3.\n@@ -1778,15 +1778,8 @@\n-    __ lwz(crc, 2*wordSize, argP);     \/\/ Current crc state, zero extend to 64 bit to have a clean register.\n-    __ lbz(data, data_offs, argP);     \/\/ Byte from buffer, zero-extended.\n-    __ load_const_optimized(table, StubRoutines::crc_table_addr(), R0);\n-    __ kernel_crc32_singleByteReg(crc, data, table, true);\n-\n-    \/\/ Restore caller sp for c2i case (from compiled) and for resized sender frame (from interpreted).\n-    __ resize_frame_absolute(R21_sender_SP, R11_scratch1, R0);\n-    __ blr();\n-\n-    \/\/ Generate a vanilla native entry as the slow path.\n-    BLOCK_COMMENT(\"} CRC32_update\");\n-    BIND(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native), R11_scratch1);\n-    return start;\n-  }\n+  __ lwz(crc, 2*wordSize, argP);     \/\/ Current crc state, zero extend to 64 bit to have a clean register.\n+  __ lbz(data, data_offs, argP);     \/\/ Byte from buffer, zero-extended.\n+  __ load_const_optimized(table, StubRoutines::crc_table_addr(), R0);\n+  __ kernel_crc32_singleByteReg(crc, data, table, true);\n+\n+  \/\/ Restore caller sp for c2i case (from compiled) and for resized sender frame (from interpreted).\n+  __ resize_frame_absolute(R21_sender_SP, R11_scratch1, R0);\n+  __ blr();\n@@ -1794,1 +1787,5 @@\n-  return NULL;\n+  \/\/ Generate a vanilla native entry as the slow path.\n+  BLOCK_COMMENT(\"} CRC32_update\");\n+  BIND(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native), R11_scratch1);\n+  return start;\n@@ -1803,48 +1800,3 @@\n-  if (UseCRC32Intrinsics) {\n-    address start = __ pc();  \/\/ Remember stub start address (is rtn value).\n-    Label slow_path;\n-\n-    \/\/ Safepoint check\n-    const Register sync_state = R11_scratch1;\n-    __ safepoint_poll(slow_path, sync_state, false \/* at_return *\/, false \/* in_nmethod *\/);\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we not even call stub code (we generate the code inline)\n-    \/\/ and there is no safepoint on this path.\n-\n-    \/\/ Load parameters.\n-    \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n-    const Register argP    = R15_esp;\n-    const Register crc     = R3_ARG1;  \/\/ crc value\n-    const Register data    = R4_ARG2;  \/\/ address of java byte array\n-    const Register dataLen = R5_ARG3;  \/\/ source data len\n-    const Register tmp     = R11_scratch1;\n-\n-    \/\/ Arguments are reversed on java expression stack.\n-    \/\/ Calculate address of start element.\n-    if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) { \/\/ Used for \"updateByteBuffer direct\".\n-      BLOCK_COMMENT(\"CRC32_updateByteBuffer {\");\n-      \/\/ crc     @ (SP + 5W) (32bit)\n-      \/\/ buf     @ (SP + 3W) (64bit ptr to long array)\n-      \/\/ off     @ (SP + 2W) (32bit)\n-      \/\/ dataLen @ (SP + 1W) (32bit)\n-      \/\/ data = buf + off\n-      __ ld(  data,    3*wordSize, argP);  \/\/ start of byte buffer\n-      __ lwa( tmp,     2*wordSize, argP);  \/\/ byte buffer offset\n-      __ lwa( dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n-      __ lwz( crc,     5*wordSize, argP);  \/\/ current crc state\n-      __ add( data, data, tmp);            \/\/ Add byte buffer offset.\n-    } else {                                                         \/\/ Used for \"updateBytes update\".\n-      BLOCK_COMMENT(\"CRC32_updateBytes {\");\n-      \/\/ crc     @ (SP + 4W) (32bit)\n-      \/\/ buf     @ (SP + 3W) (64bit ptr to byte array)\n-      \/\/ off     @ (SP + 2W) (32bit)\n-      \/\/ dataLen @ (SP + 1W) (32bit)\n-      \/\/ data = buf + off + base_offset\n-      __ ld(  data,    3*wordSize, argP);  \/\/ start of byte buffer\n-      __ lwa( tmp,     2*wordSize, argP);  \/\/ byte buffer offset\n-      __ lwa( dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n-      __ add( data, data, tmp);            \/\/ add byte buffer offset\n-      __ lwz( crc,     4*wordSize, argP);  \/\/ current crc state\n-      __ addi(data, data, arrayOopDesc::base_offset_in_bytes(T_BYTE));\n-    }\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address start = __ pc();  \/\/ Remember stub start address (is rtn value).\n+  Label slow_path;\n@@ -1852,1 +1804,44 @@\n-    __ crc32(crc, data, dataLen, R2, R6, R7, R8, R9, R10, R11, R12, false);\n+  \/\/ Safepoint check\n+  const Register sync_state = R11_scratch1;\n+  __ safepoint_poll(slow_path, sync_state, false \/* at_return *\/, false \/* in_nmethod *\/);\n+\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we not even call stub code (we generate the code inline)\n+  \/\/ and there is no safepoint on this path.\n+\n+  \/\/ Load parameters.\n+  \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n+  const Register argP    = R15_esp;\n+  const Register crc     = R3_ARG1;  \/\/ crc value\n+  const Register data    = R4_ARG2;  \/\/ address of java byte array\n+  const Register dataLen = R5_ARG3;  \/\/ source data len\n+  const Register tmp     = R11_scratch1;\n+\n+  \/\/ Arguments are reversed on java expression stack.\n+  \/\/ Calculate address of start element.\n+  if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) { \/\/ Used for \"updateByteBuffer direct\".\n+    BLOCK_COMMENT(\"CRC32_updateByteBuffer {\");\n+    \/\/ crc     @ (SP + 5W) (32bit)\n+    \/\/ buf     @ (SP + 3W) (64bit ptr to long array)\n+    \/\/ off     @ (SP + 2W) (32bit)\n+    \/\/ dataLen @ (SP + 1W) (32bit)\n+    \/\/ data = buf + off\n+    __ ld(  data,    3*wordSize, argP);  \/\/ start of byte buffer\n+    __ lwa( tmp,     2*wordSize, argP);  \/\/ byte buffer offset\n+    __ lwa( dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n+    __ lwz( crc,     5*wordSize, argP);  \/\/ current crc state\n+    __ add( data, data, tmp);            \/\/ Add byte buffer offset.\n+  } else {                                                         \/\/ Used for \"updateBytes update\".\n+    BLOCK_COMMENT(\"CRC32_updateBytes {\");\n+    \/\/ crc     @ (SP + 4W) (32bit)\n+    \/\/ buf     @ (SP + 3W) (64bit ptr to byte array)\n+    \/\/ off     @ (SP + 2W) (32bit)\n+    \/\/ dataLen @ (SP + 1W) (32bit)\n+    \/\/ data = buf + off + base_offset\n+    __ ld(  data,    3*wordSize, argP);  \/\/ start of byte buffer\n+    __ lwa( tmp,     2*wordSize, argP);  \/\/ byte buffer offset\n+    __ lwa( dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n+    __ add( data, data, tmp);            \/\/ add byte buffer offset\n+    __ lwz( crc,     4*wordSize, argP);  \/\/ current crc state\n+    __ addi(data, data, arrayOopDesc::base_offset_in_bytes(T_BYTE));\n+  }\n@@ -1854,3 +1849,1 @@\n-    \/\/ Restore caller sp for c2i case (from compiled) and for resized sender frame (from interpreted).\n-    __ resize_frame_absolute(R21_sender_SP, R11_scratch1, R0);\n-    __ blr();\n+  __ crc32(crc, data, dataLen, R2, R6, R7, R8, R9, R10, R11, R12, false);\n@@ -1858,6 +1851,3 @@\n-    \/\/ Generate a vanilla native entry as the slow path.\n-    BLOCK_COMMENT(\"} CRC32_updateBytes(Buffer)\");\n-    BIND(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native), R11_scratch1);\n-    return start;\n-  }\n+  \/\/ Restore caller sp for c2i case (from compiled) and for resized sender frame (from interpreted).\n+  __ resize_frame_absolute(R21_sender_SP, R11_scratch1, R0);\n+  __ blr();\n@@ -1865,1 +1855,5 @@\n-  return NULL;\n+  \/\/ Generate a vanilla native entry as the slow path.\n+  BLOCK_COMMENT(\"} CRC32_updateBytes(Buffer)\");\n+  BIND(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native), R11_scratch1);\n+  return start;\n@@ -1877,47 +1871,45 @@\n-  if (UseCRC32CIntrinsics) {\n-    address start = __ pc();  \/\/ Remember stub start address (is rtn value).\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we not even call stub code (we generate the code inline)\n-    \/\/ and there is no safepoint on this path.\n-\n-    \/\/ Load parameters.\n-    \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n-    const Register argP    = R15_esp;\n-    const Register crc     = R3_ARG1;  \/\/ crc value\n-    const Register data    = R4_ARG2;  \/\/ address of java byte array\n-    const Register dataLen = R5_ARG3;  \/\/ source data len\n-    const Register tmp     = R11_scratch1;\n-\n-    \/\/ Arguments are reversed on java expression stack.\n-    \/\/ Calculate address of start element.\n-    if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) { \/\/ Used for \"updateDirectByteBuffer\".\n-      BLOCK_COMMENT(\"CRC32C_updateDirectByteBuffer {\");\n-      \/\/ crc     @ (SP + 5W) (32bit)\n-      \/\/ buf     @ (SP + 3W) (64bit ptr to long array)\n-      \/\/ off     @ (SP + 2W) (32bit)\n-      \/\/ dataLen @ (SP + 1W) (32bit)\n-      \/\/ data = buf + off\n-      __ ld(  data,    3*wordSize, argP);  \/\/ start of byte buffer\n-      __ lwa( tmp,     2*wordSize, argP);  \/\/ byte buffer offset\n-      __ lwa( dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n-      __ lwz( crc,     5*wordSize, argP);  \/\/ current crc state\n-      __ add( data, data, tmp);            \/\/ Add byte buffer offset.\n-      __ sub( dataLen, dataLen, tmp);      \/\/ (end_index - offset)\n-    } else {                                                         \/\/ Used for \"updateBytes update\".\n-      BLOCK_COMMENT(\"CRC32C_updateBytes {\");\n-      \/\/ crc     @ (SP + 4W) (32bit)\n-      \/\/ buf     @ (SP + 3W) (64bit ptr to byte array)\n-      \/\/ off     @ (SP + 2W) (32bit)\n-      \/\/ dataLen @ (SP + 1W) (32bit)\n-      \/\/ data = buf + off + base_offset\n-      __ ld(  data,    3*wordSize, argP);  \/\/ start of byte buffer\n-      __ lwa( tmp,     2*wordSize, argP);  \/\/ byte buffer offset\n-      __ lwa( dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n-      __ add( data, data, tmp);            \/\/ add byte buffer offset\n-      __ sub( dataLen, dataLen, tmp);      \/\/ (end_index - offset)\n-      __ lwz( crc,     4*wordSize, argP);  \/\/ current crc state\n-      __ addi(data, data, arrayOopDesc::base_offset_in_bytes(T_BYTE));\n-    }\n-\n-    __ crc32(crc, data, dataLen, R2, R6, R7, R8, R9, R10, R11, R12, true);\n+  assert(UseCRC32CIntrinsics, \"this intrinsic is not supported\");\n+  address start = __ pc();  \/\/ Remember stub start address (is rtn value).\n+\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we not even call stub code (we generate the code inline)\n+  \/\/ and there is no safepoint on this path.\n+\n+  \/\/ Load parameters.\n+  \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n+  const Register argP    = R15_esp;\n+  const Register crc     = R3_ARG1;  \/\/ crc value\n+  const Register data    = R4_ARG2;  \/\/ address of java byte array\n+  const Register dataLen = R5_ARG3;  \/\/ source data len\n+  const Register tmp     = R11_scratch1;\n+\n+  \/\/ Arguments are reversed on java expression stack.\n+  \/\/ Calculate address of start element.\n+  if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) { \/\/ Used for \"updateDirectByteBuffer\".\n+    BLOCK_COMMENT(\"CRC32C_updateDirectByteBuffer {\");\n+    \/\/ crc     @ (SP + 5W) (32bit)\n+    \/\/ buf     @ (SP + 3W) (64bit ptr to long array)\n+    \/\/ off     @ (SP + 2W) (32bit)\n+    \/\/ dataLen @ (SP + 1W) (32bit)\n+    \/\/ data = buf + off\n+    __ ld(  data,    3*wordSize, argP);  \/\/ start of byte buffer\n+    __ lwa( tmp,     2*wordSize, argP);  \/\/ byte buffer offset\n+    __ lwa( dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n+    __ lwz( crc,     5*wordSize, argP);  \/\/ current crc state\n+    __ add( data, data, tmp);            \/\/ Add byte buffer offset.\n+    __ sub( dataLen, dataLen, tmp);      \/\/ (end_index - offset)\n+  } else {                                                         \/\/ Used for \"updateBytes update\".\n+    BLOCK_COMMENT(\"CRC32C_updateBytes {\");\n+    \/\/ crc     @ (SP + 4W) (32bit)\n+    \/\/ buf     @ (SP + 3W) (64bit ptr to byte array)\n+    \/\/ off     @ (SP + 2W) (32bit)\n+    \/\/ dataLen @ (SP + 1W) (32bit)\n+    \/\/ data = buf + off + base_offset\n+    __ ld(  data,    3*wordSize, argP);  \/\/ start of byte buffer\n+    __ lwa( tmp,     2*wordSize, argP);  \/\/ byte buffer offset\n+    __ lwa( dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n+    __ add( data, data, tmp);            \/\/ add byte buffer offset\n+    __ sub( dataLen, dataLen, tmp);      \/\/ (end_index - offset)\n+    __ lwz( crc,     4*wordSize, argP);  \/\/ current crc state\n+    __ addi(data, data, arrayOopDesc::base_offset_in_bytes(T_BYTE));\n+  }\n@@ -1925,3 +1917,1 @@\n-    \/\/ Restore caller sp for c2i case (from compiled) and for resized sender frame (from interpreted).\n-    __ resize_frame_absolute(R21_sender_SP, R11_scratch1, R0);\n-    __ blr();\n+  __ crc32(crc, data, dataLen, R2, R6, R7, R8, R9, R10, R11, R12, true);\n@@ -1929,3 +1919,3 @@\n-    BLOCK_COMMENT(\"} CRC32C_update{Bytes|DirectByteBuffer}\");\n-    return start;\n-  }\n+  \/\/ Restore caller sp for c2i case (from compiled) and for resized sender frame (from interpreted).\n+  __ resize_frame_absolute(R21_sender_SP, R11_scratch1, R0);\n+  __ blr();\n@@ -1933,1 +1923,2 @@\n-  return NULL;\n+  BLOCK_COMMENT(\"} CRC32C_update{Bytes|DirectByteBuffer}\");\n+  return start;\n@@ -1937,0 +1928,5 @@\n+address TemplateInterpreterGenerator::generate_currentThread() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_intBitsToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToRawIntBits_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_longBitsToDouble_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_doubleToRawLongBits_entry() { return nullptr; }\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":146,"deletions":150,"binary":false,"changes":296,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,2 @@\n-static const int native_invoker_code_size = 1024;\n+static const int native_invoker_code_base_size = 256;\n+static const int native_invoker_size_per_arg = 8;\n@@ -103,4 +104,4 @@\n-                                                int captured_state_mask,\n-                                                bool needs_transition) {\n-  int locs_size = 64;\n-  CodeBuffer code(\"nep_invoker_blob\", native_invoker_code_size, locs_size);\n+                                                int captured_state_mask) {\n+  int code_size = native_invoker_code_base_size + (num_args * native_invoker_size_per_arg);\n+  int locs_size = 1; \/\/ must be non-zero\n+  CodeBuffer code(\"nep_invoker_blob\", code_size, locs_size);\n","filename":"src\/hotspot\/cpu\/riscv\/downcallLinker_riscv.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -684,1 +684,0 @@\n-  __ flush();\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -900,1 +900,1 @@\n-  void copy_memory_v(Register s, Register d, Register count, Register tmp, int step) {\n+  void copy_memory_v(Register s, Register d, Register count, int step) {\n@@ -905,1 +905,1 @@\n-    assert_different_registers(s, d, cnt, vl, tmp, tmp1, tmp2);\n+    assert_different_registers(s, d, cnt, vl, tmp1, tmp2);\n@@ -932,3 +932,3 @@\n-      __ sub(tmp, cnt, vl);\n-      __ slli(tmp, tmp, sew);\n-      __ add(tmp1, s, tmp);\n+      __ sub(t0, cnt, vl);\n+      __ slli(t0, t0, sew);\n+      __ add(tmp1, s, t0);\n@@ -936,1 +936,1 @@\n-      __ add(tmp2, d, tmp);\n+      __ add(tmp2, d, t0);\n@@ -945,1 +945,1 @@\n-                   Register s, Register d, Register count, Register tmp, int step) {\n+                   Register s, Register d, Register count, int step) {\n@@ -948,1 +948,1 @@\n-      return copy_memory_v(s, d, count, tmp, step);\n+      return copy_memory_v(s, d, count, step);\n@@ -971,4 +971,4 @@\n-      __ addi(tmp, cnt, -32);\n-      __ bgez(tmp, copy32_loop);\n-      __ addi(tmp, cnt, -8);\n-      __ bgez(tmp, copy8_loop);\n+      __ addi(t0, cnt, -32);\n+      __ bgez(t0, copy32_loop);\n+      __ addi(t0, cnt, -8);\n+      __ bgez(t0, copy8_loop);\n@@ -977,2 +977,2 @@\n-      __ mv(tmp, 16);\n-      __ blt(cnt, tmp, copy_small);\n+      __ mv(t0, 16);\n+      __ blt(cnt, t0, copy_small);\n@@ -980,3 +980,3 @@\n-      __ xorr(tmp, src, dst);\n-      __ andi(tmp, tmp, 0b111);\n-      __ bnez(tmp, copy_small);\n+      __ xorr(t0, src, dst);\n+      __ andi(t0, t0, 0b111);\n+      __ bnez(t0, copy_small);\n@@ -985,2 +985,2 @@\n-      __ andi(tmp, src, 0b111);\n-      __ beqz(tmp, copy_big);\n+      __ andi(t0, src, 0b111);\n+      __ beqz(t0, copy_big);\n@@ -1002,2 +1002,2 @@\n-      __ mv(tmp, 32);\n-      __ blt(cnt, tmp, copy8_loop);\n+      __ mv(t0, 32);\n+      __ blt(cnt, t0, copy8_loop);\n@@ -1025,1 +1025,1 @@\n-    __ addi(tmp, cnt, -(32 + wordSize * 4));\n+    __ addi(t0, cnt, -(32 + wordSize * 4));\n@@ -1027,1 +1027,1 @@\n-    __ bgez(tmp, copy32_loop); \/\/ cnt >= 32, do next loop\n+    __ bgez(t0, copy32_loop); \/\/ cnt >= 32, do next loop\n@@ -1031,2 +1031,2 @@\n-    __ addi(tmp, cnt, -8); \/\/ if not - copy the reminder\n-    __ bltz(tmp, copy_small); \/\/ cnt < 8, go to copy_small, else fall throught to copy8_loop\n+    __ addi(t0, cnt, -8); \/\/ if not - copy the reminder\n+    __ bltz(t0, copy_small); \/\/ cnt < 8, go to copy_small, else fall throught to copy8_loop\n@@ -1046,1 +1046,1 @@\n-    __ addi(tmp, cnt, -(8 + wordSize));\n+    __ addi(t0, cnt, -(8 + wordSize));\n@@ -1048,1 +1048,1 @@\n-    __ bgez(tmp, copy8_loop); \/\/ cnt >= 8, do next loop\n+    __ bgez(t0, copy8_loop); \/\/ cnt >= 8, do next loop\n@@ -1147,1 +1147,1 @@\n-      copy_memory(decorators, is_oop ? T_OBJECT : T_BYTE, aligned, s, d, count, t0, size);\n+      copy_memory(decorators, is_oop ? T_OBJECT : T_BYTE, aligned, s, d, count, size);\n@@ -1223,1 +1223,1 @@\n-      copy_memory(decorators, is_oop ? T_OBJECT : T_BYTE, aligned, s, d, count, t0, -size);\n+      copy_memory(decorators, is_oop ? T_OBJECT : T_BYTE, aligned, s, d, count, -size);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -146,4 +146,0 @@\n-  if (!InlineIntrinsics) {\n-    return NULL; \/\/ Generate a vanilla entry\n-  }\n-\n@@ -304,4 +300,0 @@\n-\/\/ Not supported\n-address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() { return nullptr; }\n-address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() { return nullptr; }\n-\n@@ -867,1 +859,1 @@\n-  return 0;\n+  return nullptr;\n@@ -877,1 +869,1 @@\n-  return 0;\n+  return nullptr;\n@@ -889,1 +881,1 @@\n-  return 0;\n+  return nullptr;\n@@ -892,0 +884,8 @@\n+\/\/ Not supported\n+address TemplateInterpreterGenerator::generate_Float_intBitsToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToRawIntBits_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_longBitsToDouble_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_doubleToRawLongBits_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() { return nullptr; }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,0 +117,3 @@\n+static const int upcall_stub_code_base_size = 2048;\n+static const int upcall_stub_size_per_arg = 16;\n+\n@@ -127,1 +130,2 @@\n-  CodeBuffer buffer(\"upcall_stub\", \/* code_size = *\/ 2048, \/* locs_size = *\/ 1024);\n+  int code_size = upcall_stub_code_base_size + (total_in_args * upcall_stub_size_per_arg);\n+  CodeBuffer buffer(\"upcall_stub\", code_size, \/* locs_size = *\/ 1);\n@@ -346,0 +350,2 @@\n+  buffer.log_section_sizes(name);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/upcallLinker_riscv.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1804,0 +1804,3 @@\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  uint64_t entry_off = __ offset();\n+  Label    slow_path;\n@@ -1805,3 +1808,2 @@\n-  if (UseCRC32Intrinsics) {\n-    uint64_t entry_off = __ offset();\n-    Label    slow_path;\n+  \/\/ If we need a safepoint check, generate full interpreter entry.\n+  __ safepoint_poll(slow_path, Z_R1);\n@@ -1809,2 +1811,1 @@\n-    \/\/ If we need a safepoint check, generate full interpreter entry.\n-    __ safepoint_poll(slow_path, Z_R1);\n+  BLOCK_COMMENT(\"CRC32_update {\");\n@@ -1812,1 +1813,3 @@\n-    BLOCK_COMMENT(\"CRC32_update {\");\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we not even call stub code (we generate the code inline)\n+  \/\/ and there is no safepoint on this path.\n@@ -1814,14 +1817,10 @@\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we not even call stub code (we generate the code inline)\n-    \/\/ and there is no safepoint on this path.\n-\n-    \/\/ Load java parameters.\n-    \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n-    const Register argP    = Z_esp;\n-    const Register crc     = Z_ARG1;  \/\/ crc value\n-    const Register data    = Z_ARG2;  \/\/ address of java byte value (kernel_crc32 needs address)\n-    const Register dataLen = Z_ARG3;  \/\/ source data len (1 byte). Not used because calling the single-byte emitter.\n-    const Register table   = Z_ARG4;  \/\/ address of crc32 table\n-\n-    \/\/ Arguments are reversed on java expression stack.\n-    __ z_la(data, 3+1*wordSize, argP);  \/\/ byte value (stack address).\n+  \/\/ Load java parameters.\n+  \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n+  const Register argP    = Z_esp;\n+  const Register crc     = Z_ARG1;  \/\/ crc value\n+  const Register data    = Z_ARG2;  \/\/ address of java byte value (kernel_crc32 needs address)\n+  const Register dataLen = Z_ARG3;  \/\/ source data len (1 byte). Not used because calling the single-byte emitter.\n+  const Register table   = Z_ARG4;  \/\/ address of crc32 table\n+\n+  \/\/ Arguments are reversed on java expression stack.\n+  __ z_la(data, 3+1*wordSize, argP);  \/\/ byte value (stack address).\n@@ -1829,1 +1828,1 @@\n-    __ z_llgf(crc, 2 * wordSize, argP); \/\/ Current crc state, zero extend to 64 bit to have a clean register.\n+  __ z_llgf(crc, 2 * wordSize, argP); \/\/ Current crc state, zero extend to 64 bit to have a clean register.\n@@ -1831,2 +1830,2 @@\n-    StubRoutines::zarch::generate_load_crc_table_addr(_masm, table);\n-    __ kernel_crc32_singleByte(crc, data, dataLen, table, Z_R1, true);\n+  StubRoutines::zarch::generate_load_crc_table_addr(_masm, table);\n+  __ kernel_crc32_singleByte(crc, data, dataLen, table, Z_R1, true);\n@@ -1834,4 +1833,2 @@\n-    \/\/ Restore caller sp for c2i case.\n-    __ resize_frame_absolute(Z_R10, Z_R0, true); \/\/ Cut the stack back to where the caller started.\n-\n-    __ z_br(Z_R14);\n+  \/\/ Restore caller sp for c2i case.\n+  __ resize_frame_absolute(Z_R10, Z_R0, true); \/\/ Cut the stack back to where the caller started.\n@@ -1839,1 +1836,1 @@\n-    BLOCK_COMMENT(\"} CRC32_update\");\n+  __ z_br(Z_R14);\n@@ -1841,5 +1838,1 @@\n-    \/\/ Use a previously generated vanilla native entry as the slow path.\n-    BIND(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native), Z_R1);\n-    return __ addr_at(entry_off);\n-  }\n+  BLOCK_COMMENT(\"} CRC32_update\");\n@@ -1847,1 +1840,4 @@\n-  return NULL;\n+  \/\/ Use a previously generated vanilla native entry as the slow path.\n+  BIND(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native), Z_R1);\n+  return __ addr_at(entry_off);\n@@ -1857,0 +1853,3 @@\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  uint64_t entry_off = __ offset();\n+  Label    slow_path;\n@@ -1858,48 +1857,2 @@\n-  if (UseCRC32Intrinsics) {\n-    uint64_t entry_off = __ offset();\n-    Label    slow_path;\n-\n-    \/\/ If we need a safepoint check, generate full interpreter entry.\n-    __ safepoint_poll(slow_path, Z_R1);\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n-\n-    \/\/ Load parameters.\n-    \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n-    const Register argP    = Z_esp;\n-    const Register crc     = Z_ARG1;  \/\/ crc value\n-    const Register data    = Z_ARG2;  \/\/ address of java byte array\n-    const Register dataLen = Z_ARG3;  \/\/ source data len\n-    const Register table   = Z_ARG4;  \/\/ address of crc32 table\n-    const Register t0      = Z_R10;   \/\/ work reg for kernel* emitters\n-    const Register t1      = Z_R11;   \/\/ work reg for kernel* emitters\n-    const Register t2      = Z_R12;   \/\/ work reg for kernel* emitters\n-    const Register t3      = Z_R13;   \/\/ work reg for kernel* emitters\n-\n-    \/\/ Arguments are reversed on java expression stack.\n-    \/\/ Calculate address of start element.\n-    if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) { \/\/ Used for \"updateByteBuffer direct\".\n-      \/\/ crc     @ (SP + 5W) (32bit)\n-      \/\/ buf     @ (SP + 3W) (64bit ptr to long array)\n-      \/\/ off     @ (SP + 2W) (32bit)\n-      \/\/ dataLen @ (SP + 1W) (32bit)\n-      \/\/ data = buf + off\n-      BLOCK_COMMENT(\"CRC32_updateByteBuffer {\");\n-      __ z_llgf(crc,    5*wordSize, argP);  \/\/ current crc state\n-      __ z_lg(data,     3*wordSize, argP);  \/\/ start of byte buffer\n-      __ z_agf(data,    2*wordSize, argP);  \/\/ Add byte buffer offset.\n-      __ z_lgf(dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n-    } else {                                                         \/\/ Used for \"updateBytes update\".\n-      \/\/ crc     @ (SP + 4W) (32bit)\n-      \/\/ buf     @ (SP + 3W) (64bit ptr to byte array)\n-      \/\/ off     @ (SP + 2W) (32bit)\n-      \/\/ dataLen @ (SP + 1W) (32bit)\n-      \/\/ data = buf + off + base_offset\n-      BLOCK_COMMENT(\"CRC32_updateBytes {\");\n-      __ z_llgf(crc,    4*wordSize, argP);  \/\/ current crc state\n-      __ z_lg(data,     3*wordSize, argP);  \/\/ start of byte buffer\n-      __ z_agf(data,    2*wordSize, argP);  \/\/ Add byte buffer offset.\n-      __ z_lgf(dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n-      __ z_aghi(data, arrayOopDesc::base_offset_in_bytes(T_BYTE));\n-    }\n+  \/\/ If we need a safepoint check, generate full interpreter entry.\n+  __ safepoint_poll(slow_path, Z_R1);\n@@ -1907,1 +1860,2 @@\n-    StubRoutines::zarch::generate_load_crc_table_addr(_masm, table);\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n@@ -1909,4 +1863,38 @@\n-    __ resize_frame(-(6*8), Z_R0, true); \/\/ Resize frame to provide add'l space to spill 5 registers.\n-    __ z_stmg(t0, t3, 1*8, Z_SP);        \/\/ Spill regs 10..13 to make them available as work registers.\n-    __ kernel_crc32_1word(crc, data, dataLen, table, t0, t1, t2, t3, true);\n-    __ z_lmg(t0, t3, 1*8, Z_SP);         \/\/ Spill regs 10..13 back from stack.\n+  \/\/ Load parameters.\n+  \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n+  const Register argP    = Z_esp;\n+  const Register crc     = Z_ARG1;  \/\/ crc value\n+  const Register data    = Z_ARG2;  \/\/ address of java byte array\n+  const Register dataLen = Z_ARG3;  \/\/ source data len\n+  const Register table   = Z_ARG4;  \/\/ address of crc32 table\n+  const Register t0      = Z_R10;   \/\/ work reg for kernel* emitters\n+  const Register t1      = Z_R11;   \/\/ work reg for kernel* emitters\n+  const Register t2      = Z_R12;   \/\/ work reg for kernel* emitters\n+  const Register t3      = Z_R13;   \/\/ work reg for kernel* emitters\n+\n+  \/\/ Arguments are reversed on java expression stack.\n+  \/\/ Calculate address of start element.\n+  if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) { \/\/ Used for \"updateByteBuffer direct\".\n+    \/\/ crc     @ (SP + 5W) (32bit)\n+    \/\/ buf     @ (SP + 3W) (64bit ptr to long array)\n+    \/\/ off     @ (SP + 2W) (32bit)\n+    \/\/ dataLen @ (SP + 1W) (32bit)\n+    \/\/ data = buf + off\n+    BLOCK_COMMENT(\"CRC32_updateByteBuffer {\");\n+    __ z_llgf(crc,    5*wordSize, argP);  \/\/ current crc state\n+    __ z_lg(data,     3*wordSize, argP);  \/\/ start of byte buffer\n+    __ z_agf(data,    2*wordSize, argP);  \/\/ Add byte buffer offset.\n+    __ z_lgf(dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n+  } else {                                                         \/\/ Used for \"updateBytes update\".\n+    \/\/ crc     @ (SP + 4W) (32bit)\n+    \/\/ buf     @ (SP + 3W) (64bit ptr to byte array)\n+    \/\/ off     @ (SP + 2W) (32bit)\n+    \/\/ dataLen @ (SP + 1W) (32bit)\n+    \/\/ data = buf + off + base_offset\n+    BLOCK_COMMENT(\"CRC32_updateBytes {\");\n+    __ z_llgf(crc,    4*wordSize, argP);  \/\/ current crc state\n+    __ z_lg(data,     3*wordSize, argP);  \/\/ start of byte buffer\n+    __ z_agf(data,    2*wordSize, argP);  \/\/ Add byte buffer offset.\n+    __ z_lgf(dataLen, 1*wordSize, argP);  \/\/ #bytes to process\n+    __ z_aghi(data, arrayOopDesc::base_offset_in_bytes(T_BYTE));\n+  }\n@@ -1914,2 +1902,1 @@\n-    \/\/ Restore caller sp for c2i case.\n-    __ resize_frame_absolute(Z_R10, Z_R0, true); \/\/ Cut the stack back to where the caller started.\n+  StubRoutines::zarch::generate_load_crc_table_addr(_masm, table);\n@@ -1917,1 +1904,4 @@\n-    __ z_br(Z_R14);\n+  __ resize_frame(-(6*8), Z_R0, true); \/\/ Resize frame to provide add'l space to spill 5 registers.\n+  __ z_stmg(t0, t3, 1*8, Z_SP);        \/\/ Spill regs 10..13 to make them available as work registers.\n+  __ kernel_crc32_1word(crc, data, dataLen, table, t0, t1, t2, t3, true);\n+  __ z_lmg(t0, t3, 1*8, Z_SP);         \/\/ Spill regs 10..13 back from stack.\n@@ -1919,1 +1909,2 @@\n-    BLOCK_COMMENT(\"} CRC32_update{Bytes|ByteBuffer}\");\n+  \/\/ Restore caller sp for c2i case.\n+  __ resize_frame_absolute(Z_R10, Z_R0, true); \/\/ Cut the stack back to where the caller started.\n@@ -1921,5 +1912,1 @@\n-    \/\/ Use a previously generated vanilla native entry as the slow path.\n-    BIND(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native), Z_R1);\n-    return __ addr_at(entry_off);\n-  }\n+  __ z_br(Z_R14);\n@@ -1927,1 +1914,6 @@\n-  return NULL;\n+  BLOCK_COMMENT(\"} CRC32_update{Bytes|ByteBuffer}\");\n+\n+  \/\/ Use a previously generated vanilla native entry as the slow path.\n+  BIND(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native), Z_R1);\n+  return __ addr_at(entry_off);\n@@ -1939,0 +1931,2 @@\n+  assert(UseCRC32CIntrinsics, \"this intrinsic is not supported\");\n+  uint64_t entry_off = __ offset();\n@@ -1940,46 +1934,2 @@\n-  if (UseCRC32CIntrinsics) {\n-    uint64_t entry_off = __ offset();\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n-\n-    \/\/ Load parameters.\n-    \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n-    const Register argP    = Z_esp;\n-    const Register crc     = Z_ARG1;  \/\/ crc value\n-    const Register data    = Z_ARG2;  \/\/ address of java byte array\n-    const Register dataLen = Z_ARG3;  \/\/ source data len\n-    const Register table   = Z_ARG4;  \/\/ address of crc32 table\n-    const Register t0      = Z_R10;   \/\/ work reg for kernel* emitters\n-    const Register t1      = Z_R11;   \/\/ work reg for kernel* emitters\n-    const Register t2      = Z_R12;   \/\/ work reg for kernel* emitters\n-    const Register t3      = Z_R13;   \/\/ work reg for kernel* emitters\n-\n-    \/\/ Arguments are reversed on java expression stack.\n-    \/\/ Calculate address of start element.\n-    if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) { \/\/ Used for \"updateByteBuffer direct\".\n-      \/\/ crc     @ (SP + 5W) (32bit)\n-      \/\/ buf     @ (SP + 3W) (64bit ptr to long array)\n-      \/\/ off     @ (SP + 2W) (32bit)\n-      \/\/ dataLen @ (SP + 1W) (32bit)\n-      \/\/ data = buf + off\n-      BLOCK_COMMENT(\"CRC32C_updateDirectByteBuffer {\");\n-      __ z_llgf(crc,    5*wordSize, argP);  \/\/ current crc state\n-      __ z_lg(data,     3*wordSize, argP);  \/\/ start of byte buffer\n-      __ z_agf(data,    2*wordSize, argP);  \/\/ Add byte buffer offset.\n-      __ z_lgf(dataLen, 1*wordSize, argP);  \/\/ #bytes to process, calculated as\n-      __ z_sgf(dataLen, Address(argP, 2*wordSize));  \/\/ (end_index - offset)\n-    } else {                                                                \/\/ Used for \"updateBytes update\".\n-      \/\/ crc     @ (SP + 4W) (32bit)\n-      \/\/ buf     @ (SP + 3W) (64bit ptr to byte array)\n-      \/\/ off     @ (SP + 2W) (32bit)\n-      \/\/ dataLen @ (SP + 1W) (32bit)\n-      \/\/ data = buf + off + base_offset\n-      BLOCK_COMMENT(\"CRC32C_updateBytes {\");\n-      __ z_llgf(crc,    4*wordSize, argP);  \/\/ current crc state\n-      __ z_lg(data,     3*wordSize, argP);  \/\/ start of byte buffer\n-      __ z_agf(data,    2*wordSize, argP);  \/\/ Add byte buffer offset.\n-      __ z_lgf(dataLen, 1*wordSize, argP);  \/\/ #bytes to process, calculated as\n-      __ z_sgf(dataLen, Address(argP, 2*wordSize));  \/\/ (end_index - offset)\n-      __ z_aghi(data, arrayOopDesc::base_offset_in_bytes(T_BYTE));\n-    }\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n@@ -1987,1 +1937,40 @@\n-    StubRoutines::zarch::generate_load_crc32c_table_addr(_masm, table);\n+  \/\/ Load parameters.\n+  \/\/ Z_esp is callers operand stack pointer, i.e. it points to the parameters.\n+  const Register argP    = Z_esp;\n+  const Register crc     = Z_ARG1;  \/\/ crc value\n+  const Register data    = Z_ARG2;  \/\/ address of java byte array\n+  const Register dataLen = Z_ARG3;  \/\/ source data len\n+  const Register table   = Z_ARG4;  \/\/ address of crc32 table\n+  const Register t0      = Z_R10;   \/\/ work reg for kernel* emitters\n+  const Register t1      = Z_R11;   \/\/ work reg for kernel* emitters\n+  const Register t2      = Z_R12;   \/\/ work reg for kernel* emitters\n+  const Register t3      = Z_R13;   \/\/ work reg for kernel* emitters\n+\n+  \/\/ Arguments are reversed on java expression stack.\n+  \/\/ Calculate address of start element.\n+  if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) { \/\/ Used for \"updateByteBuffer direct\".\n+    \/\/ crc     @ (SP + 5W) (32bit)\n+    \/\/ buf     @ (SP + 3W) (64bit ptr to long array)\n+    \/\/ off     @ (SP + 2W) (32bit)\n+    \/\/ dataLen @ (SP + 1W) (32bit)\n+    \/\/ data = buf + off\n+    BLOCK_COMMENT(\"CRC32C_updateDirectByteBuffer {\");\n+    __ z_llgf(crc,    5*wordSize, argP);  \/\/ current crc state\n+    __ z_lg(data,     3*wordSize, argP);  \/\/ start of byte buffer\n+    __ z_agf(data,    2*wordSize, argP);  \/\/ Add byte buffer offset.\n+    __ z_lgf(dataLen, 1*wordSize, argP);  \/\/ #bytes to process, calculated as\n+    __ z_sgf(dataLen, Address(argP, 2*wordSize));  \/\/ (end_index - offset)\n+  } else {                                                                \/\/ Used for \"updateBytes update\".\n+    \/\/ crc     @ (SP + 4W) (32bit)\n+    \/\/ buf     @ (SP + 3W) (64bit ptr to byte array)\n+    \/\/ off     @ (SP + 2W) (32bit)\n+    \/\/ dataLen @ (SP + 1W) (32bit)\n+    \/\/ data = buf + off + base_offset\n+    BLOCK_COMMENT(\"CRC32C_updateBytes {\");\n+    __ z_llgf(crc,    4*wordSize, argP);  \/\/ current crc state\n+    __ z_lg(data,     3*wordSize, argP);  \/\/ start of byte buffer\n+    __ z_agf(data,    2*wordSize, argP);  \/\/ Add byte buffer offset.\n+    __ z_lgf(dataLen, 1*wordSize, argP);  \/\/ #bytes to process, calculated as\n+    __ z_sgf(dataLen, Address(argP, 2*wordSize));  \/\/ (end_index - offset)\n+    __ z_aghi(data, arrayOopDesc::base_offset_in_bytes(T_BYTE));\n+  }\n@@ -1989,4 +1978,1 @@\n-    __ resize_frame(-(6*8), Z_R0, true); \/\/ Resize frame to provide add'l space to spill 5 registers.\n-    __ z_stmg(t0, t3, 1*8, Z_SP);        \/\/ Spill regs 10..13 to make them available as work registers.\n-    __ kernel_crc32_1word(crc, data, dataLen, table, t0, t1, t2, t3, false);\n-    __ z_lmg(t0, t3, 1*8, Z_SP);         \/\/ Spill regs 10..13 back from stack.\n+  StubRoutines::zarch::generate_load_crc32c_table_addr(_masm, table);\n@@ -1994,2 +1980,4 @@\n-    \/\/ Restore caller sp for c2i case.\n-    __ resize_frame_absolute(Z_R10, Z_R0, true); \/\/ Cut the stack back to where the caller started.\n+  __ resize_frame(-(6*8), Z_R0, true); \/\/ Resize frame to provide add'l space to spill 5 registers.\n+  __ z_stmg(t0, t3, 1*8, Z_SP);        \/\/ Spill regs 10..13 to make them available as work registers.\n+  __ kernel_crc32_1word(crc, data, dataLen, table, t0, t1, t2, t3, false);\n+  __ z_lmg(t0, t3, 1*8, Z_SP);         \/\/ Spill regs 10..13 back from stack.\n@@ -1997,1 +1985,2 @@\n-    __ z_br(Z_R14);\n+  \/\/ Restore caller sp for c2i case.\n+  __ resize_frame_absolute(Z_R10, Z_R0, true); \/\/ Cut the stack back to where the caller started.\n@@ -1999,3 +1988,1 @@\n-    BLOCK_COMMENT(\"} CRC32C_update{Bytes|DirectByteBuffer}\");\n-    return __ addr_at(entry_off);\n-  }\n+  __ z_br(Z_R14);\n@@ -2003,1 +1990,2 @@\n-  return NULL;\n+  BLOCK_COMMENT(\"} CRC32C_update{Bytes|DirectByteBuffer}\");\n+  return __ addr_at(entry_off);\n@@ -2007,0 +1995,5 @@\n+address TemplateInterpreterGenerator::generate_currentThread() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_intBitsToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToRawIntBits_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_longBitsToDouble_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_doubleToRawLongBits_entry() { return nullptr; }\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":148,"deletions":155,"binary":false,"changes":303,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,2 @@\n-static const int native_invoker_code_size = 1024;\n+static const int native_invoker_code_base_size = 512;\n+static const int native_invoker_size_per_arg = 8;\n@@ -104,4 +105,4 @@\n-                                                int captured_state_mask,\n-                                                bool needs_transition) {\n-  int locs_size = 64;\n-  CodeBuffer code(\"nep_invoker_blob\", native_invoker_code_size, locs_size);\n+                                                int captured_state_mask) {\n+  int code_size = native_invoker_code_base_size + (num_args * native_invoker_size_per_arg);\n+  int locs_size = 1; \/\/ can not be zero\n+  CodeBuffer code(\"nep_invoker_blob\", code_size, locs_size);\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -971,1 +971,0 @@\n-  __ flush();\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1044,1 +1044,0 @@\n-  __ flush();\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-  if (UseCRC32Intrinsics) {\n-    address entry = __ pc();\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n@@ -59,32 +59,32 @@\n-    \/\/ rbx: Method*\n-    \/\/ rsi: senderSP must preserved for slow path, set SP to it on fast path\n-    \/\/ rdx: scratch\n-    \/\/ rdi: scratch\n-\n-    Label slow_path;\n-    \/\/ If we need a safepoint check, generate full interpreter entry.\n-    __ get_thread(rdi);\n-    __ safepoint_poll(slow_path, rdi, false \/* at_return *\/, false \/* in_nmethod *\/);\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n-\n-    \/\/ Load parameters\n-    const Register crc = rax;  \/\/ crc\n-    const Register val = rdx;  \/\/ source java byte value\n-    const Register tbl = rdi;  \/\/ scratch\n-\n-    \/\/ Arguments are reversed on java expression stack\n-    __ movl(val, Address(rsp,   wordSize)); \/\/ byte value\n-    __ movl(crc, Address(rsp, 2*wordSize)); \/\/ Initial CRC\n-\n-    __ lea(tbl, ExternalAddress(StubRoutines::crc_table_addr()));\n-    __ notl(crc); \/\/ ~crc\n-    __ update_byte_crc32(crc, val, tbl);\n-    __ notl(crc); \/\/ ~crc\n-    \/\/ result in rax\n-\n-    \/\/ _areturn\n-    __ pop(rdi);                \/\/ get return address\n-    __ mov(rsp, rsi);           \/\/ set sp to sender sp\n-    __ jmp(rdi);\n+  \/\/ rbx: Method*\n+  \/\/ rsi: senderSP must preserved for slow path, set SP to it on fast path\n+  \/\/ rdx: scratch\n+  \/\/ rdi: scratch\n+\n+  Label slow_path;\n+  \/\/ If we need a safepoint check, generate full interpreter entry.\n+  __ get_thread(rdi);\n+  __ safepoint_poll(slow_path, rdi, false \/* at_return *\/, false \/* in_nmethod *\/);\n+\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n+\n+  \/\/ Load parameters\n+  const Register crc = rax;  \/\/ crc\n+  const Register val = rdx;  \/\/ source java byte value\n+  const Register tbl = rdi;  \/\/ scratch\n+\n+  \/\/ Arguments are reversed on java expression stack\n+  __ movl(val, Address(rsp,   wordSize)); \/\/ byte value\n+  __ movl(crc, Address(rsp, 2*wordSize)); \/\/ Initial CRC\n+\n+  __ lea(tbl, ExternalAddress(StubRoutines::crc_table_addr()));\n+  __ notl(crc); \/\/ ~crc\n+  __ update_byte_crc32(crc, val, tbl);\n+  __ notl(crc); \/\/ ~crc\n+  \/\/ result in rax\n+\n+  \/\/ _areturn\n+  __ pop(rdi);                \/\/ get return address\n+  __ mov(rsp, rsi);           \/\/ set sp to sender sp\n+  __ jmp(rdi);\n@@ -92,6 +92,4 @@\n-    \/\/ generate a vanilla native entry as the slow path\n-    __ bind(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n-    return entry;\n-  }\n-  return NULL;\n+  \/\/ generate a vanilla native entry as the slow path\n+  __ bind(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n+  return entry;\n@@ -106,2 +104,2 @@\n-  if (UseCRC32Intrinsics) {\n-    address entry = __ pc();\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n@@ -109,38 +107,38 @@\n-    \/\/ rbx,: Method*\n-    \/\/ rsi: senderSP must preserved for slow path, set SP to it on fast path\n-    \/\/ rdx: scratch\n-    \/\/ rdi: scratch\n-\n-    Label slow_path;\n-    \/\/ If we need a safepoint check, generate full interpreter entry.\n-    __ get_thread(rdi);\n-    __ safepoint_poll(slow_path, rdi, false \/* at_return *\/, false \/* in_nmethod *\/);\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n-\n-    \/\/ Load parameters\n-    const Register crc = rax;  \/\/ crc\n-    const Register buf = rdx;  \/\/ source java byte array address\n-    const Register len = rdi;  \/\/ length\n-\n-    \/\/ value              x86_32\n-    \/\/ interp. arg ptr    ESP + 4\n-    \/\/ int java.util.zip.CRC32.updateBytes(int crc, byte[] b, int off, int len)\n-    \/\/                                         3           2      1        0\n-    \/\/ int java.util.zip.CRC32.updateByteBuffer(int crc, long buf, int off, int len)\n-    \/\/                                              4         2,3      1        0\n-\n-    \/\/ Arguments are reversed on java expression stack\n-    __ movl(len,   Address(rsp,   4 + 0)); \/\/ Length\n-    \/\/ Calculate address of start element\n-    if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) {\n-      __ movptr(buf, Address(rsp, 4 + 2 * wordSize)); \/\/ long buf\n-      __ addptr(buf, Address(rsp, 4 + 1 * wordSize)); \/\/ + offset\n-      __ movl(crc,   Address(rsp, 4 + 4 * wordSize)); \/\/ Initial CRC\n-    } else {\n-      __ movptr(buf, Address(rsp, 4 + 2 * wordSize)); \/\/ byte[] array\n-      __ addptr(buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n-      __ addptr(buf, Address(rsp, 4 + 1 * wordSize)); \/\/ + offset\n-      __ movl(crc,   Address(rsp, 4 + 3 * wordSize)); \/\/ Initial CRC\n-    }\n+  \/\/ rbx,: Method*\n+  \/\/ rsi: senderSP must preserved for slow path, set SP to it on fast path\n+  \/\/ rdx: scratch\n+  \/\/ rdi: scratch\n+\n+  Label slow_path;\n+  \/\/ If we need a safepoint check, generate full interpreter entry.\n+  __ get_thread(rdi);\n+  __ safepoint_poll(slow_path, rdi, false \/* at_return *\/, false \/* in_nmethod *\/);\n+\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n+\n+  \/\/ Load parameters\n+  const Register crc = rax;  \/\/ crc\n+  const Register buf = rdx;  \/\/ source java byte array address\n+  const Register len = rdi;  \/\/ length\n+\n+  \/\/ value              x86_32\n+  \/\/ interp. arg ptr    ESP + 4\n+  \/\/ int java.util.zip.CRC32.updateBytes(int crc, byte[] b, int off, int len)\n+  \/\/                                         3           2      1        0\n+  \/\/ int java.util.zip.CRC32.updateByteBuffer(int crc, long buf, int off, int len)\n+  \/\/                                              4         2,3      1        0\n+\n+  \/\/ Arguments are reversed on java expression stack\n+  __ movl(len,   Address(rsp,   4 + 0)); \/\/ Length\n+  \/\/ Calculate address of start element\n+  if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) {\n+    __ movptr(buf, Address(rsp, 4 + 2 * wordSize)); \/\/ long buf\n+    __ addptr(buf, Address(rsp, 4 + 1 * wordSize)); \/\/ + offset\n+    __ movl(crc,   Address(rsp, 4 + 4 * wordSize)); \/\/ Initial CRC\n+  } else {\n+    __ movptr(buf, Address(rsp, 4 + 2 * wordSize)); \/\/ byte[] array\n+    __ addptr(buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n+    __ addptr(buf, Address(rsp, 4 + 1 * wordSize)); \/\/ + offset\n+    __ movl(crc,   Address(rsp, 4 + 3 * wordSize)); \/\/ Initial CRC\n+  }\n@@ -148,2 +146,2 @@\n-    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32()), crc, buf, len);\n-    \/\/ result in rax\n+  __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32()), crc, buf, len);\n+  \/\/ result in rax\n@@ -151,4 +149,4 @@\n-    \/\/ _areturn\n-    __ pop(rdi);                \/\/ get return address\n-    __ mov(rsp, rsi);           \/\/ set sp to sender sp\n-    __ jmp(rdi);\n+  \/\/ _areturn\n+  __ pop(rdi);                \/\/ get return address\n+  __ mov(rsp, rsi);           \/\/ set sp to sender sp\n+  __ jmp(rdi);\n@@ -156,6 +154,4 @@\n-    \/\/ generate a vanilla native entry as the slow path\n-    __ bind(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n-    return entry;\n-  }\n-  return NULL;\n+  \/\/ generate a vanilla native entry as the slow path\n+  __ bind(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n+  return entry;\n@@ -170,37 +166,28 @@\n-  if (UseCRC32CIntrinsics) {\n-    address entry = __ pc();\n-    \/\/ Load parameters\n-    const Register crc = rax;  \/\/ crc\n-    const Register buf = rcx;  \/\/ source java byte array address\n-    const Register len = rdx;  \/\/ length\n-    const Register end = len;\n-\n-    \/\/ value              x86_32\n-    \/\/ interp. arg ptr    ESP + 4\n-    \/\/ int java.util.zip.CRC32.updateBytes(int crc, byte[] b, int off, int end)\n-    \/\/                                         3           2      1        0\n-    \/\/ int java.util.zip.CRC32.updateByteBuffer(int crc, long address, int off, int end)\n-    \/\/                                              4         2,3          1        0\n-\n-    \/\/ Arguments are reversed on java expression stack\n-    __ movl(end, Address(rsp, 4 + 0)); \/\/ end\n-    __ subl(len, Address(rsp, 4 + 1 * wordSize));  \/\/ end - offset == length\n-    \/\/ Calculate address of start element\n-    if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) {\n-      __ movptr(buf, Address(rsp, 4 + 2 * wordSize)); \/\/ long address\n-      __ addptr(buf, Address(rsp, 4 + 1 * wordSize)); \/\/ + offset\n-      __ movl(crc, Address(rsp, 4 + 4 * wordSize)); \/\/ Initial CRC\n-    } else {\n-      __ movptr(buf, Address(rsp, 4 + 2 * wordSize)); \/\/ byte[] array\n-      __ addptr(buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n-      __ addptr(buf, Address(rsp, 4 + 1 * wordSize)); \/\/ + offset\n-      __ movl(crc, Address(rsp, 4 + 3 * wordSize)); \/\/ Initial CRC\n-    }\n-    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32C()), crc, buf, len);\n-    \/\/ result in rax\n-    \/\/ _areturn\n-    __ pop(rdi);                \/\/ get return address\n-    __ mov(rsp, rsi);           \/\/ set sp to sender sp\n-    __ jmp(rdi);\n-\n-    return entry;\n+  assert(UseCRC32CIntrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n+  \/\/ Load parameters\n+  const Register crc = rax;  \/\/ crc\n+  const Register buf = rcx;  \/\/ source java byte array address\n+  const Register len = rdx;  \/\/ length\n+  const Register end = len;\n+\n+  \/\/ value              x86_32\n+  \/\/ interp. arg ptr    ESP + 4\n+  \/\/ int java.util.zip.CRC32.updateBytes(int crc, byte[] b, int off, int end)\n+  \/\/                                         3           2      1        0\n+  \/\/ int java.util.zip.CRC32.updateByteBuffer(int crc, long address, int off, int end)\n+  \/\/                                              4         2,3          1        0\n+\n+  \/\/ Arguments are reversed on java expression stack\n+  __ movl(end, Address(rsp, 4 + 0)); \/\/ end\n+  __ subl(len, Address(rsp, 4 + 1 * wordSize));  \/\/ end - offset == length\n+  \/\/ Calculate address of start element\n+  if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) {\n+    __ movptr(buf, Address(rsp, 4 + 2 * wordSize)); \/\/ long address\n+    __ addptr(buf, Address(rsp, 4 + 1 * wordSize)); \/\/ + offset\n+    __ movl(crc, Address(rsp, 4 + 4 * wordSize)); \/\/ Initial CRC\n+  } else {\n+    __ movptr(buf, Address(rsp, 4 + 2 * wordSize)); \/\/ byte[] array\n+    __ addptr(buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n+    __ addptr(buf, Address(rsp, 4 + 1 * wordSize)); \/\/ + offset\n+    __ movl(crc, Address(rsp, 4 + 3 * wordSize)); \/\/ Initial CRC\n@@ -208,1 +195,8 @@\n-  return NULL;\n+  __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32C()), crc, buf, len);\n+  \/\/ result in rax\n+  \/\/ _areturn\n+  __ pop(rdi);                \/\/ get return address\n+  __ mov(rsp, rsi);           \/\/ set sp to sender sp\n+  __ jmp(rdi);\n+\n+  return entry;\n@@ -322,6 +316,1 @@\n-  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n-  if (!VM_Version::supports_float16() ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat) ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16)) {\n-    return nullptr; \/\/ Generate a vanilla entry\n-  }\n+  assert(VM_Version::supports_float16(), \"this intrinsic is not supported\");\n@@ -348,6 +337,1 @@\n-  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n-  if (!VM_Version::supports_float16() ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16) ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat)) {\n-    return nullptr; \/\/ Generate a vanilla entry\n-  }\n+  assert(VM_Version::supports_float16(), \"this intrinsic is not supported\");\n@@ -375,2 +359,0 @@\n-  if (!InlineIntrinsics) return NULL; \/\/ Generate a vanilla entry\n-\n@@ -521,0 +503,4 @@\n+\n+\/\/ Not supported\n+address TemplateInterpreterGenerator::generate_currentThread() { return nullptr; }\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_32.cpp","additions":130,"deletions":144,"binary":false,"changes":274,"status":"modified"},{"patch":"@@ -185,40 +185,38 @@\n-  if (UseCRC32Intrinsics) {\n-    address entry = __ pc();\n-\n-    \/\/ rbx,: Method*\n-    \/\/ r13: senderSP must preserved for slow path, set SP to it on fast path\n-    \/\/ c_rarg0: scratch (rdi on non-Win64, rcx on Win64)\n-    \/\/ c_rarg1: scratch (rsi on non-Win64, rdx on Win64)\n-\n-    Label slow_path;\n-    __ safepoint_poll(slow_path, r15_thread, true \/* at_return *\/, false \/* in_nmethod *\/);\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n-\n-    \/\/ Load parameters\n-    const Register crc = rax;  \/\/ crc\n-    const Register val = c_rarg0;  \/\/ source java byte value\n-    const Register tbl = c_rarg1;  \/\/ scratch\n-\n-    \/\/ Arguments are reversed on java expression stack\n-    __ movl(val, Address(rsp,   wordSize)); \/\/ byte value\n-    __ movl(crc, Address(rsp, 2*wordSize)); \/\/ Initial CRC\n-\n-    __ lea(tbl, ExternalAddress(StubRoutines::crc_table_addr()));\n-    __ notl(crc); \/\/ ~crc\n-    __ update_byte_crc32(crc, val, tbl);\n-    __ notl(crc); \/\/ ~crc\n-    \/\/ result in rax\n-\n-    \/\/ _areturn\n-    __ pop(rdi);                \/\/ get return address\n-    __ mov(rsp, r13);           \/\/ set sp to sender sp\n-    __ jmp(rdi);\n-\n-    \/\/ generate a vanilla native entry as the slow path\n-    __ bind(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n-    return entry;\n-  }\n-  return NULL;\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n+\n+  \/\/ rbx,: Method*\n+  \/\/ r13: senderSP must preserved for slow path, set SP to it on fast path\n+  \/\/ c_rarg0: scratch (rdi on non-Win64, rcx on Win64)\n+  \/\/ c_rarg1: scratch (rsi on non-Win64, rdx on Win64)\n+\n+  Label slow_path;\n+  __ safepoint_poll(slow_path, r15_thread, true \/* at_return *\/, false \/* in_nmethod *\/);\n+\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n+\n+  \/\/ Load parameters\n+  const Register crc = rax;  \/\/ crc\n+  const Register val = c_rarg0;  \/\/ source java byte value\n+  const Register tbl = c_rarg1;  \/\/ scratch\n+\n+  \/\/ Arguments are reversed on java expression stack\n+  __ movl(val, Address(rsp,   wordSize)); \/\/ byte value\n+  __ movl(crc, Address(rsp, 2*wordSize)); \/\/ Initial CRC\n+\n+  __ lea(tbl, ExternalAddress(StubRoutines::crc_table_addr()));\n+  __ notl(crc); \/\/ ~crc\n+  __ update_byte_crc32(crc, val, tbl);\n+  __ notl(crc); \/\/ ~crc\n+  \/\/ result in rax\n+\n+  \/\/ _areturn\n+  __ pop(rdi);                \/\/ get return address\n+  __ mov(rsp, r13);           \/\/ set sp to sender sp\n+  __ jmp(rdi);\n+\n+  \/\/ generate a vanilla native entry as the slow path\n+  __ bind(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n+  return entry;\n@@ -233,34 +231,2 @@\n-  if (UseCRC32Intrinsics) {\n-    address entry = __ pc();\n-\n-    \/\/ rbx,: Method*\n-    \/\/ r13: senderSP must preserved for slow path, set SP to it on fast path\n-\n-    Label slow_path;\n-    __ safepoint_poll(slow_path, r15_thread, false \/* at_return *\/, false \/* in_nmethod *\/);\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n-\n-    \/\/ Load parameters\n-    const Register crc = c_rarg0;  \/\/ crc\n-    const Register buf = c_rarg1;  \/\/ source java byte array address\n-    const Register len = c_rarg2;  \/\/ length\n-    const Register off = len;      \/\/ offset (never overlaps with 'len')\n-\n-    \/\/ Arguments are reversed on java expression stack\n-    \/\/ Calculate address of start element\n-    if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) {\n-      __ movptr(buf, Address(rsp, 3*wordSize)); \/\/ long buf\n-      __ movl2ptr(off, Address(rsp, 2*wordSize)); \/\/ offset\n-      __ addq(buf, off); \/\/ + offset\n-      __ movl(crc,   Address(rsp, 5*wordSize)); \/\/ Initial CRC\n-    } else {\n-      __ movptr(buf, Address(rsp, 3*wordSize)); \/\/ byte[] array\n-      __ addptr(buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n-      __ movl2ptr(off, Address(rsp, 2*wordSize)); \/\/ offset\n-      __ addq(buf, off); \/\/ + offset\n-      __ movl(crc,   Address(rsp, 4*wordSize)); \/\/ Initial CRC\n-    }\n-    \/\/ Can now load 'len' since we're finished with 'off'\n-    __ movl(len, Address(rsp, wordSize)); \/\/ Length\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n@@ -268,2 +234,31 @@\n-    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32()), crc, buf, len);\n-    \/\/ result in rax\n+  \/\/ rbx,: Method*\n+  \/\/ r13: senderSP must preserved for slow path, set SP to it on fast path\n+\n+  Label slow_path;\n+  __ safepoint_poll(slow_path, r15_thread, false \/* at_return *\/, false \/* in_nmethod *\/);\n+\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n+\n+  \/\/ Load parameters\n+  const Register crc = c_rarg0;  \/\/ crc\n+  const Register buf = c_rarg1;  \/\/ source java byte array address\n+  const Register len = c_rarg2;  \/\/ length\n+  const Register off = len;      \/\/ offset (never overlaps with 'len')\n+\n+  \/\/ Arguments are reversed on java expression stack\n+  \/\/ Calculate address of start element\n+  if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) {\n+    __ movptr(buf, Address(rsp, 3*wordSize)); \/\/ long buf\n+    __ movl2ptr(off, Address(rsp, 2*wordSize)); \/\/ offset\n+    __ addq(buf, off); \/\/ + offset\n+    __ movl(crc,   Address(rsp, 5*wordSize)); \/\/ Initial CRC\n+  } else {\n+    __ movptr(buf, Address(rsp, 3*wordSize)); \/\/ byte[] array\n+    __ addptr(buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n+    __ movl2ptr(off, Address(rsp, 2*wordSize)); \/\/ offset\n+    __ addq(buf, off); \/\/ + offset\n+    __ movl(crc,   Address(rsp, 4*wordSize)); \/\/ Initial CRC\n+  }\n+  \/\/ Can now load 'len' since we're finished with 'off'\n+  __ movl(len, Address(rsp, wordSize)); \/\/ Length\n@@ -271,4 +266,2 @@\n-    \/\/ _areturn\n-    __ pop(rdi);                \/\/ get return address\n-    __ mov(rsp, r13);           \/\/ set sp to sender sp\n-    __ jmp(rdi);\n+  __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32()), crc, buf, len);\n+  \/\/ result in rax\n@@ -276,6 +269,9 @@\n-    \/\/ generate a vanilla native entry as the slow path\n-    __ bind(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n-    return entry;\n-  }\n-  return NULL;\n+  \/\/ _areturn\n+  __ pop(rdi);                \/\/ get return address\n+  __ mov(rsp, r13);           \/\/ set sp to sender sp\n+  __ jmp(rdi);\n+\n+  \/\/ generate a vanilla native entry as the slow path\n+  __ bind(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n+  return entry;\n@@ -290,40 +286,29 @@\n-  if (UseCRC32CIntrinsics) {\n-    address entry = __ pc();\n-    \/\/ Load parameters\n-    const Register crc = c_rarg0;  \/\/ crc\n-    const Register buf = c_rarg1;  \/\/ source java byte array address\n-    const Register len = c_rarg2;\n-    const Register off = c_rarg3;  \/\/ offset\n-    const Register end = len;\n-\n-    \/\/ Arguments are reversed on java expression stack\n-    \/\/ Calculate address of start element\n-    if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) {\n-      __ movptr(buf, Address(rsp, 3 * wordSize)); \/\/ long address\n-      __ movl2ptr(off, Address(rsp, 2 * wordSize)); \/\/ offset\n-      __ addq(buf, off); \/\/ + offset\n-      __ movl(crc, Address(rsp, 5 * wordSize)); \/\/ Initial CRC\n-      \/\/ Note on 5 * wordSize vs. 4 * wordSize:\n-      \/\/ *   int java.util.zip.CRC32C.updateByteBuffer(int crc, long address, int off, int end)\n-      \/\/                                                   4         2,3          1        0\n-      \/\/ end starts at SP + 8\n-      \/\/ The Java(R) Virtual Machine Specification Java SE 7 Edition\n-      \/\/ 4.10.2.3. Values of Types long and double\n-      \/\/    \"When calculating operand stack length, values of type long and double have length two.\"\n-    } else {\n-      __ movptr(buf, Address(rsp, 3 * wordSize)); \/\/ byte[] array\n-      __ addptr(buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n-      __ movl2ptr(off, Address(rsp, 2 * wordSize)); \/\/ offset\n-      __ addq(buf, off); \/\/ + offset\n-      __ movl(crc, Address(rsp, 4 * wordSize)); \/\/ Initial CRC\n-    }\n-    __ movl(end, Address(rsp, wordSize)); \/\/ end\n-    __ subl(end, off); \/\/ end - off\n-    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32C()), crc, buf, len);\n-    \/\/ result in rax\n-    \/\/ _areturn\n-    __ pop(rdi);                \/\/ get return address\n-    __ mov(rsp, r13);           \/\/ set sp to sender sp\n-    __ jmp(rdi);\n-\n-    return entry;\n+  assert(UseCRC32CIntrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n+  \/\/ Load parameters\n+  const Register crc = c_rarg0;  \/\/ crc\n+  const Register buf = c_rarg1;  \/\/ source java byte array address\n+  const Register len = c_rarg2;\n+  const Register off = c_rarg3;  \/\/ offset\n+  const Register end = len;\n+\n+  \/\/ Arguments are reversed on java expression stack\n+  \/\/ Calculate address of start element\n+  if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) {\n+    __ movptr(buf, Address(rsp, 3 * wordSize)); \/\/ long address\n+    __ movl2ptr(off, Address(rsp, 2 * wordSize)); \/\/ offset\n+    __ addq(buf, off); \/\/ + offset\n+    __ movl(crc, Address(rsp, 5 * wordSize)); \/\/ Initial CRC\n+    \/\/ Note on 5 * wordSize vs. 4 * wordSize:\n+    \/\/ *   int java.util.zip.CRC32C.updateByteBuffer(int crc, long address, int off, int end)\n+    \/\/                                                   4         2,3          1        0\n+    \/\/ end starts at SP + 8\n+    \/\/ The Java(R) Virtual Machine Specification Java SE 7 Edition\n+    \/\/ 4.10.2.3. Values of Types long and double\n+    \/\/    \"When calculating operand stack length, values of type long and double have length two.\"\n+  } else {\n+    __ movptr(buf, Address(rsp, 3 * wordSize)); \/\/ byte[] array\n+    __ addptr(buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n+    __ movl2ptr(off, Address(rsp, 2 * wordSize)); \/\/ offset\n+    __ addq(buf, off); \/\/ + offset\n+    __ movl(crc, Address(rsp, 4 * wordSize)); \/\/ Initial CRC\n@@ -331,0 +316,8 @@\n+  __ movl(end, Address(rsp, wordSize)); \/\/ end\n+  __ subl(end, off); \/\/ end - off\n+  __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32C()), crc, buf, len);\n+  \/\/ result in rax\n+  \/\/ _areturn\n+  __ pop(rdi);                \/\/ get return address\n+  __ mov(rsp, r13);           \/\/ set sp to sender sp\n+  __ jmp(rdi);\n@@ -332,1 +325,1 @@\n-  return NULL;\n+  return entry;\n@@ -340,6 +333,1 @@\n-  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n-  if (!VM_Version::supports_float16() ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat) ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16)) {\n-    return nullptr; \/\/ Generate a vanilla entry\n-  }\n+  assert(VM_Version::supports_float16(), \"this intrinsic is not supported\");\n@@ -367,6 +355,1 @@\n-  \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n-  if (!VM_Version::supports_float16() ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_floatToFloat16) ||\n-      vmIntrinsics::is_disabled_by_flags(vmIntrinsics::_float16ToFloat)) {\n-    return nullptr; \/\/ Generate a vanilla entry\n-  }\n+  assert(VM_Version::supports_float16(), \"this intrinsic is not supported\");\n@@ -399,2 +382,0 @@\n-  if (!InlineIntrinsics) return NULL; \/\/ Generate a vanilla entry\n-\n@@ -517,0 +498,6 @@\n+\/\/ Not supported\n+address TemplateInterpreterGenerator::generate_Float_intBitsToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToRawIntBits_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_longBitsToDouble_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_doubleToRawLongBits_entry() { return nullptr; }\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_64.cpp","additions":128,"deletions":141,"binary":false,"changes":269,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,0 +168,3 @@\n+static const int upcall_stub_code_base_size = 2048;\n+static const int upcall_stub_size_per_arg = 16;\n+\n@@ -176,1 +179,2 @@\n-  CodeBuffer buffer(\"upcall_stub\", \/* code_size = *\/ 2048, \/* locs_size = *\/ 1024);\n+  int code_size = upcall_stub_code_base_size + (total_in_args * upcall_stub_size_per_arg);\n+  CodeBuffer buffer(\"upcall_stub\", code_size, \/* locs_size = *\/ 1);\n@@ -389,0 +393,2 @@\n+  buffer.log_section_sizes(name);\n+\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmIntrinsics.hpp\"\n@@ -3223,0 +3224,16 @@\n+\n+bool VM_Version::is_intrinsic_supported(vmIntrinsicID id) {\n+  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n+  switch (id) {\n+  case vmIntrinsics::_floatToFloat16:\n+  case vmIntrinsics::_float16ToFloat:\n+    if (!supports_float16()) {\n+      return false;\n+    }\n+    break;\n+  default:\n+    break;\n+  }\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -767,0 +767,3 @@\n+  \/\/ Check intrinsic support\n+  static bool is_intrinsic_supported(vmIntrinsicID id);\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -526,1 +526,1 @@\n-    if (cs->is_empty())  continue;  \/\/ skip trivial section\n+    if (cs->is_empty() || !cs->has_locs()) continue;  \/\/ skip trivial section\n@@ -794,1 +794,1 @@\n-    if (cs->is_empty()) continue;  \/\/ skip trivial section\n+    if (cs->is_empty() || !cs->has_locs()) continue;  \/\/ skip trivial section\n@@ -1001,1 +1001,1 @@\n-    xtty->print_cr(\"<blob name='%s' size='%d'>\", name, _total_size);\n+    xtty->print_cr(\"<blob name='%s' total_size='%d'>\", name, _total_size);\n@@ -1005,2 +1005,2 @@\n-      xtty->print_cr(\"<sect index='%d' size='\" SIZE_FORMAT \"' free='\" SIZE_FORMAT \"'\/>\",\n-                     n, sect->limit() - sect->start(), sect->limit() - sect->end());\n+      xtty->print_cr(\"<sect index='%d' capacity='%d' size='%d' remaining='%d'\/>\",\n+                     n, sect->capacity(), sect->size(), sect->remaining());\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -316,3 +316,0 @@\n-\n-  \/\/ done\n-  masm()->flush();\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -575,1 +575,1 @@\n-    int offset = field->offset();\n+    int offset = field->offset_in_bytes();\n@@ -585,1 +585,1 @@\n-    int offset = field->offset();\n+    int offset = field->offset_in_bytes();\n@@ -626,1 +626,1 @@\n-      int offset = field->offset();\n+      int offset = field->offset_in_bytes();\n@@ -694,1 +694,1 @@\n-      int offset = field->offset();\n+      int offset = field->offset_in_bytes();\n@@ -1755,1 +1755,1 @@\n-  const int offset = !needs_patching ? field->offset() : -1;\n+  const int offset = !needs_patching ? field->offset_in_bytes() : -1;\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,1 +193,1 @@\n-                   && (all_offsets || lf->field()->offset() == field->offset());\n+                   && (all_offsets || lf->field()->offset_in_bytes() == field->offset_in_bytes());\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    warning(\"DumpLoadedClassList and CDS are not supported in exploded build\");\n+    log_warning(cds)(\"DumpLoadedClassList and CDS are not supported in exploded build\");\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-      warning(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n+      log_warning(cds)(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n@@ -373,1 +373,1 @@\n-      warning(\"-XX:ArchiveClassesAtExit\" __THEMSG);\n+      log_warning(cds)(\"-XX:ArchiveClassesAtExit\" __THEMSG);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,1 +194,0 @@\n-    FREE_C_HEAP_ARRAY(const char, default_base_archive_name);\n@@ -1047,1 +1046,1 @@\n-      warning(\n+      log_warning(cds)(\n@@ -1053,1 +1052,1 @@\n-        warning(\n+        log_warning(cds)(\n@@ -1138,1 +1137,1 @@\n-      warning(\"Archived non-system classes are disabled because the \"\n+      log_warning(cds)(\"Archived non-system classes are disabled because the \"\n@@ -2389,1 +2388,1 @@\n-    log_info(cds)(\"UseSharedSpaces: Unable to allocate region, range is not within java heap.\");\n+    log_info(cds)(\"Unable to allocate region, range is not within java heap.\");\n@@ -2396,1 +2395,1 @@\n-    log_info(cds)(\"UseSharedSpaces: Unable to allocate region, java heap range is already in use.\");\n+    log_info(cds)(\"Unable to allocate region, java heap range is already in use.\");\n@@ -2412,1 +2411,1 @@\n-      log_info(cds)(\"UseSharedSpaces: Unable to map at required address in java heap. \"\n+      log_info(cds)(\"Unable to map at required address in java heap. \"\n@@ -2422,1 +2421,1 @@\n-      log_info(cds)(\"UseSharedSpaces: mapped heap regions are corrupt\");\n+      log_info(cds)(\"mapped heap regions are corrupt\");\n@@ -2648,1 +2647,1 @@\n-    warning(\"Archived non-system classes are disabled because the \"\n+    log_warning(cds)(\"Archived non-system classes are disabled because the \"\n@@ -2687,1 +2686,1 @@\n-    warning(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n+    log_warning(cds)(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -212,4 +212,2 @@\n-  {\n-    MutexLocker mu_r(THREAD, Compile_lock); \/\/ add_to_hierarchy asserts this.\n-    SystemDictionary::add_to_hierarchy(result);\n-  }\n+  SystemDictionary::add_to_hierarchy(THREAD, result);\n+\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -563,1 +563,1 @@\n-    warning(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n+    log_warning(cds)(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n@@ -944,1 +944,1 @@\n-      warning(\"-XX:ArchiveClassesAtExit is unsupported when base CDS archive is not loaded. Run with -Xlog:cds for more info.\");\n+      log_warning(cds)(\"-XX:ArchiveClassesAtExit is unsupported when base CDS archive is not loaded. Run with -Xlog:cds for more info.\");\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -884,1 +884,1 @@\n-            set_modified(p, will_link ? field->offset() : OFFSET_ANY, type2size[field_type]*HeapWordSize);\n+            set_modified(p, will_link ? field->offset_in_bytes() : OFFSET_ANY, type2size[field_type]*HeapWordSize);\n","filename":"src\/hotspot\/share\/ci\/bcEscapeAnalyzer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -315,1 +315,1 @@\n-    _constant_value = mirror->field_value_impl(type()->basic_type(), offset());\n+    _constant_value = mirror->field_value_impl(type()->basic_type(), offset_in_bytes());\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -110,2 +110,2 @@\n-  \/\/ What is the offset of this field?\n-  int offset() const {\n+  \/\/ What is the offset of this field? (Fields are aligned to the byte level.)\n+  int offset_in_bytes() const {\n@@ -116,5 +116,0 @@\n-  \/\/ Same question, explicit units.  (Fields are aligned to the byte level.)\n-  int offset_in_bytes() const {\n-    return offset();\n-  }\n-\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  return field_value_impl(field->type()->basic_type(), field->offset());\n+  return field_value_impl(field->type()->basic_type(), field->offset_in_bytes());\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -805,1 +805,0 @@\n-                                               const char* path,\n@@ -856,1 +855,1 @@\n-      add_to_app_classpath_entries(current, path, new_entry, check_for_duplicates);\n+      add_to_app_classpath_entries(current, new_entry, check_for_duplicates);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -226,1 +226,0 @@\n-                                           const char* path,\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,12 +48,0 @@\n-\n-int ClassLoaderHierarchyDCmd::num_arguments() {\n-  ResourceMark rm;\n-  ClassLoaderHierarchyDCmd* dcmd = new ClassLoaderHierarchyDCmd(nullptr, false);\n-  if (dcmd != nullptr) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderHierarchyDCmd.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  static int num_arguments();\n+  static int num_arguments() { return 3; }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderHierarchyDCmd.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2743,4 +2743,5 @@\n-Handle java_lang_Throwable::get_cause_with_stack_trace(Handle throwable, TRAPS) {\n-  \/\/ Call to JVM to fill in the stack trace and clear declaringClassObject to\n-  \/\/ not keep classes alive in the stack trace.\n-  \/\/ call this:  public StackTraceElement[] getStackTrace()\n+Handle java_lang_Throwable::create_initialization_error(JavaThread* current, Handle throwable) {\n+  \/\/ Creates an ExceptionInInitializerError to be recorded as the initialization error when class initialization\n+  \/\/ failed due to the passed in 'throwable'. We cannot save 'throwable' directly due to issues with keeping alive\n+  \/\/ all objects referenced via its stacktrace. So instead we save a new EIIE instance, with the same message and\n+  \/\/ symbolic stacktrace of 'throwable'.\n@@ -2749,13 +2750,1 @@\n-  JavaValue result(T_ARRAY);\n-  JavaCalls::call_virtual(&result, throwable,\n-                          vmClasses::Throwable_klass(),\n-                          vmSymbols::getStackTrace_name(),\n-                          vmSymbols::getStackTrace_signature(),\n-                          CHECK_NH);\n-  Handle stack_trace(THREAD, result.get_oop());\n-  assert(stack_trace->is_objArray(), \"Should be an array\");\n-\n-  \/\/ Throw ExceptionInInitializerError as the cause with this exception in\n-  \/\/ the message and stack trace.\n-\n-  \/\/ Now create the message with the original exception and thread name.\n+  \/\/ Now create the message from the original exception and thread name.\n@@ -2763,1 +2752,1 @@\n-  ResourceMark rm(THREAD);\n+  ResourceMark rm(current);\n@@ -2768,1 +2757,1 @@\n-    st.print(\"[in thread \\\"%s\\\"]\", THREAD->name());\n+    st.print(\"[in thread \\\"%s\\\"]\", current->name());\n@@ -2770,1 +2759,1 @@\n-    st.print(\"%s [in thread \\\"%s\\\"]\", message->as_C_string(), THREAD->name());\n+    st.print(\"%s [in thread \\\"%s\\\"]\", message->as_C_string(), current->name());\n@@ -2774,4 +2763,4 @@\n-  Handle h_cause = Exceptions::new_exception(THREAD, exception_name, st.as_string());\n-\n-  \/\/ If new_exception returns a different exception while creating the exception, return null.\n-  if (h_cause->klass()->name() != exception_name) {\n+  Handle init_error = Exceptions::new_exception(current, exception_name, st.as_string());\n+  \/\/ If new_exception returns a different exception while creating the exception,\n+  \/\/ abandon the attempt to save the initialization error and return null.\n+  if (init_error->klass()->name() != exception_name) {\n@@ -2779,1 +2768,1 @@\n-                          h_cause->klass()->external_name());\n+                        init_error->klass()->external_name());\n@@ -2782,4 +2771,23 @@\n-  java_lang_Throwable::set_stacktrace(h_cause(), stack_trace());\n-  \/\/ Clear backtrace because the stacktrace should be used instead.\n-  set_backtrace(h_cause(), nullptr);\n-  return h_cause;\n+\n+  \/\/ Call to java to fill in the stack trace and clear declaringClassObject to\n+  \/\/ not keep classes alive in the stack trace.\n+  \/\/ call this:  public StackTraceElement[] getStackTrace()\n+  JavaValue result(T_ARRAY);\n+  JavaCalls::call_virtual(&result, throwable,\n+                          vmClasses::Throwable_klass(),\n+                          vmSymbols::getStackTrace_name(),\n+                          vmSymbols::getStackTrace_signature(),\n+                          current);\n+  if (!current->has_pending_exception()){\n+    Handle stack_trace(current, result.get_oop());\n+    assert(stack_trace->is_objArray(), \"Should be an array\");\n+    java_lang_Throwable::set_stacktrace(init_error(), stack_trace());\n+    \/\/ Clear backtrace because the stacktrace should be used instead.\n+    set_backtrace(init_error(), nullptr);\n+  } else {\n+    log_info(class, init)(\"Exception thrown while getting stack trace for initialization exception %s\",\n+                        init_error->klass()->external_name());\n+    current->clear_pending_exception();\n+  }\n+\n+  return init_error;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":37,"deletions":29,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -619,1 +619,1 @@\n-  static Handle get_cause_with_stack_trace(Handle throwable, TRAPS);\n+  static Handle create_initialization_error(JavaThread* current, Handle throwable);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -902,6 +903,3 @@\n-  {\n-    MutexLocker mu_r(THREAD, Compile_lock);\n-    \/\/ Add to class hierarchy, and do possible deoptimizations.\n-    add_to_hierarchy(k);\n-    \/\/ But, do not add to dictionary.\n-  }\n+  \/\/ Add to class hierarchy, and do possible deoptimizations.\n+  add_to_hierarchy(THREAD, k);\n+  \/\/ But, do not add to dictionary.\n@@ -1492,1 +1490,3 @@\n-  \/\/ Add the new class. We need recompile lock during update of CHA.\n+  \/\/ Add to class hierarchy, and do possible deoptimizations.\n+  add_to_hierarchy(THREAD, k);\n+\n@@ -1495,4 +1495,0 @@\n-\n-    \/\/ Add to class hierarchy, and do possible deoptimizations.\n-    add_to_hierarchy(k);\n-\n@@ -1615,2 +1611,1 @@\n-\/\/ is held, to ensure that the compiler is not using the class hierarchy, and that deoptimization will kick in\n-\/\/ before a new class is used.\n+\/\/ is grabbed, to ensure that the compiler is not using the class hierarchy.\n@@ -1618,1 +1613,1 @@\n-void SystemDictionary::add_to_hierarchy(InstanceKlass* k) {\n+void SystemDictionary::add_to_hierarchy(JavaThread* current, InstanceKlass* k) {\n@@ -1620,2 +1615,8 @@\n-  if (Universe::is_fully_initialized()) {\n-    assert_locked_or_safepoint(Compile_lock);\n+  assert(!SafepointSynchronize::is_at_safepoint(), \"must NOT be at safepoint\");\n+\n+  \/\/ In case we are not using CHA based vtables we need to make sure the loaded\n+  \/\/ deopt is completed before anyone links this class.\n+  \/\/ Linking is done with _init_monitor held, by loading and deopting with it\n+  \/\/ held we make sure the deopt is completed before linking.\n+  if (!UseVtableBasedCHA) {\n+    k->init_monitor()->lock();\n@@ -1624,4 +1625,8 @@\n-  k->set_init_state(InstanceKlass::loaded);\n-  \/\/ make sure init_state store is already done.\n-  \/\/ The compiler reads the hierarchy outside of the Compile_lock.\n-  \/\/ Access ordering is used to add to hierarchy.\n+  DeoptimizationScope deopt_scope;\n+  {\n+    MutexLocker ml(current, Compile_lock);\n+\n+    k->set_init_state(InstanceKlass::loaded);\n+    \/\/ make sure init_state store is already done.\n+    \/\/ The compiler reads the hierarchy outside of the Compile_lock.\n+    \/\/ Access ordering is used to add to hierarchy.\n@@ -1629,3 +1634,12 @@\n-  \/\/ Link into hierarchy.\n-  k->append_to_sibling_list();                    \/\/ add to superklass\/sibling list\n-  k->process_interfaces();                        \/\/ handle all \"implements\" declarations\n+    \/\/ Link into hierarchy.\n+    k->append_to_sibling_list();                    \/\/ add to superklass\/sibling list\n+    k->process_interfaces();                        \/\/ handle all \"implements\" declarations\n+\n+    \/\/ Now mark all code that depended on old class hierarchy.\n+    \/\/ Note: must be done *after* linking k into the hierarchy (was bug 12\/9\/97)\n+    if (Universe::is_fully_initialized()) {\n+      CodeCache::mark_dependents_on(&deopt_scope, k);\n+    }\n+  }\n+  \/\/ Perform the deopt handshake outside Compile_lock.\n+  deopt_scope.deoptimize_marked();\n@@ -1633,4 +1647,2 @@\n-  \/\/ Now flush all code that depended on old class hierarchy.\n-  \/\/ Note: must be done *after* linking k into the hierarchy (was bug 12\/9\/97)\n-  if (Universe::is_fully_initialized()) {\n-    CodeCache::flush_dependents_on(k);\n+  if (!UseVtableBasedCHA) {\n+    k->init_monitor()->unlock();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -369,2 +369,2 @@\n-  \/\/ Setup link to hierarchy\n-  static void add_to_hierarchy(InstanceKlass* k);\n+  \/\/ Setup link to hierarchy and deoptimize\n+  static void add_to_hierarchy(JavaThread* current, InstanceKlass* k);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -853,2 +853,0 @@\n-  {\n-    MutexLocker mu_r(THREAD, Compile_lock);\n@@ -856,4 +854,4 @@\n-    \/\/ Add to class hierarchy, and do possible deoptimizations.\n-    SystemDictionary::add_to_hierarchy(loaded_lambda);\n-    \/\/ But, do not add to dictionary.\n-  }\n+  \/\/ Add to class hierarchy, and do possible deoptimizations.\n+  SystemDictionary::add_to_hierarchy(THREAD, loaded_lambda);\n+  \/\/ But, do not add to dictionary.\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -252,1 +252,1 @@\n-  SystemDictionary::add_to_hierarchy(klass);\n+  SystemDictionary::add_to_hierarchy(THREAD, klass);\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -652,3 +653,2 @@\n-bool vmIntrinsics::is_disabled_by_flags(const methodHandle& method) {\n-  vmIntrinsics::ID id = method->intrinsic_id();\n-  return is_disabled_by_flags(id);\n+bool vmIntrinsics::is_intrinsic_available(vmIntrinsics::ID id) {\n+  return VM_Version::is_intrinsic_supported(id) && !is_disabled_by_flags(id);\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1527,4 +1527,1 @@\n-  static bool is_disabled_by_flags(const methodHandle& method);\n-  static bool is_intrinsic_available(vmIntrinsics::ID id) {\n-    return !is_disabled_by_flags(id);\n-  }\n+  static bool is_intrinsic_available(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -631,3 +631,0 @@\n-\n-  \/\/ flush the hardware I-cache\n-  ICache::invalidate_range(cb->content_begin(), cb->content_size());\n@@ -1246,1 +1243,1 @@\n-int CodeCache::mark_for_deoptimization(KlassDepChange& changes) {\n+void CodeCache::mark_for_deoptimization(DeoptimizationScope* deopt_scope, KlassDepChange& changes) {\n@@ -1248,1 +1245,0 @@\n-  int number_of_marked_CodeBlobs = 0;\n@@ -1259,2 +1255,2 @@\n-    Klass* d = str.klass();\n-    number_of_marked_CodeBlobs += InstanceKlass::cast(d)->mark_dependent_nmethods(changes);\n+    InstanceKlass* d = str.klass();\n+    d->mark_dependent_nmethods(deopt_scope, changes);\n@@ -1272,2 +1268,0 @@\n-\n-  return number_of_marked_CodeBlobs;\n@@ -1328,1 +1322,1 @@\n-int CodeCache::mark_dependents_for_evol_deoptimization() {\n+void CodeCache::mark_dependents_for_evol_deoptimization(DeoptimizationScope* deopt_scope) {\n@@ -1334,1 +1328,0 @@\n-  int number_of_marked_CodeBlobs = 0;\n@@ -1342,1 +1335,1 @@\n-      nm->mark_for_deoptimization();\n+      deopt_scope->mark(nm);\n@@ -1344,1 +1337,0 @@\n-      number_of_marked_CodeBlobs++;\n@@ -1347,4 +1339,0 @@\n-\n-  \/\/ return total count of nmethods marked for deoptimization, if zero the caller\n-  \/\/ can skip deoptimization\n-  return number_of_marked_CodeBlobs;\n@@ -1353,1 +1341,1 @@\n-void CodeCache::mark_all_nmethods_for_evol_deoptimization() {\n+void CodeCache::mark_all_nmethods_for_evol_deoptimization(DeoptimizationScope* deopt_scope) {\n@@ -1360,1 +1348,1 @@\n-        nm->mark_for_deoptimization();\n+        deopt_scope->mark(nm);\n@@ -1369,13 +1357,0 @@\n-\/\/ Flushes compiled methods dependent on redefined classes, that have already been\n-\/\/ marked for deoptimization.\n-void CodeCache::flush_evol_dependents() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Can only do this at a safepoint!\");\n-\n-  \/\/ CodeCache can only be updated by a thread_in_VM and they will all be\n-  \/\/ stopped during the safepoint so CodeCache will be safe to update without\n-  \/\/ holding the CodeCache_lock.\n-\n-  \/\/ At least one nmethod has been marked for deoptimization\n-\n-  Deoptimization::deoptimize_all_marked();\n-}\n@@ -1385,1 +1360,1 @@\n-void CodeCache::mark_all_nmethods_for_deoptimization() {\n+void CodeCache::mark_all_nmethods_for_deoptimization(DeoptimizationScope* deopt_scope) {\n@@ -1391,1 +1366,1 @@\n-      nm->mark_for_deoptimization();\n+      deopt_scope->mark(nm);\n@@ -1396,1 +1371,1 @@\n-int CodeCache::mark_for_deoptimization(Method* dependee) {\n+void CodeCache::mark_for_deoptimization(DeoptimizationScope* deopt_scope, Method* dependee) {\n@@ -1398,1 +1373,0 @@\n-  int number_of_marked_CodeBlobs = 0;\n@@ -1404,3 +1378,1 @@\n-      ResourceMark rm;\n-      nm->mark_for_deoptimization();\n-      number_of_marked_CodeBlobs++;\n+      deopt_scope->mark(nm);\n@@ -1409,2 +1381,0 @@\n-\n-  return number_of_marked_CodeBlobs;\n@@ -1419,1 +1389,1 @@\n-      make_nmethod_deoptimized(nm);\n+      nm->make_deoptimized();\n@@ -1424,8 +1394,2 @@\n-void CodeCache::make_nmethod_deoptimized(CompiledMethod* nm) {\n-  if (nm->is_marked_for_deoptimization() && nm->can_be_deoptimized()) {\n-    nm->make_deoptimized();\n-  }\n-}\n-\n-\/\/ Flushes compiled methods dependent on dependee.\n-void CodeCache::flush_dependents_on(InstanceKlass* dependee) {\n+\/\/ Marks compiled methods dependent on dependee.\n+void CodeCache::mark_dependents_on(DeoptimizationScope* deopt_scope, InstanceKlass* dependee) {\n@@ -1438,1 +1402,0 @@\n-  int marked = 0;\n@@ -1442,1 +1405,1 @@\n-    marked = mark_for_deoptimization(changes);\n+    mark_for_deoptimization(deopt_scope, changes);\n@@ -1446,6 +1409,1 @@\n-    marked = mark_for_deoptimization(changes);\n-  }\n-\n-  if (marked > 0) {\n-    \/\/ At least one nmethod has been marked for deoptimization\n-    Deoptimization::deoptimize_all_marked();\n+    mark_for_deoptimization(deopt_scope, changes);\n@@ -1455,4 +1413,3 @@\n-\/\/ Flushes compiled methods dependent on dependee\n-void CodeCache::flush_dependents_on_method(const methodHandle& m_h) {\n-  \/\/ --- Compile_lock is not held. However we are at a safepoint.\n-  assert_locked_or_safepoint(Compile_lock);\n+\/\/ Marks compiled methods dependent on dependee\n+void CodeCache::mark_dependents_on_method_for_breakpoint(const methodHandle& m_h) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n@@ -1460,0 +1417,1 @@\n+  DeoptimizationScope deopt_scope;\n@@ -1461,3 +1419,2 @@\n-  if (mark_for_deoptimization(m_h()) > 0) {\n-    Deoptimization::deoptimize_all_marked();\n-  }\n+  mark_for_deoptimization(&deopt_scope, m_h());\n+  deopt_scope.deoptimize_marked();\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":22,"deletions":65,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+class DeoptimizationScope;\n@@ -304,1 +305,1 @@\n-  static int  mark_for_deoptimization(KlassDepChange& changes);\n+  static void mark_for_deoptimization(DeoptimizationScope* deopt_scope, KlassDepChange& changes);\n@@ -307,2 +308,2 @@\n-  static void mark_all_nmethods_for_deoptimization();\n-  static int  mark_for_deoptimization(Method* dependee);\n+  static void mark_all_nmethods_for_deoptimization(DeoptimizationScope* deopt_scope);\n+  static void mark_for_deoptimization(DeoptimizationScope* deopt_scope, Method* dependee);\n@@ -310,1 +311,0 @@\n-  static void make_nmethod_deoptimized(CompiledMethod* nm);\n@@ -312,2 +312,2 @@\n-  \/\/ Flushing and deoptimization\n-  static void flush_dependents_on(InstanceKlass* dependee);\n+  \/\/ Marks dependents during classloading\n+  static void mark_dependents_on(DeoptimizationScope* deopt_scope, InstanceKlass* dependee);\n@@ -316,4 +316,3 @@\n-  \/\/ Flushing and deoptimization in case of evolution\n-  static int  mark_dependents_for_evol_deoptimization();\n-  static void mark_all_nmethods_for_evol_deoptimization();\n-  static void flush_evol_dependents();\n+  \/\/ Marks in case of evolution\n+  static void mark_dependents_for_evol_deoptimization(DeoptimizationScope* deopt_scope);\n+  static void mark_all_nmethods_for_evol_deoptimization(DeoptimizationScope* deopt_scope);\n@@ -324,1 +323,1 @@\n-  static void flush_dependents_on_method(const methodHandle& dependee);\n+  static void mark_dependents_on_method_for_breakpoint(const methodHandle& dependee);\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -57,1 +57,2 @@\n-    _mark_for_deoptimization_status(not_marked),\n+    _deoptimization_status(not_marked),\n+    _deoptimization_generation(0),\n@@ -69,1 +70,2 @@\n-    _mark_for_deoptimization_status(not_marked),\n+    _deoptimization_status(not_marked),\n+    _deoptimization_generation(0),\n@@ -116,6 +118,4 @@\n-void CompiledMethod::mark_for_deoptimization(bool inc_recompile_counts) {\n-  \/\/ assert(can_be_deoptimized(), \"\"); \/\/ in some places we check before marking, in others not.\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n-                 Mutex::_no_safepoint_check_flag);\n-  if (_mark_for_deoptimization_status != deoptimize_done) { \/\/ can't go backwards\n-     _mark_for_deoptimization_status = (inc_recompile_counts ? deoptimize : deoptimize_noupdate);\n+void CompiledMethod::set_deoptimized_done() {\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+  if (_deoptimization_status != deoptimize_done) { \/\/ can't go backwards\n+    Atomic::store(&_deoptimization_status, deoptimize_done);\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-\n+  friend class DeoptimizationScope;\n@@ -146,1 +146,1 @@\n-  enum MarkForDeoptimizationStatus : u1 {\n+  enum DeoptimizationStatus : u1 {\n@@ -153,1 +153,3 @@\n-  MarkForDeoptimizationStatus _mark_for_deoptimization_status; \/\/ Used for stack deoptimization\n+  volatile DeoptimizationStatus _deoptimization_status; \/\/ Used for stack deoptimization\n+  \/\/ Used to track in which deoptimize handshake this method will be deoptimized.\n+  uint64_t                      _deoptimization_generation;\n@@ -177,0 +179,5 @@\n+private:\n+  DeoptimizationStatus deoptimization_status() const {\n+    return Atomic::load(&_deoptimization_status);\n+  }\n+\n@@ -239,5 +246,3 @@\n-  bool  is_marked_for_deoptimization() const { return _mark_for_deoptimization_status != not_marked; }\n-  void  mark_for_deoptimization(bool inc_recompile_counts = true);\n-\n-  bool  has_been_deoptimized() const { return _mark_for_deoptimization_status == deoptimize_done; }\n-  void  mark_deoptimized() { _mark_for_deoptimization_status = deoptimize_done; }\n+  bool  is_marked_for_deoptimization() const { return deoptimization_status() != not_marked; }\n+  bool  has_been_deoptimized() const { return deoptimization_status() == deoptimize_done; }\n+  void  set_deoptimized_done();\n@@ -251,2 +256,2 @@\n-    return _mark_for_deoptimization_status != deoptimize_noupdate &&\n-           _mark_for_deoptimization_status != deoptimize_done;\n+    DeoptimizationStatus status = deoptimization_status();\n+    return status != deoptimize_noupdate && status != deoptimize_done;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1169,1 +1169,1 @@\n-      context_type = InstanceKlass::cast(context_type->implementor());\n+      context_type = context_type->implementor();\n@@ -1600,1 +1600,1 @@\n-  if (lm == nullptr && ctxk->is_instance_klass()) {\n+  if (lm == nullptr) {\n@@ -1602,2 +1602,1 @@\n-    lm = InstanceKlass::cast(ctxk)->lookup_method_in_ordered_interfaces(m->name(),\n-                                                                        m->signature());\n+    lm = ctxk->lookup_method_in_ordered_interfaces(m->name(), m->signature());\n@@ -2177,1 +2176,1 @@\n-    Klass* k = str.klass();\n+    InstanceKlass* k = str.klass();\n@@ -2206,1 +2205,1 @@\n-  Klass* type = (_changes.is_klass_change() ? _changes.as_klass_change()->type() : (Klass*) nullptr);\n+  InstanceKlass* type = (_changes.is_klass_change() ? _changes.as_klass_change()->type() : (InstanceKlass*) nullptr);\n@@ -2217,1 +2216,1 @@\n-    _ti_base = InstanceKlass::cast(_klass)->transitive_interfaces();\n+    _ti_base = _klass->transitive_interfaces();\n@@ -2227,1 +2226,1 @@\n-      _klass = _klass->super();\n+      _klass = _klass->java_super();\n@@ -2257,3 +2256,3 @@\n-    Klass* d = str.klass();\n-    assert(!InstanceKlass::cast(d)->is_marked_dependent(), \"checking\");\n-    InstanceKlass::cast(d)->set_is_marked_dependent(true);\n+    InstanceKlass* d = str.klass();\n+    assert(!d->is_marked_dependent(), \"checking\");\n+    d->set_is_marked_dependent(true);\n@@ -2267,2 +2266,2 @@\n-    Klass* d = str.klass();\n-    InstanceKlass::cast(d)->set_is_marked_dependent(false);\n+    InstanceKlass* d = str.klass();\n+    d->set_is_marked_dependent(false);\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -685,2 +685,0 @@\n-  virtual void mark_for_deoptimization(nmethod* nm) = 0;\n-\n@@ -719,1 +717,1 @@\n-  \/\/   Klass* k = str.klass();\n+  \/\/   InstanceKlass* k = str.klass();\n@@ -730,2 +728,2 @@\n-    ChangeType  _change_type;\n-    Klass*      _klass;\n+    ChangeType     _change_type;\n+    InstanceKlass* _klass;\n@@ -752,1 +750,1 @@\n-    Klass*     klass()           { return _klass; }\n+    InstanceKlass* klass()       { return _klass; }\n@@ -783,4 +781,0 @@\n-  virtual void mark_for_deoptimization(nmethod* nm) {\n-    nm->mark_for_deoptimization(\/*inc_recompile_counts=*\/true);\n-  }\n-\n@@ -825,4 +819,0 @@\n-  virtual void mark_for_deoptimization(nmethod* nm) {\n-    nm->mark_for_deoptimization(\/*inc_recompile_counts=*\/false);\n-  }\n-\n","filename":"src\/hotspot\/share\/code\/dependencies.hpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -65,1 +66,1 @@\n-\/\/ deoptimization.  Returns the number of nmethods found.\n+\/\/ deoptimization.\n@@ -67,2 +68,1 @@\n-int DependencyContext::mark_dependent_nmethods(DepChange& changes) {\n-  int found = 0;\n+void DependencyContext::mark_dependent_nmethods(DeoptimizationScope* deopt_scope, DepChange& changes) {\n@@ -73,3 +73,1 @@\n-        \/\/ Also count already (concurrently) marked nmethods to make sure\n-        \/\/ deoptimization is triggered before execution in this thread continues.\n-        found++;\n+        deopt_scope->dependent(nm);\n@@ -84,2 +82,1 @@\n-        changes.mark_for_deoptimization(nm);\n-        found++;\n+        deopt_scope->mark(nm, !changes.is_call_site_change());\n@@ -89,1 +86,0 @@\n-  return found;\n@@ -192,1 +188,1 @@\n-int DependencyContext::remove_and_mark_for_deoptimization_all_dependents() {\n+void DependencyContext::remove_and_mark_for_deoptimization_all_dependents(DeoptimizationScope* deopt_scope) {\n@@ -195,1 +191,0 @@\n-  int marked = 0;\n@@ -201,2 +196,1 @@\n-      nm->mark_for_deoptimization();\n-      marked++;\n+      deopt_scope->mark(nm);\n@@ -206,1 +200,0 @@\n-  return marked;\n","filename":"src\/hotspot\/share\/code\/dependencyContext.cpp","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+class DeoptimizationScope;\n@@ -120,1 +121,1 @@\n-  int  mark_dependent_nmethods(DepChange& changes);\n+  void mark_dependent_nmethods(DeoptimizationScope* deopt_scope, DepChange& changes);\n@@ -123,1 +124,1 @@\n-  int  remove_and_mark_for_deoptimization_all_dependents();\n+  void remove_and_mark_for_deoptimization_all_dependents(DeoptimizationScope* deopt_scope);\n","filename":"src\/hotspot\/share\/code\/dependencyContext.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -616,2 +616,2 @@\n-          Klass* klass = deps.context_type();\n-          if (klass == nullptr) {\n+          InstanceKlass* ik = deps.context_type();\n+          if (ik == nullptr) {\n@@ -621,1 +621,1 @@\n-          InstanceKlass::cast(klass)->add_dependent_nmethod(nm);\n+          ik->add_dependent_nmethod(nm);\n@@ -1163,0 +1163,2 @@\n+    \/\/ Don't deopt this again.\n+    set_deoptimized_done();\n@@ -1170,0 +1172,6 @@\n+\n+  \/\/ If post call nops have been already patched, we can just bail-out.\n+  if (has_been_deoptimized()) {\n+    return;\n+  }\n+\n@@ -1205,1 +1213,1 @@\n-  mark_deoptimized();\n+  set_deoptimized_done();\n@@ -1491,2 +1499,2 @@\n-        Klass* klass = deps.context_type();\n-        if (klass == nullptr) {\n+        InstanceKlass* ik = deps.context_type();\n+        if (ik == nullptr) {\n@@ -1497,1 +1505,1 @@\n-        InstanceKlass::cast(klass)->clean_dependency_context();\n+        ik->clean_dependency_context();\n@@ -2482,1 +2490,1 @@\n-    Klass* ctxk = deps.context_type();\n+    InstanceKlass* ctxk = deps.context_type();\n@@ -2484,1 +2492,1 @@\n-      if (ctxk->is_instance_klass() && InstanceKlass::cast(ctxk)->is_dependent_nmethod(this)) {\n+      if (ctxk->is_dependent_nmethod(this)) {\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -152,1 +152,2 @@\n-\n+  assert((cs->locs_start() != nullptr) && (cs->locs_end() != nullptr) ||\n+         (cs->locs_start() == nullptr) && (cs->locs_end() == nullptr), \"valid start and end pointer\");\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -129,0 +129,2 @@\n+    vmIntrinsics::ID id = method->intrinsic_id();\n+    assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n@@ -130,2 +132,2 @@\n-           !directive->is_intrinsic_disabled(method) &&\n-           !vmIntrinsics::is_disabled_by_flags(method);\n+           vmIntrinsics::is_intrinsic_available(id) &&\n+           !directive->is_intrinsic_disabled(id);\n","filename":"src\/hotspot\/share\/compiler\/abstractCompiler.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -552,2 +552,1 @@\n-bool DirectiveSet::is_intrinsic_disabled(const methodHandle& method) {\n-  vmIntrinsics::ID id = method->intrinsic_id();\n+bool DirectiveSet::is_intrinsic_disabled(vmIntrinsics::ID id) {\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-  bool is_intrinsic_disabled(const methodHandle& method);\n+  bool is_intrinsic_disabled(vmIntrinsicID id);\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -367,28 +367,0 @@\n-\n-HeapRegion* OldGCAllocRegion::release() {\n-  HeapRegion* cur = get();\n-  if (cur != NULL) {\n-    \/\/ Determine how far we are from the next card boundary. If it is smaller than\n-    \/\/ the minimum object size we can allocate into, expand into the next card.\n-    HeapWord* top = cur->top();\n-    HeapWord* aligned_top = align_up(top, BOTConstants::card_size());\n-\n-    size_t to_allocate_words = pointer_delta(aligned_top, top, HeapWordSize);\n-\n-    if (to_allocate_words != 0) {\n-      \/\/ We are not at a card boundary. Fill up, possibly into the next, taking the\n-      \/\/ end of the region and the minimum object size into account.\n-      to_allocate_words = MIN2(pointer_delta(cur->end(), cur->top(), HeapWordSize),\n-                               MAX2(to_allocate_words, G1CollectedHeap::min_fill_size()));\n-\n-      \/\/ Skip allocation if there is not enough space to allocate even the smallest\n-      \/\/ possible object. In this case this region will not be retained, so the\n-      \/\/ original problem cannot occur.\n-      if (to_allocate_words >= G1CollectedHeap::min_fill_size()) {\n-        HeapWord* dummy = attempt_allocation(to_allocate_words);\n-        cur->fill_with_dummy_object(dummy, to_allocate_words);\n-      }\n-    }\n-  }\n-  return G1AllocRegion::release();\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.cpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -278,7 +278,0 @@\n-\n-  \/\/ This specialization of release() makes sure that the last card that has\n-  \/\/ been allocated into has been completely filled by a dummy object.  This\n-  \/\/ avoids races when remembered set scanning wants to update the BOT of the\n-  \/\/ last card in the retained old gc alloc region, and allocation threads\n-  \/\/ allocating into that card at the same time.\n-  virtual HeapRegion* release();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1AllocRegion.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,1 +233,1 @@\n-    return static_cast<uint>(bm.get_next_one_offset(idx));\n+    return static_cast<uint>(bm.find_first_set_bit(idx));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -196,22 +196,8 @@\n-HeapWord*\n-G1CollectedHeap::humongous_obj_allocate_initialize_regions(HeapRegion* first_hr,\n-                                                           uint num_regions,\n-                                                           size_t word_size) {\n-  assert(first_hr != NULL, \"pre-condition\");\n-  assert(is_humongous(word_size), \"word_size should be humongous\");\n-  assert(num_regions * HeapRegion::GrainWords >= word_size, \"pre-condition\");\n-\n-  \/\/ Index of last region in the series.\n-  uint first = first_hr->hrm_index();\n-  uint last = first + num_regions - 1;\n-\n-  \/\/ We need to initialize the region(s) we just discovered. This is\n-  \/\/ a bit tricky given that it can happen concurrently with\n-  \/\/ refinement threads refining cards on these regions and\n-  \/\/ potentially wanting to refine the BOT as they are scanning\n-  \/\/ those cards (this can happen shortly after a cleanup; see CR\n-  \/\/ 6991377). So we have to set up the region(s) carefully and in\n-  \/\/ a specific order.\n-\n-  \/\/ The word size sum of all the regions we will allocate.\n-  size_t word_size_sum = (size_t) num_regions * HeapRegion::GrainWords;\n+void G1CollectedHeap::set_humongous_metadata(HeapRegion* first_hr,\n+                                             uint num_regions,\n+                                             size_t word_size,\n+                                             bool update_remsets) {\n+  \/\/ Calculate the new top of the humongous object.\n+  HeapWord* obj_top = first_hr->bottom() + word_size;\n+  \/\/ The word size sum of all the regions used\n+  size_t word_size_sum = num_regions * HeapRegion::GrainWords;\n@@ -220,20 +206,2 @@\n-  \/\/ The passed in hr will be the \"starts humongous\" region. The header\n-  \/\/ of the new object will be placed at the bottom of this region.\n-  HeapWord* new_obj = first_hr->bottom();\n-  \/\/ This will be the new top of the new object.\n-  HeapWord* obj_top = new_obj + word_size;\n-\n-  \/\/ First, we need to zero the header of the space that we will be\n-  \/\/ allocating. When we update top further down, some refinement\n-  \/\/ threads might try to scan the region. By zeroing the header we\n-  \/\/ ensure that any thread that will try to scan the region will\n-  \/\/ come across the zero klass word and bail out.\n-  \/\/\n-  \/\/ NOTE: It would not have been correct to have used\n-  \/\/ CollectedHeap::fill_with_object() and make the space look like\n-  \/\/ an int array. The thread that is doing the allocation will\n-  \/\/ later update the object header to a potentially different array\n-  \/\/ type and, for a very short period of time, the klass and length\n-  \/\/ fields will be inconsistent. This could cause a refinement\n-  \/\/ thread to calculate the object size incorrectly.\n-  Copy::fill_to_words(new_obj, oopDesc::header_size(), 0);\n+  \/\/ How many words memory we \"waste\" which cannot hold a filler object.\n+  size_t words_not_fillable = 0;\n@@ -241,1 +209,1 @@\n-  \/\/ Next, pad out the unused tail of the last region with filler\n+  \/\/ Pad out the unused tail of the last region with filler\n@@ -243,2 +211,0 @@\n-  \/\/ How many words we use for filler objects.\n-  size_t word_fill_size = word_size_sum - word_size;\n@@ -246,2 +212,2 @@\n-  \/\/ How many words memory we \"waste\" which cannot hold a filler object.\n-  size_t words_not_fillable = 0;\n+  \/\/ How many words can we use for filler objects.\n+  size_t words_fillable = word_size_sum - word_size;\n@@ -249,3 +215,3 @@\n-  if (word_fill_size >= min_fill_size()) {\n-    fill_with_objects(obj_top, word_fill_size);\n-  } else if (word_fill_size > 0) {\n+  if (words_fillable >= G1CollectedHeap::min_fill_size()) {\n+    G1CollectedHeap::fill_with_objects(obj_top, words_fillable);\n+  } else {\n@@ -253,2 +219,2 @@\n-    words_not_fillable = word_fill_size;\n-    word_fill_size = 0;\n+    words_not_fillable = words_fillable;\n+    words_fillable = 0;\n@@ -261,5 +227,12 @@\n-  first_hr->set_starts_humongous(obj_top, word_fill_size);\n-  _policy->remset_tracker()->update_at_allocate(first_hr);\n-  \/\/ Then, if there are any, we will set up the \"continues\n-  \/\/ humongous\" regions.\n-  HeapRegion* hr = NULL;\n+  first_hr->hr_clear(false \/* clear_space *\/);\n+  first_hr->set_starts_humongous(obj_top, words_fillable);\n+\n+  if (update_remsets) {\n+    _policy->remset_tracker()->update_at_allocate(first_hr);\n+  }\n+\n+  \/\/ Indices of first and last regions in the series.\n+  uint first = first_hr->hrm_index();\n+  uint last = first + num_regions - 1;\n+\n+  HeapRegion* hr = nullptr;\n@@ -268,0 +241,1 @@\n+    hr->hr_clear(false \/* clear_space *\/);\n@@ -269,1 +243,3 @@\n-    _policy->remset_tracker()->update_at_allocate(hr);\n+    if (update_remsets) {\n+      _policy->remset_tracker()->update_at_allocate(hr);\n+    }\n@@ -300,0 +276,9 @@\n+}\n+\n+HeapWord*\n+G1CollectedHeap::humongous_obj_allocate_initialize_regions(HeapRegion* first_hr,\n+                                                           uint num_regions,\n+                                                           size_t word_size) {\n+  assert(first_hr != NULL, \"pre-condition\");\n+  assert(is_humongous(word_size), \"word_size should be humongous\");\n+  assert(num_regions * HeapRegion::GrainWords >= word_size, \"pre-condition\");\n@@ -301,1 +286,38 @@\n-  increase_used((word_size_sum - words_not_fillable) * HeapWordSize);\n+  \/\/ Index of last region in the series.\n+  uint first = first_hr->hrm_index();\n+  uint last = first + num_regions - 1;\n+\n+  \/\/ We need to initialize the region(s) we just discovered. This is\n+  \/\/ a bit tricky given that it can happen concurrently with\n+  \/\/ refinement threads refining cards on these regions and\n+  \/\/ potentially wanting to refine the BOT as they are scanning\n+  \/\/ those cards (this can happen shortly after a cleanup; see CR\n+  \/\/ 6991377). So we have to set up the region(s) carefully and in\n+  \/\/ a specific order.\n+\n+  \/\/ The passed in hr will be the \"starts humongous\" region. The header\n+  \/\/ of the new object will be placed at the bottom of this region.\n+  HeapWord* new_obj = first_hr->bottom();\n+\n+  \/\/ First, we need to zero the header of the space that we will be\n+  \/\/ allocating. When we update top further down, some refinement\n+  \/\/ threads might try to scan the region. By zeroing the header we\n+  \/\/ ensure that any thread that will try to scan the region will\n+  \/\/ come across the zero klass word and bail out.\n+  \/\/\n+  \/\/ NOTE: It would not have been correct to have used\n+  \/\/ CollectedHeap::fill_with_object() and make the space look like\n+  \/\/ an int array. The thread that is doing the allocation will\n+  \/\/ later update the object header to a potentially different array\n+  \/\/ type and, for a very short period of time, the klass and length\n+  \/\/ fields will be inconsistent. This could cause a refinement\n+  \/\/ thread to calculate the object size incorrectly.\n+  Copy::fill_to_words(new_obj, oopDesc::header_size(), 0);\n+\n+  \/\/ Next, update the metadata for the regions.\n+  set_humongous_metadata(first_hr, num_regions, word_size, true);\n+\n+  HeapRegion* last_hr = region_at(last);\n+  size_t used = byte_size(first_hr->bottom(), last_hr->top());\n+\n+  increase_used(used);\n@@ -304,1 +326,1 @@\n-    hr = region_at(i);\n+    HeapRegion *hr = region_at(i);\n@@ -1068,6 +1090,4 @@\n-  \/\/ When clear_all_soft_refs is set we want to do a maximal compaction\n-  \/\/ not leaving any dead wood.\n-  bool do_maximal_compaction = clear_all_soft_refs;\n-  bool dummy = do_full_collection(true,                \/* explicit_gc *\/\n-                                  clear_all_soft_refs,\n-                                  do_maximal_compaction);\n+\n+  do_full_collection(false,                \/* explicit_gc *\/\n+                     clear_all_soft_refs,\n+                     false \/* do_maximal_compaction *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":86,"deletions":66,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -609,0 +609,5 @@\n+  void set_humongous_metadata(HeapRegion* first_hr,\n+                              uint num_regions,\n+                              size_t word_size,\n+                              bool update_remsets);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-  uint start = (uint) _active.get_next_one_offset(offset);\n+  uint start = (uint) _active.find_first_set_bit(offset);\n@@ -108,1 +108,1 @@\n-  uint end = (uint) _active.get_next_zero_offset(start);\n+  uint end = (uint) _active.find_first_clear_bit(start);\n@@ -119,1 +119,1 @@\n-  uint start = (uint) _active.get_next_zero_offset(offset);\n+  uint start = (uint) _active.find_first_clear_bit(offset);\n@@ -125,1 +125,1 @@\n-  uint end = (uint) _active.get_next_one_offset(start);\n+  uint end = (uint) _active.find_first_set_bit(start);\n@@ -133,1 +133,1 @@\n-  uint start = (uint) _inactive.get_next_one_offset(offset);\n+  uint start = (uint) _inactive.find_first_set_bit(offset);\n@@ -140,1 +140,1 @@\n-  uint end = (uint) _inactive.get_next_zero_offset(start);\n+  uint end = (uint) _inactive.find_first_clear_bit(start);\n@@ -235,1 +235,1 @@\n-  BitMap::idx_t first_inactive = _inactive.get_next_one_offset(0);\n+  BitMap::idx_t first_inactive = _inactive.find_first_set_bit(0);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CommittedRegionMap.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -609,1 +609,1 @@\n-        if (_cm->live_words(r->hrm_index()) == 0) {\n+        if (!_cm->contains_live_object(r->hrm_index())) {\n@@ -1112,1 +1112,1 @@\n-        bool const is_live = _cm->live_words(hr->humongous_start_region()->hrm_index()) > 0;\n+        bool const is_live = _cm->contains_live_object(hr->humongous_start_region()->hrm_index());\n@@ -1124,3 +1124,3 @@\n-    \/\/ Distribute the given words across the humongous object starting with hr and\n-    \/\/ note end of marking.\n-    void distribute_marked_bytes(HeapRegion* hr, size_t marked_words) {\n+    \/\/ Distribute the given marked bytes across the humongous object starting\n+    \/\/ with hr and note end of marking for these regions.\n+    void distribute_marked_bytes(HeapRegion* hr, size_t marked_bytes) {\n@@ -1128,0 +1128,1 @@\n+\n@@ -1133,3 +1134,3 @@\n-      assert(marked_words == 0 || obj_size_in_words == marked_words,\n-             \"Marked words should either be 0 or the same as humongous object (\" SIZE_FORMAT \") but is \" SIZE_FORMAT,\n-             obj_size_in_words, marked_words);\n+      assert(marked_bytes == 0 || obj_size_in_words * HeapWordSize == marked_bytes,\n+             \"Marked bytes should either be 0 or the same as humongous object (%zu) but is %zu\",\n+             obj_size_in_words * HeapWordSize, marked_bytes);\n@@ -1139,1 +1140,1 @@\n-        size_t const words_to_add = MIN2(HeapRegion::GrainWords, marked_words);\n+        size_t const bytes_to_add = MIN2(HeapRegion::GrainBytes, marked_bytes);\n@@ -1141,4 +1142,4 @@\n-        log_trace(gc, marking)(\"Adding \" SIZE_FORMAT \" words to humongous region %u (%s)\",\n-                               words_to_add, i, r->get_type_str());\n-        add_marked_bytes_and_note_end(r, words_to_add * HeapWordSize);\n-        marked_words -= words_to_add;\n+        log_trace(gc, marking)(\"Adding %zu bytes to humongous region %u (%s)\",\n+                               bytes_to_add, i, r->get_type_str());\n+        add_marked_bytes_and_note_end(r, bytes_to_add);\n+        marked_bytes -= bytes_to_add;\n@@ -1146,3 +1147,3 @@\n-      assert(marked_words == 0,\n-             SIZE_FORMAT \" words left after distributing space across %u regions\",\n-             marked_words, num_regions_in_humongous);\n+      assert(marked_bytes == 0,\n+             \"%zu bytes left after distributing space across %u regions\",\n+             marked_bytes, num_regions_in_humongous);\n@@ -1153,1 +1154,1 @@\n-      size_t const marked_words = _cm->live_words(region_idx);\n+      size_t const marked_bytes = _cm->live_bytes(region_idx);\n@@ -1158,3 +1159,3 @@\n-        assert(hr->is_starts_humongous() || marked_words == 0,\n-               \"Should not have marked words \" SIZE_FORMAT \" in non-starts humongous region %u (%s)\",\n-               marked_words, region_idx, hr->get_type_str());\n+        assert(hr->is_starts_humongous() || marked_bytes == 0,\n+               \"Should not have live bytes %zu in continues humongous region %u (%s)\",\n+               marked_bytes, region_idx, hr->get_type_str());\n@@ -1162,1 +1163,1 @@\n-          distribute_marked_bytes(hr, marked_words);\n+          distribute_marked_bytes(hr, marked_bytes);\n@@ -1165,2 +1166,2 @@\n-        log_trace(gc, marking)(\"Adding \" SIZE_FORMAT \" words to region %u (%s)\", marked_words, region_idx, hr->get_type_str());\n-        add_marked_bytes_and_note_end(hr, _cm->live_bytes(region_idx));\n+        log_trace(gc, marking)(\"Adding %zu bytes to region %u (%s)\", marked_bytes, region_idx, hr->get_type_str());\n+        add_marked_bytes_and_note_end(hr, marked_bytes);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -471,5 +471,5 @@\n-  \/\/ Live words in the given region as determined by concurrent marking, i.e. the amount of\n-  \/\/ live words between bottom and TAMS.\n-  size_t live_words(uint region) const { return _region_mark_stats[region]._live_words; }\n-  \/\/ Returns the liveness value in bytes.\n-  size_t live_bytes(uint region) const { return live_words(region) * HeapWordSize; }\n+  \/\/ Did the last marking find a live object between bottom and TAMS?\n+  bool contains_live_object(uint region) const { return _region_mark_stats[region]._live_words != 0; }\n+  \/\/ Live bytes in the given region as determined by concurrent marking, i.e. the amount of\n+  \/\/ live bytes between bottom and TAMS.\n+  size_t live_bytes(uint region) const { return _region_mark_stats[region]._live_words * HeapWordSize; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  BitMap::idx_t offset = _bm.get_next_one_offset(addr_to_offset(mr.start()), end_offset);\n+  BitMap::idx_t offset = _bm.find_first_set_bit(addr_to_offset(mr.start()), end_offset);\n@@ -50,1 +50,1 @@\n-    offset = _bm.get_next_one_offset(offset + (obj_size >> _shifter), end_offset);\n+    offset = _bm.find_first_set_bit(offset + (obj_size >> _shifter), end_offset);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkBitMap.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-#include \"gc\/shared\/preservedMarks.hpp\"\n+#include \"gc\/shared\/preservedMarks.inline.hpp\"\n@@ -122,0 +122,1 @@\n+    _has_humongous(false),\n@@ -126,0 +127,1 @@\n+    _humongous_compaction_point(this),\n@@ -128,0 +130,1 @@\n+    _humongous_compaction_regions(8),\n@@ -158,0 +161,1 @@\n+\n@@ -249,0 +253,2 @@\n+\n+  _heap->print_heap_after_full_collection();\n@@ -346,0 +352,6 @@\n+\n+    if (scope()->do_maximal_compaction() &&\n+        has_humongous() &&\n+        serial_compaction_point()->has_regions()) {\n+      phase2d_prepare_humongous_compaction();\n+    }\n@@ -366,1 +378,1 @@\n-  uint lowest_current = (uint)-1;\n+  uint lowest_current = UINT_MAX;\n@@ -421,0 +433,29 @@\n+void G1FullCollector::phase2d_prepare_humongous_compaction() {\n+  GCTraceTime(Debug, gc, phases) debug(\"Phase 2: Prepare humongous compaction\", scope()->timer());\n+  G1FullGCCompactionPoint* serial_cp = serial_compaction_point();\n+  assert(serial_cp->has_regions(), \"Sanity!\" );\n+\n+  uint last_serial_target = serial_cp->current_region()->hrm_index();\n+  uint region_index = last_serial_target + 1;\n+  uint max_reserved_regions = _heap->max_reserved_regions();\n+\n+  G1FullGCCompactionPoint* humongous_cp = humongous_compaction_point();\n+\n+  while (region_index < max_reserved_regions) {\n+    HeapRegion* hr = _heap->region_at_or_null(region_index);\n+\n+    if (hr == nullptr) {\n+      region_index++;\n+      continue;\n+    } else if (hr->is_starts_humongous()) {\n+      uint num_regions = humongous_cp->forward_humongous(hr);\n+      region_index += num_regions; \/\/ Skip over the continues humongous regions.\n+      continue;\n+    } else if (is_compaction_target(region_index)) {\n+      \/\/ Add the region to the humongous compaction point.\n+      humongous_cp->add(hr);\n+    }\n+    region_index++;\n+  }\n+}\n+\n@@ -439,0 +480,5 @@\n+\n+  if (!_humongous_compaction_regions.is_empty()) {\n+    assert(scope()->do_maximal_compaction(), \"Only compact humongous during maximal compaction\");\n+    task.humongous_compaction();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+  bool                      _has_humongous;\n@@ -85,0 +86,1 @@\n+  G1FullGCCompactionPoint   _humongous_compaction_point;\n@@ -88,0 +90,1 @@\n+  GrowableArrayCHeap<HeapRegion*, mtGC> _humongous_compaction_regions;\n@@ -118,0 +121,1 @@\n+  G1FullGCCompactionPoint* humongous_compaction_point() { return &_humongous_compaction_point; }\n@@ -137,0 +141,1 @@\n+  inline void update_from_skip_compacting_to_compacting(uint region_idx);\n@@ -144,0 +149,3 @@\n+  inline void add_humongous_region(HeapRegion* hr);\n+  inline GrowableArrayCHeap<HeapRegion*, mtGC>& humongous_compaction_regions();\n+\n@@ -146,0 +154,3 @@\n+  inline void set_has_humongous();\n+  inline bool has_humongous();\n+\n@@ -153,0 +164,1 @@\n+  void phase2d_prepare_humongous_compaction();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -64,0 +64,5 @@\n+void G1FullCollector::update_from_skip_compacting_to_compacting(uint region_idx) {\n+  DEBUG_ONLY(_region_attr_table.verify_is_skip_compacting(region_idx);)\n+  _region_attr_table.set_compacting(region_idx);\n+}\n+\n@@ -82,0 +87,18 @@\n+void G1FullCollector::set_has_humongous() {\n+  if (!_has_humongous) {\n+    _has_humongous = true;\n+  }\n+}\n+\n+bool G1FullCollector::has_humongous() {\n+  return _has_humongous;\n+}\n+\n+void G1FullCollector::add_humongous_region(HeapRegion* hr) {\n+  _humongous_compaction_regions.append(hr);\n+}\n+\n+GrowableArrayCHeap<HeapRegion*, mtGC>& G1FullCollector::humongous_compaction_regions() {\n+  return _humongous_compaction_regions;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.inline.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -45,10 +45,1 @@\n-    HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n-\n-    \/\/ copy object and reinit its mark\n-    HeapWord* obj_addr = cast_from_oop<HeapWord*>(obj);\n-    assert(obj_addr != destination, \"everything in this pass should be moving\");\n-    Copy::aligned_conjoint_words(obj_addr, destination, size);\n-\n-    \/\/ There is no need to transform stack chunks - marking already did that.\n-    cast_to_oop(destination)->init_mark();\n-    assert(cast_to_oop(destination)->klass() != NULL, \"should have a class\");\n+    G1FullGCCompactTask::copy_object_to_new_location(obj);\n@@ -63,0 +54,15 @@\n+void G1FullGCCompactTask::copy_object_to_new_location(oop obj) {\n+  assert(obj->is_forwarded(), \"Sanity!\");\n+  assert(obj->forwardee() != obj, \"Object must have a new location\");\n+\n+  size_t size = obj->size();\n+  \/\/ Copy object and reinit its mark.\n+  HeapWord* obj_addr = cast_from_oop<HeapWord*>(obj);\n+  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n+  Copy::aligned_conjoint_words(obj_addr, destination, size);\n+\n+  \/\/ There is no need to transform stack chunks - marking already did that.\n+  cast_to_oop(destination)->init_mark();\n+  assert(cast_to_oop(destination)->klass() != nullptr, \"should have a class\");\n+}\n+\n@@ -101,0 +107,46 @@\n+\n+void G1FullGCCompactTask::humongous_compaction() {\n+  GCTraceTime(Debug, gc, phases) tm(\"Phase 4: Humonguous Compaction\", collector()->scope()->timer());\n+\n+  for (HeapRegion* hr : collector()->humongous_compaction_regions()) {\n+    assert(collector()->is_compaction_target(hr->hrm_index()), \"Sanity\");\n+    compact_humongous_obj(hr);\n+  }\n+}\n+\n+void G1FullGCCompactTask::compact_humongous_obj(HeapRegion* src_hr) {\n+  assert(src_hr->is_starts_humongous(), \"Should be start region of the humongous object\");\n+\n+  oop obj = cast_to_oop(src_hr->bottom());\n+  size_t word_size = obj->size();\n+\n+  uint num_regions = (uint)G1CollectedHeap::humongous_obj_size_in_regions(word_size);\n+  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n+\n+  assert(collector()->mark_bitmap()->is_marked(obj), \"Should only compact marked objects\");\n+  collector()->mark_bitmap()->clear(obj);\n+\n+  copy_object_to_new_location(obj);\n+\n+  uint dest_start_idx = _g1h->addr_to_region(destination);\n+  \/\/ Update the metadata for the destination regions.\n+  _g1h->set_humongous_metadata(_g1h->region_at(dest_start_idx), num_regions, word_size, false);\n+\n+  \/\/ Free the source regions that do not overlap with the destination regions.\n+  uint src_start_idx = src_hr->hrm_index();\n+  free_non_overlapping_regions(src_start_idx, dest_start_idx, num_regions);\n+}\n+\n+void G1FullGCCompactTask::free_non_overlapping_regions(uint src_start_idx, uint dest_start_idx, uint num_regions) {\n+  uint dest_end_idx = dest_start_idx + num_regions -1;\n+  uint src_end_idx  = src_start_idx + num_regions - 1;\n+\n+  uint non_overlapping_start = dest_end_idx < src_start_idx ?\n+                               src_start_idx :\n+                               dest_end_idx + 1;\n+\n+  for (uint i = non_overlapping_start; i <= src_end_idx; ++i) {\n+    HeapRegion* hr = _g1h->region_at(i);\n+    _g1h->free_humongous_region(hr, nullptr);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":62,"deletions":10,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+  G1CollectedHeap* _g1h;\n@@ -43,0 +44,4 @@\n+  void compact_humongous_obj(HeapRegion* hr);\n+  void free_non_overlapping_regions(uint src_start_idx, uint dest_start_idx, uint num_regions);\n+\n+  static void copy_object_to_new_location(oop obj);\n@@ -48,1 +53,3 @@\n-    _claimer(collector->workers()) { }\n+    _claimer(collector->workers()),\n+    _g1h(G1CollectedHeap::heap()) { }\n+\n@@ -51,0 +58,1 @@\n+  void humongous_compaction();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/preservedMarks.inline.hpp\"\n@@ -133,0 +134,81 @@\n+\n+void G1FullGCCompactionPoint::add_humongous(HeapRegion* hr) {\n+  assert(hr->is_starts_humongous(), \"Sanity!\");\n+\n+  _collector->add_humongous_region(hr);\n+\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+  do {\n+    add(hr);\n+    _collector->update_from_skip_compacting_to_compacting(hr->hrm_index());\n+    hr = g1h->next_region_in_humongous(hr);\n+  } while (hr != nullptr);\n+}\n+\n+uint G1FullGCCompactionPoint::forward_humongous(HeapRegion* hr) {\n+  assert(hr->is_starts_humongous(), \"Sanity!\");\n+\n+  oop obj = cast_to_oop(hr->bottom());\n+  size_t obj_size = obj->size();\n+  uint num_regions = (uint)G1CollectedHeap::humongous_obj_size_in_regions(obj_size);\n+\n+  if (!has_regions()) {\n+    return num_regions;\n+  }\n+\n+  \/\/ Find contiguous compaction target regions for the humongous object.\n+  uint range_begin = find_contiguous_before(hr, num_regions);\n+\n+  if (range_begin == UINT_MAX) {\n+    \/\/ No contiguous compaction target regions found, so the object cannot be moved.\n+    return num_regions;\n+  }\n+\n+  \/\/ Preserve the mark for the humongous object as the region was initially not compacting.\n+  _collector->marker(0)->preserved_stack()->push_if_necessary(obj, obj->mark());\n+\n+  HeapRegion* dest_hr = _compaction_regions->at(range_begin);\n+  obj->forward_to(cast_to_oop(dest_hr->bottom()));\n+  assert(obj->is_forwarded(), \"Object must be forwarded!\");\n+\n+  \/\/ Add the humongous object regions to the compaction point.\n+  add_humongous(hr);\n+\n+  \/\/ Remove covered regions from compaction target candidates.\n+  _compaction_regions->remove_range(range_begin, (range_begin + num_regions));\n+\n+  return num_regions;\n+}\n+\n+uint G1FullGCCompactionPoint::find_contiguous_before(HeapRegion* hr, uint num_regions) {\n+  assert(num_regions > 0, \"Sanity!\");\n+  assert(has_regions(), \"Sanity!\");\n+\n+  if (num_regions == 1) {\n+    \/\/ If only one region, return the first region.\n+    return 0;\n+  }\n+\n+  uint contiguous_region_count = 1;\n+\n+  uint range_end = 1;\n+  uint range_limit = (uint)_compaction_regions->length();\n+\n+  for (; range_end < range_limit; range_end++) {\n+    if (contiguous_region_count == num_regions) {\n+      break;\n+    }\n+    \/\/ Check if the current region and the previous region are contiguous.\n+    bool regions_are_contiguous = (_compaction_regions->at(range_end)->hrm_index() - _compaction_regions->at(range_end - 1)->hrm_index()) == 1;\n+    contiguous_region_count = regions_are_contiguous ? contiguous_region_count + 1 : 1;\n+  }\n+\n+  if (contiguous_region_count < num_regions &&\n+      hr->hrm_index() - _compaction_regions->at(range_end-1)->hrm_index() != 1) {\n+    \/\/ We reached the end but the final region is not contiguous with the target region;\n+    \/\/ no contiguous regions to move to.\n+    return UINT_MAX;\n+  }\n+  \/\/ Return the index of the first region in the range of contiguous regions.\n+  return range_end - contiguous_region_count;\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/pair.hpp\"\n@@ -46,0 +47,1 @@\n+  uint find_contiguous_before(HeapRegion* hr, uint num_regions);\n@@ -56,0 +58,1 @@\n+  uint forward_humongous(HeapRegion* hr);\n@@ -57,0 +60,1 @@\n+  void add_humongous(HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,0 +87,2 @@\n+  void verify_is_skip_compacting(uint idx) { assert(get_by_index(idx) == SkipCompacting, \"invariant\"); }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCHeapRegionAttr.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,0 +92,2 @@\n+      } else {\n+        _collector->set_has_humongous();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-  return _committed.get_next_zero_offset(start_page, end_page) >= end_page;\n+  return _committed.find_first_clear_bit(start_page, end_page) >= end_page;\n@@ -114,1 +114,1 @@\n-  return _committed.get_next_one_offset(start_page, end_page) >= end_page;\n+  return _committed.find_first_set_bit(start_page, end_page) >= end_page;\n@@ -191,1 +191,1 @@\n-    if (_dirty.get_next_one_offset(start_page, end_page) < end_page) {\n+    if (_dirty.find_first_set_bit(start_page, end_page) < end_page) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-    return _region_commit_map.get_next_zero_offset(start_idx, end) == end;\n+    return _region_commit_map.find_first_clear_bit(start_idx, end) == end;\n@@ -89,1 +89,1 @@\n-    return _region_commit_map.get_next_one_offset(start_idx, end) == end;\n+    return _region_commit_map.find_first_set_bit(start_idx, end) == end;\n@@ -149,1 +149,1 @@\n-    return _region_commit_map.get_next_one_offset(region, region_limit) != region_limit;\n+    return _region_commit_map.find_first_set_bit(region, region_limit) != region_limit;\n@@ -178,1 +178,1 @@\n-    assert(_region_commit_map.get_next_one_offset(start_idx, region_limit) == region_limit,\n+    assert(_region_commit_map.find_first_set_bit(start_idx, region_limit) == region_limit,\n@@ -181,1 +181,1 @@\n-    size_t const NoPage = ~(size_t)0;\n+    size_t const NoPage = SIZE_MAX;\n@@ -231,1 +231,1 @@\n-    assert(_region_commit_map.get_next_zero_offset(start_idx, region_limit) == region_limit,\n+    assert(_region_commit_map.find_first_clear_bit(start_idx, region_limit) == region_limit,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -217,1 +217,2 @@\n-          \"The maximum number of verification failures to print.\")          \\\n+          \"The maximum number of liveness and remembered set verification \" \\\n+          \"failures to print per thread.\")                                  \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -119,3 +119,1 @@\n-  assert(_humongous_start_region == NULL,\n-         \"we should have already filtered out humongous regions\");\n-\n+  set_top(bottom());\n@@ -622,0 +620,4 @@\n+    if (num_failures() >= G1MaxVerifyFailures) {\n+      return;\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -184,2 +184,0 @@\n-  assert(!is_pinned(), \"must be\");\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  const idx_t end_bit = _end_bits.get_next_one_offset(beg_bit, size());\n+  const idx_t end_bit = _end_bits.find_first_set_bit(beg_bit, size());\n@@ -168,1 +168,1 @@\n-  return _beg_bits.get_next_one_offset_aligned_right(beg, end);\n+  return _beg_bits.find_first_set_bit_aligned_right(beg, end);\n@@ -172,1 +172,1 @@\n-  return _end_bits.get_next_one_offset_aligned_right(beg, end);\n+  return _end_bits.find_first_set_bit_aligned_right(beg, end);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -106,0 +106,5 @@\n+  MemRegion committed() const {\n+    return MemRegion((HeapWord*)(_virtual_space->low()),\n+                     (HeapWord*)(_virtual_space->high()));\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1020,1 +1020,1 @@\n-  MemRegion old_mr = heap->old_gen()->reserved();\n+  MemRegion old_mr = heap->old_gen()->committed();\n@@ -1022,1 +1022,1 @@\n-    ct->clear(old_mr);\n+    ct->clear_MemRegion(old_mr);\n@@ -1024,1 +1024,1 @@\n-    ct->invalidate(old_mr);\n+    ct->dirty_MemRegion(old_mr);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  clear(old_gen->prev_used_region());\n+  clear_MemRegion(old_gen->prev_used_region());\n@@ -158,1 +158,1 @@\n-    clear(to_be_cleared_mr);\n+    clear_MemRegion(to_be_cleared_mr);\n@@ -160,1 +160,1 @@\n-  invalidate(used_mr);\n+  dirty_MemRegion(used_mr);\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-size_t CollectedHeap::_lab_alignment_reserve = ~(size_t)0;\n+size_t CollectedHeap::_lab_alignment_reserve = SIZE_MAX;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -317,1 +317,1 @@\n-    assert(_lab_alignment_reserve != ~(size_t)0, \"uninitialized\");\n+    assert(_lab_alignment_reserve != SIZE_MAX, \"uninitialized\");\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  static const uint UNDEFINED = (uint)-1;\n+  static const uint UNDEFINED = UINT_MAX;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcId.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  size_t const nextOffset = _bm.get_next_one_offset(addr_offset, limit_offset);\n+  size_t const nextOffset = _bm.find_first_set_bit(addr_offset, limit_offset);\n","filename":"src\/hotspot\/share\/gc\/shared\/markBitMap.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-  return (size_t)-1;\n+  return SIZE_MAX;\n","filename":"src\/hotspot\/share\/gc\/shared\/workerDataArray.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -693,2 +693,2 @@\n-  size_t beg_off = _mutator_free_bitmap.get_next_one_offset(0);\n-  size_t end_off = _mutator_free_bitmap.get_next_one_offset(_mutator_rightmost + 1);\n+  size_t beg_off = _mutator_free_bitmap.find_first_set_bit(0);\n+  size_t end_off = _mutator_free_bitmap.find_first_set_bit(_mutator_rightmost + 1);\n@@ -704,2 +704,2 @@\n-  beg_off = _collector_free_bitmap.get_next_one_offset(0);\n-  end_off = _collector_free_bitmap.get_next_one_offset(_collector_rightmost + 1);\n+  beg_off = _collector_free_bitmap.find_first_set_bit(0);\n+  end_off = _collector_free_bitmap.find_first_set_bit(_collector_rightmost + 1);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-  return segment_live_bits().get_next_one_offset(0, nsegments);\n+  return segment_live_bits().find_first_set_bit(0, nsegments);\n@@ -88,1 +88,1 @@\n-  return segment_live_bits().get_next_one_offset(segment + 1, nsegments);\n+  return segment_live_bits().find_first_set_bit(segment + 1, nsegments);\n@@ -141,1 +141,1 @@\n-  BitMap::idx_t index = _bitmap.get_next_one_offset(start_index, end_index);\n+  BitMap::idx_t index = _bitmap.find_first_set_bit(start_index, end_index);\n@@ -162,1 +162,1 @@\n-    index = _bitmap.get_next_one_offset(next_index, end_index);\n+    index = _bitmap.find_first_set_bit(next_index, end_index);\n","filename":"src\/hotspot\/share\/gc\/z\/zLiveMap.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -90,2 +90,0 @@\n-address    AbstractInterpreter::_native_entry_begin                         = nullptr;\n-address    AbstractInterpreter::_native_entry_end                           = nullptr;\n@@ -138,1 +136,0 @@\n-#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n@@ -140,1 +137,0 @@\n-#endif\n@@ -153,1 +149,1 @@\n-      case vmIntrinsics::_dsqrt_strict:      return java_lang_math_sqrt;\n+      case vmIntrinsics::_dsqrt_strict:      return java_lang_math_sqrt_strict;\n@@ -200,1 +196,47 @@\n-void AbstractInterpreter::set_entry_for_kind(AbstractInterpreter::MethodKind kind, address entry) {\n+vmIntrinsics::ID AbstractInterpreter::method_intrinsic(MethodKind kind) {\n+  switch (kind) {\n+  case java_lang_math_sin         : return vmIntrinsics::_dsin;\n+  case java_lang_math_cos         : return vmIntrinsics::_dcos;\n+  case java_lang_math_tan         : return vmIntrinsics::_dtan;\n+  case java_lang_math_abs         : return vmIntrinsics::_dabs;\n+  case java_lang_math_log         : return vmIntrinsics::_dlog;\n+  case java_lang_math_log10       : return vmIntrinsics::_dlog10;\n+  case java_lang_math_sqrt        : return vmIntrinsics::_dsqrt;\n+  case java_lang_math_sqrt_strict : return vmIntrinsics::_dsqrt_strict;\n+  case java_lang_math_pow         : return vmIntrinsics::_dpow;\n+  case java_lang_math_exp         : return vmIntrinsics::_dexp;\n+  case java_lang_math_fmaD        : return vmIntrinsics::_fmaD;\n+  case java_lang_math_fmaF        : return vmIntrinsics::_fmaF;\n+  case java_lang_ref_reference_get: return vmIntrinsics::_Reference_get;\n+  case java_util_zip_CRC32_update : return vmIntrinsics::_updateCRC32;\n+  case java_util_zip_CRC32_updateBytes\n+                                  : return vmIntrinsics::_updateBytesCRC32;\n+  case java_util_zip_CRC32_updateByteBuffer\n+                                  : return vmIntrinsics::_updateByteBufferCRC32;\n+  case java_util_zip_CRC32C_updateBytes\n+                                  : return vmIntrinsics::_updateBytesCRC32C;\n+  case java_util_zip_CRC32C_updateDirectByteBuffer\n+                                  : return vmIntrinsics::_updateDirectByteBufferCRC32C;\n+  case java_lang_Thread_currentThread\n+                                  : return vmIntrinsics::_currentThread;\n+  case java_lang_Float_intBitsToFloat\n+                                  : return vmIntrinsics::_intBitsToFloat;\n+  case java_lang_Float_floatToRawIntBits\n+                                  : return vmIntrinsics::_floatToRawIntBits;\n+  case java_lang_Double_longBitsToDouble\n+                                  : return vmIntrinsics::_longBitsToDouble;\n+  case java_lang_Double_doubleToRawLongBits\n+                                  : return vmIntrinsics::_doubleToRawLongBits;\n+  case java_lang_Float_float16ToFloat\n+                                  : return vmIntrinsics::_float16ToFloat;\n+  case java_lang_Float_floatToFloat16\n+                                  : return vmIntrinsics::_floatToFloat16;\n+\n+  default:\n+    fatal(\"unexpected method intrinsic kind: %d\", kind);\n+    break;\n+  }\n+  return vmIntrinsics::_none;\n+}\n+\n+void AbstractInterpreter::set_entry_for_kind(MethodKind kind, address entry) {\n@@ -271,1 +313,0 @@\n-    case java_lang_math_sqrt    : tty->print(\"java_lang_math_sqrt\"    ); break;\n@@ -274,0 +315,2 @@\n+    case java_lang_math_pow     : tty->print(\"java_lang_math_pow\"     ); break;\n+    case java_lang_math_exp     : tty->print(\"java_lang_math_exp\"     ); break;\n@@ -276,0 +319,2 @@\n+    case java_lang_math_sqrt    : tty->print(\"java_lang_math_sqrt\"    ); break;\n+    case java_lang_math_sqrt_strict           : tty->print(\"java_lang_math_sqrt_strict\"); break;\n@@ -281,0 +326,8 @@\n+    case java_lang_ref_reference_get          : tty->print(\"java_lang_ref_reference_get\"); break;\n+    case java_lang_Thread_currentThread       : tty->print(\"java_lang_Thread_currentThread\"); break;\n+    case java_lang_Float_intBitsToFloat       : tty->print(\"java_lang_Float_intBitsToFloat\"); break;\n+    case java_lang_Float_floatToRawIntBits    : tty->print(\"java_lang_Float_floatToRawIntBits\"); break;\n+    case java_lang_Double_longBitsToDouble    : tty->print(\"java_lang_Double_longBitsToDouble\"); break;\n+    case java_lang_Double_doubleToRawLongBits : tty->print(\"java_lang_Double_doubleToRawLongBits\"); break;\n+    case java_lang_Float_float16ToFloat       : tty->print(\"java_lang_Float_float16ToFloat\"); break;\n+    case java_lang_Float_floatToFloat16       : tty->print(\"java_lang_Float_floatToFloat16\"); break;\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":60,"deletions":7,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+    java_lang_math_sqrt_strict,                                 \/\/ implementation of java.lang.StrictMath.sqrt(x)\n@@ -108,0 +109,3 @@\n+  \/\/ Conversion from the above enum to vmIntrinsics::ID\n+  static vmIntrinsics::ID method_intrinsic(MethodKind kind);\n+\n@@ -117,3 +121,0 @@\n-  static address    _native_entry_begin;                        \/\/ Region for native entry code\n-  static address    _native_entry_end;\n-\n@@ -226,1 +227,0 @@\n-  static bool       in_native_entry(address pc)                 { return _native_entry_begin <= pc && pc < _native_entry_end; }\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -180,3 +180,3 @@\n-#define method_entry(kind)                                                                   \\\n-  { CodeletMark cm(_masm, \"method entry point (kind = \" #kind \")\");                          \\\n-    Interpreter::_entry_table[Interpreter::kind] = generate_method_entry(Interpreter::kind); \\\n+#define method_entry(kind)                                                                          \\\n+  { CodeletMark cm(_masm, \"method entry point (kind = \" #kind \")\");                                 \\\n+    Interpreter::_entry_table[Interpreter::kind] = generate_method_entry(Interpreter::kind, false); \\\n@@ -197,0 +197,1 @@\n+  method_entry(java_lang_math_sqrt_strict)\n@@ -204,3 +205,0 @@\n-#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n-  method_entry(java_lang_Thread_currentThread)\n-#endif\n@@ -209,9 +207,0 @@\n-  \/\/ all native method kinds (must be one contiguous block)\n-  Interpreter::_native_entry_begin = Interpreter::code()->code_end();\n-  method_entry(native)\n-  method_entry(native_synchronized)\n-  Interpreter::_native_entry_end = Interpreter::code()->code_end();\n-\n-  method_entry(java_util_zip_CRC32_update)\n-  method_entry(java_util_zip_CRC32_updateBytes)\n-  method_entry(java_util_zip_CRC32_updateByteBuffer)\n@@ -221,5 +210,0 @@\n-  method_entry(java_lang_Float_intBitsToFloat);\n-  method_entry(java_lang_Float_floatToRawIntBits);\n-  method_entry(java_lang_Double_longBitsToDouble);\n-  method_entry(java_lang_Double_doubleToRawLongBits);\n-\n@@ -231,0 +215,25 @@\n+  \/\/ all native method kinds\n+#define native_method_entry(kind)                                                                  \\\n+  { CodeletMark cm(_masm, \"native method entry point (kind = \" #kind \")\");                         \\\n+    Interpreter::_entry_table[Interpreter::kind] = generate_method_entry(Interpreter::kind, true); \\\n+  }\n+\n+  native_method_entry(native)\n+  native_method_entry(native_synchronized)\n+\n+  \/\/ Entries to intrinsics for native methods should follow\n+  \/\/ entries for `native` methods to use the same address in case\n+  \/\/ intrinsic is disabled.\n+  native_method_entry(java_lang_Thread_currentThread)\n+\n+  native_method_entry(java_util_zip_CRC32_update)\n+  native_method_entry(java_util_zip_CRC32_updateBytes)\n+  native_method_entry(java_util_zip_CRC32_updateByteBuffer)\n+\n+  native_method_entry(java_lang_Float_intBitsToFloat)\n+  native_method_entry(java_lang_Float_floatToRawIntBits)\n+  native_method_entry(java_lang_Double_longBitsToDouble)\n+  native_method_entry(java_lang_Double_doubleToRawLongBits)\n+\n+#undef native_method_entry\n+\n@@ -400,1 +409,1 @@\n-                                        AbstractInterpreter::MethodKind kind) {\n+                                        AbstractInterpreter::MethodKind kind, bool native) {\n@@ -402,1 +411,0 @@\n-  bool native = false;\n@@ -407,4 +415,4 @@\n-  case Interpreter::zerolocals             :                                          break;\n-  case Interpreter::zerolocals_synchronized:                synchronized = true;      break;\n-  case Interpreter::native                 : native = true;                           break;\n-  case Interpreter::native_synchronized    : native = true; synchronized = true;      break;\n+  case Interpreter::zerolocals             :                           break;\n+  case Interpreter::zerolocals_synchronized: synchronized = true;      break;\n+  case Interpreter::native                 :                           break;\n+  case Interpreter::native_synchronized    : synchronized = true;      break;\n@@ -415,0 +423,21 @@\n+  default:\n+    entry_point = generate_intrinsic_entry(kind); \/\/ process the rest\n+    break;\n+  }\n+\n+  if (entry_point) {\n+    return entry_point;\n+  }\n+\n+  \/\/ We expect the normal and native entry points to be generated first so we can reuse them.\n+  if (native) {\n+    entry_point = Interpreter::entry_for_kind(synchronized ? Interpreter::native_synchronized : Interpreter::native);\n+    if (entry_point == nullptr) {\n+      entry_point = generate_native_entry(synchronized);\n+    }\n+  } else {\n+    entry_point = Interpreter::entry_for_kind(synchronized ? Interpreter::zerolocals_synchronized : Interpreter::zerolocals);\n+    if (entry_point == nullptr) {\n+      entry_point = generate_normal_entry(synchronized);\n+    }\n+  }\n@@ -416,0 +445,12 @@\n+  return entry_point;\n+}\n+\n+\/\/ Generate intrinsic method entries\n+address TemplateInterpreterGenerator::generate_intrinsic_entry(AbstractInterpreter::MethodKind kind) {\n+  if (!InlineIntrinsics || !vmIntrinsics::is_intrinsic_available(AbstractInterpreter::method_intrinsic(kind))) {\n+    return nullptr;\n+  }\n+\n+  address entry_point = nullptr;\n+\n+  switch (kind) {\n@@ -427,0 +468,2 @@\n+  case Interpreter::java_lang_math_sqrt_strict\n+                                           : entry_point = generate_math_entry(Interpreter::java_lang_math_sqrt); break;\n@@ -430,1 +473,1 @@\n-                                           : native = true; entry_point = generate_CRC32_update_entry();  break;\n+                                           : entry_point = generate_CRC32_update_entry();  break;\n@@ -434,1 +477,1 @@\n-                                           : native = true; entry_point = generate_CRC32_updateBytes_entry(kind); break;\n+                                           : entry_point = generate_CRC32_updateBytes_entry(kind); break;\n@@ -439,1 +482,0 @@\n-#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n@@ -442,1 +484,0 @@\n-#endif\n@@ -447,1 +488,1 @@\n-#ifdef IA32\n+\n@@ -449,1 +490,1 @@\n-  \/\/ On other platforms the normal entry is used to enter these methods.\n+  \/\/ On other platforms the native entry is used to enter these methods.\n@@ -451,1 +492,1 @@\n-                                           : native = true; entry_point = generate_Float_intBitsToFloat_entry(); break;\n+                                           : entry_point = generate_Float_intBitsToFloat_entry(); break;\n@@ -453,1 +494,1 @@\n-                                           : native = true; entry_point = generate_Float_floatToRawIntBits_entry(); break;\n+                                           : entry_point = generate_Float_floatToRawIntBits_entry(); break;\n@@ -455,1 +496,1 @@\n-                                           : native = true; entry_point = generate_Double_longBitsToDouble_entry(); break;\n+                                           : entry_point = generate_Double_longBitsToDouble_entry(); break;\n@@ -457,9 +498,1 @@\n-                                           : native = true; entry_point = generate_Double_doubleToRawLongBits_entry(); break;\n-#else\n-  case Interpreter::java_lang_Float_intBitsToFloat:\n-  case Interpreter::java_lang_Float_floatToRawIntBits:\n-  case Interpreter::java_lang_Double_longBitsToDouble:\n-  case Interpreter::java_lang_Double_doubleToRawLongBits:\n-    native = true;\n-    break;\n-#endif \/\/ !IA32\n+                                           : entry_point = generate_Double_doubleToRawLongBits_entry(); break;\n@@ -467,1 +500,1 @@\n-    fatal(\"unexpected method kind: %d\", kind);\n+    fatal(\"unexpected intrinsic method kind: %d\", kind);\n@@ -470,18 +503,0 @@\n-\n-  if (entry_point) {\n-    return entry_point;\n-  }\n-\n-  \/\/ We expect the normal and native entry points to be generated first so we can reuse them.\n-  if (native) {\n-    entry_point = Interpreter::entry_for_kind(synchronized ? Interpreter::native_synchronized : Interpreter::native);\n-    if (entry_point == nullptr) {\n-      entry_point = generate_native_entry(synchronized);\n-    }\n-  } else {\n-    entry_point = Interpreter::entry_for_kind(synchronized ? Interpreter::zerolocals_synchronized : Interpreter::zerolocals);\n-    if (entry_point == nullptr) {\n-      entry_point = generate_normal_entry(synchronized);\n-    }\n-  }\n-\n@@ -490,0 +505,1 @@\n+\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":79,"deletions":63,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -87,1 +87,4 @@\n-  address generate_method_entry(AbstractInterpreter::MethodKind kind);\n+  address generate_method_entry(AbstractInterpreter::MethodKind kind, bool native);\n+\n+  \/\/ generate intrinsic method entries\n+  address generate_intrinsic_entry(AbstractInterpreter::MethodKind kind);\n@@ -97,1 +100,0 @@\n-#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n@@ -99,2 +101,0 @@\n-#endif\n-#ifdef IA32\n@@ -105,1 +105,0 @@\n-#endif \/\/ IA32\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+    method_entry(java_lang_math_sqrt_strict);\n@@ -69,1 +70,0 @@\n-    Interpreter::_native_entry_begin = Interpreter::code()->code_end();\n@@ -72,1 +72,0 @@\n-    Interpreter::_native_entry_end = Interpreter::code()->code_end();\n@@ -103,0 +102,1 @@\n+  case Interpreter::java_lang_math_sqrt_strict: \/\/ fall thru\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -450,10 +450,0 @@\n-int JfrConfigureFlightRecorderDCmd::num_arguments() {\n-  ResourceMark rm;\n-  JfrConfigureFlightRecorderDCmd* dcmd = new JfrConfigureFlightRecorderDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  }\n-  return 0;\n-}\n-\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,1 +180,1 @@\n-  static int num_arguments();\n+  static int num_arguments() { return 9; }\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -579,0 +579,19 @@\n+C2V_VMENTRY_NULL(jobject, lookupJClass, (JNIEnv* env, jobject, jlong jclass_value))\n+    if (jclass_value == 0L) {\n+        JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"jclass must not be zero\");\n+    }\n+    jclass mirror = reinterpret_cast<jclass>(jclass_value);\n+    \/\/ Since the jclass_value is passed as a jlong, we perform additional checks to prevent the caller from accidentally\n+    \/\/ sending a value that is not a JNI handle.\n+    if (JNIHandles::handle_type(thread, mirror) == JNIInvalidRefType) {\n+        JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"jclass is not a valid JNI reference\");\n+    }\n+    oop obj = JNIHandles::resolve(mirror);\n+    if (!java_lang_Class::is_instance(obj)) {\n+        JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"jclass must be a reference to the Class object\");\n+    }\n+    JVMCIKlassHandle klass(THREAD, java_lang_Class::as_Klass(obj));\n+    JVMCIObject result = JVMCIENV->get_jvmci_type(klass, JVMCI_CHECK_NULL);\n+    return JVMCIENV->get_jobject(result);\n+C2V_END\n+\n@@ -2829,0 +2848,1 @@\n+  {CC \"lookupJClass\",                                 CC \"(J)\" HS_RESOLVED_TYPE,                                                            FN_PTR(lookupJClass)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1594,1 +1594,5 @@\n-    Deoptimization::deoptimize_all_marked(nm);\n+    DeoptimizationScope deopt_scope;\n+    deopt_scope.mark(nm);\n+    nm->make_not_entrant();\n+    nm->make_deoptimized();\n+    deopt_scope.deoptimize_marked();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,11 +48,0 @@\n-int LogDiagnosticCommand::num_arguments() {\n-  ResourceMark rm;\n-  LogDiagnosticCommand* dcmd = new LogDiagnosticCommand(nullptr, false);\n-  if (dcmd != nullptr) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/logging\/logDiagnosticCommand.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  static int num_arguments();\n+  static int num_arguments() { return 7; }\n","filename":"src\/hotspot\/share\/logging\/logDiagnosticCommand.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-            (chunklevel::is_valid_level(level()) ? chunklevel::word_size_for_level(level()) : (size_t)-1),\n+            (chunklevel::is_valid_level(level()) ? chunklevel::word_size_for_level(level()) : SIZE_MAX),\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metachunk.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,11 +61,0 @@\n-int MetaspaceDCmd::num_arguments() {\n-  ResourceMark rm;\n-  MetaspaceDCmd* dcmd = new MetaspaceDCmd(nullptr, false);\n-  if (dcmd != nullptr) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceDCmd.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  static int num_arguments();\n+  static int num_arguments() { return 8; }\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceDCmd.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -983,3 +984,4 @@\n-  Handle cause = java_lang_Throwable::get_cause_with_stack_trace(exception, THREAD);\n-  if (HAS_PENDING_EXCEPTION || cause.is_null()) {\n-    CLEAR_PENDING_EXCEPTION;\n+  Handle init_error = java_lang_Throwable::create_initialization_error(current, exception);\n+  ResourceMark rm(THREAD);\n+  if (init_error.is_null()) {\n+    log_trace(class, init)(\"Initialization error is null for class %s\", external_name());\n@@ -990,2 +992,2 @@\n-  OopHandle elem = OopHandle(Universe::vm_global(), cause());\n-  bool created = false;\n+  OopHandle elem = OopHandle(Universe::vm_global(), init_error());\n+  bool created;\n@@ -994,1 +996,0 @@\n-  ResourceMark rm(THREAD);\n@@ -1181,2 +1182,0 @@\n-  \/\/ Now flush all code that assume the class is not linked.\n-  \/\/ Set state under the Compile_lock also.\n@@ -1184,1 +1183,5 @@\n-    MutexLocker ml(current, Compile_lock);\n+    DeoptimizationScope deopt_scope;\n+    {\n+      \/\/ Now mark all code that assumes the class is not linked.\n+      \/\/ Set state under the Compile_lock also.\n+      MutexLocker ml(current, Compile_lock);\n@@ -1186,2 +1189,2 @@\n-    set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n-    set_init_state(state);\n+      set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n+      set_init_state(state);\n@@ -1189,1 +1192,4 @@\n-    CodeCache::flush_dependents_on(this);\n+      CodeCache::mark_dependents_on(&deopt_scope, this);\n+    }\n+    \/\/ Perform the deopt handshake outside Compile_lock.\n+    deopt_scope.deoptimize_marked();\n@@ -2328,2 +2334,2 @@\n-int InstanceKlass::mark_dependent_nmethods(KlassDepChange& changes) {\n-  return dependencies().mark_dependent_nmethods(changes);\n+void InstanceKlass::mark_dependent_nmethods(DeoptimizationScope* deopt_scope, KlassDepChange& changes) {\n+  dependencies().mark_dependent_nmethods(deopt_scope, changes);\n@@ -2409,1 +2415,15 @@\n-  it->push(&_methods);\n+#if INCLUDE_CDS\n+  \/\/ For \"old\" classes with methods containing the jsr bytecode, the _methods array will\n+  \/\/ be rewritten during runtime (see Rewriter::rewrite_jsrs()). So setting the _methods to\n+  \/\/ be writable. The length check on the _methods is necessary because classes which\n+  \/\/ don't have any methods share the Universe::_the_empty_method_array which is in the RO region.\n+  if (_methods != nullptr && _methods->length() > 0 &&\n+      !can_be_verified_at_dumptime() && methods_contain_jsr_bytecode()) {\n+    \/\/ To handle jsr bytecode, new Method* maybe stored into _methods\n+    it->push(&_methods, MetaspaceClosure::_writable);\n+  } else {\n+#endif\n+    it->push(&_methods);\n+#if INCLUDE_CDS\n+  }\n+#endif\n@@ -2617,0 +2637,15 @@\n+\n+bool InstanceKlass::methods_contain_jsr_bytecode() const {\n+  Thread* thread = Thread::current();\n+  for (int i = 0; i < _methods->length(); i++) {\n+    methodHandle m(thread, _methods->at(i));\n+    BytecodeStream bcs(m);\n+    while (!bcs.is_last_bytecode()) {\n+      Bytecodes::Code opcode = bcs.next();\n+      if (opcode == Bytecodes::_jsr || opcode == Bytecodes::_jsr_w) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n@@ -3275,1 +3310,1 @@\n-int InstanceKlass::mark_osr_nmethods(const Method* m) {\n+int InstanceKlass::mark_osr_nmethods(DeoptimizationScope* deopt_scope, const Method* m) {\n@@ -3283,1 +3318,1 @@\n-      osr->mark_for_deoptimization();\n+      deopt_scope->mark(osr);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":52,"deletions":17,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+class DeoptimizationScope;\n@@ -864,1 +865,1 @@\n-  int  mark_dependent_nmethods(KlassDepChange& changes);\n+  void mark_dependent_nmethods(DeoptimizationScope* deopt_scope, KlassDepChange& changes);\n@@ -873,1 +874,1 @@\n-  int mark_osr_nmethods(const Method* m);\n+  int mark_osr_nmethods(DeoptimizationScope* deopt_scope, const Method* m);\n@@ -1147,0 +1148,1 @@\n+  bool methods_contain_jsr_bytecode() const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2011,1 +2011,1 @@\n-    CodeCache::flush_dependents_on_method(mh);\n+    CodeCache::mark_dependents_on_method_for_breakpoint(mh);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -908,4 +908,0 @@\n-  int mark_osr_nmethods() {\n-    return method_holder()->mark_osr_nmethods(this);\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-    Node* off = phase->MakeConX(field->offset());\n+    Node* off = phase->MakeConX(field->offset_in_bytes());\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-bool C2Compiler::is_intrinsic_supported(const methodHandle& method, bool is_virtual) {\n+bool C2Compiler::is_intrinsic_supported(const methodHandle& method) {\n@@ -191,14 +191,0 @@\n-  \/\/ Only Object.hashCode and Object.clone intrinsics implement also a virtual\n-  \/\/ dispatch because calling both methods is expensive but both methods are\n-  \/\/ frequently overridden. All other intrinsics implement only a non-virtual\n-  \/\/ dispatch.\n-  if (is_virtual) {\n-    switch (id) {\n-    case vmIntrinsics::_hashCode:\n-    case vmIntrinsics::_clone:\n-      break;\n-    default:\n-      return false;\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -64,7 +64,1 @@\n-  virtual bool is_intrinsic_supported(const methodHandle& method) {\n-    return is_intrinsic_supported(method, false);\n-  }\n-\n-  \/\/ Check if the compiler supports an intrinsic for 'method' given the\n-  \/\/ the dispatch mode specified by the 'is_virtual' parameter.\n-  bool is_intrinsic_supported(const methodHandle& method, bool is_virtual);\n+  virtual bool is_intrinsic_supported(const methodHandle& method);\n","filename":"src\/hotspot\/share\/opto\/c2compiler.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1706,1 +1706,1 @@\n-              field->offset() == original_field->offset() &&\n+              field->offset_in_bytes() == original_field->offset_in_bytes() &&\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3610,1 +3610,1 @@\n-        if (field->offset() >= TrackedInitializationLimit * HeapWordSize)\n+        if (field->offset_in_bytes() >= TrackedInitializationLimit * HeapWordSize)\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,4 +80,4 @@\n-    is_available = compiler != nullptr && compiler->is_intrinsic_supported(mh, is_virtual) &&\n-                   !C->directive()->is_intrinsic_disabled(mh) &&\n-                   !vmIntrinsics::is_disabled_by_flags(mh);\n-\n+    is_available = compiler != nullptr && compiler->is_intrinsic_available(mh, C->directive());\n+    if (is_available && is_virtual) {\n+      is_available = vmIntrinsics::does_virtual_dispatch(id);\n+    }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -738,1 +738,1 @@\n-        offset = field->offset();\n+        offset = field->offset_in_bytes();\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -284,5 +284,37 @@\n-\/\/------------------------------mul_ring---------------------------------------\n-\/\/ Compute the product type of two integer ranges into this node.\n-const Type *MulINode::mul_ring(const Type *t0, const Type *t1) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n+\/\/ Classes to perform mul_ring() for MulI\/MulLNode.\n+\/\/\n+\/\/ This class checks if all cross products of the left and right input of a multiplication have the same \"overflow value\".\n+\/\/ Without overflow\/underflow:\n+\/\/ Product is positive? High signed multiplication result: 0\n+\/\/ Product is negative? High signed multiplication result: -1\n+\/\/\n+\/\/ We normalize these values (see normalize_overflow_value()) such that we get the same \"overflow value\" by adding 1 if\n+\/\/ the product is negative. This allows us to compare all the cross product \"overflow values\". If one is different,\n+\/\/ compared to the others, then we know that this multiplication has a different number of over- or underflows compared\n+\/\/ to the others. In this case, we need to use bottom type and cannot guarantee a better type. Otherwise, we can take\n+\/\/ the min und max of all computed cross products as type of this Mul node.\n+template<typename IntegerType>\n+class IntegerMulRing {\n+  using NativeType = std::conditional_t<std::is_same<TypeInt, IntegerType>::value, jint, jlong>;\n+\n+  NativeType _lo_left;\n+  NativeType _lo_right;\n+  NativeType _hi_left;\n+  NativeType _hi_right;\n+  NativeType _lo_lo_product;\n+  NativeType _lo_hi_product;\n+  NativeType _hi_lo_product;\n+  NativeType _hi_hi_product;\n+  short _widen_left;\n+  short _widen_right;\n+\n+  static const Type* overflow_type();\n+  static NativeType multiply_high_signed_overflow_value(NativeType x, NativeType y);\n+\n+  \/\/ Pre-compute cross products which are used at several places\n+  void compute_cross_products() {\n+    _lo_lo_product = java_multiply(_lo_left, _lo_right);\n+    _lo_hi_product = java_multiply(_lo_left, _hi_right);\n+    _hi_lo_product = java_multiply(_hi_left, _lo_right);\n+    _hi_hi_product = java_multiply(_hi_left, _hi_right);\n+  }\n@@ -290,28 +322,12 @@\n-  \/\/ Fetch endpoints of all ranges\n-  jint lo0 = r0->_lo;\n-  double a = (double)lo0;\n-  jint hi0 = r0->_hi;\n-  double b = (double)hi0;\n-  jint lo1 = r1->_lo;\n-  double c = (double)lo1;\n-  jint hi1 = r1->_hi;\n-  double d = (double)hi1;\n-\n-  \/\/ Compute all endpoints & check for overflow\n-  int32_t A = java_multiply(lo0, lo1);\n-  if( (double)A != a*c ) return TypeInt::INT; \/\/ Overflow?\n-  int32_t B = java_multiply(lo0, hi1);\n-  if( (double)B != a*d ) return TypeInt::INT; \/\/ Overflow?\n-  int32_t C = java_multiply(hi0, lo1);\n-  if( (double)C != b*c ) return TypeInt::INT; \/\/ Overflow?\n-  int32_t D = java_multiply(hi0, hi1);\n-  if( (double)D != b*d ) return TypeInt::INT; \/\/ Overflow?\n-\n-  if( A < B ) { lo0 = A; hi0 = B; } \/\/ Sort range endpoints\n-  else { lo0 = B; hi0 = A; }\n-  if( C < D ) {\n-    if( C < lo0 ) lo0 = C;\n-    if( D > hi0 ) hi0 = D;\n-  } else {\n-    if( D < lo0 ) lo0 = D;\n-    if( C > hi0 ) hi0 = C;\n+  bool cross_products_not_same_overflow() const {\n+    const NativeType lo_lo_high_product = multiply_high_signed_overflow_value(_lo_left, _lo_right);\n+    const NativeType lo_hi_high_product = multiply_high_signed_overflow_value(_lo_left, _hi_right);\n+    const NativeType hi_lo_high_product = multiply_high_signed_overflow_value(_hi_left, _lo_right);\n+    const NativeType hi_hi_high_product = multiply_high_signed_overflow_value(_hi_left, _hi_right);\n+    return lo_lo_high_product != lo_hi_high_product ||\n+           lo_hi_high_product != hi_lo_high_product ||\n+           hi_lo_high_product != hi_hi_high_product;\n+  }\n+\n+  static NativeType normalize_overflow_value(const NativeType x, const NativeType y, NativeType result) {\n+    return java_multiply(x, y) < 0 ? result + 1 : result;\n@@ -319,1 +335,25 @@\n-  return TypeInt::make(lo0, hi0, MAX2(r0->_widen,r1->_widen));\n+\n+ public:\n+  IntegerMulRing(const IntegerType* left, const IntegerType* right) : _lo_left(left->_lo), _lo_right(right->_lo),\n+    _hi_left(left->_hi), _hi_right(right->_hi), _widen_left(left->_widen), _widen_right(right->_widen)  {\n+    compute_cross_products();\n+  }\n+\n+  \/\/ Compute the product type by multiplying the two input type ranges. We take the minimum and maximum of all possible\n+  \/\/ values (requires 4 multiplications of all possible combinations of the two range boundary values). If any of these\n+  \/\/ multiplications overflows\/underflows, we need to make sure that they all have the same number of overflows\/underflows\n+  \/\/ If that is not the case, we return the bottom type to cover all values due to the inconsistent overflows\/underflows).\n+  const Type* compute() const {\n+    if (cross_products_not_same_overflow()) {\n+      return overflow_type();\n+    }\n+    const NativeType min = MIN4(_lo_lo_product, _lo_hi_product, _hi_lo_product, _hi_hi_product);\n+    const NativeType max = MAX4(_lo_lo_product, _lo_hi_product, _hi_lo_product, _hi_hi_product);\n+    return IntegerType::make(min, max, MAX2(_widen_left, _widen_right));\n+  }\n+};\n+\n+\n+template <>\n+const Type* IntegerMulRing<TypeInt>::overflow_type() {\n+  return TypeInt::INT;\n@@ -322,0 +362,31 @@\n+template <>\n+jint IntegerMulRing<TypeInt>::multiply_high_signed_overflow_value(const jint x, const jint y) {\n+  const jlong x_64 = x;\n+  const jlong y_64 = y;\n+  const jlong product = x_64 * y_64;\n+  const jint result = (jint)((uint64_t)product >> 32u);\n+  return normalize_overflow_value(x, y, result);\n+}\n+\n+template <>\n+const Type* IntegerMulRing<TypeLong>::overflow_type() {\n+  return TypeLong::LONG;\n+}\n+\n+template <>\n+jlong IntegerMulRing<TypeLong>::multiply_high_signed_overflow_value(const jlong x, const jlong y) {\n+  const jlong result = multiply_high_signed(x, y);\n+  return normalize_overflow_value(x, y, result);\n+}\n+\n+\/\/ Compute the product type of two integer ranges into this node.\n+const Type* MulINode::mul_ring(const Type* type_left, const Type* type_right) const {\n+  const IntegerMulRing<TypeInt> integer_mul_ring(type_left->is_int(), type_right->is_int());\n+  return integer_mul_ring.compute();\n+}\n+\n+\/\/ Compute the product type of two long ranges into this node.\n+const Type* MulLNode::mul_ring(const Type* type_left, const Type* type_right) const {\n+  const IntegerMulRing<TypeLong> integer_mul_ring(type_left->is_long(), type_right->is_long());\n+  return integer_mul_ring.compute();\n+}\n@@ -380,38 +451,0 @@\n-\/\/------------------------------mul_ring---------------------------------------\n-\/\/ Compute the product type of two integer ranges into this node.\n-const Type *MulLNode::mul_ring(const Type *t0, const Type *t1) const {\n-  const TypeLong *r0 = t0->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t1->is_long();\n-\n-  \/\/ Fetch endpoints of all ranges\n-  jlong lo0 = r0->_lo;\n-  double a = (double)lo0;\n-  jlong hi0 = r0->_hi;\n-  double b = (double)hi0;\n-  jlong lo1 = r1->_lo;\n-  double c = (double)lo1;\n-  jlong hi1 = r1->_hi;\n-  double d = (double)hi1;\n-\n-  \/\/ Compute all endpoints & check for overflow\n-  jlong A = java_multiply(lo0, lo1);\n-  if( (double)A != a*c ) return TypeLong::LONG; \/\/ Overflow?\n-  jlong B = java_multiply(lo0, hi1);\n-  if( (double)B != a*d ) return TypeLong::LONG; \/\/ Overflow?\n-  jlong C = java_multiply(hi0, lo1);\n-  if( (double)C != b*c ) return TypeLong::LONG; \/\/ Overflow?\n-  jlong D = java_multiply(hi0, hi1);\n-  if( (double)D != b*d ) return TypeLong::LONG; \/\/ Overflow?\n-\n-  if( A < B ) { lo0 = A; hi0 = B; } \/\/ Sort range endpoints\n-  else { lo0 = B; hi0 = A; }\n-  if( C < D ) {\n-    if( C < lo0 ) lo0 = C;\n-    if( D > hi0 ) hi0 = D;\n-  } else {\n-    if( D < lo0 ) lo0 = D;\n-    if( C > hi0 ) hi0 = C;\n-  }\n-  return TypeLong::make(lo0, hi0, MAX2(r0->_widen,r1->_widen));\n-}\n-\n@@ -850,5 +883,39 @@\n-  \/\/ Check for \"(x>>c0)<<c0\" which just masks off low bits\n-  if( (add1_op == Op_RShiftI || add1_op == Op_URShiftI ) &&\n-      add1->in(2) == in(2) )\n-    \/\/ Convert to \"(x & -(1<<c0))\"\n-    return new AndINode(add1->in(1),phase->intcon( -(1<<con)));\n+  \/\/ Check for \"(x >> C1) << C2\"\n+  if (add1_op == Op_RShiftI || add1_op == Op_URShiftI) {\n+    \/\/ Special case C1 == C2, which just masks off low bits\n+    if (add1->in(2) == in(2)) {\n+      \/\/ Convert to \"(x & -(1 << C2))\"\n+      return new AndINode(add1->in(1), phase->intcon(-(1 << con)));\n+    } else {\n+      int add1Con = 0;\n+      const_shift_count(phase, add1, &add1Con);\n+\n+      \/\/ Wait until the right shift has been sharpened to the correct count\n+      if (add1Con > 0 && add1Con < BitsPerJavaInteger) {\n+        \/\/ As loop parsing can produce LShiftI nodes, we should wait until the graph is fully formed\n+        \/\/ to apply optimizations, otherwise we can inadvertently stop vectorization opportunities.\n+        if (phase->is_IterGVN()) {\n+          if (con > add1Con) {\n+            \/\/ Creates \"(x << (C2 - C1)) & -(1 << C2)\"\n+            Node* lshift = phase->transform(new LShiftINode(add1->in(1), phase->intcon(con - add1Con)));\n+            return new AndINode(lshift, phase->intcon(-(1 << con)));\n+          } else {\n+            assert(con < add1Con, \"must be (%d < %d)\", con, add1Con);\n+            \/\/ Creates \"(x >> (C1 - C2)) & -(1 << C2)\"\n+\n+            \/\/ Handle logical and arithmetic shifts\n+            Node* rshift;\n+            if (add1_op == Op_RShiftI) {\n+              rshift = phase->transform(new RShiftINode(add1->in(1), phase->intcon(add1Con - con)));\n+            } else {\n+              rshift = phase->transform(new URShiftINode(add1->in(1), phase->intcon(add1Con - con)));\n+            }\n+\n+            return new AndINode(rshift, phase->intcon(-(1 << con)));\n+          }\n+        } else {\n+          phase->record_for_igvn(this);\n+        }\n+      }\n+    }\n+  }\n@@ -856,2 +923,2 @@\n-  \/\/ Check for \"((x>>c0) & Y)<<c0\" which just masks off more low bits\n-  if( add1_op == Op_AndI ) {\n+  \/\/ Check for \"((x >> C1) & Y) << C2\"\n+  if (add1_op == Op_AndI) {\n@@ -860,5 +927,24 @@\n-    if( (add2_op == Op_RShiftI || add2_op == Op_URShiftI ) &&\n-        add2->in(2) == in(2) ) {\n-      \/\/ Convert to \"(x & (Y<<c0))\"\n-      Node *y_sh = phase->transform( new LShiftINode( add1->in(2), in(2) ) );\n-      return new AndINode( add2->in(1), y_sh );\n+    if (add2_op == Op_RShiftI || add2_op == Op_URShiftI) {\n+      \/\/ Special case C1 == C2, which just masks off low bits\n+      if (add2->in(2) == in(2)) {\n+        \/\/ Convert to \"(x & (Y << C2))\"\n+        Node* y_sh = phase->transform(new LShiftINode(add1->in(2), phase->intcon(con)));\n+        return new AndINode(add2->in(1), y_sh);\n+      }\n+\n+      int add2Con = 0;\n+      const_shift_count(phase, add2, &add2Con);\n+      if (add2Con > 0 && add2Con < BitsPerJavaInteger) {\n+        if (phase->is_IterGVN()) {\n+          \/\/ Convert to \"((x >> C1) << C2) & (Y << C2)\"\n+\n+          \/\/ Make \"(x >> C1) << C2\", which will get folded away by the rule above\n+          Node* x_sh = phase->transform(new LShiftINode(add2, phase->intcon(con)));\n+          \/\/ Make \"Y << C2\", which will simplify when Y is a constant\n+          Node* y_sh = phase->transform(new LShiftINode(add1->in(2), phase->intcon(con)));\n+\n+          return new AndINode(x_sh, y_sh);\n+        } else {\n+          phase->record_for_igvn(this);\n+        }\n+      }\n@@ -973,5 +1059,39 @@\n-  \/\/ Check for \"(x>>c0)<<c0\" which just masks off low bits\n-  if( (add1_op == Op_RShiftL || add1_op == Op_URShiftL ) &&\n-      add1->in(2) == in(2) )\n-    \/\/ Convert to \"(x & -(1<<c0))\"\n-    return new AndLNode(add1->in(1),phase->longcon( -(CONST64(1)<<con)));\n+  \/\/ Check for \"(x >> C1) << C2\"\n+  if (add1_op == Op_RShiftL || add1_op == Op_URShiftL) {\n+    \/\/ Special case C1 == C2, which just masks off low bits\n+    if (add1->in(2) == in(2)) {\n+      \/\/ Convert to \"(x & -(1 << C2))\"\n+      return new AndLNode(add1->in(1), phase->longcon(-(CONST64(1) << con)));\n+    } else {\n+      int add1Con = 0;\n+      const_shift_count(phase, add1, &add1Con);\n+\n+      \/\/ Wait until the right shift has been sharpened to the correct count\n+      if (add1Con > 0 && add1Con < BitsPerJavaLong) {\n+        \/\/ As loop parsing can produce LShiftI nodes, we should wait until the graph is fully formed\n+        \/\/ to apply optimizations, otherwise we can inadvertently stop vectorization opportunities.\n+        if (phase->is_IterGVN()) {\n+          if (con > add1Con) {\n+            \/\/ Creates \"(x << (C2 - C1)) & -(1 << C2)\"\n+            Node* lshift = phase->transform(new LShiftLNode(add1->in(1), phase->intcon(con - add1Con)));\n+            return new AndLNode(lshift, phase->longcon(-(CONST64(1) << con)));\n+          } else {\n+            assert(con < add1Con, \"must be (%d < %d)\", con, add1Con);\n+            \/\/ Creates \"(x >> (C1 - C2)) & -(1 << C2)\"\n+\n+            \/\/ Handle logical and arithmetic shifts\n+            Node* rshift;\n+            if (add1_op == Op_RShiftL) {\n+              rshift = phase->transform(new RShiftLNode(add1->in(1), phase->intcon(add1Con - con)));\n+            } else {\n+              rshift = phase->transform(new URShiftLNode(add1->in(1), phase->intcon(add1Con - con)));\n+            }\n+\n+            return new AndLNode(rshift, phase->longcon(-(CONST64(1) << con)));\n+          }\n+        } else {\n+          phase->record_for_igvn(this);\n+        }\n+      }\n+    }\n+  }\n@@ -979,3 +1099,3 @@\n-  \/\/ Check for \"((x>>c0) & Y)<<c0\" which just masks off more low bits\n-  if( add1_op == Op_AndL ) {\n-    Node *add2 = add1->in(1);\n+  \/\/ Check for \"((x >> C1) & Y) << C2\"\n+  if (add1_op == Op_AndL) {\n+    Node* add2 = add1->in(1);\n@@ -983,5 +1103,24 @@\n-    if( (add2_op == Op_RShiftL || add2_op == Op_URShiftL ) &&\n-        add2->in(2) == in(2) ) {\n-      \/\/ Convert to \"(x & (Y<<c0))\"\n-      Node *y_sh = phase->transform( new LShiftLNode( add1->in(2), in(2) ) );\n-      return new AndLNode( add2->in(1), y_sh );\n+    if (add2_op == Op_RShiftL || add2_op == Op_URShiftL) {\n+      \/\/ Special case C1 == C2, which just masks off low bits\n+      if (add2->in(2) == in(2)) {\n+        \/\/ Convert to \"(x & (Y << C2))\"\n+        Node* y_sh = phase->transform(new LShiftLNode(add1->in(2), phase->intcon(con)));\n+        return new AndLNode(add2->in(1), y_sh);\n+      }\n+\n+      int add2Con = 0;\n+      const_shift_count(phase, add2, &add2Con);\n+      if (add2Con > 0 && add2Con < BitsPerJavaLong) {\n+        if (phase->is_IterGVN()) {\n+          \/\/ Convert to \"((x >> C1) << C2) & (Y << C2)\"\n+\n+          \/\/ Make \"(x >> C1) << C2\", which will get folded away by the rule above\n+          Node* x_sh = phase->transform(new LShiftLNode(add2, phase->intcon(con)));\n+          \/\/ Make \"Y << C2\", which will simplify when Y is a constant\n+          Node* y_sh = phase->transform(new LShiftLNode(add1->in(2), phase->intcon(con)));\n+\n+          return new AndLNode(x_sh, y_sh);\n+        } else {\n+          phase->record_for_igvn(this);\n+        }\n+      }\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":236,"deletions":97,"binary":false,"changes":333,"status":"modified"},{"patch":"@@ -542,0 +542,2 @@\n+    DEBUG_ONLY(verify_packs();)\n+\n@@ -643,48 +645,4 @@\n-    \/\/ Create initial pack pairs of memory operations for which\n-    \/\/ alignment is set and vectors will be aligned.\n-    bool create_pack = true;\n-    if (memory_alignment(mem_ref, best_iv_adjustment) == 0 || _do_vector_loop) {\n-      if (vectors_should_be_aligned()) {\n-        int vw = vector_width(mem_ref);\n-        int vw_best = vector_width(best_align_to_mem_ref);\n-        if (vw > vw_best) {\n-          \/\/ Do not vectorize a memory access with more elements per vector\n-          \/\/ if unaligned memory access is not allowed because number of\n-          \/\/ iterations in pre-loop will be not enough to align it.\n-          create_pack = false;\n-        } else {\n-          SWPointer p2(best_align_to_mem_ref, this, nullptr, false);\n-          if (!align_to_ref_p.invar_equals(p2)) {\n-            \/\/ Do not vectorize memory accesses with different invariants\n-            \/\/ if unaligned memory accesses are not allowed.\n-            create_pack = false;\n-          }\n-        }\n-      }\n-    } else {\n-      if (same_memory_slice(best_align_to_mem_ref, mem_ref)) {\n-        \/\/ Can't allow vectorization of unaligned memory accesses with the\n-        \/\/ same memory slice since it could be overlapped accesses to the same array.\n-        create_pack = false;\n-      } else {\n-        \/\/ Allow independent (different type) unaligned memory operations\n-        \/\/ if HW supports them.\n-        if (vectors_should_be_aligned()) {\n-          create_pack = false;\n-        } else {\n-          \/\/ Check if packs of the same memory slice but\n-          \/\/ with a different alignment were created before.\n-          for (uint i = 0; i < align_to_refs.size(); i++) {\n-            MemNode* mr = align_to_refs.at(i)->as_Mem();\n-            if (mr == mem_ref) {\n-              \/\/ Skip when we are looking at same memory operation.\n-              continue;\n-            }\n-            if (same_memory_slice(mem_ref, mr) &&\n-                memory_alignment(mr, iv_adjustment) != 0)\n-              create_pack = false;\n-          }\n-        }\n-      }\n-    }\n-    if (create_pack) {\n+    if (can_create_pairs(mem_ref, iv_adjustment, align_to_ref_p,\n+                         best_align_to_mem_ref, best_iv_adjustment,\n+                         align_to_refs)) {\n+      \/\/ Create initial pack pairs of memory operations for which alignment was set.\n@@ -710,1 +668,3 @@\n-    } else { \/\/ Don't create unaligned pack\n+    } else {\n+      \/\/ Cannot create pairs for mem_ref. Reject all related memops forever.\n+\n@@ -797,0 +757,90 @@\n+\/\/ Check if we can create the pack pairs for mem_ref:\n+\/\/ If required, enforce strict alignment requirements of hardware.\n+\/\/ Else, only enforce alignment within a memory slice, so that there cannot be any\n+\/\/ memory-dependence between different vector \"lanes\".\n+bool SuperWord::can_create_pairs(MemNode* mem_ref, int iv_adjustment, SWPointer &align_to_ref_p,\n+                                 MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n+                                 Node_List &align_to_refs) {\n+  bool is_aligned_with_best = memory_alignment(mem_ref, best_iv_adjustment) == 0;\n+\n+  if (vectors_should_be_aligned()) {\n+    \/\/ All vectors need to be memory aligned, modulo their vector_width. This is more strict\n+    \/\/ than the hardware probably requires. Most hardware at most requires 4-byte alignment.\n+    \/\/\n+    \/\/ In the pre-loop, we align best_align_to_mem_ref to its vector_length. To ensure that\n+    \/\/ all mem_ref's are memory aligned modulo their vector_width, we only need to check that\n+    \/\/ they are all aligned to best_align_to_mem_ref, modulo their vector_width. For that,\n+    \/\/ we check the following 3 conditions.\n+\n+    \/\/ (1) All packs are aligned with best_align_to_mem_ref.\n+    if (!is_aligned_with_best) {\n+      return false;\n+    }\n+    \/\/ (2) All other vectors have vector_size less or equal to that of best_align_to_mem_ref.\n+    int vw = vector_width(mem_ref);\n+    int vw_best = vector_width(best_align_to_mem_ref);\n+    if (vw > vw_best) {\n+      \/\/ We only align to vector_width of best_align_to_mem_ref during pre-loop.\n+      \/\/ A mem_ref with a larger vector_width might thus not be vector_width aligned.\n+      return false;\n+    }\n+    \/\/ (3) Ensure that all vectors have the same invariant. We model memory accesses like this\n+    \/\/     address = base + k*iv + constant [+ invar]\n+    \/\/     memory_alignment ignores the invariant.\n+    SWPointer p2(best_align_to_mem_ref, this, nullptr, false);\n+    if (!align_to_ref_p.invar_equals(p2)) {\n+      \/\/ Do not vectorize memory accesses with different invariants\n+      \/\/ if unaligned memory accesses are not allowed.\n+      return false;\n+    }\n+    return true;\n+  } else {\n+    \/\/ Alignment is not required by the hardware.\n+\n+    \/\/ However, we need to ensure that the pack for mem_ref is independent, i.e. all members\n+    \/\/ of the pack are mutually independent.\n+\n+    if (_do_vector_loop) {\n+      \/\/ Wait until combine_packs to check independence of packs. For now we just know that\n+      \/\/ the adjacent pairs are independent. This allows us to vectorize when we do not have\n+      \/\/ alignment modulo vector_width. For example (forward read):\n+      \/\/ for (int i ...) { v[i] = v[i + 1] + 5; }\n+      \/\/ The following will be filtered out in combine_packs (forward write):\n+      \/\/ for (int i ...) { v[i + 1] = v[i] + 5; }\n+      return true;\n+    }\n+\n+    \/\/ If all mem_ref's are modulo vector_width aligned with all other mem_ref's of their\n+    \/\/ memory slice, then the VectorLoad \/ VectorStore regions are either exactly overlapping\n+    \/\/ or completely non-overlapping. This ensures that there cannot be memory-dependencies\n+    \/\/ between different vector \"lanes\".\n+    \/\/ During SuperWord::filter_packs -> SuperWord::profitable -> SuperWord::is_vector_use,\n+    \/\/ we check that all inputs are vectors that match on every element (with some reasonable\n+    \/\/ exceptions). This ensures that every \"lane\" is isomorpic and independent to all other\n+    \/\/ \"lanes\". This allows us to vectorize these cases:\n+    \/\/ for (int i ...) { v[i] = v[i] + 5; }      \/\/ same alignment\n+    \/\/ for (int i ...) { v[i] = v[i + 32] + 5; } \/\/ alignment modulo vector_width\n+    if (same_memory_slice(mem_ref, best_align_to_mem_ref)) {\n+      return is_aligned_with_best;\n+    } else {\n+      return is_mem_ref_aligned_with_same_memory_slice(mem_ref, iv_adjustment, align_to_refs);\n+    }\n+  }\n+}\n+\n+\/\/ Check if alignment of mem_ref is consistent with the other packs of the same memory slice\n+bool SuperWord::is_mem_ref_aligned_with_same_memory_slice(MemNode* mem_ref, int iv_adjustment,\n+                                                          Node_List &align_to_refs) {\n+  for (uint i = 0; i < align_to_refs.size(); i++) {\n+    MemNode* mr = align_to_refs.at(i)->as_Mem();\n+    if (mr != mem_ref &&\n+        same_memory_slice(mr, mem_ref) &&\n+        memory_alignment(mr, iv_adjustment) != 0) {\n+      \/\/ mem_ref is misaligned with mr, another ref of the same memory slice.\n+      return false;\n+    }\n+  }\n+  \/\/ No misalignment found.\n+  return true;\n+}\n+\n@@ -1329,0 +1379,38 @@\n+\/\/------------------------------find_dependence---------------------\n+\/\/ Is any s1 in p dependent on any s2 in p? Yes: return such a s2. No: return nullptr.\n+\/\/ We could query independent(s1, s2) for all pairs, but that results\n+\/\/ in O(p.size * p.size) graph traversals. We can do it all in one BFS!\n+\/\/ Start the BFS traversal at all nodes from the pack. Traverse DepPreds\n+\/\/ recursively, for nodes that have at least depth min_d, which is the\n+\/\/ smallest depth of all nodes from the pack. Once we have traversed all\n+\/\/ those nodes, and have not found another node from the pack, we know\n+\/\/ that all nodes in the pack are independent.\n+Node* SuperWord::find_dependence(Node_List* p) {\n+  if (p->at(0)->is_reduction()) {\n+    return nullptr; \/\/ ignore reductions\n+  }\n+  ResourceMark rm;\n+  Unique_Node_List worklist; \/\/ traversal queue\n+  int min_d = depth(p->at(0));\n+  visited_clear();\n+  for (uint k = 0; k < p->size(); k++) {\n+    Node* n = p->at(k);\n+    min_d = MIN2(min_d, depth(n));\n+    worklist.push(n); \/\/ start traversal at all nodes in p\n+    visited_set(n); \/\/ mark node\n+  }\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    Node* n = worklist.at(i);\n+    for (DepPreds preds(n, _dg); !preds.done(); preds.next()) {\n+      Node* pred = preds.current();\n+      if (in_bb(pred) && depth(pred) >= min_d) {\n+        if (visited_test(pred)) { \/\/ marked as in p?\n+          return pred;\n+        }\n+        worklist.push(pred);\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -1486,1 +1574,2 @@\n-    if (!in_bb(t1) || !in_bb(t2))\n+    if (!in_bb(t1) || !in_bb(t2) || t1->is_Mem() || t2->is_Mem())  {\n+      \/\/ Only follow non-memory nodes in block - we do not want to resurrect misaligned packs.\n@@ -1488,0 +1577,1 @@\n+    }\n@@ -1525,1 +1615,4 @@\n-    if (!in_bb(t1)) continue;\n+    if (!in_bb(t1) || t1->is_Mem()) {\n+      \/\/ Only follow non-memory nodes in block - we do not want to resurrect misaligned packs.\n+      continue;\n+    }\n@@ -1528,1 +1621,4 @@\n-      if (!in_bb(t2)) continue;\n+      if (!in_bb(t2) || t2->is_Mem()) {\n+        \/\/ Only follow non-memory nodes in block - we do not want to resurrect misaligned packs.\n+        continue;\n+      }\n@@ -1717,1 +1813,0 @@\n-        if (i == j) continue;\n@@ -1758,0 +1853,26 @@\n+  if (_do_vector_loop) {\n+    \/\/ Since we did not enforce exact alignment of the packsets, we only know that there\n+    \/\/ is no dependence with distance 1, because we have checked independent(s1, s2) for\n+    \/\/ all adjacent memops. But there could be a dependence of a different distance.\n+    \/\/ Hence: remove the pack if there is a dependence.\n+    for (int i = 0; i < _packset.length(); i++) {\n+      Node_List* p = _packset.at(i);\n+      if (p != nullptr) {\n+        Node* dependence = find_dependence(p);\n+        if (dependence != nullptr) {\n+#ifndef PRODUCT\n+          if (TraceSuperWord) {\n+            tty->cr();\n+            tty->print_cr(\"WARNING: Found dependency.\");\n+            tty->print_cr(\"Cannot vectorize despite compile directive Vectorize.\");\n+            dependence->dump();\n+            tty->print_cr(\"In pack[%d]\", i);\n+            print_pack(p);\n+          }\n+#endif\n+          _packset.at_put(i, nullptr);\n+        }\n+      }\n+    }\n+  }\n+\n@@ -1776,1 +1897,0 @@\n-  Node_List* rslt = nullptr;\n@@ -2206,0 +2326,23 @@\n+#ifdef ASSERT\n+void SuperWord::verify_packs() {\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* p = _packset.at(i);\n+    Node* dependence = find_dependence(p);\n+    if (dependence != nullptr) {\n+      tty->print_cr(\"Other nodes in pack have dependence on:\");\n+      dependence->dump();\n+      tty->print_cr(\"The following nodes are not independent:\");\n+      for (uint k = 0; k < p->size(); k++) {\n+        Node* n = p->at(k);\n+        if (!independent(n, dependence)) {\n+          n->dump();\n+        }\n+      }\n+      tty->print_cr(\"They are all from pack[%d]\", i);\n+      print_pack(p);\n+    }\n+    assert(dependence == nullptr, \"all nodes in pack must be mutually independent\");\n+  }\n+}\n+#endif\n+\n@@ -4030,1 +4173,5 @@\n-    print_pack(p);\n+    if (p == nullptr) {\n+      tty->print_cr(\"  nullptr\");\n+    } else {\n+      print_pack(p);\n+    }\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":202,"deletions":55,"binary":false,"changes":257,"status":"modified"},{"patch":"@@ -479,0 +479,9 @@\n+  \/\/ Check if we can create the pack pairs for mem_ref:\n+  \/\/ If required, enforce strict alignment requirements of hardware.\n+  \/\/ Else, only enforce alignment within a memory slice, so that there cannot be any\n+  \/\/ memory-dependence between different vector \"lanes\".\n+  bool can_create_pairs(MemNode* mem_ref, int iv_adjustment, SWPointer &align_to_ref_p,\n+                        MemNode* best_align_to_mem_ref, int best_iv_adjustment,\n+                        Node_List &align_to_refs);\n+  \/\/ Check if alignment of mem_ref is consistent with the other packs of the same memory slice.\n+  bool is_mem_ref_aligned_with_same_memory_slice(MemNode* mem_ref, int iv_adjustment, Node_List &align_to_refs);\n@@ -515,0 +524,2 @@\n+  \/\/ Is any s1 in p dependent on any s2 in p? Yes: return such a s2. No: return nullptr.\n+  Node* find_dependence(Node_List* p);\n@@ -546,0 +557,2 @@\n+  \/\/ Verify that for every pack, all nodes are mutually independent\n+  DEBUG_ONLY(void verify_packs();)\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -4101,1 +4101,1 @@\n-  bool deopt_needed;\n+  DeoptimizationScope deopt_scope;\n@@ -4105,0 +4105,1 @@\n+    CodeCache::mark_all_nmethods_for_evol_deoptimization(&deopt_scope);\n@@ -4106,2 +4107,0 @@\n-    CodeCache::mark_all_nmethods_for_evol_deoptimization();\n-    deopt_needed = true;\n@@ -4109,3 +4108,2 @@\n-    int deopt = CodeCache::mark_dependents_for_evol_deoptimization();\n-    log_debug(redefine, class, nmethod)(\"Marked %d dependent nmethods for deopt\", deopt);\n-    deopt_needed = (deopt != 0);\n+    CodeCache::mark_dependents_for_evol_deoptimization(&deopt_scope);\n+    log_debug(redefine, class, nmethod)(\"Marked dependent nmethods for deopt\");\n@@ -4114,3 +4112,1 @@\n-  if (deopt_needed) {\n-    CodeCache::flush_evol_dependents();\n-  }\n+  deopt_scope.deoptimize_marked();\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -331,1 +331,2 @@\n-      while (_VTMS_transition_disable_for_all_count > 0) {\n+      while (_VTMS_transition_disable_for_all_count > 0 ||\n+             _VTMS_transition_disable_for_one_count > 0) {\n@@ -372,1 +373,1 @@\n-  if (_VTMS_transition_disable_for_one_count == 0 || _is_SR) {\n+  if (_VTMS_transition_disable_for_one_count == 0) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -953,1 +953,1 @@\n-void MethodHandles::flush_dependent_nmethods(Handle call_site, Handle target) {\n+void MethodHandles::mark_dependent_nmethods(DeoptimizationScope* deopt_scope, Handle call_site, Handle target) {\n@@ -956,1 +956,0 @@\n-  int marked = 0;\n@@ -960,1 +959,1 @@\n-    MutexLocker mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -964,5 +963,1 @@\n-    marked = deps.mark_dependent_nmethods(changes);\n-  }\n-  if (marked > 0) {\n-    \/\/ At least one nmethod has been marked for deoptimization.\n-    Deoptimization::deoptimize_all_marked();\n+    deps.mark_dependent_nmethods(deopt_scope, changes);\n@@ -1221,0 +1216,1 @@\n+  DeoptimizationScope deopt_scope;\n@@ -1224,1 +1220,1 @@\n-    MethodHandles::flush_dependent_nmethods(call_site, target);\n+    MethodHandles::mark_dependent_nmethods(&deopt_scope, call_site, target);\n@@ -1226,0 +1222,3 @@\n+    \/\/ This is assumed to be an 'atomic' operation by verification.\n+    \/\/ So keep it under lock for now.\n+    deopt_scope.deoptimize_marked();\n@@ -1233,0 +1232,1 @@\n+  DeoptimizationScope deopt_scope;\n@@ -1236,1 +1236,1 @@\n-    MethodHandles::flush_dependent_nmethods(call_site, target);\n+    MethodHandles::mark_dependent_nmethods(&deopt_scope, call_site, target);\n@@ -1238,0 +1238,3 @@\n+    \/\/ This is assumed to be an 'atomic' operation by verification.\n+    \/\/ So keep it under lock for now.\n+    deopt_scope.deoptimize_marked();\n@@ -1327,0 +1330,1 @@\n+  DeoptimizationScope deopt_scope;\n@@ -1328,14 +1332,7 @@\n-    \/\/ Walk all nmethods depending on this call site.\n-    MutexLocker mu1(thread, Compile_lock);\n-\n-    int marked = 0;\n-    {\n-      NoSafepointVerifier nsv;\n-      MutexLocker mu2(THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-      DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());\n-      marked = deps.remove_and_mark_for_deoptimization_all_dependents();\n-    }\n-    if (marked > 0) {\n-      \/\/ At least one nmethod has been marked for deoptimization\n-      Deoptimization::deoptimize_all_marked();\n-    }\n+    NoSafepointVerifier nsv;\n+    MutexLocker ml(THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());\n+    deps.remove_and_mark_for_deoptimization_all_dependents(&deopt_scope);\n+    \/\/ This is assumed to be an 'atomic' operation by verification.\n+    \/\/ So keep it under lock for now.\n+    deopt_scope.deoptimize_marked();\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-  static void flush_dependent_nmethods(Handle call_site, Handle target);\n+  static void mark_dependent_nmethods(DeoptimizationScope* deopt_scope, Handle call_site, Handle target);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -121,2 +121,0 @@\n-#define SIZE_T_MAX_VALUE ((size_t) -1)\n-\n@@ -350,1 +348,1 @@\n-    jlong size_t_max_value = (jlong) SIZE_T_MAX_VALUE;\n+    jlong size_t_max_value = (jlong)SIZE_MAX;\n@@ -781,2 +779,3 @@\n-  CodeCache::mark_all_nmethods_for_deoptimization();\n-  Deoptimization::deoptimize_all_marked();\n+  DeoptimizationScope deopt_scope;\n+  CodeCache::mark_all_nmethods_for_deoptimization(&deopt_scope);\n+  deopt_scope.deoptimize_marked();\n@@ -789,11 +788,15 @@\n-  MutexLocker mu(Compile_lock);\n-  methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n-  if (is_osr) {\n-    result += mh->mark_osr_nmethods();\n-  } else if (mh->code() != nullptr) {\n-    mh->code()->mark_for_deoptimization();\n-    ++result;\n-  }\n-  result += CodeCache::mark_for_deoptimization(mh());\n-  if (result > 0) {\n-    Deoptimization::deoptimize_all_marked();\n+\n+  DeoptimizationScope deopt_scope;\n+  {\n+    MutexLocker mu(Compile_lock);\n+    methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n+    if (is_osr) {\n+      result += mh->method_holder()->mark_osr_nmethods(&deopt_scope, mh());\n+    } else {\n+      MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+      if (mh->code() != nullptr) {\n+        deopt_scope.mark(mh->code());\n+        ++result;\n+      }\n+    }\n+    CodeCache::mark_for_deoptimization(&deopt_scope, mh());\n@@ -801,0 +804,3 @@\n+\n+  deopt_scope.deoptimize_marked();\n+\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+enum class vmIntrinsicID;\n@@ -184,0 +185,4 @@\n+\n+  \/\/ Does this CPU support this intrinsic?\n+  static bool is_intrinsic_supported(vmIntrinsicID id) { return true; }\n+\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -73,1 +73,3 @@\n-#define DEFAULT_JAVA_LAUNCHER  \"generic\"\n+static const char _default_java_launcher[] = \"generic\";\n+\n+#define DEFAULT_JAVA_LAUNCHER _default_java_launcher\n@@ -99,0 +101,1 @@\n+char*  Arguments::_default_shared_archive_path  = nullptr;\n@@ -325,1 +328,1 @@\n-void Arguments::add_init_library(const char* name, char* options) {\n+void Arguments::add_init_library(const char* name, const char* options) {\n@@ -329,1 +332,1 @@\n-void Arguments::add_init_agent(const char* name, char* options, bool absolute_path) {\n+void Arguments::add_init_agent(const char* name, const char* options, bool absolute_path) {\n@@ -333,1 +336,1 @@\n-void Arguments::add_instrument_agent(const char* name, char* options, bool absolute_path) {\n+void Arguments::add_instrument_agent(const char* name, const char* options, bool absolute_path) {\n@@ -1910,0 +1913,3 @@\n+  if (_sun_java_launcher != _default_java_launcher) {\n+    os::free(const_cast<char*>(_sun_java_launcher));\n+  }\n@@ -2370,0 +2376,2 @@\n+        FREE_C_HEAP_ARRAY(char, name);\n+        FREE_C_HEAP_ARRAY(char, options);\n@@ -2440,0 +2448,2 @@\n+        os::free(name);\n+        os::free(options);\n@@ -2453,0 +2463,1 @@\n+        FREE_C_HEAP_ARRAY(char, options);\n@@ -3413,13 +3424,14 @@\n-  char *default_archive_path;\n-  char jvm_path[JVM_MAXPATHLEN];\n-  os::jvm_path(jvm_path, sizeof(jvm_path));\n-  char *end = strrchr(jvm_path, *os::file_separator());\n-  if (end != nullptr) *end = '\\0';\n-  size_t jvm_path_len = strlen(jvm_path);\n-  size_t file_sep_len = strlen(os::file_separator());\n-  const size_t len = jvm_path_len + file_sep_len + 20;\n-  default_archive_path = NEW_C_HEAP_ARRAY(char, len, mtArguments);\n-  jio_snprintf(default_archive_path, len,\n-               LP64_ONLY(!UseCompressedOops ? \"%s%sclasses_nocoops.jsa\":) \"%s%sclasses.jsa\",\n-               jvm_path, os::file_separator());\n-  return default_archive_path;\n+  if (_default_shared_archive_path == nullptr) {\n+    char jvm_path[JVM_MAXPATHLEN];\n+    os::jvm_path(jvm_path, sizeof(jvm_path));\n+    char *end = strrchr(jvm_path, *os::file_separator());\n+    if (end != nullptr) *end = '\\0';\n+    size_t jvm_path_len = strlen(jvm_path);\n+    size_t file_sep_len = strlen(os::file_separator());\n+    const size_t len = jvm_path_len + file_sep_len + 20;\n+    _default_shared_archive_path = NEW_C_HEAP_ARRAY(char, len, mtArguments);\n+    jio_snprintf(_default_shared_archive_path, len,\n+                LP64_ONLY(!UseCompressedOops ? \"%s%sclasses_nocoops.jsa\":) \"%s%sclasses.jsa\",\n+                jvm_path, os::file_separator());\n+  }\n+  return _default_shared_archive_path;\n@@ -3477,2 +3489,1 @@\n-    char* shared_archive_path = get_default_shared_archive_path();\n-    if (os::same_files(shared_archive_path, ArchiveClassesAtExit)) {\n+    if (os::same_files(get_default_shared_archive_path(), ArchiveClassesAtExit)) {\n@@ -3480,1 +3491,1 @@\n-        \"Cannot specify the default CDS archive for -XX:ArchiveClassesAtExit\", shared_archive_path);\n+        \"Cannot specify the default CDS archive for -XX:ArchiveClassesAtExit\", get_default_shared_archive_path());\n@@ -3482,1 +3493,0 @@\n-    FREE_C_HEAP_ARRAY(char, shared_archive_path);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":31,"deletions":21,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -336,1 +336,1 @@\n-  static void add_init_library(const char* name, char* options);\n+  static void add_init_library(const char* name, const char* options);\n@@ -340,2 +340,2 @@\n-  static void add_init_agent(const char* name, char* options, bool absolute_path);\n-  static void add_instrument_agent(const char* name, char* options, bool absolute_path);\n+  static void add_init_agent(const char* name, const char* options, bool absolute_path);\n+  static void add_instrument_agent(const char* name, const char* options, bool absolute_path);\n@@ -473,0 +473,1 @@\n+  static char*  _default_shared_archive_path;\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -101,0 +101,115 @@\n+uint64_t DeoptimizationScope::_committed_deopt_gen = 0;\n+uint64_t DeoptimizationScope::_active_deopt_gen    = 1;\n+bool     DeoptimizationScope::_committing_in_progress = false;\n+\n+DeoptimizationScope::DeoptimizationScope() : _required_gen(0) {\n+  DEBUG_ONLY(_deopted = false;)\n+\n+  MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+  \/\/ If there is nothing to deopt _required_gen is the same as comitted.\n+  _required_gen = DeoptimizationScope::_committed_deopt_gen;\n+}\n+\n+DeoptimizationScope::~DeoptimizationScope() {\n+  assert(_deopted, \"Deopt not executed\");\n+}\n+\n+void DeoptimizationScope::mark(CompiledMethod* cm, bool inc_recompile_counts) {\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n+                 Mutex::_no_safepoint_check_flag);\n+\n+  \/\/ If it's already marked but we still need it to be deopted.\n+  if (cm->is_marked_for_deoptimization()) {\n+    dependent(cm);\n+    return;\n+  }\n+\n+  CompiledMethod::DeoptimizationStatus status =\n+    inc_recompile_counts ? CompiledMethod::deoptimize : CompiledMethod::deoptimize_noupdate;\n+  Atomic::store(&cm->_deoptimization_status, status);\n+\n+  \/\/ Make sure active is not committed\n+  assert(DeoptimizationScope::_committed_deopt_gen < DeoptimizationScope::_active_deopt_gen, \"Must be\");\n+  assert(cm->_deoptimization_generation == 0, \"Is already marked\");\n+\n+  cm->_deoptimization_generation = DeoptimizationScope::_active_deopt_gen;\n+  _required_gen                  = DeoptimizationScope::_active_deopt_gen;\n+}\n+\n+void DeoptimizationScope::dependent(CompiledMethod* cm) {\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n+                 Mutex::_no_safepoint_check_flag);\n+  \/\/ A method marked by someone else may have a _required_gen lower than what we marked with.\n+  \/\/ Therefore only store it if it's higher than _required_gen.\n+  if (_required_gen < cm->_deoptimization_generation) {\n+    _required_gen = cm->_deoptimization_generation;\n+  }\n+}\n+\n+void DeoptimizationScope::deoptimize_marked() {\n+  assert(!_deopted, \"Already deopted\");\n+\n+  \/\/ We are not alive yet.\n+  if (!Universe::is_fully_initialized()) {\n+    DEBUG_ONLY(_deopted = true;)\n+    return;\n+  }\n+\n+  \/\/ Safepoints are a special case, handled here.\n+  if (SafepointSynchronize::is_at_safepoint()) {\n+    DeoptimizationScope::_committed_deopt_gen = DeoptimizationScope::_active_deopt_gen;\n+    DeoptimizationScope::_active_deopt_gen++;\n+    Deoptimization::deoptimize_all_marked();\n+    DEBUG_ONLY(_deopted = true;)\n+    return;\n+  }\n+\n+  uint64_t comitting = 0;\n+  bool wait = false;\n+  while (true) {\n+    {\n+      MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n+                 Mutex::_no_safepoint_check_flag);\n+      \/\/ First we check if we or someone else already deopted the gen we want.\n+      if (DeoptimizationScope::_committed_deopt_gen >= _required_gen) {\n+        DEBUG_ONLY(_deopted = true;)\n+        return;\n+      }\n+      if (!_committing_in_progress) {\n+        \/\/ The version we are about to commit.\n+        comitting = DeoptimizationScope::_active_deopt_gen;\n+        \/\/ Make sure new marks use a higher gen.\n+        DeoptimizationScope::_active_deopt_gen++;\n+        _committing_in_progress = true;\n+        wait = false;\n+      } else {\n+        \/\/ Another thread is handshaking and committing a gen.\n+        wait = true;\n+      }\n+    }\n+    if (wait) {\n+      \/\/ Wait and let the concurrent handshake be performed.\n+      ThreadBlockInVM tbivm(JavaThread::current());\n+      os::naked_yield();\n+    } else {\n+      \/\/ Performs the handshake.\n+      Deoptimization::deoptimize_all_marked(); \/\/ May safepoint and an additional deopt may have occurred.\n+      DEBUG_ONLY(_deopted = true;)\n+      {\n+        MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n+                       Mutex::_no_safepoint_check_flag);\n+        \/\/ Make sure that committed doesn't go backwards.\n+        \/\/ Should only happen if we did a deopt during a safepoint above.\n+        if (DeoptimizationScope::_committed_deopt_gen < comitting) {\n+          DeoptimizationScope::_committed_deopt_gen = comitting;\n+        }\n+        _committing_in_progress = false;\n+\n+        assert(DeoptimizationScope::_committed_deopt_gen >= _required_gen, \"Must be\");\n+\n+        return;\n+      }\n+    }\n+  }\n+}\n+\n@@ -918,1 +1033,1 @@\n-void Deoptimization::deoptimize_all_marked(nmethod* nmethod_only) {\n+void Deoptimization::deoptimize_all_marked() {\n@@ -922,7 +1037,1 @@\n-  if (nmethod_only != nullptr) {\n-    nmethod_only->mark_for_deoptimization();\n-    nmethod_only->make_not_entrant();\n-    CodeCache::make_nmethod_deoptimized(nmethod_only);\n-  } else {\n-    CodeCache::make_marked_nmethods_deoptimized();\n-  }\n+  CodeCache::make_marked_nmethods_deoptimized();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":117,"deletions":8,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -43,0 +43,26 @@\n+class DeoptimizationScope {\n+ private:\n+  \/\/ What gen we have done the deopt handshake for.\n+  static uint64_t _committed_deopt_gen;\n+  \/\/ What gen to mark a method with, hence larger than _committed_deopt_gen.\n+  static uint64_t _active_deopt_gen;\n+  \/\/ Indicate an in-progress deopt handshake.\n+  static bool     _committing_in_progress;\n+\n+  \/\/ The required gen we need to execute\/wait for\n+  uint64_t _required_gen;\n+  DEBUG_ONLY(bool _deopted;)\n+\n+ public:\n+  DeoptimizationScope();\n+  ~DeoptimizationScope();\n+  \/\/ Mark a method, if already marked as dependent.\n+  void mark(CompiledMethod* cm, bool inc_recompile_counts = true);\n+  \/\/ Record this as a dependent method.\n+  void dependent(CompiledMethod* cm);\n+\n+  \/\/ Execute the deoptimization.\n+  \/\/ Make the nmethods not entrant, stackwalks and patch return pcs and sets post call nops.\n+  void deoptimize_marked();\n+};\n+\n@@ -152,2 +178,1 @@\n-  \/\/ activations using those nmethods.  If an nmethod is passed as an argument then it is\n-  \/\/ marked_for_deoptimization and made not_entrant.  Otherwise a scan of the code cache is done to\n+  \/\/ activations using those nmethods. Scan of the code cache is done to\n@@ -155,1 +180,1 @@\n-  static void deoptimize_all_marked(nmethod* nmethod_only = nullptr);\n+  static void deoptimize_all_marked();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1197,1 +1197,1 @@\n-          \"Inline intrinsics that can be statically resolved\")              \\\n+          \"Use intrinsics in Interpreter that can be statically resolved\")  \\\n@@ -1888,1 +1888,1 @@\n-  product(size_t, ArrayAllocatorMallocLimit, (size_t)-1, EXPERIMENTAL,      \\\n+  product(size_t, ArrayAllocatorMallocLimit, SIZE_MAX, EXPERIMENTAL,        \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -273,2 +273,2 @@\n-        \/\/ Wait a second, then recheck for timeout.\n-        os::naked_short_sleep(999);\n+        \/\/ Wait a bit, then recheck for timeout.\n+        os::naked_short_sleep(250);\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1821,1 +1821,1 @@\n-  os::print_memory_mappings(nullptr, (size_t)-1, st);\n+  os::print_memory_mappings(nullptr, SIZE_MAX, st);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -657,0 +657,2 @@\n+  log_info(os)(\"Initialized VM with process ID %d\", os::current_process_id());\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1076,11 +1076,0 @@\n-int ThreadDumpToFileDCmd::num_arguments() {\n-  ResourceMark rm;\n-  ThreadDumpToFileDCmd* dcmd = new ThreadDumpToFileDCmd(nullptr, false);\n-  if (dcmd != nullptr) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  static int num_arguments() { return 2; }\n@@ -116,0 +117,1 @@\n+  static int num_arguments() { return 1; }\n@@ -138,0 +140,1 @@\n+  static int num_arguments() { return 2; }\n@@ -179,0 +182,1 @@\n+  static int num_arguments() { return 2; }\n@@ -219,0 +223,1 @@\n+  static int num_arguments() { return 1; }\n@@ -319,0 +324,1 @@\n+  static int num_arguments() { return 4; }\n@@ -345,0 +351,1 @@\n+  static int num_arguments() { return 2; }\n@@ -369,0 +376,1 @@\n+  static int num_arguments() { return 3; }\n@@ -395,0 +403,1 @@\n+  static int num_arguments() { return 2; }\n@@ -410,1 +419,0 @@\n-  static int num_arguments();\n@@ -421,0 +429,1 @@\n+  static int num_arguments() { return 2; }\n@@ -472,0 +481,2 @@\n+  static int num_arguments() { return 21; }\n+\n@@ -635,0 +646,1 @@\n+  static int num_arguments() { return 2; }\n@@ -699,0 +711,1 @@\n+  static int num_arguments() { return 1; }\n@@ -784,0 +797,1 @@\n+  static int num_arguments() { return 1; }\n@@ -806,0 +820,1 @@\n+  static int num_arguments() { return 1; }\n@@ -828,0 +843,1 @@\n+  static int num_arguments() { return 1; }\n@@ -850,0 +866,1 @@\n+  static int num_arguments() { return 1; }\n@@ -894,0 +911,1 @@\n+  static int num_arguments() { return 2; }\n@@ -920,0 +938,1 @@\n+  static int num_arguments() { return 3; }\n@@ -934,1 +953,0 @@\n-  static int num_arguments();\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -279,3 +279,1 @@\n-  \/\/ - For subclasses of DCmdWithParser, it's calculated by DCmdParser::num_arguments().\n-  \/\/ - Other subclasses of DCmd have zero arguments by default. You can change this\n-  \/\/   by defining your own version of MyDCmd::num_arguments().\n+  \/\/ All subclasses should override this to report the actual number of arguments.\n@@ -442,0 +440,1 @@\n+#ifdef ASSERT\n@@ -443,1 +442,1 @@\n-  static int get_num_arguments() {\n+  static int get_parsed_num_arguments() {\n@@ -448,1 +447,1 @@\n-  static int get_num_arguments() {\n+  static int get_parsed_num_arguments() {\n@@ -458,0 +457,14 @@\n+#endif\n+\n+  template <typename T, ENABLE_IF(std::is_convertible<T, DCmd>::value)>\n+  static int get_num_arguments() {\n+    int n_args = T::num_arguments();\n+#ifdef ASSERT\n+    int n_parsed_args = get_parsed_num_arguments<T>();\n+    assert(n_args == n_parsed_args,\n+           \"static argument count %d does not match parsed argument count %d\",\n+           n_args, n_parsed_args);\n+#endif\n+    return n_args;\n+  }\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.hpp","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-      MemoryUsage usage(u.init_size(), u.used(), u.committed(), (size_t)-1);\n+      MemoryUsage usage(u.init_size(), u.used(), u.committed(), MemoryUsage::undefined_size());\n","filename":"src\/hotspot\/share\/services\/gcNotifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,4 +58,8 @@\n-  ssize_t n = os::write(_fd, buf, (uint) size);\n-\n-  if (n <= 0) {\n-    return os::strerror(errno);\n+  while (size > 0) {\n+    ssize_t n = os::write(_fd, buf, (uint) size);\n+    if (n <= 0) {\n+      return os::strerror(errno);\n+    }\n+\n+    buf += n;\n+    size -= n;\n","filename":"src\/hotspot\/share\/services\/heapDumperCompression.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1916,1 +1916,1 @@\n-      MemoryUsage usage(u.init_size(), u.used(), u.committed(), (size_t)-1);\n+      MemoryUsage usage(u.init_size(), u.used(), u.committed(), MemoryUsage::undefined_size());\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  static size_t undefined_size() { return (size_t) -1; }\n+  static size_t undefined_size() { return SIZE_MAX; }\n","filename":"src\/hotspot\/share\/services\/memoryUsage.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  static int num_arguments() { return 7; }\n","filename":"src\/hotspot\/share\/services\/nmtDCmd.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  \/\/ Helper for get_next_{zero,one}_bit variants.\n+  \/\/ Helper for find_first_{set,clear}_bit variants.\n@@ -102,1 +102,1 @@\n-  inline idx_t get_next_bit_impl(idx_t beg, idx_t end) const;\n+  inline idx_t find_first_bit_impl(idx_t beg, idx_t end) const;\n@@ -104,1 +104,1 @@\n-  \/\/ Values for get_next_bit_impl flip parameter.\n+  \/\/ Values for find_first_bit_impl flip parameter.\n@@ -293,2 +293,2 @@\n-  idx_t get_next_one_offset (idx_t beg, idx_t end) const;\n-  idx_t get_next_zero_offset(idx_t beg, idx_t end) const;\n+  idx_t find_first_set_bit(idx_t beg, idx_t end) const;\n+  idx_t find_first_clear_bit(idx_t beg, idx_t end) const;\n@@ -296,2 +296,2 @@\n-  idx_t get_next_one_offset(idx_t beg) const {\n-    return get_next_one_offset(beg, size());\n+  idx_t find_first_set_bit(idx_t beg) const {\n+    return find_first_set_bit(beg, size());\n@@ -299,2 +299,2 @@\n-  idx_t get_next_zero_offset(idx_t beg) const {\n-    return get_next_zero_offset(beg, size());\n+  idx_t find_first_clear_bit(idx_t beg) const {\n+    return find_first_clear_bit(beg, size());\n@@ -303,1 +303,1 @@\n-  \/\/ Like \"get_next_one_offset\", except requires that \"end\" is\n+  \/\/ Like \"find_first_set_bit\", except requires that \"end\" is\n@@ -305,1 +305,1 @@\n-  idx_t get_next_one_offset_aligned_right(idx_t beg, idx_t end) const;\n+  idx_t find_first_set_bit_aligned_right(idx_t beg, idx_t end) const;\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-inline BitMap::idx_t BitMap::get_next_bit_impl(idx_t beg, idx_t end) const {\n+inline BitMap::idx_t BitMap::find_first_bit_impl(idx_t beg, idx_t end) const {\n@@ -232,2 +232,2 @@\n-BitMap::get_next_one_offset(idx_t beg, idx_t end) const {\n-  return get_next_bit_impl<find_ones_flip, false>(beg, end);\n+BitMap::find_first_set_bit(idx_t beg, idx_t end) const {\n+  return find_first_bit_impl<find_ones_flip, false>(beg, end);\n@@ -237,2 +237,2 @@\n-BitMap::get_next_zero_offset(idx_t beg, idx_t end) const {\n-  return get_next_bit_impl<find_zeros_flip, false>(beg, end);\n+BitMap::find_first_clear_bit(idx_t beg, idx_t end) const {\n+  return find_first_bit_impl<find_zeros_flip, false>(beg, end);\n@@ -242,2 +242,2 @@\n-BitMap::get_next_one_offset_aligned_right(idx_t beg, idx_t end) const {\n-  return get_next_bit_impl<find_ones_flip, true>(beg, end);\n+BitMap::find_first_set_bit_aligned_right(idx_t beg, idx_t end) const {\n+  return find_first_bit_impl<find_ones_flip, true>(beg, end);\n@@ -274,1 +274,1 @@\n-    index = get_next_one_offset(index, end);\n+    index = find_first_set_bit(index, end);\n","filename":"src\/hotspot\/share\/utilities\/bitMap.inline.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -37,3 +37,4 @@\n-#define PRAGMA_DISABLE_GCC_WARNING_AUX(x) _Pragma(#x)\n-#define PRAGMA_DISABLE_GCC_WARNING(option_string) \\\n-  PRAGMA_DISABLE_GCC_WARNING_AUX(GCC diagnostic ignored option_string)\n+#define PRAGMA_DISABLE_GCC_WARNING(optstring) _Pragma(STR(GCC diagnostic ignored optstring))\n+\n+#define PRAGMA_DIAG_PUSH             _Pragma(\"GCC diagnostic push\")\n+#define PRAGMA_DIAG_POP              _Pragma(\"GCC diagnostic pop\")\n@@ -59,12 +60,1 @@\n-#define PRAGMA_NONNULL_IGNORED \\\n-  PRAGMA_DISABLE_GCC_WARNING(\"-Wnonnull\")\n-\n-#if defined(__clang_major__) && \\\n-      (__clang_major__ >= 4 || \\\n-      (__clang_major__ >= 3 && __clang_minor__ >= 1)) || \\\n-    ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 6)) || (__GNUC__ > 4)\n-\/\/ Tested to work with clang version 3.1 and better.\n-#define PRAGMA_DIAG_PUSH             _Pragma(\"GCC diagnostic push\")\n-#define PRAGMA_DIAG_POP              _Pragma(\"GCC diagnostic pop\")\n-\n-#endif \/\/ clang\/gcc version check\n+#define PRAGMA_NONNULL_IGNORED PRAGMA_DISABLE_GCC_WARNING(\"-Wnonnull\")\n","filename":"src\/hotspot\/share\/utilities\/compilerWarnings_gcc.hpp","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-#define PRAGMA_DIAG_PUSH __pragma(warning(push))\n-#define PRAGMA_DIAG_POP  __pragma(warning(pop))\n+#define PRAGMA_DISABLE_MSVC_WARNING(num) _Pragma(STR(warning(disable : num)))\n@@ -31,1 +30,2 @@\n-#define PRAGMA_DISABLE_MSVC_WARNING(num) __pragma(warning(disable : num))\n+#define PRAGMA_DIAG_PUSH _Pragma(\"warning(push)\")\n+#define PRAGMA_DIAG_POP  _Pragma(\"warning(pop)\")\n","filename":"src\/hotspot\/share\/utilities\/compilerWarnings_visCPP.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1238,0 +1238,1 @@\n+\n@@ -1239,0 +1240,14 @@\n+\/\/\n+\/\/ C++14 5.8\/3: In the description of \"E1 >> E2\" it says \"If E1 has a signed type\n+\/\/ and a negative value, the resulting value is implementation-defined.\"\n+\/\/\n+\/\/ However, C++20 7.6.7\/3 further defines integral arithmetic, as part of\n+\/\/ requiring two's-complement behavior.\n+\/\/ https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p0907r3.html\n+\/\/ https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p1236r1.html\n+\/\/ The corresponding C++20 text is \"Right-shift on signed integral types is an\n+\/\/ arithmetic right shift, which performs sign-extension.\"\n+\/\/\n+\/\/ As discussed in the two's complement proposal, all known modern C++ compilers\n+\/\/ already behave that way. And it is unlikely any would go off and do something\n+\/\/ different now, with C++20 tightening things up.\n@@ -1269,0 +1284,32 @@\n+\/\/ Taken from rom section 8-2 of Henry S. Warren, Jr., Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174.\n+inline uint64_t multiply_high_unsigned(const uint64_t x, const uint64_t y) {\n+  const uint64_t x1 = x >> 32u;\n+  const uint64_t x2 = x & 0xFFFFFFFF;\n+  const uint64_t y1 = y >> 32u;\n+  const uint64_t y2 = y & 0xFFFFFFFF;\n+  const uint64_t z2 = x2 * y2;\n+  const uint64_t t = x1 * y2 + (z2 >> 32u);\n+  uint64_t z1 = t & 0xFFFFFFFF;\n+  const uint64_t z0 = t >> 32u;\n+  z1 += x2 * y1;\n+\n+  return x1 * y1 + z0 + (z1 >> 32u);\n+}\n+\n+\/\/ Taken from java.lang.Math::multiplyHigh which uses the technique from section 8-2 of Henry S. Warren, Jr.,\n+\/\/ Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174 but adapted for signed longs.\n+inline int64_t multiply_high_signed(const int64_t x, const int64_t y) {\n+  const jlong x1 = java_shift_right((jlong)x, 32);\n+  const jlong x2 = x & 0xFFFFFFFF;\n+  const jlong y1 = java_shift_right((jlong)y, 32);\n+  const jlong y2 = y & 0xFFFFFFFF;\n+\n+  const uint64_t z2 = x2 * y2;\n+  const int64_t t = x1 * y2 + (z2 >> 32u); \/\/ Unsigned shift\n+  int64_t z1 = t & 0xFFFFFFFF;\n+  const int64_t z0 = java_shift_right((jlong)t, 32);\n+  z1 += x2 * y1;\n+\n+  return x1 * y1 + z0 + java_shift_right((jlong)z1, 32);\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -257,1 +257,9 @@\n-    for (int i = 0, j = idx; j < length(); i++, j++) {\n+    remove_range(0, idx);\n+  }\n+\n+  \/\/ Remove all elements in the range [start - end). The order is preserved.\n+  void remove_range(int start, int end) {\n+    assert(0 <= start, \"illegal index\");\n+    assert(start < end && end <= _len, \"erase called with invalid range\");\n+\n+    for (int i = start, j = end; j < length(); i++, j++) {\n@@ -260,1 +268,1 @@\n-    trunc_to(length() - idx);\n+    trunc_to(length() - (end - start));\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n@@ -1747,3 +1748,13 @@\n-\/\/ Timeout handling: check if a timeout happened (either a single step did\n-\/\/ timeout or the whole of error reporting hit ErrorLogTimeout). Interrupt\n-\/\/ the reporting thread if that is the case.\n+\/\/ Fatal error handling is subject to several timeouts:\n+\/\/ - a global timeout (controlled via ErrorLogTimeout)\n+\/\/ - local error reporting step timeouts.\n+\/\/\n+\/\/ The latter aims to \"give the JVM a kick\" if it gets stuck in one particular place during\n+\/\/ error reporting. This prevents one error reporting step from hogging all the time allotted\n+\/\/ to error reporting under ErrorLogTimeout.\n+\/\/\n+\/\/ VMError::check_timeout() is called from the watcher thread and checks for either global\n+\/\/ or step timeout. If a timeout happened, we interrupt the reporting thread and set either\n+\/\/ _reporting_did_timeout or _step_did_timeout to signal which timeout fired. Function returns\n+\/\/ true if the *global* timeout fired, which will cause WatcherThread to shut down the JVM\n+\/\/ immediately.\n@@ -1752,0 +1763,4 @@\n+  \/\/ This function is supposed to be called from watcher thread during fatal error handling only.\n+  assert(VMError::is_error_reported(), \"Only call during error handling\");\n+  assert(Thread::current()->is_Watcher_thread(), \"Only call from watcher thread\");\n+\n@@ -1756,7 +1771,11 @@\n-  \/\/ Do not check for timeouts if we still have a message box to show to the\n-  \/\/ user or if there are OnError handlers to be run.\n-  if (ShowMessageBoxOnError\n-      || (OnError != nullptr && OnError[0] != '\\0')\n-      || Arguments::abort_hook() != nullptr) {\n-    return false;\n-  }\n+  \/\/ There are three situations where we suppress the *global* error timeout:\n+  \/\/ - if the JVM is embedded and the launcher has its abort hook installed.\n+  \/\/   That must be allowed to run.\n+  \/\/ - if the user specified one or more OnError commands to run, and these\n+  \/\/   did not yet run. These must have finished.\n+  \/\/ - if the user (typically developer) specified ShowMessageBoxOnError,\n+  \/\/   and the error box has not yet been shown\n+  const bool ignore_global_timeout =\n+      (ShowMessageBoxOnError\n+            || (OnError != nullptr && OnError[0] != '\\0')\n+            || Arguments::abort_hook() != nullptr);\n@@ -1764,1 +1783,0 @@\n-  const jlong reporting_start_time_l = get_reporting_start_time();\n@@ -1766,9 +1784,14 @@\n-  \/\/ Timestamp is stored in nanos.\n-  if (reporting_start_time_l > 0) {\n-    const jlong end = reporting_start_time_l + (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR;\n-    if (end <= now && !_reporting_did_timeout) {\n-      \/\/ We hit ErrorLogTimeout and we haven't interrupted the reporting\n-      \/\/ thread yet.\n-      _reporting_did_timeout = true;\n-      interrupt_reporting_thread();\n-      return true; \/\/ global timeout\n+\n+  \/\/ Global timeout hit?\n+  if (!ignore_global_timeout) {\n+    const jlong reporting_start_time = get_reporting_start_time();\n+    \/\/ Timestamp is stored in nanos.\n+    if (reporting_start_time > 0) {\n+      const jlong end = reporting_start_time + (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR;\n+      if (end <= now && !_reporting_did_timeout) {\n+        \/\/ We hit ErrorLogTimeout and we haven't interrupted the reporting\n+        \/\/ thread yet.\n+        _reporting_did_timeout = true;\n+        interrupt_reporting_thread();\n+        return true; \/\/ global timeout\n+      }\n@@ -1778,2 +1801,3 @@\n-  const jlong step_start_time_l = get_step_start_time();\n-  if (step_start_time_l > 0) {\n+  \/\/ Reporting step timeout?\n+  const jlong step_start_time = get_step_start_time();\n+  if (step_start_time > 0) {\n@@ -1783,1 +1807,3 @@\n-    const jlong end = step_start_time_l + (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR \/ 4;\n+    const int max_step_timeout_secs = 5;\n+    const jlong timeout_duration = MAX2((jlong)max_step_timeout_secs, (jlong)ErrorLogTimeout * TIMESTAMP_TO_SECONDS_FACTOR \/ 4);\n+    const jlong end = step_start_time + timeout_duration;\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":49,"deletions":23,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-        + \"BO\" + \"BOL\"  \/\/ Bolivia, Republic of\n+        + \"BO\" + \"BOL\"  \/\/ Bolivia, Plurinational State of\n@@ -295,1 +295,1 @@\n-        + \"ER\" + \"ERI\"  \/\/ Eritrea\n+        + \"ER\" + \"ERI\"  \/\/ Eritrea, State of\n@@ -299,1 +299,1 @@\n-        + \"FJ\" + \"FJI\"  \/\/ Fiji, Republic of the Fiji Islands\n+        + \"FJ\" + \"FJI\"  \/\/ Fiji, Republic of\n@@ -309,1 +309,1 @@\n-        + \"GG\" + \"GGY\"  \/\/ Guernsey\n+        + \"GG\" + \"GGY\"  \/\/ Guernsey, Bailiwick of\n@@ -328,1 +328,1 @@\n-        + \"HU\" + \"HUN\"  \/\/ Hungary, Hungarian People's Republic\n+        + \"HU\" + \"HUN\"  \/\/ Hungary\n@@ -339,1 +339,1 @@\n-        + \"JE\" + \"JEY\"  \/\/ Jersey\n+        + \"JE\" + \"JEY\"  \/\/ Jersey, Bailiwick of\n@@ -364,1 +364,1 @@\n-        + \"LY\" + \"LBY\"  \/\/ Libyan Arab Jamahiriya\n+        + \"LY\" + \"LBY\"  \/\/ Libya\n@@ -368,2 +368,2 @@\n-        + \"ME\" + \"MNE\"  \/\/ Montenegro, Republic of\n-        + \"MF\" + \"MAF\"  \/\/ Saint Martin\n+        + \"ME\" + \"MNE\"  \/\/ Montenegro\n+        + \"MF\" + \"MAF\"  \/\/ Saint Martin (French part)\n@@ -374,1 +374,1 @@\n-        + \"MM\" + \"MMR\"  \/\/ Myanmar\n+        + \"MM\" + \"MMR\"  \/\/ Myanmar, Republic of the Union of\n@@ -398,1 +398,1 @@\n-        + \"NU\" + \"NIU\"  \/\/ Niue, Republic of\n+        + \"NU\" + \"NIU\"  \/\/ Niue\n@@ -411,1 +411,1 @@\n-        + \"PS\" + \"PSE\"  \/\/ Palestinian Territory, Occupied\n+        + \"PS\" + \"PSE\"  \/\/ Palestine, State of\n@@ -424,1 +424,1 @@\n-        + \"SD\" + \"SDN\"  \/\/ Sudan, Democratic Republic of the\n+        + \"SD\" + \"SDN\"  \/\/ Sudan, Republic of the\n@@ -427,1 +427,1 @@\n-        + \"SH\" + \"SHN\"  \/\/ St. Helena\n+        + \"SH\" + \"SHN\"  \/\/ Saint Helena, Ascension and Tristan da Cunha\n@@ -436,1 +436,1 @@\n-        + \"SS\" + \"SSD\"  \/\/ South Sudan\n+        + \"SS\" + \"SSD\"  \/\/ South Sudan, Republic of\n","filename":"src\/java.base\/share\/classes\/java\/util\/LocaleISOData.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -36,0 +35,2 @@\n+import java.lang.invoke.VarHandle;\n+import java.lang.invoke.MethodHandles;\n@@ -367,1 +368,0 @@\n-        private final ConcurrentHashMap<ForEachOrderedTask<S, T>, ForEachOrderedTask<S, T>> completionMap;\n@@ -372,0 +372,11 @@\n+        private ForEachOrderedTask<S, T> next;\n+        private static final VarHandle NEXT;\n+        static {\n+            try {\n+                MethodHandles.Lookup l = MethodHandles.lookup();\n+                NEXT = l.findVarHandle(ForEachOrderedTask.class, \"next\", ForEachOrderedTask.class);\n+            } catch (Exception e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+\n@@ -379,2 +390,0 @@\n-            \/\/ Size map to avoid concurrent re-sizes\n-            this.completionMap = new ConcurrentHashMap<>(Math.max(16, AbstractTask.getLeafTarget() << 1));\n@@ -392,1 +401,0 @@\n-            this.completionMap = parent.completionMap;\n@@ -413,0 +421,4 @@\n+                \/\/ leftChild and rightChild were just created and not fork():ed\n+                \/\/ yet so no need for a volatile write\n+                leftChild.next = rightChild;\n+\n@@ -420,1 +432,0 @@\n-                task.completionMap.put(leftChild, rightChild);\n@@ -436,1 +447,1 @@\n-                    if (task.completionMap.replace(task.leftPredecessor, task, leftChild)) {\n+                    if (NEXT.compareAndSet(task.leftPredecessor, task, leftChild)) {\n@@ -502,1 +513,1 @@\n-            ForEachOrderedTask<S, T> leftDescendant = completionMap.remove(this);\n+            var leftDescendant = (ForEachOrderedTask<S, T>)NEXT.getAndSet(this, null);\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/ForEachOps.java","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-        return buildModule(moduleAttribute, List.of(), clb -> {});\n+        return buildModule(moduleAttribute, clb -> {});\n@@ -259,12 +259,0 @@\n-     * @param packages additional module packages\n-     * @return the classfile bytes\n-     *\/\n-    public static byte[] buildModule(ModuleAttribute moduleAttribute,\n-                                     List<PackageDesc> packages) {\n-        return buildModule(moduleAttribute, packages, clb -> {});\n-    }\n-\n-    \/**\n-     * Build a module descriptor into a byte array.\n-     * @param moduleAttribute the {@code Module} attribute\n-     * @param packages additional module packages\n@@ -275,1 +263,0 @@\n-                                     List<PackageDesc> packages,\n@@ -280,11 +267,0 @@\n-            if (!packages.isEmpty()) {\n-                var cp = clb.constantPool();\n-                var allPackages = new LinkedHashSet<PackageEntry>();\n-                for (var exp : moduleAttribute.exports()) allPackages.add(AbstractPoolEntry.maybeClone(cp, exp.exportedPackage()));\n-                for (var opn : moduleAttribute.opens()) allPackages.add(AbstractPoolEntry.maybeClone(cp, opn.openedPackage()));\n-                boolean emitMPA = false;\n-                for (var p : packages)\n-                    emitMPA |= allPackages.add(cp.packageEntry(p));\n-                if(emitMPA)\n-                    clb.with(new UnboundAttribute.UnboundModulePackagesAttribute(allPackages));\n-            }\n@@ -302,13 +278,1 @@\n-        buildModuleTo(path, moduleAttribute, List.of(), clb -> {});\n-    }\n-\n-    \/**\n-     * Build a module descriptor into a file.\n-     * @param path the file to write\n-     * @param moduleAttribute the {@code Module} attribute\n-     * @param packages additional module packages\n-     *\/\n-    public static void buildModuleTo(Path path,\n-                                     ModuleAttribute moduleAttribute,\n-                                     List<PackageDesc> packages) throws IOException {\n-        buildModuleTo(path, moduleAttribute, packages, clb -> {});\n+        buildModuleTo(path, moduleAttribute, clb -> {});\n@@ -321,1 +285,0 @@\n-     * @param packages additional module packages\n@@ -326,1 +289,0 @@\n-                                     List<PackageDesc> packages,\n@@ -328,1 +290,1 @@\n-        Files.write(path, buildModule(moduleAttribute, packages, handler));\n+        Files.write(path, buildModule(moduleAttribute, handler));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Classfile.java","additions":3,"deletions":41,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.invoke.TypeDescriptor;\n+\n@@ -53,2 +55,0 @@\n-    private static TypeKind[] newarraycodeToTypeTag;\n-\n@@ -105,7 +105,11 @@\n-        if (newarraycodeToTypeTag == null) {\n-            newarraycodeToTypeTag = new TypeKind[12];\n-            for (TypeKind tag : TypeKind.values()) {\n-                if (tag.newarraycode > 0) newarraycodeToTypeTag[tag.newarraycode] = tag;\n-            }\n-        }\n-        return newarraycodeToTypeTag[newarraycode];\n+        return switch (newarraycode) {\n+            case 4 -> TypeKind.BooleanType;\n+            case 5 -> TypeKind.CharType;\n+            case 6 -> TypeKind.FloatType;\n+            case 7 -> TypeKind.DoubleType;\n+            case 8 -> TypeKind.ByteType;\n+            case 9 -> TypeKind.ShortType;\n+            case 10 -> TypeKind.IntType;\n+            case 11 -> TypeKind.LongType;\n+            default -> throw new IllegalArgumentException(\"Bad new array code: \" + newarraycode);\n+        };\n@@ -130,1 +134,1 @@\n-            default -> throw new IllegalStateException(\"Bad type: \" + s);\n+            default -> throw new IllegalArgumentException(\"Bad type: \" + s);\n@@ -133,0 +137,8 @@\n+\n+    \/**\n+     * {@return the type kind associated with the specified field descriptor}\n+     * @param descriptor the field descriptor\n+     *\/\n+    public static TypeKind from(TypeDescriptor.OfField<?> descriptor) {\n+        return fromDescriptor(descriptor.descriptorString());\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/TypeKind.java","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -145,0 +145,13 @@\n+    \/**\n+     * {@return a {@code Module} attribute}\n+     *\n+     * @param moduleName the module name\n+     * @param attrHandler a handler that receives a {@link ModuleAttributeBuilder}\n+     *\/\n+    static ModuleAttribute of(ModuleEntry moduleName,\n+                              Consumer<ModuleAttributeBuilder> attrHandler) {\n+        var mb = new ModuleAttributeBuilderImpl(moduleName);\n+        attrHandler.accept(mb);\n+        return  mb.build();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/ModuleAttribute.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            fixed += TypeKind.fromDescriptor(param.descriptorString()).slotSize();\n+            fixed += TypeKind.from(param).slotSize();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/CodeLocalsShifter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-                    push(TypeKind.fromDescriptor(type.returnType().descriptorString()));\n+                    push(TypeKind.from(type.returnType()));\n@@ -244,1 +244,1 @@\n-                    push(TypeKind.fromDescriptor(type.returnType().descriptorString()));\n+                    push(TypeKind.from(type.returnType()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/CodeStackTracker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-                                                    var tk = TypeKind.fromDescriptor(pt.descriptorString());\n+                                                    var tk = TypeKind.from(pt);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/snippet-files\/PackageSnippets.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-    public ModuleAttributeBuilderImpl(ModuleDesc moduleName) {\n-        this.moduleEntry = TemporaryConstantPool.INSTANCE.moduleEntry(TemporaryConstantPool.INSTANCE.utf8Entry(moduleName.moduleName()));\n+    public ModuleAttributeBuilderImpl(ModuleEntry moduleName) {\n+        this.moduleEntry = moduleName;\n@@ -57,0 +57,4 @@\n+    public ModuleAttributeBuilderImpl(ModuleDesc moduleName) {\n+        this(TemporaryConstantPool.INSTANCE.moduleEntry(TemporaryConstantPool.INSTANCE.utf8Entry(moduleName.moduleName())));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ModuleAttributeBuilderImpl.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -270,1 +270,1 @@\n-                                                    var tk = TypeKind.fromDescriptor(pt.descriptorString());\n+                                                    var tk = TypeKind.from(pt);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/snippet-files\/PackageSnippets.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,16 +197,1 @@\n-public interface Binding {\n-\n-    enum Tag {\n-        VM_STORE,\n-        VM_LOAD,\n-        BUFFER_STORE,\n-        BUFFER_LOAD,\n-        COPY_BUFFER,\n-        ALLOC_BUFFER,\n-        BOX_ADDRESS,\n-        UNBOX_ADDRESS,\n-        DUP,\n-        CAST\n-    }\n-\n-    Tag tag();\n+public sealed interface Binding {\n@@ -410,1 +395,1 @@\n-    interface Move extends Binding {\n+    sealed interface Move extends Binding {\n@@ -421,4 +406,0 @@\n-        @Override\n-        public Tag tag() {\n-            return Tag.VM_STORE;\n-        }\n@@ -446,4 +427,0 @@\n-        @Override\n-        public Tag tag() {\n-            return Tag.VM_LOAD;\n-        }\n@@ -463,1 +440,1 @@\n-    interface Dereference extends Binding {\n+    sealed interface Dereference extends Binding {\n@@ -475,4 +452,0 @@\n-        @Override\n-        public Tag tag() {\n-            return Tag.BUFFER_STORE;\n-        }\n@@ -536,4 +509,0 @@\n-        @Override\n-        public Tag tag() {\n-            return Tag.BUFFER_LOAD;\n-        }\n@@ -600,5 +569,0 @@\n-        @Override\n-        public Tag tag() {\n-            return Tag.COPY_BUFFER;\n-        }\n-\n@@ -630,5 +594,0 @@\n-        @Override\n-        public Tag tag() {\n-            return Tag.ALLOC_BUFFER;\n-        }\n-\n@@ -655,5 +614,0 @@\n-        @Override\n-        public Tag tag() {\n-            return Tag.UNBOX_ADDRESS;\n-        }\n-\n@@ -681,5 +635,0 @@\n-        @Override\n-        public Tag tag() {\n-            return Tag.BOX_ADDRESS;\n-        }\n-\n@@ -712,5 +661,0 @@\n-        @Override\n-        public Tag tag() {\n-            return Tag.DUP;\n-        }\n-\n@@ -770,5 +714,0 @@\n-        @Override\n-        public Tag tag() {\n-            return Tag.CAST;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":4,"deletions":65,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,10 @@\n+import jdk.internal.foreign.abi.Binding.Allocate;\n+import jdk.internal.foreign.abi.Binding.BoxAddress;\n+import jdk.internal.foreign.abi.Binding.BufferLoad;\n+import jdk.internal.foreign.abi.Binding.BufferStore;\n+import jdk.internal.foreign.abi.Binding.Cast;\n+import jdk.internal.foreign.abi.Binding.Copy;\n+import jdk.internal.foreign.abi.Binding.Dup;\n+import jdk.internal.foreign.abi.Binding.UnboxAddress;\n+import jdk.internal.foreign.abi.Binding.VMLoad;\n+import jdk.internal.foreign.abi.Binding.VMStore;\n@@ -423,3 +433,3 @@\n-                .filter(Binding.BoxAddress.class::isInstance)\n-                .map(Binding.BoxAddress.class::cast)\n-                .anyMatch(Binding.BoxAddress::needsScope);\n+                .filter(BoxAddress.class::isInstance)\n+                .map(BoxAddress.class::cast)\n+                .anyMatch(BoxAddress::needsScope);\n@@ -453,11 +463,11 @@\n-            switch (binding.tag()) {\n-                case VM_STORE -> emitVMStore((Binding.VMStore) binding);\n-                case VM_LOAD -> emitVMLoad((Binding.VMLoad) binding);\n-                case BUFFER_STORE -> emitBufferStore((Binding.BufferStore) binding);\n-                case BUFFER_LOAD -> emitBufferLoad((Binding.BufferLoad) binding);\n-                case COPY_BUFFER -> emitCopyBuffer((Binding.Copy) binding);\n-                case ALLOC_BUFFER -> emitAllocBuffer((Binding.Allocate) binding);\n-                case BOX_ADDRESS -> emitBoxAddress((Binding.BoxAddress) binding);\n-                case UNBOX_ADDRESS -> emitUnboxAddress();\n-                case DUP -> emitDupBinding();\n-                case CAST -> emitCast((Binding.Cast) binding);\n+            switch (binding) {\n+                case VMStore vmStore         -> emitVMStore(vmStore);\n+                case VMLoad vmLoad           -> emitVMLoad(vmLoad);\n+                case BufferStore bufferStore -> emitBufferStore(bufferStore);\n+                case BufferLoad bufferLoad   -> emitBufferLoad(bufferLoad);\n+                case Copy copy               -> emitCopyBuffer(copy);\n+                case Allocate allocate       -> emitAllocBuffer(allocate);\n+                case BoxAddress boxAddress   -> emitBoxAddress(boxAddress);\n+                case UnboxAddress unused     -> emitUnboxAddress();\n+                case Dup unused              -> emitDupBinding();\n+                case Cast cast               -> emitCast(cast);\n@@ -567,1 +577,1 @@\n-    private void emitBoxAddress(Binding.BoxAddress boxAddress) {\n+    private void emitBoxAddress(BoxAddress boxAddress) {\n@@ -580,1 +590,1 @@\n-    private void emitAllocBuffer(Binding.Allocate binding) {\n+    private void emitAllocBuffer(Allocate binding) {\n@@ -591,1 +601,1 @@\n-    private void emitBufferStore(Binding.BufferStore bufferStore) {\n+    private void emitBufferStore(BufferStore bufferStore) {\n@@ -627,1 +637,1 @@\n-                    case 4 -> {\n+                    case Integer.BYTES -> {\n@@ -631,1 +641,1 @@\n-                    case 2 -> {\n+                    case Short.BYTES -> {\n@@ -635,1 +645,1 @@\n-                    case 1 -> {\n+                    case Byte.BYTES -> {\n@@ -673,1 +683,1 @@\n-    private void emitVMStore(Binding.VMStore vmStore) {\n+    private void emitVMStore(VMStore vmStore) {\n@@ -700,1 +710,1 @@\n-    private void emitVMLoad(Binding.VMLoad vmLoad) {\n+    private void emitVMLoad(VMLoad vmLoad) {\n@@ -729,1 +739,1 @@\n-    private void emitCast(Binding.Cast cast) {\n+    private void emitCast(Cast cast) {\n@@ -762,1 +772,1 @@\n-    private void emitBufferLoad(Binding.BufferLoad bufferLoad) {\n+    private void emitBufferLoad(BufferLoad bufferLoad) {\n@@ -791,1 +801,1 @@\n-                    case 4 -> {\n+                    case Integer.BYTES -> {\n@@ -796,1 +806,1 @@\n-                    case 2 -> {\n+                    case Short.BYTES -> {\n@@ -801,1 +811,1 @@\n-                    case 1 -> {\n+                    case Byte.BYTES -> {\n@@ -844,1 +854,1 @@\n-    private void emitCopyBuffer(Binding.Copy copy) {\n+    private void emitCopyBuffer(Copy copy) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":39,"deletions":29,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,10 @@\n+import jdk.internal.foreign.abi.Binding.Allocate;\n+import jdk.internal.foreign.abi.Binding.BoxAddress;\n+import jdk.internal.foreign.abi.Binding.BufferLoad;\n+import jdk.internal.foreign.abi.Binding.BufferStore;\n+import jdk.internal.foreign.abi.Binding.Cast;\n+import jdk.internal.foreign.abi.Binding.Copy;\n+import jdk.internal.foreign.abi.Binding.Dup;\n+import jdk.internal.foreign.abi.Binding.UnboxAddress;\n+import jdk.internal.foreign.abi.Binding.VMLoad;\n+import jdk.internal.foreign.abi.Binding.VMStore;\n@@ -38,1 +48,0 @@\n-import java.util.EnumSet;\n@@ -40,1 +49,0 @@\n-import java.util.Set;\n@@ -43,1 +51,0 @@\n-import static jdk.internal.foreign.abi.Binding.Tag.*;\n@@ -95,1 +102,1 @@\n-        long returnBufferSize = needsReturnBuffer ? computeReturnBuferSize() : 0;\n+        long returnBufferSize = needsReturnBuffer ? computeReturnBufferSize() : 0;\n@@ -131,1 +138,1 @@\n-        return computeTypeHelper(Binding.VMLoad.class, Binding.VMStore.class);\n+        return computeTypeHelper(VMLoad.class, VMStore.class);\n@@ -135,1 +142,1 @@\n-        return computeTypeHelper(Binding.VMStore.class, Binding.VMLoad.class);\n+        return computeTypeHelper(VMStore.class, VMLoad.class);\n@@ -162,1 +169,1 @@\n-                if (b instanceof Binding.Copy copy) {\n+                if (b instanceof Copy copy) {\n@@ -165,1 +172,1 @@\n-                } else if (b instanceof Binding.Allocate allocate) {\n+                } else if (b instanceof Allocate allocate) {\n@@ -174,1 +181,1 @@\n-    private long computeReturnBuferSize() {\n+    private long computeReturnBufferSize() {\n@@ -194,13 +201,0 @@\n-    private static final Set<Binding.Tag> UNBOX_TAGS = EnumSet.of(\n-        VM_STORE,\n-        \/\/VM_LOAD,\n-        \/\/BUFFER_STORE,\n-        BUFFER_LOAD,\n-        COPY_BUFFER,\n-        \/\/ALLOC_BUFFER,\n-        \/\/BOX_ADDRESS,\n-        UNBOX_ADDRESS,\n-        DUP,\n-        CAST\n-    );\n-\n@@ -212,1 +206,1 @@\n-            if (!UNBOX_TAGS.contains(b.tag()))\n+            if (!isUnbox(b))\n@@ -222,12 +216,15 @@\n-    private static final Set<Binding.Tag> BOX_TAGS = EnumSet.of(\n-        \/\/VM_STORE,\n-        VM_LOAD,\n-        BUFFER_STORE,\n-        \/\/BUFFER_LOAD,\n-        COPY_BUFFER,\n-        ALLOC_BUFFER,\n-        BOX_ADDRESS,\n-        \/\/UNBOX_ADDRESS,\n-        DUP,\n-        CAST\n-    );\n+    static boolean isUnbox(Binding binding) {\n+        return switch (binding) {\n+            case VMStore      unused -> true;\n+            case BufferLoad   unused -> true;\n+            case Copy         unused -> true;\n+            case UnboxAddress unused -> true;\n+            case Dup          unused -> true;\n+            case Cast         unused -> true;\n+\n+            case VMLoad       unused -> false;\n+            case BufferStore  unused -> false;\n+            case Allocate     unused -> false;\n+            case BoxAddress   unused -> false;\n+        };\n+    }\n@@ -239,1 +236,1 @@\n-            if (!BOX_TAGS.contains(b.tag()))\n+            if (!isBox(b))\n@@ -251,0 +248,17 @@\n+\n+    static boolean isBox(Binding binding) {\n+        return switch (binding) {\n+            case VMLoad       unused -> true;\n+            case BufferStore  unused -> true;\n+            case Copy         unused -> true;\n+            case Allocate     unused -> true;\n+            case BoxAddress   unused -> true;\n+            case Dup          unused -> true;\n+            case Cast         unused -> true;\n+\n+            case VMStore      unused -> false;\n+            case BufferLoad   unused -> false;\n+            case UnboxAddress unused -> false;\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":51,"deletions":37,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,3 +52,3 @@\n-        switch (cls) {\n-            case StorageType.INTEGER: return INTEGER_REG_SIZE;\n-            case StorageType.VECTOR: return VECTOR_REG_SIZE;\n+        return switch (cls) {\n+            case StorageType.INTEGER -> INTEGER_REG_SIZE;\n+            case StorageType.VECTOR -> VECTOR_REG_SIZE;\n@@ -56,3 +56,2 @@\n-        }\n-\n-        throw new IllegalArgumentException(\"Invalid Storage Class: \" + cls);\n+            default -> throw new IllegalArgumentException(\"Invalid Storage Class: \" + cls);\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,3 +51,3 @@\n-        switch (cls) {\n-            case StorageType.INTEGER: return INTEGER_REG_SIZE;\n-            case StorageType.FLOAT: return FLOAT_REG_SIZE;\n+        return switch (cls) {\n+            case StorageType.INTEGER -> INTEGER_REG_SIZE;\n+            case StorageType.FLOAT   -> FLOAT_REG_SIZE;\n@@ -55,3 +55,2 @@\n-        }\n-\n-        throw new IllegalArgumentException(\"Invalid Storage Class: \" + cls);\n+            default -> throw new IllegalArgumentException(\"Invalid Storage Class: \" + cls);\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/RISCV64Architecture.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-                        bindings.bufferLoad(offset, type)\n+                        bindings.bufferLoad(offset, type, (int) copy)\n@@ -416,1 +416,1 @@\n-                                .bufferStore(offset, type);\n+                                .bufferStore(offset, type, (int) copy);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,12 +86,16 @@\n-            if (layout instanceof ValueLayout valueLayout) {\n-                return switch (classifyValueType(valueLayout)) {\n-                    case INTEGER -> FieldCounter.SINGLE_INTEGER;\n-                    case FLOAT -> FieldCounter.SINGLE_FLOAT;\n-                    case POINTER -> FieldCounter.SINGLE_POINTER;\n-                    default -> throw new IllegalStateException(\"Should not reach here.\");\n-                };\n-            } else if (layout instanceof GroupLayout groupLayout) {\n-                FieldCounter currCounter = FieldCounter.EMPTY;\n-                for (MemoryLayout memberLayout : groupLayout.memberLayouts()) {\n-                    if (memberLayout instanceof PaddingLayout) {\n-                        continue;\n+            switch (layout) {\n+                case ValueLayout valueLayout -> {\n+                    return switch (classifyValueType(valueLayout)) {\n+                        case INTEGER -> FieldCounter.SINGLE_INTEGER;\n+                        case FLOAT   -> FieldCounter.SINGLE_FLOAT;\n+                        case POINTER -> FieldCounter.SINGLE_POINTER;\n+                        default -> throw new IllegalStateException(\"Should not reach here.\");\n+                    };\n+                }\n+                case GroupLayout groupLayout -> {\n+                    FieldCounter currCounter = FieldCounter.EMPTY;\n+                    for (MemoryLayout memberLayout : groupLayout.memberLayouts()) {\n+                        if (memberLayout instanceof PaddingLayout) {\n+                            continue;\n+                        }\n+                        currCounter = currCounter.add(flatten(memberLayout));\n@@ -99,1 +103,1 @@\n-                    currCounter = currCounter.add(flatten(memberLayout));\n+                    return currCounter;\n@@ -101,5 +105,6 @@\n-                return currCounter;\n-            } else if (layout instanceof SequenceLayout sequenceLayout) {\n-                long elementCount = sequenceLayout.elementCount();\n-                if (elementCount == 0) {\n-                    return FieldCounter.EMPTY;\n+                case SequenceLayout sequenceLayout -> {\n+                    long elementCount = sequenceLayout.elementCount();\n+                    if (elementCount == 0) {\n+                        return FieldCounter.EMPTY;\n+                    }\n+                    return flatten(sequenceLayout.elementLayout()).mul(elementCount);\n@@ -107,3 +112,1 @@\n-                return flatten(sequenceLayout.elementLayout()).mul(elementCount);\n-            } else {\n-                throw new IllegalStateException(\"Cannot get here: \" + layout);\n+                default -> throw new IllegalStateException(\"Cannot get here: \" + layout);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/TypeClass.java","additions":25,"deletions":22,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,4 +61,4 @@\n-        switch (cls) {\n-            case StorageType.INTEGER: return INTEGER_REG_SIZE;\n-            case StorageType.VECTOR: return VECTOR_REG_SIZE;\n-            case StorageType.X87: return X87_REG_SIZE;\n+        return switch (cls) {\n+            case StorageType.INTEGER -> INTEGER_REG_SIZE;\n+            case StorageType.VECTOR  -> VECTOR_REG_SIZE;\n+            case StorageType.X87     -> X87_REG_SIZE;\n@@ -66,3 +66,2 @@\n-        }\n-\n-        throw new IllegalArgumentException(\"Invalid Storage Class: \" +cls);\n+            default -> throw new IllegalArgumentException(\"Invalid Storage Class: \" +cls);\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-                forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true);\n+                    forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true);\n@@ -92,1 +92,1 @@\n-                forUpcall ? new UnboxBindingCalculator(false) : new BoxBindingCalculator(false);\n+                    forUpcall ? new UnboxBindingCalculator(false) : new BoxBindingCalculator(false);\n@@ -172,1 +172,1 @@\n-                 [type][nRegs++];\n+                    [type][nRegs++];\n@@ -197,1 +197,1 @@\n-                case STRUCT_REGISTER: {\n+                case STRUCT_REGISTER -> {\n@@ -203,1 +203,0 @@\n-                    break;\n@@ -205,1 +204,1 @@\n-                case STRUCT_REFERENCE: {\n+                case STRUCT_REFERENCE -> {\n@@ -211,1 +210,0 @@\n-                    break;\n@@ -213,1 +211,1 @@\n-                case POINTER: {\n+                case POINTER -> {\n@@ -217,1 +215,0 @@\n-                    break;\n@@ -219,1 +216,1 @@\n-                case INTEGER: {\n+                case INTEGER -> {\n@@ -222,1 +219,0 @@\n-                    break;\n@@ -224,1 +220,1 @@\n-                case FLOAT: {\n+                case FLOAT -> {\n@@ -227,1 +223,0 @@\n-                    break;\n@@ -229,1 +224,1 @@\n-                case VARARG_FLOAT: {\n+                case VARARG_FLOAT -> {\n@@ -238,1 +233,0 @@\n-                    break;\n@@ -240,2 +234,1 @@\n-                default:\n-                    throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n+                default -> throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n@@ -259,1 +252,1 @@\n-                case STRUCT_REGISTER: {\n+                case STRUCT_REGISTER -> {\n@@ -267,1 +260,0 @@\n-                    break;\n@@ -269,1 +261,1 @@\n-                case STRUCT_REFERENCE: {\n+                case STRUCT_REFERENCE -> {\n@@ -274,1 +266,0 @@\n-                    break;\n@@ -276,1 +267,1 @@\n-                case POINTER: {\n+                case POINTER -> {\n@@ -281,1 +272,0 @@\n-                    break;\n@@ -283,1 +273,1 @@\n-                case INTEGER: {\n+                case INTEGER -> {\n@@ -286,1 +276,0 @@\n-                    break;\n@@ -288,1 +277,1 @@\n-                case FLOAT: {\n+                case FLOAT -> {\n@@ -291,1 +280,0 @@\n-                    break;\n@@ -293,2 +281,1 @@\n-                default:\n-                    throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n+                default -> throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":16,"deletions":29,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -32,1 +33,0 @@\n-import java.util.ArrayList;\n@@ -36,0 +36,11 @@\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleHashInfo;\n+import jdk.internal.classfile.attribute.ModuleHashesAttribute;\n+import jdk.internal.classfile.attribute.ModuleMainClassAttribute;\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n+import jdk.internal.classfile.attribute.ModuleResolutionAttribute;\n+import jdk.internal.classfile.attribute.ModuleTargetAttribute;\n+import jdk.internal.classfile.java.lang.constant.ModuleDesc;\n+import jdk.internal.classfile.java.lang.constant.PackageDesc;\n@@ -37,9 +48,0 @@\n-import jdk.internal.org.objectweb.asm.Attribute;\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ModuleVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.commons.ModuleHashesAttribute;\n-import jdk.internal.org.objectweb.asm.commons.ModuleResolutionAttribute;\n-import jdk.internal.org.objectweb.asm.commons.ModuleTargetAttribute;\n@@ -151,38 +153,6 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                         + ClassWriter.COMPUTE_FRAMES);\n-\n-        ClassReader cr = new ClassReader(in);\n-\n-        ClassVisitor cv = new ClassVisitor(Opcodes.ASM7, cw) {\n-            @Override\n-            public ModuleVisitor visitModule(String name, int flags, String version) {\n-                Version v = ModuleInfoExtender.this.version;\n-                String vs = (v != null) ? v.toString() : version;\n-                ModuleVisitor mv = super.visitModule(name, flags, vs);\n-\n-                \/\/ ModuleMainClass attribute\n-                if (mainClass != null) {\n-                    mv.visitMainClass(mainClass.replace('.', '\/'));\n-                }\n-\n-                \/\/ ModulePackages attribute\n-                if (packages != null) {\n-                    packages.stream()\n-                            .sorted()\n-                            .forEach(pn -> mv.visitPackage(pn.replace('.', '\/')));\n-                }\n-\n-                return new ModuleVisitor(Opcodes.ASM7, mv) {\n-                    public void visitMainClass(String existingMainClass) {\n-                        \/\/ skip main class if there is a new value\n-                        if (mainClass == null) {\n-                            super.visitMainClass(existingMainClass);\n-                        }\n-                    }\n-                    public void visitPackage(String existingPackage) {\n-                        \/\/ skip packages if there is a new set of packages\n-                        if (packages == null) {\n-                            super.visitPackage(existingPackage);\n-                        }\n-                    }\n-                };\n+        var cm = Classfile.parse(in.readAllBytes());\n+        Version v = ModuleInfoExtender.this.version;\n+        return cm.transform(ClassTransform.endHandler(clb -> {\n+            \/\/ ModuleMainClass attribute\n+            if (mainClass != null) {\n+                clb.with(ModuleMainClassAttribute.of(ClassDesc.of(mainClass)));\n@@ -190,15 +160,0 @@\n-            @Override\n-            public void visitAttribute(Attribute attr) {\n-                String name = attr.type;\n-                \/\/ drop existing attributes if there are replacements\n-                if (name.equals(ClassFileConstants.MODULE_TARGET)\n-                    && targetPlatform != null)\n-                    return;\n-                if (name.equals(ClassFileConstants.MODULE_RESOLUTION)\n-                    && moduleResolution != null)\n-                    return;\n-                if (name.equals(ClassFileConstants.MODULE_HASHES)\n-                    && hashes != null)\n-                    return;\n-\n-                super.visitAttribute(attr);\n@@ -206,0 +161,7 @@\n+            \/\/ ModulePackages attribute\n+            if (packages != null) {\n+                List<PackageDesc> packageNames = packages.stream()\n+                        .sorted()\n+                        .map(PackageDesc::of)\n+                        .toList();\n+                clb.with(ModulePackagesAttribute.ofNames(packageNames));\n@@ -207,26 +169,0 @@\n-        };\n-\n-        List<Attribute> attrs = new ArrayList<>();\n-        attrs.add(new ModuleTargetAttribute());\n-        attrs.add(new ModuleResolutionAttribute());\n-        attrs.add(new ModuleHashesAttribute());\n-        cr.accept(cv, attrs.toArray(new Attribute[0]), 0);\n-\n-        \/\/ add ModuleTarget, ModuleResolution and ModuleHashes attributes\n-        if (targetPlatform != null) {\n-            cw.visitAttribute(new ModuleTargetAttribute(targetPlatform));\n-        }\n-        if (moduleResolution != null) {\n-            int flags = moduleResolution.value();\n-            cw.visitAttribute(new ModuleResolutionAttribute(flags));\n-        }\n-        if (hashes != null) {\n-            String algorithm = hashes.algorithm();\n-            List<String> names = new ArrayList<>();\n-            List<byte[]> values = new ArrayList<>();\n-            for (String name : hashes.names()) {\n-                names.add(name);\n-                values.add(hashes.hashFor(name));\n-            }\n-            cw.visitAttribute(new ModuleHashesAttribute(algorithm, names, values));\n-        }\n@@ -234,1 +170,30 @@\n-        return cw.toByteArray();\n+            \/\/ ModuleTarget, ModuleResolution and ModuleHashes attributes\n+            if (targetPlatform != null) {\n+                clb.with(ModuleTargetAttribute.of(targetPlatform));\n+            }\n+            if (moduleResolution != null) {\n+                clb.with(ModuleResolutionAttribute.of(moduleResolution.value()));\n+            }\n+            if (hashes != null) {\n+                clb.with(ModuleHashesAttribute.of(\n+                        hashes.algorithm(),\n+                        hashes.hashes().entrySet().stream().map(he ->\n+                                ModuleHashInfo.of(ModuleDesc.of(\n+                                        he.getKey()),\n+                                        he.getValue())).toList()));\n+            }\n+        }).andThen((clb, cle) -> {\n+            if (v != null && cle instanceof ModuleAttribute ma) {\n+                clb.with(ModuleAttribute.of(\n+                        ma.moduleName(),\n+                        ma.moduleFlagsMask(),\n+                        clb.constantPool().utf8Entry(v.toString()),\n+                        ma.requires(),\n+                        ma.exports(),\n+                        ma.opens(),\n+                        ma.uses(),\n+                        ma.provides()));\n+            } else {\n+                clb.accept(cle);\n+            }\n+        }));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleInfoExtender.java","additions":55,"deletions":90,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -30,0 +31,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -32,8 +34,11 @@\n-import java.util.stream.Stream;\n-\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ModuleVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.commons.ModuleResolutionAttribute;\n-import jdk.internal.org.objectweb.asm.commons.ModuleTargetAttribute;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.java.lang.constant.PackageDesc;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleExportInfo;\n+import jdk.internal.classfile.attribute.ModuleMainClassAttribute;\n+import jdk.internal.classfile.attribute.ModuleOpenInfo;\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n+import jdk.internal.classfile.attribute.ModuleResolutionAttribute;\n+import jdk.internal.classfile.attribute.ModuleRequireInfo;\n+import jdk.internal.classfile.attribute.ModuleTargetAttribute;\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n@@ -49,3 +54,3 @@\n-            ModuleDescriptor.Modifier.OPEN, ACC_OPEN,\n-            ModuleDescriptor.Modifier.SYNTHETIC, ACC_SYNTHETIC,\n-            ModuleDescriptor.Modifier.MANDATED, ACC_MANDATED\n+            ModuleDescriptor.Modifier.OPEN, Classfile.ACC_OPEN,\n+            ModuleDescriptor.Modifier.SYNTHETIC, Classfile.ACC_SYNTHETIC,\n+            ModuleDescriptor.Modifier.MANDATED, Classfile.ACC_MANDATED\n@@ -56,4 +61,4 @@\n-            ModuleDescriptor.Requires.Modifier.TRANSITIVE, ACC_TRANSITIVE,\n-            ModuleDescriptor.Requires.Modifier.STATIC, ACC_STATIC_PHASE,\n-            ModuleDescriptor.Requires.Modifier.SYNTHETIC, ACC_SYNTHETIC,\n-            ModuleDescriptor.Requires.Modifier.MANDATED, ACC_MANDATED\n+            ModuleDescriptor.Requires.Modifier.TRANSITIVE, Classfile.ACC_TRANSITIVE,\n+            ModuleDescriptor.Requires.Modifier.STATIC, Classfile.ACC_STATIC_PHASE,\n+            ModuleDescriptor.Requires.Modifier.SYNTHETIC, Classfile.ACC_SYNTHETIC,\n+            ModuleDescriptor.Requires.Modifier.MANDATED, Classfile.ACC_MANDATED\n@@ -64,2 +69,2 @@\n-            ModuleDescriptor.Exports.Modifier.SYNTHETIC, ACC_SYNTHETIC,\n-            ModuleDescriptor.Exports.Modifier.MANDATED, ACC_MANDATED\n+            ModuleDescriptor.Exports.Modifier.SYNTHETIC, Classfile.ACC_SYNTHETIC,\n+            ModuleDescriptor.Exports.Modifier.MANDATED, Classfile.ACC_MANDATED\n@@ -70,2 +75,2 @@\n-            ModuleDescriptor.Opens.Modifier.SYNTHETIC, ACC_SYNTHETIC,\n-            ModuleDescriptor.Opens.Modifier.MANDATED, ACC_MANDATED\n+            ModuleDescriptor.Opens.Modifier.SYNTHETIC, Classfile.ACC_SYNTHETIC,\n+            ModuleDescriptor.Opens.Modifier.MANDATED, Classfile.ACC_MANDATED\n@@ -74,2 +79,0 @@\n-    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n-\n@@ -85,80 +88,80 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(Opcodes.V10, ACC_MODULE, \"module-info\", null, null, null);\n-\n-        int moduleFlags = md.modifiers().stream()\n-                .map(MODULE_MODS_TO_FLAGS::get)\n-                .reduce(0, (x, y) -> (x | y));\n-        String vs = md.rawVersion().orElse(null);\n-        ModuleVisitor mv = cw.visitModule(md.name(), moduleFlags, vs);\n-\n-        \/\/ requires\n-        for (ModuleDescriptor.Requires r : md.requires()) {\n-            int flags = r.modifiers().stream()\n-                    .map(REQUIRES_MODS_TO_FLAGS::get)\n-                    .reduce(0, (x, y) -> (x | y));\n-            vs = r.rawCompiledVersion().orElse(null);\n-            mv.visitRequire(r.name(), flags, vs);\n-        }\n-\n-        \/\/ exports\n-        for (ModuleDescriptor.Exports e : md.exports()) {\n-            int flags = e.modifiers().stream()\n-                    .map(EXPORTS_MODS_TO_FLAGS::get)\n-                    .reduce(0, (x, y) -> (x | y));\n-            String[] targets = e.targets().toArray(EMPTY_STRING_ARRAY);\n-            mv.visitExport(e.source().replace('.', '\/'), flags, targets);\n-        }\n-\n-        \/\/ opens\n-        for (ModuleDescriptor.Opens opens : md.opens()) {\n-            int flags = opens.modifiers().stream()\n-                    .map(OPENS_MODS_TO_FLAGS::get)\n-                    .reduce(0, (x, y) -> (x | y));\n-            String[] targets = opens.targets().toArray(EMPTY_STRING_ARRAY);\n-            mv.visitOpen(opens.source().replace('.', '\/'), flags, targets);\n-        }\n-\n-        \/\/ uses\n-        md.uses().stream().map(sn -> sn.replace('.', '\/')).forEach(mv::visitUse);\n-\n-        \/\/ provides\n-        for (ModuleDescriptor.Provides p : md.provides()) {\n-            mv.visitProvide(p.service().replace('.', '\/'),\n-                            p.providers()\n-                                .stream()\n-                                .map(pn -> pn.replace('.', '\/'))\n-                                .toArray(String[]::new));\n-        }\n-\n-        \/\/ add the ModulePackages attribute when there are packages that aren't\n-        \/\/ exported or open\n-        Stream<String> exported = md.exports().stream()\n-                .map(ModuleDescriptor.Exports::source);\n-        Stream<String> open = md.opens().stream()\n-                .map(ModuleDescriptor.Opens::source);\n-        long exportedOrOpen = Stream.concat(exported, open).distinct().count();\n-        if (md.packages().size() > exportedOrOpen) {\n-            md.packages().stream()\n-                    .map(pn -> pn.replace('.', '\/'))\n-                    .forEach(mv::visitPackage);\n-        }\n-\n-        \/\/ ModuleMainClass attribute\n-        md.mainClass()\n-            .map(mc -> mc.replace('.', '\/'))\n-            .ifPresent(mv::visitMainClass);\n-\n-        mv.visitEnd();\n-\n-        \/\/ write ModuleResolution attribute if specified\n-        if (mres != null) {\n-            cw.visitAttribute(new ModuleResolutionAttribute(mres.value()));\n-        }\n-\n-        \/\/ write ModuleTarget attribute if there is a target platform\n-        if (target != null && target.targetPlatform().length() > 0) {\n-            cw.visitAttribute(new ModuleTargetAttribute(target.targetPlatform()));\n-        }\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        \/\/using low-level module building to avoid validation in ModuleDesc and allow invalid names\n+        return Classfile.build(ClassDesc.of(\"module-info\"), clb -> {\n+            clb.withFlags(AccessFlag.MODULE);\n+            var cp = clb.constantPool();\n+            clb.with(ModuleAttribute.of(cp.moduleEntry(cp.utf8Entry(md.name())), mb -> {\n+                    mb.moduleFlags(md.modifiers().stream()\n+                            .mapToInt(mm -> MODULE_MODS_TO_FLAGS.getOrDefault(mm, 0))\n+                            .reduce(0, (x, y) -> (x | y)));\n+\n+                    md.rawVersion().ifPresent(vs -> mb.moduleVersion(vs));\n+\n+                    \/\/ requires\n+                    for (ModuleDescriptor.Requires r : md.requires()) {\n+                        int flags = r.modifiers().stream()\n+                                .mapToInt(REQUIRES_MODS_TO_FLAGS::get)\n+                                .reduce(0, (x, y) -> (x | y));\n+                        mb.requires(ModuleRequireInfo.of(\n+                                cp.moduleEntry(cp.utf8Entry(r.name())),\n+                                flags,\n+                                r.rawCompiledVersion().map(cp::utf8Entry).orElse(null)));\n+                    }\n+\n+                    \/\/ exports\n+                    for (ModuleDescriptor.Exports e : md.exports()) {\n+                        int flags = e.modifiers().stream()\n+                                .mapToInt(EXPORTS_MODS_TO_FLAGS::get)\n+                                .reduce(0, (x, y) -> (x | y));\n+                        var targets = e.targets().stream().map(mn -> cp.moduleEntry(cp.utf8Entry(mn)))\n+                                .toArray(ModuleEntry[]::new);\n+                        mb.exports(ModuleExportInfo.of(\n+                                cp.packageEntry(cp.utf8Entry(e.source())),\n+                                flags,\n+                                targets));\n+                    }\n+\n+                    \/\/ opens\n+                    for (ModuleDescriptor.Opens opens : md.opens()) {\n+                        int flags = opens.modifiers().stream()\n+                                .mapToInt(OPENS_MODS_TO_FLAGS::get)\n+                                .reduce(0, (x, y) -> (x | y));\n+                        var targets = opens.targets().stream().map(mn -> cp.moduleEntry(cp.utf8Entry(mn)))\n+                                .toArray(ModuleEntry[]::new);\n+                        mb.opens(ModuleOpenInfo.of(\n+                                cp.packageEntry(cp.utf8Entry(opens.source())),\n+                                flags,\n+                                targets));\n+                    }\n+\n+                    \/\/ uses\n+                    md.uses().stream().map(ClassDesc::of).forEach(mb::uses);\n+\n+                    \/\/ provides\n+                    for (ModuleDescriptor.Provides p : md.provides()) {\n+                        mb.provides(ClassDesc.of(p.service()),\n+                                                 p.providers().stream()\n+                                                         .map(ClassDesc::of)\n+                                                         .toArray(ClassDesc[]::new));\n+                    }\n+                }));\n+\n+                \/\/ packages\n+                var packages = md.packages().stream().sorted().map(PackageDesc::of).toList();\n+                if (!packages.isEmpty()) {\n+                    clb.with(ModulePackagesAttribute.ofNames(packages));\n+                }\n+\n+                \/\/ ModuleMainClass attribute\n+                md.mainClass().ifPresent(mc ->\n+                        clb.with(ModuleMainClassAttribute.of(ClassDesc.of(mc))));\n+\n+                \/\/ write ModuleResolution attribute if specified\n+                if (mres != null) {\n+                    clb.with(ModuleResolutionAttribute.of(mres.value()));\n+                }\n+\n+                \/\/ write ModuleTarget attribute if there is a target platform\n+                if (target != null && !target.targetPlatform().isEmpty()) {\n+                    clb.with(ModuleTargetAttribute.of(target.targetPlatform()));\n+                }\n+            });\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleInfoWriter.java","additions":104,"deletions":101,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -155,0 +155,1 @@\n+        jdk.jartool, \/\/ participates in preview features\n@@ -194,2 +195,0 @@\n-        jdk.jlink;\n-    exports jdk.internal.org.objectweb.asm to\n@@ -197,1 +196,0 @@\n-        jdk.jfr,\n@@ -200,0 +198,9 @@\n+    exports jdk.internal.classfile.attribute to\n+        jdk.jartool;\n+    exports jdk.internal.classfile.constantpool to\n+        jdk.jartool;\n+    exports jdk.internal.classfile.instruction to\n+        jdk.jshell;\n+    exports jdk.internal.org.objectweb.asm to\n+        jdk.jfr,\n+        jdk.jlink;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -522,0 +522,9 @@\n+\n+    \/**\n+     * Releases any system or cryptographic resources.\n+     * It is up to implementors to override disposeContext()\n+     * to take necessary action.\n+     *\/\n+    public void disposeContext() {\n+        \/\/ do nothing\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/AuthenticationInfo.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2012,0 +2012,6 @@\n+            if (proxyAuthentication != null) {\n+                proxyAuthentication.disposeContext();\n+            }\n+            if (serverAuthentication != null) {\n+                serverAuthentication.disposeContext();\n+            }\n@@ -2255,0 +2261,3 @@\n+            if (proxyAuthentication != null) {\n+                proxyAuthentication.disposeContext();\n+            }\n@@ -2505,0 +2514,1 @@\n+                    ret.disposeContext();\n@@ -2677,0 +2687,1 @@\n+                    ret.disposeContext();\n@@ -2703,0 +2714,1 @@\n+                    currentProxyCredentials.disposeContext();\n@@ -2713,0 +2725,1 @@\n+                    currentServerCredentials.disposeContext();\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -245,0 +245,16 @@\n+    \/**\n+     * Releases any system resources and cryptographic information stored in\n+     * the context object and invalidates the context.\n+     *\/\n+    @Override\n+    public void disposeContext() {\n+        if (negotiator != null) {\n+            try {\n+                negotiator.disposeContext();\n+            } catch (IOException ioEx) {\n+                \/\/do not rethrow IOException\n+            }\n+            negotiator = null;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/NegotiateAuthentication.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+\n+    public void disposeContext() throws IOException { };\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/Negotiator.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -433,1 +433,1 @@\n-                            if (pointCrlIssuers.size() != 1) {\n+                            if (pointCrlIssuers == null || pointCrlIssuers.size() != 1) {\n@@ -442,0 +442,3 @@\n+                            \/\/ if pointCrlIssuers is not null, pointCrlIssuer\n+                            \/\/ will also be non-null or the code would have\n+                            \/\/ returned before now\n@@ -478,0 +481,3 @@\n+                    \/\/ the DP's fullName and relativeName fields are null\n+                    \/\/ which means pointCrlIssuers is non-null; the three\n+                    \/\/ cannot all be missing from a certificate.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/DistributionPointFetcher.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -188,1 +188,0 @@\n-            JNU_ThrowOutOfMemoryError(env, NULL);\n@@ -199,1 +198,0 @@\n-            JNU_ThrowOutOfMemoryError(env, NULL);\n@@ -304,1 +302,0 @@\n-        JNU_ThrowOutOfMemoryError(env, NULL);\n","filename":"src\/java.base\/share\/native\/libjava\/ClassLoader.c","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,2 +207,0 @@\n-    char buf[256];\n-    size_t n;\n@@ -210,1 +208,1 @@\n-    jstring why = NULL;\n+    jstring why;\n@@ -212,5 +210,2 @@\n-    n = getLastErrorString(buf, sizeof(buf));\n-    if (n > 0) {\n-        why = JNU_NewStringPlatform(env, buf);\n-        CHECK_NULL(why);\n-    }\n+    why = getLastErrorString(env);\n+    JNU_CHECK_EXCEPTION(env);\n","filename":"src\/java.base\/share\/native\/libjava\/io_util.c","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,11 +106,7 @@\n-    char buf[256];\n-    size_t n = getLastErrorString(buf, sizeof(buf));\n-\n-    if (n > 0) {\n-        jstring s = JNU_NewStringPlatform(env, buf);\n-        if (s != NULL) {\n-            jobject x = JNU_NewObjectByName(env, name,\n-                                            \"(Ljava\/lang\/String;)V\", s);\n-            if (x != NULL) {\n-                (*env)->Throw(env, x);\n-            }\n+    jstring s = getLastErrorString(env);\n+\n+    if (s != NULL) {\n+        jobject x = JNU_NewObjectByName(env, name,\n+                                        \"(Ljava\/lang\/String;)V\", s);\n+        if (x != NULL) {\n+            (*env)->Throw(env, x);\n@@ -132,2 +128,0 @@\n-    char buf[256];\n-    size_t n = getLastErrorString(buf, sizeof(buf));\n@@ -136,15 +130,21 @@\n-    if (n > 0) {\n-        jstring s = JNU_NewStringPlatform(env, buf);\n-        if (s != NULL) {\n-            jobject x = NULL;\n-            if (messagelen) {\n-                jstring s2 = NULL;\n-                size_t messageextlen = messagelen + 4;\n-                char *str1 = (char *)malloc((messageextlen) * sizeof(char));\n-                if (str1 == 0) {\n-                    JNU_ThrowOutOfMemoryError(env, 0);\n-                    return;\n-                }\n-                jio_snprintf(str1, messageextlen, \" (%s)\", message);\n-                s2 = (*env)->NewStringUTF(env, str1);\n-                free(str1);\n+    jstring s = getLastErrorString(env);\n+    if (s != NULL) {\n+        jobject x = NULL;\n+        if (messagelen > 0) {\n+            jstring s2 = NULL;\n+            size_t messageextlen = messagelen + 4;\n+            char *str1 = (char *)malloc((messageextlen) * sizeof(char));\n+            if (str1 == NULL) {\n+                JNU_ThrowOutOfMemoryError(env, 0);\n+                return;\n+            }\n+            jio_snprintf(str1, messageextlen, \" (%s)\", message);\n+            s2 = (*env)->NewStringUTF(env, str1);\n+            free(str1);\n+            JNU_CHECK_EXCEPTION(env);\n+            if (s2 != NULL) {\n+                jstring s3 = JNU_CallMethodByName(\n+                                 env, NULL, s, \"concat\",\n+                                 \"(Ljava\/lang\/String;)Ljava\/lang\/String;\",\n+                                 s2).l;\n+                (*env)->DeleteLocalRef(env, s2);\n@@ -152,11 +152,3 @@\n-                if (s2 != NULL) {\n-                    jstring s3 = JNU_CallMethodByName(\n-                                     env, NULL, s, \"concat\",\n-                                     \"(Ljava\/lang\/String;)Ljava\/lang\/String;\",\n-                                     s2).l;\n-                    (*env)->DeleteLocalRef(env, s2);\n-                    JNU_CHECK_EXCEPTION(env);\n-                    if (s3 != NULL) {\n-                        (*env)->DeleteLocalRef(env, s);\n-                        s = s3;\n-                    }\n+                if (s3 != NULL) {\n+                    (*env)->DeleteLocalRef(env, s);\n+                    s = s3;\n@@ -165,4 +157,4 @@\n-            x = JNU_NewObjectByName(env, name, \"(Ljava\/lang\/String;)V\", s);\n-            if (x != NULL) {\n-                (*env)->Throw(env, x);\n-            }\n+        }\n+        x = JNU_NewObjectByName(env, name, \"(Ljava\/lang\/String;)V\", s);\n+        if (x != NULL) {\n+            (*env)->Throw(env, x);\n@@ -173,1 +165,1 @@\n-        if (messagelen) {\n+        if (messagelen > 0) {\n","filename":"src\/java.base\/share\/native\/libjava\/jni_util.c","additions":37,"deletions":45,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -339,2 +339,1 @@\n-JNIEXPORT size_t JNICALL\n-getLastErrorString(char *buf, size_t len);\n+jstring getLastErrorString(JNIEnv *env);\n","filename":"src\/java.base\/share\/native\/libjava\/jni_util.h","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -532,1 +532,1 @@\n-    if (zip->metanames) {\n+    if (zip->metanames != NULL) {\n@@ -767,1 +767,2 @@\n- * set to NULL. Caller is responsible to free the error message.\n+ * set to NULL. Caller doesn't need to free the error message.\n+ * The error message, if set, points to a static thread-safe buffer.\n@@ -793,1 +794,1 @@\n- * is responsible to free the error message.\n+ * doesn't need to free the error message.\n@@ -806,1 +807,1 @@\n-    if (pmsg != 0) {\n+    if (pmsg != NULL) {\n@@ -811,2 +812,2 @@\n-        if (pmsg) {\n-            *pmsg = strdup(\"zip file name too long\");\n+        if (pmsg != NULL) {\n+            *pmsg = \"zip file name too long\";\n@@ -837,1 +838,1 @@\n- * pmsg != 0. Otherwise, *pmsg will be set to NULL. Caller is responsible to\n+ * pmsg != 0. Otherwise, *pmsg will be set to NULL. Caller doesn't need to\n@@ -866,2 +867,2 @@\n-        if (pmsg && getLastErrorString(errbuf, sizeof(errbuf)) > 0)\n-            *pmsg = strdup(errbuf);\n+        if (pmsg != NULL)\n+            *pmsg = \"ZFILE_Open failed\";\n@@ -880,2 +881,2 @@\n-            if (pmsg) {\n-                *pmsg = strdup(\"zip file is empty\");\n+            if (pmsg != NULL) {\n+                *pmsg = \"zip file is empty\";\n@@ -884,2 +885,2 @@\n-            if (pmsg && getLastErrorString(errbuf, sizeof(errbuf)) > 0)\n-                *pmsg = strdup(errbuf);\n+            if (pmsg != NULL)\n+                *pmsg = \"IO_Lseek failed\";\n@@ -895,1 +896,1 @@\n-        if (pmsg != 0) {\n+        if (pmsg != NULL) {\n@@ -897,2 +898,1 @@\n-            if (zip->msg != NULL)\n-                *pmsg = strdup(zip->msg);\n+            *pmsg = zip->msg;\n@@ -921,4 +921,0 @@\n-    if (file == NULL && pmsg != NULL && *pmsg != NULL) {\n-        free(*pmsg);\n-        *pmsg = \"Zip file open error\";\n-    }\n@@ -1141,2 +1137,2 @@\n-        if (last->extra)   free(last->extra);\n-        if (last->comment) free(last->comment);\n+        free(last->extra);\n+        free(last->comment);\n@@ -1520,1 +1516,1 @@\n-                if (msg == 0) {\n+                if (msg == NULL) {\n@@ -1537,1 +1533,1 @@\n-            if (msg == 0) {\n+            if (msg == NULL) {\n@@ -1557,1 +1553,1 @@\n-    *pmsg = 0; \/* Reset error message *\/\n+    *pmsg = NULL; \/* Reset error message *\/\n","filename":"src\/java.base\/share\/native\/libzip\/zip_util.c","additions":22,"deletions":26,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,2 +63,2 @@\n-JNIEXPORT size_t JNICALL\n-getLastErrorString(char *buf, size_t len)\n+jstring\n+getLastErrorString(JNIEnv *env)\n@@ -66,3 +66,4 @@\n-    if (errno == 0 || len < 1) return 0;\n-    getErrorString(errno, buf, len);\n-    return strlen(buf);\n+    char buf[256] = {0};\n+    if (errno == 0) return NULL;\n+    getErrorString(errno, buf, sizeof(buf));\n+    return (buf[0] != 0) ? JNU_NewStringPlatform(env, buf) : NULL;\n","filename":"src\/java.base\/unix\/native\/libjava\/jni_util_md.c","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,2 +66,2 @@\n-JNIEXPORT size_t JNICALL\n-getLastErrorString(char *buf, size_t len) {\n+jstring\n+getLastErrorString(JNIEnv *env) {\n@@ -69,0 +69,1 @@\n+#define BUFSIZE 256\n@@ -70,0 +71,1 @@\n+    WCHAR buf[BUFSIZE];\n@@ -73,1 +75,1 @@\n-        size_t n = (size_t)FormatMessage(\n+        jsize n = FormatMessageW(\n@@ -79,1 +81,1 @@\n-                (DWORD)len,\n+                BUFSIZE,\n@@ -83,4 +85,4 @@\n-            if (buf[n - 1] == '\\n') n--;\n-            if (buf[n - 1] == '\\r') n--;\n-            if (buf[n - 1] == '.') n--;\n-            buf[n] = '\\0';\n+            if (buf[n - 1] == L'\\n') n--;\n+            if (buf[n - 1] == L'\\r') n--;\n+            if (buf[n - 1] == L'.') n--;\n+            buf[n] = L'\\0';\n@@ -88,1 +90,2 @@\n-        return n;\n+        jstring s = (*env)->NewString(env, buf, n);\n+        return s;\n@@ -90,4 +93,1 @@\n-\n-    \/\/ C runtime error that has no corresponding DOS error code\n-    if (errno == 0 || len < 1) return 0;\n-    return strerror_s(buf, len, errno);\n+    return NULL;\n","filename":"src\/java.base\/windows\/native\/libjava\/jni_util_md.c","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,13 +35,0 @@\n- *\n- * Interfaces and addresses are enumerated using the IP helper routines\n- * GetIfTable, GetIfAddrTable resp. These routines are available on Windows\n- * 98, NT SP+4, 2000, and XP. They are also available on Windows 95 if\n- * IE is upgraded to 5.x.\n- *\n- * Windows does not have any standard for device names so we are forced\n- * to use our own convention which is based on the normal Unix naming\n- * convention (\"lo\" for the loopback, eth0, eth1, .. for ethernet devices,\n- * tr0, tr1, .. for token ring, and so on). This convention gives us\n- * consistency across multiple Windows editions and also consistency with\n- * Solaris\/Linux device names. Note that we always enumerate in index\n- * order and this ensures consistent device number across invocations.\n@@ -50,0 +37,3 @@\n+#define NDIS_IF_MAX_BUFFER_SIZE NDIS_IF_MAX_STRING_SIZE + 1\n+#define NO_PREFIX 255\n+\n@@ -70,1 +60,4 @@\n- * Support routines to free netif and netaddr lists\n+ * Gets the unicast and anycast IP address tables.\n+ * If an error occurs while fetching a table,\n+ * any tables already fetched are freed and an exception is set.\n+ * It is the caller's responsibility to free the tables when they are no longer needed.\n@@ -72,13 +65,22 @@\n-void free_netif(netif *netifP) {\n-    netif *curr = netifP;\n-    while (curr != NULL) {\n-        if (curr->name != NULL)\n-            free(curr->name);\n-        if (curr->displayName != NULL)\n-            free(curr->displayName);\n-        if (curr->addrs != NULL)\n-            free_netaddr (curr->addrs);\n-        netifP = netifP->next;\n-        free(curr);\n-        curr = netifP;\n-    }\n+static BOOL getAddressTables(\n+        JNIEnv *env, MIB_UNICASTIPADDRESS_TABLE **uniAddrs,\n+        MIB_ANYCASTIPADDRESS_TABLE **anyAddrs) {\n+    ULONG apiRetVal;\n+    ADDRESS_FAMILY addrFamily = ipv6_available() ? AF_UNSPEC : AF_INET;\n+\n+    apiRetVal = GetUnicastIpAddressTable(addrFamily, uniAddrs);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetUnicastIpAddressTable\");\n+        return FALSE;\n+    }\n+    apiRetVal = GetAnycastIpAddressTable(addrFamily, anyAddrs);\n+    if (apiRetVal != NO_ERROR) {\n+        FreeMibTable(*uniAddrs);\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetAnycastIpAddressTable\");\n+        return FALSE;\n+    }\n+    return TRUE;\n@@ -87,1 +89,4 @@\n-void free_netaddr(netaddr *netaddrP) {\n+\/*\n+ * Frees a linked list of netaddr structs.\n+ *\/\n+static void freeNetaddrs(netaddr *netaddrP) {\n@@ -90,1 +95,1 @@\n-        netaddrP = netaddrP->next;\n+        netaddrP = netaddrP->Next;\n@@ -97,1 +102,6 @@\n- * Returns the interface structure from the table with the matching index.\n+ * Builds and returns a java.net.NetworkInterface object from the given MIB_IF_ROW2.\n+ * Unlike createNetworkInterfaceForSingleRowWithTables,\n+ * this expects that the row is already populated, either by GetIfEntry2 or GetIfTable2.\n+ * If anything goes wrong, an exception will be set,\n+ * but the address tables are not freed.\n+ * Freeing the address tables is always the caller's responsibility.\n@@ -99,6 +109,9 @@\n-MIB_IFROW *getIF(jint index) {\n-    MIB_IFTABLE *tableP;\n-    MIB_IFROW *ifrowP, *ret = NULL;\n-    ULONG size;\n-    DWORD i, count;\n-    jint ifindex;\n+static jobject createNetworkInterface(\n+        JNIEnv *env, MIB_IF_ROW2 *ifRow, MIB_UNICASTIPADDRESS_TABLE *uniAddrs,\n+        MIB_ANYCASTIPADDRESS_TABLE *anyAddrs) {\n+    WCHAR ifName[NDIS_IF_MAX_BUFFER_SIZE];\n+    jobject netifObj, name, displayName, inetAddr, bcastAddr, bindAddr;\n+    jobjectArray addrArr, bindsArr, childArr;\n+    netaddr *addrsHead = NULL, *addrsCurrent = NULL;\n+    int addrCount = 0;\n+    ULONG apiRetVal, i, mask;\n@@ -106,6 +119,3 @@\n-    \/*\n-     * Ask the IP Helper library to enumerate the adapters\n-     *\/\n-    size = sizeof(MIB_IFTABLE);\n-    tableP = (MIB_IFTABLE *)malloc(size);\n-    if(tableP == NULL)\n+    \/\/ instantiate the NetworkInterface object\n+    netifObj = (*env)->NewObject(env, ni_class, ni_ctor);\n+    if (netifObj == NULL) {\n@@ -113,11 +123,0 @@\n-\n-    count = GetIfTable(tableP, &size, TRUE);\n-    if (count == ERROR_INSUFFICIENT_BUFFER) {\n-        MIB_IFTABLE* newTableP =  (MIB_IFTABLE *)realloc(tableP, size);\n-        if (newTableP == NULL) {\n-            free(tableP);\n-            return NULL;\n-        }\n-        tableP = newTableP;\n-\n-        count = GetIfTable(tableP, &size, TRUE);\n@@ -126,2 +125,7 @@\n-    if (count != NO_ERROR) {\n-        free(tableP);\n+    \/\/ set the NetworkInterface's name\n+    apiRetVal = ConvertInterfaceLuidToNameW(\n+            &(ifRow->InterfaceLuid), ifName, NDIS_IF_MAX_BUFFER_SIZE);\n+    if (apiRetVal != ERROR_SUCCESS) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"ConvertInterfaceLuidToNameW\");\n@@ -130,71 +134,3 @@\n-\n-    {\n-    ifrowP = tableP->table;\n-    for (i=0; i<tableP->dwNumEntries; i++) {\n-    \/*\n-     * Warning: the real index is obtained by GetFriendlyIfIndex()\n-    *\/\n-        ifindex = GetFriendlyIfIndex(ifrowP->dwIndex);\n-        if (ifindex == index) {\n-          \/*\n-           * Create a copy of the entry so that we can free the table.\n-           *\/\n-            ret = (MIB_IFROW *) malloc(sizeof(MIB_IFROW));\n-            if (ret == NULL) {\n-                free(tableP);\n-                return NULL;\n-            }\n-            memcpy(ret, ifrowP, sizeof(MIB_IFROW));\n-            break;\n-        }\n-\n-        \/* onto the next interface *\/\n-        ifrowP++;\n-      }\n-      free(tableP);\n-    }\n-    return ret;\n-}\n-\n-\/*\n- * Enumerate network interfaces using IP Helper Library routine GetIfTable.\n- * We use GetIfTable rather than other IP helper routines because it's\n- * available on 98 & NT SP4+.\n- *\n- * Returns the number of interfaces found or -1 if error. If no error\n- * occurs then netifPP be returned as list of netif structures or NULL\n- * if no interfaces are found.\n- *\/\n-int enumInterfaces(JNIEnv *env, netif **netifPP)\n-{\n-    MIB_IFTABLE *tableP;\n-    MIB_IFROW *ifrowP;\n-    ULONG size;\n-    DWORD ret;\n-    int count;\n-    netif *netifP;\n-    DWORD i;\n-    int lo=0, eth=0, tr=0, fddi=0, ppp=0, sl=0, wlan=0, net=0, wlen=0;\n-\n-    *netifPP = NULL;\n-\n-    \/*\n-     * Ask the IP Helper library to enumerate the adapters\n-     *\/\n-    size = sizeof(MIB_IFTABLE);\n-    tableP = (MIB_IFTABLE *)malloc(size);\n-    if (tableP == NULL) {\n-        JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failure\");\n-        return -1;\n-    }\n-\n-    ret = GetIfTable(tableP, &size, TRUE);\n-    if (ret == ERROR_INSUFFICIENT_BUFFER) {\n-        MIB_IFTABLE * newTableP = (MIB_IFTABLE *)realloc(tableP, size);\n-        if (newTableP == NULL) {\n-            free(tableP);\n-            JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failure\");\n-            return -1;\n-        }\n-        tableP = newTableP;\n-        ret = GetIfTable(tableP, &size, TRUE);\n+    name = (*env)->NewString(env, ifName, (jsize) wcslen(ifName));\n+    if (name == NULL) {\n+        return NULL;\n@@ -202,0 +138,2 @@\n+    (*env)->SetObjectField(env, netifObj, ni_nameID, name);\n+    (*env)->DeleteLocalRef(env, name);\n@@ -203,16 +141,5 @@\n-    if (ret != NO_ERROR) {\n-        free(tableP);\n-        switch (ret) {\n-            case ERROR_INVALID_PARAMETER:\n-                JNU_ThrowInternalError(env,\n-                    \"IP Helper Library GetIfTable function failed: \"\n-                    \"invalid parameter\");\n-                break;\n-            default:\n-                SetLastError(ret);\n-                JNU_ThrowByNameWithMessageAndLastError(env,\n-                    JNU_JAVANETPKG \"SocketException\",\n-                    \"IP Helper Library GetIfTable function failed\");\n-                break;\n-        }\n-        return -1;\n+    \/\/ set the NetworkInterface's display name\n+    displayName = (*env)->NewString(\n+            env, ifRow->Description, (jsize) wcslen(ifRow->Description));\n+    if (displayName == NULL) {\n+        return NULL;\n@@ -220,0 +147,2 @@\n+    (*env)->SetObjectField(env, netifObj, ni_displayNameID, displayName);\n+    (*env)->DeleteLocalRef(env, displayName);\n@@ -221,129 +150,14 @@\n-    \/*\n-     * Iterate through the list of adapters\n-     *\/\n-    count = 0;\n-    netifP = NULL;\n-\n-    ifrowP = tableP->table;\n-    for (i=0; i<tableP->dwNumEntries; i++) {\n-        char dev_name[8];\n-        netif *curr;\n-\n-        \/*\n-         * Generate a name for the device as Windows doesn't have any\n-         * real concept of a device name.\n-         *\/\n-        switch (ifrowP->dwType) {\n-            case MIB_IF_TYPE_ETHERNET:\n-                _snprintf_s(dev_name, 8, _TRUNCATE, \"eth%d\", eth++);\n-                break;\n-\n-            case MIB_IF_TYPE_TOKENRING:\n-                _snprintf_s(dev_name, 8, _TRUNCATE, \"tr%d\", tr++);\n-                break;\n-\n-            case MIB_IF_TYPE_FDDI:\n-                _snprintf_s(dev_name, 8, _TRUNCATE, \"fddi%d\", fddi++);\n-                break;\n-\n-            case MIB_IF_TYPE_LOOPBACK:\n-                \/* There should only be only IPv4 loopback address *\/\n-                if (lo > 0) {\n-                    continue;\n-                }\n-                strncpy_s(dev_name, 8, \"lo\", _TRUNCATE);\n-                lo++;\n-                break;\n-\n-            case MIB_IF_TYPE_PPP:\n-                _snprintf_s(dev_name, 8, _TRUNCATE, \"ppp%d\", ppp++);\n-                break;\n-\n-            case MIB_IF_TYPE_SLIP:\n-                _snprintf_s(dev_name, 8, _TRUNCATE, \"sl%d\", sl++);\n-                break;\n-\n-            case IF_TYPE_IEEE80211:\n-                _snprintf_s(dev_name, 8, _TRUNCATE, \"wlan%d\", wlan++);\n-                break;\n-\n-            default:\n-                _snprintf_s(dev_name, 8, _TRUNCATE, \"net%d\", net++);\n-        }\n-\n-        \/*\n-         * Allocate a netif structure and space for the name and\n-         * display name (description in this case).\n-         *\/\n-        curr = (netif *)calloc(1, sizeof(netif));\n-        if (curr != NULL) {\n-            wlen = MultiByteToWideChar(CP_OEMCP, 0, ifrowP->bDescr,\n-                       ifrowP->dwDescrLen, NULL, 0);\n-            if(wlen == 0) {\n-                \/\/ MultiByteToWideChar should not fail\n-                \/\/ But in rare case it fails, we allow 'char' to be displayed\n-                curr->displayName = (char *)malloc(ifrowP->dwDescrLen + 1);\n-            } else {\n-                curr->displayName = (wchar_t *)malloc((wlen+1)*sizeof(wchar_t));\n-            }\n-\n-            curr->name = (char *)malloc(strlen(dev_name) + 1);\n-\n-            if (curr->name == NULL || curr->displayName == NULL) {\n-                if (curr->name) free(curr->name);\n-                if (curr->displayName) free(curr->displayName);\n-                free(curr);\n-                curr = NULL;\n-            }\n-        }\n-        if (curr == NULL) {\n-            JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failure\");\n-            free_netif(netifP);\n-            free(tableP);\n-            return -1;\n-        }\n-\n-        \/*\n-         * Populate the interface. Note that we need to convert the\n-         * index into its \"friendly\" value as otherwise we will expose\n-         * 32-bit numbers as index values.\n-         *\/\n-        strcpy(curr->name, dev_name);\n-        if (wlen == 0) {\n-            \/\/ display char type in case of MultiByteToWideChar failure\n-            strncpy(curr->displayName, ifrowP->bDescr, ifrowP->dwDescrLen);\n-            curr->displayName[ifrowP->dwDescrLen] = '\\0';\n-        } else {\n-            \/\/ call MultiByteToWideChar again to fill curr->displayName\n-            \/\/ it should not fail, because we have called it once before\n-            if (MultiByteToWideChar(CP_OEMCP, 0, ifrowP->bDescr,\n-                   ifrowP->dwDescrLen, curr->displayName, wlen) == 0) {\n-                JNU_ThrowInternalError(env,\n-                    \"Cannot get multibyte char for interface display name\");\n-                free_netif(netifP);\n-                free(tableP);\n-                free(curr->name);\n-                free(curr->displayName);\n-                free(curr);\n-                return -1;\n-            } else {\n-                ((wchar_t *)curr->displayName)[wlen] = L'\\0';\n-                curr->dNameIsUnicode = TRUE;\n-            }\n-        }\n-\n-        curr->dwIndex = ifrowP->dwIndex;\n-        curr->ifType = ifrowP->dwType;\n-        curr->index = GetFriendlyIfIndex(ifrowP->dwIndex);\n-\n-        \/*\n-         * Put the interface at tail of list as GetIfTable(,,TRUE) is\n-         * returning the interfaces in index order.\n-         *\/\n-        count++;\n-        if (netifP == NULL) {\n-            netifP = curr;\n-        } else {\n-            netif *tail = netifP;\n-            while (tail->next != NULL) {\n-                tail = tail->next;\n+    \/\/ set the NetworkInterface's index\n+    (*env)->SetIntField(env, netifObj, ni_indexID, ifRow->InterfaceIndex);\n+\n+    \/\/ find addresses associated with this interface\n+    for (i = 0; i < uniAddrs->NumEntries; i++) {\n+        if (uniAddrs->Table[i].InterfaceLuid.Value == ifRow->InterfaceLuid.Value &&\n+                (uniAddrs->Table[i].DadState == IpDadStatePreferred ||\n+                        uniAddrs->Table[i].DadState == IpDadStateDeprecated)) {\n+            addrCount++;\n+            addrsCurrent = malloc(sizeof(netaddr));\n+            if (addrsCurrent == NULL) {\n+                freeNetaddrs(addrsHead);\n+                JNU_ThrowOutOfMemoryError(env, \"native heap\");\n+                return NULL;\n@@ -351,66 +165,4 @@\n-            tail->next = curr;\n-        }\n-\n-        \/* onto the next interface *\/\n-        ifrowP++;\n-    }\n-\n-    \/*\n-     * Free the interface table and return the interface list\n-     *\/\n-    if (tableP != NULL) {\n-        free(tableP);\n-    }\n-    *netifPP = netifP;\n-    return count;\n-}\n-\n-\/*\n- * Enumerate all addresses using the IP helper library\n- *\/\n-int lookupIPAddrTable(JNIEnv *env, MIB_IPADDRTABLE **tablePP)\n-{\n-    MIB_IPADDRTABLE *tableP;\n-    ULONG size;\n-    DWORD ret;\n-\n-    *tablePP = NULL;\n-\n-    \/*\n-     * Use GetIpAddrTable to enumerate the IP Addresses\n-     *\/\n-    size = sizeof(MIB_IPADDRTABLE);\n-    tableP = (MIB_IPADDRTABLE *)malloc(size);\n-    if (tableP == NULL) {\n-        JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failure\");\n-        return -1;\n-    }\n-\n-    ret = GetIpAddrTable(tableP, &size, FALSE);\n-    if (ret == ERROR_INSUFFICIENT_BUFFER) {\n-        MIB_IPADDRTABLE * newTableP = (MIB_IPADDRTABLE *)realloc(tableP, size);\n-        if (newTableP == NULL) {\n-            free(tableP);\n-            JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failure\");\n-            return -1;\n-        }\n-        tableP = newTableP;\n-\n-        ret = GetIpAddrTable(tableP, &size, FALSE);\n-    }\n-    if (ret != NO_ERROR) {\n-        if (tableP != NULL) {\n-            free(tableP);\n-        }\n-        switch (ret) {\n-            case ERROR_INVALID_PARAMETER:\n-                JNU_ThrowInternalError(env,\n-                    \"IP Helper Library GetIpAddrTable function failed: \"\n-                    \"invalid parameter\");\n-                break;\n-            default:\n-                SetLastError(ret);\n-                JNU_ThrowByNameWithMessageAndLastError(env,\n-                    JNU_JAVANETPKG \"SocketException\",\n-                    \"IP Helper Library GetIpAddrTable function failed\");\n-                break;\n+            addrsCurrent->Address = uniAddrs->Table[i].Address;\n+            addrsCurrent->PrefixLength = uniAddrs->Table[i].OnLinkPrefixLength;\n+            addrsCurrent->Next = addrsHead;\n+            addrsHead = addrsCurrent;\n@@ -418,3 +170,0 @@\n-        \/\/ this different error code is to handle the case when we call\n-        \/\/ GetIpAddrTable in pure IPv6 environment\n-        return -2;\n@@ -422,80 +171,8 @@\n-    *tablePP = tableP;\n-    return 0;\n-}\n-\n-\/*\n- * Enumerate the IP addresses on an interface, given an IP address table\n- * and matching based on index.\n- *\n- * Returns the count of addresses, or -1 if error. If no error occurs then\n- * netaddrPP will return a list of netaddr structures with the IP addresses.\n- *\/\n-int enumAddresses_win_ipaddrtable(JNIEnv *env, netif *netifP, netaddr **netaddrPP, MIB_IPADDRTABLE *tableP)\n-{\n-    DWORD i;\n-    netaddr *netaddrP;\n-    int count = 0;\n-    unsigned long mask;\n-\n-    *netaddrPP = NULL;\n-\n-    \/*\n-     * Iterate through the table to find the addresses with the\n-     * matching dwIndex. Ignore 0.0.0.0 addresses.\n-     *\/\n-    if (tableP == NULL) {\n-        return 0;\n-    }\n-    count = 0;\n-    netaddrP = NULL;\n-\n-    i = 0;\n-    while (i < tableP->dwNumEntries) {\n-        if (tableP->table[i].dwIndex == netifP->dwIndex &&\n-            tableP->table[i].dwAddr != 0) {\n-\n-            netaddr *curr = (netaddr *)malloc(sizeof(netaddr));\n-            if (curr == NULL) {\n-                JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failure\");\n-                free_netaddr(netaddrP);\n-                return -1;\n-            }\n-\n-            curr->addr.sa4.sin_family = AF_INET;\n-            curr->addr.sa4.sin_addr.s_addr = tableP->table[i].dwAddr;\n-            \/*\n-             * Get netmask \/ broadcast address\n-             *\/\n-            switch (netifP->ifType) {\n-            case MIB_IF_TYPE_ETHERNET:\n-            case MIB_IF_TYPE_TOKENRING:\n-            case MIB_IF_TYPE_FDDI:\n-            case MIB_IF_TYPE_LOOPBACK:\n-            case IF_TYPE_IEEE80211:\n-                \/**\n-                 * Contrary to what it seems to indicate, dwBCastAddr doesn't\n-                 * contain the broadcast address but 0 or 1 depending on whether\n-                 * the broadcast address should set the bits of the host part\n-                 * to 0 or 1.\n-                 * Yes, I know it's stupid, but what can I say, it's MSFTs API.\n-                 *\/\n-                curr->brdcast.sa4.sin_family = AF_INET;\n-                if (tableP->table[i].dwBCastAddr == 1)\n-                    curr->brdcast.sa4.sin_addr.s_addr = (tableP->table[i].dwAddr & tableP->table[i].dwMask) | (0xffffffff ^ tableP->table[i].dwMask);\n-                else\n-                    curr->brdcast.sa4.sin_addr.s_addr = (tableP->table[i].dwAddr & tableP->table[i].dwMask);\n-                mask = ntohl(tableP->table[i].dwMask);\n-                curr->mask = 0;\n-                while (mask) {\n-                    mask <<= 1;\n-                    curr->mask++;\n-                }\n-                break;\n-            case MIB_IF_TYPE_PPP:\n-            case MIB_IF_TYPE_SLIP:\n-            default:\n-                \/**\n-                 * these don't have broadcast\/subnet\n-                 *\/\n-                curr->mask = -1;\n-                    break;\n+    for (i = 0; i < anyAddrs->NumEntries; i++) {\n+        if (anyAddrs->Table[i].InterfaceLuid.Value == ifRow->InterfaceLuid.Value) {\n+            addrCount++;\n+            addrsCurrent = malloc(sizeof(netaddr));\n+            if (addrsCurrent == NULL) {\n+                freeNetaddrs(addrsHead);\n+                JNU_ThrowOutOfMemoryError(env, \"native heap\");\n+                return NULL;\n@@ -503,4 +180,4 @@\n-\n-            curr->next = netaddrP;\n-            netaddrP = curr;\n-            count++;\n+            addrsCurrent->Address = anyAddrs->Table[i].Address;\n+            addrsCurrent->PrefixLength = NO_PREFIX;\n+            addrsCurrent->Next = addrsHead;\n+            addrsHead = addrsCurrent;\n@@ -508,101 +185,0 @@\n-        i++;\n-    }\n-\n-    *netaddrPP = netaddrP;\n-    return count;\n-}\n-\n-\n-\/*\n- * Enumerate the IP addresses on an interface, using an IP address table\n- * retrieved using GetIPAddrTable and matching based on index.\n- *\n- * Returns the count of addresses, or -1 if error. If no error occurs then\n- * netaddrPP will return a list of netaddr structures with the IP addresses.\n- *\/\n-int enumAddresses_win(JNIEnv *env, netif *netifP, netaddr **netaddrPP) {\n-    MIB_IPADDRTABLE *tableP;\n-    int count;\n-\n-    *netaddrPP = NULL;\n-\n-    int ret = lookupIPAddrTable(env, &tableP);\n-    if (ret < 0) {\n-      return ret;\n-    }\n-    count = enumAddresses_win_ipaddrtable(env, netifP, netaddrPP, tableP);\n-    free(tableP);\n-    return count;\n-}\n-\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    init\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_NetworkInterface_init(JNIEnv *env, jclass cls)\n-{\n-    \/*\n-     * Get the various JNI ids that we require\n-     *\/\n-    ni_class = (*env)->NewGlobalRef(env, cls);\n-    CHECK_NULL(ni_class);\n-    ni_nameID = (*env)->GetFieldID(env, ni_class, \"name\", \"Ljava\/lang\/String;\");\n-    CHECK_NULL(ni_nameID);\n-    ni_displayNameID = (*env)->GetFieldID(env, ni_class, \"displayName\", \"Ljava\/lang\/String;\");\n-    CHECK_NULL(ni_displayNameID);\n-    ni_indexID = (*env)->GetFieldID(env, ni_class, \"index\", \"I\");\n-    CHECK_NULL(ni_indexID);\n-    ni_addrsID = (*env)->GetFieldID(env, ni_class, \"addrs\", \"[Ljava\/net\/InetAddress;\");\n-    CHECK_NULL(ni_addrsID);\n-    ni_bindsID = (*env)->GetFieldID(env, ni_class, \"bindings\", \"[Ljava\/net\/InterfaceAddress;\");\n-    CHECK_NULL(ni_bindsID);\n-    ni_childsID = (*env)->GetFieldID(env, ni_class, \"childs\", \"[Ljava\/net\/NetworkInterface;\");\n-    CHECK_NULL(ni_childsID);\n-    ni_ctor = (*env)->GetMethodID(env, ni_class, \"<init>\", \"()V\");\n-    CHECK_NULL(ni_ctor);\n-    ni_ibcls = (*env)->FindClass(env, \"java\/net\/InterfaceAddress\");\n-    CHECK_NULL(ni_ibcls);\n-    ni_ibcls = (*env)->NewGlobalRef(env, ni_ibcls);\n-    CHECK_NULL(ni_ibcls);\n-    ni_ibctrID = (*env)->GetMethodID(env, ni_ibcls, \"<init>\", \"()V\");\n-    CHECK_NULL(ni_ibctrID);\n-    ni_ibaddressID = (*env)->GetFieldID(env, ni_ibcls, \"address\", \"Ljava\/net\/InetAddress;\");\n-    CHECK_NULL(ni_ibaddressID);\n-    ni_ibbroadcastID = (*env)->GetFieldID(env, ni_ibcls, \"broadcast\", \"Ljava\/net\/Inet4Address;\");\n-    CHECK_NULL(ni_ibbroadcastID);\n-    ni_ibmaskID = (*env)->GetFieldID(env, ni_ibcls, \"maskLength\", \"S\");\n-    CHECK_NULL(ni_ibmaskID);\n-\n-    initInetAddressIDs(env);\n-}\n-\n-\/*\n- * Create a NetworkInterface object, populate the name and index, and\n- * populate the InetAddress array based on the IP addresses for this\n- * interface.\n- *\/\n-jobject createNetworkInterface\n-    (JNIEnv *env, netif *ifs, int netaddrCount, netaddr *netaddrP)\n-{\n-    jobject netifObj;\n-    jobject name, displayName;\n-    jobjectArray addrArr, bindsArr, childArr;\n-    netaddr *addrs;\n-    jint addr_index;\n-    jint bind_index;\n-\n-    \/*\n-     * Create a NetworkInterface object and populate it\n-     *\/\n-    netifObj = (*env)->NewObject(env, ni_class, ni_ctor);\n-    CHECK_NULL_RETURN(netifObj, NULL);\n-    name = (*env)->NewStringUTF(env, ifs->name);\n-    CHECK_NULL_RETURN(name, NULL);\n-    if (ifs->dNameIsUnicode) {\n-        displayName = (*env)->NewString(env, (PWCHAR)ifs->displayName,\n-                                       (jsize)wcslen ((PWCHAR)ifs->displayName));\n-    } else {\n-        displayName = (*env)->NewStringUTF(env, ifs->displayName);\n@@ -610,4 +186,0 @@\n-    CHECK_NULL_RETURN(displayName, NULL);\n-    (*env)->SetObjectField(env, netifObj, ni_nameID, name);\n-    (*env)->SetObjectField(env, netifObj, ni_displayNameID, displayName);\n-    (*env)->SetIntField(env, netifObj, ni_indexID, ifs->index);\n@@ -615,11 +187,2 @@\n-    \/*\n-     * Get the IP addresses for this interface if necessary\n-     * Note that 0 is a valid number of addresses.\n-     *\/\n-    if (netaddrCount < 0) {\n-        netaddrCount = enumAddresses_win(env, ifs, &netaddrP);\n-        if (netaddrCount < 0) {\n-            return NULL;\n-        }\n-    }\n-    addrArr = (*env)->NewObjectArray(env, netaddrCount, ia_class, NULL);\n+    \/\/ instantiate the addrs and bindings array\n+    addrArr = (*env)->NewObjectArray(env, addrCount, ia_class, NULL);\n@@ -627,1 +190,1 @@\n-        free_netaddr(netaddrP);\n+        freeNetaddrs(addrsHead);\n@@ -630,2 +193,1 @@\n-\n-    bindsArr = (*env)->NewObjectArray(env, netaddrCount, ni_ibcls, NULL);\n+    bindsArr = (*env)->NewObjectArray(env, addrCount, ni_ibcls, NULL);\n@@ -633,2 +195,2 @@\n-      free_netaddr(netaddrP);\n-      return NULL;\n+        freeNetaddrs(addrsHead);\n+        return NULL;\n@@ -636,10 +198,9 @@\n-    addrs = netaddrP;\n-    addr_index = 0;\n-    bind_index = 0;\n-    while (addrs != NULL) {\n-        jobject iaObj, ia2Obj;\n-        jobject ibObj = NULL;\n-        if (addrs->addr.sa.sa_family == AF_INET) {\n-            iaObj = (*env)->NewObject(env, ia4_class, ia4_ctrID);\n-            if (iaObj == NULL) {\n-                free_netaddr(netaddrP);\n+\n+    \/\/ populate the addrs and bindings arrays\n+    i = 0;\n+    while (addrsCurrent != NULL) {\n+        if (addrsCurrent->Address.si_family == AF_INET) { \/\/ IPv4\n+            \/\/ create and populate InetAddress object\n+            inetAddr = (*env)->NewObject(env, ia4_class, ia4_ctrID);\n+            if (inetAddr == NULL) {\n+                freeNetaddrs(addrsHead);\n@@ -648,3 +209,2 @@\n-            \/* default ctor will set family to AF_INET *\/\n-\n-            setInetAddress_addr(env, iaObj, ntohl(addrs->addr.sa4.sin_addr.s_addr));\n+            setInetAddress_addr(\n+                    env, inetAddr, ntohl(addrsCurrent->Address.Ipv4.sin_addr.s_addr));\n@@ -652,1 +212,1 @@\n-                free_netaddr(netaddrP);\n+                freeNetaddrs(addrsHead);\n@@ -655,10 +215,5 @@\n-            if (addrs->mask != -1) {\n-              ibObj = (*env)->NewObject(env, ni_ibcls, ni_ibctrID);\n-              if (ibObj == NULL) {\n-                free_netaddr(netaddrP);\n-                return NULL;\n-              }\n-              (*env)->SetObjectField(env, ibObj, ni_ibaddressID, iaObj);\n-              ia2Obj = (*env)->NewObject(env, ia4_class, ia4_ctrID);\n-              if (ia2Obj == NULL) {\n-                free_netaddr(netaddrP);\n+\n+            \/\/ create and populate InterfaceAddress object\n+            bindAddr = (*env)->NewObject(env, ni_ibcls, ni_ibctrID);\n+            if (bindAddr == NULL) {\n+                freeNetaddrs(addrsHead);\n@@ -666,11 +221,0 @@\n-              }\n-              setInetAddress_addr(env, ia2Obj, ntohl(addrs->brdcast.sa4.sin_addr.s_addr));\n-              if ((*env)->ExceptionCheck(env)) {\n-                  free_netaddr(netaddrP);\n-                  return NULL;\n-              }\n-              (*env)->SetObjectField(env, ibObj, ni_ibbroadcastID, ia2Obj);\n-              (*env)->DeleteLocalRef(env, ia2Obj);\n-              (*env)->SetShortField(env, ibObj, ni_ibmaskID, addrs->mask);\n-              (*env)->SetObjectArrayElement(env, bindsArr, bind_index++, ibObj);\n-              (*env)->DeleteLocalRef(env, ibObj);\n@@ -678,7 +222,11 @@\n-        } else \/* AF_INET6 *\/ {\n-            int scope;\n-            iaObj = (*env)->NewObject(env, ia6_class, ia6_ctrID);\n-            if (iaObj) {\n-                jboolean ret = setInet6Address_ipaddress(env, iaObj,  (jbyte *)&(addrs->addr.sa6.sin6_addr.s6_addr));\n-                if (ret == JNI_FALSE) {\n-                    free_netaddr(netaddrP);\n+            (*env)->SetObjectField(env, bindAddr, ni_ibaddressID, inetAddr);\n+            if (addrsCurrent->PrefixLength != NO_PREFIX) {\n+                (*env)->SetShortField(\n+                        env, bindAddr, ni_ibmaskID, addrsCurrent->PrefixLength);\n+                apiRetVal = ConvertLengthToIpv4Mask(addrsCurrent->PrefixLength, &mask);\n+                if (apiRetVal != NO_ERROR) {\n+                    freeNetaddrs(addrsHead);\n+                    SetLastError(apiRetVal);\n+                    NET_ThrowByNameWithLastError(\n+                            env, JNU_JAVANETPKG \"SocketException\",\n+                            \"ConvertLengthToIpv4Mask\");\n@@ -687,5 +235,4 @@\n-\n-                scope = addrs->addr.sa6.sin6_scope_id;\n-                if (scope != 0) { \/* zero is default value, no need to set *\/\n-                    setInet6Address_scopeid(env, iaObj, scope);\n-                    setInet6Address_scopeifname(env, iaObj, netifObj);\n+                bcastAddr = (*env)->NewObject(env, ia4_class, ia4_ctrID);\n+                if (bcastAddr == NULL) {\n+                    freeNetaddrs(addrsHead);\n+                    return NULL;\n@@ -693,4 +240,6 @@\n-                ibObj = (*env)->NewObject(env, ni_ibcls, ni_ibctrID);\n-                if (ibObj == NULL) {\n-                  free_netaddr(netaddrP);\n-                  return NULL;\n+                setInetAddress_addr(\n+                        env, bcastAddr,\n+                        ntohl(addrsCurrent->Address.Ipv4.sin_addr.s_addr | ~mask));\n+                if ((*env)->ExceptionCheck(env)) {\n+                    freeNetaddrs(addrsHead);\n+                    return NULL;\n@@ -698,4 +247,31 @@\n-                (*env)->SetObjectField(env, ibObj, ni_ibaddressID, iaObj);\n-                (*env)->SetShortField(env, ibObj, ni_ibmaskID, addrs->mask);\n-                (*env)->SetObjectArrayElement(env, bindsArr, bind_index++, ibObj);\n-                (*env)->DeleteLocalRef(env, ibObj);\n+                (*env)->SetObjectField(env, bindAddr, ni_ibbroadcastID, bcastAddr);\n+                (*env)->DeleteLocalRef(env, bcastAddr);\n+            }\n+        } else { \/\/ IPv6\n+            inetAddr = (*env)->NewObject(env, ia6_class, ia6_ctrID);\n+            if (inetAddr == NULL) {\n+                freeNetaddrs(addrsHead);\n+                return NULL;\n+            }\n+            if (setInet6Address_ipaddress(\n+                    env, inetAddr,\n+                    (jbyte *)&(addrsCurrent->Address.Ipv6.sin6_addr.s6_addr))\n+                    == JNI_FALSE) {\n+                freeNetaddrs(addrsHead);\n+                return NULL;\n+            }\n+            \/* zero is default value, no need to set *\/\n+            if (addrsCurrent->Address.Ipv6.sin6_scope_id != 0) {\n+                setInet6Address_scopeid(\n+                        env, inetAddr, addrsCurrent->Address.Ipv6.sin6_scope_id);\n+                setInet6Address_scopeifname(env, inetAddr, netifObj);\n+            }\n+            bindAddr = (*env)->NewObject(env, ni_ibcls, ni_ibctrID);\n+            if (bindAddr == NULL) {\n+                freeNetaddrs(addrsHead);\n+                return NULL;\n+            }\n+            (*env)->SetObjectField(env, bindAddr, ni_ibaddressID, inetAddr);\n+            if (addrsCurrent->PrefixLength != NO_PREFIX) {\n+                (*env)->SetShortField(\n+                        env, bindAddr, ni_ibmaskID, addrsCurrent->PrefixLength);\n@@ -704,4 +280,10 @@\n-        (*env)->SetObjectArrayElement(env, addrArr, addr_index, iaObj);\n-        (*env)->DeleteLocalRef(env, iaObj);\n-        addrs = addrs->next;\n-        addr_index++;\n+\n+        \/\/ add the new elements to the arrays\n+        (*env)->SetObjectArrayElement(env, addrArr, i, inetAddr);\n+        (*env)->DeleteLocalRef(env, inetAddr);\n+        (*env)->SetObjectArrayElement(env, bindsArr, i, bindAddr);\n+        (*env)->DeleteLocalRef(env, bindAddr);\n+\n+        \/\/ advance to the next address\n+        addrsCurrent = addrsCurrent->Next;\n+        i++;\n@@ -709,2 +291,0 @@\n-    (*env)->SetObjectField(env, netifObj, ni_addrsID, addrArr);\n-    (*env)->SetObjectField(env, netifObj, ni_bindsID, bindsArr);\n@@ -712,3 +292,5 @@\n-    free_netaddr(netaddrP);\n-    (*env)->DeleteLocalRef(env, name);\n-    (*env)->DeleteLocalRef(env, displayName);\n+    \/\/ free the address list since we no longer need it\n+    freeNetaddrs(addrsHead);\n+\n+    \/\/ set the addrs and bindings arrays on the NetworkInterface\n+    (*env)->SetObjectField(env, netifObj, ni_addrsID, addrArr);\n@@ -716,0 +298,1 @@\n+    (*env)->SetObjectField(env, netifObj, ni_bindsID, bindsArr);\n@@ -718,4 +301,2 @@\n-    \/*\n-     * Windows doesn't have virtual interfaces, so child array\n-     * is always empty.\n-     *\/\n+    \/\/ set child array on the NetworkInterface\n+    \/\/ Windows doesn't have virtual interfaces, so this is always empty\n@@ -724,1 +305,1 @@\n-      return NULL;\n+        return NULL;\n@@ -729,1 +310,0 @@\n-    \/* return the NetworkInterface *\/\n@@ -734,3 +314,6 @@\n- * Class:     java_net_NetworkInterface\n- * Method:    getByName0\n- * Signature: (Ljava\/lang\/String;)Ljava\/net\/NetworkInterface;\n+ * Builds and returns a java.net.NetworkInterface object from the given MIB_IF_ROW2.\n+ * This expects that the row is not yet populated, but an index has been set,\n+ * so the row is ready to be populated by GetIfEntry2.\n+ * If anything goes wrong, an exception will be set,\n+ * but the address tables are not freed.\n+ * Freeing the address tables is always the caller's responsibility.\n@@ -738,15 +321,12 @@\n-JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByName0\n-    (JNIEnv *env, jclass cls, jstring name)\n-{\n-    netif *ifList, *curr;\n-    jboolean isCopy;\n-    const char *name_utf;\n-    jobject netifObj = NULL;\n-\n-    \/\/ Retained for now to support IPv4 only stack, java.net.preferIPv4Stack\n-    if (ipv6_available()) {\n-        return Java_java_net_NetworkInterface_getByName0_XP (env, cls, name);\n-    }\n-\n-    \/* get the list of interfaces *\/\n-    if (enumInterfaces(env, &ifList) < 0) {\n+static jobject createNetworkInterfaceForSingleRowWithTables(\n+        JNIEnv *env, MIB_IF_ROW2 *ifRow,\n+        MIB_UNICASTIPADDRESS_TABLE *uniAddrs, MIB_ANYCASTIPADDRESS_TABLE *anyAddrs) {\n+    ULONG apiRetVal;\n+\n+    apiRetVal = GetIfEntry2(ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        if (apiRetVal != ERROR_FILE_NOT_FOUND) {\n+            SetLastError(apiRetVal);\n+            NET_ThrowByNameWithLastError(\n+                    env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n+        }\n@@ -755,0 +335,2 @@\n+    return createNetworkInterface(env, ifRow, uniAddrs, anyAddrs);\n+}\n@@ -756,17 +338,13 @@\n-    \/* get the name as a C string *\/\n-    name_utf = (*env)->GetStringUTFChars(env, name, &isCopy);\n-    if (name_utf != NULL) {\n-\n-        \/* Search by name *\/\n-        curr = ifList;\n-        while (curr != NULL) {\n-            if (strcmp(name_utf, curr->name) == 0) {\n-                break;\n-            }\n-            curr = curr->next;\n-        }\n-\n-        \/* if found create a NetworkInterface *\/\n-        if (curr != NULL) {;\n-            netifObj = createNetworkInterface(env, curr, -1, NULL);\n-        }\n+\/*\n+ * Builds and returns a java.net.NetworkInterface object from the given MIB_IF_ROW2.\n+ * This expects that the row is not yet populated, but an index has been set,\n+ * so the row is ready to be populated by GetIfEntry2.\n+ * Unlike createNetworkInterfaceForSingleRowWithTables, this will get the address\n+ * tables at the beginning and free them at the end.\n+ * If anything goes wrong, an exception will be set.\n+ *\/\n+static jobject createNetworkInterfaceForSingleRow(\n+        JNIEnv *env, MIB_IF_ROW2 *ifRow) {\n+    MIB_UNICASTIPADDRESS_TABLE *uniAddrs;\n+    MIB_ANYCASTIPADDRESS_TABLE *anyAddrs;\n+    jobject netifObj;\n@@ -774,5 +352,2 @@\n-        \/* release the UTF string *\/\n-        (*env)->ReleaseStringUTFChars(env, name, name_utf);\n-    } else {\n-        if (!(*env)->ExceptionCheck(env))\n-            JNU_ThrowOutOfMemoryError(env, NULL);\n+    if (getAddressTables(env, &uniAddrs, &anyAddrs) == FALSE) {\n+        return NULL;\n@@ -781,2 +356,5 @@\n-    \/* release the interface list *\/\n-    free_netif(ifList);\n+    netifObj = createNetworkInterfaceForSingleRowWithTables(\n+            env, ifRow, uniAddrs, anyAddrs);\n+\n+    FreeMibTable(uniAddrs);\n+    FreeMibTable(anyAddrs);\n@@ -792,10 +370,3 @@\n-JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByIndex0\n-  (JNIEnv *env, jclass cls, jint index)\n-{\n-    netif *ifList, *curr;\n-    jobject netifObj = NULL;\n-\n-    \/\/ Retained for now to support IPv4 only stack, java.net.preferIPv4Stack\n-    if (ipv6_available()) {\n-        return Java_java_net_NetworkInterface_getByIndex0_XP (env, cls, index);\n-    }\n+JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByIndex0(\n+        JNIEnv *env, jclass cls, jint index) {\n+    MIB_IF_ROW2 ifRow = {0};\n@@ -803,2 +374,2 @@\n-    \/* get the list of interfaces *\/\n-    if (enumInterfaces(env, &ifList) < 0) {\n+    if (index == 0) {\n+        \/\/ 0 is never a valid index, and would make GetIfEntry2 think nothing is set\n@@ -808,18 +379,2 @@\n-    \/* search by index *\/\n-    curr = ifList;\n-    while (curr != NULL) {\n-        if (index == curr->index) {\n-            break;\n-        }\n-        curr = curr->next;\n-    }\n-\n-    \/* if found create a NetworkInterface *\/\n-    if (curr != NULL) {\n-        netifObj = createNetworkInterface(env, curr, -1, NULL);\n-    }\n-\n-    \/* release the interface list *\/\n-    free_netif(ifList);\n-\n-    return netifObj;\n+    ifRow.InterfaceIndex = index;\n+    return createNetworkInterfaceForSingleRow(env, &ifRow);\n@@ -828,1 +383,0 @@\n-\n@@ -831,2 +385,2 @@\n- * Method:    boundInetAddress0\n- * Signature: (Ljava\/net\/InetAddress;)Z\n+ * Method:    getByName0\n+ * Signature: (Ljava\/lang\/String;)Ljava\/net\/NetworkInterface;\n@@ -834,27 +388,15 @@\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_boundInetAddress0\n-    (JNIEnv *env, jclass cls, jobject iaObj)\n-{\n-    DWORD i;\n-\n-    int family = getInetAddress_family(env, iaObj);\n-    JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);\n-\n-    if (family == java_net_InetAddress_IPv6) {\n-        if (!ipv6_available())\n-            return JNI_FALSE;\n-        return Java_java_net_NetworkInterface_getByInetAddress0_XP(env, cls, iaObj) != NULL;\n-    } else if (family == java_net_InetAddress_IPv4) {\n-        jint addr = getInetAddress_addr(env, iaObj);\n-        JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);\n-\n-        jboolean found = JNI_FALSE;\n-        MIB_IPADDRTABLE *tableP;\n-        if (lookupIPAddrTable(env, &tableP) >= 0 && tableP != NULL) {\n-            for (i = 0; i < tableP->dwNumEntries; i++) {\n-                if (tableP->table[i].dwAddr != 0 &&\n-                    (unsigned long)addr == ntohl(tableP->table[i].dwAddr)) {\n-                    found = JNI_TRUE;\n-                    break;\n-                }\n-            }\n-            free(tableP);\n+JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByName0(\n+        JNIEnv *env, jclass cls, jstring name) {\n+    const jchar *nameChars;\n+    ULONG apiRetVal;\n+    MIB_IF_ROW2 ifRow = {0};\n+\n+    nameChars = (*env)->GetStringChars(env, name, NULL);\n+    apiRetVal = ConvertInterfaceNameToLuidW(nameChars, &(ifRow.InterfaceLuid));\n+    (*env)->ReleaseStringChars(env, name, nameChars);\n+    if (apiRetVal != ERROR_SUCCESS) {\n+        if (apiRetVal != ERROR_INVALID_NAME) {\n+            SetLastError(apiRetVal);\n+            NET_ThrowByNameWithLastError(\n+                    env, JNU_JAVANETPKG \"SocketException\",\n+                    \"ConvertInterfaceNameToLuidW\");\n@@ -862,4 +404,1 @@\n-        return found;\n-    } else {\n-      \/\/ Unknown address family\n-      return JNI_FALSE;\n+        return NULL;\n@@ -867,0 +406,1 @@\n+    return createNetworkInterfaceForSingleRow(env, &ifRow);\n@@ -874,15 +414,9 @@\n-JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByInetAddress0\n-    (JNIEnv *env, jclass cls, jobject iaObj)\n-{\n-    netif *ifList, *curr;\n-    MIB_IPADDRTABLE *tableP;\n-    jobject netifObj = NULL;\n-    jint addr = getInetAddress_addr(env, iaObj);\n-    JNU_CHECK_EXCEPTION_RETURN(env, NULL);\n-\n-    if (ipv6_available()) {\n-        return Java_java_net_NetworkInterface_getByInetAddress0_XP (env, cls, iaObj);\n-    }\n-\n-    \/* get the list of interfaces *\/\n-    if (enumInterfaces(env, &ifList) < 0) {\n+JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByInetAddress0(\n+        JNIEnv *env, jclass cls, jobject inetAddr) {\n+    MIB_UNICASTIPADDRESS_TABLE *uniAddrs;\n+    MIB_ANYCASTIPADDRESS_TABLE *anyAddrs;\n+    ULONG i;\n+    MIB_IF_ROW2 ifRow = {0};\n+    jobject result = NULL;\n+\n+    if (getAddressTables(env, &uniAddrs, &anyAddrs) == FALSE) {\n@@ -892,29 +426,20 @@\n-    \/*\n-     * Enumerate the addresses on each interface until we find a\n-     * matching address.\n-     *\/\n-    tableP = NULL;\n-    if (lookupIPAddrTable(env, &tableP) >= 0) {\n-        curr = ifList;\n-        while (curr != NULL) {\n-            int count;\n-            netaddr *addrList;\n-            netaddr *addrP;\n-\n-            \/* enumerate the addresses on this interface *\/\n-            count = enumAddresses_win_ipaddrtable(env, curr, &addrList, tableP);\n-            if (count < 0) {\n-                free_netif(ifList);\n-                free(tableP);\n-                return NULL;\n-            }\n-\n-            \/* iterate through each address *\/\n-            addrP = addrList;\n-\n-            while (addrP != NULL) {\n-                if ((unsigned long)addr == ntohl(addrP->addr.sa4.sin_addr.s_addr)) {\n-                    break;\n-                }\n-                addrP = addrP->next;\n-            }\n+    for (i = 0; i < uniAddrs->NumEntries; i++) {\n+        if (NET_SockaddrEqualsInetAddress(\n+                env, (SOCKETADDRESS*) &(uniAddrs->Table[i].Address), inetAddr) &&\n+                (uniAddrs->Table[i].DadState == IpDadStatePreferred ||\n+                        uniAddrs->Table[i].DadState == IpDadStateDeprecated)) {\n+            ifRow.InterfaceLuid = uniAddrs->Table[i].InterfaceLuid;\n+            result = createNetworkInterfaceForSingleRowWithTables(\n+                    env, &ifRow, uniAddrs, anyAddrs);\n+            goto done;\n+        }\n+    }\n+    for (i = 0; i < anyAddrs->NumEntries; i++) {\n+        if (NET_SockaddrEqualsInetAddress(\n+                env, (SOCKETADDRESS*) &(anyAddrs->Table[i].Address), inetAddr)) {\n+            ifRow.InterfaceLuid = anyAddrs->Table[i].InterfaceLuid;\n+            result = createNetworkInterfaceForSingleRowWithTables(\n+                    env, &ifRow, uniAddrs, anyAddrs);\n+            goto done;\n+        }\n+    }\n@@ -922,11 +447,5 @@\n-            \/*\n-             * Address matched so create NetworkInterface for this interface\n-             * and address list.\n-             *\/\n-            if (addrP != NULL) {\n-                \/* createNetworkInterface will free addrList *\/\n-                netifObj = createNetworkInterface(env, curr, count, addrList);\n-                break;\n-            } else {\n-                free_netaddr(addrList);\n-            }\n+    done:\n+    FreeMibTable(uniAddrs);\n+    FreeMibTable(anyAddrs);\n+    return result;\n+}\n@@ -934,2 +453,30 @@\n-            \/* on next interface *\/\n-            curr = curr->next;\n+\/*\n+ * Class:     java_net_NetworkInterface\n+ * Method:    boundInetAddress0\n+ * Signature: (Ljava\/net\/InetAddress;)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_boundInetAddress0(\n+        JNIEnv *env, jclass cls, jobject inetAddr) {\n+    MIB_UNICASTIPADDRESS_TABLE *uniAddrs;\n+    MIB_ANYCASTIPADDRESS_TABLE *anyAddrs;\n+    ULONG i;\n+    jboolean result = JNI_FALSE;\n+\n+    if (getAddressTables(env, &uniAddrs, &anyAddrs) == FALSE) {\n+        return JNI_FALSE;\n+    }\n+\n+    for (i = 0; i < uniAddrs->NumEntries; i++) {\n+        if (NET_SockaddrEqualsInetAddress(\n+                env, (SOCKETADDRESS*) &(uniAddrs->Table[i].Address), inetAddr) &&\n+                (uniAddrs->Table[i].DadState == IpDadStatePreferred ||\n+                        uniAddrs->Table[i].DadState == IpDadStateDeprecated)) {\n+            result = JNI_TRUE;\n+            goto done;\n+        }\n+    }\n+    for (i = 0; i < anyAddrs->NumEntries; i++) {\n+        if (NET_SockaddrEqualsInetAddress(\n+                env, (SOCKETADDRESS*) &(anyAddrs->Table[i].Address), inetAddr)) {\n+            result = JNI_TRUE;\n+            goto done;\n@@ -937,2 +484,0 @@\n-        \/* release the IP address table *\/\n-        free(tableP);\n@@ -941,4 +486,4 @@\n-    \/* release the interface list *\/\n-    free_netif(ifList);\n-\n-    return netifObj;\n+    done:\n+    FreeMibTable(uniAddrs);\n+    FreeMibTable(anyAddrs);\n+    return result;\n@@ -952,11 +497,15 @@\n-JNIEXPORT jobjectArray JNICALL Java_java_net_NetworkInterface_getAll\n-    (JNIEnv *env, jclass cls)\n-{\n-    int count;\n-    netif *ifList, *curr;\n-    jobjectArray netIFArr;\n-    jint arr_index;\n-\n-    \/\/ Retained for now to support IPv4 only stack, java.net.preferIPv4Stack\n-    if (ipv6_available()) {\n-        return Java_java_net_NetworkInterface_getAll_XP (env, cls);\n+JNIEXPORT jobjectArray JNICALL Java_java_net_NetworkInterface_getAll(\n+        JNIEnv *env, jclass cls) {\n+    MIB_IF_TABLE2 *ifTable;\n+    jobjectArray ifArray;\n+    MIB_UNICASTIPADDRESS_TABLE *uniAddrs;\n+    MIB_ANYCASTIPADDRESS_TABLE *anyAddrs;\n+    ULONG apiRetVal, i;\n+    jobject ifObj;\n+\n+    apiRetVal = GetIfTable2(&ifTable);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfTable2\");\n+        return NULL;\n@@ -965,5 +514,3 @@\n-    \/*\n-     * Get list of interfaces\n-     *\/\n-    count = enumInterfaces(env, &ifList);\n-    if (count < 0) {\n+    ifArray = (*env)->NewObjectArray(env, ifTable->NumEntries, cls, NULL);\n+    if (ifArray == NULL) {\n+        FreeMibTable(ifTable);\n@@ -973,4 +520,2 @@\n-    \/* allocate a NetworkInterface array *\/\n-    netIFArr = (*env)->NewObjectArray(env, count, cls, NULL);\n-    if (netIFArr == NULL) {\n-        free_netif(ifList);\n+    if (getAddressTables(env, &uniAddrs, &anyAddrs) == FALSE) {\n+        FreeMibTable(ifTable);\n@@ -980,12 +525,7 @@\n-    \/*\n-     * Iterate through the interfaces, create a NetworkInterface instance\n-     * for each array element and populate the object.\n-     *\/\n-    curr = ifList;\n-    arr_index = 0;\n-    while (curr != NULL) {\n-        jobject netifObj;\n-\n-        netifObj = createNetworkInterface(env, curr, -1, NULL);\n-        if (netifObj == NULL) {\n-            free_netif(ifList);\n+    for (i = 0; i < ifTable->NumEntries; i++) {\n+        ifObj = createNetworkInterface(\n+                env, &(ifTable->Table[i]), uniAddrs, anyAddrs);\n+        if (ifObj == NULL) {\n+            FreeMibTable(ifTable);\n+            FreeMibTable(uniAddrs);\n+            FreeMibTable(anyAddrs);\n@@ -994,6 +534,2 @@\n-\n-        \/* put the NetworkInterface into the array *\/\n-        (*env)->SetObjectArrayElement(env, netIFArr, arr_index++, netifObj);\n-        (*env)->DeleteLocalRef(env, netifObj);\n-\n-        curr = curr->next;\n+        (*env)->SetObjectArrayElement(env, ifArray, i, ifObj);\n+        (*env)->DeleteLocalRef(env, ifObj);\n@@ -1002,4 +538,4 @@\n-    \/* release the interface list *\/\n-    free_netif(ifList);\n-\n-    return netIFArr;\n+    FreeMibTable(ifTable);\n+    FreeMibTable(uniAddrs);\n+    FreeMibTable(anyAddrs);\n+    return ifArray;\n@@ -1013,18 +549,16 @@\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isUp0\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-  jboolean ret = JNI_FALSE;\n-\n-  \/\/ Retained for now to support IPv4 only stack, java.net.preferIPv4Stack\n-  if (ipv6_available()) {\n-    return Java_java_net_NetworkInterface_isUp0_XP(env, cls, name, index);\n-  } else {\n-    MIB_IFROW *ifRowP;\n-    ifRowP = getIF(index);\n-    if (ifRowP != NULL) {\n-      ret = ifRowP->dwAdminStatus == MIB_IF_ADMIN_STATUS_UP &&\n-            (ifRowP->dwOperStatus == MIB_IF_OPER_STATUS_OPERATIONAL ||\n-             ifRowP->dwOperStatus == MIB_IF_OPER_STATUS_CONNECTED);\n-      free(ifRowP);\n-    }\n-  }\n-    return ret;\n+JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isUp0(\n+        JNIEnv *env, jclass cls, jstring name, jint index) {\n+    MIB_IF_ROW2 ifRow = {0};\n+    ULONG apiRetVal;\n+\n+    ifRow.InterfaceIndex = index;\n+    apiRetVal = GetIfEntry2(&ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n+        return JNI_FALSE;\n+    }\n+    return ifRow.AdminStatus == NET_IF_ADMIN_STATUS_UP &&\n+            ifRow.OperStatus == IfOperStatusUp\n+            ? JNI_TRUE : JNI_FALSE;\n@@ -1038,21 +572,14 @@\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isP2P0\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-  MIB_IFROW *ifRowP;\n-  jboolean ret = JNI_FALSE;\n-\n-  \/\/ Retained for now to support IPv4 only stack, java.net.preferIPv4Stack\n-  if (ipv6_available()) {\n-    return Java_java_net_NetworkInterface_isP2P0_XP(env, cls, name, index);\n-  } else {\n-    ifRowP = getIF(index);\n-    if (ifRowP != NULL) {\n-      switch(ifRowP->dwType) {\n-      case MIB_IF_TYPE_PPP:\n-      case MIB_IF_TYPE_SLIP:\n-        ret = JNI_TRUE;\n-        break;\n-      }\n-      free(ifRowP);\n-    }\n-  }\n-  return ret;\n+JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isP2P0(\n+        JNIEnv *env, jclass cls, jstring name, jint index) {\n+    MIB_IF_ROW2 ifRow = {0};\n+    ULONG apiRetVal;\n+\n+    ifRow.InterfaceIndex = index;\n+    apiRetVal = GetIfEntry2(&ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n+        return JNI_FALSE;\n+    }\n+    return ifRow.AccessType == NET_IF_ACCESS_POINT_TO_POINT ? JNI_TRUE : JNI_FALSE;\n@@ -1066,28 +593,14 @@\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isLoopback0\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-  MIB_IFROW *ifRowP;\n-  jboolean ret = JNI_FALSE;\n-\n-  \/\/ Retained for now to support IPv4 only stack, java.net.preferIPv4Stack\n-  if (ipv6_available()) {\n-    return Java_java_net_NetworkInterface_isLoopback0_XP(env, cls, name, index);\n-  } else {\n-    ifRowP = getIF(index);\n-    if (ifRowP != NULL) {\n-      if (ifRowP->dwType == MIB_IF_TYPE_LOOPBACK)\n-        ret = JNI_TRUE;\n-      free(ifRowP);\n-    }\n-    return ret;\n-  }\n-}\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    supportsMulticast0\n- * Signature: (Ljava\/lang\/String;I)Z\n- *\/\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_supportsMulticast0\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-    return Java_java_net_NetworkInterface_supportsMulticast0_XP(env, cls,\n-                                                               name, index);\n+JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isLoopback0(\n+        JNIEnv *env, jclass cls, jstring name, jint index) {\n+    MIB_IF_ROW2 ifRow = {0};\n+    ULONG apiRetVal;\n+\n+    ifRow.InterfaceIndex = index;\n+    apiRetVal = GetIfEntry2(&ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n+        return JNI_FALSE;\n+    }\n+    return ifRow.Type == IF_TYPE_SOFTWARE_LOOPBACK ? JNI_TRUE : JNI_FALSE;\n@@ -1101,27 +614,13 @@\n-JNIEXPORT jbyteArray JNICALL Java_java_net_NetworkInterface_getMacAddr0\n-    (JNIEnv *env, jclass class, jbyteArray addrArray, jstring name, jint index) {\n-  jbyteArray ret = NULL;\n-  int len;\n-  MIB_IFROW *ifRowP;\n-\n-  \/\/ Retained for now to support IPv4 only stack, java.net.preferIPv4Stack\n-  if (ipv6_available()) {\n-    return Java_java_net_NetworkInterface_getMacAddr0_XP(env, class, name, index);\n-  } else {\n-    ifRowP = getIF(index);\n-    if (ifRowP != NULL) {\n-      switch(ifRowP->dwType) {\n-      case MIB_IF_TYPE_ETHERNET:\n-      case MIB_IF_TYPE_TOKENRING:\n-      case MIB_IF_TYPE_FDDI:\n-      case IF_TYPE_IEEE80211:\n-        len = ifRowP->dwPhysAddrLen;\n-        if (len > 0) {\n-            ret = (*env)->NewByteArray(env, len);\n-            if (!IS_NULL(ret)) {\n-              (*env)->SetByteArrayRegion(env, ret, 0, len, (jbyte *) ifRowP->bPhysAddr);\n-            }\n-        }\n-        break;\n-      }\n-      free(ifRowP);\n+JNIEXPORT jbyteArray JNICALL Java_java_net_NetworkInterface_getMacAddr0(\n+        JNIEnv *env, jclass class, jbyteArray addrArray, jstring name, jint index) {\n+    MIB_IF_ROW2 ifRow = {0};\n+    ULONG apiRetVal;\n+    jbyteArray macAddr;\n+\n+    ifRow.InterfaceIndex = index;\n+    apiRetVal = GetIfEntry2(&ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n+        return NULL;\n@@ -1129,2 +628,11 @@\n-    return ret;\n-  }\n+    if (ifRow.PhysicalAddressLength == 0) {\n+        return NULL;\n+    }\n+    macAddr = (*env)->NewByteArray(env, ifRow.PhysicalAddressLength);\n+    if (macAddr == NULL) {\n+        return NULL;\n+    }\n+    (*env)->SetByteArrayRegion(\n+            env, macAddr, 0, ifRow.PhysicalAddressLength,\n+            (jbyte *) ifRow.PhysicalAddress);\n+    return macAddr;\n@@ -1138,13 +646,12 @@\n-JNIEXPORT jint JNICALL Java_java_net_NetworkInterface_getMTU0\n-    (JNIEnv *env, jclass class, jstring name, jint index) {\n-  jint ret = -1;\n-  MIB_IFROW *ifRowP;\n-\n-  \/\/ Retained for now to support IPv4 only stack, java.net.preferIPv4Stack\n-  if (ipv6_available()) {\n-    return Java_java_net_NetworkInterface_getMTU0_XP(env, class, name, index);\n-  } else {\n-    ifRowP = getIF(index);\n-    if (ifRowP != NULL) {\n-      ret = ifRowP->dwMtu;\n-      free(ifRowP);\n+JNIEXPORT jint JNICALL Java_java_net_NetworkInterface_getMTU0(\n+        JNIEnv *env, jclass class, jstring name, jint index) {\n+    MIB_IF_ROW2 ifRow = {0};\n+    ULONG apiRetVal;\n+\n+    ifRow.InterfaceIndex = index;\n+    apiRetVal = GetIfEntry2(&ifRow);\n+    if (apiRetVal != NO_ERROR) {\n+        SetLastError(apiRetVal);\n+        NET_ThrowByNameWithLastError(\n+                env, JNU_JAVANETPKG \"SocketException\", \"GetIfEntry2\");\n+        return -1;\n@@ -1152,2 +659,53 @@\n-    return ret;\n-  }\n+    return ifRow.Mtu;\n+}\n+\n+\/*\n+ * Class:     java_net_NetworkInterface\n+ * Method:    supportsMulticast0\n+ * Signature: (Ljava\/lang\/String;I)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_supportsMulticast0(\n+        JNIEnv *env, jclass cls, jstring name, jint index) {\n+    \/\/ we assume that multicast is enabled, because there are no reliable APIs to tell us\n+    return JNI_TRUE;\n+}\n+\n+\/*\n+ * Class:     java_net_NetworkInterface\n+ * Method:    init\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL Java_java_net_NetworkInterface_init(JNIEnv *env, jclass cls) {\n+    \/*\n+     * Get the various JNI ids that we require\n+     *\/\n+    ni_class = (*env)->NewGlobalRef(env, cls);\n+    CHECK_NULL(ni_class);\n+    ni_nameID = (*env)->GetFieldID(env, ni_class, \"name\", \"Ljava\/lang\/String;\");\n+    CHECK_NULL(ni_nameID);\n+    ni_displayNameID = (*env)->GetFieldID(env, ni_class, \"displayName\", \"Ljava\/lang\/String;\");\n+    CHECK_NULL(ni_displayNameID);\n+    ni_indexID = (*env)->GetFieldID(env, ni_class, \"index\", \"I\");\n+    CHECK_NULL(ni_indexID);\n+    ni_addrsID = (*env)->GetFieldID(env, ni_class, \"addrs\", \"[Ljava\/net\/InetAddress;\");\n+    CHECK_NULL(ni_addrsID);\n+    ni_bindsID = (*env)->GetFieldID(env, ni_class, \"bindings\", \"[Ljava\/net\/InterfaceAddress;\");\n+    CHECK_NULL(ni_bindsID);\n+    ni_childsID = (*env)->GetFieldID(env, ni_class, \"childs\", \"[Ljava\/net\/NetworkInterface;\");\n+    CHECK_NULL(ni_childsID);\n+    ni_ctor = (*env)->GetMethodID(env, ni_class, \"<init>\", \"()V\");\n+    CHECK_NULL(ni_ctor);\n+    ni_ibcls = (*env)->FindClass(env, \"java\/net\/InterfaceAddress\");\n+    CHECK_NULL(ni_ibcls);\n+    ni_ibcls = (*env)->NewGlobalRef(env, ni_ibcls);\n+    CHECK_NULL(ni_ibcls);\n+    ni_ibctrID = (*env)->GetMethodID(env, ni_ibcls, \"<init>\", \"()V\");\n+    CHECK_NULL(ni_ibctrID);\n+    ni_ibaddressID = (*env)->GetFieldID(env, ni_ibcls, \"address\", \"Ljava\/net\/InetAddress;\");\n+    CHECK_NULL(ni_ibaddressID);\n+    ni_ibbroadcastID = (*env)->GetFieldID(env, ni_ibcls, \"broadcast\", \"Ljava\/net\/Inet4Address;\");\n+    CHECK_NULL(ni_ibbroadcastID);\n+    ni_ibmaskID = (*env)->GetFieldID(env, ni_ibcls, \"maskLength\", \"S\");\n+    CHECK_NULL(ni_ibmaskID);\n+\n+    initInetAddressIDs(env);\n","filename":"src\/java.base\/windows\/native\/libnet\/NetworkInterface.c","additions":496,"deletions":938,"binary":false,"changes":1434,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,5 +34,4 @@\n-typedef struct _netaddr  {\n-    SOCKETADDRESS    addr;                  \/* IPv4 or IPv6 address *\/\n-    SOCKETADDRESS    brdcast;\n-    short            mask;\n-    struct _netaddr *next;\n+typedef struct _netaddr {\n+    SOCKADDR_INET Address;\n+    UINT8 PrefixLength;\n+    struct _netaddr *Next;\n@@ -41,44 +40,0 @@\n-typedef struct _netif {\n-    char *name;\n-    char *displayName;\n-    DWORD dwIndex;              \/* Internal index *\/\n-    DWORD ifType;               \/* Interface type *\/\n-    int index;                  \/* Friendly index *\/\n-    struct _netif *next;\n-\n-    \/* Following fields used on Windows XP when IPv6 is used only *\/\n-    jboolean hasIpv6Address;    \/* true when following fields valid *\/\n-    jboolean dNameIsUnicode;    \/* Display Name is Unicode *\/\n-    int naddrs;                 \/* Number of addrs *\/\n-    DWORD ipv6Index;\n-    struct _netaddr *addrs;     \/* addr list for interfaces *\/\n-} netif;\n-\n-extern void free_netif(netif *netifP);\n-extern void free_netaddr(netaddr *netaddrP);\n-\n-\/* various JNI ids *\/\n-extern jclass ni_class;             \/* NetworkInterface *\/\n-\n-extern jmethodID ni_ctor;           \/* NetworkInterface() *\/\n-\n-extern jfieldID ni_indexID;         \/* NetworkInterface.index *\/\n-extern jfieldID ni_addrsID;         \/* NetworkInterface.addrs *\/\n-extern jfieldID ni_bindsID;         \/* NetworkInterface.bindings *\/\n-extern jfieldID ni_nameID;          \/* NetworkInterface.name *\/\n-extern jfieldID ni_displayNameID;   \/* NetworkInterface.displayName *\/\n-extern jfieldID ni_childsID;        \/* NetworkInterface.childs *\/\n-\n-extern jclass ni_ibcls;             \/* InterfaceAddress *\/\n-extern jmethodID ni_ibctrID;        \/* InterfaceAddress() *\/\n-extern jfieldID ni_ibaddressID;     \/* InterfaceAddress.address *\/\n-extern jfieldID ni_ibbroadcastID;   \/* InterfaceAddress.broadcast *\/\n-extern jfieldID ni_ibmaskID;        \/* InterfaceAddress.maskLength *\/\n-\n-int enumInterfaces(JNIEnv *env, netif **netifPP);\n-\n-\/\/ Windows Visa (and later) only.....\n-#ifndef IF_TYPE_IEEE80211\n-#define IF_TYPE_IEEE80211     71\n-#endif\n-\n","filename":"src\/java.base\/windows\/native\/libnet\/NetworkInterface.h","additions":5,"deletions":50,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1,1010 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include \"net_util.h\"\n-#include \"NetworkInterface.h\"\n-\n-#include \"java_net_NetworkInterface.h\"\n-\n-\/*\n- * Windows implementation of the java.net.NetworkInterface native methods.\n- * This module provides the implementations of getAll, getByName, getByIndex,\n- * and getByAddress.\n- *\/\n-\n-extern int enumAddresses_win_ipaddrtable(JNIEnv *env, netif *netifP, netaddr **netaddrPP, MIB_IPADDRTABLE *tableP);\n-extern int enumAddresses_win(JNIEnv *env, netif *netifP, netaddr **netaddrPP);\n-extern int lookupIPAddrTable(JNIEnv *env, MIB_IPADDRTABLE **tablePP);\n-int getAddrsFromAdapter(IP_ADAPTER_ADDRESSES *ptr, netaddr **netaddrPP);\n-\n-#ifdef DEBUG\n-void printnif (netif *nif) {\n-#ifdef _WIN64\n-        printf (\"nif:0x%I64x name:%s\\n\", (UINT_PTR)nif, nif->name);\n-#else\n-        printf (\"nif:0x%x name:%s\\n\", (UINT_PTR)nif, nif->name);\n-#endif\n-        if (nif->dNameIsUnicode) {\n-            printf (\"dName:%S index:%d \", (unsigned short *)nif->displayName,\n-                nif->index);\n-        } else {\n-            printf (\"dName:%s index:%d \", nif->displayName, nif->index);\n-        }\n-        printf (\"naddrs:%d\\n\", nif->naddrs);\n-}\n-\n-void printnifs (netif *netifPP, char *str) {\n-    netif *nif;\n-    printf (\"%s\\n\", str);\n-    for (nif=netifPP; nif!=NULL; nif=nif->next) {\n-        printnif (nif);\n-    }\n-    printf(\"-----------------\\n\");\n-}\n-\n-#endif\n-\n-const ULONG BUFF_SIZE = 15360;\n-const int MAX_TRIES = 3;\n-\n-\/*\n- * return an array of IP_ADAPTER_ADDRESSES containing one element\n- * for each adapter on the system. Returned in *adapters.\n- * Buffer is malloc'd and must be freed (unless error returned)\n- *\/\n-int getAdapters (JNIEnv *env, int flags, IP_ADAPTER_ADDRESSES **adapters) {\n-    DWORD ret;\n-    IP_ADAPTER_ADDRESSES *adapterInfo;\n-    ULONG len;\n-    int try;\n-\n-    *adapters = NULL;\n-\n-    adapterInfo = (IP_ADAPTER_ADDRESSES *) malloc(BUFF_SIZE);\n-    if (adapterInfo == NULL) {\n-        JNU_ThrowByName(env, \"java\/lang\/OutOfMemoryError\",\n-            \"Native heap allocation failure\");\n-        return -1;\n-    }\n-\n-    len = BUFF_SIZE;\n-    ret = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &len);\n-\n-    for (try = 0; ret == ERROR_BUFFER_OVERFLOW && try < MAX_TRIES; ++try) {\n-        IP_ADAPTER_ADDRESSES * newAdapterInfo = NULL;\n-        if (len < (ULONG_MAX - BUFF_SIZE)) {\n-            len += BUFF_SIZE;\n-        }\n-        newAdapterInfo =\n-            (IP_ADAPTER_ADDRESSES *) realloc (adapterInfo, len);\n-        if (newAdapterInfo == NULL) {\n-            free(adapterInfo);\n-            JNU_ThrowByName(env, \"java\/lang\/OutOfMemoryError\",\n-                \"Native heap allocation failure\");\n-            return -1;\n-        }\n-\n-        adapterInfo = newAdapterInfo;\n-\n-        ret = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &len);\n-    }\n-\n-    if (ret != ERROR_SUCCESS) {\n-        free (adapterInfo);\n-        switch (ret) {\n-            case ERROR_INVALID_PARAMETER:\n-                JNU_ThrowInternalError(env,\n-                    \"IP Helper Library GetAdaptersAddresses function failed: \"\n-                    \"invalid parameter\");\n-                break;\n-            case ERROR_NOT_ENOUGH_MEMORY:\n-                JNU_ThrowOutOfMemoryError(env,\n-                    \"IP Helper Library GetAdaptersAddresses function failed: \"\n-                    \"not enough memory\");\n-                break;\n-            case ERROR_NO_DATA:\n-                \/\/ not an error\n-                *adapters = NULL;\n-                return ERROR_SUCCESS;\n-            default:\n-                SetLastError(ret);\n-                JNU_ThrowByNameWithMessageAndLastError(env,\n-                    JNU_JAVANETPKG \"SocketException\",\n-                    \"IP Helper Library GetAdaptersAddresses function failed\");\n-                break;\n-        }\n-\n-        return -1;\n-    }\n-    *adapters = adapterInfo;\n-    return ERROR_SUCCESS;\n-}\n-\n-\/*\n- * return an array of IP_ADAPTER_ADDRESSES containing one element\n- * for each adapter on the system. Returned in *adapters.\n- * Buffer is malloc'd and must be freed (unless error returned)\n- *\/\n-IP_ADAPTER_ADDRESSES *getAdapter (JNIEnv *env,  jint index) {\n-    DWORD flags, val;\n-    IP_ADAPTER_ADDRESSES *adapterInfo, *ptr, *ret;\n-    ULONG len;\n-    int try;\n-    adapterInfo = (IP_ADAPTER_ADDRESSES *) malloc(BUFF_SIZE);\n-    if (adapterInfo == NULL) {\n-        JNU_ThrowByName(env, \"java\/lang\/OutOfMemoryError\",\n-            \"Native heap allocation failure\");\n-        return NULL;\n-    }\n-    len = BUFF_SIZE;\n-    flags = GAA_FLAG_SKIP_DNS_SERVER;\n-    flags |= GAA_FLAG_SKIP_MULTICAST;\n-    flags |= GAA_FLAG_INCLUDE_PREFIX;\n-    val = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &len);\n-    for (try = 0; val == ERROR_BUFFER_OVERFLOW && try < MAX_TRIES; ++try) {\n-        IP_ADAPTER_ADDRESSES * newAdapterInfo = NULL;\n-        if (len < (ULONG_MAX - BUFF_SIZE)) {\n-            len += BUFF_SIZE;\n-        }\n-        newAdapterInfo =\n-                (IP_ADAPTER_ADDRESSES *) realloc (adapterInfo, len);\n-        if (newAdapterInfo == NULL) {\n-            free(adapterInfo);\n-            JNU_ThrowByName(env, \"java\/lang\/OutOfMemoryError\",\n-                \"Native heap allocation failure\");\n-            return NULL;\n-        }\n-\n-        adapterInfo = newAdapterInfo;\n-\n-        val = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &len);\n-    }\n-\n-    if (val != ERROR_SUCCESS) {\n-        free (adapterInfo);\n-        switch (val) {\n-            case ERROR_INVALID_PARAMETER:\n-                JNU_ThrowInternalError(env,\n-                    \"IP Helper Library GetAdaptersAddresses function failed: \"\n-                    \"invalid parameter\");\n-                break;\n-            case ERROR_NOT_ENOUGH_MEMORY:\n-                JNU_ThrowOutOfMemoryError(env,\n-                    \"IP Helper Library GetAdaptersAddresses function failed: \"\n-                    \"not enough memory\");\n-                break;\n-            case ERROR_NO_DATA:\n-                \/\/ not an error\n-                break;\n-            default:\n-                SetLastError(val);\n-                JNU_ThrowByNameWithMessageAndLastError(env,\n-                    JNU_JAVANETPKG \"SocketException\",\n-                    \"IP Helper Library GetAdaptersAddresses function failed\");\n-                break;\n-        }\n-        return NULL;\n-    }\n-\n-    ptr = adapterInfo;\n-    ret = NULL;\n-    while (ptr != NULL) {\n-      \/\/ in theory the IPv4 index and the IPv6 index can be the same\n-      \/\/ where an interface is enabled for v4 and v6\n-      \/\/ IfIndex == 0 IPv4 not available on this interface\n-      \/\/ Ipv6IfIndex == 0 IPv6 not available on this interface\n-      if (((ptr->IfIndex != 0)&&(ptr->IfIndex == index)) ||\n-          ((ptr->Ipv6IfIndex !=0) && (ptr->Ipv6IfIndex == index))) {\n-        ret = (IP_ADAPTER_ADDRESSES *) malloc(sizeof(IP_ADAPTER_ADDRESSES));\n-        if (ret == NULL) {\n-            free(adapterInfo);\n-            JNU_ThrowByName(env, \"java\/lang\/OutOfMemoryError\",\n-                \"Native heap allocation failure\");\n-            return NULL;\n-        }\n-\n-        \/\/copy the memory and break out of the while loop.\n-        memcpy(ret, ptr, sizeof(IP_ADAPTER_ADDRESSES));\n-        break;\n-\n-      }\n-      ptr=ptr->Next;\n-    }\n-    free(adapterInfo);\n-    return ret;\n-}\n-\n-\/*\n- *\/\n-int getAllInterfacesAndAddresses (JNIEnv *env, netif **netifPP)\n-{\n-    int ret, flags;\n-    MIB_IPADDRTABLE *tableP;\n-    IP_ADAPTER_ADDRESSES *ptr, *adapters=NULL;\n-    ULONG count=0;\n-    netif *nif=NULL, *dup_nif, *last=NULL, *loopif=NULL, *curr;\n-    int tun=0, net=0;\n-\n-   \/*\n-    * Get the IPv4 interfaces. This information is the same\n-    * as what previous JDK versions would return.\n-    *\/\n-\n-    ret = enumInterfaces(env, netifPP);\n-    if (ret < 0) {\n-        return -1;\n-    } else {\n-        count = ret;\n-    }\n-\n-    \/* locate the loopback (and the last) interface *\/\n-    for (nif=*netifPP, last=nif; nif!=NULL; nif=nif->next) {\n-        if (nif->ifType == MIB_IF_TYPE_LOOPBACK) {\n-            loopif = nif;\n-        }\n-        last = nif;\n-    }\n-\n-    \/\/ Retrieve IPv4 addresses with the IP Helper API\n-    curr = *netifPP;\n-    ret = lookupIPAddrTable(env, &tableP);\n-    if (ret == -1) {\n-      free_netif(*netifPP);\n-      return -1;\n-    } else if (ret == -2) {\n-        \/\/ Clear the exception and continue.\n-        if ((*env)->ExceptionCheck(env)) {\n-            (*env)->ExceptionClear(env);\n-        }\n-        tableP = NULL;\n-    }\n-    while (curr != NULL) {\n-        netaddr *netaddrP;\n-        ret = enumAddresses_win_ipaddrtable(env, curr, &netaddrP, tableP);\n-        if (ret < 0) {\n-            free_netif(*netifPP);\n-            free(tableP);\n-            return -1;\n-        } else{\n-            curr->addrs = netaddrP;\n-            curr->naddrs += ret;\n-            curr = curr->next;\n-        }\n-    }\n-    free(tableP);\n-\n-    flags = GAA_FLAG_SKIP_DNS_SERVER;\n-    flags |= GAA_FLAG_SKIP_MULTICAST;\n-    flags |= GAA_FLAG_INCLUDE_PREFIX;\n-    ret = getAdapters (env, flags, &adapters);\n-    if (ret != ERROR_SUCCESS) {\n-        free_netif(*netifPP);\n-        return -1;\n-    }\n-\n-    \/* Now get the IPv6 information. This includes:\n-     *  (a)  IPv6 information associated with interfaces already found\n-     *  (b)  IPv6 information for IPv6 only interfaces (probably tunnels)\n-     *\n-     * For compatibility with previous releases we use the naming\n-     * information gotten from enumInterfaces() for (a) entries\n-     * However, the index numbers are taken from the new API.\n-     *\n-     * The procedure is to go through the list of adapters returned\n-     * by the new API looking for entries that correspond to IPv4 interfaces\n-     * already found.\n-     *\/\n-\n-    ptr = adapters;\n-    while (ptr != NULL) {\n-        int c;\n-        netif *nif0;\n-        if (ptr->IfType == IF_TYPE_SOFTWARE_LOOPBACK && (loopif != NULL)) {\n-            c = getAddrsFromAdapter(ptr, &loopif->addrs);\n-            if (c == -1) {\n-                goto err;\n-            }\n-            loopif->naddrs += c;\n-            loopif->ipv6Index = ptr->Ipv6IfIndex;\n-        } else {\n-            int index = ptr->IfIndex;\n-            if (index != 0) {\n-                \/* This entry is associated with an IPv4 interface *\/\n-                for (nif=*netifPP; nif!=NULL; nif=nif->next) {\n-                    if (nif->index == index) {\n-                        \/* found the interface entry\n-                         * set the index to the IPv6 index and add the\n-                         * IPv6 addresses\n-                         *\/\n-                        nif->ipv6Index = ptr->Ipv6IfIndex;\n-                        c = getAddrsFromAdapter(ptr, &nif->addrs);\n-                        if (c == -1) {\n-                            goto err;\n-                        }\n-                        nif->naddrs += c;\n-                        break;\n-                    }\n-                }\n-            } else {\n-                \/* This entry is IPv6 only *\/\n-                char newname [128];\n-                int c;\n-\n-                \/* Windows allocates duplicate adapter entries\n-                 * for tunnel interfaces when there are multiple\n-                 * physical adapters. Need to check\n-                 * if this is a duplicate (ipv6Index is the same)\n-                 *\/\n-                dup_nif = 0;\n-                for (nif0=*netifPP; nif0!=NULL; nif0=nif0->next) {\n-                    if (nif0->hasIpv6Address &&\n-                                ptr->Ipv6IfIndex == nif0->ipv6Index) {\n-                        dup_nif = nif0;\n-                        break;\n-                    }\n-                }\n-                if (dup_nif == 0) {\n-                    \/* new interface *\/\n-                        nif = (netif *) calloc (1, sizeof(netif));\n-                        if (nif == 0) {\n-                            goto err;\n-                        }\n-                        if (ptr->IfType == IF_TYPE_TUNNEL) {\n-                                sprintf (newname, \"tun%d\", tun);\n-                                tun ++;\n-                        } else {\n-                                sprintf (newname, \"net%d\", net);\n-                                net ++;\n-                        }\n-                        nif->name = malloc (strlen(newname)+1);\n-                        nif->displayName = malloc (wcslen(ptr->FriendlyName)*2+2);\n-                        if (nif->name == 0 || nif->displayName == 0) {\n-                                free(nif);\n-                                goto err;\n-                        }\n-                        strcpy (nif->name, newname);\n-                        wcscpy ((PWCHAR)nif->displayName, ptr->FriendlyName);\n-                        nif->dNameIsUnicode = TRUE;\n-\n-                        \/\/ the java.net.NetworkInterface abstraction only has index\n-                        \/\/ so the Ipv6IfIndex needs to map onto index\n-                        nif->index = ptr->Ipv6IfIndex;\n-                        nif->ipv6Index = ptr->Ipv6IfIndex;\n-                        nif->hasIpv6Address = TRUE;\n-\n-                        if (last) {\n-                                last->next = nif;\n-                        } else {\n-                                *netifPP = nif;\n-                        }\n-                        last = nif;\n-                        count++;\n-                        c = getAddrsFromAdapter(ptr, &nif->addrs);\n-                        if (c == -1) {\n-                                goto err;\n-                        }\n-                        nif->naddrs += c;\n-                 } else {\n-                        \/* add the addresses from this adapter to the\n-                         * original (dup_nif)\n-                         *\/\n-                        c = getAddrsFromAdapter(ptr, &dup_nif->addrs);\n-                        if (c == -1) {\n-                                goto err;\n-                        }\n-                        dup_nif->naddrs += c;\n-                }\n-            }\n-        }\n-        ptr=ptr->Next;\n-    }\n-\n-    free (adapters);\n-    return count;\n-\n-err:\n-    if (*netifPP) {\n-        free_netif (*netifPP);\n-    }\n-    if (adapters) {\n-        free (adapters);\n-    }\n-    return -1;\n-}\n-\n-\/* If *netaddrPP is null, then the addresses are allocated and the beginning\n- * of the allocated chain is returned in *netaddrPP.\n- * If *netaddrPP is not null, then the addresses allocated here are appended\n- * to the existing chain.\n- *\n- * Returns count of addresses or -1 on error.\n- *\/\n-\n-static int getAddrsFromAdapter(IP_ADAPTER_ADDRESSES *ptr, netaddr **netaddrPP) {\n-        LPSOCKADDR sock;\n-        int        count = 0;\n-        netaddr    *curr, *start = NULL, *prev = NULL;\n-        PIP_ADAPTER_UNICAST_ADDRESS uni_addr;\n-        PIP_ADAPTER_ANYCAST_ADDRESS any_addr;\n-        PIP_ADAPTER_PREFIX prefix;\n-\n-        \/* If chain passed in, find end *\/\n-        if (*netaddrPP != NULL) {\n-            for (start=*netaddrPP; start->next!=NULL; start=start->next)\n-                ;\n-\n-            prev=start;\n-        }\n-\n-        prefix = ptr->FirstPrefix;\n-        \/* Unicast *\/\n-        uni_addr = ptr->FirstUnicastAddress;\n-        while (uni_addr != NULL) {\n-        \/* address is only usable if dad state is preferred or deprecated *\/\n-                if (uni_addr->DadState == IpDadStateDeprecated ||\n-                                uni_addr->DadState == IpDadStatePreferred) {\n-                        sock = uni_addr->Address.lpSockaddr;\n-\n-                        \/\/ IPv4 addresses already retrieved with enumAddresses_win\n-                        if (sock->sa_family == AF_INET) {\n-                                uni_addr = uni_addr->Next;\n-                                continue;\n-                        }\n-\n-            curr = (netaddr *)calloc (1, sizeof (netaddr));\n-\n-            if (curr == NULL)\n-                goto freeAllocatedMemory;\n-\n-            if (start == NULL)\n-                start = curr;\n-\n-            if (prev != NULL)\n-               prev->next = curr;\n-\n-            prev = curr;\n-            SOCKETADDRESS_COPY (&curr->addr, sock);\n-            if (prefix != NULL) {\n-              curr->mask = (short)prefix->PrefixLength;\n-              prefix = prefix->Next;\n-            }\n-            count ++;\n-        }\n-        uni_addr = uni_addr->Next;\n-    }\n-    \/* Anycast *\/\n-    any_addr = ptr->FirstAnycastAddress;\n-    while (any_addr != NULL) {\n-        curr = (netaddr *)calloc (1, sizeof (netaddr));\n-\n-        if (curr == NULL)\n-            goto freeAllocatedMemory;\n-\n-        if (start == NULL)\n-            start = curr;\n-\n-        if (prev != NULL)\n-            prev->next = curr;\n-\n-        prev = curr;\n-        sock = any_addr->Address.lpSockaddr;\n-        SOCKETADDRESS_COPY (&curr->addr, sock);\n-        count ++;\n-        any_addr = any_addr->Next;\n-    }\n-    if (*netaddrPP == NULL) {\n-        *netaddrPP = start;\n-    }\n-    return count;\n-\n-freeAllocatedMemory:\n-\n-    if (*netaddrPP != NULL) {\n-        \/\/N.B. the variable \"start\" cannot be NULL at this point because we started with an\n-        \/\/existing list.\n-        curr=start->next;\n-        start->next = NULL;\n-        start = curr;\n-    }\n-    \/\/ otherwise, \"start\" points to the beginning of an incomplete list that we must deallocate.\n-\n-    while (start != NULL) {\n-        curr = start->next;\n-        free(start);\n-        start = curr;\n-    }\n-\n-    return -1;\n-}\n-\n-\/*\n- * Create a NetworkInterface object, populate the name and index, and\n- * populate the InetAddress array based on the IP addresses for this\n- * interface.\n- *\/\n-static jobject createNetworkInterfaceXP(JNIEnv *env, netif *ifs)\n-{\n-    jobject netifObj;\n-    jobject name, displayName;\n-    jobjectArray addrArr, bindsArr, childArr;\n-    netaddr *addrs;\n-    jint addr_index;\n-    int netaddrCount = ifs->naddrs;\n-    netaddr *netaddrP = ifs->addrs;\n-    netaddr *netaddrPToFree = NULL;\n-    jint bind_index;\n-\n-    \/*\n-     * Create a NetworkInterface object and populate it\n-     *\/\n-    netifObj = (*env)->NewObject(env, ni_class, ni_ctor);\n-    if (netifObj == NULL) {\n-        return NULL;\n-    }\n-    name = (*env)->NewStringUTF(env, ifs->name);\n-    if (name == NULL) {\n-        return NULL;\n-    }\n-    if (ifs->dNameIsUnicode) {\n-        displayName = (*env)->NewString(env, (PWCHAR)ifs->displayName,\n-                                        (jsize)wcslen ((PWCHAR)ifs->displayName));\n-    } else {\n-        displayName = (*env)->NewStringUTF(env, ifs->displayName);\n-    }\n-    if (displayName == NULL) {\n-        return NULL;\n-    }\n-    (*env)->SetObjectField(env, netifObj, ni_nameID, name);\n-    (*env)->DeleteLocalRef(env, name);\n-    (*env)->SetObjectField(env, netifObj, ni_displayNameID, displayName);\n-    (*env)->DeleteLocalRef(env, displayName);\n-    (*env)->SetIntField(env, netifObj, ni_indexID, ifs->index);\n-    \/*\n-     * Get the IP addresses for this interface if necessary\n-     * Note that 0 is a valid number of addresses.\n-     *\/\n-    if (netaddrCount < 0) {\n-        netaddrCount = enumAddresses_win(env, ifs, &netaddrPToFree);\n-        if (netaddrCount == -1) {\n-            return NULL;\n-        }\n-        if (netaddrCount == -2) {\n-            \/\/ Clear the exception and continue.\n-            if ((*env)->ExceptionCheck(env)) {\n-                (*env)->ExceptionClear(env);\n-            }\n-            netaddrCount = 0;\n-            netaddrPToFree = NULL;\n-        }\n-        netaddrP = netaddrPToFree;\n-    }\n-\n-    addrArr = (*env)->NewObjectArray(env, netaddrCount, ia_class, NULL);\n-    if (addrArr == NULL) {\n-        free_netaddr(netaddrPToFree);\n-        return NULL;\n-    }\n-\n-    bindsArr = (*env)->NewObjectArray(env, netaddrCount, ni_ibcls, NULL);\n-    if (bindsArr == NULL) {\n-        free_netaddr(netaddrPToFree);\n-        return NULL;\n-    }\n-\n-    addrs = netaddrP;\n-    addr_index = 0;\n-    bind_index = 0;\n-    while (addrs != NULL) {\n-        jobject iaObj, ia2Obj;\n-        jobject ibObj = NULL;\n-        if (addrs->addr.sa.sa_family == AF_INET) {\n-            iaObj = (*env)->NewObject(env, ia4_class, ia4_ctrID);\n-            if (iaObj == NULL) {\n-                free_netaddr(netaddrPToFree);\n-                return NULL;\n-            }\n-            \/* default ctor will set family to AF_INET *\/\n-\n-            setInetAddress_addr(env, iaObj, ntohl(addrs->addr.sa4.sin_addr.s_addr));\n-            if ((*env)->ExceptionCheck(env)) {\n-                free_netaddr(netaddrPToFree);\n-                return NULL;\n-            }\n-            ibObj = (*env)->NewObject(env, ni_ibcls, ni_ibctrID);\n-            if (ibObj == NULL) {\n-                free_netaddr(netaddrPToFree);\n-                return NULL;\n-            }\n-            (*env)->SetObjectField(env, ibObj, ni_ibaddressID, iaObj);\n-            ia2Obj = (*env)->NewObject(env, ia4_class, ia4_ctrID);\n-            if (ia2Obj == NULL) {\n-                free_netaddr(netaddrPToFree);\n-                return NULL;\n-            }\n-            setInetAddress_addr(env, ia2Obj, ntohl(addrs->brdcast.sa4.sin_addr.s_addr));\n-            if ((*env)->ExceptionCheck(env)) {\n-                free_netaddr(netaddrPToFree);\n-                return NULL;\n-            }\n-            (*env)->SetObjectField(env, ibObj, ni_ibbroadcastID, ia2Obj);\n-            (*env)->DeleteLocalRef(env, ia2Obj);\n-            (*env)->SetShortField(env, ibObj, ni_ibmaskID, addrs->mask);\n-            (*env)->SetObjectArrayElement(env, bindsArr, bind_index++, ibObj);\n-            (*env)->DeleteLocalRef(env, ibObj);\n-        } else \/* AF_INET6 *\/ {\n-            int scope;\n-            jboolean ret;\n-            iaObj = (*env)->NewObject(env, ia6_class, ia6_ctrID);\n-            if (iaObj == NULL) {\n-                free_netaddr(netaddrPToFree);\n-                return NULL;\n-            }\n-            ret = setInet6Address_ipaddress(env, iaObj, (jbyte *)&(addrs->addr.sa6.sin6_addr.s6_addr));\n-            if (ret == JNI_FALSE) {\n-                free_netaddr(netaddrPToFree);\n-                return NULL;\n-            }\n-            scope = addrs->addr.sa6.sin6_scope_id;\n-            if (scope != 0) { \/* zero is default value, no need to set *\/\n-                setInet6Address_scopeid(env, iaObj, scope);\n-                setInet6Address_scopeifname(env, iaObj, netifObj);\n-            }\n-            ibObj = (*env)->NewObject(env, ni_ibcls, ni_ibctrID);\n-            if (ibObj == NULL) {\n-                free_netaddr(netaddrPToFree);\n-                return NULL;\n-            }\n-            (*env)->SetObjectField(env, ibObj, ni_ibaddressID, iaObj);\n-            (*env)->SetShortField(env, ibObj, ni_ibmaskID, addrs->mask);\n-            (*env)->SetObjectArrayElement(env, bindsArr, bind_index++, ibObj);\n-            (*env)->DeleteLocalRef(env, ibObj);\n-        }\n-        (*env)->SetObjectArrayElement(env, addrArr, addr_index, iaObj);\n-        (*env)->DeleteLocalRef(env, iaObj);\n-        addrs = addrs->next;\n-        addr_index++;\n-    }\n-    (*env)->SetObjectField(env, netifObj, ni_addrsID, addrArr);\n-    (*env)->DeleteLocalRef(env, addrArr);\n-    (*env)->SetObjectField(env, netifObj, ni_bindsID, bindsArr);\n-    (*env)->DeleteLocalRef(env, bindsArr);\n-\n-    free_netaddr(netaddrPToFree);\n-\n-    \/*\n-     * Windows doesn't have virtual interfaces, so child array\n-     * is always empty.\n-     *\/\n-    childArr = (*env)->NewObjectArray(env, 0, ni_class, NULL);\n-    if (childArr == NULL) {\n-      return NULL;\n-    }\n-    (*env)->SetObjectField(env, netifObj, ni_childsID, childArr);\n-    (*env)->DeleteLocalRef(env, childArr);\n-\n-    \/* return the NetworkInterface *\/\n-    return netifObj;\n-}\n-\n-JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByName0_XP\n-    (JNIEnv *env, jclass cls, jstring name)\n-{\n-    netif *ifList, *curr;\n-    jboolean isCopy;\n-    const char *name_utf;\n-    jobject netifObj = NULL;\n-\n-    if (getAllInterfacesAndAddresses (env, &ifList) < 0) {\n-        return NULL;\n-    }\n-\n-    \/* get the name as a C string *\/\n-    name_utf = (*env)->GetStringUTFChars(env, name, &isCopy);\n-\n-    \/* Search by name *\/\n-    curr = ifList;\n-    while (curr != NULL) {\n-        if (strcmp(name_utf, curr->name) == 0) {\n-            break;\n-        }\n-        curr = curr->next;\n-    }\n-\n-    \/* if found create a NetworkInterface *\/\n-    if (curr != NULL) {\n-        netifObj = createNetworkInterfaceXP(env, curr);\n-    }\n-\n-    \/* release the UTF string *\/\n-    (*env)->ReleaseStringUTFChars(env, name, name_utf);\n-\n-    \/* release the interface list *\/\n-    free_netif(ifList);\n-\n-    return netifObj;\n-}\n-\n-\/*\n- * Class:     NetworkInterface\n- * Method:    getByIndex0_XP\n- * Signature: (I)LNetworkInterface;\n- *\/\n-JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByIndex0_XP\n-  (JNIEnv *env, jclass cls, jint index)\n-{\n-    netif *ifList, *curr;\n-    jobject netifObj = NULL;\n-\n-    if (getAllInterfacesAndAddresses (env, &ifList) < 0) {\n-        return NULL;\n-    }\n-\n-    \/* search by index *\/\n-    curr = ifList;\n-    while (curr != NULL) {\n-        if (index == curr->index) {\n-            break;\n-        }\n-        curr = curr->next;\n-    }\n-\n-    \/* if found create a NetworkInterface *\/\n-    if (curr != NULL) {\n-        netifObj = createNetworkInterfaceXP(env, curr);\n-    }\n-\n-    \/* release the interface list *\/\n-    free_netif(ifList);\n-\n-    return netifObj;\n-}\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    getByInetAddress0\n- * Signature: (Ljava\/net\/InetAddress;)Ljava\/net\/NetworkInterface;\n- *\/\n-JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByInetAddress0_XP\n-    (JNIEnv *env, jclass cls, jobject iaObj)\n-{\n-    netif *ifList, *curr;\n-    jobject netifObj = NULL;\n-\n-    \/* get the list of interfaces *\/\n-    if (getAllInterfacesAndAddresses (env, &ifList) < 0) {\n-        return NULL;\n-    }\n-\n-    \/*\n-     * Enumerate the addresses on each interface until we find a\n-     * matching address.\n-     *\/\n-    curr = ifList;\n-    while (curr != NULL) {\n-        netaddr *addrList = curr->addrs;\n-        netaddr *addrP;\n-\n-        \/* iterate through each address *\/\n-        addrP = addrList;\n-\n-        while (addrP != NULL) {\n-            if (NET_SockaddrEqualsInetAddress(env,\n-                                (struct sockaddr*)&addrP->addr, iaObj)) {\n-                break;\n-            }\n-            addrP = addrP->next;\n-        }\n-\n-        \/*\n-         * Address matched so create NetworkInterface for this interface\n-         * and address list.\n-         *\/\n-        if (addrP != NULL) {\n-            netifObj = createNetworkInterfaceXP(env, curr);\n-            break;\n-        }\n-\n-        \/* on next interface *\/\n-        curr = curr->next;\n-    }\n-\n-    \/* release the interface list *\/\n-    free_netif(ifList);\n-\n-    return netifObj;\n-}\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    getAll\n- * Signature: ()[Ljava\/net\/NetworkInterface;\n- *\/\n-JNIEXPORT jobjectArray JNICALL Java_java_net_NetworkInterface_getAll_XP\n-    (JNIEnv *env, jclass cls)\n-{\n-    int count;\n-    netif *ifList, *curr;\n-    jobjectArray netIFArr;\n-    jint arr_index;\n-\n-    \/*\n-     * Get list of interfaces\n-     *\/\n-    count = getAllInterfacesAndAddresses (env, &ifList);\n-    if (count < 0) {\n-        return NULL;\n-    }\n-\n-    \/* allocate a NetworkInterface array *\/\n-    netIFArr = (*env)->NewObjectArray(env, count, cls, NULL);\n-    if (netIFArr == NULL) {\n-        free_netif(ifList);\n-        return NULL;\n-    }\n-\n-    \/*\n-     * Iterate through the interfaces, create a NetworkInterface instance\n-     * for each array element and populate the object.\n-     *\/\n-    curr = ifList;\n-    arr_index = 0;\n-    while (curr != NULL) {\n-        jobject netifObj;\n-\n-        netifObj = createNetworkInterfaceXP(env, curr);\n-        if (netifObj == NULL) {\n-            free_netif(ifList);\n-            return NULL;\n-        }\n-\n-        \/* put the NetworkInterface into the array *\/\n-        (*env)->SetObjectArrayElement(env, netIFArr, arr_index++, netifObj);\n-        (*env)->DeleteLocalRef(env, netifObj);\n-        curr = curr->next;\n-    }\n-\n-    \/* release the interface list *\/\n-    free_netif(ifList);\n-\n-    return netIFArr;\n-}\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    supportsMulticast0\n- * Signature: (Ljava\/lang\/String;I)Z\n- *\/\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_supportsMulticast0_XP\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-      IP_ADAPTER_ADDRESSES *ptr;\n-      jboolean val = JNI_TRUE;\n-\n-      ptr = getAdapter(env, index);\n-      if (ptr != NULL) {\n-        val = ptr->Flags & IP_ADAPTER_NO_MULTICAST ? JNI_FALSE : JNI_TRUE;\n-        free(ptr);\n-      }\n-      return val;\n-}\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    isUp0\n- * Signature: (Ljava\/lang\/String;I)Z\n- *\/\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isUp0_XP\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-      IP_ADAPTER_ADDRESSES *ptr;\n-      jboolean val = JNI_FALSE;\n-\n-      ptr = getAdapter(env, index);\n-      if (ptr != NULL) {\n-        val = ptr->OperStatus == IfOperStatusUp ? JNI_TRUE : JNI_FALSE;\n-        free(ptr);\n-      }\n-      return val;\n-}\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    getMacAddr0\n- * Signature: (Ljava\/lang\/String;I)Z\n- *\/\n-JNIEXPORT jbyteArray JNICALL Java_java_net_NetworkInterface_getMacAddr0_XP\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-      IP_ADAPTER_ADDRESSES *ptr;\n-      jbyteArray ret = NULL;\n-      int len;\n-\n-      ptr = getAdapter(env, index);\n-      if (ptr != NULL) {\n-        len = ptr->PhysicalAddressLength;\n-        if (len > 0) {\n-          ret = (*env)->NewByteArray(env, len);\n-          if (!IS_NULL(ret)) {\n-            (*env)->SetByteArrayRegion(env, ret, 0, len,\n-                                       (jbyte*) ptr->PhysicalAddress);\n-          }\n-        }\n-        free(ptr);\n-      }\n-      return ret;\n-}\n-\n-\/*\n- * Class:       java_net_NetworkInterface\n- * Method:      getMTU0\n- * Signature:   ([bLjava\/lang\/String;I)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_NetworkInterface_getMTU0_XP\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-      IP_ADAPTER_ADDRESSES *ptr;\n-      jint ret = -1;\n-\n-      ptr = getAdapter(env, index);\n-      if (ptr != NULL) {\n-        ret = ptr->Mtu;\n-        free(ptr);\n-      }\n-      return ret;\n-}\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    isLoopback0\n- * Signature: (Ljava\/lang\/String;I)Z\n- *\/\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isLoopback0_XP\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-      IP_ADAPTER_ADDRESSES *ptr;\n-      jboolean val = JNI_FALSE;\n-\n-      ptr = getAdapter(env, index);\n-      if (ptr != NULL) {\n-        val = ptr->IfType == IF_TYPE_SOFTWARE_LOOPBACK ? JNI_TRUE : JNI_FALSE;\n-        free(ptr);\n-      }\n-      return val;\n-}\n-\n-\/*\n- * Class:     java_net_NetworkInterface\n- * Method:    isP2P0\n- * Signature: (Ljava\/lang\/String;I)Z\n- *\/\n-JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isP2P0_XP\n-    (JNIEnv *env, jclass cls, jstring name, jint index) {\n-      IP_ADAPTER_ADDRESSES *ptr;\n-      jboolean val = JNI_FALSE;\n-\n-      ptr = getAdapter(env, index);\n-      if (ptr != NULL) {\n-        if (ptr->IfType == IF_TYPE_PPP || ptr->IfType == IF_TYPE_SLIP ||\n-           ptr->IfType == IF_TYPE_TUNNEL) {\n-          val = JNI_TRUE;\n-        }\n-        free(ptr);\n-      }\n-      return val;\n-}\n","filename":"src\/java.base\/windows\/native\/libnet\/NetworkInterface_winXP.c","additions":0,"deletions":1010,"binary":false,"changes":1010,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+#define BUFF_SIZE           15360\n+#define MAX_TRIES           3\n@@ -49,1 +51,72 @@\n-extern int getAdapters(JNIEnv *env, int flags, IP_ADAPTER_ADDRESSES **adapters);\n+\/*\n+ * return an array of IP_ADAPTER_ADDRESSES containing one element\n+ * for each adapter on the system. Returned in *adapters.\n+ * Buffer is malloc'd and must be freed (unless error returned)\n+ *\/\n+static int getAdapters (JNIEnv *env, int flags, IP_ADAPTER_ADDRESSES **adapters) {\n+    DWORD ret;\n+    IP_ADAPTER_ADDRESSES *adapterInfo;\n+    ULONG len;\n+    int try;\n+\n+    *adapters = NULL;\n+\n+    adapterInfo = (IP_ADAPTER_ADDRESSES *) malloc(BUFF_SIZE);\n+    if (adapterInfo == NULL) {\n+        JNU_ThrowByName(env, \"java\/lang\/OutOfMemoryError\",\n+            \"Native heap allocation failure\");\n+        return -1;\n+    }\n+\n+    len = BUFF_SIZE;\n+    ret = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &len);\n+\n+    for (try = 0; ret == ERROR_BUFFER_OVERFLOW && try < MAX_TRIES; ++try) {\n+        IP_ADAPTER_ADDRESSES * newAdapterInfo = NULL;\n+        if (len < (ULONG_MAX - BUFF_SIZE)) {\n+            len += BUFF_SIZE;\n+        }\n+        newAdapterInfo =\n+            (IP_ADAPTER_ADDRESSES *) realloc (adapterInfo, len);\n+        if (newAdapterInfo == NULL) {\n+            free(adapterInfo);\n+            JNU_ThrowByName(env, \"java\/lang\/OutOfMemoryError\",\n+                \"Native heap allocation failure\");\n+            return -1;\n+        }\n+\n+        adapterInfo = newAdapterInfo;\n+\n+        ret = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &len);\n+    }\n+\n+    if (ret != ERROR_SUCCESS) {\n+        free (adapterInfo);\n+        switch (ret) {\n+            case ERROR_INVALID_PARAMETER:\n+                JNU_ThrowInternalError(env,\n+                    \"IP Helper Library GetAdaptersAddresses function failed: \"\n+                    \"invalid parameter\");\n+                break;\n+            case ERROR_NOT_ENOUGH_MEMORY:\n+                JNU_ThrowOutOfMemoryError(env,\n+                    \"IP Helper Library GetAdaptersAddresses function failed: \"\n+                    \"not enough memory\");\n+                break;\n+            case ERROR_NO_DATA:\n+                \/\/ not an error\n+                *adapters = NULL;\n+                return ERROR_SUCCESS;\n+            default:\n+                SetLastError(ret);\n+                JNU_ThrowByNameWithMessageAndLastError(env,\n+                    JNU_JAVANETPKG \"SocketException\",\n+                    \"IP Helper Library GetAdaptersAddresses function failed\");\n+                break;\n+        }\n+\n+        return -1;\n+    }\n+    *adapters = adapterInfo;\n+    return ERROR_SUCCESS;\n+}\n","filename":"src\/java.base\/windows\/native\/libnet\/ResolverConfigurationImpl.c","additions":75,"deletions":2,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-        JNU_ThrowIOExceptionWithLastError(env, \"Invalid handle\");\n+        JNU_ThrowIOException(env, \"Invalid handle\");\n@@ -88,1 +88,1 @@\n-        JNU_ThrowIOExceptionWithLastError(env, \"Invalid handle\");\n+        JNU_ThrowIOException(env, \"Invalid handle\");\n@@ -134,1 +134,1 @@\n-        JNU_ThrowIOExceptionWithLastError(env, \"Invalid handle\");\n+        JNU_ThrowIOException(env, \"Invalid handle\");\n@@ -202,0 +202,3 @@\n+    } else {\n+        JNU_ThrowIOException(env, \"Invalid handle\");\n+        return IOS_THROWN;\n@@ -204,1 +207,1 @@\n-    if ((h == INVALID_HANDLE_VALUE) || (result == 0)) {\n+    if (result == 0) {\n@@ -251,0 +254,3 @@\n+    } else {\n+        JNU_ThrowIOException(env, \"Invalid handle\");\n+        return IOS_THROWN;\n@@ -253,1 +259,1 @@\n-    if ((h == INVALID_HANDLE_VALUE) || (result == 0)) {\n+    if (result == 0) {\n@@ -271,0 +277,4 @@\n+    if (h == INVALID_HANDLE_VALUE) {\n+        JNU_ThrowIOException(env, \"Invalid handle\");\n+        return IOS_THROWN;\n+    }\n@@ -288,1 +298,1 @@\n-    if ((h == INVALID_HANDLE_VALUE) || (result == 0)) {\n+    if (result == 0) {\n@@ -344,1 +354,1 @@\n-        JNU_ThrowIOExceptionWithLastError(env, \"Force failed\");\n+        JNU_ThrowIOException(env, \"Invalid handle\");\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -187,0 +187,10 @@\n+\n+                    \/\/ Do send radio button state changes to native side\n+                    if (thisRole == AccessibleRole.RADIO_BUTTON) {\n+                        valueChanged(ptr);\n+                    }\n+\n+                    \/\/ Do send toggle button state changes to native side\n+                    if (thisRole == AccessibleRole.TOGGLE_BUTTON) {\n+                        valueChanged(ptr);\n+                    }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CAccessible.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import sun.awt.util.IdentityLinkedList;\n@@ -1420,1 +1419,1 @@\n-        java.util.List<Window> toBlock = new IdentityLinkedList<Window>();\n+        java.util.List<Window> toBlock = new IdentityArrayList<Window>();\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Dialog.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,2 @@\n+    private boolean showHorizLines;\n+    private boolean showVertLines;\n@@ -181,0 +183,2 @@\n+            showHorizLines = table.getShowHorizontalLines();\n+            showVertLines = table.getShowVerticalLines();\n@@ -182,3 +186,1 @@\n-            if (!showGrid) {\n-                table.setShowGrid(false);\n-            }\n+            table.setShowGrid(showGrid);\n@@ -230,0 +232,2 @@\n+        table.setShowHorizontalLines(showHorizLines);\n+        table.setShowVerticalLines(showVertLines);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthTableUI.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,880 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.awt.util;\n-\n-import java.util.AbstractSequentialList;\n-import java.util.Collection;\n-import java.util.ConcurrentModificationException;\n-import java.util.Deque;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.NoSuchElementException;\n-\n-\/**\n- * Linked list implementation of the {@code List} interface.  Implements all\n- * optional list operations, and permits all elements (including\n- * {@code null}).  In addition to implementing the {@code List} interface,\n- * the {@code IdentityLinkedList} class provides uniformly named methods to\n- * {@code get}, {@code remove} and {@code insert} an element at the\n- * beginning and end of the list.  These operations allow linked lists to be\n- * used as a stack, {@linkplain java.util.Queue queue}, or {@linkplain Deque\n- * double-ended queue}. <p>\n- *\n- * The class implements the {@code Deque} interface, providing\n- * first-in-first-out queue operations for {@code add},\n- * {@code poll}, along with other stack and deque operations.<p>\n- *\n- * All of the operations perform as could be expected for a doubly-linked\n- * list.  Operations that index into the list will traverse the list from\n- * the beginning or the end, whichever is closer to the specified index.<p>\n- *\n- * <p><strong>Note that this implementation is not synchronized.<\/strong>\n- * If multiple threads access a linked list concurrently, and at least\n- * one of the threads modifies the list structurally, it <i>must<\/i> be\n- * synchronized externally.  (A structural modification is any operation\n- * that adds or deletes one or more elements; merely setting the value of\n- * an element is not a structural modification.)  This is typically\n- * accomplished by synchronizing on some object that naturally\n- * encapsulates the list.\n- *\n- * If no such object exists, the list should be \"wrapped\" using the\n- * {@link java.util.Collections#synchronizedList Collections.synchronizedList}\n- * method.  This is best done at creation time, to prevent accidental\n- * unsynchronized access to the list:<pre>\n- *   List list = Collections.synchronizedList(new IdentityLinkedList(...));<\/pre>\n- *\n- * <p>The iterators returned by this class's {@code iterator} and\n- * {@code listIterator} methods are <i>fail-fast<\/i>: if the list is\n- * structurally modified at any time after the iterator is created, in\n- * any way except through the Iterator's own {@code remove} or\n- * {@code add} methods, the iterator will throw a {@link\n- * ConcurrentModificationException}.  Thus, in the face of concurrent\n- * modification, the iterator fails quickly and cleanly, rather than\n- * risking arbitrary, non-deterministic behavior at an undetermined\n- * time in the future.\n- *\n- * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed\n- * as it is, generally speaking, impossible to make any hard guarantees in the\n- * presence of unsynchronized concurrent modification.  Fail-fast iterators\n- * throw {@code ConcurrentModificationException} on a best-effort basis.\n- * Therefore, it would be wrong to write a program that depended on this\n- * exception for its correctness:   <i>the fail-fast behavior of iterators\n- * should be used only to detect bugs.<\/i>\n- *\/\n-\n-public class IdentityLinkedList<E>\n-    extends AbstractSequentialList<E>\n-    implements List<E>, Deque<E>\n-{\n-    private transient Entry<E> header = new Entry<E>(null, null, null);\n-    private transient int size = 0;\n-\n-    \/**\n-     * Constructs an empty list.\n-     *\/\n-    public IdentityLinkedList() {\n-        header.next = header.previous = header;\n-    }\n-\n-    \/**\n-     * Constructs a list containing the elements of the specified\n-     * collection, in the order they are returned by the collection's\n-     * iterator.\n-     *\n-     * @param  c the collection whose elements are to be placed into this list\n-     * @throws NullPointerException if the specified collection is null\n-     *\/\n-    public IdentityLinkedList(Collection<? extends E> c) {\n-        this();\n-        addAll(c);\n-    }\n-\n-    \/**\n-     * Returns the first element in this list.\n-     *\n-     * @return the first element in this list\n-     * @throws NoSuchElementException if this list is empty\n-     *\/\n-    public E getFirst() {\n-        if (size==0)\n-            throw new NoSuchElementException();\n-\n-        return header.next.element;\n-    }\n-\n-    \/**\n-     * Returns the last element in this list.\n-     *\n-     * @return the last element in this list\n-     * @throws NoSuchElementException if this list is empty\n-     *\/\n-    public E getLast()  {\n-        if (size==0)\n-            throw new NoSuchElementException();\n-\n-        return header.previous.element;\n-    }\n-\n-    \/**\n-     * Removes and returns the first element from this list.\n-     *\n-     * @return the first element from this list\n-     * @throws NoSuchElementException if this list is empty\n-     *\/\n-    public E removeFirst() {\n-        return remove(header.next);\n-    }\n-\n-    \/**\n-     * Removes and returns the last element from this list.\n-     *\n-     * @return the last element from this list\n-     * @throws NoSuchElementException if this list is empty\n-     *\/\n-    public E removeLast() {\n-        return remove(header.previous);\n-    }\n-\n-    \/**\n-     * Inserts the specified element at the beginning of this list.\n-     *\n-     * @param e the element to add\n-     *\/\n-    public void addFirst(E e) {\n-        addBefore(e, header.next);\n-    }\n-\n-    \/**\n-     * Appends the specified element to the end of this list.\n-     *\n-     * <p>This method is equivalent to {@link #add}.\n-     *\n-     * @param e the element to add\n-     *\/\n-    public void addLast(E e) {\n-        addBefore(e, header);\n-    }\n-\n-    \/**\n-     * Returns {@code true} if this list contains the specified element.\n-     * More formally, returns {@code true} if and only if this list contains\n-     * at least one element {@code e} such that\n-     * {@code o == e}.\n-     *\n-     * @param o element whose presence in this list is to be tested\n-     * @return {@code true} if this list contains the specified element\n-     *\/\n-    public boolean contains(Object o) {\n-        return indexOf(o) != -1;\n-    }\n-\n-    \/**\n-     * Returns the number of elements in this list.\n-     *\n-     * @return the number of elements in this list\n-     *\/\n-    public int size() {\n-        return size;\n-    }\n-\n-    \/**\n-     * Appends the specified element to the end of this list.\n-     *\n-     * <p>This method is equivalent to {@link #addLast}.\n-     *\n-     * @param e element to be appended to this list\n-     * @return {@code true} (as specified by {@link Collection#add})\n-     *\/\n-    public boolean add(E e) {\n-        addBefore(e, header);\n-        return true;\n-    }\n-\n-    \/**\n-     * Removes the first occurrence of the specified element from this list,\n-     * if it is present.  If this list does not contain the element, it is\n-     * unchanged.  More formally, removes the element with the lowest index\n-     * {@code i} such that {@code get(i) == o}\n-     * (if such an element exists).  Returns {@code true} if this list\n-     * contained the specified element (or equivalently, if this list\n-     * changed as a result of the call).\n-     *\n-     * @param o element to be removed from this list, if present\n-     * @return {@code true} if this list contained the specified element\n-     *\/\n-    public boolean remove(Object o) {\n-        for (Entry<E> e = header.next; e != header; e = e.next) {\n-            if (o == e.element) {\n-                remove(e);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Appends all of the elements in the specified collection to the end of\n-     * this list, in the order that they are returned by the specified\n-     * collection's iterator.  The behavior of this operation is undefined if\n-     * the specified collection is modified while the operation is in\n-     * progress.  (Note that this will occur if the specified collection is\n-     * this list, and it's nonempty.)\n-     *\n-     * @param c collection containing elements to be added to this list\n-     * @return {@code true} if this list changed as a result of the call\n-     * @throws NullPointerException if the specified collection is null\n-     *\/\n-    public boolean addAll(Collection<? extends E> c) {\n-        return addAll(size, c);\n-    }\n-\n-    \/**\n-     * Inserts all of the elements in the specified collection into this\n-     * list, starting at the specified position.  Shifts the element\n-     * currently at that position (if any) and any subsequent elements to\n-     * the right (increases their indices).  The new elements will appear\n-     * in the list in the order that they are returned by the\n-     * specified collection's iterator.\n-     *\n-     * @param index index at which to insert the first element\n-     *              from the specified collection\n-     * @param c collection containing elements to be added to this list\n-     * @return {@code true} if this list changed as a result of the call\n-     * @throws IndexOutOfBoundsException {@inheritDoc}\n-     * @throws NullPointerException if the specified collection is null\n-     *\/\n-    public boolean addAll(int index, Collection<? extends E> c) {\n-        if (index < 0 || index > size)\n-            throw new IndexOutOfBoundsException(\"Index: \"+index+\n-                                                \", Size: \"+size);\n-        Object[] a = c.toArray();\n-        int numNew = a.length;\n-        if (numNew==0)\n-            return false;\n-        modCount++;\n-\n-        Entry<E> successor = (index==size ? header : entry(index));\n-        Entry<E> predecessor = successor.previous;\n-        for (int i=0; i<numNew; i++) {\n-            @SuppressWarnings(\"unchecked\")\n-            E tmp = (E) a[i];\n-            Entry<E> e = new Entry<E>(tmp, successor, predecessor);\n-            predecessor.next = e;\n-            predecessor = e;\n-        }\n-        successor.previous = predecessor;\n-\n-        size += numNew;\n-        return true;\n-    }\n-\n-    \/**\n-     * Removes all of the elements from this list.\n-     *\/\n-    public void clear() {\n-        Entry<E> e = header.next;\n-        while (e != header) {\n-            Entry<E> next = e.next;\n-            e.next = e.previous = null;\n-            e.element = null;\n-            e = next;\n-        }\n-        header.next = header.previous = header;\n-        size = 0;\n-        modCount++;\n-    }\n-\n-\n-    \/\/ Positional Access Operations\n-\n-    \/**\n-     * Returns the element at the specified position in this list.\n-     *\n-     * @param index index of the element to return\n-     * @return the element at the specified position in this list\n-     * @throws IndexOutOfBoundsException {@inheritDoc}\n-     *\/\n-    public E get(int index) {\n-        return entry(index).element;\n-    }\n-\n-    \/**\n-     * Replaces the element at the specified position in this list with the\n-     * specified element.\n-     *\n-     * @param index index of the element to replace\n-     * @param element element to be stored at the specified position\n-     * @return the element previously at the specified position\n-     * @throws IndexOutOfBoundsException {@inheritDoc}\n-     *\/\n-    public E set(int index, E element) {\n-        Entry<E> e = entry(index);\n-        E oldVal = e.element;\n-        e.element = element;\n-        return oldVal;\n-    }\n-\n-    \/**\n-     * Inserts the specified element at the specified position in this list.\n-     * Shifts the element currently at that position (if any) and any\n-     * subsequent elements to the right (adds one to their indices).\n-     *\n-     * @param index index at which the specified element is to be inserted\n-     * @param element element to be inserted\n-     * @throws IndexOutOfBoundsException {@inheritDoc}\n-     *\/\n-    public void add(int index, E element) {\n-        addBefore(element, (index==size ? header : entry(index)));\n-    }\n-\n-    \/**\n-     * Removes the element at the specified position in this list.  Shifts any\n-     * subsequent elements to the left (subtracts one from their indices).\n-     * Returns the element that was removed from the list.\n-     *\n-     * @param index the index of the element to be removed\n-     * @return the element previously at the specified position\n-     * @throws IndexOutOfBoundsException {@inheritDoc}\n-     *\/\n-    public E remove(int index) {\n-        return remove(entry(index));\n-    }\n-\n-    \/**\n-     * Returns the indexed entry.\n-     *\/\n-    private Entry<E> entry(int index) {\n-        if (index < 0 || index >= size)\n-            throw new IndexOutOfBoundsException(\"Index: \"+index+\n-                                                \", Size: \"+size);\n-        Entry<E> e = header;\n-        if (index < (size >> 1)) {\n-            for (int i = 0; i <= index; i++)\n-                e = e.next;\n-        } else {\n-            for (int i = size; i > index; i--)\n-                e = e.previous;\n-        }\n-        return e;\n-    }\n-\n-\n-    \/\/ Search Operations\n-\n-    \/**\n-     * Returns the index of the first occurrence of the specified element\n-     * in this list, or -1 if this list does not contain the element.\n-     * More formally, returns the lowest index {@code i} such that\n-     * {@code get(i) == o},\n-     * or -1 if there is no such index.\n-     *\n-     * @param o element to search for\n-     * @return the index of the first occurrence of the specified element in\n-     *         this list, or -1 if this list does not contain the element\n-     *\/\n-    public int indexOf(Object o) {\n-        int index = 0;\n-        for (Entry<E> e = header.next; e != header; e = e.next) {\n-            if (o == e.element) {\n-                return index;\n-            }\n-            index++;\n-        }\n-        return -1;\n-    }\n-\n-    \/**\n-     * Returns the index of the last occurrence of the specified element\n-     * in this list, or -1 if this list does not contain the element.\n-     * More formally, returns the highest index {@code i} such that\n-     * {@code get(i) == o},\n-     * or -1 if there is no such index.\n-     *\n-     * @param o element to search for\n-     * @return the index of the last occurrence of the specified element in\n-     *         this list, or -1 if this list does not contain the element\n-     *\/\n-    public int lastIndexOf(Object o) {\n-        int index = size;\n-        for (Entry<E> e = header.previous; e != header; e = e.previous) {\n-            index--;\n-            if (o == e.element) {\n-                return index;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    \/\/ Queue operations.\n-\n-    \/**\n-     * Retrieves, but does not remove, the head (first element) of this list.\n-     * @return the head of this list, or {@code null} if this list is empty\n-     * @since 1.5\n-     *\/\n-    public E peek() {\n-        if (size==0)\n-            return null;\n-        return getFirst();\n-    }\n-\n-    \/**\n-     * Retrieves, but does not remove, the head (first element) of this list.\n-     * @return the head of this list\n-     * @throws NoSuchElementException if this list is empty\n-     * @since 1.5\n-     *\/\n-    public E element() {\n-        return getFirst();\n-    }\n-\n-    \/**\n-     * Retrieves and removes the head (first element) of this list\n-     * @return the head of this list, or {@code null} if this list is empty\n-     * @since 1.5\n-     *\/\n-    public E poll() {\n-        if (size==0)\n-            return null;\n-        return removeFirst();\n-    }\n-\n-    \/**\n-     * Retrieves and removes the head (first element) of this list.\n-     *\n-     * @return the head of this list\n-     * @throws NoSuchElementException if this list is empty\n-     * @since 1.5\n-     *\/\n-    public E remove() {\n-        return removeFirst();\n-    }\n-\n-    \/**\n-     * Adds the specified element as the tail (last element) of this list.\n-     *\n-     * @param e the element to add\n-     * @return {@code true} (as specified by {@link java.util.Queue#offer})\n-     * @since 1.5\n-     *\/\n-    public boolean offer(E e) {\n-        return add(e);\n-    }\n-\n-    \/\/ Deque operations\n-    \/**\n-     * Inserts the specified element at the front of this list.\n-     *\n-     * @param e the element to insert\n-     * @return {@code true} (as specified by {@link Deque#offerFirst})\n-     * @since 1.6\n-     *\/\n-    public boolean offerFirst(E e) {\n-        addFirst(e);\n-        return true;\n-    }\n-\n-    \/**\n-     * Inserts the specified element at the end of this list.\n-     *\n-     * @param e the element to insert\n-     * @return {@code true} (as specified by {@link Deque#offerLast})\n-     * @since 1.6\n-     *\/\n-    public boolean offerLast(E e) {\n-        addLast(e);\n-        return true;\n-    }\n-\n-    \/**\n-     * Retrieves, but does not remove, the first element of this list,\n-     * or returns {@code null} if this list is empty.\n-     *\n-     * @return the first element of this list, or {@code null}\n-     *         if this list is empty\n-     * @since 1.6\n-     *\/\n-    public E peekFirst() {\n-        if (size==0)\n-            return null;\n-        return getFirst();\n-    }\n-\n-    \/**\n-     * Retrieves, but does not remove, the last element of this list,\n-     * or returns {@code null} if this list is empty.\n-     *\n-     * @return the last element of this list, or {@code null}\n-     *         if this list is empty\n-     * @since 1.6\n-     *\/\n-    public E peekLast() {\n-        if (size==0)\n-            return null;\n-        return getLast();\n-    }\n-\n-    \/**\n-     * Retrieves and removes the first element of this list,\n-     * or returns {@code null} if this list is empty.\n-     *\n-     * @return the first element of this list, or {@code null} if\n-     *     this list is empty\n-     * @since 1.6\n-     *\/\n-    public E pollFirst() {\n-        if (size==0)\n-            return null;\n-        return removeFirst();\n-    }\n-\n-    \/**\n-     * Retrieves and removes the last element of this list,\n-     * or returns {@code null} if this list is empty.\n-     *\n-     * @return the last element of this list, or {@code null} if\n-     *     this list is empty\n-     * @since 1.6\n-     *\/\n-    public E pollLast() {\n-        if (size==0)\n-            return null;\n-        return removeLast();\n-    }\n-\n-    \/**\n-     * Pushes an element onto the stack represented by this list.  In other\n-     * words, inserts the element at the front of this list.\n-     *\n-     * <p>This method is equivalent to {@link #addFirst}.\n-     *\n-     * @param e the element to push\n-     * @since 1.6\n-     *\/\n-    public void push(E e) {\n-        addFirst(e);\n-    }\n-\n-    \/**\n-     * Pops an element from the stack represented by this list.  In other\n-     * words, removes and returns the first element of this list.\n-     *\n-     * <p>This method is equivalent to {@link #removeFirst()}.\n-     *\n-     * @return the element at the front of this list (which is the top\n-     *         of the stack represented by this list)\n-     * @throws NoSuchElementException if this list is empty\n-     * @since 1.6\n-     *\/\n-    public E pop() {\n-        return removeFirst();\n-    }\n-\n-    \/**\n-     * Removes the first occurrence of the specified element in this\n-     * list (when traversing the list from head to tail).  If the list\n-     * does not contain the element, it is unchanged.\n-     *\n-     * @param o element to be removed from this list, if present\n-     * @return {@code true} if the list contained the specified element\n-     * @since 1.6\n-     *\/\n-    public boolean removeFirstOccurrence(Object o) {\n-        return remove(o);\n-    }\n-\n-    \/**\n-     * Removes the last occurrence of the specified element in this\n-     * list (when traversing the list from head to tail).  If the list\n-     * does not contain the element, it is unchanged.\n-     *\n-     * @param o element to be removed from this list, if present\n-     * @return {@code true} if the list contained the specified element\n-     * @since 1.6\n-     *\/\n-    public boolean removeLastOccurrence(Object o) {\n-        for (Entry<E> e = header.previous; e != header; e = e.previous) {\n-            if (o == e.element) {\n-                remove(e);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Returns a list-iterator of the elements in this list (in proper\n-     * sequence), starting at the specified position in the list.\n-     * Obeys the general contract of {@code List.listIterator(int)}.<p>\n-     *\n-     * The list-iterator is <i>fail-fast<\/i>: if the list is structurally\n-     * modified at any time after the Iterator is created, in any way except\n-     * through the list-iterator's own {@code remove} or {@code add}\n-     * methods, the list-iterator will throw a\n-     * {@code ConcurrentModificationException}.  Thus, in the face of\n-     * concurrent modification, the iterator fails quickly and cleanly, rather\n-     * than risking arbitrary, non-deterministic behavior at an undetermined\n-     * time in the future.\n-     *\n-     * @param index index of the first element to be returned from the\n-     *              list-iterator (by a call to {@code next})\n-     * @return a ListIterator of the elements in this list (in proper\n-     *         sequence), starting at the specified position in the list\n-     * @throws IndexOutOfBoundsException {@inheritDoc}\n-     * @see List#listIterator(int)\n-     *\/\n-    public ListIterator<E> listIterator(int index) {\n-        return new ListItr(index);\n-    }\n-\n-    private class ListItr implements ListIterator<E> {\n-        private Entry<E> lastReturned = header;\n-        private Entry<E> next;\n-        private int nextIndex;\n-        private int expectedModCount = modCount;\n-\n-        ListItr(int index) {\n-            if (index < 0 || index > size)\n-                throw new IndexOutOfBoundsException(\"Index: \"+index+\n-                                                    \", Size: \"+size);\n-            if (index < (size >> 1)) {\n-                next = header.next;\n-                for (nextIndex=0; nextIndex<index; nextIndex++)\n-                    next = next.next;\n-            } else {\n-                next = header;\n-                for (nextIndex=size; nextIndex>index; nextIndex--)\n-                    next = next.previous;\n-            }\n-        }\n-\n-        public boolean hasNext() {\n-            return nextIndex != size;\n-        }\n-\n-        public E next() {\n-            checkForComodification();\n-            if (nextIndex == size)\n-                throw new NoSuchElementException();\n-\n-            lastReturned = next;\n-            next = next.next;\n-            nextIndex++;\n-            return lastReturned.element;\n-        }\n-\n-        public boolean hasPrevious() {\n-            return nextIndex != 0;\n-        }\n-\n-        public E previous() {\n-            if (nextIndex == 0)\n-                throw new NoSuchElementException();\n-\n-            lastReturned = next = next.previous;\n-            nextIndex--;\n-            checkForComodification();\n-            return lastReturned.element;\n-        }\n-\n-        public int nextIndex() {\n-            return nextIndex;\n-        }\n-\n-        public int previousIndex() {\n-            return nextIndex-1;\n-        }\n-\n-        public void remove() {\n-            checkForComodification();\n-            Entry<E> lastNext = lastReturned.next;\n-            try {\n-                IdentityLinkedList.this.remove(lastReturned);\n-            } catch (NoSuchElementException e) {\n-                throw new IllegalStateException();\n-            }\n-            if (next==lastReturned)\n-                next = lastNext;\n-            else\n-                nextIndex--;\n-            lastReturned = header;\n-            expectedModCount++;\n-        }\n-\n-        public void set(E e) {\n-            if (lastReturned == header)\n-                throw new IllegalStateException();\n-            checkForComodification();\n-            lastReturned.element = e;\n-        }\n-\n-        public void add(E e) {\n-            checkForComodification();\n-            lastReturned = header;\n-            addBefore(e, next);\n-            nextIndex++;\n-            expectedModCount++;\n-        }\n-\n-        final void checkForComodification() {\n-            if (modCount != expectedModCount)\n-                throw new ConcurrentModificationException();\n-        }\n-    }\n-\n-    private static class Entry<E> {\n-        E element;\n-        Entry<E> next;\n-        Entry<E> previous;\n-\n-        Entry(E element, Entry<E> next, Entry<E> previous) {\n-            this.element = element;\n-            this.next = next;\n-            this.previous = previous;\n-        }\n-    }\n-\n-    private Entry<E> addBefore(E e, Entry<E> entry) {\n-        Entry<E> newEntry = new Entry<E>(e, entry, entry.previous);\n-        newEntry.previous.next = newEntry;\n-        newEntry.next.previous = newEntry;\n-        size++;\n-        modCount++;\n-        return newEntry;\n-    }\n-\n-    private E remove(Entry<E> e) {\n-        if (e == header)\n-            throw new NoSuchElementException();\n-\n-        E result = e.element;\n-        e.previous.next = e.next;\n-        e.next.previous = e.previous;\n-        e.next = e.previous = null;\n-        e.element = null;\n-        size--;\n-        modCount++;\n-        return result;\n-    }\n-\n-    \/**\n-     * @since 1.6\n-     *\/\n-    public Iterator<E> descendingIterator() {\n-        return new DescendingIterator();\n-    }\n-\n-    \/** Adapter to provide descending iterators via ListItr.previous *\/\n-    private class DescendingIterator implements Iterator<E> {\n-        final ListItr itr = new ListItr(size());\n-        public boolean hasNext() {\n-            return itr.hasPrevious();\n-        }\n-        public E next() {\n-            return itr.previous();\n-        }\n-        public void remove() {\n-            itr.remove();\n-        }\n-    }\n-\n-    \/**\n-     * Returns an array containing all of the elements in this list\n-     * in proper sequence (from first to last element).\n-     *\n-     * <p>The returned array will be \"safe\" in that no references to it are\n-     * maintained by this list.  (In other words, this method must allocate\n-     * a new array).  The caller is thus free to modify the returned array.\n-     *\n-     * <p>This method acts as bridge between array-based and collection-based\n-     * APIs.\n-     *\n-     * @return an array containing all of the elements in this list\n-     *         in proper sequence\n-     *\/\n-    public Object[] toArray() {\n-        Object[] result = new Object[size];\n-        int i = 0;\n-        for (Entry<E> e = header.next; e != header; e = e.next)\n-            result[i++] = e.element;\n-        return result;\n-    }\n-\n-    \/**\n-     * Returns an array containing all of the elements in this list in\n-     * proper sequence (from first to last element); the runtime type of\n-     * the returned array is that of the specified array.  If the list fits\n-     * in the specified array, it is returned therein.  Otherwise, a new\n-     * array is allocated with the runtime type of the specified array and\n-     * the size of this list.\n-     *\n-     * <p>If the list fits in the specified array with room to spare (i.e.,\n-     * the array has more elements than the list), the element in the array\n-     * immediately following the end of the list is set to {@code null}.\n-     * (This is useful in determining the length of the list <i>only<\/i> if\n-     * the caller knows that the list does not contain any null elements.)\n-     *\n-     * <p>Like the {@link #toArray()} method, this method acts as bridge between\n-     * array-based and collection-based APIs.  Further, this method allows\n-     * precise control over the runtime type of the output array, and may,\n-     * under certain circumstances, be used to save allocation costs.\n-     *\n-     * <p>Suppose {@code x} is a list known to contain only strings.\n-     * The following code can be used to dump the list into a newly\n-     * allocated array of {@code String}:\n-     *\n-     * <pre>\n-     *     String[] y = x.toArray(new String[0]);<\/pre>\n-     *\n-     * Note that {@code toArray(new Object[0])} is identical in function to\n-     * {@code toArray()}.\n-     *\n-     * @param a the array into which the elements of the list are to\n-     *          be stored, if it is big enough; otherwise, a new array of the\n-     *          same runtime type is allocated for this purpose.\n-     * @return an array containing the elements of the list\n-     * @throws ArrayStoreException if the runtime type of the specified array\n-     *         is not a supertype of the runtime type of every element in\n-     *         this list\n-     * @throws NullPointerException if the specified array is null\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> T[] toArray(T[] a) {\n-        if (a.length < size)\n-            a = (T[])java.lang.reflect.Array.newInstance(\n-                                a.getClass().getComponentType(), size);\n-        int i = 0;\n-        Object[] result = a;\n-        for (Entry<E> e = header.next; e != header; e = e.next)\n-            result[i++] = e.element;\n-\n-        if (a.length > size)\n-            a[size] = null;\n-\n-        return a;\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/util\/IdentityLinkedList.java","additions":0,"deletions":880,"binary":false,"changes":880,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-import java.util.concurrent.atomic.AtomicReference;\n@@ -51,1 +50,9 @@\n-import javax.swing.*;\n+import javax.swing.BorderFactory;\n+import javax.swing.CellRendererPane;\n+import javax.swing.JEditorPane;\n+import javax.swing.JPasswordField;\n+import javax.swing.JTextArea;\n+import javax.swing.JTextField;\n+import javax.swing.JTextPane;\n+import javax.swing.JViewport;\n+import javax.swing.SwingUtilities;\n@@ -106,2 +113,1 @@\n-    private final AtomicReference<FontRenderContext> frc =\n-        new AtomicReference<FontRenderContext>(null);\n+    private volatile FontRenderContext frc;\n@@ -328,0 +334,1 @@\n+\n@@ -343,1 +350,2 @@\n-                        return (frc.get() == null)\n+                        FontRenderContext frc = TextComponentPrintable.this.frc;\n+                        return (frc == null)\n@@ -345,1 +353,1 @@\n-                            : FontDesignMetrics.getMetrics(font, frc.get());\n+                            : FontDesignMetrics.getMetrics(font, frc);\n@@ -357,1 +365,2 @@\n-                        return (frc.get() == null)\n+                        FontRenderContext frc = TextComponentPrintable.this.frc;\n+                        return (frc == null)\n@@ -359,1 +368,1 @@\n-                            : FontDesignMetrics.getMetrics(font, frc.get());\n+                            : FontDesignMetrics.getMetrics(font, frc);\n@@ -373,1 +382,2 @@\n-                        return (frc.get() == null)\n+                        FontRenderContext frc = TextComponentPrintable.this.frc;\n+                        return (frc == null)\n@@ -375,1 +385,1 @@\n-                            : FontDesignMetrics.getMetrics(font, frc.get());\n+                            : FontDesignMetrics.getMetrics(font, frc);\n@@ -383,1 +393,2 @@\n-                        return (frc.get() == null)\n+                        FontRenderContext frc = TextComponentPrintable.this.frc;\n+                        return (frc == null)\n@@ -385,1 +396,1 @@\n-                            : FontDesignMetrics.getMetrics(font, frc.get());\n+                            : FontDesignMetrics.getMetrics(font, frc);\n@@ -401,1 +412,2 @@\n-                        return (frc.get() == null)\n+                        FontRenderContext frc = TextComponentPrintable.this.frc;\n+                        return (frc == null)\n@@ -403,1 +415,1 @@\n-                            : FontDesignMetrics.getMetrics(font, frc.get());\n+                            : FontDesignMetrics.getMetrics(font, frc);\n@@ -469,1 +481,1 @@\n-                frc.set(((Graphics2D)graphics).getFontRenderContext());\n+                frc = ((Graphics2D)graphics).getFontRenderContext();\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/text\/TextComponentPrintable.java","additions":28,"deletions":16,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## Harfbuzz v4.4.1\n+## Harfbuzz v7.0.1\n@@ -5,1 +5,1 @@\n-https:\/\/github.com\/harfbuzz\/harfbuzz\/blob\/4.4.1\/COPYING\n+https:\/\/github.com\/harfbuzz\/harfbuzz\/blob\/7.0.1\/COPYING\n@@ -15,9 +15,0 @@\n-Copyright © 2019-2020  Facebook, Inc.\n-Copyright © 2012-2015  Mozilla Foundation.\n-Copyright © 2011  Codethink Limited\n-Copyright © 2008-2010  Nokia Corporation and\/or its subsidiary(-ies)\n-Copyright © 2009  Keith Stribley\n-Copyright © 2009  Martin Hosken and SIL International\n-Copyright © 2007  Chris Wilson\n-Copyright © 2005-2022 Behdad Esfahbod\n-Copyright © 2005  David Turner\n@@ -25,2 +16,2 @@\n-Copyright © 1998-2004  David Turner and Werner Lemberg\n-Copyright © 2016  Elie Roux <elie.roux@telecom-bretagne.eu>\n+Copyright © 2019  Facebook, Inc.\n+Copyright © 2007  Chris Wilson\n@@ -28,0 +19,3 @@\n+Copyright © 2006-2023 Behdad Esfahbod\n+Copyright © 1998-2004  David Turner and Werner Lemberg\n+Copyright © 2009  Keith Stribley\n@@ -29,0 +23,1 @@\n+Copyright © 2016  Elie Roux <elie.roux@telecom-bretagne.eu>\n@@ -30,0 +25,6 @@\n+Copyright © 2015  Mozilla Foundation.\n+Copyright © 1999  David Turner\n+Copyright © 2005  Werner Lemberg\n+Copyright © 2013-2015  Alexei Podtelezhnikov\n+Copyright © 2022 Matthias Clasen\n+Copyright © 2011  Codethink Limited\n@@ -75,0 +76,20 @@\n+\n+### AUTHORS File Information\n+```\n+\n+Behdad Esfahbod\n+David Corbett\n+David Turner\n+Ebrahim Byagowi\n+Garret Rieger\n+Jonathan Kew\n+Khaled Hosny\n+Lars Knoll\n+Martin Hosken\n+Owen Taylor\n+Roderick Sheeter\n+Roozbeh Pournader\n+Simon Hausmann\n+Werner Lemberg\n+\n+```\n","filename":"src\/java.desktop\/share\/legal\/harfbuzz.md","additions":34,"deletions":13,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## Little Color Management System (LCMS) v2.14\n+## Little Color Management System (LCMS) v2.15\n@@ -5,1 +5,0 @@\n-\n@@ -13,1 +12,1 @@\n-Copyright (c) 1998-2022 Marti Maria Saguer\n+Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -35,1 +34,0 @@\n-\n@@ -47,1 +45,0 @@\n-\n@@ -53,0 +50,1 @@\n+\n@@ -93,0 +91,3 @@\n+Amyspark\n+Lovell Fuller\n+Eli Schwartz\n@@ -98,0 +99,1 @@\n+libVIPS\n@@ -106,1 +108,0 @@\n-\n","filename":"src\/java.desktop\/share\/legal\/lcms.md","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-#ifndef HB_OT_COLOR_CBDT_TABLE_HH\n-#define HB_OT_COLOR_CBDT_TABLE_HH\n+#ifndef OT_COLOR_CBDT_CBDT_HH\n+#define OT_COLOR_CBDT_CBDT_HH\n@@ -30,1 +30,2 @@\n-#include \"hb-open-type.hh\"\n+#include \"..\/..\/..\/hb-open-type.hh\"\n+#include \"..\/..\/..\/hb-paint.hh\"\n@@ -70,1 +71,1 @@\n-  memcpy (cbdt_prime->arrayZ + cbdt_prime->length, data, length);\n+  hb_memcpy (cbdt_prime->arrayZ + cbdt_prime->length, data, length);\n@@ -83,1 +84,1 @@\n-  void get_extents (hb_font_t *font, hb_glyph_extents_t *extents) const\n+  void get_extents (hb_font_t *font, hb_glyph_extents_t *extents, bool scale) const\n@@ -85,4 +86,7 @@\n-    extents->x_bearing = font->em_scale_x (bearingX);\n-    extents->y_bearing = font->em_scale_y (bearingY);\n-    extents->width = font->em_scale_x (width);\n-    extents->height = font->em_scale_y (-static_cast<int>(height));\n+    extents->x_bearing = bearingX;\n+    extents->y_bearing = bearingY;\n+    extents->width = width;\n+    extents->height = -static_cast<int> (height);\n+\n+    if (scale)\n+      font->scale_glyph_extents (extents);\n@@ -310,1 +314,1 @@\n-  bool get_extents (hb_glyph_extents_t *extents HB_UNUSED) const\n+  bool get_extents (hb_glyph_extents_t *extents HB_UNUSED, bool scale HB_UNUSED) const\n@@ -471,2 +475,2 @@\n-    (*records)[records->length - 1].firstGlyphIndex = 1;\n-    (*records)[records->length - 1].lastGlyphIndex = 0;\n+    records->tail ().firstGlyphIndex = 1;\n+    records->tail ().lastGlyphIndex = 0;\n@@ -477,1 +481,1 @@\n-    if (unlikely (!add_new_subtable (c, bitmap_size_context, &((*records)[records->length - 1]), lookup, base, start)))\n+    if (unlikely (!add_new_subtable (c, bitmap_size_context, &(records->tail ()), lookup, base, start)))\n@@ -507,2 +511,2 @@\n-  bool get_extents (hb_glyph_extents_t *extents, const void *base) const\n-  { return (base+offsetToSubtable).get_extents (extents); }\n+  bool get_extents (hb_glyph_extents_t *extents, const void *base, bool scale) const\n+  { return (base+offsetToSubtable).get_extents (extents, scale); }\n@@ -836,1 +840,1 @@\n-    get_extents (hb_font_t *font, hb_codepoint_t glyph, hb_glyph_extents_t *extents) const\n+    get_extents (hb_font_t *font, hb_codepoint_t glyph, hb_glyph_extents_t *extents, bool scale = true) const\n@@ -844,1 +848,1 @@\n-      if (subtable_record->get_extents (extents, base))\n+      if (subtable_record->get_extents (extents, base, scale))\n@@ -861,1 +865,1 @@\n-        glyphFormat17.glyphMetrics.get_extents (font, extents);\n+        glyphFormat17.glyphMetrics.get_extents (font, extents, scale);\n@@ -868,1 +872,1 @@\n-        glyphFormat18.glyphMetrics.get_extents (font, extents);\n+        glyphFormat18.glyphMetrics.get_extents (font, extents, scale);\n@@ -875,6 +879,9 @@\n-      float x_scale = upem \/ (float) strike.ppemX;\n-      float y_scale = upem \/ (float) strike.ppemY;\n-      extents->x_bearing = roundf (extents->x_bearing * x_scale);\n-      extents->y_bearing = roundf (extents->y_bearing * y_scale);\n-      extents->width = roundf (extents->width * x_scale);\n-      extents->height = roundf (extents->height * y_scale);\n+      if (scale)\n+      {\n+        float x_scale = upem \/ (float) strike.ppemX;\n+        float y_scale = upem \/ (float) strike.ppemY;\n+        extents->x_bearing = roundf (extents->x_bearing * x_scale);\n+        extents->y_bearing = roundf (extents->y_bearing * y_scale);\n+        extents->width = roundf (extents->width * x_scale);\n+        extents->height = roundf (extents->height * y_scale);\n+      }\n@@ -937,0 +944,26 @@\n+    bool paint_glyph (hb_font_t *font, hb_codepoint_t glyph, hb_paint_funcs_t *funcs, void *data) const\n+    {\n+      hb_glyph_extents_t extents;\n+      hb_glyph_extents_t pixel_extents;\n+      hb_blob_t *blob = reference_png (font, glyph);\n+\n+      if (unlikely (blob == hb_blob_get_empty ()))\n+        return false;\n+\n+      if (unlikely (!hb_font_get_glyph_extents (font, glyph, &extents)))\n+        return false;\n+\n+      if (unlikely (!get_extents (font, glyph, &pixel_extents, false)))\n+        return false;\n+\n+      bool ret = funcs->image (data,\n+                               blob,\n+                               pixel_extents.width, -pixel_extents.height,\n+                               HB_PAINT_IMAGE_FORMAT_PNG,\n+                               font->slant_xy,\n+                               &extents);\n+\n+      hb_blob_destroy (blob);\n+      return ret;\n+    }\n+\n@@ -997,1 +1030,1 @@\n-#endif \/* HB_OT_COLOR_CBDT_TABLE_HH *\/\n+#endif \/* OT_COLOR_CBDT_CBDT_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Color\/CBDT\/CBDT.hh","additions":59,"deletions":26,"binary":false,"changes":85,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-cbdt-table.hh","status":"renamed"},{"patch":"@@ -0,0 +1,2203 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi\n+ * Copyright © 2020  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Calder Kitagawa\n+ *\/\n+\n+#ifndef OT_COLOR_COLR_COLR_HH\n+#define OT_COLOR_COLR_COLR_HH\n+\n+#include \"..\/..\/..\/hb.hh\"\n+#include \"..\/..\/..\/hb-open-type.hh\"\n+#include \"..\/..\/..\/hb-ot-var-common.hh\"\n+#include \"..\/..\/..\/hb-paint.hh\"\n+#include \"..\/..\/..\/hb-paint-extents.hh\"\n+\n+\/*\n+ * COLR -- Color\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/colr\n+ *\/\n+#define HB_OT_TAG_COLR HB_TAG('C','O','L','R')\n+\n+\n+namespace OT {\n+struct hb_paint_context_t;\n+}\n+\n+namespace OT {\n+\n+struct COLR;\n+\n+struct Paint;\n+\n+struct hb_paint_context_t :\n+       hb_dispatch_context_t<hb_paint_context_t>\n+{\n+  template <typename T>\n+  return_t dispatch (const T &obj) { obj.paint_glyph (this); return hb_empty_t (); }\n+  static return_t default_return_value () { return hb_empty_t (); }\n+\n+  const COLR* get_colr_table () const\n+  { return reinterpret_cast<const COLR *> (base); }\n+\n+public:\n+  const void *base;\n+  hb_paint_funcs_t *funcs;\n+  void *data;\n+  hb_font_t *font;\n+  unsigned int palette_index;\n+  hb_color_t foreground;\n+  VarStoreInstancer &instancer;\n+  int depth_left = HB_MAX_NESTING_LEVEL;\n+  int edge_count = HB_COLRV1_MAX_EDGE_COUNT;\n+\n+  hb_paint_context_t (const void *base_,\n+                      hb_paint_funcs_t *funcs_,\n+                      void *data_,\n+                      hb_font_t *font_,\n+                      unsigned int palette_,\n+                      hb_color_t foreground_,\n+                      VarStoreInstancer &instancer_) :\n+    base (base_),\n+    funcs (funcs_),\n+    data (data_),\n+    font (font_),\n+    palette_index (palette_),\n+    foreground (foreground_),\n+    instancer (instancer_)\n+  { }\n+\n+  hb_color_t get_color (unsigned int color_index, float alpha, hb_bool_t *is_foreground)\n+  {\n+    hb_color_t color = foreground;\n+\n+    *is_foreground = true;\n+\n+    if (color_index != 0xffff)\n+    {\n+      if (!funcs->custom_palette_color (data, color_index, &color))\n+      {\n+        unsigned int clen = 1;\n+        hb_face_t *face = hb_font_get_face (font);\n+\n+        hb_ot_color_palette_get_colors (face, palette_index, color_index, &clen, &color);\n+      }\n+\n+      *is_foreground = false;\n+    }\n+\n+    return HB_COLOR (hb_color_get_blue (color),\n+                     hb_color_get_green (color),\n+                     hb_color_get_red (color),\n+                     hb_color_get_alpha (color) * alpha);\n+  }\n+\n+  inline void recurse (const Paint &paint);\n+};\n+\n+struct hb_colrv1_closure_context_t :\n+       hb_dispatch_context_t<hb_colrv1_closure_context_t>\n+{\n+  template <typename T>\n+  return_t dispatch (const T &obj)\n+  {\n+    if (unlikely (nesting_level_left == 0))\n+      return hb_empty_t ();\n+\n+    if (paint_visited (&obj))\n+      return hb_empty_t ();\n+\n+    nesting_level_left--;\n+    obj.closurev1 (this);\n+    nesting_level_left++;\n+    return hb_empty_t ();\n+  }\n+  static return_t default_return_value () { return hb_empty_t (); }\n+\n+  bool paint_visited (const void *paint)\n+  {\n+    hb_codepoint_t delta = (hb_codepoint_t) ((uintptr_t) paint - (uintptr_t) base);\n+    if (visited_paint.in_error() || visited_paint.has (delta))\n+      return true;\n+\n+    visited_paint.add (delta);\n+    return false;\n+  }\n+\n+  const COLR* get_colr_table () const\n+  { return reinterpret_cast<const COLR *> (base); }\n+\n+  void add_glyph (unsigned glyph_id)\n+  { glyphs->add (glyph_id); }\n+\n+  void add_layer_indices (unsigned first_layer_index, unsigned num_of_layers)\n+  { layer_indices->add_range (first_layer_index, first_layer_index + num_of_layers - 1); }\n+\n+  void add_palette_index (unsigned palette_index)\n+  { palette_indices->add (palette_index); }\n+\n+  public:\n+  const void *base;\n+  hb_set_t visited_paint;\n+  hb_set_t *glyphs;\n+  hb_set_t *layer_indices;\n+  hb_set_t *palette_indices;\n+  unsigned nesting_level_left;\n+\n+  hb_colrv1_closure_context_t (const void *base_,\n+                               hb_set_t *glyphs_,\n+                               hb_set_t *layer_indices_,\n+                               hb_set_t *palette_indices_,\n+                               unsigned nesting_level_left_ = HB_MAX_NESTING_LEVEL) :\n+                          base (base_),\n+                          glyphs (glyphs_),\n+                          layer_indices (layer_indices_),\n+                          palette_indices (palette_indices_),\n+                          nesting_level_left (nesting_level_left_)\n+  {}\n+};\n+\n+struct LayerRecord\n+{\n+  operator hb_ot_color_layer_t () const { return {glyphId, colorIdx}; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  public:\n+  HBGlyphID16   glyphId;        \/* Glyph ID of layer glyph *\/\n+  Index         colorIdx;       \/* Index value to use with a\n+                                 * selected color palette.\n+                                 * An index value of 0xFFFF\n+                                 * is a special case indicating\n+                                 * that the text foreground\n+                                 * color (defined by a\n+                                 * higher-level client) should\n+                                 * be used and shall not be\n+                                 * treated as actual index\n+                                 * into CPAL ColorRecord array. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct BaseGlyphRecord\n+{\n+  int cmp (hb_codepoint_t g) const\n+  { return g < glyphId ? -1 : g > glyphId ? 1 : 0; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  public:\n+  HBGlyphID16   glyphId;        \/* Glyph ID of reference glyph *\/\n+  HBUINT16      firstLayerIdx;  \/* Index (from beginning of\n+                                 * the Layer Records) to the\n+                                 * layer record. There will be\n+                                 * numLayers consecutive entries\n+                                 * for this base glyph. *\/\n+  HBUINT16      numLayers;      \/* Number of color layers\n+                                 * associated with this glyph *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+template <typename T>\n+struct Variable\n+{\n+  static constexpr bool is_variable = true;\n+\n+  Variable<T>* copy (hb_serialize_context_t *c) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    return_trace (c->embed (this));\n+  }\n+\n+  void closurev1 (hb_colrv1_closure_context_t* c) const\n+  { value.closurev1 (c); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    if (!value.subset (c)) return_trace (false);\n+    return_trace (c->serializer->embed (varIdxBase));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && value.sanitize (c));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c) const\n+  {\n+    value.paint_glyph (c, varIdxBase);\n+  }\n+\n+  void get_color_stop (hb_paint_context_t *c,\n+                       hb_color_stop_t *stop,\n+                       const VarStoreInstancer &instancer) const\n+  {\n+    value.get_color_stop (c, stop, varIdxBase, instancer);\n+  }\n+\n+  hb_paint_extend_t get_extend () const\n+  {\n+    return value.get_extend ();\n+  }\n+\n+  protected:\n+  T      value;\n+  public:\n+  VarIdx varIdxBase;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + T::static_size);\n+};\n+\n+template <typename T>\n+struct NoVariable\n+{\n+  static constexpr bool is_variable = false;\n+\n+  static constexpr uint32_t varIdxBase = VarIdx::NO_VARIATION;\n+\n+  NoVariable<T>* copy (hb_serialize_context_t *c) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    return_trace (c->embed (this));\n+  }\n+\n+  void closurev1 (hb_colrv1_closure_context_t* c) const\n+  { value.closurev1 (c); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    return_trace (value.subset (c));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && value.sanitize (c));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c) const\n+  {\n+    value.paint_glyph (c, varIdxBase);\n+  }\n+\n+  void get_color_stop (hb_paint_context_t *c,\n+                       hb_color_stop_t *stop,\n+                       const VarStoreInstancer &instancer) const\n+  {\n+    value.get_color_stop (c, stop, VarIdx::NO_VARIATION, instancer);\n+  }\n+\n+  hb_paint_extend_t get_extend () const\n+  {\n+    return value.get_extend ();\n+  }\n+\n+  T      value;\n+  public:\n+  DEFINE_SIZE_STATIC (T::static_size);\n+};\n+\n+\/\/ Color structures\n+\n+struct ColorStop\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const\n+  { c->add_palette_index (paletteIndex); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+    return_trace (c->serializer->check_assign (out->paletteIndex, c->plan->colr_palettes.get (paletteIndex),\n+                                               HB_SERIALIZE_ERROR_INT_OVERFLOW));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  void get_color_stop (hb_paint_context_t *c,\n+                       hb_color_stop_t *out,\n+                       uint32_t varIdx,\n+                       const VarStoreInstancer &instancer) const\n+  {\n+    out->offset = stopOffset.to_float(instancer (varIdx, 0));\n+    out->color = c->get_color (paletteIndex,\n+                               alpha.to_float (instancer (varIdx, 1)),\n+                               &out->is_foreground);\n+  }\n+\n+  F2DOT14       stopOffset;\n+  HBUINT16      paletteIndex;\n+  F2DOT14       alpha;\n+  public:\n+  DEFINE_SIZE_STATIC (2 + 2 * F2DOT14::static_size);\n+};\n+\n+struct Extend : HBUINT8\n+{\n+  enum {\n+    EXTEND_PAD     = 0,\n+    EXTEND_REPEAT  = 1,\n+    EXTEND_REFLECT = 2,\n+  };\n+  public:\n+  DEFINE_SIZE_STATIC (1);\n+};\n+\n+template <template<typename> class Var>\n+struct ColorLine\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const\n+  {\n+    for (const auto &stop : stops.iter ())\n+      stop.closurev1 (c);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+\n+    if (!c->serializer->check_assign (out->extend, extend, HB_SERIALIZE_ERROR_INT_OVERFLOW)) return_trace (false);\n+    if (!c->serializer->check_assign (out->stops.len, stops.len, HB_SERIALIZE_ERROR_ARRAY_OVERFLOW)) return_trace (false);\n+\n+    for (const auto& stop : stops.iter ())\n+    {\n+      if (!stop.subset (c)) return_trace (false);\n+    }\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  stops.sanitize (c));\n+  }\n+\n+  \/* get up to count stops from start *\/\n+  unsigned int\n+  get_color_stops (hb_paint_context_t *c,\n+                   unsigned int start,\n+                   unsigned int *count,\n+                   hb_color_stop_t *color_stops,\n+                   const VarStoreInstancer &instancer) const\n+  {\n+    unsigned int len = stops.len;\n+\n+    if (count && color_stops)\n+    {\n+      unsigned int i;\n+      for (i = 0; i < *count && start + i < len; i++)\n+        stops[start + i].get_color_stop (c, &color_stops[i], instancer);\n+      *count = i;\n+    }\n+\n+    return len;\n+  }\n+\n+  HB_INTERNAL static unsigned int static_get_color_stops (hb_color_line_t *color_line,\n+                                                          void *color_line_data,\n+                                                          unsigned int start,\n+                                                          unsigned int *count,\n+                                                          hb_color_stop_t *color_stops,\n+                                                          void *user_data)\n+  {\n+    const ColorLine *thiz = (const ColorLine *) color_line_data;\n+    hb_paint_context_t *c = (hb_paint_context_t *) user_data;\n+    return thiz->get_color_stops (c, start, count, color_stops, c->instancer);\n+  }\n+\n+  hb_paint_extend_t get_extend () const\n+  {\n+    return (hb_paint_extend_t) (unsigned int) extend;\n+  }\n+\n+  HB_INTERNAL static hb_paint_extend_t static_get_extend (hb_color_line_t *color_line,\n+                                                          void *color_line_data,\n+                                                          void *user_data)\n+  {\n+    const ColorLine *thiz = (const ColorLine *) color_line_data;\n+    return thiz->get_extend ();\n+  }\n+\n+  Extend        extend;\n+  Array16Of<Var<ColorStop>>     stops;\n+  public:\n+  DEFINE_SIZE_ARRAY_SIZED (3, stops);\n+};\n+\n+\/\/ Composition modes\n+\n+\/\/ Compositing modes are taken from https:\/\/www.w3.org\/TR\/compositing-1\/\n+\/\/ NOTE: a brief audit of major implementations suggests most support most\n+\/\/ or all of the specified modes.\n+struct CompositeMode : HBUINT8\n+{\n+  enum {\n+    \/\/ Porter-Duff modes\n+    \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators\n+    COMPOSITE_CLEAR          =  0,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_clear\n+    COMPOSITE_SRC            =  1,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_src\n+    COMPOSITE_DEST           =  2,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dst\n+    COMPOSITE_SRC_OVER       =  3,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_srcover\n+    COMPOSITE_DEST_OVER      =  4,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dstover\n+    COMPOSITE_SRC_IN         =  5,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_srcin\n+    COMPOSITE_DEST_IN        =  6,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dstin\n+    COMPOSITE_SRC_OUT        =  7,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_srcout\n+    COMPOSITE_DEST_OUT       =  8,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dstout\n+    COMPOSITE_SRC_ATOP       =  9,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_srcatop\n+    COMPOSITE_DEST_ATOP      = 10,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dstatop\n+    COMPOSITE_XOR            = 11,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_xor\n+    COMPOSITE_PLUS           = 12,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_plus\n+\n+    \/\/ Blend modes\n+    \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blending\n+    COMPOSITE_SCREEN         = 13,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingscreen\n+    COMPOSITE_OVERLAY        = 14,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingoverlay\n+    COMPOSITE_DARKEN         = 15,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingdarken\n+    COMPOSITE_LIGHTEN        = 16,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendinglighten\n+    COMPOSITE_COLOR_DODGE    = 17,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingcolordodge\n+    COMPOSITE_COLOR_BURN     = 18,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingcolorburn\n+    COMPOSITE_HARD_LIGHT     = 19,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendinghardlight\n+    COMPOSITE_SOFT_LIGHT     = 20,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingsoftlight\n+    COMPOSITE_DIFFERENCE     = 21,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingdifference\n+    COMPOSITE_EXCLUSION      = 22,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingexclusion\n+    COMPOSITE_MULTIPLY       = 23,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingmultiply\n+\n+    \/\/ Modes that, uniquely, do not operate on components\n+    \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingnonseparable\n+    COMPOSITE_HSL_HUE        = 24,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendinghue\n+    COMPOSITE_HSL_SATURATION = 25,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingsaturation\n+    COMPOSITE_HSL_COLOR      = 26,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingcolor\n+    COMPOSITE_HSL_LUMINOSITY = 27,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingluminosity\n+  };\n+  public:\n+  DEFINE_SIZE_STATIC (1);\n+};\n+\n+struct Affine2x3\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c, uint32_t varIdxBase) const\n+  {\n+    c->funcs->push_transform (c->data,\n+                              xx.to_float (c->instancer (varIdxBase, 0)),\n+                              yx.to_float (c->instancer (varIdxBase, 1)),\n+                              xy.to_float (c->instancer (varIdxBase, 2)),\n+                              yy.to_float (c->instancer (varIdxBase, 3)),\n+                              dx.to_float (c->instancer (varIdxBase, 4)),\n+                              dy.to_float (c->instancer (varIdxBase, 5)));\n+  }\n+\n+  F16DOT16 xx;\n+  F16DOT16 yx;\n+  F16DOT16 xy;\n+  F16DOT16 yy;\n+  F16DOT16 dx;\n+  F16DOT16 dy;\n+  public:\n+  DEFINE_SIZE_STATIC (6 * F16DOT16::static_size);\n+};\n+\n+struct PaintColrLayers\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+    return_trace (c->serializer->check_assign (out->firstLayerIndex, c->plan->colrv1_layers.get (firstLayerIndex),\n+                                               HB_SERIALIZE_ERROR_INT_OVERFLOW));\n+\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  inline void paint_glyph (hb_paint_context_t *c) const;\n+\n+  HBUINT8       format; \/* format = 1 *\/\n+  HBUINT8       numLayers;\n+  HBUINT32      firstLayerIndex;  \/* index into COLRv1::layerList *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct PaintSolid\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const\n+  { c->add_palette_index (paletteIndex); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+    return_trace (c->serializer->check_assign (out->paletteIndex, c->plan->colr_palettes.get (paletteIndex),\n+                                               HB_SERIALIZE_ERROR_INT_OVERFLOW));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c, uint32_t varIdxBase) const\n+  {\n+    hb_bool_t is_foreground;\n+    hb_color_t color;\n+\n+    color = c->get_color (paletteIndex,\n+                          alpha.to_float (c->instancer (varIdxBase, 0)),\n+                          &is_foreground);\n+    c->funcs->color (c->data, is_foreground, color);\n+  }\n+\n+  HBUINT8       format; \/* format = 2(noVar) or 3(Var)*\/\n+  HBUINT16      paletteIndex;\n+  F2DOT14       alpha;\n+  public:\n+  DEFINE_SIZE_STATIC (3 + F2DOT14::static_size);\n+};\n+\n+template <template<typename> class Var>\n+struct PaintLinearGradient\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const\n+  { (this+colorLine).closurev1 (c); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && colorLine.sanitize (c, this));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c, uint32_t varIdxBase) const\n+  {\n+    hb_color_line_t cl = {\n+      (void *) &(this+colorLine),\n+      (this+colorLine).static_get_color_stops, c,\n+      (this+colorLine).static_get_extend, nullptr\n+    };\n+\n+    c->funcs->linear_gradient (c->data, &cl,\n+                               x0 + c->instancer (varIdxBase, 0),\n+                               y0 + c->instancer (varIdxBase, 1),\n+                               x1 + c->instancer (varIdxBase, 2),\n+                               y1 + c->instancer (varIdxBase, 3),\n+                               x2 + c->instancer (varIdxBase, 4),\n+                               y2 + c->instancer (varIdxBase, 5));\n+  }\n+\n+  HBUINT8                       format; \/* format = 4(noVar) or 5 (Var) *\/\n+  Offset24To<ColorLine<Var>>    colorLine; \/* Offset (from beginning of PaintLinearGradient\n+                                            * table) to ColorLine subtable. *\/\n+  FWORD                 x0;\n+  FWORD                 y0;\n+  FWORD                 x1;\n+  FWORD                 y1;\n+  FWORD                 x2;\n+  FWORD                 y2;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + 6 * FWORD::static_size);\n+};\n+\n+template <template<typename> class Var>\n+struct PaintRadialGradient\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const\n+  { (this+colorLine).closurev1 (c); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && colorLine.sanitize (c, this));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c, uint32_t varIdxBase) const\n+  {\n+    hb_color_line_t cl = {\n+      (void *) &(this+colorLine),\n+      (this+colorLine).static_get_color_stops, c,\n+      (this+colorLine).static_get_extend, nullptr\n+    };\n+\n+    c->funcs->radial_gradient (c->data, &cl,\n+                               x0 + c->instancer (varIdxBase, 0),\n+                               y0 + c->instancer (varIdxBase, 1),\n+                               radius0 + c->instancer (varIdxBase, 2),\n+                               x1 + c->instancer (varIdxBase, 3),\n+                               y1 + c->instancer (varIdxBase, 4),\n+                               radius1 + c->instancer (varIdxBase, 5));\n+  }\n+\n+  HBUINT8                       format; \/* format = 6(noVar) or 7 (Var) *\/\n+  Offset24To<ColorLine<Var>>    colorLine; \/* Offset (from beginning of PaintRadialGradient\n+                                            * table) to ColorLine subtable. *\/\n+  FWORD                 x0;\n+  FWORD                 y0;\n+  UFWORD                radius0;\n+  FWORD                 x1;\n+  FWORD                 y1;\n+  UFWORD                radius1;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + 6 * FWORD::static_size);\n+};\n+\n+template <template<typename> class Var>\n+struct PaintSweepGradient\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const\n+  { (this+colorLine).closurev1 (c); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && colorLine.sanitize (c, this));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c, uint32_t varIdxBase) const\n+  {\n+    hb_color_line_t cl = {\n+      (void *) &(this+colorLine),\n+      (this+colorLine).static_get_color_stops, c,\n+      (this+colorLine).static_get_extend, nullptr\n+    };\n+\n+    c->funcs->sweep_gradient (c->data, &cl,\n+                              centerX + c->instancer (varIdxBase, 0),\n+                              centerY + c->instancer (varIdxBase, 1),\n+                              (startAngle.to_float (c->instancer (varIdxBase, 2)) + 1) * (float) M_PI,\n+                              (endAngle.to_float   (c->instancer (varIdxBase, 3)) + 1) * (float) M_PI);\n+  }\n+\n+  HBUINT8                       format; \/* format = 8(noVar) or 9 (Var) *\/\n+  Offset24To<ColorLine<Var>>    colorLine; \/* Offset (from beginning of PaintSweepGradient\n+                                            * table) to ColorLine subtable. *\/\n+  FWORD                 centerX;\n+  FWORD                 centerY;\n+  F2DOT14               startAngle;\n+  F2DOT14               endAngle;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + 2 * FWORD::static_size + 2 * F2DOT14::static_size);\n+};\n+\n+\/\/ Paint a non-COLR glyph, filled as indicated by paint.\n+struct PaintGlyph\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    if (! c->serializer->check_assign (out->gid, c->plan->glyph_map->get (gid),\n+                                       HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+      return_trace (false);\n+\n+    return_trace (out->paint.serialize_subset (c, paint, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && paint.sanitize (c, this));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c) const\n+  {\n+    c->funcs->push_inverse_root_transform (c->data, c->font);\n+    c->funcs->push_clip_glyph (c->data, gid, c->font);\n+    c->funcs->push_root_transform (c->data, c->font);\n+    c->recurse (this+paint);\n+    c->funcs->pop_transform (c->data);\n+    c->funcs->pop_clip (c->data);\n+    c->funcs->pop_transform (c->data);\n+  }\n+\n+  HBUINT8               format; \/* format = 10 *\/\n+  Offset24To<Paint>     paint;  \/* Offset (from beginning of PaintGlyph table) to Paint subtable. *\/\n+  HBUINT16              gid;\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct PaintColrGlyph\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (c->serializer->check_assign (out->gid, c->plan->glyph_map->get (gid),\n+                                               HB_SERIALIZE_ERROR_INT_OVERFLOW));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  inline void paint_glyph (hb_paint_context_t *c) const;\n+\n+  HBUINT8       format; \/* format = 11 *\/\n+  HBUINT16      gid;\n+  public:\n+  DEFINE_SIZE_STATIC (3);\n+};\n+\n+template <template<typename> class Var>\n+struct PaintTransform\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+    if (!out->transform.serialize_copy (c->serializer, transform, this)) return_trace (false);\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  src.sanitize (c, this) &&\n+                  transform.sanitize (c, this));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c) const\n+  {\n+    (this+transform).paint_glyph (c);\n+    c->recurse (this+src);\n+    c->funcs->pop_transform (c->data);\n+  }\n+\n+  HBUINT8                       format; \/* format = 12(noVar) or 13 (Var) *\/\n+  Offset24To<Paint>             src; \/* Offset (from beginning of PaintTransform table) to Paint subtable. *\/\n+  Offset24To<Var<Affine2x3>>    transform;\n+  public:\n+  DEFINE_SIZE_STATIC (7);\n+};\n+\n+struct PaintTranslate\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c, uint32_t varIdxBase) const\n+  {\n+    float ddx = dx + c->instancer (varIdxBase, 0);\n+    float ddy = dy + c->instancer (varIdxBase, 1);\n+\n+    bool p1 = c->funcs->push_translate (c->data, ddx, ddy);\n+    c->recurse (this+src);\n+    if (p1) c->funcs->pop_transform (c->data);\n+  }\n+\n+  HBUINT8               format; \/* format = 14(noVar) or 15 (Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintTranslate table) to Paint subtable. *\/\n+  FWORD         dx;\n+  FWORD         dy;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + 2 * FWORD::static_size);\n+};\n+\n+struct PaintScale\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c, uint32_t varIdxBase) const\n+  {\n+    float sx = scaleX.to_float (c->instancer (varIdxBase, 0));\n+    float sy = scaleY.to_float (c->instancer (varIdxBase, 1));\n+\n+    bool p1 = c->funcs->push_scale (c->data, sx, sy);\n+    c->recurse (this+src);\n+    if (p1) c->funcs->pop_transform (c->data);\n+  }\n+\n+  HBUINT8               format; \/* format = 16 (noVar) or 17(Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintScale table) to Paint subtable. *\/\n+  F2DOT14               scaleX;\n+  F2DOT14               scaleY;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + 2 * F2DOT14::static_size);\n+};\n+\n+struct PaintScaleAroundCenter\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c, uint32_t varIdxBase) const\n+  {\n+    float sx = scaleX.to_float (c->instancer (varIdxBase, 0));\n+    float sy = scaleY.to_float (c->instancer (varIdxBase, 1));\n+    float tCenterX = centerX + c->instancer (varIdxBase, 2);\n+    float tCenterY = centerY + c->instancer (varIdxBase, 3);\n+\n+    bool p1 = c->funcs->push_translate (c->data, +tCenterX, +tCenterY);\n+    bool p2 = c->funcs->push_scale (c->data, sx, sy);\n+    bool p3 = c->funcs->push_translate (c->data, -tCenterX, -tCenterY);\n+    c->recurse (this+src);\n+    if (p3) c->funcs->pop_transform (c->data);\n+    if (p2) c->funcs->pop_transform (c->data);\n+    if (p1) c->funcs->pop_transform (c->data);\n+  }\n+\n+  HBUINT8               format; \/* format = 18 (noVar) or 19(Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintScaleAroundCenter table) to Paint subtable. *\/\n+  F2DOT14       scaleX;\n+  F2DOT14       scaleY;\n+  FWORD         centerX;\n+  FWORD         centerY;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + 2 * F2DOT14::static_size + 2 * FWORD::static_size);\n+};\n+\n+struct PaintScaleUniform\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c, uint32_t varIdxBase) const\n+  {\n+    float s = scale.to_float (c->instancer (varIdxBase, 0));\n+\n+    bool p1 = c->funcs->push_scale (c->data, s, s);\n+    c->recurse (this+src);\n+    if (p1) c->funcs->pop_transform (c->data);\n+  }\n+\n+  HBUINT8               format; \/* format = 20 (noVar) or 21(Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintScaleUniform table) to Paint subtable. *\/\n+  F2DOT14               scale;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + F2DOT14::static_size);\n+};\n+\n+struct PaintScaleUniformAroundCenter\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c, uint32_t varIdxBase) const\n+  {\n+    float s = scale.to_float (c->instancer (varIdxBase, 0));\n+    float tCenterX = centerX + c->instancer (varIdxBase, 1);\n+    float tCenterY = centerY + c->instancer (varIdxBase, 2);\n+\n+    bool p1 = c->funcs->push_translate (c->data, +tCenterX, +tCenterY);\n+    bool p2 = c->funcs->push_scale (c->data, s, s);\n+    bool p3 = c->funcs->push_translate (c->data, -tCenterX, -tCenterY);\n+    c->recurse (this+src);\n+    if (p3) c->funcs->pop_transform (c->data);\n+    if (p2) c->funcs->pop_transform (c->data);\n+    if (p1) c->funcs->pop_transform (c->data);\n+  }\n+\n+  HBUINT8               format; \/* format = 22 (noVar) or 23(Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintScaleUniformAroundCenter table) to Paint subtable. *\/\n+  F2DOT14       scale;\n+  FWORD         centerX;\n+  FWORD         centerY;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + F2DOT14::static_size + 2 * FWORD::static_size);\n+};\n+\n+struct PaintRotate\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c, uint32_t varIdxBase) const\n+  {\n+    float a = angle.to_float (c->instancer (varIdxBase, 0));\n+\n+    bool p1 = c->funcs->push_rotate (c->data, a);\n+    c->recurse (this+src);\n+    if (p1) c->funcs->pop_transform (c->data);\n+  }\n+\n+  HBUINT8               format; \/* format = 24 (noVar) or 25(Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintRotate table) to Paint subtable. *\/\n+  F2DOT14               angle;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + F2DOT14::static_size);\n+};\n+\n+struct PaintRotateAroundCenter\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c, uint32_t varIdxBase) const\n+  {\n+    float a = angle.to_float (c->instancer (varIdxBase, 0));\n+    float tCenterX = centerX + c->instancer (varIdxBase, 1);\n+    float tCenterY = centerY + c->instancer (varIdxBase, 2);\n+\n+    bool p1 = c->funcs->push_translate (c->data, +tCenterX, +tCenterY);\n+    bool p2 = c->funcs->push_rotate (c->data, a);\n+    bool p3 = c->funcs->push_translate (c->data, -tCenterX, -tCenterY);\n+    c->recurse (this+src);\n+    if (p3) c->funcs->pop_transform (c->data);\n+    if (p2) c->funcs->pop_transform (c->data);\n+    if (p1) c->funcs->pop_transform (c->data);\n+  }\n+\n+  HBUINT8               format; \/* format = 26 (noVar) or 27(Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintRotateAroundCenter table) to Paint subtable. *\/\n+  F2DOT14       angle;\n+  FWORD         centerX;\n+  FWORD         centerY;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + F2DOT14::static_size + 2 * FWORD::static_size);\n+};\n+\n+struct PaintSkew\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c, uint32_t varIdxBase) const\n+  {\n+    float sx = xSkewAngle.to_float(c->instancer (varIdxBase, 0));\n+    float sy = ySkewAngle.to_float(c->instancer (varIdxBase, 1));\n+\n+    bool p1 = c->funcs->push_skew (c->data, sx, sy);\n+    c->recurse (this+src);\n+    if (p1) c->funcs->pop_transform (c->data);\n+  }\n+\n+  HBUINT8               format; \/* format = 28(noVar) or 29 (Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintSkew table) to Paint subtable. *\/\n+  F2DOT14               xSkewAngle;\n+  F2DOT14               ySkewAngle;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + 2 * F2DOT14::static_size);\n+};\n+\n+struct PaintSkewAroundCenter\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c, uint32_t varIdxBase) const\n+  {\n+    float sx = xSkewAngle.to_float(c->instancer (varIdxBase, 0));\n+    float sy = ySkewAngle.to_float(c->instancer (varIdxBase, 1));\n+    float tCenterX = centerX + c->instancer (varIdxBase, 2);\n+    float tCenterY = centerY + c->instancer (varIdxBase, 3);\n+\n+    bool p1 = c->funcs->push_translate (c->data, +tCenterX, +tCenterY);\n+    bool p2 = c->funcs->push_skew (c->data, sx, sy);\n+    bool p3 = c->funcs->push_translate (c->data, -tCenterX, -tCenterY);\n+    c->recurse (this+src);\n+    if (p3) c->funcs->pop_transform (c->data);\n+    if (p2) c->funcs->pop_transform (c->data);\n+    if (p1) c->funcs->pop_transform (c->data);\n+  }\n+\n+  HBUINT8               format; \/* format = 30(noVar) or 31 (Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintSkewAroundCenter table) to Paint subtable. *\/\n+  F2DOT14       xSkewAngle;\n+  F2DOT14       ySkewAngle;\n+  FWORD         centerX;\n+  FWORD         centerY;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + 2 * F2DOT14::static_size + 2 * FWORD::static_size);\n+};\n+\n+struct PaintComposite\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    if (!out->src.serialize_subset (c, src, this)) return_trace (false);\n+    return_trace (out->backdrop.serialize_subset (c, backdrop, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  src.sanitize (c, this) &&\n+                  backdrop.sanitize (c, this));\n+  }\n+\n+  void paint_glyph (hb_paint_context_t *c) const\n+  {\n+    c->recurse (this+backdrop);\n+    c->funcs->push_group (c->data);\n+    c->recurse (this+src);\n+    c->funcs->pop_group (c->data, (hb_paint_composite_mode_t) (int) mode);\n+  }\n+\n+  HBUINT8               format; \/* format = 32 *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintComposite table) to source Paint subtable. *\/\n+  CompositeMode         mode;   \/* If mode is unrecognized use COMPOSITE_CLEAR *\/\n+  Offset24To<Paint>     backdrop; \/* Offset (from beginning of PaintComposite table) to backdrop Paint subtable. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+struct ClipBoxData\n+{\n+  int xMin, yMin, xMax, yMax;\n+};\n+\n+struct ClipBoxFormat1\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  void get_clip_box (ClipBoxData &clip_box, const VarStoreInstancer &instancer HB_UNUSED) const\n+  {\n+    clip_box.xMin = xMin;\n+    clip_box.yMin = yMin;\n+    clip_box.xMax = xMax;\n+    clip_box.yMax = yMax;\n+  }\n+\n+  public:\n+  HBUINT8       format; \/* format = 1(noVar) or 2(Var)*\/\n+  FWORD         xMin;\n+  FWORD         yMin;\n+  FWORD         xMax;\n+  FWORD         yMax;\n+  public:\n+  DEFINE_SIZE_STATIC (1 + 4 * FWORD::static_size);\n+};\n+\n+struct ClipBoxFormat2 : Variable<ClipBoxFormat1>\n+{\n+  void get_clip_box (ClipBoxData &clip_box, const VarStoreInstancer &instancer) const\n+  {\n+    value.get_clip_box(clip_box, instancer);\n+    if (instancer)\n+    {\n+      clip_box.xMin += _hb_roundf (instancer (varIdxBase, 0));\n+      clip_box.yMin += _hb_roundf (instancer (varIdxBase, 1));\n+      clip_box.xMax += _hb_roundf (instancer (varIdxBase, 2));\n+      clip_box.yMax += _hb_roundf (instancer (varIdxBase, 3));\n+    }\n+  }\n+};\n+\n+struct ClipBox\n+{\n+  ClipBox* copy (hb_serialize_context_t *c) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    switch (u.format) {\n+    case 1: return_trace (reinterpret_cast<ClipBox *> (c->embed (u.format1)));\n+    case 2: return_trace (reinterpret_cast<ClipBox *> (c->embed (u.format2)));\n+    default:return_trace (nullptr);\n+    }\n+  }\n+\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  {\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n+    TRACE_DISPATCH (this, u.format);\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  bool get_extents (hb_glyph_extents_t *extents,\n+                    const VarStoreInstancer &instancer) const\n+  {\n+    ClipBoxData clip_box;\n+    switch (u.format) {\n+    case 1:\n+      u.format1.get_clip_box (clip_box, instancer);\n+      break;\n+    case 2:\n+      u.format2.get_clip_box (clip_box, instancer);\n+      break;\n+    default:\n+      return false;\n+    }\n+\n+    extents->x_bearing = clip_box.xMin;\n+    extents->y_bearing = clip_box.yMax;\n+    extents->width = clip_box.xMax - clip_box.xMin;\n+    extents->height = clip_box.yMin - clip_box.yMax;\n+    return true;\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT8               format;         \/* Format identifier *\/\n+  ClipBoxFormat1        format1;\n+  ClipBoxFormat2        format2;\n+  } u;\n+};\n+\n+struct ClipRecord\n+{\n+  int cmp (hb_codepoint_t g) const\n+  { return g < startGlyphID ? -1 : g <= endGlyphID ? 0 : +1; }\n+\n+  ClipRecord* copy (hb_serialize_context_t *c, const void *base) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    auto *out = c->embed (this);\n+    if (unlikely (!out)) return_trace (nullptr);\n+    if (!out->clipBox.serialize_copy (c, clipBox, base)) return_trace (nullptr);\n+    return_trace (out);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && clipBox.sanitize (c, base));\n+  }\n+\n+  bool get_extents (hb_glyph_extents_t *extents,\n+                    const void *base,\n+                    const VarStoreInstancer &instancer) const\n+  {\n+    return (base+clipBox).get_extents (extents, instancer);\n+  }\n+\n+  public:\n+  HBUINT16              startGlyphID;  \/\/ first gid clip applies to\n+  HBUINT16              endGlyphID;    \/\/ last gid clip applies to, inclusive\n+  Offset24To<ClipBox>   clipBox;   \/\/ Box or VarBox\n+  public:\n+  DEFINE_SIZE_STATIC (7);\n+};\n+DECLARE_NULL_NAMESPACE_BYTES (OT, ClipRecord);\n+\n+struct ClipList\n+{\n+  unsigned serialize_clip_records (hb_serialize_context_t *c,\n+                                   const hb_set_t& gids,\n+                                   const hb_map_t& gid_offset_map) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (gids.is_empty () ||\n+        gid_offset_map.get_population () != gids.get_population ())\n+      return_trace (0);\n+\n+    unsigned count  = 0;\n+\n+    hb_codepoint_t start_gid= gids.get_min ();\n+    hb_codepoint_t prev_gid = start_gid;\n+\n+    unsigned offset = gid_offset_map.get (start_gid);\n+    unsigned prev_offset = offset;\n+    for (const hb_codepoint_t _ : gids.iter ())\n+    {\n+      if (_ == start_gid) continue;\n+\n+      offset = gid_offset_map.get (_);\n+      if (_ == prev_gid + 1 &&  offset == prev_offset)\n+      {\n+        prev_gid = _;\n+        continue;\n+      }\n+\n+      ClipRecord record;\n+      record.startGlyphID = start_gid;\n+      record.endGlyphID = prev_gid;\n+      record.clipBox = prev_offset;\n+\n+      if (!c->copy (record, this)) return_trace (0);\n+      count++;\n+\n+      start_gid = _;\n+      prev_gid = _;\n+      prev_offset = offset;\n+    }\n+\n+    \/\/last one\n+    {\n+      ClipRecord record;\n+      record.startGlyphID = start_gid;\n+      record.endGlyphID = prev_gid;\n+      record.clipBox = prev_offset;\n+      if (!c->copy (record, this)) return_trace (0);\n+      count++;\n+    }\n+    return_trace (count);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+    if (!c->serializer->check_assign (out->format, format, HB_SERIALIZE_ERROR_INT_OVERFLOW)) return_trace (false);\n+\n+    const hb_set_t& glyphset = c->plan->_glyphset_colred;\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    hb_map_t new_gid_offset_map;\n+    hb_set_t new_gids;\n+    for (const ClipRecord& record : clips.iter ())\n+    {\n+      unsigned start_gid = record.startGlyphID;\n+      unsigned end_gid = record.endGlyphID;\n+      for (unsigned gid = start_gid; gid <= end_gid; gid++)\n+      {\n+        if (!glyphset.has (gid) || !glyph_map.has (gid)) continue;\n+        unsigned new_gid = glyph_map.get (gid);\n+        new_gid_offset_map.set (new_gid, record.clipBox);\n+        new_gids.add (new_gid);\n+      }\n+    }\n+\n+    unsigned count = serialize_clip_records (c->serializer, new_gids, new_gid_offset_map);\n+    if (!count) return_trace (false);\n+    return_trace (c->serializer->check_assign (out->clips.len, count, HB_SERIALIZE_ERROR_INT_OVERFLOW));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    \/\/ TODO Make a formatted struct!\n+    return_trace (c->check_struct (this) && clips.sanitize (c, this));\n+  }\n+\n+  bool\n+  get_extents (hb_codepoint_t gid,\n+               hb_glyph_extents_t *extents,\n+               const VarStoreInstancer &instancer) const\n+  {\n+    auto *rec = clips.as_array ().bsearch (gid);\n+    if (rec)\n+    {\n+      rec->get_extents (extents, this, instancer);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  HBUINT8                       format;  \/\/ Set to 1.\n+  SortedArray32Of<ClipRecord>   clips;  \/\/ Clip records, sorted by startGlyphID\n+  public:\n+  DEFINE_SIZE_ARRAY_SIZED (5, clips);\n+};\n+\n+struct Paint\n+{\n+\n+  template <typename ...Ts>\n+  bool sanitize (hb_sanitize_context_t *c, Ts&&... ds) const\n+  {\n+    TRACE_SANITIZE (this);\n+\n+    if (unlikely (!c->check_start_recursion (HB_MAX_NESTING_LEVEL)))\n+      return_trace (c->no_dispatch_return_value ());\n+\n+    return_trace (c->end_recursion (this->dispatch (c, std::forward<Ts> (ds)...)));\n+  }\n+\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  {\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n+    TRACE_DISPATCH (this, u.format);\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.paintformat1, std::forward<Ts> (ds)...));\n+    case 2: return_trace (c->dispatch (u.paintformat2, std::forward<Ts> (ds)...));\n+    case 3: return_trace (c->dispatch (u.paintformat3, std::forward<Ts> (ds)...));\n+    case 4: return_trace (c->dispatch (u.paintformat4, std::forward<Ts> (ds)...));\n+    case 5: return_trace (c->dispatch (u.paintformat5, std::forward<Ts> (ds)...));\n+    case 6: return_trace (c->dispatch (u.paintformat6, std::forward<Ts> (ds)...));\n+    case 7: return_trace (c->dispatch (u.paintformat7, std::forward<Ts> (ds)...));\n+    case 8: return_trace (c->dispatch (u.paintformat8, std::forward<Ts> (ds)...));\n+    case 9: return_trace (c->dispatch (u.paintformat9, std::forward<Ts> (ds)...));\n+    case 10: return_trace (c->dispatch (u.paintformat10, std::forward<Ts> (ds)...));\n+    case 11: return_trace (c->dispatch (u.paintformat11, std::forward<Ts> (ds)...));\n+    case 12: return_trace (c->dispatch (u.paintformat12, std::forward<Ts> (ds)...));\n+    case 13: return_trace (c->dispatch (u.paintformat13, std::forward<Ts> (ds)...));\n+    case 14: return_trace (c->dispatch (u.paintformat14, std::forward<Ts> (ds)...));\n+    case 15: return_trace (c->dispatch (u.paintformat15, std::forward<Ts> (ds)...));\n+    case 16: return_trace (c->dispatch (u.paintformat16, std::forward<Ts> (ds)...));\n+    case 17: return_trace (c->dispatch (u.paintformat17, std::forward<Ts> (ds)...));\n+    case 18: return_trace (c->dispatch (u.paintformat18, std::forward<Ts> (ds)...));\n+    case 19: return_trace (c->dispatch (u.paintformat19, std::forward<Ts> (ds)...));\n+    case 20: return_trace (c->dispatch (u.paintformat20, std::forward<Ts> (ds)...));\n+    case 21: return_trace (c->dispatch (u.paintformat21, std::forward<Ts> (ds)...));\n+    case 22: return_trace (c->dispatch (u.paintformat22, std::forward<Ts> (ds)...));\n+    case 23: return_trace (c->dispatch (u.paintformat23, std::forward<Ts> (ds)...));\n+    case 24: return_trace (c->dispatch (u.paintformat24, std::forward<Ts> (ds)...));\n+    case 25: return_trace (c->dispatch (u.paintformat25, std::forward<Ts> (ds)...));\n+    case 26: return_trace (c->dispatch (u.paintformat26, std::forward<Ts> (ds)...));\n+    case 27: return_trace (c->dispatch (u.paintformat27, std::forward<Ts> (ds)...));\n+    case 28: return_trace (c->dispatch (u.paintformat28, std::forward<Ts> (ds)...));\n+    case 29: return_trace (c->dispatch (u.paintformat29, std::forward<Ts> (ds)...));\n+    case 30: return_trace (c->dispatch (u.paintformat30, std::forward<Ts> (ds)...));\n+    case 31: return_trace (c->dispatch (u.paintformat31, std::forward<Ts> (ds)...));\n+    case 32: return_trace (c->dispatch (u.paintformat32, std::forward<Ts> (ds)...));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT8                                       format;\n+  PaintColrLayers                               paintformat1;\n+  NoVariable<PaintSolid>                        paintformat2;\n+  Variable<PaintSolid>                          paintformat3;\n+  NoVariable<PaintLinearGradient<NoVariable>>   paintformat4;\n+  Variable<PaintLinearGradient<Variable>>       paintformat5;\n+  NoVariable<PaintRadialGradient<NoVariable>>   paintformat6;\n+  Variable<PaintRadialGradient<Variable>>       paintformat7;\n+  NoVariable<PaintSweepGradient<NoVariable>>    paintformat8;\n+  Variable<PaintSweepGradient<Variable>>        paintformat9;\n+  PaintGlyph                                    paintformat10;\n+  PaintColrGlyph                                paintformat11;\n+  PaintTransform<NoVariable>                    paintformat12;\n+  PaintTransform<Variable>                      paintformat13;\n+  NoVariable<PaintTranslate>                    paintformat14;\n+  Variable<PaintTranslate>                      paintformat15;\n+  NoVariable<PaintScale>                        paintformat16;\n+  Variable<PaintScale>                          paintformat17;\n+  NoVariable<PaintScaleAroundCenter>            paintformat18;\n+  Variable<PaintScaleAroundCenter>              paintformat19;\n+  NoVariable<PaintScaleUniform>                 paintformat20;\n+  Variable<PaintScaleUniform>                   paintformat21;\n+  NoVariable<PaintScaleUniformAroundCenter>     paintformat22;\n+  Variable<PaintScaleUniformAroundCenter>       paintformat23;\n+  NoVariable<PaintRotate>                       paintformat24;\n+  Variable<PaintRotate>                         paintformat25;\n+  NoVariable<PaintRotateAroundCenter>           paintformat26;\n+  Variable<PaintRotateAroundCenter>             paintformat27;\n+  NoVariable<PaintSkew>                         paintformat28;\n+  Variable<PaintSkew>                           paintformat29;\n+  NoVariable<PaintSkewAroundCenter>             paintformat30;\n+  Variable<PaintSkewAroundCenter>               paintformat31;\n+  PaintComposite                                paintformat32;\n+  } u;\n+  public:\n+  DEFINE_SIZE_MIN (2);\n+};\n+\n+struct BaseGlyphPaintRecord\n+{\n+  int cmp (hb_codepoint_t g) const\n+  { return g < glyphId ? -1 : g > glyphId ? 1 : 0; }\n+\n+  bool serialize (hb_serialize_context_t *s, const hb_map_t* glyph_map,\n+                  const void* src_base, hb_subset_context_t *c) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    auto *out = s->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+    if (!s->check_assign (out->glyphId, glyph_map->get (glyphId),\n+                          HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+      return_trace (false);\n+\n+    return_trace (out->paint.serialize_subset (c, paint, src_base));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) && paint.sanitize (c, base)));\n+  }\n+\n+  public:\n+  HBGlyphID16           glyphId;    \/* Glyph ID of reference glyph *\/\n+  Offset32To<Paint>     paint;      \/* Offset (from beginning of BaseGlyphPaintRecord array) to Paint,\n+                                     * Typically PaintColrLayers *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct BaseGlyphList : SortedArray32Of<BaseGlyphPaintRecord>\n+{\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (this);\n+    if (unlikely (!c->serializer->extend_min (out)))  return_trace (false);\n+    const hb_set_t* glyphset = &c->plan->_glyphset_colred;\n+\n+    for (const auto& _ : as_array ())\n+    {\n+      unsigned gid = _.glyphId;\n+      if (!glyphset->has (gid)) continue;\n+\n+      if (_.serialize (c->serializer, c->plan->glyph_map, this, c)) out->len++;\n+      else return_trace (false);\n+    }\n+\n+    return_trace (out->len != 0);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (SortedArray32Of<BaseGlyphPaintRecord>::sanitize (c, this));\n+  }\n+};\n+\n+struct LayerList : Array32OfOffset32To<Paint>\n+{\n+  const Paint& get_paint (unsigned i) const\n+  { return this+(*this)[i]; }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (this);\n+    if (unlikely (!c->serializer->extend_min (out)))  return_trace (false);\n+\n+    for (const auto& _ : + hb_enumerate (*this)\n+                         | hb_filter (c->plan->colrv1_layers, hb_first))\n+\n+    {\n+      auto *o = out->serialize_append (c->serializer);\n+      if (unlikely (!o) || !o->serialize_subset (c, _.second, this))\n+        return_trace (false);\n+    }\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (Array32OfOffset32To<Paint>::sanitize (c, this));\n+  }\n+};\n+\n+struct COLR\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_COLR;\n+\n+  bool has_v0_data () const { return numBaseGlyphs; }\n+  bool has_v1_data () const\n+  {\n+    if (version == 1)\n+      return (this+baseGlyphList).len > 0;\n+\n+    return false;\n+  }\n+\n+  unsigned int get_glyph_layers (hb_codepoint_t       glyph,\n+                                 unsigned int         start_offset,\n+                                 unsigned int        *count, \/* IN\/OUT.  May be NULL. *\/\n+                                 hb_ot_color_layer_t *layers \/* OUT.     May be NULL. *\/) const\n+  {\n+    const BaseGlyphRecord &record = (this+baseGlyphsZ).bsearch (numBaseGlyphs, glyph);\n+\n+    hb_array_t<const LayerRecord> all_layers = (this+layersZ).as_array (numLayers);\n+    hb_array_t<const LayerRecord> glyph_layers = all_layers.sub_array (record.firstLayerIdx,\n+                                                                       record.numLayers);\n+    if (count)\n+    {\n+      + glyph_layers.sub_array (start_offset, count)\n+      | hb_sink (hb_array (layers, *count))\n+      ;\n+    }\n+    return glyph_layers.length;\n+  }\n+\n+  struct accelerator_t\n+  {\n+    accelerator_t (hb_face_t *face)\n+    { colr = hb_sanitize_context_t ().reference_table<COLR> (face); }\n+    ~accelerator_t () { this->colr.destroy (); }\n+\n+    bool is_valid () { return colr.get_blob ()->length; }\n+\n+    void closure_glyphs (hb_codepoint_t glyph,\n+                         hb_set_t *related_ids \/* OUT *\/) const\n+    { colr->closure_glyphs (glyph, related_ids); }\n+\n+    void closure_V0palette_indices (const hb_set_t *glyphs,\n+                                    hb_set_t *palettes \/* OUT *\/) const\n+    { colr->closure_V0palette_indices (glyphs, palettes); }\n+\n+    void closure_forV1 (hb_set_t *glyphset,\n+                        hb_set_t *layer_indices,\n+                        hb_set_t *palette_indices) const\n+    { colr->closure_forV1 (glyphset, layer_indices, palette_indices); }\n+\n+    private:\n+    hb_blob_ptr_t<COLR> colr;\n+  };\n+\n+  void closure_glyphs (hb_codepoint_t glyph,\n+                       hb_set_t *related_ids \/* OUT *\/) const\n+  {\n+    const BaseGlyphRecord *record = get_base_glyph_record (glyph);\n+    if (!record) return;\n+\n+    auto glyph_layers = (this+layersZ).as_array (numLayers).sub_array (record->firstLayerIdx,\n+                                                                       record->numLayers);\n+    if (!glyph_layers.length) return;\n+    related_ids->add_array (&glyph_layers[0].glyphId, glyph_layers.length, LayerRecord::min_size);\n+  }\n+\n+  void closure_V0palette_indices (const hb_set_t *glyphs,\n+                                  hb_set_t *palettes \/* OUT *\/) const\n+  {\n+    if (!numBaseGlyphs || !numLayers) return;\n+    hb_array_t<const BaseGlyphRecord> baseGlyphs = (this+baseGlyphsZ).as_array (numBaseGlyphs);\n+    hb_array_t<const LayerRecord> all_layers = (this+layersZ).as_array (numLayers);\n+\n+    for (const BaseGlyphRecord record : baseGlyphs)\n+    {\n+      if (!glyphs->has (record.glyphId)) continue;\n+      hb_array_t<const LayerRecord> glyph_layers = all_layers.sub_array (record.firstLayerIdx,\n+                                                                   record.numLayers);\n+      for (const LayerRecord layer : glyph_layers)\n+        palettes->add (layer.colorIdx);\n+    }\n+  }\n+\n+  void closure_forV1 (hb_set_t *glyphset,\n+                      hb_set_t *layer_indices,\n+                      hb_set_t *palette_indices) const\n+  {\n+    if (version != 1) return;\n+    hb_set_t visited_glyphs;\n+\n+    hb_colrv1_closure_context_t c (this, &visited_glyphs, layer_indices, palette_indices);\n+    const BaseGlyphList &baseglyph_paintrecords = this+baseGlyphList;\n+\n+    for (const BaseGlyphPaintRecord &baseglyph_paintrecord: baseglyph_paintrecords.iter ())\n+    {\n+      unsigned gid = baseglyph_paintrecord.glyphId;\n+      if (!glyphset->has (gid)) continue;\n+\n+      const Paint &paint = &baseglyph_paintrecords+baseglyph_paintrecord.paint;\n+      paint.dispatch (&c);\n+    }\n+    hb_set_union (glyphset, &visited_glyphs);\n+  }\n+\n+  const LayerList& get_layerList () const\n+  { return (this+layerList); }\n+\n+  const BaseGlyphList& get_baseglyphList () const\n+  { return (this+baseGlyphList); }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  (this+baseGlyphsZ).sanitize (c, numBaseGlyphs) &&\n+                  (this+layersZ).sanitize (c, numLayers) &&\n+                  (version == 0 ||\n+                   (version == 1 &&\n+                    baseGlyphList.sanitize (c, this) &&\n+                    layerList.sanitize (c, this) &&\n+                    clipList.sanitize (c, this) &&\n+                    varIdxMap.sanitize (c, this) &&\n+                    varStore.sanitize (c, this))));\n+  }\n+\n+  template<typename BaseIterator, typename LayerIterator,\n+           hb_requires (hb_is_iterator (BaseIterator)),\n+           hb_requires (hb_is_iterator (LayerIterator))>\n+  bool serialize_V0 (hb_serialize_context_t *c,\n+                     unsigned version,\n+                     BaseIterator base_it,\n+                     LayerIterator layer_it)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (base_it.len () != layer_it.len ()))\n+      return_trace (false);\n+\n+    this->version = version;\n+    numLayers = 0;\n+    numBaseGlyphs = base_it.len ();\n+    if (numBaseGlyphs == 0)\n+    {\n+      baseGlyphsZ = 0;\n+      layersZ = 0;\n+      return_trace (true);\n+    }\n+\n+    c->push ();\n+    for (const hb_item_type<BaseIterator> _ : + base_it.iter ())\n+    {\n+      auto* record = c->embed (_);\n+      if (unlikely (!record)) return_trace (false);\n+      record->firstLayerIdx = numLayers;\n+      numLayers += record->numLayers;\n+    }\n+    c->add_link (baseGlyphsZ, c->pop_pack ());\n+\n+    c->push ();\n+    for (const hb_item_type<LayerIterator>& _ : + layer_it.iter ())\n+      _.as_array ().copy (c);\n+\n+    c->add_link (layersZ, c->pop_pack ());\n+\n+    return_trace (true);\n+  }\n+\n+  const BaseGlyphRecord* get_base_glyph_record (hb_codepoint_t gid) const\n+  {\n+    const BaseGlyphRecord* record = &(this+baseGlyphsZ).bsearch (numBaseGlyphs, (unsigned int) gid);\n+    if (record == &Null (BaseGlyphRecord) ||\n+        (record && (hb_codepoint_t) record->glyphId != gid))\n+      record = nullptr;\n+    return record;\n+  }\n+\n+  const BaseGlyphPaintRecord* get_base_glyph_paintrecord (hb_codepoint_t gid) const\n+  {\n+    const BaseGlyphPaintRecord* record = &(this+baseGlyphList).bsearch ((unsigned) gid);\n+    if ((record && (hb_codepoint_t) record->glyphId != gid))\n+      record = nullptr;\n+    return record;\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+\n+    const hb_map_t &reverse_glyph_map = *c->plan->reverse_glyph_map;\n+    const hb_set_t& glyphset = c->plan->_glyphset_colred;\n+\n+    auto base_it =\n+    + hb_range (c->plan->num_output_glyphs ())\n+    | hb_filter ([&](hb_codepoint_t new_gid)\n+                 {\n+                    hb_codepoint_t old_gid = reverse_glyph_map.get (new_gid);\n+                    if (glyphset.has (old_gid)) return true;\n+                    return false;\n+                 })\n+    | hb_map_retains_sorting ([&](hb_codepoint_t new_gid)\n+                              {\n+                                hb_codepoint_t old_gid = reverse_glyph_map.get (new_gid);\n+\n+                                const BaseGlyphRecord* old_record = get_base_glyph_record (old_gid);\n+                                if (unlikely (!old_record))\n+                                  return hb_pair_t<bool, BaseGlyphRecord> (false, Null (BaseGlyphRecord));\n+                                BaseGlyphRecord new_record = {};\n+                                new_record.glyphId = new_gid;\n+                                new_record.numLayers = old_record->numLayers;\n+                                return hb_pair_t<bool, BaseGlyphRecord> (true, new_record);\n+                              })\n+    | hb_filter (hb_first)\n+    | hb_map_retains_sorting (hb_second)\n+    ;\n+\n+    auto layer_it =\n+    + hb_range (c->plan->num_output_glyphs ())\n+    | hb_map (reverse_glyph_map)\n+    | hb_filter (glyphset)\n+    | hb_map_retains_sorting ([&](hb_codepoint_t old_gid)\n+                              {\n+                                const BaseGlyphRecord* old_record = get_base_glyph_record (old_gid);\n+                                hb_vector_t<LayerRecord> out_layers;\n+\n+                                if (unlikely (!old_record ||\n+                                              old_record->firstLayerIdx >= numLayers ||\n+                                              old_record->firstLayerIdx + old_record->numLayers > numLayers))\n+                                  return hb_pair_t<bool, hb_vector_t<LayerRecord>> (false, out_layers);\n+\n+                                auto layers = (this+layersZ).as_array (numLayers).sub_array (old_record->firstLayerIdx,\n+                                                                                             old_record->numLayers);\n+                                out_layers.resize (layers.length);\n+                                for (unsigned int i = 0; i < layers.length; i++) {\n+                                  out_layers[i] = layers[i];\n+                                  hb_codepoint_t new_gid = 0;\n+                                  if (unlikely (!c->plan->new_gid_for_old_gid (out_layers[i].glyphId, &new_gid)))\n+                                    return hb_pair_t<bool, hb_vector_t<LayerRecord>> (false, out_layers);\n+                                  out_layers[i].glyphId = new_gid;\n+                                  out_layers[i].colorIdx = c->plan->colr_palettes.get (layers[i].colorIdx);\n+                                }\n+\n+                                return hb_pair_t<bool, hb_vector_t<LayerRecord>> (true, out_layers);\n+                              })\n+    | hb_filter (hb_first)\n+    | hb_map_retains_sorting (hb_second)\n+    ;\n+\n+    if (version == 0 && (!base_it || !layer_it))\n+      return_trace (false);\n+\n+    COLR *colr_prime = c->serializer->start_embed<COLR> ();\n+    if (unlikely (!c->serializer->extend_min (colr_prime)))  return_trace (false);\n+\n+    if (version == 0)\n+    return_trace (colr_prime->serialize_V0 (c->serializer, version, base_it, layer_it));\n+\n+    auto snap = c->serializer->snapshot ();\n+    if (!c->serializer->allocate_size<void> (5 * HBUINT32::static_size)) return_trace (false);\n+    if (!colr_prime->baseGlyphList.serialize_subset (c, baseGlyphList, this))\n+    {\n+      if (c->serializer->in_error ()) return_trace (false);\n+      \/\/no more COLRv1 glyphs: downgrade to version 0\n+      c->serializer->revert (snap);\n+      return_trace (colr_prime->serialize_V0 (c->serializer, 0, base_it, layer_it));\n+    }\n+\n+    if (!colr_prime->serialize_V0 (c->serializer, version, base_it, layer_it)) return_trace (false);\n+\n+    colr_prime->layerList.serialize_subset (c, layerList, this);\n+    colr_prime->clipList.serialize_subset (c, clipList, this);\n+    colr_prime->varIdxMap.serialize_copy (c->serializer, varIdxMap, this);\n+    colr_prime->varStore.serialize_copy (c->serializer, varStore, this);\n+    return_trace (true);\n+  }\n+\n+  const Paint *get_base_glyph_paint (hb_codepoint_t glyph) const\n+  {\n+    const BaseGlyphList &baseglyph_paintrecords = this+baseGlyphList;\n+    const BaseGlyphPaintRecord* record = get_base_glyph_paintrecord (glyph);\n+    if (record)\n+    {\n+      const Paint &paint = &baseglyph_paintrecords+record->paint;\n+      return &paint;\n+    }\n+    else\n+      return nullptr;\n+  }\n+\n+  bool\n+  get_extents (hb_font_t *font, hb_codepoint_t glyph, hb_glyph_extents_t *extents) const\n+  {\n+    if (version != 1)\n+      return false;\n+\n+    VarStoreInstancer instancer (this+varStore,\n+                                 this+varIdxMap,\n+                                 hb_array (font->coords, font->num_coords));\n+\n+    if (get_clip (glyph, extents, instancer))\n+    {\n+      font->scale_glyph_extents (extents);\n+      return true;\n+    }\n+\n+    auto *extents_funcs = hb_paint_extents_get_funcs ();\n+    hb_paint_extents_context_t extents_data;\n+    bool ret = paint_glyph (font, glyph, extents_funcs, &extents_data, 0, HB_COLOR(0,0,0,0));\n+\n+    hb_extents_t e = extents_data.get_extents ();\n+    if (e.is_void ())\n+    {\n+      extents->x_bearing = 0;\n+      extents->y_bearing = 0;\n+      extents->width = 0;\n+      extents->height = 0;\n+    }\n+    else\n+    {\n+      extents->x_bearing = e.xmin;\n+      extents->y_bearing = e.ymax;\n+      extents->width = e.xmax - e.xmin;\n+      extents->height = e.ymin - e.ymax;\n+    }\n+\n+    return ret;\n+  }\n+\n+  bool\n+  has_paint_for_glyph (hb_codepoint_t glyph) const\n+  {\n+    if (version == 1)\n+    {\n+      const Paint *paint = get_base_glyph_paint (glyph);\n+\n+      return paint != nullptr;\n+    }\n+\n+    return false;\n+  }\n+\n+  bool get_clip (hb_codepoint_t glyph,\n+                 hb_glyph_extents_t *extents,\n+                 const VarStoreInstancer instancer) const\n+  {\n+    return (this+clipList).get_extents (glyph,\n+                                        extents,\n+                                        instancer);\n+  }\n+\n+  bool\n+  paint_glyph (hb_font_t *font, hb_codepoint_t glyph, hb_paint_funcs_t *funcs, void *data, unsigned int palette_index, hb_color_t foreground, bool clip = true) const\n+  {\n+    VarStoreInstancer instancer (this+varStore,\n+                                 this+varIdxMap,\n+                                 hb_array (font->coords, font->num_coords));\n+    hb_paint_context_t c (this, funcs, data, font, palette_index, foreground, instancer);\n+\n+    if (version == 1)\n+    {\n+      const Paint *paint = get_base_glyph_paint (glyph);\n+      if (paint)\n+      {\n+        \/\/ COLRv1 glyph\n+\n+        VarStoreInstancer instancer (this+varStore,\n+                                     this+varIdxMap,\n+                                     hb_array (font->coords, font->num_coords));\n+\n+        bool is_bounded = true;\n+        if (clip)\n+        {\n+          hb_glyph_extents_t extents;\n+          if (get_clip (glyph, &extents, instancer))\n+          {\n+            font->scale_glyph_extents (&extents);\n+            c.funcs->push_clip_rectangle (c.data,\n+                                          extents.x_bearing,\n+                                          extents.y_bearing + extents.height,\n+                                          extents.x_bearing + extents.width,\n+                                          extents.y_bearing);\n+          }\n+          else\n+          {\n+            auto *extents_funcs = hb_paint_extents_get_funcs ();\n+            hb_paint_extents_context_t extents_data;\n+\n+            paint_glyph (font, glyph,\n+                         extents_funcs, &extents_data,\n+                         palette_index, foreground,\n+                         false);\n+\n+            hb_extents_t extents = extents_data.get_extents ();\n+            is_bounded = extents_data.is_bounded ();\n+\n+            c.funcs->push_clip_rectangle (c.data,\n+                                          extents.xmin,\n+                                          extents.ymin,\n+                                          extents.xmax,\n+                                          extents.ymax);\n+          }\n+        }\n+\n+        c.funcs->push_root_transform (c.data, font);\n+\n+        if (is_bounded)\n+          c.recurse (*paint);\n+\n+        c.funcs->pop_transform (c.data);\n+\n+        if (clip)\n+          c.funcs->pop_clip (c.data);\n+\n+        return true;\n+      }\n+    }\n+\n+    const BaseGlyphRecord *record = get_base_glyph_record (glyph);\n+    if (record && ((hb_codepoint_t) record->glyphId == glyph))\n+    {\n+      \/\/ COLRv0 glyph\n+      for (const auto &r : (this+layersZ).as_array (numLayers)\n+                           .sub_array (record->firstLayerIdx, record->numLayers))\n+      {\n+        hb_bool_t is_foreground;\n+        hb_color_t color = c.get_color (r.colorIdx, 1., &is_foreground);\n+        c.funcs->push_clip_glyph (c.data, r.glyphId, c.font);\n+        c.funcs->color (c.data, is_foreground, color);\n+        c.funcs->pop_clip (c.data);\n+      }\n+\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  protected:\n+  HBUINT16      version;        \/* Table version number (starts at 0). *\/\n+  HBUINT16      numBaseGlyphs;  \/* Number of Base Glyph Records. *\/\n+  NNOffset32To<SortedUnsizedArrayOf<BaseGlyphRecord>>\n+                baseGlyphsZ;    \/* Offset to Base Glyph records. *\/\n+  NNOffset32To<UnsizedArrayOf<LayerRecord>>\n+                layersZ;        \/* Offset to Layer Records. *\/\n+  HBUINT16      numLayers;      \/* Number of Layer Records. *\/\n+  \/\/ Version-1 additions\n+  Offset32To<BaseGlyphList>             baseGlyphList;\n+  Offset32To<LayerList>                 layerList;\n+  Offset32To<ClipList>                  clipList;   \/\/ Offset to ClipList table (may be NULL)\n+  Offset32To<DeltaSetIndexMap>          varIdxMap;  \/\/ Offset to DeltaSetIndexMap table (may be NULL)\n+  Offset32To<VariationStore>            varStore;\n+  public:\n+  DEFINE_SIZE_MIN (14);\n+};\n+\n+struct COLR_accelerator_t : COLR::accelerator_t {\n+  COLR_accelerator_t (hb_face_t *face) : COLR::accelerator_t (face) {}\n+};\n+\n+void\n+hb_paint_context_t::recurse (const Paint &paint)\n+{\n+  if (unlikely (depth_left <= 0 || edge_count <= 0)) return;\n+  depth_left--;\n+  edge_count--;\n+  paint.dispatch (this);\n+  depth_left++;\n+}\n+\n+void PaintColrLayers::paint_glyph (hb_paint_context_t *c) const\n+{\n+  const LayerList &paint_offset_lists = c->get_colr_table ()->get_layerList ();\n+  for (unsigned i = firstLayerIndex; i < firstLayerIndex + numLayers; i++)\n+  {\n+    const Paint &paint = paint_offset_lists.get_paint (i);\n+    c->funcs->push_group (c->data);\n+    c->recurse (paint);\n+    c->funcs->pop_group (c->data, HB_PAINT_COMPOSITE_MODE_SRC_OVER);\n+  }\n+}\n+\n+void PaintColrGlyph::paint_glyph (hb_paint_context_t *c) const\n+{\n+  const COLR *colr_table = c->get_colr_table ();\n+  const Paint *paint = colr_table->get_base_glyph_paint (gid);\n+\n+  hb_glyph_extents_t extents = {0};\n+  bool has_clip_box = colr_table->get_clip (gid, &extents, c->instancer);\n+\n+  if (has_clip_box)\n+    c->funcs->push_clip_rectangle (c->data,\n+                                   extents.x_bearing,\n+                                   extents.y_bearing + extents.height,\n+                                   extents.x_bearing + extents.width,\n+                                   extents.y_bearing);\n+\n+  if (paint)\n+    c->recurse (*paint);\n+\n+  if (has_clip_box)\n+    c->funcs->pop_clip (c->data);\n+}\n+\n+} \/* namespace OT *\/\n+\n+#endif \/* OT_COLOR_COLR_COLR_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Color\/COLR\/COLR.hh","additions":2203,"deletions":0,"binary":false,"changes":2203,"status":"added"},{"patch":"@@ -27,2 +27,2 @@\n-#ifndef HB_OT_COLR_COLRV1_CLOSURE_HH\n-#define HB_OT_COLR_COLRV1_CLOSURE_HH\n+#ifndef OT_COLOR_COLR_COLRV1_CLOSURE_HH\n+#define OT_COLOR_COLR_COLRV1_CLOSURE_HH\n@@ -30,3 +30,2 @@\n-#include \"hb-open-type.hh\"\n-#include \"hb-ot-layout-common.hh\"\n-#include \"hb-ot-color-colr-table.hh\"\n+#include \"..\/..\/..\/hb-open-type.hh\"\n+#include \"COLR.hh\"\n@@ -108,1 +107,1 @@\n-#endif \/* HB_OT_COLR_COLRV1_CLOSURE_HH *\/\n+#endif \/* OT_COLOR_COLR_COLRV1_CLOSURE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Color\/COLR\/colrv1-closure.hh","additions":5,"deletions":6,"binary":false,"changes":11,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-colrv1-closure.hh","status":"renamed"},{"patch":"@@ -28,2 +28,2 @@\n-#ifndef HB_OT_COLOR_CPAL_TABLE_HH\n-#define HB_OT_COLOR_CPAL_TABLE_HH\n+#ifndef OT_COLOR_CPAL_CPAL_HH\n+#define OT_COLOR_CPAL_CPAL_HH\n@@ -31,3 +31,3 @@\n-#include \"hb-open-type.hh\"\n-#include \"hb-ot-color.h\"\n-#include \"hb-ot-name.h\"\n+#include \"..\/..\/..\/hb-open-type.hh\"\n+#include \"..\/..\/..\/hb-ot-color.h\"\n+#include \"..\/..\/..\/hb-ot-name.h\"\n@@ -242,1 +242,1 @@\n-    const hb_map_t *color_index_map = c->plan->colr_palettes;\n+    const hb_map_t *color_index_map = &c->plan->colr_palettes;\n@@ -322,1 +322,1 @@\n-#endif \/* HB_OT_COLOR_CPAL_TABLE_HH *\/\n+#endif \/* OT_COLOR_CPAL_CPAL_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Color\/CPAL\/CPAL.hh","additions":7,"deletions":7,"binary":false,"changes":14,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-cpal-table.hh","status":"renamed"},{"patch":"@@ -0,0 +1,452 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi\n+ * Copyright © 2020  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Calder Kitagawa\n+ *\/\n+\n+#ifndef OT_COLOR_SBIX_SBIX_HH\n+#define OT_COLOR_SBIX_SBIX_HH\n+\n+#include \"..\/..\/..\/hb-open-type.hh\"\n+#include \"..\/..\/..\/hb-paint.hh\"\n+\n+\/*\n+ * sbix -- Standard Bitmap Graphics\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/sbix\n+ * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6sbix.html\n+ *\/\n+#define HB_OT_TAG_sbix HB_TAG('s','b','i','x')\n+\n+\n+namespace OT {\n+\n+\n+struct SBIXGlyph\n+{\n+  SBIXGlyph* copy (hb_serialize_context_t *c, unsigned int data_length) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    SBIXGlyph* new_glyph = c->start_embed<SBIXGlyph> ();\n+    if (unlikely (!new_glyph)) return_trace (nullptr);\n+    if (unlikely (!c->extend_min (new_glyph))) return_trace (nullptr);\n+\n+    new_glyph->xOffset = xOffset;\n+    new_glyph->yOffset = yOffset;\n+    new_glyph->graphicType = graphicType;\n+    data.copy (c, data_length);\n+    return_trace (new_glyph);\n+  }\n+\n+  HBINT16       xOffset;        \/* The horizontal (x-axis) offset from the left\n+                                 * edge of the graphic to the glyph’s origin.\n+                                 * That is, the x-coordinate of the point on the\n+                                 * baseline at the left edge of the glyph. *\/\n+  HBINT16       yOffset;        \/* The vertical (y-axis) offset from the bottom\n+                                 * edge of the graphic to the glyph’s origin.\n+                                 * That is, the y-coordinate of the point on the\n+                                 * baseline at the left edge of the glyph. *\/\n+  Tag           graphicType;    \/* Indicates the format of the embedded graphic\n+                                 * data: one of 'jpg ', 'png ' or 'tiff', or the\n+                                 * special format 'dupe'. *\/\n+  UnsizedArrayOf<HBUINT8>\n+                data;           \/* The actual embedded graphic data. The total\n+                                 * length is inferred from sequential entries in\n+                                 * the glyphDataOffsets array and the fixed size\n+                                 * (8 bytes) of the preceding fields. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (8, data);\n+};\n+\n+struct SBIXStrike\n+{\n+  static unsigned int get_size (unsigned num_glyphs)\n+  { return min_size + num_glyphs * HBUINT32::static_size; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  imageOffsetsZ.sanitize_shallow (c, c->get_num_glyphs () + 1));\n+  }\n+\n+  hb_blob_t *get_glyph_blob (unsigned int  glyph_id,\n+                             hb_blob_t    *sbix_blob,\n+                             hb_tag_t      file_type,\n+                             int          *x_offset,\n+                             int          *y_offset,\n+                             unsigned int  num_glyphs,\n+                             unsigned int *strike_ppem) const\n+  {\n+    if (unlikely (!ppem)) return hb_blob_get_empty (); \/* To get Null() object out of the way. *\/\n+\n+    unsigned int retry_count = 8;\n+    unsigned int sbix_len = sbix_blob->length;\n+    unsigned int strike_offset = (const char *) this - (const char *) sbix_blob->data;\n+    assert (strike_offset < sbix_len);\n+\n+  retry:\n+    if (unlikely (glyph_id >= num_glyphs ||\n+                  imageOffsetsZ[glyph_id + 1] <= imageOffsetsZ[glyph_id] ||\n+                  imageOffsetsZ[glyph_id + 1] - imageOffsetsZ[glyph_id] <= SBIXGlyph::min_size ||\n+                  (unsigned int) imageOffsetsZ[glyph_id + 1] > sbix_len - strike_offset))\n+      return hb_blob_get_empty ();\n+\n+    unsigned int glyph_offset = strike_offset + (unsigned int) imageOffsetsZ[glyph_id] + SBIXGlyph::min_size;\n+    unsigned int glyph_length = imageOffsetsZ[glyph_id + 1] - imageOffsetsZ[glyph_id] - SBIXGlyph::min_size;\n+\n+    const SBIXGlyph *glyph = &(this+imageOffsetsZ[glyph_id]);\n+\n+    if (glyph->graphicType == HB_TAG ('d','u','p','e'))\n+    {\n+      if (glyph_length >= 2)\n+      {\n+        glyph_id = *((HBUINT16 *) &glyph->data);\n+        if (retry_count--)\n+          goto retry;\n+      }\n+      return hb_blob_get_empty ();\n+    }\n+\n+    if (unlikely (file_type != glyph->graphicType))\n+      return hb_blob_get_empty ();\n+\n+    if (strike_ppem) *strike_ppem = ppem;\n+    if (x_offset) *x_offset = glyph->xOffset;\n+    if (y_offset) *y_offset = glyph->yOffset;\n+    return hb_blob_create_sub_blob (sbix_blob, glyph_offset, glyph_length);\n+  }\n+\n+  bool subset (hb_subset_context_t *c, unsigned int available_len) const\n+  {\n+    TRACE_SUBSET (this);\n+    unsigned int num_output_glyphs = c->plan->num_output_glyphs ();\n+\n+    auto* out = c->serializer->start_embed<SBIXStrike> ();\n+    if (unlikely (!out)) return_trace (false);\n+    auto snap = c->serializer->snapshot ();\n+    if (unlikely (!c->serializer->extend (out, num_output_glyphs + 1))) return_trace (false);\n+    out->ppem = ppem;\n+    out->resolution = resolution;\n+    HBUINT32 head;\n+    head = get_size (num_output_glyphs + 1);\n+\n+    bool has_glyphs = false;\n+    for (unsigned new_gid = 0; new_gid < num_output_glyphs; new_gid++)\n+    {\n+      hb_codepoint_t old_gid;\n+      if (!c->plan->old_gid_for_new_gid (new_gid, &old_gid) ||\n+          unlikely (imageOffsetsZ[old_gid].is_null () ||\n+                    imageOffsetsZ[old_gid + 1].is_null () ||\n+                    imageOffsetsZ[old_gid + 1] <= imageOffsetsZ[old_gid] ||\n+                    imageOffsetsZ[old_gid + 1] - imageOffsetsZ[old_gid] <= SBIXGlyph::min_size) ||\n+                    (unsigned int) imageOffsetsZ[old_gid + 1] > available_len)\n+      {\n+        out->imageOffsetsZ[new_gid] = head;\n+        continue;\n+      }\n+      has_glyphs = true;\n+      unsigned int delta = imageOffsetsZ[old_gid + 1] - imageOffsetsZ[old_gid];\n+      unsigned int glyph_data_length = delta - SBIXGlyph::min_size;\n+      if (!(this+imageOffsetsZ[old_gid]).copy (c->serializer, glyph_data_length))\n+        return_trace (false);\n+      out->imageOffsetsZ[new_gid] = head;\n+      head += delta;\n+    }\n+    if (has_glyphs)\n+      out->imageOffsetsZ[num_output_glyphs] = head;\n+    else\n+      c->serializer->revert (snap);\n+    return_trace (has_glyphs);\n+  }\n+\n+  public:\n+  HBUINT16      ppem;           \/* The PPEM size for which this strike was designed. *\/\n+  HBUINT16      resolution;     \/* The device pixel density (in PPI) for which this\n+                                 * strike was designed. (E.g., 96 PPI, 192 PPI.) *\/\n+  protected:\n+  UnsizedArrayOf<Offset32To<SBIXGlyph>>\n+                imageOffsetsZ;  \/* Offset from the beginning of the strike data header\n+                                 * to bitmap data for an individual glyph ID. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, imageOffsetsZ);\n+};\n+\n+struct sbix\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_sbix;\n+\n+  bool has_data () const { return version; }\n+\n+  const SBIXStrike &get_strike (unsigned int i) const { return this+strikes[i]; }\n+\n+  struct accelerator_t\n+  {\n+    accelerator_t (hb_face_t *face)\n+    {\n+      table = hb_sanitize_context_t ().reference_table<sbix> (face);\n+      num_glyphs = face->get_num_glyphs ();\n+    }\n+    ~accelerator_t () { table.destroy (); }\n+\n+    bool has_data () const { return table->has_data (); }\n+\n+    bool get_extents (hb_font_t          *font,\n+                      hb_codepoint_t      glyph,\n+                      hb_glyph_extents_t *extents,\n+                      bool                scale = true) const\n+    {\n+      \/* We only support PNG right now, and following function checks type. *\/\n+      return get_png_extents (font, glyph, extents, scale);\n+    }\n+\n+    hb_blob_t *reference_png (hb_font_t      *font,\n+                              hb_codepoint_t  glyph_id,\n+                              int            *x_offset,\n+                              int            *y_offset,\n+                              unsigned int   *available_ppem) const\n+    {\n+      return choose_strike (font).get_glyph_blob (glyph_id, table.get_blob (),\n+                                                  HB_TAG ('p','n','g',' '),\n+                                                  x_offset, y_offset,\n+                                                  num_glyphs, available_ppem);\n+    }\n+\n+    bool paint_glyph (hb_font_t *font, hb_codepoint_t glyph, hb_paint_funcs_t *funcs, void *data) const\n+    {\n+      if (!has_data ())\n+        return false;\n+\n+      int x_offset = 0, y_offset = 0;\n+      unsigned int strike_ppem = 0;\n+      hb_blob_t *blob = reference_png (font, glyph, &x_offset, &y_offset, &strike_ppem);\n+      hb_glyph_extents_t extents;\n+      hb_glyph_extents_t pixel_extents;\n+\n+      if (blob == hb_blob_get_empty ())\n+        return false;\n+\n+      if (!hb_font_get_glyph_extents (font, glyph, &extents))\n+        return false;\n+\n+      if (unlikely (!get_extents (font, glyph, &pixel_extents, false)))\n+        return false;\n+\n+      bool ret = funcs->image (data,\n+                               blob,\n+                               pixel_extents.width, -pixel_extents.height,\n+                               HB_PAINT_IMAGE_FORMAT_PNG,\n+                               font->slant_xy,\n+                               &extents);\n+\n+      hb_blob_destroy (blob);\n+      return ret;\n+    }\n+\n+    private:\n+\n+    const SBIXStrike &choose_strike (hb_font_t *font) const\n+    {\n+      unsigned count = table->strikes.len;\n+      if (unlikely (!count))\n+        return Null (SBIXStrike);\n+\n+      unsigned int requested_ppem = hb_max (font->x_ppem, font->y_ppem);\n+      if (!requested_ppem)\n+        requested_ppem = 1<<30; \/* Choose largest strike. *\/\n+      \/* TODO Add DPI sensitivity as well? *\/\n+      unsigned int best_i = 0;\n+      unsigned int best_ppem = table->get_strike (0).ppem;\n+\n+      for (unsigned int i = 1; i < count; i++)\n+      {\n+        unsigned int ppem = (table->get_strike (i)).ppem;\n+        if ((requested_ppem <= ppem && ppem < best_ppem) ||\n+            (requested_ppem > best_ppem && ppem > best_ppem))\n+        {\n+          best_i = i;\n+          best_ppem = ppem;\n+        }\n+      }\n+\n+      return table->get_strike (best_i);\n+    }\n+\n+    struct PNGHeader\n+    {\n+      HBUINT8   signature[8];\n+      struct\n+      {\n+        struct\n+        {\n+          HBUINT32      length;\n+          Tag           type;\n+        }               header;\n+        HBUINT32        width;\n+        HBUINT32        height;\n+        HBUINT8         bitDepth;\n+        HBUINT8         colorType;\n+        HBUINT8         compressionMethod;\n+        HBUINT8         filterMethod;\n+        HBUINT8         interlaceMethod;\n+      } IHDR;\n+\n+      public:\n+      DEFINE_SIZE_STATIC (29);\n+    };\n+\n+    bool get_png_extents (hb_font_t          *font,\n+                          hb_codepoint_t      glyph,\n+                          hb_glyph_extents_t *extents,\n+                          bool                scale = true) const\n+    {\n+      \/* Following code is safe to call even without data.\n+       * But faster to short-circuit. *\/\n+      if (!has_data ())\n+        return false;\n+\n+      int x_offset = 0, y_offset = 0;\n+      unsigned int strike_ppem = 0;\n+      hb_blob_t *blob = reference_png (font, glyph, &x_offset, &y_offset, &strike_ppem);\n+\n+      const PNGHeader &png = *blob->as<PNGHeader>();\n+\n+      if (png.IHDR.height >= 65536 || png.IHDR.width >= 65536)\n+      {\n+        hb_blob_destroy (blob);\n+        return false;\n+      }\n+\n+      extents->x_bearing = x_offset;\n+      extents->y_bearing = png.IHDR.height + y_offset;\n+      extents->width     = png.IHDR.width;\n+      extents->height    = -1 * png.IHDR.height;\n+\n+      \/* Convert to font units. *\/\n+      if (strike_ppem && scale)\n+      {\n+        float scale = font->face->get_upem () \/ (float) strike_ppem;\n+        extents->x_bearing = roundf (extents->x_bearing * scale);\n+        extents->y_bearing = roundf (extents->y_bearing * scale);\n+        extents->width = roundf (extents->width * scale);\n+        extents->height = roundf (extents->height * scale);\n+      }\n+\n+      if (scale)\n+        font->scale_glyph_extents (extents);\n+\n+      hb_blob_destroy (blob);\n+\n+      return strike_ppem;\n+    }\n+\n+    private:\n+    hb_blob_ptr_t<sbix> table;\n+\n+    unsigned int num_glyphs;\n+  };\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          version >= 1 &&\n+                          strikes.sanitize (c, this)));\n+  }\n+\n+  bool\n+  add_strike (hb_subset_context_t *c, unsigned i) const\n+  {\n+    if (strikes[i].is_null () || c->source_blob->length < (unsigned) strikes[i])\n+      return false;\n+\n+    return (this+strikes[i]).subset (c, c->source_blob->length - (unsigned) strikes[i]);\n+  }\n+\n+  bool serialize_strike_offsets (hb_subset_context_t *c) const\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    auto *out = c->serializer->start_embed<Array32OfOffset32To<SBIXStrike>> ();\n+    if (unlikely (!out)) return_trace (false);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+\n+    hb_vector_t<Offset32To<SBIXStrike>*> new_strikes;\n+    hb_vector_t<hb_serialize_context_t::objidx_t> objidxs;\n+    for (int i = strikes.len - 1; i >= 0; --i)\n+    {\n+      auto* o = out->serialize_append (c->serializer);\n+      if (unlikely (!o)) return_trace (false);\n+      *o = 0;\n+      auto snap = c->serializer->snapshot ();\n+      c->serializer->push ();\n+      bool ret = add_strike (c, i);\n+      if (!ret)\n+      {\n+        c->serializer->pop_discard ();\n+        out->pop ();\n+        c->serializer->revert (snap);\n+      }\n+      else\n+      {\n+        objidxs.push (c->serializer->pop_pack ());\n+        new_strikes.push (o);\n+      }\n+    }\n+    for (unsigned int i = 0; i < new_strikes.length; ++i)\n+      c->serializer->add_link (*new_strikes[i], objidxs[new_strikes.length - 1 - i]);\n+\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_context_t* c) const\n+  {\n+    TRACE_SUBSET (this);\n+\n+    sbix *sbix_prime = c->serializer->start_embed<sbix> ();\n+    if (unlikely (!sbix_prime)) return_trace (false);\n+    if (unlikely (!c->serializer->embed (this->version))) return_trace (false);\n+    if (unlikely (!c->serializer->embed (this->flags))) return_trace (false);\n+\n+    return_trace (serialize_strike_offsets (c));\n+  }\n+\n+  protected:\n+  HBUINT16      version;        \/* Table version number — set to 1 *\/\n+  HBUINT16      flags;          \/* Bit 0: Set to 1. Bit 1: Draw outlines.\n+                                 * Bits 2 to 15: reserved (set to 0). *\/\n+  Array32OfOffset32To<SBIXStrike>\n+                strikes;        \/* Offsets from the beginning of the 'sbix'\n+                                 * table to data for each individual bitmap strike. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (8, strikes);\n+};\n+\n+struct sbix_accelerator_t : sbix::accelerator_t {\n+  sbix_accelerator_t (hb_face_t *face) : sbix::accelerator_t (face) {}\n+};\n+\n+\n+} \/* namespace OT *\/\n+\n+#endif \/* OT_COLOR_SBIX_SBIX_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Color\/sbix\/sbix.hh","additions":452,"deletions":0,"binary":false,"changes":452,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef OT_COLOR_SVG_SVG_HH\n+#define OT_COLOR_SVG_SVG_HH\n+\n+#include \"..\/..\/..\/hb-open-type.hh\"\n+#include \"..\/..\/..\/hb-blob.hh\"\n+#include \"..\/..\/..\/hb-paint.hh\"\n+\n+\/*\n+ * SVG -- SVG (Scalable Vector Graphics)\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/svg\n+ *\/\n+\n+#define HB_OT_TAG_SVG HB_TAG('S','V','G',' ')\n+\n+\n+namespace OT {\n+\n+\n+struct SVGDocumentIndexEntry\n+{\n+  int cmp (hb_codepoint_t g) const\n+  { return g < startGlyphID ? -1 : g > endGlyphID ? 1 : 0; }\n+\n+  hb_blob_t *reference_blob (hb_blob_t *svg_blob, unsigned int index_offset) const\n+  {\n+    return hb_blob_create_sub_blob (svg_blob,\n+                                    index_offset + (unsigned int) svgDoc,\n+                                    svgDocLength);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  svgDoc.sanitize (c, base, svgDocLength));\n+  }\n+\n+  protected:\n+  HBUINT16      startGlyphID;   \/* The first glyph ID in the range described by\n+                                 * this index entry. *\/\n+  HBUINT16      endGlyphID;     \/* The last glyph ID in the range described by\n+                                 * this index entry. Must be >= startGlyphID. *\/\n+  NNOffset32To<UnsizedArrayOf<HBUINT8>>\n+                svgDoc;         \/* Offset from the beginning of the SVG Document Index\n+                                 * to an SVG document. Must be non-zero. *\/\n+  HBUINT32      svgDocLength;   \/* Length of the SVG document.\n+                                 * Must be non-zero. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+};\n+\n+struct SVG\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_SVG;\n+\n+  bool has_data () const { return svgDocEntries; }\n+\n+  struct accelerator_t\n+  {\n+    accelerator_t (hb_face_t *face)\n+    { table = hb_sanitize_context_t ().reference_table<SVG> (face); }\n+    ~accelerator_t () { table.destroy (); }\n+\n+    hb_blob_t *reference_blob_for_glyph (hb_codepoint_t glyph_id) const\n+    {\n+      return table->get_glyph_entry (glyph_id).reference_blob (table.get_blob (),\n+                                                               table->svgDocEntries);\n+    }\n+\n+    bool has_data () const { return table->has_data (); }\n+\n+    bool paint_glyph (hb_font_t *font HB_UNUSED, hb_codepoint_t glyph, hb_paint_funcs_t *funcs, void *data) const\n+    {\n+      if (!has_data ())\n+        return false;\n+\n+      hb_blob_t *blob = reference_blob_for_glyph (glyph);\n+\n+      if (blob == hb_blob_get_empty ())\n+        return false;\n+\n+      funcs->image (data,\n+                    blob,\n+                    0, 0,\n+                    HB_PAINT_IMAGE_FORMAT_SVG,\n+                    font->slant_xy,\n+                    nullptr);\n+\n+      hb_blob_destroy (blob);\n+      return true;\n+    }\n+\n+    private:\n+    hb_blob_ptr_t<SVG> table;\n+    public:\n+    DEFINE_SIZE_STATIC (sizeof (hb_blob_ptr_t<SVG>));\n+  };\n+\n+  const SVGDocumentIndexEntry &get_glyph_entry (hb_codepoint_t glyph_id) const\n+  { return (this+svgDocEntries).bsearch (glyph_id); }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          (this+svgDocEntries).sanitize_shallow (c)));\n+  }\n+\n+  protected:\n+  HBUINT16      version;        \/* Table version (starting at 0). *\/\n+  Offset32To<SortedArray16Of<SVGDocumentIndexEntry>>\n+                svgDocEntries;  \/* Offset (relative to the start of the SVG table) to the\n+                                 * SVG Documents Index. Must be non-zero. *\/\n+                                \/* Array of SVG Document Index Entries. *\/\n+  HBUINT32      reserved;       \/* Set to 0. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (10);\n+};\n+\n+struct SVG_accelerator_t : SVG::accelerator_t {\n+  SVG_accelerator_t (hb_face_t *face) : SVG::accelerator_t (face) {}\n+};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* OT_COLOR_SVG_SVG_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Color\/svg\/svg.hh","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,337 @@\n+\/*\n+ * Copyright © 2007,2008,2009  Red Hat, Inc.\n+ * Copyright © 2010,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod, Garret Rieger\n+ *\/\n+\n+#ifndef OT_LAYOUT_COMMON_COVERAGE_HH\n+#define OT_LAYOUT_COMMON_COVERAGE_HH\n+\n+#include \"..\/types.hh\"\n+#include \"CoverageFormat1.hh\"\n+#include \"CoverageFormat2.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace Common {\n+\n+template<typename Iterator>\n+static inline void Coverage_serialize (hb_serialize_context_t *c,\n+                                       Iterator it);\n+\n+struct Coverage\n+{\n+\n+  protected:\n+  union {\n+  HBUINT16                      format;         \/* Format identifier *\/\n+  CoverageFormat1_3<SmallTypes> format1;\n+  CoverageFormat2_4<SmallTypes> format2;\n+#ifndef HB_NO_BEYOND_64K\n+  CoverageFormat1_3<MediumTypes>format3;\n+  CoverageFormat2_4<MediumTypes>format4;\n+#endif\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (2, format);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.format.sanitize (c)) return_trace (false);\n+    switch (u.format)\n+    {\n+    case 1: return_trace (u.format1.sanitize (c));\n+    case 2: return_trace (u.format2.sanitize (c));\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return_trace (u.format3.sanitize (c));\n+    case 4: return_trace (u.format4.sanitize (c));\n+#endif\n+    default:return_trace (true);\n+    }\n+  }\n+\n+  \/* Has interface. *\/\n+  unsigned operator [] (hb_codepoint_t k) const { return get (k); }\n+  bool has (hb_codepoint_t k) const { return (*this)[k] != NOT_COVERED; }\n+  \/* Predicate. *\/\n+  bool operator () (hb_codepoint_t k) const { return has (k); }\n+\n+  unsigned int get (hb_codepoint_t k) const { return get_coverage (k); }\n+  unsigned int get_coverage (hb_codepoint_t glyph_id) const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.get_coverage (glyph_id);\n+    case 2: return u.format2.get_coverage (glyph_id);\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return u.format3.get_coverage (glyph_id);\n+    case 4: return u.format4.get_coverage (glyph_id);\n+#endif\n+    default:return NOT_COVERED;\n+    }\n+  }\n+\n+  unsigned get_population () const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.get_population ();\n+    case 2: return u.format2.get_population ();\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return u.format3.get_population ();\n+    case 4: return u.format4.get_population ();\n+#endif\n+    default:return NOT_COVERED;\n+    }\n+  }\n+\n+  template <typename Iterator,\n+      hb_requires (hb_is_sorted_source_of (Iterator, hb_codepoint_t))>\n+  bool serialize (hb_serialize_context_t *c, Iterator glyphs)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n+\n+    unsigned count = 0;\n+    unsigned num_ranges = 0;\n+    hb_codepoint_t last = (hb_codepoint_t) -2;\n+    for (auto g: glyphs)\n+    {\n+      if (last + 1 != g)\n+        num_ranges++;\n+      last = g;\n+      count++;\n+    }\n+    u.format = count <= num_ranges * 3 ? 1 : 2;\n+\n+#ifndef HB_NO_BEYOND_64K\n+    if (count && last > 0xFFFFu)\n+      u.format += 2;\n+#endif\n+\n+    switch (u.format)\n+    {\n+    case 1: return_trace (u.format1.serialize (c, glyphs));\n+    case 2: return_trace (u.format2.serialize (c, glyphs));\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return_trace (u.format3.serialize (c, glyphs));\n+    case 4: return_trace (u.format4.serialize (c, glyphs));\n+#endif\n+    default:return_trace (false);\n+    }\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto it =\n+    + iter ()\n+    | hb_take (c->plan->source->get_num_glyphs ())\n+    | hb_filter (c->plan->glyph_map_gsub)\n+    | hb_map_retains_sorting (c->plan->glyph_map_gsub)\n+    ;\n+\n+    \/\/ Cache the iterator result as it will be iterated multiple times\n+    \/\/ by the serialize code below.\n+    hb_sorted_vector_t<hb_codepoint_t> glyphs (it);\n+    Coverage_serialize (c->serializer, glyphs.iter ());\n+    return_trace (bool (glyphs));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    switch (u.format)\n+    {\n+    case 1: return u.format1.intersects (glyphs);\n+    case 2: return u.format2.intersects (glyphs);\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return u.format3.intersects (glyphs);\n+    case 4: return u.format4.intersects (glyphs);\n+#endif\n+    default:return false;\n+    }\n+  }\n+  bool intersects_coverage (const hb_set_t *glyphs, unsigned int index) const\n+  {\n+    switch (u.format)\n+    {\n+    case 1: return u.format1.intersects_coverage (glyphs, index);\n+    case 2: return u.format2.intersects_coverage (glyphs, index);\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return u.format3.intersects_coverage (glyphs, index);\n+    case 4: return u.format4.intersects_coverage (glyphs, index);\n+#endif\n+    default:return false;\n+    }\n+  }\n+\n+  \/* Might return false if array looks unsorted.\n+   * Used for faster rejection of corrupt data. *\/\n+  template <typename set_t>\n+  bool collect_coverage (set_t *glyphs) const\n+  {\n+    switch (u.format)\n+    {\n+    case 1: return u.format1.collect_coverage (glyphs);\n+    case 2: return u.format2.collect_coverage (glyphs);\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return u.format3.collect_coverage (glyphs);\n+    case 4: return u.format4.collect_coverage (glyphs);\n+#endif\n+    default:return false;\n+    }\n+  }\n+\n+  template <typename IterableOut,\n+            hb_requires (hb_is_sink_of (IterableOut, hb_codepoint_t))>\n+  void intersect_set (const hb_set_t &glyphs, IterableOut&& intersect_glyphs) const\n+  {\n+    switch (u.format)\n+    {\n+    case 1: return u.format1.intersect_set (glyphs, intersect_glyphs);\n+    case 2: return u.format2.intersect_set (glyphs, intersect_glyphs);\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return u.format3.intersect_set (glyphs, intersect_glyphs);\n+    case 4: return u.format4.intersect_set (glyphs, intersect_glyphs);\n+#endif\n+    default:return ;\n+    }\n+  }\n+\n+  struct iter_t : hb_iter_with_fallback_t<iter_t, hb_codepoint_t>\n+  {\n+    static constexpr bool is_sorted_iterator = true;\n+    iter_t (const Coverage &c_ = Null (Coverage))\n+    {\n+      hb_memset (this, 0, sizeof (*this));\n+      format = c_.u.format;\n+      switch (format)\n+      {\n+      case 1: u.format1.init (c_.u.format1); return;\n+      case 2: u.format2.init (c_.u.format2); return;\n+#ifndef HB_NO_BEYOND_64K\n+      case 3: u.format3.init (c_.u.format3); return;\n+      case 4: u.format4.init (c_.u.format4); return;\n+#endif\n+      default:                               return;\n+      }\n+    }\n+    bool __more__ () const\n+    {\n+      switch (format)\n+      {\n+      case 1: return u.format1.__more__ ();\n+      case 2: return u.format2.__more__ ();\n+#ifndef HB_NO_BEYOND_64K\n+      case 3: return u.format3.__more__ ();\n+      case 4: return u.format4.__more__ ();\n+#endif\n+      default:return false;\n+      }\n+    }\n+    void __next__ ()\n+    {\n+      switch (format)\n+      {\n+      case 1: u.format1.__next__ (); break;\n+      case 2: u.format2.__next__ (); break;\n+#ifndef HB_NO_BEYOND_64K\n+      case 3: u.format3.__next__ (); break;\n+      case 4: u.format4.__next__ (); break;\n+#endif\n+      default:                   break;\n+      }\n+    }\n+    typedef hb_codepoint_t __item_t__;\n+    __item_t__ __item__ () const { return get_glyph (); }\n+\n+    hb_codepoint_t get_glyph () const\n+    {\n+      switch (format)\n+      {\n+      case 1: return u.format1.get_glyph ();\n+      case 2: return u.format2.get_glyph ();\n+#ifndef HB_NO_BEYOND_64K\n+      case 3: return u.format3.get_glyph ();\n+      case 4: return u.format4.get_glyph ();\n+#endif\n+      default:return 0;\n+      }\n+    }\n+    bool operator != (const iter_t& o) const\n+    {\n+      if (unlikely (format != o.format)) return true;\n+      switch (format)\n+      {\n+      case 1: return u.format1 != o.u.format1;\n+      case 2: return u.format2 != o.u.format2;\n+#ifndef HB_NO_BEYOND_64K\n+      case 3: return u.format3 != o.u.format3;\n+      case 4: return u.format4 != o.u.format4;\n+#endif\n+      default:return false;\n+      }\n+    }\n+    iter_t __end__ () const\n+    {\n+      iter_t it = {};\n+      it.format = format;\n+      switch (format)\n+      {\n+      case 1: it.u.format1 = u.format1.__end__ (); break;\n+      case 2: it.u.format2 = u.format2.__end__ (); break;\n+#ifndef HB_NO_BEYOND_64K\n+      case 3: it.u.format3 = u.format3.__end__ (); break;\n+      case 4: it.u.format4 = u.format4.__end__ (); break;\n+#endif\n+      default: break;\n+      }\n+      return it;\n+    }\n+\n+    private:\n+    unsigned int format;\n+    union {\n+#ifndef HB_NO_BEYOND_64K\n+    CoverageFormat2_4<MediumTypes>::iter_t      format4; \/* Put this one first since it's larger; helps shut up compiler. *\/\n+    CoverageFormat1_3<MediumTypes>::iter_t      format3;\n+#endif\n+    CoverageFormat2_4<SmallTypes>::iter_t       format2; \/* Put this one first since it's larger; helps shut up compiler. *\/\n+    CoverageFormat1_3<SmallTypes>::iter_t       format1;\n+    } u;\n+  };\n+  iter_t iter () const { return iter_t (*this); }\n+};\n+\n+template<typename Iterator>\n+static inline void\n+Coverage_serialize (hb_serialize_context_t *c,\n+                    Iterator it)\n+{ c->start_embed<Coverage> ()->serialize (c, it); }\n+\n+}\n+}\n+}\n+\n+#endif  \/\/ #ifndef OT_LAYOUT_COMMON_COVERAGE_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/Common\/Coverage.hh","additions":337,"deletions":0,"binary":false,"changes":337,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright © 2007,2008,2009  Red Hat, Inc.\n+ * Copyright © 2010,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod, Garret Rieger\n+ *\/\n+\n+\n+#ifndef OT_LAYOUT_COMMON_COVERAGEFORMAT1_HH\n+#define OT_LAYOUT_COMMON_COVERAGEFORMAT1_HH\n+\n+namespace OT {\n+namespace Layout {\n+namespace Common {\n+\n+#define NOT_COVERED             ((unsigned int) -1)\n+\n+template <typename Types>\n+struct CoverageFormat1_3\n+{\n+  friend struct Coverage;\n+\n+  protected:\n+  HBUINT16      coverageFormat; \/* Format identifier--format = 1 *\/\n+  SortedArray16Of<typename Types::HBGlyphID>\n+                glyphArray;     \/* Array of GlyphIDs--in numerical order *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, glyphArray);\n+\n+  private:\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (glyphArray.sanitize (c));\n+  }\n+\n+  unsigned int get_coverage (hb_codepoint_t glyph_id) const\n+  {\n+    unsigned int i;\n+    glyphArray.bfind (glyph_id, &i, HB_NOT_FOUND_STORE, NOT_COVERED);\n+    return i;\n+  }\n+\n+  unsigned get_population () const\n+  {\n+    return glyphArray.len;\n+  }\n+\n+  template <typename Iterator,\n+      hb_requires (hb_is_sorted_source_of (Iterator, hb_codepoint_t))>\n+  bool serialize (hb_serialize_context_t *c, Iterator glyphs)\n+  {\n+    TRACE_SERIALIZE (this);\n+    return_trace (glyphArray.serialize (c, glyphs));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    if (glyphArray.len > glyphs->get_population () * hb_bit_storage ((unsigned) glyphArray.len) \/ 2)\n+    {\n+      for (hb_codepoint_t g = HB_SET_VALUE_INVALID; glyphs->next (&g);)\n+        if (get_coverage (g) != NOT_COVERED)\n+          return true;\n+      return false;\n+    }\n+\n+    for (const auto& g : glyphArray.as_array ())\n+      if (glyphs->has (g))\n+        return true;\n+    return false;\n+  }\n+  bool intersects_coverage (const hb_set_t *glyphs, unsigned int index) const\n+  { return glyphs->has (glyphArray[index]); }\n+\n+  template <typename IterableOut,\n+            hb_requires (hb_is_sink_of (IterableOut, hb_codepoint_t))>\n+  void intersect_set (const hb_set_t &glyphs, IterableOut&& intersect_glyphs) const\n+  {\n+    unsigned count = glyphArray.len;\n+    for (unsigned i = 0; i < count; i++)\n+      if (glyphs.has (glyphArray[i]))\n+        intersect_glyphs << glyphArray[i];\n+  }\n+\n+  template <typename set_t>\n+  bool collect_coverage (set_t *glyphs) const\n+  { return glyphs->add_sorted_array (glyphArray.as_array ()); }\n+\n+  public:\n+  \/* Older compilers need this to be public. *\/\n+  struct iter_t\n+  {\n+    void init (const struct CoverageFormat1_3 &c_) { c = &c_; i = 0; }\n+    bool __more__ () const { return i < c->glyphArray.len; }\n+    void __next__ () { i++; }\n+    hb_codepoint_t get_glyph () const { return c->glyphArray[i]; }\n+    bool operator != (const iter_t& o) const\n+    { return i != o.i; }\n+    iter_t __end__ () const { iter_t it; it.init (*c); it.i = c->glyphArray.len; return it; }\n+\n+    private:\n+    const struct CoverageFormat1_3 *c;\n+    unsigned int i;\n+  };\n+  private:\n+};\n+\n+}\n+}\n+}\n+\n+#endif  \/\/ #ifndef OT_LAYOUT_COMMON_COVERAGEFORMAT1_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/Common\/CoverageFormat1.hh","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright © 2007,2008,2009  Red Hat, Inc.\n+ * Copyright © 2010,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod, Garret Rieger\n+ *\/\n+\n+#ifndef OT_LAYOUT_COMMON_COVERAGEFORMAT2_HH\n+#define OT_LAYOUT_COMMON_COVERAGEFORMAT2_HH\n+\n+#include \"RangeRecord.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace Common {\n+\n+template <typename Types>\n+struct CoverageFormat2_4\n+{\n+  friend struct Coverage;\n+\n+  protected:\n+  HBUINT16      coverageFormat; \/* Format identifier--format = 2 *\/\n+  SortedArray16Of<RangeRecord<Types>>\n+                rangeRecord;    \/* Array of glyph ranges--ordered by\n+                                 * Start GlyphID. rangeCount entries\n+                                 * long *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, rangeRecord);\n+\n+  private:\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (rangeRecord.sanitize (c));\n+  }\n+\n+  unsigned int get_coverage (hb_codepoint_t glyph_id) const\n+  {\n+    const RangeRecord<Types> &range = rangeRecord.bsearch (glyph_id);\n+    return likely (range.first <= range.last)\n+         ? (unsigned int) range.value + (glyph_id - range.first)\n+         : NOT_COVERED;\n+  }\n+\n+  unsigned get_population () const\n+  {\n+    typename Types::large_int ret = 0;\n+    for (const auto &r : rangeRecord)\n+      ret += r.get_population ();\n+    return ret > UINT_MAX ? UINT_MAX : (unsigned) ret;\n+  }\n+\n+  template <typename Iterator,\n+      hb_requires (hb_is_sorted_source_of (Iterator, hb_codepoint_t))>\n+  bool serialize (hb_serialize_context_t *c, Iterator glyphs)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n+\n+    unsigned num_ranges = 0;\n+    hb_codepoint_t last = (hb_codepoint_t) -2;\n+    for (auto g: glyphs)\n+    {\n+      if (last + 1 != g)\n+        num_ranges++;\n+      last = g;\n+    }\n+\n+    if (unlikely (!rangeRecord.serialize (c, num_ranges))) return_trace (false);\n+    if (!num_ranges) return_trace (true);\n+\n+    unsigned count = 0;\n+    unsigned range = (unsigned) -1;\n+    last = (hb_codepoint_t) -2;\n+    for (auto g: glyphs)\n+    {\n+      if (last + 1 != g)\n+      {\n+        range++;\n+        rangeRecord[range].first = g;\n+        rangeRecord[range].value = count;\n+      }\n+      rangeRecord[range].last = g;\n+      last = g;\n+      count++;\n+    }\n+\n+    return_trace (true);\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    if (rangeRecord.len > glyphs->get_population () * hb_bit_storage ((unsigned) rangeRecord.len) \/ 2)\n+    {\n+      for (hb_codepoint_t g = HB_SET_VALUE_INVALID; glyphs->next (&g);)\n+        if (get_coverage (g) != NOT_COVERED)\n+          return true;\n+      return false;\n+    }\n+\n+    return hb_any (+ hb_iter (rangeRecord)\n+                   | hb_map ([glyphs] (const RangeRecord<Types> &range) { return range.intersects (*glyphs); }));\n+  }\n+  bool intersects_coverage (const hb_set_t *glyphs, unsigned int index) const\n+  {\n+    auto *range = rangeRecord.as_array ().bsearch (index);\n+    if (range)\n+      return range->intersects (*glyphs);\n+    return false;\n+  }\n+\n+  template <typename IterableOut,\n+            hb_requires (hb_is_sink_of (IterableOut, hb_codepoint_t))>\n+  void intersect_set (const hb_set_t &glyphs, IterableOut&& intersect_glyphs) const\n+  {\n+    \/* Break out of loop for overlapping, broken, tables,\n+     * to avoid fuzzer timouts. *\/\n+    hb_codepoint_t last = 0;\n+    for (const auto& range : rangeRecord)\n+    {\n+      if (unlikely (range.first < last))\n+        break;\n+      last = range.last;\n+      for (hb_codepoint_t g = range.first - 1;\n+           glyphs.next (&g) && g <= last;)\n+        intersect_glyphs << g;\n+    }\n+  }\n+\n+  template <typename set_t>\n+  bool collect_coverage (set_t *glyphs) const\n+  {\n+    for (const auto& range: rangeRecord)\n+      if (unlikely (!range.collect_coverage (glyphs)))\n+        return false;\n+    return true;\n+  }\n+\n+  public:\n+  \/* Older compilers need this to be public. *\/\n+  struct iter_t\n+  {\n+    void init (const CoverageFormat2_4 &c_)\n+    {\n+      c = &c_;\n+      coverage = 0;\n+      i = 0;\n+      j = c->rangeRecord.len ? c->rangeRecord[0].first : 0;\n+      if (unlikely (c->rangeRecord[0].first > c->rangeRecord[0].last))\n+      {\n+        \/* Broken table. Skip. *\/\n+        i = c->rangeRecord.len;\n+        j = 0;\n+      }\n+    }\n+    bool __more__ () const { return i < c->rangeRecord.len; }\n+    void __next__ ()\n+    {\n+      if (j >= c->rangeRecord[i].last)\n+      {\n+        i++;\n+        if (__more__ ())\n+        {\n+          unsigned int old = coverage;\n+          j = c->rangeRecord[i].first;\n+          coverage = c->rangeRecord[i].value;\n+          if (unlikely (coverage != old + 1))\n+          {\n+            \/* Broken table. Skip. Important to avoid DoS.\n+             * Also, our callers depend on coverage being\n+             * consecutive and monotonically increasing,\n+             * ie. iota(). *\/\n+           i = c->rangeRecord.len;\n+           j = 0;\n+           return;\n+          }\n+        }\n+        else\n+          j = 0;\n+        return;\n+      }\n+      coverage++;\n+      j++;\n+    }\n+    hb_codepoint_t get_glyph () const { return j; }\n+    bool operator != (const iter_t& o) const\n+    { return i != o.i || j != o.j; }\n+    iter_t __end__ () const\n+    {\n+      iter_t it;\n+      it.init (*c);\n+      it.i = c->rangeRecord.len;\n+      it.j = 0;\n+      return it;\n+    }\n+\n+    private:\n+    const struct CoverageFormat2_4 *c;\n+    unsigned int i, coverage;\n+    hb_codepoint_t j;\n+  };\n+  private:\n+};\n+\n+}\n+}\n+}\n+\n+#endif  \/\/ #ifndef OT_LAYOUT_COMMON_COVERAGEFORMAT2_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/Common\/CoverageFormat2.hh","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright © 2007,2008,2009  Red Hat, Inc.\n+ * Copyright © 2010,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod, Garret Rieger\n+ *\/\n+\n+#ifndef OT_LAYOUT_COMMON_RANGERECORD_HH\n+#define OT_LAYOUT_COMMON_RANGERECORD_HH\n+\n+namespace OT {\n+namespace Layout {\n+namespace Common {\n+\n+template <typename Types>\n+struct RangeRecord\n+{\n+  typename Types::HBGlyphID     first;          \/* First GlyphID in the range *\/\n+  typename Types::HBGlyphID     last;           \/* Last GlyphID in the range *\/\n+  HBUINT16                      value;          \/* Value *\/\n+\n+  DEFINE_SIZE_STATIC (2 + 2 * Types::size);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  int cmp (hb_codepoint_t g) const\n+  { return g < first ? -1 : g <= last ? 0 : +1; }\n+\n+  unsigned get_population () const\n+  {\n+    if (unlikely (last < first)) return 0;\n+    return (last - first + 1);\n+  }\n+\n+  bool intersects (const hb_set_t &glyphs) const\n+  { return glyphs.intersects (first, last); }\n+\n+  template <typename set_t>\n+  bool collect_coverage (set_t *glyphs) const\n+  { return glyphs->add_range (first, last); }\n+};\n+\n+}\n+}\n+}\n+\n+\/\/ TODO(garretrieger): This was previously implemented using\n+\/\/    DECLARE_NULL_NAMESPACE_BYTES_TEMPLATE1 (OT, RangeRecord, 9);\n+\/\/    but that only works when there is only a single namespace level.\n+\/\/    The macro should probably be fixed so it can work in this situation.\n+extern HB_INTERNAL const unsigned char _hb_Null_OT_RangeRecord[9];\n+template <typename Spec>\n+struct Null<OT::Layout::Common::RangeRecord<Spec>> {\n+  static OT::Layout::Common::RangeRecord<Spec> const & get_null () {\n+    return *reinterpret_cast<const OT::Layout::Common::RangeRecord<Spec> *> (_hb_Null_OT_RangeRecord);\n+  }\n+};\n+\n+\n+#endif  \/\/ #ifndef OT_LAYOUT_COMMON_RANGERECORD_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/Common\/RangeRecord.hh","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,918 @@\n+\/*\n+ * Copyright © 2007,2008,2009  Red Hat, Inc.\n+ * Copyright © 2010,2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef OT_LAYOUT_GDEF_GDEF_HH\n+#define OT_LAYOUT_GDEF_GDEF_HH\n+\n+#include \"..\/..\/..\/hb-ot-layout-common.hh\"\n+\n+#include \"..\/..\/..\/hb-font.hh\"\n+\n+\n+namespace OT {\n+\n+\n+\/*\n+ * Attachment List Table\n+ *\/\n+\n+\/* Array of contour point indices--in increasing numerical order *\/\n+struct AttachPoint : Array16Of<HBUINT16>\n+{\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->serialize (c->serializer, + iter ()));\n+  }\n+};\n+\n+struct AttachList\n+{\n+  unsigned int get_attach_points (hb_codepoint_t glyph_id,\n+                                  unsigned int start_offset,\n+                                  unsigned int *point_count \/* IN\/OUT *\/,\n+                                  unsigned int *point_array \/* OUT *\/) const\n+  {\n+    unsigned int index = (this+coverage).get_coverage (glyph_id);\n+    if (index == NOT_COVERED)\n+    {\n+      if (point_count)\n+        *point_count = 0;\n+      return 0;\n+    }\n+\n+    const AttachPoint &points = this+attachPoint[index];\n+\n+    if (point_count)\n+    {\n+      + points.as_array ().sub_array (start_offset, point_count)\n+      | hb_sink (hb_array (point_array, *point_count))\n+      ;\n+    }\n+\n+    return points.len;\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+\n+    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n+    + hb_zip (this+coverage, attachPoint)\n+    | hb_filter (glyphset, hb_first)\n+    | hb_filter (subset_offset_array (c, out->attachPoint, this), hb_second)\n+    | hb_map (hb_first)\n+    | hb_map (glyph_map)\n+    | hb_sink (new_coverage)\n+    ;\n+    out->coverage.serialize_serialize (c->serializer, new_coverage.iter ());\n+    return_trace (bool (new_coverage));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && attachPoint.sanitize (c, this));\n+  }\n+\n+  protected:\n+  Offset16To<Coverage>\n+                coverage;               \/* Offset to Coverage table -- from\n+                                         * beginning of AttachList table *\/\n+  Array16OfOffset16To<AttachPoint>\n+                attachPoint;            \/* Array of AttachPoint tables\n+                                         * in Coverage Index order *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, attachPoint);\n+};\n+\n+\/*\n+ * Ligature Caret Table\n+ *\/\n+\n+struct CaretValueFormat1\n+{\n+  friend struct CaretValue;\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  private:\n+  hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction) const\n+  {\n+    return HB_DIRECTION_IS_HORIZONTAL (direction) ? font->em_scale_x (coordinate) : font->em_scale_y (coordinate);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  protected:\n+  HBUINT16      caretValueFormat;       \/* Format identifier--format = 1 *\/\n+  FWORD         coordinate;             \/* X or Y value, in design units *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct CaretValueFormat2\n+{\n+  friend struct CaretValue;\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  private:\n+  hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, hb_codepoint_t glyph_id) const\n+  {\n+    hb_position_t x, y;\n+    font->get_glyph_contour_point_for_origin (glyph_id, caretValuePoint, direction, &x, &y);\n+    return HB_DIRECTION_IS_HORIZONTAL (direction) ? x : y;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  protected:\n+  HBUINT16      caretValueFormat;       \/* Format identifier--format = 2 *\/\n+  HBUINT16      caretValuePoint;        \/* Contour point index on glyph *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct CaretValueFormat3\n+{\n+  friend struct CaretValue;\n+\n+  hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction,\n+                                 const VariationStore &var_store) const\n+  {\n+    return HB_DIRECTION_IS_HORIZONTAL (direction) ?\n+           font->em_scale_x (coordinate) + (this+deviceTable).get_x_delta (font, var_store) :\n+           font->em_scale_y (coordinate) + (this+deviceTable).get_y_delta (font, var_store);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+    if (!c->serializer->embed (caretValueFormat)) return_trace (false);\n+    if (!c->serializer->embed (coordinate)) return_trace (false);\n+\n+    unsigned varidx = (this+deviceTable).get_variation_index ();\n+    if (c->plan->layout_variation_idx_delta_map.has (varidx))\n+    {\n+      int delta = hb_second (c->plan->layout_variation_idx_delta_map.get (varidx));\n+      if (delta != 0)\n+      {\n+        if (!c->serializer->check_assign (out->coordinate, coordinate + delta, HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+          return_trace (false);\n+      }\n+    }\n+\n+    if (c->plan->all_axes_pinned)\n+      return_trace (c->serializer->check_assign (out->caretValueFormat, 1, HB_SERIALIZE_ERROR_INT_OVERFLOW));\n+\n+    if (!c->serializer->embed (deviceTable))\n+      return_trace (false);\n+\n+    return_trace (out->deviceTable.serialize_copy (c->serializer, deviceTable, this, c->serializer->to_bias (out),\n+                                                   hb_serialize_context_t::Head, &c->plan->layout_variation_idx_delta_map));\n+  }\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n+  { (this+deviceTable).collect_variation_indices (c); }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && deviceTable.sanitize (c, this));\n+  }\n+\n+  protected:\n+  HBUINT16      caretValueFormat;       \/* Format identifier--format = 3 *\/\n+  FWORD         coordinate;             \/* X or Y value, in design units *\/\n+  Offset16To<Device>\n+                deviceTable;            \/* Offset to Device table for X or Y\n+                                         * value--from beginning of CaretValue\n+                                         * table *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct CaretValue\n+{\n+  hb_position_t get_caret_value (hb_font_t *font,\n+                                 hb_direction_t direction,\n+                                 hb_codepoint_t glyph_id,\n+                                 const VariationStore &var_store) const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.get_caret_value (font, direction);\n+    case 2: return u.format2.get_caret_value (font, direction, glyph_id);\n+    case 3: return u.format3.get_caret_value (font, direction, var_store);\n+    default:return 0;\n+    }\n+  }\n+\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  {\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n+    TRACE_DISPATCH (this, u.format);\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n+    case 3: return_trace (c->dispatch (u.format3, std::forward<Ts> (ds)...));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n+  {\n+    switch (u.format) {\n+    case 1:\n+    case 2:\n+      return;\n+    case 3:\n+      u.format3.collect_variation_indices (c);\n+      return;\n+    default: return;\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.format.sanitize (c)) return_trace (false);\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.sanitize (c));\n+    case 2: return_trace (u.format2.sanitize (c));\n+    case 3: return_trace (u.format3.sanitize (c));\n+    default:return_trace (true);\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  CaretValueFormat1     format1;\n+  CaretValueFormat2     format2;\n+  CaretValueFormat3     format3;\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (2, format);\n+};\n+\n+struct LigGlyph\n+{\n+  unsigned get_lig_carets (hb_font_t            *font,\n+                           hb_direction_t        direction,\n+                           hb_codepoint_t        glyph_id,\n+                           const VariationStore &var_store,\n+                           unsigned              start_offset,\n+                           unsigned             *caret_count \/* IN\/OUT *\/,\n+                           hb_position_t        *caret_array \/* OUT *\/) const\n+  {\n+    if (caret_count)\n+    {\n+      + carets.as_array ().sub_array (start_offset, caret_count)\n+      | hb_map (hb_add (this))\n+      | hb_map ([&] (const CaretValue &value) { return value.get_caret_value (font, direction, glyph_id, var_store); })\n+      | hb_sink (hb_array (caret_array, *caret_count))\n+      ;\n+    }\n+\n+    return carets.len;\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+\n+    + hb_iter (carets)\n+    | hb_apply (subset_offset_array (c, out->carets, this))\n+    ;\n+\n+    return_trace (bool (out->carets));\n+  }\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n+  {\n+    for (const Offset16To<CaretValue>& offset : carets.iter ())\n+      (this+offset).collect_variation_indices (c);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (carets.sanitize (c, this));\n+  }\n+\n+  protected:\n+  Array16OfOffset16To<CaretValue>\n+                carets;                 \/* Offset array of CaretValue tables\n+                                         * --from beginning of LigGlyph table\n+                                         * --in increasing coordinate order *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (2, carets);\n+};\n+\n+struct LigCaretList\n+{\n+  unsigned int get_lig_carets (hb_font_t *font,\n+                               hb_direction_t direction,\n+                               hb_codepoint_t glyph_id,\n+                               const VariationStore &var_store,\n+                               unsigned int start_offset,\n+                               unsigned int *caret_count \/* IN\/OUT *\/,\n+                               hb_position_t *caret_array \/* OUT *\/) const\n+  {\n+    unsigned int index = (this+coverage).get_coverage (glyph_id);\n+    if (index == NOT_COVERED)\n+    {\n+      if (caret_count)\n+        *caret_count = 0;\n+      return 0;\n+    }\n+    const LigGlyph &lig_glyph = this+ligGlyph[index];\n+    return lig_glyph.get_lig_carets (font, direction, glyph_id, var_store, start_offset, caret_count, caret_array);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+\n+    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n+    + hb_zip (this+coverage, ligGlyph)\n+    | hb_filter (glyphset, hb_first)\n+    | hb_filter (subset_offset_array (c, out->ligGlyph, this), hb_second)\n+    | hb_map (hb_first)\n+    | hb_map (glyph_map)\n+    | hb_sink (new_coverage)\n+    ;\n+    out->coverage.serialize_serialize (c->serializer, new_coverage.iter ());\n+    return_trace (bool (new_coverage));\n+  }\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n+  {\n+    + hb_zip (this+coverage, ligGlyph)\n+    | hb_filter (c->glyph_set, hb_first)\n+    | hb_map (hb_second)\n+    | hb_map (hb_add (this))\n+    | hb_apply ([c] (const LigGlyph& _) { _.collect_variation_indices (c); })\n+    ;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && ligGlyph.sanitize (c, this));\n+  }\n+\n+  protected:\n+  Offset16To<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of LigCaretList table *\/\n+  Array16OfOffset16To<LigGlyph>\n+                ligGlyph;               \/* Array of LigGlyph tables\n+                                         * in Coverage Index order *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, ligGlyph);\n+};\n+\n+\n+struct MarkGlyphSetsFormat1\n+{\n+  bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const\n+  { return (this+coverage[set_index]).get_coverage (glyph_id) != NOT_COVERED; }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+    out->format = format;\n+\n+    bool ret = true;\n+    for (const Offset32To<Coverage>& offset : coverage.iter ())\n+    {\n+      auto *o = out->coverage.serialize_append (c->serializer);\n+      if (unlikely (!o))\n+      {\n+        ret = false;\n+        break;\n+      }\n+\n+      \/\/not using o->serialize_subset (c, offset, this, out) here because\n+      \/\/OTS doesn't allow null offset.\n+      \/\/See issue: https:\/\/github.com\/khaledhosny\/ots\/issues\/172\n+      c->serializer->push ();\n+      c->dispatch (this+offset);\n+      c->serializer->add_link (*o, c->serializer->pop_pack ());\n+    }\n+\n+    return_trace (ret && out->coverage.len);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  Array16Of<Offset32To<Coverage>>\n+                coverage;               \/* Array of long offsets to mark set\n+                                         * coverage tables *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, coverage);\n+};\n+\n+struct MarkGlyphSets\n+{\n+  bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.covers (set_index, glyph_id);\n+    default:return false;\n+    }\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.subset (c));\n+    default:return_trace (false);\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.format.sanitize (c)) return_trace (false);\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.sanitize (c));\n+    default:return_trace (true);\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  MarkGlyphSetsFormat1  format1;\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (2, format);\n+};\n+\n+\n+\/*\n+ * GDEF -- Glyph Definition\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/gdef\n+ *\/\n+\n+\n+template <typename Types>\n+struct GDEFVersion1_2\n+{\n+  friend struct GDEF;\n+\n+  protected:\n+  FixedVersion<>version;                \/* Version of the GDEF table--currently\n+                                         * 0x00010003u *\/\n+  typename Types::template OffsetTo<ClassDef>\n+                glyphClassDef;          \/* Offset to class definition table\n+                                         * for glyph type--from beginning of\n+                                         * GDEF header (may be Null) *\/\n+  typename Types::template OffsetTo<AttachList>\n+                attachList;             \/* Offset to list of glyphs with\n+                                         * attachment points--from beginning\n+                                         * of GDEF header (may be Null) *\/\n+  typename Types::template OffsetTo<LigCaretList>\n+                ligCaretList;           \/* Offset to list of positioning points\n+                                         * for ligature carets--from beginning\n+                                         * of GDEF header (may be Null) *\/\n+  typename Types::template OffsetTo<ClassDef>\n+                markAttachClassDef;     \/* Offset to class definition table for\n+                                         * mark attachment type--from beginning\n+                                         * of GDEF header (may be Null) *\/\n+  typename Types::template OffsetTo<MarkGlyphSets>\n+                markGlyphSetsDef;       \/* Offset to the table of mark set\n+                                         * definitions--from beginning of GDEF\n+                                         * header (may be NULL).  Introduced\n+                                         * in version 0x00010002. *\/\n+  Offset32To<VariationStore>\n+                varStore;               \/* Offset to the table of Item Variation\n+                                         * Store--from beginning of GDEF\n+                                         * header (may be NULL).  Introduced\n+                                         * in version 0x00010003. *\/\n+  public:\n+  DEFINE_SIZE_MIN (4 + 4 * Types::size);\n+\n+  unsigned int get_size () const\n+  {\n+    return min_size +\n+           (version.to_int () >= 0x00010002u ? markGlyphSetsDef.static_size : 0) +\n+           (version.to_int () >= 0x00010003u ? varStore.static_size : 0);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (version.sanitize (c) &&\n+                  glyphClassDef.sanitize (c, this) &&\n+                  attachList.sanitize (c, this) &&\n+                  ligCaretList.sanitize (c, this) &&\n+                  markAttachClassDef.sanitize (c, this) &&\n+                  (version.to_int () < 0x00010002u || markGlyphSetsDef.sanitize (c, this)) &&\n+                  (version.to_int () < 0x00010003u || varStore.sanitize (c, this)));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    bool subset_glyphclassdef = out->glyphClassDef.serialize_subset (c, glyphClassDef, this, nullptr, false, true);\n+    bool subset_attachlist = out->attachList.serialize_subset (c, attachList, this);\n+    bool subset_ligcaretlist = out->ligCaretList.serialize_subset (c, ligCaretList, this);\n+    bool subset_markattachclassdef = out->markAttachClassDef.serialize_subset (c, markAttachClassDef, this, nullptr, false, true);\n+\n+    bool subset_markglyphsetsdef = false;\n+    if (version.to_int () >= 0x00010002u)\n+    {\n+      subset_markglyphsetsdef = out->markGlyphSetsDef.serialize_subset (c, markGlyphSetsDef, this);\n+    }\n+\n+    bool subset_varstore = false;\n+    if (version.to_int () >= 0x00010003u)\n+    {\n+      if (c->plan->all_axes_pinned)\n+        out->varStore = 0;\n+      else\n+        subset_varstore = out->varStore.serialize_subset (c, varStore, this, c->plan->gdef_varstore_inner_maps.as_array ());\n+    }\n+\n+    if (subset_varstore)\n+    {\n+      out->version.minor = 3;\n+    } else if (subset_markglyphsetsdef) {\n+      out->version.minor = 2;\n+    } else  {\n+      out->version.minor = 0;\n+    }\n+\n+    return_trace (subset_glyphclassdef || subset_attachlist ||\n+                  subset_ligcaretlist || subset_markattachclassdef ||\n+                  (out->version.to_int () >= 0x00010002u && subset_markglyphsetsdef) ||\n+                  (out->version.to_int () >= 0x00010003u && subset_varstore));\n+  }\n+};\n+\n+struct GDEF\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_GDEF;\n+\n+  enum GlyphClasses {\n+    UnclassifiedGlyph   = 0,\n+    BaseGlyph           = 1,\n+    LigatureGlyph       = 2,\n+    MarkGlyph           = 3,\n+    ComponentGlyph      = 4\n+  };\n+\n+  unsigned int get_size () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return u.version1.get_size ();\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return u.version2.get_size ();\n+#endif\n+    default: return u.version.static_size;\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!u.version.sanitize (c))) return_trace (false);\n+    switch (u.version.major) {\n+    case 1: return_trace (u.version1.sanitize (c));\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return_trace (u.version2.sanitize (c));\n+#endif\n+    default: return_trace (true);\n+    }\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    switch (u.version.major) {\n+    case 1: return u.version1.subset (c);\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return u.version2.subset (c);\n+#endif\n+    default: return false;\n+    }\n+  }\n+\n+  bool has_glyph_classes () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return u.version1.glyphClassDef != 0;\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return u.version2.glyphClassDef != 0;\n+#endif\n+    default: return false;\n+    }\n+  }\n+  const ClassDef &get_glyph_class_def () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return this+u.version1.glyphClassDef;\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return this+u.version2.glyphClassDef;\n+#endif\n+    default: return Null(ClassDef);\n+    }\n+  }\n+  bool has_attach_list () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return u.version1.attachList != 0;\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return u.version2.attachList != 0;\n+#endif\n+    default: return false;\n+    }\n+  }\n+  const AttachList &get_attach_list () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return this+u.version1.attachList;\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return this+u.version2.attachList;\n+#endif\n+    default: return Null(AttachList);\n+    }\n+  }\n+  bool has_lig_carets () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return u.version1.ligCaretList != 0;\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return u.version2.ligCaretList != 0;\n+#endif\n+    default: return false;\n+    }\n+  }\n+  const LigCaretList &get_lig_caret_list () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return this+u.version1.ligCaretList;\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return this+u.version2.ligCaretList;\n+#endif\n+    default: return Null(LigCaretList);\n+    }\n+  }\n+  bool has_mark_attachment_types () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return u.version1.markAttachClassDef != 0;\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return u.version2.markAttachClassDef != 0;\n+#endif\n+    default: return false;\n+    }\n+  }\n+  const ClassDef &get_mark_attach_class_def () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return this+u.version1.markAttachClassDef;\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return this+u.version2.markAttachClassDef;\n+#endif\n+    default: return Null(ClassDef);\n+    }\n+  }\n+  bool has_mark_glyph_sets () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return u.version.to_int () >= 0x00010002u && u.version1.markGlyphSetsDef != 0;\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return u.version2.markGlyphSetsDef != 0;\n+#endif\n+    default: return false;\n+    }\n+  }\n+  const MarkGlyphSets &get_mark_glyph_sets () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return u.version.to_int () >= 0x00010002u ? this+u.version1.markGlyphSetsDef : Null(MarkGlyphSets);\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return this+u.version2.markGlyphSetsDef;\n+#endif\n+    default: return Null(MarkGlyphSets);\n+    }\n+  }\n+  bool has_var_store () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return u.version.to_int () >= 0x00010003u && u.version1.varStore != 0;\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return u.version2.varStore != 0;\n+#endif\n+    default: return false;\n+    }\n+  }\n+  const VariationStore &get_var_store () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return u.version.to_int () >= 0x00010003u ? this+u.version1.varStore : Null(VariationStore);\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return this+u.version2.varStore;\n+#endif\n+    default: return Null(VariationStore);\n+    }\n+  }\n+\n+\n+  bool has_data () const { return u.version.to_int (); }\n+  unsigned int get_glyph_class (hb_codepoint_t glyph) const\n+  { return get_glyph_class_def ().get_class (glyph); }\n+  void get_glyphs_in_class (unsigned int klass, hb_set_t *glyphs) const\n+  { get_glyph_class_def ().collect_class (glyphs, klass); }\n+\n+  unsigned int get_mark_attachment_type (hb_codepoint_t glyph) const\n+  { return get_mark_attach_class_def ().get_class (glyph); }\n+\n+  unsigned int get_attach_points (hb_codepoint_t glyph_id,\n+                                  unsigned int start_offset,\n+                                  unsigned int *point_count \/* IN\/OUT *\/,\n+                                  unsigned int *point_array \/* OUT *\/) const\n+  { return get_attach_list ().get_attach_points (glyph_id, start_offset, point_count, point_array); }\n+\n+  unsigned int get_lig_carets (hb_font_t *font,\n+                               hb_direction_t direction,\n+                               hb_codepoint_t glyph_id,\n+                               unsigned int start_offset,\n+                               unsigned int *caret_count \/* IN\/OUT *\/,\n+                               hb_position_t *caret_array \/* OUT *\/) const\n+  { return get_lig_caret_list ().get_lig_carets (font,\n+                                                 direction, glyph_id, get_var_store(),\n+                                                 start_offset, caret_count, caret_array); }\n+\n+  bool mark_set_covers (unsigned int set_index, hb_codepoint_t glyph_id) const\n+  { return get_mark_glyph_sets ().covers (set_index, glyph_id); }\n+\n+  \/* glyph_props is a 16-bit integer where the lower 8-bit have bits representing\n+   * glyph class and other bits, and high 8-bit the mark attachment type (if any).\n+   * Not to be confused with lookup_props which is very similar. *\/\n+  unsigned int get_glyph_props (hb_codepoint_t glyph) const\n+  {\n+    unsigned int klass = get_glyph_class (glyph);\n+\n+    static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH == (unsigned int) LookupFlag::IgnoreBaseGlyphs), \"\");\n+    static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE == (unsigned int) LookupFlag::IgnoreLigatures), \"\");\n+    static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_MARK == (unsigned int) LookupFlag::IgnoreMarks), \"\");\n+\n+    switch (klass) {\n+    default:                    return HB_OT_LAYOUT_GLYPH_CLASS_UNCLASSIFIED;\n+    case BaseGlyph:             return HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH;\n+    case LigatureGlyph:         return HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE;\n+    case MarkGlyph:\n+          klass = get_mark_attachment_type (glyph);\n+          return HB_OT_LAYOUT_GLYPH_PROPS_MARK | (klass << 8);\n+    }\n+  }\n+\n+  HB_INTERNAL bool is_blocklisted (hb_blob_t *blob,\n+                                   hb_face_t *face) const;\n+\n+  struct accelerator_t\n+  {\n+    accelerator_t (hb_face_t *face)\n+    {\n+      table = hb_sanitize_context_t ().reference_table<GDEF> (face);\n+      if (unlikely (table->is_blocklisted (table.get_blob (), face)))\n+      {\n+        hb_blob_destroy (table.get_blob ());\n+        table = hb_blob_get_empty ();\n+      }\n+    }\n+    ~accelerator_t () { table.destroy (); }\n+\n+    hb_blob_ptr_t<GDEF> table;\n+  };\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n+  { get_lig_caret_list ().collect_variation_indices (c); }\n+\n+  void remap_layout_variation_indices (const hb_set_t *layout_variation_indices,\n+                                       hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> *layout_variation_idx_delta_map \/* OUT *\/) const\n+  {\n+    if (!has_var_store ()) return;\n+    if (layout_variation_indices->is_empty ()) return;\n+\n+    unsigned new_major = 0, new_minor = 0;\n+    unsigned last_major = (layout_variation_indices->get_min ()) >> 16;\n+    for (unsigned idx : layout_variation_indices->iter ())\n+    {\n+      uint16_t major = idx >> 16;\n+      if (major >= get_var_store ().get_sub_table_count ()) break;\n+      if (major != last_major)\n+      {\n+        new_minor = 0;\n+        ++new_major;\n+      }\n+\n+      unsigned new_idx = (new_major << 16) + new_minor;\n+      if (!layout_variation_idx_delta_map->has (idx))\n+        continue;\n+      int delta = hb_second (layout_variation_idx_delta_map->get (idx));\n+\n+      layout_variation_idx_delta_map->set (idx, hb_pair_t<unsigned, int> (new_idx, delta));\n+      ++new_minor;\n+      last_major = major;\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  FixedVersion<>                version;        \/* Version identifier *\/\n+  GDEFVersion1_2<SmallTypes>    version1;\n+#ifndef HB_NO_BEYOND_64K\n+  GDEFVersion1_2<MediumTypes>   version2;\n+#endif\n+  } u;\n+  public:\n+  DEFINE_SIZE_MIN (4);\n+};\n+\n+struct GDEF_accelerator_t : GDEF::accelerator_t {\n+  GDEF_accelerator_t (hb_face_t *face) : GDEF::accelerator_t (face) {}\n+};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* OT_LAYOUT_GDEF_GDEF_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GDEF\/GDEF.hh","additions":918,"deletions":0,"binary":false,"changes":918,"status":"added"},{"patch":"@@ -1,165 +0,0 @@\n-#ifndef OT_LAYOUT_GPOS_HH\n-#define OT_LAYOUT_GPOS_HH\n-\n-#include \"..\/..\/hb-ot-layout-common.hh\"\n-#include \"..\/..\/hb-ot-layout-gsubgpos.hh\"\n-#include \"GPOS\/Common.hh\"\n-#include \"GPOS\/PosLookup.hh\"\n-\n-namespace OT {\n-namespace Layout {\n-\n-static void\n-propagate_attachment_offsets (hb_glyph_position_t *pos,\n-                              unsigned int len,\n-                              unsigned int i,\n-                              hb_direction_t direction,\n-                              unsigned nesting_level = HB_MAX_NESTING_LEVEL);\n-\n-\/*\n- * GPOS -- Glyph Positioning\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/gpos\n- *\/\n-\n-struct GPOS : GSUBGPOS\n-{\n-  static constexpr hb_tag_t tableTag = HB_OT_TAG_GPOS;\n-\n-  using Lookup = GPOS_impl::PosLookup;\n-\n-  const GPOS_impl::PosLookup& get_lookup (unsigned int i) const\n-  { return static_cast<const GPOS_impl::PosLookup &> (GSUBGPOS::get_lookup (i)); }\n-\n-  static inline void position_start (hb_font_t *font, hb_buffer_t *buffer);\n-  static inline void position_finish_advances (hb_font_t *font, hb_buffer_t *buffer);\n-  static inline void position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer);\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    hb_subset_layout_context_t l (c, tableTag, c->plan->gpos_lookups, c->plan->gpos_langsys, c->plan->gpos_features);\n-    return GSUBGPOS::subset<GPOS_impl::PosLookup> (&l);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  { return GSUBGPOS::sanitize<GPOS_impl::PosLookup> (c); }\n-\n-  HB_INTERNAL bool is_blocklisted (hb_blob_t *blob,\n-                                   hb_face_t *face) const;\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n-  {\n-    for (unsigned i = 0; i < GSUBGPOS::get_lookup_count (); i++)\n-    {\n-      if (!c->gpos_lookups->has (i)) continue;\n-      const GPOS_impl::PosLookup &l = get_lookup (i);\n-      l.dispatch (c);\n-    }\n-  }\n-\n-  void closure_lookups (hb_face_t      *face,\n-                        const hb_set_t *glyphs,\n-                        hb_set_t       *lookup_indexes \/* IN\/OUT *\/) const\n-  { GSUBGPOS::closure_lookups<GPOS_impl::PosLookup> (face, glyphs, lookup_indexes); }\n-\n-  typedef GSUBGPOS::accelerator_t<GPOS> accelerator_t;\n-};\n-\n-\n-static void\n-propagate_attachment_offsets (hb_glyph_position_t *pos,\n-                              unsigned int len,\n-                              unsigned int i,\n-                              hb_direction_t direction,\n-                              unsigned nesting_level)\n-{\n-  \/* Adjusts offsets of attached glyphs (both cursive and mark) to accumulate\n-   * offset of glyph they are attached to. *\/\n-  int chain = pos[i].attach_chain(), type = pos[i].attach_type();\n-  if (likely (!chain))\n-    return;\n-\n-  pos[i].attach_chain() = 0;\n-\n-  unsigned int j = (int) i + chain;\n-\n-  if (unlikely (j >= len))\n-    return;\n-\n-  if (unlikely (!nesting_level))\n-    return;\n-\n-  propagate_attachment_offsets (pos, len, j, direction, nesting_level - 1);\n-\n-  assert (!!(type & GPOS_impl::ATTACH_TYPE_MARK) ^ !!(type & GPOS_impl::ATTACH_TYPE_CURSIVE));\n-\n-  if (type & GPOS_impl::ATTACH_TYPE_CURSIVE)\n-  {\n-    if (HB_DIRECTION_IS_HORIZONTAL (direction))\n-      pos[i].y_offset += pos[j].y_offset;\n-    else\n-      pos[i].x_offset += pos[j].x_offset;\n-  }\n-  else \/*if (type & GPOS_impl::ATTACH_TYPE_MARK)*\/\n-  {\n-    pos[i].x_offset += pos[j].x_offset;\n-    pos[i].y_offset += pos[j].y_offset;\n-\n-    assert (j < i);\n-    if (HB_DIRECTION_IS_FORWARD (direction))\n-      for (unsigned int k = j; k < i; k++) {\n-        pos[i].x_offset -= pos[k].x_advance;\n-        pos[i].y_offset -= pos[k].y_advance;\n-      }\n-    else\n-      for (unsigned int k = j + 1; k < i + 1; k++) {\n-        pos[i].x_offset += pos[k].x_advance;\n-        pos[i].y_offset += pos[k].y_advance;\n-      }\n-  }\n-}\n-\n-void\n-GPOS::position_start (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)\n-{\n-  unsigned int count = buffer->len;\n-  for (unsigned int i = 0; i < count; i++)\n-    buffer->pos[i].attach_chain() = buffer->pos[i].attach_type() = 0;\n-}\n-\n-void\n-GPOS::position_finish_advances (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer HB_UNUSED)\n-{\n-  \/\/_hb_buffer_assert_gsubgpos_vars (buffer);\n-}\n-\n-void\n-GPOS::position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer)\n-{\n-  _hb_buffer_assert_gsubgpos_vars (buffer);\n-\n-  unsigned int len;\n-  hb_glyph_position_t *pos = hb_buffer_get_glyph_positions (buffer, &len);\n-  hb_direction_t direction = buffer->props.direction;\n-\n-  \/* Handle attachments *\/\n-  if (buffer->scratch_flags & HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT)\n-    for (unsigned i = 0; i < len; i++)\n-      propagate_attachment_offsets (pos, len, i, direction);\n-\n-  if (unlikely (font->slant))\n-  {\n-    for (unsigned i = 0; i < len; i++)\n-      if (unlikely (pos[i].y_offset))\n-        pos[i].x_offset += _hb_roundf (font->slant_xy * pos[i].y_offset);\n-  }\n-}\n-\n-}\n-\n-struct GPOS_accelerator_t : Layout::GPOS::accelerator_t {\n-  GPOS_accelerator_t (hb_face_t *face) : Layout::GPOS::accelerator_t (face) {}\n-};\n-\n-}\n-\n-#endif  \/* OT_LAYOUT_GPOS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS.hh","additions":0,"deletions":165,"binary":false,"changes":165,"status":"deleted"},{"patch":"@@ -61,2 +61,1 @@\n-    case 3: return_trace (bool (reinterpret_cast<Anchor *> (u.format3.copy (c->serializer,\n-                                                                            c->plan->layout_variation_idx_map))));\n+    case 3: return_trace (u.format3.subset (c));\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/Anchor.hh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,2 +44,1 @@\n-  AnchorFormat3* copy (hb_serialize_context_t *c,\n-                       const hb_map_t *layout_variation_idx_map) const\n+  bool subset (hb_subset_context_t *c) const\n@@ -47,2 +46,6 @@\n-    TRACE_SERIALIZE (this);\n-    if (!layout_variation_idx_map) return_trace (nullptr);\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+    if (unlikely (!c->serializer->embed (format))) return_trace (false);\n+    if (unlikely (!c->serializer->embed (xCoordinate))) return_trace (false);\n+    if (unlikely (!c->serializer->embed (yCoordinate))) return_trace (false);\n@@ -50,2 +53,11 @@\n-    auto *out = c->embed<AnchorFormat3> (this);\n-    if (unlikely (!out)) return_trace (nullptr);\n+    unsigned x_varidx = xDeviceTable ? (this+xDeviceTable).get_variation_index () : HB_OT_LAYOUT_NO_VARIATIONS_INDEX;\n+    if (c->plan->layout_variation_idx_delta_map.has (x_varidx))\n+    {\n+      int delta = hb_second (c->plan->layout_variation_idx_delta_map.get (x_varidx));\n+      if (delta != 0)\n+      {\n+        if (!c->serializer->check_assign (out->xCoordinate, xCoordinate + delta,\n+                                          HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+          return_trace (false);\n+      }\n+    }\n@@ -53,2 +65,20 @@\n-    out->xDeviceTable.serialize_copy (c, xDeviceTable, this, 0, hb_serialize_context_t::Head, layout_variation_idx_map);\n-    out->yDeviceTable.serialize_copy (c, yDeviceTable, this, 0, hb_serialize_context_t::Head, layout_variation_idx_map);\n+    unsigned y_varidx = yDeviceTable ? (this+yDeviceTable).get_variation_index () : HB_OT_LAYOUT_NO_VARIATIONS_INDEX;\n+    if (c->plan->layout_variation_idx_delta_map.has (y_varidx))\n+    {\n+      int delta = hb_second (c->plan->layout_variation_idx_delta_map.get (y_varidx));\n+      if (delta != 0)\n+      {\n+        if (!c->serializer->check_assign (out->yCoordinate, yCoordinate + delta,\n+                                          HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+          return_trace (false);\n+      }\n+    }\n+\n+    if (c->plan->all_axes_pinned)\n+      return_trace (c->serializer->check_assign (out->format, 1, HB_SERIALIZE_ERROR_INT_OVERFLOW));\n+\n+    if (!c->serializer->embed (xDeviceTable)) return_trace (false);\n+    if (!c->serializer->embed (yDeviceTable)) return_trace (false);\n+\n+    out->xDeviceTable.serialize_copy (c->serializer, xDeviceTable, this, 0, hb_serialize_context_t::Head, &c->plan->layout_variation_idx_delta_map);\n+    out->yDeviceTable.serialize_copy (c->serializer, yDeviceTable, this, 0, hb_serialize_context_t::Head, &c->plan->layout_variation_idx_delta_map);\n@@ -60,2 +90,2 @@\n-    (this+xDeviceTable).collect_variation_indices (c->layout_variation_indices);\n-    (this+yDeviceTable).collect_variation_indices (c->layout_variation_indices);\n+    (this+xDeviceTable).collect_variation_indices (c);\n+    (this+yDeviceTable).collect_variation_indices (c);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/AnchorFormat3.hh","additions":40,"deletions":10,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n-                                 const hb_map_t *layout_variation_idx_map);\n+                                 const hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> *layout_variation_idx_delta_map,\n+                                 bool all_axes_pinned);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/Common.hh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -22,0 +22,1 @@\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n@@ -23,1 +24,0 @@\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/CursivePos.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -143,1 +143,8 @@\n-    buffer->unsafe_to_break (i, j);\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->message (c->font,\n+                          \"cursive attaching glyph at %u to glyph at %u\",\n+                          i, j);\n+    }\n+\n+    buffer->unsafe_to_break (i, j + 1);\n@@ -226,0 +233,1 @@\n+    {\n@@ -227,0 +235,12 @@\n+      if (likely (HB_DIRECTION_IS_HORIZONTAL (c->direction)))\n+        pos[parent].y_offset = 0;\n+      else\n+        pos[parent].x_offset = 0;\n+    }\n+\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->message (c->font,\n+                          \"cursive attached glyph at %u to glyph at %u\",\n+                          i, j);\n+    }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/CursivePosFormat1.hh","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+#ifndef OT_LAYOUT_GPOS_GPOS_HH\n+#define OT_LAYOUT_GPOS_GPOS_HH\n+\n+#include \"..\/..\/..\/hb-ot-layout-common.hh\"\n+#include \"..\/..\/..\/hb-ot-layout-gsubgpos.hh\"\n+#include \"Common.hh\"\n+#include \"PosLookup.hh\"\n+\n+namespace OT {\n+\n+using Layout::GPOS_impl::PosLookup;\n+\n+namespace Layout {\n+\n+static void\n+propagate_attachment_offsets (hb_glyph_position_t *pos,\n+                              unsigned int len,\n+                              unsigned int i,\n+                              hb_direction_t direction,\n+                              unsigned nesting_level = HB_MAX_NESTING_LEVEL);\n+\n+\/*\n+ * GPOS -- Glyph Positioning\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/gpos\n+ *\/\n+\n+struct GPOS : GSUBGPOS\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_GPOS;\n+\n+  using Lookup = PosLookup;\n+\n+  const PosLookup& get_lookup (unsigned int i) const\n+  { return static_cast<const PosLookup &> (GSUBGPOS::get_lookup (i)); }\n+\n+  static inline void position_start (hb_font_t *font, hb_buffer_t *buffer);\n+  static inline void position_finish_advances (hb_font_t *font, hb_buffer_t *buffer);\n+  static inline void position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer);\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    hb_subset_layout_context_t l (c, tableTag);\n+    return GSUBGPOS::subset<PosLookup> (&l);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (GSUBGPOS::sanitize<PosLookup> (c));\n+  }\n+\n+  HB_INTERNAL bool is_blocklisted (hb_blob_t *blob,\n+                                   hb_face_t *face) const;\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n+  {\n+    for (unsigned i = 0; i < GSUBGPOS::get_lookup_count (); i++)\n+    {\n+      if (!c->gpos_lookups->has (i)) continue;\n+      const PosLookup &l = get_lookup (i);\n+      l.dispatch (c);\n+    }\n+  }\n+\n+  void closure_lookups (hb_face_t      *face,\n+                        const hb_set_t *glyphs,\n+                        hb_set_t       *lookup_indexes \/* IN\/OUT *\/) const\n+  { GSUBGPOS::closure_lookups<PosLookup> (face, glyphs, lookup_indexes); }\n+\n+  typedef GSUBGPOS::accelerator_t<GPOS> accelerator_t;\n+};\n+\n+\n+static void\n+propagate_attachment_offsets (hb_glyph_position_t *pos,\n+                              unsigned int len,\n+                              unsigned int i,\n+                              hb_direction_t direction,\n+                              unsigned nesting_level)\n+{\n+  \/* Adjusts offsets of attached glyphs (both cursive and mark) to accumulate\n+   * offset of glyph they are attached to. *\/\n+  int chain = pos[i].attach_chain(), type = pos[i].attach_type();\n+  if (likely (!chain))\n+    return;\n+\n+  pos[i].attach_chain() = 0;\n+\n+  unsigned int j = (int) i + chain;\n+\n+  if (unlikely (j >= len))\n+    return;\n+\n+  if (unlikely (!nesting_level))\n+    return;\n+\n+  propagate_attachment_offsets (pos, len, j, direction, nesting_level - 1);\n+\n+  assert (!!(type & GPOS_impl::ATTACH_TYPE_MARK) ^ !!(type & GPOS_impl::ATTACH_TYPE_CURSIVE));\n+\n+  if (type & GPOS_impl::ATTACH_TYPE_CURSIVE)\n+  {\n+    if (HB_DIRECTION_IS_HORIZONTAL (direction))\n+      pos[i].y_offset += pos[j].y_offset;\n+    else\n+      pos[i].x_offset += pos[j].x_offset;\n+  }\n+  else \/*if (type & GPOS_impl::ATTACH_TYPE_MARK)*\/\n+  {\n+    pos[i].x_offset += pos[j].x_offset;\n+    pos[i].y_offset += pos[j].y_offset;\n+\n+    assert (j < i);\n+    if (HB_DIRECTION_IS_FORWARD (direction))\n+      for (unsigned int k = j; k < i; k++) {\n+        pos[i].x_offset -= pos[k].x_advance;\n+        pos[i].y_offset -= pos[k].y_advance;\n+      }\n+    else\n+      for (unsigned int k = j + 1; k < i + 1; k++) {\n+        pos[i].x_offset += pos[k].x_advance;\n+        pos[i].y_offset += pos[k].y_advance;\n+      }\n+  }\n+}\n+\n+void\n+GPOS::position_start (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)\n+{\n+  unsigned int count = buffer->len;\n+  for (unsigned int i = 0; i < count; i++)\n+    buffer->pos[i].attach_chain() = buffer->pos[i].attach_type() = 0;\n+}\n+\n+void\n+GPOS::position_finish_advances (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer HB_UNUSED)\n+{\n+  \/\/_hb_buffer_assert_gsubgpos_vars (buffer);\n+}\n+\n+void\n+GPOS::position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer)\n+{\n+  _hb_buffer_assert_gsubgpos_vars (buffer);\n+\n+  unsigned int len;\n+  hb_glyph_position_t *pos = hb_buffer_get_glyph_positions (buffer, &len);\n+  hb_direction_t direction = buffer->props.direction;\n+\n+  \/* Handle attachments *\/\n+  if (buffer->scratch_flags & HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT)\n+    for (unsigned i = 0; i < len; i++)\n+      propagate_attachment_offsets (pos, len, i, direction);\n+\n+  if (unlikely (font->slant))\n+  {\n+    for (unsigned i = 0; i < len; i++)\n+      if (unlikely (pos[i].y_offset))\n+        pos[i].x_offset += _hb_roundf (font->slant_xy * pos[i].y_offset);\n+  }\n+}\n+\n+}\n+\n+struct GPOS_accelerator_t : Layout::GPOS::accelerator_t {\n+  GPOS_accelerator_t (hb_face_t *face) : Layout::GPOS::accelerator_t (face) {}\n+};\n+\n+}\n+\n+#endif  \/* OT_LAYOUT_GPOS_GPOS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/GPOS.hh","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+#ifndef OT_LAYOUT_GPOS_LIGATUREARRAY_HH\n+#define OT_LAYOUT_GPOS_LIGATUREARRAY_HH\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+\n+typedef AnchorMatrix LigatureAttach;    \/* component-major--\n+                                         * in order of writing direction--,\n+                                         * mark-minor--\n+                                         * ordered by class--zero-based. *\/\n+\n+\/* Array of LigatureAttach tables ordered by LigatureCoverage Index *\/\n+struct LigatureArray : List16OfOffset16To<LigatureAttach>\n+{\n+  template <typename Iterator,\n+            hb_requires (hb_is_iterator (Iterator))>\n+  bool subset (hb_subset_context_t *c,\n+               Iterator             coverage,\n+               unsigned             class_count,\n+               const hb_map_t      *klass_mapping) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+\n+    auto *out = c->serializer->start_embed (this);\n+    if (unlikely (!c->serializer->extend_min (out)))  return_trace (false);\n+\n+    for (const auto _ : + hb_zip (coverage, *this)\n+                  | hb_filter (glyphset, hb_first))\n+    {\n+      auto *matrix = out->serialize_append (c->serializer);\n+      if (unlikely (!matrix)) return_trace (false);\n+\n+      const LigatureAttach& src = (this + _.second);\n+      auto indexes =\n+          + hb_range (src.rows * class_count)\n+          | hb_filter ([=] (unsigned index) { return klass_mapping->has (index % class_count); })\n+          ;\n+      matrix->serialize_subset (c,\n+                                _.second,\n+                                this,\n+                                src.rows,\n+                                indexes);\n+    }\n+    return_trace (this->len);\n+  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_LIGATUREARRAY_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/LigatureArray.hh","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -42,0 +42,7 @@\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->message (c->font,\n+                          \"attaching mark glyph at %u to glyph at %u\",\n+                          c->buffer->idx, glyph_pos);\n+    }\n+\n@@ -49,0 +56,7 @@\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->message (c->font,\n+                          \"attached mark glyph at %u to glyph at %u\",\n+                          c->buffer->idx, glyph_pos);\n+    }\n+\n@@ -86,4 +100,5 @@\n-static void Markclass_closure_and_remap_indexes (const Coverage  &mark_coverage,\n-                                                 const MarkArray &mark_array,\n-                                                 const hb_set_t  &glyphset,\n-                                                 hb_map_t*        klass_mapping \/* INOUT *\/)\n+HB_INTERNAL inline\n+void Markclass_closure_and_remap_indexes (const Coverage  &mark_coverage,\n+                                          const MarkArray &mark_array,\n+                                          const hb_set_t  &glyphset,\n+                                          hb_map_t*        klass_mapping \/* INOUT *\/)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkArray.hh","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -14,2 +14,5 @@\n-  HBUINT16              format;         \/* Format identifier *\/\n-  MarkBasePosFormat1    format1;\n+  HBUINT16                              format;         \/* Format identifier *\/\n+  MarkBasePosFormat1_2<SmallTypes>      format1;\n+#ifndef HB_NO_BEYOND_64K\n+  MarkBasePosFormat1_2<MediumTypes>     format2;\n+#endif\n@@ -22,0 +25,1 @@\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n@@ -23,1 +27,0 @@\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n@@ -26,0 +29,3 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkBasePos.hh","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -15,1 +15,2 @@\n-struct MarkBasePosFormat1\n+template <typename Types>\n+struct MarkBasePosFormat1_2\n@@ -19,1 +20,1 @@\n-  Offset16To<Coverage>\n+  typename Types::template OffsetTo<Coverage>\n@@ -22,1 +23,1 @@\n-  Offset16To<Coverage>\n+  typename Types::template OffsetTo<Coverage>\n@@ -26,1 +27,1 @@\n-  Offset16To<MarkArray>\n+  typename Types::template OffsetTo<MarkArray>\n@@ -29,1 +30,1 @@\n-  Offset16To<BaseArray>\n+  typename Types::template OffsetTo<BaseArray>\n@@ -34,1 +35,1 @@\n-  DEFINE_SIZE_STATIC (12);\n+  DEFINE_SIZE_STATIC (4 + 4 * Types::size);\n@@ -92,0 +93,19 @@\n+  static inline bool accept (hb_buffer_t *buffer, unsigned idx)\n+  {\n+    \/* We only want to attach to the first of a MultipleSubst sequence.\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/740\n+     * Reject others...\n+     * ...but stop if we find a mark in the MultipleSubst sequence:\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1020 *\/\n+    return !_hb_glyph_info_multiplied (&buffer->info[idx]) ||\n+           0 == _hb_glyph_info_get_lig_comp (&buffer->info[idx]) ||\n+           (idx == 0 ||\n+            _hb_glyph_info_is_mark (&buffer->info[idx - 1]) ||\n+            !_hb_glyph_info_multiplied (&buffer->info[idx - 1]) ||\n+            _hb_glyph_info_get_lig_id (&buffer->info[idx]) !=\n+            _hb_glyph_info_get_lig_id (&buffer->info[idx - 1]) ||\n+            _hb_glyph_info_get_lig_comp (&buffer->info[idx]) !=\n+            _hb_glyph_info_get_lig_comp (&buffer->info[idx - 1]) + 1\n+            );\n+  }\n+\n@@ -99,1 +119,3 @@\n-    \/* Now we search backwards for a non-mark glyph *\/\n+    \/* Now we search backwards for a non-mark glyph.\n+     * We don't use skippy_iter.prev() to avoid O(n^2) behavior. *\/\n+\n@@ -101,1 +123,0 @@\n-    skippy_iter.reset (buffer->idx, 1);\n@@ -103,3 +124,11 @@\n-    do {\n-      unsigned unsafe_from;\n-      if (!skippy_iter.prev (&unsafe_from))\n+\n+    if (c->last_base_until > buffer->idx)\n+    {\n+      c->last_base_until = 0;\n+      c->last_base = -1;\n+    }\n+    unsigned j;\n+    for (j = buffer->idx; j > c->last_base_until; j--)\n+    {\n+      auto match = skippy_iter.match (buffer->info[j - 1]);\n+      if (match == skippy_iter.MATCH)\n@@ -107,2 +136,4 @@\n-        buffer->unsafe_to_concat_from_outbuffer (unsafe_from, buffer->idx + 1);\n-        return_trace (false);\n+        \/\/ https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/4124\n+        if (!accept (buffer, j - 1) &&\n+            NOT_COVERED == (this+baseCoverage).get_coverage  (buffer->info[j - 1].codepoint))\n+          match = skippy_iter.SKIP;\n@@ -110,15 +141,3 @@\n-\n-      \/* We only want to attach to the first of a MultipleSubst sequence.\n-       * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/740\n-       * Reject others...\n-       * ...but stop if we find a mark in the MultipleSubst sequence:\n-       * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1020 *\/\n-      if (!_hb_glyph_info_multiplied (&buffer->info[skippy_iter.idx]) ||\n-          0 == _hb_glyph_info_get_lig_comp (&buffer->info[skippy_iter.idx]) ||\n-          (skippy_iter.idx == 0 ||\n-           _hb_glyph_info_is_mark (&buffer->info[skippy_iter.idx - 1]) ||\n-           _hb_glyph_info_get_lig_id (&buffer->info[skippy_iter.idx]) !=\n-           _hb_glyph_info_get_lig_id (&buffer->info[skippy_iter.idx - 1]) ||\n-           _hb_glyph_info_get_lig_comp (&buffer->info[skippy_iter.idx]) !=\n-           _hb_glyph_info_get_lig_comp (&buffer->info[skippy_iter.idx - 1]) + 1\n-           ))\n+      if (match == skippy_iter.MATCH)\n+      {\n+        c->last_base = (signed) j - 1;\n@@ -126,2 +145,10 @@\n-      skippy_iter.reject ();\n-    } while (true);\n+      }\n+    }\n+    c->last_base_until = buffer->idx;\n+    if (c->last_base == -1)\n+    {\n+      buffer->unsafe_to_concat_from_outbuffer (0, buffer->idx + 1);\n+      return_trace (false);\n+    }\n+\n+    unsigned idx = (unsigned) c->last_base;\n@@ -130,1 +157,1 @@\n-    \/\/if (!_hb_glyph_info_is_base_glyph (&buffer->info[skippy_iter.idx])) { return_trace (false); }\n+    \/\/if (!_hb_glyph_info_is_base_glyph (&buffer->info[idx])) { return_trace (false); }\n@@ -132,1 +159,1 @@\n-    unsigned int base_index = (this+baseCoverage).get_coverage  (buffer->info[skippy_iter.idx].codepoint);\n+    unsigned int base_index = (this+baseCoverage).get_coverage  (buffer->info[idx].codepoint);\n@@ -135,1 +162,1 @@\n-      buffer->unsafe_to_concat_from_outbuffer (skippy_iter.idx, buffer->idx + 1);\n+      buffer->unsafe_to_concat_from_outbuffer (idx, buffer->idx + 1);\n@@ -139,1 +166,1 @@\n-    return_trace ((this+markArray).apply (c, mark_index, base_index, this+baseArray, classCount, skippy_iter.idx));\n+    return_trace ((this+markArray).apply (c, mark_index, base_index, this+baseArray, classCount, idx));\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkBasePosFormat1.hh","additions":61,"deletions":34,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -14,2 +14,5 @@\n-  HBUINT16              format;         \/* Format identifier *\/\n-  MarkLigPosFormat1     format1;\n+  HBUINT16                              format;         \/* Format identifier *\/\n+  MarkLigPosFormat1_2<SmallTypes>       format1;\n+#ifndef HB_NO_BEYOND_64K\n+  MarkLigPosFormat1_2<MediumTypes>      format2;\n+#endif\n@@ -22,0 +25,1 @@\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n@@ -23,1 +27,0 @@\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n@@ -26,0 +29,3 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkLigPos.hh","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4,0 +4,2 @@\n+#include \"LigatureArray.hh\"\n+\n@@ -8,41 +10,0 @@\n-typedef AnchorMatrix LigatureAttach;    \/* component-major--\n-                                         * in order of writing direction--,\n-                                         * mark-minor--\n-                                         * ordered by class--zero-based. *\/\n-\n-\/* Array of LigatureAttach tables ordered by LigatureCoverage Index *\/\n-struct LigatureArray : List16OfOffset16To<LigatureAttach>\n-{\n-  template <typename Iterator,\n-            hb_requires (hb_is_iterator (Iterator))>\n-  bool subset (hb_subset_context_t *c,\n-               Iterator             coverage,\n-               unsigned             class_count,\n-               const hb_map_t      *klass_mapping) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-\n-    auto *out = c->serializer->start_embed (this);\n-    if (unlikely (!c->serializer->extend_min (out)))  return_trace (false);\n-\n-    for (const auto _ : + hb_zip (coverage, *this)\n-                  | hb_filter (glyphset, hb_first))\n-    {\n-      auto *matrix = out->serialize_append (c->serializer);\n-      if (unlikely (!matrix)) return_trace (false);\n-\n-      const LigatureAttach& src = (this + _.second);\n-      auto indexes =\n-          + hb_range (src.rows * class_count)\n-          | hb_filter ([=] (unsigned index) { return klass_mapping->has (index % class_count); })\n-          ;\n-      matrix->serialize_subset (c,\n-                                _.second,\n-                                this,\n-                                src.rows,\n-                                indexes);\n-    }\n-    return_trace (this->len);\n-  }\n-};\n@@ -50,1 +11,2 @@\n-struct MarkLigPosFormat1\n+template <typename Types>\n+struct MarkLigPosFormat1_2\n@@ -54,1 +16,1 @@\n-  Offset16To<Coverage>\n+  typename Types::template OffsetTo<Coverage>\n@@ -57,1 +19,1 @@\n-  Offset16To<Coverage>\n+  typename Types::template OffsetTo<Coverage>\n@@ -62,1 +24,1 @@\n-  Offset16To<MarkArray>\n+  typename Types::template OffsetTo<MarkArray>\n@@ -65,1 +27,1 @@\n-  Offset16To<LigatureArray>\n+  typename Types::template OffsetTo<LigatureArray>\n@@ -69,1 +31,1 @@\n-  DEFINE_SIZE_STATIC (12);\n+  DEFINE_SIZE_STATIC (4 + 4 * Types::size);\n@@ -141,0 +103,1 @@\n+\n@@ -142,1 +105,0 @@\n-    skippy_iter.reset (buffer->idx, 1);\n@@ -144,2 +106,2 @@\n-    unsigned unsafe_from;\n-    if (!skippy_iter.prev (&unsafe_from))\n+\n+    if (c->last_base_until > buffer->idx)\n@@ -147,1 +109,17 @@\n-      buffer->unsafe_to_concat_from_outbuffer (unsafe_from, buffer->idx + 1);\n+      c->last_base_until = 0;\n+      c->last_base = -1;\n+    }\n+    unsigned j;\n+    for (j = buffer->idx; j > c->last_base_until; j--)\n+    {\n+      auto match = skippy_iter.match (buffer->info[j - 1]);\n+      if (match == skippy_iter.MATCH)\n+      {\n+        c->last_base = (signed) j - 1;\n+        break;\n+      }\n+    }\n+    c->last_base_until = buffer->idx;\n+    if (c->last_base == -1)\n+    {\n+      buffer->unsafe_to_concat_from_outbuffer (0, buffer->idx + 1);\n@@ -151,0 +129,2 @@\n+    j = (unsigned) c->last_base;\n+\n@@ -152,1 +132,1 @@\n-    \/\/if (!_hb_glyph_info_is_ligature (&buffer->info[skippy_iter.idx])) { return_trace (false); }\n+    \/\/if (!_hb_glyph_info_is_ligature (&buffer->info[j])) { return_trace (false); }\n@@ -154,1 +134,0 @@\n-    unsigned int j = skippy_iter.idx;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkLigPosFormat1.hh","additions":32,"deletions":53,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -14,2 +14,5 @@\n-  HBUINT16              format;         \/* Format identifier *\/\n-  MarkMarkPosFormat1    format1;\n+  HBUINT16                              format;         \/* Format identifier *\/\n+  MarkMarkPosFormat1_2<SmallTypes>      format1;\n+#ifndef HB_NO_BEYOND_64K\n+  MarkMarkPosFormat1_2<MediumTypes>     format2;\n+#endif\n@@ -22,0 +25,1 @@\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n@@ -23,1 +27,0 @@\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n@@ -26,0 +29,3 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkMarkPos.hh","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -15,1 +15,2 @@\n-struct MarkMarkPosFormat1\n+template <typename Types>\n+struct MarkMarkPosFormat1_2\n@@ -19,1 +20,1 @@\n-  Offset16To<Coverage>\n+  typename Types::template OffsetTo<Coverage>\n@@ -23,1 +24,1 @@\n-  Offset16To<Coverage>\n+  typename Types::template OffsetTo<Coverage>\n@@ -28,1 +29,1 @@\n-  Offset16To<MarkArray>\n+  typename Types::template OffsetTo<MarkArray>\n@@ -31,1 +32,1 @@\n-  Offset16To<Mark2Array>\n+  typename Types::template OffsetTo<Mark2Array>\n@@ -35,1 +36,1 @@\n-  DEFINE_SIZE_STATIC (12);\n+  DEFINE_SIZE_STATIC (4 + 4 * Types::size);\n@@ -103,1 +104,1 @@\n-    skippy_iter.set_lookup_props (c->lookup_props & ~LookupFlag::IgnoreFlags);\n+    skippy_iter.set_lookup_props (c->lookup_props & ~(uint32_t)LookupFlag::IgnoreFlags);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkMarkPosFormat1.hh","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-  protected:\n+  public:\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkRecord.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,3 +15,7 @@\n-  HBUINT16              format;         \/* Format identifier *\/\n-  PairPosFormat1        format1;\n-  PairPosFormat2        format2;\n+  HBUINT16                      format;         \/* Format identifier *\/\n+  PairPosFormat1_3<SmallTypes>  format1;\n+  PairPosFormat2_4<SmallTypes>  format2;\n+#ifndef HB_NO_BEYOND_64K\n+  PairPosFormat1_3<MediumTypes> format3;\n+  PairPosFormat2_4<MediumTypes> format4;\n+#endif\n@@ -24,0 +28,1 @@\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n@@ -25,1 +30,0 @@\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n@@ -29,0 +33,4 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return_trace (c->dispatch (u.format3, std::forward<Ts> (ds)...));\n+    case 4: return_trace (c->dispatch (u.format4, std::forward<Ts> (ds)...));\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/PairPos.hh","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4,0 +4,2 @@\n+#include \"PairSet.hh\"\n+\n@@ -8,79 +10,0 @@\n-struct PairValueRecord\n-{\n-  friend struct PairSet;\n-\n-  int cmp (hb_codepoint_t k) const\n-  { return secondGlyph.cmp (k); }\n-\n-  struct context_t\n-  {\n-    const void          *base;\n-    const ValueFormat   *valueFormats;\n-    const ValueFormat   *newFormats;\n-    unsigned            len1; \/* valueFormats[0].get_len() *\/\n-    const hb_map_t      *glyph_map;\n-    const hb_map_t      *layout_variation_idx_map;\n-  };\n-\n-  bool subset (hb_subset_context_t *c,\n-               context_t *closure) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    auto *s = c->serializer;\n-    auto *out = s->start_embed (*this);\n-    if (unlikely (!s->extend_min (out))) return_trace (false);\n-\n-    out->secondGlyph = (*closure->glyph_map)[secondGlyph];\n-\n-    closure->valueFormats[0].copy_values (s,\n-                                          closure->newFormats[0],\n-                                          closure->base, &values[0],\n-                                          closure->layout_variation_idx_map);\n-    closure->valueFormats[1].copy_values (s,\n-                                          closure->newFormats[1],\n-                                          closure->base,\n-                                          &values[closure->len1],\n-                                          closure->layout_variation_idx_map);\n-\n-    return_trace (true);\n-  }\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c,\n-                                  const ValueFormat *valueFormats,\n-                                  const void *base) const\n-  {\n-    unsigned record1_len = valueFormats[0].get_len ();\n-    unsigned record2_len = valueFormats[1].get_len ();\n-    const hb_array_t<const Value> values_array = values.as_array (record1_len + record2_len);\n-\n-    if (valueFormats[0].has_device ())\n-      valueFormats[0].collect_variation_indices (c, base, values_array.sub_array (0, record1_len));\n-\n-    if (valueFormats[1].has_device ())\n-      valueFormats[1].collect_variation_indices (c, base, values_array.sub_array (record1_len, record2_len));\n-  }\n-\n-  bool intersects (const hb_set_t& glyphset) const\n-  {\n-    return glyphset.has(secondGlyph);\n-  }\n-\n-  const Value* get_values_1 () const\n-  {\n-    return &values[0];\n-  }\n-\n-  const Value* get_values_2 (ValueFormat format1) const\n-  {\n-    return &values[format1.get_len ()];\n-  }\n-\n-  protected:\n-  HBGlyphID16   secondGlyph;            \/* GlyphID of second glyph in the\n-                                         * pair--first glyph is listed in the\n-                                         * Coverage table *\/\n-  ValueRecord   values;                 \/* Positioning data for the first glyph\n-                                         * followed by for second glyph *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (2, values);\n-};\n@@ -88,1 +11,2 @@\n-struct PairSet\n+template <typename Types>\n+struct PairPosFormat1_3\n@@ -90,141 +14,2 @@\n-  friend struct PairPosFormat1;\n-\n-  bool intersects (const hb_set_t *glyphs,\n-                   const ValueFormat *valueFormats) const\n-  {\n-    unsigned int len1 = valueFormats[0].get_len ();\n-    unsigned int len2 = valueFormats[1].get_len ();\n-    unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);\n-\n-    const PairValueRecord *record = &firstPairValueRecord;\n-    unsigned int count = len;\n-    for (unsigned int i = 0; i < count; i++)\n-    {\n-      if (glyphs->has (record->secondGlyph))\n-        return true;\n-      record = &StructAtOffset<const PairValueRecord> (record, record_size);\n-    }\n-    return false;\n-  }\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c,\n-                       const ValueFormat *valueFormats) const\n-  {\n-    unsigned int len1 = valueFormats[0].get_len ();\n-    unsigned int len2 = valueFormats[1].get_len ();\n-    unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);\n-\n-    const PairValueRecord *record = &firstPairValueRecord;\n-    c->input->add_array (&record->secondGlyph, len, record_size);\n-  }\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c,\n-                                  const ValueFormat *valueFormats) const\n-  {\n-    unsigned len1 = valueFormats[0].get_len ();\n-    unsigned len2 = valueFormats[1].get_len ();\n-    unsigned record_size = HBUINT16::static_size * (1 + len1 + len2);\n-\n-    const PairValueRecord *record = &firstPairValueRecord;\n-    unsigned count = len;\n-    for (unsigned i = 0; i < count; i++)\n-    {\n-      if (c->glyph_set->has (record->secondGlyph))\n-      { record->collect_variation_indices (c, valueFormats, this); }\n-\n-      record = &StructAtOffset<const PairValueRecord> (record, record_size);\n-    }\n-  }\n-\n-  bool apply (hb_ot_apply_context_t *c,\n-              const ValueFormat *valueFormats,\n-              unsigned int pos) const\n-  {\n-    TRACE_APPLY (this);\n-    hb_buffer_t *buffer = c->buffer;\n-    unsigned int len1 = valueFormats[0].get_len ();\n-    unsigned int len2 = valueFormats[1].get_len ();\n-    unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);\n-\n-    const PairValueRecord *record = hb_bsearch (buffer->info[pos].codepoint,\n-                                                &firstPairValueRecord,\n-                                                len,\n-                                                record_size);\n-    if (record)\n-    {\n-      bool applied_first = valueFormats[0].apply_value (c, this, &record->values[0], buffer->cur_pos());\n-      bool applied_second = valueFormats[1].apply_value (c, this, &record->values[len1], buffer->pos[pos]);\n-      if (applied_first || applied_second)\n-        buffer->unsafe_to_break (buffer->idx, pos + 1);\n-      if (len2)\n-        pos++;\n-      buffer->idx = pos;\n-      return_trace (true);\n-    }\n-    buffer->unsafe_to_concat (buffer->idx, pos + 1);\n-    return_trace (false);\n-  }\n-\n-  bool subset (hb_subset_context_t *c,\n-               const ValueFormat valueFormats[2],\n-               const ValueFormat newFormats[2]) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto snap = c->serializer->snapshot ();\n-\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-    out->len = 0;\n-\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    unsigned len1 = valueFormats[0].get_len ();\n-    unsigned len2 = valueFormats[1].get_len ();\n-    unsigned record_size = HBUINT16::static_size + Value::static_size * (len1 + len2);\n-\n-    PairValueRecord::context_t context =\n-    {\n-      this,\n-      valueFormats,\n-      newFormats,\n-      len1,\n-      &glyph_map,\n-      c->plan->layout_variation_idx_map\n-    };\n-\n-    const PairValueRecord *record = &firstPairValueRecord;\n-    unsigned count = len, num = 0;\n-    for (unsigned i = 0; i < count; i++)\n-    {\n-      if (glyphset.has (record->secondGlyph)\n-         && record->subset (c, &context)) num++;\n-      record = &StructAtOffset<const PairValueRecord> (record, record_size);\n-    }\n-\n-    out->len = num;\n-    if (!num) c->serializer->revert (snap);\n-    return_trace (num);\n-  }\n-\n-  struct sanitize_closure_t\n-  {\n-    const ValueFormat *valueFormats;\n-    unsigned int len1; \/* valueFormats[0].get_len() *\/\n-    unsigned int stride; \/* 1 + len1 + len2 *\/\n-  };\n-\n-  bool sanitize (hb_sanitize_context_t *c, const sanitize_closure_t *closure) const\n-  {\n-    TRACE_SANITIZE (this);\n-    if (!(c->check_struct (this)\n-       && c->check_range (&firstPairValueRecord,\n-                          len,\n-                          HBUINT16::static_size,\n-                          closure->stride))) return_trace (false);\n-\n-    unsigned int count = len;\n-    const PairValueRecord *record = &firstPairValueRecord;\n-    return_trace (closure->valueFormats[0].sanitize_values_stride_unsafe (c, this, &record->values[0], count, closure->stride) &&\n-                  closure->valueFormats[1].sanitize_values_stride_unsafe (c, this, &record->values[closure->len1], count, closure->stride));\n-  }\n+  using PairSet = GPOS_impl::PairSet<Types>;\n+  using PairValueRecord = GPOS_impl::PairValueRecord<Types>;\n@@ -232,11 +17,0 @@\n-  protected:\n-  HBUINT16              len;    \/* Number of PairValueRecords *\/\n-  PairValueRecord       firstPairValueRecord;\n-                                \/* Array of PairValueRecords--ordered\n-                                 * by GlyphID of the second glyph *\/\n-  public:\n-  DEFINE_SIZE_MIN (2);\n-};\n-\n-struct PairPosFormat1\n-{\n@@ -245,1 +19,1 @@\n-  Offset16To<Coverage>\n+  typename Types::template OffsetTo<Coverage>\n@@ -254,1 +28,1 @@\n-  Array16OfOffset16To<PairSet>\n+  Array16Of<typename Types::template OffsetTo<PairSet>>\n@@ -258,1 +32,1 @@\n-  DEFINE_SIZE_ARRAY (10, pairSet);\n+  DEFINE_SIZE_ARRAY (8 + Types::size, pairSet);\n@@ -268,1 +42,1 @@\n-    PairSet::sanitize_closure_t closure =\n+    typename PairSet::sanitize_closure_t closure =\n@@ -272,1 +46,1 @@\n-      1 + len1 + len2\n+      PairSet::get_size (len1, len2)\n@@ -278,1 +52,0 @@\n-\n@@ -281,0 +54,13 @@\n+    auto &cov = this+coverage;\n+\n+    if (pairSet.len > glyphs->get_population () * hb_bit_storage ((unsigned) pairSet.len) \/ 4)\n+    {\n+      for (hb_codepoint_t g = HB_SET_VALUE_INVALID; glyphs->next (&g);)\n+      {\n+        unsigned i = cov.get_coverage (g);\n+        if ((this+pairSet[i]).intersects (glyphs, valueFormat))\n+          return true;\n+      }\n+      return false;\n+    }\n+\n@@ -282,1 +68,1 @@\n-    + hb_zip (this+coverage, pairSet)\n+    + hb_zip (cov, pairSet)\n@@ -285,1 +71,1 @@\n-    | hb_map ([glyphs, this] (const Offset16To<PairSet> &_)\n+    | hb_map ([glyphs, this] (const typename Types::template OffsetTo<PairSet> &_)\n@@ -357,0 +143,6 @@\n+    if (c->plan->all_axes_pinned)\n+    {\n+      out->valueFormat[0] = out->valueFormat[0].drop_device_table_flags ();\n+      out->valueFormat[1] = out->valueFormat[1].drop_device_table_flags ();\n+    }\n+\n@@ -361,1 +153,1 @@\n-    | hb_filter ([this, c, out] (const Offset16To<PairSet>& _)\n+    | hb_filter ([this, c, out] (const typename Types::template OffsetTo<PairSet>& _)\n@@ -388,3 +180,1 @@\n-    unsigned len1 = valueFormat[0].get_len ();\n-    unsigned len2 = valueFormat[1].get_len ();\n-    unsigned record_size = HBUINT16::static_size + Value::static_size * (len1 + len2);\n+    unsigned record_size = PairSet::get_size (valueFormat);\n@@ -394,2 +184,5 @@\n-    for (const Offset16To<PairSet>& _ :\n-             + hb_zip (this+coverage, pairSet) | hb_filter (glyphset, hb_first) | hb_map (hb_second))\n+    for (const auto & _ :\n+          + hb_zip (this+coverage, pairSet)\n+          | hb_filter (glyphset, hb_first)\n+          | hb_map (hb_second)\n+        )\n@@ -400,1 +193,2 @@\n-      for (unsigned i = 0; i < set.len; i++)\n+      unsigned count = set.len;\n+      for (unsigned i = 0; i < count; i++)\n@@ -409,0 +203,3 @@\n+\n+      if (format1 == valueFormat[0] && format2 == valueFormat[1])\n+        break;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/PairPosFormat1.hh","additions":44,"deletions":247,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -10,1 +10,2 @@\n-struct PairPosFormat2\n+template <typename Types>\n+struct PairPosFormat2_4\n@@ -14,1 +15,1 @@\n-  Offset16To<Coverage>\n+  typename Types::template OffsetTo<Coverage>\n@@ -23,1 +24,1 @@\n-  Offset16To<ClassDef>\n+  typename Types::template OffsetTo<ClassDef>\n@@ -27,1 +28,1 @@\n-  Offset16To<ClassDef>\n+  typename Types::template OffsetTo<ClassDef>\n@@ -39,1 +40,1 @@\n-  DEFINE_SIZE_ARRAY (16, values);\n+  DEFINE_SIZE_ARRAY (10 + 3 * Types::size, values);\n@@ -51,1 +52,1 @@\n-    unsigned int stride = len1 + len2;\n+    unsigned int stride = HBUINT16::static_size * (len1 + len2);\n@@ -219,0 +220,6 @@\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->message (c->font,\n+                          \"try kerning glyphs at %u,%u\",\n+                          c->buffer->idx, skippy_iter.idx);\n+    }\n@@ -223,0 +230,15 @@\n+    if (applied_first || applied_second)\n+      if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+      {\n+        c->buffer->message (c->font,\n+                            \"kerned glyphs at %u,%u\",\n+                            c->buffer->idx, skippy_iter.idx);\n+      }\n+\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->message (c->font,\n+                          \"tried kerning glyphs at %u,%u\",\n+                          c->buffer->idx, skippy_iter.idx);\n+    }\n+\n@@ -230,0 +252,7 @@\n+    if (len2)\n+    {\n+      skippy_iter.idx++;\n+      \/\/ https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/3824\n+      \/\/ https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/3888#issuecomment-1326781116\n+      buffer->unsafe_to_break (buffer->idx, skippy_iter.idx + 1);\n+    }\n@@ -232,2 +261,0 @@\n-    if (len2)\n-      buffer->idx++;\n@@ -263,0 +290,6 @@\n+    if (c->plan->all_axes_pinned)\n+    {\n+      out->valueFormat1 = out->valueFormat1.drop_device_table_flags ();\n+      out->valueFormat2 = out->valueFormat2.drop_device_table_flags ();\n+    }\n+\n@@ -268,2 +301,2 @@\n-        valueFormat1.copy_values (c->serializer, newFormats.first, this, &values[idx], c->plan->layout_variation_idx_map);\n-        valueFormat2.copy_values (c->serializer, newFormats.second, this, &values[idx + len1], c->plan->layout_variation_idx_map);\n+        valueFormat1.copy_values (c->serializer, out->valueFormat1, this, &values[idx], &c->plan->layout_variation_idx_delta_map);\n+        valueFormat2.copy_values (c->serializer, out->valueFormat2, this, &values[idx + len1], &c->plan->layout_variation_idx_delta_map);\n@@ -292,0 +325,1 @@\n+    unsigned record_size = len1 + len2;\n@@ -300,1 +334,1 @@\n-        unsigned idx = (class1_idx * (unsigned) class2Count + class2_idx) * (len1 + len2);\n+        unsigned idx = (class1_idx * (unsigned) class2Count + class2_idx) * record_size;\n@@ -304,0 +338,3 @@\n+\n+      if (format1 == valueFormat1 && format2 == valueFormat2)\n+        break;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/PairPosFormat2.hh","additions":48,"deletions":11,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,207 @@\n+#ifndef OT_LAYOUT_GPOS_PAIRSET_HH\n+#define OT_LAYOUT_GPOS_PAIRSET_HH\n+\n+#include \"PairValueRecord.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+\n+template <typename Types>\n+struct PairSet\n+{\n+  template <typename Types2>\n+  friend struct PairPosFormat1_3;\n+\n+  using PairValueRecord = GPOS_impl::PairValueRecord<Types>;\n+\n+  protected:\n+  HBUINT16              len;    \/* Number of PairValueRecords *\/\n+  PairValueRecord       firstPairValueRecord;\n+                                \/* Array of PairValueRecords--ordered\n+                                 * by GlyphID of the second glyph *\/\n+  public:\n+  DEFINE_SIZE_MIN (2);\n+\n+  static unsigned get_size (unsigned len1, unsigned len2)\n+  {\n+    return Types::HBGlyphID::static_size + Value::static_size * (len1 + len2);\n+  }\n+  static unsigned get_size (const ValueFormat valueFormats[2])\n+  {\n+    unsigned len1 = valueFormats[0].get_len ();\n+    unsigned len2 = valueFormats[1].get_len ();\n+    return get_size (len1, len2);\n+  }\n+\n+  struct sanitize_closure_t\n+  {\n+    const ValueFormat *valueFormats;\n+    unsigned int len1; \/* valueFormats[0].get_len() *\/\n+    unsigned int stride; \/* bytes *\/\n+  };\n+\n+  bool sanitize (hb_sanitize_context_t *c, const sanitize_closure_t *closure) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!(c->check_struct (this)\n+       && c->check_range (&firstPairValueRecord,\n+                          len,\n+                          closure->stride))) return_trace (false);\n+\n+    unsigned int count = len;\n+    const PairValueRecord *record = &firstPairValueRecord;\n+    return_trace (closure->valueFormats[0].sanitize_values_stride_unsafe (c, this, &record->values[0], count, closure->stride) &&\n+                  closure->valueFormats[1].sanitize_values_stride_unsafe (c, this, &record->values[closure->len1], count, closure->stride));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs,\n+                   const ValueFormat *valueFormats) const\n+  {\n+    unsigned record_size = get_size (valueFormats);\n+\n+    const PairValueRecord *record = &firstPairValueRecord;\n+    unsigned int count = len;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (glyphs->has (record->secondGlyph))\n+        return true;\n+      record = &StructAtOffset<const PairValueRecord> (record, record_size);\n+    }\n+    return false;\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c,\n+                       const ValueFormat *valueFormats) const\n+  {\n+    unsigned record_size = get_size (valueFormats);\n+\n+    const PairValueRecord *record = &firstPairValueRecord;\n+    c->input->add_array (&record->secondGlyph, len, record_size);\n+  }\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c,\n+                                  const ValueFormat *valueFormats) const\n+  {\n+    unsigned record_size = get_size (valueFormats);\n+\n+    const PairValueRecord *record = &firstPairValueRecord;\n+    unsigned count = len;\n+    for (unsigned i = 0; i < count; i++)\n+    {\n+      if (c->glyph_set->has (record->secondGlyph))\n+      { record->collect_variation_indices (c, valueFormats, this); }\n+\n+      record = &StructAtOffset<const PairValueRecord> (record, record_size);\n+    }\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c,\n+              const ValueFormat *valueFormats,\n+              unsigned int pos) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    unsigned int len1 = valueFormats[0].get_len ();\n+    unsigned int len2 = valueFormats[1].get_len ();\n+    unsigned record_size = get_size (len1, len2);\n+\n+    const PairValueRecord *record = hb_bsearch (buffer->info[pos].codepoint,\n+                                                &firstPairValueRecord,\n+                                                len,\n+                                                record_size);\n+    if (record)\n+    {\n+      if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+      {\n+        c->buffer->message (c->font,\n+                            \"try kerning glyphs at %u,%u\",\n+                            c->buffer->idx, pos);\n+      }\n+\n+      bool applied_first = valueFormats[0].apply_value (c, this, &record->values[0], buffer->cur_pos());\n+      bool applied_second = valueFormats[1].apply_value (c, this, &record->values[len1], buffer->pos[pos]);\n+\n+      if (applied_first || applied_second)\n+        if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+        {\n+          c->buffer->message (c->font,\n+                              \"kerned glyphs at %u,%u\",\n+                              c->buffer->idx, pos);\n+        }\n+\n+      if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+      {\n+        c->buffer->message (c->font,\n+                            \"tried kerning glyphs at %u,%u\",\n+                            c->buffer->idx, pos);\n+      }\n+\n+      if (applied_first || applied_second)\n+        buffer->unsafe_to_break (buffer->idx, pos + 1);\n+\n+      if (len2)\n+      {\n+        pos++;\n+      \/\/ https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/3824\n+      \/\/ https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/3888#issuecomment-1326781116\n+      buffer->unsafe_to_break (buffer->idx, pos + 1);\n+      }\n+\n+      buffer->idx = pos;\n+      return_trace (true);\n+    }\n+    buffer->unsafe_to_concat (buffer->idx, pos + 1);\n+    return_trace (false);\n+  }\n+\n+  bool subset (hb_subset_context_t *c,\n+               const ValueFormat valueFormats[2],\n+               const ValueFormat newFormats[2]) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto snap = c->serializer->snapshot ();\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+    out->len = 0;\n+\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    unsigned len1 = valueFormats[0].get_len ();\n+    unsigned len2 = valueFormats[1].get_len ();\n+    unsigned record_size = get_size (len1, len2);\n+\n+    typename PairValueRecord::context_t context =\n+    {\n+      this,\n+      valueFormats,\n+      newFormats,\n+      len1,\n+      &glyph_map,\n+      &c->plan->layout_variation_idx_delta_map\n+    };\n+\n+    const PairValueRecord *record = &firstPairValueRecord;\n+    unsigned count = len, num = 0;\n+    for (unsigned i = 0; i < count; i++)\n+    {\n+      if (glyphset.has (record->secondGlyph)\n+         && record->subset (c, &context)) num++;\n+      record = &StructAtOffset<const PairValueRecord> (record, record_size);\n+    }\n+\n+    out->len = num;\n+    if (!num) c->serializer->revert (snap);\n+    return_trace (num);\n+  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif  \/\/ OT_LAYOUT_GPOS_PAIRSET_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/PairSet.hh","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+#ifndef OT_LAYOUT_GPOS_PAIRVALUERECORD_HH\n+#define OT_LAYOUT_GPOS_PAIRVALUERECORD_HH\n+\n+#include \"ValueFormat.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+\n+template <typename Types>\n+struct PairValueRecord\n+{\n+  template <typename Types2>\n+  friend struct PairSet;\n+\n+  protected:\n+  typename Types::HBGlyphID\n+                secondGlyph;            \/* GlyphID of second glyph in the\n+                                         * pair--first glyph is listed in the\n+                                         * Coverage table *\/\n+  ValueRecord   values;                 \/* Positioning data for the first glyph\n+                                         * followed by for second glyph *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (Types::size, values);\n+\n+  int cmp (hb_codepoint_t k) const\n+  { return secondGlyph.cmp (k); }\n+\n+  struct context_t\n+  {\n+    const void          *base;\n+    const ValueFormat   *valueFormats;\n+    const ValueFormat   *newFormats;\n+    unsigned            len1; \/* valueFormats[0].get_len() *\/\n+    const hb_map_t      *glyph_map;\n+    const hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> *layout_variation_idx_delta_map;\n+  };\n+\n+  bool subset (hb_subset_context_t *c,\n+               context_t *closure) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    auto *s = c->serializer;\n+    auto *out = s->start_embed (*this);\n+    if (unlikely (!s->extend_min (out))) return_trace (false);\n+\n+    out->secondGlyph = (*closure->glyph_map)[secondGlyph];\n+\n+    closure->valueFormats[0].copy_values (s,\n+                                          closure->newFormats[0],\n+                                          closure->base, &values[0],\n+                                          closure->layout_variation_idx_delta_map);\n+    closure->valueFormats[1].copy_values (s,\n+                                          closure->newFormats[1],\n+                                          closure->base,\n+                                          &values[closure->len1],\n+                                          closure->layout_variation_idx_delta_map);\n+\n+    return_trace (true);\n+  }\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c,\n+                                  const ValueFormat *valueFormats,\n+                                  const void *base) const\n+  {\n+    unsigned record1_len = valueFormats[0].get_len ();\n+    unsigned record2_len = valueFormats[1].get_len ();\n+    const hb_array_t<const Value> values_array = values.as_array (record1_len + record2_len);\n+\n+    if (valueFormats[0].has_device ())\n+      valueFormats[0].collect_variation_indices (c, base, values_array.sub_array (0, record1_len));\n+\n+    if (valueFormats[1].has_device ())\n+      valueFormats[1].collect_variation_indices (c, base, values_array.sub_array (record1_len, record2_len));\n+  }\n+\n+  bool intersects (const hb_set_t& glyphset) const\n+  {\n+    return glyphset.has(secondGlyph);\n+  }\n+\n+  const Value* get_values_1 () const\n+  {\n+    return &values[0];\n+  }\n+\n+  const Value* get_values_2 (ValueFormat format1) const\n+  {\n+    return &values[format1.get_len ()];\n+  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif  \/\/ OT_LAYOUT_GPOS_PAIRVALUERECORD_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/PairValueRecord.hh","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -41,1 +41,2 @@\n-                  const hb_map_t *layout_variation_idx_map)\n+                  const hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> *layout_variation_idx_delta_map,\n+                  bool all_axes_pinned)\n@@ -47,0 +48,3 @@\n+    if (all_axes_pinned)\n+      new_format = new_format.drop_device_table_flags ();\n+\n@@ -48,1 +52,0 @@\n-    {\n@@ -50,2 +53,0 @@\n-      new_format = src->get_value_format ().get_effective_format (+ glyph_val_iter_pairs | hb_map (hb_second));\n-    }\n@@ -59,1 +60,1 @@\n-                                 layout_variation_idx_map);\n+                                 layout_variation_idx_delta_map);\n@@ -65,1 +66,1 @@\n-                                 layout_variation_idx_map);\n+                                 layout_variation_idx_delta_map);\n@@ -74,0 +75,1 @@\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n@@ -75,1 +77,0 @@\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n@@ -90,2 +91,3 @@\n-                     const hb_map_t *layout_variation_idx_map)\n-{ c->start_embed<SinglePos> ()->serialize (c, src, it, layout_variation_idx_map); }\n+                     const hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> *layout_variation_idx_delta_map,\n+                     bool all_axes_pinned)\n+{ c->start_embed<SinglePos> ()->serialize (c, src, it, layout_variation_idx_delta_map, all_axes_pinned); }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/SinglePos.hh","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -42,4 +42,3 @@\n-    auto it =\n-    + hb_iter (this+coverage)\n-    | hb_filter (c->glyph_set)\n-    ;\n+    hb_set_t intersection;\n+    (this+coverage).intersect_set (*c->glyph_set, intersection);\n+    if (!intersection) return;\n@@ -47,1 +46,0 @@\n-    if (!it) return;\n@@ -65,0 +63,7 @@\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->message (c->font,\n+                          \"positioning glyph at %u\",\n+                          c->buffer->idx);\n+    }\n+\n@@ -67,0 +72,7 @@\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->message (c->font,\n+                          \"positioned glyph at %u\",\n+                          c->buffer->idx);\n+    }\n+\n@@ -71,0 +83,18 @@\n+  bool\n+  position_single (hb_font_t           *font,\n+                   hb_direction_t       direction,\n+                   hb_codepoint_t       gid,\n+                   hb_glyph_position_t &pos) const\n+  {\n+    unsigned int index = (this+coverage).get_coverage  (gid);\n+    if (likely (index == NOT_COVERED)) return false;\n+\n+    \/* This is ugly... *\/\n+    hb_buffer_t buffer;\n+    buffer.props.direction = direction;\n+    OT::hb_ot_apply_context_t c (1, font, &buffer);\n+\n+    valueFormat.apply_value (&c, this, values, pos);\n+    return true;\n+  }\n+\n@@ -78,1 +108,1 @@\n-                  const hb_map_t *layout_variation_idx_map)\n+                  const hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> *layout_variation_idx_delta_map)\n@@ -87,1 +117,1 @@\n-      src->get_value_format ().copy_values (c, newFormat, src,  &_, layout_variation_idx_map);\n+      src->get_value_format ().copy_values (c, newFormat, src,  &_, layout_variation_idx_delta_map);\n@@ -107,0 +137,3 @@\n+    hb_set_t intersection;\n+    (this+coverage).intersect_set (glyphset, intersection);\n+\n@@ -108,2 +141,1 @@\n-    + hb_iter (this+coverage)\n-    | hb_filter (glyphset)\n+    + hb_iter (intersection)\n@@ -115,1 +147,1 @@\n-    SinglePos_serialize (c->serializer, this, it, c->plan->layout_variation_idx_map);\n+    SinglePos_serialize (c->serializer, this, it, &c->plan->layout_variation_idx_delta_map, c->plan->all_axes_pinned);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/SinglePosFormat1.hh","additions":42,"deletions":10,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -71,1 +71,8 @@\n-    if (likely (index >= valueCount)) return_trace (false);\n+    if (unlikely (index >= valueCount)) return_trace (false);\n+\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->message (c->font,\n+                          \"positioning glyph at %u\",\n+                          c->buffer->idx);\n+    }\n@@ -77,0 +84,7 @@\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->message (c->font,\n+                          \"positioned glyph at %u\",\n+                          c->buffer->idx);\n+    }\n+\n@@ -81,0 +95,22 @@\n+  bool\n+  position_single (hb_font_t           *font,\n+                   hb_direction_t       direction,\n+                   hb_codepoint_t       gid,\n+                   hb_glyph_position_t &pos) const\n+  {\n+    unsigned int index = (this+coverage).get_coverage  (gid);\n+    if (likely (index == NOT_COVERED)) return false;\n+    if (unlikely (index >= valueCount)) return false;\n+\n+    \/* This is ugly... *\/\n+    hb_buffer_t buffer;\n+    buffer.props.direction = direction;\n+    OT::hb_ot_apply_context_t c (1, font, &buffer);\n+\n+    valueFormat.apply_value (&c, this,\n+                             &values[index * valueFormat.get_len ()],\n+                             pos);\n+    return true;\n+  }\n+\n+\n@@ -88,1 +124,1 @@\n-                  const hb_map_t *layout_variation_idx_map)\n+                  const hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> *layout_variation_idx_delta_map)\n@@ -98,1 +134,1 @@\n-    { src->get_value_format ().copy_values (c, newFormat, src, &_, layout_variation_idx_map); })\n+    { src->get_value_format ().copy_values (c, newFormat, src, &_, layout_variation_idx_delta_map); })\n@@ -130,1 +166,1 @@\n-    SinglePos_serialize (c->serializer, this, it, c->plan->layout_variation_idx_map);\n+    SinglePos_serialize (c->serializer, this, it, &c->plan->layout_variation_idx_delta_map, c->plan->all_axes_pinned);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/SinglePosFormat2.hh","additions":40,"deletions":4,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -62,0 +62,18 @@\n+  hb_vector_t<unsigned> get_device_table_indices () const {\n+    unsigned i = 0;\n+    hb_vector_t<unsigned> result;\n+    unsigned format = *this;\n+\n+    if (format & xPlacement) i++;\n+    if (format & yPlacement) i++;\n+    if (format & xAdvance)   i++;\n+    if (format & yAdvance)   i++;\n+\n+    if (format & xPlaDevice) result.push (i++);\n+    if (format & yPlaDevice) result.push (i++);\n+    if (format & xAdvDevice) result.push (i++);\n+    if (format & yAdvDevice) result.push (i++);\n+\n+    return result;\n+  }\n+\n@@ -148,1 +166,1 @@\n-                    const hb_map_t *layout_variation_idx_map) const\n+                    const hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> *layout_variation_idx_delta_map) const\n@@ -153,4 +171,5 @@\n-    if (format & xPlacement) copy_value (c, new_format, xPlacement, *values++);\n-    if (format & yPlacement) copy_value (c, new_format, yPlacement, *values++);\n-    if (format & xAdvance)   copy_value (c, new_format, xAdvance, *values++);\n-    if (format & yAdvance)   copy_value (c, new_format, yAdvance, *values++);\n+    HBINT16 *x_placement = nullptr, *y_placement = nullptr, *x_adv = nullptr, *y_adv = nullptr;\n+    if (format & xPlacement) x_placement = copy_value (c, new_format, xPlacement, *values++);\n+    if (format & yPlacement) y_placement = copy_value (c, new_format, yPlacement, *values++);\n+    if (format & xAdvance)   x_adv = copy_value (c, new_format, xAdvance, *values++);\n+    if (format & yAdvance)   y_adv = copy_value (c, new_format, yAdvance, *values++);\n@@ -158,4 +177,23 @@\n-    if (format & xPlaDevice) copy_device (c, base, values++, layout_variation_idx_map);\n-    if (format & yPlaDevice) copy_device (c, base, values++, layout_variation_idx_map);\n-    if (format & xAdvDevice) copy_device (c, base, values++, layout_variation_idx_map);\n-    if (format & yAdvDevice) copy_device (c, base, values++, layout_variation_idx_map);\n+    if (format & xPlaDevice)\n+    {\n+      add_delta_to_value (x_placement, base, values, layout_variation_idx_delta_map);\n+      copy_device (c, base, values++, layout_variation_idx_delta_map, new_format, xPlaDevice);\n+    }\n+\n+    if (format & yPlaDevice)\n+    {\n+      add_delta_to_value (y_placement, base, values, layout_variation_idx_delta_map);\n+      copy_device (c, base, values++, layout_variation_idx_delta_map, new_format, yPlaDevice);\n+    }\n+\n+    if (format & xAdvDevice)\n+    {\n+      add_delta_to_value (x_adv, base, values, layout_variation_idx_delta_map);\n+      copy_device (c, base, values++, layout_variation_idx_delta_map, new_format, xAdvDevice);\n+    }\n+\n+    if (format & yAdvDevice)\n+    {\n+      add_delta_to_value (y_adv, base, values, layout_variation_idx_delta_map);\n+      copy_device (c, base, values++, layout_variation_idx_delta_map, new_format, yAdvDevice);\n+    }\n@@ -164,4 +202,4 @@\n-  void copy_value (hb_serialize_context_t *c,\n-                   unsigned int new_format,\n-                   Flags flag,\n-                   Value value) const\n+  HBINT16* copy_value (hb_serialize_context_t *c,\n+                       unsigned int new_format,\n+                       Flags flag,\n+                       Value value) const\n@@ -170,2 +208,2 @@\n-    if (!(new_format & flag)) return;\n-    c->copy (value);\n+    if (!(new_format & flag)) return nullptr;\n+    return reinterpret_cast<HBINT16 *> (c->copy (value));\n@@ -186,1 +224,1 @@\n-      (base + get_device (&(values[i]))).collect_variation_indices (c->layout_variation_indices);\n+      (base + get_device (&(values[i]))).collect_variation_indices (c);\n@@ -192,1 +230,1 @@\n-      (base + get_device (&(values[i]))).collect_variation_indices (c->layout_variation_indices);\n+      (base + get_device (&(values[i]))).collect_variation_indices (c);\n@@ -199,1 +237,1 @@\n-      (base + get_device (&(values[i]))).collect_variation_indices (c->layout_variation_indices);\n+      (base + get_device (&(values[i]))).collect_variation_indices (c);\n@@ -206,1 +244,1 @@\n-      (base + get_device (&(values[i]))).collect_variation_indices (c->layout_variation_indices);\n+      (base + get_device (&(values[i]))).collect_variation_indices (c);\n@@ -211,0 +249,9 @@\n+  unsigned drop_device_table_flags () const\n+  {\n+    unsigned format = *this;\n+    for (unsigned flag = xPlaDevice; flag <= yAdvDevice; flag = flag << 1)\n+      format = format & ~flag;\n+\n+    return format;\n+  }\n+\n@@ -239,0 +286,13 @@\n+  void add_delta_to_value (HBINT16 *value,\n+                           const void *base,\n+                           const Value *src_value,\n+                           const hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> *layout_variation_idx_delta_map) const\n+  {\n+    if (!value) return;\n+    unsigned varidx = (base + get_device (src_value)).get_variation_index ();\n+    hb_pair_t<unsigned, int> *varidx_delta;\n+    if (!layout_variation_idx_delta_map->has (varidx, &varidx_delta)) return;\n+\n+    *value += hb_second (*varidx_delta);\n+  }\n+\n@@ -240,1 +300,3 @@\n-                    const Value *src_value, const hb_map_t *layout_variation_idx_map) const\n+                    const Value *src_value,\n+                    const hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> *layout_variation_idx_delta_map,\n+                    unsigned int new_format, Flags flag) const\n@@ -242,0 +304,3 @@\n+    \/\/ Filter by new format.\n+    if (!(new_format & flag)) return true;\n+\n@@ -249,1 +314,1 @@\n-    if ((base + get_device (src_value)).copy (c, layout_variation_idx_map))\n+    if ((base + get_device (src_value)).copy (c, layout_variation_idx_delta_map))\n@@ -309,1 +374,1 @@\n-      values += stride;\n+      values = &StructAtOffset<const Value> (values, stride);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/ValueFormat.hh","additions":87,"deletions":22,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n@@ -10,0 +10,1 @@\n+template <typename Types>\n@@ -13,1 +14,1 @@\n-  Array16Of<HBGlyphID16>\n+  Array16Of<typename Types::HBGlyphID>\n@@ -59,0 +60,8 @@\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->sync_so_far ();\n+      c->buffer->message (c->font,\n+                          \"replacing glyph at %u (alternate substitution)\",\n+                          c->buffer->idx);\n+    }\n+\n@@ -61,0 +70,7 @@\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->message (c->font,\n+                          \"replaced glyph at %u (alternate substitution)\",\n+                          c->buffer->idx - 1u);\n+    }\n+\n@@ -71,1 +87,1 @@\n-      + alternates.sub_array (start_offset, alternate_count)\n+      + alternates.as_array ().sub_array (start_offset, alternate_count)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/AlternateSet.hh","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n@@ -15,2 +15,5 @@\n-  HBUINT16              format;         \/* Format identifier *\/\n-  AlternateSubstFormat1 format1;\n+  HBUINT16                              format;         \/* Format identifier *\/\n+  AlternateSubstFormat1_2<SmallTypes>   format1;\n+#ifndef HB_NO_BEYOND_64K\n+  AlternateSubstFormat1_2<MediumTypes>  format2;\n+#endif\n@@ -23,0 +26,1 @@\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n@@ -24,1 +28,0 @@\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n@@ -27,0 +30,3 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n+#endif\n@@ -31,0 +37,2 @@\n+  \/* TODO This function is unused and not updated to 24bit GIDs. Should be done by using\n+   * iterators. While at it perhaps using iterator of arrays of hb_codepoint_t instead. *\/\n@@ -45,0 +53,3 @@\n+\n+  \/* TODO subset() should choose format. *\/\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/AlternateSubst.hh","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n@@ -11,1 +11,2 @@\n-struct AlternateSubstFormat1\n+template <typename Types>\n+struct AlternateSubstFormat1_2\n@@ -15,1 +16,1 @@\n-  Offset16To<Coverage>\n+  typename Types::template OffsetTo<Coverage>\n@@ -18,1 +19,1 @@\n-  Array16OfOffset16To<AlternateSet>\n+  Array16Of<typename Types::template OffsetTo<AlternateSet<Types>>>\n@@ -22,1 +23,1 @@\n-  DEFINE_SIZE_ARRAY (6, alternateSet);\n+  DEFINE_SIZE_ARRAY (2 + 2 * Types::size, alternateSet);\n@@ -42,1 +43,1 @@\n-    | hb_apply ([c] (const AlternateSet &_) { _.closure (c); })\n+    | hb_apply ([c] (const AlternateSet<Types> &_) { _.closure (c); })\n@@ -44,1 +45,0 @@\n-\n@@ -55,1 +55,1 @@\n-    | hb_apply ([c] (const AlternateSet &_) { _.collect_glyphs (c); })\n+    | hb_apply ([c] (const AlternateSet<Types> &_) { _.collect_glyphs (c); })\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/AlternateSubstFormat1.hh","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/ChainContextSubst.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/Common.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/ContextSubst.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/ExtensionSubst.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n-\/\/ TODO(garretrieger): move to new layout.\n@@ -9,2 +8,0 @@\n-using OT::Layout::GSUB::SubstLookup;\n-\n@@ -12,0 +9,3 @@\n+\n+using Layout::GSUB_impl::SubstLookup;\n+\n@@ -13,1 +13,0 @@\n-namespace GSUB {\n@@ -31,1 +30,1 @@\n-    hb_subset_layout_context_t l (c, tableTag, c->plan->gsub_lookups, c->plan->gsub_langsys, c->plan->gsub_features);\n+    hb_subset_layout_context_t l (c, tableTag);\n@@ -36,1 +35,4 @@\n-  { return GSUBGPOS::sanitize<SubstLookup> (c); }\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (GSUBGPOS::sanitize<SubstLookup> (c));\n+  }\n@@ -50,1 +52,0 @@\n-}\n@@ -53,2 +54,2 @@\n-struct GSUB_accelerator_t : Layout::GSUB::GSUB::accelerator_t {\n-  GSUB_accelerator_t (hb_face_t *face) : Layout::GSUB::GSUB::accelerator_t (face) {}\n+struct GSUB_accelerator_t : Layout::GSUB::accelerator_t {\n+  GSUB_accelerator_t (hb_face_t *face) : Layout::GSUB::accelerator_t (face) {}\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/GSUB.hh","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n@@ -10,0 +10,1 @@\n+template <typename Types>\n@@ -13,2 +14,3 @@\n-  HBGlyphID16   ligGlyph;               \/* GlyphID of ligature to substitute *\/\n-  HeadlessArrayOf<HBGlyphID16>\n+  typename Types::HBGlyphID\n+                ligGlyph;               \/* GlyphID of ligature to substitute *\/\n+  HeadlessArrayOf<typename Types::HBGlyphID>\n@@ -19,1 +21,1 @@\n-  DEFINE_SIZE_ARRAY (4, component);\n+  DEFINE_SIZE_ARRAY (Types::size + 2, component);\n@@ -65,0 +67,9 @@\n+\n+      if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+      {\n+        c->buffer->sync_so_far ();\n+        c->buffer->message (c->font,\n+                            \"replacing glyph at %u (ligature substitution)\",\n+                            c->buffer->idx);\n+      }\n+\n@@ -66,0 +77,8 @@\n+\n+      if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+      {\n+        c->buffer->message (c->font,\n+                            \"replaced glyph at %u (ligature substitution)\",\n+                            c->buffer->idx - 1u);\n+      }\n+\n@@ -86,0 +105,25 @@\n+    unsigned pos = 0;\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      unsigned delta = c->buffer->sync_so_far ();\n+\n+      pos = c->buffer->idx;\n+\n+      char buf[HB_MAX_CONTEXT_LENGTH * 16] = {0};\n+      char *p = buf;\n+\n+      match_end += delta;\n+      for (unsigned i = 0; i < count; i++)\n+      {\n+        match_positions[i] += delta;\n+        if (i)\n+          *p++ = ',';\n+        snprintf (p, sizeof(buf) - (p - buf), \"%u\", match_positions[i]);\n+        p += strlen(p);\n+      }\n+\n+      c->buffer->message (c->font,\n+                          \"ligating glyphs at %s\",\n+                          buf);\n+    }\n+\n@@ -93,0 +137,8 @@\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->sync_so_far ();\n+      c->buffer->message (c->font,\n+                          \"ligated glyph at %u\",\n+                          pos);\n+    }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/Ligature.hh","additions":56,"deletions":4,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n@@ -11,0 +11,1 @@\n+template <typename Types>\n@@ -14,1 +15,1 @@\n-  Array16OfOffset16To<Ligature>\n+  Array16OfOffset16To<Ligature<Types>>\n@@ -31,1 +32,1 @@\n-    | hb_map ([glyphs] (const Ligature &_) { return _.intersects (glyphs); })\n+    | hb_map ([glyphs] (const Ligature<Types> &_) { return _.intersects (glyphs); })\n@@ -40,1 +41,1 @@\n-    | hb_apply ([c] (const Ligature &_) { _.closure (c); })\n+    | hb_apply ([c] (const Ligature<Types> &_) { _.closure (c); })\n@@ -48,1 +49,1 @@\n-    | hb_apply ([c] (const Ligature &_) { _.collect_glyphs (c); })\n+    | hb_apply ([c] (const Ligature<Types> &_) { _.collect_glyphs (c); })\n@@ -57,1 +58,1 @@\n-    | hb_map ([c] (const Ligature &_) { return _.would_apply (c); })\n+    | hb_map ([c] (const Ligature<Types> &_) { return _.would_apply (c); })\n@@ -68,1 +69,1 @@\n-      const Ligature &lig = this+ligature[i];\n+      const auto &lig = this+ligature[i];\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/LigatureSet.hh","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n@@ -15,2 +15,5 @@\n-  HBUINT16              format;         \/* Format identifier *\/\n-  LigatureSubstFormat1  format1;\n+  HBUINT16                              format;         \/* Format identifier *\/\n+  LigatureSubstFormat1_2<SmallTypes>    format1;\n+#ifndef HB_NO_BEYOND_64K\n+  LigatureSubstFormat1_2<MediumTypes>   format2;\n+#endif\n@@ -23,0 +26,1 @@\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n@@ -24,1 +28,0 @@\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n@@ -27,0 +30,3 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n+#endif\n@@ -31,0 +37,3 @@\n+  \/* TODO This function is only used by small GIDs, and not updated to 24bit GIDs. Should\n+   * be done by using iterators. While at it perhaps using iterator of arrays of hb_codepoint_t\n+   * instead. *\/\n@@ -52,0 +61,3 @@\n+\n+  \/* TODO subset() should choose format. *\/\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/LigatureSubst.hh","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n@@ -11,1 +11,2 @@\n-struct LigatureSubstFormat1\n+template <typename Types>\n+struct LigatureSubstFormat1_2\n@@ -15,1 +16,1 @@\n-  Offset16To<Coverage>\n+  typename Types::template OffsetTo<Coverage>\n@@ -18,1 +19,1 @@\n-  Array16OfOffset16To<LigatureSet>\n+  Array16Of<typename Types::template OffsetTo<LigatureSet<Types>>>\n@@ -22,1 +23,1 @@\n-  DEFINE_SIZE_ARRAY (6, ligatureSet);\n+  DEFINE_SIZE_ARRAY (4 + Types::size, ligatureSet);\n@@ -36,1 +37,1 @@\n-    | hb_map ([this, glyphs] (const Offset16To<LigatureSet> &_)\n+    | hb_map ([this, glyphs] (const typename Types::template OffsetTo<LigatureSet<Types>> &_)\n@@ -51,1 +52,1 @@\n-    | hb_apply ([c] (const LigatureSet &_) { _.closure (c); })\n+    | hb_apply ([c] (const LigatureSet<Types> &_) { _.closure (c); })\n@@ -65,1 +66,1 @@\n-    | hb_apply ([c] (const LigatureSet &_) { _.collect_glyphs (c); })\n+    | hb_apply ([c] (const LigatureSet<Types> &_) { _.collect_glyphs (c); })\n@@ -76,1 +77,1 @@\n-    const LigatureSet &lig_set = this+ligatureSet[index];\n+    const auto &lig_set = this+ligatureSet[index];\n@@ -87,1 +88,1 @@\n-    const LigatureSet &lig_set = this+ligatureSet[index];\n+    const auto &lig_set = this+ligatureSet[index];\n@@ -131,1 +132,1 @@\n-    | hb_filter ([&] (const LigatureSet& _) {\n+    | hb_filter ([&] (const LigatureSet<Types>& _) {\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/LigatureSubstFormat1.hh","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n@@ -15,2 +15,5 @@\n-  HBUINT16              format;         \/* Format identifier *\/\n-  MultipleSubstFormat1  format1;\n+  HBUINT16                              format;         \/* Format identifier *\/\n+  MultipleSubstFormat1_2<SmallTypes>    format1;\n+#ifndef HB_NO_BEYOND_64K\n+  MultipleSubstFormat1_2<MediumTypes>   format2;\n+#endif\n@@ -24,0 +27,1 @@\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n@@ -25,1 +29,0 @@\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n@@ -28,0 +31,3 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n+#endif\n@@ -32,0 +38,2 @@\n+  template<typename Iterator,\n+           hb_requires (hb_is_sorted_iterator (Iterator))>\n@@ -33,3 +41,1 @@\n-                  hb_sorted_array_t<const HBGlyphID16> glyphs,\n-                  hb_array_t<const unsigned int> substitute_len_list,\n-                  hb_array_t<const HBGlyphID16> substitute_glyphs_list)\n+                  Iterator it)\n@@ -42,1 +48,1 @@\n-    case 1: return_trace (u.format1.serialize (c, glyphs, substitute_len_list, substitute_glyphs_list));\n+    case 1: return_trace (u.format1.serialize (c, it));\n@@ -46,0 +52,3 @@\n+\n+  \/* TODO subset() should choose format. *\/\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/MultipleSubst.hh","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n@@ -11,1 +11,2 @@\n-struct MultipleSubstFormat1\n+template <typename Types>\n+struct MultipleSubstFormat1_2\n@@ -15,1 +16,1 @@\n-  Offset16To<Coverage>\n+  typename Types::template OffsetTo<Coverage>\n@@ -18,1 +19,1 @@\n-  Array16OfOffset16To<Sequence>\n+  Array16Of<typename Types::template OffsetTo<Sequence<Types>>>\n@@ -22,1 +23,1 @@\n-  DEFINE_SIZE_ARRAY (6, sequence);\n+  DEFINE_SIZE_ARRAY (4 + Types::size, sequence);\n@@ -42,1 +43,1 @@\n-    | hb_apply ([c] (const Sequence &_) { _.closure (c); })\n+    | hb_apply ([c] (const Sequence<Types> &_) { _.closure (c); })\n@@ -54,1 +55,1 @@\n-    | hb_apply ([c] (const Sequence &_) { _.collect_glyphs (c); })\n+    | hb_apply ([c] (const Sequence<Types> &_) { _.collect_glyphs (c); })\n@@ -73,0 +74,2 @@\n+  template<typename Iterator,\n+           hb_requires (hb_is_sorted_iterator (Iterator))>\n@@ -74,3 +77,1 @@\n-                  hb_sorted_array_t<const HBGlyphID16> glyphs,\n-                  hb_array_t<const unsigned int> substitute_len_list,\n-                  hb_array_t<const HBGlyphID16> substitute_glyphs_list)\n+                  Iterator it)\n@@ -79,0 +80,8 @@\n+    auto sequences =\n+      + it\n+      | hb_map (hb_second)\n+      ;\n+    auto glyphs =\n+      + it\n+      | hb_map_retains_sorting (hb_first)\n+      ;\n@@ -80,2 +89,4 @@\n-    if (unlikely (!sequence.serialize (c, glyphs.length))) return_trace (false);\n-    for (unsigned int i = 0; i < glyphs.length; i++)\n+\n+    if (unlikely (!sequence.serialize (c, sequences.length))) return_trace (false);\n+\n+    for (auto& pair : hb_zip (sequences, sequence))\n@@ -83,3 +94,2 @@\n-      unsigned int substitute_len = substitute_len_list[i];\n-      if (unlikely (!sequence[i]\n-                        .serialize_serialize (c, substitute_glyphs_list.sub_array (0, substitute_len))))\n+      if (unlikely (!pair.second\n+                    .serialize_serialize (c, pair.first)))\n@@ -87,1 +97,0 @@\n-      substitute_glyphs_list += substitute_len;\n@@ -89,0 +98,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/MultipleSubstFormat1.hh","additions":26,"deletions":16,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n@@ -23,0 +23,1 @@\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n@@ -24,1 +25,0 @@\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/ReverseChainSingleSubst.hh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n@@ -36,1 +36,1 @@\n-    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (backtrack);\n@@ -39,1 +39,1 @@\n-    const Array16Of<HBGlyphID16> &substitute = StructAfter<Array16Of<HBGlyphID16>> (lookahead);\n+    const auto &substitute = StructAfter<decltype (substituteX)> (lookahead);\n@@ -48,1 +48,1 @@\n-    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (backtrack);\n@@ -72,2 +72,2 @@\n-    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n-    const Array16Of<HBGlyphID16> &substitute = StructAfter<Array16Of<HBGlyphID16>> (lookahead);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (backtrack);\n+    const auto &substitute = StructAfter<decltype (substituteX)> (lookahead);\n@@ -94,1 +94,1 @@\n-    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (backtrack);\n@@ -99,1 +99,1 @@\n-    const Array16Of<HBGlyphID16> &substitute = StructAfter<Array16Of<HBGlyphID16>> (lookahead);\n+    const auto &substitute = StructAfter<decltype (substituteX)> (lookahead);\n@@ -118,2 +118,2 @@\n-    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n-    const Array16Of<HBGlyphID16> &substitute = StructAfter<Array16Of<HBGlyphID16>> (lookahead);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (backtrack);\n+    const auto &substitute = StructAfter<decltype (substituteX)> (lookahead);\n@@ -134,0 +134,8 @@\n+\n+      if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+      {\n+        c->buffer->message (c->font,\n+                            \"replacing glyph at %u (reverse chaining substitution)\",\n+                            c->buffer->idx);\n+      }\n+\n@@ -135,0 +143,8 @@\n+\n+      if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+      {\n+        c->buffer->message (c->font,\n+                            \"replaced glyph at %u (reverse chaining substitution)\",\n+                            c->buffer->idx);\n+      }\n+\n@@ -209,2 +225,2 @@\n-    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n-    const Array16Of<HBGlyphID16> &substitute = StructAfter<Array16Of<HBGlyphID16>> (lookahead);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (backtrack);\n+    const auto &substitute = StructAfter<decltype (substituteX)> (lookahead);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/ReverseChainSingleSubstFormat1.hh","additions":28,"deletions":12,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n@@ -10,0 +10,1 @@\n+template <typename Types>\n@@ -13,1 +14,1 @@\n-  Array16Of<HBGlyphID16>\n+  Array16Of<typename Types::HBGlyphID>\n@@ -42,0 +43,8 @@\n+      if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+      {\n+        c->buffer->sync_so_far ();\n+        c->buffer->message (c->font,\n+                            \"replacing glyph at %u (multiple substitution)\",\n+                            c->buffer->idx);\n+      }\n+\n@@ -43,0 +52,8 @@\n+\n+      if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+      {\n+        c->buffer->message (c->font,\n+                            \"replaced glyph at %u (multiple subtitution)\",\n+                            c->buffer->idx - 1u);\n+      }\n+\n@@ -49,0 +66,8 @@\n+      if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+      {\n+        c->buffer->sync_so_far ();\n+        c->buffer->message (c->font,\n+                            \"deleting glyph at %u (multiple substitution)\",\n+                            c->buffer->idx);\n+      }\n+\n@@ -50,0 +75,9 @@\n+\n+      if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+      {\n+        c->buffer->sync_so_far ();\n+        c->buffer->message (c->font,\n+                            \"deleted glyph at %u (multiple substitution)\",\n+                            c->buffer->idx);\n+      }\n+\n@@ -53,0 +87,8 @@\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->sync_so_far ();\n+      c->buffer->message (c->font,\n+                          \"multiplying glyph at %u\",\n+                          c->buffer->idx);\n+    }\n+\n@@ -67,0 +109,20 @@\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->sync_so_far ();\n+\n+      char buf[HB_MAX_CONTEXT_LENGTH * 16] = {0};\n+      char *p = buf;\n+\n+      for (unsigned i = c->buffer->idx - count; i < c->buffer->idx; i++)\n+      {\n+        if (buf < p)\n+          *p++ = ',';\n+        snprintf (p, sizeof(buf) - (p - buf), \"%u\", i);\n+        p += strlen(p);\n+      }\n+\n+      c->buffer->message (c->font,\n+                          \"multiplied glyphs at %s\",\n+                          buf);\n+    }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/Sequence.hh","additions":64,"deletions":2,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n@@ -16,3 +16,7 @@\n-  HBUINT16              format;         \/* Format identifier *\/\n-  SingleSubstFormat1    format1;\n-  SingleSubstFormat2    format2;\n+  HBUINT16                              format;         \/* Format identifier *\/\n+  SingleSubstFormat1_3<SmallTypes>      format1;\n+  SingleSubstFormat2_4<SmallTypes>      format2;\n+#ifndef HB_NO_BEYOND_64K\n+  SingleSubstFormat1_3<MediumTypes>     format3;\n+  SingleSubstFormat2_4<MediumTypes>     format4;\n+#endif\n@@ -26,0 +30,1 @@\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n@@ -27,1 +32,0 @@\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n@@ -31,0 +35,4 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return_trace (c->dispatch (u.format3, std::forward<Ts> (ds)...));\n+    case 4: return_trace (c->dispatch (u.format4, std::forward<Ts> (ds)...));\n+#endif\n@@ -48,0 +56,12 @@\n+      hb_codepoint_t mask = 0xFFFFu;\n+\n+#ifndef HB_NO_BEYOND_64K\n+       if (+ glyphs\n+           | hb_map_retains_sorting (hb_first)\n+           | hb_filter ([] (hb_codepoint_t gid) { return gid > 0xFFFFu; }))\n+       {\n+         format += 2;\n+         mask = 0xFFFFFFu;\n+       }\n+#endif\n+\n@@ -49,1 +69,1 @@\n-                       { return (unsigned) (_.second - _.first) & 0xFFFF; };\n+                       { return (unsigned) (_.second - _.first) & mask; };\n@@ -51,1 +71,1 @@\n-      if (!hb_all (++(+glyphs), delta, get_delta)) format = 2;\n+      if (!hb_all (++(+glyphs), delta, get_delta)) format += 1;\n@@ -53,0 +73,1 @@\n+\n@@ -60,0 +81,7 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return_trace (u.format3.serialize (c,\n+                                               + glyphs\n+                                               | hb_map_retains_sorting (hb_first),\n+                                               delta));\n+    case 4: return_trace (u.format4.serialize (c, glyphs));\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/SingleSubst.hh","additions":35,"deletions":7,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n@@ -10,1 +10,2 @@\n-struct SingleSubstFormat1\n+template <typename Types>\n+struct SingleSubstFormat1_3\n@@ -14,1 +15,1 @@\n-  Offset16To<Coverage>\n+  typename Types::template OffsetTo<Coverage>\n@@ -17,1 +18,2 @@\n-  HBUINT16      deltaGlyphID;           \/* Add to original GlyphID to get\n+  typename Types::HBUINT\n+                deltaGlyphID;           \/* Add to original GlyphID to get\n@@ -21,1 +23,1 @@\n-  DEFINE_SIZE_STATIC (6);\n+  DEFINE_SIZE_STATIC (2 + 2 * Types::size);\n@@ -29,0 +31,3 @@\n+  hb_codepoint_t get_mask () const\n+  { return (1 << (8 * Types::size)) - 1; }\n+\n@@ -37,5 +42,25 @@\n-    unsigned d = deltaGlyphID;\n-\n-    + hb_iter (this+coverage)\n-    | hb_filter (c->parent_active_glyphs ())\n-    | hb_map ([d] (hb_codepoint_t g) { return (g + d) & 0xFFFFu; })\n+    hb_codepoint_t d = deltaGlyphID;\n+    hb_codepoint_t mask = get_mask ();\n+\n+    \/* Help fuzzer avoid this function as much. *\/\n+    unsigned pop = (this+coverage).get_population ();\n+    if (pop >= mask)\n+      return;\n+\n+    hb_set_t intersection;\n+    (this+coverage).intersect_set (c->parent_active_glyphs (), intersection);\n+\n+    \/* In degenerate fuzzer-found fonts, but not real fonts,\n+     * this table can keep adding new glyphs in each round of closure.\n+     * Refuse to close-over, if it maps glyph range to overlapping range. *\/\n+    hb_codepoint_t min_before = intersection.get_min ();\n+    hb_codepoint_t max_before = intersection.get_max ();\n+    hb_codepoint_t min_after = (min_before + d) & mask;\n+    hb_codepoint_t max_after = (max_before + d) & mask;\n+    if (intersection.get_population () == max_before - min_before + 1 &&\n+        ((min_before <= min_after && min_after <= max_before) ||\n+         (min_before <= max_after && max_after <= max_before)))\n+      return;\n+\n+    + hb_iter (intersection)\n+    | hb_map ([d, mask] (hb_codepoint_t g) { return (g + d) & mask; })\n@@ -44,1 +69,0 @@\n-\n@@ -52,1 +76,3 @@\n-    unsigned d = deltaGlyphID;\n+    hb_codepoint_t d = deltaGlyphID;\n+    hb_codepoint_t mask = get_mask ();\n+\n@@ -54,1 +80,1 @@\n-    | hb_map ([d] (hb_codepoint_t g) { return (g + d) & 0xFFFFu; })\n+    | hb_map ([d, mask] (hb_codepoint_t g) { return (g + d) & mask; })\n@@ -71,3 +97,13 @@\n-    \/* According to the Adobe Annotated OpenType Suite, result is always\n-     * limited to 16bit. *\/\n-    glyph_id = (glyph_id + deltaGlyphID) & 0xFFFFu;\n+    hb_codepoint_t d = deltaGlyphID;\n+    hb_codepoint_t mask = get_mask ();\n+\n+    glyph_id = (glyph_id + d) & mask;\n+\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->sync_so_far ();\n+      c->buffer->message (c->font,\n+                          \"replacing glyph at %u (single substitution)\",\n+                          c->buffer->idx);\n+    }\n+\n@@ -76,0 +112,7 @@\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->message (c->font,\n+                          \"replaced glyph at %u (single substitution)\",\n+                          c->buffer->idx - 1u);\n+    }\n+\n@@ -98,1 +141,5 @@\n-    hb_codepoint_t delta = deltaGlyphID;\n+    hb_codepoint_t d = deltaGlyphID;\n+    hb_codepoint_t mask = get_mask ();\n+\n+    hb_set_t intersection;\n+    (this+coverage).intersect_set (glyphset, intersection);\n@@ -101,3 +148,2 @@\n-    + hb_iter (this+coverage)\n-    | hb_filter (glyphset)\n-    | hb_map_retains_sorting ([&] (hb_codepoint_t g) {\n+    + hb_iter (intersection)\n+    | hb_map_retains_sorting ([d, mask] (hb_codepoint_t g) {\n@@ -105,1 +151,1 @@\n-                                                            (g + delta) & 0xFFFF); })\n+                                                            (g + d) & mask); })\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/SingleSubstFormat1.hh","additions":67,"deletions":21,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n@@ -10,1 +10,2 @@\n-struct SingleSubstFormat2\n+template <typename Types>\n+struct SingleSubstFormat2_4\n@@ -14,1 +15,1 @@\n-  Offset16To<Coverage>\n+  typename Types::template OffsetTo<Coverage>\n@@ -17,1 +18,1 @@\n-  Array16Of<HBGlyphID16>\n+  Array16Of<typename Types::HBGlyphID>\n@@ -22,1 +23,1 @@\n-  DEFINE_SIZE_ARRAY (6, substitute);\n+  DEFINE_SIZE_ARRAY (4 + Types::size, substitute);\n@@ -38,2 +39,18 @@\n-    + hb_zip (this+coverage, substitute)\n-    | hb_filter (c->parent_active_glyphs (), hb_first)\n+    auto &cov = this+coverage;\n+    auto &glyph_set = c->parent_active_glyphs ();\n+\n+    if (substitute.len > glyph_set.get_population () * 4)\n+    {\n+      for (auto g : glyph_set)\n+      {\n+        unsigned i = cov.get_coverage (g);\n+        if (i == NOT_COVERED || i >= substitute.len)\n+          continue;\n+        c->output->add (substitute.arrayZ[i]);\n+      }\n+\n+      return;\n+    }\n+\n+    + hb_zip (cov, substitute)\n+    | hb_filter (glyph_set, hb_first)\n@@ -43,1 +60,0 @@\n-\n@@ -70,0 +86,8 @@\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->sync_so_far ();\n+      c->buffer->message (c->font,\n+                          \"replacing glyph at %u (single substitution)\",\n+                          c->buffer->idx);\n+    }\n+\n@@ -72,0 +96,7 @@\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      c->buffer->message (c->font,\n+                          \"replaced glyph at %u (single substitution)\",\n+                          c->buffer->idx - 1u);\n+    }\n+\n@@ -106,1 +137,1 @@\n-    | hb_map_retains_sorting ([&] (hb_pair_t<hb_codepoint_t, const HBGlyphID16 &> p) -> hb_codepoint_pair_t\n+    | hb_map_retains_sorting ([&] (hb_pair_t<hb_codepoint_t, const typename Types::HBGlyphID &> p) -> hb_codepoint_pair_t\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/SingleSubstFormat2.hh","additions":40,"deletions":9,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n@@ -28,1 +28,1 @@\n-      return reinterpret_cast<const ExtensionSubst &> (get_subtable (0)).is_reverse ();\n+      return get_subtable (0).u.extension.is_reverse ();\n@@ -101,0 +101,5 @@\n+  template<typename Glyphs, typename Substitutes,\n+           hb_requires (hb_is_sorted_source_of (Glyphs,\n+                                                const hb_codepoint_t) &&\n+                        hb_is_source_of (Substitutes,\n+                                         const hb_codepoint_t))>\n@@ -103,2 +108,2 @@\n-                         hb_sorted_array_t<const HBGlyphID16> glyphs,\n-                         hb_array_t<const HBGlyphID16> substitutes)\n+                         Glyphs glyphs,\n+                         Substitutes substitutes)\n@@ -117,5 +122,5 @@\n-  bool serialize_multiple (hb_serialize_context_t *c,\n-                           uint32_t lookup_props,\n-                           hb_sorted_array_t<const HBGlyphID16> glyphs,\n-                           hb_array_t<const unsigned int> substitute_len_list,\n-                           hb_array_t<const HBGlyphID16> substitute_glyphs_list)\n+  template<typename Iterator,\n+           hb_requires (hb_is_sorted_iterator (Iterator))>\n+  bool serialize (hb_serialize_context_t *c,\n+                  uint32_t lookup_props,\n+                  Iterator it)\n@@ -126,4 +131,1 @@\n-        serialize (c,\n-                   glyphs,\n-                   substitute_len_list,\n-                   substitute_glyphs_list))\n+        serialize (c, it))\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/SubstLookup.hh","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -16,1 +16,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/SubstLookupSubTable.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright © 2007,2008,2009  Red Hat, Inc.\n+ * Copyright © 2010,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod, Garret Rieger\n+ *\/\n+\n+#ifndef OT_LAYOUT_TYPES_HH\n+#define OT_LAYOUT_TYPES_HH\n+\n+namespace OT {\n+namespace Layout {\n+\n+struct SmallTypes {\n+  static constexpr unsigned size = 2;\n+  using large_int = uint32_t;\n+  using HBUINT = HBUINT16;\n+  using HBGlyphID = HBGlyphID16;\n+  using Offset = Offset16;\n+  template <typename Type, bool has_null=true>\n+  using OffsetTo = OT::Offset16To<Type, has_null>;\n+  template <typename Type>\n+  using ArrayOf = OT::Array16Of<Type>;\n+  template <typename Type>\n+  using SortedArrayOf = OT::SortedArray16Of<Type>;\n+};\n+\n+struct MediumTypes {\n+  static constexpr unsigned size = 3;\n+  using large_int = uint64_t;\n+  using HBUINT = HBUINT24;\n+  using HBGlyphID = HBGlyphID24;\n+  using Offset = Offset24;\n+  template <typename Type, bool has_null=true>\n+  using OffsetTo = OT::Offset24To<Type, has_null>;\n+  template <typename Type>\n+  using ArrayOf = OT::Array24Of<Type>;\n+  template <typename Type>\n+  using SortedArrayOf = OT::SortedArray24Of<Type>;\n+};\n+\n+}\n+}\n+\n+#endif  \/* OT_LAYOUT_TYPES_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/types.hh","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -6,0 +6,1 @@\n+#include \"composite-iter.hh\"\n@@ -28,1 +29,4 @@\n-    UNSCALED_COMPONENT_OFFSET   = 0x1000\n+    UNSCALED_COMPONENT_OFFSET   = 0x1000,\n+#ifndef HB_NO_BEYOND_64K\n+    GID_IS_24BIT                = 0x2000\n+#endif\n@@ -35,0 +39,4 @@\n+    \/* glyphIndex is 24bit instead of 16bit *\/\n+#ifndef HB_NO_BEYOND_64K\n+    if (flags & GID_IS_24BIT) size += HBGlyphID24::static_size - HBGlyphID16::static_size;\n+#endif\n@@ -63,1 +71,7 @@\n-    const HBUINT8 *p = &StructAfter<const HBUINT8> (glyphIndex);\n+    const auto *p = &StructAfter<const HBUINT8> (flags);\n+#ifndef HB_NO_BEYOND_64K\n+    if (flags & GID_IS_24BIT)\n+      p += HBGlyphID24::static_size;\n+    else\n+#endif\n+      p += HBGlyphID16::static_size;\n@@ -95,0 +109,61 @@\n+  unsigned compile_with_deltas (const contour_point_t &p_delta,\n+                                char *out) const\n+  {\n+    const HBINT8 *p = &StructAfter<const HBINT8> (flags);\n+#ifndef HB_NO_BEYOND_64K\n+    if (flags & GID_IS_24BIT)\n+      p += HBGlyphID24::static_size;\n+    else\n+#endif\n+      p += HBGlyphID16::static_size;\n+\n+    unsigned len = get_size ();\n+    unsigned len_before_val = (const char *)p - (const char *)this;\n+    if (flags & ARG_1_AND_2_ARE_WORDS)\n+    {\n+      \/\/ no overflow, copy and update value with deltas\n+      hb_memcpy (out, this, len);\n+\n+      const HBINT16 *px = reinterpret_cast<const HBINT16 *> (p);\n+      HBINT16 *o = reinterpret_cast<HBINT16 *> (out + len_before_val);\n+      o[0] = px[0] + roundf (p_delta.x);\n+      o[1] = px[1] + roundf (p_delta.y);\n+    }\n+    else\n+    {\n+      int new_x = p[0] + roundf (p_delta.x);\n+      int new_y = p[1] + roundf (p_delta.y);\n+      if (new_x <= 127 && new_x >= -128 &&\n+          new_y <= 127 && new_y >= -128)\n+      {\n+        hb_memcpy (out, this, len);\n+        HBINT8 *o = reinterpret_cast<HBINT8 *> (out + len_before_val);\n+        o[0] = new_x;\n+        o[1] = new_y;\n+      }\n+      else\n+      {\n+        \/\/ int8 overflows after deltas applied\n+        hb_memcpy (out, this, len_before_val);\n+\n+        \/\/update flags\n+        CompositeGlyphRecord *o = reinterpret_cast<CompositeGlyphRecord *> (out);\n+        o->flags = flags | ARG_1_AND_2_ARE_WORDS;\n+        out += len_before_val;\n+\n+        HBINT16 new_value;\n+        new_value = new_x;\n+        hb_memcpy (out, &new_value, HBINT16::static_size);\n+        out += HBINT16::static_size;\n+\n+        new_value = new_y;\n+        hb_memcpy (out, &new_value, HBINT16::static_size);\n+        out += HBINT16::static_size;\n+\n+        hb_memcpy (out, p+2, len - len_before_val - 2);\n+        len += 2;\n+      }\n+    }\n+    return len;\n+  }\n+\n@@ -104,0 +179,7 @@\n+    const auto *p = &StructAfter<const HBINT8> (flags);\n+#ifndef HB_NO_BEYOND_64K\n+    if (flags & GID_IS_24BIT)\n+      p += HBGlyphID24::static_size;\n+    else\n+#endif\n+      p += HBGlyphID16::static_size;\n@@ -105,1 +187,0 @@\n-    const HBINT8 *p = &StructAfter<const HBINT8> (glyphIndex);\n@@ -148,11 +229,1 @@\n-  HBUINT16      flags;\n-  HBGlyphID16   glyphIndex;\n-  public:\n-  DEFINE_SIZE_MIN (4);\n-};\n-\n-struct composite_iter_t : hb_iter_with_fallback_t<composite_iter_t, const CompositeGlyphRecord &>\n-{\n-  typedef const CompositeGlyphRecord *__item_t__;\n-  composite_iter_t (hb_bytes_t glyph_, __item_t__ current_) :\n-      glyph (glyph_), current (nullptr), current_size (0)\n+  hb_codepoint_t get_gid () const\n@@ -160,1 +231,6 @@\n-    set_current (current_);\n+#ifndef HB_NO_BEYOND_64K\n+    if (flags & GID_IS_24BIT)\n+      return StructAfter<const HBGlyphID24> (flags);\n+    else\n+#endif\n+      return StructAfter<const HBGlyphID16> (flags);\n@@ -162,6 +238,1 @@\n-\n-  composite_iter_t () : glyph (hb_bytes_t ()), current (nullptr), current_size (0) {}\n-\n-  item_t __item__ () const { return *current; }\n-  bool __more__ () const { return current; }\n-  void __next__ ()\n+  void set_gid (hb_codepoint_t gid)\n@@ -169,27 +240,7 @@\n-    if (!current->has_more ()) { current = nullptr; return; }\n-\n-    set_current (&StructAtOffset<CompositeGlyphRecord> (current, current_size));\n-  }\n-  composite_iter_t __end__ () const { return composite_iter_t (); }\n-  bool operator != (const composite_iter_t& o) const\n-  { return current != o.current; }\n-\n-\n-  void set_current (__item_t__ current_)\n-  {\n-    if (!glyph.check_range (current_, CompositeGlyphRecord::min_size))\n-    {\n-      current = nullptr;\n-      current_size = 0;\n-      return;\n-    }\n-    unsigned size = current_->get_size ();\n-    if (!glyph.check_range (current_, size))\n-    {\n-      current = nullptr;\n-      current_size = 0;\n-      return;\n-    }\n-\n-    current = current_;\n-    current_size = size;\n+#ifndef HB_NO_BEYOND_64K\n+    if (flags & GID_IS_24BIT)\n+      StructAfter<HBGlyphID24> (flags) = gid;\n+    else\n+#endif\n+      \/* TODO assert? *\/\n+      StructAfter<HBGlyphID16> (flags) = gid;\n@@ -198,4 +249,5 @@\n-  private:\n-  hb_bytes_t glyph;\n-  __item_t__ current;\n-  unsigned current_size;\n+  protected:\n+  HBUINT16      flags;\n+  HBUINT24      pad;\n+  public:\n+  DEFINE_SIZE_MIN (4);\n@@ -204,0 +256,2 @@\n+using composite_iter_t = composite_iter_tmpl<CompositeGlyphRecord>;\n+\n@@ -251,0 +305,57 @@\n+\n+  bool compile_bytes_with_deltas (const hb_bytes_t &source_bytes,\n+                                  const contour_point_vector_t &deltas,\n+                                  hb_bytes_t &dest_bytes \/* OUT *\/)\n+  {\n+    if (source_bytes.length <= GlyphHeader::static_size ||\n+        header.numberOfContours != -1)\n+    {\n+      dest_bytes = hb_bytes_t ();\n+      return true;\n+    }\n+\n+    unsigned source_len = source_bytes.length - GlyphHeader::static_size;\n+\n+    \/* try to allocate more memories than source glyph bytes\n+     * in case that there might be an overflow for int8 value\n+     * and we would need to use int16 instead *\/\n+    char *o = (char *) hb_calloc (source_len + source_len\/2, sizeof (char));\n+    if (unlikely (!o)) return false;\n+\n+    const CompositeGlyphRecord *c = reinterpret_cast<const CompositeGlyphRecord *> (source_bytes.arrayZ + GlyphHeader::static_size);\n+    auto it = composite_iter_t (hb_bytes_t ((const char *)c, source_len), c);\n+\n+    char *p = o;\n+    unsigned i = 0, source_comp_len = 0;\n+    for (const auto &component : it)\n+    {\n+      \/* last 4 points in deltas are phantom points and should not be included *\/\n+      if (i >= deltas.length - 4) return false;\n+\n+      unsigned comp_len = component.get_size ();\n+      if (component.is_anchored ())\n+      {\n+        hb_memcpy (p, &component, comp_len);\n+        p += comp_len;\n+      }\n+      else\n+      {\n+        unsigned new_len = component.compile_with_deltas (deltas[i], p);\n+        p += new_len;\n+      }\n+      i++;\n+      source_comp_len += comp_len;\n+    }\n+\n+    \/\/copy instructions if any\n+    if (source_len > source_comp_len)\n+    {\n+      unsigned instr_len = source_len - source_comp_len;\n+      hb_memcpy (p, (const char *)c + source_comp_len, instr_len);\n+      p += instr_len;\n+    }\n+\n+    unsigned len = p - o;\n+    dest_bytes = hb_bytes_t (o, len);\n+    return true;\n+  }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/CompositeGlyph.hh","additions":163,"deletions":52,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -10,0 +10,2 @@\n+#include \"VarCompositeGlyph.hh\"\n+#include \"coord-setter.hh\"\n@@ -30,1 +32,1 @@\n-  enum glyph_type_t { EMPTY, SIMPLE, COMPOSITE };\n+  enum glyph_type_t { EMPTY, SIMPLE, COMPOSITE, VAR_COMPOSITE };\n@@ -38,0 +40,5 @@\n+  var_composite_iter_t get_var_composite_iterator () const\n+  {\n+    if (type != VAR_COMPOSITE) return var_composite_iter_t ();\n+    return VarCompositeGlyph (*header, bytes).iter ();\n+  }\n@@ -75,0 +82,162 @@\n+  void update_mtx (const hb_subset_plan_t *plan,\n+                   int xMin, int xMax,\n+                   int yMin, int yMax,\n+                   const contour_point_vector_t &all_points) const\n+  {\n+    hb_codepoint_t new_gid = 0;\n+    if (!plan->new_gid_for_old_gid (gid, &new_gid))\n+      return;\n+\n+    if (type != EMPTY)\n+    {\n+      plan->bounds_width_map.set (new_gid, xMax - xMin);\n+      plan->bounds_height_map.set (new_gid, yMax - yMin);\n+    }\n+\n+    unsigned len = all_points.length;\n+    float leftSideX = all_points[len - 4].x;\n+    float rightSideX = all_points[len - 3].x;\n+    float topSideY = all_points[len - 2].y;\n+    float bottomSideY = all_points[len - 1].y;\n+\n+    signed hori_aw = roundf (rightSideX - leftSideX);\n+    if (hori_aw < 0) hori_aw = 0;\n+    int lsb = roundf (xMin - leftSideX);\n+    plan->hmtx_map.set (new_gid, hb_pair ((unsigned) hori_aw, lsb));\n+    \/\/flag value should be computed using non-empty glyphs\n+    if (type != EMPTY && lsb != xMin)\n+      plan->head_maxp_info.allXMinIsLsb = false;\n+\n+    signed vert_aw = roundf (topSideY - bottomSideY);\n+    if (vert_aw < 0) vert_aw = 0;\n+    int tsb = roundf (topSideY - yMax);\n+    plan->vmtx_map.set (new_gid, hb_pair ((unsigned) vert_aw, tsb));\n+  }\n+\n+  bool compile_header_bytes (const hb_subset_plan_t *plan,\n+                             const contour_point_vector_t &all_points,\n+                             hb_bytes_t &dest_bytes \/* OUT *\/) const\n+  {\n+    GlyphHeader *glyph_header = nullptr;\n+    if (!plan->pinned_at_default && type != EMPTY && all_points.length >= 4)\n+    {\n+      glyph_header = (GlyphHeader *) hb_calloc (1, GlyphHeader::static_size);\n+      if (unlikely (!glyph_header)) return false;\n+    }\n+\n+    float xMin = 0, xMax = 0;\n+    float yMin = 0, yMax = 0;\n+    if (all_points.length > 4)\n+    {\n+      xMin = xMax = all_points[0].x;\n+      yMin = yMax = all_points[0].y;\n+    }\n+\n+    for (unsigned i = 1; i < all_points.length - 4; i++)\n+    {\n+      float x = all_points[i].x;\n+      float y = all_points[i].y;\n+      xMin = hb_min (xMin, x);\n+      xMax = hb_max (xMax, x);\n+      yMin = hb_min (yMin, y);\n+      yMax = hb_max (yMax, y);\n+    }\n+\n+    update_mtx (plan, roundf (xMin), roundf (xMax), roundf (yMin), roundf (yMax), all_points);\n+\n+    int rounded_xMin = roundf (xMin);\n+    int rounded_xMax = roundf (xMax);\n+    int rounded_yMin = roundf (yMin);\n+    int rounded_yMax = roundf (yMax);\n+\n+    if (type != EMPTY)\n+    {\n+      plan->head_maxp_info.xMin = hb_min (plan->head_maxp_info.xMin, rounded_xMin);\n+      plan->head_maxp_info.yMin = hb_min (plan->head_maxp_info.yMin, rounded_yMin);\n+      plan->head_maxp_info.xMax = hb_max (plan->head_maxp_info.xMax, rounded_xMax);\n+      plan->head_maxp_info.yMax = hb_max (plan->head_maxp_info.yMax, rounded_yMax);\n+    }\n+\n+    \/* when pinned at default, no need to compile glyph header\n+     * and for empty glyphs: all_points only include phantom points.\n+     * just update metrics and then return *\/\n+    if (!glyph_header)\n+      return true;\n+\n+    glyph_header->numberOfContours = header->numberOfContours;\n+\n+    glyph_header->xMin = rounded_xMin;\n+    glyph_header->yMin = rounded_yMin;\n+    glyph_header->xMax = rounded_xMax;\n+    glyph_header->yMax = rounded_yMax;\n+\n+    dest_bytes = hb_bytes_t ((const char *)glyph_header, GlyphHeader::static_size);\n+    return true;\n+  }\n+\n+  bool compile_bytes_with_deltas (const hb_subset_plan_t *plan,\n+                                  hb_font_t *font,\n+                                  const glyf_accelerator_t &glyf,\n+                                  hb_bytes_t &dest_start,  \/* IN\/OUT *\/\n+                                  hb_bytes_t &dest_end \/* OUT *\/)\n+  {\n+    contour_point_vector_t all_points, deltas;\n+    unsigned composite_contours = 0;\n+    head_maxp_info_t *head_maxp_info_p = &plan->head_maxp_info;\n+    unsigned *composite_contours_p = &composite_contours;\n+\n+    \/\/ don't compute head\/maxp values when glyph has no contours(type is EMPTY)\n+    \/\/ also ignore .notdef glyph when --notdef-outline is not enabled\n+    if (type == EMPTY ||\n+        (gid == 0 && !(plan->flags & HB_SUBSET_FLAGS_NOTDEF_OUTLINE)))\n+    {\n+      head_maxp_info_p = nullptr;\n+      composite_contours_p = nullptr;\n+    }\n+\n+    if (!get_points (font, glyf, all_points, &deltas, head_maxp_info_p, composite_contours_p, false, false))\n+      return false;\n+\n+    \/\/ .notdef, set type to empty so we only update metrics and don't compile bytes for\n+    \/\/ it\n+    if (gid == 0 &&\n+        !(plan->flags & HB_SUBSET_FLAGS_NOTDEF_OUTLINE))\n+    {\n+      type = EMPTY;\n+      dest_start = hb_bytes_t ();\n+      dest_end = hb_bytes_t ();\n+    }\n+\n+    \/\/dont compile bytes when pinned at default, just recalculate bounds\n+    if (!plan->pinned_at_default) {\n+      switch (type) {\n+      case COMPOSITE:\n+        if (!CompositeGlyph (*header, bytes).compile_bytes_with_deltas (dest_start,\n+                                                                        deltas,\n+                                                                        dest_end))\n+          return false;\n+        break;\n+      case SIMPLE:\n+        if (!SimpleGlyph (*header, bytes).compile_bytes_with_deltas (all_points,\n+                                                                     plan->flags & HB_SUBSET_FLAGS_NO_HINTING,\n+                                                                     dest_end))\n+          return false;\n+        break;\n+      default:\n+        \/* set empty bytes for empty glyph\n+         * do not use source glyph's pointers *\/\n+        dest_start = hb_bytes_t ();\n+        dest_end = hb_bytes_t ();\n+        break;\n+      }\n+    }\n+\n+    if (!compile_header_bytes (plan, all_points, dest_start))\n+    {\n+      dest_end.fini ();\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+\n@@ -81,0 +250,5 @@\n+                   contour_point_vector_t *deltas = nullptr, \/* OUT *\/\n+                   head_maxp_info_t * head_maxp_info = nullptr, \/* OUT *\/\n+                   unsigned *composite_contours = nullptr, \/* OUT *\/\n+                   bool shift_points_hori = true,\n+                   bool use_my_metrics = true,\n@@ -82,1 +256,3 @@\n-                   unsigned int depth = 0) const\n+                   hb_array_t<int> coords = hb_array_t<int> (),\n+                   unsigned int depth = 0,\n+                   unsigned *edge_count = nullptr) const\n@@ -85,0 +261,13 @@\n+    unsigned stack_edge_count = 0;\n+    if (!edge_count) edge_count = &stack_edge_count;\n+    if (unlikely (*edge_count > HB_GLYF_MAX_EDGE_COUNT)) return false;\n+    (*edge_count)++;\n+\n+    if (head_maxp_info)\n+    {\n+      head_maxp_info->maxComponentDepth = hb_max (head_maxp_info->maxComponentDepth, depth);\n+    }\n+\n+    if (!coords)\n+      coords = hb_array (font->coords, font->num_coords);\n+\n@@ -91,0 +280,8 @@\n+    case SIMPLE:\n+      if (depth == 0 && head_maxp_info)\n+        head_maxp_info->maxContours = hb_max (head_maxp_info->maxContours, (unsigned) header->numberOfContours);\n+      if (depth > 0 && composite_contours)\n+        *composite_contours += (unsigned) header->numberOfContours;\n+      if (unlikely (!SimpleGlyph (*header, bytes).get_contour_points (points, phantom_only)))\n+        return false;\n+      break;\n@@ -98,3 +295,8 @@\n-    case SIMPLE:\n-      if (unlikely (!SimpleGlyph (*header, bytes).get_contour_points (points, phantom_only)))\n-        return false;\n+#ifndef HB_NO_VAR_COMPOSITES\n+    case VAR_COMPOSITE:\n+    {\n+      for (auto &item : get_var_composite_iterator ())\n+        if (unlikely (!item.get_points (points))) return false;\n+    }\n+#endif\n+    default:\n@@ -106,1 +308,1 @@\n-    hb_array_t<contour_point_t> phantoms = points.sub_array (points.length - PHANTOM_COUNT, PHANTOM_COUNT);\n+    hb_array_t<contour_point_t> phantoms = points.as_array ().sub_array (points.length - PHANTOM_COUNT, PHANTOM_COUNT);\n@@ -108,2 +310,4 @@\n-      int h_delta = (int) header->xMin -\n-                    glyf_accelerator.hmtx->get_side_bearing (gid);\n+      int lsb = 0;\n+      int h_delta = glyf_accelerator.hmtx->get_leading_bearing_without_var_unscaled (gid, &lsb) ?\n+                    (int) header->xMin - lsb : 0;\n+      HB_UNUSED int tsb = 0;\n@@ -112,1 +316,1 @@\n-                    glyf_accelerator.vmtx->get_side_bearing (gid)\n+                    ((void) glyf_accelerator.vmtx->get_leading_bearing_without_var_unscaled (gid, &tsb), tsb)\n@@ -117,1 +321,1 @@\n-      unsigned h_adv = glyf_accelerator.hmtx->get_advance (gid);\n+      unsigned h_adv = glyf_accelerator.hmtx->get_advance_without_var_unscaled (gid);\n@@ -120,1 +324,1 @@\n-                       glyf_accelerator.vmtx->get_advance (gid)\n+                       glyf_accelerator.vmtx->get_advance_without_var_unscaled (gid)\n@@ -131,0 +335,6 @@\n+    if (deltas != nullptr && depth == 0 && type == COMPOSITE)\n+    {\n+      if (unlikely (!deltas->resize (points.length))) return false;\n+      deltas->copy_vector (points);\n+    }\n+\n@@ -132,1 +342,3 @@\n-    glyf_accelerator.gvar->apply_deltas_to_points (gid, font, points.as_array ());\n+    glyf_accelerator.gvar->apply_deltas_to_points (gid,\n+                                                   coords,\n+                                                   points.as_array ());\n@@ -135,0 +347,11 @@\n+    \/\/ mainly used by CompositeGlyph calculating new X\/Y offset value so no need to extend it\n+    \/\/ with child glyphs' points\n+    if (deltas != nullptr && depth == 0 && type == COMPOSITE)\n+    {\n+      for (unsigned i = 0 ; i < points.length; i++)\n+      {\n+        deltas->arrayZ[i].x = points.arrayZ[i].x - deltas->arrayZ[i].x;\n+        deltas->arrayZ[i].y = points.arrayZ[i].y - deltas->arrayZ[i].y;\n+      }\n+    }\n+\n@@ -137,0 +360,2 @@\n+      if (depth == 0 && head_maxp_info)\n+        head_maxp_info->maxPoints = hb_max (head_maxp_info->maxPoints, points.length - 4);\n@@ -147,3 +372,13 @@\n-        if (unlikely (!glyf_accelerator.glyph_for_gid (item.glyphIndex)\n-                                       .get_points (font, glyf_accelerator, comp_points,\n-                                                    phantom_only, depth + 1)))\n+        if (unlikely (!glyf_accelerator.glyph_for_gid (item.get_gid ())\n+                                       .get_points (font,\n+                                                    glyf_accelerator,\n+                                                    comp_points,\n+                                                    deltas,\n+                                                    head_maxp_info,\n+                                                    composite_contours,\n+                                                    shift_points_hori,\n+                                                    use_my_metrics,\n+                                                    phantom_only,\n+                                                    coords,\n+                                                    depth + 1,\n+                                                    edge_count)))\n@@ -153,1 +388,1 @@\n-        if (item.is_use_my_metrics ())\n+        if (use_my_metrics && item.is_use_my_metrics ())\n@@ -177,1 +412,4 @@\n-        all_points.extend (comp_points.sub_array (0, comp_points.length - PHANTOM_COUNT));\n+        all_points.extend (comp_points.as_array ().sub_array (0, comp_points.length - PHANTOM_COUNT));\n+\n+        if (all_points.length > HB_GLYF_MAX_POINTS)\n+          return false;\n@@ -182,0 +420,57 @@\n+      if (head_maxp_info && depth == 0)\n+      {\n+        if (composite_contours)\n+          head_maxp_info->maxCompositeContours = hb_max (head_maxp_info->maxCompositeContours, *composite_contours);\n+        head_maxp_info->maxCompositePoints = hb_max (head_maxp_info->maxCompositePoints, all_points.length);\n+        head_maxp_info->maxComponentElements = hb_max (head_maxp_info->maxComponentElements, comp_index);\n+      }\n+      all_points.extend (phantoms);\n+    } break;\n+#ifndef HB_NO_VAR_COMPOSITES\n+    case VAR_COMPOSITE:\n+    {\n+      contour_point_vector_t comp_points;\n+      hb_array_t<contour_point_t> points_left = points.as_array ();\n+      for (auto &item : get_var_composite_iterator ())\n+      {\n+        hb_array_t<contour_point_t> record_points = points_left.sub_array (0, item.get_num_points ());\n+\n+        comp_points.reset ();\n+\n+        auto component_coords = coords;\n+        if (item.is_reset_unspecified_axes ())\n+          component_coords = hb_array<int> ();\n+\n+        coord_setter_t coord_setter (component_coords);\n+        item.set_variations (coord_setter, record_points);\n+\n+        if (unlikely (!glyf_accelerator.glyph_for_gid (item.get_gid ())\n+                                       .get_points (font,\n+                                                    glyf_accelerator,\n+                                                    comp_points,\n+                                                    deltas,\n+                                                    head_maxp_info,\n+                                                    nullptr,\n+                                                    shift_points_hori,\n+                                                    use_my_metrics,\n+                                                    phantom_only,\n+                                                    coord_setter.get_coords (),\n+                                                    depth + 1,\n+                                                    edge_count)))\n+          return false;\n+\n+        \/* Apply component transformation *\/\n+        item.transform_points (record_points, comp_points);\n+\n+        \/* Copy phantom points from component if USE_MY_METRICS flag set *\/\n+        if (use_my_metrics && item.is_use_my_metrics ())\n+          for (unsigned int i = 0; i < PHANTOM_COUNT; i++)\n+            phantoms[i] = comp_points[comp_points.length - PHANTOM_COUNT + i];\n+\n+        all_points.extend (comp_points.as_array ().sub_array (0, comp_points.length - PHANTOM_COUNT));\n+\n+        if (all_points.length > HB_GLYF_MAX_POINTS)\n+          return false;\n+\n+        points_left += item.get_num_points ();\n+      }\n@@ -184,0 +479,1 @@\n+#endif\n@@ -186,0 +482,1 @@\n+      break;\n@@ -188,1 +485,1 @@\n-    if (depth == 0) \/* Apply at top level *\/\n+    if (depth == 0 && shift_points_hori) \/* Apply at top level *\/\n@@ -201,2 +498,2 @@\n-  bool get_extents (hb_font_t *font, const glyf_accelerator_t &glyf_accelerator,\n-                    hb_glyph_extents_t *extents) const\n+  bool get_extents_without_var_scaled (hb_font_t *font, const glyf_accelerator_t &glyf_accelerator,\n+                                       hb_glyph_extents_t *extents) const\n@@ -205,1 +502,1 @@\n-    return header->get_extents (font, glyf_accelerator, gid, extents);\n+    return header->get_extents_without_var_scaled (font, glyf_accelerator, gid, extents);\n@@ -210,4 +507,10 @@\n-  Glyph (hb_bytes_t bytes_ = hb_bytes_t (),\n-         hb_codepoint_t gid_ = (hb_codepoint_t) -1) : bytes (bytes_),\n-                                                      header (bytes.as<GlyphHeader> ()),\n-                                                      gid (gid_)\n+  Glyph () : bytes (),\n+             header (bytes.as<GlyphHeader> ()),\n+             gid (-1),\n+             type(EMPTY)\n+  {}\n+\n+  Glyph (hb_bytes_t bytes_,\n+         hb_codepoint_t gid_ = (unsigned) -1) : bytes (bytes_),\n+                                                header (bytes.as<GlyphHeader> ()),\n+                                                gid (gid_)\n@@ -218,0 +521,1 @@\n+    else if (num_contours == -2) type = VAR_COMPOSITE;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/Glyph.hh","additions":329,"deletions":25,"binary":false,"changes":354,"status":"modified"},{"patch":"@@ -17,2 +17,2 @@\n-  bool get_extents (hb_font_t *font, const accelerator_t &glyf_accelerator,\n-                    hb_codepoint_t gid, hb_glyph_extents_t *extents) const\n+  bool get_extents_without_var_scaled (hb_font_t *font, const accelerator_t &glyf_accelerator,\n+                                       hb_codepoint_t gid, hb_glyph_extents_t *extents) const\n@@ -22,4 +22,8 @@\n-    extents->x_bearing = font->em_scale_x (glyf_accelerator.hmtx->get_side_bearing (gid));\n-    extents->y_bearing = font->em_scale_y (hb_max (yMin, yMax));\n-    extents->width     = font->em_scale_x (hb_max (xMin, xMax) - hb_min (xMin, xMax));\n-    extents->height    = font->em_scale_y (hb_min (yMin, yMax) - hb_max (yMin, yMax));\n+    int lsb = hb_min (xMin, xMax);\n+    (void) glyf_accelerator.hmtx->get_leading_bearing_without_var_unscaled (gid, &lsb);\n+    extents->x_bearing = lsb;\n+    extents->y_bearing = hb_max (yMin, yMax);\n+    extents->width     = hb_max (xMin, xMax) - hb_min (xMin, xMax);\n+    extents->height    = hb_min (yMin, yMax) - hb_max (yMin, yMax);\n+\n+    font->scale_glyph_extents (extents);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/GlyphHeader.hh","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-    FLAG_RESERVED2      = 0x80\n+    FLAG_CUBIC          = 0x80\n@@ -135,2 +135,2 @@\n-        for (; i < stop;)\n-          points_.arrayZ[i++].flag = flag;\n+        for (; i < stop; i++)\n+          points_.arrayZ[i].flag = flag;\n@@ -187,1 +187,1 @@\n-    points_.alloc (num_points + 4); \/\/ Allocate for phantom points, to avoid a possible copy\n+    points_.alloc (num_points + 4, true); \/\/ Allocate for phantom points, to avoid a possible copy\n@@ -209,0 +209,123 @@\n+\n+  static void encode_coord (int value,\n+                            uint8_t &flag,\n+                            const simple_glyph_flag_t short_flag,\n+                            const simple_glyph_flag_t same_flag,\n+                            hb_vector_t<uint8_t> &coords \/* OUT *\/)\n+  {\n+    if (value == 0)\n+    {\n+      flag |= same_flag;\n+    }\n+    else if (value >= -255 && value <= 255)\n+    {\n+      flag |= short_flag;\n+      if (value > 0) flag |= same_flag;\n+      else value = -value;\n+\n+      coords.arrayZ[coords.length++] = (uint8_t) value;\n+    }\n+    else\n+    {\n+      int16_t val = value;\n+      coords.arrayZ[coords.length++] = val >> 8;\n+      coords.arrayZ[coords.length++] = val & 0xff;\n+    }\n+  }\n+\n+  static void encode_flag (uint8_t &flag,\n+                           uint8_t &repeat,\n+                           uint8_t lastflag,\n+                           hb_vector_t<uint8_t> &flags \/* OUT *\/)\n+  {\n+    if (flag == lastflag && repeat != 255)\n+    {\n+      repeat++;\n+      if (repeat == 1)\n+      {\n+        \/* We know there's room. *\/\n+        flags.arrayZ[flags.length++] = flag;\n+      }\n+      else\n+      {\n+        unsigned len = flags.length;\n+        flags.arrayZ[len-2] = flag | FLAG_REPEAT;\n+        flags.arrayZ[len-1] = repeat;\n+      }\n+    }\n+    else\n+    {\n+      repeat = 0;\n+      flags.push (flag);\n+    }\n+  }\n+\n+  bool compile_bytes_with_deltas (const contour_point_vector_t &all_points,\n+                                  bool no_hinting,\n+                                  hb_bytes_t &dest_bytes \/* OUT *\/)\n+  {\n+    if (header.numberOfContours == 0 || all_points.length <= 4)\n+    {\n+      dest_bytes = hb_bytes_t ();\n+      return true;\n+    }\n+    unsigned num_points = all_points.length - 4;\n+\n+    hb_vector_t<uint8_t> flags, x_coords, y_coords;\n+    if (unlikely (!flags.alloc (num_points, true))) return false;\n+    if (unlikely (!x_coords.alloc (2*num_points, true))) return false;\n+    if (unlikely (!y_coords.alloc (2*num_points, true))) return false;\n+\n+    uint8_t lastflag = 255, repeat = 0;\n+    int prev_x = 0, prev_y = 0;\n+\n+    for (unsigned i = 0; i < num_points; i++)\n+    {\n+      uint8_t flag = all_points.arrayZ[i].flag;\n+      flag &= FLAG_ON_CURVE + FLAG_OVERLAP_SIMPLE;\n+\n+      int cur_x = roundf (all_points.arrayZ[i].x);\n+      int cur_y = roundf (all_points.arrayZ[i].y);\n+      encode_coord (cur_x - prev_x, flag, FLAG_X_SHORT, FLAG_X_SAME, x_coords);\n+      encode_coord (cur_y - prev_y, flag, FLAG_Y_SHORT, FLAG_Y_SAME, y_coords);\n+      encode_flag (flag, repeat, lastflag, flags);\n+\n+      prev_x = cur_x;\n+      prev_y = cur_y;\n+      lastflag = flag;\n+    }\n+\n+    unsigned len_before_instrs = 2 * header.numberOfContours + 2;\n+    unsigned len_instrs = instructions_length ();\n+    unsigned total_len = len_before_instrs + flags.length + x_coords.length + y_coords.length;\n+\n+    if (!no_hinting)\n+      total_len += len_instrs;\n+\n+    char *p = (char *) hb_malloc (total_len);\n+    if (unlikely (!p)) return false;\n+\n+    const char *src = bytes.arrayZ + GlyphHeader::static_size;\n+    char *cur = p;\n+    hb_memcpy (p, src, len_before_instrs);\n+\n+    cur += len_before_instrs;\n+    src += len_before_instrs;\n+\n+    if (!no_hinting)\n+    {\n+      hb_memcpy (cur, src, len_instrs);\n+      cur += len_instrs;\n+    }\n+\n+    hb_memcpy (cur, flags.arrayZ, flags.length);\n+    cur += flags.length;\n+\n+    hb_memcpy (cur, x_coords.arrayZ, x_coords.length);\n+    cur += x_coords.length;\n+\n+    hb_memcpy (cur, y_coords.arrayZ, y_coords.length);\n+\n+    dest_bytes = hb_bytes_t (p, total_len);\n+    return true;\n+  }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/SimpleGlyph.hh","additions":127,"deletions":4,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -9,0 +9,3 @@\n+\n+struct glyf_accelerator_t;\n+\n@@ -14,1 +17,0 @@\n-  hb_codepoint_t new_gid;\n@@ -22,1 +24,1 @@\n-                  const hb_subset_plan_t *plan) const\n+                  const hb_subset_plan_t *plan)\n@@ -29,1 +31,1 @@\n-    DEBUG_MSG (SUBSET, nullptr, \"serialize %d byte glyph, width %d pad %d\", dest_glyph.length, dest_glyph.length + pad_length, pad_length);\n+    DEBUG_MSG (SUBSET, nullptr, \"serialize %u byte glyph, width %u pad %u\", dest_glyph.length, dest_glyph.length + pad_length, pad_length);\n@@ -45,2 +47,2 @@\n-      if (plan->new_gid_for_old_gid (_.glyphIndex, &new_gid))\n-        const_cast<CompositeGlyphRecord &> (_).glyphIndex = new_gid;\n+      if (plan->new_gid_for_old_gid (_.get_gid(), &new_gid))\n+        const_cast<CompositeGlyphRecord &> (_).set_gid (new_gid);\n@@ -58,0 +60,11 @@\n+  bool compile_bytes_with_deltas (const hb_subset_plan_t *plan,\n+                                  hb_font_t *font,\n+                                  const glyf_accelerator_t &glyf)\n+  { return source_glyph.compile_bytes_with_deltas (plan, font, glyf, dest_start, dest_end); }\n+\n+  void free_compiled_bytes ()\n+  {\n+    dest_start.fini ();\n+    dest_end.fini ();\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/SubsetGlyph.hh","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,354 @@\n+#ifndef OT_GLYF_VARCOMPOSITEGLYPH_HH\n+#define OT_GLYF_VARCOMPOSITEGLYPH_HH\n+\n+\n+#include \"..\/..\/hb-open-type.hh\"\n+#include \"coord-setter.hh\"\n+\n+\n+namespace OT {\n+namespace glyf_impl {\n+\n+\n+struct VarCompositeGlyphRecord\n+{\n+  protected:\n+  enum var_composite_glyph_flag_t\n+  {\n+    USE_MY_METRICS              = 0x0001,\n+    AXIS_INDICES_ARE_SHORT      = 0x0002,\n+    UNIFORM_SCALE               = 0x0004,\n+    HAVE_TRANSLATE_X            = 0x0008,\n+    HAVE_TRANSLATE_Y            = 0x0010,\n+    HAVE_ROTATION               = 0x0020,\n+    HAVE_SCALE_X                = 0x0040,\n+    HAVE_SCALE_Y                = 0x0080,\n+    HAVE_SKEW_X                 = 0x0100,\n+    HAVE_SKEW_Y                 = 0x0200,\n+    HAVE_TCENTER_X              = 0x0400,\n+    HAVE_TCENTER_Y              = 0x0800,\n+    GID_IS_24                   = 0x1000,\n+    AXES_HAVE_VARIATION         = 0x2000,\n+    RESET_UNSPECIFIED_AXES      = 0x4000,\n+  };\n+\n+  public:\n+\n+  unsigned int get_size () const\n+  {\n+    unsigned int size = min_size;\n+\n+    unsigned axis_width = (flags & AXIS_INDICES_ARE_SHORT) ? 4 : 3;\n+    size += numAxes * axis_width;\n+\n+    \/\/ gid\n+    size += 2;\n+    if (flags & GID_IS_24)              size += 1;\n+\n+    if (flags & HAVE_TRANSLATE_X)       size += 2;\n+    if (flags & HAVE_TRANSLATE_Y)       size += 2;\n+    if (flags & HAVE_ROTATION)          size += 2;\n+    if (flags & HAVE_SCALE_X)           size += 2;\n+    if (flags & HAVE_SCALE_Y)           size += 2;\n+    if (flags & HAVE_SKEW_X)            size += 2;\n+    if (flags & HAVE_SKEW_Y)            size += 2;\n+    if (flags & HAVE_TCENTER_X)         size += 2;\n+    if (flags & HAVE_TCENTER_Y)         size += 2;\n+\n+    return size;\n+  }\n+\n+  bool has_more () const { return true; }\n+\n+  bool is_use_my_metrics () const { return flags & USE_MY_METRICS; }\n+  bool is_reset_unspecified_axes () const { return flags & RESET_UNSPECIFIED_AXES; }\n+\n+  hb_codepoint_t get_gid () const\n+  {\n+    if (flags & GID_IS_24)\n+      return StructAfter<const HBGlyphID24> (numAxes);\n+    else\n+      return StructAfter<const HBGlyphID16> (numAxes);\n+  }\n+\n+  unsigned get_numAxes () const\n+  {\n+    return numAxes;\n+  }\n+\n+  unsigned get_num_points () const\n+  {\n+    unsigned num = 0;\n+    if (flags & AXES_HAVE_VARIATION)                    num += numAxes;\n+    if (flags & (HAVE_TRANSLATE_X | HAVE_TRANSLATE_Y))  num++;\n+    if (flags & HAVE_ROTATION)                          num++;\n+    if (flags & (HAVE_SCALE_X | HAVE_SCALE_Y))          num++;\n+    if (flags & (HAVE_SKEW_X | HAVE_SKEW_Y))            num++;\n+    if (flags & (HAVE_TCENTER_X | HAVE_TCENTER_Y))      num++;\n+    return num;\n+  }\n+\n+  void transform_points (hb_array_t<contour_point_t> record_points,\n+                         contour_point_vector_t &points) const\n+  {\n+    float matrix[4];\n+    contour_point_t trans;\n+\n+    get_transformation_from_points (record_points, matrix, trans);\n+\n+    points.transform (matrix);\n+    points.translate (trans);\n+  }\n+\n+  static inline void transform (float (&matrix)[4], contour_point_t &trans,\n+                                float (other)[6])\n+  {\n+    \/\/ https:\/\/github.com\/fonttools\/fonttools\/blob\/f66ee05f71c8b57b5f519ee975e95edcd1466e14\/Lib\/fontTools\/misc\/transform.py#L268\n+    float xx1 = other[0];\n+    float xy1 = other[1];\n+    float yx1 = other[2];\n+    float yy1 = other[3];\n+    float dx1 = other[4];\n+    float dy1 = other[5];\n+    float xx2 = matrix[0];\n+    float xy2 = matrix[1];\n+    float yx2 = matrix[2];\n+    float yy2 = matrix[3];\n+    float dx2 = trans.x;\n+    float dy2 = trans.y;\n+\n+    matrix[0] = xx1*xx2 + xy1*yx2;\n+    matrix[1] = xx1*xy2 + xy1*yy2;\n+    matrix[2] = yx1*xx2 + yy1*yx2;\n+    matrix[3] = yx1*xy2 + yy1*yy2;\n+    trans.x = xx2*dx1 + yx2*dy1 + dx2;\n+    trans.y = xy2*dx1 + yy2*dy1 + dy2;\n+  }\n+\n+  static void translate (float (&matrix)[4], contour_point_t &trans,\n+                         float translateX, float translateY)\n+  {\n+    \/\/ https:\/\/github.com\/fonttools\/fonttools\/blob\/f66ee05f71c8b57b5f519ee975e95edcd1466e14\/Lib\/fontTools\/misc\/transform.py#L213\n+    float other[6] = {1.f, 0.f, 0.f, 1.f, translateX, translateY};\n+    transform (matrix, trans, other);\n+  }\n+\n+  static void scale (float (&matrix)[4], contour_point_t &trans,\n+                     float scaleX, float scaleY)\n+  {\n+    \/\/ https:\/\/github.com\/fonttools\/fonttools\/blob\/f66ee05f71c8b57b5f519ee975e95edcd1466e14\/Lib\/fontTools\/misc\/transform.py#L224\n+    float other[6] = {scaleX, 0.f, 0.f, scaleY, 0.f, 0.f};\n+    transform (matrix, trans, other);\n+  }\n+\n+  static void rotate (float (&matrix)[4], contour_point_t &trans,\n+                      float rotation)\n+  {\n+    \/\/ https:\/\/github.com\/fonttools\/fonttools\/blob\/f66ee05f71c8b57b5f519ee975e95edcd1466e14\/Lib\/fontTools\/misc\/transform.py#L240\n+    rotation = rotation * float (M_PI);\n+    float c = cosf (rotation);\n+    float s = sinf (rotation);\n+    float other[6] = {c, s, -s, c, 0.f, 0.f};\n+    transform (matrix, trans, other);\n+  }\n+\n+  static void skew (float (&matrix)[4], contour_point_t &trans,\n+                    float skewX, float skewY)\n+  {\n+    \/\/ https:\/\/github.com\/fonttools\/fonttools\/blob\/f66ee05f71c8b57b5f519ee975e95edcd1466e14\/Lib\/fontTools\/misc\/transform.py#L255\n+    skewX = skewX * float (M_PI);\n+    skewY = skewY * float (M_PI);\n+    float other[6] = {1.f, tanf (skewY), tanf (skewX), 1.f, 0.f, 0.f};\n+    transform (matrix, trans, other);\n+  }\n+\n+  bool get_points (contour_point_vector_t &points) const\n+  {\n+    float translateX = 0.f;\n+    float translateY = 0.f;\n+    float rotation = 0.f;\n+    float scaleX = 1.f * (1 << 10);\n+    float scaleY = 1.f * (1 << 10);\n+    float skewX = 0.f;\n+    float skewY = 0.f;\n+    float tCenterX = 0.f;\n+    float tCenterY = 0.f;\n+\n+    if (unlikely (!points.resize (points.length + get_num_points ()))) return false;\n+\n+    unsigned axis_width = (flags & AXIS_INDICES_ARE_SHORT) ? 2 : 1;\n+    unsigned axes_size = numAxes * axis_width;\n+\n+    const F2DOT14 *q = (const F2DOT14 *) (axes_size +\n+                                          (flags & GID_IS_24 ? 3 : 2) +\n+                                          &StructAfter<const HBUINT8> (numAxes));\n+\n+    hb_array_t<contour_point_t> rec_points = points.as_array ().sub_array (points.length - get_num_points ());\n+\n+    unsigned count = numAxes;\n+    if (flags & AXES_HAVE_VARIATION)\n+    {\n+      for (unsigned i = 0; i < count; i++)\n+        rec_points[i].x = q++->to_int ();\n+      rec_points += count;\n+    }\n+    else\n+      q += count;\n+\n+    const HBUINT16 *p = (const HBUINT16 *) q;\n+\n+    if (flags & HAVE_TRANSLATE_X)       translateX = * (const FWORD *) p++;\n+    if (flags & HAVE_TRANSLATE_Y)       translateY = * (const FWORD *) p++;\n+    if (flags & HAVE_ROTATION)          rotation = ((const F4DOT12 *) p++)->to_int ();\n+    if (flags & HAVE_SCALE_X)           scaleX = ((const F6DOT10 *) p++)->to_int ();\n+    if (flags & HAVE_SCALE_Y)           scaleY = ((const F6DOT10 *) p++)->to_int ();\n+    if (flags & HAVE_SKEW_X)            skewX = ((const F4DOT12 *) p++)->to_int ();\n+    if (flags & HAVE_SKEW_Y)            skewY = ((const F4DOT12 *) p++)->to_int ();\n+    if (flags & HAVE_TCENTER_X)         tCenterX = * (const FWORD *) p++;\n+    if (flags & HAVE_TCENTER_Y)         tCenterY = * (const FWORD *) p++;\n+\n+    if ((flags & UNIFORM_SCALE) && !(flags & HAVE_SCALE_Y))\n+      scaleY = scaleX;\n+\n+    if (flags & (HAVE_TRANSLATE_X | HAVE_TRANSLATE_Y))\n+    {\n+      rec_points[0].x = translateX;\n+      rec_points[0].y = translateY;\n+      rec_points++;\n+    }\n+    if (flags & HAVE_ROTATION)\n+    {\n+      rec_points[0].x = rotation;\n+      rec_points++;\n+    }\n+    if (flags & (HAVE_SCALE_X | HAVE_SCALE_Y))\n+    {\n+      rec_points[0].x = scaleX;\n+      rec_points[0].y = scaleY;\n+      rec_points++;\n+    }\n+    if (flags & (HAVE_SKEW_X | HAVE_SKEW_Y))\n+    {\n+      rec_points[0].x = skewX;\n+      rec_points[0].y = skewY;\n+      rec_points++;\n+    }\n+    if (flags & (HAVE_TCENTER_X | HAVE_TCENTER_Y))\n+    {\n+      rec_points[0].x = tCenterX;\n+      rec_points[0].y = tCenterY;\n+      rec_points++;\n+    }\n+    assert (!rec_points);\n+\n+    return true;\n+  }\n+\n+  void get_transformation_from_points (hb_array_t<contour_point_t> rec_points,\n+                                       float (&matrix)[4], contour_point_t &trans) const\n+  {\n+    if (flags & AXES_HAVE_VARIATION)\n+      rec_points += numAxes;\n+\n+    matrix[0] = matrix[3] = 1.f;\n+    matrix[1] = matrix[2] = 0.f;\n+    trans.init (0.f, 0.f);\n+\n+    float translateX = 0.f;\n+    float translateY = 0.f;\n+    float rotation = 0.f;\n+    float scaleX = 1.f;\n+    float scaleY = 1.f;\n+    float skewX = 0.f;\n+    float skewY = 0.f;\n+    float tCenterX = 0.f;\n+    float tCenterY = 0.f;\n+\n+    if (flags & (HAVE_TRANSLATE_X | HAVE_TRANSLATE_Y))\n+    {\n+      translateX = rec_points[0].x;\n+      translateY = rec_points[0].y;\n+      rec_points++;\n+    }\n+    if (flags & HAVE_ROTATION)\n+    {\n+      rotation = rec_points[0].x \/ (1 << 12);\n+      rec_points++;\n+    }\n+    if (flags & (HAVE_SCALE_X | HAVE_SCALE_Y))\n+    {\n+      scaleX = rec_points[0].x \/ (1 << 10);\n+      scaleY = rec_points[0].y \/ (1 << 10);\n+      rec_points++;\n+    }\n+    if (flags & (HAVE_SKEW_X | HAVE_SKEW_Y))\n+    {\n+      skewX = rec_points[0].x \/ (1 << 12);\n+      skewY = rec_points[0].y \/ (1 << 12);\n+      rec_points++;\n+    }\n+    if (flags & (HAVE_TCENTER_X | HAVE_TCENTER_Y))\n+    {\n+      tCenterX = rec_points[0].x;\n+      tCenterY = rec_points[0].y;\n+      rec_points++;\n+    }\n+    assert (!rec_points);\n+\n+    translate (matrix, trans, translateX + tCenterX, translateY + tCenterY);\n+    rotate (matrix, trans, rotation);\n+    scale (matrix, trans, scaleX, scaleY);\n+    skew (matrix, trans, -skewX, skewY);\n+    translate (matrix, trans, -tCenterX, -tCenterY);\n+  }\n+\n+  void set_variations (coord_setter_t &setter,\n+                       hb_array_t<contour_point_t> rec_points) const\n+  {\n+    bool have_variations = flags & AXES_HAVE_VARIATION;\n+    unsigned axis_width = (flags & AXIS_INDICES_ARE_SHORT) ? 2 : 1;\n+\n+    const HBUINT8  *p = (const HBUINT8 *)  (((HBUINT8 *) &numAxes) + numAxes.static_size + (flags & GID_IS_24 ? 3 : 2));\n+    const HBUINT16 *q = (const HBUINT16 *) (((HBUINT8 *) &numAxes) + numAxes.static_size + (flags & GID_IS_24 ? 3 : 2));\n+\n+    const F2DOT14 *a = (const F2DOT14 *) ((HBUINT8 *) (axis_width == 1 ? (p + numAxes) : (HBUINT8 *) (q + numAxes)));\n+\n+    unsigned count = numAxes;\n+    for (unsigned i = 0; i < count; i++)\n+    {\n+      unsigned axis_index = axis_width == 1 ? (unsigned) *p++ : (unsigned) *q++;\n+\n+      signed v = have_variations ? rec_points[i].x : a++->to_int ();\n+\n+      v = hb_clamp (v, -(1<<14), (1<<14));\n+      setter[axis_index] = v;\n+    }\n+  }\n+\n+  protected:\n+  HBUINT16      flags;\n+  HBUINT8       numAxes;\n+  public:\n+  DEFINE_SIZE_MIN (3);\n+};\n+\n+using var_composite_iter_t = composite_iter_tmpl<VarCompositeGlyphRecord>;\n+\n+struct VarCompositeGlyph\n+{\n+  const GlyphHeader &header;\n+  hb_bytes_t bytes;\n+  VarCompositeGlyph (const GlyphHeader &header_, hb_bytes_t bytes_) :\n+    header (header_), bytes (bytes_) {}\n+\n+  var_composite_iter_t iter () const\n+  { return var_composite_iter_t (bytes, &StructAfter<VarCompositeGlyphRecord, GlyphHeader> (header)); }\n+\n+};\n+\n+\n+} \/* namespace glyf_impl *\/\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* OT_GLYF_VARCOMPOSITEGLYPH_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/VarCompositeGlyph.hh","additions":354,"deletions":0,"binary":false,"changes":354,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+#ifndef OT_GLYF_COMPOSITE_ITER_HH\n+#define OT_GLYF_COMPOSITE_ITER_HH\n+\n+\n+#include \"..\/..\/hb.hh\"\n+\n+\n+namespace OT {\n+namespace glyf_impl {\n+\n+\n+template <typename CompositeGlyphRecord>\n+struct composite_iter_tmpl : hb_iter_with_fallback_t<composite_iter_tmpl<CompositeGlyphRecord>,\n+                                                     const CompositeGlyphRecord &>\n+{\n+  typedef const CompositeGlyphRecord *__item_t__;\n+  composite_iter_tmpl (hb_bytes_t glyph_, __item_t__ current_) :\n+      glyph (glyph_), current (nullptr), current_size (0)\n+  {\n+    set_current (current_);\n+  }\n+\n+  composite_iter_tmpl () : glyph (hb_bytes_t ()), current (nullptr), current_size (0) {}\n+\n+  const CompositeGlyphRecord & __item__ () const { return *current; }\n+  bool __more__ () const { return current; }\n+  void __next__ ()\n+  {\n+    if (!current->has_more ()) { current = nullptr; return; }\n+\n+    set_current (&StructAtOffset<CompositeGlyphRecord> (current, current_size));\n+  }\n+  composite_iter_tmpl __end__ () const { return composite_iter_tmpl (); }\n+  bool operator != (const composite_iter_tmpl& o) const\n+  { return current != o.current; }\n+\n+\n+  void set_current (__item_t__ current_)\n+  {\n+    if (!glyph.check_range (current_, CompositeGlyphRecord::min_size))\n+    {\n+      current = nullptr;\n+      current_size = 0;\n+      return;\n+    }\n+    unsigned size = current_->get_size ();\n+    if (!glyph.check_range (current_, size))\n+    {\n+      current = nullptr;\n+      current_size = 0;\n+      return;\n+    }\n+\n+    current = current_;\n+    current_size = size;\n+  }\n+\n+  private:\n+  hb_bytes_t glyph;\n+  __item_t__ current;\n+  unsigned current_size;\n+};\n+\n+\n+} \/* namespace glyf_impl *\/\n+} \/* namespace OT *\/\n+\n+#endif \/* OT_GLYF_COMPOSITE_ITER_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/composite-iter.hh","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+#ifndef OT_GLYF_COORD_SETTER_HH\n+#define OT_GLYF_COORD_SETTER_HH\n+\n+\n+#include \"..\/..\/hb.hh\"\n+\n+\n+namespace OT {\n+namespace glyf_impl {\n+\n+\n+struct coord_setter_t\n+{\n+  coord_setter_t (hb_array_t<int> coords) :\n+    coords (coords) {}\n+\n+  int& operator [] (unsigned idx)\n+  {\n+    if (coords.length < idx + 1)\n+      coords.resize (idx + 1);\n+    return coords[idx];\n+  }\n+\n+  hb_array_t<int> get_coords ()\n+  { return coords.as_array (); }\n+\n+  hb_vector_t<int> coords;\n+};\n+\n+\n+} \/* namespace glyf_impl *\/\n+} \/* namespace OT *\/\n+\n+#endif \/* OT_GLYF_COORD_SETTER_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/coord-setter.hh","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -19,1 +19,1 @@\n-_write_loca (IteratorIn it, bool short_offsets, IteratorOut dest)\n+_write_loca (IteratorIn&& it, bool short_offsets, IteratorOut&& dest)\n@@ -28,1 +28,1 @@\n-              DEBUG_MSG (SUBSET, nullptr, \"loca entry offset %d\", offset);\n+              DEBUG_MSG (SUBSET, nullptr, \"loca entry offset %u\", offset);\n@@ -47,0 +47,14 @@\n+  if (plan->normalized_coords)\n+  {\n+    head_prime->xMin = plan->head_maxp_info.xMin;\n+    head_prime->xMax = plan->head_maxp_info.xMax;\n+    head_prime->yMin = plan->head_maxp_info.yMin;\n+    head_prime->yMax = plan->head_maxp_info.yMax;\n+\n+    unsigned orig_flag = head_prime->flags;\n+    if (plan->head_maxp_info.allXMinIsLsb)\n+      orig_flag |= 1 << 1;\n+    else\n+      orig_flag &= ~(1 << 1);\n+    head_prime->flags = orig_flag;\n+  }\n@@ -64,1 +78,1 @@\n-  DEBUG_MSG (SUBSET, nullptr, \"loca entry_size %d num_offsets %d size %d\",\n+  DEBUG_MSG (SUBSET, nullptr, \"loca entry_size %u num_offsets %u size %u\",\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/glyf-helpers.hh","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -10,0 +10,1 @@\n+#include \"..\/..\/hb-paint.hh\"\n@@ -27,1 +28,0 @@\n-\n@@ -49,0 +49,1 @@\n+\n@@ -50,1 +51,3 @@\n-    for (const auto &_ : it) _.serialize (c, use_short_loca, plan);\n+    for (auto &_ : it)\n+      if (unlikely (!_.serialize (c, use_short_loca, plan)))\n+        return false;\n@@ -75,0 +78,12 @@\n+    hb_font_t *font = nullptr;\n+    if (c->plan->normalized_coords)\n+    {\n+      font = _create_font_for_instancing (c->plan);\n+      if (unlikely (!font)) return false;\n+    }\n+\n+    hb_vector_t<unsigned> padded_offsets;\n+    unsigned num_glyphs = c->plan->num_output_glyphs ();\n+    if (unlikely (!padded_offsets.resize (num_glyphs)))\n+      return false;\n+\n@@ -76,1 +91,2 @@\n-    _populate_subset_glyphs (c->plan, &glyphs);\n+    if (!_populate_subset_glyphs (c->plan, font, glyphs))\n+      return false;\n@@ -78,4 +94,2 @@\n-    auto padded_offsets =\n-    + hb_iter (glyphs)\n-    | hb_map (&glyf_impl::SubsetGlyph::padded_size)\n-    ;\n+    if (font)\n+      hb_font_destroy (font);\n@@ -83,2 +97,6 @@\n-    unsigned max_offset = + padded_offsets | hb_reduce (hb_add, 0);\n-    bool use_short_loca = max_offset < 0x1FFFF;\n+    unsigned max_offset = 0;\n+    for (unsigned i = 0; i < num_glyphs; i++)\n+    {\n+      padded_offsets[i] = glyphs[i].padded_size ();\n+      max_offset += padded_offsets[i];\n+    }\n@@ -86,0 +104,3 @@\n+    bool use_short_loca = false;\n+    if (likely (!c->plan->force_long_loca))\n+      use_short_loca = max_offset < 0x1FFFF;\n@@ -87,1 +108,0 @@\n-    glyf_prime->serialize (c->serializer, hb_iter (glyphs), use_short_loca, c->plan);\n@@ -89,4 +109,2 @@\n-      padded_offsets =\n-          + hb_iter (glyphs)\n-          | hb_map (&glyf_impl::SubsetGlyph::length)\n-          ;\n+      for (unsigned i = 0; i < num_glyphs; i++)\n+        padded_offsets[i] = glyphs[i].length ();\n@@ -95,0 +113,5 @@\n+    bool result = glyf_prime->serialize (c->serializer, glyphs.writer (), use_short_loca, c->plan);\n+    if (c->plan->normalized_coords && !c->plan->pinned_at_default)\n+      _free_compiled_subset_glyphs (glyphs, glyphs.length - 1);\n+\n+    if (!result) return false;\n@@ -97,0 +120,1 @@\n+\n@@ -98,1 +122,1 @@\n-                                                                               padded_offsets,\n+                                                                               padded_offsets.iter (),\n@@ -102,1 +126,1 @@\n-  void\n+  bool\n@@ -104,1 +128,11 @@\n-                           hb_vector_t<glyf_impl::SubsetGlyph> *glyphs \/* OUT *\/) const;\n+                           hb_font_t                *font,\n+                           hb_vector_t<glyf_impl::SubsetGlyph> &glyphs \/* OUT *\/) const;\n+\n+  hb_font_t *\n+  _create_font_for_instancing (const hb_subset_plan_t *plan) const;\n+\n+  void _free_compiled_subset_glyphs (hb_vector_t<glyf_impl::SubsetGlyph> &glyphs, unsigned index) const\n+  {\n+    for (unsigned i = 0; i <= index && i < glyphs.length; i++)\n+      glyphs[i].free_compiled_bytes ();\n+  }\n@@ -169,1 +203,1 @@\n-    if (unlikely (!glyph_for_gid (gid).get_points (font, *this, all_points, phantom_only)))\n+    if (unlikely (!glyph_for_gid (gid).get_points (font, *this, all_points, nullptr, nullptr, nullptr, true, true, phantom_only)))\n@@ -197,0 +231,1 @@\n+    bool scaled;\n@@ -212,1 +247,1 @@\n-      void get_extents (hb_font_t *font, hb_glyph_extents_t *extents)\n+      void get_extents (hb_font_t *font, hb_glyph_extents_t *extents, bool scaled)\n@@ -222,4 +257,9 @@\n-        extents->x_bearing = font->em_scalef_x (min_x);\n-        extents->width = font->em_scalef_x (max_x) - extents->x_bearing;\n-        extents->y_bearing = font->em_scalef_y (max_y);\n-        extents->height = font->em_scalef_y (min_y) - extents->y_bearing;\n+        {\n+          extents->x_bearing = roundf (min_x);\n+          extents->width = roundf (max_x - extents->x_bearing);\n+          extents->y_bearing = roundf (max_y);\n+          extents->height = roundf (min_y - extents->y_bearing);\n+\n+          if (scaled)\n+            font->scale_glyph_extents (extents);\n+        }\n@@ -232,1 +272,1 @@\n-    points_aggregator_t (hb_font_t *font_, hb_glyph_extents_t *extents_, contour_point_t *phantoms_)\n+    points_aggregator_t (hb_font_t *font_, hb_glyph_extents_t *extents_, contour_point_t *phantoms_, bool scaled_)\n@@ -237,0 +277,1 @@\n+      scaled = scaled_;\n@@ -241,1 +282,1 @@\n-    void points_end () { bounds.get_extents (font, extents); }\n+    void points_end () { bounds.get_extents (font, extents, scaled); }\n@@ -249,1 +290,1 @@\n-  get_advance_var (hb_font_t *font, hb_codepoint_t gid, bool is_vertical) const\n+  get_advance_with_var_unscaled (hb_font_t *font, hb_codepoint_t gid, bool is_vertical) const\n@@ -256,2 +297,2 @@\n-    if (likely (font->num_coords == gvar->get_axis_count ()))\n-      success = get_points (font, gid, points_aggregator_t (font, nullptr, phantoms));\n+    if (font->num_coords)\n+      success = get_points (font, gid, points_aggregator_t (font, nullptr, phantoms, false));\n@@ -262,1 +303,1 @@\n-        is_vertical ? vmtx->get_advance (gid) :\n+        is_vertical ? vmtx->get_advance_without_var_unscaled (gid) :\n@@ -264,1 +305,1 @@\n-        hmtx->get_advance (gid);\n+        hmtx->get_advance_without_var_unscaled (gid);\n@@ -272,1 +313,1 @@\n-  int get_side_bearing_var (hb_font_t *font, hb_codepoint_t gid, bool is_vertical) const\n+  bool get_leading_bearing_with_var_unscaled (hb_font_t *font, hb_codepoint_t gid, bool is_vertical, int *lsb) const\n@@ -274,1 +315,1 @@\n-    if (unlikely (gid >= num_glyphs)) return 0;\n+    if (unlikely (gid >= num_glyphs)) return false;\n@@ -279,6 +320,2 @@\n-    if (unlikely (!get_points (font, gid, points_aggregator_t (font, &extents, phantoms))))\n-      return\n-#ifndef HB_NO_VERTICAL\n-        is_vertical ? vmtx->get_side_bearing (gid) :\n-#endif\n-        hmtx->get_side_bearing (gid);\n+    if (unlikely (!get_points (font, gid, points_aggregator_t (font, &extents, phantoms, false))))\n+      return false;\n@@ -286,3 +323,4 @@\n-    return is_vertical\n-         ? ceilf (phantoms[glyf_impl::PHANTOM_TOP].y) - extents.y_bearing\n-         : floorf (phantoms[glyf_impl::PHANTOM_LEFT].x);\n+    *lsb = is_vertical\n+         ? roundf (phantoms[glyf_impl::PHANTOM_TOP].y) - extents.y_bearing\n+         : roundf (phantoms[glyf_impl::PHANTOM_LEFT].x);\n+    return true;\n@@ -299,1 +337,1 @@\n-      return get_points (font, gid, points_aggregator_t (font, extents, nullptr));\n+      return get_points (font, gid, points_aggregator_t (font, extents, nullptr, true));\n@@ -301,1 +339,10 @@\n-    return glyph_for_gid (gid).get_extents (font, *this, extents);\n+    return glyph_for_gid (gid).get_extents_without_var_scaled (font, *this, extents);\n+  }\n+\n+  bool paint_glyph (hb_font_t *font, hb_codepoint_t gid, hb_paint_funcs_t *funcs, void *data, hb_color_t foreground) const\n+  {\n+    funcs->push_clip_glyph (data, gid, font);\n+    funcs->color (data, true, foreground);\n+    funcs->pop_clip (data);\n+\n+    return true;\n@@ -352,1 +399,1 @@\n-inline void\n+inline bool\n@@ -354,1 +401,2 @@\n-                               hb_vector_t<glyf_impl::SubsetGlyph> *glyphs \/* OUT *\/) const\n+                               hb_font_t *font,\n+                               hb_vector_t<glyf_impl::SubsetGlyph>& glyphs \/* OUT *\/) const\n@@ -357,0 +405,2 @@\n+  unsigned num_glyphs = plan->num_output_glyphs ();\n+  if (!glyphs.resize (num_glyphs)) return false;\n@@ -358,23 +408,36 @@\n-  + hb_range (plan->num_output_glyphs ())\n-  | hb_map ([&] (hb_codepoint_t new_gid)\n-        {\n-          glyf_impl::SubsetGlyph subset_glyph = {0};\n-          subset_glyph.new_gid = new_gid;\n-\n-          \/* should never fail: all old gids should be mapped *\/\n-          if (!plan->old_gid_for_new_gid (new_gid, &subset_glyph.old_gid))\n-            return subset_glyph;\n-\n-          if (new_gid == 0 &&\n-              !(plan->flags & HB_SUBSET_FLAGS_NOTDEF_OUTLINE))\n-            subset_glyph.source_glyph = glyf_impl::Glyph ();\n-          else\n-            subset_glyph.source_glyph = glyf.glyph_for_gid (subset_glyph.old_gid, true);\n-          if (plan->flags & HB_SUBSET_FLAGS_NO_HINTING)\n-            subset_glyph.drop_hints_bytes ();\n-          else\n-            subset_glyph.dest_start = subset_glyph.source_glyph.get_bytes ();\n-          return subset_glyph;\n-        })\n-  | hb_sink (glyphs)\n-  ;\n+  unsigned idx = 0;\n+  for (auto p : plan->glyph_map->iter ())\n+  {\n+    unsigned new_gid = p.second;\n+    glyf_impl::SubsetGlyph& subset_glyph = glyphs.arrayZ[new_gid];\n+    subset_glyph.old_gid = p.first;\n+\n+    if (unlikely (new_gid == 0 &&\n+                  !(plan->flags & HB_SUBSET_FLAGS_NOTDEF_OUTLINE)) &&\n+                  !plan->normalized_coords)\n+      subset_glyph.source_glyph = glyf_impl::Glyph ();\n+    else\n+    {\n+      \/* If plan has an accelerator, the preprocessing step already trimmed glyphs.\n+       * Don't trim them again! *\/\n+      subset_glyph.source_glyph = glyf.glyph_for_gid (subset_glyph.old_gid, !plan->accelerator);\n+    }\n+\n+    if (plan->flags & HB_SUBSET_FLAGS_NO_HINTING)\n+      subset_glyph.drop_hints_bytes ();\n+    else\n+      subset_glyph.dest_start = subset_glyph.source_glyph.get_bytes ();\n+\n+    if (font)\n+    {\n+      if (unlikely (!subset_glyph.compile_bytes_with_deltas (plan, font, glyf)))\n+      {\n+        \/\/ when pinned at default, only bounds are updated, thus no need to free\n+        if (!plan->pinned_at_default && idx > 0)\n+          _free_compiled_subset_glyphs (glyphs, idx - 1);\n+        return false;\n+      }\n+      idx++;\n+    }\n+  }\n+  return true;\n@@ -383,0 +446,23 @@\n+inline hb_font_t *\n+glyf::_create_font_for_instancing (const hb_subset_plan_t *plan) const\n+{\n+  hb_font_t *font = hb_font_create (plan->source);\n+  if (unlikely (font == hb_font_get_empty ())) return nullptr;\n+\n+  hb_vector_t<hb_variation_t> vars;\n+  if (unlikely (!vars.alloc (plan->user_axes_location.get_population (), true)))\n+    return nullptr;\n+\n+  for (auto _ : plan->user_axes_location)\n+  {\n+    hb_variation_t var;\n+    var.tag = _.first;\n+    var.value = _.second;\n+    vars.push (var);\n+  }\n+\n+#ifndef HB_NO_VAR\n+  hb_font_set_variations (font, vars.arrayZ, plan->user_axes_location.get_population ());\n+#endif\n+  return font;\n+}\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/glyf.hh","additions":154,"deletions":68,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-  } first_oncurve, first_offcurve, last_offcurve;\n+  } first_oncurve, first_offcurve, last_offcurve, last_offcurve2;\n@@ -35,1 +35,1 @@\n-    first_oncurve = first_offcurve = last_offcurve = optional_point_t ();\n+    first_oncurve = first_offcurve = last_offcurve = last_offcurve2 = optional_point_t ();\n@@ -41,1 +41,3 @@\n-     * https:\/\/stackoverflow.com\/a\/20772557 *\/\n+     * https:\/\/stackoverflow.com\/a\/20772557\n+     *\n+     * Cubic support added (incomplete). *\/\n@@ -45,0 +47,5 @@\n+#ifdef HB_NO_CUBIC_GLYF\n+    bool is_cubic = false;\n+#else\n+    bool is_cubic = !is_on_curve && (point.flag & glyf_impl::SimpleGlyph::FLAG_CUBIC);\n+#endif\n@@ -72,2 +79,10 @@\n-          draw_session->quadratic_to (last_offcurve.x, last_offcurve.y,\n-                                     p.x, p.y);\n+          if (last_offcurve2)\n+          {\n+            draw_session->cubic_to (last_offcurve2.x, last_offcurve2.y,\n+                                    last_offcurve.x, last_offcurve.y,\n+                                    p.x, p.y);\n+            last_offcurve2 = optional_point_t ();\n+          }\n+          else\n+            draw_session->quadratic_to (last_offcurve.x, last_offcurve.y,\n+                                       p.x, p.y);\n@@ -78,4 +93,21 @@\n-          optional_point_t mid = last_offcurve.lerp (p, .5f);\n-          draw_session->quadratic_to (last_offcurve.x, last_offcurve.y,\n-                                     mid.x, mid.y);\n-          last_offcurve = p;\n+          if (is_cubic && !last_offcurve2)\n+          {\n+            last_offcurve2 = last_offcurve;\n+            last_offcurve = p;\n+          }\n+          else\n+          {\n+            optional_point_t mid = last_offcurve.lerp (p, .5f);\n+\n+            if (is_cubic)\n+            {\n+              draw_session->cubic_to (last_offcurve2.x, last_offcurve2.y,\n+                                      last_offcurve.x, last_offcurve.y,\n+                                      mid.x, mid.y);\n+              last_offcurve2 = optional_point_t ();\n+            }\n+            else\n+              draw_session->quadratic_to (last_offcurve.x, last_offcurve.y,\n+                                         mid.x, mid.y);\n+            last_offcurve = p;\n+          }\n@@ -108,2 +140,9 @@\n-        draw_session->quadratic_to (last_offcurve.x, last_offcurve.y,\n-                                   first_oncurve.x, first_oncurve.y);\n+      {\n+        if (last_offcurve2)\n+          draw_session->cubic_to (last_offcurve2.x, last_offcurve2.y,\n+                                  last_offcurve.x, last_offcurve.y,\n+                                  first_oncurve.x, first_oncurve.y);\n+        else\n+          draw_session->quadratic_to (last_offcurve.x, last_offcurve.y,\n+                                     first_oncurve.x, first_oncurve.y);\n+      }\n@@ -120,1 +159,1 @@\n-      first_oncurve = first_offcurve = last_offcurve = optional_point_t ();\n+      first_oncurve = first_offcurve = last_offcurve = last_offcurve2 = optional_point_t ();\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/path-builder.hh","additions":51,"deletions":12,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -0,0 +1,589 @@\n+\/*\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef OT_NAME_NAME_HH\n+#define OT_NAME_NAME_HH\n+\n+#include \"..\/..\/hb-open-type.hh\"\n+#include \"..\/..\/hb-ot-name-language.hh\"\n+#include \"..\/..\/hb-aat-layout.hh\"\n+#include \"..\/..\/hb-utf.hh\"\n+\n+\n+namespace OT {\n+\n+template <typename in_utf_t, typename out_utf_t>\n+inline unsigned int\n+hb_ot_name_convert_utf (hb_bytes_t                       bytes,\n+                        unsigned int                    *text_size \/* IN\/OUT *\/,\n+                        typename out_utf_t::codepoint_t *text \/* OUT *\/)\n+{\n+  unsigned int src_len = bytes.length \/ sizeof (typename in_utf_t::codepoint_t);\n+  const typename in_utf_t::codepoint_t *src = (const typename in_utf_t::codepoint_t *) bytes.arrayZ;\n+  const typename in_utf_t::codepoint_t *src_end = src + src_len;\n+\n+  typename out_utf_t::codepoint_t *dst = text;\n+\n+  hb_codepoint_t unicode;\n+  const hb_codepoint_t replacement = HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT;\n+\n+  if (text_size && *text_size)\n+  {\n+    (*text_size)--; \/* Save room for NUL-termination. *\/\n+    const typename out_utf_t::codepoint_t *dst_end = text + *text_size;\n+\n+    while (src < src_end && dst < dst_end)\n+    {\n+      const typename in_utf_t::codepoint_t *src_next = in_utf_t::next (src, src_end, &unicode, replacement);\n+      typename out_utf_t::codepoint_t *dst_next = out_utf_t::encode (dst, dst_end, unicode);\n+      if (dst_next == dst)\n+        break; \/* Out-of-room. *\/\n+\n+      dst = dst_next;\n+      src = src_next;\n+    }\n+\n+    *text_size = dst - text;\n+    *dst = 0; \/* NUL-terminate. *\/\n+  }\n+\n+  \/* Accumulate length of rest. *\/\n+  unsigned int dst_len = dst - text;\n+  while (src < src_end)\n+  {\n+    src = in_utf_t::next (src, src_end, &unicode, replacement);\n+    dst_len += out_utf_t::encode_len (unicode);\n+  }\n+  return dst_len;\n+}\n+\n+#define entry_score var.u16[0]\n+#define entry_index var.u16[1]\n+\n+\n+\/*\n+ * name -- Naming\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/name\n+ *\/\n+#define HB_OT_TAG_name HB_TAG('n','a','m','e')\n+\n+#define UNSUPPORTED     42\n+\n+struct NameRecord\n+{\n+  hb_language_t language (hb_face_t *face) const\n+  {\n+#ifndef HB_NO_OT_NAME_LANGUAGE\n+    unsigned int p = platformID;\n+    unsigned int l = languageID;\n+\n+    if (p == 3)\n+      return _hb_ot_name_language_for_ms_code (l);\n+\n+    if (p == 1)\n+      return _hb_ot_name_language_for_mac_code (l);\n+\n+#ifndef HB_NO_OT_NAME_LANGUAGE_AAT\n+    if (p == 0)\n+      return face->table.ltag->get_language (l);\n+#endif\n+\n+#endif\n+    return HB_LANGUAGE_INVALID;\n+  }\n+\n+  uint16_t score () const\n+  {\n+    \/* Same order as in cmap::find_best_subtable(). *\/\n+    unsigned int p = platformID;\n+    unsigned int e = encodingID;\n+\n+    \/* 32-bit. *\/\n+    if (p == 3 && e == 10) return 0;\n+    if (p == 0 && e ==  6) return 1;\n+    if (p == 0 && e ==  4) return 2;\n+\n+    \/* 16-bit. *\/\n+    if (p == 3 && e ==  1) return 3;\n+    if (p == 0 && e ==  3) return 4;\n+    if (p == 0 && e ==  2) return 5;\n+    if (p == 0 && e ==  1) return 6;\n+    if (p == 0 && e ==  0) return 7;\n+\n+    \/* Symbol. *\/\n+    if (p == 3 && e ==  0) return 8;\n+\n+    \/* We treat all Mac Latin names as ASCII only. *\/\n+    if (p == 1 && e ==  0) return 10; \/* 10 is magic number :| *\/\n+\n+    return UNSUPPORTED;\n+  }\n+\n+  NameRecord* copy (hb_serialize_context_t *c, const void *base\n+#ifdef HB_EXPERIMENTAL_API\n+                    , const hb_hashmap_t<hb_ot_name_record_ids_t, hb_bytes_t> *name_table_overrides\n+#endif\n+                    ) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    HB_UNUSED auto snap = c->snapshot ();\n+    auto *out = c->embed (this);\n+    if (unlikely (!out)) return_trace (nullptr);\n+#ifdef HB_EXPERIMENTAL_API\n+    hb_ot_name_record_ids_t record_ids (platformID, encodingID, languageID, nameID);\n+    hb_bytes_t* name_bytes;\n+\n+    if (name_table_overrides->has (record_ids, &name_bytes)) {\n+      hb_bytes_t encoded_bytes = *name_bytes;\n+      char *name_str_utf16_be = nullptr;\n+\n+      if (platformID != 1)\n+      {\n+        unsigned text_size = hb_ot_name_convert_utf<hb_utf8_t, hb_utf16_be_t> (*name_bytes, nullptr, nullptr);\n+\n+        text_size++; \/\/ needs to consider NULL terminator for use in hb_ot_name_convert_utf()\n+        unsigned byte_len = text_size * hb_utf16_be_t::codepoint_t::static_size;\n+        name_str_utf16_be = (char *) hb_calloc (byte_len, 1);\n+        if (!name_str_utf16_be)\n+        {\n+          c->revert (snap);\n+          return_trace (nullptr);\n+        }\n+        hb_ot_name_convert_utf<hb_utf8_t, hb_utf16_be_t> (*name_bytes, &text_size,\n+                                                          (hb_utf16_be_t::codepoint_t *) name_str_utf16_be);\n+\n+        unsigned encoded_byte_len = text_size * hb_utf16_be_t::codepoint_t::static_size;\n+        if (!encoded_byte_len || !c->check_assign (out->length, encoded_byte_len, HB_SERIALIZE_ERROR_INT_OVERFLOW)) {\n+          c->revert (snap);\n+          hb_free (name_str_utf16_be);\n+          return_trace (nullptr);\n+        }\n+\n+        encoded_bytes = hb_bytes_t (name_str_utf16_be, encoded_byte_len);\n+      }\n+      else\n+      {\n+        \/\/ mac platform, copy the UTF-8 string(all ascii characters) as is\n+        if (!c->check_assign (out->length, encoded_bytes.length, HB_SERIALIZE_ERROR_INT_OVERFLOW)) {\n+          c->revert (snap);\n+          return_trace (nullptr);\n+        }\n+      }\n+\n+      out->offset = 0;\n+      c->push ();\n+      encoded_bytes.copy (c);\n+      c->add_link (out->offset, c->pop_pack (), hb_serialize_context_t::Tail, 0);\n+      hb_free (name_str_utf16_be);\n+    }\n+    else\n+#endif\n+    {\n+      out->offset.serialize_copy (c, offset, base, 0, hb_serialize_context_t::Tail, length);\n+    }\n+    return_trace (out);\n+  }\n+\n+  bool isUnicode () const\n+  {\n+    unsigned int p = platformID;\n+    unsigned int e = encodingID;\n+\n+    return (p == 0 ||\n+            (p == 3 && (e == 0 || e == 1 || e == 10)));\n+  }\n+\n+  static int cmp (const void *pa, const void *pb)\n+  {\n+    const NameRecord *a = (const NameRecord *)pa;\n+    const NameRecord *b = (const NameRecord *)pb;\n+\n+    if (a->platformID != b->platformID)\n+      return a->platformID - b->platformID;\n+\n+    if (a->encodingID != b->encodingID)\n+      return a->encodingID - b->encodingID;\n+\n+    if (a->languageID != b->languageID)\n+      return a->languageID - b->languageID;\n+\n+    if (a->nameID != b->nameID)\n+      return a->nameID - b->nameID;\n+\n+    if (a->length != b->length)\n+      return a->length - b->length;\n+\n+    return 0;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && offset.sanitize (c, base, length));\n+  }\n+\n+  HBUINT16      platformID;     \/* Platform ID. *\/\n+  HBUINT16      encodingID;     \/* Platform-specific encoding ID. *\/\n+  HBUINT16      languageID;     \/* Language ID. *\/\n+  HBUINT16      nameID;         \/* Name ID. *\/\n+  HBUINT16      length;         \/* String length (in bytes). *\/\n+  NNOffset16To<UnsizedArrayOf<HBUINT8>>\n+                offset;         \/* String offset from start of storage area (in bytes). *\/\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+};\n+\n+static int\n+_hb_ot_name_entry_cmp_key (const void *pa, const void *pb, bool exact)\n+{\n+  const hb_ot_name_entry_t *a = (const hb_ot_name_entry_t *) pa;\n+  const hb_ot_name_entry_t *b = (const hb_ot_name_entry_t *) pb;\n+\n+  \/* Compare by name_id, then language. *\/\n+\n+  if (a->name_id != b->name_id)\n+    return a->name_id - b->name_id;\n+\n+  if (a->language == b->language) return 0;\n+  if (!a->language) return -1;\n+  if (!b->language) return +1;\n+\n+  const char *astr = hb_language_to_string (a->language);\n+  const char *bstr = hb_language_to_string (b->language);\n+\n+  signed c = strcmp (astr, bstr);\n+\n+  \/\/ 'a' is the user request, and 'b' is string in the font.\n+  \/\/ If eg. user asks for \"en-us\" and font has \"en\", approve.\n+  if (!exact && c &&\n+      hb_language_matches (b->language, a->language))\n+    return 0;\n+\n+  return c;\n+}\n+\n+static int\n+_hb_ot_name_entry_cmp (const void *pa, const void *pb)\n+{\n+  \/* Compare by name_id, then language, then score, then index. *\/\n+\n+  int v = _hb_ot_name_entry_cmp_key (pa, pb, true);\n+  if (v)\n+    return v;\n+\n+  const hb_ot_name_entry_t *a = (const hb_ot_name_entry_t *) pa;\n+  const hb_ot_name_entry_t *b = (const hb_ot_name_entry_t *) pb;\n+\n+  if (a->entry_score != b->entry_score)\n+    return a->entry_score - b->entry_score;\n+\n+  if (a->entry_index != b->entry_index)\n+    return a->entry_index - b->entry_index;\n+\n+  return 0;\n+}\n+\n+struct name\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_name;\n+\n+  unsigned int get_size () const\n+  { return min_size + count * nameRecordZ.item_size; }\n+\n+  template <typename Iterator,\n+            hb_requires (hb_is_source_of (Iterator, const NameRecord &))>\n+  bool serialize (hb_serialize_context_t *c,\n+                  Iterator it,\n+                  const void *src_string_pool\n+#ifdef HB_EXPERIMENTAL_API\n+                  , const hb_vector_t<hb_ot_name_record_ids_t>& insert_name_records\n+                  , const hb_hashmap_t<hb_ot_name_record_ids_t, hb_bytes_t> *name_table_overrides\n+#endif\n+                  )\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    if (unlikely (!c->extend_min ((*this))))  return_trace (false);\n+\n+    unsigned total_count = it.len ()\n+#ifdef HB_EXPERIMENTAL_API\n+        + insert_name_records.length\n+#endif\n+        ;\n+    this->format = 0;\n+    if (!c->check_assign (this->count, total_count, HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+      return false;\n+\n+    NameRecord *name_records = (NameRecord *) hb_calloc (total_count, NameRecord::static_size);\n+    if (unlikely (!name_records)) return_trace (false);\n+\n+    hb_array_t<NameRecord> records (name_records, total_count);\n+\n+    for (const NameRecord& record : it)\n+    {\n+      hb_memcpy (name_records, &record, NameRecord::static_size);\n+      name_records++;\n+    }\n+\n+#ifdef HB_EXPERIMENTAL_API\n+    for (unsigned i = 0; i < insert_name_records.length; i++)\n+    {\n+      const hb_ot_name_record_ids_t& ids = insert_name_records[i];\n+      NameRecord record;\n+      record.platformID = ids.platform_id;\n+      record.encodingID = ids.encoding_id;\n+      record.languageID = ids.language_id;\n+      record.nameID = ids.name_id;\n+      record.length = 0; \/\/ handled in NameRecord copy()\n+      record.offset = 0;\n+      memcpy (name_records, &record, NameRecord::static_size);\n+      name_records++;\n+    }\n+#endif\n+\n+    records.qsort ();\n+\n+    c->copy_all (records,\n+                 src_string_pool\n+#ifdef HB_EXPERIMENTAL_API\n+                 , name_table_overrides\n+#endif\n+                 );\n+    hb_free (records.arrayZ);\n+\n+\n+    if (unlikely (c->ran_out_of_room ())) return_trace (false);\n+\n+    this->stringOffset = c->length ();\n+\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+\n+    name *name_prime = c->serializer->start_embed<name> ();\n+    if (unlikely (!name_prime)) return_trace (false);\n+\n+#ifdef HB_EXPERIMENTAL_API\n+    const hb_hashmap_t<hb_ot_name_record_ids_t, hb_bytes_t> *name_table_overrides =\n+        &c->plan->name_table_overrides;\n+#endif\n+\n+    auto it =\n+    + nameRecordZ.as_array (count)\n+    | hb_filter (c->plan->name_ids, &NameRecord::nameID)\n+    | hb_filter (c->plan->name_languages, &NameRecord::languageID)\n+    | hb_filter ([&] (const NameRecord& namerecord) {\n+      return\n+          (c->plan->flags & HB_SUBSET_FLAGS_NAME_LEGACY)\n+          || namerecord.isUnicode ();\n+    })\n+#ifdef HB_EXPERIMENTAL_API\n+    | hb_filter ([&] (const NameRecord& namerecord) {\n+      if (name_table_overrides->is_empty ())\n+        return true;\n+      hb_ot_name_record_ids_t rec_ids (namerecord.platformID,\n+                                       namerecord.encodingID,\n+                                       namerecord.languageID,\n+                                       namerecord.nameID);\n+\n+      hb_bytes_t *p;\n+      if (name_table_overrides->has (rec_ids, &p) &&\n+          (*p).length == 0)\n+        return false;\n+      return true;\n+    })\n+#endif\n+    ;\n+\n+#ifdef HB_EXPERIMENTAL_API\n+    hb_hashmap_t<hb_ot_name_record_ids_t, unsigned> retained_name_record_ids;\n+    for (const NameRecord& rec : it)\n+    {\n+      hb_ot_name_record_ids_t rec_ids (rec.platformID,\n+                                       rec.encodingID,\n+                                       rec.languageID,\n+                                       rec.nameID);\n+      retained_name_record_ids.set (rec_ids, 1);\n+    }\n+\n+    hb_vector_t<hb_ot_name_record_ids_t> insert_name_records;\n+    if (!name_table_overrides->is_empty ())\n+    {\n+      if (unlikely (!insert_name_records.alloc (name_table_overrides->get_population (), true)))\n+        return_trace (false);\n+      for (const auto& record_ids : name_table_overrides->keys ())\n+      {\n+        if (name_table_overrides->get (record_ids).length == 0)\n+          continue;\n+        if (retained_name_record_ids.has (record_ids))\n+          continue;\n+        insert_name_records.push (record_ids);\n+      }\n+    }\n+#endif\n+\n+    return (name_prime->serialize (c->serializer, it,\n+                                   std::addressof (this + stringOffset)\n+#ifdef HB_EXPERIMENTAL_API\n+                                   , insert_name_records\n+                                   , name_table_overrides\n+#endif\n+                                   ));\n+  }\n+\n+  bool sanitize_records (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    const void *string_pool = (this+stringOffset).arrayZ;\n+    return_trace (nameRecordZ.sanitize (c, count, string_pool));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  likely (format == 0 || format == 1) &&\n+                  c->check_array (nameRecordZ.arrayZ, count) &&\n+                  c->check_range (this, stringOffset) &&\n+                  sanitize_records (c));\n+  }\n+\n+  struct accelerator_t\n+  {\n+    accelerator_t (hb_face_t *face)\n+    {\n+      this->table = hb_sanitize_context_t ().reference_table<name> (face);\n+      assert (this->table.get_length () >= this->table->stringOffset);\n+      this->pool = (const char *) (const void *) (this->table+this->table->stringOffset);\n+      this->pool_len = this->table.get_length () - this->table->stringOffset;\n+      const hb_array_t<const NameRecord> all_names (this->table->nameRecordZ.arrayZ,\n+                                                    this->table->count);\n+\n+      this->names.alloc (all_names.length, true);\n+\n+      for (unsigned int i = 0; i < all_names.length; i++)\n+      {\n+        hb_ot_name_entry_t *entry = this->names.push ();\n+\n+        entry->name_id = all_names[i].nameID;\n+        entry->language = all_names[i].language (face);\n+        entry->entry_score =  all_names[i].score ();\n+        entry->entry_index = i;\n+      }\n+\n+      this->names.qsort (_hb_ot_name_entry_cmp);\n+      \/* Walk and pick best only for each name_id,language pair,\n+       * while dropping unsupported encodings. *\/\n+      unsigned int j = 0;\n+      for (unsigned int i = 0; i < this->names.length; i++)\n+      {\n+        if (this->names[i].entry_score == UNSUPPORTED ||\n+            this->names[i].language == HB_LANGUAGE_INVALID)\n+          continue;\n+        if (i &&\n+            this->names[i - 1].name_id  == this->names[i].name_id &&\n+            this->names[i - 1].language == this->names[i].language)\n+          continue;\n+        this->names[j++] = this->names[i];\n+      }\n+      this->names.resize (j);\n+    }\n+    ~accelerator_t ()\n+    {\n+      this->table.destroy ();\n+    }\n+\n+    int get_index (hb_ot_name_id_t  name_id,\n+                   hb_language_t    language,\n+                   unsigned int    *width=nullptr) const\n+    {\n+      const hb_ot_name_entry_t key = {name_id, {0}, language};\n+      const hb_ot_name_entry_t *entry = hb_bsearch (key, (const hb_ot_name_entry_t *) this->names,\n+                                                    this->names.length,\n+                                                    sizeof (hb_ot_name_entry_t),\n+                                                    _hb_ot_name_entry_cmp_key,\n+                                                    true);\n+\n+      if (!entry)\n+      {\n+        entry = hb_bsearch (key, (const hb_ot_name_entry_t *) this->names,\n+                            this->names.length,\n+                            sizeof (hb_ot_name_entry_t),\n+                            _hb_ot_name_entry_cmp_key,\n+                            false);\n+      }\n+\n+      if (!entry)\n+        return -1;\n+\n+      if (width)\n+        *width = entry->entry_score < 10 ? 2 : 1;\n+\n+      return entry->entry_index;\n+    }\n+\n+    hb_bytes_t get_name (unsigned int idx) const\n+    {\n+      const hb_array_t<const NameRecord> all_names (table->nameRecordZ.arrayZ, table->count);\n+      const NameRecord &record = all_names[idx];\n+      const hb_bytes_t string_pool (pool, pool_len);\n+      return string_pool.sub_array (record.offset, record.length);\n+    }\n+\n+    private:\n+    const char *pool;\n+    unsigned int pool_len;\n+    public:\n+    hb_blob_ptr_t<name> table;\n+    hb_vector_t<hb_ot_name_entry_t> names;\n+  };\n+\n+  public:\n+  \/* We only implement format 0 for now. *\/\n+  HBUINT16      format;         \/* Format selector (=0\/1). *\/\n+  HBUINT16      count;          \/* Number of name records. *\/\n+  NNOffset16To<UnsizedArrayOf<HBUINT8>>\n+                stringOffset;   \/* Offset to start of string storage (from start of table). *\/\n+  UnsizedArrayOf<NameRecord>\n+                nameRecordZ;    \/* The name records where count is the number of records. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, nameRecordZ);\n+};\n+\n+#undef entry_index\n+#undef entry_score\n+\n+struct name_accelerator_t : name::accelerator_t {\n+  name_accelerator_t (hb_face_t *face) : name::accelerator_t (face) {}\n+};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* OT_NAME_NAME_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/name\/name.hh","additions":589,"deletions":0,"binary":false,"changes":589,"status":"added"},{"patch":"@@ -4,0 +4,3 @@\n+STEP 1: UPDATING FILES\n+----------------------\n+Download and unzip the latest version from https:\/\/github.com\/harfbuzz\/harfbuzz\/releases\n@@ -6,1 +9,2 @@\n-and even then just the ones we use. Do NOT just copy everything.\n+and even then just the ones we use.\n+IMPORTANT! DO NOT just copy everything.\n@@ -8,13 +12,1 @@\n-So one way to update is to\n-\n-- copy over from the updated harfbuzz the exact same files we already have\n-- it isn't a flat directory so watch out for that\n-- any that are no longer available (copy fails) we remove but these may come\n-  back later if they were actually renamed\n-- look for files in the destination that were NOT updated - perhaps they\n-  are gone in the upstream - or renamed. Remove them if they are really\n-  obsolete, or add their replacements\/renames.\n-- iterate over : build and see what new file is missing that causes a build failure\n-- when this is done we have something buildable\n-- make sure it builds on all supported platforms.\n-- Harfbuzz is not modular so it is not easy,\n+- Harfbuzz is not modular, so the update is not a straightforward process.\n@@ -26,2 +18,2 @@\n-  * but we do use core text support on macOS.\n-  * I really wish that \"src\" were just library source but I expect the authors\n+   * but we do use core text support on macOS.\n+   * I really wish that \"src\" were just library source, but I expect the authors\n@@ -30,1 +22,50 @@\n-- we do not apply any header file changes so this is not an issue\n+So one way to update is to\n+\n+- copy over from the updated harfbuzz the exact same files we already have\n+- it isn't a flat directory so watch out for that.\n+\n+- For files that are no longer available (for which copy fails), we remove such files,\n+  but these may come back later if they were actually renamed.\n+\n+- look for files in the destination that were NOT updated - perhaps they\n+  are removed or renamed in the upstream. Remove them if they are really\n+  obsolete, or add their replacements\/renames.\n+  In IntelliJ IDE:\n+    Newly added files are shown in RED\n+    Modified in BLUE\n+    NOT Updated in WHITE\n+  This feature might be helpful to keep track of new, modified and unchanged files.\n+\n+\n+STEP 2: BUILD CHANGES INCREMENTALLY\n+-----------------------------------\n+- iterate over : build and see what new file is missing that causes a build failure.\n+  Sometimes just running a build does not show up any failures due to stale files.\n+  Clean followed by build would be helpful in this situation.\n+\n+- You might run into compiler warnings that are treated as errors or the requirement\n+  to set certain compiler flags if the build fails on a specific platform.\n+  Check \"COMPILER WARNINGS AND SETTING FLAGS\" section for more details.\n+\n+- when this is done we have something buildable, make sure it builds\n+  on all supported platforms.\n+\n+\n+STEP 3: COMPILER WARNINGS AND SETTING FLAGS\n+-------------------------------------------\n+- Update make parameters in Awt2DLibraries.gmk\n+  Since we don't use configure we need to manually specify the options\n+  we need in the Harfbuzz section of Awt2DLibraries.gmk.\n+  As well as adding new options, we may need to clean up obsolete options.\n+  Note there may be platform variations in the flags.\n+\n+- As with other 3rd party libs we do not fix the code to eliminate compiler\n+  warnings unless they are critical and clearly avoiding a bug. Even then\n+  we'd report it upstream and apply the patch once it is made available.\n+  The usual practice is do just disable the warnings.\n+\n+\n+STEP 4: UPDATING .md FILE\n+-------------------------\n+- we do not apply any header file changes so this is not an issue.\n+\n@@ -32,1 +73,5 @@\n-   src\/java.desktop\/share\/legal\/harfbuzz.md with the new version\n+  src\/java.desktop\/share\/legal\/harfbuzz.md with the new version.\n+\n+\n+STEP 5: REPLACE TABS & REMOVE TRAILING SPACES\n+---------------------------------------------\n@@ -36,3 +81,26 @@\n-- test using all the automated jtreg tests on all platforms\n-- do manual verification of Arabic, Hebrew, Thai, Indic against previous releases. \n-  Look for manual related layout jtreg tests and run on Windows,Linux and Mac.\n+  To clean up the extra spaces and tabs run the following script at\n+  each folder level within libharfbuzz.\n+\n+  for f in *.c *.h *.cc *.hh;\n+      do\n+          # replace tabs with spaces\n+          expand ${f} > ${f}.tmp;\n+          mv ${f}.tmp $f;\n+\n+          # fix line endings to LF\n+          sed -e 's\/\\r$\/\/g' ${f} > ${f}.tmp;\n+          mv ${f}.tmp $f;\n+\n+          # remove trailing spaces\n+          sed -e 's\/[ ]* $\/\/g' ${f} > ${f}.tmp;\n+          mv ${f}.tmp $f;\n+      done\n+\n+\n+STEP 6: TESTING\n+---------------\n+- test using all the automated jtreg tests on all platforms.\n+\n+- do MANUAL verification of Arabic, Hebrew, Thai, Indic against previous releases.\n+  Look for manual related layout jtreg tests (test\/jdk\/java\/awt\/font\/TextLayout)\n+  and run on Windows,Linux and Mac.\n@@ -43,5 +111,5 @@\n-- Update make parameters as needed\n-  Since we don't use configure we need to manually specify the options\n-  we need in the harfbuzz section of Awt2DLibraries.gmk.\n-  As well as adding new options, we may need to clean up obsolete options.\n-  Note there may be platform variations in the flags.\n+  Different unicode combinations can be checked using Font2DTest.\n+  Run Font2DTest, select 'UserText' option for 'Text to use'.\n+  Paste unicodes of different languages (Arabic, Hebrew, Thai, Indic)\n+  and compare the glyphs with previous versions.\n+  It should look the same in both cases.\n@@ -49,3 +117,0 @@\n-- As with other 3rd party libs we do not fix the code to eliminate compiler\n-  warnings unless they are critical and clearly avoiding a bug. Even then\n-  we'd report it upstream. The usual practice is do just disable the warnings\n@@ -53,1 +118,1 @@\n-- Update THIS UPDATING.txt file too if it is outdated.\n+- FINALLY, Do update THIS UPDATING.txt file too if it is outdated.\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/UPDATING.txt","additions":95,"deletions":30,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright © 2022  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger\n+ *\/\n+\n+#include \"graph.hh\"\n+#include \"..\/hb-ot-layout-common.hh\"\n+\n+#ifndef GRAPH_CLASSDEF_GRAPH_HH\n+#define GRAPH_CLASSDEF_GRAPH_HH\n+\n+namespace graph {\n+\n+struct ClassDefFormat1 : public OT::ClassDefFormat1_3<SmallTypes>\n+{\n+  bool sanitize (graph_t::vertex_t& vertex) const\n+  {\n+    int64_t vertex_len = vertex.obj.tail - vertex.obj.head;\n+    constexpr unsigned min_size = OT::ClassDefFormat1_3<SmallTypes>::min_size;\n+    if (vertex_len < min_size) return false;\n+    return vertex_len >= min_size + classValue.get_size () - classValue.len.get_size ();\n+  }\n+};\n+\n+struct ClassDefFormat2 : public OT::ClassDefFormat2_4<SmallTypes>\n+{\n+  bool sanitize (graph_t::vertex_t& vertex) const\n+  {\n+    int64_t vertex_len = vertex.obj.tail - vertex.obj.head;\n+    constexpr unsigned min_size = OT::ClassDefFormat2_4<SmallTypes>::min_size;\n+    if (vertex_len < min_size) return false;\n+    return vertex_len >= min_size + rangeRecord.get_size () - rangeRecord.len.get_size ();\n+  }\n+};\n+\n+struct ClassDef : public OT::ClassDef\n+{\n+  template<typename It>\n+  static bool add_class_def (gsubgpos_graph_context_t& c,\n+                             unsigned parent_id,\n+                             unsigned link_position,\n+                             It glyph_and_class,\n+                             unsigned max_size)\n+  {\n+    unsigned class_def_prime_id = c.graph.new_node (nullptr, nullptr);\n+    auto& class_def_prime_vertex = c.graph.vertices_[class_def_prime_id];\n+    if (!make_class_def (c, glyph_and_class, class_def_prime_id, max_size))\n+      return false;\n+\n+    auto* class_def_link = c.graph.vertices_[parent_id].obj.real_links.push ();\n+    class_def_link->width = SmallTypes::size;\n+    class_def_link->objidx = class_def_prime_id;\n+    class_def_link->position = link_position;\n+    class_def_prime_vertex.parents.push (parent_id);\n+\n+    return true;\n+  }\n+\n+  template<typename It>\n+  static bool make_class_def (gsubgpos_graph_context_t& c,\n+                              It glyph_and_class,\n+                              unsigned dest_obj,\n+                              unsigned max_size)\n+  {\n+    char* buffer = (char*) hb_calloc (1, max_size);\n+    hb_serialize_context_t serializer (buffer, max_size);\n+    OT::ClassDef_serialize (&serializer, glyph_and_class);\n+    serializer.end_serialize ();\n+    if (serializer.in_error ())\n+    {\n+      hb_free (buffer);\n+      return false;\n+    }\n+\n+    hb_bytes_t class_def_copy = serializer.copy_bytes ();\n+    c.add_buffer ((char *) class_def_copy.arrayZ); \/\/ Give ownership to the context, it will cleanup the buffer.\n+\n+    auto& obj = c.graph.vertices_[dest_obj].obj;\n+    obj.head = (char *) class_def_copy.arrayZ;\n+    obj.tail = obj.head + class_def_copy.length;\n+\n+    hb_free (buffer);\n+    return true;\n+  }\n+\n+  bool sanitize (graph_t::vertex_t& vertex) const\n+  {\n+    int64_t vertex_len = vertex.obj.tail - vertex.obj.head;\n+    if (vertex_len < OT::ClassDef::min_size) return false;\n+    switch (u.format)\n+    {\n+    case 1: return ((ClassDefFormat1*)this)->sanitize (vertex);\n+    case 2: return ((ClassDefFormat2*)this)->sanitize (vertex);\n+#ifndef HB_NO_BEYOND_64K\n+    \/\/ Not currently supported\n+    case 3:\n+    case 4:\n+#endif\n+    default: return false;\n+    }\n+  }\n+};\n+\n+\n+struct class_def_size_estimator_t\n+{\n+  template<typename It>\n+  class_def_size_estimator_t (It glyph_and_class)\n+      : gids_consecutive (true), num_ranges_per_class (), glyphs_per_class ()\n+  {\n+    unsigned last_gid = (unsigned) -1;\n+    for (auto p : + glyph_and_class)\n+    {\n+      unsigned gid = p.first;\n+      unsigned klass = p.second;\n+\n+      if (last_gid != (unsigned) -1 && gid != last_gid + 1)\n+        gids_consecutive = false;\n+      last_gid = gid;\n+\n+      hb_set_t* glyphs;\n+      if (glyphs_per_class.has (klass, &glyphs) && glyphs) {\n+        glyphs->add (gid);\n+        continue;\n+      }\n+\n+      hb_set_t new_glyphs;\n+      new_glyphs.add (gid);\n+      glyphs_per_class.set (klass, std::move (new_glyphs));\n+    }\n+\n+    if (in_error ()) return;\n+\n+    for (unsigned klass : glyphs_per_class.keys ())\n+    {\n+      if (!klass) continue; \/\/ class 0 doesn't get encoded.\n+\n+      const hb_set_t& glyphs = glyphs_per_class.get (klass);\n+      hb_codepoint_t start = HB_SET_VALUE_INVALID;\n+      hb_codepoint_t end = HB_SET_VALUE_INVALID;\n+\n+      unsigned count = 0;\n+      while (glyphs.next_range (&start, &end))\n+        count++;\n+\n+      num_ranges_per_class.set (klass, count);\n+    }\n+  }\n+\n+  \/\/ Incremental increase in the Coverage and ClassDef table size\n+  \/\/ (worst case) if all glyphs associated with 'klass' were added.\n+  unsigned incremental_coverage_size (unsigned klass) const\n+  {\n+    \/\/ Coverage takes 2 bytes per glyph worst case,\n+    return 2 * glyphs_per_class.get (klass).get_population ();\n+  }\n+\n+  \/\/ Incremental increase in the Coverage and ClassDef table size\n+  \/\/ (worst case) if all glyphs associated with 'klass' were added.\n+  unsigned incremental_class_def_size (unsigned klass) const\n+  {\n+    \/\/ ClassDef takes 6 bytes per range\n+    unsigned class_def_2_size = 6 * num_ranges_per_class.get (klass);\n+    if (gids_consecutive)\n+    {\n+      \/\/ ClassDef1 takes 2 bytes per glyph, but only can be used\n+      \/\/ when gids are consecutive.\n+      return hb_min (2 * glyphs_per_class.get (klass).get_population (), class_def_2_size);\n+    }\n+\n+    return class_def_2_size;\n+  }\n+\n+  bool in_error ()\n+  {\n+    if (num_ranges_per_class.in_error ()) return true;\n+    if (glyphs_per_class.in_error ()) return true;\n+\n+    for (const hb_set_t& s : glyphs_per_class.values ())\n+    {\n+      if (s.in_error ()) return true;\n+    }\n+    return false;\n+  }\n+\n+ private:\n+  bool gids_consecutive;\n+  hb_hashmap_t<unsigned, unsigned> num_ranges_per_class;\n+  hb_hashmap_t<unsigned, hb_set_t> glyphs_per_class;\n+};\n+\n+\n+}\n+\n+#endif  \/\/ GRAPH_CLASSDEF_GRAPH_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/graph\/classdef-graph.hh","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright © 2022  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger\n+ *\/\n+\n+#include \"graph.hh\"\n+#include \"..\/OT\/Layout\/Common\/Coverage.hh\"\n+\n+#ifndef GRAPH_COVERAGE_GRAPH_HH\n+#define GRAPH_COVERAGE_GRAPH_HH\n+\n+namespace graph {\n+\n+struct CoverageFormat1 : public OT::Layout::Common::CoverageFormat1_3<SmallTypes>\n+{\n+  bool sanitize (graph_t::vertex_t& vertex) const\n+  {\n+    int64_t vertex_len = vertex.obj.tail - vertex.obj.head;\n+    constexpr unsigned min_size = OT::Layout::Common::CoverageFormat1_3<SmallTypes>::min_size;\n+    if (vertex_len < min_size) return false;\n+    return vertex_len >= min_size + glyphArray.get_size () - glyphArray.len.get_size ();\n+  }\n+};\n+\n+struct CoverageFormat2 : public OT::Layout::Common::CoverageFormat2_4<SmallTypes>\n+{\n+  bool sanitize (graph_t::vertex_t& vertex) const\n+  {\n+    int64_t vertex_len = vertex.obj.tail - vertex.obj.head;\n+    constexpr unsigned min_size = OT::Layout::Common::CoverageFormat2_4<SmallTypes>::min_size;\n+    if (vertex_len < min_size) return false;\n+    return vertex_len >= min_size + rangeRecord.get_size () - rangeRecord.len.get_size ();\n+  }\n+};\n+\n+struct Coverage : public OT::Layout::Common::Coverage\n+{\n+  static Coverage* clone_coverage (gsubgpos_graph_context_t& c,\n+                                   unsigned coverage_id,\n+                                   unsigned new_parent_id,\n+                                   unsigned link_position,\n+                                   unsigned start, unsigned end)\n+\n+  {\n+    unsigned coverage_size = c.graph.vertices_[coverage_id].table_size ();\n+    auto& coverage_v = c.graph.vertices_[coverage_id];\n+    Coverage* coverage_table = (Coverage*) coverage_v.obj.head;\n+    if (!coverage_table || !coverage_table->sanitize (coverage_v))\n+      return nullptr;\n+\n+    auto new_coverage =\n+        + hb_zip (coverage_table->iter (), hb_range ())\n+        | hb_filter ([&] (hb_pair_t<unsigned, unsigned> p) {\n+          return p.second >= start && p.second < end;\n+        })\n+        | hb_map_retains_sorting (hb_first)\n+        ;\n+\n+    return add_coverage (c, new_parent_id, link_position, new_coverage, coverage_size);\n+  }\n+\n+  template<typename It>\n+  static Coverage* add_coverage (gsubgpos_graph_context_t& c,\n+                                 unsigned parent_id,\n+                                 unsigned link_position,\n+                                 It glyphs,\n+                                 unsigned max_size)\n+  {\n+    unsigned coverage_prime_id = c.graph.new_node (nullptr, nullptr);\n+    auto& coverage_prime_vertex = c.graph.vertices_[coverage_prime_id];\n+    if (!make_coverage (c, glyphs, coverage_prime_id, max_size))\n+      return nullptr;\n+\n+    auto* coverage_link = c.graph.vertices_[parent_id].obj.real_links.push ();\n+    coverage_link->width = SmallTypes::size;\n+    coverage_link->objidx = coverage_prime_id;\n+    coverage_link->position = link_position;\n+    coverage_prime_vertex.parents.push (parent_id);\n+\n+    return (Coverage*) coverage_prime_vertex.obj.head;\n+  }\n+\n+  template<typename It>\n+  static bool make_coverage (gsubgpos_graph_context_t& c,\n+                             It glyphs,\n+                             unsigned dest_obj,\n+                             unsigned max_size)\n+  {\n+    char* buffer = (char*) hb_calloc (1, max_size);\n+    hb_serialize_context_t serializer (buffer, max_size);\n+    OT::Layout::Common::Coverage_serialize (&serializer, glyphs);\n+    serializer.end_serialize ();\n+    if (serializer.in_error ())\n+    {\n+      hb_free (buffer);\n+      return false;\n+    }\n+\n+    hb_bytes_t coverage_copy = serializer.copy_bytes ();\n+    c.add_buffer ((char *) coverage_copy.arrayZ); \/\/ Give ownership to the context, it will cleanup the buffer.\n+\n+    auto& obj = c.graph.vertices_[dest_obj].obj;\n+    obj.head = (char *) coverage_copy.arrayZ;\n+    obj.tail = obj.head + coverage_copy.length;\n+\n+    hb_free (buffer);\n+    return true;\n+  }\n+\n+  bool sanitize (graph_t::vertex_t& vertex) const\n+  {\n+    int64_t vertex_len = vertex.obj.tail - vertex.obj.head;\n+    if (vertex_len < OT::Layout::Common::Coverage::min_size) return false;\n+    switch (u.format)\n+    {\n+    case 1: return ((CoverageFormat1*)this)->sanitize (vertex);\n+    case 2: return ((CoverageFormat2*)this)->sanitize (vertex);\n+#ifndef HB_NO_BEYOND_64K\n+    \/\/ Not currently supported\n+    case 3:\n+    case 4:\n+#endif\n+    default: return false;\n+    }\n+  }\n+};\n+\n+\n+}\n+\n+#endif  \/\/ GRAPH_COVERAGE_GRAPH_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/graph\/coverage-graph.hh","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -27,0 +27,4 @@\n+#include \"..\/hb-set.hh\"\n+#include \"..\/hb-priority-queue.hh\"\n+#include \"..\/hb-serialize.hh\"\n+\n@@ -48,0 +52,89 @@\n+\n+    bool link_positions_valid (unsigned num_objects, bool removed_nil)\n+    {\n+      hb_set_t assigned_bytes;\n+      for (const auto& l : obj.real_links)\n+      {\n+        if (l.objidx >= num_objects\n+            || (removed_nil && !l.objidx))\n+        {\n+          DEBUG_MSG (SUBSET_REPACK, nullptr,\n+                     \"Invalid graph. Invalid object index.\");\n+          return false;\n+        }\n+\n+        unsigned start = l.position;\n+        unsigned end = start + l.width - 1;\n+\n+        if (unlikely (l.width < 2 || l.width > 4))\n+        {\n+          DEBUG_MSG (SUBSET_REPACK, nullptr,\n+                     \"Invalid graph. Invalid link width.\");\n+          return false;\n+        }\n+\n+        if (unlikely (end >= table_size ()))\n+        {\n+          DEBUG_MSG (SUBSET_REPACK, nullptr,\n+                     \"Invalid graph. Link position is out of bounds.\");\n+          return false;\n+        }\n+\n+        if (unlikely (assigned_bytes.intersects (start, end)))\n+        {\n+          DEBUG_MSG (SUBSET_REPACK, nullptr,\n+                     \"Invalid graph. Found offsets whose positions overlap.\");\n+          return false;\n+        }\n+\n+        assigned_bytes.add_range (start, end);\n+      }\n+\n+      return !assigned_bytes.in_error ();\n+    }\n+\n+    void normalize ()\n+    {\n+      obj.real_links.qsort ();\n+      for (auto& l : obj.real_links)\n+      {\n+        for (unsigned i = 0; i < l.width; i++)\n+        {\n+          obj.head[l.position + i] = 0;\n+        }\n+      }\n+    }\n+\n+    bool equals (const vertex_t& other,\n+                 const graph_t& graph,\n+                 const graph_t& other_graph,\n+                 unsigned depth) const\n+    {\n+      if (!(as_bytes () == other.as_bytes ()))\n+      {\n+        DEBUG_MSG (SUBSET_REPACK, nullptr,\n+                   \"vertex [%lu] bytes != [%lu] bytes, depth = %u\",\n+                   (unsigned long) table_size (),\n+                   (unsigned long) other.table_size (),\n+                   depth);\n+\n+        auto a = as_bytes ();\n+        auto b = other.as_bytes ();\n+        while (a || b)\n+        {\n+          DEBUG_MSG (SUBSET_REPACK, nullptr,\n+                     \"  0x%x %s 0x%x\", (unsigned) *a, (*a == *b) ? \"==\" : \"!=\", (unsigned) *b);\n+          a++;\n+          b++;\n+        }\n+        return false;\n+      }\n+\n+      return links_equal (obj.real_links, other.obj.real_links, graph, other_graph, depth);\n+    }\n+\n+    hb_bytes_t as_bytes () const\n+    {\n+      return hb_bytes_t (obj.head, table_size ());\n+    }\n+\n@@ -59,0 +152,12 @@\n+    hb_hashmap_t<unsigned, unsigned>\n+    position_to_index_map () const\n+    {\n+      hb_hashmap_t<unsigned, unsigned> result;\n+\n+      for (const auto& l : obj.real_links) {\n+        result.set (l.position, l.objidx);\n+      }\n+\n+      return result;\n+    }\n+\n@@ -74,1 +179,1 @@\n-        parents.remove (i);\n+        parents.remove_unordered (i);\n@@ -79,0 +184,16 @@\n+    void remove_real_link (unsigned child_index, const void* offset)\n+    {\n+      for (unsigned i = 0; i < obj.real_links.length; i++)\n+      {\n+        auto& link = obj.real_links.arrayZ[i];\n+        if (link.objidx != child_index)\n+          continue;\n+\n+        if ((obj.head + link.position) != offset)\n+          continue;\n+\n+        obj.real_links.remove_unordered (i);\n+        return;\n+      }\n+    }\n+\n@@ -110,0 +231,4 @@\n+    size_t table_size () const {\n+      return obj.tail - obj.head;\n+    }\n+\n@@ -134,0 +259,51 @@\n+\n+   private:\n+    bool links_equal (const hb_vector_t<hb_serialize_context_t::object_t::link_t>& this_links,\n+                      const hb_vector_t<hb_serialize_context_t::object_t::link_t>& other_links,\n+                      const graph_t& graph,\n+                      const graph_t& other_graph,\n+                      unsigned depth) const\n+    {\n+      auto a = this_links.iter ();\n+      auto b = other_links.iter ();\n+\n+      while (a && b)\n+      {\n+        const auto& link_a = *a;\n+        const auto& link_b = *b;\n+\n+        if (link_a.width != link_b.width ||\n+            link_a.is_signed != link_b.is_signed ||\n+            link_a.whence != link_b.whence ||\n+            link_a.position != link_b.position ||\n+            link_a.bias != link_b.bias)\n+          return false;\n+\n+        if (!graph.vertices_[link_a.objidx].equals (\n+                other_graph.vertices_[link_b.objidx], graph, other_graph, depth + 1))\n+          return false;\n+\n+        a++;\n+        b++;\n+      }\n+\n+      if (bool (a) != bool (b))\n+        return false;\n+\n+      return true;\n+    }\n+  };\n+\n+  template <typename T>\n+  struct vertex_and_table_t\n+  {\n+    vertex_and_table_t () : index (0), vertex (nullptr), table (nullptr)\n+    {}\n+\n+    unsigned index;\n+    vertex_t* vertex;\n+    T* table;\n+\n+    operator bool () {\n+       return table && vertex;\n+    }\n@@ -148,1 +324,2 @@\n-        successful (true)\n+        successful (true),\n+        buffers ()\n@@ -156,2 +333,0 @@\n-      \/\/ TODO(grieger): check all links point to valid objects.\n-\n@@ -169,0 +344,3 @@\n+\n+      check_success (v->link_positions_valid (objects.length, removed_nil));\n+\n@@ -180,0 +358,14 @@\n+    for (char* b : buffers)\n+      hb_free (b);\n+  }\n+\n+  bool operator== (const graph_t& other) const\n+  {\n+    return root ().equals (other.root (), *this, other, 0);\n+  }\n+\n+  \/\/ Sorts links of all objects in a consistent manner and zeroes all offsets.\n+  void normalize ()\n+  {\n+    for (auto& v : vertices_.writer ())\n+      v.normalize ();\n@@ -202,1 +394,1 @@\n-  const hb_serialize_context_t::object_t& object(unsigned i) const\n+  const hb_serialize_context_t::object_t& object (unsigned i) const\n@@ -207,0 +399,32 @@\n+  void add_buffer (char* buffer)\n+  {\n+    buffers.push (buffer);\n+  }\n+\n+  \/*\n+   * Adds a 16 bit link from parent_id to child_id\n+   *\/\n+  template<typename T>\n+  void add_link (T* offset,\n+                 unsigned parent_id,\n+                 unsigned child_id)\n+  {\n+    auto& v = vertices_[parent_id];\n+    auto* link = v.obj.real_links.push ();\n+    link->width = 2;\n+    link->objidx = child_id;\n+    link->position = (char*) offset - (char*) v.obj.head;\n+    vertices_[child_id].parents.push (parent_id);\n+  }\n+\n+  \/*\n+   * Generates a new topological sorting of graph ordered by the shortest\n+   * distance to each node if positions are marked as invalid.\n+   *\/\n+  void sort_shortest_distance_if_needed ()\n+  {\n+    if (!positions_invalid) return;\n+    sort_shortest_distance ();\n+  }\n+\n+\n@@ -242,0 +466,7 @@\n+      if (unlikely (!check_success(new_id >= 0))) {\n+        \/\/ We are out of ids. Which means we've visited a node more than once.\n+        \/\/ This graph contains a cycle which is not allowed.\n+        DEBUG_MSG (SUBSET_REPACK, nullptr, \"Invalid graph. Contains cycle.\");\n+        return;\n+      }\n+\n@@ -259,2 +490,0 @@\n-    if (!check_success (new_id == -1))\n-      print_orphaned_nodes ();\n@@ -263,1 +492,0 @@\n-\n@@ -265,0 +493,3 @@\n+\n+    if (!check_success (new_id == -1))\n+      print_orphaned_nodes ();\n@@ -268,1 +499,3 @@\n-   * Assign unique space numbers to each connected subgraph of 32 bit offset(s).\n+   * Finds the set of nodes (placed into roots) that should be assigned unique spaces.\n+   * More specifically this looks for the top most 24 bit or 32 bit links in the graph.\n+   * Some special casing is done that is specific to the layout of GSUB\/GPOS tables.\n@@ -270,1 +503,1 @@\n-  bool assign_32bit_spaces ()\n+  void find_space_roots (hb_set_t& visited, hb_set_t& roots)\n@@ -272,4 +505,2 @@\n-    unsigned root_index = root_idx ();\n-    hb_set_t visited;\n-    hb_set_t roots;\n-    for (unsigned i = 0; i <= root_index; i++)\n+    int root_index = (int) root_idx ();\n+    for (int i = root_index; i >= 0; i--)\n@@ -277,0 +508,2 @@\n+      if (visited.has (i)) continue;\n+\n@@ -280,1 +513,9 @@\n-        if (l.width == 4 && !l.is_signed)\n+        if (l.is_signed || l.width < 3)\n+          continue;\n+\n+        if (i == root_index && l.width == 3)\n+          \/\/ Ignore 24bit links from the root node, this skips past the single 24bit\n+          \/\/ pointer to the lookup list.\n+          continue;\n+\n+        if (l.width == 3)\n@@ -282,2 +523,13 @@\n-          roots.add (l.objidx);\n-          find_subgraph (l.objidx, visited);\n+          \/\/ A 24bit offset forms a root, unless there is 32bit offsets somewhere\n+          \/\/ in it's subgraph, then those become the roots instead. This is to make sure\n+          \/\/ that extension subtables beneath a 24bit lookup become the spaces instead\n+          \/\/ of the offset to the lookup.\n+          hb_set_t sub_roots;\n+          find_32bit_roots (l.objidx, sub_roots);\n+          if (sub_roots) {\n+            for (unsigned sub_root_idx : sub_roots) {\n+              roots.add (sub_root_idx);\n+              find_subgraph (sub_root_idx, visited);\n+            }\n+            continue;\n+          }\n@@ -285,0 +537,3 @@\n+\n+        roots.add (l.objidx);\n+        find_subgraph (l.objidx, visited);\n@@ -287,0 +542,1 @@\n+  }\n@@ -288,2 +544,85 @@\n-    \/\/ Mark everything not in the subgraphs of 32 bit roots as visited.\n-    \/\/ This prevents 32 bit subgraphs from being connected via nodes not in the 32 bit subgraphs.\n+  template <typename T, typename ...Ts>\n+  vertex_and_table_t<T> as_table (unsigned parent, const void* offset, Ts... ds)\n+  {\n+    return as_table_from_index<T> (index_for_offset (parent, offset), std::forward<Ts>(ds)...);\n+  }\n+\n+  template <typename T, typename ...Ts>\n+  vertex_and_table_t<T> as_mutable_table (unsigned parent, const void* offset, Ts... ds)\n+  {\n+    return as_table_from_index<T> (mutable_index_for_offset (parent, offset), std::forward<Ts>(ds)...);\n+  }\n+\n+  template <typename T, typename ...Ts>\n+  vertex_and_table_t<T> as_table_from_index (unsigned index, Ts... ds)\n+  {\n+    if (index >= vertices_.length)\n+      return vertex_and_table_t<T> ();\n+\n+    vertex_and_table_t<T> r;\n+    r.vertex = &vertices_[index];\n+    r.table = (T*) r.vertex->obj.head;\n+    r.index = index;\n+    if (!r.table)\n+      return vertex_and_table_t<T> ();\n+\n+    if (!r.table->sanitize (*(r.vertex), std::forward<Ts>(ds)...))\n+      return vertex_and_table_t<T> ();\n+\n+    return r;\n+  }\n+\n+  \/\/ Finds the object id of the object pointed to by the offset at 'offset'\n+  \/\/ within object[node_idx].\n+  unsigned index_for_offset (unsigned node_idx, const void* offset) const\n+  {\n+    const auto& node = object (node_idx);\n+    if (offset < node.head || offset >= node.tail) return -1;\n+\n+    unsigned length = node.real_links.length;\n+    for (unsigned i = 0; i < length; i++)\n+    {\n+      \/\/ Use direct access for increased performance, this is a hot method.\n+      const auto& link = node.real_links.arrayZ[i];\n+      if (offset != node.head + link.position)\n+        continue;\n+      return link.objidx;\n+    }\n+\n+    return -1;\n+  }\n+\n+  \/\/ Finds the object id of the object pointed to by the offset at 'offset'\n+  \/\/ within object[node_idx]. Ensures that the returned object is safe to mutate.\n+  \/\/ That is, if the original child object is shared by parents other than node_idx\n+  \/\/ it will be duplicated and the duplicate will be returned instead.\n+  unsigned mutable_index_for_offset (unsigned node_idx, const void* offset)\n+  {\n+    unsigned child_idx = index_for_offset (node_idx, offset);\n+    auto& child = vertices_[child_idx];\n+    for (unsigned p : child.parents)\n+    {\n+      if (p != node_idx) {\n+        return duplicate (node_idx, child_idx);\n+      }\n+    }\n+\n+    return child_idx;\n+  }\n+\n+\n+  \/*\n+   * Assign unique space numbers to each connected subgraph of 24 bit and\/or 32 bit offset(s).\n+   * Currently, this is implemented specifically tailored to the structure of a GPOS\/GSUB\n+   * (including with 24bit offsets) table.\n+   *\/\n+  bool assign_spaces ()\n+  {\n+    update_parents ();\n+\n+    hb_set_t visited;\n+    hb_set_t roots;\n+    find_space_roots (visited, roots);\n+\n+    \/\/ Mark everything not in the subgraphs of the roots as visited. This prevents\n+    \/\/ subgraphs from being connected via nodes not in those subgraphs.\n@@ -296,1 +635,1 @@\n-      unsigned next = HB_SET_VALUE_INVALID;\n+      uint32_t next = HB_SET_VALUE_INVALID;\n@@ -364,0 +703,3 @@\n+    if (in_error ())\n+      return false;\n+\n@@ -377,2 +719,2 @@\n-        | hb_map([&] (unsigned node_idx) {\n-          const unsigned *v;\n+        | hb_map([&] (uint32_t node_idx) {\n+          const uint32_t *v;\n@@ -388,1 +730,1 @@\n-    unsigned next = HB_SET_VALUE_INVALID;\n+    uint32_t next = HB_SET_VALUE_INVALID;\n@@ -391,1 +733,1 @@\n-      const unsigned *v;\n+      const uint32_t *v;\n@@ -406,1 +748,1 @@\n-      const unsigned *v;\n+      const uint32_t *v;\n@@ -425,0 +767,62 @@\n+  size_t find_subgraph_size (unsigned node_idx, hb_set_t& subgraph, unsigned max_depth = -1)\n+  {\n+    if (subgraph.has (node_idx)) return 0;\n+    subgraph.add (node_idx);\n+\n+    const auto& o = vertices_[node_idx].obj;\n+    size_t size = o.tail - o.head;\n+    if (max_depth == 0)\n+      return size;\n+\n+    for (const auto& link : o.all_links ())\n+      size += find_subgraph_size (link.objidx, subgraph, max_depth - 1);\n+    return size;\n+  }\n+\n+  \/*\n+   * Finds the topmost children of 32bit offsets in the subgraph starting\n+   * at node_idx. Found indices are placed into 'found'.\n+   *\/\n+  void find_32bit_roots (unsigned node_idx, hb_set_t& found)\n+  {\n+    for (const auto& link : vertices_[node_idx].obj.all_links ())\n+    {\n+      if (!link.is_signed && link.width == 4) {\n+        found.add (link.objidx);\n+        continue;\n+      }\n+      find_32bit_roots (link.objidx, found);\n+    }\n+  }\n+\n+  \/*\n+   * Moves the child of old_parent_idx pointed to by old_offset to a new\n+   * vertex at the new_offset.\n+   *\/\n+  template<typename O>\n+  void move_child (unsigned old_parent_idx,\n+                   const O* old_offset,\n+                   unsigned new_parent_idx,\n+                   const O* new_offset)\n+  {\n+    distance_invalid = true;\n+    positions_invalid = true;\n+\n+    auto& old_v = vertices_[old_parent_idx];\n+    auto& new_v = vertices_[new_parent_idx];\n+\n+    unsigned child_id = index_for_offset (old_parent_idx,\n+                                          old_offset);\n+\n+    auto* new_link = new_v.obj.real_links.push ();\n+    new_link->width = O::static_size;\n+    new_link->objidx = child_id;\n+    new_link->position = (const char*) new_offset - (const char*) new_v.obj.head;\n+\n+    auto& child = vertices_[child_id];\n+    child.parents.push (new_parent_idx);\n+\n+    old_v.remove_real_link (child_id, old_offset);\n+    child.remove_parent (old_parent_idx);\n+  }\n+\n@@ -435,1 +839,5 @@\n-    index_map.set (node_idx, duplicate (node_idx));\n+    unsigned clone_idx = duplicate (node_idx);\n+    if (!check_success (clone_idx != (unsigned) -1))\n+      return;\n+\n+    index_map.set (node_idx, clone_idx);\n@@ -493,1 +901,14 @@\n-  bool duplicate (unsigned parent_idx, unsigned child_idx)\n+  unsigned duplicate_if_shared (unsigned parent_idx, unsigned child_idx)\n+  {\n+    unsigned new_idx = duplicate (parent_idx, child_idx);\n+    if (new_idx == (unsigned) -1) return child_idx;\n+    return new_idx;\n+  }\n+\n+\n+  \/*\n+   * Creates a copy of child and re-assigns the link from\n+   * parent to the clone. The copy is a shallow copy, objects\n+   * linked from child are not duplicated.\n+   *\/\n+  unsigned duplicate (unsigned parent_idx, unsigned child_idx)\n@@ -507,1 +928,1 @@\n-      DEBUG_MSG (SUBSET_REPACK, nullptr, \"  Not duplicating %d => %d\",\n+      DEBUG_MSG (SUBSET_REPACK, nullptr, \"  Not duplicating %u => %u\",\n@@ -509,1 +930,1 @@\n-      return false;\n+      return -1;\n@@ -512,1 +933,1 @@\n-    DEBUG_MSG (SUBSET_REPACK, nullptr, \"  Duplicating %d => %d\",\n+    DEBUG_MSG (SUBSET_REPACK, nullptr, \"  Duplicating %u => %u\",\n@@ -529,1 +950,34 @@\n-    return true;\n+    return clone_idx;\n+  }\n+\n+\n+  \/*\n+   * Adds a new node to the graph, not connected to anything.\n+   *\/\n+  unsigned new_node (char* head, char* tail)\n+  {\n+    positions_invalid = true;\n+    distance_invalid = true;\n+\n+    auto* clone = vertices_.push ();\n+    if (vertices_.in_error ()) {\n+      return -1;\n+    }\n+\n+    clone->obj.head = head;\n+    clone->obj.tail = tail;\n+    clone->distance = 0;\n+    clone->space = 0;\n+\n+    unsigned clone_idx = vertices_.length - 2;\n+\n+    \/\/ The last object is the root of the graph, so swap back the root to the end.\n+    \/\/ The root's obj idx does change, however since it's root nothing else refers to it.\n+    \/\/ all other obj idx's will be unaffected.\n+    hb_swap (vertices_[vertices_.length - 2], *clone);\n+\n+    \/\/ Since the root moved, update the parents arrays of all children on the root.\n+    for (const auto& l : root ().obj.all_links ())\n+      vertices_[l.objidx].remap_parent (root_idx () - 1, root_idx ());\n+\n+    return clone_idx;\n@@ -537,1 +991,1 @@\n-    DEBUG_MSG (SUBSET_REPACK, nullptr, \"  Raising priority of all children of %d\",\n+    DEBUG_MSG (SUBSET_REPACK, nullptr, \"  Raising priority of all children of %u\",\n@@ -549,0 +1003,66 @@\n+  bool is_fully_connected ()\n+  {\n+    update_parents();\n+\n+    if (root().parents)\n+      \/\/ Root cannot have parents.\n+      return false;\n+\n+    for (unsigned i = 0; i < root_idx (); i++)\n+    {\n+      if (!vertices_[i].parents)\n+        return false;\n+    }\n+    return true;\n+  }\n+\n+#if 0\n+  \/*\n+   * Saves the current graph to a packed binary format which the repacker fuzzer takes\n+   * as a seed.\n+   *\/\n+  void save_fuzzer_seed (hb_tag_t tag) const\n+  {\n+    FILE* f = fopen (\".\/repacker_fuzzer_seed\", \"w\");\n+    fwrite ((void*) &tag, sizeof (tag), 1, f);\n+\n+    uint16_t num_objects = vertices_.length;\n+    fwrite ((void*) &num_objects, sizeof (num_objects), 1, f);\n+\n+    for (const auto& v : vertices_)\n+    {\n+      uint16_t blob_size = v.table_size ();\n+      fwrite ((void*) &blob_size, sizeof (blob_size), 1, f);\n+      fwrite ((const void*) v.obj.head, blob_size, 1, f);\n+    }\n+\n+    uint16_t link_count = 0;\n+    for (const auto& v : vertices_)\n+      link_count += v.obj.real_links.length;\n+\n+    fwrite ((void*) &link_count, sizeof (link_count), 1, f);\n+\n+    typedef struct\n+    {\n+      uint16_t parent;\n+      uint16_t child;\n+      uint16_t position;\n+      uint8_t width;\n+    } link_t;\n+\n+    for (unsigned i = 0; i < vertices_.length; i++)\n+    {\n+      for (const auto& l : vertices_[i].obj.real_links)\n+      {\n+        link_t link {\n+          (uint16_t) i, (uint16_t) l.objidx,\n+          (uint16_t) l.position, (uint8_t) l.width\n+        };\n+        fwrite ((void*) &link, sizeof (link), 1, f);\n+      }\n+    }\n+\n+    fclose (f);\n+  }\n+#endif\n+\n@@ -557,0 +1077,4 @@\n+    if (root().parents) {\n+      DEBUG_MSG (SUBSET_REPACK, nullptr, \"Root node has incoming edges.\");\n+    }\n+\n@@ -625,1 +1149,1 @@\n-   * Returns the numbers of incoming edges that are 32bits wide.\n+   * Returns the numbers of incoming edges that are 24 or 32 bits wide.\n@@ -639,1 +1163,3 @@\n-        if (l.objidx == node_idx && l.width == 4 && !l.is_signed)\n+        if (l.objidx == node_idx\n+            && (l.width == 3 || l.width == 4)\n+            && !l.is_signed)\n@@ -671,0 +1197,5 @@\n+    for (unsigned i = 0; i < vertices_.length; i++)\n+      \/\/ parents arrays must be accurate or downstream operations like cycle detection\n+      \/\/ and sorting won't work correctly.\n+      check_success (!vertices_[i].parents.in_error ());\n+\n@@ -789,1 +1320,1 @@\n-        const unsigned *v;\n+        const uint32_t *v;\n@@ -856,0 +1387,1 @@\n+  hb_vector_t<char*> buffers;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/graph\/graph.hh","additions":567,"deletions":35,"binary":false,"changes":602,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright © 2022  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger\n+ *\/\n+\n+#include \"gsubgpos-graph.hh\"\n+\n+namespace graph {\n+\n+gsubgpos_graph_context_t::gsubgpos_graph_context_t (hb_tag_t table_tag_,\n+                                                    graph_t& graph_)\n+    : table_tag (table_tag_),\n+      graph (graph_),\n+      lookup_list_index (0),\n+      lookups ()\n+{\n+  if (table_tag_ != HB_OT_TAG_GPOS\n+      &&  table_tag_ != HB_OT_TAG_GSUB)\n+    return;\n+\n+  GSTAR* gstar = graph::GSTAR::graph_to_gstar (graph_);\n+  if (gstar) {\n+    gstar->find_lookups (graph, lookups);\n+    lookup_list_index = gstar->get_lookup_list_index (graph_);\n+  }\n+}\n+\n+unsigned gsubgpos_graph_context_t::create_node (unsigned size)\n+{\n+  char* buffer = (char*) hb_calloc (1, size);\n+  if (!buffer)\n+    return -1;\n+\n+  add_buffer (buffer);\n+\n+  return graph.new_node (buffer, buffer + size);\n+}\n+\n+unsigned gsubgpos_graph_context_t::num_non_ext_subtables ()  {\n+  unsigned count = 0;\n+  for (auto l : lookups.values ())\n+  {\n+    if (l->is_extension (table_tag)) continue;\n+    count += l->number_of_subtables ();\n+  }\n+  return count;\n+}\n+\n+}\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/graph\/gsubgpos-context.cc","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright © 2022  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger\n+ *\/\n+\n+#include \"graph.hh\"\n+#include \"..\/hb-ot-layout-gsubgpos.hh\"\n+\n+#ifndef GRAPH_GSUBGPOS_CONTEXT_HH\n+#define GRAPH_GSUBGPOS_CONTEXT_HH\n+\n+namespace graph {\n+\n+struct Lookup;\n+\n+struct gsubgpos_graph_context_t\n+{\n+  hb_tag_t table_tag;\n+  graph_t& graph;\n+  unsigned lookup_list_index;\n+  hb_hashmap_t<unsigned, graph::Lookup*> lookups;\n+\n+\n+  HB_INTERNAL gsubgpos_graph_context_t (hb_tag_t table_tag_,\n+                                        graph_t& graph_);\n+\n+  HB_INTERNAL unsigned create_node (unsigned size);\n+\n+  void add_buffer (char* buffer)\n+  {\n+    graph.add_buffer (buffer);\n+  }\n+\n+ private:\n+  HB_INTERNAL unsigned num_non_ext_subtables ();\n+};\n+\n+}\n+\n+#endif  \/\/ GRAPH_GSUBGPOS_CONTEXT\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/graph\/gsubgpos-context.hh","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,414 @@\n+\/*\n+ * Copyright © 2022  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger\n+ *\/\n+\n+#include \"graph.hh\"\n+#include \"..\/hb-ot-layout-gsubgpos.hh\"\n+#include \"..\/OT\/Layout\/GSUB\/ExtensionSubst.hh\"\n+#include \"gsubgpos-context.hh\"\n+#include \"pairpos-graph.hh\"\n+#include \"markbasepos-graph.hh\"\n+\n+#ifndef GRAPH_GSUBGPOS_GRAPH_HH\n+#define GRAPH_GSUBGPOS_GRAPH_HH\n+\n+namespace graph {\n+\n+struct Lookup;\n+\n+template<typename T>\n+struct ExtensionFormat1 : public OT::ExtensionFormat1<T>\n+{\n+  void reset(unsigned type)\n+  {\n+    this->format = 1;\n+    this->extensionLookupType = type;\n+    this->extensionOffset = 0;\n+  }\n+\n+  bool sanitize (graph_t::vertex_t& vertex) const\n+  {\n+    int64_t vertex_len = vertex.obj.tail - vertex.obj.head;\n+    return vertex_len >= OT::ExtensionFormat1<T>::static_size;\n+  }\n+\n+  unsigned get_lookup_type () const\n+  {\n+    return this->extensionLookupType;\n+  }\n+\n+  unsigned get_subtable_index (graph_t& graph, unsigned this_index) const\n+  {\n+    return graph.index_for_offset (this_index, &this->extensionOffset);\n+  }\n+};\n+\n+struct Lookup : public OT::Lookup\n+{\n+  unsigned number_of_subtables () const\n+  {\n+    return subTable.len;\n+  }\n+\n+  bool sanitize (graph_t::vertex_t& vertex) const\n+  {\n+    int64_t vertex_len = vertex.obj.tail - vertex.obj.head;\n+    if (vertex_len < OT::Lookup::min_size) return false;\n+    return vertex_len >= this->get_size ();\n+  }\n+\n+  bool is_extension (hb_tag_t table_tag) const\n+  {\n+    return lookupType == extension_type (table_tag);\n+  }\n+\n+  bool make_extension (gsubgpos_graph_context_t& c,\n+                       unsigned this_index)\n+  {\n+    unsigned type = lookupType;\n+    unsigned ext_type = extension_type (c.table_tag);\n+    if (!ext_type || is_extension (c.table_tag))\n+    {\n+      \/\/ NOOP\n+      return true;\n+    }\n+\n+    DEBUG_MSG (SUBSET_REPACK, nullptr,\n+               \"Promoting lookup type %u (obj %u) to extension.\",\n+               type,\n+               this_index);\n+\n+    for (unsigned i = 0; i < subTable.len; i++)\n+    {\n+      unsigned subtable_index = c.graph.index_for_offset (this_index, &subTable[i]);\n+      if (!make_subtable_extension (c,\n+                                    this_index,\n+                                    subtable_index))\n+        return false;\n+    }\n+\n+    lookupType = ext_type;\n+    return true;\n+  }\n+\n+  bool split_subtables_if_needed (gsubgpos_graph_context_t& c,\n+                                  unsigned this_index)\n+  {\n+    unsigned type = lookupType;\n+    bool is_ext = is_extension (c.table_tag);\n+\n+    if (c.table_tag != HB_OT_TAG_GPOS)\n+      return true;\n+\n+    if (!is_ext &&\n+        type != OT::Layout::GPOS_impl::PosLookupSubTable::Type::Pair &&\n+        type != OT::Layout::GPOS_impl::PosLookupSubTable::Type::MarkBase)\n+      return true;\n+\n+    hb_vector_t<hb_pair_t<unsigned, hb_vector_t<unsigned>>> all_new_subtables;\n+    for (unsigned i = 0; i < subTable.len; i++)\n+    {\n+      unsigned subtable_index = c.graph.index_for_offset (this_index, &subTable[i]);\n+      unsigned parent_index = this_index;\n+      if (is_ext) {\n+        unsigned ext_subtable_index = subtable_index;\n+        parent_index = ext_subtable_index;\n+        ExtensionFormat1<OT::Layout::GSUB_impl::ExtensionSubst>* extension =\n+            (ExtensionFormat1<OT::Layout::GSUB_impl::ExtensionSubst>*)\n+            c.graph.object (ext_subtable_index).head;\n+        if (!extension || !extension->sanitize (c.graph.vertices_[ext_subtable_index]))\n+          continue;\n+\n+        subtable_index = extension->get_subtable_index (c.graph, ext_subtable_index);\n+        type = extension->get_lookup_type ();\n+        if (type != OT::Layout::GPOS_impl::PosLookupSubTable::Type::Pair\n+            && type != OT::Layout::GPOS_impl::PosLookupSubTable::Type::MarkBase)\n+          continue;\n+      }\n+\n+      hb_vector_t<unsigned> new_sub_tables;\n+      switch (type)\n+      {\n+      case 2:\n+        new_sub_tables = split_subtable<PairPos> (c, parent_index, subtable_index); break;\n+      case 4:\n+        new_sub_tables = split_subtable<MarkBasePos> (c, parent_index, subtable_index); break;\n+      default:\n+        break;\n+      }\n+      if (new_sub_tables.in_error ()) return false;\n+      if (!new_sub_tables) continue;\n+      hb_pair_t<unsigned, hb_vector_t<unsigned>>* entry = all_new_subtables.push ();\n+      entry->first = i;\n+      entry->second = std::move (new_sub_tables);\n+    }\n+\n+    if (all_new_subtables) {\n+      add_sub_tables (c, this_index, type, all_new_subtables);\n+    }\n+\n+    return true;\n+  }\n+\n+  template<typename T>\n+  hb_vector_t<unsigned> split_subtable (gsubgpos_graph_context_t& c,\n+                                        unsigned parent_idx,\n+                                        unsigned objidx)\n+  {\n+    T* sub_table = (T*) c.graph.object (objidx).head;\n+    if (!sub_table || !sub_table->sanitize (c.graph.vertices_[objidx]))\n+      return hb_vector_t<unsigned> ();\n+\n+    return sub_table->split_subtables (c, parent_idx, objidx);\n+  }\n+\n+  void add_sub_tables (gsubgpos_graph_context_t& c,\n+                       unsigned this_index,\n+                       unsigned type,\n+                       hb_vector_t<hb_pair_t<unsigned, hb_vector_t<unsigned>>>& subtable_ids)\n+  {\n+    bool is_ext = is_extension (c.table_tag);\n+    auto& v = c.graph.vertices_[this_index];\n+    fix_existing_subtable_links (c, this_index, subtable_ids);\n+\n+    unsigned new_subtable_count = 0;\n+    for (const auto& p : subtable_ids)\n+      new_subtable_count += p.second.length;\n+\n+    size_t new_size = v.table_size ()\n+                      + new_subtable_count * OT::Offset16::static_size;\n+    char* buffer = (char*) hb_calloc (1, new_size);\n+    c.add_buffer (buffer);\n+    hb_memcpy (buffer, v.obj.head, v.table_size());\n+\n+    v.obj.head = buffer;\n+    v.obj.tail = buffer + new_size;\n+\n+    Lookup* new_lookup = (Lookup*) buffer;\n+\n+    unsigned shift = 0;\n+    new_lookup->subTable.len = subTable.len + new_subtable_count;\n+    for (const auto& p : subtable_ids)\n+    {\n+      unsigned offset_index = p.first + shift + 1;\n+      shift += p.second.length;\n+\n+      for (unsigned subtable_id : p.second)\n+      {\n+        if (is_ext)\n+        {\n+          unsigned ext_id = create_extension_subtable (c, subtable_id, type);\n+          c.graph.vertices_[subtable_id].parents.push (ext_id);\n+          subtable_id = ext_id;\n+        }\n+\n+        auto* link = v.obj.real_links.push ();\n+        link->width = 2;\n+        link->objidx = subtable_id;\n+        link->position = (char*) &new_lookup->subTable[offset_index++] -\n+                         (char*) new_lookup;\n+        c.graph.vertices_[subtable_id].parents.push (this_index);\n+      }\n+    }\n+\n+    \/\/ Repacker sort order depends on link order, which we've messed up so resort it.\n+    v.obj.real_links.qsort ();\n+\n+    \/\/ The head location of the lookup has changed, invalidating the lookups map entry\n+    \/\/ in the context. Update the map.\n+    c.lookups.set (this_index, new_lookup);\n+  }\n+\n+  void fix_existing_subtable_links (gsubgpos_graph_context_t& c,\n+                                    unsigned this_index,\n+                                    hb_vector_t<hb_pair_t<unsigned, hb_vector_t<unsigned>>>& subtable_ids)\n+  {\n+    auto& v = c.graph.vertices_[this_index];\n+    Lookup* lookup = (Lookup*) v.obj.head;\n+\n+    unsigned shift = 0;\n+    for (const auto& p : subtable_ids)\n+    {\n+      unsigned insert_index = p.first + shift;\n+      unsigned pos_offset = p.second.length * OT::Offset16::static_size;\n+      unsigned insert_offset = (char*) &lookup->subTable[insert_index] - (char*) lookup;\n+      shift += p.second.length;\n+\n+      for (auto& l : v.obj.all_links_writer ())\n+      {\n+        if (l.position > insert_offset) l.position += pos_offset;\n+      }\n+    }\n+  }\n+\n+  unsigned create_extension_subtable (gsubgpos_graph_context_t& c,\n+                                      unsigned subtable_index,\n+                                      unsigned type)\n+  {\n+    unsigned extension_size = OT::ExtensionFormat1<OT::Layout::GSUB_impl::ExtensionSubst>::static_size;\n+\n+    unsigned ext_index = c.create_node (extension_size);\n+    if (ext_index == (unsigned) -1)\n+      return -1;\n+\n+    auto& ext_vertex = c.graph.vertices_[ext_index];\n+    ExtensionFormat1<OT::Layout::GSUB_impl::ExtensionSubst>* extension =\n+        (ExtensionFormat1<OT::Layout::GSUB_impl::ExtensionSubst>*) ext_vertex.obj.head;\n+    extension->reset (type);\n+\n+    \/\/ Make extension point at the subtable.\n+    auto* l = ext_vertex.obj.real_links.push ();\n+\n+    l->width = 4;\n+    l->objidx = subtable_index;\n+    l->position = 4;\n+\n+    return ext_index;\n+  }\n+\n+  bool make_subtable_extension (gsubgpos_graph_context_t& c,\n+                                unsigned lookup_index,\n+                                unsigned subtable_index)\n+  {\n+    unsigned type = lookupType;\n+\n+    unsigned ext_index = create_extension_subtable(c, subtable_index, type);\n+    if (ext_index == (unsigned) -1)\n+      return false;\n+\n+    auto& lookup_vertex = c.graph.vertices_[lookup_index];\n+    for (auto& l : lookup_vertex.obj.real_links.writer ())\n+    {\n+      if (l.objidx == subtable_index)\n+        \/\/ Change lookup to point at the extension.\n+        l.objidx = ext_index;\n+    }\n+\n+    \/\/ Make extension point at the subtable.\n+    auto& ext_vertex = c.graph.vertices_[ext_index];\n+    auto& subtable_vertex = c.graph.vertices_[subtable_index];\n+    ext_vertex.parents.push (lookup_index);\n+    subtable_vertex.remap_parent (lookup_index, ext_index);\n+\n+    return true;\n+  }\n+\n+ private:\n+  unsigned extension_type (hb_tag_t table_tag) const\n+  {\n+    switch (table_tag)\n+    {\n+    case HB_OT_TAG_GPOS: return 9;\n+    case HB_OT_TAG_GSUB: return 7;\n+    default: return 0;\n+    }\n+  }\n+};\n+\n+template <typename T>\n+struct LookupList : public OT::LookupList<T>\n+{\n+  bool sanitize (const graph_t::vertex_t& vertex) const\n+  {\n+    int64_t vertex_len = vertex.obj.tail - vertex.obj.head;\n+    if (vertex_len < OT::LookupList<T>::min_size) return false;\n+    return vertex_len >= OT::LookupList<T>::item_size * this->len;\n+  }\n+};\n+\n+struct GSTAR : public OT::GSUBGPOS\n+{\n+  static GSTAR* graph_to_gstar (graph_t& graph)\n+  {\n+    const auto& r = graph.root ();\n+\n+    GSTAR* gstar = (GSTAR*) r.obj.head;\n+    if (!gstar || !gstar->sanitize (r))\n+      return nullptr;\n+\n+    return gstar;\n+  }\n+\n+  const void* get_lookup_list_field_offset () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return u.version1.get_lookup_list_offset ();\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return u.version2.get_lookup_list_offset ();\n+#endif\n+    default: return 0;\n+    }\n+  }\n+\n+  bool sanitize (const graph_t::vertex_t& vertex)\n+  {\n+    int64_t len = vertex.obj.tail - vertex.obj.head;\n+    if (len < OT::GSUBGPOS::min_size) return false;\n+    return len >= get_size ();\n+  }\n+\n+  void find_lookups (graph_t& graph,\n+                     hb_hashmap_t<unsigned, Lookup*>& lookups \/* OUT *\/)\n+  {\n+    switch (u.version.major) {\n+      case 1: find_lookups<SmallTypes> (graph, lookups); break;\n+#ifndef HB_NO_BEYOND_64K\n+      case 2: find_lookups<MediumTypes> (graph, lookups); break;\n+#endif\n+    }\n+  }\n+\n+  unsigned get_lookup_list_index (graph_t& graph)\n+  {\n+    return graph.index_for_offset (graph.root_idx (),\n+                                   get_lookup_list_field_offset());\n+  }\n+\n+  template<typename Types>\n+  void find_lookups (graph_t& graph,\n+                     hb_hashmap_t<unsigned, Lookup*>& lookups \/* OUT *\/)\n+  {\n+    unsigned lookup_list_idx = get_lookup_list_index (graph);\n+    const LookupList<Types>* lookupList =\n+        (const LookupList<Types>*) graph.object (lookup_list_idx).head;\n+    if (!lookupList || !lookupList->sanitize (graph.vertices_[lookup_list_idx]))\n+      return;\n+\n+    for (unsigned i = 0; i < lookupList->len; i++)\n+    {\n+      unsigned lookup_idx = graph.index_for_offset (lookup_list_idx, &(lookupList->arrayZ[i]));\n+      Lookup* lookup = (Lookup*) graph.object (lookup_idx).head;\n+      if (!lookup || !lookup->sanitize (graph.vertices_[lookup_idx])) continue;\n+      lookups.set (lookup_idx, lookup);\n+    }\n+  }\n+};\n+\n+\n+\n+\n+}\n+\n+#endif  \/* GRAPH_GSUBGPOS_GRAPH_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/graph\/gsubgpos-graph.hh","additions":414,"deletions":0,"binary":false,"changes":414,"status":"added"},{"patch":"@@ -0,0 +1,510 @@\n+\/*\n+ * Copyright © 2022  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger\n+ *\/\n+\n+#ifndef GRAPH_MARKBASEPOS_GRAPH_HH\n+#define GRAPH_MARKBASEPOS_GRAPH_HH\n+\n+#include \"split-helpers.hh\"\n+#include \"coverage-graph.hh\"\n+#include \"..\/OT\/Layout\/GPOS\/MarkBasePos.hh\"\n+#include \"..\/OT\/Layout\/GPOS\/PosLookupSubTable.hh\"\n+\n+namespace graph {\n+\n+struct AnchorMatrix : public OT::Layout::GPOS_impl::AnchorMatrix\n+{\n+  bool sanitize (graph_t::vertex_t& vertex, unsigned class_count) const\n+  {\n+    int64_t vertex_len = vertex.obj.tail - vertex.obj.head;\n+    if (vertex_len < AnchorMatrix::min_size) return false;\n+\n+    return vertex_len >= AnchorMatrix::min_size +\n+        OT::Offset16::static_size * class_count * this->rows;\n+  }\n+\n+  bool shrink (gsubgpos_graph_context_t& c,\n+               unsigned this_index,\n+               unsigned old_class_count,\n+               unsigned new_class_count)\n+  {\n+    if (new_class_count >= old_class_count) return false;\n+    auto& o = c.graph.vertices_[this_index].obj;\n+    unsigned base_count = rows;\n+    o.tail = o.head +\n+             AnchorMatrix::min_size +\n+             OT::Offset16::static_size * base_count * new_class_count;\n+\n+    \/\/ Reposition links into the new indexing scheme.\n+    for (auto& link : o.real_links.writer ())\n+    {\n+      unsigned index = (link.position - 2) \/ 2;\n+      unsigned base = index \/ old_class_count;\n+      unsigned klass = index % old_class_count;\n+      if (klass >= new_class_count)\n+        \/\/ should have already been removed\n+        return false;\n+\n+      unsigned new_index = base * new_class_count + klass;\n+\n+      link.position = (char*) &(this->matrixZ[new_index]) - (char*) this;\n+    }\n+\n+    return true;\n+  }\n+\n+  unsigned clone (gsubgpos_graph_context_t& c,\n+                  unsigned this_index,\n+                  unsigned start,\n+                  unsigned end,\n+                  unsigned class_count)\n+  {\n+    unsigned base_count = rows;\n+    unsigned new_class_count = end - start;\n+    unsigned size = AnchorMatrix::min_size +\n+                    OT::Offset16::static_size * new_class_count * rows;\n+    unsigned prime_id = c.create_node (size);\n+    if (prime_id == (unsigned) -1) return -1;\n+    AnchorMatrix* prime = (AnchorMatrix*) c.graph.object (prime_id).head;\n+    prime->rows = base_count;\n+\n+    auto& o = c.graph.vertices_[this_index].obj;\n+    int num_links = o.real_links.length;\n+    for (int i = 0; i < num_links; i++)\n+    {\n+      const auto& link = o.real_links[i];\n+      unsigned old_index = (link.position - 2) \/ OT::Offset16::static_size;\n+      unsigned klass = old_index % class_count;\n+      if (klass < start || klass >= end) continue;\n+\n+      unsigned base = old_index \/ class_count;\n+      unsigned new_klass = klass - start;\n+      unsigned new_index = base * new_class_count + new_klass;\n+\n+\n+      unsigned child_idx = link.objidx;\n+      c.graph.add_link (&(prime->matrixZ[new_index]),\n+                        prime_id,\n+                        child_idx);\n+\n+      auto& child = c.graph.vertices_[child_idx];\n+      child.remove_parent (this_index);\n+\n+      o.real_links.remove_unordered (i);\n+      num_links--;\n+      i--;\n+    }\n+\n+    return prime_id;\n+  }\n+};\n+\n+struct MarkArray : public OT::Layout::GPOS_impl::MarkArray\n+{\n+  bool sanitize (graph_t::vertex_t& vertex) const\n+  {\n+    int64_t vertex_len = vertex.obj.tail - vertex.obj.head;\n+    unsigned min_size = MarkArray::min_size;\n+    if (vertex_len < min_size) return false;\n+\n+    return vertex_len >= get_size ();\n+  }\n+\n+  bool shrink (gsubgpos_graph_context_t& c,\n+               const hb_hashmap_t<unsigned, unsigned>& mark_array_links,\n+               unsigned this_index,\n+               unsigned new_class_count)\n+  {\n+    auto& o = c.graph.vertices_[this_index].obj;\n+    for (const auto& link : o.real_links)\n+      c.graph.vertices_[link.objidx].remove_parent (this_index);\n+    o.real_links.reset ();\n+\n+    unsigned new_index = 0;\n+    for (const auto& record : this->iter ())\n+    {\n+      unsigned klass = record.klass;\n+      if (klass >= new_class_count) continue;\n+\n+      (*this)[new_index].klass = klass;\n+      unsigned position = (char*) &record.markAnchor - (char*) this;\n+      unsigned* objidx;\n+      if (!mark_array_links.has (position, &objidx))\n+      {\n+        new_index++;\n+        continue;\n+      }\n+\n+      c.graph.add_link (&(*this)[new_index].markAnchor, this_index, *objidx);\n+      new_index++;\n+    }\n+\n+    this->len = new_index;\n+    o.tail = o.head + MarkArray::min_size +\n+             OT::Layout::GPOS_impl::MarkRecord::static_size * new_index;\n+    return true;\n+  }\n+\n+  unsigned clone (gsubgpos_graph_context_t& c,\n+                  unsigned this_index,\n+                  const hb_hashmap_t<unsigned, unsigned>& pos_to_index,\n+                  hb_set_t& marks,\n+                  unsigned start_class)\n+  {\n+    unsigned size = MarkArray::min_size +\n+                    OT::Layout::GPOS_impl::MarkRecord::static_size *\n+                    marks.get_population ();\n+    unsigned prime_id = c.create_node (size);\n+    if (prime_id == (unsigned) -1) return -1;\n+    MarkArray* prime = (MarkArray*) c.graph.object (prime_id).head;\n+    prime->len = marks.get_population ();\n+\n+\n+    unsigned i = 0;\n+    for (hb_codepoint_t mark : marks)\n+    {\n+      (*prime)[i].klass = (*this)[mark].klass - start_class;\n+      unsigned offset_pos = (char*) &((*this)[mark].markAnchor) - (char*) this;\n+      unsigned* anchor_index;\n+      if (pos_to_index.has (offset_pos, &anchor_index))\n+        c.graph.move_child (this_index,\n+                            &((*this)[mark].markAnchor),\n+                            prime_id,\n+                            &((*prime)[i].markAnchor));\n+\n+      i++;\n+    }\n+\n+    return prime_id;\n+  }\n+};\n+\n+struct MarkBasePosFormat1 : public OT::Layout::GPOS_impl::MarkBasePosFormat1_2<SmallTypes>\n+{\n+  bool sanitize (graph_t::vertex_t& vertex) const\n+  {\n+    int64_t vertex_len = vertex.obj.tail - vertex.obj.head;\n+    return vertex_len >= MarkBasePosFormat1::static_size;\n+  }\n+\n+  hb_vector_t<unsigned> split_subtables (gsubgpos_graph_context_t& c,\n+                                         unsigned parent_index,\n+                                         unsigned this_index)\n+  {\n+    hb_set_t visited;\n+\n+    const unsigned base_coverage_id = c.graph.index_for_offset (this_index, &baseCoverage);\n+    const unsigned base_size =\n+        OT::Layout::GPOS_impl::PairPosFormat1_3<SmallTypes>::min_size +\n+        MarkArray::min_size +\n+        AnchorMatrix::min_size +\n+        c.graph.vertices_[base_coverage_id].table_size ();\n+\n+    hb_vector_t<class_info_t> class_to_info = get_class_info (c, this_index);\n+\n+    unsigned class_count = classCount;\n+    auto base_array = c.graph.as_table<AnchorMatrix> (this_index,\n+                                                      &baseArray,\n+                                                      class_count);\n+    if (!base_array) return hb_vector_t<unsigned> ();\n+    unsigned base_count = base_array.table->rows;\n+\n+    unsigned partial_coverage_size = 4;\n+    unsigned accumulated = base_size;\n+    hb_vector_t<unsigned> split_points;\n+\n+    for (unsigned klass = 0; klass < class_count; klass++)\n+    {\n+      class_info_t& info = class_to_info[klass];\n+      partial_coverage_size += OT::HBUINT16::static_size * info.marks.get_population ();\n+      unsigned accumulated_delta =\n+          OT::Layout::GPOS_impl::MarkRecord::static_size * info.marks.get_population () +\n+          OT::Offset16::static_size * base_count;\n+\n+      for (unsigned objidx : info.child_indices)\n+        accumulated_delta += c.graph.find_subgraph_size (objidx, visited);\n+\n+      accumulated += accumulated_delta;\n+      unsigned total = accumulated + partial_coverage_size;\n+\n+      if (total >= (1 << 16))\n+      {\n+        split_points.push (klass);\n+        accumulated = base_size + accumulated_delta;\n+        partial_coverage_size = 4 + OT::HBUINT16::static_size * info.marks.get_population ();\n+        visited.clear (); \/\/ node sharing isn't allowed between splits.\n+      }\n+    }\n+\n+\n+    const unsigned mark_array_id = c.graph.index_for_offset (this_index, &markArray);\n+    split_context_t split_context {\n+      c,\n+      this,\n+      c.graph.duplicate_if_shared (parent_index, this_index),\n+      std::move (class_to_info),\n+      c.graph.vertices_[mark_array_id].position_to_index_map (),\n+    };\n+\n+    return actuate_subtable_split<split_context_t> (split_context, split_points);\n+  }\n+\n+ private:\n+\n+  struct class_info_t {\n+    hb_set_t marks;\n+    hb_vector_t<unsigned> child_indices;\n+  };\n+\n+  struct split_context_t {\n+    gsubgpos_graph_context_t& c;\n+    MarkBasePosFormat1* thiz;\n+    unsigned this_index;\n+    hb_vector_t<class_info_t> class_to_info;\n+    hb_hashmap_t<unsigned, unsigned> mark_array_links;\n+\n+    hb_set_t marks_for (unsigned start, unsigned end)\n+    {\n+      hb_set_t marks;\n+      for (unsigned klass = start; klass < end; klass++)\n+      {\n+        + class_to_info[klass].marks.iter ()\n+        | hb_sink (marks)\n+        ;\n+      }\n+      return marks;\n+    }\n+\n+    unsigned original_count ()\n+    {\n+      return thiz->classCount;\n+    }\n+\n+    unsigned clone_range (unsigned start, unsigned end)\n+    {\n+      return thiz->clone_range (*this, this->this_index, start, end);\n+    }\n+\n+    bool shrink (unsigned count)\n+    {\n+      return thiz->shrink (*this, this->this_index, count);\n+    }\n+  };\n+\n+  hb_vector_t<class_info_t> get_class_info (gsubgpos_graph_context_t& c,\n+                                            unsigned this_index)\n+  {\n+    hb_vector_t<class_info_t> class_to_info;\n+\n+    unsigned class_count= classCount;\n+    class_to_info.resize (class_count);\n+\n+    auto mark_array = c.graph.as_table<MarkArray> (this_index, &markArray);\n+    if (!mark_array) return hb_vector_t<class_info_t> ();\n+    unsigned mark_count = mark_array.table->len;\n+    for (unsigned mark = 0; mark < mark_count; mark++)\n+    {\n+      unsigned klass = (*mark_array.table)[mark].get_class ();\n+      class_to_info[klass].marks.add (mark);\n+    }\n+\n+    for (const auto& link : mark_array.vertex->obj.real_links)\n+    {\n+      unsigned mark = (link.position - 2) \/\n+                     OT::Layout::GPOS_impl::MarkRecord::static_size;\n+      unsigned klass = (*mark_array.table)[mark].get_class ();\n+      class_to_info[klass].child_indices.push (link.objidx);\n+    }\n+\n+    unsigned base_array_id =\n+        c.graph.index_for_offset (this_index, &baseArray);\n+    auto& base_array_v = c.graph.vertices_[base_array_id];\n+\n+    for (const auto& link : base_array_v.obj.real_links)\n+    {\n+      unsigned index = (link.position - 2) \/ OT::Offset16::static_size;\n+      unsigned klass = index % class_count;\n+      class_to_info[klass].child_indices.push (link.objidx);\n+    }\n+\n+    return class_to_info;\n+  }\n+\n+  bool shrink (split_context_t& sc,\n+               unsigned this_index,\n+               unsigned count)\n+  {\n+    DEBUG_MSG (SUBSET_REPACK, nullptr,\n+               \"  Shrinking MarkBasePosFormat1 (%u) to [0, %u).\",\n+               this_index,\n+               count);\n+\n+    unsigned old_count = classCount;\n+    if (count >= old_count)\n+      return true;\n+\n+    classCount = count;\n+\n+    auto mark_coverage = sc.c.graph.as_mutable_table<Coverage> (this_index,\n+                                                                &markCoverage);\n+    if (!mark_coverage) return false;\n+    hb_set_t marks = sc.marks_for (0, count);\n+    auto new_coverage =\n+        + hb_enumerate (mark_coverage.table->iter ())\n+        | hb_filter (marks, hb_first)\n+        | hb_map_retains_sorting (hb_second)\n+        ;\n+    if (!Coverage::make_coverage (sc.c, + new_coverage,\n+                                  mark_coverage.index,\n+                                  4 + 2 * marks.get_population ()))\n+      return false;\n+\n+\n+    auto base_array = sc.c.graph.as_mutable_table<AnchorMatrix> (this_index,\n+                                                                 &baseArray,\n+                                                                 old_count);\n+    if (!base_array || !base_array.table->shrink (sc.c,\n+                                                  base_array.index,\n+                                                  old_count,\n+                                                  count))\n+      return false;\n+\n+    auto mark_array = sc.c.graph.as_mutable_table<MarkArray> (this_index,\n+                                                              &markArray);\n+    if (!mark_array || !mark_array.table->shrink (sc.c,\n+                                                  sc.mark_array_links,\n+                                                  mark_array.index,\n+                                                  count))\n+      return false;\n+\n+    return true;\n+  }\n+\n+  \/\/ Create a new MarkBasePos that has all of the data for classes from [start, end).\n+  unsigned clone_range (split_context_t& sc,\n+                        unsigned this_index,\n+                        unsigned start, unsigned end) const\n+  {\n+    DEBUG_MSG (SUBSET_REPACK, nullptr,\n+               \"  Cloning MarkBasePosFormat1 (%u) range [%u, %u).\", this_index, start, end);\n+\n+    graph_t& graph = sc.c.graph;\n+    unsigned prime_size = OT::Layout::GPOS_impl::MarkBasePosFormat1_2<SmallTypes>::static_size;\n+\n+    unsigned prime_id = sc.c.create_node (prime_size);\n+    if (prime_id == (unsigned) -1) return -1;\n+\n+    MarkBasePosFormat1* prime = (MarkBasePosFormat1*) graph.object (prime_id).head;\n+    prime->format = this->format;\n+    unsigned new_class_count = end - start;\n+    prime->classCount = new_class_count;\n+\n+    unsigned base_coverage_id =\n+        graph.index_for_offset (sc.this_index, &baseCoverage);\n+    graph.add_link (&(prime->baseCoverage), prime_id, base_coverage_id);\n+    graph.duplicate (prime_id, base_coverage_id);\n+\n+    auto mark_coverage = sc.c.graph.as_table<Coverage> (this_index,\n+                                                        &markCoverage);\n+    if (!mark_coverage) return false;\n+    hb_set_t marks = sc.marks_for (start, end);\n+    auto new_coverage =\n+        + hb_enumerate (mark_coverage.table->iter ())\n+        | hb_filter (marks, hb_first)\n+        | hb_map_retains_sorting (hb_second)\n+        ;\n+    if (!Coverage::add_coverage (sc.c,\n+                                 prime_id,\n+                                 2,\n+                                 + new_coverage,\n+                                 marks.get_population () * 2 + 4))\n+      return -1;\n+\n+    auto mark_array =\n+        graph.as_table <MarkArray> (sc.this_index, &markArray);\n+    if (!mark_array) return -1;\n+    unsigned new_mark_array =\n+        mark_array.table->clone (sc.c,\n+                                 mark_array.index,\n+                                 sc.mark_array_links,\n+                                 marks,\n+                                 start);\n+    graph.add_link (&(prime->markArray), prime_id, new_mark_array);\n+\n+    unsigned class_count = classCount;\n+    auto base_array =\n+        graph.as_table<AnchorMatrix> (sc.this_index, &baseArray, class_count);\n+    if (!base_array) return -1;\n+    unsigned new_base_array =\n+        base_array.table->clone (sc.c,\n+                                 base_array.index,\n+                                 start, end, this->classCount);\n+    graph.add_link (&(prime->baseArray), prime_id, new_base_array);\n+\n+    return prime_id;\n+  }\n+};\n+\n+\n+struct MarkBasePos : public OT::Layout::GPOS_impl::MarkBasePos\n+{\n+  hb_vector_t<unsigned> split_subtables (gsubgpos_graph_context_t& c,\n+                                         unsigned parent_index,\n+                                         unsigned this_index)\n+  {\n+    switch (u.format) {\n+    case 1:\n+      return ((MarkBasePosFormat1*)(&u.format1))->split_subtables (c, parent_index, this_index);\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: HB_FALLTHROUGH;\n+      \/\/ Don't split 24bit PairPos's.\n+#endif\n+    default:\n+      return hb_vector_t<unsigned> ();\n+    }\n+  }\n+\n+  bool sanitize (graph_t::vertex_t& vertex) const\n+  {\n+    int64_t vertex_len = vertex.obj.tail - vertex.obj.head;\n+    if (vertex_len < u.format.get_size ()) return false;\n+\n+    switch (u.format) {\n+    case 1:\n+      return ((MarkBasePosFormat1*)(&u.format1))->sanitize (vertex);\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: HB_FALLTHROUGH;\n+#endif\n+    default:\n+      \/\/ We don't handle format 3 and 4 here.\n+      return false;\n+    }\n+  }\n+};\n+\n+\n+}\n+\n+#endif  \/\/ GRAPH_MARKBASEPOS_GRAPH_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/graph\/markbasepos-graph.hh","additions":510,"deletions":0,"binary":false,"changes":510,"status":"added"},{"patch":"@@ -0,0 +1,647 @@\n+\/*\n+ * Copyright © 2022  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger\n+ *\/\n+\n+#ifndef GRAPH_PAIRPOS_GRAPH_HH\n+#define GRAPH_PAIRPOS_GRAPH_HH\n+\n+#include \"split-helpers.hh\"\n+#include \"coverage-graph.hh\"\n+#include \"classdef-graph.hh\"\n+#include \"..\/OT\/Layout\/GPOS\/PairPos.hh\"\n+#include \"..\/OT\/Layout\/GPOS\/PosLookupSubTable.hh\"\n+\n+namespace graph {\n+\n+struct PairPosFormat1 : public OT::Layout::GPOS_impl::PairPosFormat1_3<SmallTypes>\n+{\n+  bool sanitize (graph_t::vertex_t& vertex) const\n+  {\n+    int64_t vertex_len = vertex.obj.tail - vertex.obj.head;\n+    unsigned min_size = OT::Layout::GPOS_impl::PairPosFormat1_3<SmallTypes>::min_size;\n+    if (vertex_len < min_size) return false;\n+\n+    return vertex_len >=\n+        min_size + pairSet.get_size () - pairSet.len.get_size();\n+  }\n+\n+  hb_vector_t<unsigned> split_subtables (gsubgpos_graph_context_t& c,\n+                                         unsigned parent_index,\n+                                         unsigned this_index)\n+  {\n+    hb_set_t visited;\n+\n+    const unsigned coverage_id = c.graph.index_for_offset (this_index, &coverage);\n+    const unsigned coverage_size = c.graph.vertices_[coverage_id].table_size ();\n+    const unsigned base_size = OT::Layout::GPOS_impl::PairPosFormat1_3<SmallTypes>::min_size;\n+\n+    unsigned partial_coverage_size = 4;\n+    unsigned accumulated = base_size;\n+    hb_vector_t<unsigned> split_points;\n+    for (unsigned i = 0; i < pairSet.len; i++)\n+    {\n+      unsigned pair_set_index = pair_set_graph_index (c, this_index, i);\n+      unsigned accumulated_delta =\n+          c.graph.find_subgraph_size (pair_set_index, visited) +\n+          SmallTypes::size; \/\/ for PairSet offset.\n+      partial_coverage_size += OT::HBUINT16::static_size;\n+\n+      accumulated += accumulated_delta;\n+      unsigned total = accumulated + hb_min (partial_coverage_size, coverage_size);\n+\n+      if (total >= (1 << 16))\n+      {\n+        split_points.push (i);\n+        accumulated = base_size + accumulated_delta;\n+        partial_coverage_size = 6;\n+        visited.clear (); \/\/ node sharing isn't allowed between splits.\n+      }\n+    }\n+\n+    split_context_t split_context {\n+      c,\n+      this,\n+      c.graph.duplicate_if_shared (parent_index, this_index),\n+    };\n+\n+    return actuate_subtable_split<split_context_t> (split_context, split_points);\n+  }\n+\n+ private:\n+\n+  struct split_context_t {\n+    gsubgpos_graph_context_t& c;\n+    PairPosFormat1* thiz;\n+    unsigned this_index;\n+\n+    unsigned original_count ()\n+    {\n+      return thiz->pairSet.len;\n+    }\n+\n+    unsigned clone_range (unsigned start, unsigned end)\n+    {\n+      return thiz->clone_range (this->c, this->this_index, start, end);\n+    }\n+\n+    bool shrink (unsigned count)\n+    {\n+      return thiz->shrink (this->c, this->this_index, count);\n+    }\n+  };\n+\n+  bool shrink (gsubgpos_graph_context_t& c,\n+               unsigned this_index,\n+               unsigned count)\n+  {\n+    DEBUG_MSG (SUBSET_REPACK, nullptr,\n+               \"  Shrinking PairPosFormat1 (%u) to [0, %u).\",\n+               this_index,\n+               count);\n+    unsigned old_count = pairSet.len;\n+    if (count >= old_count)\n+      return true;\n+\n+    pairSet.len = count;\n+    c.graph.vertices_[this_index].obj.tail -= (old_count - count) * SmallTypes::size;\n+\n+    auto coverage = c.graph.as_mutable_table<Coverage> (this_index, &this->coverage);\n+    if (!coverage) return false;\n+\n+    unsigned coverage_size = coverage.vertex->table_size ();\n+    auto new_coverage =\n+        + hb_zip (coverage.table->iter (), hb_range ())\n+        | hb_filter ([&] (hb_pair_t<unsigned, unsigned> p) {\n+          return p.second < count;\n+        })\n+        | hb_map_retains_sorting (hb_first)\n+        ;\n+\n+    return Coverage::make_coverage (c, new_coverage, coverage.index, coverage_size);\n+  }\n+\n+  \/\/ Create a new PairPos including PairSet's from start (inclusive) to end (exclusive).\n+  \/\/ Returns object id of the new object.\n+  unsigned clone_range (gsubgpos_graph_context_t& c,\n+                        unsigned this_index,\n+                        unsigned start, unsigned end) const\n+  {\n+    DEBUG_MSG (SUBSET_REPACK, nullptr,\n+               \"  Cloning PairPosFormat1 (%u) range [%u, %u).\", this_index, start, end);\n+\n+    unsigned num_pair_sets = end - start;\n+    unsigned prime_size = OT::Layout::GPOS_impl::PairPosFormat1_3<SmallTypes>::min_size\n+                          + num_pair_sets * SmallTypes::size;\n+\n+    unsigned pair_pos_prime_id = c.create_node (prime_size);\n+    if (pair_pos_prime_id == (unsigned) -1) return -1;\n+\n+    PairPosFormat1* pair_pos_prime = (PairPosFormat1*) c.graph.object (pair_pos_prime_id).head;\n+    pair_pos_prime->format = this->format;\n+    pair_pos_prime->valueFormat[0] = this->valueFormat[0];\n+    pair_pos_prime->valueFormat[1] = this->valueFormat[1];\n+    pair_pos_prime->pairSet.len = num_pair_sets;\n+\n+    for (unsigned i = start; i < end; i++)\n+    {\n+      c.graph.move_child<> (this_index,\n+                            &pairSet[i],\n+                            pair_pos_prime_id,\n+                            &pair_pos_prime->pairSet[i - start]);\n+    }\n+\n+    unsigned coverage_id = c.graph.index_for_offset (this_index, &coverage);\n+    if (!Coverage::clone_coverage (c,\n+                                   coverage_id,\n+                                   pair_pos_prime_id,\n+                                   2,\n+                                   start, end))\n+      return -1;\n+\n+    return pair_pos_prime_id;\n+  }\n+\n+\n+\n+  unsigned pair_set_graph_index (gsubgpos_graph_context_t& c, unsigned this_index, unsigned i) const\n+  {\n+    return c.graph.index_for_offset (this_index, &pairSet[i]);\n+  }\n+};\n+\n+struct PairPosFormat2 : public OT::Layout::GPOS_impl::PairPosFormat2_4<SmallTypes>\n+{\n+  bool sanitize (graph_t::vertex_t& vertex) const\n+  {\n+    size_t vertex_len = vertex.table_size ();\n+    unsigned min_size = OT::Layout::GPOS_impl::PairPosFormat2_4<SmallTypes>::min_size;\n+    if (vertex_len < min_size) return false;\n+\n+    const unsigned class1_count = class1Count;\n+    return vertex_len >=\n+        min_size + class1_count * get_class1_record_size ();\n+  }\n+\n+  hb_vector_t<unsigned> split_subtables (gsubgpos_graph_context_t& c,\n+                                         unsigned parent_index,\n+                                         unsigned this_index)\n+  {\n+    const unsigned base_size = OT::Layout::GPOS_impl::PairPosFormat2_4<SmallTypes>::min_size;\n+    const unsigned class_def_2_size = size_of (c, this_index, &classDef2);\n+    const Coverage* coverage = get_coverage (c, this_index);\n+    const ClassDef* class_def_1 = get_class_def_1 (c, this_index);\n+    auto gid_and_class =\n+        + coverage->iter ()\n+        | hb_map_retains_sorting ([&] (hb_codepoint_t gid) {\n+          return hb_pair_t<hb_codepoint_t, hb_codepoint_t> (gid, class_def_1->get_class (gid));\n+        })\n+        ;\n+    class_def_size_estimator_t estimator (gid_and_class);\n+\n+    const unsigned class1_count = class1Count;\n+    const unsigned class2_count = class2Count;\n+    const unsigned class1_record_size = get_class1_record_size ();\n+\n+    const unsigned value_1_len = valueFormat1.get_len ();\n+    const unsigned value_2_len = valueFormat2.get_len ();\n+    const unsigned total_value_len = value_1_len + value_2_len;\n+\n+    unsigned accumulated = base_size;\n+    unsigned coverage_size = 4;\n+    unsigned class_def_1_size = 4;\n+    unsigned max_coverage_size = coverage_size;\n+    unsigned max_class_def_1_size = class_def_1_size;\n+\n+    hb_vector_t<unsigned> split_points;\n+\n+    hb_hashmap_t<unsigned, unsigned> device_tables = get_all_device_tables (c, this_index);\n+    hb_vector_t<unsigned> format1_device_table_indices = valueFormat1.get_device_table_indices ();\n+    hb_vector_t<unsigned> format2_device_table_indices = valueFormat2.get_device_table_indices ();\n+    bool has_device_tables = bool(format1_device_table_indices) || bool(format2_device_table_indices);\n+\n+    hb_set_t visited;\n+    for (unsigned i = 0; i < class1_count; i++)\n+    {\n+      unsigned accumulated_delta = class1_record_size;\n+      coverage_size += estimator.incremental_coverage_size (i);\n+      class_def_1_size += estimator.incremental_class_def_size (i);\n+      max_coverage_size = hb_max (max_coverage_size, coverage_size);\n+      max_class_def_1_size = hb_max (max_class_def_1_size, class_def_1_size);\n+\n+      if (has_device_tables) {\n+        for (unsigned j = 0; j < class2_count; j++)\n+        {\n+          unsigned value1_index = total_value_len * (class2_count * i + j);\n+          unsigned value2_index = value1_index + value_1_len;\n+          accumulated_delta += size_of_value_record_children (c,\n+                                                        device_tables,\n+                                                        format1_device_table_indices,\n+                                                        value1_index,\n+                                                        visited);\n+          accumulated_delta += size_of_value_record_children (c,\n+                                                        device_tables,\n+                                                        format2_device_table_indices,\n+                                                        value2_index,\n+                                                        visited);\n+        }\n+      }\n+\n+      accumulated += accumulated_delta;\n+      unsigned total = accumulated\n+                       + coverage_size + class_def_1_size + class_def_2_size\n+                       \/\/ The largest object will pack last and can exceed the size limit.\n+                       - hb_max (hb_max (coverage_size, class_def_1_size), class_def_2_size);\n+      if (total >= (1 << 16))\n+      {\n+        split_points.push (i);\n+        \/\/ split does not include i, so add the size for i when we reset the size counters.\n+        accumulated = base_size + accumulated_delta;\n+        coverage_size = 4 + estimator.incremental_coverage_size (i);\n+        class_def_1_size = 4 + estimator.incremental_class_def_size (i);\n+        visited.clear (); \/\/ node sharing isn't allowed between splits.\n+      }\n+    }\n+\n+    split_context_t split_context {\n+      c,\n+      this,\n+      c.graph.duplicate_if_shared (parent_index, this_index),\n+      class1_record_size,\n+      total_value_len,\n+      value_1_len,\n+      value_2_len,\n+      max_coverage_size,\n+      max_class_def_1_size,\n+      device_tables,\n+      format1_device_table_indices,\n+      format2_device_table_indices\n+    };\n+\n+    return actuate_subtable_split<split_context_t> (split_context, split_points);\n+  }\n+ private:\n+\n+  struct split_context_t\n+  {\n+    gsubgpos_graph_context_t& c;\n+    PairPosFormat2* thiz;\n+    unsigned this_index;\n+    unsigned class1_record_size;\n+    unsigned value_record_len;\n+    unsigned value1_record_len;\n+    unsigned value2_record_len;\n+    unsigned max_coverage_size;\n+    unsigned max_class_def_size;\n+\n+    const hb_hashmap_t<unsigned, unsigned>& device_tables;\n+    const hb_vector_t<unsigned>& format1_device_table_indices;\n+    const hb_vector_t<unsigned>& format2_device_table_indices;\n+\n+    unsigned original_count ()\n+    {\n+      return thiz->class1Count;\n+    }\n+\n+    unsigned clone_range (unsigned start, unsigned end)\n+    {\n+      return thiz->clone_range (*this, start, end);\n+    }\n+\n+    bool shrink (unsigned count)\n+    {\n+      return thiz->shrink (*this, count);\n+    }\n+  };\n+\n+  size_t get_class1_record_size () const\n+  {\n+    const size_t class2_count = class2Count;\n+    return\n+        class2_count * (valueFormat1.get_size () + valueFormat2.get_size ());\n+  }\n+\n+  unsigned clone_range (split_context_t& split_context,\n+                        unsigned start, unsigned end) const\n+  {\n+    DEBUG_MSG (SUBSET_REPACK, nullptr,\n+               \"  Cloning PairPosFormat2 (%u) range [%u, %u).\", split_context.this_index, start, end);\n+\n+    graph_t& graph = split_context.c.graph;\n+\n+    unsigned num_records = end - start;\n+    unsigned prime_size = OT::Layout::GPOS_impl::PairPosFormat2_4<SmallTypes>::min_size\n+                          + num_records * split_context.class1_record_size;\n+\n+    unsigned pair_pos_prime_id = split_context.c.create_node (prime_size);\n+    if (pair_pos_prime_id == (unsigned) -1) return -1;\n+\n+    PairPosFormat2* pair_pos_prime =\n+        (PairPosFormat2*) graph.object (pair_pos_prime_id).head;\n+    pair_pos_prime->format = this->format;\n+    pair_pos_prime->valueFormat1 = this->valueFormat1;\n+    pair_pos_prime->valueFormat2 = this->valueFormat2;\n+    pair_pos_prime->class1Count = num_records;\n+    pair_pos_prime->class2Count = this->class2Count;\n+    clone_class1_records (split_context,\n+                          pair_pos_prime_id,\n+                          start,\n+                          end);\n+\n+    unsigned coverage_id =\n+        graph.index_for_offset (split_context.this_index, &coverage);\n+    unsigned class_def_1_id =\n+        graph.index_for_offset (split_context.this_index, &classDef1);\n+    auto& coverage_v = graph.vertices_[coverage_id];\n+    auto& class_def_1_v = graph.vertices_[class_def_1_id];\n+    Coverage* coverage_table = (Coverage*) coverage_v.obj.head;\n+    ClassDef* class_def_1_table = (ClassDef*) class_def_1_v.obj.head;\n+    if (!coverage_table\n+        || !coverage_table->sanitize (coverage_v)\n+        || !class_def_1_table\n+        || !class_def_1_table->sanitize (class_def_1_v))\n+      return -1;\n+\n+    auto klass_map =\n+    + coverage_table->iter ()\n+    | hb_map_retains_sorting ([&] (hb_codepoint_t gid) {\n+      return hb_pair_t<hb_codepoint_t, hb_codepoint_t> (gid, class_def_1_table->get_class (gid));\n+    })\n+    | hb_filter ([&] (hb_codepoint_t klass) {\n+      return klass >= start && klass < end;\n+    }, hb_second)\n+    | hb_map_retains_sorting ([&] (hb_pair_t<hb_codepoint_t, hb_codepoint_t> gid_and_class) {\n+      \/\/ Classes must be from 0...N so subtract start\n+      return hb_pair_t<hb_codepoint_t, hb_codepoint_t> (gid_and_class.first, gid_and_class.second - start);\n+    })\n+    ;\n+\n+    if (!Coverage::add_coverage (split_context.c,\n+                                 pair_pos_prime_id,\n+                                 2,\n+                                 + klass_map | hb_map_retains_sorting (hb_first),\n+                                 split_context.max_coverage_size))\n+      return -1;\n+\n+    \/\/ classDef1\n+    if (!ClassDef::add_class_def (split_context.c,\n+                                  pair_pos_prime_id,\n+                                  8,\n+                                  + klass_map,\n+                                  split_context.max_class_def_size))\n+      return -1;\n+\n+    \/\/ classDef2\n+    unsigned class_def_2_id =\n+        graph.index_for_offset (split_context.this_index, &classDef2);\n+    auto* class_def_link = graph.vertices_[pair_pos_prime_id].obj.real_links.push ();\n+    class_def_link->width = SmallTypes::size;\n+    class_def_link->objidx = class_def_2_id;\n+    class_def_link->position = 10;\n+    graph.vertices_[class_def_2_id].parents.push (pair_pos_prime_id);\n+    graph.duplicate (pair_pos_prime_id, class_def_2_id);\n+\n+    return pair_pos_prime_id;\n+  }\n+\n+  void clone_class1_records (split_context_t& split_context,\n+                             unsigned pair_pos_prime_id,\n+                             unsigned start, unsigned end) const\n+  {\n+    PairPosFormat2* pair_pos_prime =\n+        (PairPosFormat2*) split_context.c.graph.object (pair_pos_prime_id).head;\n+\n+    char* start_addr = ((char*)&values[0]) + start * split_context.class1_record_size;\n+    unsigned num_records = end - start;\n+    hb_memcpy (&pair_pos_prime->values[0],\n+            start_addr,\n+            num_records * split_context.class1_record_size);\n+\n+    if (!split_context.format1_device_table_indices\n+        && !split_context.format2_device_table_indices)\n+      \/\/ No device tables to move over.\n+      return;\n+\n+    unsigned class2_count = class2Count;\n+    for (unsigned i = start; i < end; i++)\n+    {\n+      for (unsigned j = 0; j < class2_count; j++)\n+      {\n+        unsigned value1_index = split_context.value_record_len * (class2_count * i + j);\n+        unsigned value2_index = value1_index + split_context.value1_record_len;\n+\n+        unsigned new_value1_index = split_context.value_record_len * (class2_count * (i - start) + j);\n+        unsigned new_value2_index = new_value1_index + split_context.value1_record_len;\n+\n+        transfer_device_tables (split_context,\n+                                pair_pos_prime_id,\n+                                split_context.format1_device_table_indices,\n+                                value1_index,\n+                                new_value1_index);\n+\n+        transfer_device_tables (split_context,\n+                                pair_pos_prime_id,\n+                                split_context.format2_device_table_indices,\n+                                value2_index,\n+                                new_value2_index);\n+      }\n+    }\n+  }\n+\n+  void transfer_device_tables (split_context_t& split_context,\n+                               unsigned pair_pos_prime_id,\n+                               const hb_vector_t<unsigned>& device_table_indices,\n+                               unsigned old_value_record_index,\n+                               unsigned new_value_record_index) const\n+  {\n+    PairPosFormat2* pair_pos_prime =\n+        (PairPosFormat2*) split_context.c.graph.object (pair_pos_prime_id).head;\n+\n+    for (unsigned i : device_table_indices)\n+    {\n+      OT::Offset16* record = (OT::Offset16*) &values[old_value_record_index + i];\n+      unsigned record_position = ((char*) record) - ((char*) this);\n+      if (!split_context.device_tables.has (record_position)) continue;\n+\n+      split_context.c.graph.move_child (\n+          split_context.this_index,\n+          record,\n+          pair_pos_prime_id,\n+          (OT::Offset16*) &pair_pos_prime->values[new_value_record_index + i]);\n+    }\n+  }\n+\n+  bool shrink (split_context_t& split_context,\n+               unsigned count)\n+  {\n+    DEBUG_MSG (SUBSET_REPACK, nullptr,\n+               \"  Shrinking PairPosFormat2 (%u) to [0, %u).\",\n+               split_context.this_index,\n+               count);\n+    unsigned old_count = class1Count;\n+    if (count >= old_count)\n+      return true;\n+\n+    graph_t& graph = split_context.c.graph;\n+    class1Count = count;\n+    graph.vertices_[split_context.this_index].obj.tail -=\n+        (old_count - count) * split_context.class1_record_size;\n+\n+    auto coverage =\n+        graph.as_mutable_table<Coverage> (split_context.this_index, &this->coverage);\n+    if (!coverage) return false;\n+\n+    auto class_def_1 =\n+        graph.as_mutable_table<ClassDef> (split_context.this_index, &classDef1);\n+    if (!class_def_1) return false;\n+\n+    auto klass_map =\n+    + coverage.table->iter ()\n+    | hb_map_retains_sorting ([&] (hb_codepoint_t gid) {\n+      return hb_pair_t<hb_codepoint_t, hb_codepoint_t> (gid, class_def_1.table->get_class (gid));\n+    })\n+    | hb_filter ([&] (hb_codepoint_t klass) {\n+      return klass < count;\n+    }, hb_second)\n+    ;\n+\n+    auto new_coverage = + klass_map | hb_map_retains_sorting (hb_first);\n+    if (!Coverage::make_coverage (split_context.c,\n+                                  + new_coverage,\n+                                  coverage.index,\n+                                  \/\/ existing ranges my not be kept, worst case size is a format 1\n+                                  \/\/ coverage table.\n+                                  4 + new_coverage.len() * 2))\n+      return false;\n+\n+    return ClassDef::make_class_def (split_context.c,\n+                                     + klass_map,\n+                                     class_def_1.index,\n+                                     class_def_1.vertex->table_size ());\n+  }\n+\n+  hb_hashmap_t<unsigned, unsigned>\n+  get_all_device_tables (gsubgpos_graph_context_t& c,\n+                         unsigned this_index) const\n+  {\n+    const auto& v = c.graph.vertices_[this_index];\n+    return v.position_to_index_map ();\n+  }\n+\n+  const Coverage* get_coverage (gsubgpos_graph_context_t& c,\n+                          unsigned this_index) const\n+  {\n+    unsigned coverage_id = c.graph.index_for_offset (this_index, &coverage);\n+    auto& coverage_v = c.graph.vertices_[coverage_id];\n+\n+    Coverage* coverage_table = (Coverage*) coverage_v.obj.head;\n+    if (!coverage_table || !coverage_table->sanitize (coverage_v))\n+      return &Null(Coverage);\n+    return coverage_table;\n+  }\n+\n+  const ClassDef* get_class_def_1 (gsubgpos_graph_context_t& c,\n+                                   unsigned this_index) const\n+  {\n+    unsigned class_def_1_id = c.graph.index_for_offset (this_index, &classDef1);\n+    auto& class_def_1_v = c.graph.vertices_[class_def_1_id];\n+\n+    ClassDef* class_def_1_table = (ClassDef*) class_def_1_v.obj.head;\n+    if (!class_def_1_table || !class_def_1_table->sanitize (class_def_1_v))\n+      return &Null(ClassDef);\n+    return class_def_1_table;\n+  }\n+\n+  unsigned size_of_value_record_children (gsubgpos_graph_context_t& c,\n+                                          const hb_hashmap_t<unsigned, unsigned>& device_tables,\n+                                          const hb_vector_t<unsigned> device_table_indices,\n+                                          unsigned value_record_index,\n+                                          hb_set_t& visited)\n+  {\n+    unsigned size = 0;\n+    for (unsigned i : device_table_indices)\n+    {\n+      OT::Layout::GPOS_impl::Value* record = &values[value_record_index + i];\n+      unsigned record_position = ((char*) record) - ((char*) this);\n+      unsigned* obj_idx;\n+      if (!device_tables.has (record_position, &obj_idx)) continue;\n+      size += c.graph.find_subgraph_size (*obj_idx, visited);\n+    }\n+    return size;\n+  }\n+\n+  unsigned size_of (gsubgpos_graph_context_t& c,\n+                    unsigned this_index,\n+                    const void* offset) const\n+  {\n+    const unsigned id = c.graph.index_for_offset (this_index, offset);\n+    return c.graph.vertices_[id].table_size ();\n+  }\n+};\n+\n+struct PairPos : public OT::Layout::GPOS_impl::PairPos\n+{\n+  hb_vector_t<unsigned> split_subtables (gsubgpos_graph_context_t& c,\n+                                         unsigned parent_index,\n+                                         unsigned this_index)\n+  {\n+    switch (u.format) {\n+    case 1:\n+      return ((PairPosFormat1*)(&u.format1))->split_subtables (c, parent_index, this_index);\n+    case 2:\n+      return ((PairPosFormat2*)(&u.format2))->split_subtables (c, parent_index, this_index);\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: HB_FALLTHROUGH;\n+    case 4: HB_FALLTHROUGH;\n+      \/\/ Don't split 24bit PairPos's.\n+#endif\n+    default:\n+      return hb_vector_t<unsigned> ();\n+    }\n+  }\n+\n+  bool sanitize (graph_t::vertex_t& vertex) const\n+  {\n+    int64_t vertex_len = vertex.obj.tail - vertex.obj.head;\n+    if (vertex_len < u.format.get_size ()) return false;\n+\n+    switch (u.format) {\n+    case 1:\n+      return ((PairPosFormat1*)(&u.format1))->sanitize (vertex);\n+    case 2:\n+      return ((PairPosFormat2*)(&u.format2))->sanitize (vertex);\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: HB_FALLTHROUGH;\n+    case 4: HB_FALLTHROUGH;\n+#endif\n+    default:\n+      \/\/ We don't handle format 3 and 4 here.\n+      return false;\n+    }\n+  }\n+};\n+\n+}\n+\n+#endif  \/\/ GRAPH_PAIRPOS_GRAPH_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/graph\/pairpos-graph.hh","additions":647,"deletions":0,"binary":false,"changes":647,"status":"added"},{"patch":"@@ -36,0 +36,17 @@\n+\n+  bool operator != (const overflow_record_t o) const\n+  { return !(*this == o); }\n+\n+  inline bool operator == (const overflow_record_t& o) const\n+  {\n+    return parent == o.parent &&\n+        child == o.child;\n+  }\n+\n+  inline uint32_t hash () const\n+  {\n+    uint32_t current = 0;\n+    current = current * 31 + hb_hash (parent);\n+    current = current * 31 + hb_hash (child);\n+    return current;\n+  }\n@@ -97,0 +114,1 @@\n+  hb_hashmap_t<overflow_record_t*, bool> record_set;\n@@ -112,0 +130,2 @@\n+      if (record_set.has(&r)) continue; \/\/ don't keep duplicate overflows.\n+\n@@ -113,0 +133,1 @@\n+      record_set.set(&r, true);\n@@ -135,2 +156,2 @@\n-               \"%4d (%4d in, %4d out, space %2d) => \"\n-               \"%4d (%4d in, %4d out, space %2d)\",\n+               \"%4u (%4u in, %4u out, space %2u) => \"\n+               \"%4u (%4u in, %4u out, space %2u)\",\n@@ -147,1 +168,1 @@\n-    DEBUG_MSG (SUBSET_REPACK, nullptr, \"  ... plus %d more overflows.\", overflows.length - 10);\n+    DEBUG_MSG (SUBSET_REPACK, nullptr, \"  ... plus %u more overflows.\", overflows.length - 10);\n@@ -226,1 +247,1 @@\n-    memcpy (start, vertices[i].obj.head, size);\n+    hb_memcpy (start, vertices[i].obj.head, size);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/graph\/serialize.hh","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright © 2022  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger\n+ *\/\n+\n+#ifndef GRAPH_SPLIT_HELPERS_HH\n+#define GRAPH_SPLIT_HELPERS_HH\n+\n+namespace graph {\n+\n+template<typename Context>\n+HB_INTERNAL\n+hb_vector_t<unsigned> actuate_subtable_split (Context& split_context,\n+                                              const hb_vector_t<unsigned>& split_points)\n+{\n+  hb_vector_t<unsigned> new_objects;\n+  if (!split_points)\n+    return new_objects;\n+\n+  for (unsigned i = 0; i < split_points.length; i++)\n+  {\n+    unsigned start = split_points[i];\n+    unsigned end = (i < split_points.length - 1)\n+                   ? split_points[i + 1]\n+                   : split_context.original_count ();\n+    unsigned id = split_context.clone_range (start, end);\n+\n+    if (id == (unsigned) -1)\n+    {\n+      new_objects.reset ();\n+      new_objects.allocated = -1; \/\/ mark error\n+      return new_objects;\n+    }\n+    new_objects.push (id);\n+  }\n+\n+  if (!split_context.shrink (split_points[0]))\n+  {\n+    new_objects.reset ();\n+    new_objects.allocated = -1; \/\/ mark error\n+  }\n+\n+  return new_objects;\n+}\n+\n+}\n+\n+#endif  \/\/ GRAPH_SPLIT_HELPERS_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/graph\/split-helpers.hh","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -45,1 +45,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n@@ -81,1 +81,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-bsln-table.hh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"hb-aat-map.hh\"\n@@ -42,0 +43,37 @@\n+struct ankr;\n+\n+struct hb_aat_apply_context_t :\n+       hb_dispatch_context_t<hb_aat_apply_context_t, bool, HB_DEBUG_APPLY>\n+{\n+  const char *get_name () { return \"APPLY\"; }\n+  template <typename T>\n+  return_t dispatch (const T &obj) { return obj.apply (this); }\n+  static return_t default_return_value () { return false; }\n+  bool stop_sublookup_iteration (return_t r) const { return r; }\n+\n+  const hb_ot_shape_plan_t *plan;\n+  hb_font_t *font;\n+  hb_face_t *face;\n+  hb_buffer_t *buffer;\n+  hb_sanitize_context_t sanitizer;\n+  const ankr *ankr_table;\n+  const OT::GDEF *gdef_table;\n+  const hb_sorted_vector_t<hb_aat_map_t::range_flags_t> *range_flags = nullptr;\n+  hb_mask_t subtable_flags = 0;\n+\n+  \/* Unused. For debug tracing only. *\/\n+  unsigned int lookup_index;\n+\n+  HB_INTERNAL hb_aat_apply_context_t (const hb_ot_shape_plan_t *plan_,\n+                                      hb_font_t *font_,\n+                                      hb_buffer_t *buffer_,\n+                                      hb_blob_t *blob = const_cast<hb_blob_t *> (&Null (hb_blob_t)));\n+\n+  HB_INTERNAL ~hb_aat_apply_context_t ();\n+\n+  HB_INTERNAL void set_ankr_table (const AAT::ankr *ankr_table_);\n+\n+  void set_lookup_index (unsigned int i) { lookup_index = i; }\n+};\n+\n+\n@@ -418,12 +456,1 @@\n-\/* Lookup 0 has unbounded size (dependant on num_glyphs).  So we need to defined\n- * special NULL objects for Lookup<> objects, but since it's template our macros\n- * don't work.  So we have to hand-code them here.  UGLY. *\/\n-} \/* Close namespace. *\/\n-\/* Ugly hand-coded null objects for template Lookup<> :(. *\/\n-extern HB_INTERNAL const unsigned char _hb_Null_AAT_Lookup[2];\n-template <typename T>\n-struct Null<AAT::Lookup<T>> {\n-  static AAT::Lookup<T> const & get_null ()\n-  { return *reinterpret_cast<const AAT::Lookup<T> *> (_hb_Null_AAT_Lookup); }\n-};\n-namespace AAT {\n+DECLARE_NULL_NAMESPACE_BYTES_TEMPLATE1 (AAT, Lookup, 2);\n@@ -684,0 +711,7 @@\n+    \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/3483 *\/\n+    \/* If offset is less than base, return an offset that would\n+     * result in an address half a 32bit address-space away,\n+     * to make sure sanitize fails even on 32bit builds. *\/\n+    if (unlikely (offset < unsigned ((const char *) array - (const char *) base)))\n+      return INT_MAX \/ T::static_size;\n+\n@@ -747,1 +781,1 @@\n-  void drive (context_t *c)\n+  void drive (context_t *c, hb_aat_apply_context_t *ac)\n@@ -753,0 +787,2 @@\n+    \/\/ If there's only one range, we already checked the flag.\n+    auto *last_range = ac->range_flags && (ac->range_flags->length > 1) ? &(*ac->range_flags)[0] : nullptr;\n@@ -755,0 +791,26 @@\n+      \/* This block is copied in NoncontextualSubtable::apply. Keep in sync. *\/\n+      if (last_range)\n+      {\n+        auto *range = last_range;\n+        if (buffer->idx < buffer->len)\n+        {\n+          unsigned cluster = buffer->cur().cluster;\n+          while (cluster < range->cluster_first)\n+            range--;\n+          while (cluster > range->cluster_last)\n+            range++;\n+\n+\n+          last_range = range;\n+        }\n+        if (!(range->flags & ac->subtable_flags))\n+        {\n+          if (buffer->idx == buffer->len || unlikely (!buffer->successful))\n+            break;\n+\n+          state = StateTableT::STATE_START_OF_TEXT;\n+          (void) buffer->next_glyph ();\n+          continue;\n+        }\n+      }\n+\n@@ -756,1 +818,1 @@\n-                           machine.get_class (buffer->info[buffer->idx].codepoint, num_glyphs) :\n+                           machine.get_class (buffer->cur().codepoint, num_glyphs) :\n@@ -852,35 +914,0 @@\n-struct ankr;\n-\n-struct hb_aat_apply_context_t :\n-       hb_dispatch_context_t<hb_aat_apply_context_t, bool, HB_DEBUG_APPLY>\n-{\n-  const char *get_name () { return \"APPLY\"; }\n-  template <typename T>\n-  return_t dispatch (const T &obj) { return obj.apply (this); }\n-  static return_t default_return_value () { return false; }\n-  bool stop_sublookup_iteration (return_t r) const { return r; }\n-\n-  const hb_ot_shape_plan_t *plan;\n-  hb_font_t *font;\n-  hb_face_t *face;\n-  hb_buffer_t *buffer;\n-  hb_sanitize_context_t sanitizer;\n-  const ankr *ankr_table;\n-  const OT::GDEF *gdef_table;\n-\n-  \/* Unused. For debug tracing only. *\/\n-  unsigned int lookup_index;\n-\n-  HB_INTERNAL hb_aat_apply_context_t (const hb_ot_shape_plan_t *plan_,\n-                                      hb_font_t *font_,\n-                                      hb_buffer_t *buffer_,\n-                                      hb_blob_t *blob = const_cast<hb_blob_t *> (&Null (hb_blob_t)));\n-\n-  HB_INTERNAL ~hb_aat_apply_context_t ();\n-\n-  HB_INTERNAL void set_ankr_table (const AAT::ankr *ankr_table_);\n-\n-  void set_lookup_index (unsigned int i) { lookup_index = i; }\n-};\n-\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-common.hh","additions":76,"deletions":49,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-feat-table.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n@@ -68,1 +68,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n@@ -73,1 +73,1 @@\n-  HBFixed       lowerLimit;     \/* If the distance factor is less than this value,\n+  F16DOT16      lowerLimit;     \/* If the distance factor is less than this value,\n@@ -75,1 +75,1 @@\n-  HBFixed       upperLimit;     \/* If the distance factor is greater than this value,\n+  F16DOT16      upperLimit;     \/* If the distance factor is greater than this value,\n@@ -115,1 +115,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n@@ -121,1 +121,1 @@\n-  HBFixed       substThreshold; \/* Distance growth factor (in ems) at which\n+  F16DOT16      substThreshold; \/* Distance growth factor (in ems) at which\n@@ -140,1 +140,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n@@ -149,1 +149,1 @@\n-  HBFixed       minimumLimit;   \/* The lowest value for the ductility axis that\n+  F16DOT16      minimumLimit;   \/* The lowest value for the ductility axis that\n@@ -152,1 +152,1 @@\n-  HBFixed       noStretchValue; \/* This is the default value that corresponds to\n+  F16DOT16      noStretchValue; \/* This is the default value that corresponds to\n@@ -155,1 +155,1 @@\n-  HBFixed       maximumLimit;   \/* The highest value for the ductility axis that\n+  F16DOT16      maximumLimit;   \/* The highest value for the ductility axis that\n@@ -166,1 +166,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n@@ -274,1 +274,1 @@\n-  HBFixed       beforeGrowLimit;\/* The ratio by which the advance width of the\n+  F16DOT16      beforeGrowLimit;\/* The ratio by which the advance width of the\n@@ -276,1 +276,1 @@\n-  HBFixed       beforeShrinkLimit;\n+  F16DOT16      beforeShrinkLimit;\n@@ -279,1 +279,1 @@\n-  HBFixed       afterGrowLimit; \/* The ratio by which the advance width of the glyph\n+  F16DOT16      afterGrowLimit; \/* The ratio by which the advance width of the glyph\n@@ -281,1 +281,1 @@\n-  HBFixed       afterShrinkLimit;\n+  F16DOT16      afterShrinkLimit;\n@@ -297,1 +297,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-just-table.hh","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -353,1 +353,1 @@\n-    driver.drive (&dc);\n+    driver.drive (&dc, c);\n@@ -597,1 +597,1 @@\n-    driver.drive (&dc);\n+    driver.drive (&dc, c);\n@@ -754,1 +754,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n@@ -872,0 +872,2 @@\n+    c->buffer->unsafe_to_concat ();\n+\n@@ -892,1 +894,1 @@\n-      if (!c->buffer->message (c->font, \"start subtable %d\", c->lookup_index))\n+      if (!c->buffer->message (c->font, \"start subtable %u\", c->lookup_index))\n@@ -924,1 +926,1 @@\n-      (void) c->buffer->message (c->font, \"end subtable %d\", c->lookup_index);\n+      (void) c->buffer->message (c->font, \"end subtable %u\", c->lookup_index);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-kerx-table.hh","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -134,2 +134,2 @@\n-          memcpy (buf, info + start, l * sizeof (buf[0]));\n-          memcpy (buf + 2, info + end - r, r * sizeof (buf[0]));\n+          hb_memcpy (buf, info + start, l * sizeof (buf[0]));\n+          hb_memcpy (buf + 2, info + end - r, r * sizeof (buf[0]));\n@@ -140,2 +140,2 @@\n-          memcpy (info + start, buf + 2, r * sizeof (buf[0]));\n-          memcpy (info + end - l, buf, l * sizeof (buf[0]));\n+          hb_memcpy (info + start, buf + 2, r * sizeof (buf[0]));\n+          hb_memcpy (info + end - l, buf, l * sizeof (buf[0]));\n@@ -172,1 +172,1 @@\n-    driver.drive (&dc);\n+    driver.drive (&dc, c);\n@@ -328,1 +328,1 @@\n-    driver.drive (&dc);\n+    driver.drive (&dc, c);\n@@ -528,1 +528,1 @@\n-          DEBUG_MSG (APPLY, nullptr, \"Action store %u last %u\",\n+          DEBUG_MSG (APPLY, nullptr, \"Action store %d last %d\",\n@@ -580,1 +580,1 @@\n-    driver.drive (&dc);\n+    driver.drive (&dc, c);\n@@ -621,0 +621,2 @@\n+    \/\/ If there's only one range, we already checked the flag.\n+    auto *last_range = c->range_flags && (c->range_flags->length > 1) ? &(*c->range_flags)[0] : nullptr;\n@@ -623,0 +625,17 @@\n+      \/* This block copied from StateTableDriver::drive. Keep in sync. *\/\n+      if (last_range)\n+      {\n+        auto *range = last_range;\n+        {\n+          unsigned cluster = info[i].cluster;\n+          while (cluster < range->cluster_first)\n+            range--;\n+          while (cluster > range->cluster_last)\n+            range++;\n+\n+          last_range = range;\n+        }\n+        if (!(range->flags & c->subtable_flags))\n+          continue;\n+      }\n+\n@@ -823,1 +842,1 @@\n-    driver.drive (&dc);\n+    driver.drive (&dc, c);\n@@ -971,1 +990,1 @@\n-        if (map->features.bsearch (info))\n+        if (map->current_features.bsearch (info))\n@@ -983,0 +1002,9 @@\n+#ifndef HB_NO_AAT\n+        else if (type == HB_AAT_LAYOUT_FEATURE_TYPE_LANGUAGE_TAG_TYPE && setting &&\n+                 \/* TODO: Rudimentary language matching. *\/\n+                 hb_language_matches (map->face->table.ltag->get_language (setting - 1), map->props.language))\n+        {\n+          flags &= feature.disableFlags;\n+          flags |= feature.enableFlags;\n+        }\n+#endif\n@@ -988,2 +1016,1 @@\n-  void apply (hb_aat_apply_context_t *c,\n-              hb_mask_t flags) const\n+  void apply (hb_aat_apply_context_t *c) const\n@@ -997,1 +1024,2 @@\n-      if (!(subtable->subFeatureFlags & flags))\n+      if (hb_none (hb_iter (c->range_flags) |\n+                   hb_map ([&subtable] (const hb_aat_map_t::range_flags_t _) -> bool { return subtable->subFeatureFlags & (_.flags); })))\n@@ -999,0 +1027,1 @@\n+      c->subtable_flags = subtable->subFeatureFlags;\n@@ -1037,1 +1066,1 @@\n-      if (!c->buffer->message (c->font, \"start chainsubtable %d\", c->lookup_index))\n+      if (!c->buffer->message (c->font, \"start chainsubtable %u\", c->lookup_index))\n@@ -1048,1 +1077,1 @@\n-      (void) c->buffer->message (c->font, \"end chainsubtable %d\", c->lookup_index);\n+      (void) c->buffer->message (c->font, \"end chainsubtable %u\", c->lookup_index);\n@@ -1114,0 +1143,2 @@\n+    if (unlikely (!map->chain_flags.resize (count)))\n+      return;\n@@ -1116,1 +1147,3 @@\n-      map->chain_flags.push (chain->compile_flags (mapper));\n+      map->chain_flags[i].push (hb_aat_map_t::range_flags_t {chain->compile_flags (mapper),\n+                                                             mapper->range_first,\n+                                                             mapper->range_last});\n@@ -1121,1 +1154,2 @@\n-  void apply (hb_aat_apply_context_t *c) const\n+  void apply (hb_aat_apply_context_t *c,\n+              const hb_aat_map_t &map) const\n@@ -1124,0 +1158,3 @@\n+\n+    c->buffer->unsafe_to_concat ();\n+\n@@ -1129,1 +1166,2 @@\n-      chain->apply (c, c->plan->aat_map.chain_flags[i]);\n+      c->range_flags = &map.chain_flags[i];\n+      chain->apply (c);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-morx-table.hh","additions":56,"deletions":18,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-opbd-table.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  HBFixed       track;          \/* Track value for this record. *\/\n+  F16DOT16      track;          \/* Track value for this record. *\/\n@@ -85,1 +85,1 @@\n-    hb_array_t<const HBFixed> size_table ((base+sizeTable).arrayZ, sizes);\n+    hb_array_t<const F16DOT16> size_table ((base+sizeTable).arrayZ, sizes);\n@@ -123,1 +123,1 @@\n-    hb_array_t<const HBFixed> size_table ((base+sizeTable).arrayZ, sizes);\n+    hb_array_t<const F16DOT16> size_table ((base+sizeTable).arrayZ, sizes);\n@@ -144,1 +144,1 @@\n-  NNOffset32To<UnsizedArrayOf<HBFixed>>\n+  NNOffset32To<UnsizedArrayOf<F16DOT16>>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-trak-table.hh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -134,0 +134,1 @@\n+  {HB_TAG ('r','l','i','g'), HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES,               HB_AAT_LAYOUT_FEATURE_SELECTOR_REQUIRED_LIGATURES_ON,          HB_AAT_LAYOUT_FEATURE_SELECTOR_REQUIRED_LIGATURES_OFF},\n@@ -232,1 +233,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -246,1 +247,3 @@\n-                          hb_buffer_t *buffer)\n+                          hb_buffer_t *buffer,\n+                          const hb_feature_t *features,\n+                          unsigned num_features)\n@@ -248,0 +251,6 @@\n+  hb_aat_map_builder_t builder (font->face, plan->props);\n+  for (unsigned i = 0; i < num_features; i++)\n+    builder.add_feature (features[i]);\n+  hb_aat_map_t map;\n+  builder.compile (map);\n+\n@@ -254,1 +263,1 @@\n-    morx.apply (&c);\n+    morx.apply (&c, map);\n@@ -265,1 +274,1 @@\n-    mort.apply (&c);\n+    mort.apply (&c, map);\n@@ -291,1 +300,1 @@\n-  hb_ot_layout_delete_glyphs_inplace (buffer, is_deleted_glyph);\n+  buffer->delete_glyphs_inplace (is_deleted_glyph);\n@@ -303,1 +312,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -336,1 +345,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout.cc","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -56,1 +56,3 @@\n-                          hb_buffer_t *buffer);\n+                          hb_buffer_t *buffer,\n+                          const hb_feature_t *features,\n+                          unsigned num_features);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout.hh","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-void hb_aat_map_builder_t::add_feature (hb_tag_t tag, unsigned value)\n+void hb_aat_map_builder_t::add_feature (const hb_feature_t &feature)\n@@ -43,1 +43,1 @@\n-  if (tag == HB_TAG ('a','a','l','t'))\n+  if (feature.tag == HB_TAG ('a','a','l','t'))\n@@ -47,5 +47,7 @@\n-    feature_info_t *info = features.push();\n-    info->type = HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_ALTERNATIVES;\n-    info->setting = (hb_aat_layout_feature_selector_t) value;\n-    info->seq = features.length;\n-    info->is_exclusive = true;\n+    feature_range_t *range = features.push();\n+    range->start = feature.start;\n+    range->end = feature.end;\n+    range->info.type = HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_ALTERNATIVES;\n+    range->info.setting = (hb_aat_layout_feature_selector_t) feature.value;\n+    range->info.seq = features.length;\n+    range->info.is_exclusive = true;\n@@ -55,1 +57,1 @@\n-  const hb_aat_feature_mapping_t *mapping = hb_aat_layout_find_feature_mapping (tag);\n+  const hb_aat_feature_mapping_t *mapping = hb_aat_layout_find_feature_mapping (feature.tag);\n@@ -58,2 +60,2 @@\n-  const AAT::FeatureName* feature = &face->table.feat->get_feature (mapping->aatFeatureType);\n-  if (!feature->has_data ())\n+  const AAT::FeatureName* feature_name = &face->table.feat->get_feature (mapping->aatFeatureType);\n+  if (!feature_name->has_data ())\n@@ -67,2 +69,2 @@\n-      feature = &face->table.feat->get_feature (HB_AAT_LAYOUT_FEATURE_TYPE_LETTER_CASE);\n-      if (!feature->has_data ()) return;\n+      feature_name = &face->table.feat->get_feature (HB_AAT_LAYOUT_FEATURE_TYPE_LETTER_CASE);\n+      if (!feature_name->has_data ()) return;\n@@ -73,5 +75,7 @@\n-  feature_info_t *info = features.push();\n-  info->type = mapping->aatFeatureType;\n-  info->setting = value ? mapping->selectorToEnable : mapping->selectorToDisable;\n-  info->seq = features.length;\n-  info->is_exclusive = feature->is_exclusive ();\n+  feature_range_t *range = features.push();\n+  range->start = feature.start;\n+  range->end = feature.end;\n+  range->info.type = mapping->aatFeatureType;\n+  range->info.setting = feature.value ? mapping->selectorToEnable : mapping->selectorToDisable;\n+  range->info.seq = features.length;\n+  range->info.is_exclusive = feature_name->is_exclusive ();\n@@ -83,2 +87,39 @@\n-  \/* Sort features and merge duplicates *\/\n-  if (features.length)\n+  \/* Compute active features per range, and compile each. *\/\n+\n+  \/* Sort features by start\/end events. *\/\n+  hb_vector_t<feature_event_t> feature_events;\n+  for (unsigned int i = 0; i < features.length; i++)\n+  {\n+    auto &feature = features[i];\n+\n+    if (features[i].start == features[i].end)\n+      continue;\n+\n+    feature_event_t *event;\n+\n+    event = feature_events.push ();\n+    event->index = features[i].start;\n+    event->start = true;\n+    event->feature = feature.info;\n+\n+    event = feature_events.push ();\n+    event->index = features[i].end;\n+    event->start = false;\n+    event->feature = feature.info;\n+  }\n+  feature_events.qsort ();\n+  \/* Add a strategic final event. *\/\n+  {\n+    feature_info_t feature;\n+    feature.seq = features.length + 1;\n+\n+    feature_event_t *event = feature_events.push ();\n+    event->index = -1; \/* This value does magic. *\/\n+    event->start = false;\n+    event->feature = feature;\n+  }\n+\n+  \/* Scan events and save features for each range. *\/\n+  hb_sorted_vector_t<feature_info_t> active_features;\n+  unsigned int last_index = 0;\n+  for (unsigned int i = 0; i < feature_events.length; i++)\n@@ -86,10 +127,37 @@\n-    features.qsort ();\n-    unsigned int j = 0;\n-    for (unsigned int i = 1; i < features.length; i++)\n-      if (features[i].type != features[j].type ||\n-          \/* Nonexclusive feature selectors come in even\/odd pairs to turn a setting on\/off\n-           * respectively, so we mask out the low-order bit when checking for \"duplicates\"\n-           * (selectors referring to the same feature setting) here. *\/\n-          (!features[i].is_exclusive && ((features[i].setting & ~1) != (features[j].setting & ~1))))\n-        features[++j] = features[i];\n-    features.shrink (j + 1);\n+    feature_event_t *event = &feature_events[i];\n+\n+    if (event->index != last_index)\n+    {\n+      \/* Save a snapshot of active features and the range. *\/\n+\n+      \/* Sort features and merge duplicates *\/\n+      current_features = active_features;\n+      range_first = last_index;\n+      range_last = event->index - 1;\n+      if (current_features.length)\n+      {\n+        current_features.qsort ();\n+        unsigned int j = 0;\n+        for (unsigned int i = 1; i < current_features.length; i++)\n+          if (current_features[i].type != current_features[j].type ||\n+              \/* Nonexclusive feature selectors come in even\/odd pairs to turn a setting on\/off\n+               * respectively, so we mask out the low-order bit when checking for \"duplicates\"\n+               * (selectors referring to the same feature setting) here. *\/\n+              (!current_features[i].is_exclusive && ((current_features[i].setting & ~1) != (current_features[j].setting & ~1))))\n+            current_features[++j] = current_features[i];\n+        current_features.shrink (j + 1);\n+      }\n+\n+      hb_aat_layout_compile_map (this, &m);\n+\n+      last_index = event->index;\n+    }\n+\n+    if (event->start)\n+    {\n+      active_features.push (event->feature);\n+    } else {\n+      feature_info_t *feature = active_features.lsearch (event->feature);\n+      if (feature)\n+        active_features.remove_ordered (feature - active_features.arrayZ);\n+    }\n@@ -98,1 +166,3 @@\n-  hb_aat_layout_compile_map (this, &m);\n+  for (auto &chain_flags : m.chain_flags)\n+    \/\/ With our above setup this value is one less than desired; adjust it.\n+    chain_flags.tail().cluster_last = HB_FEATURE_GLOBAL_END;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-map.cc","additions":100,"deletions":30,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -38,2 +38,1 @@\n-\n-  void init ()\n+  struct range_flags_t\n@@ -41,4 +40,4 @@\n-    memset (this, 0, sizeof (*this));\n-    chain_flags.init ();\n-  }\n-  void fini () { chain_flags.fini (); }\n+    hb_mask_t flags;\n+    unsigned cluster_first;\n+    unsigned cluster_last; \/\/ end - 1\n+  };\n@@ -47,1 +46,1 @@\n-  hb_vector_t<hb_mask_t> chain_flags;\n+  hb_vector_t<hb_sorted_vector_t<range_flags_t>> chain_flags;\n@@ -55,2 +54,3 @@\n-                                    const hb_segment_properties_t *props_ HB_UNUSED) :\n-                                      face (face_) {}\n+                                    const hb_segment_properties_t props_) :\n+                                      face (face_),\n+                                      props (props_) {}\n@@ -58,1 +58,1 @@\n-  HB_INTERNAL void add_feature (hb_tag_t tag, unsigned int value=1);\n+  HB_INTERNAL void add_feature (const hb_feature_t &feature);\n@@ -80,1 +80,1 @@\n-    \/* compares type & setting only, not is_exclusive flag or seq number *\/\n+    \/* compares type & setting only *\/\n@@ -88,0 +88,23 @@\n+  struct feature_range_t\n+  {\n+    feature_info_t info;\n+    unsigned start;\n+    unsigned end;\n+  };\n+\n+  private:\n+  struct feature_event_t\n+  {\n+    unsigned int index;\n+    bool start;\n+    feature_info_t feature;\n+\n+    HB_INTERNAL static int cmp (const void *pa, const void *pb) {\n+      const feature_event_t *a = (const feature_event_t *) pa;\n+      const feature_event_t *b = (const feature_event_t *) pb;\n+      return a->index < b->index ? -1 : a->index > b->index ? 1 :\n+             a->start < b->start ? -1 : a->start > b->start ? 1 :\n+             feature_info_t::cmp (&a->feature, &b->feature);\n+    }\n+  };\n+\n@@ -90,0 +113,1 @@\n+  hb_segment_properties_t props;\n@@ -92,1 +116,4 @@\n-  hb_sorted_vector_t<feature_info_t> features;\n+  hb_sorted_vector_t<feature_range_t> features;\n+  hb_sorted_vector_t<feature_info_t> current_features;\n+  unsigned range_first = HB_FEATURE_GLOBAL_START;\n+  unsigned range_last = HB_FEATURE_GLOBAL_END;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-map.hh","additions":39,"deletions":12,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -112,1 +112,2 @@\n-#if ((defined(__GNUC__) && __GNUC__ >= 5) || defined(__clang__)) && \\\n+#if defined(__OPTIMIZE__) && !defined(HB_NO_PACKED) && \\\n+    ((defined(__GNUC__) && __GNUC__ >= 5) || defined(__clang__)) && \\\n@@ -118,1 +119,1 @@\n-    return __builtin_bswap16 (((packed_uint16_t *) this)->v);\n+    return __builtin_bswap16 (((packed_uint16_t *) v)->v);\n@@ -120,1 +121,1 @@\n-    return ((packed_uint16_t *) this)->v;\n+    return ((packed_uint16_t *) v)->v;\n@@ -156,1 +157,2 @@\n-#if ((defined(__GNUC__) && __GNUC__ >= 5) || defined(__clang__)) && \\\n+#if defined(__OPTIMIZE__) && !defined(HB_NO_PACKED) && \\\n+    ((defined(__GNUC__) && __GNUC__ >= 5) || defined(__clang__)) && \\\n@@ -162,1 +164,1 @@\n-    return __builtin_bswap32 (((packed_uint32_t *) this)->v);\n+    return __builtin_bswap32 (((packed_uint32_t *) v)->v);\n@@ -164,1 +166,1 @@\n-    return ((packed_uint32_t *) this)->v;\n+    return ((packed_uint32_t *) v)->v;\n@@ -237,11 +239,0 @@\n-  template <typename T> constexpr uint32_t\n-  impl (const hb::shared_ptr<T>& v, hb_priority<1>) const\n-  {\n-    return v.get () ? v.get ()->hash () : 0;\n-  }\n-  template <typename T> constexpr uint32_t\n-  impl (const hb::unique_ptr<T>& v, hb_priority<1>) const\n-  {\n-    return v.get () ? v.get ()->hash () : 0;\n-  }\n-\n@@ -496,0 +487,11 @@\n+struct\n+{\n+  template <typename T> void\n+  operator () (T& a, T& b) const\n+  {\n+    using std::swap; \/\/ allow ADL\n+    swap (a, b);\n+  }\n+}\n+HB_FUNCOBJ (hb_swap);\n+\n@@ -508,1 +510,1 @@\n-  hb_pair_t (T1 a, T2 b) : first (a), second (b) {}\n+  hb_pair_t (T1 a, T2 b) : first (std::forward<T1> (a)), second (std::forward<T2> (b)) {}\n@@ -525,0 +527,19 @@\n+  static int cmp (const void *pa, const void *pb)\n+  {\n+    pair_t *a = (pair_t *) pa;\n+    pair_t *b = (pair_t *) pb;\n+\n+    if (a->first < b->first) return -1;\n+    if (a->first > b->first) return +1;\n+    if (a->second < b->second) return -1;\n+    if (a->second > b->second) return +1;\n+    return 0;\n+  }\n+\n+  friend void swap (hb_pair_t& a, hb_pair_t& b)\n+  {\n+    hb_swap (a.first, b.first);\n+    hb_swap (a.second, b.second);\n+  }\n+\n+\n@@ -528,1 +549,0 @@\n-#define hb_pair_t(T1,T2) hb_pair_t<T1, T2>\n@@ -554,1 +574,1 @@\n-  (a <= b ? std::forward<T> (a) : std::forward<T2> (b))\n+  (a <= b ? a : b)\n@@ -561,1 +581,1 @@\n-  (a >= b ? std::forward<T> (a) : std::forward<T2> (b))\n+  (a >= b ? a : b)\n@@ -572,11 +592,0 @@\n-struct\n-{\n-  template <typename T> void\n-  operator () (T& a, T& b) const\n-  {\n-    using std::swap; \/\/ allow ADL\n-    swap (a, b);\n-  }\n-}\n-HB_FUNCOBJ (hb_swap);\n-\n@@ -851,6 +860,1 @@\n-hb_in_ranges (T u, T lo1, T hi1, T lo2, T hi2)\n-{\n-  return hb_in_range (u, lo1, hi1) || hb_in_range (u, lo2, hi2);\n-}\n-template <typename T> static inline bool\n-hb_in_ranges (T u, T lo1, T hi1, T lo2, T hi2, T lo3, T hi3)\n+hb_in_ranges (T u, T lo1, T hi1)\n@@ -858,1 +862,1 @@\n-  return hb_in_range (u, lo1, hi1) || hb_in_range (u, lo2, hi2) || hb_in_range (u, lo3, hi3);\n+  return hb_in_range (u, lo1, hi1);\n@@ -860,2 +864,2 @@\n-template <typename T> static inline bool\n-hb_in_ranges (T u, T lo1, T hi1, T lo2, T hi2, T lo3, T hi3, T lo4, T hi4)\n+template <typename T, typename ...Ts> static inline bool\n+hb_in_ranges (T u, T lo1, T hi1, Ts... ds)\n@@ -863,1 +867,1 @@\n-  return hb_in_range (u, lo1, hi1) || hb_in_range (u, lo2, hi2) || hb_in_range (u, lo3, hi3) || hb_in_range (u, lo4, hi4);\n+  return hb_in_range<T> (u, lo1, hi1) || hb_in_ranges<T> (u, ds...);\n@@ -871,1 +875,0 @@\n-\/* Consider __builtin_mul_overflow use here also *\/\n@@ -873,1 +876,1 @@\n-hb_unsigned_mul_overflows (unsigned int count, unsigned int size)\n+hb_unsigned_mul_overflows (unsigned int count, unsigned int size, unsigned *result = nullptr)\n@@ -875,0 +878,9 @@\n+#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && (__clang_major__ >= 8))\n+  unsigned stack_result;\n+  if (!result)\n+    result = &stack_result;\n+  return __builtin_mul_overflow (count, size, result);\n+#endif\n+\n+  if (result)\n+    *result = count * size;\n@@ -975,1 +987,1 @@\n-#define SORT_R_SWAP(a,b,tmp) ((tmp) = (a), (a) = (b), (b) = (tmp))\n+#define SORT_R_SWAP(a,b,tmp) ((void) ((tmp) = (a)), (void) ((a) = (b)), (b) = (tmp))\n@@ -1166,2 +1178,2 @@\n-template <typename T, typename T2, typename T3> static inline void\n-hb_stable_sort (T *array, unsigned int len, int(*compar)(const T2 *, const T2 *), T3 *array2)\n+template <typename T, typename T2, typename T3 = int> static inline void\n+hb_stable_sort (T *array, unsigned int len, int(*compar)(const T2 *, const T2 *), T3 *array2 = nullptr)\n@@ -1169,0 +1181,3 @@\n+  static_assert (hb_is_trivially_copy_assignable (T), \"\");\n+  static_assert (hb_is_trivially_copy_assignable (T3), \"\");\n+\n@@ -1191,6 +1206,0 @@\n-template <typename T> static inline void\n-hb_stable_sort (T *array, unsigned int len, int(*compar)(const T *, const T *))\n-{\n-  hb_stable_sort (array, len, compar, (int *) nullptr);\n-}\n-\n@@ -1324,43 +1333,0 @@\n-\/* Compiler-assisted vectorization. *\/\n-\n-\/* Type behaving similar to vectorized vars defined using __attribute__((vector_size(...))),\n- * basically a fixed-size bitset. *\/\n-template <typename elt_t, unsigned int byte_size>\n-struct hb_vector_size_t\n-{\n-  elt_t& operator [] (unsigned int i) { return v[i]; }\n-  const elt_t& operator [] (unsigned int i) const { return v[i]; }\n-\n-  void clear (unsigned char v = 0) { memset (this, v, sizeof (*this)); }\n-\n-  template <typename Op>\n-  hb_vector_size_t process (const Op& op) const\n-  {\n-    hb_vector_size_t r;\n-    for (unsigned int i = 0; i < ARRAY_LENGTH (v); i++)\n-      r.v[i] = op (v[i]);\n-    return r;\n-  }\n-  template <typename Op>\n-  hb_vector_size_t process (const Op& op, const hb_vector_size_t &o) const\n-  {\n-    hb_vector_size_t r;\n-    for (unsigned int i = 0; i < ARRAY_LENGTH (v); i++)\n-      r.v[i] = op (v[i], o.v[i]);\n-    return r;\n-  }\n-  hb_vector_size_t operator | (const hb_vector_size_t &o) const\n-  { return process (hb_bitwise_or, o); }\n-  hb_vector_size_t operator & (const hb_vector_size_t &o) const\n-  { return process (hb_bitwise_and, o); }\n-  hb_vector_size_t operator ^ (const hb_vector_size_t &o) const\n-  { return process (hb_bitwise_xor, o); }\n-  hb_vector_size_t operator ~ () const\n-  { return process (hb_bitwise_neg); }\n-\n-  private:\n-  static_assert (0 == byte_size % sizeof (elt_t), \"\");\n-  elt_t v[byte_size \/ sizeof (elt_t)];\n-};\n-\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-algs.hh","additions":62,"deletions":96,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -103,2 +103,4 @@\n-   * for range-based for loop and just compare arrayZ.  No need to compare length, as we\n-   * assume we're only compared to .end(). *\/\n+   * for range-based for loop and just compare arrayZ and length.\n+   *\n+   * The above comment is outdated now because we implemented separate begin\/end to\n+   * objects that were using hb_array_t for range-based loop before. *\/\n@@ -106,1 +108,6 @@\n-  { return arrayZ != o.arrayZ; }\n+  { return this->arrayZ != o.arrayZ || this->length != o.length; }\n+\n+  \/* Faster range-based for loop without bounds-check. *\/\n+  Type *begin () const { return arrayZ; }\n+  Type *end () const { return arrayZ + length; }\n+\n@@ -116,1 +123,2 @@\n-  uint32_t hash () const {\n+  uint32_t hash () const\n+  {\n@@ -118,3 +126,2 @@\n-    for (unsigned int i = 0; i < this->length; i++) {\n-      current = current * 31 + hb_hash (this->arrayZ[i]);\n-    }\n+    for (auto &v : *this)\n+      current = current * 31 + hb_hash (v);\n@@ -188,0 +195,1 @@\n+    \/\/static_assert (hb_enable_if (hb_is_trivially_copy_assignable(Type)), \"\");\n@@ -194,0 +202,1 @@\n+    \/\/static_assert (hb_enable_if (hb_is_trivially_copy_assignable(Type)), \"\");\n@@ -198,7 +207,0 @@\n-  void qsort (unsigned int start, unsigned int end)\n-  {\n-    end = hb_min (end, length);\n-    assert (start <= end);\n-    if (likely (start < end))\n-      hb_qsort (arrayZ + start, end - start, this->get_item_size (), Type::cmp);\n-  }\n@@ -223,5 +225,2 @@\n-    for (unsigned lhs = start, rhs = end - 1; lhs < rhs; lhs++, rhs--) {\n-      Type temp = arrayZ[rhs];\n-      arrayZ[rhs] = arrayZ[lhs];\n-      arrayZ[lhs] = temp;\n-    }\n+    for (unsigned lhs = start, rhs = end - 1; lhs < rhs; lhs++, rhs--)\n+      hb_swap (arrayZ[rhs], arrayZ[lhs]);\n@@ -269,1 +268,3 @@\n-  template <typename hb_serialize_context_t>\n+  template <typename hb_serialize_context_t,\n+            typename U = Type,\n+            hb_enable_if (!(sizeof (U) < sizeof (long long) && hb_is_trivially_copy_assignable(hb_decay<Type>)))>\n@@ -274,1 +275,1 @@\n-    if (unlikely (!c->extend_size (out, get_size ()))) return_trace (hb_array_t ());\n+    if (unlikely (!c->extend_size (out, get_size (), false))) return_trace (hb_array_t ());\n@@ -280,0 +281,12 @@\n+  template <typename hb_serialize_context_t,\n+            typename U = Type,\n+            hb_enable_if (sizeof (U) < sizeof (long long) && hb_is_trivially_copy_assignable(hb_decay<Type>))>\n+  hb_array_t copy (hb_serialize_context_t *c) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    auto* out = c->start_embed (arrayZ);\n+    if (unlikely (!c->extend_size (out, get_size (), false))) return_trace (hb_array_t ());\n+    hb_memcpy (out, arrayZ, get_size ());\n+    return_trace (hb_array_t (out, length));\n+  }\n+\n@@ -294,0 +307,3 @@\n+hb_array ()\n+{ return hb_array_t<T> (); }\n+template <typename T> inline hb_array_t<T>\n@@ -302,2 +318,2 @@\n-        hb_iter_t<hb_sorted_array_t<Type>, Type&>,\n-        hb_array_t<Type>\n+        hb_array_t<Type>,\n+        hb_iter_t<hb_sorted_array_t<Type>, Type&>\n@@ -323,2 +339,2 @@\n-    hb_iter_t<hb_sorted_array_t, Type&> (),\n-    hb_array_t<Type> (o) {}\n+    hb_array_t<Type> (o),\n+    hb_iter_t<hb_sorted_array_t, Type&> () {}\n@@ -331,0 +347,2 @@\n+\n+  \/* See comment in hb_array_of::operator != *\/\n@@ -334,0 +352,5 @@\n+  \/* Faster range-based for loop without bounds-check. *\/\n+  Type *begin () const { return this->arrayZ; }\n+  Type *end () const { return this->arrayZ + this->length; }\n+\n+\n@@ -347,1 +370,1 @@\n-  template <typename T, typename ...Ts>\n+  template <typename T>\n@@ -394,1 +417,1 @@\n-                            ds...);\n+                            std::forward<Ts> (ds)...);\n@@ -426,0 +449,3 @@\n+\n+\/* Specialize hash() for byte arrays. *\/\n+\n@@ -427,1 +453,2 @@\n-inline uint32_t hb_array_t<const char>::hash () const {\n+inline uint32_t hb_array_t<const char>::hash () const\n+{\n@@ -429,2 +456,11 @@\n-  for (unsigned int i = 0; i < this->length; i++)\n-    current = current * 31 + (uint32_t) (this->arrayZ[i] * 2654435761u);\n+  unsigned i = 0;\n+\n+#if defined(__OPTIMIZE__) && !defined(HB_NO_PACKED) && \\\n+    ((defined(__GNUC__) && __GNUC__ >= 5) || defined(__clang__))\n+  struct __attribute__((packed)) packed_uint32_t { uint32_t v; };\n+  for (; i + 4 <= this->length; i += 4)\n+    current = current * 31 + hb_hash ((uint32_t) ((packed_uint32_t *) &this->arrayZ[i])->v);\n+#endif\n+\n+  for (; i < this->length; i++)\n+    current = current * 31 + hb_hash (this->arrayZ[i]);\n@@ -433,0 +469,1 @@\n+\n@@ -434,1 +471,2 @@\n-inline uint32_t hb_array_t<const unsigned char>::hash () const {\n+inline uint32_t hb_array_t<const unsigned char>::hash () const\n+{\n@@ -436,2 +474,11 @@\n-  for (unsigned int i = 0; i < this->length; i++)\n-    current = current * 31 + (uint32_t) (this->arrayZ[i] * 2654435761u);\n+  unsigned i = 0;\n+\n+#if defined(__OPTIMIZE__) && !defined(HB_NO_PACKED) && \\\n+    ((defined(__GNUC__) && __GNUC__ >= 5) || defined(__clang__))\n+  struct __attribute__((packed)) packed_uint32_t { uint32_t v; };\n+  for (; i + 4 <= this->length; i += 4)\n+    current = current * 31 + hb_hash ((uint32_t) ((packed_uint32_t *) &this->arrayZ[i])->v);\n+#endif\n+\n+  for (; i < this->length; i++)\n+    current = current * 31 + hb_hash (this->arrayZ[i]);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-array.hh","additions":80,"deletions":33,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -87,5 +87,5 @@\n-#define hb_atomic_int_impl_add(AI, V)           (reinterpret_cast<std::atomic<int> *> (AI)->fetch_add ((V), std::memory_order_acq_rel))\n-#define hb_atomic_int_impl_set_relaxed(AI, V)   (reinterpret_cast<std::atomic<int> *> (AI)->store ((V), std::memory_order_relaxed))\n-#define hb_atomic_int_impl_set(AI, V)           (reinterpret_cast<std::atomic<int> *> (AI)->store ((V), std::memory_order_release))\n-#define hb_atomic_int_impl_get_relaxed(AI)      (reinterpret_cast<std::atomic<int> const *> (AI)->load (std::memory_order_relaxed))\n-#define hb_atomic_int_impl_get(AI)              (reinterpret_cast<std::atomic<int> const *> (AI)->load (std::memory_order_acquire))\n+#define hb_atomic_int_impl_add(AI, V)           (reinterpret_cast<std::atomic<std::decay<decltype (*(AI))>::type> *> (AI)->fetch_add ((V), std::memory_order_acq_rel))\n+#define hb_atomic_int_impl_set_relaxed(AI, V)   (reinterpret_cast<std::atomic<std::decay<decltype (*(AI))>::type> *> (AI)->store ((V), std::memory_order_relaxed))\n+#define hb_atomic_int_impl_set(AI, V)           (reinterpret_cast<std::atomic<std::decay<decltype (*(AI))>::type> *> (AI)->store ((V), std::memory_order_release))\n+#define hb_atomic_int_impl_get_relaxed(AI)      (reinterpret_cast<std::atomic<std::decay<decltype (*(AI))>::type> const *> (AI)->load (std::memory_order_relaxed))\n+#define hb_atomic_int_impl_get(AI)              (reinterpret_cast<std::atomic<std::decay<decltype (*(AI))>::type> const *> (AI)->load (std::memory_order_acquire))\n@@ -114,0 +114,18 @@\n+\/* This should never be disabled, even under HB_NO_MT.\n+ * except that MSVC gives me an internal compiler error, so disabled there.\n+ *\n+ * https:\/\/github.com\/harfbuzz\/harfbuzz\/pull\/4119\n+ *\/\n+#ifndef _hb_compiler_memory_r_barrier\n+#if defined(__ATOMIC_ACQUIRE) \/\/ gcc-like\n+#define _hb_compiler_memory_r_barrier() asm volatile(\"\": : :\"memory\")\n+#elif !defined(_MSC_VER)\n+#include <atomic>\n+#define _hb_compiler_memory_r_barrier() std::atomic_signal_fence (std::memory_order_acquire)\n+#else\n+#define _hb_compiler_memory_r_barrier() do {} while (0)\n+#endif\n+#endif\n+\n+\n+\n@@ -135,0 +153,1 @@\n+inline void hb_atomic_int_impl_set (short *AI, short v) { _hb_memory_w_barrier (); *AI = v; }\n@@ -138,0 +157,1 @@\n+inline short hb_atomic_int_impl_get (const short *AI)   { short v = *AI; _hb_memory_r_barrier (); return v; }\n@@ -144,0 +164,18 @@\n+struct hb_atomic_short_t\n+{\n+  hb_atomic_short_t () = default;\n+  constexpr hb_atomic_short_t (short v) : v (v) {}\n+\n+  hb_atomic_short_t& operator = (short v_) { set_relaxed (v_); return *this; }\n+  operator short () const { return get_relaxed (); }\n+\n+  void set_relaxed (short v_) { hb_atomic_int_impl_set_relaxed (&v, v_); }\n+  void set_release (short v_) { hb_atomic_int_impl_set (&v, v_); }\n+  short get_relaxed () const { return hb_atomic_int_impl_get_relaxed (&v); }\n+  short get_acquire () const { return hb_atomic_int_impl_get (&v); }\n+  short inc () { return hb_atomic_int_impl_add (&v,  1); }\n+  short dec () { return hb_atomic_int_impl_add (&v, -1); }\n+\n+  short v = 0;\n+};\n+\n@@ -149,0 +187,3 @@\n+  hb_atomic_int_t& operator = (int v_) { set_relaxed (v_); return *this; }\n+  operator int () const { return get_relaxed (); }\n+\n@@ -150,1 +191,1 @@\n-  void set (int v_) { hb_atomic_int_impl_set (&v, v_); }\n+  void set_release (int v_) { hb_atomic_int_impl_set (&v, v_); }\n@@ -152,1 +193,1 @@\n-  int get () const { return hb_atomic_int_impl_get (&v); }\n+  int get_acquire () const { return hb_atomic_int_impl_get (&v); }\n@@ -170,1 +211,1 @@\n-  T *get () const { return (T *) hb_atomic_ptr_impl_get ((void **) &v); }\n+  T *get_acquire () const { return (T *) hb_atomic_ptr_impl_get ((void **) &v); }\n@@ -173,2 +214,2 @@\n-  T * operator -> () const                    { return get (); }\n-  template <typename C> operator C * () const { return get (); }\n+  T * operator -> () const                    { return get_acquire (); }\n+  template <typename C> operator C * () const { return get_acquire (); }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-atomic.hh","additions":51,"deletions":10,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -33,0 +33,57 @@\n+\n+\/* Compiler-assisted vectorization. *\/\n+\n+\/* Type behaving similar to vectorized vars defined using __attribute__((vector_size(...))),\n+ * basically a fixed-size bitset. We can't use the compiler type because hb_vector_t cannot\n+ * guarantee alignment requirements. *\/\n+template <typename elt_t, unsigned int byte_size>\n+struct hb_vector_size_t\n+{\n+  elt_t& operator [] (unsigned int i) { return v[i]; }\n+  const elt_t& operator [] (unsigned int i) const { return v[i]; }\n+\n+  void init0 ()\n+  {\n+    for (unsigned int i = 0; i < ARRAY_LENGTH (v); i++)\n+      v[i] = 0;\n+  }\n+  void init1 ()\n+  {\n+    for (unsigned int i = 0; i < ARRAY_LENGTH (v); i++)\n+      v[i] = (elt_t) -1;\n+  }\n+\n+  template <typename Op>\n+  hb_vector_size_t process (const Op& op) const\n+  {\n+    hb_vector_size_t r;\n+    for (unsigned int i = 0; i < ARRAY_LENGTH (v); i++)\n+      r.v[i] = op (v[i]);\n+    return r;\n+  }\n+  template <typename Op>\n+  hb_vector_size_t process (const Op& op, const hb_vector_size_t &o) const\n+  {\n+    hb_vector_size_t r;\n+    for (unsigned int i = 0; i < ARRAY_LENGTH (v); i++)\n+      r.v[i] = op (v[i], o.v[i]);\n+    return r;\n+  }\n+  hb_vector_size_t operator | (const hb_vector_size_t &o) const\n+  { return process (hb_bitwise_or, o); }\n+  hb_vector_size_t operator & (const hb_vector_size_t &o) const\n+  { return process (hb_bitwise_and, o); }\n+  hb_vector_size_t operator ^ (const hb_vector_size_t &o) const\n+  { return process (hb_bitwise_xor, o); }\n+  hb_vector_size_t operator ~ () const\n+  { return process (hb_bitwise_neg); }\n+\n+  hb_array_t<const elt_t> iter () const\n+  { return hb_array (v); }\n+\n+  private:\n+  static_assert (0 == byte_size % sizeof (elt_t), \"\");\n+  elt_t v[byte_size \/ sizeof (elt_t)];\n+};\n+\n+\n@@ -35,2 +92,2 @@\n-  void init0 () { v.clear (); }\n-  void init1 () { v.clear (0xFF); }\n+  void init0 () { v.init0 (); }\n+  void init1 () { v.init1 (); }\n@@ -38,1 +95,1 @@\n-  constexpr unsigned len () const\n+  static inline constexpr unsigned len ()\n@@ -43,4 +100,4 @@\n-    for (unsigned i = 0; i < len (); i++)\n-      if (v[i])\n-        return false;\n-    return true;\n+    return\n+    + hb_iter (v)\n+    | hb_none\n+    ;\n@@ -50,4 +107,4 @@\n-    uint32_t h = 0;\n-    for (unsigned i = 0; i < len (); i++)\n-      h = h * 31 + hb_hash (v[i]);\n-    return h;\n+    return\n+    + hb_iter (v)\n+    | hb_reduce ([] (uint32_t h, const elt_t &_) { return h * 31 + hb_hash (_); }, (uint32_t) 0u)\n+    ;\n@@ -58,1 +115,1 @@\n-  void set (hb_codepoint_t g, bool v) { if (v) add (g); else del (g); }\n+  void set (hb_codepoint_t g, bool value) { if (value) add (g); else del (g); }\n@@ -72,1 +129,1 @@\n-      memset (la, 0xff, (char *) lb - (char *) la);\n+      hb_memset (la, 0xff, (char *) lb - (char *) la);\n@@ -88,1 +145,1 @@\n-      memset (la, 0, (char *) lb - (char *) la);\n+      hb_memset (la, 0, (char *) lb - (char *) la);\n@@ -104,1 +161,1 @@\n-    unsigned int start_v = start_value >> ELT_BITS_LOG_2;\n+    unsigned int start_v = start_value \/ ELT_BITS;\n@@ -110,1 +167,1 @@\n-      uint32_t v_base = base | (i << ELT_BITS_LOG_2);\n+      uint32_t v_base = base | (i * ELT_BITS);\n@@ -135,1 +192,1 @@\n-    unsigned int start_v = start_value >> ELT_BITS_LOG_2;\n+    unsigned int start_v = start_value \/ ELT_BITS;\n@@ -141,1 +198,1 @@\n-      uint32_t v_offset = i << ELT_BITS_LOG_2;\n+      uint32_t v_offset = i * ELT_BITS;\n@@ -164,1 +221,4 @@\n-    return 0 == hb_memcmp (&v, &other.v, sizeof (v));\n+    for (unsigned i = 0; i < len (); i++)\n+      if (v[i] != other.v[i])\n+        return false;\n+    return true;\n@@ -176,4 +236,4 @@\n-    unsigned int pop = 0;\n-    for (unsigned int i = 0; i < len (); i++)\n-      pop += hb_popcount (v[i]);\n-    return pop;\n+    return\n+    + hb_iter (v)\n+    | hb_reduce ([] (unsigned pop, const elt_t &_) { return pop + hb_popcount (_); }, 0u)\n+    ;\n@@ -253,3 +313,2 @@\n-  static constexpr unsigned PAGE_BITS = 512;\n-  static_assert ((PAGE_BITS & ((PAGE_BITS) - 1)) == 0, \"\");\n-  static constexpr unsigned PAGE_BITS_LOG_2 = 9;\n+  static constexpr unsigned PAGE_BITS_LOG_2 = 9; \/\/ 512 bits\n+  static constexpr unsigned PAGE_BITS = 1 << PAGE_BITS_LOG_2;\n@@ -257,0 +316,1 @@\n+  static_assert ((PAGE_BITS & ((PAGE_BITS) - 1)) == 0, \"\");\n@@ -265,2 +325,0 @@\n-  static constexpr unsigned ELT_BITS_LOG_2 = 6;\n-  static_assert (1 << ELT_BITS_LOG_2 == ELT_BITS, \"\");\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-bit-page.hh","additions":86,"deletions":28,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -77,0 +77,5 @@\n+  bool is_inverted () const\n+  {\n+    return inverted;\n+  }\n+\n@@ -126,4 +131,2 @@\n-  static constexpr bool SENTINEL = false;\n-  typedef bool value_t;\n-  value_t operator [] (hb_codepoint_t k) const { return get (k); }\n-  bool has (hb_codepoint_t k) const { return (*this)[k] != SENTINEL; }\n+  bool operator [] (hb_codepoint_t k) const { return get (k); }\n+  bool has (hb_codepoint_t k) const { return (*this)[k]; }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-bit-set-invertible.hh","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  hb_bit_set_t (const hb_bit_set_t& other) : hb_bit_set_t () { set (other); }\n+  hb_bit_set_t (const hb_bit_set_t& other) : hb_bit_set_t () { set (other, true); }\n@@ -59,1 +59,1 @@\n-    last_page_lookup.set_relaxed (0);\n+    last_page_lookup = 0;\n@@ -88,1 +88,1 @@\n-  bool resize (unsigned int count)\n+  bool resize (unsigned int count, bool clear = true, bool exact_size = false)\n@@ -91,1 +91,5 @@\n-    if (unlikely (!pages.resize (count) || !page_map.resize (count)))\n+\n+    if (pages.length == 0 && count == 1)\n+      exact_size = true; \/\/ Most sets are small and local\n+\n+    if (unlikely (!pages.resize (count, clear, exact_size) || !page_map.resize (count, clear, exact_size)))\n@@ -93,1 +97,1 @@\n-      pages.resize (page_map.length);\n+      pages.resize (page_map.length, clear, exact_size);\n@@ -333,4 +337,2 @@\n-  static constexpr bool SENTINEL = false;\n-  typedef bool value_t;\n-  value_t operator [] (hb_codepoint_t k) const { return get (k); }\n-  bool has (hb_codepoint_t k) const { return (*this)[k] != SENTINEL; }\n+  bool operator [] (hb_codepoint_t k) const { return get (k); }\n+  bool has (hb_codepoint_t k) const { return (*this)[k]; }\n@@ -351,1 +353,1 @@\n-  void set (const hb_bit_set_t &other)\n+  void set (const hb_bit_set_t &other, bool exact_size = false)\n@@ -355,1 +357,1 @@\n-    if (unlikely (!resize (count)))\n+    if (unlikely (!resize (count, false, exact_size)))\n@@ -394,1 +396,1 @@\n-        population != larger_set.population)\n+        population > larger_set.population)\n@@ -427,1 +429,1 @@\n-    if (unlikely (!workspace.resize (pages.length)))\n+    if (unlikely (!workspace.resize_exact (pages.length)))\n@@ -468,2 +470,3 @@\n-  template <typename Op>\n-  void process (const Op& op, const hb_bit_set_t &other)\n+  void process_ (hb_bit_page_t::vector_t (*op) (const hb_bit_page_t::vector_t &, const hb_bit_page_t::vector_t &),\n+                 bool passthru_left, bool passthru_right,\n+                 const hb_bit_set_t &other)\n@@ -471,3 +474,0 @@\n-    const bool passthru_left = op (1, 0);\n-    const bool passthru_right = op (0, 1);\n-\n@@ -545,1 +545,1 @@\n-      if (page_map[a - 1].major == other.page_map[b - 1].major)\n+      if (page_map.arrayZ[a - 1].major == other.page_map.arrayZ[b - 1].major)\n@@ -550,1 +550,1 @@\n-        page_map[count] = page_map[a];\n+        page_map.arrayZ[count] = page_map.arrayZ[a];\n@@ -553,1 +553,1 @@\n-      else if (page_map[a - 1].major > other.page_map[b - 1].major)\n+      else if (page_map.arrayZ[a - 1].major > other.page_map.arrayZ[b - 1].major)\n@@ -559,1 +559,1 @@\n-          page_map[count] = page_map[a];\n+          page_map.arrayZ[count] = page_map.arrayZ[a];\n@@ -568,2 +568,2 @@\n-          page_map[count].major = other.page_map[b].major;\n-          page_map[count].index = next_page++;\n+          page_map.arrayZ[count].major = other.page_map.arrayZ[b].major;\n+          page_map.arrayZ[count].index = next_page++;\n@@ -579,1 +579,1 @@\n-        page_map[count] = page_map [a];\n+        page_map.arrayZ[count] = page_map.arrayZ[a];\n@@ -586,2 +586,2 @@\n-        page_map[count].major = other.page_map[b].major;\n-        page_map[count].index = next_page++;\n+        page_map.arrayZ[count].major = other.page_map.arrayZ[b].major;\n+        page_map.arrayZ[count].index = next_page++;\n@@ -593,0 +593,9 @@\n+  template <typename Op>\n+  static hb_bit_page_t::vector_t\n+  op_ (const hb_bit_page_t::vector_t &a, const hb_bit_page_t::vector_t &b)\n+  { return Op{} (a, b); }\n+  template <typename Op>\n+  void process (const Op& op, const hb_bit_set_t &other)\n+  {\n+    process_ (op_<Op>, op (1, 0), op (0, 1), other);\n+  }\n@@ -601,2 +610,0 @@\n-    \/\/ TODO: this should be merged with prev() as both implementations\n-    \/\/       are very similar.\n@@ -610,1 +617,1 @@\n-    unsigned int i = last_page_lookup.get_relaxed ();\n+    unsigned int i = last_page_lookup;\n@@ -628,1 +635,1 @@\n-        last_page_lookup.set_relaxed (i);\n+        last_page_lookup = i;\n@@ -636,1 +643,1 @@\n-      const page_map_t &current = page_map.arrayZ[i];\n+      const page_map_t &current = page_map_array[i];\n@@ -641,1 +648,1 @@\n-        last_page_lookup.set_relaxed (i);\n+        last_page_lookup = i;\n@@ -645,1 +652,1 @@\n-    last_page_lookup.set_relaxed (0);\n+    last_page_lookup = 0;\n@@ -659,1 +666,1 @@\n-    if (i < page_map.length && page_map[i].major == map.major)\n+    if (i < page_map.length && page_map.arrayZ[i].major == map.major)\n@@ -661,1 +668,1 @@\n-      if (pages[page_map[i].index].previous (codepoint))\n+      if (pages[page_map.arrayZ[i].index].previous (codepoint))\n@@ -663,1 +670,1 @@\n-        *codepoint += page_map[i].major * page_t::PAGE_BITS;\n+        *codepoint += page_map.arrayZ[i].major * page_t::PAGE_BITS;\n@@ -670,1 +677,1 @@\n-      hb_codepoint_t m = pages[page_map[i].index].get_max ();\n+      hb_codepoint_t m = pages.arrayZ[page_map.arrayZ[i].index].get_max ();\n@@ -673,1 +680,1 @@\n-        *codepoint = page_map[i].major * page_t::PAGE_BITS + m;\n+        *codepoint = page_map.arrayZ[i].major * page_t::PAGE_BITS + m;\n@@ -728,1 +735,1 @@\n-      unsigned int i = last_page_lookup.get_relaxed ();\n+      unsigned int i = last_page_lookup;\n@@ -769,1 +776,1 @@\n-      unsigned int i = last_page_lookup.get_relaxed ();\n+      unsigned int i = last_page_lookup;\n@@ -896,1 +903,1 @@\n-    unsigned i = last_page_lookup.get_relaxed ();\n+    unsigned i = last_page_lookup;\n@@ -901,1 +908,1 @@\n-        return &pages[cached_page.index];\n+        return &pages.arrayZ[cached_page.index];\n@@ -913,3 +920,3 @@\n-      pages[map.index].init0 ();\n-      memmove (page_map + i + 1,\n-               page_map + i,\n+      pages.arrayZ[map.index].init0 ();\n+      memmove (page_map.arrayZ + i + 1,\n+               page_map.arrayZ + i,\n@@ -920,2 +927,2 @@\n-    last_page_lookup.set_relaxed (i);\n-    return &pages[page_map[i].index];\n+    last_page_lookup = i;\n+    return &pages.arrayZ[page_map.arrayZ[i].index];\n@@ -930,1 +937,1 @@\n-    unsigned i = last_page_lookup.get_relaxed ();\n+    unsigned i = last_page_lookup;\n@@ -935,1 +942,1 @@\n-        return &pages[cached_page.index];\n+        return &pages.arrayZ[cached_page.index];\n@@ -942,2 +949,12 @@\n-    last_page_lookup.set_relaxed (i);\n-    return &pages[page_map[i].index];\n+    last_page_lookup = i;\n+    return &pages.arrayZ[page_map[i].index];\n+  }\n+  page_t &page_at (unsigned int i)\n+  {\n+    assert (i < page_map.length);\n+    return pages.arrayZ[page_map.arrayZ[i].index];\n+  }\n+  const page_t &page_at (unsigned int i) const\n+  {\n+    assert (i < page_map.length);\n+    return pages.arrayZ[page_map.arrayZ[i].index];\n@@ -945,2 +962,0 @@\n-  page_t &page_at (unsigned int i) { return pages[page_map[i].index]; }\n-  const page_t &page_at (unsigned int i) const { return pages[page_map[i].index]; }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-bit-set.hh","additions":69,"deletions":54,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n- * Return value: New blob, or %NULL if failed.  Destroy with hb_blob_destroy().\n+ * Return value: New blob, or `NULL` if failed.  Destroy with hb_blob_destroy().\n@@ -266,2 +266,0 @@\n-  blob->fini_shallow ();\n-\n@@ -281,1 +279,1 @@\n- * Return value: %true if success, %false otherwise\n+ * Return value: `true` if success, `false` otherwise\n@@ -308,1 +306,1 @@\n-hb_blob_get_user_data (hb_blob_t          *blob,\n+hb_blob_get_user_data (const hb_blob_t    *blob,\n@@ -338,1 +336,1 @@\n- * Return value: %true if @blob is immutable, %false otherwise\n+ * Return value: `true` if @blob is immutable, `false` otherwise\n@@ -397,1 +395,1 @@\n- * or %NULL if failed.\n+ * or `NULL` if failed.\n@@ -500,1 +498,1 @@\n-  memcpy (new_data, this->data, this->length);\n+  hb_memcpy (new_data, this->data, this->length);\n@@ -623,1 +621,1 @@\n- * or %NULL if failed.\n+ * or `NULL` if failed.\n@@ -681,1 +679,1 @@\n-#if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)\n+#if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)\n@@ -702,1 +700,1 @@\n-#if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)\n+#if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)\n@@ -715,1 +713,1 @@\n-#if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)\n+#if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-blob.cc","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-hb_blob_get_user_data (hb_blob_t          *blob,\n+hb_blob_get_user_data (const hb_blob_t    *blob,\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-blob.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  void fini_shallow () { destroy_user_data (); }\n+  ~hb_blob_t () { destroy_user_data (); }\n@@ -64,3 +64,3 @@\n-  const char *data;\n-  unsigned int length;\n-  hb_memory_mode_t mode;\n+  const char *data = nullptr;\n+  unsigned int length = 0;\n+  hb_memory_mode_t mode = (hb_memory_mode_t) 0;\n@@ -68,2 +68,2 @@\n-  void *user_data;\n-  hb_destroy_func_t destroy;\n+  void *user_data = nullptr;\n+  hb_destroy_func_t destroy = nullptr;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-blob.hh","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#line 36 \"hb-buffer-deserialize-json.hh\"\n+#line 33 \"hb-buffer-deserialize-json.hh\"\n@@ -38,6 +38,7 @@\n-        48u, 57u, 9u, 125u, 9u, 125u, 9u, 125u, 34u, 34u, 9u, 58u, 9u, 57u, 48u, 57u,\n-        9u, 125u, 9u, 125u, 108u, 108u, 34u, 34u, 9u, 58u, 9u, 57u, 9u, 125u, 9u, 125u,\n-        120u, 121u, 34u, 34u, 9u, 58u, 9u, 57u, 48u, 57u, 9u, 125u, 9u, 125u, 34u, 34u,\n-        9u, 58u, 9u, 57u, 48u, 57u, 9u, 125u, 9u, 125u, 34u, 34u, 9u, 58u, 9u, 57u,\n-        34u, 92u, 9u, 125u, 34u, 92u, 9u, 125u, 9u, 125u, 34u, 34u, 9u, 58u, 9u, 57u,\n-        9u, 125u, 9u, 93u, 9u, 123u, 0u, 0u, 0\n+        48u, 57u, 9u, 125u, 9u, 125u, 9u, 93u, 9u, 125u, 34u, 34u, 9u, 58u, 9u, 57u,\n+        48u, 57u, 9u, 125u, 9u, 125u, 108u, 108u, 34u, 34u, 9u, 58u, 9u, 57u, 9u, 125u,\n+        9u, 125u, 120u, 121u, 34u, 34u, 9u, 58u, 9u, 57u, 48u, 57u, 9u, 125u, 9u, 125u,\n+        34u, 34u, 9u, 58u, 9u, 57u, 48u, 57u, 9u, 125u, 9u, 125u, 108u, 108u, 34u, 34u,\n+        9u, 58u, 9u, 57u, 9u, 125u, 9u, 125u, 34u, 34u, 9u, 58u, 9u, 57u, 34u, 92u,\n+        9u, 125u, 34u, 92u, 9u, 125u, 9u, 125u, 34u, 34u, 9u, 58u, 9u, 57u, 9u, 125u,\n+        9u, 123u, 0u, 0u, 0\n@@ -48,6 +49,7 @@\n-        10, 117, 117, 117, 1, 50, 49, 10,\n-        117, 117, 1, 1, 50, 49, 117, 117,\n-        2, 1, 50, 49, 10, 117, 117, 1,\n-        50, 49, 10, 117, 117, 1, 50, 49,\n-        59, 117, 59, 117, 117, 1, 50, 49,\n-        117, 85, 115, 0\n+        10, 117, 117, 85, 117, 1, 50, 49,\n+        10, 117, 117, 1, 1, 50, 49, 117,\n+        117, 2, 1, 50, 49, 10, 117, 117,\n+        1, 50, 49, 10, 117, 117, 1, 1,\n+        50, 49, 117, 117, 1, 50, 49, 59,\n+        117, 59, 117, 117, 1, 50, 49, 117,\n+        115, 0\n@@ -58,6 +60,7 @@\n-        271, 282, 400, 518, 636, 638, 689, 739,\n-        750, 868, 986, 988, 990, 1041, 1091, 1209,\n-        1327, 1330, 1332, 1383, 1433, 1444, 1562, 1680,\n-        1682, 1733, 1783, 1794, 1912, 2030, 2032, 2083,\n-        2133, 2193, 2311, 2371, 2489, 2607, 2609, 2660,\n-        2710, 2828, 2914, 3030\n+        271, 282, 400, 518, 604, 722, 724, 775,\n+        825, 836, 954, 1072, 1074, 1076, 1127, 1177,\n+        1295, 1413, 1416, 1418, 1469, 1519, 1530, 1648,\n+        1766, 1768, 1819, 1869, 1880, 1998, 2116, 2118,\n+        2120, 2171, 2221, 2339, 2457, 2459, 2510, 2560,\n+        2620, 2738, 2798, 2916, 3034, 3036, 3087, 3137,\n+        3255, 3371\n@@ -85,1 +88,1 @@\n-        5, 1, 6, 7, 1, 1, 8, 1,\n+        5, 1, 6, 7, 1, 8, 9, 1,\n@@ -87,2 +90,2 @@\n-        1, 1, 1, 1, 9, 1, 10, 11,\n-        1, 12, 1, 12, 12, 12, 12, 12,\n+        1, 1, 1, 1, 10, 1, 11, 12,\n+        1, 13, 1, 13, 13, 13, 13, 13,\n@@ -91,1 +94,1 @@\n-        1, 1, 12, 1, 1, 1, 1, 1,\n+        1, 1, 13, 1, 1, 1, 1, 1,\n@@ -94,2 +97,2 @@\n-        1, 1, 1, 1, 13, 1, 13, 13,\n-        13, 13, 13, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 14, 1, 14, 14,\n+        14, 14, 14, 1, 1, 1, 1, 1,\n@@ -97,1 +100,1 @@\n-        1, 1, 1, 1, 1, 13, 1, 1,\n+        1, 1, 1, 1, 1, 14, 1, 1,\n@@ -99,4 +102,4 @@\n-        1, 1, 14, 1, 1, 15, 16, 16,\n-        16, 16, 16, 16, 16, 16, 16, 1,\n-        17, 18, 18, 18, 18, 18, 18, 18,\n-        18, 18, 1, 19, 19, 19, 19, 19,\n+        1, 1, 15, 1, 1, 16, 17, 17,\n+        17, 17, 17, 17, 17, 17, 17, 1,\n+        18, 19, 19, 19, 19, 19, 19, 19,\n+        19, 19, 1, 20, 20, 20, 20, 20,\n@@ -105,2 +108,2 @@\n-        1, 1, 19, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 20, 1,\n+        1, 1, 20, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 21, 1,\n@@ -116,2 +119,2 @@\n-        1, 1, 1, 1, 1, 1, 1, 21,\n-        1, 22, 22, 22, 22, 22, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 22,\n+        1, 23, 23, 23, 23, 23, 1, 1,\n@@ -120,1 +123,1 @@\n-        22, 1, 1, 1, 1, 1, 1, 1,\n+        23, 1, 1, 1, 1, 1, 1, 1,\n@@ -131,2 +134,2 @@\n-        1, 1, 1, 1, 1, 23, 1, 19,\n-        19, 19, 19, 19, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 24, 1, 25,\n+        25, 25, 25, 25, 1, 1, 1, 1,\n@@ -134,1 +137,1 @@\n-        1, 1, 1, 1, 1, 1, 19, 1,\n+        1, 1, 1, 1, 1, 1, 25, 1,\n@@ -136,2 +139,1 @@\n-        1, 1, 20, 1, 1, 1, 18, 18,\n-        18, 18, 18, 18, 18, 18, 18, 18,\n+        1, 1, 26, 1, 1, 1, 1, 1,\n@@ -143,0 +145,2 @@\n+        1, 1, 1, 27, 1, 20, 20, 20,\n+        20, 20, 1, 1, 1, 1, 1, 1,\n@@ -144,0 +148,1 @@\n+        1, 1, 1, 1, 20, 1, 1, 1,\n@@ -145,0 +150,2 @@\n+        21, 1, 1, 1, 19, 19, 19, 19,\n+        19, 19, 19, 19, 19, 19, 1, 1,\n@@ -146,2 +153,0 @@\n-        1, 1, 1, 21, 1, 24, 1, 24,\n-        24, 24, 24, 24, 1, 1, 1, 1,\n@@ -149,1 +154,0 @@\n-        1, 1, 1, 1, 1, 1, 24, 1,\n@@ -153,1 +157,0 @@\n-        25, 1, 25, 25, 25, 25, 25, 1,\n@@ -156,6 +159,0 @@\n-        1, 25, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 26, 1,\n-        1, 27, 28, 28, 28, 28, 28, 28,\n-        28, 28, 28, 1, 29, 30, 30, 30,\n-        30, 30, 30, 30, 30, 30, 1, 31,\n-        31, 31, 31, 31, 1, 1, 1, 1,\n@@ -163,1 +160,2 @@\n-        1, 1, 1, 1, 1, 1, 31, 1,\n+        1, 22, 1, 28, 1, 28, 28, 28,\n+        28, 28, 1, 1, 1, 1, 1, 1,\n@@ -165,1 +163,1 @@\n-        1, 1, 32, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 28, 1, 1, 1,\n@@ -168,0 +166,2 @@\n+        1, 1, 1, 1, 1, 1, 29, 1,\n+        29, 29, 29, 29, 29, 1, 1, 1,\n@@ -169,0 +169,1 @@\n+        1, 1, 1, 1, 1, 1, 1, 29,\n@@ -170,0 +171,5 @@\n+        1, 1, 1, 1, 30, 1, 1, 31,\n+        32, 32, 32, 32, 32, 32, 32, 32,\n+        32, 1, 33, 34, 34, 34, 34, 34,\n+        34, 34, 34, 34, 1, 35, 35, 35,\n+        35, 35, 1, 1, 1, 1, 1, 1,\n@@ -171,0 +177,1 @@\n+        1, 1, 1, 1, 35, 1, 1, 1,\n@@ -172,0 +179,1 @@\n+        36, 1, 1, 1, 1, 1, 1, 1,\n@@ -175,2 +183,0 @@\n-        1, 1, 1, 33, 1, 31, 31, 31,\n-        31, 31, 1, 1, 1, 1, 1, 1,\n@@ -178,1 +184,0 @@\n-        1, 1, 1, 1, 31, 1, 1, 1,\n@@ -180,2 +185,0 @@\n-        32, 1, 1, 1, 30, 30, 30, 30,\n-        30, 30, 30, 30, 30, 30, 1, 1,\n@@ -186,0 +189,1 @@\n+        1, 37, 1, 35, 35, 35, 35, 35,\n@@ -188,0 +192,4 @@\n+        1, 1, 35, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 36, 1,\n+        1, 1, 34, 34, 34, 34, 34, 34,\n+        34, 34, 34, 34, 1, 1, 1, 1,\n@@ -190,2 +198,0 @@\n-        1, 33, 1, 34, 1, 35, 1, 35,\n-        35, 35, 35, 35, 1, 1, 1, 1,\n@@ -193,1 +199,0 @@\n-        1, 1, 1, 1, 1, 1, 35, 1,\n@@ -197,1 +202,0 @@\n-        36, 1, 36, 36, 36, 36, 36, 1,\n@@ -199,0 +203,3 @@\n+        1, 1, 1, 1, 1, 1, 1, 37,\n+        1, 38, 1, 39, 1, 39, 39, 39,\n+        39, 39, 1, 1, 1, 1, 1, 1,\n@@ -200,1 +207,1 @@\n-        1, 36, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 39, 1, 1, 1,\n@@ -202,3 +209,0 @@\n-        1, 37, 38, 38, 38, 38, 38, 38,\n-        38, 38, 38, 1, 39, 39, 39, 39,\n-        39, 1, 1, 1, 1, 1, 1, 1,\n@@ -206,1 +210,3 @@\n-        1, 1, 1, 39, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 40, 1,\n+        40, 40, 40, 40, 40, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n@@ -209,0 +215,4 @@\n+        1, 1, 1, 1, 1, 1, 1, 41,\n+        42, 42, 42, 42, 42, 42, 42, 42,\n+        42, 1, 43, 43, 43, 43, 43, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n@@ -210,0 +220,2 @@\n+        1, 43, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 44, 1, 1,\n@@ -218,1 +230,0 @@\n-        41, 1, 39, 39, 39, 39, 39, 1,\n@@ -220,0 +231,2 @@\n+        1, 1, 1, 1, 1, 1, 45, 1,\n+        43, 43, 43, 43, 43, 1, 1, 1,\n@@ -221,4 +234,1 @@\n-        1, 39, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 40, 1, 1,\n-        1, 42, 42, 42, 42, 42, 42, 42,\n-        42, 42, 42, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 43,\n@@ -226,0 +236,3 @@\n+        1, 1, 1, 44, 1, 1, 1, 46,\n+        46, 46, 46, 46, 46, 46, 46, 46,\n+        46, 1, 1, 1, 1, 1, 1, 1,\n@@ -232,3 +245,0 @@\n-        1, 1, 1, 1, 1, 1, 41, 1,\n-        43, 44, 1, 45, 1, 45, 45, 45,\n-        45, 45, 1, 1, 1, 1, 1, 1,\n@@ -236,1 +246,2 @@\n-        1, 1, 1, 1, 45, 1, 1, 1,\n+        1, 1, 1, 1, 45, 1, 47, 48,\n+        1, 49, 1, 49, 49, 49, 49, 49,\n@@ -239,2 +250,1 @@\n-        1, 1, 1, 1, 1, 1, 46, 1,\n-        46, 46, 46, 46, 46, 1, 1, 1,\n+        1, 1, 49, 1, 1, 1, 1, 1,\n@@ -242,1 +252,0 @@\n-        1, 1, 1, 1, 1, 1, 1, 46,\n@@ -244,5 +253,2 @@\n-        1, 1, 1, 1, 47, 1, 1, 48,\n-        49, 49, 49, 49, 49, 49, 49, 49,\n-        49, 1, 50, 51, 51, 51, 51, 51,\n-        51, 51, 51, 51, 1, 52, 52, 52,\n-        52, 52, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 50, 1, 50, 50,\n+        50, 50, 50, 1, 1, 1, 1, 1,\n@@ -250,1 +256,1 @@\n-        1, 1, 1, 1, 52, 1, 1, 1,\n+        1, 1, 1, 1, 1, 50, 1, 1,\n@@ -252,1 +258,4 @@\n-        53, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 51, 1, 1, 52, 53, 53,\n+        53, 53, 53, 53, 53, 53, 53, 1,\n+        54, 55, 55, 55, 55, 55, 55, 55,\n+        55, 55, 1, 56, 56, 56, 56, 56,\n@@ -255,0 +264,2 @@\n+        1, 1, 56, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 57, 1,\n@@ -262,1 +273,0 @@\n-        1, 54, 1, 52, 52, 52, 52, 52,\n@@ -265,4 +275,2 @@\n-        1, 1, 52, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 53, 1,\n-        1, 1, 51, 51, 51, 51, 51, 51,\n-        51, 51, 51, 51, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 58,\n+        1, 56, 56, 56, 56, 56, 1, 1,\n@@ -271,0 +279,4 @@\n+        56, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 57, 1, 1, 1,\n+        55, 55, 55, 55, 55, 55, 55, 55,\n+        55, 55, 1, 1, 1, 1, 1, 1,\n@@ -276,2 +288,0 @@\n-        1, 1, 1, 1, 1, 1, 1, 54,\n-        1, 55, 1, 55, 55, 55, 55, 55,\n@@ -280,1 +290,2 @@\n-        1, 1, 55, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 58, 1, 59,\n+        1, 59, 59, 59, 59, 59, 1, 1,\n@@ -283,2 +294,1 @@\n-        1, 1, 1, 1, 56, 1, 56, 56,\n-        56, 56, 56, 1, 1, 1, 1, 1,\n+        59, 1, 1, 1, 1, 1, 1, 1,\n@@ -286,1 +296,0 @@\n-        1, 1, 1, 1, 1, 56, 1, 1,\n@@ -288,4 +297,2 @@\n-        1, 1, 57, 1, 1, 58, 59, 59,\n-        59, 59, 59, 59, 59, 59, 59, 1,\n-        60, 61, 61, 61, 61, 61, 61, 61,\n-        61, 61, 1, 62, 62, 62, 62, 62,\n+        1, 1, 60, 1, 60, 60, 60, 60,\n+        60, 1, 1, 1, 1, 1, 1, 1,\n@@ -293,0 +300,1 @@\n+        1, 1, 1, 60, 1, 1, 1, 1,\n@@ -294,2 +302,4 @@\n-        1, 1, 62, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 63, 1,\n+        61, 1, 1, 62, 63, 63, 63, 63,\n+        63, 63, 63, 63, 63, 1, 64, 65,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        1, 66, 66, 66, 66, 66, 1, 1,\n@@ -298,0 +308,2 @@\n+        66, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 67, 1, 1, 1,\n@@ -305,2 +317,0 @@\n-        1, 1, 1, 1, 1, 1, 1, 64,\n-        1, 62, 62, 62, 62, 62, 1, 1,\n@@ -309,4 +319,2 @@\n-        62, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 63, 1, 1, 1,\n-        61, 61, 61, 61, 61, 61, 61, 61,\n-        61, 61, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 68, 1, 66,\n+        66, 66, 66, 66, 1, 1, 1, 1,\n@@ -314,0 +322,1 @@\n+        1, 1, 1, 1, 1, 1, 66, 1,\n@@ -315,0 +324,2 @@\n+        1, 1, 67, 1, 1, 1, 65, 65,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n@@ -320,2 +331,0 @@\n-        1, 1, 1, 1, 1, 64, 1, 65,\n-        1, 65, 65, 65, 65, 65, 1, 1,\n@@ -324,1 +333,0 @@\n-        65, 1, 1, 1, 1, 1, 1, 1,\n@@ -326,0 +334,5 @@\n+        1, 1, 1, 68, 1, 69, 1, 70,\n+        1, 70, 70, 70, 70, 70, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        70, 1, 1, 1, 1, 1, 1, 1,\n@@ -327,2 +340,0 @@\n-        1, 1, 66, 1, 66, 66, 66, 66,\n-        66, 1, 1, 1, 1, 1, 1, 1,\n@@ -330,1 +341,2 @@\n-        1, 1, 1, 66, 1, 67, 1, 1,\n+        1, 1, 71, 1, 71, 71, 71, 71,\n+        71, 1, 1, 1, 1, 1, 1, 1,\n@@ -332,10 +344,1 @@\n-        1, 1, 1, 68, 69, 69, 69, 69,\n-        69, 69, 69, 69, 69, 1, 71, 70,\n-        70, 70, 70, 70, 70, 70, 70, 70,\n-        70, 70, 70, 70, 70, 70, 70, 70,\n-        70, 70, 70, 70, 70, 70, 70, 70,\n-        70, 70, 70, 70, 70, 70, 70, 70,\n-        70, 70, 70, 70, 70, 70, 70, 70,\n-        70, 70, 70, 70, 70, 70, 70, 70,\n-        70, 70, 70, 70, 70, 70, 70, 70,\n-        72, 70, 73, 73, 73, 73, 73, 1,\n+        1, 1, 1, 71, 1, 1, 1, 1,\n@@ -343,0 +346,3 @@\n+        1, 1, 1, 72, 73, 73, 73, 73,\n+        73, 73, 73, 73, 73, 1, 74, 74,\n+        74, 74, 74, 1, 1, 1, 1, 1,\n@@ -344,1 +350,0 @@\n-        1, 73, 1, 1, 1, 1, 1, 1,\n@@ -347,0 +352,1 @@\n+        1, 75, 1, 1, 1, 1, 1, 1,\n@@ -355,2 +361,43 @@\n-        1, 1, 1, 1, 1, 1, 75, 1,\n-        70, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 76, 1, 74, 74, 74, 74,\n+        74, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 74, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 75,\n+        1, 1, 1, 77, 77, 77, 77, 77,\n+        77, 77, 77, 77, 77, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        76, 1, 78, 1, 78, 78, 78, 78,\n+        78, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 78, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 79, 1, 79,\n+        79, 79, 79, 79, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 79, 1,\n+        80, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 81, 82,\n+        82, 82, 82, 82, 82, 82, 82, 82,\n+        1, 84, 83, 83, 83, 83, 83, 83,\n+        83, 83, 83, 83, 83, 83, 83, 83,\n+        83, 83, 83, 83, 83, 83, 83, 83,\n+        83, 83, 83, 83, 83, 83, 83, 83,\n+        83, 83, 83, 83, 83, 83, 83, 83,\n+        83, 83, 83, 83, 83, 83, 83, 83,\n+        83, 83, 83, 83, 83, 83, 83, 83,\n+        83, 83, 83, 85, 83, 86, 86, 86,\n+        86, 86, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 86, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        87, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n@@ -363,2 +410,0 @@\n-        1, 1, 70, 1, 76, 76, 76, 76,\n-        76, 1, 1, 1, 1, 1, 1, 1,\n@@ -366,2 +411,0 @@\n-        1, 1, 1, 76, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 77,\n@@ -369,0 +412,1 @@\n+        1, 88, 1, 83, 1, 1, 1, 1,\n@@ -375,0 +419,2 @@\n+        1, 1, 1, 1, 1, 83, 1, 89,\n+        89, 89, 89, 89, 1, 1, 1, 1,\n@@ -376,0 +422,1 @@\n+        1, 1, 1, 1, 1, 1, 89, 1,\n@@ -377,0 +424,1 @@\n+        1, 1, 90, 1, 1, 1, 1, 1,\n@@ -378,1 +426,0 @@\n-        78, 1, 76, 76, 76, 76, 76, 1,\n@@ -381,4 +428,0 @@\n-        1, 76, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 77, 1, 1,\n-        1, 79, 79, 79, 79, 79, 79, 79,\n-        79, 79, 79, 1, 1, 1, 1, 1,\n@@ -391,0 +434,2 @@\n+        1, 1, 1, 91, 1, 89, 89, 89,\n+        89, 89, 1, 1, 1, 1, 1, 1,\n@@ -392,2 +437,1 @@\n-        1, 1, 1, 1, 1, 1, 78, 1,\n-        80, 1, 80, 80, 80, 80, 80, 1,\n+        1, 1, 1, 1, 89, 1, 1, 1,\n@@ -395,0 +439,2 @@\n+        90, 1, 1, 1, 92, 92, 92, 92,\n+        92, 92, 92, 92, 92, 92, 1, 1,\n@@ -396,1 +442,0 @@\n-        1, 80, 1, 1, 1, 1, 1, 1,\n@@ -399,2 +444,0 @@\n-        1, 1, 1, 81, 1, 81, 81, 81,\n-        81, 81, 1, 1, 1, 1, 1, 1,\n@@ -402,1 +445,0 @@\n-        1, 1, 1, 1, 81, 1, 1, 1,\n@@ -404,3 +446,0 @@\n-        1, 1, 1, 1, 82, 83, 83, 83,\n-        83, 83, 83, 83, 83, 83, 1, 76,\n-        76, 76, 76, 76, 1, 1, 1, 1,\n@@ -408,1 +447,0 @@\n-        1, 1, 1, 1, 1, 1, 76, 1,\n@@ -410,2 +448,0 @@\n-        1, 1, 77, 1, 1, 1, 84, 84,\n-        84, 84, 84, 84, 84, 84, 84, 84,\n@@ -413,0 +449,2 @@\n+        1, 91, 1, 93, 1, 93, 93, 93,\n+        93, 93, 1, 1, 1, 1, 1, 1,\n@@ -414,0 +452,1 @@\n+        1, 1, 1, 1, 93, 1, 1, 1,\n@@ -416,0 +455,2 @@\n+        1, 1, 1, 1, 1, 1, 94, 1,\n+        94, 94, 94, 94, 94, 1, 1, 1,\n@@ -417,0 +458,1 @@\n+        1, 1, 1, 1, 1, 1, 1, 94,\n@@ -418,0 +460,3 @@\n+        1, 1, 1, 1, 1, 1, 1, 95,\n+        96, 96, 96, 96, 96, 96, 96, 96,\n+        96, 1, 89, 89, 89, 89, 89, 1,\n@@ -420,2 +465,4 @@\n-        1, 1, 1, 78, 1, 85, 85, 85,\n-        85, 85, 1, 1, 1, 1, 1, 1,\n+        1, 89, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 90, 1, 1,\n+        1, 97, 97, 97, 97, 97, 97, 97,\n+        97, 97, 97, 1, 1, 1, 1, 1,\n@@ -423,1 +470,0 @@\n-        1, 1, 1, 1, 85, 1, 1, 1,\n@@ -425,1 +471,0 @@\n-        86, 1, 1, 1, 1, 1, 1, 1,\n@@ -431,1 +476,2 @@\n-        1, 87, 1, 0, 0, 0, 0, 0,\n+        1, 1, 1, 1, 1, 1, 91, 1,\n+        0, 0, 0, 0, 0, 1, 1, 1,\n@@ -433,0 +479,1 @@\n+        1, 1, 1, 1, 1, 1, 1, 0,\n@@ -434,1 +481,0 @@\n-        1, 1, 0, 1, 1, 1, 1, 1,\n@@ -445,2 +491,1 @@\n-        1, 1, 1, 1, 1, 2, 1, 1,\n-        0\n+        1, 1, 2, 1, 1, 0\n@@ -450,11 +495,13 @@\n-        1, 0, 2, 2, 3, 4, 18, 24,\n-        37, 45, 5, 12, 6, 7, 8, 9,\n-        11, 9, 11, 10, 2, 49, 10, 49,\n-        13, 14, 15, 16, 17, 16, 17, 10,\n-        2, 49, 19, 20, 21, 22, 23, 10,\n-        2, 49, 23, 25, 31, 26, 27, 28,\n-        29, 30, 29, 30, 10, 2, 49, 32,\n-        33, 34, 35, 36, 35, 36, 10, 2,\n-        49, 38, 39, 40, 43, 44, 40, 41,\n-        42, 10, 2, 49, 10, 2, 49, 44,\n-        46, 47, 43, 48, 48, 49, 50, 51\n+        1, 0, 2, 2, 3, 4, 19, 25,\n+        38, 44, 52, 5, 13, 6, 7, 8,\n+        9, 12, 9, 12, 10, 2, 11, 10,\n+        11, 11, 56, 57, 14, 15, 16, 17,\n+        18, 17, 18, 10, 2, 11, 20, 21,\n+        22, 23, 24, 10, 2, 11, 24, 26,\n+        32, 27, 28, 29, 30, 31, 30, 31,\n+        10, 2, 11, 33, 34, 35, 36, 37,\n+        36, 37, 10, 2, 11, 39, 40, 41,\n+        42, 43, 10, 2, 11, 43, 45, 46,\n+        47, 50, 51, 47, 48, 49, 10, 2,\n+        11, 10, 2, 11, 51, 53, 54, 50,\n+        55, 55\n@@ -465,10 +512,12 @@\n-        0, 0, 0, 0, 0, 0, 2, 2,\n-        2, 0, 0, 3, 3, 4, 0, 5,\n-        0, 0, 2, 2, 2, 0, 0, 6,\n-        6, 7, 0, 0, 0, 2, 2, 8,\n-        8, 9, 0, 0, 0, 0, 0, 2,\n-        2, 2, 0, 0, 10, 10, 11, 0,\n-        0, 2, 2, 2, 0, 0, 12, 12,\n-        13, 0, 0, 2, 14, 14, 0, 15,\n-        0, 16, 16, 17, 18, 18, 19, 15,\n-        0, 0, 20, 20, 21, 0, 0, 0\n+        0, 0, 0, 0, 0, 0, 0, 2,\n+        2, 2, 0, 0, 3, 3, 4, 0,\n+        5, 0, 0, 0, 0, 0, 2, 2,\n+        2, 0, 0, 6, 6, 7, 0, 0,\n+        0, 2, 2, 8, 8, 9, 0, 0,\n+        0, 0, 0, 2, 2, 2, 0, 0,\n+        10, 10, 11, 0, 0, 2, 2, 2,\n+        0, 0, 12, 12, 13, 0, 0, 0,\n+        2, 2, 14, 14, 15, 0, 0, 0,\n+        2, 16, 16, 0, 17, 0, 18, 18,\n+        19, 20, 20, 21, 17, 0, 0, 22,\n+        22, 23\n@@ -478,1 +527,1 @@\n-static const int deserialize_json_first_final = 49;\n+static const int deserialize_json_first_final = 56;\n@@ -484,1 +533,1 @@\n-#line 108 \"hb-buffer-deserialize-json.rl\"\n+#line 111 \"hb-buffer-deserialize-json.rl\"\n@@ -502,1 +551,0 @@\n-  {\n@@ -504,1 +552,0 @@\n-  }\n@@ -511,1 +558,1 @@\n-#line 512 \"hb-buffer-deserialize-json.hh\"\n+#line 552 \"hb-buffer-deserialize-json.hh\"\n@@ -516,1 +563,1 @@\n-#line 517 \"hb-buffer-deserialize-json.hh\"\n+#line 555 \"hb-buffer-deserialize-json.hh\"\n@@ -544,2 +591,2 @@\n-        memset (&info, 0, sizeof (info));\n-        memset (&pos , 0, sizeof (pos ));\n+        hb_memset (&info, 0, sizeof (info));\n+        hb_memset (&pos , 0, sizeof (pos ));\n@@ -564,1 +611,1 @@\n-        case 15:\n+        case 17:\n@@ -568,1 +615,1 @@\n-        case 21:\n+        case 23:\n@@ -572,1 +619,1 @@\n-        case 16:\n+        case 18:\n@@ -577,1 +624,1 @@\n-                                        tok, p - tok,\n+                                        tok+1, p - tok - 2, \/* Skip \"\" *\/\n@@ -582,1 +629,1 @@\n-        case 18:\n+        case 20:\n@@ -607,0 +654,4 @@\n+#line 72 \"hb-buffer-deserialize-json.rl\"\n+        { if (!parse_uint (tok, p, &info.mask    )) return false; }\n+        break;\n+        case 16:\n@@ -614,1 +665,1 @@\n-        case 20:\n+        case 22:\n@@ -622,1 +673,1 @@\n-        case 17:\n+        case 19:\n@@ -627,1 +678,1 @@\n-                                        tok, p - tok,\n+                                        tok+1, p - tok - 2, \/* Skip \"\" *\/\n@@ -640,1 +691,1 @@\n-        case 19:\n+        case 21:\n@@ -712,1 +763,13 @@\n-#line 713 \"hb-buffer-deserialize-json.hh\"\n+        case 15:\n+#line 72 \"hb-buffer-deserialize-json.rl\"\n+        { if (!parse_uint (tok, p, &info.mask    )) return false; }\n+#line 43 \"hb-buffer-deserialize-json.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+#line 733 \"hb-buffer-deserialize-json.hh\"\n@@ -724,1 +787,1 @@\n-#line 136 \"hb-buffer-deserialize-json.rl\"\n+#line 137 \"hb-buffer-deserialize-json.rl\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer-deserialize-json.hh","additions":259,"deletions":196,"binary":false,"changes":455,"status":"modified"},{"patch":"@@ -0,0 +1,692 @@\n+\n+#line 1 \"hb-buffer-deserialize-text-glyphs.rl\"\n+\/*\n+ * Copyright © 2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_BUFFER_DESERIALIZE_TEXT_GLYPHS_HH\n+#define HB_BUFFER_DESERIALIZE_TEXT_GLYPHS_HH\n+\n+#include \"hb.hh\"\n+\n+\n+#line 33 \"hb-buffer-deserialize-text-glyphs.hh\"\n+static const unsigned char _deserialize_text_glyphs_trans_keys[] = {\n+        0u, 0u, 48u, 57u, 45u, 57u, 48u, 57u, 45u, 57u, 48u, 57u, 48u, 57u, 45u, 57u,\n+        48u, 57u, 44u, 44u, 45u, 57u, 48u, 57u, 44u, 57u, 43u, 124u, 9u, 124u, 9u, 124u,\n+        9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u,\n+        9u, 124u, 9u, 124u, 9u, 124u, 0\n+};\n+\n+static const char _deserialize_text_glyphs_key_spans[] = {\n+        0, 10, 13, 10, 13, 10, 10, 13,\n+        10, 1, 13, 10, 14, 82, 116, 116,\n+        116, 116, 116, 116, 116, 116, 116, 116,\n+        116, 116, 116\n+};\n+\n+static const short _deserialize_text_glyphs_index_offsets[] = {\n+        0, 0, 11, 25, 36, 50, 61, 72,\n+        86, 97, 99, 113, 124, 139, 222, 339,\n+        456, 573, 690, 807, 924, 1041, 1158, 1275,\n+        1392, 1509, 1626\n+};\n+\n+static const char _deserialize_text_glyphs_indicies[] = {\n+        0, 2, 2, 2, 2, 2, 2,\n+        2, 2, 2, 1, 3, 1, 1, 4,\n+        5, 5, 5, 5, 5, 5, 5, 5,\n+        5, 1, 6, 7, 7, 7, 7, 7,\n+        7, 7, 7, 7, 1, 8, 1, 1,\n+        9, 10, 10, 10, 10, 10, 10, 10,\n+        10, 10, 1, 11, 12, 12, 12, 12,\n+        12, 12, 12, 12, 12, 1, 13, 14,\n+        14, 14, 14, 14, 14, 14, 14, 14,\n+        1, 15, 1, 1, 16, 17, 17, 17,\n+        17, 17, 17, 17, 17, 17, 1, 18,\n+        19, 19, 19, 19, 19, 19, 19, 19,\n+        19, 1, 20, 1, 21, 1, 1, 22,\n+        23, 23, 23, 23, 23, 23, 23, 23,\n+        23, 1, 24, 25, 25, 25, 25, 25,\n+        25, 25, 25, 25, 1, 20, 1, 1,\n+        1, 19, 19, 19, 19, 19, 19, 19,\n+        19, 19, 19, 1, 26, 26, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 26, 1,\n+        1, 26, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 26, 26, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 26, 1, 28,\n+        28, 28, 28, 28, 27, 27, 27, 27,\n+        27, 27, 27, 27, 27, 27, 27, 27,\n+        27, 27, 27, 27, 27, 27, 28, 27,\n+        27, 29, 27, 27, 27, 27, 27, 27,\n+        27, 30, 1, 27, 27, 27, 27, 27,\n+        27, 27, 27, 27, 27, 27, 27, 27,\n+        27, 27, 27, 31, 27, 27, 32, 27,\n+        27, 27, 27, 27, 27, 27, 27, 27,\n+        27, 27, 27, 27, 27, 27, 27, 27,\n+        27, 27, 27, 27, 27, 27, 27, 27,\n+        27, 27, 33, 1, 27, 27, 27, 27,\n+        27, 27, 27, 27, 27, 27, 27, 27,\n+        27, 27, 27, 27, 27, 27, 27, 27,\n+        27, 27, 27, 27, 27, 27, 27, 27,\n+        27, 27, 28, 27, 34, 34, 34, 34,\n+        34, 26, 26, 26, 26, 26, 26, 26,\n+        26, 26, 26, 26, 26, 26, 26, 26,\n+        26, 26, 26, 34, 26, 26, 35, 26,\n+        26, 26, 26, 26, 26, 26, 36, 1,\n+        26, 26, 26, 26, 26, 26, 26, 26,\n+        26, 26, 26, 26, 26, 26, 26, 26,\n+        37, 26, 26, 38, 26, 26, 26, 26,\n+        26, 26, 26, 26, 26, 26, 26, 26,\n+        26, 26, 26, 26, 26, 26, 26, 26,\n+        26, 26, 26, 26, 26, 26, 26, 39,\n+        1, 26, 26, 26, 26, 26, 26, 26,\n+        26, 26, 26, 26, 26, 26, 26, 26,\n+        26, 26, 26, 26, 26, 26, 26, 26,\n+        26, 26, 26, 26, 26, 26, 26, 40,\n+        26, 41, 41, 41, 41, 41, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        41, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 42, 1, 43, 43,\n+        43, 43, 43, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 43, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 44, 1, 41, 41, 41, 41, 41,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 41, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 45, 45, 45, 45, 45, 45,\n+        45, 45, 45, 45, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 42, 1,\n+        46, 46, 46, 46, 46, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 46,\n+        1, 1, 47, 1, 1, 1, 1, 1,\n+        1, 1, 1, 48, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 49, 1, 50, 50, 50,\n+        50, 50, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 50, 1, 1, 51,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        52, 1, 50, 50, 50, 50, 50, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 50, 1, 1, 51, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 12, 12, 12, 12, 12, 12, 12,\n+        12, 12, 12, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 52, 1, 46,\n+        46, 46, 46, 46, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 46, 1,\n+        1, 47, 1, 1, 1, 1, 1, 1,\n+        1, 1, 48, 1, 1, 1, 7, 7,\n+        7, 7, 7, 7, 7, 7, 7, 7,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 49, 1, 53, 53, 53, 53,\n+        53, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 53, 1, 1, 54, 1,\n+        1, 1, 1, 1, 1, 1, 55, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 56, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 57,\n+        1, 58, 58, 58, 58, 58, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        58, 1, 1, 59, 1, 1, 1, 1,\n+        1, 1, 1, 60, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 61, 1, 58, 58,\n+        58, 58, 58, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 58, 1, 1,\n+        59, 1, 1, 1, 1, 1, 1, 1,\n+        60, 1, 1, 1, 1, 25, 25, 25,\n+        25, 25, 25, 25, 25, 25, 25, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 61, 1, 53, 53, 53, 53, 53,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 53, 1, 1, 54, 1, 1,\n+        1, 1, 1, 1, 1, 55, 1, 1,\n+        1, 1, 62, 62, 62, 62, 62, 62,\n+        62, 62, 62, 62, 1, 1, 1, 1,\n+        1, 1, 56, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 57, 1,\n+        0\n+};\n+\n+static const char _deserialize_text_glyphs_trans_targs[] = {\n+        16, 0, 18, 3, 19, 22, 19, 22,\n+        5, 20, 21, 20, 21, 23, 26, 8,\n+        9, 12, 9, 12, 10, 11, 24, 25,\n+        24, 25, 15, 15, 14, 1, 2, 6,\n+        7, 13, 15, 1, 2, 6, 7, 13,\n+        14, 17, 14, 17, 14, 18, 17, 1,\n+        4, 14, 17, 1, 14, 17, 1, 2,\n+        7, 14, 17, 1, 2, 14, 26\n+};\n+\n+static const char _deserialize_text_glyphs_trans_actions[] = {\n+        1, 0, 1, 1, 1, 1, 0, 0,\n+        1, 1, 1, 0, 0, 1, 1, 1,\n+        1, 1, 0, 0, 2, 1, 1, 1,\n+        0, 0, 0, 4, 3, 5, 5, 5,\n+        5, 4, 6, 7, 7, 7, 7, 0,\n+        6, 8, 8, 0, 0, 0, 9, 10,\n+        10, 9, 11, 12, 11, 13, 14, 14,\n+        14, 13, 15, 16, 16, 15, 0\n+};\n+\n+static const char _deserialize_text_glyphs_eof_actions[] = {\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 3, 6,\n+        8, 0, 8, 9, 11, 11, 9, 13,\n+        15, 15, 13\n+};\n+\n+static const int deserialize_text_glyphs_start = 14;\n+static const int deserialize_text_glyphs_first_final = 14;\n+static const int deserialize_text_glyphs_error = 0;\n+\n+static const int deserialize_text_glyphs_en_main = 14;\n+\n+\n+#line 98 \"hb-buffer-deserialize-text-glyphs.rl\"\n+\n+\n+static hb_bool_t\n+_hb_buffer_deserialize_text_glyphs (hb_buffer_t *buffer,\n+                                    const char *buf,\n+                                    unsigned int buf_len,\n+                                    const char **end_ptr,\n+                                    hb_font_t *font)\n+{\n+  const char *p = buf, *pe = buf + buf_len, *eof = pe, *orig_pe = pe;\n+\n+  \/* Ensure we have positions. *\/\n+  (void) hb_buffer_get_glyph_positions (buffer, nullptr);\n+\n+  while (p < pe && ISSPACE (*p))\n+    p++;\n+  if (p < pe && *p == (buffer->len ? '|' : '['))\n+    *end_ptr = ++p;\n+\n+  const char *end = strchr ((char *) p, ']');\n+  if (end)\n+    pe = eof = end;\n+  else\n+  {\n+    end = strrchr ((char *) p, '|');\n+    if (end)\n+      pe = eof = end;\n+    else\n+      pe = eof = p;\n+  }\n+\n+  const char *tok = nullptr;\n+  int cs;\n+  hb_glyph_info_t info = {0};\n+  hb_glyph_position_t pos = {0};\n+\n+#line 346 \"hb-buffer-deserialize-text-glyphs.hh\"\n+        {\n+        cs = deserialize_text_glyphs_start;\n+        }\n+\n+#line 349 \"hb-buffer-deserialize-text-glyphs.hh\"\n+        {\n+        int _slen;\n+        int _trans;\n+        const unsigned char *_keys;\n+        const char *_inds;\n+        if ( p == pe )\n+                goto _test_eof;\n+        if ( cs == 0 )\n+                goto _out;\n+_resume:\n+        _keys = _deserialize_text_glyphs_trans_keys + (cs<<1);\n+        _inds = _deserialize_text_glyphs_indicies + _deserialize_text_glyphs_index_offsets[cs];\n+\n+        _slen = _deserialize_text_glyphs_key_spans[cs];\n+        _trans = _inds[ _slen > 0 && _keys[0] <=(*p) &&\n+                (*p) <= _keys[1] ?\n+                (*p) - _keys[0] : _slen ];\n+\n+        cs = _deserialize_text_glyphs_trans_targs[_trans];\n+\n+        if ( _deserialize_text_glyphs_trans_actions[_trans] == 0 )\n+                goto _again;\n+\n+        switch ( _deserialize_text_glyphs_trans_actions[_trans] ) {\n+        case 1:\n+#line 51 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        tok = p;\n+}\n+        break;\n+        case 7:\n+#line 55 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        \/* TODO Unescape delimiters. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n+        break;\n+        case 14:\n+#line 63 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n+        break;\n+        case 2:\n+#line 64 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        { if (!parse_int  (tok, p, &pos.x_offset )) return false; }\n+        break;\n+        case 16:\n+#line 65 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n+        break;\n+        case 10:\n+#line 66 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n+        break;\n+        case 12:\n+#line 67 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n+        break;\n+        case 4:\n+#line 38 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        hb_memset (&info, 0, sizeof (info));\n+        hb_memset (&pos , 0, sizeof (pos ));\n+}\n+#line 51 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        tok = p;\n+}\n+        break;\n+        case 6:\n+#line 55 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        \/* TODO Unescape delimiters. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n+#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 13:\n+#line 63 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n+#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 15:\n+#line 65 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n+#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 9:\n+#line 66 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n+#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 11:\n+#line 67 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n+#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 8:\n+#line 68 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        { if (!parse_uint (tok, p, &info.mask    )) return false; }\n+#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 5:\n+#line 38 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        hb_memset (&info, 0, sizeof (info));\n+        hb_memset (&pos , 0, sizeof (pos ));\n+}\n+#line 51 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        tok = p;\n+}\n+#line 55 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        \/* TODO Unescape delimiters. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n+        break;\n+        case 3:\n+#line 38 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        hb_memset (&info, 0, sizeof (info));\n+        hb_memset (&pos , 0, sizeof (pos ));\n+}\n+#line 51 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        tok = p;\n+}\n+#line 55 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        \/* TODO Unescape delimiters. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n+#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+#line 516 \"hb-buffer-deserialize-text-glyphs.hh\"\n+        }\n+\n+_again:\n+        if ( cs == 0 )\n+                goto _out;\n+        if ( ++p != pe )\n+                goto _resume;\n+        _test_eof: {}\n+        if ( p == eof )\n+        {\n+        switch ( _deserialize_text_glyphs_eof_actions[cs] ) {\n+        case 6:\n+#line 55 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        \/* TODO Unescape delimiters. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n+#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 13:\n+#line 63 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n+#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 15:\n+#line 65 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n+#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 9:\n+#line 66 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n+#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 11:\n+#line 67 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n+#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 8:\n+#line 68 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        { if (!parse_uint (tok, p, &info.mask    )) return false; }\n+#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 3:\n+#line 38 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        hb_memset (&info, 0, sizeof (info));\n+        hb_memset (&pos , 0, sizeof (pos ));\n+}\n+#line 51 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        tok = p;\n+}\n+#line 55 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        \/* TODO Unescape delimiters. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n+#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+#line 616 \"hb-buffer-deserialize-text-glyphs.hh\"\n+        }\n+        }\n+\n+        _out: {}\n+        }\n+\n+#line 136 \"hb-buffer-deserialize-text-glyphs.rl\"\n+\n+\n+  if (pe < orig_pe && *pe == ']')\n+  {\n+    pe++;\n+    if (p == pe)\n+      p++;\n+  }\n+\n+  *end_ptr = p;\n+\n+  return p == pe;\n+}\n+\n+#endif \/* HB_BUFFER_DESERIALIZE_TEXT_GLYPHS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer-deserialize-text-glyphs.hh","additions":692,"deletions":0,"binary":false,"changes":692,"status":"added"},{"patch":"@@ -0,0 +1,332 @@\n+\n+#line 1 \"hb-buffer-deserialize-text-unicode.rl\"\n+\/*\n+ * Copyright © 2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_BUFFER_DESERIALIZE_TEXT_UNICODE_HH\n+#define HB_BUFFER_DESERIALIZE_TEXT_UNICODE_HH\n+\n+#include \"hb.hh\"\n+\n+\n+#line 33 \"hb-buffer-deserialize-text-unicode.hh\"\n+static const unsigned char _deserialize_text_unicode_trans_keys[] = {\n+        0u, 0u, 9u, 117u, 43u, 102u, 48u, 102u, 48u, 57u, 9u, 124u, 9u, 124u, 9u, 124u,\n+        9u, 124u, 0\n+};\n+\n+static const char _deserialize_text_unicode_key_spans[] = {\n+        0, 109, 60, 55, 10, 116, 116, 116,\n+        116\n+};\n+\n+static const short _deserialize_text_unicode_index_offsets[] = {\n+        0, 0, 110, 171, 227, 238, 355, 472,\n+        589\n+};\n+\n+static const char _deserialize_text_unicode_indicies[] = {\n+        0, 0, 0, 0, 0, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        0, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 2, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 2, 1, 3,\n+        1, 1, 1, 1, 4, 4, 4, 4,\n+        4, 4, 4, 4, 4, 4, 1, 1,\n+        1, 1, 1, 1, 1, 4, 4, 4,\n+        4, 4, 4, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 4, 4, 4,\n+        4, 4, 4, 1, 4, 4, 4, 4,\n+        4, 4, 4, 4, 4, 4, 1, 1,\n+        1, 1, 1, 1, 1, 4, 4, 4,\n+        4, 4, 4, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 4, 4, 4,\n+        4, 4, 4, 1, 5, 6, 6, 6,\n+        6, 6, 6, 6, 6, 6, 1, 7,\n+        7, 7, 7, 7, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 7, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 8, 8,\n+        8, 8, 8, 8, 8, 8, 8, 8,\n+        1, 1, 1, 9, 1, 1, 1, 8,\n+        8, 8, 8, 8, 8, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 8,\n+        8, 8, 8, 8, 8, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 10, 1, 11, 11, 11, 11,\n+        11, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 11, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 0,\n+        1, 12, 12, 12, 12, 12, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        12, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 13, 1, 12, 12,\n+        12, 12, 12, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 12, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 14, 14, 14,\n+        14, 14, 14, 14, 14, 14, 14, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 13, 1, 0\n+};\n+\n+static const char _deserialize_text_unicode_trans_targs[] = {\n+        1, 0, 2, 3, 5, 7, 8, 6,\n+        5, 4, 1, 6, 6, 1, 8\n+};\n+\n+static const char _deserialize_text_unicode_trans_actions[] = {\n+        0, 0, 1, 0, 2, 2, 2, 3,\n+        0, 4, 3, 0, 5, 5, 0\n+};\n+\n+static const char _deserialize_text_unicode_eof_actions[] = {\n+        0, 0, 0, 0, 0, 3, 0, 5,\n+        5\n+};\n+\n+static const int deserialize_text_unicode_start = 1;\n+static const int deserialize_text_unicode_first_final = 5;\n+static const int deserialize_text_unicode_error = 0;\n+\n+static const int deserialize_text_unicode_en_main = 1;\n+\n+\n+#line 79 \"hb-buffer-deserialize-text-unicode.rl\"\n+\n+\n+static hb_bool_t\n+_hb_buffer_deserialize_text_unicode (hb_buffer_t *buffer,\n+                                     const char *buf,\n+                                     unsigned int buf_len,\n+                                     const char **end_ptr,\n+                                     hb_font_t *font)\n+{\n+  const char *p = buf, *pe = buf + buf_len, *eof = pe, *orig_pe = pe;\n+\n+  while (p < pe && ISSPACE (*p))\n+    p++;\n+  if (p < pe && *p == (buffer->len ? '|' : '<'))\n+    *end_ptr = ++p;\n+\n+  const char *end = strchr ((char *) p, '>');\n+  if (end)\n+    pe = eof = end;\n+  else\n+  {\n+    end = strrchr ((char *) p, '|');\n+    if (end)\n+      pe = eof = end;\n+    else\n+      pe = eof = p;\n+  }\n+\n+\n+  const char *tok = nullptr;\n+  int cs;\n+  hb_glyph_info_t info = {0};\n+  const hb_glyph_position_t pos = {0};\n+\n+#line 194 \"hb-buffer-deserialize-text-unicode.hh\"\n+        {\n+        cs = deserialize_text_unicode_start;\n+        }\n+\n+#line 197 \"hb-buffer-deserialize-text-unicode.hh\"\n+        {\n+        int _slen;\n+        int _trans;\n+        const unsigned char *_keys;\n+        const char *_inds;\n+        if ( p == pe )\n+                goto _test_eof;\n+        if ( cs == 0 )\n+                goto _out;\n+_resume:\n+        _keys = _deserialize_text_unicode_trans_keys + (cs<<1);\n+        _inds = _deserialize_text_unicode_indicies + _deserialize_text_unicode_index_offsets[cs];\n+\n+        _slen = _deserialize_text_unicode_key_spans[cs];\n+        _trans = _inds[ _slen > 0 && _keys[0] <=(*p) &&\n+                (*p) <= _keys[1] ?\n+                (*p) - _keys[0] : _slen ];\n+\n+        cs = _deserialize_text_unicode_trans_targs[_trans];\n+\n+        if ( _deserialize_text_unicode_trans_actions[_trans] == 0 )\n+                goto _again;\n+\n+        switch ( _deserialize_text_unicode_trans_actions[_trans] ) {\n+        case 1:\n+#line 38 \"hb-buffer-deserialize-text-unicode.rl\"\n+        {\n+        hb_memset (&info, 0, sizeof (info));\n+}\n+        break;\n+        case 2:\n+#line 51 \"hb-buffer-deserialize-text-unicode.rl\"\n+        {\n+        tok = p;\n+}\n+        break;\n+        case 4:\n+#line 55 \"hb-buffer-deserialize-text-unicode.rl\"\n+        {if (!parse_hex (tok, p, &info.codepoint )) return false; }\n+        break;\n+        case 3:\n+#line 55 \"hb-buffer-deserialize-text-unicode.rl\"\n+        {if (!parse_hex (tok, p, &info.codepoint )) return false; }\n+#line 42 \"hb-buffer-deserialize-text-unicode.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        if (buffer->have_positions)\n+          buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 5:\n+#line 57 \"hb-buffer-deserialize-text-unicode.rl\"\n+        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n+#line 42 \"hb-buffer-deserialize-text-unicode.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        if (buffer->have_positions)\n+          buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+#line 256 \"hb-buffer-deserialize-text-unicode.hh\"\n+        }\n+\n+_again:\n+        if ( cs == 0 )\n+                goto _out;\n+        if ( ++p != pe )\n+                goto _resume;\n+        _test_eof: {}\n+        if ( p == eof )\n+        {\n+        switch ( _deserialize_text_unicode_eof_actions[cs] ) {\n+        case 3:\n+#line 55 \"hb-buffer-deserialize-text-unicode.rl\"\n+        {if (!parse_hex (tok, p, &info.codepoint )) return false; }\n+#line 42 \"hb-buffer-deserialize-text-unicode.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        if (buffer->have_positions)\n+          buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 5:\n+#line 57 \"hb-buffer-deserialize-text-unicode.rl\"\n+        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n+#line 42 \"hb-buffer-deserialize-text-unicode.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        if (buffer->have_positions)\n+          buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+#line 289 \"hb-buffer-deserialize-text-unicode.hh\"\n+        }\n+        }\n+\n+        _out: {}\n+        }\n+\n+#line 115 \"hb-buffer-deserialize-text-unicode.rl\"\n+\n+\n+  if (pe < orig_pe && *pe == '>')\n+  {\n+    pe++;\n+    if (p == pe)\n+      p++;\n+  }\n+\n+  *end_ptr = p;\n+\n+  return p == pe;\n+}\n+\n+#endif \/* HB_BUFFER_DESERIALIZE_TEXT_UNICODE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer-deserialize-text-unicode.hh","additions":332,"deletions":0,"binary":false,"changes":332,"status":"added"},{"patch":"@@ -1,853 +0,0 @@\n-\n-#line 1 \"hb-buffer-deserialize-text.rl\"\n-\/*\n- * Copyright © 2013  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Behdad Esfahbod\n- *\/\n-\n-#ifndef HB_BUFFER_DESERIALIZE_TEXT_HH\n-#define HB_BUFFER_DESERIALIZE_TEXT_HH\n-\n-#include \"hb.hh\"\n-\n-\n-#line 36 \"hb-buffer-deserialize-text.hh\"\n-static const unsigned char _deserialize_text_trans_keys[] = {\n-        0u, 0u, 9u, 91u, 85u, 85u, 43u, 43u, 48u, 102u, 9u, 85u, 48u, 57u, 45u, 57u,\n-        48u, 57u, 48u, 57u, 45u, 57u, 48u, 57u, 44u, 44u, 45u, 57u, 48u, 57u, 44u, 57u,\n-        43u, 124u, 45u, 57u, 48u, 57u, 9u, 124u, 9u, 124u, 0u, 0u, 9u, 85u, 9u, 124u,\n-        9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u,\n-        9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 0\n-};\n-\n-static const char _deserialize_text_key_spans[] = {\n-        0, 83, 1, 1, 55, 77, 10, 13,\n-        10, 10, 13, 10, 1, 13, 10, 14,\n-        82, 13, 10, 116, 116, 0, 77, 116,\n-        116, 116, 116, 116, 116, 116, 116, 116,\n-        116, 116, 116, 116, 116\n-};\n-\n-static const short _deserialize_text_index_offsets[] = {\n-        0, 0, 84, 86, 88, 144, 222, 233,\n-        247, 258, 269, 283, 294, 296, 310, 321,\n-        336, 419, 433, 444, 561, 678, 679, 757,\n-        874, 991, 1108, 1225, 1342, 1459, 1576, 1693,\n-        1810, 1927, 2044, 2161, 2278\n-};\n-\n-static const char _deserialize_text_indicies[] = {\n-        0, 0, 0, 0, 0, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        0, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 2, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 3, 1, 4, 1, 5,\n-        1, 6, 6, 6, 6, 6, 6, 6,\n-        6, 6, 6, 1, 1, 1, 1, 1,\n-        1, 1, 6, 6, 6, 6, 6, 6,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 6, 6, 6, 6, 6, 6,\n-        1, 7, 7, 7, 7, 7, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        7, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 4, 1, 8,\n-        9, 9, 9, 9, 9, 9, 9, 9,\n-        9, 1, 10, 1, 1, 11, 12, 12,\n-        12, 12, 12, 12, 12, 12, 12, 1,\n-        13, 14, 14, 14, 14, 14, 14, 14,\n-        14, 14, 1, 15, 16, 16, 16, 16,\n-        16, 16, 16, 16, 16, 1, 17, 1,\n-        1, 18, 19, 19, 19, 19, 19, 19,\n-        19, 19, 19, 1, 20, 21, 21, 21,\n-        21, 21, 21, 21, 21, 21, 1, 22,\n-        1, 23, 1, 1, 24, 25, 25, 25,\n-        25, 25, 25, 25, 25, 25, 1, 26,\n-        27, 27, 27, 27, 27, 27, 27, 27,\n-        27, 1, 22, 1, 1, 1, 21, 21,\n-        21, 21, 21, 21, 21, 21, 21, 21,\n-        1, 28, 28, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 28, 1, 1, 28, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 28, 28, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 28, 1, 29, 1, 1, 30,\n-        31, 31, 31, 31, 31, 31, 31, 31,\n-        31, 1, 32, 33, 33, 33, 33, 33,\n-        33, 33, 33, 33, 1, 34, 34, 34,\n-        34, 34, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 34, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 35, 35, 35, 35,\n-        35, 35, 35, 35, 35, 35, 1, 1,\n-        1, 36, 37, 1, 1, 35, 35, 35,\n-        35, 35, 35, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 35, 35, 35,\n-        35, 35, 35, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        38, 1, 39, 39, 39, 39, 39, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 39, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 40,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 41, 1, 1,\n-        7, 7, 7, 7, 7, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 7,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 4, 1, 42, 42,\n-        42, 42, 42, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 42, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 43, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 44, 1, 42, 42, 42, 42, 42,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 42, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 45, 45, 45, 45, 45, 45,\n-        45, 45, 45, 45, 1, 1, 1, 1,\n-        43, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 44, 1,\n-        47, 47, 47, 47, 47, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 47,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 48, 1, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 49, 46, 46, 50,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 51, 52, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 53, 46, 54, 54, 54,\n-        54, 54, 28, 28, 28, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 28,\n-        28, 28, 28, 28, 54, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 55,\n-        1, 28, 28, 28, 28, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 28,\n-        28, 56, 28, 28, 57, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 28,\n-        58, 59, 28, 28, 28, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 28,\n-        28, 28, 28, 28, 28, 28, 28, 28,\n-        60, 28, 61, 61, 61, 61, 61, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 61, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 62, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 63, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 64, 1, 65,\n-        65, 65, 65, 65, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 65, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 40, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 66, 1, 67, 67, 67, 67,\n-        67, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 67, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 48, 1,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        49, 46, 46, 50, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 51,\n-        52, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 53,\n-        46, 68, 68, 68, 68, 68, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        68, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 69, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        70, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 43, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 71, 1, 72, 72,\n-        72, 72, 72, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 72, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        73, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 74, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 75, 1, 72, 72, 72, 72, 72,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 72, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 73, 1, 1,\n-        1, 1, 27, 27, 27, 27, 27, 27,\n-        27, 27, 27, 27, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 74,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 75, 1,\n-        68, 68, 68, 68, 68, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 68,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 69, 1, 1, 1, 1, 76,\n-        76, 76, 76, 76, 76, 76, 76, 76,\n-        76, 1, 1, 1, 1, 1, 1, 70,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 43, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 71, 1, 77, 77, 77,\n-        77, 77, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 77, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 78, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        79, 1, 77, 77, 77, 77, 77, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 77, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 33, 33, 33, 33, 33, 33, 33,\n-        33, 33, 33, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 78, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 79, 1, 61,\n-        61, 61, 61, 61, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 61, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 62, 1, 1, 1, 14, 14,\n-        14, 14, 14, 14, 14, 14, 14, 14,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 63, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 64, 1, 0\n-};\n-\n-static const char _deserialize_text_trans_targs[] = {\n-        1, 0, 2, 25, 3, 4, 19, 5,\n-        23, 24, 8, 27, 36, 27, 36, 30,\n-        33, 11, 12, 15, 12, 15, 13, 14,\n-        31, 32, 31, 32, 26, 18, 34, 35,\n-        34, 35, 20, 19, 6, 21, 22, 20,\n-        21, 22, 20, 21, 22, 24, 26, 26,\n-        7, 9, 10, 16, 21, 29, 26, 7,\n-        9, 10, 16, 21, 29, 28, 17, 21,\n-        29, 28, 29, 29, 28, 7, 10, 29,\n-        28, 7, 21, 29, 33, 28, 21, 29\n-};\n-\n-static const char _deserialize_text_trans_actions[] = {\n-        0, 0, 0, 0, 1, 0, 2, 0,\n-        2, 2, 3, 4, 4, 5, 5, 4,\n-        4, 3, 3, 3, 0, 0, 6, 3,\n-        4, 4, 5, 5, 5, 3, 4, 4,\n-        5, 5, 7, 8, 9, 7, 7, 0,\n-        0, 0, 10, 10, 10, 8, 12, 13,\n-        14, 14, 14, 15, 11, 11, 17, 18,\n-        18, 18, 0, 16, 16, 19, 20, 19,\n-        19, 0, 0, 13, 10, 21, 21, 10,\n-        22, 23, 22, 22, 5, 24, 24, 24\n-};\n-\n-static const char _deserialize_text_eof_actions[] = {\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 7, 0, 0, 0, 10,\n-        10, 11, 16, 19, 0, 11, 10, 22,\n-        22, 10, 24, 24, 19\n-};\n-\n-static const int deserialize_text_start = 1;\n-static const int deserialize_text_first_final = 19;\n-static const int deserialize_text_error = 0;\n-\n-static const int deserialize_text_en_main = 1;\n-\n-\n-#line 114 \"hb-buffer-deserialize-text.rl\"\n-\n-\n-static hb_bool_t\n-_hb_buffer_deserialize_text (hb_buffer_t *buffer,\n-                                    const char *buf,\n-                                    unsigned int buf_len,\n-                                    const char **end_ptr,\n-                                    hb_font_t *font)\n-{\n-  const char *p = buf, *pe = buf + buf_len;\n-\n-  \/* Ensure we have positions. *\/\n-  (void) hb_buffer_get_glyph_positions (buffer, nullptr);\n-\n-  while (p < pe && ISSPACE (*p))\n-    p++;\n-\n-  const char *eof = pe, *tok = nullptr;\n-  int cs;\n-  hb_glyph_info_t info = {0};\n-  hb_glyph_position_t pos = {0};\n-\n-#line 428 \"hb-buffer-deserialize-text.hh\"\n-        {\n-        cs = deserialize_text_start;\n-        }\n-\n-#line 433 \"hb-buffer-deserialize-text.hh\"\n-        {\n-        int _slen;\n-        int _trans;\n-        const unsigned char *_keys;\n-        const char *_inds;\n-        if ( p == pe )\n-                goto _test_eof;\n-        if ( cs == 0 )\n-                goto _out;\n-_resume:\n-        _keys = _deserialize_text_trans_keys + (cs<<1);\n-        _inds = _deserialize_text_indicies + _deserialize_text_index_offsets[cs];\n-\n-        _slen = _deserialize_text_key_spans[cs];\n-        _trans = _inds[ _slen > 0 && _keys[0] <=(*p) &&\n-                (*p) <= _keys[1] ?\n-                (*p) - _keys[0] : _slen ];\n-\n-        cs = _deserialize_text_trans_targs[_trans];\n-\n-        if ( _deserialize_text_trans_actions[_trans] == 0 )\n-                goto _again;\n-\n-        switch ( _deserialize_text_trans_actions[_trans] ) {\n-        case 1:\n-#line 38 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        memset (&info, 0, sizeof (info));\n-        memset (&pos , 0, sizeof (pos ));\n-}\n-        break;\n-        case 3:\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-        break;\n-        case 5:\n-#line 55 \"hb-buffer-deserialize-text.rl\"\n-        { if (unlikely (!buffer->ensure_glyphs ())) return false; }\n-        break;\n-        case 8:\n-#line 56 \"hb-buffer-deserialize-text.rl\"\n-        { if (unlikely (!buffer->ensure_unicode ())) return false; }\n-        break;\n-        case 18:\n-#line 58 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n-        break;\n-        case 9:\n-#line 66 \"hb-buffer-deserialize-text.rl\"\n-        {if (!parse_hex (tok, p, &info.codepoint )) return false; }\n-        break;\n-        case 21:\n-#line 68 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n-        break;\n-        case 6:\n-#line 69 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.x_offset )) return false; }\n-        break;\n-        case 23:\n-#line 70 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n-        break;\n-        case 20:\n-#line 71 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n-        break;\n-        case 15:\n-#line 38 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        memset (&info, 0, sizeof (info));\n-        memset (&pos , 0, sizeof (pos ));\n-}\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-        break;\n-        case 4:\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-#line 55 \"hb-buffer-deserialize-text.rl\"\n-        { if (unlikely (!buffer->ensure_glyphs ())) return false; }\n-        break;\n-        case 2:\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-#line 56 \"hb-buffer-deserialize-text.rl\"\n-        { if (unlikely (!buffer->ensure_unicode ())) return false; }\n-        break;\n-        case 16:\n-#line 58 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 7:\n-#line 66 \"hb-buffer-deserialize-text.rl\"\n-        {if (!parse_hex (tok, p, &info.codepoint )) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 10:\n-#line 68 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 22:\n-#line 70 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 19:\n-#line 71 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 24:\n-#line 72 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 12:\n-#line 38 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        memset (&info, 0, sizeof (info));\n-        memset (&pos , 0, sizeof (pos ));\n-}\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-#line 55 \"hb-buffer-deserialize-text.rl\"\n-        { if (unlikely (!buffer->ensure_glyphs ())) return false; }\n-        break;\n-        case 14:\n-#line 38 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        memset (&info, 0, sizeof (info));\n-        memset (&pos , 0, sizeof (pos ));\n-}\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-#line 58 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n-        break;\n-        case 17:\n-#line 58 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n-#line 55 \"hb-buffer-deserialize-text.rl\"\n-        { if (unlikely (!buffer->ensure_glyphs ())) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 11:\n-#line 38 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        memset (&info, 0, sizeof (info));\n-        memset (&pos , 0, sizeof (pos ));\n-}\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-#line 58 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 13:\n-#line 38 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        memset (&info, 0, sizeof (info));\n-        memset (&pos , 0, sizeof (pos ));\n-}\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-#line 58 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n-#line 55 \"hb-buffer-deserialize-text.rl\"\n-        { if (unlikely (!buffer->ensure_glyphs ())) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-#line 722 \"hb-buffer-deserialize-text.hh\"\n-        }\n-\n-_again:\n-        if ( cs == 0 )\n-                goto _out;\n-        if ( ++p != pe )\n-                goto _resume;\n-        _test_eof: {}\n-        if ( p == eof )\n-        {\n-        switch ( _deserialize_text_eof_actions[cs] ) {\n-        case 16:\n-#line 58 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 7:\n-#line 66 \"hb-buffer-deserialize-text.rl\"\n-        {if (!parse_hex (tok, p, &info.codepoint )) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 10:\n-#line 68 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 22:\n-#line 70 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 19:\n-#line 71 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 24:\n-#line 72 \"hb-buffer-deserialize-text.rl\"\n-        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 11:\n-#line 38 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        memset (&info, 0, sizeof (info));\n-        memset (&pos , 0, sizeof (pos ));\n-}\n-#line 51 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        tok = p;\n-}\n-#line 58 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n-#line 43 \"hb-buffer-deserialize-text.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-#line 839 \"hb-buffer-deserialize-text.hh\"\n-        }\n-        }\n-\n-        _out: {}\n-        }\n-\n-#line 138 \"hb-buffer-deserialize-text.rl\"\n-\n-\n-  *end_ptr = p;\n-\n-  return p == pe && *(p-1) != ']';\n-}\n-\n-#endif \/* HB_BUFFER_DESERIALIZE_TEXT_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer-deserialize-text.hh","additions":0,"deletions":853,"binary":false,"changes":853,"status":"deleted"},{"patch":"@@ -59,1 +59,1 @@\n- * @len: length of @str, or -1 if string is %NULL terminated\n+ * @len: length of @str, or -1 if string is `NULL` terminated\n@@ -81,1 +81,1 @@\n- * Converts @format to the string corresponding it, or %NULL if it is not a valid\n+ * Converts @format to the string corresponding it, or `NULL` if it is not a valid\n@@ -85,1 +85,1 @@\n- * A %NULL terminated string corresponding to @format. Should not be freed.\n+ * A `NULL` terminated string corresponding to @format. Should not be freed.\n@@ -186,1 +186,1 @@\n-      memcpy (buf, b, l);\n+      hb_memcpy (buf, b, l);\n@@ -244,1 +244,1 @@\n-      memcpy (buf, b, l);\n+      hb_memcpy (buf, b, l);\n@@ -332,1 +332,1 @@\n-      memcpy (buf, b, l);\n+      hb_memcpy (buf, b, l);\n@@ -384,1 +384,1 @@\n-      memcpy (buf, b, l);\n+      hb_memcpy (buf, b, l);\n@@ -403,1 +403,1 @@\n- * @buf_consumed: (out) (optional): if not %NULL, will be set to the number of bytes written into @buf.\n+ * @buf_consumed: (out) (optional): if not `NULL`, will be set to the number of bytes written into @buf.\n@@ -405,1 +405,1 @@\n- *        read glyph names and extents. If %NULL, an empty font will be used.\n+ *        read glyph names and extents. If `NULL`, an empty font will be used.\n@@ -517,1 +517,1 @@\n- * @buf_consumed: (out) (optional): if not %NULL, will be set to the number of bytes written into @buf.\n+ * @buf_consumed: (out) (optional): if not `NULL`, will be set to the number of bytes written into @buf.\n@@ -640,1 +640,1 @@\n- * @buf_consumed: (out) (optional): if not %NULL, will be set to the number of bytes written into @buf.\n+ * @buf_consumed: (out) (optional): if not `NULL`, will be set to the number of bytes written into @buf.\n@@ -642,1 +642,1 @@\n- *        read glyph names and extents. If %NULL, an empty font will be used.\n+ *        read glyph names and extents. If `NULL`, an empty font will be used.\n@@ -724,1 +724,2 @@\n-#include \"hb-buffer-deserialize-text.hh\"\n+#include \"hb-buffer-deserialize-text-glyphs.hh\"\n+#include \"hb-buffer-deserialize-text-unicode.hh\"\n@@ -730,1 +731,1 @@\n- * @buf_len: the size of @buf, or -1 if it is %NULL-terminated\n+ * @buf_len: the size of @buf, or -1 if it is `NULL`-terminated\n@@ -739,1 +740,2 @@\n- * Return value: %true if @buf is not fully consumed, %false otherwise.\n+ * Return value: `true` if parse was successful, `false` if an error\n+ * occurred.\n@@ -782,3 +784,3 @@\n-      return _hb_buffer_deserialize_text (buffer,\n-                                          buf, buf_len, end_ptr,\n-                                          font);\n+      return _hb_buffer_deserialize_text_glyphs (buffer,\n+                                                 buf, buf_len, end_ptr,\n+                                                 font);\n@@ -803,1 +805,1 @@\n- * @buf_len: the size of @buf, or -1 if it is %NULL-terminated\n+ * @buf_len: the size of @buf, or -1 if it is `NULL`-terminated\n@@ -811,1 +813,2 @@\n- * Return value: %true if @buf is not fully consumed, %false otherwise.\n+ * Return value: `true` if parse was successful, `false` if an error\n+ * occurred.\n@@ -852,3 +855,3 @@\n-      return _hb_buffer_deserialize_text (buffer,\n-                                          buf, buf_len, end_ptr,\n-                                          font);\n+      return _hb_buffer_deserialize_text_unicode (buffer,\n+                                                  buf, buf_len, end_ptr,\n+                                                  font);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer-serialize.cc","additions":26,"deletions":23,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-      printf(\"start %d end %d text start %d end %d\\n\", start, end, text_start, text_end);\n+      printf(\"start %u end %u text start %u end %u\\n\", start, end, text_start, text_end);\n@@ -189,1 +189,1 @@\n-  if (diff)\n+  if (diff & ~HB_BUFFER_DIFF_FLAG_GLYPH_FLAGS_MISMATCH)\n@@ -295,1 +295,1 @@\n-        printf(\"start %d end %d text start %d end %d\\n\", start, end, text_start, text_end);\n+        printf(\"start %u end %u text start %u end %u\\n\", start, end, text_start, text_end);\n@@ -316,1 +316,0 @@\n-\n@@ -385,1 +384,1 @@\n-  if (diff)\n+  if (diff & ~HB_BUFFER_DIFF_FLAG_GLYPH_FLAGS_MISMATCH)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer-verify.cc","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- * %true if all properties of @a equal those of @b, %false otherwise.\n+ * `true` if all properties of @a equal those of @b, `false` otherwise.\n@@ -175,2 +175,2 @@\n-  static_assert ((sizeof (info[0]) == sizeof (pos[0])), \"\");\n-  if (unlikely (hb_unsigned_mul_overflows (new_allocated, sizeof (info[0]))))\n+  unsigned new_bytes;\n+  if (unlikely (hb_unsigned_mul_overflows (new_allocated, sizeof (info[0]), &new_bytes)))\n@@ -179,2 +179,3 @@\n-  new_pos = (hb_glyph_position_t *) hb_realloc (pos, new_allocated * sizeof (pos[0]));\n-  new_info = (hb_glyph_info_t *) hb_realloc (info, new_allocated * sizeof (info[0]));\n+  static_assert (sizeof (info[0]) == sizeof (pos[0]), \"\");\n+  new_pos = (hb_glyph_position_t *) hb_realloc (pos, new_bytes);\n+  new_info = (hb_glyph_info_t *) hb_realloc (info, new_bytes);\n@@ -211,1 +212,1 @@\n-    memcpy (out_info, info, out_len * sizeof (out_info[0]));\n+    hb_memcpy (out_info, info, out_len * sizeof (out_info[0]));\n@@ -232,1 +233,1 @@\n-    memset (info + len, 0, (idx + count - len) * sizeof (info[0]));\n+    hb_memset (info + len, 0, (idx + count - len) * sizeof (info[0]));\n@@ -301,2 +302,2 @@\n-  memset (context, 0, sizeof context);\n-  memset (context_len, 0, sizeof context_len);\n+  hb_memset (context, 0, sizeof context);\n+  hb_memset (context_len, 0, sizeof context_len);\n@@ -316,1 +317,2 @@\n-  if (likely (!hb_unsigned_mul_overflows (len, HB_BUFFER_MAX_LEN_FACTOR)))\n+  unsigned mul;\n+  if (likely (!hb_unsigned_mul_overflows (len, HB_BUFFER_MAX_LEN_FACTOR, &mul)))\n@@ -318,2 +320,1 @@\n-    max_len = hb_max (len * HB_BUFFER_MAX_LEN_FACTOR,\n-                      (unsigned) HB_BUFFER_MAX_LEN_MIN);\n+    max_len = hb_max (mul, (unsigned) HB_BUFFER_MAX_LEN_MIN);\n@@ -321,1 +322,1 @@\n-  if (likely (!hb_unsigned_mul_overflows (len, HB_BUFFER_MAX_OPS_FACTOR)))\n+  if (likely (!hb_unsigned_mul_overflows (len, HB_BUFFER_MAX_OPS_FACTOR, &mul)))\n@@ -323,2 +324,1 @@\n-    max_ops = hb_max (len * HB_BUFFER_MAX_OPS_FACTOR,\n-                      (unsigned) HB_BUFFER_MAX_OPS_MIN);\n+    max_ops = hb_max (mul, (unsigned) HB_BUFFER_MAX_OPS_MIN);\n@@ -348,1 +348,1 @@\n-  memset (glyph, 0, sizeof (*glyph));\n+  hb_memset (glyph, 0, sizeof (*glyph));\n@@ -390,1 +390,1 @@\n-void\n+bool\n@@ -393,0 +393,2 @@\n+  bool ret = false;\n+\n@@ -406,0 +408,1 @@\n+  ret = true;\n@@ -412,0 +415,26 @@\n+\n+  return ret;\n+}\n+\n+int\n+hb_buffer_t::sync_so_far ()\n+{\n+  bool had_output = have_output;\n+  unsigned out_i = out_len;\n+  unsigned i = idx;\n+  unsigned old_idx = idx;\n+\n+  if (sync ())\n+    idx = out_i;\n+  else\n+    idx = i;\n+\n+  if (had_output)\n+  {\n+    have_output = true;\n+    out_len = idx;\n+  }\n+\n+  assert (idx <= len);\n+\n+  return idx - old_idx;\n@@ -496,2 +525,3 @@\n-  while (end < len && info[end - 1].cluster == info[end].cluster)\n-    end++;\n+  if (cluster != info[end - 1].cluster)\n+    while (end < len && info[end - 1].cluster == info[end].cluster)\n+      end++;\n@@ -500,2 +530,3 @@\n-  while (idx < start && info[start - 1].cluster == info[start].cluster)\n-    start--;\n+  if (cluster != info[start].cluster)\n+    while (idx < start && info[start - 1].cluster == info[start].cluster)\n+      start--;\n@@ -504,1 +535,1 @@\n-  if (idx == start)\n+  if (idx == start && info[start].cluster != cluster)\n@@ -579,0 +610,47 @@\n+void\n+hb_buffer_t::delete_glyphs_inplace (bool (*filter) (const hb_glyph_info_t *info))\n+{\n+  \/* Merge clusters and delete filtered glyphs.\n+   * NOTE! We can't use out-buffer as we have positioning data. *\/\n+  unsigned int j = 0;\n+  unsigned int count = len;\n+  for (unsigned int i = 0; i < count; i++)\n+  {\n+    if (filter (&info[i]))\n+    {\n+      \/* Merge clusters.\n+       * Same logic as delete_glyph(), but for in-place removal. *\/\n+\n+      unsigned int cluster = info[i].cluster;\n+      if (i + 1 < count && cluster == info[i + 1].cluster)\n+        continue; \/* Cluster survives; do nothing. *\/\n+\n+      if (j)\n+      {\n+        \/* Merge cluster backward. *\/\n+        if (cluster < info[j - 1].cluster)\n+        {\n+          unsigned int mask = info[i].mask;\n+          unsigned int old_cluster = info[j - 1].cluster;\n+          for (unsigned k = j; k && info[k - 1].cluster == old_cluster; k--)\n+            set_cluster (info[k - 1], cluster, mask);\n+        }\n+        continue;\n+      }\n+\n+      if (i + 1 < count)\n+        merge_clusters (i, i + 2); \/* Merge cluster forward. *\/\n+\n+      continue;\n+    }\n+\n+    if (j != i)\n+    {\n+      info[j] = info[i];\n+      pos[j] = pos[i];\n+    }\n+    j++;\n+  }\n+  len = j;\n+}\n+\n@@ -646,1 +724,1 @@\n- * using the #hb_buffer_t. This function never returns %NULL. If memory cannot\n+ * using the #hb_buffer_t. This function never returns `NULL`. If memory cannot\n@@ -648,1 +726,1 @@\n- * hb_buffer_allocation_successful() returns %false.\n+ * hb_buffer_allocation_successful() returns `false`.\n@@ -778,1 +856,1 @@\n- * Return value: %true if success, %false otherwise\n+ * Return value: `true` if success, `false` otherwise\n@@ -805,1 +883,1 @@\n-hb_buffer_get_user_data (hb_buffer_t        *buffer,\n+hb_buffer_get_user_data (const hb_buffer_t  *buffer,\n@@ -820,0 +898,26 @@\n+ * You rarely need to call this function, since a number of other\n+ * functions transition the content type for you. Namely:\n+ *\n+ * - A newly created buffer starts with content type\n+ *   %HB_BUFFER_CONTENT_TYPE_INVALID. Calling hb_buffer_reset(),\n+ *   hb_buffer_clear_contents(), as well as calling hb_buffer_set_length()\n+ *   with an argument of zero all set the buffer content type to invalid\n+ *   as well.\n+ *\n+ * - Calling hb_buffer_add_utf8(), hb_buffer_add_utf16(),\n+ *   hb_buffer_add_utf32(), hb_buffer_add_codepoints() and\n+ *   hb_buffer_add_latin1() expect that buffer is either empty and\n+ *   have a content type of invalid, or that buffer content type is\n+ *   %HB_BUFFER_CONTENT_TYPE_UNICODE, and they also set the content\n+ *   type to Unicode if they added anything to an empty buffer.\n+ *\n+ * - Finally hb_shape() and hb_shape_full() expect that the buffer\n+ *   is either empty and have content type of invalid, or that buffer\n+ *   content type is %HB_BUFFER_CONTENT_TYPE_UNICODE, and upon\n+ *   success they set the buffer content type to\n+ *   %HB_BUFFER_CONTENT_TYPE_GLYPHS.\n+ *\n+ * The above transitions are designed such that one can use a buffer\n+ * in a loop of \"reset : add-text : shape\" without needing to ever\n+ * modify the content type manually.\n+ *\n@@ -907,1 +1011,0 @@\n-\n@@ -1281,1 +1384,1 @@\n- * %true if @buffer memory allocation succeeded, %false otherwise\n+ * `true` if @buffer memory allocation succeeded, `false` otherwise\n@@ -1298,1 +1401,1 @@\n- * %true if @buffer memory allocation succeeded, %false otherwise.\n+ * `true` if @buffer memory allocation succeeded, `false` otherwise.\n@@ -1343,1 +1446,1 @@\n- * %true if @buffer memory allocation succeeded, %false otherwise.\n+ * `true` if @buffer memory allocation succeeded, `false` otherwise.\n@@ -1359,1 +1462,1 @@\n-    memset (buffer->info + buffer->len, 0, sizeof (buffer->info[0]) * (length - buffer->len));\n+    hb_memset (buffer->info + buffer->len, 0, sizeof (buffer->info[0]) * (length - buffer->len));\n@@ -1361,1 +1464,1 @@\n-      memset (buffer->pos + buffer->len, 0, sizeof (buffer->pos[0]) * (length - buffer->len));\n+      hb_memset (buffer->pos + buffer->len, 0, sizeof (buffer->pos[0]) * (length - buffer->len));\n@@ -1429,1 +1532,1 @@\n- * in which case %NULL is returned.\n+ * in which case `NULL` is returned.\n@@ -1464,1 +1567,1 @@\n- * %true if the @buffer has position array, %false otherwise.\n+ * `true` if the @buffer has position array, `false` otherwise.\n@@ -1648,1 +1751,1 @@\n- * @text_length: The length of the @text, or -1 if it is %NULL terminated.\n+ * @text_length: The length of the @text, or -1 if it is `NULL` terminated.\n@@ -1651,1 +1754,1 @@\n- *               end of @text (assuming it is %NULL terminated).\n+ *               end of @text (assuming it is `NULL` terminated).\n@@ -1674,1 +1777,1 @@\n- * @text_length: The length of the @text, or -1 if it is %NULL terminated\n+ * @text_length: The length of the @text, or -1 if it is `NULL` terminated\n@@ -1677,1 +1780,1 @@\n- *               end of @text (assuming it is %NULL terminated)\n+ *               end of @text (assuming it is `NULL` terminated)\n@@ -1700,1 +1803,1 @@\n- * @text_length: The length of the @text, or -1 if it is %NULL terminated\n+ * @text_length: The length of the @text, or -1 if it is `NULL` terminated\n@@ -1703,1 +1806,1 @@\n- *               end of @text (assuming it is %NULL terminated)\n+ *               end of @text (assuming it is `NULL` terminated)\n@@ -1727,1 +1830,1 @@\n- * @text_length: the length of the @text, or -1 if it is %NULL terminated\n+ * @text_length: the length of the @text, or -1 if it is `NULL` terminated\n@@ -1730,1 +1833,1 @@\n- *               end of @text (assuming it is %NULL terminated)\n+ *               end of @text (assuming it is `NULL` terminated)\n@@ -1753,1 +1856,1 @@\n- * @text_length: the length of the @text, or -1 if it is %NULL terminated.\n+ * @text_length: the length of the @text, or -1 if it is `NULL` terminated.\n@@ -1756,1 +1859,1 @@\n- *               end of @text (assuming it is %NULL terminated).\n+ *               end of @text (assuming it is `NULL` terminated).\n@@ -1769,1 +1872,3 @@\n- * to ensure it contains a valid Unicode code points.\n+ * to ensure it contains a valid Unicode scalar values.  In contrast,\n+ * hb_buffer_add_utf32() can be used that takes similar input but performs\n+ * sanity-check on the input.\n@@ -1832,1 +1937,1 @@\n-  memcpy (buffer->info + orig_len, source->info + start, (end - start) * sizeof (buffer->info[0]));\n+  hb_memcpy (buffer->info + orig_len, source->info + start, (end - start) * sizeof (buffer->info[0]));\n@@ -1834,1 +1939,1 @@\n-    memcpy (buffer->pos + orig_len, source->pos + start, (end - start) * sizeof (buffer->pos[0]));\n+    hb_memcpy (buffer->pos + orig_len, source->pos + start, (end - start) * sizeof (buffer->pos[0]));\n@@ -2022,1 +2127,1 @@\n-    if ((buf_info->mask & ~ref_info->mask & HB_GLYPH_FLAG_DEFINED))\n+    if ((buf_info->mask ^ ref_info->mask) & HB_GLYPH_FLAG_DEFINED)\n@@ -2077,0 +2182,7 @@\n+  if (unlikely (hb_object_is_immutable (buffer)))\n+  {\n+    if (destroy)\n+      destroy (user_data);\n+    return;\n+  }\n+\n@@ -2093,0 +2205,4 @@\n+  assert (!have_output || (out_info == info && out_len == idx));\n+\n+  message_depth++;\n+\n@@ -2095,1 +2211,5 @@\n-  return (bool) this->message_func (this, font, buf, this->message_data);\n+  bool ret = (bool) this->message_func (this, font, buf, this->message_data);\n+\n+  message_depth--;\n+\n+  return ret;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer.cc","additions":169,"deletions":49,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -145,0 +145,9 @@\n+ * @HB_GLYPH_FLAG_SAFE_TO_INSERT_TATWEEL: In scripts that use elongation (Arabic,\n+                                   Mongolian, Syriac, etc.), this flag signifies\n+                                   that it is safe to insert a U+0640 TATWEEL\n+                                   character before this cluster for elongation.\n+                                   This flag does not determine the\n+                                   script-specific elongation places, but only\n+                                   when it is safe to do the elongation without\n+                                   interrupting text shaping.\n+                                   Since: 5.1.0\n@@ -152,2 +161,3 @@\n-  HB_GLYPH_FLAG_UNSAFE_TO_BREAK         = 0x00000001,\n-  HB_GLYPH_FLAG_UNSAFE_TO_CONCAT        = 0x00000002,\n+  HB_GLYPH_FLAG_UNSAFE_TO_BREAK                 = 0x00000001,\n+  HB_GLYPH_FLAG_UNSAFE_TO_CONCAT                = 0x00000002,\n+  HB_GLYPH_FLAG_SAFE_TO_INSERT_TATWEEL          = 0x00000004,\n@@ -155,1 +165,1 @@\n-  HB_GLYPH_FLAG_DEFINED                 = 0x00000003 \/* OR of all defined flags *\/\n+  HB_GLYPH_FLAG_DEFINED                         = 0x00000007 \/* OR of all defined flags *\/\n@@ -269,1 +279,1 @@\n-hb_buffer_get_user_data (hb_buffer_t        *buffer,\n+hb_buffer_get_user_data (const hb_buffer_t  *buffer,\n@@ -376,0 +386,4 @@\n+ * @HB_BUFFER_FLAG_PRODUCE_SAFE_TO_INSERT_TATWEEL:\n+ *                      flag indicating that the @HB_GLYPH_FLAG_SAFE_TO_INSERT_TATWEEL\n+ *                      glyph-flag should be produced by the shaper. By default\n+ *                      it will not be produced. Since: 5.1.0\n@@ -391,0 +405,1 @@\n+  HB_BUFFER_FLAG_PRODUCE_SAFE_TO_INSERT_TATWEEL = 0x00000080u,\n@@ -392,1 +407,1 @@\n-  HB_BUFFER_FLAG_DEFINED                        = 0x0000007Fu\n+  HB_BUFFER_FLAG_DEFINED                        = 0x000000FFu\n@@ -751,1 +766,1 @@\n- * Debugging.\n+ * Tracing.\n@@ -758,1 +773,1 @@\n- * @message: %NULL-terminated message passed to the function\n+ * @message: `NULL`-terminated message passed to the function\n@@ -764,1 +779,1 @@\n- * Returning %false from this method will skip this shaping step and move to\n+ * Returning `false` from this method will skip this shaping step and move to\n@@ -767,1 +782,1 @@\n- * Return value: %true to perform the shaping step, %false to skip it.\n+ * Return value: `true` to perform the shaping step, `false` to skip it.\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer.h","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"hb-set-digest.hh\"\n@@ -37,20 +38,0 @@\n-#ifndef HB_BUFFER_MAX_LEN_FACTOR\n-#define HB_BUFFER_MAX_LEN_FACTOR 64\n-#endif\n-#ifndef HB_BUFFER_MAX_LEN_MIN\n-#define HB_BUFFER_MAX_LEN_MIN 16384\n-#endif\n-#ifndef HB_BUFFER_MAX_LEN_DEFAULT\n-#define HB_BUFFER_MAX_LEN_DEFAULT 0x3FFFFFFF \/* Shaping more than a billion chars? Let us know! *\/\n-#endif\n-\n-#ifndef HB_BUFFER_MAX_OPS_FACTOR\n-#define HB_BUFFER_MAX_OPS_FACTOR 1024\n-#endif\n-#ifndef HB_BUFFER_MAX_OPS_MIN\n-#define HB_BUFFER_MAX_OPS_MIN 16384\n-#endif\n-#ifndef HB_BUFFER_MAX_OPS_DEFAULT\n-#define HB_BUFFER_MAX_OPS_DEFAULT 0x1FFFFFFF \/* Shaping more than a billion operations? Let us know! *\/\n-#endif\n-\n@@ -210,0 +191,8 @@\n+  hb_set_digest_t digest () const\n+  {\n+    hb_set_digest_t d;\n+    d.init ();\n+    d.add_array (&info[0].codepoint, len, sizeof (info[0]));\n+    return d;\n+  }\n+\n@@ -291,1 +280,2 @@\n-  HB_INTERNAL void sync ();\n+  HB_INTERNAL bool sync ();\n+  HB_INTERNAL int sync_so_far ();\n@@ -404,0 +394,2 @@\n+  HB_INTERNAL void delete_glyphs_inplace (bool (*filter) (const hb_glyph_info_t *info));\n+\n@@ -464,0 +456,11 @@\n+  void safe_to_insert_tatweel (unsigned int start = 0, unsigned int end = -1)\n+  {\n+    if ((flags & HB_BUFFER_FLAG_PRODUCE_SAFE_TO_INSERT_TATWEEL) == 0)\n+    {\n+      unsafe_to_break (start, end);\n+      return;\n+    }\n+    _set_glyph_flags (HB_GLYPH_FLAG_SAFE_TO_INSERT_TATWEEL,\n+                      start, end,\n+                      true);\n+  }\n@@ -558,2 +561,0 @@\n-    message_depth++;\n-\n@@ -565,2 +566,0 @@\n-    message_depth--;\n-\n@@ -585,2 +584,31 @@\n-    for (unsigned int i = start; i < end; i++)\n-      if (cluster != infos[i].cluster)\n+    if (unlikely (start == end))\n+      return;\n+\n+    unsigned cluster_first = infos[start].cluster;\n+    unsigned cluster_last = infos[end - 1].cluster;\n+\n+    if (cluster_level == HB_BUFFER_CLUSTER_LEVEL_CHARACTERS ||\n+        (cluster != cluster_first && cluster != cluster_last))\n+    {\n+      for (unsigned int i = start; i < end; i++)\n+        if (cluster != infos[i].cluster)\n+        {\n+          scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GLYPH_FLAGS;\n+          infos[i].mask |= mask;\n+        }\n+      return;\n+    }\n+\n+    \/* Monotone clusters *\/\n+\n+    if (cluster == cluster_first)\n+    {\n+      for (unsigned int i = end; start < i && infos[i - 1].cluster != cluster_first; i--)\n+      {\n+        scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GLYPH_FLAGS;\n+        infos[i - 1].mask |= mask;\n+      }\n+    }\n+    else \/* cluster == cluster_last *\/\n+    {\n+      for (unsigned int i = start; i < end && infos[i].cluster != cluster_last; i++)\n@@ -591,0 +619,1 @@\n+    }\n@@ -592,1 +621,1 @@\n-  static unsigned\n+  unsigned\n@@ -597,3 +626,11 @@\n-    for (unsigned int i = start; i < end; i++)\n-      cluster = hb_min (cluster, infos[i].cluster);\n-    return cluster;\n+    if (unlikely (start == end))\n+      return cluster;\n+\n+    if (cluster_level == HB_BUFFER_CLUSTER_LEVEL_CHARACTERS)\n+    {\n+      for (unsigned int i = start; i < end; i++)\n+        cluster = hb_min (cluster, infos[i].cluster);\n+      return cluster;\n+    }\n+\n+    return hb_min (cluster, hb_min (infos[start].cluster, infos[end - 1].cluster));\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer.hh","additions":68,"deletions":31,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -35,1 +35,4 @@\n-template <unsigned int key_bits=16, unsigned int value_bits=8 + 32 - key_bits, unsigned int cache_bits=8>\n+template <unsigned int key_bits=16,\n+         unsigned int value_bits=8 + 32 - key_bits,\n+         unsigned int cache_bits=8,\n+         bool thread_safe=true>\n@@ -38,0 +41,9 @@\n+  using item_t = typename std::conditional<thread_safe,\n+                                           typename std::conditional<key_bits + value_bits - cache_bits <= 16,\n+                                                                     hb_atomic_short_t,\n+                                                                     hb_atomic_int_t>::type,\n+                                           typename std::conditional<key_bits + value_bits - cache_bits <= 16,\n+                                                                     short,\n+                                                                     int>::type\n+                                          >::type;\n+\n@@ -39,2 +51,3 @@\n-  static_assert ((key_bits + value_bits - cache_bits <= 8 * sizeof (hb_atomic_int_t)), \"\");\n-  static_assert (sizeof (hb_atomic_int_t) == sizeof (unsigned int), \"\");\n+  static_assert ((key_bits + value_bits <= cache_bits + 8 * sizeof (item_t)), \"\");\n+\n+  hb_cache_t () { init (); }\n@@ -43,1 +56,0 @@\n-  void fini () {}\n@@ -48,1 +60,1 @@\n-      values[i].set_relaxed (-1);\n+      values[i] = -1;\n@@ -54,2 +66,2 @@\n-    unsigned int v = values[k].get_relaxed ();\n-    if ((key_bits + value_bits - cache_bits == 8 * sizeof (hb_atomic_int_t) && v == (unsigned int) -1) ||\n+    unsigned int v = values[k];\n+    if ((key_bits + value_bits - cache_bits == 8 * sizeof (item_t) && v == (unsigned int) -1) ||\n@@ -68,1 +80,1 @@\n-    values[k].set_relaxed (v);\n+    values[k] = v;\n@@ -73,1 +85,1 @@\n-  hb_atomic_int_t values[1u<<cache_bits];\n+  item_t values[1u<<cache_bits];\n@@ -76,3 +88,0 @@\n-typedef hb_cache_t<21, 16, 8> hb_cmap_cache_t;\n-typedef hb_cache_t<16, 24, 8> hb_advance_cache_t;\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cache.hh","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -287,10 +287,2 @@\n-  byte_str_ref_t () { init (); }\n-\n-  void init ()\n-  {\n-    str = hb_ubytes_t ();\n-    offset = 0;\n-    error = false;\n-  }\n-\n-  void fini () {}\n+  byte_str_ref_t ()\n+    : str () {}\n@@ -299,1 +291,1 @@\n-    : str (str_), offset (offset_), error (false) {}\n+    : str (str_) { set_offset (offset_); }\n@@ -304,2 +296,1 @@\n-    offset = offset_;\n-    error = false;\n+    set_offset (offset_);\n@@ -309,1 +300,1 @@\n-    if (unlikely ((unsigned int) (offset + i) >= str.length))\n+    if (unlikely ((unsigned int) (get_offset () + i) >= str.length))\n@@ -314,1 +305,1 @@\n-    return str[offset + i];\n+    return str.arrayZ[get_offset () + i];\n@@ -317,0 +308,2 @@\n+  unsigned char head_unchecked () const { return str.arrayZ[get_offset ()]; }\n+\n@@ -318,1 +311,1 @@\n-  operator hb_ubytes_t () const { return str.sub_array (offset, str.length - offset); }\n+  operator hb_ubytes_t () const { return str.sub_array (get_offset ()); }\n@@ -324,1 +317,1 @@\n-  { return (!in_error () && offset + count <= str.length); }\n+  { return get_offset () + count <= str.length; }\n@@ -327,9 +320,2 @@\n-    if (likely (!in_error () && (offset <= str.length) && (offset + count <= str.length)))\n-    {\n-      offset += count;\n-    }\n-    else\n-    {\n-      offset = str.length;\n-      set_error ();\n-    }\n+    \/* Automatically puts us in error if count is out-of-range. *\/\n+    set_offset (get_offset () + count);\n@@ -338,2 +324,2 @@\n-  void set_error ()      { error = true; }\n-  bool in_error () const { return error; }\n+  \/* We (ab)use ubytes backwards_length as a cursor (called offset),\n+   * as well as to store error condition. *\/\n@@ -341,2 +327,7 @@\n-  hb_ubytes_t       str;\n-  unsigned int  offset; \/* beginning of the sub-string within str *\/\n+  unsigned get_offset () const { return str.backwards_length; }\n+  void set_offset (unsigned offset) { str.backwards_length = offset; }\n+\n+  void set_error ()      { str.backwards_length = str.length + 1; }\n+  bool in_error () const { return str.backwards_length > str.length; }\n+\n+  unsigned total_size () const { return str.length; }\n@@ -345,1 +336,1 @@\n-  bool    error;\n+  hb_ubytes_t       str;\n@@ -494,2 +485,9 @@\n-  hb_ubytes_t str;\n-  op_code_t  op;\n+  \/* This used to have a hb_ubytes_t. Using a pointer and length\n+   * in a particular order, saves 8 bytes in this struct and more\n+   * in our parsed_cs_op_t subclass. *\/\n+\n+  const unsigned char *ptr = nullptr;\n+\n+  op_code_t  op = OpCode_Invalid;\n+\n+  uint8_t length = 0;\n@@ -506,1 +504,1 @@\n-    HBUINT8 *d = c->allocate_size<HBUINT8> (opstr.str.length);\n+    unsigned char *d = c->allocate_size<unsigned char> (opstr.length);\n@@ -508,1 +506,3 @@\n-    memcpy (d, &opstr.str[0], opstr.str.length);\n+    \/* Faster than hb_memcpy for small strings. *\/\n+    for (unsigned i = 0; i < opstr.length; i++)\n+      d[i] = opstr.ptr[i];\n@@ -525,1 +525,1 @@\n-    values.alloc (n);\n+    values.alloc (n, true);\n@@ -528,9 +528,1 @@\n-  void add_op (op_code_t op, const byte_str_ref_t& str_ref = byte_str_ref_t ())\n-  {\n-    VAL *val = values.push ();\n-    val->op = op;\n-    val->str = str_ref.str.sub_array (opStart, str_ref.offset - opStart);\n-    opStart = str_ref.offset;\n-  }\n-\n-  void add_op (op_code_t op, const byte_str_ref_t& str_ref, const VAL &v)\n+  void add_op (op_code_t op, const byte_str_ref_t& str_ref = byte_str_ref_t (), const VAL &v = VAL ())\n@@ -540,2 +532,4 @@\n-    val->str = str_ref.sub_array ( opStart, str_ref.offset - opStart);\n-    opStart = str_ref.offset;\n+    auto arr = str_ref.sub_array (opStart, str_ref.get_offset () - opStart);\n+    val->ptr = arr.arrayZ;\n+    val->length = arr.length;\n+    opStart = str_ref.get_offset ();\n@@ -552,2 +546,1 @@\n-  const VAL &get_value (unsigned int i)   const { return values[i]; }\n-  const VAL &operator [] (unsigned int i) const { return get_value (i); }\n+  const VAL &operator [] (unsigned int i) const { return values[i]; }\n@@ -568,1 +561,1 @@\n-  { return error || str_ref.in_error () || argStack.in_error (); }\n+  { return str_ref.in_error () || argStack.in_error (); }\n@@ -570,1 +563,1 @@\n-  void set_error () { error = true; }\n+  void set_error () { str_ref.set_error (); }\n@@ -577,1 +570,2 @@\n-    op = (op_code_t)(unsigned char)str_ref[0];\n+    op = (op_code_t) str_ref.head_unchecked ();\n+    str_ref.inc ();\n@@ -581,1 +575,1 @@\n-      op = Make_OpCode_ESC(str_ref[1]);\n+      op = Make_OpCode_ESC (str_ref.head_unchecked ());\n@@ -584,1 +578,0 @@\n-    str_ref.inc ();\n@@ -599,2 +592,0 @@\n-  protected:\n-  bool          error = false;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cff-interp-common.hh","additions":47,"deletions":56,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -884,0 +884,1 @@\n+    unsigned max_ops = HB_CFF_MAX_OPS;\n@@ -885,0 +886,5 @@\n+      if (unlikely (!--max_ops))\n+      {\n+        SUPER::env.set_error ();\n+        break;\n+      }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cff-interp-cs-common.hh","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  void init () { single_val.set_int (0); }\n+  void init () {}\n@@ -40,2 +40,0 @@\n-\n-  number_t            single_val;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cff-interp-dict-common.hh","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,2 @@\n-  cff1_cs_interp_env_t (const hb_ubytes_t &str, ACC &acc, unsigned int fd)\n+  cff1_cs_interp_env_t (const hb_ubytes_t &str, ACC &acc, unsigned int fd,\n+                        const int *coords_=nullptr, unsigned int num_coords_=0)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cff1-interp-cs.hh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-                   unsigned int numBlends, hb_array_t<const blend_arg_t> blends_)\n+                   hb_array_t<const blend_arg_t> blends_)\n@@ -47,1 +47,3 @@\n-    deltas.resize (numBlends);\n+    unsigned numBlends = blends_.length;\n+    if (unlikely (!deltas.resize_exact (numBlends)))\n+      return;\n@@ -49,1 +51,1 @@\n-      deltas[i] = blends_[i];\n+      deltas.arrayZ[i] = blends_.arrayZ[i];\n@@ -56,1 +58,1 @@\n-    deltas.resize (0);\n+    deltas.shrink (0);\n@@ -64,1 +66,0 @@\n-typedef interp_env_t<blend_arg_t> BlendInterpEnv;\n@@ -120,1 +121,1 @@\n-        if (unlikely (!scalars.resize (region_count)))\n+        if (unlikely (!scalars.resize_exact (region_count)))\n@@ -157,2 +158,3 @@\n-        for (unsigned int i = 0; i < scalars.length; i++)\n-          v += (double) scalars[i] * deltas[i].to_real ();\n+        unsigned count = scalars.length;\n+        for (unsigned i = 0; i < count; i++)\n+          v += (double) scalars.arrayZ[i] * deltas.arrayZ[i].to_real ();\n@@ -164,0 +166,2 @@\n+  bool have_coords () const { return num_coords; }\n+\n@@ -223,1 +227,4 @@\n-    arg.set_blends (n, i, blends.length, blends);\n+    if (env.have_coords ())\n+      arg.set_int (round (arg.to_real () + env.blend_deltas (blends)));\n+    else\n+      arg.set_blends (n, i, blends);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cff2-interp-cs.hh","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,26 +32,0 @@\n-#if !defined(HB_NO_SETLOCALE) && (!defined(HAVE_NEWLOCALE) || !defined(HAVE_USELOCALE))\n-#define HB_NO_SETLOCALE 1\n-#endif\n-\n-#ifndef HB_NO_SETLOCALE\n-\n-#include <locale.h>\n-#ifdef HAVE_XLOCALE_H\n-#include <xlocale.h> \/\/ Needed on BSD\/OS X for uselocale\n-#endif\n-\n-#ifdef WIN32\n-#define hb_locale_t _locale_t\n-#else\n-#define hb_locale_t locale_t\n-#endif\n-#define hb_setlocale setlocale\n-#define hb_uselocale uselocale\n-\n-#else\n-\n-#define hb_locale_t void *\n-#define hb_setlocale(Category, Locale) \"C\"\n-#define hb_uselocale(Locale) ((hb_locale_t) 0)\n-\n-#endif\n@@ -102,1 +76,1 @@\n-  _hb_options.set_relaxed (u.i);\n+  _hb_options = u.i;\n@@ -111,1 +85,1 @@\n- * @len: Length of @str, or -1 if it is %NULL-terminated\n+ * @len: Length of @str, or -1 if it is `NULL`-terminated\n@@ -173,1 +147,1 @@\n- * @len: Length of @str, or -1 if it is %NULL-terminated\n+ * @len: Length of @str, or -1 if it is `NULL`-terminated\n@@ -288,1 +262,1 @@\n-      memcpy((unsigned char *) lang, s, len);\n+      hb_memcpy((unsigned char *) lang, s, len);\n@@ -360,1 +334,1 @@\n- * @len: length of the @str, or -1 if it is %NULL-terminated.\n+ * @len: length of the @str, or -1 if it is `NULL`-terminated.\n@@ -382,1 +356,1 @@\n-    memcpy (strbuf, str, len);\n+    hb_memcpy (strbuf, str, len);\n@@ -399,1 +373,1 @@\n- * A %NULL-terminated string representing the @language. Must not be freed by\n+ * A `NULL`-terminated string representing the @language. Must not be freed by\n@@ -444,0 +418,32 @@\n+\/**\n+ * hb_language_matches:\n+ * @language: The #hb_language_t to work on\n+ * @specific: Another #hb_language_t\n+ *\n+ * Check whether a second language tag is the same or a more\n+ * specific version of the provided language tag.  For example,\n+ * \"fa_IR.utf8\" is a more specific tag for \"fa\" or for \"fa_IR\".\n+ *\n+ * Return value: `true` if languages match, `false` otherwise.\n+ *\n+ * Since: 5.0.0\n+ **\/\n+hb_bool_t\n+hb_language_matches (hb_language_t language,\n+                     hb_language_t specific)\n+{\n+  if (language == specific) return true;\n+  if (!language || !specific) return false;\n+\n+  const char *l = language->s;\n+  const char *s = specific->s;\n+  unsigned ll = strlen (l);\n+  unsigned sl = strlen (s);\n+\n+  if (ll > sl)\n+    return false;\n+\n+  return strncmp (l, s, ll) == 0 &&\n+         (s[ll] == '\\0' || s[ll] == '-');\n+}\n+\n@@ -501,1 +507,1 @@\n- * @len: length of the @str, or -1 if it is %NULL-terminated.\n+ * @len: length of the @str, or -1 if it is `NULL`-terminated.\n@@ -696,2 +702,2 @@\n- * Return value: %true if the library is equal to or greater than\n- * the test value, %false otherwise\n+ * Return value: `true` if the library is equal to or greater than\n+ * the test value, `false` otherwise\n@@ -884,1 +890,1 @@\n- * @len: length of @str, or -1 if string is %NULL terminated\n+ * @len: length of @str, or -1 if string is `NULL` terminated\n@@ -926,1 +932,1 @@\n- * %true if @str is successfully parsed, %false otherwise\n+ * `true` if @str is successfully parsed, `false` otherwise\n@@ -947,1 +953,1 @@\n-    memset (feature, 0, sizeof (*feature));\n+    hb_memset (feature, 0, sizeof (*feature));\n@@ -957,1 +963,1 @@\n- * Converts a #hb_feature_t into a %NULL-terminated string in the format\n+ * Converts a #hb_feature_t into a `NULL`-terminated string in the format\n@@ -996,1 +1002,1 @@\n-  memcpy (buf, s, len);\n+  hb_memcpy (buf, s, len);\n@@ -1025,1 +1031,1 @@\n- * @len: length of @str, or -1 if string is %NULL terminated\n+ * @len: length of @str, or -1 if string is `NULL` terminated\n@@ -1038,1 +1044,1 @@\n- * %true if @str is successfully parsed, %false otherwise\n+ * `true` if @str is successfully parsed, `false` otherwise\n@@ -1059,1 +1065,1 @@\n-    memset (variation, 0, sizeof (*variation));\n+    hb_memset (variation, 0, sizeof (*variation));\n@@ -1107,1 +1113,1 @@\n- * @buf: (array length=size) (out): output string\n+ * @buf: (array length=size) (out caller-allocates): output string\n@@ -1110,1 +1116,1 @@\n- * Converts an #hb_variation_t into a %NULL-terminated string in the format\n+ * Converts an #hb_variation_t into a `NULL`-terminated string in the format\n@@ -1137,1 +1143,1 @@\n-  memcpy (buf, s, len);\n+  hb_memcpy (buf, s, len);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-common.cc","additions":53,"deletions":47,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -329,0 +329,3 @@\n+HB_EXTERN hb_bool_t\n+hb_language_matches (hb_language_t language,\n+                     hb_language_t specific);\n@@ -495,0 +498,2 @@\n+ * @HB_SCRIPT_KAWI: `Kawi`, Since: 5.2.0\n+ * @HB_SCRIPT_NAG_MUNDARI: `Nagm`, Since: 5.2.0\n@@ -716,0 +721,6 @@\n+  \/*\n+   * Since 5.2.0\n+   *\/\n+  HB_SCRIPT_KAWI                        = HB_TAG ('K','a','w','i'), \/*15.0*\/\n+  HB_SCRIPT_NAG_MUNDARI                 = HB_TAG ('N','a','g','m'), \/*15.0*\/\n+\n@@ -889,0 +900,26 @@\n+\/**\n+ * hb_glyph_extents_t:\n+ * @x_bearing: Distance from the x-origin to the left extremum of the glyph.\n+ * @y_bearing: Distance from the top extremum of the glyph to the y-origin.\n+ * @width: Distance from the left extremum of the glyph to the right extremum.\n+ * @height: Distance from the top extremum of the glyph to the bottom extremum.\n+ *\n+ * Glyph extent values, measured in font units.\n+ *\n+ * Note that @height is negative, in coordinate systems that grow up.\n+ **\/\n+typedef struct hb_glyph_extents_t {\n+  hb_position_t x_bearing;\n+  hb_position_t y_bearing;\n+  hb_position_t width;\n+  hb_position_t height;\n+} hb_glyph_extents_t;\n+\n+\/**\n+ * hb_font_t:\n+ *\n+ * Data type for holding fonts.\n+ *\n+ *\/\n+typedef struct hb_font_t hb_font_t;\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-common.h","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+#ifndef HB_EXPERIMENTAL_API\n+#define HB_NO_BEYOND_64K\n+#define HB_NO_CUBIC_GLYF\n+#define HB_NO_VAR_COMPOSITES\n+#endif\n@@ -71,0 +76,1 @@\n+#define HB_NO_LAYOUT_RARELY_USED\n@@ -78,1 +84,0 @@\n-#define HB_NO_SETLOCALE\n@@ -81,0 +86,2 @@\n+#define HB_NO_PAINT\n+#define HB_NO_SETLOCALE\n@@ -83,0 +90,1 @@\n+#define HB_NO_VERTICAL\n@@ -101,0 +109,5 @@\n+#ifdef HB_NO_BORING_EXPANSION\n+#define HB_NO_BEYOND_64K\n+#define HB_NO_AVAR2\n+#endif\n+\n@@ -107,0 +120,5 @@\n+#ifdef HB_NO_SHAPER\n+#define HB_NO_OT_SHAPE\n+#define HB_NO_AAT_SHAPE\n+#endif\n+\n@@ -153,0 +171,1 @@\n+#define HB_NO_OT_SHAPER_MYANMAR_ZAWGYI\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-config.hh","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -72,3 +72,3 @@\n-  operator bool () { return p; }\n-  bool operator == (const shared_ptr &o) { return p == o.p; }\n-  bool operator != (const shared_ptr &o) { return p != o.p; }\n+  operator bool () const { return p; }\n+  bool operator == (const shared_ptr &o) const { return p == o.p; }\n+  bool operator != (const shared_ptr &o) const { return p != o.p; }\n@@ -133,1 +133,1 @@\n-          void * (*_get_user_data) (T *,\n+          void * (*_get_user_data) (const T *,\n@@ -163,0 +163,2 @@\n+HB_DEFINE_VTABLE (draw_funcs);\n+HB_DEFINE_VTABLE (paint_funcs);\n@@ -167,0 +169,21 @@\n+#ifdef HB_SUBSET_H\n+\n+#define HB_DEFINE_VTABLE(name) \\\n+        template<> \\\n+        struct vtable<hb_##name##_t> \\\n+             : vtable_t<hb_##name##_t, \\\n+                        nullptr, \\\n+                        &hb_##name##_reference, \\\n+                        &hb_##name##_destroy, \\\n+                        &hb_##name##_set_user_data, \\\n+                        &hb_##name##_get_user_data> {}\n+\n+\n+HB_DEFINE_VTABLE (subset_input);\n+HB_DEFINE_VTABLE (subset_plan);\n+\n+#undef HB_DEFINE_VTABLE\n+\n+#endif\n+\n+\n@@ -169,0 +192,6 @@\n+\/* Workaround for GCC < 7, see:\n+ * https:\/\/gcc.gnu.org\/bugzilla\/show_bug.cgi?id=56480\n+ * https:\/\/stackoverflow.com\/a\/25594741 *\/\n+namespace std {\n+\n+\n@@ -170,1 +199,1 @@\n-struct std::hash<hb::shared_ptr<T>>\n+struct hash<hb::shared_ptr<T>>\n@@ -180,1 +209,1 @@\n-struct std::hash<hb::unique_ptr<T>>\n+struct hash<hb::unique_ptr<T>>\n@@ -190,0 +219,2 @@\n+} \/\/ namespace std\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cplusplus.hh","additions":37,"deletions":6,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  u.i = _hb_options.get_relaxed ();\n+  u.i = _hb_options;\n@@ -75,1 +75,1 @@\n-    u.i = _hb_options.get_relaxed ();\n+    u.i = _hb_options;\n@@ -116,1 +116,1 @@\n-    fprintf (stderr, \"%.*s\", func_len, func);\n+    fprintf (stderr, \"%.*s\", (int) func_len, func);\n@@ -145,1 +145,1 @@\n-    fprintf (stderr, \"(%*p) \", (unsigned int) (2 * sizeof (void *)), obj);\n+    fprintf (stderr, \"(%*p) \", (int) (2 * sizeof (void *)), obj);\n@@ -147,1 +147,1 @@\n-    fprintf (stderr, \" %*s  \", (unsigned int) (2 * sizeof (void *)), \"\");\n+    fprintf (stderr, \" %*s  \", (int) (2 * sizeof (void *)), \"\");\n@@ -309,1 +309,1 @@\n-                              \"return %s (line %d)\",\n+                              \"return %s (line %u)\",\n@@ -399,1 +399,1 @@\n-         \"idx %d gid %u lookup %d\", \\\n+         \"idx %u gid %u lookup %d\", \\\n@@ -457,1 +457,1 @@\n-         \"format %d\", (int) format)\n+         \"format %u\", (unsigned) format)\n@@ -463,0 +463,5 @@\n+#ifndef HB_BUFFER_MESSAGE_MORE\n+#define HB_BUFFER_MESSAGE_MORE (HB_DEBUG+1)\n+#endif\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-debug.hh","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -105,1 +105,2 @@\n-HB_EXTERN HB_DEPRECATED_FOR(hb_font_funcs_set_nominal_glyph_func and hb_font_funcs_set_variation_glyph_func) void\n+HB_DEPRECATED_FOR (hb_font_funcs_set_nominal_glyph_func and hb_font_funcs_set_variation_glyph_func)\n+HB_EXTERN void\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-deprecated.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+ *\n+ * The #hb_draw_funcs_t struct can be used with hb_font_draw_glyph().\n@@ -83,0 +85,50 @@\n+static bool\n+_hb_draw_funcs_set_preamble (hb_draw_funcs_t    *dfuncs,\n+                             bool                func_is_null,\n+                             void              **user_data,\n+                             hb_destroy_func_t  *destroy)\n+{\n+  if (hb_object_is_immutable (dfuncs))\n+  {\n+    if (*destroy)\n+      (*destroy) (*user_data);\n+    return false;\n+  }\n+\n+  if (func_is_null)\n+  {\n+    if (*destroy)\n+      (*destroy) (*user_data);\n+    *destroy = nullptr;\n+    *user_data = nullptr;\n+  }\n+\n+  return true;\n+}\n+\n+static bool\n+_hb_draw_funcs_set_middle (hb_draw_funcs_t   *dfuncs,\n+                           void              *user_data,\n+                           hb_destroy_func_t  destroy)\n+{\n+  if (user_data && !dfuncs->user_data)\n+  {\n+    dfuncs->user_data = (decltype (dfuncs->user_data)) hb_calloc (1, sizeof (*dfuncs->user_data));\n+    if (unlikely (!dfuncs->user_data))\n+      goto fail;\n+  }\n+  if (destroy && !dfuncs->destroy)\n+  {\n+    dfuncs->destroy = (decltype (dfuncs->destroy)) hb_calloc (1, sizeof (*dfuncs->destroy));\n+    if (unlikely (!dfuncs->destroy))\n+      goto fail;\n+  }\n+\n+  return true;\n+\n+fail:\n+  if (destroy)\n+    (destroy) (user_data);\n+  return false;\n+}\n+\n@@ -91,2 +143,2 @@\n-  if (hb_object_is_immutable (dfuncs))                                          \\\n-    return;                                                                     \\\n+  if (!_hb_draw_funcs_set_preamble (dfuncs, !func, &user_data, &destroy))\\\n+      return;                                                            \\\n@@ -97,12 +149,2 @@\n-  if (user_data && !dfuncs->user_data)                                   \\\n-  {                                                                      \\\n-    dfuncs->user_data = (decltype (dfuncs->user_data)) hb_calloc (1, sizeof (*dfuncs->user_data)); \\\n-    if (unlikely (!dfuncs->user_data))                                   \\\n-      goto fail;                                                         \\\n-  }                                                                      \\\n-  if (destroy && !dfuncs->destroy)                                       \\\n-  {                                                                      \\\n-    dfuncs->destroy = (decltype (dfuncs->destroy)) hb_calloc (1, sizeof (*dfuncs->destroy)); \\\n-    if (unlikely (!dfuncs->destroy))                                     \\\n-      goto fail;                                                         \\\n-  }                                                                      \\\n+  if (!_hb_draw_funcs_set_middle (dfuncs, user_data, destroy))           \\\n+      return;                                                            \\\n@@ -110,1 +152,1 @@\n-  if (func) {                                                           \\\n+  if (func)                                                             \\\n@@ -112,5 +154,1 @@\n-    if (dfuncs->user_data)                                              \\\n-      dfuncs->user_data->name = user_data;                              \\\n-    if (dfuncs->destroy)                                                \\\n-      dfuncs->destroy->name = destroy;                                  \\\n-  } else {                                                              \\\n+  else                                                                  \\\n@@ -118,9 +156,5 @@\n-    if (dfuncs->user_data)                                              \\\n-      dfuncs->user_data->name = nullptr;                                \\\n-    if (dfuncs->destroy)                                                \\\n-      dfuncs->destroy->name = nullptr;                                  \\\n-  }                                                                     \\\n-                                                                         \\\n-fail:                                                                    \\\n-  if (destroy)                                                           \\\n-    destroy (user_data);                                                 \\\n+                                                                        \\\n+  if (dfuncs->user_data)                                                \\\n+    dfuncs->user_data->name = user_data;                                \\\n+  if (dfuncs->destroy)                                                  \\\n+    dfuncs->destroy->name = destroy;                                    \\\n@@ -140,1 +174,1 @@\n- * done using the #hb_draw_funcs_t. This function never returns %NULL. If\n+ * done using the #hb_draw_funcs_t. This function never returns `NULL`. If\n@@ -169,0 +203,14 @@\n+\/**\n+ * hb_draw_funcs_get_empty:\n+ *\n+ * Fetches the singleton empty draw-functions structure.\n+ *\n+ * Return value: (transfer full): The empty draw-functions structure\n+ *\n+ * Since: 7.0.0\n+ **\/\n+hb_draw_funcs_t *\n+hb_draw_funcs_get_empty ()\n+{\n+  return const_cast<hb_draw_funcs_t *> (&Null (hb_draw_funcs_t));\n+}\n@@ -174,2 +222,4 @@\n- * Increases the reference count on @dfuncs by one. This prevents @buffer from\n- * being destroyed until a matching call to hb_draw_funcs_destroy() is made.\n+ * Increases the reference count on @dfuncs by one.\n+ *\n+ * This prevents @dfuncs from being destroyed until a matching\n+ * call to hb_draw_funcs_destroy() is made.\n@@ -211,0 +261,3 @@\n+  hb_free (dfuncs->destroy);\n+  hb_free (dfuncs->user_data);\n+\n@@ -214,0 +267,43 @@\n+\/**\n+ * hb_draw_funcs_set_user_data: (skip)\n+ * @dfuncs: The draw-functions structure\n+ * @key: The user-data key\n+ * @data: A pointer to the user data\n+ * @destroy: (nullable): A callback to call when @data is not needed anymore\n+ * @replace: Whether to replace an existing data with the same key\n+ *\n+ * Attaches a user-data key\/data pair to the specified draw-functions structure.\n+ *\n+ * Return value: `true` if success, `false` otherwise\n+ *\n+ * Since: 7.0.0\n+ **\/\n+hb_bool_t\n+hb_draw_funcs_set_user_data (hb_draw_funcs_t *dfuncs,\n+                             hb_user_data_key_t *key,\n+                             void *              data,\n+                             hb_destroy_func_t   destroy,\n+                             hb_bool_t           replace)\n+{\n+  return hb_object_set_user_data (dfuncs, key, data, destroy, replace);\n+}\n+\n+\/**\n+ * hb_draw_funcs_get_user_data: (skip)\n+ * @dfuncs: The draw-functions structure\n+ * @key: The user-data key to query\n+ *\n+ * Fetches the user-data associated with the specified key,\n+ * attached to the specified draw-functions structure.\n+ *\n+ * Return value: (transfer none): A pointer to the user data\n+ *\n+ * Since: 7.0.0\n+ **\/\n+void *\n+hb_draw_funcs_get_user_data (const hb_draw_funcs_t *dfuncs,\n+                             hb_user_data_key_t       *key)\n+{\n+  return hb_object_get_user_data (dfuncs, key);\n+}\n+\n@@ -237,1 +333,1 @@\n- * Return value: %true if @dfuncs is immutable, %false otherwise\n+ * Return value: `true` if @dfuncs is immutable, `false` otherwise\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-draw.cc","additions":129,"deletions":33,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n- * @draw_data: The data accompanying the draw functions\n+ * @draw_data: The data accompanying the draw functions in hb_font_draw_glyph()\n@@ -99,1 +99,1 @@\n- * @user_data: User data pointer passed by the caller\n+ * @user_data: User data pointer passed to hb_draw_funcs_set_move_to_func()\n@@ -115,1 +115,1 @@\n- * @draw_data: The data accompanying the draw functions\n+ * @draw_data: The data accompanying the draw functions in hb_font_draw_glyph()\n@@ -119,1 +119,1 @@\n- * @user_data: User data pointer passed by the caller\n+ * @user_data: User data pointer passed to hb_draw_funcs_set_line_to_func()\n@@ -135,1 +135,1 @@\n- * @draw_data: The data accompanying the draw functions\n+ * @draw_data: The data accompanying the draw functions in hb_font_draw_glyph()\n@@ -141,1 +141,1 @@\n- * @user_data: User data pointer passed by the caller\n+ * @user_data: User data pointer passed to hb_draw_funcs_set_quadratic_to_func()\n@@ -158,1 +158,1 @@\n- * @draw_data: The data accompanying the draw functions\n+ * @draw_data: The data accompanying the draw functions in hb_font_draw_glyph()\n@@ -166,1 +166,1 @@\n- * @user_data: User data pointer passed by the caller\n+ * @user_data: User data pointer passed to hb_draw_funcs_set_cubic_to_func()\n@@ -184,1 +184,1 @@\n- * @draw_data: The data accompanying the draw functions\n+ * @draw_data: The data accompanying the draw functions in hb_font_draw_glyph()\n@@ -186,1 +186,1 @@\n- * @user_data: User data pointer passed by the caller\n+ * @user_data: User data pointer passed to hb_draw_funcs_set_close_path_func()\n@@ -282,0 +282,3 @@\n+HB_EXTERN hb_draw_funcs_t *\n+hb_draw_funcs_get_empty (void);\n+\n@@ -288,0 +291,12 @@\n+HB_EXTERN hb_bool_t\n+hb_draw_funcs_set_user_data (hb_draw_funcs_t *dfuncs,\n+                             hb_user_data_key_t *key,\n+                             void *              data,\n+                             hb_destroy_func_t   destroy,\n+                             hb_bool_t           replace);\n+\n+\n+HB_EXTERN void *\n+hb_draw_funcs_get_user_data (const hb_draw_funcs_t *dfuncs,\n+                             hb_user_data_key_t       *key);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-draw.h","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-face.hh\"\n+\n+#include \"hb-map.hh\"\n+#include \"hb-open-file.hh\"\n+#include \"hb-serialize.hh\"\n+\n+\n+\/*\n+ * face-builder: A face that has add_table().\n+ *\/\n+\n+struct face_table_info_t\n+{\n+  hb_blob_t* data;\n+  signed order;\n+};\n+\n+struct hb_face_builder_data_t\n+{\n+  hb_hashmap_t<hb_tag_t, face_table_info_t> tables;\n+};\n+\n+static int compare_entries (const void* pa, const void* pb)\n+{\n+  const auto& a = * (const hb_pair_t<hb_tag_t, face_table_info_t> *) pa;\n+  const auto& b = * (const hb_pair_t<hb_tag_t, face_table_info_t> *) pb;\n+\n+  \/* Order by blob size first (smallest to largest) and then table tag *\/\n+\n+  if (a.second.order != b.second.order)\n+    return a.second.order < b.second.order ? -1 : +1;\n+\n+  if (a.second.data->length != b.second.data->length)\n+    return a.second.data->length < b.second.data->length ? -1 : +1;\n+\n+  return a.first < b.first ? -1 : a.first == b.first ? 0 : +1;\n+}\n+\n+static hb_face_builder_data_t *\n+_hb_face_builder_data_create ()\n+{\n+  hb_face_builder_data_t *data = (hb_face_builder_data_t *) hb_calloc (1, sizeof (hb_face_builder_data_t));\n+  if (unlikely (!data))\n+    return nullptr;\n+\n+  data->tables.init ();\n+\n+  return data;\n+}\n+\n+static void\n+_hb_face_builder_data_destroy (void *user_data)\n+{\n+  hb_face_builder_data_t *data = (hb_face_builder_data_t *) user_data;\n+\n+  for (auto info : data->tables.values())\n+    hb_blob_destroy (info.data);\n+\n+  data->tables.fini ();\n+\n+  hb_free (data);\n+}\n+\n+static hb_blob_t *\n+_hb_face_builder_data_reference_blob (hb_face_builder_data_t *data)\n+{\n+\n+  unsigned int table_count = data->tables.get_population ();\n+  unsigned int face_length = table_count * 16 + 12;\n+\n+  for (auto info : data->tables.values())\n+    face_length += hb_ceil_to_4 (hb_blob_get_length (info.data));\n+\n+  char *buf = (char *) hb_malloc (face_length);\n+  if (unlikely (!buf))\n+    return nullptr;\n+\n+  hb_serialize_context_t c (buf, face_length);\n+  c.propagate_error (data->tables);\n+  OT::OpenTypeFontFile *f = c.start_serialize<OT::OpenTypeFontFile> ();\n+\n+  bool is_cff = (data->tables.has (HB_TAG ('C','F','F',' '))\n+                 || data->tables.has (HB_TAG ('C','F','F','2')));\n+  hb_tag_t sfnt_tag = is_cff ? OT::OpenTypeFontFile::CFFTag : OT::OpenTypeFontFile::TrueTypeTag;\n+\n+  \/\/ Sort the tags so that produced face is deterministic.\n+  hb_vector_t<hb_pair_t <hb_tag_t, face_table_info_t>> sorted_entries;\n+  data->tables.iter () | hb_sink (sorted_entries);\n+  if (unlikely (sorted_entries.in_error ()))\n+  {\n+    hb_free (buf);\n+    return nullptr;\n+  }\n+\n+  sorted_entries.qsort (compare_entries);\n+\n+  bool ret = f->serialize_single (&c,\n+                                  sfnt_tag,\n+                                  + sorted_entries.iter()\n+                                  | hb_map ([&] (hb_pair_t<hb_tag_t, face_table_info_t> _) {\n+                                    return hb_pair_t<hb_tag_t, hb_blob_t*> (_.first, _.second.data);\n+                                  }));\n+\n+  c.end_serialize ();\n+\n+  if (unlikely (!ret))\n+  {\n+    hb_free (buf);\n+    return nullptr;\n+  }\n+\n+  return hb_blob_create (buf, face_length, HB_MEMORY_MODE_WRITABLE, buf, hb_free);\n+}\n+\n+static hb_blob_t *\n+_hb_face_builder_reference_table (hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data)\n+{\n+  hb_face_builder_data_t *data = (hb_face_builder_data_t *) user_data;\n+\n+  if (!tag)\n+    return _hb_face_builder_data_reference_blob (data);\n+\n+  return hb_blob_reference (data->tables[tag].data);\n+}\n+\n+\n+\/**\n+ * hb_face_builder_create:\n+ *\n+ * Creates a #hb_face_t that can be used with hb_face_builder_add_table().\n+ * After tables are added to the face, it can be compiled to a binary\n+ * font file by calling hb_face_reference_blob().\n+ *\n+ * Return value: (transfer full): New face.\n+ *\n+ * Since: 1.9.0\n+ **\/\n+hb_face_t *\n+hb_face_builder_create ()\n+{\n+  hb_face_builder_data_t *data = _hb_face_builder_data_create ();\n+  if (unlikely (!data)) return hb_face_get_empty ();\n+\n+  return hb_face_create_for_tables (_hb_face_builder_reference_table,\n+                                    data,\n+                                    _hb_face_builder_data_destroy);\n+}\n+\n+\/**\n+ * hb_face_builder_add_table:\n+ * @face: A face object created with hb_face_builder_create()\n+ * @tag: The #hb_tag_t of the table to add\n+ * @blob: The blob containing the table data to add\n+ *\n+ * Add table for @tag with data provided by @blob to the face.  @face must\n+ * be created using hb_face_builder_create().\n+ *\n+ * Since: 1.9.0\n+ **\/\n+hb_bool_t\n+hb_face_builder_add_table (hb_face_t *face, hb_tag_t tag, hb_blob_t *blob)\n+{\n+  if (unlikely (face->destroy != (hb_destroy_func_t) _hb_face_builder_data_destroy))\n+    return false;\n+\n+  if (tag == HB_MAP_VALUE_INVALID)\n+    return false;\n+\n+  hb_face_builder_data_t *data = (hb_face_builder_data_t *) face->user_data;\n+\n+  hb_blob_t* previous = data->tables.get (tag).data;\n+  if (!data->tables.set (tag, face_table_info_t {hb_blob_reference (blob), -1}))\n+  {\n+    hb_blob_destroy (blob);\n+    return false;\n+  }\n+\n+  hb_blob_destroy (previous);\n+  return true;\n+}\n+\n+\/**\n+ * hb_face_builder_sort_tables:\n+ * @face: A face object created with hb_face_builder_create()\n+ * @tags: (array zero-terminated=1): ordered list of table tags terminated by\n+ *   %HB_TAG_NONE\n+ *\n+ * Set the ordering of tables for serialization. Any tables not\n+ * specified in the tags list will be ordered after the tables in\n+ * tags, ordered by the default sort ordering.\n+ *\n+ * Since: 5.3.0\n+ **\/\n+void\n+hb_face_builder_sort_tables (hb_face_t *face,\n+                             const hb_tag_t  *tags)\n+{\n+  if (unlikely (face->destroy != (hb_destroy_func_t) _hb_face_builder_data_destroy))\n+    return;\n+\n+  hb_face_builder_data_t *data = (hb_face_builder_data_t *) face->user_data;\n+\n+  \/\/ Sort all unspecified tables after any specified tables.\n+  for (auto& info : data->tables.values_ref())\n+    info.order = (unsigned) -1;\n+\n+  signed order = 0;\n+  for (const hb_tag_t* tag = tags;\n+       *tag;\n+       tag++)\n+  {\n+    face_table_info_t* info;\n+    if (!data->tables.has (*tag, &info)) continue;\n+    info->order = order++;\n+  }\n+}\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-face-builder.cc","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"hb-map.hh\"\n@@ -135,1 +134,1 @@\n-  face->num_glyphs.set_relaxed (-1);\n+  face->num_glyphs = -1;\n@@ -291,0 +290,1 @@\n+#ifndef HB_NO_SHAPER\n@@ -298,0 +298,1 @@\n+#endif\n@@ -318,1 +319,1 @@\n- * Return value: %true if success, %false otherwise\n+ * Return value: `true` if success, `false` otherwise\n@@ -345,1 +346,1 @@\n-hb_face_get_user_data (hb_face_t          *face,\n+hb_face_get_user_data (const hb_face_t    *face,\n@@ -374,1 +375,1 @@\n- * Return value: %true is @face is immutable, %false otherwise\n+ * Return value: `true` is @face is immutable, `false` otherwise\n@@ -473,0 +474,2 @@\n+ * This API is used in rare circumstances.\n+ *\n@@ -482,1 +485,1 @@\n-  face->upem.set_relaxed (upem);\n+  face->upem = upem;\n@@ -489,1 +492,4 @@\n- * Fetches the units-per-em (upem) value of the specified face object.\n+ * Fetches the units-per-em (UPEM) value of the specified face object.\n+ *\n+ * Typical UPEM values for fonts are 1000, or 2048, but any value\n+ * in between 16 and 16,384 is allowed for OpenType fonts.\n@@ -508,0 +514,2 @@\n+ * This API is used in rare circumstances.\n+ *\n@@ -517,1 +525,1 @@\n-  face->num_glyphs.set_relaxed (glyph_count);\n+  face->num_glyphs = glyph_count;\n@@ -582,1 +590,1 @@\n- * @out: The set to add Unicode characters to\n+ * @out: (out): The set to add Unicode characters to\n@@ -595,0 +603,21 @@\n+\/**\n+ * hb_face_collect_nominal_glyph_mapping:\n+ * @face: A face object\n+ * @mapping: (out): The map to add Unicode-to-glyph mapping to\n+ * @unicodes: (nullable) (out): The set to add Unicode characters to, or `NULL`\n+ *\n+ * Collects the mapping from Unicode characters to nominal glyphs of the @face,\n+ * and optionally all of the Unicode characters covered by @face.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+void\n+hb_face_collect_nominal_glyph_mapping (hb_face_t *face,\n+                                       hb_map_t  *mapping,\n+                                       hb_set_t  *unicodes)\n+{\n+  hb_set_t stack_unicodes;\n+  if (!unicodes)\n+    unicodes = &stack_unicodes;\n+  face->table.cmap->collect_mapping (unicodes, mapping, face->get_num_glyphs ());\n+}\n@@ -598,1 +627,1 @@\n- * @out: The set to add Variation Selector characters to\n+ * @out: (out): The set to add Variation Selector characters to\n@@ -615,1 +644,1 @@\n- * @out: The set to add Unicode characters to\n+ * @out: (out): The set to add Unicode characters to\n@@ -630,160 +659,0 @@\n-\n-\n-\/*\n- * face-builder: A face that has add_table().\n- *\/\n-\n-struct hb_face_builder_data_t\n-{\n-  hb_hashmap_t<hb_tag_t, hb_blob_t *> tables;\n-};\n-\n-static int compare_entries (const void* pa, const void* pb)\n-{\n-  const auto& a = * (const hb_pair_t<hb_tag_t, hb_blob_t*> *) pa;\n-  const auto& b = * (const hb_pair_t<hb_tag_t, hb_blob_t*> *) pb;\n-\n-  \/* Order by blob size first (smallest to largest) and then table tag *\/\n-\n-  if (a.second->length != b.second->length)\n-    return a.second->length < b.second->length ? -1 : +1;\n-\n-  return a.first < b.first ? -1 : a.first == b.first ? 0 : +1;\n-}\n-\n-static hb_face_builder_data_t *\n-_hb_face_builder_data_create ()\n-{\n-  hb_face_builder_data_t *data = (hb_face_builder_data_t *) hb_calloc (1, sizeof (hb_face_builder_data_t));\n-  if (unlikely (!data))\n-    return nullptr;\n-\n-  data->tables.init ();\n-\n-  return data;\n-}\n-\n-static void\n-_hb_face_builder_data_destroy (void *user_data)\n-{\n-  hb_face_builder_data_t *data = (hb_face_builder_data_t *) user_data;\n-\n-  for (hb_blob_t* b : data->tables.values())\n-    hb_blob_destroy (b);\n-\n-  data->tables.fini ();\n-\n-  hb_free (data);\n-}\n-\n-static hb_blob_t *\n-_hb_face_builder_data_reference_blob (hb_face_builder_data_t *data)\n-{\n-\n-  unsigned int table_count = data->tables.get_population ();\n-  unsigned int face_length = table_count * 16 + 12;\n-\n-  for (hb_blob_t* b : data->tables.values())\n-    face_length += hb_ceil_to_4 (hb_blob_get_length (b));\n-\n-  char *buf = (char *) hb_malloc (face_length);\n-  if (unlikely (!buf))\n-    return nullptr;\n-\n-  hb_serialize_context_t c (buf, face_length);\n-  c.propagate_error (data->tables);\n-  OT::OpenTypeFontFile *f = c.start_serialize<OT::OpenTypeFontFile> ();\n-\n-  bool is_cff = (data->tables.has (HB_TAG ('C','F','F',' '))\n-                 || data->tables.has (HB_TAG ('C','F','F','2')));\n-  hb_tag_t sfnt_tag = is_cff ? OT::OpenTypeFontFile::CFFTag : OT::OpenTypeFontFile::TrueTypeTag;\n-\n-  \/\/ Sort the tags so that produced face is deterministic.\n-  hb_vector_t<hb_pair_t <hb_tag_t, hb_blob_t*>> sorted_entries;\n-  data->tables.iter () | hb_sink (sorted_entries);\n-  if (unlikely (sorted_entries.in_error ()))\n-  {\n-    hb_free (buf);\n-    return nullptr;\n-  }\n-\n-  sorted_entries.qsort (compare_entries);\n-  bool ret = f->serialize_single (&c, sfnt_tag, + sorted_entries.iter());\n-\n-  c.end_serialize ();\n-\n-  if (unlikely (!ret))\n-  {\n-    hb_free (buf);\n-    return nullptr;\n-  }\n-\n-  return hb_blob_create (buf, face_length, HB_MEMORY_MODE_WRITABLE, buf, hb_free);\n-}\n-\n-static hb_blob_t *\n-_hb_face_builder_reference_table (hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data)\n-{\n-  hb_face_builder_data_t *data = (hb_face_builder_data_t *) user_data;\n-\n-  if (!tag)\n-    return _hb_face_builder_data_reference_blob (data);\n-\n-  return hb_blob_reference (data->tables[tag]);\n-}\n-\n-\n-\/**\n- * hb_face_builder_create:\n- *\n- * Creates a #hb_face_t that can be used with hb_face_builder_add_table().\n- * After tables are added to the face, it can be compiled to a binary\n- * font file by calling hb_face_reference_blob().\n- *\n- * Return value: (transfer full): New face.\n- *\n- * Since: 1.9.0\n- **\/\n-hb_face_t *\n-hb_face_builder_create ()\n-{\n-  hb_face_builder_data_t *data = _hb_face_builder_data_create ();\n-  if (unlikely (!data)) return hb_face_get_empty ();\n-\n-  return hb_face_create_for_tables (_hb_face_builder_reference_table,\n-                                    data,\n-                                    _hb_face_builder_data_destroy);\n-}\n-\n-\/**\n- * hb_face_builder_add_table:\n- * @face: A face object created with hb_face_builder_create()\n- * @tag: The #hb_tag_t of the table to add\n- * @blob: The blob containing the table data to add\n- *\n- * Add table for @tag with data provided by @blob to the face.  @face must\n- * be created using hb_face_builder_create().\n- *\n- * Since: 1.9.0\n- **\/\n-hb_bool_t\n-hb_face_builder_add_table (hb_face_t *face, hb_tag_t tag, hb_blob_t *blob)\n-{\n-  if (tag == HB_MAP_VALUE_INVALID)\n-    return false;\n-\n-  if (unlikely (face->destroy != (hb_destroy_func_t) _hb_face_builder_data_destroy))\n-    return false;\n-\n-  hb_face_builder_data_t *data = (hb_face_builder_data_t *) face->user_data;\n-\n-  hb_blob_t* previous = data->tables.get (tag);\n-  if (!data->tables.set (tag, hb_blob_reference (blob)))\n-  {\n-    hb_blob_destroy (blob);\n-    return false;\n-  }\n-\n-  hb_blob_destroy (previous);\n-  return true;\n-}\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-face.cc","additions":40,"deletions":171,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"hb-map.h\"\n@@ -99,1 +100,1 @@\n-hb_face_get_user_data (hb_face_t          *face,\n+hb_face_get_user_data (const hb_face_t    *face,\n@@ -152,0 +153,5 @@\n+HB_EXTERN void\n+hb_face_collect_nominal_glyph_mapping (hb_face_t *face,\n+                                       hb_map_t  *mapping,\n+                                       hb_set_t  *unicodes);\n+\n@@ -174,0 +180,4 @@\n+HB_EXTERN void\n+hb_face_builder_sort_tables (hb_face_t *face,\n+                             const hb_tag_t  *tags);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-face.h","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#ifndef HB_NO_SHAPER\n@@ -69,0 +70,1 @@\n+#endif\n@@ -86,1 +88,1 @@\n-    unsigned int ret = upem.get_relaxed ();\n+    unsigned int ret = upem;\n@@ -96,1 +98,1 @@\n-    unsigned int ret = num_glyphs.get_relaxed ();\n+    unsigned int ret = num_glyphs;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-face.hh","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -78,10 +78,0 @@\n-  \/* TODO\n-   *\n-   * - Apply fallback kern.\n-   * - Handle Variation Selectors?\n-   * - Apply normalization?\n-   *\n-   * This will make the fallback shaper into a dumb \"TrueType\"\n-   * shaper which many people unfortunately still request.\n-   *\/\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-fallback-shape.cc","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"hb-paint.hh\"\n@@ -74,1 +75,1 @@\n-  memset (extents, 0, sizeof (*extents));\n+  hb_memset (extents, 0, sizeof (*extents));\n@@ -99,1 +100,1 @@\n-  memset (extents, 0, sizeof (*extents));\n+  hb_memset (extents, 0, sizeof (*extents));\n@@ -412,1 +413,1 @@\n-  memset (extents, 0, sizeof (*extents));\n+  hb_memset (extents, 0, sizeof (*extents));\n@@ -506,6 +507,6 @@\n-hb_font_get_glyph_shape_nil (hb_font_t       *font HB_UNUSED,\n-                             void            *font_data HB_UNUSED,\n-                             hb_codepoint_t   glyph,\n-                             hb_draw_funcs_t *draw_funcs,\n-                             void            *draw_data,\n-                             void            *user_data HB_UNUSED)\n+hb_font_draw_glyph_nil (hb_font_t       *font HB_UNUSED,\n+                        void            *font_data HB_UNUSED,\n+                        hb_codepoint_t   glyph,\n+                        hb_draw_funcs_t *draw_funcs,\n+                        void            *draw_data,\n+                        void            *user_data HB_UNUSED)\n@@ -515,0 +516,11 @@\n+static void\n+hb_font_paint_glyph_nil (hb_font_t *font HB_UNUSED,\n+                         void *font_data HB_UNUSED,\n+                         hb_codepoint_t glyph HB_UNUSED,\n+                         hb_paint_funcs_t *paint_funcs HB_UNUSED,\n+                         void *paint_data HB_UNUSED,\n+                         unsigned int palette HB_UNUSED,\n+                         hb_color_t foreground HB_UNUSED,\n+                         void *user_data HB_UNUSED)\n+{\n+}\n@@ -516,1 +528,1 @@\n-typedef struct hb_font_get_glyph_shape_default_adaptor_t {\n+typedef struct hb_font_draw_glyph_default_adaptor_t {\n@@ -521,1 +533,2 @@\n-} hb_font_get_glyph_shape_default_adaptor_t;\n+  float            slant;\n+} hb_font_draw_glyph_default_adaptor_t;\n@@ -530,1 +543,1 @@\n-  hb_font_get_glyph_shape_default_adaptor_t *adaptor = (hb_font_get_glyph_shape_default_adaptor_t *) draw_data;\n+  hb_font_draw_glyph_default_adaptor_t *adaptor = (hb_font_draw_glyph_default_adaptor_t *) draw_data;\n@@ -533,0 +546,1 @@\n+  float slant   = adaptor->slant;\n@@ -535,1 +549,1 @@\n-                                     x_scale * to_x, y_scale * to_y);\n+                                     x_scale * to_x + slant * to_y, y_scale * to_y);\n@@ -544,1 +558,1 @@\n-  hb_font_get_glyph_shape_default_adaptor_t *adaptor = (hb_font_get_glyph_shape_default_adaptor_t *) draw_data;\n+  hb_font_draw_glyph_default_adaptor_t *adaptor = (hb_font_draw_glyph_default_adaptor_t *) draw_data;\n@@ -547,0 +561,1 @@\n+  float slant   = adaptor->slant;\n@@ -548,2 +563,2 @@\n-  st->current_x *= x_scale;\n-  st->current_y *= y_scale;\n+  st->current_x = st->current_x * x_scale + st->current_y * slant;\n+  st->current_y = st->current_y * y_scale;\n@@ -552,1 +567,1 @@\n-                                     x_scale * to_x, y_scale * to_y);\n+                                     x_scale * to_x + slant * to_y, y_scale * to_y);\n@@ -562,1 +577,1 @@\n-  hb_font_get_glyph_shape_default_adaptor_t *adaptor = (hb_font_get_glyph_shape_default_adaptor_t *) draw_data;\n+  hb_font_draw_glyph_default_adaptor_t *adaptor = (hb_font_draw_glyph_default_adaptor_t *) draw_data;\n@@ -565,0 +580,1 @@\n+  float slant   = adaptor->slant;\n@@ -566,2 +582,2 @@\n-  st->current_x *= x_scale;\n-  st->current_y *= y_scale;\n+  st->current_x = st->current_x * x_scale + st->current_y * slant;\n+  st->current_y = st->current_y * y_scale;\n@@ -570,2 +586,2 @@\n-                                          x_scale * control_x, y_scale * control_y,\n-                                          x_scale * to_x, y_scale * to_y);\n+                                          x_scale * control_x + slant * control_y, y_scale * control_y,\n+                                          x_scale * to_x + slant * to_y, y_scale * to_y);\n@@ -582,1 +598,1 @@\n-  hb_font_get_glyph_shape_default_adaptor_t *adaptor = (hb_font_get_glyph_shape_default_adaptor_t *) draw_data;\n+  hb_font_draw_glyph_default_adaptor_t *adaptor = (hb_font_draw_glyph_default_adaptor_t *) draw_data;\n@@ -585,0 +601,1 @@\n+  float slant   = adaptor->slant;\n@@ -586,2 +603,2 @@\n-  st->current_x *= x_scale;\n-  st->current_y *= y_scale;\n+  st->current_x = st->current_x * x_scale + st->current_y * slant;\n+  st->current_y = st->current_y * y_scale;\n@@ -590,3 +607,3 @@\n-                                      x_scale * control1_x, y_scale * control1_y,\n-                                      x_scale * control2_x, y_scale * control2_y,\n-                                      x_scale * to_x, y_scale * to_y);\n+                                      x_scale * control1_x + slant * control1_y, y_scale * control1_y,\n+                                      x_scale * control2_x + slant * control2_y, y_scale * control2_y,\n+                                      x_scale * to_x + slant * to_y, y_scale * to_y);\n@@ -600,1 +617,1 @@\n-  hb_font_get_glyph_shape_default_adaptor_t *adaptor = (hb_font_get_glyph_shape_default_adaptor_t *) draw_data;\n+  hb_font_draw_glyph_default_adaptor_t *adaptor = (hb_font_draw_glyph_default_adaptor_t *) draw_data;\n@@ -616,1 +633,1 @@\n-hb_font_get_glyph_shape_default (hb_font_t       *font,\n+hb_font_draw_glyph_default (hb_font_t       *font,\n@@ -623,1 +640,1 @@\n-  hb_font_get_glyph_shape_default_adaptor_t adaptor = {\n+  hb_font_draw_glyph_default_adaptor_t adaptor = {\n@@ -626,2 +643,4 @@\n-    (float) font->x_scale \/ (float) font->parent->x_scale,\n-    (float) font->y_scale \/ (float) font->parent->y_scale\n+    font->parent->x_scale ? (float) font->x_scale \/ (float) font->parent->x_scale : 0.f,\n+    font->parent->y_scale ? (float) font->y_scale \/ (float) font->parent->y_scale : 0.f,\n+    font->parent->y_scale ? (font->slant - font->parent->slant) *\n+                            (float) font->x_scale \/ (float) font->parent->y_scale : 0.f\n@@ -630,1 +649,1 @@\n-  font->parent->get_glyph_shape (glyph,\n+  font->parent->draw_glyph (glyph,\n@@ -635,0 +654,23 @@\n+static void\n+hb_font_paint_glyph_default (hb_font_t *font,\n+                             void *font_data,\n+                             hb_codepoint_t glyph,\n+                             hb_paint_funcs_t *paint_funcs,\n+                             void *paint_data,\n+                             unsigned int palette,\n+                             hb_color_t foreground,\n+                             void *user_data)\n+{\n+  paint_funcs->push_transform (paint_data,\n+    font->parent->x_scale ? (float) font->x_scale \/ (float) font->parent->x_scale : 0.f,\n+    font->parent->y_scale ? (font->slant - font->parent->slant) *\n+                            (float) font->x_scale \/ (float) font->parent->y_scale : 0.f,\n+    0.f,\n+    font->parent->y_scale ? (float) font->y_scale \/ (float) font->parent->y_scale : 0.f,\n+    0.f, 0.f);\n+\n+  font->parent->paint_glyph (glyph, paint_funcs, paint_data, palette, foreground);\n+\n+  paint_funcs->pop_transform (paint_data);\n+}\n+\n@@ -643,1 +685,1 @@\n-#define HB_FONT_FUNC_IMPLEMENT(name) hb_font_get_##name##_nil,\n+#define HB_FONT_FUNC_IMPLEMENT(get_,name) hb_font_##get_##name##_nil,\n@@ -657,1 +699,1 @@\n-#define HB_FONT_FUNC_IMPLEMENT(name) hb_font_get_##name##_default,\n+#define HB_FONT_FUNC_IMPLEMENT(get_,name) hb_font_##get_##name##_default,\n@@ -735,1 +777,1 @@\n-#define HB_FONT_FUNC_IMPLEMENT(name) if (ffuncs->destroy->name) \\\n+#define HB_FONT_FUNC_IMPLEMENT(get_,name) if (ffuncs->destroy->name) \\\n@@ -757,1 +799,1 @@\n- * Return value: %true if success, %false otherwise\n+ * Return value: `true` if success, `false` otherwise\n@@ -784,2 +826,2 @@\n-hb_font_funcs_get_user_data (hb_font_funcs_t    *ffuncs,\n-                             hb_user_data_key_t *key)\n+hb_font_funcs_get_user_data (const hb_font_funcs_t *ffuncs,\n+                             hb_user_data_key_t    *key)\n@@ -814,1 +856,1 @@\n- * Return value: %true if @ffuncs is immutable, %false otherwise\n+ * Return value: `true` if @ffuncs is immutable, `false` otherwise\n@@ -825,1 +867,51 @@\n-#define HB_FONT_FUNC_IMPLEMENT(name) \\\n+static bool\n+_hb_font_funcs_set_preamble (hb_font_funcs_t    *ffuncs,\n+                             bool                func_is_null,\n+                             void              **user_data,\n+                             hb_destroy_func_t  *destroy)\n+{\n+  if (hb_object_is_immutable (ffuncs))\n+  {\n+    if (*destroy)\n+      (*destroy) (*user_data);\n+    return false;\n+  }\n+\n+  if (func_is_null)\n+  {\n+    if (*destroy)\n+      (*destroy) (*user_data);\n+    *destroy = nullptr;\n+    *user_data = nullptr;\n+  }\n+\n+  return true;\n+}\n+\n+static bool\n+_hb_font_funcs_set_middle (hb_font_funcs_t   *ffuncs,\n+                           void              *user_data,\n+                           hb_destroy_func_t  destroy)\n+{\n+  if (user_data && !ffuncs->user_data)\n+  {\n+    ffuncs->user_data = (decltype (ffuncs->user_data)) hb_calloc (1, sizeof (*ffuncs->user_data));\n+    if (unlikely (!ffuncs->user_data))\n+      goto fail;\n+  }\n+  if (destroy && !ffuncs->destroy)\n+  {\n+    ffuncs->destroy = (decltype (ffuncs->destroy)) hb_calloc (1, sizeof (*ffuncs->destroy));\n+    if (unlikely (!ffuncs->destroy))\n+      goto fail;\n+  }\n+\n+  return true;\n+\n+fail:\n+  if (destroy)\n+    (destroy) (user_data);\n+  return false;\n+}\n+\n+#define HB_FONT_FUNC_IMPLEMENT(get_,name) \\\n@@ -829,1 +921,1 @@\n-                                 hb_font_get_##name##_func_t  func,      \\\n+                                 hb_font_##get_##name##_func_t func,     \\\n@@ -833,10 +925,2 @@\n-  if (hb_object_is_immutable (ffuncs))                                   \\\n-    goto fail;                                                           \\\n-                                                                         \\\n-  if (!func)                                                             \\\n-  {                                                                      \\\n-    if (destroy)                                                         \\\n-      destroy (user_data);                                               \\\n-    destroy = nullptr;                                                   \\\n-    user_data = nullptr;                                                 \\\n-  }                                                                      \\\n+  if (!_hb_font_funcs_set_preamble (ffuncs, !func, &user_data, &destroy))\\\n+      return;                                                            \\\n@@ -847,12 +931,2 @@\n-  if (user_data && !ffuncs->user_data)                                   \\\n-  {                                                                      \\\n-    ffuncs->user_data = (decltype (ffuncs->user_data)) hb_calloc (1, sizeof (*ffuncs->user_data)); \\\n-    if (unlikely (!ffuncs->user_data))                                   \\\n-      goto fail;                                                         \\\n-  }                                                                      \\\n-  if (destroy && !ffuncs->destroy)                                       \\\n-  {                                                                      \\\n-    ffuncs->destroy = (decltype (ffuncs->destroy)) hb_calloc (1, sizeof (*ffuncs->destroy)); \\\n-    if (unlikely (!ffuncs->destroy))                                     \\\n-      goto fail;                                                         \\\n-  }                                                                      \\\n+  if (!_hb_font_funcs_set_middle (ffuncs, user_data, destroy))           \\\n+      return;                                                            \\\n@@ -860,1 +934,1 @@\n-  if (func) {                                                            \\\n+  if (func)                                                              \\\n@@ -862,12 +936,2 @@\n-    if (ffuncs->user_data)                                               \\\n-      ffuncs->user_data->name = user_data;                               \\\n-    if (ffuncs->destroy)                                                 \\\n-      ffuncs->destroy->name = destroy;                                   \\\n-  } else {                                                               \\\n-    ffuncs->get.f.name = hb_font_get_##name##_default;                   \\\n-    if (ffuncs->user_data)                                               \\\n-      ffuncs->user_data->name = nullptr;                                 \\\n-    if (ffuncs->destroy)                                                 \\\n-      ffuncs->destroy->name = nullptr;                                   \\\n-  }                                                                      \\\n-  return;                                                                \\\n+  else                                                                   \\\n+    ffuncs->get.f.name = hb_font_##get_##name##_default;                   \\\n@@ -875,3 +939,4 @@\n-fail:                                                                    \\\n-  if (destroy)                                                           \\\n-    destroy (user_data);                                                 \\\n+  if (ffuncs->user_data)                                                 \\\n+    ffuncs->user_data->name = user_data;                                 \\\n+  if (ffuncs->destroy)                                                   \\\n+    ffuncs->destroy->name = destroy;                                     \\\n@@ -906,1 +971,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -925,1 +990,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -949,1 +1014,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -977,1 +1042,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -999,1 +1064,2 @@\n- * IDs must be returned in a #hb_codepoint_t output parameter.\n+ * IDs must be returned in a #hb_codepoint_t output parameter. Stopes at the\n+ * first unsupported glyph ID.\n@@ -1029,1 +1095,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -1139,1 +1205,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -1162,1 +1228,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -1235,1 +1301,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -1258,1 +1324,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -1281,1 +1347,4 @@\n- * Return value: %true if data found, %false otherwise\n+ * According to the OpenType specification, glyph names are limited to 63\n+ * characters and can only contain (a subset of) ASCII.\n+ *\n+ * Return value: `true` if data found, `false` otherwise\n@@ -1305,1 +1374,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -1326,1 +1395,1 @@\n- * The shape is returned by way of calls to the callsbacks of the @dfuncs\n+ * The shape is returned by way of calls to the callbacks of the @dfuncs\n@@ -1330,1 +1399,2 @@\n- **\/\n+ * Deprecated: 7.0.0: Use hb_font_draw_glyph() instead\n+ *\/\n@@ -1336,1 +1406,54 @@\n-  font->get_glyph_shape (glyph, dfuncs, draw_data);\n+  hb_font_draw_glyph (font, glyph, dfuncs, draw_data);\n+}\n+\n+\/**\n+ * hb_font_draw_glyph:\n+ * @font: #hb_font_t to work upon\n+ * @glyph: : The glyph ID\n+ * @dfuncs: #hb_draw_funcs_t to draw to\n+ * @draw_data: User data to pass to draw callbacks\n+ *\n+ * Draws the outline that corresponds to a glyph in the specified @font.\n+ *\n+ * The outline is returned by way of calls to the callbacks of the @dfuncs\n+ * objects, with @draw_data passed to them.\n+ *\n+ * Since: 7.0.0\n+ **\/\n+void\n+hb_font_draw_glyph (hb_font_t *font,\n+                         hb_codepoint_t glyph,\n+                         hb_draw_funcs_t *dfuncs, void *draw_data)\n+{\n+  font->draw_glyph (glyph, dfuncs, draw_data);\n+}\n+\n+\/**\n+ * hb_font_paint_glyph:\n+ * @font: #hb_font_t to work upon\n+ * @glyph: The glyph ID\n+ * @pfuncs: #hb_paint_funcs_t to paint with\n+ * @paint_data: User data to pass to paint callbacks\n+ * @palette_index: The index of the font's color palette to use\n+ * @foreground: The foreground color, unpremultipled\n+ *\n+ * Paints the glyph.\n+ *\n+ * The painting instructions are returned by way of calls to\n+ * the callbacks of the @funcs object, with @paint_data passed\n+ * to them.\n+ *\n+ * If the font has color palettes (see hb_ot_color_has_palettes()),\n+ * then @palette_index selects the palette to use. If the font only\n+ * has one palette, this will be 0.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+void\n+hb_font_paint_glyph (hb_font_t *font,\n+                     hb_codepoint_t glyph,\n+                     hb_paint_funcs_t *pfuncs, void *paint_data,\n+                     unsigned int palette_index,\n+                     hb_color_t foreground)\n+{\n+  font->paint_glyph (glyph, pfuncs, paint_data, palette_index, foreground);\n@@ -1540,1 +1663,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -1569,1 +1692,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -1597,0 +1720,3 @@\n+ * According to the OpenType specification, glyph names are limited to 63\n+ * characters and can only contain (a subset of) ASCII.\n+ *\n@@ -1620,1 +1746,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -1650,2 +1776,7 @@\n-  0., \/* slant *\/\n-  0., \/* slant_xy; *\/\n+  0.f, \/* x_embolden *\/\n+  0.f, \/* y_embolden *\/\n+  true, \/* embolden_in_place *\/\n+  0, \/* x_strength *\/\n+  0, \/* y_strength *\/\n+  0.f, \/* slant *\/\n+  0.f, \/* slant_xy; *\/\n@@ -1661,0 +1792,1 @@\n+  HB_FONT_NO_VAR_NAMED_INSTANCE, \/* instance_index *\/\n@@ -1678,0 +1810,1 @@\n+\n@@ -1687,0 +1820,1 @@\n+  font->embolden_in_place = true;\n@@ -1689,0 +1823,1 @@\n+  font->instance_index = HB_FONT_NO_VAR_NAMED_INSTANCE;\n@@ -1770,0 +1905,3 @@\n+  font->x_embolden = parent->x_embolden;\n+  font->y_embolden = parent->y_embolden;\n+  font->embolden_in_place = parent->embolden_in_place;\n@@ -1782,2 +1920,2 @@\n-      memcpy (coords, parent->coords, num_coords * sizeof (parent->coords[0]));\n-      memcpy (design_coords, parent->design_coords, num_coords * sizeof (parent->design_coords[0]));\n+      hb_memcpy (coords, parent->coords, num_coords * sizeof (parent->coords[0]));\n+      hb_memcpy (design_coords, parent->design_coords, num_coords * sizeof (parent->design_coords[0]));\n@@ -1869,1 +2007,1 @@\n- * Return value: %true if success, %false otherwise\n+ * Return value: `true` if success, `false` otherwise\n@@ -1899,1 +2037,1 @@\n-hb_font_get_user_data (hb_font_t          *font,\n+hb_font_get_user_data (const hb_font_t    *font,\n@@ -1931,1 +2069,1 @@\n- * Return value: %true if @font is immutable, %false otherwise\n+ * Return value: `true` if @font is immutable, `false` otherwise\n@@ -1951,1 +2089,1 @@\n- * Since: 4.4.0.\n+ * Since: 4.4.0\n@@ -1967,1 +2105,1 @@\n- * Since: 4.4.0.\n+ * Since: 4.4.0\n@@ -2159,0 +2297,25 @@\n+ * The font scale is a number related to, but not the same as,\n+ * font size. Typically the client establishes a scale factor\n+ * to be used between the two. For example, 64, or 256, which\n+ * would be the fractional-precision part of the font scale.\n+ * This is necessary because #hb_position_t values are integer\n+ * types and you need to leave room for fractional values\n+ * in there.\n+ *\n+ * For example, to set the font size to 20, with 64\n+ * levels of fractional precision you would call\n+ * `hb_font_set_scale(font, 20 * 64, 20 * 64)`.\n+ *\n+ * In the example above, even what font size 20 means is up to\n+ * you. It might be 20 pixels, or 20 points, or 20 millimeters.\n+ * HarfBuzz does not care about that.  You can set the point\n+ * size of the font using hb_font_set_ptem(), and the pixel\n+ * size using hb_font_set_ppem().\n+ *\n+ * The choice of scale is yours but needs to be consistent between\n+ * what you set here, and what you expect out of #hb_position_t\n+ * as well has draw \/ paint API output values.\n+ *\n+ * Fonts default to a scale equal to the UPEM value of their face.\n+ * A font with this setting is sometimes called an \"unscaled\" font.\n+ *\n@@ -2204,1 +2367,5 @@\n- * Sets the horizontal and vertical pixels-per-em (ppem) of a font.\n+ * Sets the horizontal and vertical pixels-per-em (PPEM) of a font.\n+ *\n+ * These values are used for pixel-size-specific adjustment to\n+ * shaping and draw results, though for the most part they are\n+ * unused and can be left unset.\n@@ -2288,0 +2455,70 @@\n+\/**\n+ * hb_font_set_synthetic_bold:\n+ * @font: #hb_font_t to work upon\n+ * @x_embolden: the amount to embolden horizontally\n+ * @y_embolden: the amount to embolden vertically\n+ * @in_place: whether to embolden glyphs in-place\n+ *\n+ * Sets the \"synthetic boldness\" of a font.\n+ *\n+ * Positive values for @x_embolden \/ @y_embolden make a font\n+ * bolder, negative values thinner. Typical values are in the\n+ * 0.01 to 0.05 range. The default value is zero.\n+ *\n+ * Synthetic boldness is applied by offsetting the contour\n+ * points of the glyph shape.\n+ *\n+ * Synthetic boldness is applied when rendering a glyph via\n+ * hb_font_draw_glyph().\n+ *\n+ * If @in_place is `false`, then glyph advance-widths are also\n+ * adjusted, otherwise they are not.  The in-place mode is\n+ * useful for simulating [font grading](https:\/\/fonts.google.com\/knowledge\/glossary\/grade).\n+ *\n+ *\n+ * Since: 7.0.0\n+ **\/\n+void\n+hb_font_set_synthetic_bold (hb_font_t *font,\n+                            float x_embolden,\n+                            float y_embolden,\n+                            hb_bool_t in_place)\n+{\n+  if (hb_object_is_immutable (font))\n+    return;\n+\n+  if (font->x_embolden == x_embolden &&\n+      font->y_embolden == y_embolden &&\n+      font->embolden_in_place == (bool) in_place)\n+    return;\n+\n+  font->serial++;\n+\n+  font->x_embolden = x_embolden;\n+  font->y_embolden = y_embolden;\n+  font->embolden_in_place = in_place;\n+  font->mults_changed ();\n+}\n+\n+\/**\n+ * hb_font_get_synthetic_bold:\n+ * @font: #hb_font_t to work upon\n+ * @x_embolden: (out): return location for horizontal value\n+ * @y_embolden: (out): return location for vertical value\n+ * @in_place: (out): return location for in-place value\n+ *\n+ * Fetches the \"synthetic boldness\" parameters of a font.\n+ *\n+ * Since: 7.0.0\n+ **\/\n+void\n+hb_font_get_synthetic_bold (hb_font_t *font,\n+                            float *x_embolden,\n+                            float *y_embolden,\n+                            hb_bool_t *in_place)\n+{\n+  if (x_embolden) *x_embolden = font->x_embolden;\n+  if (y_embolden) *y_embolden = font->y_embolden;\n+  if (in_place) *in_place = font->embolden_in_place;\n+}\n+\n@@ -2300,3 +2537,2 @@\n- * <note>Note: The glyph shape fetched via the\n- * hb_font_get_glyph_shape() is slanted to reflect this value\n- * as well.<\/note>\n+ * <note>Note: The glyph shape fetched via the hb_font_draw_glyph()\n+ * function is slanted to reflect this value as well.<\/note>\n@@ -2369,1 +2605,1 @@\n-  if (!variations_length)\n+  if (!variations_length && font->instance_index == HB_FONT_NO_VAR_NAMED_INSTANCE)\n@@ -2389,0 +2625,13 @@\n+  \/* Initialize design coords. *\/\n+  for (unsigned int i = 0; i < coords_length; i++)\n+    design_coords[i] = axes[i].get_default ();\n+  if (font->instance_index != HB_FONT_NO_VAR_NAMED_INSTANCE)\n+  {\n+    unsigned count = coords_length;\n+    \/* This may fail if index is out-of-range;\n+     * That's why we initialize design_coords from fvar above\n+     * unconditionally. *\/\n+    hb_ot_var_named_instance_get_design_coords (font->face, font->instance_index,\n+                                                &count, design_coords);\n+  }\n+\n@@ -2395,1 +2644,0 @@\n-      {\n@@ -2397,2 +2645,0 @@\n-        normalized[axis_index] = fvar.normalize_axis_value (axis_index, v);\n-      }\n@@ -2402,0 +2648,1 @@\n+  hb_ot_var_normalize_coords (font->face, coords_length, design_coords, normalized);\n@@ -2441,1 +2688,1 @@\n-    memcpy (design_coords, coords, coords_length * sizeof (font->design_coords[0]));\n+    hb_memcpy (design_coords, coords, coords_length * sizeof (font->design_coords[0]));\n@@ -2452,1 +2699,1 @@\n- * Sets design coords of a font from a named instance index.\n+ * Sets design coords of a font from a named-instance index.\n@@ -2458,1 +2705,1 @@\n-                                unsigned instance_index)\n+                                unsigned int instance_index)\n@@ -2463,1 +2710,2 @@\n-  font->serial_coords = ++font->serial;\n+  if (font->instance_index == instance_index)\n+    return;\n@@ -2465,1 +2713,1 @@\n-  unsigned int coords_length = hb_ot_var_named_instance_get_design_coords (font->face, instance_index, nullptr, nullptr);\n+  font->serial_coords = ++font->serial;\n@@ -2467,3 +2715,3 @@\n-  float *coords = coords_length ? (float *) hb_calloc (coords_length, sizeof (float)) : nullptr;\n-  if (unlikely (coords_length && !coords))\n-    return;\n+  font->instance_index = instance_index;\n+  hb_font_set_variations (font, nullptr, 0);\n+}\n@@ -2471,3 +2719,14 @@\n-  hb_ot_var_named_instance_get_design_coords (font->face, instance_index, &coords_length, coords);\n-  hb_font_set_var_coords_design (font, coords, coords_length);\n-  hb_free (coords);\n+\/**\n+ * hb_font_get_var_named_instance:\n+ * @font: a font.\n+ *\n+ * Returns the currently-set named-instance index of the font.\n+ *\n+ * Return value: Named-instance index or %HB_FONT_NO_VAR_NAMED_INSTANCE.\n+ *\n+ * Since: 7.0.0\n+ **\/\n+unsigned int\n+hb_font_get_var_named_instance (hb_font_t *font)\n+{\n+  return font->instance_index;\n@@ -2517,2 +2776,2 @@\n-    memcpy (copy, coords, coords_length * sizeof (coords[0]));\n-    memcpy (unmapped, coords, coords_length * sizeof (coords[0]));\n+    hb_memcpy (copy, coords, coords_length * sizeof (coords[0]));\n+    hb_memcpy (unmapped, coords, coords_length * sizeof (coords[0]));\n@@ -2722,0 +2981,10 @@\n+\n+\n+void\n+hb_font_funcs_set_glyph_shape_func (hb_font_funcs_t               *ffuncs,\n+                                   hb_font_get_glyph_shape_func_t  func,\n+                                   void                           *user_data,\n+                                   hb_destroy_func_t               destroy \/* May be NULL. *\/)\n+{\n+  hb_font_funcs_set_draw_glyph_func (ffuncs, func, user_data, destroy);\n+}\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-font.cc","additions":398,"deletions":129,"binary":false,"changes":527,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"hb-paint.h\"\n@@ -40,9 +41,0 @@\n-\/**\n- * hb_font_t:\n- *\n- * Data type for holding fonts.\n- *\n- *\/\n-typedef struct hb_font_t hb_font_t;\n-\n-\n@@ -89,2 +81,2 @@\n-hb_font_funcs_get_user_data (hb_font_funcs_t    *ffuncs,\n-                             hb_user_data_key_t *key);\n+hb_font_funcs_get_user_data (const hb_font_funcs_t *ffuncs,\n+                             hb_user_data_key_t    *key);\n@@ -100,1 +92,1 @@\n-\/* font and glyph extents *\/\n+\/* font extents *\/\n@@ -129,18 +121,0 @@\n-\/**\n- * hb_glyph_extents_t:\n- * @x_bearing: Distance from the x-origin to the left extremum of the glyph.\n- * @y_bearing: Distance from the top extremum of the glyph to the y-origin.\n- * @width: Distance from the left extremum of the glyph to the right extremum.\n- * @height: Distance from the top extremum of the glyph to the bottom extremum.\n- *\n- * Glyph extent values, measured in font units.\n- *\n- * Note that @height is negative, in coordinate systems that grow up.\n- **\/\n-typedef struct hb_glyph_extents_t {\n-  hb_position_t x_bearing;\n-  hb_position_t y_bearing;\n-  hb_position_t width;\n-  hb_position_t height;\n-} hb_glyph_extents_t;\n-\n@@ -201,1 +175,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -224,1 +198,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -365,1 +339,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -437,1 +411,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -461,1 +435,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -484,1 +458,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -506,1 +480,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -526,1 +500,1 @@\n- *\n+ * Deprecated: 7.0.0: Use #hb_font_draw_glyph_func_t instead\n@@ -533,0 +507,40 @@\n+\/**\n+ * hb_font_draw_glyph_func_t:\n+ * @font: #hb_font_t to work upon\n+ * @font_data: @font user data pointer\n+ * @glyph: The glyph ID to query\n+ * @draw_funcs: The draw functions to send the shape data to\n+ * @draw_data: The data accompanying the draw functions\n+ * @user_data: User data pointer passed by the caller\n+ *\n+ * A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n+ *\n+ * Since: 7.0.0\n+ *\n+ **\/\n+typedef void (*hb_font_draw_glyph_func_t) (hb_font_t *font, void *font_data,\n+                                           hb_codepoint_t glyph,\n+                                           hb_draw_funcs_t *draw_funcs, void *draw_data,\n+                                           void *user_data);\n+\n+\/**\n+ * hb_font_paint_glyph_func_t:\n+ * @font: #hb_font_t to work upon\n+ * @font_data: @font user data pointer\n+ * @glyph: The glyph ID to query\n+ * @paint_funcs: The paint functions to use\n+ * @paint_data: The data accompanying the paint functions\n+ * @palette_index: The color palette to use\n+ * @foreground: The foreground color\n+ * @user_data: User data pointer passed by the caller\n+ *\n+ * A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef void (*hb_font_paint_glyph_func_t) (hb_font_t *font, void *font_data,\n+                                            hb_codepoint_t glyph,\n+                                            hb_paint_funcs_t *paint_funcs, void *paint_data,\n+                                            unsigned int palette_index,\n+                                            hb_color_t foreground,\n+                                            void *user_data);\n@@ -799,1 +813,2 @@\n- * Sets the implementation function for #hb_font_get_glyph_shape_func_t.\n+ * Sets the implementation function for #hb_font_get_glyph_shape_func_t,\n+ * which is the same as #hb_font_draw_glyph_func_t.\n@@ -802,0 +817,1 @@\n+ * Deprecated: 7.0.0: Use hb_font_funcs_set_draw_glyph_func() instead\n@@ -808,0 +824,33 @@\n+\/**\n+ * hb_font_funcs_set_draw_glyph_func:\n+ * @ffuncs: A font-function structure\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): The function to call when @user_data is not needed anymore\n+ *\n+ * Sets the implementation function for #hb_font_draw_glyph_func_t,\n+ * which is the same as #hb_font_get_glyph_shape_func_t.\n+ *\n+ * Since: 7.0.0\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_draw_glyph_func (hb_font_funcs_t *ffuncs,\n+                                   hb_font_draw_glyph_func_t func,\n+                                   void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_font_funcs_set_paint_glyph_func:\n+ * @ffuncs: A font-function structure\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): The function to call when @user_data is no longer needed\n+ *\n+ * Sets the implementation function for #hb_font_paint_glyph_func_t.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+HB_EXTERN void\n+hb_font_funcs_set_paint_glyph_func (hb_font_funcs_t *ffuncs,\n+                                    hb_font_paint_glyph_func_t func,\n+                                    void *user_data, hb_destroy_func_t destroy);\n+\n@@ -893,0 +942,11 @@\n+HB_EXTERN void\n+hb_font_draw_glyph (hb_font_t *font,\n+                    hb_codepoint_t glyph,\n+                    hb_draw_funcs_t *dfuncs, void *draw_data);\n+\n+HB_EXTERN void\n+hb_font_paint_glyph (hb_font_t *font,\n+                     hb_codepoint_t glyph,\n+                     hb_paint_funcs_t *pfuncs, void *paint_data,\n+                     unsigned int palette_index,\n+                     hb_color_t foreground);\n@@ -996,1 +1056,1 @@\n-hb_font_get_user_data (hb_font_t          *font,\n+hb_font_get_user_data (const hb_font_t    *font,\n@@ -1072,0 +1132,10 @@\n+HB_EXTERN void\n+hb_font_set_synthetic_bold (hb_font_t *font,\n+                            float x_embolden, float y_embolden,\n+                            hb_bool_t in_place);\n+\n+HB_EXTERN void\n+hb_font_get_synthetic_bold (hb_font_t *font,\n+                            float *x_embolden, float *y_embolden,\n+                            hb_bool_t *in_place);\n+\n@@ -1101,0 +1171,11 @@\n+\/**\n+ * HB_FONT_NO_VAR_NAMED_INSTANCE:\n+ *\n+ * Constant signifying that a font does not have any\n+ * named-instance index set.  This is the default of\n+ * a font.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+#define HB_FONT_NO_VAR_NAMED_INSTANCE 0xFFFFFFFF\n+\n@@ -1103,1 +1184,1 @@\n-                                unsigned instance_index);\n+                                unsigned int instance_index);\n@@ -1105,0 +1186,2 @@\n+HB_EXTERN unsigned int\n+hb_font_get_var_named_instance (hb_font_t *font);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-font.h","additions":124,"deletions":41,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -43,18 +43,19 @@\n-  HB_FONT_FUNC_IMPLEMENT (font_h_extents) \\\n-  HB_FONT_FUNC_IMPLEMENT (font_v_extents) \\\n-  HB_FONT_FUNC_IMPLEMENT (nominal_glyph) \\\n-  HB_FONT_FUNC_IMPLEMENT (nominal_glyphs) \\\n-  HB_FONT_FUNC_IMPLEMENT (variation_glyph) \\\n-  HB_FONT_FUNC_IMPLEMENT (glyph_h_advance) \\\n-  HB_FONT_FUNC_IMPLEMENT (glyph_v_advance) \\\n-  HB_FONT_FUNC_IMPLEMENT (glyph_h_advances) \\\n-  HB_FONT_FUNC_IMPLEMENT (glyph_v_advances) \\\n-  HB_FONT_FUNC_IMPLEMENT (glyph_h_origin) \\\n-  HB_FONT_FUNC_IMPLEMENT (glyph_v_origin) \\\n-  HB_FONT_FUNC_IMPLEMENT (glyph_h_kerning) \\\n-  HB_IF_NOT_DEPRECATED (HB_FONT_FUNC_IMPLEMENT (glyph_v_kerning)) \\\n-  HB_FONT_FUNC_IMPLEMENT (glyph_extents) \\\n-  HB_FONT_FUNC_IMPLEMENT (glyph_contour_point) \\\n-  HB_FONT_FUNC_IMPLEMENT (glyph_name) \\\n-  HB_FONT_FUNC_IMPLEMENT (glyph_from_name) \\\n-  HB_FONT_FUNC_IMPLEMENT (glyph_shape) \\\n+  HB_FONT_FUNC_IMPLEMENT (get_,font_h_extents) \\\n+  HB_FONT_FUNC_IMPLEMENT (get_,font_v_extents) \\\n+  HB_FONT_FUNC_IMPLEMENT (get_,nominal_glyph) \\\n+  HB_FONT_FUNC_IMPLEMENT (get_,nominal_glyphs) \\\n+  HB_FONT_FUNC_IMPLEMENT (get_,variation_glyph) \\\n+  HB_FONT_FUNC_IMPLEMENT (get_,glyph_h_advance) \\\n+  HB_FONT_FUNC_IMPLEMENT (get_,glyph_v_advance) \\\n+  HB_FONT_FUNC_IMPLEMENT (get_,glyph_h_advances) \\\n+  HB_FONT_FUNC_IMPLEMENT (get_,glyph_v_advances) \\\n+  HB_FONT_FUNC_IMPLEMENT (get_,glyph_h_origin) \\\n+  HB_FONT_FUNC_IMPLEMENT (get_,glyph_v_origin) \\\n+  HB_FONT_FUNC_IMPLEMENT (get_,glyph_h_kerning) \\\n+  HB_IF_NOT_DEPRECATED (HB_FONT_FUNC_IMPLEMENT (get_,glyph_v_kerning)) \\\n+  HB_FONT_FUNC_IMPLEMENT (get_,glyph_extents) \\\n+  HB_FONT_FUNC_IMPLEMENT (get_,glyph_contour_point) \\\n+  HB_FONT_FUNC_IMPLEMENT (get_,glyph_name) \\\n+  HB_FONT_FUNC_IMPLEMENT (get_,glyph_from_name) \\\n+  HB_FONT_FUNC_IMPLEMENT (,draw_glyph) \\\n+  HB_FONT_FUNC_IMPLEMENT (,paint_glyph) \\\n@@ -68,1 +69,1 @@\n-#define HB_FONT_FUNC_IMPLEMENT(name) void *name;\n+#define HB_FONT_FUNC_IMPLEMENT(get_,name) void *name;\n@@ -74,1 +75,1 @@\n-#define HB_FONT_FUNC_IMPLEMENT(name) hb_destroy_func_t name;\n+#define HB_FONT_FUNC_IMPLEMENT(get_,name) hb_destroy_func_t name;\n@@ -82,1 +83,1 @@\n-#define HB_FONT_FUNC_IMPLEMENT(name) hb_font_get_##name##_func_t name;\n+#define HB_FONT_FUNC_IMPLEMENT(get_,name) hb_font_##get_##name##_func_t name;\n@@ -87,1 +88,1 @@\n-#define HB_FONT_FUNC_IMPLEMENT(name) +1\n+#define HB_FONT_FUNC_IMPLEMENT(get_,name) +1\n@@ -115,0 +116,7 @@\n+\n+  float x_embolden;\n+  float y_embolden;\n+  bool embolden_in_place;\n+  int32_t x_strength; \/* x_embolden, in scaled units. *\/\n+  int32_t y_strength; \/* y_embolden, in scaled units. *\/\n+\n@@ -117,0 +125,1 @@\n+\n@@ -128,0 +137,1 @@\n+  unsigned int instance_index;\n@@ -182,0 +192,36 @@\n+  void scale_glyph_extents (hb_glyph_extents_t *extents)\n+  {\n+    float x1 = em_fscale_x (extents->x_bearing);\n+    float y1 = em_fscale_y (extents->y_bearing);\n+    float x2 = em_fscale_x (extents->x_bearing + extents->width);\n+    float y2 = em_fscale_y (extents->y_bearing + extents->height);\n+\n+    \/* Apply slant. *\/\n+    if (slant_xy)\n+    {\n+      x1 += hb_min (y1 * slant_xy, y2 * slant_xy);\n+      x2 += hb_max (y1 * slant_xy, y2 * slant_xy);\n+    }\n+\n+    extents->x_bearing = floorf (x1);\n+    extents->y_bearing = floorf (y1);\n+    extents->width = ceilf (x2) - extents->x_bearing;\n+    extents->height = ceilf (y2) - extents->y_bearing;\n+\n+    if (x_strength || y_strength)\n+    {\n+      \/* Y *\/\n+      int y_shift = y_strength;\n+      if (y_scale < 0) y_shift = -y_shift;\n+      extents->y_bearing += y_shift;\n+      extents->height -= y_shift;\n+\n+      \/* X *\/\n+      int x_shift = x_strength;\n+      if (x_scale < 0) x_shift = -x_shift;\n+      if (embolden_in_place)\n+        extents->x_bearing -= x_shift \/ 2;\n+      extents->width += x_shift;\n+    }\n+  }\n+\n@@ -189,1 +235,1 @@\n-#define HB_FONT_FUNC_IMPLEMENT(name) \\\n+#define HB_FONT_FUNC_IMPLEMENT(get_,name) \\\n@@ -209,1 +255,1 @@\n-    memset (extents, 0, sizeof (*extents));\n+    hb_memset (extents, 0, sizeof (*extents));\n@@ -216,1 +262,1 @@\n-    memset (extents, 0, sizeof (*extents));\n+    hb_memset (extents, 0, sizeof (*extents));\n@@ -345,1 +391,1 @@\n-    memset (extents, 0, sizeof (*extents));\n+    hb_memset (extents, 0, sizeof (*extents));\n@@ -383,2 +429,2 @@\n-  void get_glyph_shape (hb_codepoint_t glyph,\n-                        hb_draw_funcs_t *draw_funcs, void *draw_data)\n+  void draw_glyph (hb_codepoint_t glyph,\n+                   hb_draw_funcs_t *draw_funcs, void *draw_data)\n@@ -386,4 +432,4 @@\n-    klass->get.f.glyph_shape (this, user_data,\n-                              glyph,\n-                              draw_funcs, draw_data,\n-                              !klass->user_data ? nullptr : klass->user_data->glyph_shape);\n+    klass->get.f.draw_glyph (this, user_data,\n+                             glyph,\n+                             draw_funcs, draw_data,\n+                             !klass->user_data ? nullptr : klass->user_data->draw_glyph);\n@@ -392,0 +438,11 @@\n+  void paint_glyph (hb_codepoint_t glyph,\n+                    hb_paint_funcs_t *paint_funcs, void *paint_data,\n+                    unsigned int palette,\n+                    hb_color_t foreground)\n+  {\n+    klass->get.f.paint_glyph (this, user_data,\n+                              glyph,\n+                              paint_funcs, paint_data,\n+                              palette, foreground,\n+                              !klass->user_data ? nullptr : klass->user_data->paint_glyph);\n+  }\n@@ -635,0 +692,1 @@\n+\n@@ -641,0 +699,4 @@\n+\n+    x_strength = fabsf (roundf (x_scale * x_embolden));\n+    y_strength = fabsf (roundf (y_scale * y_embolden));\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-font.hh","additions":94,"deletions":32,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"hb-cache.hh\"\n@@ -39,1 +40,0 @@\n-#include \"hb-cache.hh\"\n@@ -42,0 +42,1 @@\n+#include \"hb-paint.hh\"\n@@ -47,0 +48,4 @@\n+#include FT_SYNTHESIS_H\n+#if (FREETYPE_MAJOR*10000 + FREETYPE_MINOR*100 + FREETYPE_PATCH) >= 21300\n+#include FT_COLOR_H\n+#endif\n@@ -83,0 +88,2 @@\n+using hb_ft_advance_cache_t = hb_cache_t<16, 8, 8, false>;\n+\n@@ -88,0 +95,1 @@\n+  bool transform; \/* Whether to apply FT_Face's transform. *\/\n@@ -89,1 +97,1 @@\n-  mutable hb_mutex_t lock;\n+  mutable hb_mutex_t lock; \/* Protects members below. *\/\n@@ -92,1 +100,1 @@\n-  mutable hb_advance_cache_t advance_cache;\n+  mutable hb_ft_advance_cache_t advance_cache;\n@@ -125,2 +133,0 @@\n-  ft_font->advance_cache.fini ();\n-\n@@ -139,0 +145,6 @@\n+  hb_ft_font_t *ft_font = (hb_ft_font_t *) font->user_data;\n+\n+  float x_mult = 1.f, y_mult = 1.f;\n+\n+  if (font->x_scale < 0) x_mult = -x_mult;\n+  if (font->y_scale < 0) y_mult = -y_mult;\n@@ -140,3 +152,3 @@\n-  FT_Set_Char_Size (ft_face,\n-                    abs (font->x_scale), abs (font->y_scale),\n-                    0, 0);\n+  if (FT_Set_Char_Size (ft_face,\n+                        abs (font->x_scale), abs (font->y_scale),\n+                        0, 0\n@@ -145,1 +157,1 @@\n-                    font->y_ppem * 72 * 64 \/ font->y_scale);\n+                    font->y_ppem * 72 * 64 \/ font->y_scale\n@@ -147,1 +159,1 @@\n-  if (font->x_scale < 0 || font->y_scale < 0)\n+     ) && ft_face->num_fixed_sizes)\n@@ -149,2 +161,22 @@\n-    FT_Matrix matrix = { font->x_scale < 0 ? -1 : +1, 0,\n-                          0, font->y_scale < 0 ? -1 : +1};\n+#ifdef HAVE_FT_GET_TRANSFORM\n+    \/* Bitmap font, eg. bitmap color emoji. *\/\n+    \/* Pick largest size? *\/\n+    int x_scale  = ft_face->available_sizes[ft_face->num_fixed_sizes - 1].x_ppem;\n+    int y_scale = ft_face->available_sizes[ft_face->num_fixed_sizes - 1].y_ppem;\n+    FT_Set_Char_Size (ft_face,\n+                      x_scale, y_scale,\n+                      0, 0);\n+\n+    \/* This contains the sign that was previously in x_mult\/y_mult. *\/\n+    x_mult = (float) font->x_scale \/ x_scale;\n+    y_mult = (float) font->y_scale \/ y_scale;\n+#endif\n+  }\n+  else\n+  { \/* Shrug *\/ }\n+\n+\n+  if (x_mult != 1.f || y_mult != 1.f)\n+  {\n+    FT_Matrix matrix = { (int) roundf (x_mult * (1<<16)), 0,\n+                          0, (int) roundf (y_mult * (1<<16))};\n@@ -152,0 +184,1 @@\n+    ft_font->transform = true;\n@@ -156,1 +189,1 @@\n-  const int *coords = hb_font_get_var_coords_normalized (font, &num_coords);\n+  const float *coords = hb_font_get_var_coords_design (font, &num_coords);\n@@ -163,2 +196,2 @@\n-        ft_coords[i] = coords[i] * 4;\n-      FT_Set_Var_Blend_Coordinates (ft_face, num_coords, ft_coords);\n+          ft_coords[i] = coords[i] * 65536.f;\n+      FT_Set_Var_Design_Coordinates (ft_face, num_coords, ft_coords);\n@@ -197,0 +230,3 @@\n+ * This function works with #hb_font_t objects created by\n+ * hb_ft_font_create() or hb_ft_font_create_referenced().\n+ *\n@@ -222,1 +258,4 @@\n- * Return value: FT_Load_Glyph flags found\n+ * This function works with #hb_font_t objects created by\n+ * hb_ft_font_create() or hb_ft_font_create_referenced().\n+ *\n+ * Return value: FT_Load_Glyph flags found, or 0\n@@ -244,1 +283,4 @@\n- * Return value: (nullable): the FT_Face found or %NULL\n+ * This function works with #hb_font_t objects created by\n+ * hb_ft_font_create() or hb_ft_font_create_referenced().\n+ *\n+ * Return value: (nullable): the FT_Face found or `NULL`\n@@ -263,2 +305,4 @@\n- * Gets the FT_Face associated with @font, This face will be kept around until\n- * you call hb_ft_font_unlock_face().\n+ * Gets the FT_Face associated with @font.\n+ *\n+ * This face will be kept around and access to the FT_Face object\n+ * from other HarfBuzz API wil be blocked until you call hb_ft_font_unlock_face().\n@@ -266,1 +310,4 @@\n- * Return value: (nullable): the FT_Face associated with @font or %NULL\n+ * This function works with #hb_font_t objects created by\n+ * hb_ft_font_create() or hb_ft_font_create_referenced().\n+ *\n+ * Return value: (nullable) (transfer none): the FT_Face associated with @font or `NULL`\n@@ -283,1 +330,1 @@\n- * hb_ft_font_unlock_face:\n+ * hb_ft_font_unlock_face: (skip)\n@@ -404,0 +451,1 @@\n+  hb_position_t *orig_first_advance = first_advance;\n@@ -407,1 +455,14 @@\n-  int mult = font->x_scale < 0 ? -1 : +1;\n+  float x_mult;\n+#ifdef HAVE_FT_GET_TRANSFORM\n+  if (ft_font->transform)\n+  {\n+    FT_Matrix matrix;\n+    FT_Get_Transform (ft_face, &matrix, nullptr);\n+    x_mult = sqrtf ((float)matrix.xx * matrix.xx + (float)matrix.xy * matrix.xy) \/ 65536.f;\n+    x_mult *= font->x_scale < 0 ? -1 : +1;\n+  }\n+  else\n+#endif\n+  {\n+    x_mult = font->x_scale < 0 ? -1 : +1;\n+  }\n@@ -420,0 +481,4 @@\n+      \/* Work around bug that FreeType seems to return negative advance\n+       * for variable-set fonts if x_scale is negative! *\/\n+      v = abs (v);\n+      v = (int) (v * x_mult + (1<<9)) >> 10;\n@@ -423,1 +488,1 @@\n-    *first_advance = (v * mult + (1<<9)) >> 10;\n+    *first_advance = v;\n@@ -427,0 +492,12 @@\n+\n+  if (font->x_strength && !font->embolden_in_place)\n+  {\n+    \/* Emboldening. *\/\n+    hb_position_t x_strength = font->x_scale >= 0 ? font->x_strength : -font->x_strength;\n+    first_advance = orig_first_advance;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      *first_advance += *first_advance ? x_strength : 0;\n+      first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+    }\n+  }\n@@ -439,0 +516,14 @@\n+  float y_mult;\n+#ifdef HAVE_FT_GET_TRANSFORM\n+  if (ft_font->transform)\n+  {\n+    FT_Matrix matrix;\n+    FT_Get_Transform (ft_font->ft_face, &matrix, nullptr);\n+    y_mult = sqrtf ((float)matrix.yx * matrix.yx + (float)matrix.yy * matrix.yy) \/ 65536.f;\n+    y_mult *= font->y_scale < 0 ? -1 : +1;\n+  }\n+  else\n+#endif\n+  {\n+    y_mult = font->y_scale < 0 ? -1 : +1;\n+  }\n@@ -443,2 +534,1 @@\n-  if (font->y_scale < 0)\n-    v = -v;\n+  v = (int) (y_mult * v);\n@@ -449,1 +539,2 @@\n-  return (-v + (1<<9)) >> 10;\n+  hb_position_t y_strength = font->y_scale >= 0 ? font->y_strength : -font->y_strength;\n+  return ((-v + (1<<9)) >> 10) + (font->embolden_in_place ? 0 : y_strength);\n@@ -465,0 +556,17 @@\n+  float x_mult, y_mult;\n+#ifdef HAVE_FT_GET_TRANSFORM\n+  if (ft_font->transform)\n+  {\n+    FT_Matrix matrix;\n+    FT_Get_Transform (ft_face, &matrix, nullptr);\n+    x_mult = sqrtf ((float)matrix.xx * matrix.xx + (float)matrix.xy * matrix.xy) \/ 65536.f;\n+    x_mult *= font->x_scale < 0 ? -1 : +1;\n+    y_mult = sqrtf ((float)matrix.yx * matrix.yx + (float)matrix.yy * matrix.yy) \/ 65536.f;\n+    y_mult *= font->y_scale < 0 ? -1 : +1;\n+  }\n+  else\n+#endif\n+  {\n+    x_mult = font->x_scale < 0 ? -1 : +1;\n+    y_mult = font->y_scale < 0 ? -1 : +1;\n+  }\n@@ -474,4 +582,2 @@\n-  if (font->x_scale < 0)\n-    *x = -*x;\n-  if (font->y_scale < 0)\n-    *y = -*y;\n+  *x = (hb_position_t) (x_mult * *x);\n+  *y = (hb_position_t) (y_mult * *y);\n@@ -513,0 +619,18 @@\n+  float x_mult, y_mult;\n+  float slant_xy = font->slant_xy;\n+#ifdef HAVE_FT_GET_TRANSFORM\n+  if (ft_font->transform)\n+  {\n+    FT_Matrix matrix;\n+    FT_Get_Transform (ft_face, &matrix, nullptr);\n+    x_mult = sqrtf ((float)matrix.xx * matrix.xx + (float)matrix.xy * matrix.xy) \/ 65536.f;\n+    x_mult *= font->x_scale < 0 ? -1 : +1;\n+    y_mult = sqrtf ((float)matrix.yx * matrix.yx + (float)matrix.yy * matrix.yy) \/ 65536.f;\n+    y_mult *= font->y_scale < 0 ? -1 : +1;\n+  }\n+  else\n+#endif\n+  {\n+    x_mult = font->x_scale < 0 ? -1 : +1;\n+    y_mult = font->y_scale < 0 ? -1 : +1;\n+  }\n@@ -517,5 +641,9 @@\n-  extents->x_bearing = ft_face->glyph->metrics.horiBearingX;\n-  extents->y_bearing = ft_face->glyph->metrics.horiBearingY;\n-  extents->width = ft_face->glyph->metrics.width;\n-  extents->height = -ft_face->glyph->metrics.height;\n-  if (font->x_scale < 0)\n+  \/* Copied from hb_font_t::scale_glyph_extents. *\/\n+\n+  float x1 = x_mult * ft_face->glyph->metrics.horiBearingX;\n+  float y1 = y_mult * ft_face->glyph->metrics.horiBearingY;\n+  float x2 = x1 + x_mult *  ft_face->glyph->metrics.width;\n+  float y2 = y1 + y_mult * -ft_face->glyph->metrics.height;\n+\n+  \/* Apply slant. *\/\n+  if (slant_xy)\n@@ -523,2 +651,2 @@\n-    extents->x_bearing = -extents->x_bearing;\n-    extents->width = -extents->width;\n+    x1 += hb_min (y1 * slant_xy, y2 * slant_xy);\n+    x2 += hb_max (y1 * slant_xy, y2 * slant_xy);\n@@ -526,1 +654,7 @@\n-  if (font->y_scale < 0)\n+\n+  extents->x_bearing = floorf (x1);\n+  extents->y_bearing = floorf (y1);\n+  extents->width = ceilf (x2) - extents->x_bearing;\n+  extents->height = ceilf (y2) - extents->y_bearing;\n+\n+  if (font->x_strength || font->y_strength)\n@@ -528,2 +662,12 @@\n-    extents->y_bearing = -extents->y_bearing;\n-    extents->height = -extents->height;\n+    \/* Y *\/\n+    int y_shift = font->y_strength;\n+    if (font->y_scale < 0) y_shift = -y_shift;\n+    extents->y_bearing += y_shift;\n+    extents->height -= y_shift;\n+\n+    \/* X *\/\n+    int x_shift = font->x_strength;\n+    if (font->x_scale < 0) x_shift = -x_shift;\n+    if (font->embolden_in_place)\n+      extents->x_bearing -= x_shift \/ 2;\n+    extents->width += x_shift;\n@@ -531,0 +675,1 @@\n+\n@@ -623,0 +768,14 @@\n+  float y_mult;\n+#ifdef HAVE_FT_GET_TRANSFORM\n+  if (ft_font->transform)\n+  {\n+    FT_Matrix matrix;\n+    FT_Get_Transform (ft_face, &matrix, nullptr);\n+    y_mult = sqrtf ((float)matrix.yx * matrix.yx + (float)matrix.yy * matrix.yy) \/ 65536.f;\n+    y_mult *= font->y_scale < 0 ? -1 : +1;\n+  }\n+  else\n+#endif\n+  {\n+    y_mult = font->y_scale < 0 ? -1 : +1;\n+  }\n@@ -624,4 +783,1 @@\n-  metrics->ascender = FT_MulFix(ft_face->ascender, ft_face->size->metrics.y_scale);\n-  metrics->descender = FT_MulFix(ft_face->descender, ft_face->size->metrics.y_scale);\n-  metrics->line_gap = FT_MulFix( ft_face->height, ft_face->size->metrics.y_scale ) - (metrics->ascender - metrics->descender);\n-  if (font->y_scale < 0)\n+  if (ft_face->units_per_EM != 0)\n@@ -629,3 +785,3 @@\n-    metrics->ascender = -metrics->ascender;\n-    metrics->descender = -metrics->descender;\n-    metrics->line_gap = -metrics->line_gap;\n+    metrics->ascender = FT_MulFix(ft_face->ascender, ft_face->size->metrics.y_scale);\n+    metrics->descender = FT_MulFix(ft_face->descender, ft_face->size->metrics.y_scale);\n+    metrics->line_gap = FT_MulFix( ft_face->height, ft_face->size->metrics.y_scale ) - (metrics->ascender - metrics->descender);\n@@ -633,0 +789,12 @@\n+  else\n+  {\n+    \/* Bitmap-only font, eg. color bitmap font. *\/\n+    metrics->ascender = ft_face->size->metrics.ascender;\n+    metrics->descender = ft_face->size->metrics.descender;\n+    metrics->line_gap = ft_face->size->metrics.height - (metrics->ascender - metrics->descender);\n+  }\n+\n+  metrics->ascender  = (hb_position_t) (y_mult * (metrics->ascender + font->y_strength));\n+  metrics->descender = (hb_position_t) (y_mult * metrics->descender);\n+  metrics->line_gap  = (hb_position_t) (y_mult * metrics->line_gap);\n+\n@@ -640,1 +808,1 @@\n-                hb_draw_session_t *drawing)\n+                void *arg)\n@@ -642,0 +810,1 @@\n+  hb_draw_session_t *drawing = (hb_draw_session_t *) arg;\n@@ -648,1 +817,1 @@\n-                hb_draw_session_t *drawing)\n+                void *arg)\n@@ -650,0 +819,1 @@\n+  hb_draw_session_t *drawing = (hb_draw_session_t *) arg;\n@@ -657,1 +827,1 @@\n-                 hb_draw_session_t *drawing)\n+                 void *arg)\n@@ -659,0 +829,1 @@\n+  hb_draw_session_t *drawing = (hb_draw_session_t *) arg;\n@@ -668,1 +839,1 @@\n-                 hb_draw_session_t *drawing)\n+                 void *arg)\n@@ -670,0 +841,1 @@\n+  hb_draw_session_t *drawing = (hb_draw_session_t *) arg;\n@@ -677,5 +849,5 @@\n-hb_ft_get_glyph_shape (hb_font_t *font HB_UNUSED,\n-                       void *font_data,\n-                       hb_codepoint_t glyph,\n-                       hb_draw_funcs_t *draw_funcs, void *draw_data,\n-                       void *user_data HB_UNUSED)\n+hb_ft_draw_glyph (hb_font_t *font,\n+                  void *font_data,\n+                  hb_codepoint_t glyph,\n+                  hb_draw_funcs_t *draw_funcs, void *draw_data,\n+                  void *user_data HB_UNUSED)\n@@ -687,2 +859,0 @@\n-  _hb_ft_hb_font_check_changed (font, ft_font);\n-\n@@ -697,4 +867,4 @@\n-    (FT_Outline_MoveToFunc) _hb_ft_move_to,\n-    (FT_Outline_LineToFunc) _hb_ft_line_to,\n-    (FT_Outline_ConicToFunc) _hb_ft_conic_to,\n-    (FT_Outline_CubicToFunc) _hb_ft_cubic_to,\n+    _hb_ft_move_to,\n+    _hb_ft_line_to,\n+    _hb_ft_conic_to,\n+    _hb_ft_cubic_to,\n@@ -707,0 +877,32 @@\n+  \/* Embolden *\/\n+  if (font->x_strength || font->y_strength)\n+  {\n+    FT_Outline_EmboldenXY (&ft_face->glyph->outline, font->x_strength, font->y_strength);\n+\n+    int x_shift = 0;\n+    int y_shift = 0;\n+    if (font->embolden_in_place)\n+    {\n+      \/* Undo the FreeType shift. *\/\n+      x_shift = -font->x_strength \/ 2;\n+      y_shift = 0;\n+      if (font->y_scale < 0) y_shift = -font->y_strength;\n+    }\n+    else\n+    {\n+      \/* FreeType applied things in the wrong direction for negative scale; fix up. *\/\n+      if (font->x_scale < 0) x_shift = -font->x_strength;\n+      if (font->y_scale < 0) y_shift = -font->y_strength;\n+    }\n+    if (x_shift || y_shift)\n+    {\n+      auto &outline = ft_face->glyph->outline;\n+      for (auto &point : hb_iter (outline.points, outline.contours[outline.n_contours - 1] + 1))\n+      {\n+        point.x += x_shift;\n+        point.y += y_shift;\n+      }\n+    }\n+  }\n+\n+\n@@ -713,0 +915,85 @@\n+#ifndef HB_NO_PAINT\n+#if (FREETYPE_MAJOR*10000 + FREETYPE_MINOR*100 + FREETYPE_PATCH) >= 21300\n+\n+#include \"hb-ft-colr.hh\"\n+\n+static void\n+hb_ft_paint_glyph (hb_font_t *font,\n+                   void *font_data,\n+                   hb_codepoint_t gid,\n+                   hb_paint_funcs_t *paint_funcs, void *paint_data,\n+                   unsigned int palette_index,\n+                   hb_color_t foreground,\n+                   void *user_data)\n+{\n+  const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;\n+  hb_lock_t lock (ft_font->lock);\n+  FT_Face ft_face = ft_font->ft_face;\n+\n+  \/* We release the lock before calling into glyph callbacks, such that\n+   * eg. draw API can call back into the face.*\/\n+\n+  if (unlikely (FT_Load_Glyph (ft_face, gid,\n+                               ft_font->load_flags | FT_LOAD_COLOR)))\n+    return;\n+\n+  if (ft_face->glyph->format == FT_GLYPH_FORMAT_OUTLINE)\n+  {\n+    if (hb_ft_paint_glyph_colr (font, font_data, gid,\n+                                paint_funcs, paint_data,\n+                                palette_index, foreground,\n+                                user_data))\n+      return;\n+\n+    \/* Simple outline. *\/\n+    ft_font->lock.unlock ();\n+    paint_funcs->push_clip_glyph (paint_data, gid, font);\n+    ft_font->lock.lock ();\n+    paint_funcs->color (paint_data, true, foreground);\n+    paint_funcs->pop_clip (paint_data);\n+\n+    return;\n+  }\n+\n+  auto *glyph = ft_face->glyph;\n+  if (glyph->format == FT_GLYPH_FORMAT_BITMAP)\n+  {\n+    auto &bitmap = glyph->bitmap;\n+    if (bitmap.pixel_mode == FT_PIXEL_MODE_BGRA)\n+    {\n+      if (bitmap.pitch != (signed) bitmap.width * 4)\n+        return;\n+\n+      ft_font->lock.unlock ();\n+\n+      hb_blob_t *blob = hb_blob_create ((const char *) bitmap.buffer,\n+                                        bitmap.pitch * bitmap.rows,\n+                                        HB_MEMORY_MODE_DUPLICATE,\n+                                        nullptr, nullptr);\n+\n+      hb_glyph_extents_t extents;\n+      if (!hb_font_get_glyph_extents (font, gid, &extents))\n+        goto out;\n+\n+      if (!paint_funcs->image (paint_data,\n+                               blob,\n+                               bitmap.width,\n+                               bitmap.rows,\n+                               HB_PAINT_IMAGE_FORMAT_BGRA,\n+                               font->slant_xy,\n+                               &extents))\n+      {\n+        \/* TODO Try a forced outline load and paint? *\/\n+      }\n+\n+    out:\n+      hb_blob_destroy (blob);\n+      ft_font->lock.lock ();\n+    }\n+\n+    return;\n+  }\n+}\n+#endif\n+#endif\n+\n@@ -746,1 +1033,7 @@\n-    hb_font_funcs_set_glyph_shape_func (funcs, hb_ft_get_glyph_shape, nullptr, nullptr);\n+    hb_font_funcs_set_draw_glyph_func (funcs, hb_ft_draw_glyph, nullptr, nullptr);\n+#endif\n+\n+#ifndef HB_NO_PAINT\n+#if (FREETYPE_MAJOR*10000 + FREETYPE_MINOR*100 + FREETYPE_PATCH) >= 21300\n+    hb_font_funcs_set_paint_glyph_func (funcs, hb_ft_paint_glyph, nullptr, nullptr);\n+#endif\n@@ -821,0 +1114,4 @@\n+ * Note that this is using the FT_Face object just to get at the underlying\n+ * font data, and fonts created from the returned #hb_face_t will use the native\n+ * HarfBuzz font implementation, unless you call hb_ft_font_set_funcs() on them.\n+ *\n@@ -865,0 +1162,4 @@\n+ * Note that this is using the FT_Face object just to get at the underlying\n+ * font data, and fonts created from the returned #hb_face_t will use the native\n+ * HarfBuzz font implementation, unless you call hb_ft_font_set_funcs() on them.\n+ *\n@@ -885,1 +1186,1 @@\n-hb_ft_face_finalize (FT_Face ft_face)\n+hb_ft_face_finalize (void *arg)\n@@ -887,0 +1188,1 @@\n+  FT_Face ft_face = (FT_Face) arg;\n@@ -896,0 +1198,4 @@\n+ * Note that this is using the FT_Face object just to get at the underlying\n+ * font data, and fonts created from the returned #hb_face_t will use the native\n+ * HarfBuzz font implementation, unless you call hb_ft_font_set_funcs() on them.\n+ *\n@@ -918,1 +1224,1 @@\n-    ft_face->generic.finalizer = (FT_Generic_Finalizer) hb_ft_face_finalize;\n+    ft_face->generic.finalizer = hb_ft_face_finalize;\n@@ -1031,0 +1337,3 @@\n+\n+  ft_font->advance_cache.clear ();\n+  ft_font->cached_serial = font->serial;\n@@ -1124,1 +1433,1 @@\n-_release_blob (FT_Face ft_face)\n+_release_blob (void *arg)\n@@ -1126,0 +1435,1 @@\n+  FT_Face ft_face = (FT_Face) arg;\n@@ -1142,1 +1452,1 @@\n- * An #hb_face_t face object created with hb_ft_face_create()\n+ * An #hb_font_t object created with hb_ft_font_create()\n@@ -1146,0 +1456,4 @@\n+ * Note that if you modify the underlying #hb_font_t after\n+ * calling this function, you need to call hb_ft_hb_font_changed()\n+ * to update the underlying FT_Face.\n+ *\n@@ -1176,1 +1490,0 @@\n-  _hb_ft_hb_font_changed (font, ft_face);\n@@ -1179,1 +1492,1 @@\n-  ft_face->generic.finalizer = (FT_Generic_Finalizer) _release_blob;\n+  ft_face->generic.finalizer = _release_blob;\n@@ -1183,1 +1496,0 @@\n-}\n@@ -1185,0 +1497,2 @@\n+  _hb_ft_hb_font_changed (font, ft_face);\n+}\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ft.cc","additions":384,"deletions":70,"binary":false,"changes":454,"status":"modified"},{"patch":"@@ -76,2 +76,4 @@\n-  iter_t begin () const { return *thiz(); }\n-  iter_t end () const { return thiz()->__end__ (); }\n+  iter_t _begin () const { return *thiz(); }\n+  iter_t begin () const { return _begin (); }\n+  iter_t _end () const { return thiz()->__end__ (); }\n+  iter_t end () const { return _end (); }\n@@ -121,0 +123,1 @@\n+  using Name::_begin; \\\n@@ -122,0 +125,1 @@\n+  using Name::_end; \\\n@@ -171,3 +175,7 @@\n-  template <typename T> unsigned\n-  operator () (T&& c) const\n-  { return c.len (); }\n+  template <typename T> auto\n+  impl (T&& c, hb_priority<1>) const HB_RETURN (unsigned, c.len ())\n+\n+  template <typename T> auto\n+  impl (T&& c, hb_priority<0>) const HB_RETURN (unsigned, c.len)\n+\n+  public:\n@@ -175,0 +183,2 @@\n+  template <typename T> auto\n+  operator () (T&& c) const HB_RETURN (unsigned, impl (std::forward<T> (c), hb_prioritize))\n@@ -256,0 +266,2 @@\n+#define hb_is_sorted_iterator_of(Iter, Item) (hb_is_iterator_of<Iter, Item>::value && Iter::is_sorted_iterator)\n+#define hb_is_sorted_iterator(Iter) hb_is_sorted_iterator_of (Iter, typename Iter::item_t)\n@@ -378,1 +390,1 @@\n-  hb_map_iter_t __end__ () const { return hb_map_iter_t (it.end (), f); }\n+  hb_map_iter_t __end__ () const { return hb_map_iter_t (it._end (), f); }\n@@ -441,1 +453,1 @@\n-  hb_filter_iter_t __end__ () const { return hb_filter_iter_t (it.end (), p, f); }\n+  hb_filter_iter_t __end__ () const { return hb_filter_iter_t (it._end (), p, f); }\n@@ -554,1 +566,1 @@\n-  hb_zip_iter_t __end__ () const { return hb_zip_iter_t (a.end (), b.end ()); }\n+  hb_zip_iter_t __end__ () const { return hb_zip_iter_t (a._end (), b._end ()); }\n@@ -638,1 +650,1 @@\n-  hb_concat_iter_t __end__ () const { return hb_concat_iter_t (a.end (), b.end ()); }\n+  hb_concat_iter_t __end__ () const { return hb_concat_iter_t (a._end (), b._end ()); }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-iter.hh","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright © 2022  Behdad Esfahbod\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_LIMITS_HH\n+#define HB_LIMITS_HH\n+\n+#include \"hb.hh\"\n+\n+\n+#ifndef HB_BUFFER_MAX_LEN_FACTOR\n+#define HB_BUFFER_MAX_LEN_FACTOR 64\n+#endif\n+#ifndef HB_BUFFER_MAX_LEN_MIN\n+#define HB_BUFFER_MAX_LEN_MIN 16384\n+#endif\n+#ifndef HB_BUFFER_MAX_LEN_DEFAULT\n+#define HB_BUFFER_MAX_LEN_DEFAULT 0x3FFFFFFF \/* Shaping more than a billion chars? Let us know! *\/\n+#endif\n+\n+#ifndef HB_BUFFER_MAX_OPS_FACTOR\n+#define HB_BUFFER_MAX_OPS_FACTOR 1024\n+#endif\n+#ifndef HB_BUFFER_MAX_OPS_MIN\n+#define HB_BUFFER_MAX_OPS_MIN 16384\n+#endif\n+#ifndef HB_BUFFER_MAX_OPS_DEFAULT\n+#define HB_BUFFER_MAX_OPS_DEFAULT 0x1FFFFFFF \/* Shaping more than a billion operations? Let us know! *\/\n+#endif\n+\n+\n+#ifndef HB_MAX_NESTING_LEVEL\n+#define HB_MAX_NESTING_LEVEL 64\n+#endif\n+\n+\n+#ifndef HB_MAX_CONTEXT_LENGTH\n+#define HB_MAX_CONTEXT_LENGTH 64\n+#endif\n+\n+#ifndef HB_CLOSURE_MAX_STAGES\n+\/*\n+ * The maximum number of times a lookup can be applied during shaping.\n+ * Used to limit the number of iterations of the closure algorithm.\n+ * This must be larger than the number of times add_gsub_pause() is\n+ * called in a collect_features call of any shaper.\n+ *\/\n+#define HB_CLOSURE_MAX_STAGES 12\n+#endif\n+\n+#ifndef HB_MAX_SCRIPTS\n+#define HB_MAX_SCRIPTS 500\n+#endif\n+\n+#ifndef HB_MAX_LANGSYS\n+#define HB_MAX_LANGSYS 2000\n+#endif\n+\n+#ifndef HB_MAX_LANGSYS_FEATURE_COUNT\n+#define HB_MAX_LANGSYS_FEATURE_COUNT 50000\n+#endif\n+\n+#ifndef HB_MAX_FEATURE_INDICES\n+#define HB_MAX_FEATURE_INDICES 1500\n+#endif\n+\n+#ifndef HB_MAX_LOOKUP_VISIT_COUNT\n+#define HB_MAX_LOOKUP_VISIT_COUNT 35000\n+#endif\n+\n+\n+#ifndef HB_GLYF_MAX_POINTS\n+#define HB_GLYF_MAX_POINTS 20000\n+#endif\n+\n+#ifndef HB_GLYF_MAX_EDGE_COUNT\n+#define HB_GLYF_MAX_EDGE_COUNT 1024\n+#endif\n+\n+#ifndef HB_CFF_MAX_OPS\n+#define HB_CFF_MAX_OPS 10000\n+#endif\n+\n+#ifndef HB_COLRV1_MAX_EDGE_COUNT\n+#define HB_COLRV1_MAX_EDGE_COUNT 1024\n+#endif\n+\n+\n+#endif \/* HB_LIMITS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-limits.hh","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"hb-serialize.hh\"\n@@ -139,0 +138,7 @@\n+ *\n+ * The lazy-loaders are thread-safe pointer-like objects that create their\n+ * instead on-demand.  They also support access to a \"data\" object that is\n+ * necessary for creating their instance.  The data object, if specified,\n+ * is accessed via pointer math, located at a location before the position\n+ * of the loader itself.  This avoids having to store a pointer to data\n+ * for every lazy-loader.  Multiple lazy-loaders can access the same data.\n@@ -179,1 +185,1 @@\n-  void fini ()  { do_destroy (instance.get ()); init (); }\n+  void fini ()  { do_destroy (instance.get_acquire ()); init (); }\n@@ -184,1 +190,1 @@\n-    Stored *p = instance.get ();\n+    Stored *p = instance.get_acquire ();\n@@ -206,1 +212,1 @@\n-    Stored *p = this->instance.get ();\n+    Stored *p = this->instance.get_acquire ();\n@@ -231,1 +237,2 @@\n-    \/* This *must* be called when there are no other threads accessing. *\/\n+    \/* This function can only be safely called directly if no\n+     * other thread is accessing. *\/\n@@ -264,1 +271,1 @@\n-\/\/  private:\n+  private:\n@@ -286,1 +293,1 @@\n-      c.set_num_glyphs (0); \/\/ So we don't recurse ad infinitum...\n+      c.set_num_glyphs (0); \/\/ So we don't recurse ad infinitum, or doesn't need num_glyphs\n@@ -300,16 +307,16 @@\n-template <typename Subclass>\n-struct hb_font_funcs_lazy_loader_t : hb_lazy_loader_t<hb_font_funcs_t, Subclass>\n-{\n-  static void destroy (hb_font_funcs_t *p)\n-  { hb_font_funcs_destroy (p); }\n-  static const hb_font_funcs_t *get_null ()\n-  { return hb_font_funcs_get_empty (); }\n-};\n-template <typename Subclass>\n-struct hb_unicode_funcs_lazy_loader_t : hb_lazy_loader_t<hb_unicode_funcs_t, Subclass>\n-{\n-  static void destroy (hb_unicode_funcs_t *p)\n-  { hb_unicode_funcs_destroy (p); }\n-  static const hb_unicode_funcs_t *get_null ()\n-  { return hb_unicode_funcs_get_empty (); }\n-};\n+#define HB_DEFINE_TYPE_FUNCS_LAZY_LOADER_T(Type) \\\n+  template <typename Subclass> \\\n+  struct hb_##Type##_funcs_lazy_loader_t : hb_lazy_loader_t<hb_##Type##_funcs_t, Subclass> \\\n+  { \\\n+    static void destroy (hb_##Type##_funcs_t *p) \\\n+    { hb_##Type##_funcs_destroy (p); } \\\n+    static const hb_##Type##_funcs_t *get_null () \\\n+    { return hb_##Type##_funcs_get_empty (); } \\\n+  }\n+\n+HB_DEFINE_TYPE_FUNCS_LAZY_LOADER_T (font);\n+HB_DEFINE_TYPE_FUNCS_LAZY_LOADER_T (unicode);\n+HB_DEFINE_TYPE_FUNCS_LAZY_LOADER_T (draw);\n+HB_DEFINE_TYPE_FUNCS_LAZY_LOADER_T (paint);\n+\n+#undef HB_DEFINE_TYPE_FUNCS_LAZY_LOADER_T\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-machinery.hh","additions":30,"deletions":23,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -59,2 +59,0 @@\n-  map->init_shallow ();\n-\n@@ -110,2 +108,0 @@\n-  map->fini_shallow ();\n-\n@@ -125,1 +121,1 @@\n- * Return value: %true if success, %false otherwise\n+ * Return value: `true` if success, `false` otherwise\n@@ -152,1 +148,1 @@\n-hb_map_get_user_data (hb_map_t           *map,\n+hb_map_get_user_data (const hb_map_t     *map,\n@@ -165,1 +161,1 @@\n- * Return value: %true if allocation succeeded, %false otherwise\n+ * Return value: `true` if allocation succeeded, `false` otherwise\n@@ -181,1 +177,1 @@\n- * Return value: Newly-allocated map.\n+ * Return value: (transfer full): Newly-allocated map.\n@@ -189,3 +185,4 @@\n-  if (unlikely (!copy)) return nullptr;\n-  copy->resize (map->population);\n-  hb_copy (*map, *copy);\n+  if (unlikely (copy->in_error ()))\n+    return hb_map_get_empty ();\n+\n+  *copy = *map;\n@@ -254,1 +251,1 @@\n- * Return value: %true if @key is found in @map, %false otherwise\n+ * Return value: `true` if @key is found in @map, `false` otherwise\n@@ -286,1 +283,1 @@\n- * Return value: %true if @map is empty\n+ * Return value: `true` if @map is empty\n@@ -320,1 +317,1 @@\n- * Return value: %true if the two maps are equal, %false otherwise.\n+ * Return value: `true` if the two maps are equal, `false` otherwise.\n@@ -342,1 +339,1 @@\n-HB_EXTERN unsigned int\n+unsigned int\n@@ -348,0 +345,75 @@\n+\/**\n+ * hb_map_update:\n+ * @map: A map\n+ * @other: Another map\n+ *\n+ * Add the contents of @other to @map.\n+ *\n+ * Since: 7.0.0\n+ **\/\n+HB_EXTERN void\n+hb_map_update (hb_map_t *map,\n+               const hb_map_t *other)\n+{\n+  map->update (*other);\n+}\n+\n+\/**\n+ * hb_map_next:\n+ * @map: A map\n+ * @idx: (inout): Iterator internal state\n+ * @key: (out): Key retrieved\n+ * @value: (out): Value retrieved\n+ *\n+ * Fetches the next key\/value paire in @map.\n+ *\n+ * Set @idx to -1 to get started.\n+ *\n+ * If the map is modified during iteration, the behavior is undefined.\n+ *\n+ * The order in which the key\/values are returned is undefined.\n+ *\n+ * Return value: `true` if there was a next value, `false` otherwise\n+ *\n+ * Since: 7.0.0\n+ **\/\n+hb_bool_t\n+hb_map_next (const hb_map_t *map,\n+             int *idx,\n+             hb_codepoint_t *key,\n+             hb_codepoint_t *value)\n+{\n+  return map->next (idx, key, value);\n+}\n+\n+\/**\n+ * hb_map_keys:\n+ * @map: A map\n+ * @keys: A set\n+ *\n+ * Add the keys of @map to @keys.\n+ *\n+ * Since: 7.0.0\n+ **\/\n+void\n+hb_map_keys (const hb_map_t *map,\n+             hb_set_t *keys)\n+{\n+  map->keys (*keys);\n+}\n+\n+\/**\n+ * hb_map_values:\n+ * @map: A map\n+ * @values: A set\n+ *\n+ * Add the values of @map to @values.\n+ *\n+ * Since: 7.0.0\n+ **\/\n+void\n+hb_map_values (const hb_map_t *map,\n+               hb_set_t *values)\n+{\n+  map->values (*values);\n+}\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-map.cc","additions":87,"deletions":15,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"hb-set.h\"\n@@ -77,1 +78,1 @@\n-hb_map_get_user_data (hb_map_t           *map,\n+hb_map_get_user_data (const hb_map_t     *map,\n@@ -121,0 +122,18 @@\n+HB_EXTERN void\n+hb_map_update (hb_map_t *map,\n+               const hb_map_t *other);\n+\n+\/* Pass -1 in for idx to get started. *\/\n+HB_EXTERN hb_bool_t\n+hb_map_next (const hb_map_t *map,\n+             int *idx,\n+             hb_codepoint_t *key,\n+             hb_codepoint_t *value);\n+\n+HB_EXTERN void\n+hb_map_keys (const hb_map_t *map,\n+             hb_set_t *keys);\n+\n+HB_EXTERN void\n+hb_map_values (const hb_map_t *map,\n+               hb_set_t *values);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-map.h","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#include \"hb-set.hh\"\n+\n@@ -46,1 +48,1 @@\n-  hb_hashmap_t (const hb_hashmap_t& o) : hb_hashmap_t () { resize (population); hb_copy (o, *this); }\n+  hb_hashmap_t (const hb_hashmap_t& o) : hb_hashmap_t () { resize (o.population); hb_copy (o, *this); }\n@@ -48,1 +50,1 @@\n-  hb_hashmap_t& operator= (const hb_hashmap_t& o)  { resize (population); hb_copy (o, *this); return *this; }\n+  hb_hashmap_t& operator= (const hb_hashmap_t& o)  { reset (); resize (o.population); hb_copy (o, *this); return *this; }\n@@ -74,0 +76,5 @@\n+    item_t () : key (),\n+                hash (0),\n+                is_used_ (false), is_tombstone_ (false),\n+                value () {}\n+\n@@ -91,11 +98,2 @@\n-    void clear ()\n-    {\n-      new (std::addressof (key)) K ();\n-      new (std::addressof (value)) V ();\n-      hash = 0;\n-      is_used_ = false;\n-      is_tombstone_ = false;\n-    }\n-\n-    bool operator == (const K &o) { return hb_deref (key) == hb_deref (o); }\n-    bool operator == (const item_t &o) { return *this == o.key; }\n+    bool operator == (const K &o) const { return hb_deref (key) == hb_deref (o); }\n+    bool operator == (const item_t &o) const { return *this == o.key; }\n@@ -110,2 +108,2 @@\n-  bool successful; \/* Allocations successful *\/\n-  unsigned int population; \/* Not including tombstones. *\/\n+  unsigned int successful : 1; \/* Allocations successful *\/\n+  unsigned int population : 31; \/* Not including tombstones. *\/\n@@ -121,1 +119,4 @@\n-    hb_swap (a.population, b.population);\n+    unsigned tmp = a.population;\n+    a.population = b.population;\n+    b.population = tmp;\n+    \/\/hb_swap (a.population, b.population);\n@@ -127,1 +128,1 @@\n-  void init_shallow ()\n+  void init ()\n@@ -129,0 +130,2 @@\n+    hb_object_init (this);\n+\n@@ -135,6 +138,1 @@\n-  void init ()\n-  {\n-    hb_object_init (this);\n-    init_shallow ();\n-  }\n-  void fini_shallow ()\n+  void fini ()\n@@ -142,0 +140,2 @@\n+    hb_object_fini (this);\n+\n@@ -151,5 +151,0 @@\n-  void fini ()\n-  {\n-    hb_object_fini (this);\n-    fini_shallow ();\n-  }\n@@ -169,1 +164,3 @@\n-    unsigned int power = hb_bit_storage (hb_max (population, new_population) * 2 + 8);\n+    if (new_population != 0 && (new_population + new_population \/ 2) < mask) return true;\n+\n+    unsigned int power = hb_bit_storage (hb_max ((unsigned) population, new_population) * 2 + 8);\n@@ -178,1 +175,1 @@\n-      _.clear ();\n+      new (&_) item_t ();\n@@ -180,1 +177,1 @@\n-    unsigned int old_size = mask + 1;\n+    unsigned int old_size = size ();\n@@ -190,2 +187,3 @@\n-    if (old_items)\n-      for (unsigned int i = 0; i < old_size; i++)\n+    for (unsigned int i = 0; i < old_size; i++)\n+    {\n+      if (old_items[i].is_real ())\n@@ -193,7 +191,3 @@\n-        if (old_items[i].is_real ())\n-        {\n-          set_with_hash (old_items[i].key,\n-                         old_items[i].hash,\n-                         std::move (old_items[i].value));\n-        }\n-        old_items[i].~item_t ();\n+        set_with_hash (std::move (old_items[i].key),\n+                       old_items[i].hash,\n+                       std::move (old_items[i].value));\n@@ -201,0 +195,2 @@\n+      old_items[i].~item_t ();\n+    }\n@@ -207,0 +203,30 @@\n+  template <typename KK, typename VV>\n+  bool set_with_hash (KK&& key, uint32_t hash, VV&& value, bool is_delete=false)\n+  {\n+    if (unlikely (!successful)) return false;\n+    if (unlikely ((occupancy + occupancy \/ 2) >= mask && !resize ())) return false;\n+    item_t &item = item_for_hash (key, hash);\n+\n+    if (is_delete && !(item == key))\n+      return true; \/* Trying to delete non-existent key. *\/\n+\n+    if (item.is_used ())\n+    {\n+      occupancy--;\n+      if (!item.is_tombstone ())\n+        population--;\n+    }\n+\n+    item.key = std::forward<KK> (key);\n+    item.value = std::forward<VV> (value);\n+    item.hash = hash;\n+    item.set_used (true);\n+    item.set_tombstone (is_delete);\n+\n+    occupancy++;\n+    if (!is_delete)\n+      population++;\n+\n+    return true;\n+  }\n+\n@@ -208,1 +234,3 @@\n-  bool set (K key, VV&& value) { return set_with_hash (key, hb_hash (key), std::forward<VV> (value)); }\n+  bool set (const K &key, VV&& value) { return set_with_hash (key, hb_hash (key), std::forward<VV> (value)); }\n+  template <typename VV>\n+  bool set (K &&key, VV&& value) { return set_with_hash (std::move (key), hb_hash (key), std::forward<VV> (value)); }\n@@ -210,1 +238,1 @@\n-  const V& get (K key) const\n+  const V& get_with_hash (const K &key, uint32_t hash) const\n@@ -213,2 +241,7 @@\n-    unsigned int i = bucket_for (key);\n-    return items[i].is_real () && items[i] == key ? items[i].value : item_t::default_value ();\n+    auto &item = item_for_hash (key, hash);\n+    return item.is_real () && item == key ? item.value : item_t::default_value ();\n+  }\n+  const V& get (const K &key) const\n+  {\n+    if (unlikely (!items)) return item_t::default_value ();\n+    return get_with_hash (key, hb_hash (key));\n@@ -217,1 +250,1 @@\n-  void del (K key) { set_with_hash (key, hb_hash (key), item_t::default_value (), true); }\n+  void del (const K &key) { set_with_hash (key, hb_hash (key), item_t::default_value (), true); }\n@@ -220,3 +253,3 @@\n-  typedef const V& value_t;\n-  value_t operator [] (K k) const { return get (k); }\n-  bool has (K key, const V **vp = nullptr) const\n+  const V& operator [] (K k) const { return get (k); }\n+  template <typename VV=V>\n+  bool has (K key, VV **vp = nullptr) const\n@@ -225,2 +258,0 @@\n-    {\n-      if (vp) *vp = &item_t::default_value ();\n@@ -228,3 +259,2 @@\n-    }\n-    unsigned int i = bucket_for (key);\n-    if (items[i].is_real () && items[i] == key)\n+    auto &item = item_for_hash (key, hb_hash (key));\n+    if (item.is_real () && item == key)\n@@ -232,1 +262,1 @@\n-      if (vp) *vp = &items[i].value;\n+      if (vp) *vp = std::addressof (item.value);\n@@ -236,2 +266,0 @@\n-    {\n-      if (vp) *vp = &item_t::default_value ();\n@@ -239,1 +267,0 @@\n-    }\n@@ -244,0 +271,2 @@\n+  unsigned size () const { return mask ? mask + 1 : 0; }\n+\n@@ -248,3 +277,6 @@\n-    if (items)\n-      for (auto &_ : hb_iter (items, mask + 1))\n-        _.clear ();\n+    for (auto &_ : hb_iter (items, size ()))\n+    {\n+      \/* Reconstruct items. *\/\n+      _.~item_t ();\n+      new (&_) item_t ();\n+    }\n@@ -260,5 +292,4 @@\n-    uint32_t h = 0;\n-    for (const auto &item : + hb_array (items, mask ? mask + 1 : 0)\n-                            | hb_filter (&item_t::is_real))\n-      h ^= item.total_hash ();\n-    return h;\n+    return\n+    + iter_items ()\n+    | hb_reduce ([] (uint32_t h, const item_t &_) { return h ^ _.total_hash (); }, (uint32_t) 0u)\n+    ;\n@@ -272,1 +303,1 @@\n-      if (get (pair.first) != pair.second)\n+      if (other.get (pair.first) != pair.second)\n@@ -282,0 +313,17 @@\n+  void update (const hb_hashmap_t &other)\n+  {\n+    if (unlikely (!successful)) return;\n+\n+    hb_copy (other, *this);\n+  }\n+\n+  void keys (hb_set_t &keys_) const\n+  {\n+    hb_copy (keys() , keys_);\n+  }\n+\n+  void values (hb_set_t &values_) const\n+  {\n+    hb_copy (values() , values_);\n+  }\n+\n@@ -285,1 +333,2 @@\n-  auto iter () const HB_AUTO_RETURN\n+\n+  auto iter_items () const HB_AUTO_RETURN\n@@ -287,1 +336,1 @@\n-    + hb_array (items, mask ? mask + 1 : 0)\n+    + hb_iter (items, size ())\n@@ -289,1 +338,0 @@\n-    | hb_map (&item_t::get_pair)\n@@ -293,2 +341,1 @@\n-    + hb_array (items, mask ? mask + 1 : 0)\n-    | hb_filter (&item_t::is_real)\n+    + iter_items ()\n@@ -297,1 +344,1 @@\n-  auto keys () const HB_AUTO_RETURN\n+  auto iter () const HB_AUTO_RETURN\n@@ -299,2 +346,6 @@\n-    + hb_array (items, mask ? mask + 1 : 0)\n-    | hb_filter (&item_t::is_real)\n+    + iter_items ()\n+    | hb_map (&item_t::get_pair)\n+  )\n+  auto keys_ref () const HB_AUTO_RETURN\n+  (\n+    + iter_items ()\n@@ -302,0 +353,4 @@\n+  )\n+  auto keys () const HB_AUTO_RETURN\n+  (\n+    + keys_ref ()\n@@ -304,1 +359,1 @@\n-  auto values () const HB_AUTO_RETURN\n+  auto values_ref () const HB_AUTO_RETURN\n@@ -306,2 +361,1 @@\n-    + hb_array (items, mask ? mask + 1 : 0)\n-    | hb_filter (&item_t::is_real)\n+    + iter_items ()\n@@ -309,0 +363,4 @@\n+  )\n+  auto values () const HB_AUTO_RETURN\n+  (\n+    + values_ref ()\n@@ -312,8 +370,4 @@\n-  \/* Sink interface. *\/\n-  hb_hashmap_t& operator << (const hb_pair_t<K, V>& v)\n-  { set (v.first, v.second); return *this; }\n-\n-  protected:\n-\n-  template <typename VV>\n-  bool set_with_hash (K key, uint32_t hash, VV&& value, bool is_delete=false)\n+  \/* C iterator. *\/\n+  bool next (int *idx,\n+             K *key,\n+             V *value) const\n@@ -321,3 +375,1 @@\n-    if (unlikely (!successful)) return false;\n-    if (unlikely ((occupancy + occupancy \/ 2) >= mask && !resize ())) return false;\n-    unsigned int i = bucket_for_hash (key, hash);\n+    unsigned i = (unsigned) (*idx + 1);\n@@ -325,2 +377,3 @@\n-    if (is_delete && items[i].key != key)\n-      return true; \/* Trying to delete non-existent key. *\/\n+    unsigned count = size ();\n+    while (i < count && !items[i].is_real ())\n+      i++;\n@@ -328,1 +381,1 @@\n-    if (items[i].is_used ())\n+    if (i >= count)\n@@ -330,3 +383,2 @@\n-      occupancy--;\n-      if (!items[i].is_tombstone ())\n-        population--;\n+      *idx = -1;\n+      return false;\n@@ -335,9 +387,2 @@\n-    items[i].key = key;\n-    items[i].value = std::forward<VV> (value);\n-    items[i].hash = hash;\n-    items[i].set_used (true);\n-    items[i].set_tombstone (is_delete);\n-\n-    occupancy++;\n-    if (!is_delete)\n-      population++;\n+    *key = items[i].key;\n+    *value = items[i].value;\n@@ -345,0 +390,1 @@\n+    *idx = (signed) i;\n@@ -348,6 +394,11 @@\n-  unsigned int bucket_for (const K &key) const\n-  {\n-    return bucket_for_hash (key, hb_hash (key));\n-  }\n-\n-  unsigned int bucket_for_hash (const K &key, uint32_t hash) const\n+  \/* Sink interface. *\/\n+  hb_hashmap_t& operator << (const hb_pair_t<K, V>& v)\n+  { set (v.first, v.second); return *this; }\n+  hb_hashmap_t& operator << (const hb_pair_t<K, V&&>& v)\n+  { set (v.first, std::move (v.second)); return *this; }\n+  hb_hashmap_t& operator << (const hb_pair_t<K&&, V>& v)\n+  { set (std::move (v.first), v.second); return *this; }\n+  hb_hashmap_t& operator << (const hb_pair_t<K&&, V&&>& v)\n+  { set (std::move (v.first), std::move (v.second)); return *this; }\n+\n+  item_t& item_for_hash (const K &key, uint32_t hash) const\n@@ -362,1 +413,1 @@\n-        return i;\n+        return items[i];\n@@ -367,1 +418,1 @@\n-    return tombstone == (unsigned) -1 ? i : tombstone;\n+    return items[tombstone == (unsigned) -1 ? i : tombstone];\n@@ -446,0 +497,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-map.hh","additions":163,"deletions":111,"binary":false,"changes":274,"status":"modified"},{"patch":"@@ -115,2 +115,1 @@\n-\/* TODO Add feature-parity to std::decay. *\/\n-template <typename T> using hb_decay = hb_remove_const<hb_remove_reference<T>>;\n+template <typename T> using hb_decay = typename std::decay<T>::type;\n@@ -136,0 +135,12 @@\n+\n+  template <typename T> constexpr auto\n+  operator () (const hb::shared_ptr<T>& v) const HB_AUTO_RETURN (*v)\n+\n+  template <typename T> constexpr auto\n+  operator () (hb::shared_ptr<T>& v) const HB_AUTO_RETURN (*v)\n+\n+  template <typename T> constexpr auto\n+  operator () (const hb::unique_ptr<T>& v) const HB_AUTO_RETURN (*v)\n+\n+  template <typename T> constexpr auto\n+  operator () (hb::unique_ptr<T>& v) const HB_AUTO_RETURN (*v)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-meta.hh","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright © 2022  Behdad Esfahbod\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_MULTIMAP_HH\n+#define HB_MULTIMAP_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-map.hh\"\n+#include \"hb-vector.hh\"\n+\n+\n+\/*\n+ * hb_multimap_t\n+ *\/\n+\n+struct hb_multimap_t\n+{\n+  void add (hb_codepoint_t k, hb_codepoint_t v)\n+  {\n+    hb_codepoint_t *i;\n+    if (multiples_indices.has (k, &i))\n+    {\n+      multiples_values[*i].push (v);\n+      return;\n+    }\n+\n+    hb_codepoint_t *old_v;\n+    if (singulars.has (k, &old_v))\n+    {\n+      hb_codepoint_t old = *old_v;\n+      singulars.del (k);\n+\n+      multiples_indices.set (k, multiples_values.length);\n+      auto *vec = multiples_values.push ();\n+\n+      vec->push (old);\n+      vec->push (v);\n+\n+      return;\n+    }\n+\n+    singulars.set (k, v);\n+  }\n+\n+  hb_array_t<const hb_codepoint_t> get (hb_codepoint_t k) const\n+  {\n+    const hb_codepoint_t *v;\n+    if (singulars.has (k, &v))\n+      return hb_array (v, 1);\n+\n+    hb_codepoint_t *i;\n+    if (multiples_indices.has (k, &i))\n+      return multiples_values[*i].as_array ();\n+\n+    return hb_array_t<const hb_codepoint_t> ();\n+  }\n+\n+  bool in_error () const\n+  {\n+    return singulars.in_error () || multiples_indices.in_error () || multiples_values.in_error ();\n+  }\n+\n+  protected:\n+  hb_map_t singulars;\n+  hb_map_t multiples_indices;\n+  hb_vector_t<hb_vector_t<hb_codepoint_t>> multiples_values;\n+};\n+\n+\n+\n+#endif \/* HB_MULTIMAP_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-multimap.hh","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -63,1 +63,1 @@\n-#if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)\n+#if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)\n@@ -100,0 +100,3 @@\n+  hb_mutex_t () { init (); }\n+  ~hb_mutex_t () { fini (); }\n+\n@@ -111,2 +114,3 @@\n-  hb_lock_t (hb_mutex_t &mutex_) : mutex (mutex_) { mutex.lock (); }\n-  ~hb_lock_t () { mutex.unlock (); }\n+  hb_lock_t (hb_mutex_t &mutex_) : mutex (&mutex_) { mutex->lock (); }\n+  hb_lock_t (hb_mutex_t *mutex_) : mutex (mutex_) { if (mutex) mutex->lock (); }\n+  ~hb_lock_t () { if (mutex) mutex->unlock (); }\n@@ -114,1 +118,1 @@\n-  hb_mutex_t &mutex;\n+  hb_mutex_t *mutex;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-mutex.hh","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,0 +42,18 @@\n+template <typename T, typename>\n+struct _hb_has_min_size : hb_false_type {};\n+template <typename T>\n+struct _hb_has_min_size<T, hb_void_t<decltype (T::min_size)>>\n+        : hb_true_type {};\n+template <typename T>\n+using hb_has_min_size = _hb_has_min_size<T, void>;\n+#define hb_has_min_size(T) hb_has_min_size<T>::value\n+\n+template <typename T, typename>\n+struct _hb_has_null_size : hb_false_type {};\n+template <typename T>\n+struct _hb_has_null_size<T, hb_void_t<decltype (T::null_size)>>\n+        : hb_true_type {};\n+template <typename T>\n+using hb_has_null_size = _hb_has_null_size<T, void>;\n+#define hb_has_null_size(T) hb_has_null_size<T>::value\n+\n@@ -120,0 +138,11 @@\n+#define DECLARE_NULL_NAMESPACE_BYTES_TEMPLATE1(Namespace, Type, Size) \\\n+        } \/* Close namespace. *\/ \\\n+        extern HB_INTERNAL const unsigned char _hb_Null_##Namespace##_##Type[Size]; \\\n+        template <typename Spec> \\\n+        struct Null<Namespace::Type<Spec>> { \\\n+          static Namespace::Type<Spec> const & get_null () { \\\n+            return *reinterpret_cast<const Namespace::Type<Spec> *> (_hb_Null_##Namespace##_##Type); \\\n+          } \\\n+        }; \\\n+        namespace Namespace { \\\n+        static_assert (true, \"\") \/* Require semicolon after. *\/\n@@ -121,1 +150,1 @@\n-        const unsigned char _hb_Null_##Namespace##_##Type[hb_null_size (Namespace::Type)]\n+        const unsigned char _hb_Null_##Namespace##_##Type[sizeof (_hb_Null_##Namespace##_##Type)]\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-null.hh","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#line 35 \"hb-number-parser.hh\"\n+#line 32 \"hb-number-parser.hh\"\n@@ -138,1 +138,1 @@\n-#line 139 \"hb-number-parser.hh\"\n+#line 132 \"hb-number-parser.hh\"\n@@ -143,1 +143,1 @@\n-#line 144 \"hb-number-parser.hh\"\n+#line 135 \"hb-number-parser.hh\"\n@@ -201,1 +201,1 @@\n-#line 202 \"hb-number-parser.hh\"\n+#line 187 \"hb-number-parser.hh\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-number-parser.hh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"hb-machinery.hh\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-number.cc","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    return item;\n+    return items.in_error () ? nullptr : item;\n@@ -83,1 +83,1 @@\n-      *item = items[items.length - 1];\n+      *item = std::move (items.tail ());\n@@ -126,1 +126,1 @@\n-      item_t old = items[items.length - 1];\n+      item_t old = items.tail ();\n@@ -147,2 +147,2 @@\n-  void init (int v = 1) { ref_count.set_relaxed (v); }\n-  int get_relaxed () const { return ref_count.get_relaxed (); }\n+  void init (int v = 1) { ref_count = v; }\n+  int get_relaxed () const { return ref_count; }\n@@ -151,1 +151,1 @@\n-  void fini () { ref_count.set_relaxed (-0x0000DEAD); }\n+  void fini () { ref_count = -0x0000DEAD; }\n@@ -153,2 +153,2 @@\n-  bool is_inert () const { return !ref_count.get_relaxed (); }\n-  bool is_valid () const { return ref_count.get_relaxed () > 0; }\n+  bool is_inert () const { return !ref_count; }\n+  bool is_valid () const { return ref_count > 0; }\n@@ -178,4 +178,9 @@\n-  HB_INTERNAL bool set (hb_user_data_key_t *key,\n-                        void *              data,\n-                        hb_destroy_func_t   destroy,\n-                        hb_bool_t           replace);\n+  void fini () { items.fini (lock); lock.fini (); }\n+\n+  bool set (hb_user_data_key_t *key,\n+            void *              data,\n+            hb_destroy_func_t   destroy,\n+            hb_bool_t           replace)\n+  {\n+    if (!key)\n+      return false;\n@@ -183,1 +188,8 @@\n-  HB_INTERNAL void *get (hb_user_data_key_t *key);\n+    if (replace) {\n+      if (!data && !destroy) {\n+        items.remove (key, lock);\n+        return true;\n+      }\n+    }\n+    hb_user_data_item_t item = {key, data, destroy};\n+    bool ret = !!items.replace_or_insert (item, lock, (bool) replace);\n@@ -185,1 +197,9 @@\n-  void fini () { items.fini (lock); lock.fini (); }\n+    return ret;\n+  }\n+\n+  void *get (hb_user_data_key_t *key)\n+  {\n+    hb_user_data_item_t item = {nullptr, nullptr, nullptr};\n+\n+    return items.find (key, &item, lock) ? item.data : nullptr;\n+  }\n@@ -217,2 +237,2 @@\n-template <typename Type>\n-static inline Type *hb_object_create ()\n+template <typename Type, typename ...Ts>\n+static inline Type *hb_object_create (Ts... ds)\n@@ -225,0 +245,2 @@\n+  new (obj) Type (std::forward<Ts> (ds)...);\n+\n@@ -227,0 +249,1 @@\n+\n@@ -233,1 +256,1 @@\n-  obj->header.writable.set_relaxed (true);\n+  obj->header.writable = true;\n@@ -244,1 +267,1 @@\n-  return !obj->header.writable.get_relaxed ();\n+  return !obj->header.writable;\n@@ -249,1 +272,1 @@\n-  obj->header.writable.set_relaxed (false);\n+  obj->header.writable = false;\n@@ -272,0 +295,4 @@\n+\n+  if (!std::is_trivially_destructible<Type>::value)\n+    obj->~Type ();\n+\n@@ -278,1 +305,1 @@\n-  hb_user_data_array_t *user_data = obj->header.user_data.get ();\n+  hb_user_data_array_t *user_data = obj->header.user_data.get_acquire ();\n@@ -283,1 +310,1 @@\n-    user_data = nullptr;\n+    obj->header.user_data.set_relaxed (nullptr);\n@@ -298,1 +325,1 @@\n-  hb_user_data_array_t *user_data = obj->header.user_data.get ();\n+  hb_user_data_array_t *user_data = obj->header.user_data.get_acquire ();\n@@ -323,1 +350,1 @@\n-  hb_user_data_array_t *user_data = obj->header.user_data.get ();\n+  hb_user_data_array_t *user_data = obj->header.user_data.get_acquire ();\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-object.hh","additions":50,"deletions":23,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-      + tables.sub_array (start_offset, table_count)\n+      + tables.as_array ().sub_array (start_offset, table_count)\n@@ -161,1 +161,1 @@\n-        memcpy (start, blob->data, len);\n+        hb_memcpy (start, blob->data, len);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-open-file.hh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n@@ -144,2 +144,2 @@\n-\/* 16-bit signed fixed number with the low 14 bits of fraction (2.14). *\/\n-struct F2DOT14 : HBINT16\n+template <typename Type, unsigned fraction_bits>\n+struct HBFixed : Type\n@@ -147,4 +147,9 @@\n-  F2DOT14& operator = (uint16_t i ) { HBINT16::operator= (i); return *this; }\n-  \/\/ 16384 means 1<<14\n-  float to_float () const  { return ((int32_t) v) \/ 16384.f; }\n-  void set_float (float f) { v = roundf (f * 16384.f); }\n+  static constexpr float shift = (float) (1 << fraction_bits);\n+  static_assert (Type::static_size * 8 > fraction_bits, \"\");\n+\n+  operator signed () const = delete;\n+  operator unsigned () const = delete;\n+  typename Type::type to_int () const { return Type::v; }\n+  void set_int (typename Type::type i ) { Type::v = i; }\n+  float to_float (float offset = 0) const  { return ((int32_t) Type::v + offset) \/ shift; }\n+  void set_float (float f) { Type::v = roundf (f * shift); }\n@@ -152,1 +157,1 @@\n-  DEFINE_SIZE_STATIC (2);\n+  DEFINE_SIZE_STATIC (Type::static_size);\n@@ -155,0 +160,5 @@\n+\/* 16-bit signed fixed number with the low 14 bits of fraction (2.14). *\/\n+using F2DOT14 = HBFixed<HBINT16, 14>;\n+using F4DOT12 = HBFixed<HBINT16, 12>;\n+using F6DOT10 = HBFixed<HBINT16, 10>;\n+\n@@ -156,9 +166,1 @@\n-struct HBFixed : HBINT32\n-{\n-  HBFixed& operator = (uint32_t i) { HBINT32::operator= (i); return *this; }\n-  \/\/ 65536 means 1<<16\n-  float to_float () const  { return ((int32_t) v) \/ 65536.f; }\n-  void set_float (float f) { v = roundf (f * 65536.f); }\n-  public:\n-  DEFINE_SIZE_STATIC (4);\n-};\n+using F16DOT16 = HBFixed<HBINT32, 16>;\n@@ -173,1 +175,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n@@ -199,0 +201,4 @@\n+struct HBGlyphID24 : HBUINT24\n+{\n+  HBGlyphID24& operator = (uint32_t i) { HBUINT24::operator= (i); return *this; }\n+};\n@@ -211,0 +217,6 @@\n+  static_assert (NO_VARIATION == HB_OT_LAYOUT_NO_VARIATIONS_INDEX, \"\");\n+  static uint32_t add (uint32_t i, unsigned short v)\n+  {\n+    if (i == NO_VARIATION) return i;\n+    return i + v;\n+  }\n@@ -303,0 +315,4 @@\n+  \/\/ Make sure Type is not unbounded; works only for types that are fully defined at OffsetTo time.\n+  static_assert (has_null == false ||\n+                 (hb_has_null_size (Type) || !hb_has_min_size (Type)), \"\");\n+\n@@ -453,1 +469,2 @@\n-    if (unlikely (p < arrayZ)) return Null (Type); \/* Overflowed. *\/\n+    if (unlikely ((const void *) p < (const void *) arrayZ)) return Null (Type); \/* Overflowed. *\/\n+    _hb_compiler_memory_r_barrier ();\n@@ -460,1 +477,2 @@\n-    if (unlikely (p < arrayZ)) return Crap (Type); \/* Overflowed. *\/\n+    if (unlikely ((const void *) p < (const void *) arrayZ)) return Crap (Type); \/* Overflowed. *\/\n+    _hb_compiler_memory_r_barrier ();\n@@ -489,1 +507,1 @@\n-  bool serialize (hb_serialize_context_t *c, unsigned int items_len)\n+  bool serialize (hb_serialize_context_t *c, unsigned int items_len, bool clear = true)\n@@ -492,1 +510,1 @@\n-    if (unlikely (!c->extend (this, items_len))) return_trace (false);\n+    if (unlikely (!c->extend_size (this, get_size (items_len), clear))) return_trace (false);\n@@ -500,2 +518,2 @@\n-    unsigned count = items.len ();\n-    if (unlikely (!serialize (c, count))) return_trace (false);\n+    unsigned count = hb_len (items);\n+    if (unlikely (!serialize (c, count, false))) return_trace (false);\n@@ -553,1 +571,2 @@\n-    if (unlikely (p < this->arrayZ)) return Null (Type); \/* Overflowed. *\/\n+    if (unlikely ((const void *) p < (const void *) this->arrayZ)) return Null (Type); \/* Overflowed. *\/\n+    _hb_compiler_memory_r_barrier ();\n@@ -560,1 +579,2 @@\n-    if (unlikely (p < this->arrayZ)) return Crap (Type); \/* Overflowed. *\/\n+    if (unlikely ((const void *) p < (const void *) this->arrayZ)) return Crap (Type); \/* Overflowed. *\/\n+    _hb_compiler_memory_r_barrier ();\n@@ -611,0 +631,1 @@\n+    _hb_compiler_memory_r_barrier ();\n@@ -617,0 +638,1 @@\n+    _hb_compiler_memory_r_barrier ();\n@@ -638,8 +660,3 @@\n-  hb_array_t<const Type> sub_array (unsigned int start_offset, unsigned int count) const\n-  { return as_array ().sub_array (start_offset, count); }\n-  hb_array_t<const Type> sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/) const\n-  { return as_array ().sub_array (start_offset, count); }\n-  hb_array_t<Type> sub_array (unsigned int start_offset, unsigned int count)\n-  { return as_array ().sub_array (start_offset, count); }\n-  hb_array_t<Type> sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/)\n-  { return as_array ().sub_array (start_offset, count); }\n+  \/* Faster range-based for loop. *\/\n+  const Type *begin () const { return arrayZ; }\n+  const Type *end () const { return arrayZ + len; }\n@@ -659,2 +676,2 @@\n-  void qsort (unsigned int start = 0, unsigned int end = (unsigned int) -1)\n-  { as_array ().qsort (start, end); }\n+  void qsort ()\n+  { as_array ().qsort (); }\n@@ -662,1 +679,1 @@\n-  HB_NODISCARD bool serialize (hb_serialize_context_t *c, unsigned items_len)\n+  HB_NODISCARD bool serialize (hb_serialize_context_t *c, unsigned items_len, bool clear = true)\n@@ -667,1 +684,1 @@\n-    if (unlikely (!c->extend (this))) return_trace (false);\n+    if (unlikely (!c->extend_size (this, get_size (), clear))) return_trace (false);\n@@ -675,2 +692,2 @@\n-    unsigned count = items.len ();\n-    if (unlikely (!serialize (c, count))) return_trace (false);\n+    unsigned count = hb_len (items);\n+    if (unlikely (!serialize (c, count, false))) return_trace (false);\n@@ -732,0 +749,1 @@\n+template <typename Type> using Array24Of = ArrayOf<Type, HBUINT24>;\n@@ -741,2 +759,2 @@\n-template <typename Type>\n-struct List16OfOffset16To : Array16OfOffset16To<Type>\n+template <typename Type, typename OffsetType>\n+struct List16OfOffsetTo : ArrayOf<OffsetTo<Type, OffsetType>, HBUINT16>\n@@ -748,0 +766,1 @@\n+    _hb_compiler_memory_r_barrier ();\n@@ -754,0 +773,1 @@\n+    _hb_compiler_memory_r_barrier ();\n@@ -760,1 +780,1 @@\n-    struct List16OfOffset16To<Type> *out = c->serializer->embed (*this);\n+    struct List16OfOffsetTo *out = c->serializer->embed (*this);\n@@ -772,1 +792,1 @@\n-    return_trace (Array16OfOffset16To<Type>::sanitize (c, this, std::forward<Ts> (ds)...));\n+    return_trace ((Array16Of<OffsetTo<Type, OffsetType>>::sanitize (c, this, std::forward<Ts> (ds)...)));\n@@ -776,0 +796,3 @@\n+template <typename Type>\n+using List16OfOffset16To = List16OfOffsetTo<Type, HBUINT16>;\n+\n@@ -788,0 +811,1 @@\n+    _hb_compiler_memory_r_barrier ();\n@@ -794,0 +818,1 @@\n+    _hb_compiler_memory_r_barrier ();\n@@ -812,1 +837,5 @@\n-  bool serialize (hb_serialize_context_t *c, unsigned int items_len)\n+  \/* Faster range-based for loop. *\/\n+  const Type *begin () const { return arrayZ; }\n+  const Type *end () const { return arrayZ + get_length (); }\n+\n+  HB_NODISCARD bool serialize (hb_serialize_context_t *c, unsigned int items_len, bool clear = true)\n@@ -817,1 +846,1 @@\n-    if (unlikely (!c->extend (this))) return_trace (false);\n+    if (unlikely (!c->extend_size (this, get_size (), clear))) return_trace (false);\n@@ -822,1 +851,1 @@\n-  bool serialize (hb_serialize_context_t *c, Iterator items)\n+  HB_NODISCARD bool serialize (hb_serialize_context_t *c, Iterator items)\n@@ -825,2 +854,2 @@\n-    unsigned count = items.len ();\n-    if (unlikely (!serialize (c, count))) return_trace (false);\n+    unsigned count = hb_len (items);\n+    if (unlikely (!serialize (c, count, false))) return_trace (false);\n@@ -872,0 +901,1 @@\n+    _hb_compiler_memory_r_barrier ();\n@@ -878,0 +908,1 @@\n+    _hb_compiler_memory_r_barrier ();\n@@ -926,8 +957,3 @@\n-  hb_sorted_array_t<const Type> sub_array (unsigned int start_offset, unsigned int count) const\n-  { return as_array ().sub_array (start_offset, count); }\n-  hb_sorted_array_t<const Type> sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/) const\n-  { return as_array ().sub_array (start_offset, count); }\n-  hb_sorted_array_t<Type> sub_array (unsigned int start_offset, unsigned int count)\n-  { return as_array ().sub_array (start_offset, count); }\n-  hb_sorted_array_t<Type> sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/)\n-  { return as_array ().sub_array (start_offset, count); }\n+  \/* Faster range-based for loop. *\/\n+  const Type *begin () const { return this->arrayZ; }\n+  const Type *end () const { return this->arrayZ + this->len; }\n@@ -964,0 +990,1 @@\n+template <typename Type> using SortedArray24Of = SortedArrayOf<Type, HBUINT24>;\n@@ -1056,0 +1083,1 @@\n+    _hb_compiler_memory_r_barrier ();\n@@ -1062,0 +1090,1 @@\n+    _hb_compiler_memory_r_barrier ();\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-open-type.hh","additions":86,"deletions":57,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    CFFIndex *out = c->allocate_size<CFFIndex> (size);\n+    CFFIndex *out = c->allocate_size<CFFIndex> (size, false);\n@@ -71,1 +71,1 @@\n-      memcpy (out, this, size);\n+      hb_memcpy (out, this, size);\n@@ -75,0 +75,2 @@\n+  template <typename Iterable,\n+            hb_requires (hb_is_iterable (Iterable))>\n@@ -76,2 +78,1 @@\n-                  unsigned int offSize_,\n-                  const byte_str_array_t &byteArray)\n+                  const Iterable &iterable)\n@@ -80,59 +81,2 @@\n-\n-    if (byteArray.length == 0)\n-    {\n-      COUNT *dest = c->allocate_min<COUNT> ();\n-      if (unlikely (!dest)) return_trace (false);\n-      *dest = 0;\n-      return_trace (true);\n-    }\n-\n-    \/* serialize CFFIndex header *\/\n-    if (unlikely (!c->extend_min (this))) return_trace (false);\n-    this->count = byteArray.length;\n-    this->offSize = offSize_;\n-    if (unlikely (!c->allocate_size<HBUINT8> (offSize_ * (byteArray.length + 1))))\n-      return_trace (false);\n-\n-    \/* serialize indices *\/\n-    unsigned int  offset = 1;\n-    unsigned int  i = 0;\n-    for (; i < byteArray.length; i++)\n-    {\n-      set_offset_at (i, offset);\n-      offset += byteArray[i].get_size ();\n-    }\n-    set_offset_at (i, offset);\n-\n-    \/* serialize data *\/\n-    for (unsigned int i = 0; i < byteArray.length; i++)\n-    {\n-      const hb_ubytes_t &bs = byteArray[i];\n-      unsigned char *dest = c->allocate_size<unsigned char> (bs.length);\n-      if (unlikely (!dest)) return_trace (false);\n-      memcpy (dest, &bs[0], bs.length);\n-    }\n-\n-    return_trace (true);\n-  }\n-\n-  bool serialize (hb_serialize_context_t *c,\n-                  unsigned int offSize_,\n-                  const str_buff_vec_t &buffArray)\n-  {\n-    byte_str_array_t  byteArray;\n-    byteArray.init ();\n-    byteArray.resize (buffArray.length);\n-    for (unsigned int i = 0; i < byteArray.length; i++)\n-      byteArray[i] = hb_ubytes_t (buffArray[i].arrayZ, buffArray[i].length);\n-    bool result = this->serialize (c, offSize_, byteArray);\n-    byteArray.fini ();\n-    return result;\n-  }\n-\n-  template <typename Iterator,\n-            hb_requires (hb_is_iterator (Iterator))>\n-  bool serialize (hb_serialize_context_t *c,\n-                  Iterator it)\n-  {\n-    TRACE_SERIALIZE (this);\n-    serialize_header(c, + it | hb_map ([] (const hb_ubytes_t &_) { return _.length; }));\n+    auto it = hb_iter (iterable);\n+    serialize_header(c, + it | hb_map (hb_iter) | hb_map (hb_len));\n@@ -140,1 +84,1 @@\n-      _.copy (c);\n+      hb_iter (_).copy (c);\n@@ -144,14 +88,0 @@\n-  bool serialize (hb_serialize_context_t *c,\n-                  const byte_str_array_t &byteArray)\n-  { return serialize (c, + hb_iter (byteArray)); }\n-\n-  bool serialize (hb_serialize_context_t *c,\n-                  const str_buff_vec_t &buffArray)\n-  {\n-    auto it =\n-    + hb_iter (buffArray)\n-    | hb_map ([] (const str_buff_t &_) { return hb_ubytes_t (_.arrayZ, _.length); })\n-    ;\n-    return serialize (c, it);\n-  }\n-\n@@ -174,1 +104,1 @@\n-    if (unlikely (!c->allocate_size<HBUINT8> (off_size * (this->count + 1))))\n+    if (unlikely (!c->allocate_size<HBUINT8> (off_size * (this->count + 1), false)))\n@@ -182,1 +112,1 @@\n-      CFFIndex<COUNT>::set_offset_at (i++, offset);\n+      set_offset_at (i++, offset);\n@@ -185,1 +115,1 @@\n-    CFFIndex<COUNT>::set_offset_at (i, offset);\n+    set_offset_at (i, offset);\n@@ -190,0 +120,13 @@\n+  template <typename Iterable,\n+            hb_requires (hb_is_iterable (Iterable))>\n+  static unsigned total_size (const Iterable &iterable)\n+  {\n+    auto it = + hb_iter (iterable) | hb_map (hb_iter) | hb_map (hb_len);\n+    if (!it) return 0;\n+\n+    unsigned total = + it | hb_reduce (hb_add, 0);\n+    unsigned off_size = (hb_bit_storage (total + 1) + 7) \/ 8;\n+\n+    return min_size + HBUINT8::static_size + (hb_len (it) + 1) * off_size + total;\n+  }\n+\n@@ -210,4 +153,8 @@\n-    unsigned int offset = 0;\n-    for (; size; size--)\n-      offset = (offset << 8) + *p++;\n-    return offset;\n+    switch (size)\n+    {\n+      case 1: return * (HBUINT8  *) p;\n+      case 2: return * (HBUINT16 *) p;\n+      case 3: return * (HBUINT24 *) p;\n+      case 4: return * (HBUINT32 *) p;\n+      default: return 0;\n+    }\n@@ -232,0 +179,1 @@\n+    _hb_compiler_memory_r_barrier ();\n@@ -283,1 +231,1 @@\n-    if (unlikely (!c->allocate_size<HBUINT8> (offSize_ * (dataArrayLen + 1))))\n+    if (unlikely (!c->allocate_size<HBUINT8> (offSize_ * (dataArrayLen + 1), false)))\n@@ -291,1 +239,1 @@\n-      CFFIndex<COUNT>::set_offset_at (i, offset);\n+      this->set_offset_at (i, offset);\n@@ -294,1 +242,1 @@\n-    CFFIndex<COUNT>::set_offset_at (i, offset);\n+    this->set_offset_at (i, offset);\n@@ -327,2 +275,1 @@\n-    \/\/ XXX: not sure why but LLVM fails to compile the following 'unlikely' macro invocation\n-    if (\/*unlikely*\/ (!serialize_int<T, V> (c, intOp, value)))\n+    if (unlikely ((!serialize_int<T, V> (c, intOp, value))))\n@@ -333,1 +280,1 @@\n-    HBUINT8 *p = c->allocate_size<HBUINT8> (OpCode_Size (op));\n+    HBUINT8 *p = c->allocate_size<HBUINT8> (OpCode_Size (op), false);\n@@ -418,3 +365,2 @@\n-    for (unsigned int i = 0; i < c->get_num_glyphs (); i++)\n-      if (unlikely (!fds[i].sanitize (c)))\n-        return_trace (false);\n+    if (unlikely (!c->check_array (fds, c->get_num_glyphs ())))\n+      return_trace (false);\n@@ -474,1 +420,1 @@\n-  hb_codepoint_t get_fd (hb_codepoint_t glyph) const\n+  static int _cmp_range (const void *_key, const void *_item)\n@@ -476,4 +422,2 @@\n-    unsigned int i;\n-    for (i = 1; i < nRanges (); i++)\n-      if (glyph < ranges[i].first)\n-        break;\n+    hb_codepoint_t glyph = * (hb_codepoint_t *) _key;\n+    FDSelect3_4_Range<GID_TYPE, FD_TYPE> *range = (FDSelect3_4_Range<GID_TYPE, FD_TYPE> *) _item;\n@@ -481,1 +425,9 @@\n-    return (hb_codepoint_t) ranges[i - 1].fd;\n+    if (glyph < range[0].first) return -1;\n+    if (glyph < range[1].first) return 0;\n+    return +1;\n+  }\n+\n+  hb_codepoint_t get_fd (hb_codepoint_t glyph) const\n+  {\n+    auto *range = hb_bsearch (glyph, &ranges[0], nRanges () - 1, sizeof (ranges[0]), _cmp_range);\n+    return range ? range->fd : ranges[nRanges () - 1].fd;\n@@ -504,1 +456,1 @@\n-    FDSelect *dest = c->allocate_size<FDSelect> (size);\n+    FDSelect *dest = c->allocate_size<FDSelect> (size, false);\n@@ -506,1 +458,1 @@\n-    memcpy (dest, &src, size);\n+    hb_memcpy (dest, &src, size);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cff-common.hh","additions":54,"deletions":102,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -425,2 +425,2 @@\n-    extents->x_bearing = font->em_scalef_x (bounds.min.x.to_real ());\n-    extents->width = font->em_scalef_x (bounds.max.x.to_real ()) - extents->x_bearing;\n+    extents->x_bearing = roundf (bounds.min.x.to_real ());\n+    extents->width = roundf (bounds.max.x.to_real () - extents->x_bearing);\n@@ -435,2 +435,2 @@\n-    extents->y_bearing = font->em_scalef_y (bounds.max.y.to_real ());\n-    extents->height = font->em_scalef_y (bounds.min.y.to_real ()) - extents->y_bearing;\n+    extents->y_bearing = roundf (bounds.max.y.to_real ());\n+    extents->height = roundf (bounds.min.y.to_real () - extents->y_bearing);\n@@ -439,0 +439,2 @@\n+  font->scale_glyph_extents (extents);\n+\n@@ -554,0 +556,9 @@\n+bool OT::cff1::accelerator_t::paint_glyph (hb_font_t *font, hb_codepoint_t glyph, hb_paint_funcs_t *funcs, void *data, hb_color_t foreground) const\n+{\n+  funcs->push_clip_glyph (data, glyph, font);\n+  funcs->color (data, true, foreground);\n+  funcs->pop_clip (data);\n+\n+  return true;\n+}\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cff1-table.cc","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"hb-paint.hh\"\n@@ -178,1 +179,1 @@\n-    memcpy (dest, &src, size);\n+    hb_memcpy (dest, &src, size);\n@@ -474,1 +475,1 @@\n-    memcpy (dest, &src, size);\n+    hb_memcpy (dest, &src, size);\n@@ -620,1 +621,0 @@\n-    bytesArray.init ();\n@@ -631,1 +631,0 @@\n-    bytesArray.fini ();\n@@ -816,1 +815,1 @@\n-        env.last_offset = env.str_ref.offset;\n+        env.last_offset = env.str_ref.get_offset ();\n@@ -906,2 +905,0 @@\n-        env.clear_args ();\n-        break;\n@@ -919,1 +916,0 @@\n-        val.single_val = env.argStack.pop_num ();\n@@ -1298,1 +1294,0 @@\n-    hb_blob_t              *blob = nullptr;\n@@ -1302,0 +1297,1 @@\n+    hb_blob_t               *blob = nullptr;\n@@ -1348,0 +1344,1 @@\n+      if (unlikely (glyph >= num_glyphs)) return false;\n@@ -1382,1 +1379,1 @@\n-      hb_sorted_vector_t<gname_t> *names = glyph_names.get ();\n+      hb_sorted_vector_t<gname_t> *names = glyph_names.get_acquire ();\n@@ -1431,0 +1428,1 @@\n+    HB_INTERNAL bool paint_glyph (hb_font_t *font, hb_codepoint_t glyph, hb_paint_funcs_t *funcs, void *data, hb_color_t foreground) const;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cff1-table.hh","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -127,2 +127,2 @@\n-    extents->x_bearing = font->em_scalef_x (param.min_x.to_real ());\n-    extents->width = font->em_scalef_x (param.max_x.to_real ()) - extents->x_bearing;\n+    extents->x_bearing = roundf (param.min_x.to_real ());\n+    extents->width = roundf (param.max_x.to_real () - extents->x_bearing);\n@@ -137,2 +137,2 @@\n-    extents->y_bearing = font->em_scalef_y (param.max_y.to_real ());\n-    extents->height = font->em_scalef_y (param.min_y.to_real ()) - extents->y_bearing;\n+    extents->y_bearing = roundf (param.max_y.to_real ());\n+    extents->height = roundf (param.min_y.to_real () - extents->y_bearing);\n@@ -141,0 +141,11 @@\n+  font->scale_glyph_extents (extents);\n+\n+  return true;\n+}\n+\n+bool OT::cff2::accelerator_t::paint_glyph (hb_font_t *font, hb_codepoint_t glyph, hb_paint_funcs_t *funcs, void *data, hb_color_t foreground) const\n+{\n+  funcs->push_clip_glyph (data, glyph, font);\n+  funcs->color (data, true, foreground);\n+  funcs->pop_clip (data);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cff2-table.cc","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"hb-paint.hh\"\n@@ -59,1 +60,1 @@\n-    memcpy (dest, &src, size);\n+    hb_memcpy (dest, &src, size);\n@@ -127,1 +128,1 @@\n-    memcpy (dest, varStore, size_);\n+    hb_memcpy (dest, varStore, size_);\n@@ -285,3 +286,0 @@\n-        val.single_val = env.argStack.pop_num ();\n-        env.clear_args ();\n-        break;\n@@ -486,0 +484,5 @@\n+    hb_map_t *create_glyph_to_sid_map () const\n+    {\n+      return nullptr;\n+    }\n+\n@@ -489,1 +492,0 @@\n-    hb_blob_t                   *blob = nullptr;\n@@ -493,0 +495,1 @@\n+    hb_blob_t                   *blob = nullptr;\n@@ -514,0 +517,1 @@\n+    HB_INTERNAL bool paint_glyph (hb_font_t *font, hb_codepoint_t glyph, hb_paint_funcs_t *funcs, void *data, hb_color_t foreground) const;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cff2-table.hh","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"hb-cache.hh\"\n@@ -912,1 +913,1 @@\n-      out->add_range (first, hb_min (last, 0x10FFFFu));\n+      out->add_range (first, last);\n@@ -928,4 +929,1 @@\n-    hb_codepoint_t lastCode = HB_MAP_VALUE_INVALID;\n-    int count = -1;\n-\n-    for (const UnicodeValueRange& _ : as_array ())\n+    if (this->len > unicodes->get_population () * hb_bit_storage ((unsigned) this->len))\n@@ -933,1 +931,5 @@\n-      for (const unsigned addcnt : hb_range ((unsigned) _.additionalCount + 1))\n+      hb_codepoint_t start = HB_SET_VALUE_INVALID;\n+      hb_codepoint_t end = HB_SET_VALUE_INVALID;\n+\n+      for (hb_codepoint_t u = HB_SET_VALUE_INVALID;\n+           unicodes->next (&u);)\n@@ -935,6 +937,8 @@\n-        unsigned curEntry = (unsigned) _.startUnicodeValue + addcnt;\n-        if (!unicodes->has (curEntry)) continue;\n-        count += 1;\n-        if (lastCode == HB_MAP_VALUE_INVALID)\n-          lastCode = curEntry;\n-        else if (lastCode + count != curEntry)\n+        if (!as_array ().bsearch (u))\n+          continue;\n+        if (start == HB_SET_VALUE_INVALID)\n+        {\n+          start = u;\n+          end = start - 1;\n+        }\n+        if (end + 1 != u || end - start == 255)\n@@ -943,2 +947,2 @@\n-          rec.startUnicodeValue = lastCode;\n-          rec.additionalCount = count - 1;\n+          rec.startUnicodeValue = start;\n+          rec.additionalCount = end - start;\n@@ -946,3 +950,1 @@\n-\n-          lastCode = curEntry;\n-          count = 0;\n+          start = u;\n@@ -950,0 +952,8 @@\n+        end = u;\n+      }\n+      if (start != HB_SET_VALUE_INVALID)\n+      {\n+        UnicodeValueRange rec;\n+        rec.startUnicodeValue = start;\n+        rec.additionalCount = end - start;\n+        c->copy<UnicodeValueRange> (rec);\n@@ -951,1 +961,0 @@\n-    }\n@@ -953,1 +962,2 @@\n-    if (lastCode != HB_MAP_VALUE_INVALID)\n+    }\n+    else\n@@ -955,4 +965,33 @@\n-      UnicodeValueRange rec;\n-      rec.startUnicodeValue = lastCode;\n-      rec.additionalCount = count;\n-      c->copy<UnicodeValueRange> (rec);\n+      hb_codepoint_t lastCode = HB_SET_VALUE_INVALID;\n+      int count = -1;\n+\n+      for (const UnicodeValueRange& _ : *this)\n+      {\n+        hb_codepoint_t curEntry = (hb_codepoint_t) (_.startUnicodeValue - 1);\n+        hb_codepoint_t end = curEntry + _.additionalCount + 2;\n+\n+        for (; unicodes->next (&curEntry) && curEntry < end;)\n+        {\n+          count += 1;\n+          if (lastCode == HB_SET_VALUE_INVALID)\n+            lastCode = curEntry;\n+          else if (lastCode + count != curEntry)\n+          {\n+            UnicodeValueRange rec;\n+            rec.startUnicodeValue = lastCode;\n+            rec.additionalCount = count - 1;\n+            c->copy<UnicodeValueRange> (rec);\n+\n+            lastCode = curEntry;\n+            count = 0;\n+          }\n+        }\n+      }\n+\n+      if (lastCode != HB_MAP_VALUE_INVALID)\n+      {\n+        UnicodeValueRange rec;\n+        rec.startUnicodeValue = lastCode;\n+        rec.additionalCount = count;\n+        c->copy<UnicodeValueRange> (rec);\n+      }\n@@ -1379,1 +1418,1 @@\n-    case 14: return u.format14.serialize (c, plan->unicodes, plan->glyphs_requested, plan->glyph_map, base);\n+    case 14: return u.format14.serialize (c, &plan->unicodes, &plan->glyphs_requested, plan->glyph_map, base);\n@@ -1477,0 +1516,2 @@\n+struct cmap;\n+\n@@ -1480,2 +1521,3 @@\n-  const void* base;\n-  hb_hashmap_t<intptr_t, hb::unique_ptr<hb_set_t>> cached_unicodes;\n+  hb_blob_ptr_t<cmap> base_blob;\n+  const char* base;\n+  hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> cached_unicodes;\n@@ -1484,0 +1526,17 @@\n+\n+  static SubtableUnicodesCache* create (hb_blob_ptr_t<cmap> source_table)\n+  {\n+    SubtableUnicodesCache* cache =\n+        (SubtableUnicodesCache*) hb_malloc (sizeof(SubtableUnicodesCache));\n+    new (cache) SubtableUnicodesCache (source_table);\n+    return cache;\n+  }\n+\n+  static void destroy (void* value) {\n+    if (!value) return;\n+\n+    SubtableUnicodesCache* cache = (SubtableUnicodesCache*) value;\n+    cache->~SubtableUnicodesCache ();\n+    hb_free (cache);\n+  }\n+\n@@ -1485,1 +1544,15 @@\n-      : base(cmap_base), cached_unicodes() {}\n+      : base_blob(),\n+        base ((const char*) cmap_base),\n+        cached_unicodes ()\n+  {}\n+\n+  SubtableUnicodesCache(hb_blob_ptr_t<cmap> base_blob_)\n+      : base_blob(base_blob_),\n+        base ((const char *) base_blob.get()),\n+        cached_unicodes ()\n+  {}\n+\n+  ~SubtableUnicodesCache()\n+  {\n+    base_blob.destroy ();\n+  }\n@@ -1487,1 +1560,1 @@\n-  hb_set_t* set_for (const EncodingRecord* record)\n+  bool same_base(const void* other) const\n@@ -1489,1 +1562,15 @@\n-    if (!cached_unicodes.has ((intptr_t) record))\n+    return other == (const void*) base;\n+  }\n+\n+  const hb_set_t* set_for (const EncodingRecord* record,\n+                           SubtableUnicodesCache& mutable_cache) const\n+  {\n+    if (cached_unicodes.has ((unsigned) ((const char *) record - base)))\n+      return cached_unicodes.get ((unsigned) ((const char *) record - base));\n+\n+    return mutable_cache.set_for (record);\n+  }\n+\n+  const hb_set_t* set_for (const EncodingRecord* record)\n+  {\n+    if (!cached_unicodes.has ((unsigned) ((const char *) record - base)))\n@@ -1497,1 +1584,1 @@\n-      if (unlikely (!cached_unicodes.set ((intptr_t) record, hb::unique_ptr<hb_set_t> {s})))\n+      if (unlikely (!cached_unicodes.set ((unsigned) ((const char *) record - base), hb::unique_ptr<hb_set_t> {s})))\n@@ -1502,1 +1589,1 @@\n-    return cached_unicodes.get ((intptr_t) record);\n+    return cached_unicodes.get ((unsigned) ((const char *) record - base));\n@@ -1526,0 +1613,17 @@\n+\n+  static SubtableUnicodesCache* create_filled_cache(hb_blob_ptr_t<cmap> source_table) {\n+    const cmap* cmap = source_table.get();\n+    auto it =\n+    + hb_iter (cmap->encodingRecord)\n+    | hb_filter ([&](const EncodingRecord& _) {\n+      return cmap::filter_encoding_records_for_subset (cmap, _);\n+    })\n+    ;\n+\n+    SubtableUnicodesCache* cache = SubtableUnicodesCache::create(source_table);\n+    for (const EncodingRecord& _ : it)\n+      cache->set_for(&_); \/\/ populate the cache for this encoding record.\n+\n+    return cache;\n+  }\n+\n@@ -1532,1 +1636,1 @@\n-                  const hb_subset_plan_t *plan,\n+                  hb_subset_plan_t *plan,\n@@ -1541,1 +1645,8 @@\n-    SubtableUnicodesCache unicodes_cache (base);\n+    SubtableUnicodesCache local_unicodes_cache (base);\n+    const SubtableUnicodesCache* unicodes_cache = &local_unicodes_cache;\n+\n+    if (plan->accelerator &&\n+        plan->accelerator->cmap_cache &&\n+        plan->accelerator->cmap_cache->same_base (base))\n+      unicodes_cache = plan->accelerator->cmap_cache;\n+\n@@ -1550,1 +1661,1 @@\n-      hb_set_t* unicodes_set = unicodes_cache.set_for (&_);\n+      const hb_set_t* unicodes_set = unicodes_cache->set_for (&_, local_unicodes_cache);\n@@ -1569,1 +1680,7 @@\n-        if (_can_drop (_, *unicodes_set, base, unicodes_cache, + it | hb_map (hb_first), encodingrec_iter)) continue;\n+        if (_can_drop (_,\n+                       *unicodes_set,\n+                       base,\n+                       *unicodes_cache,\n+                       local_unicodes_cache,\n+                       + it | hb_map (hb_first), encodingrec_iter))\n+          continue;\n@@ -1588,1 +1705,2 @@\n-                  SubtableUnicodesCache& unicodes_cache,\n+                  const SubtableUnicodesCache& unicodes_cache,\n+                  SubtableUnicodesCache& local_unicodes_cache,\n@@ -1619,1 +1737,1 @@\n-      hb_set_t* sibling_unicodes = unicodes_cache.set_for (&_);\n+      const hb_set_t* sibling_unicodes = unicodes_cache.set_for (&_, local_unicodes_cache);\n@@ -1656,11 +1774,3 @@\n-    | hb_filter ([&] (const EncodingRecord& _)\n-                {\n-                  if ((_.platformID == 0 && _.encodingID == 3) ||\n-                      (_.platformID == 0 && _.encodingID == 4) ||\n-                      (_.platformID == 3 && _.encodingID == 1) ||\n-                      (_.platformID == 3 && _.encodingID == 10) ||\n-                      (this + _.subtable).u.format == 14)\n-                    return true;\n-\n-                  return false;\n-                })\n+    | hb_filter ([&](const EncodingRecord& _) {\n+      return cmap::filter_encoding_records_for_subset (this, _);\n+    })\n@@ -1695,1 +1805,5 @@\n-    return_trace (cmap_prime->serialize (c->serializer, it, encodingrec_iter, this, c->plan));\n+    return_trace (cmap_prime->serialize (c->serializer,\n+                                         it,\n+                                         encodingrec_iter,\n+                                         this,\n+                                         c->plan));\n@@ -1731,0 +1845,2 @@\n+    using cache_t = hb_cache_t<21, 16, 8, true>;\n+\n@@ -1785,0 +1901,17 @@\n+    inline bool _cached_get (hb_codepoint_t unicode,\n+                             hb_codepoint_t *glyph,\n+                             cache_t *cache) const\n+    {\n+      unsigned v;\n+      if (cache && cache->get (unicode, &v))\n+      {\n+        *glyph = v;\n+        return true;\n+      }\n+      bool ret  = this->get_glyph_funcZ (this->get_glyph_data, unicode, glyph);\n+\n+      if (cache && ret)\n+        cache->set (unicode, *glyph);\n+      return ret;\n+    }\n+\n@@ -1786,1 +1919,2 @@\n-                            hb_codepoint_t *glyph) const\n+                            hb_codepoint_t *glyph,\n+                            cache_t *cache = nullptr) const\n@@ -1788,2 +1922,2 @@\n-      if (unlikely (!this->get_glyph_funcZ)) return false;\n-      return this->get_glyph_funcZ (this->get_glyph_data, unicode, glyph);\n+      if (unlikely (!this->get_glyph_funcZ)) return 0;\n+      return _cached_get (unicode, glyph, cache);\n@@ -1791,0 +1925,1 @@\n+\n@@ -1795,1 +1930,2 @@\n-                                     unsigned int glyph_stride) const\n+                                     unsigned int glyph_stride,\n+                                     cache_t *cache = nullptr) const\n@@ -1799,3 +1935,0 @@\n-      hb_cmap_get_glyph_func_t get_glyph_funcZ = this->get_glyph_funcZ;\n-      const void *get_glyph_data = this->get_glyph_data;\n-\n@@ -1804,1 +1937,1 @@\n-           done < count && get_glyph_funcZ (get_glyph_data, *first_unicode, first_glyph);\n+           done < count && _cached_get (*first_unicode, first_glyph, cache);\n@@ -1815,1 +1948,2 @@\n-                              hb_codepoint_t *glyph) const\n+                              hb_codepoint_t *glyph,\n+                              cache_t *cache = nullptr) const\n@@ -1826,1 +1960,1 @@\n-      return get_nominal_glyph (unicode, glyph);\n+      return get_nominal_glyph (unicode, glyph, cache);\n@@ -1931,0 +2065,13 @@\n+ private:\n+\n+  static bool filter_encoding_records_for_subset(const cmap* cmap,\n+                                                 const EncodingRecord& _)\n+  {\n+    return\n+        (_.platformID == 0 && _.encodingID == 3) ||\n+        (_.platformID == 0 && _.encodingID == 4) ||\n+        (_.platformID == 3 && _.encodingID == 1) ||\n+        (_.platformID == 3 && _.encodingID == 10) ||\n+        (cmap + _.subtable).u.format == 14;\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cmap-table.hh","additions":206,"deletions":59,"binary":false,"changes":265,"status":"modified"},{"patch":"@@ -1,1541 +0,0 @@\n-\/*\n- * Copyright © 2018  Ebrahim Byagowi\n- * Copyright © 2020  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Calder Kitagawa\n- *\/\n-\n-#ifndef HB_OT_COLOR_COLR_TABLE_HH\n-#define HB_OT_COLOR_COLR_TABLE_HH\n-\n-#include \"hb-open-type.hh\"\n-#include \"hb-ot-layout-common.hh\"\n-#include \"hb-ot-var-common.hh\"\n-\n-\/*\n- * COLR -- Color\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/colr\n- *\/\n-#define HB_OT_TAG_COLR HB_TAG('C','O','L','R')\n-\n-#ifndef HB_COLRV1_MAX_NESTING_LEVEL\n-#define HB_COLRV1_MAX_NESTING_LEVEL     100\n-#endif\n-\n-#ifndef COLRV1_ENABLE_SUBSETTING\n-#define COLRV1_ENABLE_SUBSETTING 1\n-#endif\n-\n-namespace OT {\n-\n-struct COLR;\n-struct hb_colrv1_closure_context_t :\n-       hb_dispatch_context_t<hb_colrv1_closure_context_t>\n-{\n-  template <typename T>\n-  return_t dispatch (const T &obj)\n-  {\n-    if (unlikely (nesting_level_left == 0))\n-      return hb_empty_t ();\n-\n-    if (paint_visited (&obj))\n-      return hb_empty_t ();\n-\n-    nesting_level_left--;\n-    obj.closurev1 (this);\n-    nesting_level_left++;\n-    return hb_empty_t ();\n-  }\n-  static return_t default_return_value () { return hb_empty_t (); }\n-\n-  bool paint_visited (const void *paint)\n-  {\n-    hb_codepoint_t delta = (hb_codepoint_t) ((uintptr_t) paint - (uintptr_t) base);\n-    if (visited_paint.in_error() || visited_paint.has (delta))\n-      return true;\n-\n-    visited_paint.add (delta);\n-    return false;\n-  }\n-\n-  const COLR* get_colr_table () const\n-  { return reinterpret_cast<const COLR *> (base); }\n-\n-  void add_glyph (unsigned glyph_id)\n-  { glyphs->add (glyph_id); }\n-\n-  void add_layer_indices (unsigned first_layer_index, unsigned num_of_layers)\n-  { layer_indices->add_range (first_layer_index, first_layer_index + num_of_layers - 1); }\n-\n-  void add_palette_index (unsigned palette_index)\n-  { palette_indices->add (palette_index); }\n-\n-  public:\n-  const void *base;\n-  hb_set_t visited_paint;\n-  hb_set_t *glyphs;\n-  hb_set_t *layer_indices;\n-  hb_set_t *palette_indices;\n-  unsigned nesting_level_left;\n-\n-  hb_colrv1_closure_context_t (const void *base_,\n-                               hb_set_t *glyphs_,\n-                               hb_set_t *layer_indices_,\n-                               hb_set_t *palette_indices_,\n-                               unsigned nesting_level_left_ = HB_COLRV1_MAX_NESTING_LEVEL) :\n-                          base (base_),\n-                          glyphs (glyphs_),\n-                          layer_indices (layer_indices_),\n-                          palette_indices (palette_indices_),\n-                          nesting_level_left (nesting_level_left_)\n-  {}\n-};\n-\n-struct LayerRecord\n-{\n-  operator hb_ot_color_layer_t () const { return {glyphId, colorIdx}; }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  public:\n-  HBGlyphID16   glyphId;        \/* Glyph ID of layer glyph *\/\n-  Index         colorIdx;       \/* Index value to use with a\n-                                 * selected color palette.\n-                                 * An index value of 0xFFFF\n-                                 * is a special case indicating\n-                                 * that the text foreground\n-                                 * color (defined by a\n-                                 * higher-level client) should\n-                                 * be used and shall not be\n-                                 * treated as actual index\n-                                 * into CPAL ColorRecord array. *\/\n-  public:\n-  DEFINE_SIZE_STATIC (4);\n-};\n-\n-struct BaseGlyphRecord\n-{\n-  int cmp (hb_codepoint_t g) const\n-  { return g < glyphId ? -1 : g > glyphId ? 1 : 0; }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (likely (c->check_struct (this)));\n-  }\n-\n-  public:\n-  HBGlyphID16   glyphId;        \/* Glyph ID of reference glyph *\/\n-  HBUINT16      firstLayerIdx;  \/* Index (from beginning of\n-                                 * the Layer Records) to the\n-                                 * layer record. There will be\n-                                 * numLayers consecutive entries\n-                                 * for this base glyph. *\/\n-  HBUINT16      numLayers;      \/* Number of color layers\n-                                 * associated with this glyph *\/\n-  public:\n-  DEFINE_SIZE_STATIC (6);\n-};\n-\n-template <typename T>\n-struct Variable\n-{\n-  Variable<T>* copy (hb_serialize_context_t *c) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    return_trace (c->embed (this));\n-  }\n-\n-  void closurev1 (hb_colrv1_closure_context_t* c) const\n-  { value.closurev1 (c); }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    if (!value.subset (c)) return_trace (false);\n-    return_trace (c->serializer->embed (varIdxBase));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && value.sanitize (c));\n-  }\n-\n-  protected:\n-  T      value;\n-  VarIdx varIdxBase;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + T::static_size);\n-};\n-\n-template <typename T>\n-struct NoVariable\n-{\n-  NoVariable<T>* copy (hb_serialize_context_t *c) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    return_trace (c->embed (this));\n-  }\n-\n-  void closurev1 (hb_colrv1_closure_context_t* c) const\n-  { value.closurev1 (c); }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    return_trace (value.subset (c));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && value.sanitize (c));\n-  }\n-\n-  T      value;\n-  public:\n-  DEFINE_SIZE_STATIC (T::static_size);\n-};\n-\n-\/\/ Color structures\n-\n-struct ColorStop\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const\n-  { c->add_palette_index (paletteIndex); }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (*this);\n-    if (unlikely (!out)) return_trace (false);\n-    return_trace (c->serializer->check_assign (out->paletteIndex, c->plan->colr_palettes->get (paletteIndex),\n-                                               HB_SERIALIZE_ERROR_INT_OVERFLOW));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  F2DOT14       stopOffset;\n-  HBUINT16      paletteIndex;\n-  F2DOT14       alpha;\n-  public:\n-  DEFINE_SIZE_STATIC (2 + 2 * F2DOT14::static_size);\n-};\n-\n-struct Extend : HBUINT8\n-{\n-  enum {\n-    EXTEND_PAD     = 0,\n-    EXTEND_REPEAT  = 1,\n-    EXTEND_REFLECT = 2,\n-  };\n-  public:\n-  DEFINE_SIZE_STATIC (1);\n-};\n-\n-template <template<typename> class Var>\n-struct ColorLine\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const\n-  {\n-    for (const auto &stop : stops.iter ())\n-      stop.closurev1 (c);\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-\n-    if (!c->serializer->check_assign (out->extend, extend, HB_SERIALIZE_ERROR_INT_OVERFLOW)) return_trace (false);\n-    if (!c->serializer->check_assign (out->stops.len, stops.len, HB_SERIALIZE_ERROR_ARRAY_OVERFLOW)) return_trace (false);\n-\n-    for (const auto& stop : stops.iter ())\n-    {\n-      if (!stop.subset (c)) return_trace (false);\n-    }\n-    return_trace (true);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  stops.sanitize (c));\n-  }\n-\n-  Extend        extend;\n-  Array16Of<Var<ColorStop>>     stops;\n-  public:\n-  DEFINE_SIZE_ARRAY_SIZED (3, stops);\n-};\n-\n-\/\/ Composition modes\n-\n-\/\/ Compositing modes are taken from https:\/\/www.w3.org\/TR\/compositing-1\/\n-\/\/ NOTE: a brief audit of major implementations suggests most support most\n-\/\/ or all of the specified modes.\n-struct CompositeMode : HBUINT8\n-{\n-  enum {\n-    \/\/ Porter-Duff modes\n-    \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators\n-    COMPOSITE_CLEAR          =  0,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_clear\n-    COMPOSITE_SRC            =  1,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_src\n-    COMPOSITE_DEST           =  2,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dst\n-    COMPOSITE_SRC_OVER       =  3,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_srcover\n-    COMPOSITE_DEST_OVER      =  4,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dstover\n-    COMPOSITE_SRC_IN         =  5,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_srcin\n-    COMPOSITE_DEST_IN        =  6,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dstin\n-    COMPOSITE_SRC_OUT        =  7,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_srcout\n-    COMPOSITE_DEST_OUT       =  8,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dstout\n-    COMPOSITE_SRC_ATOP       =  9,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_srcatop\n-    COMPOSITE_DEST_ATOP      = 10,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dstatop\n-    COMPOSITE_XOR            = 11,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_xor\n-    COMPOSITE_PLUS           = 12,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_plus\n-\n-    \/\/ Blend modes\n-    \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blending\n-    COMPOSITE_SCREEN         = 13,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingscreen\n-    COMPOSITE_OVERLAY        = 14,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingoverlay\n-    COMPOSITE_DARKEN         = 15,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingdarken\n-    COMPOSITE_LIGHTEN        = 16,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendinglighten\n-    COMPOSITE_COLOR_DODGE    = 17,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingcolordodge\n-    COMPOSITE_COLOR_BURN     = 18,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingcolorburn\n-    COMPOSITE_HARD_LIGHT     = 19,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendinghardlight\n-    COMPOSITE_SOFT_LIGHT     = 20,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingsoftlight\n-    COMPOSITE_DIFFERENCE     = 21,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingdifference\n-    COMPOSITE_EXCLUSION      = 22,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingexclusion\n-    COMPOSITE_MULTIPLY       = 23,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingmultiply\n-\n-    \/\/ Modes that, uniquely, do not operate on components\n-    \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingnonseparable\n-    COMPOSITE_HSL_HUE        = 24,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendinghue\n-    COMPOSITE_HSL_SATURATION = 25,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingsaturation\n-    COMPOSITE_HSL_COLOR      = 26,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingcolor\n-    COMPOSITE_HSL_LUMINOSITY = 27,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingluminosity\n-  };\n-  public:\n-  DEFINE_SIZE_STATIC (1);\n-};\n-\n-struct Affine2x3\n-{\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  HBFixed xx;\n-  HBFixed yx;\n-  HBFixed xy;\n-  HBFixed yy;\n-  HBFixed dx;\n-  HBFixed dy;\n-  public:\n-  DEFINE_SIZE_STATIC (6 * HBFixed::static_size);\n-};\n-\n-struct PaintColrLayers\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-    return_trace (c->serializer->check_assign (out->firstLayerIndex, c->plan->colrv1_layers->get (firstLayerIndex),\n-                                               HB_SERIALIZE_ERROR_INT_OVERFLOW));\n-\n-    return_trace (true);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  HBUINT8       format; \/* format = 1 *\/\n-  HBUINT8       numLayers;\n-  HBUINT32      firstLayerIndex;  \/* index into COLRv1::layerList *\/\n-  public:\n-  DEFINE_SIZE_STATIC (6);\n-};\n-\n-struct PaintSolid\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const\n-  { c->add_palette_index (paletteIndex); }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (*this);\n-    if (unlikely (!out)) return_trace (false);\n-    return_trace (c->serializer->check_assign (out->paletteIndex, c->plan->colr_palettes->get (paletteIndex),\n-                                               HB_SERIALIZE_ERROR_INT_OVERFLOW));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  HBUINT8       format; \/* format = 2(noVar) or 3(Var)*\/\n-  HBUINT16      paletteIndex;\n-  F2DOT14       alpha;\n-  public:\n-  DEFINE_SIZE_STATIC (3 + F2DOT14::static_size);\n-};\n-\n-template <template<typename> class Var>\n-struct PaintLinearGradient\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const\n-  { (this+colorLine).closurev1 (c); }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && colorLine.sanitize (c, this));\n-  }\n-\n-  HBUINT8                       format; \/* format = 4(noVar) or 5 (Var) *\/\n-  Offset24To<ColorLine<Var>>    colorLine; \/* Offset (from beginning of PaintLinearGradient\n-                                            * table) to ColorLine subtable. *\/\n-  FWORD                 x0;\n-  FWORD                 y0;\n-  FWORD                 x1;\n-  FWORD                 y1;\n-  FWORD                 x2;\n-  FWORD                 y2;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + 6 * FWORD::static_size);\n-};\n-\n-template <template<typename> class Var>\n-struct PaintRadialGradient\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const\n-  { (this+colorLine).closurev1 (c); }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && colorLine.sanitize (c, this));\n-  }\n-\n-  HBUINT8                       format; \/* format = 6(noVar) or 7 (Var) *\/\n-  Offset24To<ColorLine<Var>>    colorLine; \/* Offset (from beginning of PaintRadialGradient\n-                                            * table) to ColorLine subtable. *\/\n-  FWORD                 x0;\n-  FWORD                 y0;\n-  UFWORD                radius0;\n-  FWORD                 x1;\n-  FWORD                 y1;\n-  UFWORD                radius1;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + 6 * FWORD::static_size);\n-};\n-\n-template <template<typename> class Var>\n-struct PaintSweepGradient\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const\n-  { (this+colorLine).closurev1 (c); }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && colorLine.sanitize (c, this));\n-  }\n-\n-  HBUINT8                       format; \/* format = 8(noVar) or 9 (Var) *\/\n-  Offset24To<ColorLine<Var>>    colorLine; \/* Offset (from beginning of PaintSweepGradient\n-                                            * table) to ColorLine subtable. *\/\n-  FWORD                 centerX;\n-  FWORD                 centerY;\n-  F2DOT14               startAngle;\n-  F2DOT14               endAngle;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + 2 * FWORD::static_size + 2 * F2DOT14::static_size);\n-};\n-\n-struct Paint;\n-\/\/ Paint a non-COLR glyph, filled as indicated by paint.\n-struct PaintGlyph\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    if (! c->serializer->check_assign (out->gid, c->plan->glyph_map->get (gid),\n-                                       HB_SERIALIZE_ERROR_INT_OVERFLOW))\n-      return_trace (false);\n-\n-    return_trace (out->paint.serialize_subset (c, paint, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && paint.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 10 *\/\n-  Offset24To<Paint>     paint;  \/* Offset (from beginning of PaintGlyph table) to Paint subtable. *\/\n-  HBUINT16              gid;\n-  public:\n-  DEFINE_SIZE_STATIC (6);\n-};\n-\n-struct PaintColrGlyph\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (c->serializer->check_assign (out->gid, c->plan->glyph_map->get (gid),\n-                                               HB_SERIALIZE_ERROR_INT_OVERFLOW));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  HBUINT8       format; \/* format = 11 *\/\n-  HBUINT16      gid;\n-  public:\n-  DEFINE_SIZE_STATIC (3);\n-};\n-\n-template <template<typename> class Var>\n-struct PaintTransform\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-    if (!out->transform.serialize_copy (c->serializer, transform, this)) return_trace (false);\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  src.sanitize (c, this) &&\n-                  transform.sanitize (c, this));\n-  }\n-\n-  HBUINT8                       format; \/* format = 12(noVar) or 13 (Var) *\/\n-  Offset24To<Paint>             src; \/* Offset (from beginning of PaintTransform table) to Paint subtable. *\/\n-  Offset24To<Var<Affine2x3>>    transform;\n-  public:\n-  DEFINE_SIZE_STATIC (7);\n-};\n-\n-struct PaintTranslate\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 14(noVar) or 15 (Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintTranslate table) to Paint subtable. *\/\n-  FWORD         dx;\n-  FWORD         dy;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + 2 * FWORD::static_size);\n-};\n-\n-struct PaintScale\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 16 (noVar) or 17(Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintScale table) to Paint subtable. *\/\n-  F2DOT14               scaleX;\n-  F2DOT14               scaleY;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + 2 * F2DOT14::static_size);\n-};\n-\n-struct PaintScaleAroundCenter\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 18 (noVar) or 19(Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintScaleAroundCenter table) to Paint subtable. *\/\n-  F2DOT14       scaleX;\n-  F2DOT14       scaleY;\n-  FWORD         centerX;\n-  FWORD         centerY;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + 2 * F2DOT14::static_size + 2 * FWORD::static_size);\n-};\n-\n-struct PaintScaleUniform\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 20 (noVar) or 21(Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintScaleUniform table) to Paint subtable. *\/\n-  F2DOT14               scale;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + F2DOT14::static_size);\n-};\n-\n-struct PaintScaleUniformAroundCenter\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 22 (noVar) or 23(Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintScaleUniformAroundCenter table) to Paint subtable. *\/\n-  F2DOT14       scale;\n-  FWORD         centerX;\n-  FWORD         centerY;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + F2DOT14::static_size + 2 * FWORD::static_size);\n-};\n-\n-struct PaintRotate\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 24 (noVar) or 25(Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintRotate table) to Paint subtable. *\/\n-  F2DOT14               angle;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + F2DOT14::static_size);\n-};\n-\n-struct PaintRotateAroundCenter\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 26 (noVar) or 27(Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintRotateAroundCenter table) to Paint subtable. *\/\n-  F2DOT14       angle;\n-  FWORD         centerX;\n-  FWORD         centerY;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + F2DOT14::static_size + 2 * FWORD::static_size);\n-};\n-\n-struct PaintSkew\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 28(noVar) or 29 (Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintSkew table) to Paint subtable. *\/\n-  F2DOT14               xSkewAngle;\n-  F2DOT14               ySkewAngle;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + 2 * F2DOT14::static_size);\n-};\n-\n-struct PaintSkewAroundCenter\n-{\n-  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->src.serialize_subset (c, src, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && src.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 30(noVar) or 31 (Var) *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintSkewAroundCenter table) to Paint subtable. *\/\n-  F2DOT14       xSkewAngle;\n-  F2DOT14       ySkewAngle;\n-  FWORD         centerX;\n-  FWORD         centerY;\n-  public:\n-  DEFINE_SIZE_STATIC (4 + 2 * F2DOT14::static_size + 2 * FWORD::static_size);\n-};\n-\n-struct PaintComposite\n-{\n-  void closurev1 (hb_colrv1_closure_context_t* c) const;\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    if (!out->src.serialize_subset (c, src, this)) return_trace (false);\n-    return_trace (out->backdrop.serialize_subset (c, backdrop, this));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  src.sanitize (c, this) &&\n-                  backdrop.sanitize (c, this));\n-  }\n-\n-  HBUINT8               format; \/* format = 32 *\/\n-  Offset24To<Paint>     src; \/* Offset (from beginning of PaintComposite table) to source Paint subtable. *\/\n-  CompositeMode         mode;   \/* If mode is unrecognized use COMPOSITE_CLEAR *\/\n-  Offset24To<Paint>     backdrop; \/* Offset (from beginning of PaintComposite table) to backdrop Paint subtable. *\/\n-  public:\n-  DEFINE_SIZE_STATIC (8);\n-};\n-\n-struct ClipBoxFormat1\n-{\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  public:\n-  HBUINT8       format; \/* format = 1(noVar) or 2(Var)*\/\n-  FWORD         xMin;\n-  FWORD         yMin;\n-  FWORD         xMax;\n-  FWORD         yMax;\n-  public:\n-  DEFINE_SIZE_STATIC (1 + 4 * FWORD::static_size);\n-};\n-\n-struct ClipBoxFormat2 : Variable<ClipBoxFormat1> {};\n-\n-struct ClipBox\n-{\n-  ClipBox* copy (hb_serialize_context_t *c) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    switch (u.format) {\n-    case 1: return_trace (reinterpret_cast<ClipBox *> (c->embed (u.format1)));\n-    case 2: return_trace (reinterpret_cast<ClipBox *> (c->embed (u.format2)));\n-    default:return_trace (nullptr);\n-    }\n-  }\n-\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, u.format);\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n-    switch (u.format) {\n-    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n-    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n-    default:return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT8               format;         \/* Format identifier *\/\n-  ClipBoxFormat1        format1;\n-  ClipBoxFormat2        format2;\n-  } u;\n-};\n-\n-struct ClipRecord\n-{\n-  ClipRecord* copy (hb_serialize_context_t *c, const void *base) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    auto *out = c->embed (this);\n-    if (unlikely (!out)) return_trace (nullptr);\n-    if (!out->clipBox.serialize_copy (c, clipBox, base)) return_trace (nullptr);\n-    return_trace (out);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && clipBox.sanitize (c, base));\n-  }\n-\n-  public:\n-  HBUINT16              startGlyphID;  \/\/ first gid clip applies to\n-  HBUINT16              endGlyphID;    \/\/ last gid clip applies to, inclusive\n-  Offset24To<ClipBox>   clipBox;   \/\/ Box or VarBox\n-  public:\n-  DEFINE_SIZE_STATIC (7);\n-};\n-\n-struct ClipList\n-{\n-  unsigned serialize_clip_records (hb_serialize_context_t *c,\n-                                   const hb_set_t& gids,\n-                                   const hb_map_t& gid_offset_map) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (gids.is_empty () ||\n-        gid_offset_map.get_population () != gids.get_population ())\n-      return_trace (0);\n-\n-    unsigned count  = 0;\n-\n-    hb_codepoint_t start_gid= gids.get_min ();\n-    hb_codepoint_t prev_gid = start_gid;\n-\n-    unsigned offset = gid_offset_map.get (start_gid);\n-    unsigned prev_offset = offset;\n-    for (const hb_codepoint_t _ : gids.iter ())\n-    {\n-      if (_ == start_gid) continue;\n-\n-      offset = gid_offset_map.get (_);\n-      if (_ == prev_gid + 1 &&  offset == prev_offset)\n-      {\n-        prev_gid = _;\n-        continue;\n-      }\n-\n-      ClipRecord record;\n-      record.startGlyphID = start_gid;\n-      record.endGlyphID = prev_gid;\n-      record.clipBox = prev_offset;\n-\n-      if (!c->copy (record, this)) return_trace (0);\n-      count++;\n-\n-      start_gid = _;\n-      prev_gid = _;\n-      prev_offset = offset;\n-    }\n-\n-    \/\/last one\n-    {\n-      ClipRecord record;\n-      record.startGlyphID = start_gid;\n-      record.endGlyphID = prev_gid;\n-      record.clipBox = prev_offset;\n-      if (!c->copy (record, this)) return_trace (0);\n-      count++;\n-    }\n-    return_trace (count);\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-    if (!c->serializer->check_assign (out->format, format, HB_SERIALIZE_ERROR_INT_OVERFLOW)) return_trace (false);\n-\n-    const hb_set_t& glyphset = *c->plan->_glyphset_colred;\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    hb_map_t new_gid_offset_map;\n-    hb_set_t new_gids;\n-    for (const ClipRecord& record : clips.iter ())\n-    {\n-      unsigned start_gid = record.startGlyphID;\n-      unsigned end_gid = record.endGlyphID;\n-      for (unsigned gid = start_gid; gid <= end_gid; gid++)\n-      {\n-        if (!glyphset.has (gid) || !glyph_map.has (gid)) continue;\n-        unsigned new_gid = glyph_map.get (gid);\n-        new_gid_offset_map.set (new_gid, record.clipBox);\n-        new_gids.add (new_gid);\n-      }\n-    }\n-\n-    unsigned count = serialize_clip_records (c->serializer, new_gids, new_gid_offset_map);\n-    if (!count) return_trace (false);\n-    return_trace (c->serializer->check_assign (out->clips.len, count, HB_SERIALIZE_ERROR_INT_OVERFLOW));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && clips.sanitize (c, this));\n-  }\n-\n-  HBUINT8                       format;  \/\/ Set to 1.\n-  Array32Of<ClipRecord>         clips;  \/\/ Clip records, sorted by startGlyphID\n-  public:\n-  DEFINE_SIZE_ARRAY_SIZED (5, clips);\n-};\n-\n-struct Paint\n-{\n-\n-  template <typename ...Ts>\n-  bool sanitize (hb_sanitize_context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_SANITIZE (this);\n-\n-    if (unlikely (!c->check_start_recursion (HB_COLRV1_MAX_NESTING_LEVEL)))\n-      return_trace (c->no_dispatch_return_value ());\n-\n-    return_trace (c->end_recursion (this->dispatch (c, std::forward<Ts> (ds)...)));\n-  }\n-\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, u.format);\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n-    switch (u.format) {\n-    case 1: return_trace (c->dispatch (u.paintformat1, std::forward<Ts> (ds)...));\n-    case 2: return_trace (c->dispatch (u.paintformat2, std::forward<Ts> (ds)...));\n-    case 3: return_trace (c->dispatch (u.paintformat3, std::forward<Ts> (ds)...));\n-    case 4: return_trace (c->dispatch (u.paintformat4, std::forward<Ts> (ds)...));\n-    case 5: return_trace (c->dispatch (u.paintformat5, std::forward<Ts> (ds)...));\n-    case 6: return_trace (c->dispatch (u.paintformat6, std::forward<Ts> (ds)...));\n-    case 7: return_trace (c->dispatch (u.paintformat7, std::forward<Ts> (ds)...));\n-    case 8: return_trace (c->dispatch (u.paintformat8, std::forward<Ts> (ds)...));\n-    case 9: return_trace (c->dispatch (u.paintformat9, std::forward<Ts> (ds)...));\n-    case 10: return_trace (c->dispatch (u.paintformat10, std::forward<Ts> (ds)...));\n-    case 11: return_trace (c->dispatch (u.paintformat11, std::forward<Ts> (ds)...));\n-    case 12: return_trace (c->dispatch (u.paintformat12, std::forward<Ts> (ds)...));\n-    case 13: return_trace (c->dispatch (u.paintformat13, std::forward<Ts> (ds)...));\n-    case 14: return_trace (c->dispatch (u.paintformat14, std::forward<Ts> (ds)...));\n-    case 15: return_trace (c->dispatch (u.paintformat15, std::forward<Ts> (ds)...));\n-    case 16: return_trace (c->dispatch (u.paintformat16, std::forward<Ts> (ds)...));\n-    case 17: return_trace (c->dispatch (u.paintformat17, std::forward<Ts> (ds)...));\n-    case 18: return_trace (c->dispatch (u.paintformat18, std::forward<Ts> (ds)...));\n-    case 19: return_trace (c->dispatch (u.paintformat19, std::forward<Ts> (ds)...));\n-    case 20: return_trace (c->dispatch (u.paintformat20, std::forward<Ts> (ds)...));\n-    case 21: return_trace (c->dispatch (u.paintformat21, std::forward<Ts> (ds)...));\n-    case 22: return_trace (c->dispatch (u.paintformat22, std::forward<Ts> (ds)...));\n-    case 23: return_trace (c->dispatch (u.paintformat23, std::forward<Ts> (ds)...));\n-    case 24: return_trace (c->dispatch (u.paintformat24, std::forward<Ts> (ds)...));\n-    case 25: return_trace (c->dispatch (u.paintformat25, std::forward<Ts> (ds)...));\n-    case 26: return_trace (c->dispatch (u.paintformat26, std::forward<Ts> (ds)...));\n-    case 27: return_trace (c->dispatch (u.paintformat27, std::forward<Ts> (ds)...));\n-    case 28: return_trace (c->dispatch (u.paintformat28, std::forward<Ts> (ds)...));\n-    case 29: return_trace (c->dispatch (u.paintformat29, std::forward<Ts> (ds)...));\n-    case 30: return_trace (c->dispatch (u.paintformat30, std::forward<Ts> (ds)...));\n-    case 31: return_trace (c->dispatch (u.paintformat31, std::forward<Ts> (ds)...));\n-    case 32: return_trace (c->dispatch (u.paintformat32, std::forward<Ts> (ds)...));\n-    default:return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT8                                       format;\n-  PaintColrLayers                               paintformat1;\n-  PaintSolid                                    paintformat2;\n-  Variable<PaintSolid>                          paintformat3;\n-  PaintLinearGradient<NoVariable>               paintformat4;\n-  Variable<PaintLinearGradient<Variable>>       paintformat5;\n-  PaintRadialGradient<NoVariable>               paintformat6;\n-  Variable<PaintRadialGradient<Variable>>       paintformat7;\n-  PaintSweepGradient<NoVariable>                paintformat8;\n-  Variable<PaintSweepGradient<Variable>>        paintformat9;\n-  PaintGlyph                                    paintformat10;\n-  PaintColrGlyph                                paintformat11;\n-  PaintTransform<NoVariable>                    paintformat12;\n-  PaintTransform<Variable>                      paintformat13;\n-  PaintTranslate                                paintformat14;\n-  Variable<PaintTranslate>                      paintformat15;\n-  PaintScale                                    paintformat16;\n-  Variable<PaintScale>                          paintformat17;\n-  PaintScaleAroundCenter                        paintformat18;\n-  Variable<PaintScaleAroundCenter>              paintformat19;\n-  PaintScaleUniform                             paintformat20;\n-  Variable<PaintScaleUniform>                   paintformat21;\n-  PaintScaleUniformAroundCenter                 paintformat22;\n-  Variable<PaintScaleUniformAroundCenter>       paintformat23;\n-  PaintRotate                                   paintformat24;\n-  Variable<PaintRotate>                         paintformat25;\n-  PaintRotateAroundCenter                       paintformat26;\n-  Variable<PaintRotateAroundCenter>             paintformat27;\n-  PaintSkew                                     paintformat28;\n-  Variable<PaintSkew>                           paintformat29;\n-  PaintSkewAroundCenter                         paintformat30;\n-  Variable<PaintSkewAroundCenter>               paintformat31;\n-  PaintComposite                                paintformat32;\n-  } u;\n-};\n-\n-struct BaseGlyphPaintRecord\n-{\n-  int cmp (hb_codepoint_t g) const\n-  { return g < glyphId ? -1 : g > glyphId ? 1 : 0; }\n-\n-  bool serialize (hb_serialize_context_t *s, const hb_map_t* glyph_map,\n-                  const void* src_base, hb_subset_context_t *c) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    auto *out = s->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-    if (!s->check_assign (out->glyphId, glyph_map->get (glyphId),\n-                          HB_SERIALIZE_ERROR_INT_OVERFLOW))\n-      return_trace (false);\n-\n-    return_trace (out->paint.serialize_subset (c, paint, src_base));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (likely (c->check_struct (this) && paint.sanitize (c, base)));\n-  }\n-\n-  public:\n-  HBGlyphID16           glyphId;    \/* Glyph ID of reference glyph *\/\n-  Offset32To<Paint>     paint;      \/* Offset (from beginning of BaseGlyphPaintRecord array) to Paint,\n-                                     * Typically PaintColrLayers *\/\n-  public:\n-  DEFINE_SIZE_STATIC (6);\n-};\n-\n-struct BaseGlyphList : SortedArray32Of<BaseGlyphPaintRecord>\n-{\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (this);\n-    if (unlikely (!c->serializer->extend_min (out)))  return_trace (false);\n-    const hb_set_t* glyphset = c->plan->_glyphset_colred;\n-\n-    for (const auto& _ : as_array ())\n-    {\n-      unsigned gid = _.glyphId;\n-      if (!glyphset->has (gid)) continue;\n-\n-      if (_.serialize (c->serializer, c->plan->glyph_map, this, c)) out->len++;\n-      else return_trace (false);\n-    }\n-\n-    return_trace (out->len != 0);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (SortedArray32Of<BaseGlyphPaintRecord>::sanitize (c, this));\n-  }\n-};\n-\n-struct LayerList : Array32OfOffset32To<Paint>\n-{\n-  const Paint& get_paint (unsigned i) const\n-  { return this+(*this)[i]; }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (this);\n-    if (unlikely (!c->serializer->extend_min (out)))  return_trace (false);\n-\n-    for (const auto& _ : + hb_enumerate (*this)\n-                         | hb_filter (c->plan->colrv1_layers, hb_first))\n-\n-    {\n-      auto *o = out->serialize_append (c->serializer);\n-      if (unlikely (!o) || !o->serialize_subset (c, _.second, this))\n-        return_trace (false);\n-    }\n-    return_trace (true);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (Array32OfOffset32To<Paint>::sanitize (c, this));\n-  }\n-};\n-\n-struct COLR\n-{\n-  static constexpr hb_tag_t tableTag = HB_OT_TAG_COLR;\n-\n-  bool has_data () const { return numBaseGlyphs; }\n-\n-  unsigned int get_glyph_layers (hb_codepoint_t       glyph,\n-                                 unsigned int         start_offset,\n-                                 unsigned int        *count, \/* IN\/OUT.  May be NULL. *\/\n-                                 hb_ot_color_layer_t *layers \/* OUT.     May be NULL. *\/) const\n-  {\n-    const BaseGlyphRecord &record = (this+baseGlyphsZ).bsearch (numBaseGlyphs, glyph);\n-\n-    hb_array_t<const LayerRecord> all_layers = (this+layersZ).as_array (numLayers);\n-    hb_array_t<const LayerRecord> glyph_layers = all_layers.sub_array (record.firstLayerIdx,\n-                                                                       record.numLayers);\n-    if (count)\n-    {\n-      + glyph_layers.sub_array (start_offset, count)\n-      | hb_sink (hb_array (layers, *count))\n-      ;\n-    }\n-    return glyph_layers.length;\n-  }\n-\n-  struct accelerator_t\n-  {\n-    accelerator_t (hb_face_t *face)\n-    { colr = hb_sanitize_context_t ().reference_table<COLR> (face); }\n-    ~accelerator_t () { this->colr.destroy (); }\n-\n-    bool is_valid () { return colr.get_blob ()->length; }\n-\n-    void closure_glyphs (hb_codepoint_t glyph,\n-                         hb_set_t *related_ids \/* OUT *\/) const\n-    { colr->closure_glyphs (glyph, related_ids); }\n-\n-    void closure_V0palette_indices (const hb_set_t *glyphs,\n-                                    hb_set_t *palettes \/* OUT *\/) const\n-    { colr->closure_V0palette_indices (glyphs, palettes); }\n-\n-    void closure_forV1 (hb_set_t *glyphset,\n-                        hb_set_t *layer_indices,\n-                        hb_set_t *palette_indices) const\n-    { colr->closure_forV1 (glyphset, layer_indices, palette_indices); }\n-\n-    private:\n-    hb_blob_ptr_t<COLR> colr;\n-  };\n-\n-  void closure_glyphs (hb_codepoint_t glyph,\n-                       hb_set_t *related_ids \/* OUT *\/) const\n-  {\n-    const BaseGlyphRecord *record = get_base_glyph_record (glyph);\n-    if (!record) return;\n-\n-    auto glyph_layers = (this+layersZ).as_array (numLayers).sub_array (record->firstLayerIdx,\n-                                                                       record->numLayers);\n-    if (!glyph_layers.length) return;\n-    related_ids->add_array (&glyph_layers[0].glyphId, glyph_layers.length, LayerRecord::min_size);\n-  }\n-\n-  void closure_V0palette_indices (const hb_set_t *glyphs,\n-                                  hb_set_t *palettes \/* OUT *\/) const\n-  {\n-    if (!numBaseGlyphs || !numLayers) return;\n-    hb_array_t<const BaseGlyphRecord> baseGlyphs = (this+baseGlyphsZ).as_array (numBaseGlyphs);\n-    hb_array_t<const LayerRecord> all_layers = (this+layersZ).as_array (numLayers);\n-\n-    for (const BaseGlyphRecord record : baseGlyphs)\n-    {\n-      if (!glyphs->has (record.glyphId)) continue;\n-      hb_array_t<const LayerRecord> glyph_layers = all_layers.sub_array (record.firstLayerIdx,\n-                                                                   record.numLayers);\n-      for (const LayerRecord layer : glyph_layers)\n-        palettes->add (layer.colorIdx);\n-    }\n-  }\n-\n-  void closure_forV1 (hb_set_t *glyphset,\n-                      hb_set_t *layer_indices,\n-                      hb_set_t *palette_indices) const\n-  {\n-    if (version != 1) return;\n-    hb_set_t visited_glyphs;\n-\n-    hb_colrv1_closure_context_t c (this, &visited_glyphs, layer_indices, palette_indices);\n-    const BaseGlyphList &baseglyph_paintrecords = this+baseGlyphList;\n-\n-    for (const BaseGlyphPaintRecord &baseglyph_paintrecord: baseglyph_paintrecords.iter ())\n-    {\n-      unsigned gid = baseglyph_paintrecord.glyphId;\n-      if (!glyphset->has (gid)) continue;\n-\n-      const Paint &paint = &baseglyph_paintrecords+baseglyph_paintrecord.paint;\n-      paint.dispatch (&c);\n-    }\n-    hb_set_union (glyphset, &visited_glyphs);\n-  }\n-\n-  const LayerList& get_layerList () const\n-  { return (this+layerList); }\n-\n-  const BaseGlyphList& get_baseglyphList () const\n-  { return (this+baseGlyphList); }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  (this+baseGlyphsZ).sanitize (c, numBaseGlyphs) &&\n-                  (this+layersZ).sanitize (c, numLayers) &&\n-                  (version == 0 ||\n-                   (COLRV1_ENABLE_SUBSETTING && version == 1 &&\n-                    baseGlyphList.sanitize (c, this) &&\n-                    layerList.sanitize (c, this) &&\n-                    clipList.sanitize (c, this) &&\n-                    varIdxMap.sanitize (c, this) &&\n-                    varStore.sanitize (c, this))));\n-  }\n-\n-  template<typename BaseIterator, typename LayerIterator,\n-           hb_requires (hb_is_iterator (BaseIterator)),\n-           hb_requires (hb_is_iterator (LayerIterator))>\n-  bool serialize_V0 (hb_serialize_context_t *c,\n-                     unsigned version,\n-                     BaseIterator base_it,\n-                     LayerIterator layer_it)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (base_it.len () != layer_it.len ()))\n-      return_trace (false);\n-\n-    this->version = version;\n-    numLayers = 0;\n-    numBaseGlyphs = base_it.len ();\n-    if (numBaseGlyphs == 0)\n-    {\n-      baseGlyphsZ = 0;\n-      layersZ = 0;\n-      return_trace (true);\n-    }\n-\n-    c->push ();\n-    for (const hb_item_type<BaseIterator> _ : + base_it.iter ())\n-    {\n-      auto* record = c->embed (_);\n-      if (unlikely (!record)) return_trace (false);\n-      record->firstLayerIdx = numLayers;\n-      numLayers += record->numLayers;\n-    }\n-    c->add_link (baseGlyphsZ, c->pop_pack ());\n-\n-    c->push ();\n-    for (const hb_item_type<LayerIterator>& _ : + layer_it.iter ())\n-      _.as_array ().copy (c);\n-\n-    c->add_link (layersZ, c->pop_pack ());\n-\n-    return_trace (true);\n-  }\n-\n-  const BaseGlyphRecord* get_base_glyph_record (hb_codepoint_t gid) const\n-  {\n-    const BaseGlyphRecord* record = &(this+baseGlyphsZ).bsearch (numBaseGlyphs, (unsigned int) gid);\n-    if (record == &Null (BaseGlyphRecord) ||\n-        (record && (hb_codepoint_t) record->glyphId != gid))\n-      record = nullptr;\n-    return record;\n-  }\n-\n-  const BaseGlyphPaintRecord* get_base_glyph_paintrecord (hb_codepoint_t gid) const\n-  {\n-    const BaseGlyphPaintRecord* record = &(this+baseGlyphList).bsearch ((unsigned) gid);\n-    if ((record && (hb_codepoint_t) record->glyphId != gid))\n-      record = nullptr;\n-    return record;\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-\n-    const hb_map_t &reverse_glyph_map = *c->plan->reverse_glyph_map;\n-    const hb_set_t& glyphset = *c->plan->_glyphset_colred;\n-\n-    auto base_it =\n-    + hb_range (c->plan->num_output_glyphs ())\n-    | hb_filter ([&](hb_codepoint_t new_gid)\n-                 {\n-                    hb_codepoint_t old_gid = reverse_glyph_map.get (new_gid);\n-                    if (glyphset.has (old_gid)) return true;\n-                    return false;\n-                 })\n-    | hb_map_retains_sorting ([&](hb_codepoint_t new_gid)\n-                              {\n-                                hb_codepoint_t old_gid = reverse_glyph_map.get (new_gid);\n-\n-                                const BaseGlyphRecord* old_record = get_base_glyph_record (old_gid);\n-                                if (unlikely (!old_record))\n-                                  return hb_pair_t<bool, BaseGlyphRecord> (false, Null (BaseGlyphRecord));\n-                                BaseGlyphRecord new_record = {};\n-                                new_record.glyphId = new_gid;\n-                                new_record.numLayers = old_record->numLayers;\n-                                return hb_pair_t<bool, BaseGlyphRecord> (true, new_record);\n-                              })\n-    | hb_filter (hb_first)\n-    | hb_map_retains_sorting (hb_second)\n-    ;\n-\n-    auto layer_it =\n-    + hb_range (c->plan->num_output_glyphs ())\n-    | hb_map (reverse_glyph_map)\n-    | hb_filter (glyphset)\n-    | hb_map_retains_sorting ([&](hb_codepoint_t old_gid)\n-                              {\n-                                const BaseGlyphRecord* old_record = get_base_glyph_record (old_gid);\n-                                hb_vector_t<LayerRecord> out_layers;\n-\n-                                if (unlikely (!old_record ||\n-                                              old_record->firstLayerIdx >= numLayers ||\n-                                              old_record->firstLayerIdx + old_record->numLayers > numLayers))\n-                                  return hb_pair_t<bool, hb_vector_t<LayerRecord>> (false, out_layers);\n-\n-                                auto layers = (this+layersZ).as_array (numLayers).sub_array (old_record->firstLayerIdx,\n-                                                                                             old_record->numLayers);\n-                                out_layers.resize (layers.length);\n-                                for (unsigned int i = 0; i < layers.length; i++) {\n-                                  out_layers[i] = layers[i];\n-                                  hb_codepoint_t new_gid = 0;\n-                                  if (unlikely (!c->plan->new_gid_for_old_gid (out_layers[i].glyphId, &new_gid)))\n-                                    return hb_pair_t<bool, hb_vector_t<LayerRecord>> (false, out_layers);\n-                                  out_layers[i].glyphId = new_gid;\n-                                  out_layers[i].colorIdx = c->plan->colr_palettes->get (layers[i].colorIdx);\n-                                }\n-\n-                                return hb_pair_t<bool, hb_vector_t<LayerRecord>> (true, out_layers);\n-                              })\n-    | hb_filter (hb_first)\n-    | hb_map_retains_sorting (hb_second)\n-    ;\n-\n-    if (version == 0 && (!base_it || !layer_it))\n-      return_trace (false);\n-\n-    COLR *colr_prime = c->serializer->start_embed<COLR> ();\n-    if (unlikely (!c->serializer->extend_min (colr_prime)))  return_trace (false);\n-\n-    if (version == 0)\n-    return_trace (colr_prime->serialize_V0 (c->serializer, version, base_it, layer_it));\n-\n-    auto snap = c->serializer->snapshot ();\n-    if (!c->serializer->allocate_size<void> (5 * HBUINT32::static_size)) return_trace (false);\n-    if (!colr_prime->baseGlyphList.serialize_subset (c, baseGlyphList, this))\n-    {\n-      if (c->serializer->in_error ()) return_trace (false);\n-      \/\/no more COLRv1 glyphs: downgrade to version 0\n-      c->serializer->revert (snap);\n-      return_trace (colr_prime->serialize_V0 (c->serializer, 0, base_it, layer_it));\n-    }\n-\n-    if (!colr_prime->serialize_V0 (c->serializer, version, base_it, layer_it)) return_trace (false);\n-\n-    colr_prime->layerList.serialize_subset (c, layerList, this);\n-    colr_prime->clipList.serialize_subset (c, clipList, this);\n-    colr_prime->varIdxMap.serialize_copy (c->serializer, varIdxMap, this);\n-    \/\/TODO: subset varStore once it's implemented in fonttools\n-    return_trace (true);\n-  }\n-\n-  protected:\n-  HBUINT16      version;        \/* Table version number (starts at 0). *\/\n-  HBUINT16      numBaseGlyphs;  \/* Number of Base Glyph Records. *\/\n-  NNOffset32To<SortedUnsizedArrayOf<BaseGlyphRecord>>\n-                baseGlyphsZ;    \/* Offset to Base Glyph records. *\/\n-  NNOffset32To<UnsizedArrayOf<LayerRecord>>\n-                layersZ;        \/* Offset to Layer Records. *\/\n-  HBUINT16      numLayers;      \/* Number of Layer Records. *\/\n-  \/\/ Version-1 additions\n-  Offset32To<BaseGlyphList>             baseGlyphList;\n-  Offset32To<LayerList>                 layerList;\n-  Offset32To<ClipList>                  clipList;   \/\/ Offset to ClipList table (may be NULL)\n-  Offset32To<DeltaSetIndexMap>          varIdxMap;  \/\/ Offset to DeltaSetIndexMap table (may be NULL)\n-  Offset32To<VariationStore>            varStore;\n-  public:\n-  DEFINE_SIZE_MIN (14);\n-};\n-\n-struct COLR_accelerator_t : COLR::accelerator_t {\n-  COLR_accelerator_t (hb_face_t *face) : COLR::accelerator_t (face) {}\n-};\n-\n-} \/* namespace OT *\/\n-\n-\n-#endif \/* HB_OT_COLOR_COLR_TABLE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-colr-table.hh","additions":0,"deletions":1541,"binary":false,"changes":1541,"status":"deleted"},{"patch":"@@ -1,423 +0,0 @@\n-\/*\n- * Copyright © 2018  Ebrahim Byagowi\n- * Copyright © 2020  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Calder Kitagawa\n- *\/\n-\n-#ifndef HB_OT_COLOR_SBIX_TABLE_HH\n-#define HB_OT_COLOR_SBIX_TABLE_HH\n-\n-#include \"hb-open-type.hh\"\n-#include \"hb-ot-layout-common.hh\"\n-\n-\/*\n- * sbix -- Standard Bitmap Graphics\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/sbix\n- * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6sbix.html\n- *\/\n-#define HB_OT_TAG_sbix HB_TAG('s','b','i','x')\n-\n-\n-namespace OT {\n-\n-\n-struct SBIXGlyph\n-{\n-  SBIXGlyph* copy (hb_serialize_context_t *c, unsigned int data_length) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    SBIXGlyph* new_glyph = c->start_embed<SBIXGlyph> ();\n-    if (unlikely (!new_glyph)) return_trace (nullptr);\n-    if (unlikely (!c->extend_min (new_glyph))) return_trace (nullptr);\n-\n-    new_glyph->xOffset = xOffset;\n-    new_glyph->yOffset = yOffset;\n-    new_glyph->graphicType = graphicType;\n-    data.copy (c, data_length);\n-    return_trace (new_glyph);\n-  }\n-\n-  HBINT16       xOffset;        \/* The horizontal (x-axis) offset from the left\n-                                 * edge of the graphic to the glyph’s origin.\n-                                 * That is, the x-coordinate of the point on the\n-                                 * baseline at the left edge of the glyph. *\/\n-  HBINT16       yOffset;        \/* The vertical (y-axis) offset from the bottom\n-                                 * edge of the graphic to the glyph’s origin.\n-                                 * That is, the y-coordinate of the point on the\n-                                 * baseline at the left edge of the glyph. *\/\n-  Tag           graphicType;    \/* Indicates the format of the embedded graphic\n-                                 * data: one of 'jpg ', 'png ' or 'tiff', or the\n-                                 * special format 'dupe'. *\/\n-  UnsizedArrayOf<HBUINT8>\n-                data;           \/* The actual embedded graphic data. The total\n-                                 * length is inferred from sequential entries in\n-                                 * the glyphDataOffsets array and the fixed size\n-                                 * (8 bytes) of the preceding fields. *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (8, data);\n-};\n-\n-struct SBIXStrike\n-{\n-  static unsigned int get_size (unsigned num_glyphs)\n-  { return min_size + num_glyphs * HBUINT32::static_size; }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  imageOffsetsZ.sanitize_shallow (c, c->get_num_glyphs () + 1));\n-  }\n-\n-  hb_blob_t *get_glyph_blob (unsigned int  glyph_id,\n-                             hb_blob_t    *sbix_blob,\n-                             hb_tag_t      file_type,\n-                             int          *x_offset,\n-                             int          *y_offset,\n-                             unsigned int  num_glyphs,\n-                             unsigned int *strike_ppem) const\n-  {\n-    if (unlikely (!ppem)) return hb_blob_get_empty (); \/* To get Null() object out of the way. *\/\n-\n-    unsigned int retry_count = 8;\n-    unsigned int sbix_len = sbix_blob->length;\n-    unsigned int strike_offset = (const char *) this - (const char *) sbix_blob->data;\n-    assert (strike_offset < sbix_len);\n-\n-  retry:\n-    if (unlikely (glyph_id >= num_glyphs ||\n-                  imageOffsetsZ[glyph_id + 1] <= imageOffsetsZ[glyph_id] ||\n-                  imageOffsetsZ[glyph_id + 1] - imageOffsetsZ[glyph_id] <= SBIXGlyph::min_size ||\n-                  (unsigned int) imageOffsetsZ[glyph_id + 1] > sbix_len - strike_offset))\n-      return hb_blob_get_empty ();\n-\n-    unsigned int glyph_offset = strike_offset + (unsigned int) imageOffsetsZ[glyph_id] + SBIXGlyph::min_size;\n-    unsigned int glyph_length = imageOffsetsZ[glyph_id + 1] - imageOffsetsZ[glyph_id] - SBIXGlyph::min_size;\n-\n-    const SBIXGlyph *glyph = &(this+imageOffsetsZ[glyph_id]);\n-\n-    if (glyph->graphicType == HB_TAG ('d','u','p','e'))\n-    {\n-      if (glyph_length >= 2)\n-      {\n-        glyph_id = *((HBUINT16 *) &glyph->data);\n-        if (retry_count--)\n-          goto retry;\n-      }\n-      return hb_blob_get_empty ();\n-    }\n-\n-    if (unlikely (file_type != glyph->graphicType))\n-      return hb_blob_get_empty ();\n-\n-    if (strike_ppem) *strike_ppem = ppem;\n-    if (x_offset) *x_offset = glyph->xOffset;\n-    if (y_offset) *y_offset = glyph->yOffset;\n-    return hb_blob_create_sub_blob (sbix_blob, glyph_offset, glyph_length);\n-  }\n-\n-  bool subset (hb_subset_context_t *c, unsigned int available_len) const\n-  {\n-    TRACE_SUBSET (this);\n-    unsigned int num_output_glyphs = c->plan->num_output_glyphs ();\n-\n-    auto* out = c->serializer->start_embed<SBIXStrike> ();\n-    if (unlikely (!out)) return_trace (false);\n-    auto snap = c->serializer->snapshot ();\n-    if (unlikely (!c->serializer->extend (out, num_output_glyphs + 1))) return_trace (false);\n-    out->ppem = ppem;\n-    out->resolution = resolution;\n-    HBUINT32 head;\n-    head = get_size (num_output_glyphs + 1);\n-\n-    bool has_glyphs = false;\n-    for (unsigned new_gid = 0; new_gid < num_output_glyphs; new_gid++)\n-    {\n-      hb_codepoint_t old_gid;\n-      if (!c->plan->old_gid_for_new_gid (new_gid, &old_gid) ||\n-          unlikely (imageOffsetsZ[old_gid].is_null () ||\n-                    imageOffsetsZ[old_gid + 1].is_null () ||\n-                    imageOffsetsZ[old_gid + 1] <= imageOffsetsZ[old_gid] ||\n-                    imageOffsetsZ[old_gid + 1] - imageOffsetsZ[old_gid] <= SBIXGlyph::min_size) ||\n-                    (unsigned int) imageOffsetsZ[old_gid + 1] > available_len)\n-      {\n-        out->imageOffsetsZ[new_gid] = head;\n-        continue;\n-      }\n-      has_glyphs = true;\n-      unsigned int delta = imageOffsetsZ[old_gid + 1] - imageOffsetsZ[old_gid];\n-      unsigned int glyph_data_length = delta - SBIXGlyph::min_size;\n-      if (!(this+imageOffsetsZ[old_gid]).copy (c->serializer, glyph_data_length))\n-        return_trace (false);\n-      out->imageOffsetsZ[new_gid] = head;\n-      head += delta;\n-    }\n-    if (has_glyphs)\n-      out->imageOffsetsZ[num_output_glyphs] = head;\n-    else\n-      c->serializer->revert (snap);\n-    return_trace (has_glyphs);\n-  }\n-\n-  public:\n-  HBUINT16      ppem;           \/* The PPEM size for which this strike was designed. *\/\n-  HBUINT16      resolution;     \/* The device pixel density (in PPI) for which this\n-                                 * strike was designed. (E.g., 96 PPI, 192 PPI.) *\/\n-  protected:\n-  UnsizedArrayOf<Offset32To<SBIXGlyph>>\n-                imageOffsetsZ;  \/* Offset from the beginning of the strike data header\n-                                 * to bitmap data for an individual glyph ID. *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (4, imageOffsetsZ);\n-};\n-\n-struct sbix\n-{\n-  static constexpr hb_tag_t tableTag = HB_OT_TAG_sbix;\n-\n-  bool has_data () const { return version; }\n-\n-  const SBIXStrike &get_strike (unsigned int i) const { return this+strikes[i]; }\n-\n-  struct accelerator_t\n-  {\n-    accelerator_t (hb_face_t *face)\n-    {\n-      table = hb_sanitize_context_t ().reference_table<sbix> (face);\n-      num_glyphs = face->get_num_glyphs ();\n-    }\n-    ~accelerator_t () { table.destroy (); }\n-\n-    bool has_data () const { return table->has_data (); }\n-\n-    bool get_extents (hb_font_t          *font,\n-                      hb_codepoint_t      glyph,\n-                      hb_glyph_extents_t *extents) const\n-    {\n-      \/* We only support PNG right now, and following function checks type. *\/\n-      return get_png_extents (font, glyph, extents);\n-    }\n-\n-    hb_blob_t *reference_png (hb_font_t      *font,\n-                              hb_codepoint_t  glyph_id,\n-                              int            *x_offset,\n-                              int            *y_offset,\n-                              unsigned int   *available_ppem) const\n-    {\n-      return choose_strike (font).get_glyph_blob (glyph_id, table.get_blob (),\n-                                                  HB_TAG ('p','n','g',' '),\n-                                                  x_offset, y_offset,\n-                                                  num_glyphs, available_ppem);\n-    }\n-\n-    private:\n-\n-    const SBIXStrike &choose_strike (hb_font_t *font) const\n-    {\n-      unsigned count = table->strikes.len;\n-      if (unlikely (!count))\n-        return Null (SBIXStrike);\n-\n-      unsigned int requested_ppem = hb_max (font->x_ppem, font->y_ppem);\n-      if (!requested_ppem)\n-        requested_ppem = 1<<30; \/* Choose largest strike. *\/\n-      \/* TODO Add DPI sensitivity as well? *\/\n-      unsigned int best_i = 0;\n-      unsigned int best_ppem = table->get_strike (0).ppem;\n-\n-      for (unsigned int i = 1; i < count; i++)\n-      {\n-        unsigned int ppem = (table->get_strike (i)).ppem;\n-        if ((requested_ppem <= ppem && ppem < best_ppem) ||\n-            (requested_ppem > best_ppem && ppem > best_ppem))\n-        {\n-          best_i = i;\n-          best_ppem = ppem;\n-        }\n-      }\n-\n-      return table->get_strike (best_i);\n-    }\n-\n-    struct PNGHeader\n-    {\n-      HBUINT8   signature[8];\n-      struct\n-      {\n-        struct\n-        {\n-          HBUINT32      length;\n-          Tag           type;\n-        }               header;\n-        HBUINT32        width;\n-        HBUINT32        height;\n-        HBUINT8         bitDepth;\n-        HBUINT8         colorType;\n-        HBUINT8         compressionMethod;\n-        HBUINT8         filterMethod;\n-        HBUINT8         interlaceMethod;\n-      } IHDR;\n-\n-      public:\n-      DEFINE_SIZE_STATIC (29);\n-    };\n-\n-    bool get_png_extents (hb_font_t          *font,\n-                          hb_codepoint_t      glyph,\n-                          hb_glyph_extents_t *extents) const\n-    {\n-      \/* Following code is safe to call even without data.\n-       * But faster to short-circuit. *\/\n-      if (!has_data ())\n-        return false;\n-\n-      int x_offset = 0, y_offset = 0;\n-      unsigned int strike_ppem = 0;\n-      hb_blob_t *blob = reference_png (font, glyph, &x_offset, &y_offset, &strike_ppem);\n-\n-      const PNGHeader &png = *blob->as<PNGHeader>();\n-\n-      if (png.IHDR.height >= 65536 || png.IHDR.width >= 65536)\n-      {\n-        hb_blob_destroy (blob);\n-        return false;\n-      }\n-\n-      extents->x_bearing = x_offset;\n-      extents->y_bearing = png.IHDR.height + y_offset;\n-      extents->width     = png.IHDR.width;\n-      extents->height    = -1 * png.IHDR.height;\n-\n-      \/* Convert to font units. *\/\n-      if (strike_ppem)\n-      {\n-        float scale = font->face->get_upem () \/ (float) strike_ppem;\n-        extents->x_bearing = font->em_scalef_x (extents->x_bearing * scale);\n-        extents->y_bearing = font->em_scalef_y (extents->y_bearing * scale);\n-        extents->width = font->em_scalef_x (extents->width * scale);\n-        extents->height = font->em_scalef_y (extents->height * scale);\n-      }\n-      else\n-      {\n-        extents->x_bearing = font->em_scale_x (extents->x_bearing);\n-        extents->y_bearing = font->em_scale_y (extents->y_bearing);\n-        extents->width = font->em_scale_x (extents->width);\n-        extents->height = font->em_scale_y (extents->height);\n-      }\n-\n-      hb_blob_destroy (blob);\n-\n-      return strike_ppem;\n-    }\n-\n-    private:\n-    hb_blob_ptr_t<sbix> table;\n-\n-    unsigned int num_glyphs;\n-  };\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (likely (c->check_struct (this) &&\n-                          version >= 1 &&\n-                          strikes.sanitize (c, this)));\n-  }\n-\n-  bool\n-  add_strike (hb_subset_context_t *c, unsigned i) const\n-  {\n-    if (strikes[i].is_null () || c->source_blob->length < (unsigned) strikes[i])\n-      return false;\n-\n-    return (this+strikes[i]).subset (c, c->source_blob->length - (unsigned) strikes[i]);\n-  }\n-\n-  bool serialize_strike_offsets (hb_subset_context_t *c) const\n-  {\n-    TRACE_SERIALIZE (this);\n-\n-    auto *out = c->serializer->start_embed<Array32OfOffset32To<SBIXStrike>> ();\n-    if (unlikely (!out)) return_trace (false);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-\n-    hb_vector_t<Offset32To<SBIXStrike>*> new_strikes;\n-    hb_vector_t<hb_serialize_context_t::objidx_t> objidxs;\n-    for (int i = strikes.len - 1; i >= 0; --i)\n-    {\n-      auto* o = out->serialize_append (c->serializer);\n-      if (unlikely (!o)) return_trace (false);\n-      *o = 0;\n-      auto snap = c->serializer->snapshot ();\n-      c->serializer->push ();\n-      bool ret = add_strike (c, i);\n-      if (!ret)\n-      {\n-        c->serializer->pop_discard ();\n-        out->pop ();\n-        c->serializer->revert (snap);\n-      }\n-      else\n-      {\n-        objidxs.push (c->serializer->pop_pack ());\n-        new_strikes.push (o);\n-      }\n-    }\n-    for (unsigned int i = 0; i < new_strikes.length; ++i)\n-      c->serializer->add_link (*new_strikes[i], objidxs[new_strikes.length - 1 - i]);\n-\n-    return_trace (true);\n-  }\n-\n-  bool subset (hb_subset_context_t* c) const\n-  {\n-    TRACE_SUBSET (this);\n-\n-    sbix *sbix_prime = c->serializer->start_embed<sbix> ();\n-    if (unlikely (!sbix_prime)) return_trace (false);\n-    if (unlikely (!c->serializer->embed (this->version))) return_trace (false);\n-    if (unlikely (!c->serializer->embed (this->flags))) return_trace (false);\n-\n-    return_trace (serialize_strike_offsets (c));\n-  }\n-\n-  protected:\n-  HBUINT16      version;        \/* Table version number — set to 1 *\/\n-  HBUINT16      flags;          \/* Bit 0: Set to 1. Bit 1: Draw outlines.\n-                                 * Bits 2 to 15: reserved (set to 0). *\/\n-  Array32OfOffset32To<SBIXStrike>\n-                strikes;        \/* Offsets from the beginning of the 'sbix'\n-                                 * table to data for each individual bitmap strike. *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (8, strikes);\n-};\n-\n-struct sbix_accelerator_t : sbix::accelerator_t {\n-  sbix_accelerator_t (hb_face_t *face) : sbix::accelerator_t (face) {}\n-};\n-\n-\n-} \/* namespace OT *\/\n-\n-#endif \/* HB_OT_COLOR_SBIX_TABLE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-sbix-table.hh","additions":0,"deletions":423,"binary":false,"changes":423,"status":"deleted"},{"patch":"@@ -1,126 +0,0 @@\n-\/*\n- * Copyright © 2018  Ebrahim Byagowi\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\/\n-\n-#ifndef HB_OT_COLOR_SVG_TABLE_HH\n-#define HB_OT_COLOR_SVG_TABLE_HH\n-\n-#include \"hb-open-type.hh\"\n-\n-\/*\n- * SVG -- SVG (Scalable Vector Graphics)\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/svg\n- *\/\n-\n-#define HB_OT_TAG_SVG HB_TAG('S','V','G',' ')\n-\n-\n-namespace OT {\n-\n-\n-struct SVGDocumentIndexEntry\n-{\n-  int cmp (hb_codepoint_t g) const\n-  { return g < startGlyphID ? -1 : g > endGlyphID ? 1 : 0; }\n-\n-  hb_blob_t *reference_blob (hb_blob_t *svg_blob, unsigned int index_offset) const\n-  {\n-    return hb_blob_create_sub_blob (svg_blob,\n-                                    index_offset + (unsigned int) svgDoc,\n-                                    svgDocLength);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  svgDoc.sanitize (c, base, svgDocLength));\n-  }\n-\n-  protected:\n-  HBUINT16      startGlyphID;   \/* The first glyph ID in the range described by\n-                                 * this index entry. *\/\n-  HBUINT16      endGlyphID;     \/* The last glyph ID in the range described by\n-                                 * this index entry. Must be >= startGlyphID. *\/\n-  NNOffset32To<UnsizedArrayOf<HBUINT8>>\n-                svgDoc;         \/* Offset from the beginning of the SVG Document Index\n-                                 * to an SVG document. Must be non-zero. *\/\n-  HBUINT32      svgDocLength;   \/* Length of the SVG document.\n-                                 * Must be non-zero. *\/\n-  public:\n-  DEFINE_SIZE_STATIC (12);\n-};\n-\n-struct SVG\n-{\n-  static constexpr hb_tag_t tableTag = HB_OT_TAG_SVG;\n-\n-  bool has_data () const { return svgDocEntries; }\n-\n-  struct accelerator_t\n-  {\n-    accelerator_t (hb_face_t *face)\n-    { table = hb_sanitize_context_t ().reference_table<SVG> (face); }\n-    ~accelerator_t () { table.destroy (); }\n-\n-    hb_blob_t *reference_blob_for_glyph (hb_codepoint_t glyph_id) const\n-    {\n-      return table->get_glyph_entry (glyph_id).reference_blob (table.get_blob (),\n-                                                               table->svgDocEntries);\n-    }\n-\n-    bool has_data () const { return table->has_data (); }\n-\n-    private:\n-    hb_blob_ptr_t<SVG> table;\n-  };\n-\n-  const SVGDocumentIndexEntry &get_glyph_entry (hb_codepoint_t glyph_id) const\n-  { return (this+svgDocEntries).bsearch (glyph_id); }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (likely (c->check_struct (this) &&\n-                          (this+svgDocEntries).sanitize_shallow (c)));\n-  }\n-\n-  protected:\n-  HBUINT16      version;        \/* Table version (starting at 0). *\/\n-  Offset32To<SortedArray16Of<SVGDocumentIndexEntry>>\n-                svgDocEntries;  \/* Offset (relative to the start of the SVG table) to the\n-                                 * SVG Documents Index. Must be non-zero. *\/\n-                                \/* Array of SVG Document Index Entries. *\/\n-  HBUINT32      reserved;       \/* Set to 0. *\/\n-  public:\n-  DEFINE_SIZE_STATIC (10);\n-};\n-\n-struct SVG_accelerator_t : SVG::accelerator_t {\n-  SVG_accelerator_t (hb_face_t *face) : SVG::accelerator_t (face) {}\n-};\n-\n-} \/* namespace OT *\/\n-\n-\n-#endif \/* HB_OT_COLOR_SVG_TABLE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-svg-table.hh","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -34,5 +34,5 @@\n-#include \"hb-ot-color-cbdt-table.hh\"\n-#include \"hb-ot-color-colr-table.hh\"\n-#include \"hb-ot-color-cpal-table.hh\"\n-#include \"hb-ot-color-sbix-table.hh\"\n-#include \"hb-ot-color-svg-table.hh\"\n+#include \"OT\/Color\/CBDT\/CBDT.hh\"\n+#include \"OT\/Color\/COLR\/COLR.hh\"\n+#include \"OT\/Color\/CPAL\/CPAL.hh\"\n+#include \"OT\/Color\/sbix\/sbix.hh\"\n+#include \"OT\/Color\/svg\/svg.hh\"\n@@ -64,1 +64,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -170,0 +170,4 @@\n+ * The RGBA values in the palette are unpremultiplied. See the\n+ * OpenType spec [CPAL](https:\/\/learn.microsoft.com\/en-us\/typography\/opentype\/spec\/cpal)\n+ * section for details.\n+ *\n@@ -193,1 +197,2 @@\n- * Tests whether a face includes any `COLR` color layers.\n+ * Tests whether a face includes a `COLR` table\n+ * with data according to COLRv0.\n@@ -195,1 +200,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -202,1 +207,37 @@\n-  return face->table.COLR->has_data ();\n+  return face->table.COLR->has_v0_data ();\n+}\n+\n+\/**\n+ * hb_ot_color_has_paint:\n+ * @face: #hb_face_t to work upon\n+ *\n+ * Tests where a face includes a `COLR` table\n+ * with data according to COLRv1.\n+ *\n+ * Return value: `true` if data found, `false` otherwise\n+ *\n+ * Since: 7.0.0\n+ *\/\n+hb_bool_t\n+hb_ot_color_has_paint (hb_face_t *face)\n+{\n+  return face->table.COLR->has_v1_data ();\n+}\n+\n+\/**\n+ * hb_ot_color_glyph_has_paint:\n+ * @face: #hb_face_t to work upon\n+ * @glyph: The glyph index to query\n+ *\n+ * Tests where a face includes COLRv1 paint\n+ * data for @glyph.\n+ *\n+ * Return value: `true` if data found, `false` otherwise\n+ *\n+ * Since: 7.0.0\n+ *\/\n+hb_bool_t\n+hb_ot_color_glyph_has_paint (hb_face_t      *face,\n+                             hb_codepoint_t  glyph)\n+{\n+  return face->table.COLR->has_paint_for_glyph (glyph);\n@@ -242,1 +283,1 @@\n- * Return value: %true if data found, %false otherwise.\n+ * Return value: `true` if data found, `false` otherwise.\n@@ -282,1 +323,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -298,2 +339,2 @@\n- * as input. To get an optimally sized PNG blob, the UPEM value must be set on the @font\n- * object. If UPEM is unset, the blob returned will be the largest PNG available.\n+ * as input. To get an optimally sized PNG blob, the PPEM values must be set on the @font\n+ * object. If PPEM is unset, the blob returned will be the largest PNG available.\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color.cc","additions":54,"deletions":13,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -105,0 +105,4 @@\n+ * A color index of 0xFFFF does not refer to a palette\n+ * color, but indicates that the foreground color should\n+ * be used.\n+ *\n@@ -119,0 +123,9 @@\n+\/* COLRv1 *\/\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_color_has_paint (hb_face_t *face);\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_color_glyph_has_paint (hb_face_t      *face,\n+                             hb_codepoint_t  glyph);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color.h","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -70,1 +70,2 @@\n-HB_EXTERN HB_DEPRECATED_FOR (hb_ot_layout_table_select_script) hb_bool_t\n+HB_DEPRECATED_FOR (hb_ot_layout_table_select_script)\n+HB_EXTERN hb_bool_t\n@@ -77,1 +78,2 @@\n-HB_EXTERN HB_DEPRECATED_FOR (hb_ot_layout_script_select_language) hb_bool_t\n+HB_DEPRECATED_FOR (hb_ot_layout_script_select_language)\n+HB_EXTERN hb_bool_t\n@@ -84,1 +86,2 @@\n-HB_EXTERN HB_DEPRECATED_FOR (hb_ot_tags_from_script_and_language) void\n+HB_DEPRECATED_FOR (hb_ot_tags_from_script_and_language)\n+HB_EXTERN void\n@@ -89,1 +92,2 @@\n-HB_EXTERN HB_DEPRECATED_FOR (hb_ot_tags_from_script_and_language) hb_tag_t\n+HB_DEPRECATED_FOR (hb_ot_tags_from_script_and_language)\n+HB_EXTERN hb_tag_t\n@@ -124,1 +128,2 @@\n-HB_EXTERN HB_DEPRECATED_FOR (hb_ot_var_get_axis_infos) unsigned int\n+HB_DEPRECATED_FOR (hb_ot_var_get_axis_infos)\n+HB_EXTERN unsigned int\n@@ -130,1 +135,2 @@\n-HB_EXTERN HB_DEPRECATED_FOR (hb_ot_var_find_axis_info) hb_bool_t\n+HB_DEPRECATED_FOR (hb_ot_var_find_axis_info)\n+HB_EXTERN hb_bool_t\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-deprecated.h","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-HB_OT_TABLE (OT, hhea)\n+HB_OT_CORE_TABLE (OT, hhea)\n@@ -61,1 +61,1 @@\n-HB_OT_TABLE (OT, OS2)\n+HB_OT_CORE_TABLE (OT, OS2)\n@@ -69,1 +69,1 @@\n-HB_OT_TABLE (OT, STAT)\n+HB_OT_CORE_TABLE (OT, STAT)\n@@ -77,1 +77,1 @@\n-HB_OT_TABLE (OT, vhea)\n+HB_OT_CORE_TABLE (OT, vhea)\n@@ -79,1 +79,1 @@\n-HB_OT_TABLE (OT, VORG)\n+HB_OT_CORE_TABLE (OT, VORG)\n@@ -94,2 +94,2 @@\n-HB_OT_TABLE (OT, fvar)\n-HB_OT_TABLE (OT, avar)\n+HB_OT_CORE_TABLE (OT, fvar)\n+HB_OT_CORE_TABLE (OT, avar)\n@@ -97,1 +97,1 @@\n-HB_OT_TABLE (OT, MVAR)\n+HB_OT_CORE_TABLE (OT, MVAR)\n@@ -102,1 +102,1 @@\n-HB_OT_TABLE (OT, kern)\n+HB_OT_CORE_TABLE (OT, kern)\n@@ -110,1 +110,1 @@\n-\/\/HB_OT_TABLE (OT, JSTF)\n+\/\/HB_OT_CORE_TABLE (OT, JSTF)\n@@ -115,1 +115,1 @@\n-HB_OT_TABLE (OT, BASE)\n+HB_OT_CORE_TABLE (OT, BASE)\n@@ -132,2 +132,2 @@\n-HB_OT_TABLE (OT, COLR)\n-HB_OT_TABLE (OT, CPAL)\n+HB_OT_CORE_TABLE (OT, COLR)\n+HB_OT_CORE_TABLE (OT, CPAL)\n@@ -141,1 +141,1 @@\n-HB_OT_TABLE (OT, MATH)\n+HB_OT_CORE_TABLE (OT, MATH)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-face-table-list.hh","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -38,3 +38,3 @@\n-#include \"hb-ot-color-cbdt-table.hh\"\n-#include \"hb-ot-color-sbix-table.hh\"\n-#include \"hb-ot-color-svg-table.hh\"\n+#include \"OT\/Color\/CBDT\/CBDT.hh\"\n+#include \"OT\/Color\/sbix\/sbix.hh\"\n+#include \"OT\/Color\/svg\/svg.hh\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-face.cc","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"hb-outline.hh\"\n@@ -43,1 +44,0 @@\n-#include \"hb-ot-os2-table.hh\"\n@@ -47,2 +47,4 @@\n-#include \"hb-ot-color-cbdt-table.hh\"\n-#include \"hb-ot-color-sbix-table.hh\"\n+#include \"OT\/Color\/CBDT\/CBDT.hh\"\n+#include \"OT\/Color\/COLR\/COLR.hh\"\n+#include \"OT\/Color\/sbix\/sbix.hh\"\n+#include \"OT\/Color\/svg\/svg.hh\"\n@@ -62,0 +64,5 @@\n+using hb_ot_font_cmap_cache_t    = hb_cache_t<21, 16, 8, true>;\n+using hb_ot_font_advance_cache_t = hb_cache_t<24, 16, 8, true>;\n+\n+static hb_user_data_key_t hb_ot_font_cmap_cache_user_data_key;\n+\n@@ -66,0 +73,2 @@\n+  hb_ot_font_cmap_cache_t *cmap_cache;\n+\n@@ -68,1 +77,1 @@\n-  mutable hb_atomic_ptr_t<hb_advance_cache_t> advance_cache;\n+  mutable hb_atomic_ptr_t<hb_ot_font_advance_cache_t> advance_cache;\n@@ -80,0 +89,27 @@\n+  \/\/ retry:\n+  auto *cmap_cache  = (hb_ot_font_cmap_cache_t *) hb_face_get_user_data (font->face,\n+                                                                         &hb_ot_font_cmap_cache_user_data_key);\n+  if (!cmap_cache)\n+  {\n+    cmap_cache = (hb_ot_font_cmap_cache_t *) hb_malloc (sizeof (hb_ot_font_cmap_cache_t));\n+    if (unlikely (!cmap_cache)) goto out;\n+    cmap_cache->init ();\n+    if (unlikely (!hb_face_set_user_data (font->face,\n+                                          &hb_ot_font_cmap_cache_user_data_key,\n+                                          cmap_cache,\n+                                          hb_free,\n+                                          false)))\n+    {\n+      hb_free (cmap_cache);\n+      cmap_cache = nullptr;\n+      \/* Normally we would retry here, but that would\n+       * infinite-loop if the face is the empty-face.\n+       * Just let it go and this font will be uncached if it\n+       * happened to collide with another thread creating the\n+       * cache at the same time. *\/\n+      \/\/ goto retry;\n+    }\n+  }\n+  out:\n+  ot_font->cmap_cache = cmap_cache;\n+\n@@ -89,5 +125,1 @@\n-  if (cache)\n-  {\n-    cache->fini ();\n-    hb_free (cache);\n-  }\n+  hb_free (cache);\n@@ -107,1 +139,1 @@\n-  return ot_face->cmap->get_nominal_glyph (unicode, glyph);\n+  return ot_face->cmap->get_nominal_glyph (unicode, glyph, ot_font->cmap_cache);\n@@ -124,1 +156,2 @@\n-                                            first_glyph, glyph_stride);\n+                                            first_glyph, glyph_stride,\n+                                            ot_font->cmap_cache);\n@@ -137,1 +170,3 @@\n-  return ot_face->cmap->get_variation_glyph (unicode, variation_selector, glyph);\n+  return ot_face->cmap->get_variation_glyph (unicode,\n+                                             variation_selector, glyph,\n+                                             ot_font->cmap_cache);\n@@ -149,0 +184,1 @@\n+\n@@ -153,0 +189,2 @@\n+  hb_position_t *orig_first_advance = first_advance;\n+\n@@ -154,1 +192,1 @@\n-  const OT::HVARVVAR &HVAR = *hmtx.var_table;\n+  const OT::HVAR &HVAR = *hmtx.var_table;\n@@ -164,1 +202,1 @@\n-  hb_advance_cache_t *cache = nullptr;\n+  hb_ot_font_advance_cache_t *cache = nullptr;\n@@ -168,1 +206,1 @@\n-    cache = ot_font->advance_cache.get ();\n+    cache = ot_font->advance_cache.get_acquire ();\n@@ -171,1 +209,1 @@\n-      cache = (hb_advance_cache_t *) hb_malloc (sizeof (hb_advance_cache_t));\n+      cache = (hb_ot_font_advance_cache_t *) hb_malloc (sizeof (hb_ot_font_advance_cache_t));\n@@ -184,1 +222,1 @@\n-      ot_font->cached_coords_serial.set (font->serial_coords);\n+      ot_font->cached_coords_serial.set_release (font->serial_coords);\n@@ -193,1 +231,1 @@\n-      *first_advance = font->em_scale_x (hmtx.get_advance (*first_glyph, font, varStore_cache));\n+      *first_advance = font->em_scale_x (hmtx.get_advance_with_var_unscaled (*first_glyph, font, varStore_cache));\n@@ -200,1 +238,1 @@\n-    if (ot_font->cached_coords_serial.get () != (int) font->serial_coords)\n+    if (ot_font->cached_coords_serial.get_acquire () != (int) font->serial_coords)\n@@ -203,1 +241,1 @@\n-      ot_font->cached_coords_serial.set (font->serial_coords);\n+      ot_font->cached_coords_serial.set_release (font->serial_coords);\n@@ -214,1 +252,1 @@\n-        v = hmtx.get_advance (*first_glyph, font, varStore_cache);\n+        v = hmtx.get_advance_with_var_unscaled (*first_glyph, font, varStore_cache);\n@@ -226,0 +264,12 @@\n+\n+  if (font->x_strength && !font->embolden_in_place)\n+  {\n+    \/* Emboldening. *\/\n+    hb_position_t x_strength = font->x_scale >= 0 ? font->x_strength : -font->x_strength;\n+    first_advance = orig_first_advance;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      *first_advance += *first_advance ? x_strength : 0;\n+      first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+    }\n+  }\n@@ -242,0 +292,2 @@\n+  hb_position_t *orig_first_advance = first_advance;\n+\n@@ -245,1 +297,1 @@\n-    const OT::HVARVVAR &VVAR = *vmtx.var_table;\n+    const OT::VVAR &VVAR = *vmtx.var_table;\n@@ -254,1 +306,1 @@\n-      *first_advance = font->em_scale_y (-(int) vmtx.get_advance (*first_glyph, font, varStore_cache));\n+      *first_advance = font->em_scale_y (-(int) vmtx.get_advance_with_var_unscaled (*first_glyph, font, varStore_cache));\n@@ -276,0 +328,12 @@\n+\n+  if (font->y_strength && !font->embolden_in_place)\n+  {\n+    \/* Emboldening. *\/\n+    hb_position_t y_strength = font->y_scale >= 0 ? font->y_strength : -font->y_strength;\n+    first_advance = orig_first_advance;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      *first_advance += *first_advance ? y_strength : 0;\n+      first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+    }\n+  }\n@@ -296,1 +360,12 @@\n-    *y = font->em_scale_y (VORG.get_y_origin (glyph));\n+    float delta = 0;\n+\n+#ifndef HB_NO_VAR\n+    const OT::vmtx_accelerator_t &vmtx = *ot_face->vmtx;\n+    const OT::VVAR &VVAR = *vmtx.var_table;\n+    if (font->num_coords)\n+      VVAR.get_vorg_delta_unscaled (glyph,\n+                                    font->coords, font->num_coords,\n+                                    &delta);\n+#endif\n+\n+    *y = font->em_scalef_y (VORG.get_y_origin (glyph) + delta);\n@@ -303,1 +378,3 @@\n-    if (ot_face->vmtx->has_data ())\n+    const OT::vmtx_accelerator_t &vmtx = *ot_face->vmtx;\n+    int tsb = 0;\n+    if (vmtx.get_leading_bearing_with_var_unscaled (font, glyph, &tsb))\n@@ -305,2 +382,0 @@\n-      const OT::vmtx_accelerator_t &vmtx = *ot_face->vmtx;\n-      hb_position_t tsb = vmtx.get_side_bearing (font, glyph);\n@@ -339,0 +414,4 @@\n+  if (ot_face->CBDT->get_extents (font, glyph, extents)) return true;\n+#endif\n+#if !defined(HB_NO_COLOR)\n+  if (ot_face->COLR->get_extents (font, glyph, extents)) return true;\n@@ -345,3 +424,0 @@\n-#if !defined(HB_NO_OT_FONT_BITMAP) && !defined(HB_NO_COLOR)\n-  if (ot_face->CBDT->get_extents (font, glyph, extents)) return true;\n-#endif\n@@ -349,1 +425,0 @@\n-  \/\/ TODO Hook up side-bearings variations.\n@@ -394,3 +469,10 @@\n-  return _hb_ot_metrics_get_position_common (font, HB_OT_METRICS_TAG_HORIZONTAL_ASCENDER, &metrics->ascender) &&\n-         _hb_ot_metrics_get_position_common (font, HB_OT_METRICS_TAG_HORIZONTAL_DESCENDER, &metrics->descender) &&\n-         _hb_ot_metrics_get_position_common (font, HB_OT_METRICS_TAG_HORIZONTAL_LINE_GAP, &metrics->line_gap);\n+  bool ret = _hb_ot_metrics_get_position_common (font, HB_OT_METRICS_TAG_HORIZONTAL_ASCENDER, &metrics->ascender) &&\n+             _hb_ot_metrics_get_position_common (font, HB_OT_METRICS_TAG_HORIZONTAL_DESCENDER, &metrics->descender) &&\n+             _hb_ot_metrics_get_position_common (font, HB_OT_METRICS_TAG_HORIZONTAL_LINE_GAP, &metrics->line_gap);\n+\n+  \/* Embolden *\/\n+  int y_shift = font->y_strength;\n+  if (font->y_scale < 0) y_shift = -y_shift;\n+  metrics->ascender += y_shift;\n+\n+  return ret;\n@@ -414,5 +496,5 @@\n-hb_ot_get_glyph_shape (hb_font_t *font,\n-                       void *font_data HB_UNUSED,\n-                       hb_codepoint_t glyph,\n-                       hb_draw_funcs_t *draw_funcs, void *draw_data,\n-                       void *user_data)\n+hb_ot_draw_glyph (hb_font_t *font,\n+                  void *font_data HB_UNUSED,\n+                  hb_codepoint_t glyph,\n+                  hb_draw_funcs_t *draw_funcs, void *draw_data,\n+                  void *user_data)\n@@ -420,2 +502,7 @@\n-  hb_draw_session_t draw_session (draw_funcs, draw_data, font->slant_xy);\n-  if (font->face->table.glyf->get_path (font, glyph, draw_session)) return;\n+  bool embolden = font->x_strength || font->y_strength;\n+  hb_outline_t outline;\n+\n+  { \/\/ Need draw_session to be destructed before emboldening.\n+    hb_draw_session_t draw_session (embolden ? hb_outline_recording_pen_get_funcs () : draw_funcs,\n+                                    embolden ? &outline : draw_data, font->slant_xy);\n+    if (!font->face->table.glyf->get_path (font, glyph, draw_session))\n@@ -423,2 +510,42 @@\n-  if (font->face->table.cff1->get_path (font, glyph, draw_session)) return;\n-  if (font->face->table.cff2->get_path (font, glyph, draw_session)) return;\n+    if (!font->face->table.cff1->get_path (font, glyph, draw_session))\n+    if (!font->face->table.cff2->get_path (font, glyph, draw_session))\n+#endif\n+    {}\n+  }\n+\n+  if (embolden)\n+  {\n+    float x_shift = font->embolden_in_place ? 0 : (float) font->x_strength \/ 2;\n+    float y_shift = (float) font->y_strength \/ 2;\n+    if (font->x_scale < 0) x_shift = -x_shift;\n+    if (font->y_scale < 0) y_shift = -y_shift;\n+    outline.embolden (font->x_strength, font->y_strength,\n+                      x_shift, y_shift);\n+\n+    outline.replay (draw_funcs, draw_data);\n+  }\n+}\n+#endif\n+\n+#ifndef HB_NO_PAINT\n+static void\n+hb_ot_paint_glyph (hb_font_t *font,\n+                   void *font_data,\n+                   hb_codepoint_t glyph,\n+                   hb_paint_funcs_t *paint_funcs, void *paint_data,\n+                   unsigned int palette,\n+                   hb_color_t foreground,\n+                   void *user_data)\n+{\n+#ifndef HB_NO_COLOR\n+  if (font->face->table.COLR->paint_glyph (font, glyph, paint_funcs, paint_data, palette, foreground)) return;\n+  if (font->face->table.SVG->paint_glyph (font, glyph, paint_funcs, paint_data)) return;\n+#ifndef HB_NO_OT_FONT_BITMAP\n+  if (font->face->table.CBDT->paint_glyph (font, glyph, paint_funcs, paint_data)) return;\n+  if (font->face->table.sbix->paint_glyph (font, glyph, paint_funcs, paint_data)) return;\n+#endif\n+#endif\n+  if (font->face->table.glyf->paint_glyph (font, glyph, paint_funcs, paint_data, foreground)) return;\n+#ifndef HB_NO_CFF\n+  if (font->face->table.cff1->paint_glyph (font, glyph, paint_funcs, paint_data, foreground)) return;\n+  if (font->face->table.cff2->paint_glyph (font, glyph, paint_funcs, paint_data, foreground)) return;\n@@ -452,1 +579,5 @@\n-    hb_font_funcs_set_glyph_shape_func (funcs, hb_ot_get_glyph_shape, nullptr, nullptr);\n+    hb_font_funcs_set_draw_glyph_func (funcs, hb_ot_draw_glyph, nullptr, nullptr);\n+#endif\n+\n+#ifndef HB_NO_PAINT\n+    hb_font_funcs_set_paint_glyph_func (funcs, hb_ot_paint_glyph, nullptr, nullptr);\n@@ -506,2 +637,3 @@\n-int\n-_glyf_get_side_bearing_var (hb_font_t *font, hb_codepoint_t glyph, bool is_vertical)\n+bool\n+_glyf_get_leading_bearing_with_var_unscaled (hb_font_t *font, hb_codepoint_t glyph, bool is_vertical,\n+                                             int *lsb)\n@@ -509,1 +641,1 @@\n-  return font->face->table.glyf->get_side_bearing_var (font, glyph, is_vertical);\n+  return font->face->table.glyf->get_leading_bearing_with_var_unscaled (font, glyph, is_vertical, lsb);\n@@ -513,1 +645,1 @@\n-_glyf_get_advance_var (hb_font_t *font, hb_codepoint_t glyph, bool is_vertical)\n+_glyf_get_advance_with_var_unscaled (hb_font_t *font, hb_codepoint_t glyph, bool is_vertical)\n@@ -515,1 +647,1 @@\n-  return font->face->table.glyf->get_advance_var (font, glyph, is_vertical);\n+  return font->face->table.glyf->get_advance_with_var_unscaled (font, glyph, is_vertical);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-font.cc","additions":181,"deletions":49,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -159,0 +159,1 @@\n+                  min_size + numRecords * sizeDeviceRecord > numRecords * sizeDeviceRecord &&\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-hdmx-table.hh","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+  public:\n@@ -144,0 +145,1 @@\n+  protected:\n@@ -151,0 +153,1 @@\n+  public:\n@@ -155,0 +158,1 @@\n+  protected:\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-head-table.hh","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"hb-ot-var-mvar-table.hh\"\n@@ -46,2 +47,2 @@\n-HB_INTERNAL int\n-_glyf_get_side_bearing_var (hb_font_t *font, hb_codepoint_t glyph, bool is_vertical);\n+HB_INTERNAL bool\n+_glyf_get_leading_bearing_with_var_unscaled (hb_font_t *font, hb_codepoint_t glyph, bool is_vertical, int *lsb);\n@@ -50,1 +51,1 @@\n-_glyf_get_advance_var (hb_font_t *font, hb_codepoint_t glyph, bool is_vertical);\n+_glyf_get_advance_with_var_unscaled (hb_font_t *font, hb_codepoint_t glyph, bool is_vertical);\n@@ -65,1 +66,1 @@\n-template <typename T, typename H>\n+template <typename T\/*Data table type*\/, typename H\/*Header table type*\/, typename V\/*Var table type*\/>\n@@ -76,0 +77,2 @@\n+  const hb_hashmap_t<hb_codepoint_t, hb_pair_t<unsigned, int>>* get_mtx_map (const hb_subset_plan_t *plan) const\n+  { return T::is_horizontal ? &plan->hmtx_map : &plan->vmtx_map; }\n@@ -77,2 +80,4 @@\n-  bool subset_update_header (hb_subset_plan_t *plan,\n-                             unsigned int num_hmetrics) const\n+  bool subset_update_header (hb_subset_context_t *c,\n+                             unsigned int num_hmetrics,\n+                             const hb_hashmap_t<hb_codepoint_t, hb_pair_t<unsigned, int>> *mtx_map,\n+                             const hb_map_t *bounds_map) const\n@@ -80,1 +85,1 @@\n-    hb_blob_t *src_blob = hb_sanitize_context_t ().reference_table<H> (plan->source, H::tableTag);\n+    hb_blob_t *src_blob = hb_sanitize_context_t ().reference_table<H> (c->plan->source, H::tableTag);\n@@ -92,1 +97,50 @@\n-    bool result = plan->add_table (H::tableTag, dest_blob);\n+#ifndef HB_NO_VAR\n+    if (c->plan->normalized_coords)\n+    {\n+      auto &MVAR = *c->plan->source->table.MVAR;\n+      if (T::is_horizontal)\n+      {\n+        HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_HORIZONTAL_CARET_RISE,   caretSlopeRise);\n+        HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_HORIZONTAL_CARET_RUN,    caretSlopeRun);\n+        HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_HORIZONTAL_CARET_OFFSET, caretOffset);\n+      }\n+      else\n+      {\n+        HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_VERTICAL_CARET_RISE,     caretSlopeRise);\n+        HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_VERTICAL_CARET_RUN,      caretSlopeRun);\n+        HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_VERTICAL_CARET_OFFSET,   caretOffset);\n+      }\n+\n+      int min_lsb = 0x7FFF;\n+      int min_rsb = 0x7FFF;\n+      int max_extent = -0x7FFF;\n+      unsigned max_adv = 0;\n+      for (const auto _ : *mtx_map)\n+      {\n+        hb_codepoint_t gid = _.first;\n+        unsigned adv = _.second.first;\n+        int lsb = _.second.second;\n+        max_adv = hb_max (max_adv, adv);\n+\n+        if (bounds_map->has (gid))\n+        {\n+          unsigned bound_width = bounds_map->get (gid);\n+          int rsb = adv - lsb - bound_width;\n+          int extent = lsb + bound_width;\n+          min_lsb = hb_min (min_lsb, lsb);\n+          min_rsb = hb_min (min_rsb, rsb);\n+          max_extent = hb_max (max_extent, extent);\n+        }\n+      }\n+\n+      table->advanceMax = max_adv;\n+      if (!bounds_map->is_empty ())\n+      {\n+        table->minLeadingBearing = min_lsb;\n+        table->minTrailingBearing = min_rsb;\n+        table->maxExtent = max_extent;\n+      }\n+    }\n+#endif\n+\n+    bool result = c->plan->add_table (H::tableTag, dest_blob);\n@@ -133,0 +187,1 @@\n+    const hb_hashmap_t<hb_codepoint_t, hb_pair_t<unsigned, int>> *mtx_map = get_mtx_map (c->plan);\n@@ -136,0 +191,1 @@\n+\n@@ -137,2 +193,1 @@\n-      hb_codepoint_t old_gid = 0;\n-      unsigned int last_advance = plan->old_gid_for_new_gid (num_long_metrics - 1, &old_gid) ? _mtx.get_advance (old_gid) : 0;\n+      unsigned int last_advance = get_new_gid_advance_unscaled (plan, mtx_map, num_long_metrics - 1, _mtx);\n@@ -140,1 +195,1 @@\n-             last_advance == (plan->old_gid_for_new_gid (num_long_metrics - 2, &old_gid) ? _mtx.get_advance (old_gid) : 0))\n+             last_advance == get_new_gid_advance_unscaled (plan, mtx_map, num_long_metrics - 2, _mtx))\n@@ -148,1 +203,1 @@\n-    | hb_map ([c, &_mtx] (unsigned _)\n+    | hb_map ([c, &_mtx, mtx_map] (unsigned _)\n@@ -150,4 +205,10 @@\n-                hb_codepoint_t old_gid;\n-                if (!c->plan->old_gid_for_new_gid (_, &old_gid))\n-                  return hb_pair (0u, 0);\n-                return hb_pair (_mtx.get_advance (old_gid), _mtx.get_side_bearing (old_gid));\n+                if (!mtx_map->has (_))\n+                {\n+                  hb_codepoint_t old_gid;\n+                  if (!c->plan->old_gid_for_new_gid (_, &old_gid))\n+                    return hb_pair (0u, 0);\n+                  int lsb = 0;\n+                  (void) _mtx.get_leading_bearing_without_var_unscaled (old_gid, &lsb);\n+                  return hb_pair (_mtx.get_advance_without_var_unscaled (old_gid), +lsb);\n+                }\n+                return mtx_map->get (_);\n@@ -163,1 +224,2 @@\n-    if (unlikely (!subset_update_header (c->plan, num_long_metrics)))\n+    if (unlikely (!subset_update_header (c, num_long_metrics, mtx_map,\n+                                         T::is_horizontal ? &c->plan->bounds_width_map : &c->plan->bounds_height_map)))\n@@ -176,1 +238,1 @@\n-      var_table = hb_sanitize_context_t ().reference_table<HVARVVAR> (face, T::variationsTag);\n+      var_table = hb_sanitize_context_t ().reference_table<V> (face, T::variationsTag);\n@@ -224,1 +286,2 @@\n-    int get_side_bearing (hb_codepoint_t glyph) const\n+    bool get_leading_bearing_without_var_unscaled (hb_codepoint_t glyph,\n+                                                   int *lsb) const\n@@ -227,1 +290,4 @@\n-        return table->longMetricZ[glyph].sb;\n+      {\n+        *lsb = table->longMetricZ[glyph].sb;\n+        return true;\n+      }\n@@ -230,1 +296,1 @@\n-        return 0;\n+        return false;\n@@ -233,1 +299,2 @@\n-      return bearings[glyph - num_long_metrics];\n+      *lsb = bearings[glyph - num_long_metrics];\n+      return true;\n@@ -236,1 +303,3 @@\n-    int get_side_bearing (hb_font_t *font, hb_codepoint_t glyph) const\n+    bool get_leading_bearing_with_var_unscaled (hb_font_t *font,\n+                                                hb_codepoint_t glyph,\n+                                                int *lsb) const\n@@ -238,1 +307,2 @@\n-      int side_bearing = get_side_bearing (glyph);\n+      if (!font->num_coords)\n+        return get_leading_bearing_without_var_unscaled (glyph, lsb);\n@@ -241,5 +311,7 @@\n-      if (unlikely (glyph >= num_bearings) || !font->num_coords)\n-        return side_bearing;\n-\n-      if (var_table.get_length ())\n-        return side_bearing + var_table->get_side_bearing_var (glyph, font->coords, font->num_coords);\n+      float delta;\n+      if (var_table->get_lsb_delta_unscaled (glyph, font->coords, font->num_coords, &delta) &&\n+          get_leading_bearing_without_var_unscaled (glyph, lsb))\n+      {\n+        *lsb += roundf (delta);\n+        return true;\n+      }\n@@ -247,1 +319,1 @@\n-      return _glyf_get_side_bearing_var (font, glyph, T::tableTag == HB_OT_TAG_vmtx);\n+      return _glyf_get_leading_bearing_with_var_unscaled (font, glyph, T::tableTag == HB_OT_TAG_vmtx, lsb);\n@@ -249,1 +321,1 @@\n-      return side_bearing;\n+      return false;\n@@ -253,1 +325,1 @@\n-    unsigned int get_advance (hb_codepoint_t glyph) const\n+    unsigned int get_advance_without_var_unscaled (hb_codepoint_t glyph) const\n@@ -265,1 +337,1 @@\n-#ifdef HB_NO_BORING_EXPANSION\n+#ifdef HB_NO_BEYOND_64K\n@@ -275,2 +347,0 @@\n-      \/* TODO Optimize *\/\n-\n@@ -278,1 +348,1 @@\n-        return get_advance (num_bearings - 1);\n+        return get_advance_without_var_unscaled (num_bearings - 1);\n@@ -286,3 +356,3 @@\n-    unsigned int get_advance (hb_codepoint_t  glyph,\n-                              hb_font_t      *font,\n-                              VariationStore::cache_t *store_cache = nullptr) const\n+    unsigned get_advance_with_var_unscaled (hb_codepoint_t  glyph,\n+                                            hb_font_t      *font,\n+                                            VariationStore::cache_t *store_cache = nullptr) const\n@@ -290,1 +360,1 @@\n-      unsigned int advance = get_advance (glyph);\n+      unsigned int advance = get_advance_without_var_unscaled (glyph);\n@@ -297,1 +367,3 @@\n-        return advance + roundf (var_table->get_advance_var (glyph, font, store_cache)); \/\/ TODO Optimize?!\n+        return advance + roundf (var_table->get_advance_delta_unscaled (glyph,\n+                                                                        font->coords, font->num_coords,\n+                                                                        store_cache));\n@@ -299,1 +371,1 @@\n-      return _glyf_get_advance_var (font, glyph, T::tableTag == HB_OT_TAG_vmtx);\n+      return _glyf_get_advance_with_var_unscaled (font, glyph, T::tableTag == HB_OT_TAG_vmtx);\n@@ -316,1 +388,1 @@\n-    hb_blob_ptr_t<HVARVVAR> var_table;\n+    hb_blob_ptr_t<V> var_table;\n@@ -319,0 +391,16 @@\n+  \/* get advance: when no variations, call get_advance_without_var_unscaled.\n+   * when there're variations, get advance value from mtx_map in subset_plan*\/\n+  unsigned get_new_gid_advance_unscaled (const hb_subset_plan_t *plan,\n+                                         const hb_hashmap_t<hb_codepoint_t, hb_pair_t<unsigned, int>> *mtx_map,\n+                                         unsigned new_gid,\n+                                         const accelerator_t &_mtx) const\n+  {\n+    if (mtx_map->is_empty ())\n+    {\n+      hb_codepoint_t old_gid = 0;\n+      return plan->old_gid_for_new_gid (new_gid, &old_gid) ?\n+             _mtx.get_advance_without_var_unscaled (old_gid) : 0;\n+    }\n+    return mtx_map->get (new_gid).first;\n+  }\n+\n@@ -349,1 +437,1 @@\n-struct hmtx : hmtxvmtx<hmtx, hhea> {\n+struct hmtx : hmtxvmtx<hmtx, hhea, HVAR> {\n@@ -354,1 +442,1 @@\n-struct vmtx : hmtxvmtx<vmtx, vhea> {\n+struct vmtx : hmtxvmtx<vmtx, vhea, VVAR> {\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-hmtx-table.hh","additions":133,"deletions":45,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-base-table.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+#include \"OT\/Layout\/Common\/Coverage.hh\"\n+#include \"OT\/Layout\/types.hh\"\n@@ -39,39 +41,5 @@\n-#ifndef HB_MAX_NESTING_LEVEL\n-#define HB_MAX_NESTING_LEVEL    64\n-#endif\n-#ifndef HB_MAX_CONTEXT_LENGTH\n-#define HB_MAX_CONTEXT_LENGTH   64\n-#endif\n-#ifndef HB_CLOSURE_MAX_STAGES\n-\/*\n- * The maximum number of times a lookup can be applied during shaping.\n- * Used to limit the number of iterations of the closure algorithm.\n- * This must be larger than the number of times add_pause() is\n- * called in a collect_features call of any shaper.\n- *\/\n-#define HB_CLOSURE_MAX_STAGES   32\n-#endif\n-\n-#ifndef HB_MAX_SCRIPTS\n-#define HB_MAX_SCRIPTS  500\n-#endif\n-\n-#ifndef HB_MAX_LANGSYS\n-#define HB_MAX_LANGSYS  2000\n-#endif\n-\n-#ifndef HB_MAX_LANGSYS_FEATURE_COUNT\n-#define HB_MAX_LANGSYS_FEATURE_COUNT 50000\n-#endif\n-\n-#ifndef HB_MAX_FEATURES\n-#define HB_MAX_FEATURES 750\n-#endif\n-\n-#ifndef HB_MAX_FEATURE_INDICES\n-#define HB_MAX_FEATURE_INDICES  1500\n-#endif\n-\n-#ifndef HB_MAX_LOOKUP_VISIT_COUNT\n-#define HB_MAX_LOOKUP_VISIT_COUNT       35000\n-#endif\n+\/\/ TODO(garretrieger): cleanup these after migration.\n+using OT::Layout::Common::Coverage;\n+using OT::Layout::Common::RangeRecord;\n+using OT::Layout::SmallTypes;\n+using OT::Layout::MediumTypes;\n@@ -82,4 +50,0 @@\n-\n-#define NOT_COVERED             ((unsigned int) -1)\n-\n-\n@@ -87,1 +51,1 @@\n-static inline void Coverage_serialize (hb_serialize_context_t *c,\n+static inline bool ClassDef_serialize (hb_serialize_context_t *c,\n@@ -90,5 +54,1 @@\n-template<typename Iterator>\n-static inline void ClassDef_serialize (hb_serialize_context_t *c,\n-                                       Iterator it);\n-\n-static void ClassDef_remap_and_serialize (\n+static bool ClassDef_remap_and_serialize (\n@@ -101,0 +61,13 @@\n+struct hb_collect_feature_substitutes_with_var_context_t\n+{\n+  const hb_map_t *axes_index_tag_map;\n+  const hb_hashmap_t<hb_tag_t, int> *axes_location;\n+  hb_hashmap_t<unsigned, hb::shared_ptr<hb_set_t>> *record_cond_idx_map;\n+  hb_hashmap_t<unsigned, const Feature*> *feature_substitutes_map;\n+\n+  \/\/ not stored in subset_plan\n+  hb_set_t *feature_indices;\n+  bool apply;\n+  unsigned cur_record_idx;\n+  hb_hashmap_t<hb::shared_ptr<hb_map_t>, unsigned> *conditionset_map;\n+};\n@@ -167,0 +140,3 @@\n+  const hb_hashmap_t<unsigned, const Feature*> *feature_substitutes_map;\n+  hb_hashmap_t<unsigned, hb::shared_ptr<hb_set_t>> *feature_record_cond_idx_map;\n+\n@@ -168,0 +144,1 @@\n+  unsigned cur_feature_var_record_idx;\n@@ -170,4 +147,1 @@\n-                              hb_tag_t tag_,\n-                              hb_map_t *lookup_map_,\n-                              hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> *script_langsys_map_,\n-                              hb_map_t *feature_index_map_) :\n+                              hb_tag_t tag_) :\n@@ -176,3 +150,0 @@\n-                                lookup_index_map (lookup_map_),\n-                                script_langsys_map (script_langsys_map_),\n-                                feature_index_map (feature_index_map_),\n@@ -180,0 +151,1 @@\n+                                cur_feature_var_record_idx (0u),\n@@ -184,1 +156,18 @@\n-  {}\n+  {\n+    if (tag_ == HB_OT_TAG_GSUB)\n+    {\n+      lookup_index_map = &c_->plan->gsub_lookups;\n+      script_langsys_map = &c_->plan->gsub_langsys;\n+      feature_index_map = &c_->plan->gsub_features;\n+      feature_substitutes_map = &c_->plan->gsub_feature_substitutes_map;\n+      feature_record_cond_idx_map = c_->plan->user_axes_location.is_empty () ? nullptr : &c_->plan->gsub_feature_record_cond_idx_map;\n+    }\n+    else\n+    {\n+      lookup_index_map = &c_->plan->gpos_lookups;\n+      script_langsys_map = &c_->plan->gpos_langsys;\n+      feature_index_map = &c_->plan->gpos_features;\n+      feature_substitutes_map = &c_->plan->gpos_feature_substitutes_map;\n+      feature_record_cond_idx_map = c_->plan->user_axes_location.is_empty () ? nullptr : &c_->plan->gpos_feature_record_cond_idx_map;\n+    }\n+  }\n@@ -193,0 +182,1 @@\n+struct VariationStore;\n@@ -201,0 +191,3 @@\n+  hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> *varidx_delta_map;\n+  hb_font_t *font;\n+  const VariationStore *var_store;\n@@ -203,0 +196,1 @@\n+  float *store_cache;\n@@ -205,0 +199,3 @@\n+                                          hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> *varidx_delta_map_,\n+                                          hb_font_t *font_,\n+                                          const VariationStore *var_store_,\n@@ -206,1 +203,2 @@\n-                                          const hb_map_t *gpos_lookups_) :\n+                                          const hb_map_t *gpos_lookups_,\n+                                          float *store_cache_) :\n@@ -208,0 +206,3 @@\n+                                        varidx_delta_map (varidx_delta_map_),\n+                                        font (font_),\n+                                        var_store (var_store_),\n@@ -209,1 +210,2 @@\n-                                        gpos_lookups (gpos_lookups_) {}\n+                                        gpos_lookups (gpos_lookups_),\n+                                        store_cache (store_cache_) {}\n@@ -318,0 +320,25 @@\n+template<typename OutputArray, typename Arg>\n+struct subset_record_array_arg_t\n+{\n+  subset_record_array_arg_t (hb_subset_layout_context_t *c_, OutputArray* out_,\n+                             const void *base_,\n+                             Arg &&arg_) : subset_layout_context (c_),\n+                                           out (out_), base (base_), arg (arg_) {}\n+\n+  template <typename T>\n+  void\n+  operator () (T&& record)\n+  {\n+    auto snap = subset_layout_context->subset_context->serializer->snapshot ();\n+    bool ret = record.subset (subset_layout_context, base, arg);\n+    if (!ret) subset_layout_context->subset_context->serializer->revert (snap);\n+    else out->len++;\n+  }\n+\n+  private:\n+  hb_subset_layout_context_t *subset_layout_context;\n+  OutputArray *out;\n+  const void *base;\n+  Arg &&arg;\n+};\n+\n@@ -329,0 +356,7 @@\n+\n+  \/* Variant with one extra argument passed to subset *\/\n+  template<typename OutputArray, typename Arg>\n+  subset_record_array_arg_t<OutputArray, Arg>\n+  operator () (hb_subset_layout_context_t *c, OutputArray* out,\n+               const void *base, Arg &&arg) const\n+  { return subset_record_array_arg_t<OutputArray, Arg> (c, out, base, arg); }\n@@ -380,160 +414,0 @@\n-struct Record_sanitize_closure_t {\n-  hb_tag_t tag;\n-  const void *list_base;\n-};\n-\n-template <typename Type>\n-struct Record\n-{\n-  int cmp (hb_tag_t a) const { return tag.cmp (a); }\n-\n-  bool subset (hb_subset_layout_context_t *c, const void *base) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->subset_context->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-    bool ret = out->offset.serialize_subset (c->subset_context, offset, base, c, &tag);\n-    return_trace (ret);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n-  {\n-    TRACE_SANITIZE (this);\n-    const Record_sanitize_closure_t closure = {tag, base};\n-    return_trace (c->check_struct (this) && offset.sanitize (c, base, &closure));\n-  }\n-\n-  Tag           tag;            \/* 4-byte Tag identifier *\/\n-  Offset16To<Type>\n-                offset;         \/* Offset from beginning of object holding\n-                                 * the Record *\/\n-  public:\n-  DEFINE_SIZE_STATIC (6);\n-};\n-\n-template <typename Type>\n-struct RecordArrayOf : SortedArray16Of<Record<Type>>\n-{\n-  const Offset16To<Type>& get_offset (unsigned int i) const\n-  { return (*this)[i].offset; }\n-  Offset16To<Type>& get_offset (unsigned int i)\n-  { return (*this)[i].offset; }\n-  const Tag& get_tag (unsigned int i) const\n-  { return (*this)[i].tag; }\n-  unsigned int get_tags (unsigned int start_offset,\n-                         unsigned int *record_count \/* IN\/OUT *\/,\n-                         hb_tag_t     *record_tags \/* OUT *\/) const\n-  {\n-    if (record_count)\n-    {\n-      + this->sub_array (start_offset, record_count)\n-      | hb_map (&Record<Type>::tag)\n-      | hb_sink (hb_array (record_tags, *record_count))\n-      ;\n-    }\n-    return this->len;\n-  }\n-  bool find_index (hb_tag_t tag, unsigned int *index) const\n-  {\n-    return this->bfind (tag, index, HB_NOT_FOUND_STORE, Index::NOT_FOUND_INDEX);\n-  }\n-};\n-\n-template <typename Type>\n-struct RecordListOf : RecordArrayOf<Type>\n-{\n-  const Type& operator [] (unsigned int i) const\n-  { return this+this->get_offset (i); }\n-\n-  bool subset (hb_subset_context_t *c,\n-               hb_subset_layout_context_t *l) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-\n-    + this->iter ()\n-    | hb_apply (subset_record_array (l, out, this))\n-    ;\n-    return_trace (true);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (RecordArrayOf<Type>::sanitize (c, this));\n-  }\n-};\n-\n-struct Feature;\n-\n-struct RecordListOfFeature : RecordListOf<Feature>\n-{\n-  bool subset (hb_subset_context_t *c,\n-               hb_subset_layout_context_t *l) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!out || !c->serializer->extend_min (out))) return_trace (false);\n-\n-    unsigned count = this->len;\n-    + hb_zip (*this, hb_range (count))\n-    | hb_filter (l->feature_index_map, hb_second)\n-    | hb_map (hb_first)\n-    | hb_apply (subset_record_array (l, out, this))\n-    ;\n-    return_trace (true);\n-  }\n-};\n-\n-struct Script;\n-struct RecordListOfScript : RecordListOf<Script>\n-{\n-  bool subset (hb_subset_context_t *c,\n-               hb_subset_layout_context_t *l) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!out || !c->serializer->extend_min (out))) return_trace (false);\n-\n-    unsigned count = this->len;\n-    for (auto _ : + hb_zip (*this, hb_range (count)))\n-    {\n-      auto snap = c->serializer->snapshot ();\n-      l->cur_script_index = _.second;\n-      bool ret = _.first.subset (l, this);\n-      if (!ret) c->serializer->revert (snap);\n-      else out->len++;\n-    }\n-\n-    return_trace (true);\n-  }\n-};\n-\n-struct RangeRecord\n-{\n-  int cmp (hb_codepoint_t g) const\n-  { return g < first ? -1 : g <= last ? 0 : +1; }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  bool intersects (const hb_set_t *glyphs) const\n-  { return glyphs->intersects (first, last); }\n-\n-  template <typename set_t>\n-  bool collect_coverage (set_t *glyphs) const\n-  { return glyphs->add_range (first, last); }\n-\n-  HBGlyphID16   first;          \/* First GlyphID in the range *\/\n-  HBGlyphID16   last;           \/* Last GlyphID in the range *\/\n-  HBUINT16      value;          \/* Value *\/\n-  public:\n-  DEFINE_SIZE_STATIC (6);\n-};\n-DECLARE_NULL_NAMESPACE_BYTES (OT, RangeRecord);\n-\n-\n@@ -571,1 +445,1 @@\n-      + this->sub_array (start_offset, _count)\n+      + this->as_array ().sub_array (start_offset, _count)\n@@ -585,1 +459,2 @@\n-struct LangSys\n+\/* https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/features_pt#size *\/\n+struct FeatureParamsSize\n@@ -587,26 +462,1 @@\n-  unsigned int get_feature_count () const\n-  { return featureIndex.len; }\n-  hb_tag_t get_feature_index (unsigned int i) const\n-  { return featureIndex[i]; }\n-  unsigned int get_feature_indexes (unsigned int start_offset,\n-                                    unsigned int *feature_count \/* IN\/OUT *\/,\n-                                    unsigned int *feature_indexes \/* OUT *\/) const\n-  { return featureIndex.get_indexes (start_offset, feature_count, feature_indexes); }\n-  void add_feature_indexes_to (hb_set_t *feature_indexes) const\n-  { featureIndex.add_indexes_to (feature_indexes); }\n-\n-  bool has_required_feature () const { return reqFeatureIndex != 0xFFFFu; }\n-  unsigned int get_required_feature_index () const\n-  {\n-    if (reqFeatureIndex == 0xFFFFu)\n-      return Index::NOT_FOUND_INDEX;\n-   return reqFeatureIndex;\n-  }\n-\n-  LangSys* copy (hb_serialize_context_t *c) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    return_trace (c->embed (*this));\n-  }\n-\n-  bool compare (const LangSys& o, const hb_map_t *feature_index_map) const\n+  bool sanitize (hb_sanitize_context_t *c) const\n@@ -614,218 +464,2 @@\n-    if (reqFeatureIndex != o.reqFeatureIndex)\n-      return false;\n-\n-    auto iter =\n-    + hb_iter (featureIndex)\n-    | hb_filter (feature_index_map)\n-    | hb_map (feature_index_map)\n-    ;\n-\n-    auto o_iter =\n-    + hb_iter (o.featureIndex)\n-    | hb_filter (feature_index_map)\n-    | hb_map (feature_index_map)\n-    ;\n-\n-    for (; iter && o_iter; iter++, o_iter++)\n-    {\n-      unsigned a = *iter;\n-      unsigned b = *o_iter;\n-      if (a != b) return false;\n-    }\n-\n-    if (iter || o_iter) return false;\n-\n-    return true;\n-  }\n-\n-  void collect_features (hb_prune_langsys_context_t *c) const\n-  {\n-    if (!has_required_feature () && !get_feature_count ()) return;\n-    if (has_required_feature () &&\n-        c->duplicate_feature_map->has (reqFeatureIndex))\n-      c->new_feature_indexes->add (get_required_feature_index ());\n-\n-    + hb_iter (featureIndex)\n-    | hb_filter (c->duplicate_feature_map)\n-    | hb_sink (c->new_feature_indexes)\n-    ;\n-  }\n-\n-  bool subset (hb_subset_context_t        *c,\n-               hb_subset_layout_context_t *l,\n-               const Tag                  *tag = nullptr) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!out || !c->serializer->extend_min (out))) return_trace (false);\n-\n-    const unsigned *v;\n-    out->reqFeatureIndex = l->feature_index_map->has (reqFeatureIndex, &v) ? *v : 0xFFFFu;\n-\n-    if (!l->visitFeatureIndex (featureIndex.len))\n-      return_trace (false);\n-\n-    auto it =\n-    + hb_iter (featureIndex)\n-    | hb_filter (l->feature_index_map)\n-    | hb_map (l->feature_index_map)\n-    ;\n-\n-    bool ret = bool (it);\n-    out->featureIndex.serialize (c->serializer, l, it);\n-    return_trace (ret);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c,\n-                 const Record_sanitize_closure_t * = nullptr) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && featureIndex.sanitize (c));\n-  }\n-\n-  Offset16      lookupOrderZ;   \/* = Null (reserved for an offset to a\n-                                 * reordering table) *\/\n-  HBUINT16      reqFeatureIndex;\/* Index of a feature required for this\n-                                 * language system--if no required features\n-                                 * = 0xFFFFu *\/\n-  IndexArray    featureIndex;   \/* Array of indices into the FeatureList *\/\n-  public:\n-  DEFINE_SIZE_ARRAY_SIZED (6, featureIndex);\n-};\n-DECLARE_NULL_NAMESPACE_BYTES (OT, LangSys);\n-\n-struct Script\n-{\n-  unsigned int get_lang_sys_count () const\n-  { return langSys.len; }\n-  const Tag& get_lang_sys_tag (unsigned int i) const\n-  { return langSys.get_tag (i); }\n-  unsigned int get_lang_sys_tags (unsigned int start_offset,\n-                                  unsigned int *lang_sys_count \/* IN\/OUT *\/,\n-                                  hb_tag_t     *lang_sys_tags \/* OUT *\/) const\n-  { return langSys.get_tags (start_offset, lang_sys_count, lang_sys_tags); }\n-  const LangSys& get_lang_sys (unsigned int i) const\n-  {\n-    if (i == Index::NOT_FOUND_INDEX) return get_default_lang_sys ();\n-    return this+langSys[i].offset;\n-  }\n-  bool find_lang_sys_index (hb_tag_t tag, unsigned int *index) const\n-  { return langSys.find_index (tag, index); }\n-\n-  bool has_default_lang_sys () const           { return defaultLangSys != 0; }\n-  const LangSys& get_default_lang_sys () const { return this+defaultLangSys; }\n-\n-  void prune_langsys (hb_prune_langsys_context_t *c,\n-                      unsigned script_index) const\n-  {\n-    if (!has_default_lang_sys () && !get_lang_sys_count ()) return;\n-    if (!c->visitScript ()) return;\n-\n-    if (!c->script_langsys_map->has (script_index))\n-    {\n-      if (unlikely (!c->script_langsys_map->set (script_index, hb::unique_ptr<hb_set_t> {hb_set_create ()})))\n-        return;\n-    }\n-\n-    unsigned langsys_count = get_lang_sys_count ();\n-    if (has_default_lang_sys ())\n-    {\n-      \/\/only collect features from non-redundant langsys\n-      const LangSys& d = get_default_lang_sys ();\n-      if (c->visitLangsys (d.get_feature_count ())) {\n-        d.collect_features (c);\n-      }\n-\n-      for (auto _ : + hb_zip (langSys, hb_range (langsys_count)))\n-      {\n-        const LangSys& l = this+_.first.offset;\n-        if (!c->visitLangsys (l.get_feature_count ())) continue;\n-        if (l.compare (d, c->duplicate_feature_map)) continue;\n-\n-        l.collect_features (c);\n-        c->script_langsys_map->get (script_index)->add (_.second);\n-      }\n-    }\n-    else\n-    {\n-      for (auto _ : + hb_zip (langSys, hb_range (langsys_count)))\n-      {\n-        const LangSys& l = this+_.first.offset;\n-        if (!c->visitLangsys (l.get_feature_count ())) continue;\n-        l.collect_features (c);\n-        c->script_langsys_map->get (script_index)->add (_.second);\n-      }\n-    }\n-  }\n-\n-  bool subset (hb_subset_context_t         *c,\n-               hb_subset_layout_context_t  *l,\n-               const Tag                   *tag) const\n-  {\n-    TRACE_SUBSET (this);\n-    if (!l->visitScript ()) return_trace (false);\n-\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!out || !c->serializer->extend_min (out))) return_trace (false);\n-\n-    bool defaultLang = false;\n-    if (has_default_lang_sys ())\n-    {\n-      c->serializer->push ();\n-      const LangSys& ls = this+defaultLangSys;\n-      bool ret = ls.subset (c, l);\n-      if (!ret && tag && *tag != HB_TAG ('D', 'F', 'L', 'T'))\n-      {\n-        c->serializer->pop_discard ();\n-        out->defaultLangSys = 0;\n-      }\n-      else\n-      {\n-        c->serializer->add_link (out->defaultLangSys, c->serializer->pop_pack ());\n-        defaultLang = true;\n-      }\n-    }\n-\n-    const hb_set_t *active_langsys = l->script_langsys_map->get (l->cur_script_index);\n-    if (active_langsys)\n-    {\n-      unsigned count = langSys.len;\n-      + hb_zip (langSys, hb_range (count))\n-      | hb_filter (active_langsys, hb_second)\n-      | hb_map (hb_first)\n-      | hb_filter ([=] (const Record<LangSys>& record) {return l->visitLangSys (); })\n-      | hb_apply (subset_record_array (l, &(out->langSys), this))\n-      ;\n-    }\n-\n-    return_trace (bool (out->langSys.len) || defaultLang || l->table_tag == HB_OT_TAG_GSUB);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c,\n-                 const Record_sanitize_closure_t * = nullptr) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (defaultLangSys.sanitize (c, this) && langSys.sanitize (c, this));\n-  }\n-\n-  protected:\n-  Offset16To<LangSys>\n-                defaultLangSys; \/* Offset to DefaultLangSys table--from\n-                                 * beginning of Script table--may be Null *\/\n-  RecordArrayOf<LangSys>\n-                langSys;        \/* Array of LangSysRecords--listed\n-                                 * alphabetically by LangSysTag *\/\n-  public:\n-  DEFINE_SIZE_ARRAY_SIZED (4, langSys);\n-};\n-\n-typedef RecordListOfScript ScriptList;\n-\n-\n-\/* https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/features_pt#size *\/\n-struct FeatureParamsSize\n-{\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    if (unlikely (!c->check_struct (this))) return_trace (false);\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!c->check_struct (this))) return_trace (false);\n@@ -991,1 +625,1 @@\n-      + characters.sub_array (start_offset, char_count)\n+      + characters.as_array ().sub_array (start_offset, char_count)\n@@ -1107,0 +741,5 @@\n+struct Record_sanitize_closure_t {\n+  hb_tag_t tag;\n+  const void *list_base;\n+};\n+\n@@ -1202,4 +841,2 @@\n-typedef RecordListOf<Feature> FeatureList;\n-\n-\n-struct LookupFlag : HBUINT16\n+template <typename Type>\n+struct Record\n@@ -1207,13 +844,1 @@\n-  enum Flags {\n-    RightToLeft         = 0x0001u,\n-    IgnoreBaseGlyphs    = 0x0002u,\n-    IgnoreLigatures     = 0x0004u,\n-    IgnoreMarks         = 0x0008u,\n-    IgnoreFlags         = 0x000Eu,\n-    UseMarkFilteringSet = 0x0010u,\n-    Reserved            = 0x00E0u,\n-    MarkAttachmentType  = 0xFF00u\n-  };\n-  public:\n-  DEFINE_SIZE_STATIC (2);\n-};\n+  int cmp (hb_tag_t a) const { return tag.cmp (a); }\n@@ -1221,4 +846,5 @@\n-} \/* namespace OT *\/\n-\/* This has to be outside the namespace. *\/\n-HB_MARK_AS_FLAG_T (OT::LookupFlag::Flags);\n-namespace OT {\n+  bool subset (hb_subset_layout_context_t *c, const void *base, const void *f_sub = nullptr) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->subset_context->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n@@ -1226,3 +852,2 @@\n-struct Lookup\n-{\n-  unsigned int get_subtable_count () const { return subTable.len; }\n+    if (!f_sub)\n+      return_trace (out->offset.serialize_subset (c->subset_context, offset, base, c, &tag));\n@@ -1230,6 +855,3 @@\n-  template <typename TSubTable>\n-  const Array16OfOffset16To<TSubTable>& get_subtables () const\n-  { return reinterpret_cast<const Array16OfOffset16To<TSubTable> &> (subTable); }\n-  template <typename TSubTable>\n-  Array16OfOffset16To<TSubTable>& get_subtables ()\n-  { return reinterpret_cast<Array16OfOffset16To<TSubTable> &> (subTable); }\n+    const Feature& f = *reinterpret_cast<const Feature *> (f_sub);\n+    auto *s = c->subset_context->serializer;\n+    s->push ();\n@@ -1237,6 +859,6 @@\n-  template <typename TSubTable>\n-  const TSubTable& get_subtable (unsigned int i) const\n-  { return this+get_subtables<TSubTable> ()[i]; }\n-  template <typename TSubTable>\n-  TSubTable& get_subtable (unsigned int i)\n-  { return this+get_subtables<TSubTable> ()[i]; }\n+    out->offset = 0;\n+    bool ret = f.subset (c->subset_context, c, &tag);\n+    if (ret)\n+      s->add_link (out->offset, s->pop_pack ());\n+    else\n+      s->pop_discard ();\n@@ -1244,6 +866,1 @@\n-  unsigned int get_size () const\n-  {\n-    const HBUINT16 &markFilteringSet = StructAfter<const HBUINT16> (subTable);\n-    if (lookupFlag & LookupFlag::UseMarkFilteringSet)\n-      return (const char *) &StructAfter<const char> (markFilteringSet) - (const char *) this;\n-    return (const char *) &markFilteringSet - (const char *) this;\n+    return_trace (ret);\n@@ -1252,6 +869,1 @@\n-  unsigned int get_type () const { return lookupType; }\n-\n-  \/* lookup_props is a 32-bit integer where the lower 16-bit is LookupFlag and\n-   * higher 16-bit is mark-filtering-set if the lookup uses one.\n-   * Not to be confused with glyph_props which is very similar. *\/\n-  uint32_t get_props () const\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n@@ -1259,7 +871,3 @@\n-    unsigned int flag = lookupFlag;\n-    if (unlikely (flag & LookupFlag::UseMarkFilteringSet))\n-    {\n-      const HBUINT16 &markFilteringSet = StructAfter<HBUINT16> (subTable);\n-      flag += (markFilteringSet << 16);\n-    }\n-    return flag;\n+    TRACE_SANITIZE (this);\n+    const Record_sanitize_closure_t closure = {tag, base};\n+    return_trace (c->check_struct (this) && offset.sanitize (c, base, &closure));\n@@ -1268,13 +876,7 @@\n-  template <typename TSubTable, typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  {\n-    unsigned int lookup_type = get_type ();\n-    TRACE_DISPATCH (this, lookup_type);\n-    unsigned int count = get_subtable_count ();\n-    for (unsigned int i = 0; i < count; i++) {\n-      typename context_t::return_t r = get_subtable<TSubTable> (i).dispatch (c, lookup_type, std::forward<Ts> (ds)...);\n-      if (c->stop_sublookup_iteration (r))\n-        return_trace (r);\n-    }\n-    return_trace (c->default_return_value ());\n-  }\n+  Tag           tag;            \/* 4-byte Tag identifier *\/\n+  Offset16To<Type>\n+                offset;         \/* Offset from beginning of object holding\n+                                 * the Record *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n@@ -1282,4 +884,12 @@\n-  bool serialize (hb_serialize_context_t *c,\n-                  unsigned int lookup_type,\n-                  uint32_t lookup_props,\n-                  unsigned int num_subtables)\n+template <typename Type>\n+struct RecordArrayOf : SortedArray16Of<Record<Type>>\n+{\n+  const Offset16To<Type>& get_offset (unsigned int i) const\n+  { return (*this)[i].offset; }\n+  Offset16To<Type>& get_offset (unsigned int i)\n+  { return (*this)[i].offset; }\n+  const Tag& get_tag (unsigned int i) const\n+  { return (*this)[i].tag; }\n+  unsigned int get_tags (unsigned int start_offset,\n+                         unsigned int *record_count \/* IN\/OUT *\/,\n+                         hb_tag_t     *record_tags \/* OUT *\/) const\n@@ -1287,6 +897,1 @@\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!c->extend_min (this))) return_trace (false);\n-    lookupType = lookup_type;\n-    lookupFlag = lookup_props & 0xFFFFu;\n-    if (unlikely (!subTable.serialize (c, num_subtables))) return_trace (false);\n-    if (lookupFlag & LookupFlag::UseMarkFilteringSet)\n+    if (record_count)\n@@ -1294,3 +899,4 @@\n-      if (unlikely (!c->extend (this))) return_trace (false);\n-      HBUINT16 &markFilteringSet = StructAfter<HBUINT16> (subTable);\n-      markFilteringSet = lookup_props >> 16;\n+      + this->as_array ().sub_array (start_offset, record_count)\n+      | hb_map (&Record<Type>::tag)\n+      | hb_sink (hb_array (record_tags, *record_count))\n+      ;\n@@ -1298,1 +904,5 @@\n-    return_trace (true);\n+    return this->len;\n+  }\n+  bool find_index (hb_tag_t tag, unsigned int *index) const\n+  {\n+    return this->bfind (tag, index, HB_NOT_FOUND_STORE, Index::NOT_FOUND_INDEX);\n@@ -1300,0 +910,1 @@\n+};\n@@ -1301,2 +912,8 @@\n-  template <typename TSubTable>\n-  bool subset (hb_subset_context_t *c) const\n+template <typename Type>\n+struct RecordListOf : RecordArrayOf<Type>\n+{\n+  const Type& operator [] (unsigned int i) const\n+  { return this+this->get_offset (i); }\n+\n+  bool subset (hb_subset_context_t *c,\n+               hb_subset_layout_context_t *l) const\n@@ -1306,3 +923,1 @@\n-    if (unlikely (!out || !c->serializer->extend_min (out))) return_trace (false);\n-    out->lookupType = lookupType;\n-    out->lookupFlag = lookupFlag;\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n@@ -1310,5 +925,2 @@\n-    const hb_set_t *glyphset = c->plan->glyphset_gsub ();\n-    unsigned int lookup_type = get_type ();\n-    + hb_iter (get_subtables <TSubTable> ())\n-    | hb_filter ([this, glyphset, lookup_type] (const Offset16To<TSubTable> &_) { return (this+_).intersects (glyphset, lookup_type); })\n-    | hb_apply (subset_offset_array (c, out->get_subtables<TSubTable> (), this, lookup_type))\n+    + this->iter ()\n+    | hb_apply (subset_record_array (l, out, this))\n@@ -1316,10 +928,1 @@\n-\n-    if (lookupFlag & LookupFlag::UseMarkFilteringSet)\n-    {\n-      if (unlikely (!c->serializer->extend (out))) return_trace (false);\n-      const HBUINT16 &markFilteringSet = StructAfter<HBUINT16> (subTable);\n-      HBUINT16 &outMarkFilteringSet = StructAfter<HBUINT16> (out->subTable);\n-      outMarkFilteringSet = markFilteringSet;\n-    }\n-\n-    return_trace (out->subTable.len);\n+    return_trace (true);\n@@ -1328,1 +931,0 @@\n-  template <typename TSubTable>\n@@ -1332,32 +934,1 @@\n-    if (!(c->check_struct (this) && subTable.sanitize (c))) return_trace (false);\n-\n-    unsigned subtables = get_subtable_count ();\n-    if (unlikely (!c->visit_subtables (subtables))) return_trace (false);\n-\n-    if (lookupFlag & LookupFlag::UseMarkFilteringSet)\n-    {\n-      const HBUINT16 &markFilteringSet = StructAfter<HBUINT16> (subTable);\n-      if (!markFilteringSet.sanitize (c)) return_trace (false);\n-    }\n-\n-    if (unlikely (!get_subtables<TSubTable> ().sanitize (c, this, get_type ())))\n-      return_trace (false);\n-\n-    if (unlikely (get_type () == TSubTable::Extension && subtables && !c->get_edit_count ()))\n-    {\n-      \/* The spec says all subtables of an Extension lookup should\n-       * have the same type, which shall not be the Extension type\n-       * itself (but we already checked for that).\n-       * This is specially important if one has a reverse type!\n-       *\n-       * We only do this if sanitizer edit_count is zero.  Otherwise,\n-       * some of the subtables might have become insane after they\n-       * were sanity-checked by the edits of subsequent subtables.\n-       * https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=960331\n-       *\/\n-      unsigned int type = get_subtable<TSubTable> (0).u.extension.get_type ();\n-      for (unsigned int i = 1; i < subtables; i++)\n-        if (get_subtable<TSubTable> (i).u.extension.get_type () != type)\n-          return_trace (false);\n-    }\n-    return_trace (true);\n+    return_trace (RecordArrayOf<Type>::sanitize (c, this));\n@@ -1365,11 +936,0 @@\n-\n-  private:\n-  HBUINT16      lookupType;             \/* Different enumerations for GSUB and GPOS *\/\n-  HBUINT16      lookupFlag;             \/* Lookup qualifiers *\/\n-  Array16Of<Offset16>\n-                subTable;               \/* Array of SubTables *\/\n-\/*HBUINT16      markFilteringSetX[HB_VAR_ARRAY];*\/\/* Index (base 0) into GDEF mark glyph sets\n-                                         * structure. This field is only present if bit\n-                                         * UseMarkFilteringSet of lookup flags is set. *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (6, subTable);\n@@ -1378,4 +938,1 @@\n-typedef List16OfOffset16To<Lookup> LookupList;\n-\n-template <typename TLookup>\n-struct LookupOffsetList : List16OfOffset16To<TLookup>\n+struct RecordListOfFeature : RecordListOf<Feature>\n@@ -1383,1 +940,1 @@\n-  bool subset (hb_subset_context_t        *c,\n+  bool subset (hb_subset_context_t *c,\n@@ -1387,1 +944,1 @@\n-    auto *out = c->serializer->start_embed (this);\n+    auto *out = c->serializer->start_embed (*this);\n@@ -1390,5 +947,11 @@\n-    unsigned count = this->len;\n-    + hb_zip (*this, hb_range (count))\n-    | hb_filter (l->lookup_index_map, hb_second)\n-    | hb_map (hb_first)\n-    | hb_apply (subset_offset_array (c, *out, this))\n+    + hb_enumerate (*this)\n+    | hb_filter (l->feature_index_map, hb_first)\n+    | hb_apply ([l, out, this] (const hb_pair_t<unsigned, const Record<Feature>&>& _)\n+                {\n+                  const Feature *f_sub = nullptr;\n+                  const Feature **f = nullptr;\n+                  if (l->feature_substitutes_map->has (_.first, &f))\n+                    f_sub = *f;\n+\n+                  subset_record_array (l, out, this, f_sub) (_.second);\n+                })\n@@ -1396,2 +959,0 @@\n-    return_trace (true);\n-  }\n@@ -1399,4 +960,1 @@\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (List16OfOffset16To<TLookup>::sanitize (c, this));\n+    return_trace (true);\n@@ -1406,0 +964,1 @@\n+typedef RecordListOf<Feature> FeatureList;\n@@ -1407,3 +966,0 @@\n-\/*\n- * Coverage Table\n- *\/\n@@ -1411,1 +967,1 @@\n-struct CoverageFormat1\n+struct LangSys\n@@ -1413,1 +969,10 @@\n-  friend struct Coverage;\n+  unsigned int get_feature_count () const\n+  { return featureIndex.len; }\n+  hb_tag_t get_feature_index (unsigned int i) const\n+  { return featureIndex[i]; }\n+  unsigned int get_feature_indexes (unsigned int start_offset,\n+                                    unsigned int *feature_count \/* IN\/OUT *\/,\n+                                    unsigned int *feature_indexes \/* OUT *\/) const\n+  { return featureIndex.get_indexes (start_offset, feature_count, feature_indexes); }\n+  void add_feature_indexes_to (hb_set_t *feature_indexes) const\n+  { featureIndex.add_indexes_to (feature_indexes); }\n@@ -1415,2 +980,2 @@\n-  private:\n-  unsigned int get_coverage (hb_codepoint_t glyph_id) const\n+  bool has_required_feature () const { return reqFeatureIndex != 0xFFFFu; }\n+  unsigned int get_required_feature_index () const\n@@ -1418,3 +983,3 @@\n-    unsigned int i;\n-    glyphArray.bfind (glyph_id, &i, HB_NOT_FOUND_STORE, NOT_COVERED);\n-    return i;\n+    if (reqFeatureIndex == 0xFFFFu)\n+      return Index::NOT_FOUND_INDEX;\n+   return reqFeatureIndex;\n@@ -1423,3 +988,1 @@\n-  template <typename Iterator,\n-      hb_requires (hb_is_sorted_source_of (Iterator, hb_codepoint_t))>\n-  bool serialize (hb_serialize_context_t *c, Iterator glyphs)\n+  LangSys* copy (hb_serialize_context_t *c) const\n@@ -1428,7 +991,1 @@\n-    return_trace (glyphArray.serialize (c, glyphs));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (glyphArray.sanitize (c));\n+    return_trace (c->embed (*this));\n@@ -1437,1 +994,1 @@\n-  bool intersects (const hb_set_t *glyphs) const\n+  bool compare (const LangSys& o, const hb_map_t *feature_index_map) const\n@@ -1439,8 +996,2 @@\n-    \/* TODO Speed up, using hb_set_next() and bsearch()? *\/\n-    for (const auto& g : glyphArray.as_array ())\n-      if (glyphs->has (g))\n-        return true;\n-    return false;\n-  }\n-  bool intersects_coverage (const hb_set_t *glyphs, unsigned int index) const\n-  { return glyphs->has (glyphArray[index]); }\n+    if (reqFeatureIndex != o.reqFeatureIndex)\n+      return false;\n@@ -1448,7 +999,5 @@\n-  void intersected_coverage_glyphs (const hb_set_t *glyphs, hb_set_t *intersect_glyphs) const\n-  {\n-    unsigned count = glyphArray.len;\n-    for (unsigned i = 0; i < count; i++)\n-      if (glyphs->has (glyphArray[i]))\n-        intersect_glyphs->add (glyphArray[i]);\n-  }\n+    auto iter =\n+    + hb_iter (featureIndex)\n+    | hb_filter (feature_index_map)\n+    | hb_map (feature_index_map)\n+    ;\n@@ -1456,3 +1005,5 @@\n-  template <typename set_t>\n-  bool collect_coverage (set_t *glyphs) const\n-  { return glyphs->add_sorted_array (glyphArray.as_array ()); }\n+    auto o_iter =\n+    + hb_iter (o.featureIndex)\n+    | hb_filter (feature_index_map)\n+    | hb_map (feature_index_map)\n+    ;\n@@ -1460,18 +1011,6 @@\n-  public:\n-  \/* Older compilers need this to be public. *\/\n-  struct iter_t\n-  {\n-    void init (const struct CoverageFormat1 &c_) { c = &c_; i = 0; }\n-    void fini () {}\n-    bool more () const { return i < c->glyphArray.len; }\n-    void next () { i++; }\n-    hb_codepoint_t get_glyph () const { return c->glyphArray[i]; }\n-    bool operator != (const iter_t& o) const\n-    { return i != o.i; }\n-    iter_t __end__ () const { iter_t it; it.init (*c); it.i = c->glyphArray.len; return it; }\n-\n-    private:\n-    const struct CoverageFormat1 *c;\n-    unsigned int i;\n-  };\n-  private:\n+    for (; iter && o_iter; iter++, o_iter++)\n+    {\n+      unsigned a = *iter;\n+      unsigned b = *o_iter;\n+      if (a != b) return false;\n+    }\n@@ -1479,7 +1018,1 @@\n-  protected:\n-  HBUINT16      coverageFormat; \/* Format identifier--format = 1 *\/\n-  SortedArray16Of<HBGlyphID16>\n-                glyphArray;     \/* Array of GlyphIDs--in numerical order *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (4, glyphArray);\n-};\n+    if (iter || o_iter) return false;\n@@ -1487,3 +1020,2 @@\n-struct CoverageFormat2\n-{\n-  friend struct Coverage;\n+    return true;\n+  }\n@@ -1491,2 +1023,1 @@\n-  private:\n-  unsigned int get_coverage (hb_codepoint_t glyph_id) const\n+  void collect_features (hb_prune_langsys_context_t *c) const\n@@ -1494,4 +1025,9 @@\n-    const RangeRecord &range = rangeRecord.bsearch (glyph_id);\n-    return likely (range.first <= range.last)\n-         ? (unsigned int) range.value + (glyph_id - range.first)\n-         : NOT_COVERED;\n+    if (!has_required_feature () && !get_feature_count ()) return;\n+    if (has_required_feature () &&\n+        c->duplicate_feature_map->has (reqFeatureIndex))\n+      c->new_feature_indexes->add (get_required_feature_index ());\n+\n+    + hb_iter (featureIndex)\n+    | hb_filter (c->duplicate_feature_map)\n+    | hb_sink (c->new_feature_indexes)\n+    ;\n@@ -1500,3 +1036,3 @@\n-  template <typename Iterator,\n-      hb_requires (hb_is_sorted_source_of (Iterator, hb_codepoint_t))>\n-  bool serialize (hb_serialize_context_t *c, Iterator glyphs)\n+  bool subset (hb_subset_context_t        *c,\n+               hb_subset_layout_context_t *l,\n+               const Tag                  *tag = nullptr) const\n@@ -1504,4 +1040,3 @@\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!c->extend_min (this))) return_trace (false);\n-\n-    \/* TODO(iter) Write more efficiently? *\/\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!out || !c->serializer->extend_min (out))) return_trace (false);\n@@ -1509,8 +1044,2 @@\n-    unsigned num_ranges = 0;\n-    hb_codepoint_t last = (hb_codepoint_t) -2;\n-    for (auto g: glyphs)\n-    {\n-      if (last + 1 != g)\n-        num_ranges++;\n-      last = g;\n-    }\n+    const uint32_t *v;\n+    out->reqFeatureIndex = l->feature_index_map->has (reqFeatureIndex, &v) ? *v : 0xFFFFu;\n@@ -1518,2 +1047,2 @@\n-    if (unlikely (!rangeRecord.serialize (c, num_ranges))) return_trace (false);\n-    if (!num_ranges) return_trace (true);\n+    if (!l->visitFeatureIndex (featureIndex.len))\n+      return_trace (false);\n@@ -1521,15 +1050,5 @@\n-    unsigned count = 0;\n-    unsigned range = (unsigned) -1;\n-    last = (hb_codepoint_t) -2;\n-    for (auto g: glyphs)\n-    {\n-      if (last + 1 != g)\n-      {\n-        range++;\n-        rangeRecord[range].first = g;\n-        rangeRecord[range].value = count;\n-      }\n-      rangeRecord[range].last = g;\n-      last = g;\n-      count++;\n-    }\n+    auto it =\n+    + hb_iter (featureIndex)\n+    | hb_filter (l->feature_index_map)\n+    | hb_map (l->feature_index_map)\n+    ;\n@@ -1537,1 +1056,3 @@\n-    return_trace (true);\n+    bool ret = bool (it);\n+    out->featureIndex.serialize (c->serializer, l, it);\n+    return_trace (ret);\n@@ -1540,1 +1061,2 @@\n-  bool sanitize (hb_sanitize_context_t *c) const\n+  bool sanitize (hb_sanitize_context_t *c,\n+                 const Record_sanitize_closure_t * = nullptr) const\n@@ -1543,1 +1065,1 @@\n-    return_trace (rangeRecord.sanitize (c));\n+    return_trace (c->check_struct (this) && featureIndex.sanitize (c));\n@@ -1546,6 +1068,22 @@\n-  bool intersects (const hb_set_t *glyphs) const\n-  {\n-    return hb_any (+ hb_iter (rangeRecord.as_array ())\n-                   | hb_map ([glyphs] (const RangeRecord &range) { return range.intersects (glyphs); }));\n-  }\n-  bool intersects_coverage (const hb_set_t *glyphs, unsigned int index) const\n+  Offset16      lookupOrderZ;   \/* = Null (reserved for an offset to a\n+                                 * reordering table) *\/\n+  HBUINT16      reqFeatureIndex;\/* Index of a feature required for this\n+                                 * language system--if no required features\n+                                 * = 0xFFFFu *\/\n+  IndexArray    featureIndex;   \/* Array of indices into the FeatureList *\/\n+  public:\n+  DEFINE_SIZE_ARRAY_SIZED (6, featureIndex);\n+};\n+DECLARE_NULL_NAMESPACE_BYTES (OT, LangSys);\n+\n+struct Script\n+{\n+  unsigned int get_lang_sys_count () const\n+  { return langSys.len; }\n+  const Tag& get_lang_sys_tag (unsigned int i) const\n+  { return langSys.get_tag (i); }\n+  unsigned int get_lang_sys_tags (unsigned int start_offset,\n+                                  unsigned int *lang_sys_count \/* IN\/OUT *\/,\n+                                  hb_tag_t     *lang_sys_tags \/* OUT *\/) const\n+  { return langSys.get_tags (start_offset, lang_sys_count, lang_sys_tags); }\n+  const LangSys& get_lang_sys (unsigned int i) const\n@@ -1553,16 +1091,2 @@\n-    auto cmp = [] (const void *pk, const void *pr) -> int\n-    {\n-      unsigned index = * (const unsigned *) pk;\n-      const RangeRecord &range = * (const RangeRecord *) pr;\n-      if (index < range.value) return -1;\n-      if (index > (unsigned int) range.value + (range.last - range.first)) return +1;\n-      return 0;\n-    };\n-\n-    auto arr = rangeRecord.as_array ();\n-    unsigned idx;\n-    if (hb_bsearch_impl (&idx, index,\n-                         arr.arrayZ, arr.length, sizeof (arr[0]),\n-                         (int (*)(const void *_key, const void *_item)) cmp))\n-      return arr.arrayZ[idx].intersects (glyphs);\n-    return false;\n+    if (i == Index::NOT_FOUND_INDEX) return get_default_lang_sys ();\n+    return this+langSys[i].offset;\n@@ -1570,0 +1094,5 @@\n+  bool find_lang_sys_index (hb_tag_t tag, unsigned int *index) const\n+  { return langSys.find_index (tag, index); }\n+\n+  bool has_default_lang_sys () const           { return defaultLangSys != 0; }\n+  const LangSys& get_default_lang_sys () const { return this+defaultLangSys; }\n@@ -1571,1 +1100,2 @@\n-  void intersected_coverage_glyphs (const hb_set_t *glyphs, hb_set_t *intersect_glyphs) const\n+  void prune_langsys (hb_prune_langsys_context_t *c,\n+                      unsigned script_index) const\n@@ -1573,1 +1103,4 @@\n-    for (const auto& range : rangeRecord.as_array ())\n+    if (!has_default_lang_sys () && !get_lang_sys_count ()) return;\n+    if (!c->visitScript ()) return;\n+\n+    if (!c->script_langsys_map->has (script_index))\n@@ -1575,5 +1108,2 @@\n-      if (!range.intersects (glyphs)) continue;\n-      unsigned last = range.last;\n-      for (hb_codepoint_t g = range.first - 1;\n-           glyphs->next (&g) && g <= last;)\n-        intersect_glyphs->add (g);\n+      if (unlikely (!c->script_langsys_map->set (script_index, hb::unique_ptr<hb_set_t> {hb_set_create ()})))\n+        return;\n@@ -1581,1 +1111,0 @@\n-  }\n@@ -1583,9 +1112,7 @@\n-  template <typename set_t>\n-  bool collect_coverage (set_t *glyphs) const\n-  {\n-    unsigned int count = rangeRecord.len;\n-    for (unsigned int i = 0; i < count; i++)\n-      if (unlikely (!rangeRecord[i].collect_coverage (glyphs)))\n-        return false;\n-    return true;\n-  }\n+    if (has_default_lang_sys ())\n+    {\n+      \/\/only collect features from non-redundant langsys\n+      const LangSys& d = get_default_lang_sys ();\n+      if (c->visitLangsys (d.get_feature_count ())) {\n+        d.collect_features (c);\n+      }\n@@ -1593,5 +1120,11 @@\n-  public:\n-  \/* Older compilers need this to be public. *\/\n-  struct iter_t\n-  {\n-    void init (const CoverageFormat2 &c_)\n+      for (auto _ : + hb_enumerate (langSys))\n+      {\n+        const LangSys& l = this+_.second.offset;\n+        if (!c->visitLangsys (l.get_feature_count ())) continue;\n+        if (l.compare (d, c->duplicate_feature_map)) continue;\n+\n+        l.collect_features (c);\n+        c->script_langsys_map->get (script_index)->add (_.first);\n+      }\n+    }\n+    else\n@@ -1599,5 +1132,1 @@\n-      c = &c_;\n-      coverage = 0;\n-      i = 0;\n-      j = c->rangeRecord.len ? c->rangeRecord[0].first : 0;\n-      if (unlikely (c->rangeRecord[0].first > c->rangeRecord[0].last))\n+      for (auto _ : + hb_enumerate (langSys))\n@@ -1605,2 +1134,4 @@\n-        \/* Broken table. Skip. *\/\n-        i = c->rangeRecord.len;\n+        const LangSys& l = this+_.second.offset;\n+        if (!c->visitLangsys (l.get_feature_count ())) continue;\n+        l.collect_features (c);\n+        c->script_langsys_map->get (script_index)->add (_.first);\n@@ -1609,3 +1140,16 @@\n-    void fini () {}\n-    bool more () const { return i < c->rangeRecord.len; }\n-    void next ()\n+  }\n+\n+  bool subset (hb_subset_context_t         *c,\n+               hb_subset_layout_context_t  *l,\n+               const Tag                   *tag) const\n+  {\n+    TRACE_SUBSET (this);\n+    if (!l->visitScript ()) return_trace (false);\n+    if (tag && !c->plan->layout_scripts.has (*tag))\n+      return false;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!out || !c->serializer->extend_min (out))) return_trace (false);\n+\n+    bool defaultLang = false;\n+    if (has_default_lang_sys ())\n@@ -1613,1 +1157,4 @@\n-      if (j >= c->rangeRecord[i].last)\n+      c->serializer->push ();\n+      const LangSys& ls = this+defaultLangSys;\n+      bool ret = ls.subset (c, l);\n+      if (!ret && tag && *tag != HB_TAG ('D', 'F', 'L', 'T'))\n@@ -1615,19 +1162,7 @@\n-        i++;\n-        if (more ())\n-        {\n-          unsigned int old = coverage;\n-          j = c->rangeRecord[i].first;\n-          coverage = c->rangeRecord[i].value;\n-          if (unlikely (coverage != old + 1))\n-          {\n-            \/* Broken table. Skip. Important to avoid DoS.\n-             * Also, our callers depend on coverage being\n-             * consecutive and monotonically increasing,\n-             * ie. iota(). *\/\n-           i = c->rangeRecord.len;\n-           return;\n-          }\n-        }\n-        else\n-          j = 0;\n-        return;\n+        c->serializer->pop_discard ();\n+        out->defaultLangSys = 0;\n+      }\n+      else\n+      {\n+        c->serializer->add_link (out->defaultLangSys, c->serializer->pop_pack ());\n+        defaultLang = true;\n@@ -1635,2 +1170,0 @@\n-      coverage++;\n-      j++;\n@@ -1638,4 +1171,3 @@\n-    hb_codepoint_t get_glyph () const { return j; }\n-    bool operator != (const iter_t& o) const\n-    { return i != o.i || j != o.j; }\n-    iter_t __end__ () const\n+\n+    const hb_set_t *active_langsys = l->script_langsys_map->get (l->cur_script_index);\n+    if (active_langsys)\n@@ -1643,5 +1175,6 @@\n-      iter_t it;\n-      it.init (*c);\n-      it.i = c->rangeRecord.len;\n-      it.j = 0;\n-      return it;\n+      + hb_enumerate (langSys)\n+      | hb_filter (active_langsys, hb_first)\n+      | hb_map (hb_second)\n+      | hb_filter ([=] (const Record<LangSys>& record) {return l->visitLangSys (); })\n+      | hb_apply (subset_record_array (l, &(out->langSys), this))\n+      ;\n@@ -1650,6 +1183,9 @@\n-    private:\n-    const struct CoverageFormat2 *c;\n-    unsigned int i, coverage;\n-    hb_codepoint_t j;\n-  };\n-  private:\n+    return_trace (bool (out->langSys.len) || defaultLang || l->table_tag == HB_OT_TAG_GSUB);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c,\n+                 const Record_sanitize_closure_t * = nullptr) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (defaultLangSys.sanitize (c, this) && langSys.sanitize (c, this));\n+  }\n@@ -1658,5 +1194,6 @@\n-  HBUINT16      coverageFormat; \/* Format identifier--format = 2 *\/\n-  SortedArray16Of<RangeRecord>\n-                rangeRecord;    \/* Array of glyph ranges--ordered by\n-                                 * Start GlyphID. rangeCount entries\n-                                 * long *\/\n+  Offset16To<LangSys>\n+                defaultLangSys; \/* Offset to DefaultLangSys table--from\n+                                 * beginning of Script table--may be Null *\/\n+  RecordArrayOf<LangSys>\n+                langSys;        \/* Array of LangSysRecords--listed\n+                                 * alphabetically by LangSysTag *\/\n@@ -1664,1 +1201,1 @@\n-  DEFINE_SIZE_ARRAY (4, rangeRecord);\n+  DEFINE_SIZE_ARRAY_SIZED (4, langSys);\n@@ -1667,1 +1204,1 @@\n-struct Coverage\n+struct RecordListOfScript : RecordListOf<Script>\n@@ -1669,21 +1206,2 @@\n-  \/* Has interface. *\/\n-  static constexpr unsigned SENTINEL = NOT_COVERED;\n-  typedef unsigned int value_t;\n-  value_t operator [] (hb_codepoint_t k) const { return get (k); }\n-  bool has (hb_codepoint_t k) const { return (*this)[k] != SENTINEL; }\n-  \/* Predicate. *\/\n-  bool operator () (hb_codepoint_t k) const { return has (k); }\n-\n-  unsigned int get (hb_codepoint_t k) const { return get_coverage (k); }\n-  unsigned int get_coverage (hb_codepoint_t glyph_id) const\n-  {\n-    switch (u.format) {\n-    case 1: return u.format1.get_coverage (glyph_id);\n-    case 2: return u.format2.get_coverage (glyph_id);\n-    default:return NOT_COVERED;\n-    }\n-  }\n-\n-  template <typename Iterator,\n-      hb_requires (hb_is_sorted_source_of (Iterator, hb_codepoint_t))>\n-  bool serialize (hb_serialize_context_t *c, Iterator glyphs)\n+  bool subset (hb_subset_context_t *c,\n+               hb_subset_layout_context_t *l) const\n@@ -1691,2 +1209,3 @@\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!c->extend_min (this))) return_trace (false);\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!out || !c->serializer->extend_min (out))) return_trace (false);\n@@ -1694,4 +1213,1 @@\n-    unsigned count = 0;\n-    unsigned num_ranges = 0;\n-    hb_codepoint_t last = (hb_codepoint_t) -2;\n-    for (auto g: glyphs)\n+    for (auto _ : + hb_enumerate (*this))\n@@ -1699,4 +1215,5 @@\n-      if (last + 1 != g)\n-        num_ranges++;\n-      last = g;\n-      count++;\n+      auto snap = c->serializer->snapshot ();\n+      l->cur_script_index = _.first;\n+      bool ret = _.second.subset (l, this);\n+      if (!ret) c->serializer->revert (snap);\n+      else out->len++;\n@@ -1704,1 +1221,0 @@\n-    u.format = count <= num_ranges * 3 ? 1 : 2;\n@@ -1706,6 +1222,1 @@\n-    switch (u.format)\n-    {\n-    case 1: return_trace (u.format1.serialize (c, glyphs));\n-    case 2: return_trace (u.format2.serialize (c, glyphs));\n-    default:return_trace (false);\n-    }\n+    return_trace (true);\n@@ -1713,0 +1224,1 @@\n+};\n@@ -1714,8 +1226,1 @@\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto it =\n-    + iter ()\n-    | hb_filter (c->plan->glyph_map_gsub)\n-    | hb_map_retains_sorting (c->plan->glyph_map_gsub)\n-    ;\n+typedef RecordListOfScript ScriptList;\n@@ -1723,6 +1228,0 @@\n-    \/\/ Cache the iterator result as it will be iterated multiple times\n-    \/\/ by the serialize code below.\n-    hb_sorted_vector_t<hb_codepoint_t> glyphs (it);\n-    Coverage_serialize (c->serializer, glyphs.iter ());\n-    return_trace (bool (glyphs));\n-  }\n@@ -1730,1 +1229,41 @@\n-  bool sanitize (hb_sanitize_context_t *c) const\n+\n+struct LookupFlag : HBUINT16\n+{\n+  enum Flags {\n+    RightToLeft         = 0x0001u,\n+    IgnoreBaseGlyphs    = 0x0002u,\n+    IgnoreLigatures     = 0x0004u,\n+    IgnoreMarks         = 0x0008u,\n+    IgnoreFlags         = 0x000Eu,\n+    UseMarkFilteringSet = 0x0010u,\n+    Reserved            = 0x00E0u,\n+    MarkAttachmentType  = 0xFF00u\n+  };\n+  public:\n+  DEFINE_SIZE_STATIC (2);\n+};\n+\n+} \/* namespace OT *\/\n+\/* This has to be outside the namespace. *\/\n+HB_MARK_AS_FLAG_T (OT::LookupFlag::Flags);\n+namespace OT {\n+\n+struct Lookup\n+{\n+  unsigned int get_subtable_count () const { return subTable.len; }\n+\n+  template <typename TSubTable>\n+  const Array16OfOffset16To<TSubTable>& get_subtables () const\n+  { return reinterpret_cast<const Array16OfOffset16To<TSubTable> &> (subTable); }\n+  template <typename TSubTable>\n+  Array16OfOffset16To<TSubTable>& get_subtables ()\n+  { return reinterpret_cast<Array16OfOffset16To<TSubTable> &> (subTable); }\n+\n+  template <typename TSubTable>\n+  const TSubTable& get_subtable (unsigned int i) const\n+  { return this+get_subtables<TSubTable> ()[i]; }\n+  template <typename TSubTable>\n+  TSubTable& get_subtable (unsigned int i)\n+  { return this+get_subtables<TSubTable> ()[i]; }\n+\n+  unsigned int get_size () const\n@@ -1732,8 +1271,4 @@\n-    TRACE_SANITIZE (this);\n-    if (!u.format.sanitize (c)) return_trace (false);\n-    switch (u.format)\n-    {\n-    case 1: return_trace (u.format1.sanitize (c));\n-    case 2: return_trace (u.format2.sanitize (c));\n-    default:return_trace (true);\n-    }\n+    const HBUINT16 &markFilteringSet = StructAfter<const HBUINT16> (subTable);\n+    if (lookupFlag & LookupFlag::UseMarkFilteringSet)\n+      return (const char *) &StructAfter<const char> (markFilteringSet) - (const char *) this;\n+    return (const char *) &markFilteringSet - (const char *) this;\n@@ -1742,1 +1277,6 @@\n-  bool intersects (const hb_set_t *glyphs) const\n+  unsigned int get_type () const { return lookupType; }\n+\n+  \/* lookup_props is a 32-bit integer where the lower 16-bit is LookupFlag and\n+   * higher 16-bit is mark-filtering-set if the lookup uses one.\n+   * Not to be confused with glyph_props which is very similar. *\/\n+  uint32_t get_props () const\n@@ -1744,1 +1284,2 @@\n-    switch (u.format)\n+    unsigned int flag = lookupFlag;\n+    if (unlikely (flag & LookupFlag::UseMarkFilteringSet))\n@@ -1746,3 +1287,2 @@\n-    case 1: return u.format1.intersects (glyphs);\n-    case 2: return u.format2.intersects (glyphs);\n-    default:return false;\n+      const HBUINT16 &markFilteringSet = StructAfter<HBUINT16> (subTable);\n+      flag += (markFilteringSet << 16);\n@@ -1750,0 +1290,1 @@\n+    return flag;\n@@ -1751,1 +1292,3 @@\n-  bool intersects_coverage (const hb_set_t *glyphs, unsigned int index) const\n+\n+  template <typename TSubTable, typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n@@ -1753,5 +1296,7 @@\n-    switch (u.format)\n-    {\n-    case 1: return u.format1.intersects_coverage (glyphs, index);\n-    case 2: return u.format2.intersects_coverage (glyphs, index);\n-    default:return false;\n+    unsigned int lookup_type = get_type ();\n+    TRACE_DISPATCH (this, lookup_type);\n+    unsigned int count = get_subtable_count ();\n+    for (unsigned int i = 0; i < count; i++) {\n+      typename context_t::return_t r = get_subtable<TSubTable> (i).dispatch (c, lookup_type, std::forward<Ts> (ds)...);\n+      if (c->stop_sublookup_iteration (r))\n+        return_trace (r);\n@@ -1759,0 +1304,1 @@\n+    return_trace (c->default_return_value ());\n@@ -1761,4 +1307,4 @@\n-  \/* Might return false if array looks unsorted.\n-   * Used for faster rejection of corrupt data. *\/\n-  template <typename set_t>\n-  bool collect_coverage (set_t *glyphs) const\n+  bool serialize (hb_serialize_context_t *c,\n+                  unsigned int lookup_type,\n+                  uint32_t lookup_props,\n+                  unsigned int num_subtables)\n@@ -1766,1 +1312,6 @@\n-    switch (u.format)\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n+    lookupType = lookup_type;\n+    lookupFlag = lookup_props & 0xFFFFu;\n+    if (unlikely (!subTable.serialize (c, num_subtables))) return_trace (false);\n+    if (lookupFlag & LookupFlag::UseMarkFilteringSet)\n@@ -1768,3 +1319,3 @@\n-    case 1: return u.format1.collect_coverage (glyphs);\n-    case 2: return u.format2.collect_coverage (glyphs);\n-    default:return false;\n+      if (unlikely (!c->extend (this))) return_trace (false);\n+      HBUINT16 &markFilteringSet = StructAfter<HBUINT16> (subTable);\n+      markFilteringSet = lookup_props >> 16;\n@@ -1772,0 +1323,1 @@\n+    return_trace (true);\n@@ -1774,1 +1326,2 @@\n-  void intersected_coverage_glyphs (const hb_set_t *glyphs, hb_set_t *intersect_glyphs) const\n+  template <typename TSubTable>\n+  bool subset (hb_subset_context_t *c) const\n@@ -1776,1 +1329,14 @@\n-    switch (u.format)\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!out || !c->serializer->extend_min (out))) return_trace (false);\n+    out->lookupType = lookupType;\n+    out->lookupFlag = lookupFlag;\n+\n+    const hb_set_t *glyphset = c->plan->glyphset_gsub ();\n+    unsigned int lookup_type = get_type ();\n+    + hb_iter (get_subtables <TSubTable> ())\n+    | hb_filter ([this, glyphset, lookup_type] (const Offset16To<TSubTable> &_) { return (this+_).intersects (glyphset, lookup_type); })\n+    | hb_apply (subset_offset_array (c, out->get_subtables<TSubTable> (), this, lookup_type))\n+    ;\n+\n+    if (lookupFlag & LookupFlag::UseMarkFilteringSet)\n@@ -1778,3 +1344,4 @@\n-    case 1: return u.format1.intersected_coverage_glyphs (glyphs, intersect_glyphs);\n-    case 2: return u.format2.intersected_coverage_glyphs (glyphs, intersect_glyphs);\n-    default:return ;\n+      if (unlikely (!c->serializer->extend (out))) return_trace (false);\n+      const HBUINT16 &markFilteringSet = StructAfter<HBUINT16> (subTable);\n+      HBUINT16 &outMarkFilteringSet = StructAfter<HBUINT16> (out->subTable);\n+      outMarkFilteringSet = markFilteringSet;\n@@ -1782,0 +1349,8 @@\n+\n+    \/\/ Always keep the lookup even if it's empty. The rest of layout subsetting depends on lookup\n+    \/\/ indices being consistent with those computed during planning. So if an empty lookup is\n+    \/\/ discarded during the subset phase it will invalidate all subsequent lookup indices.\n+    \/\/ Generally we shouldn't end up with an empty lookup as we pre-prune them during the planning\n+    \/\/ phase, but it can happen in rare cases such as when during closure subtable is considered\n+    \/\/ degenerate (see: https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/3853)\n+    return_trace (true);\n@@ -1784,1 +1359,2 @@\n-  struct iter_t : hb_iter_with_fallback_t<iter_t, hb_codepoint_t>\n+  template <typename TSubTable>\n+  bool sanitize (hb_sanitize_context_t *c) const\n@@ -1786,32 +1362,2 @@\n-    static constexpr bool is_sorted_iterator = true;\n-    iter_t (const Coverage &c_ = Null (Coverage))\n-    {\n-      memset (this, 0, sizeof (*this));\n-      format = c_.u.format;\n-      switch (format)\n-      {\n-      case 1: u.format1.init (c_.u.format1); return;\n-      case 2: u.format2.init (c_.u.format2); return;\n-      default:                               return;\n-      }\n-    }\n-    bool __more__ () const\n-    {\n-      switch (format)\n-      {\n-      case 1: return u.format1.more ();\n-      case 2: return u.format2.more ();\n-      default:return false;\n-      }\n-    }\n-    void __next__ ()\n-    {\n-      switch (format)\n-      {\n-      case 1: u.format1.next (); break;\n-      case 2: u.format2.next (); break;\n-      default:                   break;\n-      }\n-    }\n-    typedef hb_codepoint_t __item_t__;\n-    __item_t__ __item__ () const { return get_glyph (); }\n+    TRACE_SANITIZE (this);\n+    if (!(c->check_struct (this) && subTable.sanitize (c))) return_trace (false);\n@@ -1819,10 +1365,4 @@\n-    hb_codepoint_t get_glyph () const\n-    {\n-      switch (format)\n-      {\n-      case 1: return u.format1.get_glyph ();\n-      case 2: return u.format2.get_glyph ();\n-      default:return 0;\n-      }\n-    }\n-    bool operator != (const iter_t& o) const\n+    unsigned subtables = get_subtable_count ();\n+    if (unlikely (!c->visit_subtables (subtables))) return_trace (false);\n+\n+    if (lookupFlag & LookupFlag::UseMarkFilteringSet)\n@@ -1830,7 +1370,2 @@\n-      if (unlikely (format != o.format)) return true;\n-      switch (format)\n-      {\n-      case 1: return u.format1 != o.u.format1;\n-      case 2: return u.format2 != o.u.format2;\n-      default:return false;\n-      }\n+      const HBUINT16 &markFilteringSet = StructAfter<HBUINT16> (subTable);\n+      if (!markFilteringSet.sanitize (c)) return_trace (false);\n@@ -1838,1 +1373,5 @@\n-    iter_t __end__ () const\n+\n+    if (unlikely (!get_subtables<TSubTable> ().sanitize (c, this, get_type ())))\n+      return_trace (false);\n+\n+    if (unlikely (get_type () == TSubTable::Extension && !c->get_edit_count ()))\n@@ -1840,9 +1379,14 @@\n-      iter_t it = {};\n-      it.format = format;\n-      switch (format)\n-      {\n-      case 1: it.u.format1 = u.format1.__end__ (); break;\n-      case 2: it.u.format2 = u.format2.__end__ (); break;\n-      default: break;\n-      }\n-      return it;\n+      \/* The spec says all subtables of an Extension lookup should\n+       * have the same type, which shall not be the Extension type\n+       * itself (but we already checked for that).\n+       * This is specially important if one has a reverse type!\n+       *\n+       * We only do this if sanitizer edit_count is zero.  Otherwise,\n+       * some of the subtables might have become insane after they\n+       * were sanity-checked by the edits of subsequent subtables.\n+       * https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=960331\n+       *\/\n+      unsigned int type = get_subtable<TSubTable> (0).u.extension.get_type ();\n+      for (unsigned int i = 1; i < subtables; i++)\n+        if (get_subtable<TSubTable> (i).u.extension.get_type () != type)\n+          return_trace (false);\n@@ -1850,0 +1394,14 @@\n+    return_trace (true);\n+  }\n+\n+  protected:\n+  HBUINT16      lookupType;             \/* Different enumerations for GSUB and GPOS *\/\n+  HBUINT16      lookupFlag;             \/* Lookup qualifiers *\/\n+  Array16Of<Offset16>\n+                subTable;               \/* Array of SubTables *\/\n+\/*HBUINT16      markFilteringSetX[HB_VAR_ARRAY];*\/\/* Index (base 0) into GDEF mark glyph sets\n+                                         * structure. This field is only present if bit\n+                                         * UseMarkFilteringSet of lookup flags is set. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, subTable);\n+};\n@@ -1851,8 +1409,2 @@\n-    private:\n-    unsigned int format;\n-    union {\n-    CoverageFormat2::iter_t     format2; \/* Put this one first since it's larger; helps shut up compiler. *\/\n-    CoverageFormat1::iter_t     format1;\n-    } u;\n-  };\n-  iter_t iter () const { return iter_t (*this); }\n+template <typename Types>\n+using LookupList = List16OfOffsetTo<Lookup, typename Types::HBUINT>;\n@@ -1860,8 +1412,23 @@\n-  protected:\n-  union {\n-  HBUINT16              format;         \/* Format identifier *\/\n-  CoverageFormat1       format1;\n-  CoverageFormat2       format2;\n-  } u;\n-  public:\n-  DEFINE_SIZE_UNION (2, format);\n+template <typename TLookup, typename OffsetType>\n+struct LookupOffsetList : List16OfOffsetTo<TLookup, OffsetType>\n+{\n+  bool subset (hb_subset_context_t        *c,\n+               hb_subset_layout_context_t *l) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (this);\n+    if (unlikely (!out || !c->serializer->extend_min (out))) return_trace (false);\n+\n+    + hb_enumerate (*this)\n+    | hb_filter (l->lookup_index_map, hb_first)\n+    | hb_map (hb_second)\n+    | hb_apply (subset_offset_array (c, *out, this))\n+    ;\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (List16OfOffset16To<TLookup>::sanitize (c, this));\n+  }\n@@ -1870,5 +1437,0 @@\n-template<typename Iterator>\n-static inline void\n-Coverage_serialize (hb_serialize_context_t *c,\n-                    Iterator it)\n-{ c->start_embed<Coverage> ()->serialize (c, it); }\n@@ -1876,1 +1438,6 @@\n-static void ClassDef_remap_and_serialize (hb_serialize_context_t *c,\n+\/*\n+ * Coverage Table\n+ *\/\n+\n+\n+static bool ClassDef_remap_and_serialize (hb_serialize_context_t *c,\n@@ -1883,4 +1450,1 @@\n-  {\n-    ClassDef_serialize (c, glyph_and_klass.iter ());\n-    return;\n-  }\n+    return ClassDef_serialize (c, glyph_and_klass.iter ());\n@@ -1894,1 +1458,1 @@\n-  for (const unsigned k: klasses.iter ())\n+  for (const unsigned k: klasses)\n@@ -1909,1 +1473,1 @@\n-  ClassDef_serialize (c, glyph_and_klass.iter ());\n+  return ClassDef_serialize (c, glyph_and_klass.iter ());\n@@ -1916,1 +1480,2 @@\n-struct ClassDefFormat1\n+template <typename Types>\n+struct ClassDefFormat1_3\n@@ -1926,0 +1491,5 @@\n+  unsigned get_population () const\n+  {\n+    return classValue.len;\n+  }\n+\n@@ -1927,1 +1497,1 @@\n-           hb_requires (hb_is_iterator (Iterator))>\n+           hb_requires (hb_is_sorted_source_of (Iterator, hb_codepoint_t))>\n@@ -1950,1 +1520,1 @@\n-    for (const hb_pair_t<hb_codepoint_t, unsigned> gid_klass_pair : + it)\n+    for (const hb_pair_t<hb_codepoint_t, uint32_t> gid_klass_pair : + it)\n@@ -1965,1 +1535,1 @@\n-    const hb_map_t &glyph_map = *c->plan->glyph_map_gsub;\n+    const hb_map_t &glyph_map = c->plan->glyph_map_gsub;\n@@ -1990,5 +1560,6 @@\n-    ClassDef_remap_and_serialize (c->serializer,\n-                                  orig_klasses,\n-                                  use_class_zero,\n-                                  glyph_and_klass,\n-                                  klass_map);\n+    if (!ClassDef_remap_and_serialize (c->serializer,\n+                                       orig_klasses,\n+                                       use_class_zero,\n+                                       glyph_and_klass,\n+                                       klass_map))\n+      return_trace (false);\n@@ -2040,1 +1611,0 @@\n-    \/* TODO Speed up, using hb_set_next()? *\/\n@@ -2044,1 +1614,1 @@\n-         hb_set_next (glyphs, &iter) && iter < end;)\n+         glyphs->next (&iter) && iter < end;)\n@@ -2055,1 +1625,1 @@\n-      if (!hb_set_next (glyphs, &g)) return false;\n+      if (!glyphs->next (&g)) return false;\n@@ -2058,1 +1628,1 @@\n-      if (hb_set_next (glyphs, &g)) return true;\n+      if (glyphs->next (&g)) return true;\n@@ -2076,2 +1646,2 @@\n-      for (unsigned g = HB_SET_VALUE_INVALID;\n-           hb_set_next (glyphs, &g) && g < start_glyph;)\n+      for (uint32_t g = HB_SET_VALUE_INVALID;\n+           glyphs->next (&g) && g < start_glyph;)\n@@ -2080,2 +1650,2 @@\n-      for (unsigned g = startGlyph + count - 1;\n-           hb_set_next (glyphs, &g);)\n+      for (uint32_t g = startGlyph + count - 1;\n+           glyphs-> next (&g);)\n@@ -2097,1 +1667,1 @@\n-         hb_set_next (glyphs, &g) && g < end_glyph;)\n+         glyphs->next (&g) && g < end_glyph;)\n@@ -2121,2 +1691,3 @@\n-  HBGlyphID16   startGlyph;     \/* First GlyphID of the classValueArray *\/\n-  Array16Of<HBUINT16>\n+  typename Types::HBGlyphID\n+                 startGlyph;    \/* First GlyphID of the classValueArray *\/\n+  typename Types::template ArrayOf<HBUINT16>\n@@ -2125,1 +1696,1 @@\n-  DEFINE_SIZE_ARRAY (6, classValue);\n+  DEFINE_SIZE_ARRAY (2 + 2 * Types::size, classValue);\n@@ -2128,1 +1699,2 @@\n-struct ClassDefFormat2\n+template <typename Types>\n+struct ClassDefFormat2_4\n@@ -2138,0 +1710,8 @@\n+  unsigned get_population () const\n+  {\n+    typename Types::large_int ret = 0;\n+    for (const auto &r : rangeRecord)\n+      ret += r.get_population ();\n+    return ret > UINT_MAX ? UINT_MAX : (unsigned) ret;\n+  }\n+\n@@ -2139,1 +1719,1 @@\n-           hb_requires (hb_is_iterator (Iterator))>\n+           hb_requires (hb_is_sorted_source_of (Iterator, hb_codepoint_t))>\n@@ -2157,1 +1737,1 @@\n-    RangeRecord range_rec;\n+    RangeRecord<Types> range_rec;\n@@ -2162,1 +1742,1 @@\n-    RangeRecord *record = c->copy (range_rec);\n+    auto *record = c->copy (range_rec);\n@@ -2200,1 +1780,2 @@\n-    const hb_map_t &glyph_map = *c->plan->glyph_map_gsub;\n+    const hb_map_t &glyph_map = c->plan->glyph_map_gsub;\n+    const hb_set_t &glyph_set = *c->plan->glyphset_gsub ();\n@@ -2205,2 +1786,2 @@\n-    unsigned count = rangeRecord.len;\n-    for (unsigned i = 0; i < count; i++)\n+    if (glyph_set.get_population () * hb_bit_storage ((unsigned) rangeRecord.len) \/ 2\n+        < get_population ())\n@@ -2208,5 +1789,1 @@\n-      unsigned klass = rangeRecord[i].value;\n-      if (!klass) continue;\n-      hb_codepoint_t start = rangeRecord[i].first;\n-      hb_codepoint_t end   = rangeRecord[i].last + 1;\n-      for (hb_codepoint_t g = start; g < end; g++)\n+      for (hb_codepoint_t g : glyph_set)\n@@ -2214,0 +1791,2 @@\n+        unsigned klass = get_class (g);\n+        if (!klass) continue;\n@@ -2217,1 +1796,0 @@\n-\n@@ -2222,0 +1800,20 @@\n+    else\n+    {\n+      unsigned num_source_glyphs = c->plan->source->get_num_glyphs ();\n+      for (auto &range : rangeRecord)\n+      {\n+        unsigned klass = range.value;\n+        if (!klass) continue;\n+        hb_codepoint_t start = range.first;\n+        hb_codepoint_t end   = hb_min (range.last + 1, num_source_glyphs);\n+        for (hb_codepoint_t g = start; g < end; g++)\n+        {\n+          hb_codepoint_t new_gid = glyph_map[g];\n+          if (new_gid == HB_MAP_VALUE_INVALID) continue;\n+          if (glyph_filter && !glyph_filter->has (g)) continue;\n+\n+          glyph_and_klass.push (hb_pair (new_gid, klass));\n+          orig_klasses.add (klass);\n+        }\n+      }\n+    }\n@@ -2228,5 +1826,6 @@\n-    ClassDef_remap_and_serialize (c->serializer,\n-                                  orig_klasses,\n-                                  use_class_zero,\n-                                  glyph_and_klass,\n-                                  klass_map);\n+    if (!ClassDef_remap_and_serialize (c->serializer,\n+                                       orig_klasses,\n+                                       use_class_zero,\n+                                       glyph_and_klass,\n+                                       klass_map))\n+      return_trace (false);\n@@ -2247,4 +1846,3 @@\n-    unsigned int count = rangeRecord.len;\n-    for (unsigned int i = 0; i < count; i++)\n-      if (rangeRecord[i].value)\n-        if (unlikely (!rangeRecord[i].collect_coverage (glyphs)))\n+    for (auto &range : rangeRecord)\n+      if (range.value)\n+        if (unlikely (!range.collect_coverage (glyphs)))\n@@ -2258,2 +1856,1 @@\n-    unsigned int count = rangeRecord.len;\n-    for (unsigned int i = 0; i < count; i++)\n+    for (auto &range : rangeRecord)\n@@ -2261,2 +1858,2 @@\n-      if (rangeRecord[i].value == klass)\n-        if (unlikely (!rangeRecord[i].collect_coverage (glyphs)))\n+      if (range.value == klass)\n+        if (unlikely (!range.collect_coverage (glyphs)))\n@@ -2270,3 +1867,1 @@\n-    \/* TODO Speed up, using hb_set_next() and bsearch()? *\/\n-    unsigned int count = rangeRecord.len;\n-    for (unsigned int i = 0; i < count; i++)\n+    if (rangeRecord.len > glyphs->get_population () * hb_bit_storage ((unsigned) rangeRecord.len) \/ 2)\n@@ -2274,3 +1869,4 @@\n-      const auto& range = rangeRecord[i];\n-      if (range.intersects (glyphs) && range.value)\n-        return true;\n+      for (hb_codepoint_t g = HB_SET_VALUE_INVALID; glyphs->next (&g);)\n+        if (get_class (g))\n+          return true;\n+      return false;\n@@ -2278,1 +1874,3 @@\n-    return false;\n+\n+    return hb_any (+ hb_iter (rangeRecord)\n+                   | hb_map ([glyphs] (const RangeRecord<Types> &range) { return range.intersects (*glyphs) && range.value; }));\n@@ -2282,1 +1880,0 @@\n-    unsigned int count = rangeRecord.len;\n@@ -2287,1 +1884,1 @@\n-      for (unsigned int i = 0; i < count; i++)\n+      for (auto &range : rangeRecord)\n@@ -2289,1 +1886,1 @@\n-        if (!hb_set_next (glyphs, &g))\n+        if (!glyphs->next (&g))\n@@ -2291,1 +1888,1 @@\n-        if (g < rangeRecord[i].first)\n+        if (g < range.first)\n@@ -2293,1 +1890,1 @@\n-        g = rangeRecord[i].last;\n+        g = range.last;\n@@ -2295,1 +1892,1 @@\n-      if (g != HB_SET_VALUE_INVALID && hb_set_next (glyphs, &g))\n+      if (g != HB_SET_VALUE_INVALID && glyphs->next (&g))\n@@ -2299,5 +1896,2 @@\n-    \/* TODO Speed up, using set overlap first? *\/\n-    \/* TODO(iter) Rewrite as dagger. *\/\n-    const RangeRecord *arr = rangeRecord.arrayZ;\n-    for (unsigned int i = 0; i < count; i++)\n-      if (arr[i].value == klass && arr[i].intersects (glyphs))\n+    for (const auto &range : rangeRecord)\n+      if (range.value == klass && range.intersects (*glyphs))\n@@ -2310,1 +1904,0 @@\n-    unsigned count = rangeRecord.len;\n@@ -2314,1 +1907,1 @@\n-      for (unsigned int i = 0; i < count; i++)\n+      for (auto &range : rangeRecord)\n@@ -2316,1 +1909,1 @@\n-        if (!hb_set_next (glyphs, &g))\n+        if (!glyphs->next (&g))\n@@ -2318,1 +1911,1 @@\n-        while (g < rangeRecord[i].first)\n+        while (g < range.first)\n@@ -2321,1 +1914,1 @@\n-          if (!hb_set_next (glyphs, &g))\n+          if (!glyphs->next (&g))\n@@ -2324,1 +1917,1 @@\n-        g = rangeRecord[i].last;\n+        g = range.last;\n@@ -2326,1 +1919,1 @@\n-      while (hb_set_next (glyphs, &g))\n+      while (glyphs->next (&g))\n@@ -2333,4 +1926,2 @@\n-#if 0\n-    \/* The following implementation is faster asymptotically, but slower\n-     * in practice. *\/\n-    if ((count >> 3) > glyphs->get_population ())\n+    unsigned count = rangeRecord.len;\n+    if (count > glyphs->get_population () * hb_bit_storage (count) * 8)\n@@ -2339,2 +1930,5 @@\n-           hb_set_next (glyphs, &g);)\n-        if (rangeRecord.as_array ().bfind (g))\n+           glyphs->next (&g);)\n+      {\n+        unsigned i;\n+        if (rangeRecord.as_array ().bfind (g, &i) &&\n+            rangeRecord.arrayZ[i].value == klass)\n@@ -2342,0 +1936,1 @@\n+      }\n@@ -2344,1 +1939,0 @@\n-#endif\n@@ -2346,1 +1940,1 @@\n-    for (unsigned int i = 0; i < count; i++)\n+    for (auto &range : rangeRecord)\n@@ -2348,1 +1942,1 @@\n-      if (rangeRecord[i].value != klass) continue;\n+      if (range.value != klass) continue;\n@@ -2350,3 +1944,3 @@\n-      unsigned end = rangeRecord[i].last + 1;\n-      for (hb_codepoint_t g = rangeRecord[i].first - 1;\n-           hb_set_next (glyphs, &g) && g < end;)\n+      unsigned end = range.last + 1;\n+      for (hb_codepoint_t g = range.first - 1;\n+           glyphs->next (&g) && g < end;)\n@@ -2361,1 +1955,0 @@\n-    unsigned count = rangeRecord.len;\n@@ -2363,1 +1956,1 @@\n-    for (unsigned int i = 0; i < count; i++)\n+    for (auto &range : rangeRecord)\n@@ -2365,1 +1958,1 @@\n-      if (!hb_set_next (glyphs, &g))\n+      if (!glyphs->next (&g))\n@@ -2367,1 +1960,1 @@\n-      if (g < rangeRecord[i].first)\n+      if (g < range.first)\n@@ -2372,1 +1965,1 @@\n-      g = rangeRecord[i].last;\n+      g = range.last;\n@@ -2374,1 +1967,1 @@\n-    if (g != HB_SET_VALUE_INVALID && hb_set_next (glyphs, &g))\n+    if (g != HB_SET_VALUE_INVALID && glyphs->next (&g))\n@@ -2377,3 +1970,3 @@\n-    for (const RangeRecord& record : rangeRecord.iter ())\n-      if (record.intersects (glyphs))\n-        intersect_classes->add (record.value);\n+    for (const auto& range : rangeRecord)\n+      if (range.intersects (*glyphs))\n+        intersect_classes->add (range.value);\n@@ -2384,1 +1977,1 @@\n-  SortedArray16Of<RangeRecord>\n+  typename Types::template SortedArrayOf<RangeRecord<Types>>\n@@ -2388,1 +1981,1 @@\n-  DEFINE_SIZE_ARRAY (4, rangeRecord);\n+  DEFINE_SIZE_ARRAY (2 + Types::size, rangeRecord);\n@@ -2394,4 +1987,2 @@\n-  static constexpr unsigned SENTINEL = 0;\n-  typedef unsigned int value_t;\n-  value_t operator [] (hb_codepoint_t k) const { return get (k); }\n-  bool has (hb_codepoint_t k) const { return (*this)[k] != SENTINEL; }\n+  unsigned operator [] (hb_codepoint_t k) const { return get (k); }\n+  bool has (hb_codepoint_t k) const { return (*this)[k]; }\n@@ -2407,0 +1998,4 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return u.format3.get_class (glyph_id);\n+    case 4: return u.format4.get_class (glyph_id);\n+#endif\n@@ -2411,0 +2006,13 @@\n+  unsigned get_population () const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.get_population ();\n+    case 2: return u.format2.get_population ();\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return u.format3.get_population ();\n+    case 4: return u.format4.get_population ();\n+#endif\n+    default:return NOT_COVERED;\n+    }\n+  }\n+\n@@ -2412,1 +2020,1 @@\n-           hb_requires (hb_is_iterator (Iterator))>\n+           hb_requires (hb_is_sorted_source_of (Iterator, hb_codepoint_t))>\n@@ -2421,0 +2029,1 @@\n+    hb_codepoint_t glyph_max = 0;\n@@ -2424,1 +2033,1 @@\n-      hb_codepoint_t glyph_max = glyph_min;\n+      glyph_max = glyph_min;\n@@ -2449,0 +2058,6 @@\n+\n+#ifndef HB_NO_BEYOND_64K\n+    if (glyph_max > 0xFFFFu)\n+      format += 2;\n+#endif\n+\n@@ -2455,0 +2070,4 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return_trace (u.format3.serialize (c, it));\n+    case 4: return_trace (u.format4.serialize (c, it));\n+#endif\n@@ -2469,0 +2088,4 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return_trace (u.format3.subset (c, klass_map, keep_empty_table, use_class_zero, glyph_filter));\n+    case 4: return_trace (u.format4.subset (c, klass_map, keep_empty_table, use_class_zero, glyph_filter));\n+#endif\n@@ -2480,0 +2103,4 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return_trace (u.format3.sanitize (c));\n+    case 4: return_trace (u.format4.sanitize (c));\n+#endif\n@@ -2489,0 +2116,4 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return u.format3.cost ();\n+    case 4: return u.format4.cost ();\n+#endif\n@@ -2501,0 +2132,4 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return u.format3.collect_coverage (glyphs);\n+    case 4: return u.format4.collect_coverage (glyphs);\n+#endif\n@@ -2513,0 +2148,4 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return u.format3.collect_class (glyphs, klass);\n+    case 4: return u.format4.collect_class (glyphs, klass);\n+#endif\n@@ -2522,0 +2161,4 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return u.format3.intersects (glyphs);\n+    case 4: return u.format4.intersects (glyphs);\n+#endif\n@@ -2530,0 +2173,4 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return u.format3.intersects_class (glyphs, klass);\n+    case 4: return u.format4.intersects_class (glyphs, klass);\n+#endif\n@@ -2539,0 +2186,4 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return u.format3.intersected_class_glyphs (glyphs, klass, intersect_glyphs);\n+    case 4: return u.format4.intersected_class_glyphs (glyphs, klass, intersect_glyphs);\n+#endif\n@@ -2548,0 +2199,4 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 3: return u.format3.intersected_classes (glyphs, intersect_classes);\n+    case 4: return u.format4.intersected_classes (glyphs, intersect_classes);\n+#endif\n@@ -2555,3 +2210,7 @@\n-  HBUINT16              format;         \/* Format identifier *\/\n-  ClassDefFormat1       format1;\n-  ClassDefFormat2       format2;\n+  HBUINT16                      format;         \/* Format identifier *\/\n+  ClassDefFormat1_3<SmallTypes> format1;\n+  ClassDefFormat2_4<SmallTypes> format2;\n+#ifndef HB_NO_BEYOND_64K\n+  ClassDefFormat1_3<MediumTypes>format3;\n+  ClassDefFormat2_4<MediumTypes>format4;\n+#endif\n@@ -2564,1 +2223,1 @@\n-static inline void ClassDef_serialize (hb_serialize_context_t *c,\n+static inline bool ClassDef_serialize (hb_serialize_context_t *c,\n@@ -2566,1 +2225,1 @@\n-{ c->start_embed<ClassDef> ()->serialize (c, it); }\n+{ return (c->start_embed<ClassDef> ()->serialize (c, it)); }\n@@ -2577,1 +2236,1 @@\n-    int start = startCoord, peak = peakCoord, end = endCoord;\n+    int start = startCoord.to_int (), peak = peakCoord.to_int (), end = endCoord.to_int ();\n@@ -2677,1 +2336,1 @@\n-      memcpy (&axesZ[axisCount * r], &src->axesZ[axisCount * backward], VarRegionAxis::static_size * axisCount);\n+      hb_memcpy (&axesZ[axisCount * r], &src->axesZ[axisCount * backward], VarRegionAxis::static_size * axisCount);\n@@ -2697,0 +2356,3 @@\n+  unsigned int get_item_count () const\n+  { return itemCount; }\n+\n@@ -2720,1 +2382,1 @@\n-   unsigned int scount = is_long ? count - word_count : word_count;\n+   unsigned int scount = is_long ? count : word_count;\n@@ -2724,1 +2386,1 @@\n-   const HBUINT8 *row = bytes + inner * (scount + count);\n+   const HBUINT8 *row = bytes + inner * get_row_size ();\n@@ -2729,1 +2391,1 @@\n-   const HBINT16 *lcursor = reinterpret_cast<const HBINT16 *> (row);\n+   const HBINT32 *lcursor = reinterpret_cast<const HBINT32 *> (row);\n@@ -2787,1 +2449,1 @@\n-    hb_vector_t<unsigned int> ri_map;   \/* maps old index to new index *\/\n+    hb_vector_t<unsigned int> ri_map;   \/* maps new index to old index *\/\n@@ -2793,0 +2455,5 @@\n+    const HBUINT8 *src_delta_bytes = src->get_delta_bytes ();\n+    unsigned src_row_size = src->get_row_size ();\n+    unsigned src_word_count = src->wordCount ();\n+    bool     src_long_words = src->longWords ();\n+\n@@ -2794,1 +2461,1 @@\n-    if (src->longWords ())\n+    if (src_long_words)\n@@ -2796,1 +2463,1 @@\n-      for (r = 0; r < ri_count; r++)\n+      for (r = 0; r < src_word_count; r++)\n@@ -2801,1 +2468,1 @@\n-          int32_t delta = src->get_item_delta (old, r);\n+          int32_t delta = src->get_item_delta_fast (old, r, src_delta_bytes, src_row_size);\n@@ -2815,0 +2482,2 @@\n+      bool short_circuit = src_long_words == has_long && src_word_count <= r;\n+\n@@ -2819,1 +2488,1 @@\n-        int32_t delta = src->get_item_delta (old, r);\n+        int32_t delta = src->get_item_delta_fast (old, r, src_delta_bytes, src_row_size);\n@@ -2827,0 +2496,1 @@\n+        {\n@@ -2828,0 +2498,3 @@\n+          if (short_circuit)\n+            break;\n+        }\n@@ -2837,1 +2510,2 @@\n-        ri_map[r] = (delta_sz[r] == kWord)? word_index++ : non_word_index++;\n+        unsigned new_r = (delta_sz[r] == kWord)? word_index++ : non_word_index++;\n+        ri_map[new_r] = r;\n@@ -2847,2 +2521,2 @@\n-    for (r = 0; r < ri_count; r++)\n-      if (delta_sz[r]) regionIndices[ri_map[r]] = region_map[src->regionIndices[r]];\n+    for (r = 0; r < new_ri_count; r++)\n+      regionIndices[r] = region_map[src->regionIndices[ri_map[r]]];\n@@ -2850,1 +2524,4 @@\n-    for (unsigned int i = 0; i < itemCount; i++)\n+    HBUINT8 *delta_bytes = get_delta_bytes ();\n+    unsigned row_size = get_row_size ();\n+    unsigned count = itemCount;\n+    for (unsigned int i = 0; i < count; i++)\n@@ -2852,3 +2529,6 @@\n-      unsigned int      old = inner_map.backward (i);\n-      for (unsigned int r = 0; r < ri_count; r++)\n-        if (delta_sz[r]) set_item_delta (i, ri_map[r], src->get_item_delta (old, r));\n+      unsigned int old = inner_map.backward (i);\n+      for (unsigned int r = 0; r < new_ri_count; r++)\n+        set_item_delta_fast (i, r,\n+                             src->get_item_delta_fast (old, ri_map[r],\n+                                                       src_delta_bytes, src_row_size),\n+                             delta_bytes, row_size);\n@@ -2862,0 +2542,3 @@\n+    const HBUINT8 *delta_bytes = get_delta_bytes ();\n+    unsigned row_size = get_row_size ();\n+\n@@ -2864,1 +2547,1 @@\n-      unsigned int region = regionIndices[r];\n+      unsigned int region = regionIndices.arrayZ[r];\n@@ -2867,1 +2550,1 @@\n-        if (get_item_delta (inner_map.backward (i), r) != 0)\n+        if (get_item_delta_fast (inner_map.backward (i), r, delta_bytes, row_size) != 0)\n@@ -2882,1 +2565,2 @@\n-  int32_t get_item_delta (unsigned int item, unsigned int region) const\n+  int32_t get_item_delta_fast (unsigned int item, unsigned int region,\n+                               const HBUINT8 *delta_bytes, unsigned row_size) const\n@@ -2884,2 +2568,3 @@\n-    if ( item >= itemCount || unlikely (region >= regionIndices.len)) return 0;\n-    const HBINT8 *p = (const HBINT8 *) get_delta_bytes () + item * get_row_size ();\n+    if (unlikely (item >= itemCount || region >= regionIndices.len)) return 0;\n+\n+    const HBINT8 *p = (const HBINT8 *) delta_bytes + item * row_size;\n@@ -2903,0 +2588,6 @@\n+  int32_t get_item_delta (unsigned int item, unsigned int region) const\n+  {\n+     return get_item_delta_fast (item, region,\n+                                 get_delta_bytes (),\n+                                 get_row_size ());\n+  }\n@@ -2904,1 +2595,2 @@\n-  void set_item_delta (unsigned int item, unsigned int region, int32_t delta)\n+  void set_item_delta_fast (unsigned int item, unsigned int region, int32_t delta,\n+                            HBUINT8 *delta_bytes, unsigned row_size)\n@@ -2906,1 +2598,1 @@\n-    HBINT8 *p = (HBINT8 *)get_delta_bytes () + item * get_row_size ();\n+    HBINT8 *p = (HBINT8 *) delta_bytes + item * row_size;\n@@ -2924,0 +2616,6 @@\n+  void set_item_delta (unsigned int item, unsigned int region, int32_t delta)\n+  {\n+    set_item_delta_fast (item, region, delta,\n+                         get_delta_bytes (),\n+                         get_row_size ());\n+  }\n@@ -2943,0 +2641,3 @@\n+#ifdef HB_NO_VAR\n+    return nullptr;\n+#endif\n@@ -2984,0 +2685,8 @@\n+  float get_delta (unsigned int index,\n+                   hb_array_t<int> coords,\n+                   VarRegionList::cache_t *cache = nullptr) const\n+  {\n+    return get_delta (index,\n+                      coords.arrayZ, coords.length,\n+                      cache);\n+  }\n@@ -3000,1 +2709,1 @@\n-                  const hb_array_t <hb_inc_bimap_t> &inner_maps)\n+                  const hb_array_t <const hb_inc_bimap_t> &inner_maps)\n@@ -3003,0 +2712,4 @@\n+#ifdef HB_NO_VAR\n+    return_trace (false);\n+#endif\n+\n@@ -3051,1 +2764,1 @@\n-  bool subset (hb_subset_context_t *c) const\n+  VariationStore *copy (hb_serialize_context_t *c) const\n@@ -3053,1 +2766,3 @@\n-    TRACE_SUBSET (this);\n+    TRACE_SERIALIZE (this);\n+    auto *out = c->start_embed (this);\n+    if (unlikely (!out)) return_trace (nullptr);\n@@ -3055,2 +2770,6 @@\n-    VariationStore *varstore_prime = c->serializer->start_embed<VariationStore> ();\n-    if (unlikely (!varstore_prime)) return_trace (false);\n+    hb_vector_t <hb_inc_bimap_t> inner_maps;\n+    unsigned count = dataSets.len;\n+    for (unsigned i = 0; i < count; i++)\n+    {\n+      hb_inc_bimap_t *map = inner_maps.push ();\n+      auto &data = this+dataSets[i];\n@@ -3058,2 +2777,4 @@\n-    const hb_set_t *variation_indices = c->plan->layout_variation_indices;\n-    if (variation_indices->is_empty ()) return_trace (false);\n+      unsigned itemCount = data.get_item_count ();\n+      for (unsigned j = 0; j < itemCount; j++)\n+        map->add (j);\n+    }\n@@ -3061,2 +2782,1 @@\n-    hb_vector_t<hb_inc_bimap_t> inner_maps;\n-    inner_maps.resize ((unsigned) dataSets.len);\n+    if (unlikely (!out->serialize (c, this, inner_maps))) return_trace (nullptr);\n@@ -3064,4 +2784,2 @@\n-    for (unsigned idx : c->plan->layout_variation_indices->iter ())\n-    {\n-      uint16_t major = idx >> 16;\n-      uint16_t minor = idx & 0xFFFF;\n+    return_trace (out);\n+  }\n@@ -3069,5 +2787,11 @@\n-      if (major >= inner_maps.length)\n-        return_trace (false);\n-      inner_maps[major].add (minor);\n-    }\n-    varstore_prime->serialize (c->serializer, this, inner_maps.as_array ());\n+  bool subset (hb_subset_context_t *c, const hb_array_t<const hb_inc_bimap_t> &inner_maps) const\n+  {\n+    TRACE_SUBSET (this);\n+#ifdef HB_NO_VAR\n+    return_trace (false);\n+#endif\n+\n+    VariationStore *varstore_prime = c->serializer->start_embed<VariationStore> ();\n+    if (unlikely (!varstore_prime)) return_trace (false);\n+\n+    varstore_prime->serialize (c->serializer, this, inner_maps);\n@@ -3081,1 +2805,6 @@\n-  { return (this+dataSets[major]).get_region_index_count (); }\n+  {\n+#ifdef HB_NO_VAR\n+    return 0;\n+#endif\n+    return (this+dataSets[major]).get_region_index_count ();\n+  }\n@@ -3099,1 +2828,7 @@\n-  unsigned int get_sub_table_count () const { return dataSets.len; }\n+  unsigned int get_sub_table_count () const\n+   {\n+#ifdef HB_NO_VAR\n+     return 0;\n+#endif\n+     return dataSets.len;\n+   }\n@@ -3114,0 +2849,7 @@\n+enum Cond_with_Var_flag_t\n+{\n+  KEEP_COND_WITH_VAR = 0,\n+  DROP_COND_WITH_VAR = 1,\n+  DROP_RECORD_WITH_VAR = 2,\n+  MEM_ERR_WITH_VAR = 3,\n+};\n@@ -3124,1 +2866,9 @@\n-    return_trace (true);\n+\n+    const hb_map_t *index_map = &c->plan->axes_index_map;\n+    if (index_map->is_empty ()) return_trace (true);\n+\n+    if (!index_map->has (axisIndex))\n+      return_trace (false);\n+\n+    return_trace (c->serializer->check_assign (out->axisIndex, index_map->get (axisIndex),\n+                                               HB_SERIALIZE_ERROR_INT_OVERFLOW));\n@@ -3128,0 +2878,34 @@\n+  Cond_with_Var_flag_t keep_with_variations (hb_collect_feature_substitutes_with_var_context_t *c,\n+                                             hb_map_t *condition_map \/* OUT *\/) const\n+  {\n+    \/\/invalid axis index, drop the entire record\n+    if (!c->axes_index_tag_map->has (axisIndex))\n+      return DROP_RECORD_WITH_VAR;\n+\n+    hb_tag_t axis_tag = c->axes_index_tag_map->get (axisIndex);\n+\n+    \/\/axis not pinned, keep the condition\n+    if (!c->axes_location->has (axis_tag))\n+    {\n+      \/\/ add axisIndex->value into the hashmap so we can check if the record is\n+      \/\/ unique with variations\n+      int16_t min_val = filterRangeMinValue.to_int ();\n+      int16_t max_val = filterRangeMaxValue.to_int ();\n+      hb_codepoint_t val = (max_val << 16) + min_val;\n+\n+      condition_map->set (axisIndex, val);\n+      return KEEP_COND_WITH_VAR;\n+    }\n+\n+    \/\/axis pinned, check if condition is met\n+    \/\/TODO: add check for axis Ranges\n+    int v = c->axes_location->get (axis_tag);\n+\n+    \/\/condition not met, drop the entire record\n+    if (v < filterRangeMinValue.to_int () || v > filterRangeMaxValue.to_int ())\n+      return DROP_RECORD_WITH_VAR;\n+\n+    \/\/axis pinned and condition met, drop the condition\n+    return DROP_COND_WITH_VAR;\n+  }\n+\n@@ -3131,1 +2915,1 @@\n-    return filterRangeMinValue <= coord && coord <= filterRangeMaxValue;\n+    return filterRangeMinValue.to_int () <= coord && coord <= filterRangeMaxValue.to_int ();\n@@ -3159,0 +2943,9 @@\n+  Cond_with_Var_flag_t keep_with_variations (hb_collect_feature_substitutes_with_var_context_t *c,\n+                                             hb_map_t *condition_map \/* OUT *\/) const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.keep_with_variations (c, condition_map);\n+    default:return KEEP_COND_WITH_VAR;\n+    }\n+  }\n+\n@@ -3162,0 +2955,1 @@\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n@@ -3163,1 +2957,0 @@\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n@@ -3200,1 +2993,43 @@\n-  bool subset (hb_subset_context_t *c) const\n+  Cond_with_Var_flag_t keep_with_variations (hb_collect_feature_substitutes_with_var_context_t *c) const\n+  {\n+    hb_map_t *condition_map = hb_map_create ();\n+    if (unlikely (!condition_map)) return MEM_ERR_WITH_VAR;\n+    hb::shared_ptr<hb_map_t> p {condition_map};\n+\n+    hb_set_t *cond_set = hb_set_create ();\n+    if (unlikely (!cond_set)) return MEM_ERR_WITH_VAR;\n+    hb::shared_ptr<hb_set_t> s {cond_set};\n+\n+    unsigned num_kept_cond = 0, cond_idx = 0;\n+    for (const auto& offset : conditions)\n+    {\n+      Cond_with_Var_flag_t ret = (this+offset).keep_with_variations (c, condition_map);\n+      \/\/ one condition is not met, drop the entire record\n+      if (ret == DROP_RECORD_WITH_VAR)\n+        return DROP_RECORD_WITH_VAR;\n+\n+      \/\/ axis not pinned, keep this condition\n+      if (ret == KEEP_COND_WITH_VAR)\n+      {\n+        cond_set->add (cond_idx);\n+        num_kept_cond++;\n+      }\n+      cond_idx++;\n+    }\n+\n+    \/\/ all conditions met\n+    if (num_kept_cond == 0) return DROP_COND_WITH_VAR;\n+\n+    \/\/check if condition_set is unique with variations\n+    if (c->conditionset_map->has (p))\n+      \/\/duplicate found, drop the entire record\n+      return DROP_RECORD_WITH_VAR;\n+\n+    c->conditionset_map->set (p, 1);\n+    c->record_cond_idx_map->set (c->cur_record_idx, s);\n+\n+    return KEEP_COND_WITH_VAR;\n+  }\n+\n+  bool subset (hb_subset_context_t *c,\n+               hb_subset_layout_context_t *l) const\n@@ -3206,3 +3041,11 @@\n-    + conditions.iter ()\n-    | hb_apply (subset_offset_array (c, out->conditions, this))\n-    ;\n+    hb_set_t *retained_cond_set = nullptr;\n+    if (l->feature_record_cond_idx_map != nullptr)\n+      retained_cond_set = l->feature_record_cond_idx_map->get (l->cur_feature_var_record_idx);\n+\n+    unsigned int count = conditions.len;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (retained_cond_set != nullptr && !retained_cond_set->has (i))\n+        continue;\n+      subset_offset_array (c, out->conditions, this) (conditions[i]);\n+    }\n@@ -3242,0 +3085,8 @@\n+  void collect_feature_substitutes_with_variations (hb_hashmap_t<unsigned, const Feature*> *feature_substitutes_map,\n+                                                    const hb_set_t *feature_indices,\n+                                                    const void *base) const\n+  {\n+    if (feature_indices->has (featureIndex))\n+      feature_substitutes_map->set (featureIndex, &(base+feature));\n+  }\n+\n@@ -3245,1 +3096,2 @@\n-    if (!c->feature_index_map->has (featureIndex)) {\n+    if (!c->feature_index_map->has (featureIndex) ||\n+        c->feature_substitutes_map->has (featureIndex)) {\n@@ -3287,0 +3139,1 @@\n+                        const hb_hashmap_t<unsigned, const Feature*> *feature_substitutes_map,\n@@ -3291,0 +3144,5 @@\n+    | hb_filter ([feature_substitutes_map] (const FeatureTableSubstitutionRecord& record)\n+                 {\n+                   if (feature_substitutes_map == nullptr) return true;\n+                   return !feature_substitutes_map->has (record.featureIndex);\n+                 })\n@@ -3312,0 +3170,6 @@\n+  void collect_feature_substitutes_with_variations (hb_collect_feature_substitutes_with_var_context_t *c) const\n+  {\n+    for (const FeatureTableSubstitutionRecord& record : substitutions)\n+      record.collect_feature_substitutes_with_variations (c->feature_substitutes_map, c->feature_indices, this);\n+  }\n+\n@@ -3351,0 +3215,1 @@\n+                        const hb_hashmap_t<unsigned, const Feature*> *feature_substitutes_map,\n@@ -3353,1 +3218,1 @@\n-    return (base+substitutions).collect_lookups (feature_indexes, lookup_indexes);\n+    return (base+substitutions).collect_lookups (feature_indexes, feature_substitutes_map, lookup_indexes);\n@@ -3368,0 +3233,12 @@\n+  void collect_feature_substitutes_with_variations (hb_collect_feature_substitutes_with_var_context_t *c,\n+                                                    const void *base) const\n+  {\n+    \/\/ ret == 1, all conditions met\n+    if ((base+conditions).keep_with_variations (c) == DROP_COND_WITH_VAR &&\n+        c->apply)\n+    {\n+      (base+substitutions).collect_feature_substitutes_with_variations (c);\n+      c->apply = false; \/\/ set variations only once\n+    }\n+  }\n+\n@@ -3374,1 +3251,1 @@\n-    out->conditions.serialize_subset (c->subset_context, conditions, base);\n+    out->conditions.serialize_subset (c->subset_context, conditions, base, c);\n@@ -3424,0 +3301,10 @@\n+  void collect_feature_substitutes_with_variations (hb_collect_feature_substitutes_with_var_context_t *c) const\n+  {\n+    unsigned int count = varRecords.len;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      c->cur_record_idx = i;\n+      varRecords[i].collect_feature_substitutes_with_variations (c, this);\n+    }\n+  }\n+\n@@ -3431,0 +3318,1 @@\n+                        const hb_hashmap_t<unsigned, const Feature*> *feature_substitutes_map,\n@@ -3434,1 +3322,1 @@\n-      r.collect_lookups (this, feature_indexes, lookup_indexes);\n+      r.collect_lookups (this, feature_indexes, feature_substitutes_map, lookup_indexes);\n@@ -3438,0 +3326,1 @@\n+                         const hb_hashmap_t<unsigned, hb::shared_ptr<hb_set_t>> *feature_record_cond_idx_map,\n@@ -3440,2 +3329,8 @@\n-    for (const FeatureVariationRecord& record : varRecords)\n-      record.closure_features (this, lookup_indexes, feature_indexes);\n+    unsigned int count = varRecords.len;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (feature_record_cond_idx_map != nullptr &&\n+          !feature_record_cond_idx_map->has (i))\n+        continue;\n+      varRecords[i].closure_features (this, lookup_indexes, feature_indexes);\n+    }\n@@ -3463,1 +3358,7 @@\n-    for (unsigned i = 0; i < count; i++) {\n+    for (unsigned i = 0; i < count; i++)\n+    {\n+      if (l->feature_record_cond_idx_map != nullptr &&\n+          !l->feature_record_cond_idx_map->has (i))\n+        continue;\n+\n+      l->cur_feature_var_record_idx = i;\n@@ -3588,1 +3489,2 @@\n-  VariationDevice* copy (hb_serialize_context_t *c, const hb_map_t *layout_variation_idx_map) const\n+  VariationDevice* copy (hb_serialize_context_t *c,\n+                         const hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> *layout_variation_idx_delta_map) const\n@@ -3591,1 +3493,7 @@\n-    auto snap = c->snapshot ();\n+    if (!layout_variation_idx_delta_map) return_trace (nullptr);\n+\n+    hb_pair_t<unsigned, int> *v;\n+    if (!layout_variation_idx_delta_map->has (varIdx, &v))\n+      return_trace (nullptr);\n+\n+    c->start_zerocopy (this->static_size);\n@@ -3594,1 +3502,0 @@\n-    if (!layout_variation_idx_map || layout_variation_idx_map->is_empty ()) return_trace (out);\n@@ -3596,7 +3503,1 @@\n-    \/* TODO Just get() and bail if NO_VARIATION. Needs to setup the map to return that. *\/\n-    if (!layout_variation_idx_map->has (varIdx))\n-    {\n-      c->revert (snap);\n-      return_trace (nullptr);\n-    }\n-    unsigned new_idx = layout_variation_idx_map->get (varIdx);\n+    unsigned new_idx = hb_first (*v);\n@@ -3607,1 +3508,1 @@\n-  void record_variation_index (hb_set_t *layout_variation_indices) const\n+  void collect_variation_index (hb_collect_variation_indices_context_t *c) const\n@@ -3609,1 +3510,8 @@\n-    layout_variation_indices->add (varIdx);\n+    c->layout_variation_indices->add (varIdx);\n+    int delta = 0;\n+    if (c->font && c->var_store)\n+      delta = roundf (get_delta (c->font, *c->var_store, c->store_cache));\n+\n+    \/* set new varidx to HB_OT_LAYOUT_NO_VARIATIONS_INDEX here, will remap\n+     * varidx later*\/\n+    c->varidx_delta_map->set (varIdx, hb_pair_t<unsigned, int> (HB_OT_LAYOUT_NO_VARIATIONS_INDEX, delta));\n@@ -3702,1 +3610,2 @@\n-  Device* copy (hb_serialize_context_t *c, const hb_map_t *layout_variation_idx_map=nullptr) const\n+  Device* copy (hb_serialize_context_t *c,\n+                const hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> *layout_variation_idx_delta_map=nullptr) const\n@@ -3714,1 +3623,1 @@\n-      return_trace (reinterpret_cast<Device *> (u.variation.copy (c, layout_variation_idx_map)));\n+      return_trace (reinterpret_cast<Device *> (u.variation.copy (c, layout_variation_idx_delta_map)));\n@@ -3721,1 +3630,1 @@\n-  void collect_variation_indices (hb_set_t *layout_variation_indices) const\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n@@ -3732,1 +3641,1 @@\n-      u.variation.record_variation_index (layout_variation_indices);\n+      u.variation.collect_variation_index (c);\n@@ -3740,0 +3649,12 @@\n+  unsigned get_variation_index () const\n+  {\n+    switch (u.b.format) {\n+#ifndef HB_NO_VAR\n+    case 0x8000:\n+      return u.variation.varIdx;\n+#endif\n+    default:\n+      return HB_OT_LAYOUT_NO_VARIATIONS_INDEX;\n+    }\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-common.hh","additions":1109,"deletions":1188,"binary":false,"changes":2297,"status":"modified"},{"patch":"@@ -32,691 +32,1 @@\n-#include \"hb-ot-layout-common.hh\"\n-\n-#include \"hb-font.hh\"\n-\n-\n-namespace OT {\n-\n-\n-\/*\n- * Attachment List Table\n- *\/\n-\n-\/* Array of contour point indices--in increasing numerical order *\/\n-struct AttachPoint : Array16Of<HBUINT16>\n-{\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->serialize (c->serializer, + iter ()));\n-  }\n-};\n-\n-struct AttachList\n-{\n-  unsigned int get_attach_points (hb_codepoint_t glyph_id,\n-                                  unsigned int start_offset,\n-                                  unsigned int *point_count \/* IN\/OUT *\/,\n-                                  unsigned int *point_array \/* OUT *\/) const\n-  {\n-    unsigned int index = (this+coverage).get_coverage (glyph_id);\n-    if (index == NOT_COVERED)\n-    {\n-      if (point_count)\n-        *point_count = 0;\n-      return 0;\n-    }\n-\n-    const AttachPoint &points = this+attachPoint[index];\n-\n-    if (point_count)\n-    {\n-      + points.sub_array (start_offset, point_count)\n-      | hb_sink (hb_array (point_array, *point_count))\n-      ;\n-    }\n-\n-    return points.len;\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-\n-    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n-    + hb_zip (this+coverage, attachPoint)\n-    | hb_filter (glyphset, hb_first)\n-    | hb_filter (subset_offset_array (c, out->attachPoint, this), hb_second)\n-    | hb_map (hb_first)\n-    | hb_map (glyph_map)\n-    | hb_sink (new_coverage)\n-    ;\n-    out->coverage.serialize_serialize (c->serializer, new_coverage.iter ());\n-    return_trace (bool (new_coverage));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (coverage.sanitize (c, this) && attachPoint.sanitize (c, this));\n-  }\n-\n-  protected:\n-  Offset16To<Coverage>\n-                coverage;               \/* Offset to Coverage table -- from\n-                                         * beginning of AttachList table *\/\n-  Array16OfOffset16To<AttachPoint>\n-                attachPoint;            \/* Array of AttachPoint tables\n-                                         * in Coverage Index order *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (4, attachPoint);\n-};\n-\n-\/*\n- * Ligature Caret Table\n- *\/\n-\n-struct CaretValueFormat1\n-{\n-  friend struct CaretValue;\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-    return_trace (true);\n-  }\n-\n-  private:\n-  hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction) const\n-  {\n-    return HB_DIRECTION_IS_HORIZONTAL (direction) ? font->em_scale_x (coordinate) : font->em_scale_y (coordinate);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  protected:\n-  HBUINT16      caretValueFormat;       \/* Format identifier--format = 1 *\/\n-  FWORD         coordinate;             \/* X or Y value, in design units *\/\n-  public:\n-  DEFINE_SIZE_STATIC (4);\n-};\n-\n-struct CaretValueFormat2\n-{\n-  friend struct CaretValue;\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-    return_trace (true);\n-  }\n-\n-  private:\n-  hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, hb_codepoint_t glyph_id) const\n-  {\n-    hb_position_t x, y;\n-    font->get_glyph_contour_point_for_origin (glyph_id, caretValuePoint, direction, &x, &y);\n-    return HB_DIRECTION_IS_HORIZONTAL (direction) ? x : y;\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  protected:\n-  HBUINT16      caretValueFormat;       \/* Format identifier--format = 2 *\/\n-  HBUINT16      caretValuePoint;        \/* Contour point index on glyph *\/\n-  public:\n-  DEFINE_SIZE_STATIC (4);\n-};\n-\n-struct CaretValueFormat3\n-{\n-  friend struct CaretValue;\n-\n-  hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction,\n-                                 const VariationStore &var_store) const\n-  {\n-    return HB_DIRECTION_IS_HORIZONTAL (direction) ?\n-           font->em_scale_x (coordinate) + (this+deviceTable).get_x_delta (font, var_store) :\n-           font->em_scale_y (coordinate) + (this+deviceTable).get_y_delta (font, var_store);\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    return_trace (out->deviceTable.serialize_copy (c->serializer, deviceTable, this, c->serializer->to_bias (out),\n-                                                   hb_serialize_context_t::Head, c->plan->layout_variation_idx_map));\n-  }\n-\n-  void collect_variation_indices (hb_set_t *layout_variation_indices) const\n-  { (this+deviceTable).collect_variation_indices (layout_variation_indices); }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && deviceTable.sanitize (c, this));\n-  }\n-\n-  protected:\n-  HBUINT16      caretValueFormat;       \/* Format identifier--format = 3 *\/\n-  FWORD         coordinate;             \/* X or Y value, in design units *\/\n-  Offset16To<Device>\n-                deviceTable;            \/* Offset to Device table for X or Y\n-                                         * value--from beginning of CaretValue\n-                                         * table *\/\n-  public:\n-  DEFINE_SIZE_STATIC (6);\n-};\n-\n-struct CaretValue\n-{\n-  hb_position_t get_caret_value (hb_font_t *font,\n-                                 hb_direction_t direction,\n-                                 hb_codepoint_t glyph_id,\n-                                 const VariationStore &var_store) const\n-  {\n-    switch (u.format) {\n-    case 1: return u.format1.get_caret_value (font, direction);\n-    case 2: return u.format2.get_caret_value (font, direction, glyph_id);\n-    case 3: return u.format3.get_caret_value (font, direction, var_store);\n-    default:return 0;\n-    }\n-  }\n-\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, u.format);\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n-    switch (u.format) {\n-    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n-    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n-    case 3: return_trace (c->dispatch (u.format3, std::forward<Ts> (ds)...));\n-    default:return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  void collect_variation_indices (hb_set_t *layout_variation_indices) const\n-  {\n-    switch (u.format) {\n-    case 1:\n-    case 2:\n-      return;\n-    case 3:\n-      u.format3.collect_variation_indices (layout_variation_indices);\n-      return;\n-    default: return;\n-    }\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    if (!u.format.sanitize (c)) return_trace (false);\n-    switch (u.format) {\n-    case 1: return_trace (u.format1.sanitize (c));\n-    case 2: return_trace (u.format2.sanitize (c));\n-    case 3: return_trace (u.format3.sanitize (c));\n-    default:return_trace (true);\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT16              format;         \/* Format identifier *\/\n-  CaretValueFormat1     format1;\n-  CaretValueFormat2     format2;\n-  CaretValueFormat3     format3;\n-  } u;\n-  public:\n-  DEFINE_SIZE_UNION (2, format);\n-};\n-\n-struct LigGlyph\n-{\n-  unsigned get_lig_carets (hb_font_t            *font,\n-                           hb_direction_t        direction,\n-                           hb_codepoint_t        glyph_id,\n-                           const VariationStore &var_store,\n-                           unsigned              start_offset,\n-                           unsigned             *caret_count \/* IN\/OUT *\/,\n-                           hb_position_t        *caret_array \/* OUT *\/) const\n-  {\n-    if (caret_count)\n-    {\n-      + carets.sub_array (start_offset, caret_count)\n-      | hb_map (hb_add (this))\n-      | hb_map ([&] (const CaretValue &value) { return value.get_caret_value (font, direction, glyph_id, var_store); })\n-      | hb_sink (hb_array (caret_array, *caret_count))\n-      ;\n-    }\n-\n-    return carets.len;\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-\n-    + hb_iter (carets)\n-    | hb_apply (subset_offset_array (c, out->carets, this))\n-    ;\n-\n-    return_trace (bool (out->carets));\n-  }\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n-  {\n-    for (const Offset16To<CaretValue>& offset : carets.iter ())\n-      (this+offset).collect_variation_indices (c->layout_variation_indices);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (carets.sanitize (c, this));\n-  }\n-\n-  protected:\n-  Array16OfOffset16To<CaretValue>\n-                carets;                 \/* Offset array of CaretValue tables\n-                                         * --from beginning of LigGlyph table\n-                                         * --in increasing coordinate order *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (2, carets);\n-};\n-\n-struct LigCaretList\n-{\n-  unsigned int get_lig_carets (hb_font_t *font,\n-                               hb_direction_t direction,\n-                               hb_codepoint_t glyph_id,\n-                               const VariationStore &var_store,\n-                               unsigned int start_offset,\n-                               unsigned int *caret_count \/* IN\/OUT *\/,\n-                               hb_position_t *caret_array \/* OUT *\/) const\n-  {\n-    unsigned int index = (this+coverage).get_coverage (glyph_id);\n-    if (index == NOT_COVERED)\n-    {\n-      if (caret_count)\n-        *caret_count = 0;\n-      return 0;\n-    }\n-    const LigGlyph &lig_glyph = this+ligGlyph[index];\n-    return lig_glyph.get_lig_carets (font, direction, glyph_id, var_store, start_offset, caret_count, caret_array);\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-\n-    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n-    + hb_zip (this+coverage, ligGlyph)\n-    | hb_filter (glyphset, hb_first)\n-    | hb_filter (subset_offset_array (c, out->ligGlyph, this), hb_second)\n-    | hb_map (hb_first)\n-    | hb_map (glyph_map)\n-    | hb_sink (new_coverage)\n-    ;\n-    out->coverage.serialize_serialize (c->serializer, new_coverage.iter ());\n-    return_trace (bool (new_coverage));\n-  }\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n-  {\n-    + hb_zip (this+coverage, ligGlyph)\n-    | hb_filter (c->glyph_set, hb_first)\n-    | hb_map (hb_second)\n-    | hb_map (hb_add (this))\n-    | hb_apply ([c] (const LigGlyph& _) { _.collect_variation_indices (c); })\n-    ;\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (coverage.sanitize (c, this) && ligGlyph.sanitize (c, this));\n-  }\n-\n-  protected:\n-  Offset16To<Coverage>\n-                coverage;               \/* Offset to Coverage table--from\n-                                         * beginning of LigCaretList table *\/\n-  Array16OfOffset16To<LigGlyph>\n-                ligGlyph;               \/* Array of LigGlyph tables\n-                                         * in Coverage Index order *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (4, ligGlyph);\n-};\n-\n-\n-struct MarkGlyphSetsFormat1\n-{\n-  bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const\n-  { return (this+coverage[set_index]).get_coverage (glyph_id) != NOT_COVERED; }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-    out->format = format;\n-\n-    bool ret = true;\n-    for (const Offset32To<Coverage>& offset : coverage.iter ())\n-    {\n-      auto *o = out->coverage.serialize_append (c->serializer);\n-      if (unlikely (!o))\n-      {\n-        ret = false;\n-        break;\n-      }\n-\n-      \/\/not using o->serialize_subset (c, offset, this, out) here because\n-      \/\/OTS doesn't allow null offset.\n-      \/\/See issue: https:\/\/github.com\/khaledhosny\/ots\/issues\/172\n-      c->serializer->push ();\n-      c->dispatch (this+offset);\n-      c->serializer->add_link (*o, c->serializer->pop_pack ());\n-    }\n-\n-    return_trace (ret && out->coverage.len);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (coverage.sanitize (c, this));\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n-  Array16Of<Offset32To<Coverage>>\n-                coverage;               \/* Array of long offsets to mark set\n-                                         * coverage tables *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (4, coverage);\n-};\n-\n-struct MarkGlyphSets\n-{\n-  bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const\n-  {\n-    switch (u.format) {\n-    case 1: return u.format1.covers (set_index, glyph_id);\n-    default:return false;\n-    }\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    switch (u.format) {\n-    case 1: return_trace (u.format1.subset (c));\n-    default:return_trace (false);\n-    }\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    if (!u.format.sanitize (c)) return_trace (false);\n-    switch (u.format) {\n-    case 1: return_trace (u.format1.sanitize (c));\n-    default:return_trace (true);\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT16              format;         \/* Format identifier *\/\n-  MarkGlyphSetsFormat1  format1;\n-  } u;\n-  public:\n-  DEFINE_SIZE_UNION (2, format);\n-};\n-\n-\n-\/*\n- * GDEF -- Glyph Definition\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/gdef\n- *\/\n-\n-\n-struct GDEF\n-{\n-  static constexpr hb_tag_t tableTag = HB_OT_TAG_GDEF;\n-\n-  enum GlyphClasses {\n-    UnclassifiedGlyph   = 0,\n-    BaseGlyph           = 1,\n-    LigatureGlyph       = 2,\n-    MarkGlyph           = 3,\n-    ComponentGlyph      = 4\n-  };\n-\n-  bool has_data () const { return version.to_int (); }\n-  bool has_glyph_classes () const { return glyphClassDef != 0; }\n-  unsigned int get_glyph_class (hb_codepoint_t glyph) const\n-  { return (this+glyphClassDef).get_class (glyph); }\n-  void get_glyphs_in_class (unsigned int klass, hb_set_t *glyphs) const\n-  { (this+glyphClassDef).collect_class (glyphs, klass); }\n-\n-  bool has_mark_attachment_types () const { return markAttachClassDef != 0; }\n-  unsigned int get_mark_attachment_type (hb_codepoint_t glyph) const\n-  { return (this+markAttachClassDef).get_class (glyph); }\n-\n-  bool has_attach_points () const { return attachList != 0; }\n-  unsigned int get_attach_points (hb_codepoint_t glyph_id,\n-                                  unsigned int start_offset,\n-                                  unsigned int *point_count \/* IN\/OUT *\/,\n-                                  unsigned int *point_array \/* OUT *\/) const\n-  { return (this+attachList).get_attach_points (glyph_id, start_offset, point_count, point_array); }\n-\n-  bool has_lig_carets () const { return ligCaretList != 0; }\n-  unsigned int get_lig_carets (hb_font_t *font,\n-                               hb_direction_t direction,\n-                               hb_codepoint_t glyph_id,\n-                               unsigned int start_offset,\n-                               unsigned int *caret_count \/* IN\/OUT *\/,\n-                               hb_position_t *caret_array \/* OUT *\/) const\n-  { return (this+ligCaretList).get_lig_carets (font,\n-                                               direction, glyph_id, get_var_store(),\n-                                               start_offset, caret_count, caret_array); }\n-\n-  bool has_mark_sets () const { return version.to_int () >= 0x00010002u && markGlyphSetsDef != 0; }\n-  bool mark_set_covers (unsigned int set_index, hb_codepoint_t glyph_id) const\n-  { return version.to_int () >= 0x00010002u && (this+markGlyphSetsDef).covers (set_index, glyph_id); }\n-\n-  bool has_var_store () const { return version.to_int () >= 0x00010003u && varStore != 0; }\n-  const VariationStore &get_var_store () const\n-  { return version.to_int () >= 0x00010003u ? this+varStore : Null (VariationStore); }\n-\n-  \/* glyph_props is a 16-bit integer where the lower 8-bit have bits representing\n-   * glyph class and other bits, and high 8-bit the mark attachment type (if any).\n-   * Not to be confused with lookup_props which is very similar. *\/\n-  unsigned int get_glyph_props (hb_codepoint_t glyph) const\n-  {\n-    unsigned int klass = get_glyph_class (glyph);\n-\n-    static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH == (unsigned int) LookupFlag::IgnoreBaseGlyphs), \"\");\n-    static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE == (unsigned int) LookupFlag::IgnoreLigatures), \"\");\n-    static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_MARK == (unsigned int) LookupFlag::IgnoreMarks), \"\");\n-\n-    switch (klass) {\n-    default:                    return HB_OT_LAYOUT_GLYPH_CLASS_UNCLASSIFIED;\n-    case BaseGlyph:             return HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH;\n-    case LigatureGlyph:         return HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE;\n-    case MarkGlyph:\n-          klass = get_mark_attachment_type (glyph);\n-          return HB_OT_LAYOUT_GLYPH_PROPS_MARK | (klass << 8);\n-    }\n-  }\n-\n-  HB_INTERNAL bool is_blocklisted (hb_blob_t *blob,\n-                                   hb_face_t *face) const;\n-\n-  struct accelerator_t\n-  {\n-    accelerator_t (hb_face_t *face)\n-    {\n-      table = hb_sanitize_context_t ().reference_table<GDEF> (face);\n-      if (unlikely (table->is_blocklisted (table.get_blob (), face)))\n-      {\n-        hb_blob_destroy (table.get_blob ());\n-        table = hb_blob_get_empty ();\n-      }\n-    }\n-    ~accelerator_t () { table.destroy (); }\n-\n-    hb_blob_ptr_t<GDEF> table;\n-  };\n-\n-  unsigned int get_size () const\n-  {\n-    return min_size +\n-           (version.to_int () >= 0x00010002u ? markGlyphSetsDef.static_size : 0) +\n-           (version.to_int () >= 0x00010003u ? varStore.static_size : 0);\n-  }\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n-  { (this+ligCaretList).collect_variation_indices (c); }\n-\n-  void remap_layout_variation_indices (const hb_set_t *layout_variation_indices,\n-                                       hb_map_t *layout_variation_idx_map \/* OUT *\/) const\n-  {\n-    if (version.to_int () < 0x00010003u || !varStore) return;\n-    if (layout_variation_indices->is_empty ()) return;\n-\n-    unsigned new_major = 0, new_minor = 0;\n-    unsigned last_major = (layout_variation_indices->get_min ()) >> 16;\n-    for (unsigned idx : layout_variation_indices->iter ())\n-    {\n-      uint16_t major = idx >> 16;\n-      if (major >= (this+varStore).get_sub_table_count ()) break;\n-      if (major != last_major)\n-      {\n-        new_minor = 0;\n-        ++new_major;\n-      }\n-\n-      unsigned new_idx = (new_major << 16) + new_minor;\n-      layout_variation_idx_map->set (idx, new_idx);\n-      ++new_minor;\n-      last_major = major;\n-    }\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->embed (*this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    bool subset_glyphclassdef = out->glyphClassDef.serialize_subset (c, glyphClassDef, this, nullptr, false, true);\n-    bool subset_attachlist = out->attachList.serialize_subset (c, attachList, this);\n-    bool subset_ligcaretlist = out->ligCaretList.serialize_subset (c, ligCaretList, this);\n-    bool subset_markattachclassdef = out->markAttachClassDef.serialize_subset (c, markAttachClassDef, this, nullptr, false, true);\n-\n-    bool subset_markglyphsetsdef = true;\n-    if (version.to_int () >= 0x00010002u)\n-    {\n-      subset_markglyphsetsdef = out->markGlyphSetsDef.serialize_subset (c, markGlyphSetsDef, this);\n-      if (!subset_markglyphsetsdef &&\n-          version.to_int () == 0x00010002u)\n-        out->version.minor = 0;\n-    }\n-\n-    bool subset_varstore = true;\n-    if (version.to_int () >= 0x00010003u)\n-    {\n-      subset_varstore = out->varStore.serialize_subset (c, varStore, this);\n-      if (!subset_varstore && version.to_int () == 0x00010003u)\n-        out->version.minor = 2;\n-    }\n-\n-    return_trace (subset_glyphclassdef || subset_attachlist ||\n-                  subset_ligcaretlist || subset_markattachclassdef ||\n-                  (out->version.to_int () >= 0x00010002u && subset_markglyphsetsdef) ||\n-                  (out->version.to_int () >= 0x00010003u && subset_varstore));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (version.sanitize (c) &&\n-                  likely (version.major == 1) &&\n-                  glyphClassDef.sanitize (c, this) &&\n-                  attachList.sanitize (c, this) &&\n-                  ligCaretList.sanitize (c, this) &&\n-                  markAttachClassDef.sanitize (c, this) &&\n-                  (version.to_int () < 0x00010002u || markGlyphSetsDef.sanitize (c, this)) &&\n-                  (version.to_int () < 0x00010003u || varStore.sanitize (c, this)));\n-  }\n-\n-  protected:\n-  FixedVersion<>version;                \/* Version of the GDEF table--currently\n-                                         * 0x00010003u *\/\n-  Offset16To<ClassDef>\n-                glyphClassDef;          \/* Offset to class definition table\n-                                         * for glyph type--from beginning of\n-                                         * GDEF header (may be Null) *\/\n-  Offset16To<AttachList>\n-                attachList;             \/* Offset to list of glyphs with\n-                                         * attachment points--from beginning\n-                                         * of GDEF header (may be Null) *\/\n-  Offset16To<LigCaretList>\n-                ligCaretList;           \/* Offset to list of positioning points\n-                                         * for ligature carets--from beginning\n-                                         * of GDEF header (may be Null) *\/\n-  Offset16To<ClassDef>\n-                markAttachClassDef;     \/* Offset to class definition table for\n-                                         * mark attachment type--from beginning\n-                                         * of GDEF header (may be Null) *\/\n-  Offset16To<MarkGlyphSets>\n-                markGlyphSetsDef;       \/* Offset to the table of mark set\n-                                         * definitions--from beginning of GDEF\n-                                         * header (may be NULL).  Introduced\n-                                         * in version 0x00010002. *\/\n-  Offset32To<VariationStore>\n-                varStore;               \/* Offset to the table of Item Variation\n-                                         * Store--from beginning of GDEF\n-                                         * header (may be NULL).  Introduced\n-                                         * in version 0x00010003. *\/\n-  public:\n-  DEFINE_SIZE_MIN (12);\n-};\n-\n-struct GDEF_accelerator_t : GDEF::accelerator_t {\n-  GDEF_accelerator_t (hb_face_t *face) : GDEF::accelerator_t (face) {}\n-};\n-\n-} \/* namespace OT *\/\n-\n+#include \"OT\/Layout\/GDEF\/GDEF.hh\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-gdef-table.hh","additions":1,"deletions":691,"binary":false,"changes":692,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"OT\/Layout\/GPOS.hh\"\n+#include \"OT\/Layout\/GPOS\/GPOS.hh\"\n@@ -35,2 +35,2 @@\n-\n-using Layout::GPOS_impl::PosLookup;\n+namespace Layout {\n+namespace GPOS_impl {\n@@ -59,1 +59,2 @@\n-  const PosLookup &l = c->face->table.GPOS.get_relaxed ()->table->get_lookup (lookup_index);\n+  auto *gpos = c->face->table.GPOS.get_relaxed ();\n+  const PosLookup &l = gpos->table->get_lookup (lookup_index);\n@@ -64,1 +65,5 @@\n-  bool ret = l.dispatch (c);\n+\n+  bool ret = false;\n+  auto *accel = gpos->get_accel (lookup_index);\n+  ret = accel && accel->apply (c, l.get_subtable_count (), false);\n+\n@@ -71,0 +76,2 @@\n+} \/* namespace GPOS_impl *\/\n+} \/* namespace Layout *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-gpos-table.hh","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -35,3 +35,2 @@\n-\n-using Layout::GSUB::SubstLookup;\n-using Layout::GSUB::ExtensionSubst;\n+namespace Layout {\n+namespace GSUB_impl {\n@@ -73,1 +72,2 @@\n-  const SubstLookup &l = c->face->table.GSUB.get_relaxed ()->table->get_lookup (lookup_index);\n+  auto *gsub = c->face->table.GSUB.get_relaxed ();\n+  const SubstLookup &l = gsub->table->get_lookup (lookup_index);\n@@ -78,1 +78,5 @@\n-  bool ret = l.dispatch (c);\n+\n+  bool ret = false;\n+  auto *accel = gsub->get_accel (lookup_index);\n+  ret = accel && accel->apply (c, l.get_subtable_count (), false);\n+\n@@ -85,1 +89,2 @@\n-\n+} \/* namespace GSUB_impl *\/\n+} \/* namespace Layout *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-gsub-table.hh","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -103,2 +103,2 @@\n-    if (done_lookups_glyph_count->in_error () ||\n-        done_lookups_glyph_set->in_error ())\n+    if (unlikely (done_lookups_glyph_count->in_error () ||\n+                  done_lookups_glyph_set->in_error ()))\n@@ -118,1 +118,1 @@\n-      hb_set_clear (done_lookups_glyph_set->get (lookup_index));\n+      done_lookups_glyph_set->get (lookup_index)->clear ();\n@@ -153,1 +153,1 @@\n-    if (active_glyphs_stack.length < 1)\n+    if (!active_glyphs_stack)\n@@ -412,1 +412,1 @@\n-    typedef bool (*match_func_t) (hb_glyph_info_t &info, const HBUINT16 &value, const void *data);\n+    typedef bool (*match_func_t) (hb_glyph_info_t &info, unsigned value, const void *data);\n@@ -431,1 +431,1 @@\n-                           const HBUINT16        *glyph_data) const\n+                           hb_codepoint_t glyph_data) const\n@@ -438,1 +438,1 @@\n-        return match_func (info, *glyph_data, match_data) ? MATCH_YES : MATCH_NO;\n+        return match_func (info, glyph_data, match_data) ? MATCH_YES : MATCH_NO;\n@@ -479,1 +479,4 @@\n-      match_glyph_data = nullptr;\n+      match_glyph_data16 = nullptr;\n+#ifndef HB_NO_BEYOND_64K\n+      match_glyph_data24 = nullptr;\n+#endif\n@@ -494,2 +497,1 @@\n-                         const void *match_data_,\n-                         const HBUINT16 glyph_data[])\n+                         const void *match_data_)\n@@ -498,1 +500,0 @@\n-      match_glyph_data = glyph_data;\n@@ -500,0 +501,14 @@\n+    void set_glyph_data (const HBUINT16 glyph_data[])\n+    {\n+      match_glyph_data16 = glyph_data;\n+#ifndef HB_NO_BEYOND_64K\n+      match_glyph_data24 = nullptr;\n+#endif\n+    }\n+#ifndef HB_NO_BEYOND_64K\n+    void set_glyph_data (const HBUINT24 glyph_data[])\n+    {\n+      match_glyph_data16 = nullptr;\n+      match_glyph_data24 = glyph_data;\n+    }\n+#endif\n@@ -513,1 +528,1 @@\n-      if (match_glyph_data) match_glyph_data--;\n+      backup_glyph_data ();\n@@ -520,0 +535,24 @@\n+    enum match_t {\n+      MATCH,\n+      NOT_MATCH,\n+      SKIP\n+    };\n+\n+    match_t match (hb_glyph_info_t &info)\n+    {\n+      matcher_t::may_skip_t skip = matcher.may_skip (c, info);\n+      if (unlikely (skip == matcher_t::SKIP_YES))\n+        return SKIP;\n+\n+      matcher_t::may_match_t match = matcher.may_match (info, get_glyph_data ());\n+      if (match == matcher_t::MATCH_YES ||\n+          (match == matcher_t::MATCH_MAYBE &&\n+           skip == matcher_t::SKIP_NO))\n+        return MATCH;\n+\n+      if (skip == matcher_t::SKIP_NO)\n+        return NOT_MATCH;\n+\n+      return SKIP;\n+  }\n+\n@@ -523,1 +562,6 @@\n-      while (idx + num_items < end)\n+      \/* The alternate condition below is faster at string boundaries,\n+       * but produces subpar \"unsafe-to-concat\" values. *\/\n+      signed stop = (signed) end - (signed) num_items;\n+      if (c->buffer->flags & HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT)\n+        stop = (signed) end - 1;\n+      while ((signed) idx < stop)\n@@ -526,17 +570,1 @@\n-        hb_glyph_info_t &info = c->buffer->info[idx];\n-\n-        matcher_t::may_skip_t skip = matcher.may_skip (c, info);\n-        if (unlikely (skip == matcher_t::SKIP_YES))\n-          continue;\n-\n-        matcher_t::may_match_t match = matcher.may_match (info, match_glyph_data);\n-        if (match == matcher_t::MATCH_YES ||\n-            (match == matcher_t::MATCH_MAYBE &&\n-             skip == matcher_t::SKIP_NO))\n-        {\n-          num_items--;\n-          if (match_glyph_data) match_glyph_data++;\n-          return true;\n-        }\n-\n-        if (skip == matcher_t::SKIP_NO)\n+        switch (match (c->buffer->info[idx]))\n@@ -544,3 +572,14 @@\n-          if (unsafe_to)\n-            *unsafe_to = idx + 1;\n-          return false;\n+          case MATCH:\n+          {\n+            num_items--;\n+            advance_glyph_data ();\n+            return true;\n+          }\n+          case NOT_MATCH:\n+          {\n+            if (unsafe_to)\n+              *unsafe_to = idx + 1;\n+            return false;\n+          }\n+          case SKIP:\n+            continue;\n@@ -556,1 +595,6 @@\n-      while (idx > num_items - 1)\n+      \/* The alternate condition below is faster at string boundaries,\n+       * but produces subpar \"unsafe-to-concat\" values. *\/\n+      unsigned stop = num_items - 1;\n+      if (c->buffer->flags & HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT)\n+        stop = 1 - 1;\n+      while (idx > stop)\n@@ -559,10 +603,1 @@\n-        hb_glyph_info_t &info = c->buffer->out_info[idx];\n-\n-        matcher_t::may_skip_t skip = matcher.may_skip (c, info);\n-        if (unlikely (skip == matcher_t::SKIP_YES))\n-          continue;\n-\n-        matcher_t::may_match_t match = matcher.may_match (info, match_glyph_data);\n-        if (match == matcher_t::MATCH_YES ||\n-            (match == matcher_t::MATCH_MAYBE &&\n-             skip == matcher_t::SKIP_NO))\n+        switch (match (c->buffer->out_info[idx]))\n@@ -570,10 +605,14 @@\n-          num_items--;\n-          if (match_glyph_data) match_glyph_data++;\n-          return true;\n-        }\n-\n-        if (skip == matcher_t::SKIP_NO)\n-        {\n-          if (unsafe_from)\n-            *unsafe_from = hb_max (1u, idx) - 1u;\n-          return false;\n+          case MATCH:\n+          {\n+            num_items--;\n+            advance_glyph_data ();\n+            return true;\n+          }\n+          case NOT_MATCH:\n+          {\n+            if (unsafe_from)\n+              *unsafe_from = hb_max (1u, idx) - 1u;\n+            return false;\n+          }\n+          case SKIP:\n+            continue;\n@@ -587,0 +626,29 @@\n+    hb_codepoint_t\n+    get_glyph_data ()\n+    {\n+      if (match_glyph_data16) return *match_glyph_data16;\n+#ifndef HB_NO_BEYOND_64K\n+      else\n+      if (match_glyph_data24) return *match_glyph_data24;\n+#endif\n+      return 0;\n+    }\n+    void\n+    advance_glyph_data ()\n+    {\n+      if (match_glyph_data16) match_glyph_data16++;\n+#ifndef HB_NO_BEYOND_64K\n+      else\n+      if (match_glyph_data24) match_glyph_data24++;\n+#endif\n+    }\n+    void\n+    backup_glyph_data ()\n+    {\n+      if (match_glyph_data16) match_glyph_data16--;\n+#ifndef HB_NO_BEYOND_64K\n+      else\n+      if (match_glyph_data24) match_glyph_data24--;\n+#endif\n+    }\n+\n@@ -591,1 +659,4 @@\n-    const HBUINT16 *match_glyph_data;\n+    const HBUINT16 *match_glyph_data16;\n+#ifndef HB_NO_BEYOND_64K\n+    const HBUINT24 *match_glyph_data24;\n+#endif\n@@ -628,0 +699,1 @@\n+  hb_set_digest_t digest;\n@@ -643,0 +715,3 @@\n+  signed last_base = -1; \/\/ GPOS uses\n+  unsigned last_base_until = 0; \/\/ GPOS uses\n+\n@@ -663,0 +738,1 @@\n+                        digest (buffer_->digest ()),\n@@ -680,1 +756,1 @@\n-  void set_lookup_mask (hb_mask_t mask) { lookup_mask = mask; init_iters (); }\n+  void set_lookup_mask (hb_mask_t mask) { lookup_mask = mask; last_base = -1; last_base_until = 0; init_iters (); }\n@@ -737,1 +813,1 @@\n-                          bool component = false) const\n+                          bool component = false)\n@@ -739,0 +815,2 @@\n+    digest.add (glyph_index);\n+\n@@ -771,1 +849,1 @@\n-  void replace_glyph (hb_codepoint_t glyph_index) const\n+  void replace_glyph (hb_codepoint_t glyph_index)\n@@ -776,1 +854,1 @@\n-  void replace_glyph_inplace (hb_codepoint_t glyph_index) const\n+  void replace_glyph_inplace (hb_codepoint_t glyph_index)\n@@ -782,1 +860,1 @@\n-                                    unsigned int class_guess) const\n+                                    unsigned int class_guess)\n@@ -788,1 +866,1 @@\n-                                   unsigned int class_guess) const\n+                                   unsigned int class_guess)\n@@ -800,1 +878,1 @@\n-  static inline bool apply_to (const void *obj, OT::hb_ot_apply_context_t *c)\n+  static inline bool apply_to (const void *obj, hb_ot_apply_context_t *c)\n@@ -808,1 +886,1 @@\n-  static inline auto apply_cached_ (const T *obj, OT::hb_ot_apply_context_t *c, hb_priority<1>) HB_RETURN (bool, obj->apply (c, true) )\n+  static inline auto apply_cached_ (const T *obj, hb_ot_apply_context_t *c, hb_priority<1>) HB_RETURN (bool, obj->apply (c, true) )\n@@ -810,1 +888,1 @@\n-  static inline auto apply_cached_ (const T *obj, OT::hb_ot_apply_context_t *c, hb_priority<0>) HB_RETURN (bool, obj->apply (c) )\n+  static inline auto apply_cached_ (const T *obj, hb_ot_apply_context_t *c, hb_priority<0>) HB_RETURN (bool, obj->apply (c) )\n@@ -812,1 +890,1 @@\n-  static inline bool apply_cached_to (const void *obj, OT::hb_ot_apply_context_t *c)\n+  static inline bool apply_cached_to (const void *obj, hb_ot_apply_context_t *c)\n@@ -819,1 +897,1 @@\n-  static inline auto cache_func_ (const T *obj, OT::hb_ot_apply_context_t *c, bool enter, hb_priority<1>) HB_RETURN (bool, obj->cache_func (c, enter) )\n+  static inline auto cache_func_ (const T *obj, hb_ot_apply_context_t *c, bool enter, hb_priority<1>) HB_RETURN (bool, obj->cache_func (c, enter) )\n@@ -821,1 +899,1 @@\n-  static inline bool cache_func_ (const T *obj, OT::hb_ot_apply_context_t *c, bool enter, hb_priority<0>) { return false; }\n+  static inline bool cache_func_ (const T *obj, hb_ot_apply_context_t *c, bool enter, hb_priority<0>) { return false; }\n@@ -823,1 +901,1 @@\n-  static inline bool cache_func_to (const void *obj, OT::hb_ot_apply_context_t *c, bool enter)\n+  static inline bool cache_func_to (const void *obj, hb_ot_apply_context_t *c, bool enter)\n@@ -830,2 +908,2 @@\n-  typedef bool (*hb_apply_func_t) (const void *obj, OT::hb_ot_apply_context_t *c);\n-  typedef bool (*hb_cache_func_t) (const void *obj, OT::hb_ot_apply_context_t *c, bool enter);\n+  typedef bool (*hb_apply_func_t) (const void *obj, hb_ot_apply_context_t *c);\n+  typedef bool (*hb_cache_func_t) (const void *obj, hb_ot_apply_context_t *c, bool enter);\n@@ -857,1 +935,1 @@\n-    bool apply (OT::hb_ot_apply_context_t *c) const\n+    bool apply (hb_ot_apply_context_t *c) const\n@@ -862,1 +940,1 @@\n-    bool apply_cached (OT::hb_ot_apply_context_t *c) const\n+    bool apply_cached (hb_ot_apply_context_t *c) const\n@@ -866,1 +944,1 @@\n-    bool cache_enter (OT::hb_ot_apply_context_t *c) const\n+    bool cache_enter (hb_ot_apply_context_t *c) const\n@@ -870,1 +948,1 @@\n-    void cache_leave (OT::hb_ot_apply_context_t *c) const\n+    void cache_leave (hb_ot_apply_context_t *c) const\n@@ -886,2 +964,0 @@\n-  typedef hb_vector_t<hb_applicable_t> array_t;\n-\n@@ -899,1 +975,1 @@\n-    hb_applicable_t entry;\n+    hb_applicable_t *entry = &array[i++];\n@@ -901,2 +977,2 @@\n-    entry.init (obj,\n-                apply_to<T>\n+    entry->init (obj,\n+                 apply_to<T>\n@@ -904,2 +980,2 @@\n-                , apply_cached_to<T>\n-                , cache_func_to<T>\n+                 , apply_cached_to<T>\n+                 , cache_func_to<T>\n@@ -907,3 +983,1 @@\n-                );\n-\n-    array.push (entry);\n+                 );\n@@ -921,1 +995,1 @@\n-    if (cost > cache_user_cost && !array.in_error ())\n+    if (cost > cache_user_cost)\n@@ -923,1 +997,1 @@\n-      cache_user_idx = array.length - 1;\n+      cache_user_idx = i - 1;\n@@ -932,1 +1006,1 @@\n-  hb_accelerate_subtables_context_t (array_t &array_) :\n+  hb_accelerate_subtables_context_t (hb_applicable_t *array_) :\n@@ -935,1 +1009,2 @@\n-  array_t &array;\n+  hb_applicable_t *array;\n+  unsigned i = 0;\n@@ -944,4 +1019,4 @@\n-typedef bool (*intersects_func_t) (const hb_set_t *glyphs, const HBUINT16 &value, const void *data);\n-typedef void (*intersected_glyphs_func_t) (const hb_set_t *glyphs, const void *data, unsigned value, hb_set_t *intersected_glyphs);\n-typedef void (*collect_glyphs_func_t) (hb_set_t *glyphs, const HBUINT16 &value, const void *data);\n-typedef bool (*match_func_t) (hb_glyph_info_t &info, const HBUINT16 &value, const void *data);\n+typedef bool (*intersects_func_t) (const hb_set_t *glyphs, unsigned value, const void *data, void *cache);\n+typedef void (*intersected_glyphs_func_t) (const hb_set_t *glyphs, const void *data, unsigned value, hb_set_t *intersected_glyphs, void *cache);\n+typedef void (*collect_glyphs_func_t) (hb_set_t *glyphs, unsigned value, const void *data);\n+typedef bool (*match_func_t) (hb_glyph_info_t &info, unsigned value, const void *data);\n@@ -968,1 +1043,1 @@\n-static inline bool intersects_glyph (const hb_set_t *glyphs, const HBUINT16 &value, const void *data HB_UNUSED)\n+static inline bool intersects_glyph (const hb_set_t *glyphs, unsigned value, const void *data HB_UNUSED, void *cache HB_UNUSED)\n@@ -972,1 +1047,1 @@\n-static inline bool intersects_class (const hb_set_t *glyphs, const HBUINT16 &value, const void *data)\n+static inline bool intersects_class (const hb_set_t *glyphs, unsigned value, const void *data, void *cache)\n@@ -975,1 +1050,10 @@\n-  return class_def.intersects_class (glyphs, value);\n+  hb_map_t *map = (hb_map_t *) cache;\n+\n+  hb_codepoint_t *cached_v;\n+  if (map->has (value, &cached_v))\n+    return *cached_v;\n+\n+  bool v = class_def.intersects_class (glyphs, value);\n+  map->set (value, v);\n+\n+  return v;\n@@ -977,1 +1061,1 @@\n-static inline bool intersects_coverage (const hb_set_t *glyphs, const HBUINT16 &value, const void *data)\n+static inline bool intersects_coverage (const hb_set_t *glyphs, unsigned value, const void *data, void *cache HB_UNUSED)\n@@ -979,1 +1063,2 @@\n-  const Offset16To<Coverage> &coverage = (const Offset16To<Coverage>&)value;\n+  Offset16To<Coverage> coverage;\n+  coverage = value;\n@@ -984,1 +1069,1 @@\n-static inline void intersected_glyph (const hb_set_t *glyphs HB_UNUSED, const void *data, unsigned value, hb_set_t *intersected_glyphs)\n+static inline void intersected_glyph (const hb_set_t *glyphs HB_UNUSED, const void *data, unsigned value, hb_set_t *intersected_glyphs, HB_UNUSED void *cache)\n@@ -989,1 +1074,4 @@\n-static inline void intersected_class_glyphs (const hb_set_t *glyphs, const void *data, unsigned value, hb_set_t *intersected_glyphs)\n+\n+using intersected_class_cache_t = hb_hashmap_t<unsigned, hb_set_t>;\n+\n+static inline void intersected_class_glyphs (const hb_set_t *glyphs, const void *data, unsigned value, hb_set_t *intersected_glyphs, void *cache)\n@@ -992,1 +1080,16 @@\n-  class_def.intersected_class_glyphs (glyphs, value, intersected_glyphs);\n+\n+  intersected_class_cache_t *map = (intersected_class_cache_t *) cache;\n+\n+  hb_set_t *cached_v;\n+  if (map->has (value, &cached_v))\n+  {\n+    intersected_glyphs->union_ (*cached_v);\n+    return;\n+  }\n+\n+  hb_set_t v;\n+  class_def.intersected_class_glyphs (glyphs, value, &v);\n+\n+  intersected_glyphs->union_ (v);\n+\n+  map->set (value, std::move (v));\n@@ -994,1 +1097,2 @@\n-static inline void intersected_coverage_glyphs (const hb_set_t *glyphs, const void *data, unsigned value, hb_set_t *intersected_glyphs)\n+\n+static inline void intersected_coverage_glyphs (const hb_set_t *glyphs, const void *data, unsigned value, hb_set_t *intersected_glyphs, HB_UNUSED void *cache)\n@@ -998,1 +1102,1 @@\n-  (data+coverage).intersected_coverage_glyphs (glyphs, intersected_glyphs);\n+  (data+coverage).intersect_set (*glyphs, *intersected_glyphs);\n@@ -1002,0 +1106,1 @@\n+template <typename HBUINT>\n@@ -1004,1 +1109,1 @@\n-                                       const HBUINT16 values[],\n+                                       const HBUINT values[],\n@@ -1006,1 +1111,2 @@\n-                                       const void *intersects_data)\n+                                       const void *intersects_data,\n+                                       void *cache)\n@@ -1008,2 +1114,2 @@\n-  for (const HBUINT16 &_ : + hb_iter (values, count))\n-    if (!intersects_func (glyphs, _, intersects_data)) return false;\n+  for (const auto &_ : + hb_iter (values, count))\n+    if (!intersects_func (glyphs, _, intersects_data, cache)) return false;\n@@ -1014,1 +1120,1 @@\n-static inline void collect_glyph (hb_set_t *glyphs, const HBUINT16 &value, const void *data HB_UNUSED)\n+static inline void collect_glyph (hb_set_t *glyphs, unsigned value, const void *data HB_UNUSED)\n@@ -1018,1 +1124,1 @@\n-static inline void collect_class (hb_set_t *glyphs, const HBUINT16 &value, const void *data)\n+static inline void collect_class (hb_set_t *glyphs, unsigned value, const void *data)\n@@ -1023,1 +1129,1 @@\n-static inline void collect_coverage (hb_set_t *glyphs, const HBUINT16 &value, const void *data)\n+static inline void collect_coverage (hb_set_t *glyphs, unsigned value, const void *data)\n@@ -1025,1 +1131,2 @@\n-  const Offset16To<Coverage> &coverage = (const Offset16To<Coverage>&)value;\n+  Offset16To<Coverage> coverage;\n+  coverage = value;\n@@ -1028,0 +1135,1 @@\n+template <typename HBUINT>\n@@ -1031,1 +1139,1 @@\n-                                  const HBUINT16 values[],\n+                                  const HBUINT values[],\n@@ -1037,1 +1145,1 @@\n-  | hb_apply ([&] (const HBUINT16 &_) { collect_func (glyphs, _, collect_data); })\n+  | hb_apply ([&] (const HBUINT &_) { collect_func (glyphs, _, collect_data); })\n@@ -1042,1 +1150,1 @@\n-static inline bool match_glyph (hb_glyph_info_t &info, const HBUINT16 &value, const void *data HB_UNUSED)\n+static inline bool match_glyph (hb_glyph_info_t &info, unsigned value, const void *data HB_UNUSED)\n@@ -1046,1 +1154,1 @@\n-static inline bool match_class (hb_glyph_info_t &info, const HBUINT16 &value, const void *data)\n+static inline bool match_class (hb_glyph_info_t &info, unsigned value, const void *data)\n@@ -1051,1 +1159,1 @@\n-static inline bool match_class_cached (hb_glyph_info_t &info, const HBUINT16 &value, const void *data)\n+static inline bool match_class_cached (hb_glyph_info_t &info, unsigned value, const void *data)\n@@ -1062,1 +1170,1 @@\n-static inline bool match_coverage (hb_glyph_info_t &info, const HBUINT16 &value, const void *data)\n+static inline bool match_coverage (hb_glyph_info_t &info, unsigned value, const void *data)\n@@ -1064,1 +1172,2 @@\n-  const Offset16To<Coverage> &coverage = (const Offset16To<Coverage>&)value;\n+  Offset16To<Coverage> coverage;\n+  coverage = value;\n@@ -1068,0 +1177,1 @@\n+template <typename HBUINT>\n@@ -1070,1 +1180,1 @@\n-                                      const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                      const HBUINT input[], \/* Array of input values--start with second glyph *\/\n@@ -1087,0 +1197,1 @@\n+template <typename HBUINT>\n@@ -1089,1 +1200,1 @@\n-                                const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                const HBUINT input[], \/* Array of input values--start with second glyph *\/\n@@ -1104,1 +1215,2 @@\n-  skippy_iter.set_match_func (match_func, match_data, input);\n+  skippy_iter.set_match_func (match_func, match_data);\n+  skippy_iter.set_glyph_data (input);\n@@ -1325,0 +1437,1 @@\n+template <typename HBUINT>\n@@ -1327,1 +1440,1 @@\n-                                    const HBUINT16 backtrack[],\n+                                    const HBUINT backtrack[],\n@@ -1336,1 +1449,2 @@\n-  skippy_iter.set_match_func (match_func, match_data, backtrack);\n+  skippy_iter.set_match_func (match_func, match_data);\n+  skippy_iter.set_glyph_data (backtrack);\n@@ -1352,0 +1466,1 @@\n+template <typename HBUINT>\n@@ -1354,1 +1469,1 @@\n-                                    const HBUINT16 lookahead[],\n+                                    const HBUINT lookahead[],\n@@ -1364,1 +1479,2 @@\n-  skippy_iter.set_match_func (match_func, match_data, lookahead);\n+  skippy_iter.set_match_func (match_func, match_data);\n+  skippy_iter.set_glyph_data (lookahead);\n@@ -1428,0 +1544,1 @@\n+template <typename HBUINT>\n@@ -1429,1 +1546,1 @@\n-                                             unsigned inputCount, const HBUINT16 input[],\n+                                             unsigned inputCount, const HBUINT input[],\n@@ -1435,1 +1552,2 @@\n-                                             intersected_glyphs_func_t intersected_glyphs_func)\n+                                             intersected_glyphs_func_t intersected_glyphs_func,\n+                                             void *cache)\n@@ -1437,1 +1555,2 @@\n-  hb_set_t *covered_seq_indicies = hb_set_create ();\n+  hb_set_t covered_seq_indicies;\n+  hb_set_t pos_glyphs;\n@@ -1444,1 +1563,0 @@\n-    hb_set_t pos_glyphs;\n@@ -1446,1 +1564,1 @@\n-    if (!hb_set_has (covered_seq_indicies, seqIndex))\n+    if (!covered_seq_indicies.has (seqIndex))\n@@ -1449,0 +1567,1 @@\n+      pos_glyphs.clear ();\n@@ -1456,1 +1575,1 @@\n-          intersected_glyphs_func (&c->parent_active_glyphs (), data, value, &pos_glyphs);\n+          intersected_glyphs_func (&c->parent_active_glyphs (), data, value, &pos_glyphs, cache);\n@@ -1473,1 +1592,1 @@\n-        intersected_glyphs_func (c->glyphs, input_data, input_value, &pos_glyphs);\n+        intersected_glyphs_func (c->glyphs, input_data, input_value, &pos_glyphs, cache);\n@@ -1477,1 +1596,1 @@\n-    covered_seq_indicies->add (seqIndex);\n+    covered_seq_indicies.add (seqIndex);\n@@ -1488,1 +1607,1 @@\n-    c->recurse (lookupRecord[i].lookupListIndex, covered_seq_indicies, seqIndex, endIndex);\n+    c->recurse (lookupRecord[i].lookupListIndex, &covered_seq_indicies, seqIndex, endIndex);\n@@ -1492,2 +1611,0 @@\n-\n-  hb_set_destroy (covered_seq_indicies);\n@@ -1545,0 +1662,10 @@\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      if (buffer->have_output)\n+        c->buffer->sync_so_far ();\n+      c->buffer->message (c->font,\n+                          \"recursing to lookup %u at %u\",\n+                          (unsigned) lookupRecord[i].lookupListIndex,\n+                          buffer->idx);\n+    }\n+\n@@ -1548,0 +1675,9 @@\n+    if (HB_BUFFER_MESSAGE_MORE && c->buffer->messaging ())\n+    {\n+      if (buffer->have_output)\n+        c->buffer->sync_so_far ();\n+      c->buffer->message (c->font,\n+                          \"recursed to lookup %u\",\n+                          (unsigned) lookupRecord[i].lookupListIndex);\n+    }\n+\n@@ -1634,0 +1770,2 @@\n+  void *intersects_cache;\n+  void *intersected_glyphs_cache;\n@@ -1648,0 +1786,1 @@\n+template <typename HBUINT>\n@@ -1650,1 +1789,1 @@\n-                                       const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                       const HBUINT input[], \/* Array of input values--start with second glyph *\/\n@@ -1655,1 +1794,3 @@\n-                             lookup_context.funcs.intersects, lookup_context.intersects_data);\n+                             lookup_context.funcs.intersects,\n+                             lookup_context.intersects_data,\n+                             lookup_context.intersects_cache);\n@@ -1658,0 +1799,1 @@\n+template <typename HBUINT>\n@@ -1660,1 +1802,1 @@\n-                                           const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                           const HBUINT input[], \/* Array of input values--start with second glyph *\/\n@@ -1675,1 +1817,2 @@\n-                                     lookup_context.funcs.intersected_glyphs);\n+                                     lookup_context.funcs.intersected_glyphs,\n+                                     lookup_context.intersected_glyphs_cache);\n@@ -1678,0 +1821,1 @@\n+template <typename HBUINT>\n@@ -1680,1 +1824,1 @@\n-                                                  const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                                  const HBUINT input[], \/* Array of input values--start with second glyph *\/\n@@ -1692,0 +1836,1 @@\n+template <typename HBUINT>\n@@ -1694,1 +1839,1 @@\n-                                               const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                               const HBUINT input[], \/* Array of input values--start with second glyph *\/\n@@ -1697,1 +1842,1 @@\n-                                               ContextApplyLookupContext &lookup_context)\n+                                               const ContextApplyLookupContext &lookup_context)\n@@ -1703,0 +1848,2 @@\n+\n+template <typename HBUINT>\n@@ -1705,1 +1852,1 @@\n-                                         const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                         const HBUINT input[], \/* Array of input values--start with second glyph *\/\n@@ -1708,1 +1855,1 @@\n-                                         ContextApplyLookupContext &lookup_context)\n+                                         const ContextApplyLookupContext &lookup_context)\n@@ -1731,0 +1878,1 @@\n+template <typename Types>\n@@ -1744,2 +1892,2 @@\n-    const UnsizedArrayOf<LookupRecord> &lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord>>\n-                                                       (inputZ.as_array ((inputCount ? inputCount - 1 : 0)));\n+    const auto &lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord>>\n+                                           (inputZ.as_array ((inputCount ? inputCount - 1 : 0)));\n@@ -1758,2 +1906,2 @@\n-    const UnsizedArrayOf<LookupRecord> &lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord>>\n-                                                       (inputZ.as_array (inputCount ? inputCount - 1 : 0));\n+    const auto &lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord>>\n+                                           (inputZ.as_array (inputCount ? inputCount - 1 : 0));\n@@ -1766,2 +1914,2 @@\n-    const UnsizedArrayOf<LookupRecord> &lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord>>\n-                                                       (inputZ.as_array (inputCount ? inputCount - 1 : 0));\n+    const auto &lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord>>\n+                                           (inputZ.as_array (inputCount ? inputCount - 1 : 0));\n@@ -1775,1 +1923,1 @@\n-                    ContextApplyLookupContext &lookup_context) const\n+                    const ContextApplyLookupContext &lookup_context) const\n@@ -1777,2 +1925,2 @@\n-    const UnsizedArrayOf<LookupRecord> &lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord>>\n-                                                       (inputZ.as_array (inputCount ? inputCount - 1 : 0));\n+    const auto &lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord>>\n+                                           (inputZ.as_array (inputCount ? inputCount - 1 : 0));\n@@ -1786,1 +1934,1 @@\n-              ContextApplyLookupContext &lookup_context) const\n+              const ContextApplyLookupContext &lookup_context) const\n@@ -1789,2 +1937,2 @@\n-    const UnsizedArrayOf<LookupRecord> &lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord>>\n-                                                       (inputZ.as_array (inputCount ? inputCount - 1 : 0));\n+    const auto &lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord>>\n+                                           (inputZ.as_array (inputCount ? inputCount - 1 : 0));\n@@ -1803,1 +1951,1 @@\n-    const hb_array_t<const HBUINT16> input = inputZ.as_array (inputCount - 1);\n+    const auto input = inputZ.as_array (inputCount - 1);\n@@ -1811,2 +1959,2 @@\n-    const UnsizedArrayOf<LookupRecord> &lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord>>\n-                                                       (inputZ.as_array ((inputCount ? inputCount - 1 : 0)));\n+    const auto &lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord>>\n+                                           (inputZ.as_array ((inputCount ? inputCount - 1 : 0)));\n@@ -1824,1 +1972,1 @@\n-    const hb_array_t<const HBUINT16> input = inputZ.as_array (inputCount - 1);\n+    const auto input = inputZ.as_array (inputCount - 1);\n@@ -1847,1 +1995,1 @@\n-  UnsizedArrayOf<HBUINT16>\n+  UnsizedArrayOf<typename Types::HBUINT>\n@@ -1857,0 +2005,1 @@\n+template <typename Types>\n@@ -1859,0 +2008,2 @@\n+  using Rule = OT::Rule<Types>;\n+\n@@ -1903,1 +2054,1 @@\n-                    ContextApplyLookupContext &lookup_context) const\n+                    const ContextApplyLookupContext &lookup_context) const\n@@ -1914,1 +2065,1 @@\n-              ContextApplyLookupContext &lookup_context) const\n+              const ContextApplyLookupContext &lookup_context) const\n@@ -1971,1 +2122,2 @@\n-struct ContextFormat1\n+template <typename Types>\n+struct ContextFormat1_4\n@@ -1973,0 +2125,2 @@\n+  using RuleSet = OT::RuleSet<Types>;\n+\n@@ -1996,3 +2150,2 @@\n-    hb_set_t* cur_active_glyphs = &c->push_cur_active_glyphs ();\n-    get_coverage ().intersected_coverage_glyphs (&c->previous_parent_active_glyphs (),\n-                                                 cur_active_glyphs);\n+    hb_set_t& cur_active_glyphs = c->push_cur_active_glyphs ();\n+    get_coverage ().intersect_set (c->previous_parent_active_glyphs (), cur_active_glyphs);\n@@ -2020,1 +2173,1 @@\n-      {intersects_glyph, intersected_glyph},\n+      {intersects_glyph, nullptr},\n@@ -2087,1 +2240,1 @@\n-    const hb_map_t *lookup_map = c->table_tag == HB_OT_TAG_GSUB ? c->plan->gsub_lookups : c->plan->gpos_lookups;\n+    const hb_map_t *lookup_map = c->table_tag == HB_OT_TAG_GSUB ? &c->plan->gsub_lookups : &c->plan->gpos_lookups;\n@@ -2109,1 +2262,1 @@\n-  Offset16To<Coverage>\n+  typename Types::template OffsetTo<Coverage>\n@@ -2112,1 +2265,1 @@\n-  Array16OfOffset16To<RuleSet>\n+  Array16Of<typename Types::template OffsetTo<RuleSet>>\n@@ -2116,1 +2269,1 @@\n-  DEFINE_SIZE_ARRAY (6, ruleSet);\n+  DEFINE_SIZE_ARRAY (2 + 2 * Types::size, ruleSet);\n@@ -2120,1 +2273,2 @@\n-struct ContextFormat2\n+template <typename Types>\n+struct ContextFormat2_5\n@@ -2122,0 +2276,2 @@\n+  using RuleSet = OT::RuleSet<SmallTypes>;\n+\n@@ -2129,0 +2285,1 @@\n+    hb_map_t cache;\n@@ -2130,1 +2287,1 @@\n-      {intersects_class, intersected_class_glyphs},\n+      {intersects_class, nullptr},\n@@ -2132,1 +2289,2 @@\n-      &class_def\n+      &class_def,\n+      &cache\n@@ -2136,1 +2294,1 @@\n-    (this+coverage).intersected_coverage_glyphs (glyphs, &retained_coverage_glyphs);\n+    (this+coverage).intersect_set (*glyphs, retained_coverage_glyphs);\n@@ -2162,2 +2320,2 @@\n-    hb_set_t* cur_active_glyphs = &c->push_cur_active_glyphs ();\n-    get_coverage ().intersected_coverage_glyphs (&c->previous_parent_active_glyphs (),\n+    hb_set_t& cur_active_glyphs = c->push_cur_active_glyphs ();\n+    get_coverage ().intersect_set (c->previous_parent_active_glyphs (),\n@@ -2168,0 +2326,2 @@\n+    hb_map_t cache;\n+    intersected_class_cache_t intersected_cache;\n@@ -2171,1 +2331,3 @@\n-      &class_def\n+      &class_def,\n+      &cache,\n+      &intersected_cache\n@@ -2178,1 +2340,1 @@\n-    | hb_apply ([&] (const hb_pair_t<unsigned, const Offset16To<RuleSet>&> _)\n+    | hb_apply ([&] (const hb_pair_t<unsigned, const typename Types::template OffsetTo<RuleSet>&> _)\n@@ -2195,0 +2357,1 @@\n+    hb_map_t cache;\n@@ -2196,1 +2359,1 @@\n-      {intersects_class, intersected_class_glyphs},\n+      {intersects_class, nullptr},\n@@ -2198,1 +2361,2 @@\n-      &class_def\n+      &class_def,\n+      &cache\n@@ -2308,1 +2472,1 @@\n-    (this+coverage).intersected_coverage_glyphs (glyphset, &retained_coverage_glyphs);\n+    (this+coverage).intersect_set (*glyphset, retained_coverage_glyphs);\n@@ -2313,1 +2477,1 @@\n-    const hb_map_t *lookup_map = c->table_tag == HB_OT_TAG_GSUB ? c->plan->gsub_lookups : c->plan->gpos_lookups;\n+    const hb_map_t *lookup_map = c->table_tag == HB_OT_TAG_GSUB ? &c->plan->gsub_lookups : &c->plan->gpos_lookups;\n@@ -2316,0 +2480,1 @@\n+    auto snapshot = c->serializer->snapshot();\n@@ -2327,1 +2492,1 @@\n-          o->serialize_subset (c, _.second, this, lookup_map, &klass_map))\n+          o->serialize_subset (c, _.second, this, lookup_map, &klass_map)) {\n@@ -2329,0 +2494,2 @@\n+        snapshot = c->serializer->snapshot();\n+      }\n@@ -2342,0 +2509,1 @@\n+    c->serializer->revert (snapshot);\n@@ -2354,1 +2522,1 @@\n-  Offset16To<Coverage>\n+  typename Types::template OffsetTo<Coverage>\n@@ -2357,1 +2525,1 @@\n-  Offset16To<ClassDef>\n+  typename Types::template OffsetTo<ClassDef>\n@@ -2360,1 +2528,1 @@\n-  Array16OfOffset16To<RuleSet>\n+  Array16Of<typename Types::template OffsetTo<RuleSet>>\n@@ -2364,1 +2532,1 @@\n-  DEFINE_SIZE_ARRAY (8, ruleSet);\n+  DEFINE_SIZE_ARRAY (4 + 2 * Types::size, ruleSet);\n@@ -2370,0 +2538,2 @@\n+  using RuleSet = OT::RuleSet<SmallTypes>;\n+\n@@ -2376,1 +2546,1 @@\n-      {intersects_coverage, intersected_coverage_glyphs},\n+      {intersects_coverage, nullptr},\n@@ -2393,2 +2563,2 @@\n-    hb_set_t* cur_active_glyphs = &c->push_cur_active_glyphs ();\n-    get_coverage ().intersected_coverage_glyphs (&c->previous_parent_active_glyphs (),\n+    hb_set_t& cur_active_glyphs = c->push_cur_active_glyphs ();\n+    get_coverage ().intersect_set (c->previous_parent_active_glyphs (),\n@@ -2486,2 +2656,2 @@\n-    const UnsizedArrayOf<LookupRecord>& lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord>> (coverageZ.as_array (glyphCount));\n-    const hb_map_t *lookup_map = c->table_tag == HB_OT_TAG_GSUB ? c->plan->gsub_lookups : c->plan->gpos_lookups;\n+    const auto& lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord>> (coverageZ.as_array (glyphCount));\n+    const hb_map_t *lookup_map = c->table_tag == HB_OT_TAG_GSUB ? &c->plan->gsub_lookups : &c->plan->gpos_lookups;\n@@ -2527,0 +2697,1 @@\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n@@ -2528,1 +2699,0 @@\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n@@ -2533,0 +2703,4 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 4: return_trace (c->dispatch (u.format4, std::forward<Ts> (ds)...));\n+    case 5: return_trace (c->dispatch (u.format5, std::forward<Ts> (ds)...));\n+#endif\n@@ -2539,4 +2713,8 @@\n-  HBUINT16              format;         \/* Format identifier *\/\n-  ContextFormat1        format1;\n-  ContextFormat2        format2;\n-  ContextFormat3        format3;\n+  HBUINT16                      format;         \/* Format identifier *\/\n+  ContextFormat1_4<SmallTypes>  format1;\n+  ContextFormat2_5<SmallTypes>  format2;\n+  ContextFormat3                format3;\n+#ifndef HB_NO_BEYOND_64K\n+  ContextFormat1_4<MediumTypes> format4;\n+  ContextFormat2_5<MediumTypes> format5;\n+#endif\n@@ -2554,0 +2732,2 @@\n+  void *intersects_cache[3];\n+  void *intersected_glyphs_cache;\n@@ -2568,0 +2748,1 @@\n+template <typename HBUINT>\n@@ -2570,1 +2751,1 @@\n-                                             const HBUINT16 backtrack[],\n+                                             const HBUINT backtrack[],\n@@ -2572,1 +2753,1 @@\n-                                             const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                             const HBUINT input[], \/* Array of input values--start with second glyph *\/\n@@ -2574,1 +2755,1 @@\n-                                             const HBUINT16 lookahead[],\n+                                             const HBUINT lookahead[],\n@@ -2579,1 +2760,3 @@\n-                             lookup_context.funcs.intersects, lookup_context.intersects_data[0])\n+                             lookup_context.funcs.intersects,\n+                             lookup_context.intersects_data[0],\n+                             lookup_context.intersects_cache[0])\n@@ -2582,1 +2765,3 @@\n-                             lookup_context.funcs.intersects, lookup_context.intersects_data[1])\n+                             lookup_context.funcs.intersects,\n+                             lookup_context.intersects_data[1],\n+                             lookup_context.intersects_cache[1])\n@@ -2585,1 +2770,3 @@\n-                             lookup_context.funcs.intersects, lookup_context.intersects_data[2]);\n+                             lookup_context.funcs.intersects,\n+                             lookup_context.intersects_data[2],\n+                             lookup_context.intersects_cache[2]);\n@@ -2588,0 +2775,1 @@\n+template <typename HBUINT>\n@@ -2590,1 +2778,1 @@\n-                                                 const HBUINT16 backtrack[],\n+                                                 const HBUINT backtrack[],\n@@ -2592,1 +2780,1 @@\n-                                                 const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                                 const HBUINT input[], \/* Array of input values--start with second glyph *\/\n@@ -2594,1 +2782,1 @@\n-                                                 const HBUINT16 lookahead[],\n+                                                 const HBUINT lookahead[],\n@@ -2611,1 +2799,2 @@\n-                     lookup_context.funcs.intersected_glyphs);\n+                     lookup_context.funcs.intersected_glyphs,\n+                     lookup_context.intersected_glyphs_cache);\n@@ -2614,0 +2803,1 @@\n+template <typename HBUINT>\n@@ -2616,1 +2806,1 @@\n-                                                        const HBUINT16 backtrack[],\n+                                                        const HBUINT backtrack[],\n@@ -2618,1 +2808,1 @@\n-                                                        const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                                        const HBUINT input[], \/* Array of input values--start with second glyph *\/\n@@ -2620,1 +2810,1 @@\n-                                                        const HBUINT16 lookahead[],\n+                                                        const HBUINT lookahead[],\n@@ -2638,0 +2828,1 @@\n+template <typename HBUINT>\n@@ -2640,1 +2831,1 @@\n-                                                     const HBUINT16 backtrack[] HB_UNUSED,\n+                                                     const HBUINT backtrack[] HB_UNUSED,\n@@ -2642,1 +2833,1 @@\n-                                                     const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                                     const HBUINT input[], \/* Array of input values--start with second glyph *\/\n@@ -2644,1 +2835,1 @@\n-                                                     const HBUINT16 lookahead[] HB_UNUSED,\n+                                                     const HBUINT lookahead[] HB_UNUSED,\n@@ -2647,1 +2838,1 @@\n-                                                     ChainContextApplyLookupContext &lookup_context)\n+                                                     const ChainContextApplyLookupContext &lookup_context)\n@@ -2655,0 +2846,1 @@\n+template <typename HBUINT>\n@@ -2657,1 +2849,1 @@\n-                                               const HBUINT16 backtrack[],\n+                                               const HBUINT backtrack[],\n@@ -2659,1 +2851,1 @@\n-                                               const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                               const HBUINT input[], \/* Array of input values--start with second glyph *\/\n@@ -2661,1 +2853,1 @@\n-                                               const HBUINT16 lookahead[],\n+                                               const HBUINT lookahead[],\n@@ -2664,1 +2856,1 @@\n-                                               ChainContextApplyLookupContext &lookup_context)\n+                                               const ChainContextApplyLookupContext &lookup_context)\n@@ -2700,0 +2892,1 @@\n+template <typename Types>\n@@ -2704,2 +2897,2 @@\n-    const HeadlessArrayOf<HBUINT16> &input = StructAfter<HeadlessArrayOf<HBUINT16>> (backtrack);\n-    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (input);\n@@ -2718,3 +2911,3 @@\n-    const HeadlessArrayOf<HBUINT16> &input = StructAfter<HeadlessArrayOf<HBUINT16>> (backtrack);\n-    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n-    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (input);\n+    const auto &lookup = StructAfter<decltype (lookupX)> (lookahead);\n@@ -2736,3 +2929,3 @@\n-    const HeadlessArrayOf<HBUINT16> &input = StructAfter<HeadlessArrayOf<HBUINT16>> (backtrack);\n-    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n-    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (input);\n+    const auto &lookup = StructAfter<decltype (lookupX)> (lookahead);\n@@ -2745,3 +2938,3 @@\n-    const HeadlessArrayOf<HBUINT16> &input = StructAfter<HeadlessArrayOf<HBUINT16>> (backtrack);\n-    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n-    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (input);\n+    const auto &lookup = StructAfter<decltype (lookupX)> (lookahead);\n@@ -2757,1 +2950,1 @@\n-                    ChainContextApplyLookupContext &lookup_context) const\n+                    const ChainContextApplyLookupContext &lookup_context) const\n@@ -2759,3 +2952,3 @@\n-    const HeadlessArrayOf<HBUINT16> &input = StructAfter<HeadlessArrayOf<HBUINT16>> (backtrack);\n-    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n-    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (input);\n+    const auto &lookup = StructAfter<decltype (lookupX)> (lookahead);\n@@ -2769,1 +2962,2 @@\n-  bool apply (hb_ot_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const\n+  bool apply (hb_ot_apply_context_t *c,\n+              const ChainContextApplyLookupContext &lookup_context) const\n@@ -2772,3 +2966,3 @@\n-    const HeadlessArrayOf<HBUINT16> &input = StructAfter<HeadlessArrayOf<HBUINT16>> (backtrack);\n-    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n-    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (input);\n+    const auto &lookup = StructAfter<decltype (lookupX)> (lookahead);\n@@ -2807,1 +3001,1 @@\n-    const HeadlessArrayOf<HBUINT16> &input = StructAfter<HeadlessArrayOf<HBUINT16>> (backtrack);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n@@ -2812,1 +3006,1 @@\n-    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (input);\n@@ -2817,1 +3011,1 @@\n-    const Array16Of<LookupRecord> &lookupRecord = StructAfter<Array16Of<LookupRecord>> (lookahead);\n+    const auto &lookup = StructAfter<decltype (lookupX)> (lookahead);\n@@ -2819,1 +3013,1 @@\n-    HBUINT16* lookupCount = c->embed (&(lookupRecord.len));\n+    HBUINT16* lookupCount = c->embed (&(lookup.len));\n@@ -2822,1 +3016,1 @@\n-    unsigned count = serialize_lookuprecord_array (c, lookupRecord.as_array (), lookup_map);\n+    unsigned count = serialize_lookuprecord_array (c, lookup.as_array (), lookup_map);\n@@ -2834,2 +3028,2 @@\n-    const HeadlessArrayOf<HBUINT16> &input = StructAfter<HeadlessArrayOf<HBUINT16>> (backtrack);\n-    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (input);\n@@ -2864,1 +3058,1 @@\n-    const HeadlessArrayOf<HBUINT16> &input = StructAfter<HeadlessArrayOf<HBUINT16>> (backtrack);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n@@ -2866,1 +3060,1 @@\n-    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (input);\n@@ -2868,1 +3062,1 @@\n-    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n+    const auto &lookup = StructAfter<decltype (lookupX)> (lookahead);\n@@ -2873,1 +3067,1 @@\n-  Array16Of<HBUINT16>\n+  Array16Of<typename Types::HBUINT>\n@@ -2877,1 +3071,1 @@\n-  HeadlessArrayOf<HBUINT16>\n+  HeadlessArrayOf<typename Types::HBUINT>\n@@ -2880,1 +3074,1 @@\n-  Array16Of<HBUINT16>\n+  Array16Of<typename Types::HBUINT>\n@@ -2890,0 +3084,1 @@\n+template <typename Types>\n@@ -2892,0 +3087,2 @@\n+  using ChainRule = OT::ChainRule<Types>;\n+\n@@ -2932,1 +3129,2 @@\n-  bool would_apply (hb_would_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const\n+  bool would_apply (hb_would_apply_context_t *c,\n+                    const ChainContextApplyLookupContext &lookup_context) const\n@@ -2942,1 +3140,2 @@\n-  bool apply (hb_ot_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const\n+  bool apply (hb_ot_apply_context_t *c,\n+              const ChainContextApplyLookupContext &lookup_context) const\n@@ -3004,1 +3203,2 @@\n-struct ChainContextFormat1\n+template <typename Types>\n+struct ChainContextFormat1_4\n@@ -3006,0 +3206,2 @@\n+  using ChainRuleSet = OT::ChainRuleSet<Types>;\n+\n@@ -3029,2 +3231,2 @@\n-    hb_set_t* cur_active_glyphs = &c->push_cur_active_glyphs ();\n-    get_coverage ().intersected_coverage_glyphs (&c->previous_parent_active_glyphs (),\n+    hb_set_t& cur_active_glyphs = c->push_cur_active_glyphs ();\n+    get_coverage ().intersect_set (c->previous_parent_active_glyphs (),\n@@ -3053,1 +3255,1 @@\n-      {intersects_glyph, intersected_glyph},\n+      {intersects_glyph, nullptr},\n@@ -3119,1 +3321,1 @@\n-    const hb_map_t *lookup_map = c->table_tag == HB_OT_TAG_GSUB ? c->plan->gsub_lookups : c->plan->gpos_lookups;\n+    const hb_map_t *lookup_map = c->table_tag == HB_OT_TAG_GSUB ? &c->plan->gsub_lookups : &c->plan->gpos_lookups;\n@@ -3141,1 +3343,1 @@\n-  Offset16To<Coverage>\n+  typename Types::template OffsetTo<Coverage>\n@@ -3144,1 +3346,1 @@\n-  Array16OfOffset16To<ChainRuleSet>\n+  Array16Of<typename Types::template OffsetTo<ChainRuleSet>>\n@@ -3148,1 +3350,1 @@\n-  DEFINE_SIZE_ARRAY (6, ruleSet);\n+  DEFINE_SIZE_ARRAY (2 + 2 * Types::size, ruleSet);\n@@ -3151,1 +3353,2 @@\n-struct ChainContextFormat2\n+template <typename Types>\n+struct ChainContextFormat2_5\n@@ -3153,0 +3356,2 @@\n+  using ChainRuleSet = OT::ChainRuleSet<SmallTypes>;\n+\n@@ -3162,0 +3367,1 @@\n+    hb_map_t caches[3] = {};\n@@ -3163,1 +3369,1 @@\n-      {intersects_class, intersected_class_glyphs},\n+      {intersects_class, nullptr},\n@@ -3167,1 +3373,2 @@\n-       &lookahead_class_def}\n+       &lookahead_class_def},\n+      {&caches[0], &caches[1], &caches[2]}\n@@ -3171,1 +3378,1 @@\n-    (this+coverage).intersected_coverage_glyphs (glyphs, &retained_coverage_glyphs);\n+    (this+coverage).intersect_set (*glyphs, retained_coverage_glyphs);\n@@ -3196,2 +3403,2 @@\n-    hb_set_t* cur_active_glyphs = &c->push_cur_active_glyphs ();\n-    get_coverage ().intersected_coverage_glyphs (&c->previous_parent_active_glyphs (),\n+    hb_set_t& cur_active_glyphs = c->push_cur_active_glyphs ();\n+    get_coverage ().intersect_set (c->previous_parent_active_glyphs (),\n@@ -3205,0 +3412,2 @@\n+    hb_map_t caches[3] = {};\n+    intersected_class_cache_t intersected_cache;\n@@ -3210,1 +3419,3 @@\n-       &lookahead_class_def}\n+       &lookahead_class_def},\n+      {&caches[0], &caches[1], &caches[2]},\n+      &intersected_cache\n@@ -3217,1 +3428,1 @@\n-    | hb_apply ([&] (const hb_pair_t<unsigned, const Offset16To<ChainRuleSet>&> _)\n+    | hb_apply ([&] (const hb_pair_t<unsigned, const typename Types::template OffsetTo<ChainRuleSet>&> _)\n@@ -3236,0 +3447,1 @@\n+    hb_map_t caches[3] = {};\n@@ -3237,1 +3449,1 @@\n-      {intersects_class, intersected_class_glyphs},\n+      {intersects_class, nullptr},\n@@ -3241,1 +3453,2 @@\n-       &lookahead_class_def}\n+       &lookahead_class_def},\n+      {&caches[0], &caches[1], &caches[2]}\n@@ -3333,1 +3546,1 @@\n-    \/* For ChainContextFormat2 we cache the LookaheadClassDef instead of InputClassDef.\n+    \/* For ChainContextFormat2_5 we cache the LookaheadClassDef instead of InputClassDef.\n@@ -3344,1 +3557,1 @@\n-      {{cached && &backtrack_class_def == &input_class_def ? match_class_cached : match_class,\n+      {{cached && &backtrack_class_def == &lookahead_class_def ? match_class_cached : match_class,\n@@ -3381,1 +3594,1 @@\n-    (this+coverage).intersected_coverage_glyphs (glyphset, &retained_coverage_glyphs);\n+    (this+coverage).intersect_set (*glyphset, retained_coverage_glyphs);\n@@ -3388,1 +3601,1 @@\n-    const hb_map_t *lookup_map = c->table_tag == HB_OT_TAG_GSUB ? c->plan->gsub_lookups : c->plan->gpos_lookups;\n+    const hb_map_t *lookup_map = c->table_tag == HB_OT_TAG_GSUB ? &c->plan->gsub_lookups : &c->plan->gpos_lookups;\n@@ -3436,1 +3649,1 @@\n-  Offset16To<Coverage>\n+  typename Types::template OffsetTo<Coverage>\n@@ -3439,1 +3652,1 @@\n-  Offset16To<ClassDef>\n+  typename Types::template OffsetTo<ClassDef>\n@@ -3443,1 +3656,1 @@\n-  Offset16To<ClassDef>\n+  typename Types::template OffsetTo<ClassDef>\n@@ -3447,1 +3660,1 @@\n-  Offset16To<ClassDef>\n+  typename Types::template OffsetTo<ClassDef>\n@@ -3451,1 +3664,1 @@\n-  Array16OfOffset16To<ChainRuleSet>\n+  Array16Of<typename Types::template OffsetTo<ChainRuleSet>>\n@@ -3455,1 +3668,1 @@\n-  DEFINE_SIZE_ARRAY (12, ruleSet);\n+  DEFINE_SIZE_ARRAY (4 + 4 * Types::size, ruleSet);\n@@ -3460,0 +3673,2 @@\n+  using RuleSet = OT::RuleSet<SmallTypes>;\n+\n@@ -3462,1 +3677,1 @@\n-    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n@@ -3467,1 +3682,1 @@\n-    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (input);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (input);\n@@ -3469,1 +3684,1 @@\n-      {intersects_coverage, intersected_coverage_glyphs},\n+      {intersects_coverage, nullptr},\n@@ -3485,1 +3700,1 @@\n-    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n@@ -3490,2 +3705,2 @@\n-    hb_set_t* cur_active_glyphs = &c->push_cur_active_glyphs ();\n-    get_coverage ().intersected_coverage_glyphs (&c->previous_parent_active_glyphs (),\n+    hb_set_t& cur_active_glyphs = c->push_cur_active_glyphs ();\n+    get_coverage ().intersect_set (c->previous_parent_active_glyphs (),\n@@ -3495,2 +3710,2 @@\n-    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (input);\n-    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (input);\n+    const auto &lookup = StructAfter<decltype (lookupX)> (lookahead);\n@@ -3517,3 +3732,3 @@\n-    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n-    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (input);\n-    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (input);\n+    const auto &lookup = StructAfter<decltype (lookupX)> (lookahead);\n@@ -3527,1 +3742,1 @@\n-    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n@@ -3531,2 +3746,3 @@\n-    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (input);\n-    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (input);\n+    const auto &lookup = StructAfter<decltype (lookupX)> (lookahead);\n+\n@@ -3547,3 +3763,3 @@\n-    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n-    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (input);\n-    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (input);\n+    const auto &lookup = StructAfter<decltype (lookupX)> (lookahead);\n@@ -3563,1 +3779,1 @@\n-    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n@@ -3570,1 +3786,1 @@\n-    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n@@ -3575,2 +3791,2 @@\n-    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (input);\n-    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (input);\n+    const auto &lookup = StructAfter<decltype (lookupX)> (lookahead);\n@@ -3618,1 +3834,1 @@\n-    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n@@ -3622,1 +3838,1 @@\n-    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (input);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (input);\n@@ -3626,2 +3842,2 @@\n-    const Array16Of<LookupRecord> &lookupRecord = StructAfter<Array16Of<LookupRecord>> (lookahead);\n-    const hb_map_t *lookup_map = c->table_tag == HB_OT_TAG_GSUB ? c->plan->gsub_lookups : c->plan->gpos_lookups;\n+    const auto &lookup = StructAfter<decltype (lookupX)> (lookahead);\n+    const hb_map_t *lookup_map = c->table_tag == HB_OT_TAG_GSUB ? &c->plan->gsub_lookups : &c->plan->gpos_lookups;\n@@ -3629,1 +3845,1 @@\n-    HBUINT16 *lookupCount = c->serializer->copy<HBUINT16> (lookupRecord.len);\n+    HBUINT16 *lookupCount = c->serializer->copy<HBUINT16> (lookup.len);\n@@ -3632,1 +3848,1 @@\n-    unsigned count = serialize_lookuprecord_array (c->serializer, lookupRecord.as_array (), lookup_map);\n+    unsigned count = serialize_lookuprecord_array (c->serializer, lookup.as_array (), lookup_map);\n@@ -3640,1 +3856,1 @@\n-    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+    const auto &input = StructAfter<decltype (inputX)> (backtrack);\n@@ -3643,1 +3859,1 @@\n-    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (input);\n+    const auto &lookahead = StructAfter<decltype (lookaheadX)> (input);\n@@ -3645,1 +3861,1 @@\n-    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n+    const auto &lookup = StructAfter<decltype (lookupX)> (lookahead);\n@@ -3675,0 +3891,1 @@\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n@@ -3676,1 +3893,0 @@\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n@@ -3681,0 +3897,4 @@\n+#ifndef HB_NO_BEYOND_64K\n+    case 4: return_trace (c->dispatch (u.format4, std::forward<Ts> (ds)...));\n+    case 5: return_trace (c->dispatch (u.format5, std::forward<Ts> (ds)...));\n+#endif\n@@ -3687,4 +3907,8 @@\n-  HBUINT16              format; \/* Format identifier *\/\n-  ChainContextFormat1   format1;\n-  ChainContextFormat2   format2;\n-  ChainContextFormat3   format3;\n+  HBUINT16                              format; \/* Format identifier *\/\n+  ChainContextFormat1_4<SmallTypes>     format1;\n+  ChainContextFormat2_5<SmallTypes>     format2;\n+  ChainContextFormat3                   format3;\n+#ifndef HB_NO_BEYOND_64K\n+  ChainContextFormat1_4<MediumTypes>    format4;\n+  ChainContextFormat2_5<MediumTypes>    format5;\n+#endif\n@@ -3707,0 +3931,1 @@\n+    if (unlikely (!c->may_dispatch (this, this))) return c->no_dispatch_return_value ();\n@@ -3708,1 +3933,0 @@\n-    if (unlikely (!c->may_dispatch (this, this))) return_trace (c->no_dispatch_return_value ());\n@@ -3786,0 +4010,1 @@\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n@@ -3787,1 +4012,0 @@\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n@@ -3809,1 +4033,1 @@\n-  void init (const TLookup &lookup)\n+  static hb_ot_layout_lookup_accelerator_t *create (const TLookup &lookup)\n@@ -3811,2 +4035,14 @@\n-    digest.init ();\n-    lookup.collect_coverage (&digest);\n+    unsigned count = lookup.get_subtable_count ();\n+\n+    unsigned size = sizeof (hb_ot_layout_lookup_accelerator_t) -\n+                    HB_VAR_ARRAY * sizeof (hb_accelerate_subtables_context_t::hb_applicable_t) +\n+                    count * sizeof (hb_accelerate_subtables_context_t::hb_applicable_t);\n+\n+    \/* The following is a calloc because when we are collecting subtables,\n+     * some of them might be invalid and hence not collect; as a result,\n+     * we might not fill in all the count entries of the subtables array.\n+     * Zeroing it allows the set digest to gatekeep it without having to\n+     * initialize it further. *\/\n+    auto *thiz = (hb_ot_layout_lookup_accelerator_t *) hb_calloc (1, size);\n+    if (unlikely (!thiz))\n+      return nullptr;\n@@ -3814,2 +4050,1 @@\n-    subtables.init ();\n-    OT::hb_accelerate_subtables_context_t c_accelerate_subtables (subtables);\n+    hb_accelerate_subtables_context_t c_accelerate_subtables (thiz->subtables);\n@@ -3818,0 +4053,4 @@\n+    thiz->digest.init ();\n+    for (auto& subtable : hb_iter (thiz->subtables, count))\n+      thiz->digest.add (subtable.digest);\n+\n@@ -3819,4 +4058,4 @@\n-    cache_user_idx = c_accelerate_subtables.cache_user_idx;\n-    for (unsigned i = 0; i < subtables.length; i++)\n-      if (i != cache_user_idx)\n-        subtables[i].apply_cached_func = subtables[i].apply_func;\n+    thiz->cache_user_idx = c_accelerate_subtables.cache_user_idx;\n+    for (unsigned i = 0; i < count; i++)\n+      if (i != thiz->cache_user_idx)\n+        thiz->subtables[i].apply_cached_func = thiz->subtables[i].apply_func;\n@@ -3824,0 +4063,2 @@\n+\n+    return thiz;\n@@ -3825,1 +4066,0 @@\n-  void fini () { subtables.fini (); }\n@@ -3830,1 +4070,1 @@\n-  bool apply (hb_ot_apply_context_t *c, bool use_cache) const\n+  bool apply (hb_ot_apply_context_t *c, unsigned subtables_count, bool use_cache) const\n@@ -3835,3 +4075,5 @@\n-      for (unsigned int i = 0; i < subtables.length; i++)\n-        if (subtables[i].apply_cached (c))\n-          return true;\n+      return\n+      + hb_iter (hb_iter (subtables, subtables_count))\n+      | hb_map ([&c] (const hb_accelerate_subtables_context_t::hb_applicable_t &_) { return _.apply_cached (c); })\n+      | hb_any\n+      ;\n@@ -3842,3 +4084,5 @@\n-      for (unsigned int i = 0; i < subtables.length; i++)\n-        if (subtables[i].apply (c))\n-          return true;\n+      return\n+      + hb_iter (hb_iter (subtables, subtables_count))\n+      | hb_map ([&c] (const hb_accelerate_subtables_context_t::hb_applicable_t &_) { return _.apply (c); })\n+      | hb_any\n+      ;\n@@ -3849,1 +4093,1 @@\n-  bool cache_enter (OT::hb_ot_apply_context_t *c) const\n+  bool cache_enter (hb_ot_apply_context_t *c) const\n@@ -3858,1 +4102,1 @@\n-  void cache_leave (OT::hb_ot_apply_context_t *c) const\n+  void cache_leave (hb_ot_apply_context_t *c) const\n@@ -3866,1 +4110,0 @@\n-  private:\n@@ -3868,1 +4111,1 @@\n-  hb_accelerate_subtables_context_t::array_t subtables;\n+  private:\n@@ -3872,0 +4115,110 @@\n+  hb_accelerate_subtables_context_t::hb_applicable_t subtables[HB_VAR_ARRAY];\n+};\n+\n+template <typename Types>\n+struct GSUBGPOSVersion1_2\n+{\n+  friend struct GSUBGPOS;\n+\n+  protected:\n+  FixedVersion<>version;        \/* Version of the GSUB\/GPOS table--initially set\n+                                 * to 0x00010000u *\/\n+  typename Types:: template OffsetTo<ScriptList>\n+                scriptList;     \/* ScriptList table *\/\n+  typename Types::template OffsetTo<FeatureList>\n+                featureList;    \/* FeatureList table *\/\n+  typename Types::template OffsetTo<LookupList<Types>>\n+                lookupList;     \/* LookupList table *\/\n+  Offset32To<FeatureVariations>\n+                featureVars;    \/* Offset to Feature Variations\n+                                   table--from beginning of table\n+                                 * (may be NULL).  Introduced\n+                                 * in version 0x00010001. *\/\n+  public:\n+  DEFINE_SIZE_MIN (4 + 3 * Types::size);\n+\n+  unsigned int get_size () const\n+  {\n+    return min_size +\n+           (version.to_int () >= 0x00010001u ? featureVars.static_size : 0);\n+  }\n+\n+  const typename Types::template OffsetTo<LookupList<Types>>* get_lookup_list_offset () const\n+  {\n+    return &lookupList;\n+  }\n+\n+  template <typename TLookup>\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    typedef List16OfOffsetTo<TLookup, typename Types::HBUINT> TLookupList;\n+    if (unlikely (!(scriptList.sanitize (c, this) &&\n+                    featureList.sanitize (c, this) &&\n+                    reinterpret_cast<const typename Types::template OffsetTo<TLookupList> &> (lookupList).sanitize (c, this))))\n+      return_trace (false);\n+\n+#ifndef HB_NO_VAR\n+    if (unlikely (!(version.to_int () < 0x00010001u || featureVars.sanitize (c, this))))\n+      return_trace (false);\n+#endif\n+\n+    return_trace (true);\n+  }\n+\n+  template <typename TLookup>\n+  bool subset (hb_subset_layout_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+\n+    auto *out = c->subset_context->serializer->start_embed (this);\n+    if (unlikely (!c->subset_context->serializer->extend_min (out))) return_trace (false);\n+\n+    out->version = version;\n+\n+    typedef LookupOffsetList<TLookup, typename Types::HBUINT> TLookupList;\n+    reinterpret_cast<typename Types::template OffsetTo<TLookupList> &> (out->lookupList)\n+        .serialize_subset (c->subset_context,\n+                           reinterpret_cast<const typename Types::template OffsetTo<TLookupList> &> (lookupList),\n+                           this,\n+                           c);\n+\n+    reinterpret_cast<typename Types::template OffsetTo<RecordListOfFeature> &> (out->featureList)\n+        .serialize_subset (c->subset_context,\n+                           reinterpret_cast<const typename Types::template OffsetTo<RecordListOfFeature> &> (featureList),\n+                           this,\n+                           c);\n+\n+    out->scriptList.serialize_subset (c->subset_context,\n+                                      scriptList,\n+                                      this,\n+                                      c);\n+\n+#ifndef HB_NO_VAR\n+    if (version.to_int () >= 0x00010001u)\n+    {\n+      auto snapshot = c->subset_context->serializer->snapshot ();\n+      if (!c->subset_context->serializer->extend_min (&out->featureVars))\n+        return_trace (false);\n+\n+      \/\/ TODO(qxliu76): the current implementation doesn't correctly handle feature variations\n+      \/\/                that are dropped by instancing when the associated conditions don't trigger.\n+      \/\/                Since partial instancing isn't yet supported this isn't an issue yet but will\n+      \/\/                need to be fixed for partial instancing.\n+\n+\n+\n+      \/\/ if all axes are pinned all feature vars are dropped.\n+      bool ret = !c->subset_context->plan->all_axes_pinned\n+                 && out->featureVars.serialize_subset (c->subset_context, featureVars, this, c);\n+      if (!ret && version.major == 1)\n+      {\n+        c->subset_context->serializer->revert (snapshot);\n+        out->version.major = 1;\n+        out->version.minor = 0;\n+      }\n+    }\n+#endif\n+\n+    return_trace (true);\n+  }\n@@ -3876,1 +4229,89 @@\n-  bool has_data () const { return version.to_int (); }\n+  unsigned int get_size () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return u.version1.get_size ();\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return u.version2.get_size ();\n+#endif\n+    default: return u.version.static_size;\n+    }\n+  }\n+\n+  template <typename TLookup>\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!u.version.sanitize (c))) return_trace (false);\n+    switch (u.version.major) {\n+    case 1: return_trace (u.version1.sanitize<TLookup> (c));\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return_trace (u.version2.sanitize<TLookup> (c));\n+#endif\n+    default: return_trace (true);\n+    }\n+  }\n+\n+  template <typename TLookup>\n+  bool subset (hb_subset_layout_context_t *c) const\n+  {\n+    switch (u.version.major) {\n+    case 1: return u.version1.subset<TLookup> (c);\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return u.version2.subset<TLookup> (c);\n+#endif\n+    default: return false;\n+    }\n+  }\n+\n+  const ScriptList &get_script_list () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return this+u.version1.scriptList;\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return this+u.version2.scriptList;\n+#endif\n+    default: return Null (ScriptList);\n+    }\n+  }\n+  const FeatureList &get_feature_list () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return this+u.version1.featureList;\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return this+u.version2.featureList;\n+#endif\n+    default: return Null (FeatureList);\n+    }\n+  }\n+  unsigned int get_lookup_count () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return (this+u.version1.lookupList).len;\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return (this+u.version2.lookupList).len;\n+#endif\n+    default: return 0;\n+    }\n+  }\n+  const Lookup& get_lookup (unsigned int i) const\n+  {\n+    switch (u.version.major) {\n+    case 1: return (this+u.version1.lookupList)[i];\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return (this+u.version2.lookupList)[i];\n+#endif\n+    default: return Null (Lookup);\n+    }\n+  }\n+  const FeatureVariations &get_feature_variations () const\n+  {\n+    switch (u.version.major) {\n+    case 1: return (u.version.to_int () >= 0x00010001u ? this+u.version1.featureVars : Null (FeatureVariations));\n+#ifndef HB_NO_BEYOND_64K\n+    case 2: return this+u.version2.featureVars;\n+#endif\n+    default: return Null (FeatureVariations);\n+    }\n+  }\n+\n+  bool has_data () const { return u.version.to_int (); }\n@@ -3878,1 +4319,1 @@\n-  { return (this+scriptList).len; }\n+  { return get_script_list ().len; }\n@@ -3880,1 +4321,1 @@\n-  { return (this+scriptList).get_tag (i); }\n+  { return get_script_list ().get_tag (i); }\n@@ -3884,1 +4325,1 @@\n-  { return (this+scriptList).get_tags (start_offset, script_count, script_tags); }\n+  { return get_script_list ().get_tags (start_offset, script_count, script_tags); }\n@@ -3886,1 +4327,1 @@\n-  { return (this+scriptList)[i]; }\n+  { return get_script_list ()[i]; }\n@@ -3888,1 +4329,1 @@\n-  { return (this+scriptList).find_index (tag, index); }\n+  { return get_script_list ().find_index (tag, index); }\n@@ -3891,1 +4332,1 @@\n-  { return (this+featureList).len; }\n+  { return get_feature_list ().len; }\n@@ -3893,1 +4334,1 @@\n-  { return i == Index::NOT_FOUND_INDEX ? HB_TAG_NONE : (this+featureList).get_tag (i); }\n+  { return i == Index::NOT_FOUND_INDEX ? HB_TAG_NONE : get_feature_list ().get_tag (i); }\n@@ -3897,1 +4338,1 @@\n-  { return (this+featureList).get_tags (start_offset, feature_count, feature_tags); }\n+  { return get_feature_list ().get_tags (start_offset, feature_count, feature_tags); }\n@@ -3899,1 +4340,1 @@\n-  { return (this+featureList)[i]; }\n+  { return get_feature_list ()[i]; }\n@@ -3901,6 +4342,1 @@\n-  { return (this+featureList).find_index (tag, index); }\n-\n-  unsigned int get_lookup_count () const\n-  { return (this+lookupList).len; }\n-  const Lookup& get_lookup (unsigned int i) const\n-  { return (this+lookupList)[i]; }\n+  { return get_feature_list ().find_index (tag, index); }\n@@ -3915,2 +4351,1 @@\n-    return (version.to_int () >= 0x00010001u ? this+featureVars : Null (FeatureVariations))\n-            .find_index (coords, num_coords, index);\n+    return get_feature_variations ().find_index (coords, num_coords, index);\n@@ -3923,1 +4358,1 @@\n-        version.to_int () >= 0x00010001u)\n+        u.version.to_int () >= 0x00010001u)\n@@ -3925,2 +4360,2 @@\n-      const Feature *feature = (this+featureVars).find_substitute (variations_index,\n-                                                                   feature_index);\n+      const Feature *feature = get_feature_variations ().find_substitute (variations_index,\n+                                                                          feature_index);\n@@ -3935,0 +4370,1 @@\n+                                          const hb_hashmap_t<unsigned, const Feature*> *feature_substitutes_map,\n@@ -3938,2 +4374,1 @@\n-    if (version.to_int () >= 0x00010001u)\n-      (this+featureVars).collect_lookups (feature_indexes, lookup_indexes);\n+    get_feature_variations ().collect_lookups (feature_indexes, feature_substitutes_map, lookup_indexes);\n@@ -3943,0 +4378,5 @@\n+#ifndef HB_NO_VAR\n+  void collect_feature_substitutes_with_variations (hb_collect_feature_substitutes_with_var_context_t *c) const\n+  { get_feature_variations ().collect_feature_substitutes_with_variations (c); }\n+#endif\n+\n@@ -3949,1 +4389,1 @@\n-    OT::hb_closure_lookups_context_t c (face, glyphs, &visited_lookups, &inactive_lookups);\n+    hb_closure_lookups_context_t c (face, glyphs, &visited_lookups, &inactive_lookups);\n@@ -3953,1 +4393,1 @@\n-    for (unsigned lookup_index : + hb_iter (lookup_indexes))\n+    for (unsigned lookup_index : *lookup_indexes)\n@@ -3961,0 +4401,1 @@\n+                      const hb_set_t *layout_scripts,\n@@ -3969,0 +4410,2 @@\n+      const Tag& tag = get_script_tag (script_index);\n+      if (!layout_scripts->has (tag)) continue;\n@@ -3974,102 +4417,0 @@\n-  template <typename TLookup>\n-  bool subset (hb_subset_layout_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->subset_context->serializer->embed (*this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    typedef LookupOffsetList<TLookup> TLookupList;\n-    reinterpret_cast<Offset16To<TLookupList> &> (out->lookupList)\n-        .serialize_subset (c->subset_context,\n-                           reinterpret_cast<const Offset16To<TLookupList> &> (lookupList),\n-                           this,\n-                           c);\n-\n-    reinterpret_cast<Offset16To<RecordListOfFeature> &> (out->featureList)\n-        .serialize_subset (c->subset_context,\n-                           reinterpret_cast<const Offset16To<RecordListOfFeature> &> (featureList),\n-                           this,\n-                           c);\n-\n-    out->scriptList.serialize_subset (c->subset_context,\n-                                      scriptList,\n-                                      this,\n-                                      c);\n-\n-#ifndef HB_NO_VAR\n-    if (version.to_int () >= 0x00010001u)\n-    {\n-      bool ret = out->featureVars.serialize_subset (c->subset_context, featureVars, this, c);\n-      if (!ret)\n-      {\n-        out->version.major = 1;\n-        out->version.minor = 0;\n-      }\n-    }\n-#endif\n-\n-    return_trace (true);\n-  }\n-\n-  void find_duplicate_features (const hb_map_t *lookup_indices,\n-                                const hb_set_t *feature_indices,\n-                                hb_map_t *duplicate_feature_map \/* OUT *\/) const\n-  {\n-    if (feature_indices->is_empty ()) return;\n-    hb_hashmap_t<hb_tag_t, hb::unique_ptr<hb_set_t>> unique_features;\n-    \/\/find out duplicate features after subset\n-    for (unsigned i : feature_indices->iter ())\n-    {\n-      hb_tag_t t = get_feature_tag (i);\n-      if (t == HB_MAP_VALUE_INVALID) continue;\n-      if (!unique_features.has (t))\n-      {\n-        if (unlikely (!unique_features.set (t, hb::unique_ptr<hb_set_t> {hb_set_create ()})))\n-          return;\n-        if (unique_features.has (t))\n-          unique_features.get (t)->add (i);\n-        duplicate_feature_map->set (i, i);\n-        continue;\n-      }\n-\n-      bool found = false;\n-\n-      hb_set_t* same_tag_features = unique_features.get (t);\n-      for (unsigned other_f_index : same_tag_features->iter ())\n-      {\n-        const Feature& f = get_feature (i);\n-        const Feature& other_f = get_feature (other_f_index);\n-\n-        auto f_iter =\n-        + hb_iter (f.lookupIndex)\n-        | hb_filter (lookup_indices)\n-        ;\n-\n-        auto other_f_iter =\n-        + hb_iter (other_f.lookupIndex)\n-        | hb_filter (lookup_indices)\n-        ;\n-\n-        bool is_equal = true;\n-        for (; f_iter && other_f_iter; f_iter++, other_f_iter++)\n-        {\n-          unsigned a = *f_iter;\n-          unsigned b = *other_f_iter;\n-          if (a != b) { is_equal = false; break; }\n-        }\n-\n-        if (is_equal == false || f_iter || other_f_iter) continue;\n-\n-        found = true;\n-        duplicate_feature_map->set (i, other_f_index);\n-        break;\n-      }\n-\n-      if (found == false)\n-      {\n-        same_tag_features->add (i);\n-        duplicate_feature_map->set (i, i);\n-      }\n-    }\n-  }\n-\n@@ -4077,0 +4418,2 @@\n+                       const hb_hashmap_t<unsigned, hb::shared_ptr<hb_set_t>> *feature_record_cond_idx_map, \/* IN *\/\n+                       const hb_hashmap_t<unsigned, const Feature*> *feature_substitutes_map, \/* IN *\/\n@@ -4084,2 +4427,1 @@\n-    if (version.to_int () >= 0x00010001u)\n-      (this+featureVars).closure_features (lookup_indices, &alternate_feature_indices);\n+    get_feature_variations ().closure_features (lookup_indices, feature_record_cond_idx_map, &alternate_feature_indices);\n@@ -4093,1 +4435,1 @@\n-    for (unsigned i : feature_indices->iter())\n+    for (unsigned i : hb_iter (feature_indices))\n@@ -4095,1 +4437,0 @@\n-      const Feature& f = get_feature (i);\n@@ -4105,1 +4446,6 @@\n-      if (!f.featureParams.is_null () &&\n+      const Feature *f = &(get_feature (i));\n+      const Feature** p = nullptr;\n+      if (feature_substitutes_map->has (i, &p))\n+        f = *p;\n+\n+      if (!f->featureParams.is_null () &&\n@@ -4109,1 +4455,1 @@\n-      if (!f.intersects_lookup_indexes (lookup_indices)\n+      if (!f->intersects_lookup_indexes (lookup_indices)\n@@ -4118,26 +4464,0 @@\n-  unsigned int get_size () const\n-  {\n-    return min_size +\n-           (version.to_int () >= 0x00010001u ? featureVars.static_size : 0);\n-  }\n-\n-  template <typename TLookup>\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    typedef List16OfOffset16To<TLookup> TLookupList;\n-    if (unlikely (!(version.sanitize (c) &&\n-                    likely (version.major == 1) &&\n-                    scriptList.sanitize (c, this) &&\n-                    featureList.sanitize (c, this) &&\n-                    reinterpret_cast<const Offset16To<TLookupList> &> (lookupList).sanitize (c, this))))\n-      return_trace (false);\n-\n-#ifndef HB_NO_VAR\n-    if (unlikely (!(version.to_int () < 0x00010001u || featureVars.sanitize (c, this))))\n-      return_trace (false);\n-#endif\n-\n-    return_trace (true);\n-  }\n-\n@@ -4158,1 +4478,1 @@\n-      this->accels = (hb_ot_layout_lookup_accelerator_t *) hb_calloc (this->lookup_count, sizeof (hb_ot_layout_lookup_accelerator_t));\n+      this->accels = (hb_atomic_ptr_t<hb_ot_layout_lookup_accelerator_t> *) hb_calloc (this->lookup_count, sizeof (*accels));\n@@ -4165,3 +4485,0 @@\n-\n-      for (unsigned int i = 0; i < this->lookup_count; i++)\n-        this->accels[i].init (table->get_lookup (i));\n@@ -4172,1 +4489,1 @@\n-        this->accels[i].fini ();\n+        hb_free (this->accels[i]);\n@@ -4177,0 +4494,22 @@\n+    hb_ot_layout_lookup_accelerator_t *get_accel (unsigned lookup_index) const\n+    {\n+      if (unlikely (lookup_index >= lookup_count)) return nullptr;\n+\n+    retry:\n+      auto *accel = accels[lookup_index].get_acquire ();\n+      if (unlikely (!accel))\n+      {\n+        accel = hb_ot_layout_lookup_accelerator_t::create (table->get_lookup (lookup_index));\n+        if (unlikely (!accel))\n+          return nullptr;\n+\n+        if (unlikely (!accels[lookup_index].cmpexch (nullptr, accel)))\n+        {\n+          hb_free (accel);\n+          goto retry;\n+        }\n+      }\n+\n+      return accel;\n+    }\n+\n@@ -4179,1 +4518,1 @@\n-    hb_ot_layout_lookup_accelerator_t *accels;\n+    hb_atomic_ptr_t<hb_ot_layout_lookup_accelerator_t> *accels;\n@@ -4183,13 +4522,7 @@\n-  FixedVersion<>version;        \/* Version of the GSUB\/GPOS table--initially set\n-                                 * to 0x00010000u *\/\n-  Offset16To<ScriptList>\n-                scriptList;     \/* ScriptList table *\/\n-  Offset16To<FeatureList>\n-                featureList;    \/* FeatureList table *\/\n-  Offset16To<LookupList>\n-                lookupList;     \/* LookupList table *\/\n-  Offset32To<FeatureVariations>\n-                featureVars;    \/* Offset to Feature Variations\n-                                   table--from beginning of table\n-                                 * (may be NULL).  Introduced\n-                                 * in version 0x00010001. *\/\n+  union {\n+  FixedVersion<>                        version;        \/* Version identifier *\/\n+  GSUBGPOSVersion1_2<SmallTypes>        version1;\n+#ifndef HB_NO_BEYOND_64K\n+  GSUBGPOSVersion1_2<MediumTypes>       version2;\n+#endif\n+  } u;\n@@ -4197,1 +4530,1 @@\n-  DEFINE_SIZE_MIN (10);\n+  DEFINE_SIZE_MIN (4);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-gsubgpos.hh","additions":852,"deletions":519,"binary":false,"changes":1371,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-using OT::Layout::GSUB::GSUB;\n+using OT::Layout::GSUB;\n@@ -82,1 +82,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -98,1 +98,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -118,1 +118,1 @@\n- * Return value: %true is data found, %false otherwise\n+ * Return value: `true` is data found, `false` otherwise\n@@ -275,1 +275,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -464,1 +464,1 @@\n- * Return value: %true if the script is found, %false otherwise\n+ * Return value: `true` if the script is found, `false` otherwise\n@@ -503,2 +503,2 @@\n- * @script_index: (out): The index of the requested script tag\n- * @chosen_script: (out): #hb_tag_t of the script tag requested\n+ * @script_index: (out): The index of the chosen script\n+ * @chosen_script: (out): #hb_tag_t of the chosen script\n@@ -534,2 +534,2 @@\n- * have any of these scripts, @script_index and @chosen_script are set to\n- * #HB_OT_LAYOUT_NO_SCRIPT_INDEX.\n+ * have any of these scripts, @script_index is set to\n+ * #HB_OT_LAYOUT_NO_SCRIPT_INDEX and @chosen_script is set to #HB_TAG_NONE.\n@@ -538,1 +538,1 @@\n- * %true if one of the requested scripts is selected, %false if a fallback\n+ * `true` if one of the requested scripts is selected, `false` if a fallback\n@@ -589,1 +589,1 @@\n-    *chosen_script = HB_OT_LAYOUT_NO_SCRIPT_INDEX;\n+    *chosen_script = HB_TAG_NONE;\n@@ -604,0 +604,2 @@\n+ * Note that there might be duplicate feature tags, belonging to different\n+ * script\/language-system pairs of the table.\n@@ -607,0 +609,2 @@\n+ * Since: 0.6.0\n+ *\n@@ -631,1 +635,4 @@\n- * Return value: %true if the feature is found, %false otherwise\n+ * Return value: `true` if the feature is found, `false` otherwise\n+ *\n+ * Since: 0.6.0\n+ *\n@@ -671,0 +678,2 @@\n+ * Since: 0.6.0\n+ *\n@@ -698,1 +707,1 @@\n- * Return value: %true if the language tag is found, %false otherwise\n+ * Return value: `true` if the language tag is found, `false` otherwise\n@@ -721,1 +730,1 @@\n- * hb_ot_layout_script_select_language:\n+ * hb_ot_layout_script_select_language2:\n@@ -727,1 +736,2 @@\n- * @language_index: (out): The index of the requested language\n+ * @language_index: (out): The index of the chosen language\n+ * @chosen_language: (out): #hb_tag_t of the chosen language\n@@ -733,2 +743,3 @@\n- * If none of the given language tags is found, %false is returned and\n- * @language_index is set to the default language index.\n+ * If none of the given language tags is found, `false` is returned and\n+ * @language_index is set to #HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX and\n+ * @chosen_language is set to #HB_TAG_NONE.\n@@ -736,1 +747,1 @@\n- * Return value: %true if one of the given language tags is found, %false otherwise\n+ * Return value: `true` if one of the given language tags is found, `false` otherwise\n@@ -738,1 +749,1 @@\n- * Since: 2.0.0\n+ * Since: 7.0.0\n@@ -741,1 +752,1 @@\n-hb_ot_layout_script_select_language (hb_face_t      *face,\n+hb_ot_layout_script_select_language2 (hb_face_t      *face,\n@@ -746,1 +757,2 @@\n-                                     unsigned int   *language_index \/* OUT *\/)\n+                                     unsigned int   *language_index \/* OUT *\/,\n+                                     hb_tag_t       *chosen_language \/* OUT *\/)\n@@ -755,0 +767,3 @@\n+    {\n+      if (chosen_language)\n+        *chosen_language = language_tags[i];\n@@ -756,0 +771,1 @@\n+    }\n@@ -760,0 +776,3 @@\n+  {\n+    if (chosen_language)\n+      *chosen_language = HB_OT_TAG_DEFAULT_LANGUAGE;\n@@ -761,0 +780,1 @@\n+  }\n@@ -764,0 +784,2 @@\n+  if (chosen_language)\n+    *chosen_language = HB_TAG_NONE;\n@@ -767,0 +789,33 @@\n+\/**\n+ * hb_ot_layout_script_select_language:\n+ * @face: #hb_face_t to work upon\n+ * @table_tag: #HB_OT_TAG_GSUB or #HB_OT_TAG_GPOS\n+ * @script_index: The index of the requested script tag\n+ * @language_count: The number of languages in the specified script\n+ * @language_tags: The array of language tags\n+ * @language_index: (out): The index of the requested language\n+ *\n+ * Fetches the index of the first language tag fom @language_tags that is present\n+ * in the specified face's GSUB or GPOS table, underneath the specified script\n+ * index.\n+ *\n+ * If none of the given language tags is found, `false` is returned and\n+ * @language_index is set to the default language index.\n+ *\n+ * Return value: `true` if one of the given language tags is found, `false` otherwise\n+ *\n+ * Since: 2.0.0\n+ **\/\n+hb_bool_t\n+hb_ot_layout_script_select_language (hb_face_t      *face,\n+                                     hb_tag_t        table_tag,\n+                                     unsigned int    script_index,\n+                                     unsigned int    language_count,\n+                                     const hb_tag_t *language_tags,\n+                                     unsigned int   *language_index \/* OUT *\/)\n+{\n+  return hb_ot_layout_script_select_language2 (face, table_tag,\n+                                               script_index,\n+                                               language_count, language_tags,\n+                                               language_index, nullptr);\n+}\n@@ -779,1 +834,3 @@\n- * Return value: %true if the feature is found, %false otherwise\n+ * Return value: `true` if the feature is found, `false` otherwise\n+ *\n+ * Since: 0.6.0\n@@ -810,1 +867,1 @@\n- * Return value: %true if the feature is found, %false otherwise\n+ * Return value: `true` if the feature is found, `false` otherwise\n@@ -849,0 +906,3 @@\n+ *\n+ * Since: 0.6.0\n+ *\n@@ -882,0 +942,3 @@\n+ *\n+ * Since: 0.6.0\n+ *\n@@ -920,1 +983,3 @@\n- * Return value: %true if the feature is found, %false otherwise\n+ * Return value: `true` if the feature is found, `false` otherwise\n+ *\n+ * Since: 0.6.0\n@@ -1170,3 +1235,6 @@\n- * @scripts: The array of scripts to collect features for\n- * @languages: The array of languages to collect features for\n- * @features: The array of features to collect\n+ * @scripts: (nullable) (array zero-terminated=1): The array of scripts to collect features for,\n+ *   terminated by %HB_TAG_NONE\n+ * @languages: (nullable) (array zero-terminated=1): The array of languages to collect features for,\n+ *   terminated by %HB_TAG_NONE\n+ * @features: (nullable) (array zero-terminated=1): The array of features to collect,\n+ *   terminated by %HB_TAG_NONE\n@@ -1219,3 +1287,6 @@\n- * @scripts: The array of scripts to collect lookups for\n- * @languages: The array of languages to collect lookups for\n- * @features: The array of features to collect lookups for\n+ * @scripts: (nullable) (array zero-terminated=1): The array of scripts to collect lookups for,\n+ *   terminated by %HB_TAG_NONE\n+ * @languages: (nullable) (array zero-terminated=1): The array of languages to collect lookups for,\n+ *   terminated by %HB_TAG_NONE\n+ * @features: (nullable) (array zero-terminated=1): The array of features to collect lookups for,\n+ *   terminated by %HB_TAG_NONE\n@@ -1249,1 +1320,1 @@\n-  g.feature_variation_collect_lookups (&feature_indexes, lookup_indexes);\n+  g.feature_variation_collect_lookups (&feature_indexes, nullptr, lookup_indexes);\n@@ -1317,1 +1388,3 @@\n- * Return value: %true if feature variations were found, %false otherwise.\n+ * Return value: `true` if feature variations were found, `false` otherwise.\n+ *\n+ * Since: 1.4.0\n@@ -1350,0 +1423,2 @@\n+ * Since: 1.4.0\n+ *\n@@ -1380,1 +1455,3 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n+ *\n+ * Since: 0.6.0\n@@ -1402,1 +1479,1 @@\n- * Return value: %true if a substitution would be triggered, %false otherwise\n+ * Return value: `true` if a substitution would be triggered, `false` otherwise\n@@ -1413,1 +1490,2 @@\n-  if (unlikely (lookup_index >= face->table.GSUB->lookup_count)) return false;\n+  auto &gsub = face->table.GSUB;\n+  if (unlikely (lookup_index >= gsub->lookup_count)) return false;\n@@ -1416,2 +1494,3 @@\n-  const OT::SubstLookup& l = face->table.GSUB->table->get_lookup (lookup_index);\n-  return l.would_apply (&c, &face->table.GSUB->accels[lookup_index]);\n+  const OT::SubstLookup& l = gsub->table->get_lookup (lookup_index);\n+  auto *accel = gsub->get_accel (lookup_index);\n+  return accel && l.would_apply (&c, accel);\n@@ -1437,50 +1516,0 @@\n-void\n-hb_ot_layout_delete_glyphs_inplace (hb_buffer_t *buffer,\n-                                    bool (*filter) (const hb_glyph_info_t *info))\n-{\n-  \/* Merge clusters and delete filtered glyphs.\n-   * NOTE! We can't use out-buffer as we have positioning data. *\/\n-  unsigned int j = 0;\n-  unsigned int count = buffer->len;\n-  hb_glyph_info_t *info = buffer->info;\n-  hb_glyph_position_t *pos = buffer->pos;\n-  for (unsigned int i = 0; i < count; i++)\n-  {\n-    if (filter (&info[i]))\n-    {\n-      \/* Merge clusters.\n-       * Same logic as buffer->delete_glyph(), but for in-place removal. *\/\n-\n-      unsigned int cluster = info[i].cluster;\n-      if (i + 1 < count && cluster == info[i + 1].cluster)\n-        continue; \/* Cluster survives; do nothing. *\/\n-\n-      if (j)\n-      {\n-        \/* Merge cluster backward. *\/\n-        if (cluster < info[j - 1].cluster)\n-        {\n-          unsigned int mask = info[i].mask;\n-          unsigned int old_cluster = info[j - 1].cluster;\n-          for (unsigned k = j; k && info[k - 1].cluster == old_cluster; k--)\n-            buffer->set_cluster (info[k - 1], cluster, mask);\n-        }\n-        continue;\n-      }\n-\n-      if (i + 1 < count)\n-        buffer->merge_clusters (i, i + 2); \/* Merge cluster forward. *\/\n-\n-      continue;\n-    }\n-\n-    if (j != i)\n-    {\n-      info[j] = info[i];\n-      pos[j] = pos[i];\n-    }\n-    j++;\n-  }\n-  buffer->len = j;\n-}\n-\n@@ -1564,1 +1593,1 @@\n- * Return value: %true if the face has GPOS data, %false otherwise\n+ * Return value: `true` if the face has GPOS data, `false` otherwise\n@@ -1637,1 +1666,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -1681,0 +1710,2 @@\n+\n+\n@@ -1701,1 +1732,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -1804,2 +1835,1 @@\n-    table (*face->table.GSUB->table),\n-    accels (face->table.GSUB->accels) {}\n+    accel (*face->table.GSUB) {}\n@@ -1807,2 +1837,1 @@\n-  const GSUB &table;\n-  const OT::hb_ot_layout_lookup_accelerator_t *accels;\n+  const GSUB::accelerator_t &accel;\n@@ -1818,2 +1847,1 @@\n-    table (*face->table.GPOS->table),\n-    accels (face->table.GPOS->accels) {}\n+    accel (*face->table.GPOS) {}\n@@ -1821,2 +1849,1 @@\n-  const GPOS &table;\n-  const OT::hb_ot_layout_lookup_accelerator_t *accels;\n+  const GPOS::accelerator_t &accel;\n@@ -1828,1 +1855,2 @@\n-               const OT::hb_ot_layout_lookup_accelerator_t &accel)\n+               const OT::hb_ot_layout_lookup_accelerator_t &accel,\n+               unsigned subtable_count)\n@@ -1837,1 +1865,1 @@\n-    if (accel.may_have (buffer->cur().codepoint) &&\n+    if (accel.digest.may_have (buffer->cur().codepoint) &&\n@@ -1841,1 +1869,1 @@\n-       applied = accel.apply (c, use_cache);\n+       applied = accel.apply (c, subtable_count, use_cache);\n@@ -1858,1 +1886,2 @@\n-               const OT::hb_ot_layout_lookup_accelerator_t &accel)\n+               const OT::hb_ot_layout_lookup_accelerator_t &accel,\n+               unsigned subtable_count)\n@@ -1864,1 +1893,1 @@\n-    if (accel.may_have (buffer->cur().codepoint) &&\n+    if (accel.digest.may_have (buffer->cur().codepoint) &&\n@@ -1867,1 +1896,1 @@\n-     ret |= accel.apply (c, false);\n+     ret |= accel.apply (c, subtable_count, false);\n@@ -1878,1 +1907,1 @@\n-static inline void\n+static inline bool\n@@ -1884,0 +1913,1 @@\n+  unsigned subtable_count = lookup.get_subtable_count ();\n@@ -1886,1 +1916,3 @@\n-    return;\n+    return false;\n+\n+  bool ret = false;\n@@ -1897,1 +1929,1 @@\n-    apply_forward (c, accel);\n+    ret = apply_forward (c, accel, subtable_count);\n@@ -1907,1 +1939,1 @@\n-    apply_backward (c, accel);\n+    ret = apply_backward (c, accel, subtable_count);\n@@ -1909,0 +1941,2 @@\n+\n+  return ret;\n@@ -1927,13 +1961,32 @@\n-      unsigned int lookup_index = lookups[table_index][i].index;\n-      if (!buffer->message (font, \"start lookup %d\", lookup_index)) continue;\n-      c.set_lookup_index (lookup_index);\n-      c.set_lookup_mask (lookups[table_index][i].mask);\n-      c.set_auto_zwj (lookups[table_index][i].auto_zwj);\n-      c.set_auto_zwnj (lookups[table_index][i].auto_zwnj);\n-      c.set_random (lookups[table_index][i].random);\n-      c.set_per_syllable (lookups[table_index][i].per_syllable);\n-\n-      apply_string<Proxy> (&c,\n-                           proxy.table.get_lookup (lookup_index),\n-                           proxy.accels[lookup_index]);\n-      (void) buffer->message (font, \"end lookup %d\", lookup_index);\n+      auto &lookup = lookups[table_index][i];\n+\n+      unsigned int lookup_index = lookup.index;\n+\n+      auto *accel = proxy.accel.get_accel (lookup_index);\n+      if (unlikely (!accel)) continue;\n+\n+      if (buffer->messaging () &&\n+          !buffer->message (font, \"start lookup %u feature '%c%c%c%c'\", lookup_index, HB_UNTAG (lookup.feature_tag))) continue;\n+\n+      \/* c.digest is a digest of all the current glyphs in the buffer\n+       * (plus some past glyphs).\n+       *\n+       * Only try applying the lookup if there is any overlap. *\/\n+      if (accel->digest.may_have (c.digest))\n+      {\n+        c.set_lookup_index (lookup_index);\n+        c.set_lookup_mask (lookup.mask);\n+        c.set_auto_zwj (lookup.auto_zwj);\n+        c.set_auto_zwnj (lookup.auto_zwnj);\n+        c.set_random (lookup.random);\n+        c.set_per_syllable (lookup.per_syllable);\n+\n+        apply_string<Proxy> (&c,\n+                             proxy.accel.table->get_lookup (lookup_index),\n+                             *accel);\n+      }\n+      else if (buffer->messaging ())\n+        (void) buffer->message (font, \"skipped lookup %u feature '%c%c%c%c' because no glyph matches\", lookup_index, HB_UNTAG (lookup.feature_tag));\n+\n+      if (buffer->messaging ())\n+        (void) buffer->message (font, \"end lookup %u feature '%c%c%c%c'\", lookup_index, HB_UNTAG (lookup.feature_tag));\n@@ -1943,1 +1996,7 @@\n-      stage->pause_func (plan, font, buffer);\n+    {\n+      if (stage->pause_func (plan, font, buffer))\n+      {\n+        \/* Refresh working buffer digest since buffer changed. *\/\n+        c.digest = buffer->digest ();\n+      }\n+    }\n@@ -1950,1 +2009,2 @@\n-  if (!buffer->message (font, \"start table GSUB\")) return;\n+  if (buffer->messaging () &&\n+      !buffer->message (font, \"start table GSUB\")) return;\n@@ -1952,1 +2012,2 @@\n-  (void) buffer->message (font, \"end table GSUB\");\n+  if (buffer->messaging ())\n+    (void) buffer->message (font, \"end table GSUB\");\n@@ -1958,1 +2019,2 @@\n-  if (!buffer->message (font, \"start table GPOS\")) return;\n+  if (buffer->messaging () &&\n+      !buffer->message (font, \"start table GPOS\")) return;\n@@ -1960,1 +2022,2 @@\n-  (void) buffer->message (font, \"end table GPOS\");\n+  if (buffer->messaging ())\n+    (void) buffer->message (font, \"end table GPOS\");\n@@ -2054,1 +2117,1 @@\n- * Return value: %true if found baseline value in the font.\n+ * Return value: `true` if found baseline value in the font.\n@@ -2300,5 +2363,0 @@\n-  hb_face_t *face;\n-\n-  hb_get_glyph_alternates_dispatch_t (hb_face_t *face) :\n-                                        face (face) {}\n-\n@@ -2318,0 +2376,1 @@\n+#ifndef HB_NO_LAYOUT_RARELY_USED\n@@ -2343,1 +2402,1 @@\n-  hb_get_glyph_alternates_dispatch_t c (face);\n+  hb_get_glyph_alternates_dispatch_t c;\n@@ -2350,0 +2409,68 @@\n+\n+struct hb_position_single_dispatch_t :\n+       hb_dispatch_context_t<hb_position_single_dispatch_t, bool>\n+{\n+  static return_t default_return_value () { return false; }\n+  bool stop_sublookup_iteration (return_t r) const { return r; }\n+\n+  private:\n+  template <typename T, typename ...Ts> auto\n+  _dispatch (const T &obj, hb_priority<1>, Ts&&... ds) HB_AUTO_RETURN\n+  ( obj.position_single (std::forward<Ts> (ds)...) )\n+  template <typename T, typename ...Ts> auto\n+  _dispatch (const T &obj, hb_priority<0>, Ts&&... ds) HB_AUTO_RETURN\n+  ( default_return_value () )\n+  public:\n+  template <typename T, typename ...Ts> auto\n+  dispatch (const T &obj, Ts&&... ds) HB_AUTO_RETURN\n+  ( _dispatch (obj, hb_prioritize, std::forward<Ts> (ds)...) )\n+};\n+\n+\/**\n+ * hb_ot_layout_lookup_get_optical_bound:\n+ * @font: a font.\n+ * @lookup_index: index of the feature lookup to query.\n+ * @direction: edge of the glyph to query.\n+ * @glyph: a glyph id.\n+ *\n+ * Fetches the optical bound of a glyph positioned at the margin of text.\n+ * The direction identifies which edge of the glyph to query.\n+ *\n+ * Return value: Adjustment value. Negative values mean the glyph will stick out of the margin.\n+ *\n+ * Since: 5.3.0\n+ **\/\n+hb_position_t\n+hb_ot_layout_lookup_get_optical_bound (hb_font_t      *font,\n+                                       unsigned        lookup_index,\n+                                       hb_direction_t  direction,\n+                                       hb_codepoint_t  glyph)\n+{\n+  const OT::PosLookup &lookup = font->face->table.GPOS->table->get_lookup (lookup_index);\n+  hb_glyph_position_t pos = {0};\n+  hb_position_single_dispatch_t c;\n+  lookup.dispatch (&c, font, direction, glyph, pos);\n+  hb_position_t ret = 0;\n+  switch (direction)\n+  {\n+    case HB_DIRECTION_LTR:\n+      ret = pos.x_offset;\n+      break;\n+    case HB_DIRECTION_RTL:\n+      ret = pos.x_advance - pos.x_offset;\n+      break;\n+    case HB_DIRECTION_TTB:\n+      ret = pos.y_offset;\n+      break;\n+    case HB_DIRECTION_BTT:\n+      ret = pos.y_advance - pos.y_offset;\n+      break;\n+    case HB_DIRECTION_INVALID:\n+    default:\n+      break;\n+  }\n+  return ret;\n+}\n+#endif\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout.cc","additions":261,"deletions":134,"binary":false,"changes":395,"status":"modified"},{"patch":"@@ -257,0 +257,9 @@\n+HB_EXTERN hb_bool_t\n+hb_ot_layout_script_select_language2 (hb_face_t      *face,\n+                                     hb_tag_t        table_tag,\n+                                     unsigned int    script_index,\n+                                     unsigned int    language_count,\n+                                     const hb_tag_t *language_tags,\n+                                     unsigned int   *language_index \/* OUT *\/,\n+                                     hb_tag_t       *chosen_language \/* OUT *\/);\n+\n@@ -406,0 +415,10 @@\n+HB_EXTERN hb_position_t\n+hb_ot_layout_lookup_get_optical_bound (hb_font_t      *font,\n+                                       unsigned        lookup_index,\n+                                       hb_direction_t  direction,\n+                                       hb_codepoint_t  glyph);\n+\n+\n+\/*\n+ * GSUB\/GPOS\n+ *\/\n@@ -426,0 +445,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout.h","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -105,4 +105,0 @@\n-HB_INTERNAL void\n-hb_ot_layout_delete_glyphs_inplace (hb_buffer_t *buffer,\n-                                    bool (*filter) (const hb_glyph_info_t *info));\n-\n@@ -113,1 +109,1 @@\n-namespace GSUB {\n+namespace GSUB_impl {\n@@ -121,1 +117,1 @@\n-                                const OT::Layout::GSUB::SubstLookup &lookup,\n+                                const OT::Layout::GSUB_impl::SubstLookup &lookup,\n@@ -555,1 +551,1 @@\n-static inline void\n+static inline bool\n@@ -564,0 +560,1 @@\n+  return false;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout.hh","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-                                          const hb_segment_properties_t *props_)\n+                                          const hb_segment_properties_t &props_)\n@@ -48,1 +48,1 @@\n-  memset (this, 0, sizeof (*this));\n+  hb_memset (this, 0, sizeof (*this));\n@@ -55,1 +55,1 @@\n-  props = *props_;\n+  props = props_;\n@@ -112,0 +112,15 @@\n+bool hb_ot_map_builder_t::has_feature (hb_tag_t tag)\n+{\n+  for (unsigned int table_index = 0; table_index < 2; table_index++)\n+  {\n+    if (hb_ot_layout_language_find_feature (face,\n+                                            table_tags[table_index],\n+                                            script_index[table_index],\n+                                            language_index[table_index],\n+                                            tag,\n+                                            nullptr))\n+      return true;\n+  }\n+  return false;\n+}\n+\n@@ -121,1 +136,2 @@\n-                                  bool          per_syllable)\n+                                  bool          per_syllable,\n+                                  hb_tag_t      feature_tag)\n@@ -150,0 +166,1 @@\n+      lookup->feature_tag = feature_tag;\n@@ -200,0 +217,1 @@\n+    auto *f = feature_infos.arrayZ;\n@@ -201,3 +219,4 @@\n-    for (unsigned int i = 1; i < feature_infos.length; i++)\n-      if (feature_infos[i].tag != feature_infos[j].tag)\n-        feature_infos[++j] = feature_infos[i];\n+    unsigned count = feature_infos.length;\n+    for (unsigned int i = 1; i < count; i++)\n+      if (f[i].tag != f[j].tag)\n+        f[++j] = f[i];\n@@ -205,4 +224,4 @@\n-        if (feature_infos[i].flags & F_GLOBAL) {\n-          feature_infos[j].flags |= F_GLOBAL;\n-          feature_infos[j].max_value = feature_infos[i].max_value;\n-          feature_infos[j].default_value = feature_infos[i].default_value;\n+        if (f[i].flags & F_GLOBAL) {\n+          f[j].flags |= F_GLOBAL;\n+          f[j].max_value = f[i].max_value;\n+          f[j].default_value = f[i].default_value;\n@@ -210,3 +229,3 @@\n-          if (feature_infos[j].flags & F_GLOBAL)\n-            feature_infos[j].flags ^= F_GLOBAL;\n-          feature_infos[j].max_value = hb_max (feature_infos[j].max_value, feature_infos[i].max_value);\n+          if (f[j].flags & F_GLOBAL)\n+            f[j].flags ^= F_GLOBAL;\n+          f[j].max_value = hb_max (f[j].max_value, f[i].max_value);\n@@ -215,3 +234,3 @@\n-        feature_infos[j].flags |= (feature_infos[i].flags & F_HAS_FALLBACK);\n-        feature_infos[j].stage[0] = hb_min (feature_infos[j].stage[0], feature_infos[i].stage[0]);\n-        feature_infos[j].stage[1] = hb_min (feature_infos[j].stage[1], feature_infos[i].stage[1]);\n+        f[j].flags |= (f[i].flags & F_HAS_FALLBACK);\n+        f[j].stage[0] = hb_min (f[j].stage[0], f[i].stage[0]);\n+        f[j].stage[1] = hb_min (f[j].stage[1], f[i].stage[1]);\n@@ -227,1 +246,2 @@\n-  for (unsigned int i = 0; i < feature_infos.length; i++)\n+  unsigned count = feature_infos.length;\n+  for (unsigned int i = 0; i < count; i++)\n@@ -296,1 +316,1 @@\n-  feature_infos.shrink (0); \/* Done with these *\/\n+  \/\/feature_infos.shrink (0); \/* Done with these *\/\n@@ -305,0 +325,1 @@\n+    auto &lookups = m.lookups[table_index];\n@@ -317,2 +338,3 @@\n-      for (unsigned i = 0; i < m.features.length; i++)\n-        if (m.features[i].stage[table_index] == stage)\n+      for (auto &feature : m.features)\n+      {\n+        if (feature.stage[table_index] == stage)\n@@ -320,1 +342,1 @@\n-                       m.features[i].index[table_index],\n+                       feature.index[table_index],\n@@ -322,5 +344,7 @@\n-                       m.features[i].mask,\n-                       m.features[i].auto_zwnj,\n-                       m.features[i].auto_zwj,\n-                       m.features[i].random,\n-                       m.features[i].per_syllable);\n+                       feature.mask,\n+                       feature.auto_zwnj,\n+                       feature.auto_zwj,\n+                       feature.random,\n+                       feature.per_syllable,\n+                       feature.tag);\n+      }\n@@ -329,1 +353,1 @@\n-      if (last_num_lookups < m.lookups[table_index].length)\n+      if (last_num_lookups < lookups.length)\n@@ -331,1 +355,1 @@\n-        m.lookups[table_index].qsort (last_num_lookups, m.lookups[table_index].length);\n+        lookups.as_array ().sub_array (last_num_lookups, lookups.length - last_num_lookups).qsort ();\n@@ -334,3 +358,3 @@\n-        for (unsigned int i = j + 1; i < m.lookups[table_index].length; i++)\n-          if (m.lookups[table_index][i].index != m.lookups[table_index][j].index)\n-            m.lookups[table_index][++j] = m.lookups[table_index][i];\n+        for (unsigned int i = j + 1; i < lookups.length; i++)\n+          if (lookups.arrayZ[i].index != lookups.arrayZ[j].index)\n+            lookups.arrayZ[++j] = lookups.arrayZ[i];\n@@ -339,3 +363,3 @@\n-            m.lookups[table_index][j].mask |= m.lookups[table_index][i].mask;\n-            m.lookups[table_index][j].auto_zwnj &= m.lookups[table_index][i].auto_zwnj;\n-            m.lookups[table_index][j].auto_zwj &= m.lookups[table_index][i].auto_zwj;\n+            lookups.arrayZ[j].mask |= lookups.arrayZ[i].mask;\n+            lookups.arrayZ[j].auto_zwnj &= lookups.arrayZ[i].auto_zwnj;\n+            lookups.arrayZ[j].auto_zwj &= lookups.arrayZ[i].auto_zwj;\n@@ -343,1 +367,1 @@\n-        m.lookups[table_index].shrink (j + 1);\n+        lookups.shrink (j + 1);\n@@ -346,1 +370,1 @@\n-      last_num_lookups = m.lookups[table_index].length;\n+      last_num_lookups = lookups.length;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-map.cc","additions":61,"deletions":37,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+    hb_tag_t feature_tag;\n@@ -81,1 +82,3 @@\n-  typedef void (*pause_func_t) (const struct hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer);\n+  \/* Pause functions return true if new glyph indices might have been\n+   * added to the buffer.  This is used to update buffer digest. *\/\n+  typedef bool (*pause_func_t) (const struct hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer);\n@@ -90,1 +93,1 @@\n-    memset (this, 0, sizeof (*this));\n+    hb_memset (this, 0, sizeof (*this));\n@@ -92,1 +95,1 @@\n-    features.init ();\n+    features.init0 ();\n@@ -95,2 +98,2 @@\n-      lookups[table_index].init ();\n-      stages[table_index].init ();\n+      lookups[table_index].init0 ();\n+      stages[table_index].init0 ();\n@@ -142,2 +145,2 @@\n-  void get_stage_lookups (unsigned int table_index, unsigned int stage,\n-                          const struct lookup_map_t **plookups, unsigned int *lookup_count) const\n+  hb_array_t<const hb_ot_map_t::lookup_map_t>\n+  get_stage_lookups (unsigned int table_index, unsigned int stage) const\n@@ -146,5 +149,2 @@\n-    {\n-      *plookups = nullptr;\n-      *lookup_count = 0;\n-      return;\n-    }\n+      return hb_array<const hb_ot_map_t::lookup_map_t> (nullptr, 0);\n+\n@@ -153,2 +153,1 @@\n-    *plookups = end == start ? nullptr : &lookups[table_index][start];\n-    *lookup_count = end - start;\n+    return lookups[table_index].as_array ().sub_array (start, end - start);\n@@ -170,1 +169,1 @@\n-  hb_mask_t global_mask;\n+  hb_mask_t global_mask = 0;\n@@ -207,1 +206,1 @@\n-                                   const hb_segment_properties_t *props_);\n+                                   const hb_segment_properties_t &props_);\n@@ -215,0 +214,2 @@\n+  HB_INTERNAL bool has_feature (hb_tag_t tag);\n+\n@@ -244,1 +245,2 @@\n-                                bool          per_syllable = false);\n+                                bool          per_syllable = false,\n+                                hb_tag_t      feature_tag = HB_TAG(' ',' ',' ',' '));\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-map.hh","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    memcpy (p, percentScaleDown, HBINT16::static_size * 2);\n+    hb_memcpy (p, percentScaleDown, HBINT16::static_size * 2);\n@@ -84,1 +84,1 @@\n-    memcpy (m, minHeight, HBUINT16::static_size * 2);\n+    hb_memcpy (m, minHeight, HBUINT16::static_size * 2);\n@@ -204,1 +204,1 @@\n-    const hb_set_t &glyphset = *c->plan->_glyphset_mathed;\n+    const hb_set_t &glyphset = c->plan->_glyphset_mathed;\n@@ -257,1 +257,1 @@\n-    const hb_set_t &glyphset = *c->plan->_glyphset_mathed;\n+    const hb_set_t &glyphset = c->plan->_glyphset_mathed;\n@@ -489,1 +489,1 @@\n-    const hb_set_t &glyphset = *c->plan->_glyphset_mathed;\n+    const hb_set_t &glyphset = c->plan->_glyphset_mathed;\n@@ -570,1 +570,1 @@\n-    const hb_set_t &glyphset = *c->plan->_glyphset_mathed;\n+    const hb_set_t &glyphset = c->plan->_glyphset_mathed;\n@@ -789,1 +789,1 @@\n-      for (auto _ : hb_zip (partRecords.sub_array (start_offset, parts_count),\n+      for (auto _ : hb_zip (partRecords.as_array ().sub_array (start_offset, parts_count),\n@@ -858,1 +858,1 @@\n-      for (auto _ : hb_zip (mathGlyphVariantRecord.sub_array (start_offset, variants_count),\n+      for (auto _ : hb_zip (mathGlyphVariantRecord.as_array ().sub_array (start_offset, variants_count),\n@@ -941,1 +941,1 @@\n-    const hb_set_t &glyphset = *c->plan->_glyphset_mathed;\n+    const hb_set_t &glyphset = c->plan->_glyphset_mathed;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-math-table.hh","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n- * Return value: %true if the table is found, %false otherwise\n+ * Return value: `true` if the table is found, `false` otherwise\n@@ -145,1 +145,1 @@\n- * Return value: %true if the glyph is an extended shape, %false otherwise\n+ * Return value: `true` if the glyph is an extended shape, `false` otherwise\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-math.cc","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -112,0 +112,3 @@\n+\n+      if (c->plan->normalized_coords)\n+        instancing_update_fields (c->plan->head_maxp_info, dest_v1);\n@@ -117,0 +120,10 @@\n+  void instancing_update_fields (head_maxp_info_t& maxp_info, maxpV1Tail* dest_v1) const\n+  {\n+    dest_v1->maxPoints = maxp_info.maxPoints;\n+    dest_v1->maxContours = maxp_info.maxContours;\n+    dest_v1->maxCompositePoints = maxp_info.maxCompositePoints;\n+    dest_v1->maxCompositeContours = maxp_info.maxCompositeContours;\n+    dest_v1->maxComponentElements = maxp_info.maxComponentElements;\n+    dest_v1->maxComponentDepth = maxp_info.maxComponentDepth;\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-maxp-table.hh","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-        + table->dataMaps.sub_array (start_offset, count)\n+        + table->dataMaps.as_array ().sub_array (start_offset, count)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-meta-table.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n-    (position && (*position = font->em_scalef_x (_fix_ascender_descender ( \\\n-      face->table.TABLE->ATTR + GET_VAR, metrics_tag))), true))\n+    ((void) (position && (*position = font->em_scalef_x (_fix_ascender_descender ( \\\n+      face->table.TABLE->ATTR + GET_VAR, metrics_tag)))), true))\n@@ -78,2 +78,2 @@\n-    (position && (*position = font->em_scalef_y (_fix_ascender_descender ( \\\n-      face->table.TABLE->ATTR + GET_VAR, metrics_tag))), true))\n+    ((void) (position && (*position = font->em_scalef_y (_fix_ascender_descender ( \\\n+      face->table.TABLE->ATTR + GET_VAR, metrics_tag)))), true))\n@@ -157,1 +157,1 @@\n-    (position && (*position = font->em_scalef_x (face->table.TABLE->ATTR + GET_VAR)), true))\n+    ((void) (position && (*position = font->em_scalef_x (face->table.TABLE->ATTR + GET_VAR))), true))\n@@ -160,1 +160,1 @@\n-    (position && (*position = font->em_scalef_y (face->table.TABLE->ATTR + GET_VAR)), true))\n+    ((void) (position && (*position = font->em_scalef_y (face->table.TABLE->ATTR + GET_VAR))), true))\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-metrics.cc","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,375 +30,1 @@\n-#include \"hb-open-type.hh\"\n-#include \"hb-ot-name-language.hh\"\n-#include \"hb-aat-layout.hh\"\n-\n-\n-namespace OT {\n-\n-\n-#define entry_score var.u16[0]\n-#define entry_index var.u16[1]\n-\n-\n-\/*\n- * name -- Naming\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/name\n- *\/\n-#define HB_OT_TAG_name HB_TAG('n','a','m','e')\n-\n-#define UNSUPPORTED     42\n-\n-struct NameRecord\n-{\n-  hb_language_t language (hb_face_t *face) const\n-  {\n-#ifndef HB_NO_OT_NAME_LANGUAGE\n-    unsigned int p = platformID;\n-    unsigned int l = languageID;\n-\n-    if (p == 3)\n-      return _hb_ot_name_language_for_ms_code (l);\n-\n-    if (p == 1)\n-      return _hb_ot_name_language_for_mac_code (l);\n-\n-#ifndef HB_NO_OT_NAME_LANGUAGE_AAT\n-    if (p == 0)\n-      return face->table.ltag->get_language (l);\n-#endif\n-\n-#endif\n-    return HB_LANGUAGE_INVALID;\n-  }\n-\n-  uint16_t score () const\n-  {\n-    \/* Same order as in cmap::find_best_subtable(). *\/\n-    unsigned int p = platformID;\n-    unsigned int e = encodingID;\n-\n-    \/* 32-bit. *\/\n-    if (p == 3 && e == 10) return 0;\n-    if (p == 0 && e ==  6) return 1;\n-    if (p == 0 && e ==  4) return 2;\n-\n-    \/* 16-bit. *\/\n-    if (p == 3 && e ==  1) return 3;\n-    if (p == 0 && e ==  3) return 4;\n-    if (p == 0 && e ==  2) return 5;\n-    if (p == 0 && e ==  1) return 6;\n-    if (p == 0 && e ==  0) return 7;\n-\n-    \/* Symbol. *\/\n-    if (p == 3 && e ==  0) return 8;\n-\n-    \/* We treat all Mac Latin names as ASCII only. *\/\n-    if (p == 1 && e ==  0) return 10; \/* 10 is magic number :| *\/\n-\n-    return UNSUPPORTED;\n-  }\n-\n-  NameRecord* copy (hb_serialize_context_t *c, const void *base) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    auto *out = c->embed (this);\n-    if (unlikely (!out)) return_trace (nullptr);\n-    out->offset.serialize_copy (c, offset, base, 0, hb_serialize_context_t::Tail, length);\n-    return_trace (out);\n-  }\n-\n-  bool isUnicode () const\n-  {\n-    unsigned int p = platformID;\n-    unsigned int e = encodingID;\n-\n-    return (p == 0 ||\n-            (p == 3 && (e == 0 || e == 1 || e == 10)));\n-  }\n-\n-  static int cmp (const void *pa, const void *pb)\n-  {\n-    const NameRecord *a = (const NameRecord *)pa;\n-    const NameRecord *b = (const NameRecord *)pb;\n-\n-    if (a->platformID != b->platformID)\n-      return a->platformID - b->platformID;\n-\n-    if (a->encodingID != b->encodingID)\n-      return a->encodingID - b->encodingID;\n-\n-    if (a->languageID != b->languageID)\n-      return a->languageID - b->languageID;\n-\n-    if (a->nameID != b->nameID)\n-      return a->nameID - b->nameID;\n-\n-    if (a->length != b->length)\n-      return a->length - b->length;\n-\n-    return 0;\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && offset.sanitize (c, base, length));\n-  }\n-\n-  HBUINT16      platformID;     \/* Platform ID. *\/\n-  HBUINT16      encodingID;     \/* Platform-specific encoding ID. *\/\n-  HBUINT16      languageID;     \/* Language ID. *\/\n-  HBUINT16      nameID;         \/* Name ID. *\/\n-  HBUINT16      length;         \/* String length (in bytes). *\/\n-  NNOffset16To<UnsizedArrayOf<HBUINT8>>\n-                offset;         \/* String offset from start of storage area (in bytes). *\/\n-  public:\n-  DEFINE_SIZE_STATIC (12);\n-};\n-\n-static int\n-_hb_ot_name_entry_cmp_key (const void *pa, const void *pb, bool exact)\n-{\n-  const hb_ot_name_entry_t *a = (const hb_ot_name_entry_t *) pa;\n-  const hb_ot_name_entry_t *b = (const hb_ot_name_entry_t *) pb;\n-\n-  \/* Compare by name_id, then language. *\/\n-\n-  if (a->name_id != b->name_id)\n-    return a->name_id - b->name_id;\n-\n-  if (a->language == b->language) return 0;\n-  if (!a->language) return -1;\n-  if (!b->language) return +1;\n-\n-  const char *astr = hb_language_to_string (a->language);\n-  const char *bstr = hb_language_to_string (b->language);\n-\n-  signed c = strcmp (astr, bstr);\n-\n-  if (!exact && c)\n-  {\n-    unsigned la = strlen (astr);\n-    unsigned lb = strlen (bstr);\n-    \/\/ 'a' is the user request, and 'b' is string in the font.\n-    \/\/ If eg. user asks for \"en-us\" and font has \"en\", approve.\n-    if (la > lb && astr[lb] == '-' && !strncmp (astr, bstr, lb))\n-      return 0;\n-  }\n-\n-  return c;\n-}\n-\n-static int\n-_hb_ot_name_entry_cmp (const void *pa, const void *pb)\n-{\n-  \/* Compare by name_id, then language, then score, then index. *\/\n-\n-  int v = _hb_ot_name_entry_cmp_key (pa, pb, true);\n-  if (v)\n-    return v;\n-\n-  const hb_ot_name_entry_t *a = (const hb_ot_name_entry_t *) pa;\n-  const hb_ot_name_entry_t *b = (const hb_ot_name_entry_t *) pb;\n-\n-  if (a->entry_score != b->entry_score)\n-    return a->entry_score - b->entry_score;\n-\n-  if (a->entry_index != b->entry_index)\n-    return a->entry_index - b->entry_index;\n-\n-  return 0;\n-}\n-\n-struct name\n-{\n-  static constexpr hb_tag_t tableTag = HB_OT_TAG_name;\n-\n-  unsigned int get_size () const\n-  { return min_size + count * nameRecordZ.item_size; }\n-\n-  template <typename Iterator,\n-            hb_requires (hb_is_source_of (Iterator, const NameRecord &))>\n-  bool serialize (hb_serialize_context_t *c,\n-                  Iterator it,\n-                  const void *src_string_pool)\n-  {\n-    TRACE_SERIALIZE (this);\n-\n-    if (unlikely (!c->extend_min ((*this))))  return_trace (false);\n-\n-    this->format = 0;\n-    this->count = it.len ();\n-\n-    NameRecord *name_records = (NameRecord *) hb_calloc (it.len (), NameRecord::static_size);\n-    if (unlikely (!name_records)) return_trace (false);\n-\n-    hb_array_t<NameRecord> records (name_records, it.len ());\n-\n-    for (const NameRecord& record : it)\n-    {\n-      memcpy (name_records, &record, NameRecord::static_size);\n-      name_records++;\n-    }\n-\n-    records.qsort ();\n-\n-    c->copy_all (records, src_string_pool);\n-    hb_free (records.arrayZ);\n-\n-\n-    if (unlikely (c->ran_out_of_room ())) return_trace (false);\n-\n-    this->stringOffset = c->length ();\n-\n-    return_trace (true);\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-\n-    name *name_prime = c->serializer->start_embed<name> ();\n-    if (unlikely (!name_prime)) return_trace (false);\n-\n-    auto it =\n-    + nameRecordZ.as_array (count)\n-    | hb_filter (c->plan->name_ids, &NameRecord::nameID)\n-    | hb_filter (c->plan->name_languages, &NameRecord::languageID)\n-    | hb_filter ([&] (const NameRecord& namerecord) {\n-      return\n-          (c->plan->flags & HB_SUBSET_FLAGS_NAME_LEGACY)\n-          || namerecord.isUnicode ();\n-    })\n-    ;\n-\n-    name_prime->serialize (c->serializer, it, std::addressof (this + stringOffset));\n-    return_trace (name_prime->count);\n-  }\n-\n-  bool sanitize_records (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    const void *string_pool = (this+stringOffset).arrayZ;\n-    return_trace (nameRecordZ.sanitize (c, count, string_pool));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  likely (format == 0 || format == 1) &&\n-                  c->check_array (nameRecordZ.arrayZ, count) &&\n-                  c->check_range (this, stringOffset) &&\n-                  sanitize_records (c));\n-  }\n-\n-  struct accelerator_t\n-  {\n-    accelerator_t (hb_face_t *face)\n-    {\n-      this->table = hb_sanitize_context_t ().reference_table<name> (face);\n-      assert (this->table.get_length () >= this->table->stringOffset);\n-      this->pool = (const char *) (const void *) (this->table+this->table->stringOffset);\n-      this->pool_len = this->table.get_length () - this->table->stringOffset;\n-      const hb_array_t<const NameRecord> all_names (this->table->nameRecordZ.arrayZ,\n-                                                    this->table->count);\n-\n-      this->names.alloc (all_names.length);\n-\n-      for (unsigned int i = 0; i < all_names.length; i++)\n-      {\n-        hb_ot_name_entry_t *entry = this->names.push ();\n-\n-        entry->name_id = all_names[i].nameID;\n-        entry->language = all_names[i].language (face);\n-        entry->entry_score =  all_names[i].score ();\n-        entry->entry_index = i;\n-      }\n-\n-      this->names.qsort (_hb_ot_name_entry_cmp);\n-      \/* Walk and pick best only for each name_id,language pair,\n-       * while dropping unsupported encodings. *\/\n-      unsigned int j = 0;\n-      for (unsigned int i = 0; i < this->names.length; i++)\n-      {\n-        if (this->names[i].entry_score == UNSUPPORTED ||\n-            this->names[i].language == HB_LANGUAGE_INVALID)\n-          continue;\n-        if (i &&\n-            this->names[i - 1].name_id  == this->names[i].name_id &&\n-            this->names[i - 1].language == this->names[i].language)\n-          continue;\n-        this->names[j++] = this->names[i];\n-      }\n-      this->names.resize (j);\n-    }\n-    ~accelerator_t ()\n-    {\n-      this->table.destroy ();\n-    }\n-\n-    int get_index (hb_ot_name_id_t  name_id,\n-                   hb_language_t    language,\n-                   unsigned int    *width=nullptr) const\n-    {\n-      const hb_ot_name_entry_t key = {name_id, {0}, language};\n-      const hb_ot_name_entry_t *entry = hb_bsearch (key, (const hb_ot_name_entry_t *) this->names,\n-                                                    this->names.length,\n-                                                    sizeof (hb_ot_name_entry_t),\n-                                                    _hb_ot_name_entry_cmp_key,\n-                                                    true);\n-\n-      if (!entry)\n-      {\n-        entry = hb_bsearch (key, (const hb_ot_name_entry_t *) this->names,\n-                            this->names.length,\n-                            sizeof (hb_ot_name_entry_t),\n-                            _hb_ot_name_entry_cmp_key,\n-                            false);\n-      }\n-\n-      if (!entry)\n-        return -1;\n-\n-      if (width)\n-        *width = entry->entry_score < 10 ? 2 : 1;\n-\n-      return entry->entry_index;\n-    }\n-\n-    hb_bytes_t get_name (unsigned int idx) const\n-    {\n-      const hb_array_t<const NameRecord> all_names (table->nameRecordZ.arrayZ, table->count);\n-      const NameRecord &record = all_names[idx];\n-      const hb_bytes_t string_pool (pool, pool_len);\n-      return string_pool.sub_array (record.offset, record.length);\n-    }\n-\n-    private:\n-    const char *pool;\n-    unsigned int pool_len;\n-    public:\n-    hb_blob_ptr_t<name> table;\n-    hb_vector_t<hb_ot_name_entry_t> names;\n-  };\n-\n-  \/* We only implement format 0 for now. *\/\n-  HBUINT16      format;         \/* Format selector (=0\/1). *\/\n-  HBUINT16      count;          \/* Number of name records. *\/\n-  NNOffset16To<UnsizedArrayOf<HBUINT8>>\n-                stringOffset;   \/* Offset to start of string storage (from start of table). *\/\n-  UnsizedArrayOf<NameRecord>\n-                nameRecordZ;    \/* The name records where count is the number of records. *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (6, nameRecordZ);\n-};\n-\n-#undef entry_index\n-#undef entry_score\n-\n-struct name_accelerator_t : name::accelerator_t {\n-  name_accelerator_t (hb_face_t *face) : name::accelerator_t (face) {}\n-};\n-\n-} \/* namespace OT *\/\n-\n+#include \"OT\/name\/name.hh\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-name-table.hh","additions":1,"deletions":375,"binary":false,"changes":376,"status":"modified"},{"patch":"@@ -67,46 +67,0 @@\n-\n-template <typename in_utf_t, typename out_utf_t>\n-static inline unsigned int\n-hb_ot_name_convert_utf (hb_bytes_t                       bytes,\n-                        unsigned int                    *text_size \/* IN\/OUT *\/,\n-                        typename out_utf_t::codepoint_t *text \/* OUT *\/)\n-{\n-  unsigned int src_len = bytes.length \/ sizeof (typename in_utf_t::codepoint_t);\n-  const typename in_utf_t::codepoint_t *src = (const typename in_utf_t::codepoint_t *) bytes.arrayZ;\n-  const typename in_utf_t::codepoint_t *src_end = src + src_len;\n-\n-  typename out_utf_t::codepoint_t *dst = text;\n-\n-  hb_codepoint_t unicode;\n-  const hb_codepoint_t replacement = HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT;\n-\n-  if (text_size && *text_size)\n-  {\n-    (*text_size)--; \/* Same room for NUL-termination. *\/\n-    const typename out_utf_t::codepoint_t *dst_end = text + *text_size;\n-\n-    while (src < src_end && dst < dst_end)\n-    {\n-      const typename in_utf_t::codepoint_t *src_next = in_utf_t::next (src, src_end, &unicode, replacement);\n-      typename out_utf_t::codepoint_t *dst_next = out_utf_t::encode (dst, dst_end, unicode);\n-      if (dst_next == dst)\n-        break; \/* Out-of-room. *\/\n-\n-      dst = dst_next;\n-      src = src_next;\n-    }\n-\n-    *text_size = dst - text;\n-    *dst = 0; \/* NUL-terminate. *\/\n-  }\n-\n-  \/* Accumulate length of rest. *\/\n-  unsigned int dst_len = dst - text;\n-  while (src < src_end)\n-  {\n-    src = in_utf_t::next (src, src_end, &unicode, replacement);\n-    dst_len += out_utf_t::encode_len (unicode);\n-  }\n-  return dst_len;\n-}\n-\n@@ -133,1 +87,1 @@\n-      return hb_ot_name_convert_utf<hb_utf16_be_t, utf_t> (bytes, text_size, text);\n+      return OT::hb_ot_name_convert_utf<hb_utf16_be_t, utf_t> (bytes, text_size, text);\n@@ -136,1 +90,1 @@\n-      return hb_ot_name_convert_utf<hb_ascii_t, utf_t> (bytes, text_size, text);\n+      return OT::hb_ot_name_convert_utf<hb_ascii_t, utf_t> (bytes, text_size, text);\n@@ -230,0 +184,1 @@\n+#include \"hb-ot-name-language-static.hh\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-name.cc","additions":3,"deletions":48,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n@@ -38,1 +37,1 @@\n- * hb_ot_name_id_t:\n+ * hb_ot_name_id_predefined_t:\n@@ -68,3 +67,1 @@\n- * An integral type representing an OpenType 'name' table name identifier.\n- * There are predefined name IDs, as well as name IDs return from other\n- * API.  These can be used to fetch name strings from a font face.\n+ * An enum type representing the pre-defined name IDs.\n@@ -75,1 +72,1 @@\n- * Since: 2.0.0\n+ * Since: 7.0.0\n@@ -77,1 +74,1 @@\n-enum\n+typedef enum\n@@ -107,1 +104,1 @@\n-};\n+} hb_ot_name_id_predefined_t;\n@@ -109,0 +106,9 @@\n+\/**\n+ * hb_ot_name_id_t:\n+ *\n+ * An integral type representing an OpenType 'name' table name identifier.\n+ * There are predefined name IDs, as well as name IDs return from other\n+ * API.  These can be used to fetch name strings from a font face.\n+ *\n+ * Since: 2.0.0\n+ **\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-name.h","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"hb-ot-var-mvar-table.hh\"\n@@ -65,0 +66,1 @@\n+  OS2V2Tail * operator -> () { return this; }\n@@ -169,0 +171,41 @@\n+  float map_wdth_to_widthclass(float width) const\n+  {\n+    if (width < 50) return 1.0f;\n+    if (width > 200) return 9.0f;\n+\n+    float ratio = (width - 50) \/ 12.5f;\n+    int a = (int) floorf (ratio);\n+    int b = (int) ceilf (ratio);\n+\n+    \/* follow this maping:\n+     * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/os2#uswidthclass\n+     *\/\n+    if (b <= 6) \/\/ 50-125\n+    {\n+      if (a == b) return a + 1.0f;\n+    }\n+    else if (b == 7) \/\/ no mapping for 137.5\n+    {\n+      a = 6;\n+      b = 8;\n+    }\n+    else if (b == 8)\n+    {\n+      if (a == b) return 8.0f; \/\/ 150\n+      a = 6;\n+    }\n+    else\n+    {\n+      if (a == b && a == 12) return 9.0f; \/\/200\n+      b = 12;\n+      a = 8;\n+    }\n+\n+    float va = 50 + a * 12.5f;\n+    float vb = 50 + b * 12.5f;\n+\n+    float ret =  a + (width - va) \/ (vb - va);\n+    if (a <= 6) ret += 1.0f;\n+    return ret;\n+  }\n+\n@@ -174,0 +217,52 @@\n+\n+#ifndef HB_NO_VAR\n+    if (c->plan->normalized_coords)\n+    {\n+      auto &MVAR = *c->plan->source->table.MVAR;\n+      auto *table = os2_prime;\n+\n+      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_HORIZONTAL_ASCENDER,         sTypoAscender);\n+      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_HORIZONTAL_DESCENDER,        sTypoDescender);\n+      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_HORIZONTAL_LINE_GAP,         sTypoLineGap);\n+      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_HORIZONTAL_CLIPPING_ASCENT,  usWinAscent);\n+      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_HORIZONTAL_CLIPPING_DESCENT, usWinDescent);\n+      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_SUBSCRIPT_EM_X_SIZE,         ySubscriptXSize);\n+      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_SUBSCRIPT_EM_Y_SIZE,         ySubscriptYSize);\n+      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_SUBSCRIPT_EM_X_OFFSET,       ySubscriptXOffset);\n+      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_SUBSCRIPT_EM_Y_OFFSET,       ySubscriptYOffset);\n+      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_SUPERSCRIPT_EM_X_SIZE,       ySuperscriptXSize);\n+      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_SUPERSCRIPT_EM_Y_SIZE,       ySuperscriptYSize);\n+      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_SUPERSCRIPT_EM_X_OFFSET,     ySuperscriptXOffset);\n+      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_SUPERSCRIPT_EM_Y_OFFSET,     ySuperscriptYOffset);\n+      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_STRIKEOUT_SIZE,              yStrikeoutSize);\n+      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_STRIKEOUT_OFFSET,            yStrikeoutPosition);\n+\n+      if (os2_prime->version >= 2)\n+      {\n+        auto *table = & const_cast<OS2V2Tail &> (os2_prime->v2 ());\n+        HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_X_HEIGHT,                   sxHeight);\n+        HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_CAP_HEIGHT,                 sCapHeight);\n+      }\n+    }\n+#endif\n+\n+    if (c->plan->user_axes_location.has (HB_TAG ('w','g','h','t')) &&\n+        !c->plan->pinned_at_default)\n+    {\n+      float weight_class = c->plan->user_axes_location.get (HB_TAG ('w','g','h','t'));\n+      if (!c->serializer->check_assign (os2_prime->usWeightClass,\n+                                        roundf (hb_clamp (weight_class, 1.0f, 1000.0f)),\n+                                        HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+        return_trace (false);\n+    }\n+\n+    if (c->plan->user_axes_location.has (HB_TAG ('w','d','t','h')) &&\n+        !c->plan->pinned_at_default)\n+    {\n+      float width = c->plan->user_axes_location.get (HB_TAG ('w','d','t','h'));\n+      if (!c->serializer->check_assign (os2_prime->usWidthClass,\n+                                        roundf (map_wdth_to_widthclass (width)),\n+                                        HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+        return_trace (false);\n+    }\n+\n@@ -177,6 +272,2 @@\n-    \/* when --gids option is not used, no need to do collect_mapping that is\n-       * iterating all codepoints in each subtable, which is not efficient *\/\n-    uint16_t min_cp, max_cp;\n-    find_min_and_max_codepoint (c->plan->unicodes, &min_cp, &max_cp);\n-    os2_prime->usFirstCharIndex = min_cp;\n-    os2_prime->usLastCharIndex = max_cp;\n+    os2_prime->usFirstCharIndex = hb_min (0xFFFFu, c->plan->unicodes.get_min ());\n+    os2_prime->usLastCharIndex  = hb_min (0xFFFFu, c->plan->unicodes.get_max ());\n@@ -184,1 +275,1 @@\n-    _update_unicode_ranges (c->plan->unicodes, os2_prime->ulUnicodeRange);\n+    _update_unicode_ranges (&c->plan->unicodes, os2_prime->ulUnicodeRange);\n@@ -192,1 +283,1 @@\n-    HBUINT32    newBits[4];\n+    HBUINT32 newBits[4];\n@@ -196,2 +287,6 @@\n-    hb_codepoint_t cp = HB_SET_VALUE_INVALID;\n-    while (codepoints->next (&cp)) {\n+    \/* This block doesn't show up in profiles. If it ever did,\n+     * we can rewrite it to iterate over OS\/2 ranges and use\n+     * set iteration to check if the range matches. *\/\n+    for (hb_codepoint_t cp = HB_SET_VALUE_INVALID;\n+         codepoints->next (&cp);)\n+    {\n@@ -219,8 +314,0 @@\n-  static void find_min_and_max_codepoint (const hb_set_t *codepoints,\n-                                          uint16_t *min_cp, \/* OUT *\/\n-                                          uint16_t *max_cp  \/* OUT *\/)\n-  {\n-    *min_cp = hb_min (0xFFFFu, codepoints->get_min ());\n-    *max_cp = hb_min (0xFFFFu, codepoints->get_max ());\n-  }\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-os2-table.hh","additions":105,"deletions":18,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  { return (key < start) ? -1 : key <= end ? 0 : +1; }\n+  { return (key < first) ? -1 : key <= last ? 0 : +1; }\n@@ -39,2 +39,2 @@\n-  hb_codepoint_t start;\n-  hb_codepoint_t end;\n+  hb_codepoint_t first;\n+  hb_codepoint_t last;\n@@ -226,1 +226,1 @@\n-  return range ? range->bit : -1;\n+  return range ? range->bit : (unsigned) -1;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-os2-unicode-ranges.hh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  hb_hashmap_t<hb_bytes_t, unsigned, true> glyph_name_to_new_index;\n+  hb_hashmap_t<hb_bytes_t, uint32_t, true> glyph_name_to_new_index;\n@@ -88,1 +88,1 @@\n-    const unsigned *new_index2;\n+    const uint32_t *new_index2;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-post-table-v2subset.hh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"hb-ot-var-mvar-table.hh\"\n@@ -87,1 +88,1 @@\n-    memcpy (post_prime, this, post::min_size);\n+    hb_memcpy (post_prime, this, post::min_size);\n@@ -101,0 +102,11 @@\n+#ifndef HB_NO_VAR\n+    if (c->plan->normalized_coords)\n+    {\n+      auto &MVAR = *c->plan->source->table.MVAR;\n+      auto *table = post_prime;\n+\n+      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_UNDERLINE_SIZE,   underlineThickness);\n+      HB_ADD_MVAR_VAR (HB_OT_METRICS_TAG_UNDERLINE_OFFSET, underlinePosition);\n+    }\n+#endif\n+\n@@ -105,0 +117,8 @@\n+    if (c->plan->user_axes_location.has (HB_TAG ('s','l','n','t')) &&\n+        !c->plan->pinned_at_default)\n+    {\n+      float italic_angle = c->plan->user_axes_location.get (HB_TAG ('s','l','n','t'));\n+      italic_angle = hb_max (-90.f, hb_min (italic_angle, 90.f));\n+      post_prime->italicAngle.set_float (italic_angle);\n+    }\n+\n@@ -129,0 +149,1 @@\n+      index_to_offset.alloc (hb_min (face->get_num_glyphs (), table_length \/ 8));\n@@ -136,1 +157,1 @@\n-      hb_free (gids_sorted_by_name.get ());\n+      hb_free (gids_sorted_by_name.get_acquire ());\n@@ -163,1 +184,1 @@\n-      uint16_t *gids = gids_sorted_by_name.get ();\n+      uint16_t *gids = gids_sorted_by_name.get_acquire ();\n@@ -266,4 +287,4 @@\n-    return_trace (likely (c->check_struct (this) &&\n-                          (version.to_int () == 0x00010000 ||\n-                           (version.to_int () == 0x00020000 && v2X.sanitize (c)) ||\n-                           version.to_int () == 0x00030000)));\n+    return_trace (c->check_struct (this) &&\n+                  (version.to_int () == 0x00010000 ||\n+                   (version.to_int () == 0x00020000 && v2X.sanitize (c)) ||\n+                   version.to_int () == 0x00030000));\n@@ -277,1 +298,1 @@\n-  HBFixed       italicAngle;            \/* Italic angle in counter-clockwise degrees\n+  F16DOT16      italicAngle;            \/* Italic angle in counter-clockwise degrees\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-post-table.hh","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -344,1 +344,1 @@\n-        if (unlikely (_hb_glyph_info_is_unicode_mark (&buffer->info[end])))\n+        if (_hb_glyph_info_is_unicode_mark (&buffer->info[end]))\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-normalize.cc","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-_hb_apply_morx (hb_face_t *face, const hb_segment_properties_t *props)\n+_hb_apply_morx (hb_face_t *face, const hb_segment_properties_t &props)\n@@ -60,1 +60,1 @@\n-         (HB_DIRECTION_IS_HORIZONTAL (props->direction) || !hb_ot_layout_has_substitution (face));\n+         (HB_DIRECTION_IS_HORIZONTAL (props.direction) || !hb_ot_layout_has_substitution (face));\n@@ -80,1 +80,1 @@\n-                                              const hb_segment_properties_t *props) :\n+                                              const hb_segment_properties_t &props) :\n@@ -82,3 +82,2 @@\n-                                                props (*props),\n-                                                map (face, props),\n-                                                aat_map (face, props)\n+                                                props (props),\n+                                                map (face, props)\n@@ -94,0 +93,1 @@\n+#ifndef HB_NO_AAT_SHAPE\n@@ -97,0 +97,1 @@\n+#endif\n@@ -106,4 +107,0 @@\n-#ifndef HB_NO_AAT_SHAPE\n-  if (apply_morx)\n-    aat_map.compile (plan.aat_map);\n-#endif\n@@ -223,3 +220,0 @@\n-#ifndef HB_NO_AAT_SHAPE\n-  aat_map.init ();\n-#endif\n@@ -228,1 +222,1 @@\n-                                 &key->props);\n+                                 key->props);\n@@ -242,3 +236,0 @@\n-#ifndef HB_NO_AAT_SHAPE\n-      aat_map.fini ();\n-#endif\n@@ -259,3 +250,0 @@\n-#ifndef HB_NO_AAT_SHAPE\n-  aat_map.fini ();\n-#endif\n@@ -268,6 +256,1 @@\n-#ifndef HB_NO_AAT_SHAPE\n-  if (unlikely (apply_morx))\n-    hb_aat_layout_substitute (this, font, buffer);\n-  else\n-#endif\n-    map.substitute (this, font, buffer);\n+  map.substitute (this, font, buffer);\n@@ -407,12 +390,0 @@\n-#ifndef HB_NO_AAT_SHAPE\n-  if (planner->apply_morx)\n-  {\n-    hb_aat_map_builder_t *aat_map = &planner->aat_map;\n-    for (unsigned int i = 0; i < num_user_features; i++)\n-    {\n-      const hb_feature_t *feature = &user_features[i];\n-      aat_map->add_feature (feature->tag, feature->value);\n-    }\n-  }\n-#endif\n-\n@@ -530,1 +501,1 @@\n-     * As of Unicode 11 that is just:\n+     * As of Unicode 15 that is just:\n@@ -537,1 +508,1 @@\n-     * it separate results in more granular clusters.  Ignore Katakana for now.\n+     * it separate results in more granular clusters.\n@@ -540,0 +511,2 @@\n+     * Katakana ones were requested:\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/3844\n@@ -541,1 +514,1 @@\n-    else if (unlikely (hb_in_range<hb_codepoint_t> (info[i].codepoint, 0xE0020u, 0xE007Fu)))\n+    else if (unlikely (hb_in_ranges<hb_codepoint_t> (info[i].codepoint, 0xFF9Eu, 0xFF9Fu, 0xE0020u, 0xE007Fu)))\n@@ -865,1 +838,1 @@\n-    hb_ot_layout_delete_glyphs_inplace (buffer, _hb_glyph_info_is_default_ignorable);\n+    buffer->delete_glyphs_inplace (_hb_glyph_info_is_default_ignorable);\n@@ -939,1 +912,7 @@\n-  c->plan->substitute (c->font, buffer);\n+#ifndef HB_NO_AAT_SHAPE\n+  if (unlikely (c->plan->apply_morx))\n+    hb_aat_layout_substitute (c->plan, c->font, c->buffer,\n+                              c->user_features, c->num_user_features);\n+  else\n+#endif\n+    c->plan->substitute (c->font, buffer);\n@@ -1144,0 +1123,12 @@\n+  \/* If we are producing SAFE_TO_INSERT_TATWEEL, then do two things:\n+   *\n+   * - If the places that the Arabic shaper marked as SAFE_TO_INSERT_TATWEEL,\n+   *   are UNSAFE_TO_BREAK, then clear the SAFE_TO_INSERT_TATWEEL,\n+   * - Any place that is SAFE_TO_INSERT_TATWEEL, is also now UNSAFE_TO_BREAK.\n+   *\n+   * We couldn't make this interaction earlier. It has to be done here.\n+   *\/\n+  bool flip_tatweel = buffer->flags & HB_BUFFER_FLAG_PRODUCE_SAFE_TO_INSERT_TATWEEL;\n+\n+  bool clear_concat = (buffer->flags & HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT) == 0;\n+\n@@ -1151,3 +1142,14 @@\n-    if (mask)\n-      for (unsigned int i = start; i < end; i++)\n-        info[i].mask |= mask;\n+\n+    if (flip_tatweel)\n+    {\n+      if (mask & HB_GLYPH_FLAG_UNSAFE_TO_BREAK)\n+        mask &= ~HB_GLYPH_FLAG_SAFE_TO_INSERT_TATWEEL;\n+      if (mask & HB_GLYPH_FLAG_SAFE_TO_INSERT_TATWEEL)\n+        mask |= HB_GLYPH_FLAG_UNSAFE_TO_BREAK | HB_GLYPH_FLAG_UNSAFE_TO_CONCAT;\n+    }\n+\n+    if (clear_concat)\n+        mask &= ~HB_GLYPH_FLAG_UNSAFE_TO_CONCAT;\n+\n+    for (unsigned int i = start; i < end; i++)\n+      info[i].mask = mask;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape.cc","additions":48,"deletions":46,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    return 0 == memcmp (this, other, sizeof (*this));\n+    return 0 == hb_memcmp (this, other, sizeof (*this));\n@@ -63,0 +63,2 @@\n+  ~hb_ot_shape_plan_t () { fini (); }\n+\n@@ -66,1 +68,0 @@\n-  hb_aat_map_t aat_map;\n@@ -153,1 +154,0 @@\n-  hb_aat_map_builder_t aat_map;\n@@ -164,1 +164,1 @@\n-                                     const hb_segment_properties_t *props);\n+                                     const hb_segment_properties_t &props);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape.hh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -157,1 +157,2 @@\n-      for (unsigned i = 0; i < component_count; i++)\n+      bool matched = true;\n+      for (unsigned j = 0; j < component_count; j++)\n@@ -159,1 +160,1 @@\n-        hb_codepoint_t component_u   = ligature_table[first_glyph_idx].ligatures[ligature_idx].components[i];\n+        hb_codepoint_t component_u   = ligature_table[first_glyph_idx].ligatures[ligature_idx].components[j];\n@@ -162,2 +163,5 @@\n-            !hb_font_get_glyph (font, component_u,   0, &component_glyph))\n-          continue;\n+            !hb_font_get_nominal_glyph (font, component_u, &component_glyph))\n+        {\n+          matched = false;\n+          break;\n+        }\n@@ -167,0 +171,2 @@\n+      if (!matched)\n+        continue;\n@@ -225,1 +231,1 @@\n-  OT::hb_ot_layout_lookup_accelerator_t accel_array[ARABIC_FALLBACK_MAX_LOOKUPS];\n+  OT::hb_ot_layout_lookup_accelerator_t *accel_array[ARABIC_FALLBACK_MAX_LOOKUPS];\n@@ -275,1 +281,1 @@\n-        fallback_plan->accel_array[j].init (*fallback_plan->lookup_array[j]);\n+        fallback_plan->accel_array[j] = OT::hb_ot_layout_lookup_accelerator_t::create (*fallback_plan->lookup_array[j]);\n@@ -305,1 +311,1 @@\n-        fallback_plan->accel_array[j].init (*fallback_plan->lookup_array[j]);\n+        fallback_plan->accel_array[j] = OT::hb_ot_layout_lookup_accelerator_t::create (*fallback_plan->lookup_array[j]);\n@@ -352,1 +358,1 @@\n-      fallback_plan->accel_array[i].fini ();\n+      hb_free (fallback_plan->accel_array[i]);\n@@ -369,3 +375,4 @@\n-      hb_ot_layout_substitute_lookup (&c,\n-                                      *fallback_plan->lookup_array[i],\n-                                      fallback_plan->accel_array[i]);\n+      if (fallback_plan->accel_array[i])\n+        hb_ot_layout_substitute_lookup (&c,\n+                                        *fallback_plan->lookup_array[i],\n+                                        *fallback_plan->accel_array[i]);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-arabic-fallback.hh","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -9,4 +9,4 @@\n- * # ArabicShaping-14.0.0.txt\n- * # Date: 2021-05-21, 01:54:00 GMT [KW, RP]\n- * # Scripts-14.0.0.txt\n- * # Date: 2021-07-10, 00:35:31 GMT\n+ * # ArabicShaping-15.0.0.txt\n+ * # Date: 2022-02-14, 18:50:00 GMT [KW, RP]\n+ * # Scripts-15.0.0.txt\n+ * # Date: 2022-04-26, 23:15:02 GMT\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-arabic-joining-list.hh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -9,4 +9,4 @@\n- * # ArabicShaping-14.0.0.txt\n- * # Date: 2021-05-21, 01:54:00 GMT [KW, RP]\n- * # Blocks-14.0.0.txt\n- * # Date: 2021-01-22, 23:29:00 GMT [KW]\n+ * # ArabicShaping-15.0.0.txt\n+ * # Date: 2022-02-14, 18:50:00 GMT [KW, RP]\n+ * # Blocks-15.0.0.txt\n+ * # Date: 2022-01-28, 20:58:00 GMT [KW]\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-arabic-table.hh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-static void\n+static bool\n@@ -169,1 +169,1 @@\n-static void\n+static bool\n@@ -174,1 +174,1 @@\n-static void\n+static bool\n@@ -180,0 +180,1 @@\n+  return false;\n@@ -204,3 +205,0 @@\n-   *\n-   * A pause after calt is required to make KFGQPC Uthmanic Script HAFS\n-   * work correctly.  See https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/505\n@@ -213,2 +211,2 @@\n-  map->enable_feature (HB_TAG('c','c','m','p'));\n-  map->enable_feature (HB_TAG('l','o','c','l'));\n+  map->enable_feature (HB_TAG('c','c','m','p'), F_MANUAL_ZWJ);\n+  map->enable_feature (HB_TAG('l','o','c','l'), F_MANUAL_ZWJ);\n@@ -221,1 +219,1 @@\n-    map->add_feature (arabic_features[i], has_fallback ? F_HAS_FALLBACK : F_NONE);\n+    map->add_feature (arabic_features[i], F_MANUAL_ZWJ | (has_fallback ? F_HAS_FALLBACK : F_NONE));\n@@ -235,4 +233,10 @@\n-  \/* No pause after rclt.  See 98460779bae19e4d64d29461ff154b3527bf8420. *\/\n-  map->enable_feature (HB_TAG('r','c','l','t'), F_MANUAL_ZWJ);\n-  map->enable_feature (HB_TAG('c','a','l','t'), F_MANUAL_ZWJ);\n-  map->add_gsub_pause (nullptr);\n+   map->enable_feature (HB_TAG('c','a','l','t'), F_MANUAL_ZWJ);\n+   \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1573 *\/\n+   if (!map->has_feature (HB_TAG('r','c','l','t')))\n+   {\n+     map->add_gsub_pause (nullptr);\n+     map->enable_feature (HB_TAG('r','c','l','t'), F_MANUAL_ZWJ);\n+   }\n+\n+   map->enable_feature (HB_TAG('l','i','g','a'), F_MANUAL_ZWJ);\n+   map->enable_feature (HB_TAG('c','l','i','g'), F_MANUAL_ZWJ);\n@@ -248,2 +252,2 @@\n-  \/\/map->enable_feature (HB_TAG('c','s','w','h'));\n-  map->enable_feature (HB_TAG('m','s','e','t'));\n+  \/\/map->enable_feature (HB_TAG('c','s','w','h'), F_MANUAL_ZWJ);\n+  map->enable_feature (HB_TAG('m','s','e','t'), F_MANUAL_ZWJ);\n@@ -331,1 +335,1 @@\n-      buffer->unsafe_to_break (prev, i + 1);\n+      buffer->safe_to_insert_tatweel (prev, i + 1);\n@@ -365,1 +369,1 @@\n-      buffer->unsafe_to_break (prev, buffer->len);\n+      buffer->safe_to_insert_tatweel (prev, buffer->len);\n@@ -412,1 +416,1 @@\n-static void\n+static bool\n@@ -418,1 +422,1 @@\n-  return;\n+  return false;\n@@ -424,1 +428,1 @@\n-    return;\n+    return false;\n@@ -440,0 +444,1 @@\n+  return true;\n@@ -450,1 +455,1 @@\n-static void\n+static bool\n@@ -457,1 +462,1 @@\n-    return;\n+    return false;\n@@ -473,0 +478,1 @@\n+  return false;\n@@ -553,1 +559,1 @@\n-      DEBUG_MSG (ARABIC, nullptr, \"%s stretch at (%d,%d,%d)\",\n+      DEBUG_MSG (ARABIC, nullptr, \"%s stretch at (%u,%u,%u)\",\n@@ -555,1 +561,1 @@\n-      DEBUG_MSG (ARABIC, nullptr, \"rest of word:    count=%d width %d\", start - context, w_total);\n+      DEBUG_MSG (ARABIC, nullptr, \"rest of word:    count=%u width %d\", start - context, w_total);\n@@ -594,1 +600,1 @@\n-          DEBUG_MSG (ARABIC, nullptr, \"appending %d copies of glyph %d; j=%d\",\n+          DEBUG_MSG (ARABIC, nullptr, \"appending %u copies of glyph %u; j=%u\",\n@@ -672,1 +678,1 @@\n-  DEBUG_MSG (ARABIC, buffer, \"Reordering marks from %d to %d\", start, end);\n+  DEBUG_MSG (ARABIC, buffer, \"Reordering marks from %u to %u\", start, end);\n@@ -677,1 +683,1 @@\n-    DEBUG_MSG (ARABIC, buffer, \"Looking for %d's starting at %d\", cc, i);\n+    DEBUG_MSG (ARABIC, buffer, \"Looking for %u's starting at %u\", cc, i);\n@@ -680,1 +686,1 @@\n-    DEBUG_MSG (ARABIC, buffer, \"Looking for %d's stopped at %d\", cc, i);\n+    DEBUG_MSG (ARABIC, buffer, \"Looking for %u's stopped at %u\", cc, i);\n@@ -695,1 +701,1 @@\n-    DEBUG_MSG (ARABIC, buffer, \"Found %d's from %d to %d\", cc, i, j);\n+    DEBUG_MSG (ARABIC, buffer, \"Found %u's from %u to %u\", cc, i, j);\n@@ -698,1 +704,1 @@\n-    DEBUG_MSG (ARABIC, buffer, \"Shifting %d's: %d %d\", cc, i, j);\n+    DEBUG_MSG (ARABIC, buffer, \"Shifting %u's: %u %u\", cc, i, j);\n@@ -738,1 +744,0 @@\n-  HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,\n@@ -742,1 +747,0 @@\n-  HB_TAG_NONE, \/* gpos_tag *\/\n@@ -744,0 +748,2 @@\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-arabic.cc","additions":38,"deletions":32,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,\n@@ -46,1 +45,0 @@\n-  HB_TAG_NONE, \/* gpos_tag *\/\n@@ -48,0 +46,2 @@\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,\n@@ -52,0 +52,1 @@\n+#ifndef HB_NO_AAT_SHAPE\n@@ -62,1 +63,0 @@\n-  HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,\n@@ -66,1 +66,0 @@\n-  HB_TAG_NONE, \/* gpos_tag *\/\n@@ -68,0 +67,2 @@\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,\n@@ -71,0 +72,1 @@\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-default.cc","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -425,1 +425,0 @@\n-  HB_OT_SHAPE_NORMALIZATION_MODE_NONE,\n@@ -429,1 +428,0 @@\n-  HB_TAG_NONE, \/* gpos_tag *\/\n@@ -431,0 +429,2 @@\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_NONE,\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-hangul.cc","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-      case 0x05B7u: \/* patah *\/\n+      case 0x05B7u: \/* PATAH *\/\n@@ -165,0 +165,26 @@\n+static void\n+reorder_marks_hebrew (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                      hb_buffer_t              *buffer,\n+                      unsigned int              start,\n+                      unsigned int              end)\n+{\n+  hb_glyph_info_t *info = buffer->info;\n+\n+  for (unsigned i = start + 2; i < end; i++)\n+  {\n+    unsigned c0 = info_cc (info[i - 2]);\n+    unsigned c1 = info_cc (info[i - 1]);\n+    unsigned c2 = info_cc (info[i - 0]);\n+\n+    if ((c0 == HB_MODIFIED_COMBINING_CLASS_CCC17 || c0 == HB_MODIFIED_COMBINING_CLASS_CCC18) \/* patach or qamats *\/ &&\n+        (c1 == HB_MODIFIED_COMBINING_CLASS_CCC10 || c1 == HB_MODIFIED_COMBINING_CLASS_CCC14) \/* sheva or hiriq *\/ &&\n+        (c2 == HB_MODIFIED_COMBINING_CLASS_CCC22 || c2 == HB_UNICODE_COMBINING_CLASS_BELOW) \/* meteg or below *\/)\n+    {\n+      buffer->merge_clusters (i - 1, i + 1);\n+      hb_swap (info[i - 1], info[i]);\n+      break;\n+    }\n+  }\n+\n+\n+}\n@@ -174,1 +200,0 @@\n-  HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,\n@@ -178,0 +203,1 @@\n+  reorder_marks_hebrew,\n@@ -179,1 +205,1 @@\n-  nullptr, \/* reorder_marks *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-hebrew.cc","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-#line 57 \"hb-ot-shaper-indic-machine.hh\"\n+#line 54 \"hb-ot-shaper-indic-machine.hh\"\n@@ -64,0 +64,1 @@\n+#define indic_syllable_machine_ex_MPst 13u\n@@ -78,1 +79,1 @@\n-#line 79 \"hb-ot-shaper-indic-machine.hh\"\n+#line 75 \"hb-ot-shaper-indic-machine.hh\"\n@@ -80,17 +81,18 @@\n-        8u, 8u, 4u, 8u, 5u, 7u, 5u, 8u, 4u, 8u, 4u, 12u, 4u, 8u, 8u, 8u,\n-        5u, 7u, 5u, 8u, 4u, 8u, 4u, 12u, 4u, 12u, 4u, 12u, 8u, 8u, 5u, 7u,\n-        5u, 8u, 4u, 8u, 4u, 8u, 4u, 12u, 8u, 8u, 5u, 7u, 5u, 8u, 4u, 8u,\n-        4u, 8u, 5u, 8u, 8u, 8u, 1u, 18u, 3u, 16u, 3u, 16u, 4u, 16u, 1u, 15u,\n-        5u, 9u, 5u, 9u, 9u, 9u, 5u, 9u, 1u, 15u, 1u, 15u, 1u, 15u, 3u, 9u,\n-        4u, 9u, 5u, 9u, 4u, 9u, 5u, 9u, 3u, 9u, 5u, 9u, 3u, 16u, 3u, 16u,\n-        3u, 16u, 3u, 16u, 4u, 16u, 1u, 15u, 3u, 16u, 3u, 16u, 4u, 16u, 1u, 15u,\n-        5u, 9u, 9u, 9u, 5u, 9u, 1u, 15u, 1u, 15u, 3u, 9u, 4u, 9u, 5u, 9u,\n-        4u, 9u, 5u, 9u, 5u, 9u, 3u, 9u, 5u, 9u, 3u, 16u, 3u, 16u, 4u, 8u,\n-        3u, 16u, 3u, 16u, 4u, 16u, 1u, 15u, 3u, 16u, 1u, 15u, 5u, 9u, 9u, 9u,\n-        5u, 9u, 1u, 15u, 1u, 15u, 3u, 9u, 4u, 9u, 5u, 9u, 3u, 16u, 4u, 9u,\n-        5u, 9u, 5u, 9u, 3u, 9u, 5u, 9u, 3u, 16u, 4u, 12u, 4u, 8u, 3u, 16u,\n-        3u, 16u, 4u, 16u, 1u, 15u, 3u, 16u, 1u, 15u, 5u, 9u, 9u, 9u, 5u, 9u,\n-        1u, 15u, 1u, 15u, 3u, 9u, 4u, 9u, 5u, 9u, 3u, 16u, 4u, 9u, 5u, 9u,\n-        5u, 9u, 3u, 9u, 5u, 9u, 1u, 16u, 3u, 16u, 1u, 16u, 4u, 12u, 5u, 9u,\n-        9u, 9u, 5u, 9u, 1u, 15u, 3u, 9u, 5u, 9u, 5u, 9u, 9u, 9u, 5u, 9u,\n-        1u, 15u, 0\n+        8u, 8u, 4u, 13u, 5u, 13u, 5u, 13u, 13u, 13u, 4u, 13u, 4u, 13u, 4u, 13u,\n+        8u, 8u, 5u, 13u, 5u, 13u, 13u, 13u, 4u, 13u, 4u, 13u, 4u, 13u, 4u, 13u,\n+        8u, 8u, 5u, 13u, 5u, 13u, 13u, 13u, 4u, 13u, 4u, 13u, 4u, 13u, 8u, 8u,\n+        5u, 13u, 5u, 13u, 13u, 13u, 4u, 13u, 4u, 13u, 5u, 13u, 8u, 8u, 1u, 18u,\n+        3u, 16u, 3u, 16u, 4u, 16u, 1u, 15u, 5u, 9u, 5u, 9u, 9u, 9u, 5u, 9u,\n+        1u, 15u, 1u, 15u, 1u, 15u, 3u, 13u, 4u, 13u, 5u, 13u, 5u, 13u, 4u, 13u,\n+        5u, 9u, 3u, 9u, 5u, 9u, 3u, 16u, 3u, 16u, 3u, 16u, 3u, 16u, 4u, 16u,\n+        1u, 15u, 3u, 16u, 3u, 16u, 4u, 16u, 1u, 15u, 5u, 9u, 9u, 9u, 5u, 9u,\n+        1u, 15u, 1u, 15u, 3u, 13u, 4u, 13u, 5u, 13u, 5u, 13u, 4u, 13u, 5u, 9u,\n+        5u, 9u, 3u, 9u, 5u, 9u, 3u, 16u, 3u, 16u, 4u, 13u, 3u, 16u, 3u, 16u,\n+        4u, 16u, 1u, 15u, 3u, 16u, 1u, 15u, 5u, 9u, 9u, 9u, 5u, 9u, 1u, 15u,\n+        1u, 15u, 3u, 13u, 4u, 13u, 5u, 13u, 5u, 13u, 3u, 16u, 4u, 13u, 5u, 9u,\n+        5u, 9u, 3u, 9u, 5u, 9u, 3u, 16u, 4u, 13u, 4u, 13u, 3u, 16u, 3u, 16u,\n+        4u, 16u, 1u, 15u, 3u, 16u, 1u, 15u, 5u, 9u, 9u, 9u, 5u, 9u, 1u, 15u,\n+        1u, 15u, 3u, 13u, 4u, 13u, 5u, 13u, 5u, 13u, 3u, 16u, 4u, 13u, 5u, 9u,\n+        5u, 9u, 3u, 9u, 5u, 9u, 1u, 16u, 3u, 16u, 1u, 16u, 4u, 13u, 5u, 13u,\n+        5u, 13u, 9u, 9u, 5u, 9u, 1u, 15u, 3u, 9u, 5u, 9u, 5u, 9u, 9u, 9u,\n+        5u, 9u, 1u, 15u, 0\n@@ -100,17 +102,18 @@\n-        1, 5, 3, 4, 5, 9, 5, 1,\n-        3, 4, 5, 9, 9, 9, 1, 3,\n-        4, 5, 5, 9, 1, 3, 4, 5,\n-        5, 4, 1, 18, 14, 14, 13, 15,\n-        5, 5, 1, 5, 15, 15, 15, 7,\n-        6, 5, 6, 5, 7, 5, 14, 14,\n-        14, 14, 13, 15, 14, 14, 13, 15,\n-        5, 1, 5, 15, 15, 7, 6, 5,\n-        6, 5, 5, 7, 5, 14, 14, 5,\n-        14, 14, 13, 15, 14, 15, 5, 1,\n-        5, 15, 15, 7, 6, 5, 14, 6,\n-        5, 5, 7, 5, 14, 9, 5, 14,\n-        14, 13, 15, 14, 15, 5, 1, 5,\n-        15, 15, 7, 6, 5, 14, 6, 5,\n-        5, 7, 5, 16, 14, 16, 9, 5,\n-        1, 5, 15, 7, 5, 5, 1, 5,\n-        15\n+        1, 10, 9, 9, 1, 10, 10, 10,\n+        1, 9, 9, 1, 10, 10, 10, 10,\n+        1, 9, 9, 1, 10, 10, 10, 1,\n+        9, 9, 1, 10, 10, 9, 1, 18,\n+        14, 14, 13, 15, 5, 5, 1, 5,\n+        15, 15, 15, 11, 10, 9, 9, 10,\n+        5, 7, 5, 14, 14, 14, 14, 13,\n+        15, 14, 14, 13, 15, 5, 1, 5,\n+        15, 15, 11, 10, 9, 9, 10, 5,\n+        5, 7, 5, 14, 14, 10, 14, 14,\n+        13, 15, 14, 15, 5, 1, 5, 15,\n+        15, 11, 10, 9, 9, 14, 10, 5,\n+        5, 7, 5, 14, 10, 10, 14, 14,\n+        13, 15, 14, 15, 5, 1, 5, 15,\n+        15, 11, 10, 9, 9, 14, 10, 5,\n+        5, 7, 5, 16, 14, 16, 10, 9,\n+        9, 1, 5, 15, 7, 5, 5, 1,\n+        5, 15\n@@ -120,17 +123,18 @@\n-        0, 2, 8, 12, 17, 23, 33, 39,\n-        41, 45, 50, 56, 66, 76, 86, 88,\n-        92, 97, 103, 109, 119, 121, 125, 130,\n-        136, 142, 147, 149, 168, 183, 198, 212,\n-        228, 234, 240, 242, 248, 264, 280, 296,\n-        304, 311, 317, 324, 330, 338, 344, 359,\n-        374, 389, 404, 418, 434, 449, 464, 478,\n-        494, 500, 502, 508, 524, 540, 548, 555,\n-        561, 568, 574, 580, 588, 594, 609, 624,\n-        630, 645, 660, 674, 690, 705, 721, 727,\n-        729, 735, 751, 767, 775, 782, 788, 803,\n-        810, 816, 822, 830, 836, 851, 861, 867,\n-        882, 897, 911, 927, 942, 958, 964, 966,\n-        972, 988, 1004, 1012, 1019, 1025, 1040, 1047,\n-        1053, 1059, 1067, 1073, 1090, 1105, 1122, 1132,\n-        1138, 1140, 1146, 1162, 1170, 1176, 1182, 1184,\n-        1190\n+        0, 2, 13, 23, 33, 35, 46, 57,\n+        68, 70, 80, 90, 92, 103, 114, 125,\n+        136, 138, 148, 158, 160, 171, 182, 193,\n+        195, 205, 215, 217, 228, 239, 249, 251,\n+        270, 285, 300, 314, 330, 336, 342, 344,\n+        350, 366, 382, 398, 410, 421, 431, 441,\n+        452, 458, 466, 472, 487, 502, 517, 532,\n+        546, 562, 577, 592, 606, 622, 628, 630,\n+        636, 652, 668, 680, 691, 701, 711, 722,\n+        728, 734, 742, 748, 763, 778, 789, 804,\n+        819, 833, 849, 864, 880, 886, 888, 894,\n+        910, 926, 938, 949, 959, 969, 984, 995,\n+        1001, 1007, 1015, 1021, 1036, 1047, 1058, 1073,\n+        1088, 1102, 1118, 1133, 1149, 1155, 1157, 1163,\n+        1179, 1195, 1207, 1218, 1228, 1238, 1253, 1264,\n+        1270, 1276, 1284, 1290, 1307, 1322, 1339, 1350,\n+        1360, 1370, 1372, 1378, 1394, 1402, 1408, 1414,\n+        1416, 1422\n@@ -140,151 +144,180 @@\n-        1, 0, 2, 3, 3, 4, 1, 0,\n-        3, 3, 4, 0, 3, 3, 4, 1,\n-        0, 5, 3, 3, 4, 1, 0, 2,\n-        3, 3, 4, 1, 0, 0, 0, 6,\n-        0, 8, 9, 9, 10, 11, 7, 11,\n-        7, 9, 9, 10, 7, 9, 9, 10,\n-        11, 7, 12, 9, 9, 10, 11, 7,\n-        8, 9, 9, 10, 11, 7, 7, 7,\n-        13, 7, 8, 9, 9, 10, 11, 7,\n-        7, 7, 14, 7, 16, 17, 17, 18,\n-        19, 15, 15, 15, 20, 15, 19, 15,\n-        17, 17, 18, 21, 17, 17, 18, 19,\n-        15, 16, 17, 17, 18, 19, 15, 22,\n-        17, 17, 18, 19, 15, 24, 25, 25,\n-        26, 27, 23, 23, 23, 28, 23, 27,\n-        23, 25, 25, 26, 23, 25, 25, 26,\n-        27, 23, 24, 25, 25, 26, 27, 23,\n-        29, 25, 25, 26, 27, 23, 17, 17,\n-        18, 1, 0, 31, 30, 33, 34, 35,\n-        36, 37, 38, 18, 19, 39, 40, 40,\n-        20, 32, 41, 42, 43, 44, 45, 32,\n-        47, 48, 49, 50, 4, 1, 51, 46,\n-        46, 6, 46, 46, 46, 52, 46, 53,\n-        48, 54, 54, 4, 1, 51, 46, 46,\n-        46, 46, 46, 46, 52, 46, 48, 54,\n-        54, 4, 1, 51, 46, 46, 46, 46,\n-        46, 46, 52, 46, 33, 46, 46, 46,\n-        55, 56, 46, 1, 51, 46, 46, 46,\n-        46, 46, 33, 46, 57, 57, 46, 1,\n-        51, 46, 51, 46, 46, 58, 51, 46,\n-        51, 46, 51, 46, 46, 46, 51, 46,\n-        33, 46, 59, 46, 57, 57, 46, 1,\n-        51, 46, 46, 46, 46, 46, 33, 46,\n-        33, 46, 46, 46, 57, 57, 46, 1,\n-        51, 46, 46, 46, 46, 46, 33, 46,\n-        33, 46, 46, 46, 57, 56, 46, 1,\n-        51, 46, 46, 46, 46, 46, 33, 46,\n-        60, 61, 62, 62, 4, 1, 51, 46,\n-        61, 62, 62, 4, 1, 51, 46, 62,\n-        62, 4, 1, 51, 46, 63, 64, 64,\n-        4, 1, 51, 46, 55, 65, 46, 1,\n-        51, 46, 55, 46, 57, 57, 46, 1,\n-        51, 46, 57, 65, 46, 1, 51, 46,\n-        47, 48, 54, 54, 4, 1, 51, 46,\n-        46, 46, 46, 46, 46, 52, 46, 47,\n-        48, 49, 54, 4, 1, 51, 46, 46,\n-        6, 46, 46, 46, 52, 46, 67, 68,\n-        69, 70, 10, 11, 71, 66, 66, 14,\n-        66, 66, 66, 72, 66, 73, 68, 74,\n-        70, 10, 11, 71, 66, 66, 66, 66,\n-        66, 66, 72, 66, 68, 74, 70, 10,\n-        11, 71, 66, 66, 66, 66, 66, 66,\n-        72, 66, 75, 66, 66, 66, 76, 77,\n-        66, 11, 71, 66, 66, 66, 66, 66,\n-        75, 66, 78, 68, 79, 80, 10, 11,\n-        71, 66, 66, 13, 66, 66, 66, 72,\n-        66, 81, 68, 74, 74, 10, 11, 71,\n-        66, 66, 66, 66, 66, 66, 72, 66,\n-        68, 74, 74, 10, 11, 71, 66, 66,\n-        66, 66, 66, 66, 72, 66, 75, 66,\n-        66, 66, 82, 77, 66, 11, 71, 66,\n-        66, 66, 66, 66, 75, 66, 71, 66,\n-        66, 83, 71, 66, 71, 66, 71, 66,\n-        66, 66, 71, 66, 75, 66, 84, 66,\n-        82, 82, 66, 11, 71, 66, 66, 66,\n-        66, 66, 75, 66, 75, 66, 66, 66,\n-        82, 82, 66, 11, 71, 66, 66, 66,\n-        66, 66, 75, 66, 85, 86, 87, 87,\n-        10, 11, 71, 66, 86, 87, 87, 10,\n-        11, 71, 66, 87, 87, 10, 11, 71,\n-        66, 88, 89, 89, 10, 11, 71, 66,\n-        76, 90, 66, 11, 71, 66, 82, 82,\n-        66, 11, 71, 66, 76, 66, 82, 82,\n-        66, 11, 71, 66, 82, 90, 66, 11,\n-        71, 66, 78, 68, 74, 74, 10, 11,\n-        71, 66, 66, 66, 66, 66, 66, 72,\n-        66, 78, 68, 79, 74, 10, 11, 71,\n-        66, 66, 13, 66, 66, 66, 72, 66,\n-        8, 9, 9, 10, 11, 66, 67, 68,\n-        74, 70, 10, 11, 71, 66, 66, 66,\n-        66, 66, 66, 72, 66, 92, 36, 93,\n-        93, 18, 19, 39, 91, 91, 91, 91,\n-        91, 91, 43, 91, 36, 93, 93, 18,\n-        19, 39, 91, 91, 91, 91, 91, 91,\n-        43, 91, 94, 91, 91, 91, 95, 96,\n-        91, 19, 39, 91, 91, 91, 91, 91,\n-        94, 91, 35, 36, 97, 98, 18, 19,\n-        39, 91, 91, 20, 91, 91, 91, 43,\n-        91, 94, 91, 91, 91, 99, 96, 91,\n-        19, 39, 91, 91, 91, 91, 91, 94,\n-        91, 39, 91, 91, 100, 39, 91, 39,\n-        91, 39, 91, 91, 91, 39, 91, 94,\n-        91, 101, 91, 99, 99, 91, 19, 39,\n-        91, 91, 91, 91, 91, 94, 91, 94,\n-        91, 91, 91, 99, 99, 91, 19, 39,\n-        91, 91, 91, 91, 91, 94, 91, 102,\n-        103, 104, 104, 18, 19, 39, 91, 103,\n-        104, 104, 18, 19, 39, 91, 104, 104,\n-        18, 19, 39, 91, 35, 36, 93, 93,\n-        18, 19, 39, 91, 91, 91, 91, 91,\n-        91, 43, 91, 105, 106, 106, 18, 19,\n-        39, 91, 95, 107, 91, 19, 39, 91,\n-        99, 99, 91, 19, 39, 91, 95, 91,\n-        99, 99, 91, 19, 39, 91, 99, 107,\n-        91, 19, 39, 91, 35, 36, 97, 93,\n-        18, 19, 39, 91, 91, 20, 91, 91,\n-        91, 43, 91, 16, 17, 17, 18, 19,\n-        108, 108, 108, 20, 108, 16, 17, 17,\n-        18, 19, 108, 110, 111, 112, 113, 26,\n-        27, 114, 109, 109, 28, 109, 109, 109,\n-        115, 109, 116, 111, 113, 113, 26, 27,\n-        114, 109, 109, 109, 109, 109, 109, 115,\n-        109, 111, 113, 113, 26, 27, 114, 109,\n-        109, 109, 109, 109, 109, 115, 109, 117,\n-        109, 109, 109, 118, 119, 109, 27, 114,\n-        109, 109, 109, 109, 109, 117, 109, 110,\n-        111, 112, 40, 26, 27, 114, 109, 109,\n-        28, 109, 109, 109, 115, 109, 117, 109,\n-        109, 109, 120, 119, 109, 27, 114, 109,\n-        109, 109, 109, 109, 117, 109, 114, 109,\n-        109, 121, 114, 109, 114, 109, 114, 109,\n-        109, 109, 114, 109, 117, 109, 122, 109,\n-        120, 120, 109, 27, 114, 109, 109, 109,\n-        109, 109, 117, 109, 117, 109, 109, 109,\n-        120, 120, 109, 27, 114, 109, 109, 109,\n-        109, 109, 117, 109, 123, 124, 125, 125,\n-        26, 27, 114, 109, 124, 125, 125, 26,\n-        27, 114, 109, 125, 125, 26, 27, 114,\n-        109, 110, 111, 113, 113, 26, 27, 114,\n-        109, 109, 109, 109, 109, 109, 115, 109,\n-        126, 127, 127, 26, 27, 114, 109, 118,\n-        128, 109, 27, 114, 109, 120, 120, 109,\n-        27, 114, 109, 118, 109, 120, 120, 109,\n-        27, 114, 109, 120, 128, 109, 27, 114,\n-        109, 33, 34, 35, 36, 97, 93, 18,\n-        19, 39, 40, 40, 20, 91, 91, 33,\n-        43, 91, 47, 129, 49, 50, 4, 1,\n-        51, 46, 46, 6, 46, 46, 46, 52,\n-        46, 33, 34, 35, 36, 130, 131, 18,\n-        132, 133, 46, 40, 20, 46, 46, 33,\n-        43, 46, 16, 134, 134, 18, 132, 51,\n-        46, 46, 20, 46, 133, 46, 46, 135,\n-        133, 46, 133, 46, 133, 46, 46, 46,\n-        133, 46, 33, 46, 59, 16, 134, 134,\n-        18, 132, 51, 46, 46, 46, 46, 46,\n-        33, 46, 137, 136, 138, 138, 136, 31,\n-        139, 136, 138, 138, 136, 31, 139, 136,\n-        139, 136, 136, 140, 139, 136, 139, 136,\n-        139, 136, 136, 136, 139, 136, 33, 108,\n-        108, 108, 108, 108, 108, 108, 108, 40,\n-        108, 108, 108, 108, 33, 108, 0\n+        1, 0, 2, 3, 3, 4, 5, 0,\n+        0, 0, 0, 4, 0, 3, 3, 4,\n+        6, 0, 0, 0, 0, 4, 0, 3,\n+        3, 4, 5, 0, 0, 0, 0, 4,\n+        0, 4, 0, 7, 3, 3, 4, 5,\n+        0, 0, 0, 0, 4, 0, 2, 3,\n+        3, 4, 5, 0, 0, 0, 8, 4,\n+        0, 10, 11, 11, 12, 13, 9, 9,\n+        9, 9, 12, 9, 14, 9, 11, 11,\n+        12, 15, 9, 9, 9, 9, 12, 9,\n+        11, 11, 12, 13, 9, 9, 9, 9,\n+        12, 9, 12, 9, 16, 11, 11, 12,\n+        13, 9, 9, 9, 9, 12, 9, 10,\n+        11, 11, 12, 13, 9, 9, 9, 17,\n+        12, 9, 10, 11, 11, 12, 13, 9,\n+        9, 9, 18, 12, 9, 20, 21, 21,\n+        22, 23, 19, 19, 19, 24, 22, 19,\n+        25, 19, 21, 21, 22, 27, 26, 26,\n+        26, 26, 22, 26, 21, 21, 22, 23,\n+        19, 19, 19, 19, 22, 19, 22, 26,\n+        20, 21, 21, 22, 23, 19, 19, 19,\n+        19, 22, 19, 28, 21, 21, 22, 23,\n+        19, 19, 19, 19, 22, 19, 30, 31,\n+        31, 32, 33, 29, 29, 29, 34, 32,\n+        29, 35, 29, 31, 31, 32, 36, 29,\n+        29, 29, 29, 32, 29, 31, 31, 32,\n+        33, 29, 29, 29, 29, 32, 29, 32,\n+        29, 30, 31, 31, 32, 33, 29, 29,\n+        29, 29, 32, 29, 37, 31, 31, 32,\n+        33, 29, 29, 29, 29, 32, 29, 21,\n+        21, 22, 38, 0, 0, 0, 0, 22,\n+        0, 40, 39, 42, 43, 44, 45, 46,\n+        47, 22, 23, 48, 49, 49, 24, 22,\n+        50, 51, 52, 53, 54, 41, 56, 57,\n+        58, 59, 4, 5, 60, 55, 55, 8,\n+        4, 55, 55, 61, 55, 62, 57, 63,\n+        63, 4, 5, 60, 55, 55, 55, 4,\n+        55, 55, 61, 55, 57, 63, 63, 4,\n+        5, 60, 55, 55, 55, 4, 55, 55,\n+        61, 55, 42, 55, 55, 55, 64, 65,\n+        55, 1, 60, 55, 55, 55, 55, 55,\n+        42, 55, 66, 66, 55, 1, 60, 55,\n+        60, 55, 55, 67, 60, 55, 60, 55,\n+        60, 55, 55, 55, 60, 55, 42, 55,\n+        68, 55, 66, 66, 55, 1, 60, 55,\n+        55, 55, 55, 55, 42, 55, 42, 55,\n+        55, 55, 66, 66, 55, 1, 60, 55,\n+        55, 55, 55, 55, 42, 55, 42, 55,\n+        55, 55, 66, 65, 55, 1, 60, 55,\n+        55, 55, 55, 55, 42, 55, 69, 70,\n+        71, 71, 4, 5, 60, 55, 55, 55,\n+        4, 55, 70, 71, 71, 4, 5, 60,\n+        55, 55, 55, 4, 55, 71, 71, 4,\n+        5, 60, 55, 55, 55, 4, 55, 60,\n+        55, 55, 67, 60, 55, 55, 55, 4,\n+        55, 72, 73, 73, 4, 5, 60, 55,\n+        55, 55, 4, 55, 64, 74, 55, 1,\n+        60, 55, 64, 55, 66, 66, 55, 1,\n+        60, 55, 66, 74, 55, 1, 60, 55,\n+        56, 57, 63, 63, 4, 5, 60, 55,\n+        55, 55, 4, 55, 55, 61, 55, 56,\n+        57, 58, 63, 4, 5, 60, 55, 55,\n+        8, 4, 55, 55, 61, 55, 76, 77,\n+        78, 79, 12, 13, 80, 75, 75, 18,\n+        12, 75, 75, 81, 75, 82, 77, 83,\n+        79, 12, 13, 80, 75, 75, 75, 12,\n+        75, 75, 81, 75, 77, 83, 79, 12,\n+        13, 80, 75, 75, 75, 12, 75, 75,\n+        81, 75, 84, 75, 75, 75, 85, 86,\n+        75, 14, 80, 75, 75, 75, 75, 75,\n+        84, 75, 87, 77, 88, 89, 12, 13,\n+        80, 75, 75, 17, 12, 75, 75, 81,\n+        75, 90, 77, 83, 83, 12, 13, 80,\n+        75, 75, 75, 12, 75, 75, 81, 75,\n+        77, 83, 83, 12, 13, 80, 75, 75,\n+        75, 12, 75, 75, 81, 75, 84, 75,\n+        75, 75, 91, 86, 75, 14, 80, 75,\n+        75, 75, 75, 75, 84, 75, 80, 75,\n+        75, 92, 80, 75, 80, 75, 80, 75,\n+        75, 75, 80, 75, 84, 75, 93, 75,\n+        91, 91, 75, 14, 80, 75, 75, 75,\n+        75, 75, 84, 75, 84, 75, 75, 75,\n+        91, 91, 75, 14, 80, 75, 75, 75,\n+        75, 75, 84, 75, 94, 95, 96, 96,\n+        12, 13, 80, 75, 75, 75, 12, 75,\n+        95, 96, 96, 12, 13, 80, 75, 75,\n+        75, 12, 75, 96, 96, 12, 13, 80,\n+        75, 75, 75, 12, 75, 80, 75, 75,\n+        92, 80, 75, 75, 75, 12, 75, 97,\n+        98, 98, 12, 13, 80, 75, 75, 75,\n+        12, 75, 85, 99, 75, 14, 80, 75,\n+        91, 91, 75, 14, 80, 75, 85, 75,\n+        91, 91, 75, 14, 80, 75, 91, 99,\n+        75, 14, 80, 75, 87, 77, 83, 83,\n+        12, 13, 80, 75, 75, 75, 12, 75,\n+        75, 81, 75, 87, 77, 88, 83, 12,\n+        13, 80, 75, 75, 17, 12, 75, 75,\n+        81, 75, 10, 11, 11, 12, 13, 75,\n+        75, 75, 75, 12, 75, 76, 77, 83,\n+        79, 12, 13, 80, 75, 75, 75, 12,\n+        75, 75, 81, 75, 101, 45, 102, 102,\n+        22, 23, 48, 100, 100, 100, 22, 100,\n+        100, 52, 100, 45, 102, 102, 22, 23,\n+        48, 100, 100, 100, 22, 100, 100, 52,\n+        100, 103, 100, 100, 100, 104, 105, 100,\n+        25, 48, 100, 100, 100, 100, 100, 103,\n+        100, 44, 45, 106, 107, 22, 23, 48,\n+        100, 100, 24, 22, 100, 100, 52, 100,\n+        103, 100, 100, 100, 108, 105, 100, 25,\n+        48, 100, 100, 100, 100, 100, 103, 100,\n+        48, 100, 100, 109, 48, 100, 48, 100,\n+        48, 100, 100, 100, 48, 100, 103, 100,\n+        110, 100, 108, 108, 100, 25, 48, 100,\n+        100, 100, 100, 100, 103, 100, 103, 100,\n+        100, 100, 108, 108, 100, 25, 48, 100,\n+        100, 100, 100, 100, 103, 100, 111, 112,\n+        113, 113, 22, 23, 48, 100, 100, 100,\n+        22, 100, 112, 113, 113, 22, 23, 48,\n+        100, 100, 100, 22, 100, 113, 113, 22,\n+        23, 48, 100, 100, 100, 22, 100, 48,\n+        100, 100, 109, 48, 100, 100, 100, 22,\n+        100, 44, 45, 102, 102, 22, 23, 48,\n+        100, 100, 100, 22, 100, 100, 52, 100,\n+        114, 115, 115, 22, 23, 48, 100, 100,\n+        100, 22, 100, 104, 116, 100, 25, 48,\n+        100, 108, 108, 100, 25, 48, 100, 104,\n+        100, 108, 108, 100, 25, 48, 100, 108,\n+        116, 100, 25, 48, 100, 44, 45, 106,\n+        102, 22, 23, 48, 100, 100, 24, 22,\n+        100, 100, 52, 100, 20, 21, 21, 22,\n+        23, 117, 117, 117, 24, 22, 117, 20,\n+        21, 21, 22, 23, 117, 117, 117, 117,\n+        22, 117, 119, 120, 121, 122, 32, 33,\n+        123, 118, 118, 34, 32, 118, 118, 124,\n+        118, 125, 120, 122, 122, 32, 33, 123,\n+        118, 118, 118, 32, 118, 118, 124, 118,\n+        120, 122, 122, 32, 33, 123, 118, 118,\n+        118, 32, 118, 118, 124, 118, 126, 118,\n+        118, 118, 127, 128, 118, 35, 123, 118,\n+        118, 118, 118, 118, 126, 118, 119, 120,\n+        121, 49, 32, 33, 123, 118, 118, 34,\n+        32, 118, 118, 124, 118, 126, 118, 118,\n+        118, 129, 128, 118, 35, 123, 118, 118,\n+        118, 118, 118, 126, 118, 123, 118, 118,\n+        130, 123, 118, 123, 118, 123, 118, 118,\n+        118, 123, 118, 126, 118, 131, 118, 129,\n+        129, 118, 35, 123, 118, 118, 118, 118,\n+        118, 126, 118, 126, 118, 118, 118, 129,\n+        129, 118, 35, 123, 118, 118, 118, 118,\n+        118, 126, 118, 132, 133, 134, 134, 32,\n+        33, 123, 118, 118, 118, 32, 118, 133,\n+        134, 134, 32, 33, 123, 118, 118, 118,\n+        32, 118, 134, 134, 32, 33, 123, 118,\n+        118, 118, 32, 118, 123, 118, 118, 130,\n+        123, 118, 118, 118, 32, 118, 119, 120,\n+        122, 122, 32, 33, 123, 118, 118, 118,\n+        32, 118, 118, 124, 118, 135, 136, 136,\n+        32, 33, 123, 118, 118, 118, 32, 118,\n+        127, 137, 118, 35, 123, 118, 129, 129,\n+        118, 35, 123, 118, 127, 118, 129, 129,\n+        118, 35, 123, 118, 129, 137, 118, 35,\n+        123, 118, 42, 43, 44, 45, 106, 102,\n+        22, 23, 48, 49, 49, 24, 22, 100,\n+        42, 52, 100, 56, 138, 58, 59, 4,\n+        5, 60, 55, 55, 8, 4, 55, 55,\n+        61, 55, 42, 43, 44, 45, 139, 140,\n+        22, 141, 142, 55, 49, 24, 22, 55,\n+        42, 52, 55, 20, 143, 143, 22, 141,\n+        60, 55, 55, 24, 22, 55, 60, 55,\n+        55, 67, 60, 55, 55, 55, 22, 55,\n+        142, 55, 55, 144, 142, 55, 55, 55,\n+        22, 55, 142, 55, 142, 55, 55, 55,\n+        142, 55, 42, 55, 68, 20, 143, 143,\n+        22, 141, 60, 55, 55, 55, 22, 55,\n+        42, 55, 146, 145, 147, 147, 145, 40,\n+        148, 145, 147, 147, 145, 40, 148, 145,\n+        148, 145, 145, 149, 148, 145, 148, 145,\n+        148, 145, 145, 145, 148, 145, 42, 117,\n+        117, 117, 117, 117, 117, 117, 117, 49,\n+        117, 117, 117, 117, 42, 117, 0\n@@ -294,18 +327,19 @@\n-        27, 33, 38, 2, 39, 45, 46, 27,\n-        55, 8, 61, 56, 68, 69, 72, 27,\n-        77, 15, 83, 78, 86, 27, 91, 27,\n-        100, 21, 106, 101, 109, 114, 27, 125,\n-        27, 28, 48, 73, 75, 93, 94, 79,\n-        95, 115, 116, 87, 123, 128, 27, 29,\n-        31, 5, 47, 34, 42, 30, 1, 32,\n-        36, 0, 35, 37, 40, 41, 3, 43,\n-        4, 44, 27, 49, 51, 12, 71, 57,\n-        64, 50, 6, 52, 66, 59, 53, 11,\n-        70, 54, 7, 58, 60, 62, 63, 9,\n-        65, 10, 67, 27, 74, 17, 76, 89,\n-        81, 13, 92, 14, 80, 82, 84, 85,\n-        16, 88, 18, 90, 27, 27, 96, 98,\n-        19, 23, 102, 110, 97, 99, 112, 104,\n-        20, 103, 105, 107, 108, 22, 111, 24,\n-        113, 117, 118, 122, 119, 120, 25, 121,\n-        27, 124, 26, 126, 127\n+        31, 37, 42, 2, 43, 46, 4, 50,\n+        51, 31, 60, 9, 66, 69, 61, 11,\n+        74, 75, 78, 31, 83, 17, 89, 92,\n+        93, 84, 31, 19, 98, 31, 107, 24,\n+        113, 116, 117, 108, 26, 122, 127, 31,\n+        134, 31, 32, 53, 79, 81, 100, 101,\n+        85, 102, 123, 124, 94, 132, 137, 31,\n+        33, 35, 6, 52, 38, 47, 34, 1,\n+        36, 40, 0, 39, 41, 44, 45, 3,\n+        48, 5, 49, 31, 54, 56, 14, 77,\n+        62, 70, 55, 7, 57, 72, 64, 58,\n+        13, 76, 59, 8, 63, 65, 67, 68,\n+        10, 71, 12, 73, 31, 80, 20, 82,\n+        96, 87, 15, 99, 16, 86, 88, 90,\n+        91, 18, 95, 21, 97, 31, 31, 103,\n+        105, 22, 27, 109, 118, 104, 106, 120,\n+        111, 23, 110, 112, 114, 115, 25, 119,\n+        28, 121, 125, 126, 131, 128, 129, 29,\n+        130, 31, 133, 30, 135, 136\n@@ -315,10 +349,8 @@\n-        1, 0, 2, 0, 2, 2, 2, 3,\n-        2, 0, 2, 0, 2, 2, 2, 4,\n-        2, 0, 5, 0, 5, 6, 2, 7,\n-        2, 0, 2, 0, 2, 2, 8, 0,\n-        11, 2, 2, 5, 0, 12, 12, 0,\n-        2, 5, 2, 5, 2, 0, 13, 2,\n-        0, 0, 2, 0, 2, 2, 0, 2,\n-        2, 0, 0, 2, 2, 2, 0, 0,\n-        0, 2, 14, 2, 0, 0, 2, 0,\n-        2, 2, 0, 2, 2, 2, 2, 0,\n+        1, 0, 2, 0, 2, 0, 0, 2,\n+        2, 3, 2, 0, 2, 0, 0, 0,\n+        2, 2, 2, 4, 2, 0, 5, 0,\n+        5, 0, 6, 0, 2, 7, 2, 0,\n+        2, 0, 2, 0, 0, 2, 0, 8,\n+        0, 11, 2, 2, 5, 0, 12, 12,\n+        0, 2, 5, 2, 5, 2, 0, 13,\n+        2, 0, 0, 2, 0, 2, 2, 0,\n@@ -326,7 +358,10 @@\n-        0, 0, 2, 15, 5, 0, 5, 2,\n-        2, 0, 5, 0, 0, 2, 5, 5,\n-        0, 0, 0, 2, 16, 17, 2, 0,\n-        0, 0, 0, 2, 2, 2, 2, 2,\n-        0, 0, 2, 2, 2, 0, 0, 0,\n-        2, 0, 18, 18, 0, 0, 0, 0,\n-        19, 2, 0, 0, 0\n+        0, 0, 2, 14, 2, 0, 0, 2,\n+        0, 2, 2, 0, 2, 2, 2, 2,\n+        0, 2, 2, 0, 0, 2, 2, 2,\n+        0, 0, 0, 2, 15, 5, 0, 5,\n+        2, 2, 0, 5, 0, 0, 2, 5,\n+        5, 0, 0, 0, 2, 16, 17, 2,\n+        0, 0, 0, 0, 2, 2, 2, 2,\n+        2, 0, 0, 2, 2, 2, 0, 0,\n+        0, 2, 0, 18, 18, 0, 0, 0,\n+        0, 19, 2, 0, 0, 0\n@@ -339,1 +374,1 @@\n-        0, 0, 0, 9, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 9,\n@@ -352,1 +387,2 @@\n-        0\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0\n@@ -359,1 +395,2 @@\n-        0, 0, 0, 10, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 10,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n@@ -372,1 +409,1 @@\n-        0\n+        0, 0\n@@ -376,17 +413,18 @@\n-        1, 1, 1, 1, 1, 1, 8, 8,\n-        8, 8, 8, 8, 8, 16, 16, 22,\n-        16, 16, 16, 24, 24, 24, 24, 24,\n-        24, 1, 31, 0, 47, 47, 47, 47,\n-        47, 47, 47, 47, 47, 47, 47, 47,\n-        47, 47, 47, 47, 47, 47, 47, 47,\n-        67, 67, 67, 67, 67, 67, 67, 67,\n-        67, 67, 67, 67, 67, 67, 67, 67,\n-        67, 67, 67, 67, 67, 67, 67, 67,\n-        67, 92, 92, 92, 92, 92, 92, 92,\n-        92, 92, 92, 92, 92, 92, 92, 92,\n-        92, 92, 92, 92, 92, 109, 109, 110,\n-        110, 110, 110, 110, 110, 110, 110, 110,\n-        110, 110, 110, 110, 110, 110, 110, 110,\n-        110, 110, 110, 92, 47, 47, 47, 47,\n-        47, 47, 47, 137, 137, 137, 137, 137,\n-        109\n+        1, 1, 1, 1, 1, 1, 1, 10,\n+        10, 10, 10, 10, 10, 10, 10, 20,\n+        20, 27, 20, 27, 20, 20, 30, 30,\n+        30, 30, 30, 30, 30, 1, 40, 0,\n+        56, 56, 56, 56, 56, 56, 56, 56,\n+        56, 56, 56, 56, 56, 56, 56, 56,\n+        56, 56, 56, 56, 56, 76, 76, 76,\n+        76, 76, 76, 76, 76, 76, 76, 76,\n+        76, 76, 76, 76, 76, 76, 76, 76,\n+        76, 76, 76, 76, 76, 76, 76, 101,\n+        101, 101, 101, 101, 101, 101, 101, 101,\n+        101, 101, 101, 101, 101, 101, 101, 101,\n+        101, 101, 101, 101, 118, 118, 119, 119,\n+        119, 119, 119, 119, 119, 119, 119, 119,\n+        119, 119, 119, 119, 119, 119, 119, 119,\n+        119, 119, 119, 101, 56, 56, 56, 56,\n+        56, 56, 56, 56, 146, 146, 146, 146,\n+        146, 118\n@@ -395,2 +433,2 @@\n-static const int indic_syllable_machine_start = 27;\n-static const int indic_syllable_machine_first_final = 27;\n+static const int indic_syllable_machine_start = 31;\n+static const int indic_syllable_machine_first_final = 31;\n@@ -399,1 +437,1 @@\n-static const int indic_syllable_machine_en_main = 27;\n+static const int indic_syllable_machine_en_main = 31;\n@@ -406,1 +444,1 @@\n-#line 117 \"hb-ot-shaper-indic-machine.rl\"\n+#line 118 \"hb-ot-shaper-indic-machine.rl\"\n@@ -411,1 +449,1 @@\n-    if (0) fprintf (stderr, \"syllable %d..%d %s\\n\", ts, te, #syllable_type); \\\n+    if (0) fprintf (stderr, \"syllable %u..%u %s\\n\", ts, te, #syllable_type); \\\n@@ -415,1 +453,1 @@\n-    if (unlikely (syllable_serial == 16)) syllable_serial = 1; \\\n+    if (syllable_serial == 16) syllable_serial = 1; \\\n@@ -425,1 +463,1 @@\n-#line 426 \"hb-ot-shaper-indic-machine.hh\"\n+#line 453 \"hb-ot-shaper-indic-machine.hh\"\n@@ -433,1 +471,1 @@\n-#line 137 \"hb-ot-shaper-indic-machine.rl\"\n+#line 138 \"hb-ot-shaper-indic-machine.rl\"\n@@ -441,1 +479,1 @@\n-#line 442 \"hb-ot-shaper-indic-machine.hh\"\n+#line 465 \"hb-ot-shaper-indic-machine.hh\"\n@@ -455,1 +493,1 @@\n-#line 456 \"hb-ot-shaper-indic-machine.hh\"\n+#line 477 \"hb-ot-shaper-indic-machine.hh\"\n@@ -478,1 +516,1 @@\n-#line 113 \"hb-ot-shaper-indic-machine.rl\"\n+#line 114 \"hb-ot-shaper-indic-machine.rl\"\n@@ -482,1 +520,1 @@\n-#line 108 \"hb-ot-shaper-indic-machine.rl\"\n+#line 109 \"hb-ot-shaper-indic-machine.rl\"\n@@ -486,1 +524,1 @@\n-#line 109 \"hb-ot-shaper-indic-machine.rl\"\n+#line 110 \"hb-ot-shaper-indic-machine.rl\"\n@@ -490,1 +528,1 @@\n-#line 110 \"hb-ot-shaper-indic-machine.rl\"\n+#line 111 \"hb-ot-shaper-indic-machine.rl\"\n@@ -494,1 +532,1 @@\n-#line 111 \"hb-ot-shaper-indic-machine.rl\"\n+#line 112 \"hb-ot-shaper-indic-machine.rl\"\n@@ -498,1 +536,1 @@\n-#line 112 \"hb-ot-shaper-indic-machine.rl\"\n+#line 113 \"hb-ot-shaper-indic-machine.rl\"\n@@ -502,1 +540,1 @@\n-#line 113 \"hb-ot-shaper-indic-machine.rl\"\n+#line 114 \"hb-ot-shaper-indic-machine.rl\"\n@@ -506,1 +544,1 @@\n-#line 108 \"hb-ot-shaper-indic-machine.rl\"\n+#line 109 \"hb-ot-shaper-indic-machine.rl\"\n@@ -510,1 +548,1 @@\n-#line 109 \"hb-ot-shaper-indic-machine.rl\"\n+#line 110 \"hb-ot-shaper-indic-machine.rl\"\n@@ -514,1 +552,1 @@\n-#line 110 \"hb-ot-shaper-indic-machine.rl\"\n+#line 111 \"hb-ot-shaper-indic-machine.rl\"\n@@ -518,1 +556,1 @@\n-#line 111 \"hb-ot-shaper-indic-machine.rl\"\n+#line 112 \"hb-ot-shaper-indic-machine.rl\"\n@@ -522,1 +560,1 @@\n-#line 112 \"hb-ot-shaper-indic-machine.rl\"\n+#line 113 \"hb-ot-shaper-indic-machine.rl\"\n@@ -543,1 +581,1 @@\n-#line 108 \"hb-ot-shaper-indic-machine.rl\"\n+#line 109 \"hb-ot-shaper-indic-machine.rl\"\n@@ -549,1 +587,1 @@\n-#line 112 \"hb-ot-shaper-indic-machine.rl\"\n+#line 113 \"hb-ot-shaper-indic-machine.rl\"\n@@ -555,1 +593,1 @@\n-#line 113 \"hb-ot-shaper-indic-machine.rl\"\n+#line 114 \"hb-ot-shaper-indic-machine.rl\"\n@@ -567,1 +605,1 @@\n-#line 568 \"hb-ot-shaper-indic-machine.hh\"\n+#line 566 \"hb-ot-shaper-indic-machine.hh\"\n@@ -583,1 +621,1 @@\n-#line 145 \"hb-ot-shaper-indic-machine.rl\"\n+#line 146 \"hb-ot-shaper-indic-machine.rl\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-indic-machine.hh","additions":325,"deletions":287,"binary":false,"changes":612,"status":"modified"},{"patch":"@@ -9,6 +9,6 @@\n- * # IndicSyllabicCategory-14.0.0.txt\n- * # Date: 2021-05-22, 01:01:00 GMT [KW, RP]\n- * # IndicPositionalCategory-14.0.0.txt\n- * # Date: 2021-05-22, 01:01:00 GMT [KW, RP]\n- * # Blocks-14.0.0.txt\n- * # Date: 2021-01-22, 23:29:00 GMT [KW]\n+ * # IndicSyllabicCategory-15.0.0.txt\n+ * # Date: 2022-05-26, 02:18:00 GMT [KW, RP]\n+ * # IndicPositionalCategory-15.0.0.txt\n+ * # Date: 2022-05-26, 02:18:00 GMT [KW, RP]\n+ * # Blocks-15.0.0.txt\n+ * # Date: 2022-01-28, 20:58:00 GMT [KW]\n@@ -45,0 +45,1 @@\n+#define OT_MPst I_Cat(MPst)\n@@ -83,1 +84,1 @@\n-#define _OT_M    OT_M            \/* 143 chars; M *\/\n+#define _OT_M    OT_M            \/* 142 chars; M *\/\n@@ -86,0 +87,1 @@\n+#define _OT_MP   OT_MPst         \/*   1 chars; MPst *\/\n@@ -95,1 +97,1 @@\n-#define _OT_SM   OT_SM           \/*  55 chars; SM *\/\n+#define _OT_SM   OT_SM           \/*  56 chars; SM *\/\n@@ -120,1 +122,1 @@\n-#define _POS_SM  POS_SMVD        \/* 129 chars; SMVD *\/\n+#define _POS_SM  POS_SMVD        \/* 130 chars; SMVD *\/\n@@ -203,1 +205,1 @@\n-  \/* 0A40 *\/ _(M,AP), _(M,AP), _(M,AP),  _(X,X),  _(X,X),  _(X,X),  _(X,X), _(M,AP),\n+  \/* 0A40 *\/_(MP,AP), _(M,AP), _(M,AP),  _(X,X),  _(X,X),  _(X,X),  _(X,X), _(M,AP),\n@@ -304,1 +306,1 @@\n-  \/* 0CF0 *\/  _(X,X), _(CS,C), _(CS,C),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 0CF0 *\/  _(X,X), _(CS,C), _(CS,C),_(SM,SM),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n@@ -454,6 +456,3 @@\n-  \/* 11308 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n-  \/* 11310 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n-  \/* 11318 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n-  \/* 11320 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n-  \/* 11328 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n-  \/* 11330 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+\n+#define indic_offset_0x11338u 1720\n+\n@@ -462,1 +461,1 @@\n-}; \/* Table items: 1776; occupancy: 69% *\/\n+}; \/* Table items: 1728; occupancy: 71% *\/\n@@ -500,1 +499,2 @@\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11300u, 0x1133Fu)) return indic_table[u - 0x11300u + indic_offset_0x11300u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11300u, 0x11307u)) return indic_table[u - 0x11300u + indic_offset_0x11300u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11338u, 0x1133Fu)) return indic_table[u - 0x11338u + indic_offset_0x11338u];\n@@ -522,0 +522,1 @@\n+#undef _OT_MP\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-indic-table.cc","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -95,3 +95,2 @@\n-    map->get_stage_lookups (0\/*GSUB*\/,\n-                            map->get_feature_stage (0\/*GSUB*\/, feature_tag),\n-                            &lookups, &count);\n+    lookups = map->get_stage_lookups (0\/*GSUB*\/,\n+                                      map->get_feature_stage (0\/*GSUB*\/, feature_tag));\n@@ -104,2 +103,2 @@\n-    for (unsigned int i = 0; i < count; i++)\n-      if (hb_ot_layout_lookup_would_substitute (face, lookups[i].index, glyphs, glyphs_count, zero_context))\n+    for (const auto &lookup : lookups)\n+      if (hb_ot_layout_lookup_would_substitute (face, lookup.index, glyphs, glyphs_count, zero_context))\n@@ -111,2 +110,1 @@\n-  const hb_ot_map_t::lookup_map_t *lookups;\n-  unsigned int count;\n+  hb_array_t<const hb_ot_map_t::lookup_map_t> lookups;\n@@ -228,1 +226,1 @@\n-static void\n+static bool\n@@ -232,1 +230,1 @@\n-static void\n+static bool\n@@ -236,1 +234,1 @@\n-static void\n+static bool\n@@ -281,1 +279,1 @@\n-    hb_codepoint_t glyph = virama_glyph.get_relaxed ();\n+    hb_codepoint_t glyph = virama_glyph;\n@@ -291,1 +289,1 @@\n-      virama_glyph.set_relaxed ((int) glyph);\n+      virama_glyph = (int) glyph;\n@@ -335,1 +333,1 @@\n-  indic_plan->virama_glyph.set_relaxed (-1);\n+  indic_plan->virama_glyph = -1;\n@@ -418,1 +416,1 @@\n-static void\n+static bool\n@@ -427,0 +425,1 @@\n+  return false;\n@@ -486,3 +485,1 @@\n-    hb_glyph_info_t tmp = info[start+1];\n-    info[start+1] = info[start+2];\n-    info[start+2] = tmp;\n+    hb_swap (info[start+1], info[start+2]);\n@@ -719,0 +716,3 @@\n+        if (info[i].indic_category() == I_Cat(MPst) &&\n+            i > start && info[i - 1].indic_category() == I_Cat(SM))\n+          info[i - 1].indic_position() = info[i].indic_position();\n@@ -734,1 +734,1 @@\n-      } else if (info[i].indic_category() == I_Cat(M))\n+      } else if (FLAG_UNSAFE (info[i].indic_category()) & (FLAG (I_Cat(M)) | FLAG (I_Cat(MPst))))\n@@ -747,1 +747,4 @@\n-    \/* Find base again *\/\n+\n+    \/* Find base again; also flip left-matra sequence. *\/\n+    unsigned first_left_matra = end;\n+    unsigned last_left_matra = end;\n@@ -750,0 +753,1 @@\n+    {\n@@ -755,0 +759,22 @@\n+      else if (info[i].indic_position() == POS_PRE_M)\n+      {\n+        if (first_left_matra == end)\n+          first_left_matra = i;\n+        last_left_matra = i;\n+      }\n+    }\n+    \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/3863 *\/\n+    if (first_left_matra < last_left_matra)\n+    {\n+      \/* No need to merge clusters, handled later. *\/\n+      buffer->reverse_range (first_left_matra, last_left_matra + 1);\n+      \/* Reverse back nuktas, etc. *\/\n+      unsigned i = first_left_matra;\n+      for (unsigned j = i; j <= last_left_matra; j++)\n+        if (FLAG_UNSAFE (info[j].indic_category()) & (FLAG (I_Cat(M)) | FLAG (I_Cat(MPst))))\n+        {\n+          buffer->reverse_range (i, j + 1);\n+          i = j + 1;\n+        }\n+    }\n+\n@@ -960,1 +986,1 @@\n-static void\n+static bool\n@@ -965,0 +991,1 @@\n+  bool ret = false;\n@@ -966,1 +993,1 @@\n-    return;\n+    return ret;\n@@ -969,5 +996,6 @@\n-  hb_syllabic_insert_dotted_circles (font, buffer,\n-                                     indic_broken_cluster,\n-                                     I_Cat(DOTTEDCIRCLE),\n-                                     I_Cat(Repha),\n-                                     POS_END);\n+  if (hb_syllabic_insert_dotted_circles (font, buffer,\n+                                         indic_broken_cluster,\n+                                         I_Cat(DOTTEDCIRCLE),\n+                                         I_Cat(Repha),\n+                                         POS_END))\n+    ret = true;\n@@ -979,0 +1007,2 @@\n+\n+  return ret;\n@@ -997,1 +1027,1 @@\n-  hb_codepoint_t virama_glyph = indic_plan->virama_glyph.get_relaxed ();\n+  hb_codepoint_t virama_glyph = indic_plan->virama_glyph;\n@@ -1121,1 +1151,1 @@\n-             !(is_one_of (info[new_pos], (FLAG (I_Cat(M)) | FLAG (I_Cat(H))))))\n+             !(is_one_of (info[new_pos], (FLAG (I_Cat(M)) | FLAG (I_Cat(MPst)) | FLAG (I_Cat(H))))))\n@@ -1321,1 +1351,2 @@\n-          if (info[i].indic_category() == I_Cat(M)) {\n+          if (FLAG_UNSAFE (info[i].indic_category()) & (FLAG (I_Cat(M)) | FLAG (I_Cat(MPst))))\n+          {\n@@ -1381,1 +1412,1 @@\n-                   !(is_one_of (info[new_pos - 1], FLAG(I_Cat(M)) | FLAG (I_Cat(H)))))\n+                   !(is_one_of (info[new_pos - 1], FLAG (I_Cat(M)) | FLAG (I_Cat(MPst)) | FLAG (I_Cat(H)))))\n@@ -1444,1 +1475,1 @@\n-static void\n+static bool\n@@ -1450,1 +1481,1 @@\n-  if (unlikely (!count)) return;\n+  if (unlikely (!count)) return false;\n@@ -1460,0 +1491,2 @@\n+\n+  return false;\n@@ -1531,1 +1564,0 @@\n-  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n@@ -1535,1 +1567,0 @@\n-  HB_TAG_NONE, \/* gpos_tag *\/\n@@ -1537,0 +1568,2 @@\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-indic.cc","additions":67,"deletions":34,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-#line 52 \"hb-ot-shaper-khmer-machine.hh\"\n+#line 49 \"hb-ot-shaper-khmer-machine.hh\"\n@@ -69,1 +69,1 @@\n-#line 70 \"hb-ot-shaper-khmer-machine.hh\"\n+#line 65 \"hb-ot-shaper-khmer-machine.hh\"\n@@ -283,1 +283,1 @@\n-    if (0) fprintf (stderr, \"syllable %d..%d %s\\n\", ts, te, #syllable_type); \\\n+    if (0) fprintf (stderr, \"syllable %u..%u %s\\n\", ts, te, #syllable_type); \\\n@@ -287,1 +287,1 @@\n-    if (unlikely (syllable_serial == 16)) syllable_serial = 1; \\\n+    if (syllable_serial == 16) syllable_serial = 1; \\\n@@ -297,1 +297,1 @@\n-#line 298 \"hb-ot-shaper-khmer-machine.hh\"\n+#line 287 \"hb-ot-shaper-khmer-machine.hh\"\n@@ -313,1 +313,1 @@\n-#line 314 \"hb-ot-shaper-khmer-machine.hh\"\n+#line 299 \"hb-ot-shaper-khmer-machine.hh\"\n@@ -327,1 +327,1 @@\n-#line 328 \"hb-ot-shaper-khmer-machine.hh\"\n+#line 311 \"hb-ot-shaper-khmer-machine.hh\"\n@@ -397,1 +397,1 @@\n-#line 398 \"hb-ot-shaper-khmer-machine.hh\"\n+#line 368 \"hb-ot-shaper-khmer-machine.hh\"\n@@ -406,1 +406,1 @@\n-#line 407 \"hb-ot-shaper-khmer-machine.hh\"\n+#line 375 \"hb-ot-shaper-khmer-machine.hh\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-khmer-machine.hh","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-static void\n+static bool\n@@ -96,1 +96,1 @@\n-static void\n+static bool\n@@ -195,1 +195,1 @@\n-static void\n+static bool\n@@ -204,0 +204,1 @@\n+  return false;\n@@ -306,1 +307,1 @@\n-static void\n+static bool\n@@ -311,0 +312,1 @@\n+  bool ret = false;\n@@ -313,4 +315,5 @@\n-    hb_syllabic_insert_dotted_circles (font, buffer,\n-                                       khmer_broken_cluster,\n-                                       K_Cat(DOTTEDCIRCLE),\n-                                       (unsigned) -1);\n+    if (hb_syllabic_insert_dotted_circles (font, buffer,\n+                                           khmer_broken_cluster,\n+                                           K_Cat(DOTTEDCIRCLE),\n+                                           (unsigned) -1))\n+      ret = true;\n@@ -323,0 +326,2 @@\n+\n+  return ret;\n@@ -371,1 +376,0 @@\n-  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n@@ -375,1 +379,0 @@\n-  HB_TAG_NONE, \/* gpos_tag *\/\n@@ -377,0 +380,2 @@\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-khmer.cc","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-#line 54 \"hb-ot-shaper-myanmar-machine.hh\"\n+#line 51 \"hb-ot-shaper-myanmar-machine.hh\"\n@@ -80,1 +80,1 @@\n-#line 81 \"hb-ot-shaper-myanmar-machine.hh\"\n+#line 76 \"hb-ot-shaper-myanmar-machine.hh\"\n@@ -432,1 +432,1 @@\n-    if (0) fprintf (stderr, \"syllable %d..%d %s\\n\", ts, te, #syllable_type); \\\n+    if (0) fprintf (stderr, \"syllable %u..%u %s\\n\", ts, te, #syllable_type); \\\n@@ -436,1 +436,1 @@\n-    if (unlikely (syllable_serial == 16)) syllable_serial = 1; \\\n+    if (syllable_serial == 16) syllable_serial = 1; \\\n@@ -446,1 +446,1 @@\n-#line 447 \"hb-ot-shaper-myanmar-machine.hh\"\n+#line 436 \"hb-ot-shaper-myanmar-machine.hh\"\n@@ -462,1 +462,1 @@\n-#line 463 \"hb-ot-shaper-myanmar-machine.hh\"\n+#line 448 \"hb-ot-shaper-myanmar-machine.hh\"\n@@ -476,1 +476,1 @@\n-#line 477 \"hb-ot-shaper-myanmar-machine.hh\"\n+#line 460 \"hb-ot-shaper-myanmar-machine.hh\"\n@@ -522,1 +522,1 @@\n-#line 523 \"hb-ot-shaper-myanmar-machine.hh\"\n+#line 498 \"hb-ot-shaper-myanmar-machine.hh\"\n@@ -531,1 +531,1 @@\n-#line 532 \"hb-ot-shaper-myanmar-machine.hh\"\n+#line 505 \"hb-ot-shaper-myanmar-machine.hh\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-myanmar-machine.hh","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-static void\n+static bool\n@@ -105,1 +105,1 @@\n-static void\n+static bool\n@@ -153,1 +153,1 @@\n-static void\n+static bool\n@@ -162,0 +162,1 @@\n+  return false;\n@@ -273,0 +274,27 @@\n+\n+  \/* Flip left-matra sequence. *\/\n+  unsigned first_left_matra = end;\n+  unsigned last_left_matra = end;\n+  for (unsigned int i = start; i < end; i++)\n+  {\n+    if (info[i].myanmar_position() == POS_PRE_M)\n+    {\n+      if (first_left_matra == end)\n+        first_left_matra = i;\n+      last_left_matra = i;\n+    }\n+  }\n+  \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/3863 *\/\n+  if (first_left_matra < last_left_matra)\n+  {\n+    \/* No need to merge clusters, done already? *\/\n+    buffer->reverse_range (first_left_matra, last_left_matra + 1);\n+    \/* Reverse back VS, etc. *\/\n+    unsigned i = first_left_matra;\n+    for (unsigned j = i; j <= last_left_matra; j++)\n+      if (info[j].myanmar_category() == M_Cat(VPre))\n+      {\n+        buffer->reverse_range (i, j + 1);\n+        i = j + 1;\n+      }\n+  }\n@@ -294,1 +322,1 @@\n-static void\n+static bool\n@@ -299,0 +327,1 @@\n+  bool ret = false;\n@@ -301,3 +330,4 @@\n-    hb_syllabic_insert_dotted_circles (font, buffer,\n-                                       myanmar_broken_cluster,\n-                                       M_Cat(DOTTEDCIRCLE));\n+    if (hb_syllabic_insert_dotted_circles (font, buffer,\n+                                           myanmar_broken_cluster,\n+                                           M_Cat(DOTTEDCIRCLE)))\n+      ret = true;\n@@ -312,0 +342,2 @@\n+\n+  return ret;\n@@ -323,1 +355,0 @@\n-  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n@@ -327,1 +358,0 @@\n-  HB_TAG_NONE, \/* gpos_tag *\/\n@@ -329,0 +359,2 @@\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n@@ -334,0 +366,1 @@\n+#ifndef HB_NO_OT_SHAPER_MYANMAR_ZAWGYI\n@@ -345,1 +378,0 @@\n-  HB_OT_SHAPE_NORMALIZATION_MODE_NONE,\n@@ -349,1 +381,0 @@\n-  HB_TAG_NONE, \/* gpos_tag *\/\n@@ -351,0 +382,2 @@\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_NONE,\n@@ -354,0 +387,1 @@\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-myanmar.cc","additions":45,"deletions":11,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-void\n+bool\n@@ -41,1 +41,1 @@\n-    return;\n+    return false;\n@@ -43,1 +43,1 @@\n-    return;\n+    return false;\n@@ -47,1 +47,1 @@\n-    return;\n+    return false;\n@@ -87,0 +87,1 @@\n+  return true;\n@@ -89,1 +90,1 @@\n-HB_INTERNAL void\n+HB_INTERNAL bool\n@@ -95,0 +96,1 @@\n+  return false;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-syllabic.cc","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-HB_INTERNAL void\n+HB_INTERNAL bool\n@@ -41,1 +41,1 @@\n-HB_INTERNAL void\n+HB_INTERNAL bool\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-syllabic.hh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -101,3 +101,3 @@\n-    hb_codepoint_t u;\n-    hb_codepoint_t win_pua;\n-    hb_codepoint_t mac_pua;\n+    uint16_t u;\n+    uint16_t win_pua;\n+    uint16_t mac_pua;\n@@ -382,1 +382,0 @@\n-  HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,\n@@ -386,1 +385,0 @@\n-  HB_TAG_NONE, \/* gpos_tag *\/\n@@ -388,0 +386,2 @@\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-thai.cc","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-#line 57 \"hb-ot-shaper-use-machine.hh\"\n+#line 54 \"hb-ot-shaper-use-machine.hh\"\n@@ -100,1 +100,1 @@\n-#line 101 \"hb-ot-shaper-use-machine.hh\"\n+#line 96 \"hb-ot-shaper-use-machine.hh\"\n@@ -102,16 +102,16 @@\n-        0u, 53u, 11u, 53u, 11u, 53u, 1u, 53u, 23u, 48u, 24u, 47u, 25u, 47u, 26u, 47u,\n-        45u, 46u, 46u, 46u, 24u, 48u, 24u, 48u, 24u, 48u, 1u, 1u, 24u, 48u, 22u, 53u,\n-        23u, 53u, 23u, 53u, 23u, 53u, 12u, 53u, 23u, 53u, 12u, 53u, 12u, 53u, 12u, 53u,\n-        11u, 53u, 1u, 1u, 1u, 48u, 11u, 53u, 41u, 42u, 42u, 42u, 11u, 53u, 11u, 53u,\n-        1u, 53u, 23u, 48u, 24u, 47u, 25u, 47u, 26u, 47u, 45u, 46u, 46u, 46u, 24u, 48u,\n-        24u, 48u, 24u, 48u, 1u, 1u, 24u, 48u, 22u, 53u, 23u, 53u, 23u, 53u, 23u, 53u,\n-        12u, 53u, 23u, 53u, 12u, 53u, 12u, 53u, 12u, 53u, 11u, 53u, 1u, 1u, 1u, 48u,\n-        13u, 13u, 4u, 4u, 11u, 53u, 11u, 53u, 1u, 53u, 23u, 48u, 24u, 47u, 25u, 47u,\n-        26u, 47u, 45u, 46u, 46u, 46u, 24u, 48u, 24u, 48u, 24u, 48u, 1u, 1u, 24u, 48u,\n-        22u, 53u, 23u, 53u, 23u, 53u, 23u, 53u, 12u, 53u, 23u, 53u, 12u, 53u, 12u, 53u,\n-        12u, 53u, 11u, 53u, 1u, 1u, 1u, 48u, 11u, 53u, 11u, 53u, 1u, 53u, 23u, 48u,\n-        24u, 47u, 25u, 47u, 26u, 47u, 45u, 46u, 46u, 46u, 24u, 48u, 24u, 48u, 24u, 48u,\n-        1u, 1u, 24u, 48u, 22u, 53u, 23u, 53u, 23u, 53u, 23u, 53u, 12u, 53u, 23u, 53u,\n-        12u, 53u, 12u, 53u, 12u, 53u, 11u, 53u, 1u, 1u, 1u, 48u, 4u, 4u, 13u, 13u,\n-        1u, 53u, 11u, 53u, 41u, 42u, 42u, 42u, 1u, 5u, 50u, 52u, 49u, 52u, 49u, 51u,\n-        0\n+        0u, 53u, 11u, 53u, 11u, 53u, 1u, 53u, 14u, 48u, 14u, 47u, 14u, 47u, 14u, 47u,\n+        14u, 46u, 14u, 46u, 14u, 14u, 14u, 48u, 14u, 48u, 14u, 48u, 1u, 14u, 14u, 48u,\n+        14u, 53u, 14u, 53u, 14u, 53u, 14u, 53u, 12u, 53u, 14u, 53u, 12u, 53u, 12u, 53u,\n+        12u, 53u, 11u, 53u, 1u, 14u, 1u, 48u, 11u, 53u, 14u, 42u, 14u, 42u, 11u, 53u,\n+        11u, 53u, 1u, 53u, 14u, 48u, 14u, 47u, 14u, 47u, 14u, 47u, 14u, 46u, 14u, 46u,\n+        14u, 14u, 14u, 48u, 14u, 48u, 14u, 48u, 1u, 14u, 14u, 48u, 14u, 53u, 14u, 53u,\n+        14u, 53u, 14u, 53u, 12u, 53u, 14u, 53u, 12u, 53u, 12u, 53u, 12u, 53u, 11u, 53u,\n+        1u, 14u, 1u, 14u, 1u, 48u, 13u, 14u, 4u, 14u, 11u, 53u, 11u, 53u, 1u, 53u,\n+        14u, 48u, 14u, 47u, 14u, 47u, 14u, 47u, 14u, 46u, 14u, 46u, 14u, 14u, 14u, 48u,\n+        14u, 48u, 14u, 48u, 1u, 14u, 14u, 48u, 14u, 53u, 14u, 53u, 14u, 53u, 14u, 53u,\n+        12u, 53u, 14u, 53u, 12u, 53u, 12u, 53u, 12u, 53u, 11u, 53u, 1u, 14u, 1u, 14u,\n+        1u, 48u, 11u, 53u, 11u, 53u, 1u, 53u, 14u, 48u, 14u, 47u, 14u, 47u, 14u, 47u,\n+        14u, 46u, 14u, 46u, 14u, 14u, 14u, 48u, 14u, 48u, 14u, 48u, 1u, 14u, 14u, 48u,\n+        14u, 53u, 14u, 53u, 14u, 53u, 14u, 53u, 12u, 53u, 14u, 53u, 12u, 53u, 12u, 53u,\n+        12u, 53u, 11u, 53u, 1u, 14u, 1u, 48u, 4u, 14u, 13u, 14u, 1u, 53u, 11u, 53u,\n+        14u, 42u, 14u, 42u, 1u, 5u, 14u, 52u, 14u, 52u, 14u, 51u, 0\n@@ -121,15 +121,16 @@\n-        54, 43, 43, 53, 26, 24, 23, 22,\n-        2, 1, 25, 25, 25, 1, 25, 32,\n-        31, 31, 31, 42, 31, 42, 42, 42,\n-        43, 1, 48, 43, 2, 1, 43, 43,\n-        53, 26, 24, 23, 22, 2, 1, 25,\n-        25, 25, 1, 25, 32, 31, 31, 31,\n-        42, 31, 42, 42, 42, 43, 1, 48,\n-        1, 1, 43, 43, 53, 26, 24, 23,\n-        22, 2, 1, 25, 25, 25, 1, 25,\n-        32, 31, 31, 31, 42, 31, 42, 42,\n-        42, 43, 1, 48, 43, 43, 53, 26,\n-        24, 23, 22, 2, 1, 25, 25, 25,\n-        1, 25, 32, 31, 31, 31, 42, 31,\n-        42, 42, 42, 43, 1, 48, 1, 1,\n-        53, 43, 2, 1, 5, 3, 4, 3\n+        54, 43, 43, 53, 35, 34, 34, 34,\n+        33, 33, 1, 35, 35, 35, 14, 35,\n+        40, 40, 40, 40, 42, 40, 42, 42,\n+        42, 43, 14, 48, 43, 29, 29, 43,\n+        43, 53, 35, 34, 34, 34, 33, 33,\n+        1, 35, 35, 35, 14, 35, 40, 40,\n+        40, 40, 42, 40, 42, 42, 42, 43,\n+        14, 14, 48, 2, 11, 43, 43, 53,\n+        35, 34, 34, 34, 33, 33, 1, 35,\n+        35, 35, 14, 35, 40, 40, 40, 40,\n+        42, 40, 42, 42, 42, 43, 14, 14,\n+        48, 43, 43, 53, 35, 34, 34, 34,\n+        33, 33, 1, 35, 35, 35, 14, 35,\n+        40, 40, 40, 40, 42, 40, 42, 42,\n+        42, 43, 14, 48, 11, 2, 53, 43,\n+        29, 29, 5, 39, 39, 38\n@@ -139,15 +140,16 @@\n-        0, 55, 99, 143, 197, 224, 249, 273,\n-        296, 299, 301, 327, 353, 379, 381, 407,\n-        440, 472, 504, 536, 579, 611, 654, 697,\n-        740, 784, 786, 835, 879, 882, 884, 928,\n-        972, 1026, 1053, 1078, 1102, 1125, 1128, 1130,\n-        1156, 1182, 1208, 1210, 1236, 1269, 1301, 1333,\n-        1365, 1408, 1440, 1483, 1526, 1569, 1613, 1615,\n-        1664, 1666, 1668, 1712, 1756, 1810, 1837, 1862,\n-        1886, 1909, 1912, 1914, 1940, 1966, 1992, 1994,\n-        2020, 2053, 2085, 2117, 2149, 2192, 2224, 2267,\n-        2310, 2353, 2397, 2399, 2448, 2492, 2536, 2590,\n-        2617, 2642, 2666, 2689, 2692, 2694, 2720, 2746,\n-        2772, 2774, 2800, 2833, 2865, 2897, 2929, 2972,\n-        3004, 3047, 3090, 3133, 3177, 3179, 3228, 3230,\n-        3232, 3286, 3330, 3333, 3335, 3341, 3345, 3350\n+        0, 55, 99, 143, 197, 233, 268, 303,\n+        338, 372, 406, 408, 444, 480, 516, 531,\n+        567, 608, 649, 690, 731, 774, 815, 858,\n+        901, 944, 988, 1003, 1052, 1096, 1126, 1156,\n+        1200, 1244, 1298, 1334, 1369, 1404, 1439, 1473,\n+        1507, 1509, 1545, 1581, 1617, 1632, 1668, 1709,\n+        1750, 1791, 1832, 1875, 1916, 1959, 2002, 2045,\n+        2089, 2104, 2119, 2168, 2171, 2183, 2227, 2271,\n+        2325, 2361, 2396, 2431, 2466, 2500, 2534, 2536,\n+        2572, 2608, 2644, 2659, 2695, 2736, 2777, 2818,\n+        2859, 2902, 2943, 2986, 3029, 3072, 3116, 3131,\n+        3146, 3195, 3239, 3283, 3337, 3373, 3408, 3443,\n+        3478, 3512, 3546, 3548, 3584, 3620, 3656, 3671,\n+        3707, 3748, 3789, 3830, 3871, 3914, 3955, 3998,\n+        4041, 4084, 4128, 4143, 4192, 4204, 4207, 4261,\n+        4305, 4335, 4365, 4371, 4411, 4451\n@@ -158,2 +160,511 @@\n-        2, 2, 2, 5, 6, 7, 2, 2,\n-        2, 2, 8, 2, 2, 2, 9, 10,\n+        2, 2, 2, 5, 6, 7, 8, 2,\n+        2, 2, 9, 2, 2, 2, 10, 11,\n+        12, 13, 14, 15, 16, 17, 18, 19,\n+        20, 21, 22, 23, 2, 24, 25, 26,\n+        2, 27, 28, 29, 30, 31, 32, 33,\n+        30, 34, 2, 35, 2, 36, 2, 38,\n+        39, 37, 40, 37, 37, 37, 37, 37,\n+        37, 37, 41, 42, 43, 44, 45, 46,\n+        47, 48, 49, 50, 51, 52, 53, 54,\n+        37, 55, 56, 57, 37, 58, 59, 37,\n+        60, 61, 62, 63, 60, 37, 37, 37,\n+        37, 64, 37, 38, 39, 37, 40, 37,\n+        37, 37, 37, 37, 37, 37, 41, 42,\n+        43, 44, 45, 46, 47, 48, 49, 51,\n+        51, 52, 53, 54, 37, 55, 56, 57,\n+        37, 37, 37, 37, 60, 61, 62, 63,\n+        60, 37, 37, 37, 37, 64, 37, 38,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 40, 37, 37, 37,\n+        37, 37, 37, 37, 37, 42, 43, 44,\n+        45, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 55, 56, 57, 37, 37,\n+        37, 37, 37, 61, 62, 63, 65, 37,\n+        37, 37, 37, 42, 37, 40, 37, 37,\n+        37, 37, 37, 37, 37, 37, 42, 43,\n+        44, 45, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 55, 56, 57, 37,\n+        37, 37, 37, 37, 61, 62, 63, 65,\n+        37, 40, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 43, 44, 45, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        61, 62, 63, 37, 40, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 44,\n+        45, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 61, 62, 63, 37, 40,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 45, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 61, 62,\n+        63, 37, 40, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 61, 62, 37, 40, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 62, 37, 40, 37,\n+        40, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 43, 44, 45, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 55,\n+        56, 57, 37, 37, 37, 37, 37, 61,\n+        62, 63, 65, 37, 40, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 43, 44,\n+        45, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 56, 57, 37, 37,\n+        37, 37, 37, 61, 62, 63, 65, 37,\n+        40, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 43, 44, 45, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 57, 37, 37, 37, 37, 37, 61,\n+        62, 63, 65, 37, 66, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 40, 37, 40, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 43, 44, 45,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 61, 62, 63, 65, 37, 40,\n+        37, 37, 37, 37, 37, 37, 37, 41,\n+        42, 43, 44, 45, 37, 37, 37, 37,\n+        37, 37, 52, 53, 54, 37, 55, 56,\n+        57, 37, 37, 37, 37, 37, 61, 62,\n+        63, 65, 37, 37, 37, 37, 42, 37,\n+        40, 37, 37, 37, 37, 37, 37, 37,\n+        37, 42, 43, 44, 45, 37, 37, 37,\n+        37, 37, 37, 52, 53, 54, 37, 55,\n+        56, 57, 37, 37, 37, 37, 37, 61,\n+        62, 63, 65, 37, 37, 37, 37, 42,\n+        37, 40, 37, 37, 37, 37, 37, 37,\n+        37, 37, 42, 43, 44, 45, 37, 37,\n+        37, 37, 37, 37, 37, 53, 54, 37,\n+        55, 56, 57, 37, 37, 37, 37, 37,\n+        61, 62, 63, 65, 37, 37, 37, 37,\n+        42, 37, 40, 37, 37, 37, 37, 37,\n+        37, 37, 37, 42, 43, 44, 45, 37,\n+        37, 37, 37, 37, 37, 37, 37, 54,\n+        37, 55, 56, 57, 37, 37, 37, 37,\n+        37, 61, 62, 63, 65, 37, 37, 37,\n+        37, 42, 37, 67, 37, 40, 37, 37,\n+        37, 37, 37, 37, 37, 41, 42, 43,\n+        44, 45, 37, 47, 48, 37, 37, 37,\n+        52, 53, 54, 37, 55, 56, 57, 37,\n+        37, 37, 37, 37, 61, 62, 63, 65,\n+        37, 37, 37, 37, 42, 37, 40, 37,\n+        37, 37, 37, 37, 37, 37, 37, 42,\n+        43, 44, 45, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 55, 56, 57,\n+        37, 37, 37, 37, 37, 61, 62, 63,\n+        65, 37, 37, 37, 37, 42, 37, 67,\n+        37, 40, 37, 37, 37, 37, 37, 37,\n+        37, 41, 42, 43, 44, 45, 37, 37,\n+        48, 37, 37, 37, 52, 53, 54, 37,\n+        55, 56, 57, 37, 37, 37, 37, 37,\n+        61, 62, 63, 65, 37, 37, 37, 37,\n+        42, 37, 67, 37, 40, 37, 37, 37,\n+        37, 37, 37, 37, 41, 42, 43, 44,\n+        45, 37, 37, 37, 37, 37, 37, 52,\n+        53, 54, 37, 55, 56, 57, 37, 37,\n+        37, 37, 37, 61, 62, 63, 65, 37,\n+        37, 37, 37, 42, 37, 67, 37, 40,\n+        37, 37, 37, 37, 37, 37, 37, 41,\n+        42, 43, 44, 45, 46, 47, 48, 37,\n+        37, 37, 52, 53, 54, 37, 55, 56,\n+        57, 37, 37, 37, 37, 37, 61, 62,\n+        63, 65, 37, 37, 37, 37, 42, 37,\n+        38, 39, 37, 40, 37, 37, 37, 37,\n+        37, 37, 37, 41, 42, 43, 44, 45,\n+        46, 47, 48, 49, 37, 51, 52, 53,\n+        54, 37, 55, 56, 57, 37, 37, 37,\n+        37, 60, 61, 62, 63, 60, 37, 37,\n+        37, 37, 64, 37, 38, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 40, 37, 38, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        40, 37, 37, 37, 37, 37, 37, 37,\n+        37, 42, 43, 44, 45, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 55,\n+        56, 57, 37, 37, 37, 37, 37, 61,\n+        62, 63, 65, 37, 38, 39, 37, 40,\n+        37, 37, 37, 37, 37, 37, 37, 41,\n+        42, 43, 44, 45, 46, 47, 48, 49,\n+        50, 51, 52, 53, 54, 37, 55, 56,\n+        57, 37, 37, 37, 37, 60, 61, 62,\n+        63, 60, 37, 37, 37, 37, 64, 37,\n+        40, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 58, 59, 37, 40, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 59, 37, 69, 70, 68, 71,\n+        68, 68, 68, 68, 68, 68, 68, 72,\n+        73, 74, 75, 76, 77, 78, 79, 80,\n+        1, 81, 82, 83, 84, 68, 85, 86,\n+        87, 68, 68, 68, 68, 88, 89, 90,\n+        91, 92, 68, 68, 68, 68, 93, 68,\n+        69, 70, 68, 71, 68, 68, 68, 68,\n+        68, 68, 68, 72, 73, 74, 75, 76,\n+        77, 78, 79, 80, 81, 81, 82, 83,\n+        84, 68, 85, 86, 87, 68, 68, 68,\n+        68, 88, 89, 90, 91, 92, 68, 68,\n+        68, 68, 93, 68, 69, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 71, 68, 68, 68, 68, 68, 68,\n+        68, 68, 73, 74, 75, 76, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        85, 86, 87, 68, 68, 68, 68, 68,\n+        89, 90, 91, 94, 68, 68, 68, 68,\n+        73, 68, 71, 68, 68, 68, 68, 68,\n+        68, 68, 68, 73, 74, 75, 76, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 85, 86, 87, 68, 68, 68, 68,\n+        68, 89, 90, 91, 94, 68, 71, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        74, 75, 76, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 89, 90, 91,\n+        68, 71, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 75, 76, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        89, 90, 91, 68, 71, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        76, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 89, 90, 91, 68, 71,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 89, 90,\n+        68, 71, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 90, 68, 71, 68, 71, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 74,\n+        75, 76, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 85, 86, 87, 68,\n+        68, 68, 68, 68, 89, 90, 91, 94,\n+        68, 71, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 74, 75, 76, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 86, 87, 68, 68, 68, 68, 68,\n+        89, 90, 91, 94, 68, 71, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 74,\n+        75, 76, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 87, 68,\n+        68, 68, 68, 68, 89, 90, 91, 94,\n+        68, 96, 95, 95, 95, 95, 95, 95,\n+        95, 95, 95, 95, 95, 95, 97, 95,\n+        71, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 74, 75, 76, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 89,\n+        90, 91, 94, 68, 71, 68, 68, 68,\n+        68, 68, 68, 68, 72, 73, 74, 75,\n+        76, 68, 68, 68, 68, 68, 68, 82,\n+        83, 84, 68, 85, 86, 87, 68, 68,\n+        68, 68, 68, 89, 90, 91, 94, 68,\n+        68, 68, 68, 73, 68, 71, 68, 68,\n+        68, 68, 68, 68, 68, 68, 73, 74,\n+        75, 76, 68, 68, 68, 68, 68, 68,\n+        82, 83, 84, 68, 85, 86, 87, 68,\n+        68, 68, 68, 68, 89, 90, 91, 94,\n+        68, 68, 68, 68, 73, 68, 71, 68,\n+        68, 68, 68, 68, 68, 68, 68, 73,\n+        74, 75, 76, 68, 68, 68, 68, 68,\n+        68, 68, 83, 84, 68, 85, 86, 87,\n+        68, 68, 68, 68, 68, 89, 90, 91,\n+        94, 68, 68, 68, 68, 73, 68, 71,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        73, 74, 75, 76, 68, 68, 68, 68,\n+        68, 68, 68, 68, 84, 68, 85, 86,\n+        87, 68, 68, 68, 68, 68, 89, 90,\n+        91, 94, 68, 68, 68, 68, 73, 68,\n+        98, 68, 71, 68, 68, 68, 68, 68,\n+        68, 68, 72, 73, 74, 75, 76, 68,\n+        78, 79, 68, 68, 68, 82, 83, 84,\n+        68, 85, 86, 87, 68, 68, 68, 68,\n+        68, 89, 90, 91, 94, 68, 68, 68,\n+        68, 73, 68, 71, 68, 68, 68, 68,\n+        68, 68, 68, 68, 73, 74, 75, 76,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 85, 86, 87, 68, 68, 68,\n+        68, 68, 89, 90, 91, 94, 68, 68,\n+        68, 68, 73, 68, 98, 68, 71, 68,\n+        68, 68, 68, 68, 68, 68, 72, 73,\n+        74, 75, 76, 68, 68, 79, 68, 68,\n+        68, 82, 83, 84, 68, 85, 86, 87,\n+        68, 68, 68, 68, 68, 89, 90, 91,\n+        94, 68, 68, 68, 68, 73, 68, 98,\n+        68, 71, 68, 68, 68, 68, 68, 68,\n+        68, 72, 73, 74, 75, 76, 68, 68,\n+        68, 68, 68, 68, 82, 83, 84, 68,\n+        85, 86, 87, 68, 68, 68, 68, 68,\n+        89, 90, 91, 94, 68, 68, 68, 68,\n+        73, 68, 98, 68, 71, 68, 68, 68,\n+        68, 68, 68, 68, 72, 73, 74, 75,\n+        76, 77, 78, 79, 68, 68, 68, 82,\n+        83, 84, 68, 85, 86, 87, 68, 68,\n+        68, 68, 68, 89, 90, 91, 94, 68,\n+        68, 68, 68, 73, 68, 69, 70, 68,\n+        71, 68, 68, 68, 68, 68, 68, 68,\n+        72, 73, 74, 75, 76, 77, 78, 79,\n+        80, 68, 81, 82, 83, 84, 68, 85,\n+        86, 87, 68, 68, 68, 68, 88, 89,\n+        90, 91, 92, 68, 68, 68, 68, 93,\n+        68, 69, 99, 99, 99, 99, 99, 99,\n+        99, 99, 99, 99, 99, 99, 100, 99,\n+        69, 95, 95, 95, 95, 95, 95, 95,\n+        95, 95, 95, 95, 95, 97, 95, 69,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 71, 68, 68, 68,\n+        68, 68, 68, 68, 68, 73, 74, 75,\n+        76, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 85, 86, 87, 68, 68,\n+        68, 68, 68, 89, 90, 91, 94, 68,\n+        102, 103, 101, 3, 104, 104, 104, 104,\n+        104, 104, 104, 104, 104, 105, 104, 106,\n+        107, 68, 71, 68, 68, 68, 68, 68,\n+        68, 68, 108, 109, 110, 111, 112, 113,\n+        114, 115, 116, 117, 118, 119, 120, 121,\n+        68, 122, 123, 124, 68, 58, 59, 68,\n+        125, 126, 127, 128, 129, 68, 68, 68,\n+        68, 130, 68, 106, 107, 68, 71, 68,\n+        68, 68, 68, 68, 68, 68, 108, 109,\n+        110, 111, 112, 113, 114, 115, 116, 118,\n+        118, 119, 120, 121, 68, 122, 123, 124,\n+        68, 68, 68, 68, 125, 126, 127, 128,\n+        129, 68, 68, 68, 68, 130, 68, 106,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 71, 68, 68, 68,\n+        68, 68, 68, 68, 68, 109, 110, 111,\n+        112, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 122, 123, 124, 68, 68,\n+        68, 68, 68, 126, 127, 128, 131, 68,\n+        68, 68, 68, 109, 68, 71, 68, 68,\n+        68, 68, 68, 68, 68, 68, 109, 110,\n+        111, 112, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 122, 123, 124, 68,\n+        68, 68, 68, 68, 126, 127, 128, 131,\n+        68, 71, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 110, 111, 112, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        126, 127, 128, 68, 71, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 111,\n+        112, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 126, 127, 128, 68, 71,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 112, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 126, 127,\n+        128, 68, 71, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 126, 127, 68, 71, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 127, 68, 71, 68,\n+        71, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 110, 111, 112, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 122,\n+        123, 124, 68, 68, 68, 68, 68, 126,\n+        127, 128, 131, 68, 71, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 110, 111,\n+        112, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 123, 124, 68, 68,\n+        68, 68, 68, 126, 127, 128, 131, 68,\n+        71, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 110, 111, 112, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 124, 68, 68, 68, 68, 68, 126,\n+        127, 128, 131, 68, 132, 95, 95, 95,\n+        95, 95, 95, 95, 95, 95, 95, 95,\n+        95, 97, 95, 71, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 110, 111, 112,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        68, 68, 126, 127, 128, 131, 68, 71,\n+        68, 68, 68, 68, 68, 68, 68, 108,\n+        109, 110, 111, 112, 68, 68, 68, 68,\n+        68, 68, 119, 120, 121, 68, 122, 123,\n+        124, 68, 68, 68, 68, 68, 126, 127,\n+        128, 131, 68, 68, 68, 68, 109, 68,\n+        71, 68, 68, 68, 68, 68, 68, 68,\n+        68, 109, 110, 111, 112, 68, 68, 68,\n+        68, 68, 68, 119, 120, 121, 68, 122,\n+        123, 124, 68, 68, 68, 68, 68, 126,\n+        127, 128, 131, 68, 68, 68, 68, 109,\n+        68, 71, 68, 68, 68, 68, 68, 68,\n+        68, 68, 109, 110, 111, 112, 68, 68,\n+        68, 68, 68, 68, 68, 120, 121, 68,\n+        122, 123, 124, 68, 68, 68, 68, 68,\n+        126, 127, 128, 131, 68, 68, 68, 68,\n+        109, 68, 71, 68, 68, 68, 68, 68,\n+        68, 68, 68, 109, 110, 111, 112, 68,\n+        68, 68, 68, 68, 68, 68, 68, 121,\n+        68, 122, 123, 124, 68, 68, 68, 68,\n+        68, 126, 127, 128, 131, 68, 68, 68,\n+        68, 109, 68, 133, 68, 71, 68, 68,\n+        68, 68, 68, 68, 68, 108, 109, 110,\n+        111, 112, 68, 114, 115, 68, 68, 68,\n+        119, 120, 121, 68, 122, 123, 124, 68,\n+        68, 68, 68, 68, 126, 127, 128, 131,\n+        68, 68, 68, 68, 109, 68, 71, 68,\n+        68, 68, 68, 68, 68, 68, 68, 109,\n+        110, 111, 112, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 122, 123, 124,\n+        68, 68, 68, 68, 68, 126, 127, 128,\n+        131, 68, 68, 68, 68, 109, 68, 133,\n+        68, 71, 68, 68, 68, 68, 68, 68,\n+        68, 108, 109, 110, 111, 112, 68, 68,\n+        115, 68, 68, 68, 119, 120, 121, 68,\n+        122, 123, 124, 68, 68, 68, 68, 68,\n+        126, 127, 128, 131, 68, 68, 68, 68,\n+        109, 68, 133, 68, 71, 68, 68, 68,\n+        68, 68, 68, 68, 108, 109, 110, 111,\n+        112, 68, 68, 68, 68, 68, 68, 119,\n+        120, 121, 68, 122, 123, 124, 68, 68,\n+        68, 68, 68, 126, 127, 128, 131, 68,\n+        68, 68, 68, 109, 68, 133, 68, 71,\n+        68, 68, 68, 68, 68, 68, 68, 108,\n+        109, 110, 111, 112, 113, 114, 115, 68,\n+        68, 68, 119, 120, 121, 68, 122, 123,\n+        124, 68, 68, 68, 68, 68, 126, 127,\n+        128, 131, 68, 68, 68, 68, 109, 68,\n+        106, 107, 68, 71, 68, 68, 68, 68,\n+        68, 68, 68, 108, 109, 110, 111, 112,\n+        113, 114, 115, 116, 68, 118, 119, 120,\n+        121, 68, 122, 123, 124, 68, 68, 68,\n+        68, 125, 126, 127, 128, 129, 68, 68,\n+        68, 68, 130, 68, 106, 99, 99, 99,\n+        99, 99, 99, 99, 99, 99, 99, 99,\n+        99, 100, 99, 106, 95, 95, 95, 95,\n+        95, 95, 95, 95, 95, 95, 95, 95,\n+        97, 95, 106, 68, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 71,\n+        68, 68, 68, 68, 68, 68, 68, 68,\n+        109, 110, 111, 112, 68, 68, 68, 68,\n+        68, 68, 68, 68, 68, 68, 122, 123,\n+        124, 68, 68, 68, 68, 68, 126, 127,\n+        128, 131, 68, 106, 107, 68, 71, 68,\n+        68, 68, 68, 68, 68, 68, 108, 109,\n+        110, 111, 112, 113, 114, 115, 116, 117,\n+        118, 119, 120, 121, 68, 122, 123, 124,\n+        68, 68, 68, 68, 125, 126, 127, 128,\n+        129, 68, 68, 68, 68, 130, 68, 5,\n+        6, 134, 8, 134, 134, 134, 134, 134,\n+        134, 134, 10, 11, 12, 13, 14, 15,\n+        16, 17, 18, 20, 20, 21, 22, 23,\n+        134, 24, 25, 26, 134, 134, 134, 134,\n+        30, 31, 32, 33, 30, 134, 134, 134,\n+        134, 36, 134, 5, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        8, 134, 134, 134, 134, 134, 134, 134,\n+        134, 11, 12, 13, 14, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 24,\n+        25, 26, 134, 134, 134, 134, 134, 31,\n+        32, 33, 135, 134, 134, 134, 134, 11,\n+        134, 8, 134, 134, 134, 134, 134, 134,\n+        134, 134, 11, 12, 13, 14, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        24, 25, 26, 134, 134, 134, 134, 134,\n+        31, 32, 33, 135, 134, 8, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 12,\n+        13, 14, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 31, 32, 33, 134,\n+        8, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 13, 14, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 31,\n+        32, 33, 134, 8, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 14,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 31, 32, 33, 134, 8, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 31, 32, 134,\n+        8, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        32, 134, 8, 134, 8, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 12, 13,\n+        14, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 24, 25, 26, 134, 134,\n+        134, 134, 134, 31, 32, 33, 135, 134,\n+        8, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 12, 13, 14, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        25, 26, 134, 134, 134, 134, 134, 31,\n+        32, 33, 135, 134, 8, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 12, 13,\n+        14, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 26, 134, 134,\n+        134, 134, 134, 31, 32, 33, 135, 134,\n+        136, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 8, 134, 8,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 12, 13, 14, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 31, 32,\n+        33, 135, 134, 8, 134, 134, 134, 134,\n+        134, 134, 134, 10, 11, 12, 13, 14,\n+        134, 134, 134, 134, 134, 134, 21, 22,\n+        23, 134, 24, 25, 26, 134, 134, 134,\n+        134, 134, 31, 32, 33, 135, 134, 134,\n+        134, 134, 11, 134, 8, 134, 134, 134,\n+        134, 134, 134, 134, 134, 11, 12, 13,\n+        14, 134, 134, 134, 134, 134, 134, 21,\n+        22, 23, 134, 24, 25, 26, 134, 134,\n+        134, 134, 134, 31, 32, 33, 135, 134,\n+        134, 134, 134, 11, 134, 8, 134, 134,\n+        134, 134, 134, 134, 134, 134, 11, 12,\n+        13, 14, 134, 134, 134, 134, 134, 134,\n+        134, 22, 23, 134, 24, 25, 26, 134,\n+        134, 134, 134, 134, 31, 32, 33, 135,\n+        134, 134, 134, 134, 11, 134, 8, 134,\n+        134, 134, 134, 134, 134, 134, 134, 11,\n+        12, 13, 14, 134, 134, 134, 134, 134,\n+        134, 134, 134, 23, 134, 24, 25, 26,\n+        134, 134, 134, 134, 134, 31, 32, 33,\n+        135, 134, 134, 134, 134, 11, 134, 137,\n+        134, 8, 134, 134, 134, 134, 134, 134,\n+        134, 10, 11, 12, 13, 14, 134, 16,\n+        17, 134, 134, 134, 21, 22, 23, 134,\n+        24, 25, 26, 134, 134, 134, 134, 134,\n+        31, 32, 33, 135, 134, 134, 134, 134,\n+        11, 134, 8, 134, 134, 134, 134, 134,\n+        134, 134, 134, 11, 12, 13, 14, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 24, 25, 26, 134, 134, 134, 134,\n+        134, 31, 32, 33, 135, 134, 134, 134,\n+        134, 11, 134, 137, 134, 8, 134, 134,\n+        134, 134, 134, 134, 134, 10, 11, 12,\n+        13, 14, 134, 134, 17, 134, 134, 134,\n+        21, 22, 23, 134, 24, 25, 26, 134,\n+        134, 134, 134, 134, 31, 32, 33, 135,\n+        134, 134, 134, 134, 11, 134, 137, 134,\n+        8, 134, 134, 134, 134, 134, 134, 134,\n+        10, 11, 12, 13, 14, 134, 134, 134,\n+        134, 134, 134, 21, 22, 23, 134, 24,\n+        25, 26, 134, 134, 134, 134, 134, 31,\n+        32, 33, 135, 134, 134, 134, 134, 11,\n+        134, 137, 134, 8, 134, 134, 134, 134,\n+        134, 134, 134, 10, 11, 12, 13, 14,\n+        15, 16, 17, 134, 134, 134, 21, 22,\n+        23, 134, 24, 25, 26, 134, 134, 134,\n+        134, 134, 31, 32, 33, 135, 134, 134,\n+        134, 134, 11, 134, 5, 6, 134, 8,\n+        134, 134, 134, 134, 134, 134, 134, 10,\n@@ -161,309 +672,21 @@\n-        19, 20, 21, 22, 2, 23, 24, 25,\n-        2, 26, 27, 28, 29, 30, 31, 32,\n-        29, 33, 2, 34, 2, 35, 2, 37,\n-        38, 36, 36, 36, 36, 36, 36, 36,\n-        36, 36, 39, 40, 41, 42, 43, 44,\n-        45, 46, 47, 48, 49, 50, 51, 52,\n-        36, 53, 54, 55, 36, 56, 57, 36,\n-        58, 59, 60, 61, 58, 36, 36, 36,\n-        36, 62, 36, 37, 38, 36, 36, 36,\n-        36, 36, 36, 36, 36, 36, 39, 40,\n-        41, 42, 43, 44, 45, 46, 47, 49,\n-        49, 50, 51, 52, 36, 53, 54, 55,\n-        36, 36, 36, 36, 58, 59, 60, 61,\n-        58, 36, 36, 36, 36, 62, 36, 37,\n-        36, 36, 36, 36, 36, 36, 36, 36,\n-        36, 36, 36, 36, 36, 36, 36, 36,\n-        36, 36, 36, 36, 36, 40, 41, 42,\n-        43, 36, 36, 36, 36, 36, 36, 36,\n-        36, 36, 36, 53, 54, 55, 36, 36,\n-        36, 36, 36, 59, 60, 61, 63, 36,\n-        36, 36, 36, 40, 36, 40, 41, 42,\n-        43, 36, 36, 36, 36, 36, 36, 36,\n-        36, 36, 36, 53, 54, 55, 36, 36,\n-        36, 36, 36, 59, 60, 61, 63, 36,\n-        41, 42, 43, 36, 36, 36, 36, 36,\n-        36, 36, 36, 36, 36, 36, 36, 36,\n-        36, 36, 36, 36, 36, 59, 60, 61,\n-        36, 42, 43, 36, 36, 36, 36, 36,\n-        36, 36, 36, 36, 36, 36, 36, 36,\n-        36, 36, 36, 36, 36, 59, 60, 61,\n-        36, 43, 36, 36, 36, 36, 36, 36,\n-        36, 36, 36, 36, 36, 36, 36, 36,\n-        36, 36, 36, 36, 59, 60, 61, 36,\n-        59, 60, 36, 60, 36, 41, 42, 43,\n-        36, 36, 36, 36, 36, 36, 36, 36,\n-        36, 36, 53, 54, 55, 36, 36, 36,\n-        36, 36, 59, 60, 61, 63, 36, 41,\n-        42, 43, 36, 36, 36, 36, 36, 36,\n-        36, 36, 36, 36, 36, 54, 55, 36,\n-        36, 36, 36, 36, 59, 60, 61, 63,\n-        36, 41, 42, 43, 36, 36, 36, 36,\n-        36, 36, 36, 36, 36, 36, 36, 36,\n-        55, 36, 36, 36, 36, 36, 59, 60,\n-        61, 63, 36, 64, 36, 41, 42, 43,\n-        36, 36, 36, 36, 36, 36, 36, 36,\n-        36, 36, 36, 36, 36, 36, 36, 36,\n-        36, 36, 59, 60, 61, 63, 36, 39,\n-        40, 41, 42, 43, 36, 36, 36, 36,\n-        36, 36, 50, 51, 52, 36, 53, 54,\n-        55, 36, 36, 36, 36, 36, 59, 60,\n-        61, 63, 36, 36, 36, 36, 40, 36,\n-        40, 41, 42, 43, 36, 36, 36, 36,\n-        36, 36, 50, 51, 52, 36, 53, 54,\n-        55, 36, 36, 36, 36, 36, 59, 60,\n-        61, 63, 36, 36, 36, 36, 40, 36,\n-        40, 41, 42, 43, 36, 36, 36, 36,\n-        36, 36, 36, 51, 52, 36, 53, 54,\n-        55, 36, 36, 36, 36, 36, 59, 60,\n-        61, 63, 36, 36, 36, 36, 40, 36,\n-        40, 41, 42, 43, 36, 36, 36, 36,\n-        36, 36, 36, 36, 52, 36, 53, 54,\n-        55, 36, 36, 36, 36, 36, 59, 60,\n-        61, 63, 36, 36, 36, 36, 40, 36,\n-        65, 36, 36, 36, 36, 36, 36, 36,\n-        36, 36, 39, 40, 41, 42, 43, 36,\n-        45, 46, 36, 36, 36, 50, 51, 52,\n-        36, 53, 54, 55, 36, 36, 36, 36,\n-        36, 59, 60, 61, 63, 36, 36, 36,\n-        36, 40, 36, 40, 41, 42, 43, 36,\n-        36, 36, 36, 36, 36, 36, 36, 36,\n-        36, 53, 54, 55, 36, 36, 36, 36,\n-        36, 59, 60, 61, 63, 36, 36, 36,\n-        36, 40, 36, 65, 36, 36, 36, 36,\n-        36, 36, 36, 36, 36, 39, 40, 41,\n-        42, 43, 36, 36, 46, 36, 36, 36,\n-        50, 51, 52, 36, 53, 54, 55, 36,\n-        36, 36, 36, 36, 59, 60, 61, 63,\n-        36, 36, 36, 36, 40, 36, 65, 36,\n-        36, 36, 36, 36, 36, 36, 36, 36,\n-        39, 40, 41, 42, 43, 36, 36, 36,\n-        36, 36, 36, 50, 51, 52, 36, 53,\n-        54, 55, 36, 36, 36, 36, 36, 59,\n-        60, 61, 63, 36, 36, 36, 36, 40,\n-        36, 65, 36, 36, 36, 36, 36, 36,\n-        36, 36, 36, 39, 40, 41, 42, 43,\n-        44, 45, 46, 36, 36, 36, 50, 51,\n-        52, 36, 53, 54, 55, 36, 36, 36,\n-        36, 36, 59, 60, 61, 63, 36, 36,\n-        36, 36, 40, 36, 37, 38, 36, 36,\n-        36, 36, 36, 36, 36, 36, 36, 39,\n-        40, 41, 42, 43, 44, 45, 46, 47,\n-        36, 49, 50, 51, 52, 36, 53, 54,\n-        55, 36, 36, 36, 36, 58, 59, 60,\n-        61, 58, 36, 36, 36, 36, 62, 36,\n-        37, 36, 37, 36, 36, 36, 36, 36,\n-        36, 36, 36, 36, 36, 36, 36, 36,\n-        36, 36, 36, 36, 36, 36, 36, 36,\n-        40, 41, 42, 43, 36, 36, 36, 36,\n-        36, 36, 36, 36, 36, 36, 53, 54,\n-        55, 36, 36, 36, 36, 36, 59, 60,\n-        61, 63, 36, 37, 38, 36, 36, 36,\n-        36, 36, 36, 36, 36, 36, 39, 40,\n-        41, 42, 43, 44, 45, 46, 47, 48,\n-        49, 50, 51, 52, 36, 53, 54, 55,\n-        36, 36, 36, 36, 58, 59, 60, 61,\n-        58, 36, 36, 36, 36, 62, 36, 56,\n-        57, 36, 57, 36, 67, 68, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 69,\n-        70, 71, 72, 73, 74, 75, 76, 77,\n-        1, 78, 79, 80, 81, 66, 82, 83,\n-        84, 66, 66, 66, 66, 85, 86, 87,\n-        88, 89, 66, 66, 66, 66, 90, 66,\n-        67, 68, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 69, 70, 71, 72, 73,\n-        74, 75, 76, 77, 78, 78, 79, 80,\n-        81, 66, 82, 83, 84, 66, 66, 66,\n-        66, 85, 86, 87, 88, 89, 66, 66,\n-        66, 66, 90, 66, 67, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 70, 71, 72, 73, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        82, 83, 84, 66, 66, 66, 66, 66,\n-        86, 87, 88, 91, 66, 66, 66, 66,\n-        70, 66, 70, 71, 72, 73, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        82, 83, 84, 66, 66, 66, 66, 66,\n-        86, 87, 88, 91, 66, 71, 72, 73,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 86, 87, 88, 66, 72, 73,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 86, 87, 88, 66, 73, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 86, 87, 88, 66, 86, 87, 66,\n-        87, 66, 71, 72, 73, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 82,\n-        83, 84, 66, 66, 66, 66, 66, 86,\n-        87, 88, 91, 66, 71, 72, 73, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 83, 84, 66, 66, 66, 66,\n-        66, 86, 87, 88, 91, 66, 71, 72,\n-        73, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 84, 66, 66,\n-        66, 66, 66, 86, 87, 88, 91, 66,\n-        93, 92, 71, 72, 73, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 86,\n-        87, 88, 91, 66, 69, 70, 71, 72,\n-        73, 66, 66, 66, 66, 66, 66, 79,\n-        80, 81, 66, 82, 83, 84, 66, 66,\n-        66, 66, 66, 86, 87, 88, 91, 66,\n-        66, 66, 66, 70, 66, 70, 71, 72,\n-        73, 66, 66, 66, 66, 66, 66, 79,\n-        80, 81, 66, 82, 83, 84, 66, 66,\n-        66, 66, 66, 86, 87, 88, 91, 66,\n-        66, 66, 66, 70, 66, 70, 71, 72,\n-        73, 66, 66, 66, 66, 66, 66, 66,\n-        80, 81, 66, 82, 83, 84, 66, 66,\n-        66, 66, 66, 86, 87, 88, 91, 66,\n-        66, 66, 66, 70, 66, 70, 71, 72,\n-        73, 66, 66, 66, 66, 66, 66, 66,\n-        66, 81, 66, 82, 83, 84, 66, 66,\n-        66, 66, 66, 86, 87, 88, 91, 66,\n-        66, 66, 66, 70, 66, 94, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 69,\n-        70, 71, 72, 73, 66, 75, 76, 66,\n-        66, 66, 79, 80, 81, 66, 82, 83,\n-        84, 66, 66, 66, 66, 66, 86, 87,\n-        88, 91, 66, 66, 66, 66, 70, 66,\n-        70, 71, 72, 73, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 82, 83,\n-        84, 66, 66, 66, 66, 66, 86, 87,\n-        88, 91, 66, 66, 66, 66, 70, 66,\n-        94, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 69, 70, 71, 72, 73, 66,\n-        66, 76, 66, 66, 66, 79, 80, 81,\n-        66, 82, 83, 84, 66, 66, 66, 66,\n-        66, 86, 87, 88, 91, 66, 66, 66,\n-        66, 70, 66, 94, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 69, 70, 71,\n-        72, 73, 66, 66, 66, 66, 66, 66,\n-        79, 80, 81, 66, 82, 83, 84, 66,\n-        66, 66, 66, 66, 86, 87, 88, 91,\n-        66, 66, 66, 66, 70, 66, 94, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        69, 70, 71, 72, 73, 74, 75, 76,\n-        66, 66, 66, 79, 80, 81, 66, 82,\n-        83, 84, 66, 66, 66, 66, 66, 86,\n-        87, 88, 91, 66, 66, 66, 66, 70,\n-        66, 67, 68, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 69, 70, 71, 72,\n-        73, 74, 75, 76, 77, 66, 78, 79,\n-        80, 81, 66, 82, 83, 84, 66, 66,\n-        66, 66, 85, 86, 87, 88, 89, 66,\n-        66, 66, 66, 90, 66, 67, 95, 67,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 70, 71, 72,\n-        73, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 82, 83, 84, 66, 66,\n-        66, 66, 66, 86, 87, 88, 91, 66,\n-        97, 96, 3, 98, 99, 100, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 101,\n-        102, 103, 104, 105, 106, 107, 108, 109,\n-        110, 111, 112, 113, 114, 66, 115, 116,\n-        117, 66, 56, 57, 66, 118, 119, 120,\n-        88, 121, 66, 66, 66, 66, 122, 66,\n-        99, 100, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 101, 102, 103, 104, 105,\n-        106, 107, 108, 109, 111, 111, 112, 113,\n-        114, 66, 115, 116, 117, 66, 66, 66,\n-        66, 118, 119, 120, 88, 121, 66, 66,\n-        66, 66, 122, 66, 99, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 102, 103, 104, 105, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        115, 116, 117, 66, 66, 66, 66, 66,\n-        119, 120, 88, 123, 66, 66, 66, 66,\n-        102, 66, 102, 103, 104, 105, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        115, 116, 117, 66, 66, 66, 66, 66,\n-        119, 120, 88, 123, 66, 103, 104, 105,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 119, 120, 88, 66, 104, 105,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 119, 120, 88, 66, 105, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 119, 120, 88, 66, 119, 120, 66,\n-        120, 66, 103, 104, 105, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 115,\n-        116, 117, 66, 66, 66, 66, 66, 119,\n-        120, 88, 123, 66, 103, 104, 105, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 116, 117, 66, 66, 66, 66,\n-        66, 119, 120, 88, 123, 66, 103, 104,\n-        105, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 117, 66, 66,\n-        66, 66, 66, 119, 120, 88, 123, 66,\n-        124, 92, 103, 104, 105, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 119,\n-        120, 88, 123, 66, 101, 102, 103, 104,\n-        105, 66, 66, 66, 66, 66, 66, 112,\n-        113, 114, 66, 115, 116, 117, 66, 66,\n-        66, 66, 66, 119, 120, 88, 123, 66,\n-        66, 66, 66, 102, 66, 102, 103, 104,\n-        105, 66, 66, 66, 66, 66, 66, 112,\n-        113, 114, 66, 115, 116, 117, 66, 66,\n-        66, 66, 66, 119, 120, 88, 123, 66,\n-        66, 66, 66, 102, 66, 102, 103, 104,\n-        105, 66, 66, 66, 66, 66, 66, 66,\n-        113, 114, 66, 115, 116, 117, 66, 66,\n-        66, 66, 66, 119, 120, 88, 123, 66,\n-        66, 66, 66, 102, 66, 102, 103, 104,\n-        105, 66, 66, 66, 66, 66, 66, 66,\n-        66, 114, 66, 115, 116, 117, 66, 66,\n-        66, 66, 66, 119, 120, 88, 123, 66,\n-        66, 66, 66, 102, 66, 125, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 101,\n-        102, 103, 104, 105, 66, 107, 108, 66,\n-        66, 66, 112, 113, 114, 66, 115, 116,\n-        117, 66, 66, 66, 66, 66, 119, 120,\n-        88, 123, 66, 66, 66, 66, 102, 66,\n-        102, 103, 104, 105, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 115, 116,\n-        117, 66, 66, 66, 66, 66, 119, 120,\n-        88, 123, 66, 66, 66, 66, 102, 66,\n-        125, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 101, 102, 103, 104, 105, 66,\n-        66, 108, 66, 66, 66, 112, 113, 114,\n-        66, 115, 116, 117, 66, 66, 66, 66,\n-        66, 119, 120, 88, 123, 66, 66, 66,\n-        66, 102, 66, 125, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 101, 102, 103,\n-        104, 105, 66, 66, 66, 66, 66, 66,\n-        112, 113, 114, 66, 115, 116, 117, 66,\n-        66, 66, 66, 66, 119, 120, 88, 123,\n-        66, 66, 66, 66, 102, 66, 125, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        101, 102, 103, 104, 105, 106, 107, 108,\n-        66, 66, 66, 112, 113, 114, 66, 115,\n-        116, 117, 66, 66, 66, 66, 66, 119,\n-        120, 88, 123, 66, 66, 66, 66, 102,\n-        66, 99, 100, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 101, 102, 103, 104,\n-        105, 106, 107, 108, 109, 66, 111, 112,\n-        113, 114, 66, 115, 116, 117, 66, 66,\n-        66, 66, 118, 119, 120, 88, 121, 66,\n-        66, 66, 66, 122, 66, 99, 95, 99,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 66, 66, 102, 103, 104,\n-        105, 66, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 115, 116, 117, 66, 66,\n-        66, 66, 66, 119, 120, 88, 123, 66,\n-        99, 100, 66, 66, 66, 66, 66, 66,\n-        66, 66, 66, 101, 102, 103, 104, 105,\n-        106, 107, 108, 109, 110, 111, 112, 113,\n-        114, 66, 115, 116, 117, 66, 66, 66,\n-        66, 118, 119, 120, 88, 121, 66, 66,\n-        66, 66, 122, 66, 5, 6, 126, 126,\n-        126, 126, 126, 126, 126, 126, 126, 9,\n+        134, 20, 21, 22, 23, 134, 24, 25,\n+        26, 134, 134, 134, 134, 30, 31, 32,\n+        33, 30, 134, 134, 134, 134, 36, 134,\n+        5, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 8, 134, 5,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 8, 134, 134, 134,\n+        134, 134, 134, 134, 134, 11, 12, 13,\n+        14, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 24, 25, 26, 134, 134,\n+        134, 134, 134, 31, 32, 33, 135, 134,\n+        138, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 8, 134, 7, 8, 134, 1,\n+        134, 134, 134, 1, 134, 134, 134, 134,\n+        134, 5, 6, 7, 8, 134, 134, 134,\n+        134, 134, 134, 134, 10, 11, 12, 13,\n+        14, 15, 16, 17, 18, 19, 20, 21,\n+        22, 23, 134, 24, 25, 26, 134, 27,\n+        28, 134, 30, 31, 32, 33, 30, 134,\n+        134, 134, 134, 36, 134, 5, 6, 134,\n+        8, 134, 134, 134, 134, 134, 134, 134,\n@@ -471,106 +694,27 @@\n-        19, 19, 20, 21, 22, 126, 23, 24,\n-        25, 126, 126, 126, 126, 29, 30, 31,\n-        32, 29, 126, 126, 126, 126, 35, 126,\n-        5, 126, 126, 126, 126, 126, 126, 126,\n-        126, 126, 126, 126, 126, 126, 126, 126,\n-        126, 126, 126, 126, 126, 126, 10, 11,\n-        12, 13, 126, 126, 126, 126, 126, 126,\n-        126, 126, 126, 126, 23, 24, 25, 126,\n-        126, 126, 126, 126, 30, 31, 32, 127,\n-        126, 126, 126, 126, 10, 126, 10, 11,\n-        12, 13, 126, 126, 126, 126, 126, 126,\n-        126, 126, 126, 126, 23, 24, 25, 126,\n-        126, 126, 126, 126, 30, 31, 32, 127,\n-        126, 11, 12, 13, 126, 126, 126, 126,\n-        126, 126, 126, 126, 126, 126, 126, 126,\n-        126, 126, 126, 126, 126, 126, 30, 31,\n-        32, 126, 12, 13, 126, 126, 126, 126,\n-        126, 126, 126, 126, 126, 126, 126, 126,\n-        126, 126, 126, 126, 126, 126, 30, 31,\n-        32, 126, 13, 126, 126, 126, 126, 126,\n-        126, 126, 126, 126, 126, 126, 126, 126,\n-        126, 126, 126, 126, 126, 30, 31, 32,\n-        126, 30, 31, 126, 31, 126, 11, 12,\n-        13, 126, 126, 126, 126, 126, 126, 126,\n-        126, 126, 126, 23, 24, 25, 126, 126,\n-        126, 126, 126, 30, 31, 32, 127, 126,\n-        11, 12, 13, 126, 126, 126, 126, 126,\n-        126, 126, 126, 126, 126, 126, 24, 25,\n-        126, 126, 126, 126, 126, 30, 31, 32,\n-        127, 126, 11, 12, 13, 126, 126, 126,\n-        126, 126, 126, 126, 126, 126, 126, 126,\n-        126, 25, 126, 126, 126, 126, 126, 30,\n-        31, 32, 127, 126, 128, 126, 11, 12,\n-        13, 126, 126, 126, 126, 126, 126, 126,\n-        126, 126, 126, 126, 126, 126, 126, 126,\n-        126, 126, 126, 30, 31, 32, 127, 126,\n-        9, 10, 11, 12, 13, 126, 126, 126,\n-        126, 126, 126, 20, 21, 22, 126, 23,\n-        24, 25, 126, 126, 126, 126, 126, 30,\n-        31, 32, 127, 126, 126, 126, 126, 10,\n-        126, 10, 11, 12, 13, 126, 126, 126,\n-        126, 126, 126, 20, 21, 22, 126, 23,\n-        24, 25, 126, 126, 126, 126, 126, 30,\n-        31, 32, 127, 126, 126, 126, 126, 10,\n-        126, 10, 11, 12, 13, 126, 126, 126,\n-        126, 126, 126, 126, 21, 22, 126, 23,\n-        24, 25, 126, 126, 126, 126, 126, 30,\n-        31, 32, 127, 126, 126, 126, 126, 10,\n-        126, 10, 11, 12, 13, 126, 126, 126,\n-        126, 126, 126, 126, 126, 22, 126, 23,\n-        24, 25, 126, 126, 126, 126, 126, 30,\n-        31, 32, 127, 126, 126, 126, 126, 10,\n-        126, 129, 126, 126, 126, 126, 126, 126,\n-        126, 126, 126, 9, 10, 11, 12, 13,\n-        126, 15, 16, 126, 126, 126, 20, 21,\n-        22, 126, 23, 24, 25, 126, 126, 126,\n-        126, 126, 30, 31, 32, 127, 126, 126,\n-        126, 126, 10, 126, 10, 11, 12, 13,\n-        126, 126, 126, 126, 126, 126, 126, 126,\n-        126, 126, 23, 24, 25, 126, 126, 126,\n-        126, 126, 30, 31, 32, 127, 126, 126,\n-        126, 126, 10, 126, 129, 126, 126, 126,\n-        126, 126, 126, 126, 126, 126, 9, 10,\n-        11, 12, 13, 126, 126, 16, 126, 126,\n-        126, 20, 21, 22, 126, 23, 24, 25,\n-        126, 126, 126, 126, 126, 30, 31, 32,\n-        127, 126, 126, 126, 126, 10, 126, 129,\n-        126, 126, 126, 126, 126, 126, 126, 126,\n-        126, 9, 10, 11, 12, 13, 126, 126,\n-        126, 126, 126, 126, 20, 21, 22, 126,\n-        23, 24, 25, 126, 126, 126, 126, 126,\n-        30, 31, 32, 127, 126, 126, 126, 126,\n-        10, 126, 129, 126, 126, 126, 126, 126,\n-        126, 126, 126, 126, 9, 10, 11, 12,\n-        13, 14, 15, 16, 126, 126, 126, 20,\n-        21, 22, 126, 23, 24, 25, 126, 126,\n-        126, 126, 126, 30, 31, 32, 127, 126,\n-        126, 126, 126, 10, 126, 5, 6, 126,\n-        126, 126, 126, 126, 126, 126, 126, 126,\n-        9, 10, 11, 12, 13, 14, 15, 16,\n-        17, 126, 19, 20, 21, 22, 126, 23,\n-        24, 25, 126, 126, 126, 126, 29, 30,\n-        31, 32, 29, 126, 126, 126, 126, 35,\n-        126, 5, 126, 5, 126, 126, 126, 126,\n-        126, 126, 126, 126, 126, 126, 126, 126,\n-        126, 126, 126, 126, 126, 126, 126, 126,\n-        126, 10, 11, 12, 13, 126, 126, 126,\n-        126, 126, 126, 126, 126, 126, 126, 23,\n-        24, 25, 126, 126, 126, 126, 126, 30,\n-        31, 32, 127, 126, 130, 126, 7, 126,\n-        1, 126, 126, 126, 1, 126, 126, 126,\n-        126, 126, 5, 6, 7, 126, 126, 126,\n-        126, 126, 126, 126, 126, 9, 10, 11,\n-        12, 13, 14, 15, 16, 17, 18, 19,\n-        20, 21, 22, 126, 23, 24, 25, 126,\n-        26, 27, 126, 29, 30, 31, 32, 29,\n-        126, 126, 126, 126, 35, 126, 5, 6,\n-        126, 126, 126, 126, 126, 126, 126, 126,\n-        126, 9, 10, 11, 12, 13, 14, 15,\n-        16, 17, 18, 19, 20, 21, 22, 126,\n-        23, 24, 25, 126, 126, 126, 126, 29,\n-        30, 31, 32, 29, 126, 126, 126, 126,\n-        35, 126, 26, 27, 126, 27, 126, 1,\n-        131, 131, 131, 1, 131, 133, 132, 33,\n-        132, 33, 133, 132, 133, 132, 33, 132,\n-        34, 132, 0\n+        18, 19, 20, 21, 22, 23, 134, 24,\n+        25, 26, 134, 134, 134, 134, 30, 31,\n+        32, 33, 30, 134, 134, 134, 134, 36,\n+        134, 8, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 27, 28, 134, 8,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 134, 134, 134, 134, 134,\n+        134, 134, 134, 28, 134, 1, 139, 139,\n+        139, 1, 139, 141, 140, 140, 140, 140,\n+        140, 140, 140, 140, 140, 140, 140, 140,\n+        140, 140, 140, 140, 140, 140, 140, 140,\n+        140, 140, 140, 140, 140, 140, 140, 140,\n+        140, 140, 140, 140, 140, 140, 140, 142,\n+        140, 34, 140, 141, 140, 140, 140, 140,\n+        140, 140, 140, 140, 140, 140, 140, 140,\n+        140, 140, 140, 140, 140, 140, 140, 140,\n+        140, 140, 140, 140, 140, 140, 140, 140,\n+        140, 140, 140, 140, 140, 140, 34, 142,\n+        140, 142, 140, 141, 140, 140, 140, 140,\n+        140, 140, 140, 140, 140, 140, 140, 140,\n+        140, 140, 140, 140, 140, 140, 140, 140,\n+        140, 140, 140, 140, 140, 140, 140, 140,\n+        140, 140, 140, 140, 140, 140, 34, 140,\n+        35, 140, 0\n@@ -580,17 +724,18 @@\n-        1, 30, 0, 56, 58, 85, 86, 110,\n-        112, 98, 87, 88, 89, 90, 102, 104,\n-        105, 106, 113, 107, 99, 100, 101, 93,\n-        94, 95, 114, 115, 116, 108, 91, 92,\n-        0, 117, 119, 109, 0, 2, 3, 15,\n-        4, 5, 6, 7, 19, 21, 22, 23,\n-        27, 24, 16, 17, 18, 10, 11, 12,\n-        28, 29, 25, 8, 9, 0, 26, 13,\n-        14, 20, 0, 31, 32, 44, 33, 34,\n-        35, 36, 48, 50, 51, 52, 53, 45,\n-        46, 47, 39, 40, 41, 54, 37, 38,\n-        0, 54, 55, 42, 0, 43, 49, 0,\n-        0, 57, 0, 59, 60, 72, 61, 62,\n-        63, 64, 76, 78, 79, 80, 84, 81,\n-        73, 74, 75, 67, 68, 69, 82, 65,\n-        66, 82, 83, 70, 71, 77, 0, 96,\n-        97, 103, 111, 0, 0, 118\n+        1, 31, 0, 59, 61, 90, 91, 116,\n+        0, 118, 104, 92, 93, 94, 95, 108,\n+        110, 111, 112, 119, 113, 105, 106, 107,\n+        99, 100, 101, 120, 121, 122, 114, 96,\n+        97, 98, 123, 125, 115, 0, 2, 3,\n+        0, 16, 4, 5, 6, 7, 20, 22,\n+        23, 24, 28, 25, 17, 18, 19, 11,\n+        12, 13, 29, 30, 26, 8, 9, 10,\n+        27, 14, 15, 21, 0, 32, 33, 0,\n+        46, 34, 35, 36, 37, 50, 52, 53,\n+        54, 55, 47, 48, 49, 41, 42, 43,\n+        56, 38, 39, 40, 57, 58, 44, 0,\n+        45, 0, 51, 0, 0, 0, 60, 0,\n+        0, 0, 62, 63, 76, 64, 65, 66,\n+        67, 80, 82, 83, 84, 89, 85, 77,\n+        78, 79, 71, 72, 73, 86, 68, 69,\n+        70, 87, 88, 74, 75, 81, 0, 102,\n+        103, 109, 117, 0, 0, 0, 124\n@@ -601,0 +746,1 @@\n+        4, 0, 0, 0, 0, 0, 0, 0,\n@@ -603,0 +749,2 @@\n+        0, 0, 0, 0, 0, 5, 0, 0,\n+        6, 0, 0, 0, 0, 0, 0, 0,\n@@ -604,1 +752,0 @@\n-        4, 0, 0, 0, 5, 0, 0, 0,\n@@ -606,0 +753,1 @@\n+        0, 0, 0, 0, 7, 0, 0, 8,\n@@ -607,2 +755,0 @@\n-        0, 0, 0, 0, 0, 6, 0, 0,\n-        0, 0, 7, 0, 0, 0, 0, 0,\n@@ -610,3 +756,3 @@\n-        0, 0, 0, 0, 0, 8, 0, 0,\n-        9, 10, 0, 0, 11, 0, 0, 12,\n-        13, 0, 14, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 9,\n+        0, 10, 0, 11, 12, 13, 0, 14,\n+        15, 16, 0, 0, 0, 0, 0, 0,\n@@ -614,3 +760,3 @@\n-        0, 0, 0, 0, 0, 0, 8, 0,\n-        0, 10, 0, 0, 0, 0, 15, 0,\n-        0, 0, 0, 16, 17, 0\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 17, 0,\n+        0, 0, 0, 18, 19, 20, 0\n@@ -634,1 +780,2 @@\n-        0, 0, 0, 0, 0, 0, 0, 0\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0\n@@ -652,1 +799,2 @@\n-        0, 0, 0, 0, 0, 0, 0, 0\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0\n@@ -656,15 +804,16 @@\n-        0, 37, 37, 37, 37, 37, 37, 37,\n-        37, 37, 37, 37, 37, 37, 37, 37,\n-        37, 37, 37, 37, 37, 37, 37, 37,\n-        37, 37, 37, 37, 37, 37, 67, 67,\n-        67, 67, 67, 67, 67, 67, 67, 67,\n-        67, 67, 93, 67, 67, 67, 67, 67,\n-        67, 67, 67, 67, 67, 67, 96, 67,\n-        97, 99, 67, 67, 67, 67, 67, 67,\n-        67, 67, 67, 67, 67, 67, 93, 67,\n-        67, 67, 67, 67, 67, 67, 67, 67,\n-        67, 67, 96, 67, 67, 127, 127, 127,\n-        127, 127, 127, 127, 127, 127, 127, 127,\n-        127, 127, 127, 127, 127, 127, 127, 127,\n-        127, 127, 127, 127, 127, 127, 127, 127,\n-        127, 127, 127, 127, 132, 133, 133, 133\n+        0, 38, 38, 38, 38, 38, 38, 38,\n+        38, 38, 38, 38, 38, 38, 38, 38,\n+        38, 38, 38, 38, 38, 38, 38, 38,\n+        38, 38, 38, 38, 38, 38, 38, 69,\n+        69, 69, 69, 69, 69, 69, 69, 69,\n+        69, 69, 69, 69, 96, 69, 69, 69,\n+        69, 69, 69, 69, 69, 69, 69, 69,\n+        100, 96, 69, 102, 105, 69, 69, 69,\n+        69, 69, 69, 69, 69, 69, 69, 69,\n+        69, 69, 96, 69, 69, 69, 69, 69,\n+        69, 69, 69, 69, 69, 69, 100, 96,\n+        69, 69, 135, 135, 135, 135, 135, 135,\n+        135, 135, 135, 135, 135, 135, 135, 135,\n+        135, 135, 135, 135, 135, 135, 135, 135,\n+        135, 135, 135, 135, 135, 135, 135, 135,\n+        135, 135, 140, 141, 141, 141\n@@ -689,1 +838,1 @@\n-    if (0) fprintf (stderr, \"syllable %d..%d %s\\n\", (*ts).second.first, (*te).second.first, #syllable_type); \\\n+    if (0) fprintf (stderr, \"syllable %u..%u %s\\n\", (*ts).second.first, (*te).second.first, #syllable_type); \\\n@@ -693,1 +842,1 @@\n-    if (unlikely (syllable_serial == 16)) syllable_serial = 1; \\\n+    if (syllable_serial == 16) syllable_serial = 1; \\\n@@ -783,1 +932,1 @@\n-#line 784 \"hb-ot-shaper-use-machine.hh\"\n+#line 922 \"hb-ot-shaper-use-machine.hh\"\n@@ -796,1 +945,1 @@\n-#line 797 \"hb-ot-shaper-use-machine.hh\"\n+#line 931 \"hb-ot-shaper-use-machine.hh\"\n@@ -810,1 +959,1 @@\n-#line 811 \"hb-ot-shaper-use-machine.hh\"\n+#line 943 \"hb-ot-shaper-use-machine.hh\"\n@@ -828,1 +977,9 @@\n-        case 9:\n+        case 12:\n+#line 170 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p+1;{ found_syllable (use_virama_terminated_cluster); }}\n+        break;\n+        case 10:\n+#line 171 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p+1;{ found_syllable (use_sakot_terminated_cluster); }}\n+        break;\n+        case 8:\n@@ -832,0 +989,8 @@\n+        case 16:\n+#line 173 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p+1;{ found_syllable (use_number_joiner_terminated_cluster); }}\n+        break;\n+        case 14:\n+#line 174 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p+1;{ found_syllable (use_numeral_cluster); }}\n+        break;\n@@ -836,0 +1001,4 @@\n+        case 20:\n+#line 176 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p+1;{ found_syllable (use_hieroglyph_cluster); }}\n+        break;\n@@ -845,0 +1014,4 @@\n+#line 170 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p;p--;{ found_syllable (use_virama_terminated_cluster); }}\n+        break;\n+        case 9:\n@@ -852,1 +1025,1 @@\n-        case 14:\n+        case 15:\n@@ -864,1 +1037,1 @@\n-        case 17:\n+        case 19:\n@@ -868,1 +1041,1 @@\n-        case 15:\n+        case 17:\n@@ -872,1 +1045,1 @@\n-        case 16:\n+        case 18:\n@@ -876,25 +1049,1 @@\n-        case 12:\n-#line 1 \"NONE\"\n-        {       switch( act ) {\n-        case 1:\n-        {{p = ((te))-1;} found_syllable (use_virama_terminated_cluster); }\n-        break;\n-        case 2:\n-        {{p = ((te))-1;} found_syllable (use_sakot_terminated_cluster); }\n-        break;\n-        }\n-        }\n-        break;\n-        case 8:\n-#line 1 \"NONE\"\n-        {te = p+1;}\n-#line 170 \"hb-ot-shaper-use-machine.rl\"\n-        {act = 1;}\n-        break;\n-        case 10:\n-#line 1 \"NONE\"\n-        {te = p+1;}\n-#line 171 \"hb-ot-shaper-use-machine.rl\"\n-        {act = 2;}\n-        break;\n-#line 901 \"hb-ot-shaper-use-machine.hh\"\n+#line 1014 \"hb-ot-shaper-use-machine.hh\"\n@@ -909,1 +1058,1 @@\n-#line 910 \"hb-ot-shaper-use-machine.hh\"\n+#line 1021 \"hb-ot-shaper-use-machine.hh\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-use-machine.hh","additions":693,"deletions":544,"binary":false,"changes":1237,"status":"modified"},{"patch":"@@ -9,12 +9,12 @@\n- * # IndicSyllabicCategory-14.0.0.txt\n- * # Date: 2021-05-22, 01:01:00 GMT [KW, RP]\n- * # IndicPositionalCategory-14.0.0.txt\n- * # Date: 2021-05-22, 01:01:00 GMT [KW, RP]\n- * # ArabicShaping-14.0.0.txt\n- * # Date: 2021-05-21, 01:54:00 GMT [KW, RP]\n- * # DerivedCoreProperties-14.0.0.txt\n- * # Date: 2021-08-12, 23:12:53 GMT\n- * # Blocks-14.0.0.txt\n- * # Date: 2021-01-22, 23:29:00 GMT [KW]\n- * # Scripts-14.0.0.txt\n- * # Date: 2021-07-10, 00:35:31 GMT\n+ * # IndicSyllabicCategory-15.0.0.txt\n+ * # Date: 2022-05-26, 02:18:00 GMT [KW, RP]\n+ * # IndicPositionalCategory-15.0.0.txt\n+ * # Date: 2022-05-26, 02:18:00 GMT [KW, RP]\n+ * # ArabicShaping-15.0.0.txt\n+ * # Date: 2022-02-14, 18:50:00 GMT [KW, RP]\n+ * # DerivedCoreProperties-15.0.0.txt\n+ * # Date: 2022-08-05, 22:17:05 GMT\n+ * # Blocks-15.0.0.txt\n+ * # Date: 2022-01-28, 20:58:00 GMT [KW]\n+ * # Scripts-15.0.0.txt\n+ * # Date: 2022-04-26, 23:15:02 GMT\n@@ -28,0 +28,1 @@\n+ * # Updated for Unicode 15.0 by Andrew Glass 2022-09-16\n@@ -37,0 +38,1 @@\n+ * # Updated for Unicode 15.0 by Andrew Glass 2022-09-16\n@@ -92,1 +94,0 @@\n-static const uint8_t use_table[] = {\n@@ -94,0 +95,1 @@\n+#ifndef HB_OPTIMIZE_SIZE\n@@ -95,1322 +97,2 @@\n-#define use_offset_0x0028u 0\n-\n-\n-  \/* Basic Latin *\/\n-                                                                         O,     O,     O,     O,     O,    GB,     O,     O,\n-  \/* 0030 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x00a0u 24\n-\n-\n-  \/* Latin-1 Supplement *\/\n-\n-  \/* 00A0 *\/    GB,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,     O,     O,\n-  \/* 00B0 *\/     O,     O, FMPst, FMPst,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 00C0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 00D0 *\/     O,     O,     O,     O,     O,     O,     O,    GB,\n-\n-#define use_offset_0x0348u 80\n-\n-\n-  \/* Combining Diacritical Marks *\/\n-                                                                         O,     O,     O,     O,     O,     O,     O,   CGJ,\n-\n-#define use_offset_0x0640u 88\n-\n-\n-  \/* Arabic *\/\n-\n-  \/* 0640 *\/     B,     O,     O,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x07c8u 96\n-\n-\n-  \/* NKo *\/\n-                                                                         O,     O,     B,     B,     B,     B,     B,     B,\n-  \/* 07D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 07E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,\n-  \/* 07F0 *\/ VMAbv, VMAbv, VMAbv, VMAbv,     O,     O,     O,     O,     O,     O,     B,    WJ,    WJ, VMAbv,     O,     O,\n-\n-#define use_offset_0x0840u 152\n-\n-\n-  \/* Mandaic *\/\n-\n-  \/* 0840 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0850 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B, CMBlw, CMBlw, CMBlw,    WJ,    WJ,     O,    WJ,\n-\n-#define use_offset_0x0900u 184\n-\n-\n-  \/* Devanagari *\/\n-\n-  \/* 0900 *\/ VMAbv, VMAbv, VMAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0910 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0920 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0930 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VAbv,  VPst, CMBlw,     B,  VPst,  VPre,\n-  \/* 0940 *\/  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,  VPst,  VPst,  VPst,  VPst,     H,  VPre,  VPst,\n-  \/* 0950 *\/     O, VMAbv, VMBlw,     O,     O,  VAbv,  VBlw,  VBlw,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0960 *\/     B,     B,  VBlw,  VBlw,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0970 *\/     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-\n-  \/* Bengali *\/\n-\n-  \/* 0980 *\/    GB, VMAbv, VMPst, VMPst,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,     B,\n-  \/* 0990 *\/     B,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 09A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n-  \/* 09B0 *\/     B,    WJ,     B,    WJ,    WJ,    WJ,     B,     B,     B,     B,    WJ,    WJ, CMBlw,     B,  VPst,  VPre,\n-  \/* 09C0 *\/  VPst,  VBlw,  VBlw,  VBlw,  VBlw,    WJ,    WJ,  VPre,  VPre,    WJ,    WJ,  VPre,  VPre,     H,     O,    WJ,\n-  \/* 09D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,  VPst,    WJ,    WJ,    WJ,    WJ,     B,     B,    WJ,     B,\n-  \/* 09E0 *\/     B,     B,  VBlw,  VBlw,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 09F0 *\/     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     B,     O, FMAbv,    WJ,\n-\n-  \/* Gurmukhi *\/\n-\n-  \/* 0A00 *\/    WJ, VMAbv, VMAbv, VMPst,    WJ,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,     B,\n-  \/* 0A10 *\/     B,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0A20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n-  \/* 0A30 *\/     B,    WJ,     B,     B,    WJ,     B,     B,    WJ,     B,     B,    WJ,    WJ, CMBlw,    WJ,  VPst,  VPre,\n-  \/* 0A40 *\/  VPst,  VBlw,  VBlw,    WJ,    WJ,    WJ,    WJ,  VAbv,  VAbv,    WJ,    WJ,  VAbv,  VAbv,     H,    WJ,    WJ,\n-  \/* 0A50 *\/    WJ, VMBlw,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     B,     B,     B,     B,    WJ,     B,    WJ,\n-  \/* 0A60 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0A70 *\/ VMAbv, CMAbv,    GB,    GB,     O,  MBlw,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Gujarati *\/\n-\n-  \/* 0A80 *\/    WJ, VMAbv, VMAbv, VMPst,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,\n-  \/* 0A90 *\/     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0AA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n-  \/* 0AB0 *\/     B,    WJ,     B,     B,    WJ,     B,     B,     B,     B,     B,    WJ,    WJ, CMBlw,     B,  VPst,  VPre,\n-  \/* 0AC0 *\/  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,    WJ,  VAbv,  VAbv,  VAbv,    WJ,  VPst,  VPst,     H,    WJ,    WJ,\n-  \/* 0AD0 *\/     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 0AE0 *\/     B,     B,  VBlw,  VBlw,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0AF0 *\/     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     B, VMAbv, VMAbv, VMAbv, CMAbv, CMAbv, CMAbv,\n-\n-  \/* Oriya *\/\n-\n-  \/* 0B00 *\/    WJ, VMAbv, VMPst, VMPst,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,     B,\n-  \/* 0B10 *\/     B,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0B20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n-  \/* 0B30 *\/     B,    WJ,     B,     B,    WJ,     B,     B,     B,     B,     B,    WJ,    WJ, CMBlw,     B,  VPst,  VAbv,\n-  \/* 0B40 *\/  VPst,  VBlw,  VBlw,  VBlw,  VBlw,    WJ,    WJ,  VPre,  VPre,    WJ,    WJ,  VPre,  VPre,     H,    WJ,    WJ,\n-  \/* 0B50 *\/    WJ,    WJ,    WJ,    WJ,    WJ,  VAbv,  VAbv,  VAbv,    WJ,    WJ,    WJ,    WJ,     B,     B,    WJ,     B,\n-  \/* 0B60 *\/     B,     B,  VBlw,  VBlw,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0B70 *\/     O,     B,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Tamil *\/\n-\n-  \/* 0B80 *\/    WJ,    WJ, VMAbv,     O,    WJ,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,     B,     B,\n-  \/* 0B90 *\/     B,    WJ,     B,     B,     B,     B,    WJ,    WJ,    WJ,     B,     B,    WJ,     B,    WJ,     B,     B,\n-  \/* 0BA0 *\/    WJ,    WJ,    WJ,     B,     B,    WJ,    WJ,    WJ,     B,     B,     B,    WJ,    WJ,    WJ,     B,     B,\n-  \/* 0BB0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,  VPst,  VPst,\n-  \/* 0BC0 *\/  VAbv,  VPst,  VPst,    WJ,    WJ,    WJ,  VPre,  VPre,  VPre,    WJ,  VPre,  VPre,  VPre,     H,    WJ,    WJ,\n-  \/* 0BD0 *\/     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,  VPst,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 0BE0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0BF0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Telugu *\/\n-\n-  \/* 0C00 *\/ VMAbv, VMPst, VMPst, VMPst, VMAbv,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,\n-  \/* 0C10 *\/     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0C20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n-  \/* 0C30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ, CMBlw,     B,  VAbv,  VAbv,\n-  \/* 0C40 *\/  VAbv,  VPst,  VPst,  VPst,  VPst,    WJ,  VAbv,  VAbv,  VAbv,    WJ,  VAbv,  VAbv,  VAbv,     H,    WJ,    WJ,\n-  \/* 0C50 *\/    WJ,    WJ,    WJ,    WJ,    WJ,  VAbv,  VBlw,    WJ,     B,     B,     B,    WJ,    WJ,     O,    WJ,    WJ,\n-  \/* 0C60 *\/     B,     B,  VBlw,  VBlw,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0C70 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Kannada *\/\n-\n-  \/* 0C80 *\/     B, VMAbv, VMPst, VMPst,     O,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,\n-  \/* 0C90 *\/     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0CA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n-  \/* 0CB0 *\/     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,    WJ,    WJ, CMBlw,     B,  VPst,  VAbv,\n-  \/* 0CC0 *\/  VAbv,  VPst,  VPst,  VPst,  VPst,    WJ,  VAbv,  VAbv,  VAbv,    WJ,  VAbv,  VAbv,  VAbv,     H,    WJ,    WJ,\n-  \/* 0CD0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,  VPst,  VPst,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     B,    WJ,\n-  \/* 0CE0 *\/     B,     B,  VBlw,  VBlw,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0CF0 *\/    WJ,    CS,    CS,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Malayalam *\/\n-\n-  \/* 0D00 *\/ VMAbv, VMAbv, VMPst, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,\n-  \/* 0D10 *\/     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0D20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0D30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VAbv,  VAbv,     B,  VPst,  VPst,\n-  \/* 0D40 *\/  VPst,  VPst,  VPst,  VBlw,  VBlw,    WJ,  VPre,  VPre,  VPre,    WJ,  VPre,  VPre,  VPre,     H,     R,     O,\n-  \/* 0D50 *\/    WJ,    WJ,    WJ,    WJ,     O,     O,     O,  VPst,     O,     O,     O,     O,     O,     O,     O,     B,\n-  \/* 0D60 *\/     B,     B,  VBlw,  VBlw,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0D70 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Sinhala *\/\n-\n-  \/* 0D80 *\/    WJ, VMAbv, VMPst, VMPst,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0D90 *\/     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,     B,     B,     B,     B,     B,     B,\n-  \/* 0DA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0DB0 *\/     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,    WJ,    WJ,\n-  \/* 0DC0 *\/     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,   HVM,    WJ,    WJ,    WJ,    WJ,  VPst,\n-  \/* 0DD0 *\/  VPst,  VPst,  VAbv,  VAbv,  VBlw,    WJ,  VBlw,    WJ,  VPst,  VPre,  VPre,  VPre,  VPre,  VPre,  VPre,  VPst,\n-  \/* 0DE0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0DF0 *\/    WJ,    WJ,  VPst,  VPst,     O,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0x0f00u 1456\n-\n-\n-  \/* Tibetan *\/\n-\n-  \/* 0F00 *\/     B,     B,     O,     O,     B,     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 0F10 *\/     O,     O,     O,     O,     O,     O,     O,     O,  VBlw,  VBlw,     O,     O,     O,     O,     O,     O,\n-  \/* 0F20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0F30 *\/     B,     B,     B,     B,     O,  FBlw,     O,  FBlw,     O, CMAbv,     O,     O,     O,     O,  VPst,  VPre,\n-  \/* 0F40 *\/     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0F50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0F60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,\n-  \/* 0F70 *\/    WJ, CMBlw,  VBlw,  VAbv,  VAbv,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw, VMAbv,     O,\n-  \/* 0F80 *\/  VBlw,  VAbv, VMAbv, VMAbv,  VBlw,     O, VMAbv, VMAbv,     B,     B,     B,     B,     B,   SUB,   SUB,   SUB,\n-  \/* 0F90 *\/   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,    WJ,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,\n-  \/* 0FA0 *\/   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,\n-  \/* 0FB0 *\/   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,    WJ,     O,     O,\n-  \/* 0FC0 *\/     O,     O,     O,     O,     O,     O,  FBlw,     O,\n-\n-#define use_offset_0x1000u 1656\n-\n-\n-  \/* Myanmar *\/\n-\n-  \/* 1000 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1010 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1020 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,  VPst,  VAbv,  VAbv,  VBlw,\n-  \/* 1030 *\/  VBlw,  VPre,  VAbv,  VAbv,  VAbv,  VAbv, VMAbv, VMBlw, VMPst,    IS,  VAbv,  MPst,  MPre,  MBlw,  MBlw,     B,\n-  \/* 1040 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,    GB,     O,     O,    GB,     O,\n-  \/* 1050 *\/     B,     B,     B,     B,     B,     B,  VPst,  VPst,  VBlw,  VBlw,     B,     B,     B,     B,  MBlw,  MBlw,\n-  \/* 1060 *\/  MBlw,     B,  VPst, VMPst, VMPst,     B,     B,  VPst,  VPst, VMPst, VMPst, VMPst, VMPst, VMPst,     B,     B,\n-  \/* 1070 *\/     B,  VAbv,  VAbv,  VAbv,  VAbv,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1080 *\/     B,     B,  MBlw,  VPst,  VPre,  VAbv,  VAbv, VMPst, VMPst, VMPst, VMPst, VMPst, VMPst, VMBlw,     B, VMPst,\n-  \/* 1090 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMPst, VMPst,  VPst,  VAbv,     O,     O,\n-\n-#define use_offset_0x1700u 1816\n-\n-\n-  \/* Tagalog *\/\n-\n-  \/* 1700 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1710 *\/     B,     B,  VAbv,  VBlw,  VBlw,  VPst,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     B,\n-\n-  \/* Hanunoo *\/\n-\n-  \/* 1720 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1730 *\/     B,     B,  VAbv,  VBlw,  VPst,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Buhid *\/\n-\n-  \/* 1740 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1750 *\/     B,     B,  VAbv,  VBlw,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Tagbanwa *\/\n-\n-  \/* 1760 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,\n-  \/* 1770 *\/     B,    WJ,  VAbv,  VBlw,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Khmer *\/\n-\n-  \/* 1780 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1790 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 17A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 17B0 *\/     B,     B,     B,     B,   CGJ,   CGJ,  VPst,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VPre,  VPre,\n-  \/* 17C0 *\/  VPre,  VPre,  VPre,  VPre,  VPre,  VPre, VMAbv, VMPst,  VPst, VMAbv, VMAbv, FMAbv,  FAbv, CMAbv, FMAbv, VMAbv,\n-  \/* 17D0 *\/ FMAbv,  VAbv,    IS, FMAbv,     O,     O,     O,     O,     O,     O,     O,     O,     B, FMAbv,    WJ,    WJ,\n-  \/* 17E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 17F0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Mongolian *\/\n-\n-  \/* 1800 *\/     B,     O,     O,     O,     O,     O,     O,     B,     O,     O,     B,   CGJ,   CGJ,   CGJ,    WJ,   CGJ,\n-  \/* 1810 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 1820 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1830 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1840 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1850 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1860 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1870 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 1880 *\/    GB,    GB,    GB,    GB,    GB, CMAbv, CMAbv,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1890 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B, CMBlw,     B,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0x1900u 2248\n-\n-\n-  \/* Limbu *\/\n-\n-  \/* 1900 *\/    GB,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1910 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,\n-  \/* 1920 *\/  VAbv,  VAbv,  VBlw,  VPst,  VPst,  VAbv,  VAbv,  VAbv,  VAbv,   SUB,   SUB,   SUB,    WJ,    WJ,    WJ,    WJ,\n-  \/* 1930 *\/  FPst,  FPst, VMBlw,  FPst,  FPst,  FPst,  FPst,  FPst,  FPst,  FBlw, VMAbv, FMBlw,    WJ,    WJ,    WJ,    WJ,\n-  \/* 1940 *\/     O,    WJ,    WJ,    WJ,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-\n-  \/* Tai Le *\/\n-\n-  \/* 1950 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1960 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,\n-  \/* 1970 *\/     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* New Tai Lue *\/\n-\n-  \/* 1980 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1990 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 19A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,\n-  \/* 19B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 19C0 *\/     B,     B,     B,     B,     B,     B,     B,     B, VMPst, VMPst,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 19D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,     O,     O,\n-  \/* 19E0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 19F0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Buginese *\/\n-\n-  \/* 1A00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1A10 *\/     B,     B,     B,     B,     B,     B,     B,  VAbv,  VAbv,  VPre,  VPst,  VAbv,    WJ,    WJ,     O,     O,\n-\n-  \/* Tai Tham *\/\n-\n-  \/* 1A20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1A30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1A40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1A50 *\/     B,     B,     B,     B,     B,  MPre,  MBlw,   SUB,  FAbv,  FAbv,  MAbv,   SUB,   SUB,   SUB,   SUB,    WJ,\n-  \/* 1A60 *\/    Sk,  VPst,  VAbv,  VPst,  VPst,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VBlw,  VAbv,  VBlw,  VPst,  VPre,  VPre,\n-  \/* 1A70 *\/  VPre,  VPre,  VPre,  VAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,  VAbv, VMAbv, VMAbv,    WJ,    WJ, VMBlw,\n-  \/* 1A80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 1A90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0x1b00u 2664\n-\n-\n-  \/* Balinese *\/\n-\n-  \/* 1B00 *\/ VMAbv, VMAbv, VMAbv,  FAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1B10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1B20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1B30 *\/     B,     B,     B,     B, CMAbv,  VPst,  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VPre,  VPre,\n-  \/* 1B40 *\/  VPre,  VPre,  VAbv,  VAbv,     H,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,\n-  \/* 1B50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-  \/* 1B60 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O, SMAbv, SMBlw, SMAbv, SMAbv, SMAbv,\n-  \/* 1B70 *\/ SMAbv, SMAbv, SMAbv, SMAbv,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,\n-\n-  \/* Sundanese *\/\n-\n-  \/* 1B80 *\/ VMAbv,  FAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1B90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BA0 *\/     B,   SUB,   SUB,   SUB,  VAbv,  VBlw,  VPre,  VPst,  VAbv,  VAbv,  VPst,    IS,   SUB,   SUB,     B,     B,\n-  \/* 1BB0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-\n-  \/* Batak *\/\n-\n-  \/* 1BC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BD0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BE0 *\/     B,     B,     B,     B,     B,     B, CMAbv,  VPst,  VAbv,  VAbv,  VPst,  VPst,  VPst,  VAbv,  VPst,  VAbv,\n-  \/* 1BF0 *\/  FAbv,  FAbv, CMBlw, CMBlw,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     O,     O,     O,\n-\n-  \/* Lepcha *\/\n-\n-  \/* 1C00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1C10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1C20 *\/     B,     B,     B,     B,   SUB,   SUB,  VPst,  VPre,  VPre,  VPre,  VPst,  VPst,  VBlw,  FAbv,  FAbv,  FAbv,\n-  \/* 1C30 *\/  FAbv,  FAbv,  FAbv,  FAbv, VMPre, VMPre, FMAbv, CMBlw,    WJ,    WJ,    WJ,     O,     O,     O,     O,     O,\n-  \/* 1C40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,     B,     B,     B,\n-\n-#define use_offset_0x1cd0u 3000\n-\n-\n-  \/* Vedic Extensions *\/\n-\n-  \/* 1CD0 *\/ VMAbv, VMAbv, VMAbv,     O, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMAbv, VMAbv, VMBlw, VMBlw, VMBlw, VMBlw,\n-  \/* 1CE0 *\/ VMAbv, VMPst, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw,     O,     O,     O,     O, VMBlw,     O,     O,\n-  \/* 1CF0 *\/     O,     O,     O,     O, VMAbv,    CS,    CS, VMPst, VMAbv, VMAbv,    GB,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0x1df8u 3048\n-\n-\n-  \/* Combining Diacritical Marks Supplement *\/\n-                                                                         O,     O,     O, FMAbv,     O,     O,     O,     O,\n-\n-#define use_offset_0x2008u 3056\n-\n-\n-  \/* General Punctuation *\/\n-                                                                         O,     O,     O,    WJ,  ZWNJ,   CGJ,    WJ,    WJ,\n-  \/* 2010 *\/    GB,    GB,    GB,    GB,    GB,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 2020 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,     O,\n-  \/* 2030 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 2040 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 2050 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 2060 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Superscripts and Subscripts *\/\n-\n-  \/* 2070 *\/     O,     O,    WJ,    WJ, FMPst,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 2080 *\/     O,     O, FMPst, FMPst, FMPst,     O,     O,     O,\n-\n-#define use_offset_0x20f0u 3184\n-\n-\n-  \/* Combining Diacritical Marks for Symbols *\/\n-\n-  \/* 20F0 *\/ VMAbv,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0x25c8u 3192\n-\n-\n-  \/* Geometric Shapes *\/\n-                                                                         O,     O,     O,     O,     B,     O,     O,     O,\n-\n-#define use_offset_0x2d30u 3200\n-\n-\n-  \/* Tifinagh *\/\n-\n-  \/* 2D30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 2D40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 2D50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 2D60 *\/     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     B,\n-  \/* 2D70 *\/     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     H,\n-\n-#define use_offset_0xa800u 3280\n-\n-\n-  \/* Syloti Nagri *\/\n-\n-  \/* A800 *\/     B,     B,  VAbv,     B,     B,     B,     H,     B,     B,     B,     B, VMAbv,     B,     B,     B,     B,\n-  \/* A810 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A820 *\/     B,     B,     B,  VPst,  VPst,  VBlw,  VAbv,  VPst,     O,     O,     O,     O,  VBlw,    WJ,    WJ,    WJ,\n-  \/* A830 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Phags-pa *\/\n-\n-  \/* A840 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A850 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A860 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A870 *\/     B,     B,     B,     B,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Saurashtra *\/\n-\n-  \/* A880 *\/ VMPst, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A890 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A8A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A8B0 *\/     B,     B,     B,     B,  MPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,\n-  \/* A8C0 *\/  VPst,  VPst,  VPst,  VPst,     H, VMAbv,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     O,\n-  \/* A8D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Devanagari Extended *\/\n-\n-  \/* A8E0 *\/ VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,\n-  \/* A8F0 *\/ VMAbv, VMAbv,     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     B,  VAbv,\n-\n-  \/* Kayah Li *\/\n-\n-  \/* A900 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A910 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A920 *\/     B,     B,     B,     B,     B,     B,  VAbv,  VAbv,  VAbv,  VAbv,  VAbv, VMBlw, VMBlw, VMBlw,     O,     O,\n-\n-  \/* Rejang *\/\n-\n-  \/* A930 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A940 *\/     B,     B,     B,     B,     B,     B,     B,  VBlw,  VBlw,  VBlw,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw,  FAbv,\n-  \/* A950 *\/  FAbv,  FAbv,  FPst,  VPst,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,\n-  \/* A960 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* A970 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,\n-\n-  \/* Javanese *\/\n-\n-  \/* A980 *\/ VMAbv, VMAbv,  FAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A990 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A9A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A9B0 *\/     B,     B,     B, CMAbv,  VPst,  VPst,  VAbv,  VAbv,  VBlw,  VBlw,  VPre,  VPre,  VAbv,  MBlw,  MPst,  MBlw,\n-  \/* A9C0 *\/     H,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,     O,\n-  \/* A9D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,     O,     O,\n-\n-  \/* Myanmar Extended-B *\/\n-\n-  \/* A9E0 *\/     B,     B,     B,     B,     B,  VAbv,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A9F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,\n-\n-  \/* Cham *\/\n-\n-  \/* AA00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* AA10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* AA20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VAbv,  VPre,\n-  \/* AA30 *\/  VPre,  VAbv,  VBlw,  MPst,  MPre,  MAbv,  MBlw,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* AA40 *\/     B,     B,     B,  FAbv,     B,     B,     B,     B,     B,     B,     B,     B,  FAbv,  FPst,    WJ,    WJ,\n-  \/* AA50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,     O,     O,     O,     O,\n-\n-  \/* Myanmar Extended-A *\/\n-\n-  \/* AA60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* AA70 *\/     O,     B,     B,     B,    GB,    GB,    GB,     O,     O,     O,     B, VMPst, VMAbv, VMPst,     B,     B,\n-\n-  \/* Tai Viet *\/\n-\n-  \/* AA80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* AA90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* AAA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* AAB0 *\/  VAbv,     B,  VAbv,  VAbv,  VBlw,     B,     B,  VAbv,  VAbv,     B,     B,     B,     B,     B,  VAbv, VMAbv,\n-  \/* AAC0 *\/     B, VMAbv,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* AAD0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     O,     O,     O,     O,\n-\n-  \/* Meetei Mayek Extensions *\/\n-\n-  \/* AAE0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPre,  VBlw,  VAbv,  VPre,  VPst,\n-  \/* AAF0 *\/     O,     O,     O,     O,     O, VMPst,    IS,    WJ,\n-\n-#define use_offset_0xabc0u 4040\n-\n-\n-  \/* Meetei Mayek *\/\n-\n-  \/* ABC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* ABD0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* ABE0 *\/     B,     B,     B,  VPst,  VPst,  VAbv,  VPst,  VPst,  VBlw,  VPst,  VPst,     O, VMPst,  VBlw,    WJ,    WJ,\n-  \/* ABF0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0xfe00u 4104\n-\n-\n-  \/* Variation Selectors *\/\n-\n-  \/* FE00 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n-\n-#define use_offset_0xfef8u 4120\n-\n-\n-  \/* Arabic Presentation Forms-B *\/\n-                                                                         O,     O,     O,     O,     O,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0xfff0u 4128\n-\n-\n-  \/* Specials *\/\n-\n-  \/* FFF0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     O,     O,     O,     O,    WJ,    WJ,\n-\n-#define use_offset_0x10570u 4144\n-\n-\n-  \/* Vithkuqi *\/\n-\n-  \/* 10570 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,\n-  \/* 10580 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,\n-  \/* 10590 *\/     B,     B,     B,    WJ,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 105A0 *\/     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 105B0 *\/     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0x10a00u 4224\n-\n-\n-  \/* Kharoshthi *\/\n-\n-  \/* 10A00 *\/     B,  VBlw,  VBlw,  VBlw,    WJ,  VAbv,  VBlw,    WJ,    WJ,    WJ,    WJ,    WJ,  VPst, VMBlw, VMBlw, VMAbv,\n-  \/* 10A10 *\/     B,     B,     B,     B,    WJ,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10A20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10A30 *\/     B,     B,     B,     B,     B,     B,    WJ,    WJ, CMBlw, CMBlw, CMBlw,    WJ,    WJ,    WJ,    WJ,    IS,\n-  \/* 10A40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0x10ac0u 4304\n-\n-\n-  \/* Manichaean *\/\n-\n-  \/* 10AC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10AD0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10AE0 *\/     B,     B,     B,     B,     B, CMBlw, CMBlw,    WJ,    WJ,    WJ,    WJ,     B,     B,     B,     B,     B,\n-\n-#define use_offset_0x10b80u 4352\n-\n-\n-  \/* Psalter Pahlavi *\/\n-\n-  \/* 10B80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10B90 *\/     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     O,     O,     O,    WJ,    WJ,    WJ,\n-  \/* 10BA0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     O,\n-\n-#define use_offset_0x10d00u 4400\n-\n-\n-  \/* Hanifi Rohingya *\/\n-\n-  \/* 10D00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10D10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10D20 *\/     B,     B,     B,     B, VMAbv, VMAbv, VMAbv, CMAbv,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 10D30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0x10e80u 4464\n-\n-\n-  \/* Yezidi *\/\n-\n-  \/* 10E80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10E90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10EA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,  VAbv,  VAbv,     O,    WJ,    WJ,\n-  \/* 10EB0 *\/     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0x10f30u 4520\n-\n-\n-  \/* Sogdian *\/\n-\n-  \/* 10F30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10F40 *\/     B,     B,     B,     B,     B,     B, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw,\n-  \/* 10F50 *\/ VMBlw,     B,     B,     B,     B,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 10F60 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Old Uyghur *\/\n-\n-  \/* 10F70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10F80 *\/     B,     B, CMBlw, CMBlw, CMBlw, CMBlw,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 10F90 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 10FA0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Chorasmian *\/\n-\n-  \/* 10FB0 *\/     B,     O,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10FC0 *\/     O,     B,     B,     B,     B,     O,     O,     O,     O,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,\n-  \/* 10FD0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 10FE0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 10FF0 *\/     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Brahmi *\/\n-\n-  \/* 11000 *\/ VMPst, VMAbv, VMPst,    CS,    CS,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11010 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11020 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11030 *\/     B,     B,     B,     B,     B,     B,     B,     B,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw,\n-  \/* 11040 *\/  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,     H,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,\n-  \/* 11050 *\/    WJ,    WJ,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,\n-  \/* 11060 *\/     N,     N,     N,     N,     N,     N,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11070 *\/  VAbv,     B,     B,  VAbv,  VAbv,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    HN,\n-\n-  \/* Kaithi *\/\n-\n-  \/* 11080 *\/ VMAbv, VMAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11090 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 110A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 110B0 *\/  VPst,  VPre,  VPst,  VBlw,  VBlw,  VAbv,  VAbv,  VPst,  VPst,     H, CMBlw,     O,     O,     O,     O,     O,\n-  \/* 110C0 *\/     O,     O,  VBlw,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0x11100u 4928\n-\n-\n-  \/* Chakma *\/\n-\n-  \/* 11100 *\/ VMAbv, VMAbv, VMAbv,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11110 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11120 *\/     B,     B,     B,     B,     B,     B,     B,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VPre,  VBlw,  VAbv,  VAbv,\n-  \/* 11130 *\/  VBlw,  VAbv,  VAbv,    IS, CMAbv,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11140 *\/     O,     O,     O,     O,     B,  VPst,  VPst,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Mahajani *\/\n-\n-  \/* 11150 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11160 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11170 *\/     B,     B,     B, CMBlw,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Sharada *\/\n-\n-  \/* 11180 *\/ VMAbv, VMAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11190 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 111A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 111B0 *\/     B,     B,     B,  VPst,  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,\n-  \/* 111C0 *\/     H,     B,     R,     R,     O,     O,     O,     O,     O, FMBlw, CMBlw,  VAbv,  VBlw,     O,  VPre, VMAbv,\n-  \/* 111D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,\n-\n-  \/* Sinhala Archaic Numbers *\/\n-\n-  \/* 111E0 *\/    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 111F0 *\/     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Khojki *\/\n-\n-  \/* 11200 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11210 *\/     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11220 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,  VPst,  VPst,  VBlw,\n-  \/* 11230 *\/  VAbv,  VAbv,  VAbv,  VAbv, VMAbv,     H, CMAbv, CMAbv,     O,     O,     O,     O,     O,     O, VMAbv,    WJ,\n-\n-#define use_offset_0x11280u 5248\n-\n-\n-  \/* Multani *\/\n-\n-  \/* 11280 *\/     B,     B,     B,     B,     B,     B,     B,    WJ,     B,    WJ,     B,     B,     B,     B,    WJ,     B,\n-  \/* 11290 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,\n-  \/* 112A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Khudawadi *\/\n-\n-  \/* 112B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 112C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 112D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv,\n-  \/* 112E0 *\/  VPst,  VPre,  VPst,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv, CMBlw,  VBlw,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 112F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Grantha *\/\n-\n-  \/* 11300 *\/ VMAbv, VMAbv, VMAbv, VMAbv,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,     B,\n-  \/* 11310 *\/     B,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11320 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n-  \/* 11330 *\/     B,    WJ,     B,     B,    WJ,     B,     B,     B,     B,     B,    WJ, CMBlw, CMBlw,     B,  VPst,  VPst,\n-  \/* 11340 *\/  VAbv,  VPst,  VPst,  VPst,  VPst,    WJ,    WJ,  VPre,  VPre,    WJ,    WJ,  VPre,  VPre,     H,    WJ,    WJ,\n-  \/* 11350 *\/     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,  VPst,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     B,     B,\n-  \/* 11360 *\/     B,     B,  VPst,  VPst,    WJ,    WJ, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,    WJ,    WJ,    WJ,\n-  \/* 11370 *\/ VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0x11400u 5496\n-\n-\n-  \/* Newa *\/\n-\n-  \/* 11400 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11410 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11420 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11430 *\/     B,     B,     B,     B,     B,  VPst,  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,\n-  \/* 11440 *\/  VPst,  VPst,     H, VMAbv, VMAbv, VMPst, CMBlw,     B,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 11450 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,    WJ,     O, FMAbv,     B,\n-  \/* 11460 *\/    CS,    CS,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 11470 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Tirhuta *\/\n-\n-  \/* 11480 *\/     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11490 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 114A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 114B0 *\/  VPst,  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VPre,  VAbv,  VPre,  VPre,  VPst,  VPre, VMAbv,\n-  \/* 114C0 *\/ VMAbv, VMAbv,     H, CMBlw,     B,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 114D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0x11580u 5720\n-\n-\n-  \/* Siddham *\/\n-\n-  \/* 11580 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11590 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 115A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,\n-  \/* 115B0 *\/  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,    WJ,    WJ,  VPre,  VPre,  VPre,  VPre, VMAbv, VMAbv, VMPst,     H,\n-  \/* 115C0 *\/ CMBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 115D0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     B,     B,     B,     B,  VBlw,  VBlw,    WJ,    WJ,\n-  \/* 115E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 115F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Modi *\/\n-\n-  \/* 11600 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11610 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11620 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11630 *\/  VPst,  VPst,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VPst,  VPst, VMAbv, VMPst,     H,\n-  \/* 11640 *\/  VAbv,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 11650 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 11660 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,\n-  \/* 11670 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Takri *\/\n-\n-  \/* 11680 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11690 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 116A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv, VMPst,  VAbv,  VPre,  VPst,\n-  \/* 116B0 *\/  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,     H, CMBlw,     B,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 116C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 116D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 116E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 116F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Ahom *\/\n-\n-  \/* 11700 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11710 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,  MBlw,  MPre,  MAbv,\n-  \/* 11720 *\/  VPst,  VPst,  VAbv,  VAbv,  VBlw,  VBlw,  VPre,  VAbv,  VBlw,  VAbv,  VAbv,  VAbv,    WJ,    WJ,    WJ,    WJ,\n-  \/* 11730 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,\n-  \/* 11740 *\/     B,     B,     B,     B,     B,     B,     B,    WJ,\n-\n-#define use_offset_0x11800u 6176\n-\n-\n-  \/* Dogra *\/\n-\n-  \/* 11800 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11810 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11820 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,  VPre,  VPst,  VBlw,\n-  \/* 11830 *\/  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv, VMAbv, VMPst,     H, CMBlw,     O,    WJ,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0x11900u 6240\n-\n-\n-  \/* Dives Akuru *\/\n-\n-  \/* 11900 *\/     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,     B,    WJ,    WJ,     B,     B,     B,     B,\n-  \/* 11910 *\/     B,     B,     B,     B,    WJ,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11920 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11930 *\/  VPst,  VPst,  VPst,  VPst,  VPst,  VPre,    WJ,  VPre,  VPre,    WJ,    WJ, VMAbv, VMAbv,  VPst,    IS,     R,\n-  \/* 11940 *\/  MPst,     R,  MPst, CMBlw,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 11950 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0x119a0u 6336\n-\n-\n-  \/* Nandinagari *\/\n-\n-  \/* 119A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,     B,     B,     B,     B,     B,     B,\n-  \/* 119B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 119C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 119D0 *\/     B,  VPst,  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,    WJ,    WJ,  VAbv,  VAbv,  VPst,  VPst, VMPst, VMPst,\n-  \/* 119E0 *\/     H,     B,     O,     O,  VPre,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 119F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Zanabazar Square *\/\n-\n-  \/* 11A00 *\/     B,  VAbv,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,     B,     B,     B,     B,     B,\n-  \/* 11A10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11A20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11A30 *\/     B,     B,     B, FMBlw,  VBlw, VMAbv, VMAbv, VMAbv, VMAbv, VMPst,     R,  MBlw,  MBlw,  MBlw,  MBlw,    GB,\n-  \/* 11A40 *\/     O,     O,     O,     O,     O,    GB,     O,    IS,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Soyombo *\/\n-\n-  \/* 11A50 *\/     B,  VAbv,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VPst,  VPst,  VBlw,  VBlw,  VBlw,     B,     B,     B,     B,\n-  \/* 11A60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11A70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11A80 *\/     B,     B,     B,     B,     R,     R,     R,     R,     R,     R,  FBlw,  FBlw,  FBlw,  FBlw,  FBlw,  FBlw,\n-  \/* 11A90 *\/  FBlw,  FBlw,  FBlw,  FBlw,  FBlw,  FBlw, VMAbv, VMPst, CMAbv,    IS,     O,     O,     O,     B,     O,     O,\n-\n-#define use_offset_0x11c00u 6592\n-\n-\n-  \/* Bhaiksuki *\/\n-\n-  \/* 11C00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n-  \/* 11C10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11C20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,\n-  \/* 11C30 *\/  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,    WJ,  VAbv,  VAbv,  VAbv,  VAbv, VMAbv, VMAbv, VMPst,     H,\n-  \/* 11C40 *\/     B,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 11C50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11C60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,\n-\n-  \/* Marchen *\/\n-\n-  \/* 11C70 *\/     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11C80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11C90 *\/    WJ,    WJ,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,\n-  \/* 11CA0 *\/   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,    WJ,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,\n-  \/* 11CB0 *\/  VBlw,  VPre,  VBlw,  VAbv,  VPst, VMAbv, VMAbv,    WJ,\n-\n-#define use_offset_0x11d00u 6776\n-\n-\n-  \/* Masaram Gondi *\/\n-\n-  \/* 11D00 *\/     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,    WJ,     B,     B,     B,     B,     B,\n-  \/* 11D10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11D20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11D30 *\/     B,  VAbv,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,    WJ,    WJ,    WJ,  VAbv,    WJ,  VAbv,  VAbv,    WJ,  VAbv,\n-  \/* 11D40 *\/ VMAbv, VMAbv, CMBlw,  VAbv,  VBlw,    IS,     R,  MBlw,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 11D50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Gunjala Gondi *\/\n-\n-  \/* 11D60 *\/     B,     B,     B,     B,     B,     B,    WJ,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n-  \/* 11D70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11D80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,  VPst,  VPst,  VPst,  VPst,    WJ,\n-  \/* 11D90 *\/  VAbv,  VAbv,    WJ,  VPst,  VPst, VMAbv, VMPst,    IS,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 11DA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0x11ee0u 6952\n-\n-\n-  \/* Makasar *\/\n-\n-  \/* 11EE0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11EF0 *\/     B,     B,    GB,  VAbv,  VBlw,  VPre,  VPst,     O,\n-\n-#define use_offset_0x13000u 6976\n-\n-\n-  \/* Egyptian Hieroglyphs *\/\n-\n-  \/* 13000 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13010 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13020 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13030 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13040 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13050 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13060 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13070 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13080 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13090 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 130A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 130B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 130C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 130D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 130E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 130F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13100 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13110 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13120 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13130 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13140 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13150 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13160 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13170 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13180 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13190 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 131A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 131B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 131C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 131D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 131E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 131F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13200 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13210 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13220 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13230 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13240 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13250 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13260 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13270 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13280 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13290 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 132A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 132B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 132C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 132D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 132E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 132F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13300 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13310 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13320 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13330 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13340 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13350 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13360 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13370 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13380 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13390 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 133A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 133B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 133C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 133D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 133E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 133F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13400 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13410 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 13420 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,\n-\n-  \/* Egyptian Hieroglyph Format Controls *\/\n-\n-  \/* 13430 *\/     H,     H,     H,     H,     H,     H,     H,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0x16ac0u 8064\n-\n-\n-  \/* Tangsa *\/\n-\n-  \/* 16AC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 16AD0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 16AE0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,\n-  \/* 16AF0 *\/     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Pahawh Hmong *\/\n-\n-  \/* 16B00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 16B10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 16B20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 16B30 *\/ VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,     O,\n-\n-#define use_offset_0x16f00u 8184\n-\n-\n-  \/* Miao *\/\n-\n-  \/* 16F00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 16F10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 16F20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 16F30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 16F40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ, CMBlw,\n-  \/* 16F50 *\/     O,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,\n-  \/* 16F60 *\/  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,\n-  \/* 16F70 *\/  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,\n-  \/* 16F80 *\/  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ, VMBlw,\n-  \/* 16F90 *\/ VMBlw, VMBlw, VMBlw,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x16fe0u 8336\n-\n-\n-  \/* Ideographic Symbols and Punctuation *\/\n-\n-  \/* 16FE0 *\/     O,     O,     O,     O,     B,    WJ,    WJ,    WJ,\n-\n-#define use_offset_0x18b00u 8344\n-\n-\n-  \/* Khitan Small Script *\/\n-\n-  \/* 18B00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18BA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18BB0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18BC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18BD0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18BE0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18BF0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18CA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18CB0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18CC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18CD0 *\/     B,     B,     B,     B,     B,     B,    WJ,    WJ,\n-\n-#define use_offset_0x1bc00u 8816\n-\n-\n-  \/* Duployan *\/\n-\n-  \/* 1BC00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BC10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BC20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BC30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BC40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BC50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BC60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 1BC70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,\n-  \/* 1BC80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* 1BC90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,     O, CMBlw, CMBlw,     O,\n-\n-#define use_offset_0x1d170u 8976\n-\n-\n-  \/* Musical Symbols *\/\n-\n-  \/* 1D170 *\/     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x1e100u 8992\n-\n-\n-  \/* Nyiakeng Puachue Hmong *\/\n-\n-  \/* 1E100 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1E110 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1E120 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,\n-  \/* 1E130 *\/ VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,\n-  \/* 1E140 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,     B,     B,\n-\n-#define use_offset_0x1e290u 9072\n-\n-\n-  \/* Toto *\/\n-\n-  \/* 1E290 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1E2A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv,    WJ,\n-  \/* 1E2B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Wancho *\/\n-\n-  \/* 1E2C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1E2D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1E2E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv, VMAbv, VMAbv, VMAbv,\n-  \/* 1E2F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,     O,\n-\n-#define use_offset_0x1e900u 9184\n-\n-\n-  \/* Adlam *\/\n-\n-  \/* 1E900 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1E910 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1E920 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1E930 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1E940 *\/     B,     B,     B,     B, CMAbv, CMAbv, CMAbv, CMAbv, CMAbv, CMAbv, CMAbv,     B,    WJ,    WJ,    WJ,    WJ,\n-  \/* 1E950 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,     O,     O,\n-\n-#define use_offset_0xe0000u 9280\n-\n-\n-  \/* Tags *\/\n-\n-  \/* E0000 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0010 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0020 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0030 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0040 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0050 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0060 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0070 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* No_Block *\/\n-\n-  \/* E0080 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0090 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E00A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E00B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E00C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E00D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E00E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E00F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-  \/* Variation Selectors Supplement *\/\n-\n-  \/* E0100 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n-  \/* E0110 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n-  \/* E0120 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n-  \/* E0130 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n-  \/* E0140 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n-  \/* E0150 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n-  \/* E0160 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n-  \/* E0170 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n-  \/* E0180 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n-  \/* E0190 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n-  \/* E01A0 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n-  \/* E01B0 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n-  \/* E01C0 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n-  \/* E01D0 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n-  \/* E01E0 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n-\n-  \/* No_Block *\/\n-\n-  \/* E01F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0200 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0210 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0220 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0230 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0240 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0250 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0260 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0270 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0280 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0290 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E02A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E02B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E02C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E02D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E02E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E02F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0300 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0310 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0320 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0330 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0340 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0350 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0360 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0370 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0380 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0390 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E03A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E03B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E03C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E03D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E03E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E03F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0400 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0410 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0420 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0430 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0440 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0450 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0460 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0470 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0480 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0490 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E04A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E04B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E04C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E04D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E04E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E04F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0500 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0510 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0520 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0530 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0540 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0550 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0560 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0570 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0580 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0590 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E05A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E05B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E05C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E05D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E05E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E05F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0600 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0610 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0620 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0630 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0640 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0650 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0660 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0670 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0680 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0690 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E06A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E06B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E06C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E06D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E06E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E06F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0700 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0710 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0720 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0730 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0740 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0750 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0760 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0770 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0780 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0790 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E07A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E07B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E07C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E07D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E07E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E07F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0800 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0810 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0820 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0830 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0840 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0850 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0860 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0870 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0880 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0890 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E08A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E08B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E08C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E08D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E08E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E08F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0900 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0910 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0920 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0930 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0940 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0950 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0960 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0970 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0980 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0990 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E09A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E09B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E09C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E09D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E09E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E09F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0A00 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0A10 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0A20 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0A30 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0A40 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0A50 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0A60 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0A70 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0A80 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0A90 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0AA0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0AB0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0AC0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0AD0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0AE0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0AF0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0B00 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0B10 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0B20 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0B30 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0B40 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0B50 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0B60 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0B70 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0B80 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0B90 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0BA0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0BB0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0BC0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0BD0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0BE0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0BF0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0C00 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0C10 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0C20 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0C30 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0C40 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0C50 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0C60 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0C70 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0C80 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0C90 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0CA0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0CB0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0CC0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0CD0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0CE0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0CF0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0D00 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0D10 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0D20 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0D30 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0D40 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0D50 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0D60 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0D70 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0D80 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0D90 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0DA0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0DB0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0DC0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0DD0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0DE0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0DF0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0E00 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0E10 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0E20 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0E30 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0E40 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0E50 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0E60 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0E70 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0E80 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0E90 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0EA0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0EB0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0EC0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0ED0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0EE0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0EF0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0F00 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0F10 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0F20 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0F30 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0F40 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0F50 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0F60 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0F70 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0F80 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0F90 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0FA0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0FB0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0FC0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0FD0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0FE0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-  \/* E0FF0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n-\n-}; \/* Table items: 13376; occupancy: 84% *\/\n-\n-static inline uint8_t\n-hb_use_get_category (hb_glyph_info_t info)\n+static const uint8_t\n+hb_use_u8[3141] =\n@@ -1418,93 +100,262 @@\n-  hb_codepoint_t u = info.codepoint;\n-  switch (u >> 12)\n-  {\n-    case 0x0u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x0028u, 0x003Fu)) return use_table[u - 0x0028u + use_offset_0x0028u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x00A0u, 0x00D7u)) return use_table[u - 0x00A0u + use_offset_0x00a0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x0348u, 0x034Fu)) return use_table[u - 0x0348u + use_offset_0x0348u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x0640u, 0x0647u)) return use_table[u - 0x0640u + use_offset_0x0640u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x07C8u, 0x07FFu)) return use_table[u - 0x07C8u + use_offset_0x07c8u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x0840u, 0x085Fu)) return use_table[u - 0x0840u + use_offset_0x0840u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x0900u, 0x0DF7u)) return use_table[u - 0x0900u + use_offset_0x0900u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x0F00u, 0x0FC7u)) return use_table[u - 0x0F00u + use_offset_0x0f00u];\n-      break;\n-\n-    case 0x1u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1000u, 0x109Fu)) return use_table[u - 0x1000u + use_offset_0x1000u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1700u, 0x18AFu)) return use_table[u - 0x1700u + use_offset_0x1700u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1900u, 0x1A9Fu)) return use_table[u - 0x1900u + use_offset_0x1900u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1B00u, 0x1C4Fu)) return use_table[u - 0x1B00u + use_offset_0x1b00u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1CD0u, 0x1CFFu)) return use_table[u - 0x1CD0u + use_offset_0x1cd0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1DF8u, 0x1DFFu)) return use_table[u - 0x1DF8u + use_offset_0x1df8u];\n-      break;\n-\n-    case 0x2u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x2008u, 0x2087u)) return use_table[u - 0x2008u + use_offset_0x2008u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x20F0u, 0x20F7u)) return use_table[u - 0x20F0u + use_offset_0x20f0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x25C8u, 0x25CFu)) return use_table[u - 0x25C8u + use_offset_0x25c8u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x2D30u, 0x2D7Fu)) return use_table[u - 0x2D30u + use_offset_0x2d30u];\n-      break;\n-\n-    case 0xAu:\n-      if (hb_in_range<hb_codepoint_t> (u, 0xA800u, 0xAAF7u)) return use_table[u - 0xA800u + use_offset_0xa800u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0xABC0u, 0xABFFu)) return use_table[u - 0xABC0u + use_offset_0xabc0u];\n-      break;\n-\n-    case 0xFu:\n-      if (hb_in_range<hb_codepoint_t> (u, 0xFE00u, 0xFE0Fu)) return use_table[u - 0xFE00u + use_offset_0xfe00u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0xFEF8u, 0xFEFFu)) return use_table[u - 0xFEF8u + use_offset_0xfef8u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0xFFF0u, 0xFFFFu)) return use_table[u - 0xFFF0u + use_offset_0xfff0u];\n-      break;\n-\n-    case 0x10u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0xFFF0u, 0xFFFFu)) return use_table[u - 0xFFF0u + use_offset_0xfff0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10570u, 0x105BFu)) return use_table[u - 0x10570u + use_offset_0x10570u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10A00u, 0x10A4Fu)) return use_table[u - 0x10A00u + use_offset_0x10a00u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10AC0u, 0x10AEFu)) return use_table[u - 0x10AC0u + use_offset_0x10ac0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10B80u, 0x10BAFu)) return use_table[u - 0x10B80u + use_offset_0x10b80u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10D00u, 0x10D3Fu)) return use_table[u - 0x10D00u + use_offset_0x10d00u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10E80u, 0x10EB7u)) return use_table[u - 0x10E80u + use_offset_0x10e80u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10F30u, 0x110C7u)) return use_table[u - 0x10F30u + use_offset_0x10f30u];\n-      break;\n-\n-    case 0x11u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10F30u, 0x110C7u)) return use_table[u - 0x10F30u + use_offset_0x10f30u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11100u, 0x1123Fu)) return use_table[u - 0x11100u + use_offset_0x11100u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11280u, 0x11377u)) return use_table[u - 0x11280u + use_offset_0x11280u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11400u, 0x114DFu)) return use_table[u - 0x11400u + use_offset_0x11400u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11580u, 0x11747u)) return use_table[u - 0x11580u + use_offset_0x11580u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11800u, 0x1183Fu)) return use_table[u - 0x11800u + use_offset_0x11800u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11900u, 0x1195Fu)) return use_table[u - 0x11900u + use_offset_0x11900u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x119A0u, 0x11A9Fu)) return use_table[u - 0x119A0u + use_offset_0x119a0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11C00u, 0x11CB7u)) return use_table[u - 0x11C00u + use_offset_0x11c00u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11D00u, 0x11DAFu)) return use_table[u - 0x11D00u + use_offset_0x11d00u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11EE0u, 0x11EF7u)) return use_table[u - 0x11EE0u + use_offset_0x11ee0u];\n-      break;\n-\n-    case 0x13u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x13000u, 0x1343Fu)) return use_table[u - 0x13000u + use_offset_0x13000u];\n-      break;\n-\n-    case 0x16u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x16AC0u, 0x16B37u)) return use_table[u - 0x16AC0u + use_offset_0x16ac0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x16F00u, 0x16F97u)) return use_table[u - 0x16F00u + use_offset_0x16f00u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x16FE0u, 0x16FE7u)) return use_table[u - 0x16FE0u + use_offset_0x16fe0u];\n-      break;\n-\n-    case 0x18u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x18B00u, 0x18CD7u)) return use_table[u - 0x18B00u + use_offset_0x18b00u];\n-      break;\n-\n-    case 0x1Bu:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1BC00u, 0x1BC9Fu)) return use_table[u - 0x1BC00u + use_offset_0x1bc00u];\n-      break;\n-\n-    case 0x1Du:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1D170u, 0x1D17Fu)) return use_table[u - 0x1D170u + use_offset_0x1d170u];\n-      break;\n-\n-    case 0x1Eu:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1E100u, 0x1E14Fu)) return use_table[u - 0x1E100u + use_offset_0x1e100u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1E290u, 0x1E2FFu)) return use_table[u - 0x1E290u + use_offset_0x1e290u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1E900u, 0x1E95Fu)) return use_table[u - 0x1E900u + use_offset_0x1e900u];\n-      break;\n+     16,   50,   51,   51,   51,   52,   51,   83,  118,  131,   51,   57,   58,  179,  195,   61,\n+     51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,\n+     51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,\n+     51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,\n+     51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,\n+     51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,\n+     51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,\n+     14,    0,    1,    2,    2,    2,    2,    3,    2,    2,    2,    2,    2,    4,    2,    2,\n+      5,    6,    2,    7,    8,    9,   10,   11,   12,   13,   14,   15,   16,    2,    2,   17,\n+     18,   19,   20,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,   21,\n+     22,   23,   24,   25,   26,   27,   28,   29,   30,   31,   32,    2,   33,    2,    2,    2,\n+      2,   34,   35,    2,    2,    2,    2,    2,    2,    2,    2,    2,   36,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,   37,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n+      2,   38,   39,   40,   41,   42,   43,    2,   44,    2,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,   45,   46,    2,\n+     47,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,   48,   49,    2,    2,    2,\n+      2,    2,    2,    2,    2,   50,   51,    2,   52,    2,    2,   53,    2,    2,   54,   55,\n+     56,   57,   58,   59,   60,   61,   62,   63,    2,   64,   65,    2,   66,   67,   68,   69,\n+      2,   70,    2,   71,   72,   73,   74,    2,    2,   75,   76,   77,   78,    2,   79,   80,\n+      2,   81,   81,   81,   81,   81,   81,   81,   81,   82,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,   83,   84,    2,    2,    2,    2,    2,    2,    2,   85,\n+     86,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,   81,   81,   81,   87,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,    2,    2,   88,   89,    2,    2,    2,    2,    2,\n+      2,    2,    2,   90,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,   91,    2,    2,   92,    2,    2,    2,   93,    2,    2,    2,    2,    2,\n+      2,    2,    2,   94,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n+      2,   95,   95,   96,   97,   95,   95,   95,   95,   95,   95,   95,   95,   95,   95,   95,\n+     95,   95,   95,   95,   95,   95,   95,   95,   95,   95,   95,   95,   95,   95,   95,   95,\n+     95,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,\n+      0,    2,    2,    2,    2,    2,    0,    0,    0,    3,    0,    0,    0,    0,    0,    4,\n+      0,    0,    5,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,    0,    0,    0,\n+      0,    0,    0,    0,    0,    0,    0,    0,    6,    7,    0,    0,    0,    0,    0,    0,\n+      0,    0,    0,    0,    0,    0,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    8,    9,    9,    9,    9,    0,    0,    0,    7,   10,\n+      0,    2,    2,    2,    2,   11,   12,    0,    0,    9,   13,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,   14,   15,   16,   17,   18,   19,   20,   14,   21,   22,\n+     23,   10,   24,   25,   18,    2,    2,    2,    2,    2,   18,    0,    2,    2,    2,    2,\n+      2,    0,    2,    2,    2,    2,    2,    2,    2,   26,   27,   28,    2,    2,    2,    7,\n+     28,    7,   28,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    7,    2,    2,\n+      2,    7,    7,    0,    2,    2,    0,   15,   16,   17,   18,   29,   30,   31,   30,   32,\n+      0,    0,    0,    0,   33,    0,    0,    2,   28,    2,    0,    0,    0,    0,    0,    7,\n+     34,   10,   13,   28,    2,    2,    7,    0,   28,    7,    2,   28,    7,    2,    0,   35,\n+     16,   17,   29,    0,   25,   36,   25,   37,    0,   38,    0,    0,    0,   28,    2,    7,\n+      7,    0,    0,    0,    2,    2,    2,    2,    2,   39,   40,   41,    0,    0,    0,    0,\n+      0,   10,   13,   28,    2,    2,    2,    2,   28,    2,   28,    2,    2,    2,    2,    2,\n+      2,    7,    2,   28,    2,    2,    0,   15,   16,   17,   18,   19,   25,   20,   33,   22,\n+      0,    0,    0,    0,    0,   28,   39,   39,   42,   10,   27,   28,    2,    2,    2,    7,\n+     28,    7,    2,   28,    2,    2,    0,   15,   43,    0,    0,   25,   20,    0,    0,    2,\n+     28,   28,    0,    0,    0,    0,    0,    0,    0,    0,   44,   28,    2,    2,    7,    0,\n+      2,    7,    2,    2,    0,   28,    7,    7,    2,    0,   28,    7,    0,    2,    7,    0,\n+      2,    2,    2,    2,    2,    2,    0,    0,   21,   14,   45,    0,   46,   31,   46,   32,\n+      0,    0,    0,    0,   33,    0,    0,    0,    0,   13,   27,   47,    2,    2,    2,    7,\n+      2,    7,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    0,   15,\n+     20,   14,   21,   45,   20,   36,   20,   37,    0,    0,    0,   25,   29,    2,    7,    0,\n+      0,    8,   27,   28,    2,    2,    2,    7,    2,    2,    2,   28,    2,    2,    0,   15,\n+     43,    0,    0,   33,   45,    0,    0,    0,    7,   48,   49,    0,    0,    0,    0,    0,\n+      0,    9,   27,    2,    2,    2,    2,    7,    2,    2,    2,    2,    2,    2,   50,   51,\n+     21,   21,   17,   29,   46,   31,   46,   32,   52,    0,    0,    0,   33,    0,    0,    0,\n+     28,   10,   27,   28,    2,    2,    2,    2,    2,    2,    2,    2,    7,    0,    2,    2,\n+      2,    2,   28,    2,    2,    2,    2,   28,    0,    2,    2,    2,    7,    0,   53,    0,\n+     33,   21,   20,   29,   29,   16,   46,   46,   23,    0,   21,    0,    0,    0,    0,    0,\n+      0,    2,    0,    2,    7,    0,    0,    0,    0,    0,    0,    0,    0,   18,    0,    0,\n+      0,    2,    2,   54,   54,   55,    0,    0,   16,    2,    2,    2,    2,   28,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,    7,    0,   56,   19,   57,   20,   20,   18,   18,\n+     44,   19,    9,   29,    9,    2,    2,   58,   59,   59,   59,   59,   59,   60,   59,   59,\n+     59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   61,\n+      0,    0,    0,    0,   62,    0,    0,    0,    0,    2,    2,    2,    2,    2,   63,   43,\n+     57,   64,   20,   20,   65,   66,   67,   68,   69,    2,    2,    2,    2,    2,    1,    0,\n+      3,    2,    2,    2,   21,   18,    2,    2,   70,   69,   71,   72,   63,   71,   27,   27,\n+      2,   50,   20,   51,    2,    2,    2,    2,    2,    2,   73,   74,   75,   27,   27,   76,\n+     77,    2,    2,    2,    2,    2,   27,   43,    0,    2,   57,   78,    0,    0,    0,    0,\n+     28,    2,   57,   45,    0,    0,    0,    0,    0,    2,   57,    0,    0,    0,    0,    0,\n+      0,    2,    2,    2,    2,    2,    2,    7,    2,    7,   57,    0,    0,    0,    0,    0,\n+      0,    2,    2,   79,   43,   20,   57,   18,   46,   46,   46,   46,   13,   80,   81,   82,\n+     83,   84,   85,    0,    0,    0,    0,   86,    0,    7,    0,    0,   28,    0,   87,   79,\n+     88,    2,    2,    2,    2,    7,    0,    0,    0,   40,   40,   89,   90,    2,    2,    2,\n+      2,    2,    2,    2,    2,   11,    7,    0,    0,   91,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,    2,    7,   20,   78,   43,   20,   92,   59,    0,\n+      0,   93,   94,   93,   93,   95,   96,    0,    0,    2,    2,    2,    2,    2,    2,    2,\n+      0,    2,    2,    7,    0,    0,    0,    0,    0,    2,    2,    2,    2,    2,    2,    0,\n+      0,    2,    2,    2,    2,   27,    0,    0,    0,    2,    2,    2,    2,    2,    7,    0,\n+      0,    2,    2,    2,   50,   97,   43,    0,    0,    2,    2,   98,   99,  100,  101,   59,\n+     61,  102,   14,   43,   20,   57,   19,   78,   46,   46,   74,    9,    9,    9,  103,   44,\n+     38,    9,  104,   72,    2,    2,    2,    2,    2,    2,    2,  105,   20,   18,   18,   20,\n+     46,   46,   20,  106,    2,    2,    2,    7,    0,    0,    0,    0,    0,    0,  107,  108,\n+    109,  109,  109,    0,    0,    0,    0,    0,    0,  104,   72,    2,    2,    2,    2,    2,\n+      2,   58,   59,   57,   23,   20,  110,   59,    2,    2,    2,    2,  105,   20,   21,   43,\n+     43,  100,   12,    0,    0,    0,    0,    0,    0,    2,    2,   59,   16,   46,   21,  111,\n+    100,  100,  100,  112,  113,    0,    0,    0,    0,    2,    2,    2,    2,    2,    0,   28,\n+      2,    9,   44,  114,  114,  114,    9,  114,  114,   13,  114,  114,  114,   24,    0,   38,\n+      0,    0,    0,  115,   49,    9,    3,    0,    0,    0,    0,    0,    0,    0,  116,    0,\n+      0,    0,    0,    0,    0,    0,    4,  117,  118,   40,   40,    3,    0,    0,    0,    0,\n+      0,    0,    0,    0,    0,    0,  118,  118,  119,  118,  118,  118,  118,  118,  118,  118,\n+    118,    0,    0,  120,    0,    0,    0,    0,    0,    0,    5,  120,    0,    0,    0,    0,\n+      0,   44,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    7,\n+      0,    2,    2,    2,    2,    0,    0,    0,   28,    0,    0,    0,    0,    0,    0,    0,\n+    121,    2,   51,    2,  106,    2,    8,    2,    2,    2,   63,   17,   14,    0,    0,   29,\n+      0,    2,    2,    0,    0,    0,    0,    0,    0,   27,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,  122,   21,   21,   21,   21,   21,   21,   21,  123,    0,    0,    0,    0,\n+      0,    9,    9,    9,    9,    9,    9,    9,    9,    9,    2,    0,    0,    0,    0,    0,\n+     50,    2,    2,    2,   20,   20,  124,  114,    0,    2,    2,    2,  125,   18,   57,   18,\n+    111,  100,  126,    0,    0,    0,    0,    0,    0,    9,  127,    2,    2,    2,    2,    2,\n+      2,    2,  128,   21,   20,   18,   46,  129,  130,  131,    0,    0,    0,    0,    0,    0,\n+      0,    2,    2,   50,   28,    2,    2,    2,    2,    2,    2,    2,    2,    8,   20,   57,\n+     97,   74,  132,  133,  134,    0,    0,    0,    0,    2,  135,    2,    2,    2,    2,  136,\n+      0,   28,    2,   40,    3,    0,   77,   13,    2,   51,   20,  137,   50,   51,    2,    2,\n+    103,    8,    7,    0,    0,    0,    0,    0,    0,    2,    2,    2,    2,    2,  138,   19,\n+     23,    0,    0,  139,  140,    0,    0,    0,    0,    2,   63,   43,   21,   78,   45,  141,\n+      0,   79,   79,   79,   79,   79,   79,   79,   79,    0,    0,    0,    0,    0,    0,    0,\n+      4,  118,  118,  118,  118,  119,    0,    0,    0,    2,    2,    2,    2,    2,    7,    2,\n+      2,    2,    7,    2,   28,    2,    2,    2,    2,    2,   28,    2,    2,    2,   28,    7,\n+      0,  125,   18,   25,   29,    0,    0,  142,  143,    2,    2,   28,    2,   28,    2,    2,\n+      2,    2,    2,    2,    0,   12,   35,    0,  144,    2,    2,   11,   35,    0,   28,    2,\n+      2,    2,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   28,    2,    2,\n+      7,    2,    2,    9,   39,    0,    0,    0,    0,    2,    2,    2,    2,    2,   25,   36,\n+      0,    2,    2,    2,  114,  114,  114,  114,  114,  145,    2,    7,    0,    0,    0,    0,\n+      0,    2,   12,   12,    0,    0,    0,    0,    0,    7,    2,    2,    7,    2,    2,    2,\n+      2,   28,    2,    7,    0,   28,    2,    0,    0,  146,  147,  148,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,   20,   20,   18,   18,   18,   20,   20,  131,    0,    0,    0,\n+      0,    0,  149,  149,  149,  149,  149,  149,  149,  149,  149,  149,    2,    2,    2,    2,\n+      2,   51,   50,   51,    0,    0,    0,    0,  150,    9,   72,    2,    2,    2,    2,    2,\n+      2,   16,   17,   19,   14,   22,   35,    0,    0,    0,   29,    0,    0,    0,    0,    0,\n+      0,    9,   47,    2,    2,    2,    2,    2,    2,    2,    2,    2,  125,   18,   20,  151,\n+     20,   19,  152,  153,    2,    2,    2,    2,    2,    0,    0,   63,  154,    0,    0,    0,\n+      0,    2,   11,    0,    0,    0,    0,    0,    0,    2,   63,   23,   18,   18,   18,   20,\n+     20,  106,  155,    0,    0,   54,  156,   29,  157,   28,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,   21,   17,   20,   20,  158,   42,    0,    0,    0,\n+     47,  125,    0,    0,    0,    0,    0,    0,    0,    2,    2,    2,    7,    7,    2,    2,\n+     28,    2,    2,    2,    2,    2,    2,    2,   28,    2,    2,    2,    2,    2,    2,    2,\n+      8,   16,   17,   19,   20,  159,   29,    0,    0,    9,    9,   28,    2,    2,    2,    7,\n+     28,    7,    2,   28,    2,    2,   56,   15,   21,   14,   21,   45,   30,   31,   30,   32,\n+      0,    0,    0,    0,   33,    0,    0,    0,    2,    2,   21,    0,    9,    9,    9,   44,\n+      0,    9,    9,   44,    0,    0,    0,    0,    0,    2,    2,   63,   23,   18,   18,   18,\n+     20,   21,  123,   13,   15,    0,    0,    0,    0,    2,    2,    2,    2,    2,    0,    0,\n+    160,  161,    0,    0,    0,    0,    0,    0,    0,   16,   17,   18,   18,   64,   97,   23,\n+    157,    9,  162,    7,    0,    0,    0,    0,    0,    2,    2,    2,    2,    2,    2,    2,\n+     63,   23,   18,   18,    0,   46,   46,    9,  163,   35,    0,    0,    0,    0,    0,    0,\n+      0,    0,    0,    0,    0,    2,    2,   18,    0,   21,   17,   18,   18,   19,   14,   80,\n+    163,   36,    0,    0,    0,    0,    0,    0,    0,    2,    2,    2,    2,    2,    8,  164,\n+     23,   18,   20,   20,  162,    7,    0,    0,    0,    2,    2,    2,    2,    2,    7,   41,\n+    133,   21,   20,   18,   74,   19,   20,    0,    0,    2,    2,    2,    7,    0,    0,    0,\n+      0,    2,    2,    2,    2,    2,    2,   16,   17,   18,   19,   20,  103,  163,   35,    0,\n+      0,    2,    2,    2,    7,   28,    0,    2,    2,    2,    2,   28,    7,    2,    2,    2,\n+      2,   21,   21,   16,   30,   31,   10,  165,  166,  167,  168,    0,    0,    0,    0,    0,\n+      0,    2,    2,    2,    2,    0,    2,    2,    2,   63,   23,   18,   18,    0,   20,   21,\n+     27,  106,    0,   31,    0,    0,    0,    0,    0,   50,   18,   20,   20,   20,  137,    2,\n+      2,    2,  169,  170,    9,   13,  171,   70,  172,    0,    0,    1,  144,    0,    0,    0,\n+      0,   50,   18,   20,   14,   17,   18,    2,    2,    2,    2,  155,  155,  155,  173,  173,\n+    173,  173,  173,  173,   13,  174,    0,   28,    0,   20,   18,   18,   29,   20,   20,    9,\n+    163,    0,   59,   59,   59,   59,   59,   59,   59,   64,   19,   80,   44,    0,    0,    0,\n+      0,    2,    2,    2,    7,    2,   28,    2,    2,   50,   20,   20,   29,    0,   36,   20,\n+     25,    9,  156,  175,  171,    0,    0,    0,    0,    2,    2,    2,   28,    7,    2,    2,\n+      2,    2,    2,    2,    2,    2,   21,   21,   45,   20,   33,   80,   66,    0,    0,    0,\n+      0,    2,  176,   64,   45,    0,    0,    0,    0,    9,  177,    2,    2,    2,    2,    2,\n+      2,    2,    2,   21,   20,   18,   29,    0,   46,   14,  140,    0,    0,    0,    0,    0,\n+      0,  178,  178,  178,  106,  179,  178,    0,    0,  145,    2,    2,  180,  114,  114,  114,\n+    114,  114,  114,  114,    0,    0,    0,    0,    0,    9,    9,    9,   44,    0,    0,    0,\n+      0,    2,    2,    2,    2,    2,    7,    0,   56,  181,   18,   18,   18,   18,   18,   18,\n+     18,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,    0,    0,    0,\n+     38,  114,   24,    0,    0,    0,    0,    0,    0,    0,    0,    7,    0,    0,    0,    0,\n+      0,    2,    2,    2,    0,    0,    0,    0,    0,    2,    2,    2,    2,    2,    0,   56,\n+     35,    0,    4,  118,  118,  118,  119,    0,    0,    9,    9,    9,   47,    2,    2,    2,\n+      0,    2,    2,    2,    2,    2,    0,    0,    2,    2,    2,    2,    2,    2,    2,    2,\n+     44,    2,    2,    2,    2,    2,    2,    9,    9,    2,    2,    2,    2,    2,    2,   20,\n+     20,    2,    2,   42,   42,   42,   90,    0,    0,    O,    O,    O,   GB,    B,    B,   GB,\n+      O,    O,   WJ,FMPst,FMPst,    O,  CGJ,    B,    O,    B,VMAbv,VMAbv,VMAbv,    O,VMAbv,    B,\n+  CMBlw,CMBlw,CMBlw,VMAbv,VMPst, VAbv, VPst,CMBlw,    B, VPst, VPre, VPst, VBlw, VBlw, VBlw, VBlw,\n+   VAbv, VAbv, VAbv, VPst, VPst, VPst,    H, VPre, VPst,VMBlw,    O,    O, VAbv,   GB,VMAbv,VMPst,\n+  VMPst,    O,    B, VBlw,    O,    O, VPre, VPre,    O, VPre,    H,    O, VPst,FMAbv,    O,CMBlw,\n+      O, VAbv,    O, VAbv,    H,    O,VMBlw,VMAbv,CMAbv,   GB,   GB,    O, MBlw,CMAbv,CMAbv, VPst,\n+   VAbv,VMAbv,    O, VPst,    O, VPre, VPre,VMAbv,    B,    O,   CS,   CS,VMPst,    B, VAbv, VAbv,\n+      B,    R,    O,  HVM,    O,    O,FMBlw,    O,CMAbv,    O,CMBlw, VAbv, VBlw,    B,  SUB,  SUB,\n+    SUB,    O,  SUB,  SUB,    O,FMBlw,    O,    B, VPst, VBlw, VPre,VMAbv,VMBlw,VMPst,   IS, VAbv,\n+   MPst, MPre, MBlw, MBlw,    B, MBlw, MBlw, VPst,VMPst,VMPst,    B, MBlw, VPst, VPre, VAbv, VAbv,\n+  VMPst,VMPst,VMBlw,    B,VMPst, VBlw, VPst,  CGJ,  CGJ, VPst,VMAbv,VMAbv,FMAbv, FAbv,CMAbv,FMAbv,\n+  VMAbv,FMAbv, VAbv,   IS,FMAbv,    B,FMAbv,    B,  CGJ,   WJ,  CGJ,   GB,CMAbv,CMAbv,    B,   GB,\n+      B, VAbv,  SUB, FPst, FPst,VMBlw, FPst, FPst, FBlw,VMAbv,FMBlw, VAbv, VPre,    B, MPre, MBlw,\n+    SUB, FAbv, FAbv, MAbv,  SUB,   Sk, VPst, VAbv,VMAbv,VMAbv, FAbv,CMAbv, VPst,    H,    B,    O,\n+  SMAbv,SMBlw,SMAbv,SMAbv,SMAbv, VPst,   IS, VBlw, FAbv,VMPre,VMPre,FMAbv,CMBlw,VMBlw,VMBlw,VMAbv,\n+     CS,    O,FMAbv, ZWNJ,  CGJ,   WJ,   WJ,   WJ,    O,FMPst,    O,    O,    H, MPst, VPst,    H,\n+  VMAbv, VAbv,VMBlw,    B, VBlw, FPst, VPst, FAbv,VMPst,    B,CMAbv, VAbv, MBlw, MPst, MBlw,    H,\n+      O, VBlw, MPst, MPre, MAbv, MBlw,    O,    B, FAbv, FAbv, FPst, VBlw,    B,    B, VPre,    O,\n+  VMPst,   IS,    O,VMPst, VBlw, VPst,VMBlw,VMBlw,VMAbv,    O,   IS,VMBlw,    B,VMPst,VMAbv,VMPst,\n+     CS,   CS,    B,    N,    N,    O,   HN, VPre, VBlw, VAbv,   IS,CMAbv,    O, VPst,    B,    R,\n+      R,CMBlw, VAbv, VPre,VMAbv,VMAbv,    H, VAbv,CMBlw,FMAbv,    B,   CS,   CS,    H,CMBlw,VMPst,\n+      H,VMPst, VAbv,VMAbv, VPst,   IS,    R, MPst,    R, MPst,CMBlw,    B,FMBlw, VBlw,VMAbv,    R,\n+   MBlw, MBlw,   GB, FBlw, FBlw,CMAbv,   IS, VBlw,   IS,   GB, VAbv,    R,VMPst,    H,    H,    B,\n+      H,    B,VMBlw,    O, VBlw,\n+};\n+static const uint16_t\n+hb_use_u16[784] =\n+{\n+    0,  0,  1,  2,  0,  0,  0,  0,  0,  0,  3,  4,  0,  5,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  0,\n+    0,  0,  0,  0,  7,  0,  0,  0,  0,  0,  0,  0,  8,  9, 10, 11,\n+    0,  0,  0,  0,  9, 12,  0,  0, 13,  9,  9, 14, 15, 16, 17, 18,\n+   19, 20, 21, 22, 23, 24, 17, 25, 26, 20, 21, 27, 28, 29, 30, 31,\n+   32, 33, 21, 34, 35,  0, 17, 36, 37, 20, 21, 38, 23, 39, 17, 40,\n+   41, 42, 43, 44, 45, 46, 30,  0, 47, 48, 21, 49, 50, 51, 17,  0,\n+   52, 48, 21, 53, 50, 54, 17, 55, 56, 48,  9, 57, 58, 59, 17,  0,\n+   60, 61,  9, 62, 63, 64, 30, 65, 66, 67,  9, 68, 69,  9, 70, 71,\n+   72, 73, 74, 75, 76,  0,  0,  0,  9,  9, 77, 78, 79, 80, 81, 82,\n+   83, 84,  0,  0,  0,  0,  0,  0,  9, 85,  9, 86,  9, 87, 88, 89,\n+    9,  9,  9, 90, 91, 92,  2,  0, 93,  0,  9,  9,  9,  9,  9, 94,\n+   95,  9, 96,  0,  0,  0,  0,  0, 97, 98, 99,100, 30,  9,101,102,\n+    9,  9,103,  9,104,105,  0,  0,  9,106,  9,  9,  9,107,108,109,\n+    2,  2,  0,  0,  0,  0,  0,  0,110,  9,  9,111,112,  2,113,114,\n+  115,  9,116,  9,  9,  9,117,118,  9,  9,119,120,121,  0,  0,  0,\n+    0,  0,  0,  0,  0,122,123,124,  0,  0,  0,  0,  0,  0,  0,125,\n+  126,127,128,  0,  0,  0,129,130,131,  0,  0,  0,  0,  0,  0,132,\n+    0,  0,  0,  0,133,  0,  0,  0,  0,  0,  0,  9,  9,  9,134,135,\n+  136,  9,137,  0,  9,  9,  9,138,139,  9,  9,140,141,  2,142,143,\n+    9,  9,144,  9,145,146,  0,  0,147,  9,  9,148,149,  2,150, 98,\n+    9,  9,151,152,153,  2,  9,154,  9,  9,  9,155,156,  0,157,158,\n+    0,  0,  0,  0,  9,  9,159,  2,160,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,161,  0,  0,  0,  0,  0,  0,  0,162,\n+    0,  0,  0,  0,  0,  0,  0,163,163,164, 33,165,  0,  0,  0,  0,\n+  166,167,  9,168, 94,  0,  0,  0,  0,  0,  0,  0, 69,  9,169,  0,\n+    9,170,171,  0,  0,  0,  0,  0,  9,  9,172,  2,  0,  0,  0,  0,\n+    9,  9,173,170,  0,  0,  0,  0,  0,  0,  0,  9,174,175,  0,  9,\n+  176,  0,  0,177,178,  0,  0,  0,179,  9,  9,180,181,182,183,184,\n+  185,  9,  9,186,187,  0,  0,  0,188,  9,189,190,191,  9,  9,192,\n+  185,  9,  9,193,194,105,195,102,  9, 33,196,197,198,  0,  0,  0,\n+  199,200, 94,  9,  9,201,202,  2,203, 20, 21,204,205,206,207,208,\n+    9,  9,  9,209,210,211,212,  0,195,  9,  9,213,214,  2,  0,  0,\n+    9,  9,215,216,217,218,  0,  0,  9,  9,  9,219,220,  2,  0,  0,\n+    9,  9,221,222,  2,  0,  0,  0,  9,223,224,103,225,  0,  0,  0,\n+    9,  9,226,227,  0,  0,  0,  0,228,229,  9,230,231,  2,  0,  0,\n+    0,  0,232,  9,  9,233,234,  0,235,  9,  9,236,237,238,  9,  9,\n+  239,240,  0,  0,  0,  0,  0,  0, 21,  9,215,241,  7,  9, 70, 18,\n+    9,242, 73,243,  0,  0,  0,  0,244,  9,  9,245,246,  2,247,  9,\n+  248,249,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  9,250,\n+  251, 48,  9,252,253,  2,  0,  0,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,254,255,256,  0,  0,  0,  0,  0,  0,  2,  0,  0,  0,\n+    9,  9,  9,257,  0,  0,  0,  0,  9,  9,  9,  9,258,259,260,260,\n+  261,262,  0,  0,  0,  0,263,  0,  9,  9,  9,  9,  9,264,  0,  0,\n+    9,  9,  9,  9,  9,  9,105, 70, 94,265,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,266,  9,  9, 70,267,268,  0,  0,  0,\n+    0,  9,269,  0,  9,  9,270,  2,  0,  0,  0,  0,  0,  9,271,  2,\n+    9,  9,  9,  9,272,  2,  0,  0,129,129,129,129,129,129,129,129,\n+  160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,129,\n+};\n+\n+static inline unsigned\n+hb_use_b4 (const uint8_t* a, unsigned i)\n+{\n+  return (a[i>>1]>>((i&1u)<<2))&15u;\n+}\n+static inline uint_fast8_t\n+hb_use_get_category (unsigned u)\n+{\n+  return u<921600u?hb_use_u8[2777+(((hb_use_u8[593+(((hb_use_u16[((hb_use_u8[113+(((hb_use_b4(hb_use_u8,u>>1>>3>>3>>5))<<5)+((u>>1>>3>>3)&31u))])<<3)+((u>>1>>3)&7u)])<<3)+((u>>1)&7u))])<<1)+((u)&1u))]:O;\n+}\n@@ -1512,3 +363,0 @@\n-    case 0xE0u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0xE0000u, 0xE0FFFu)) return use_table[u - 0xE0000u + use_offset_0xe0000u];\n-      break;\n@@ -1516,3 +364,1 @@\n-    case 0xE1u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0xE0000u, 0xE0FFFu)) return use_table[u - 0xE0000u + use_offset_0xe0000u];\n-      break;\n+#else\n@@ -1520,6 +366,255 @@\n-    default:\n-      break;\n-  }\n-  if (_hb_glyph_info_get_general_category (&info) == HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED)\n-    return WJ;\n-  return O;\n+static const uint8_t\n+hb_use_u8[3413] =\n+{\n+     16,   50,   51,   51,   51,   52,   51,   83,  118,  131,   51,   57,   58,  179,  195,   61,\n+     51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,\n+     51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,\n+     51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,\n+     51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,\n+     51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,\n+     51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,   51,\n+     14,    0,    1,    1,    2,    1,    1,    3,    4,    5,    6,    7,    8,    9,   10,    1,\n+     11,   12,    1,    1,    1,    1,    1,    1,   13,   14,   15,   16,   17,   18,   19,    1,\n+      1,   20,    1,    1,    1,    1,   21,    1,    1,    1,    1,    1,    1,    1,   22,    1,\n+      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+      1,    1,    1,    1,    1,    1,    1,    1,    1,   23,   24,   25,   26,    1,    1,    1,\n+      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,   27,\n+     28,    1,    1,    1,    1,    1,   29,    1,    1,    1,    1,   30,   31,    1,   32,   33,\n+     34,   35,   36,   37,   38,   39,   40,   41,   42,   43,   44,   45,    1,   46,   47,   48,\n+     49,   50,   50,   50,   50,   51,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,   52,   53,    1,    1,    1,\n+     54,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,   50,   55,    1,    1,\n+      1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,   56,    1,    1,\n+      1,    1,   57,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n+      1,    1,   58,   59,    1,   60,    1,    1,    1,    1,   61,    1,    1,    1,    1,    1,\n+      1,   62,   63,   62,   62,   62,   62,   62,   62,   62,   62,   62,   62,   62,   62,   62,\n+     62,    0,    1,    0,    0,    0,    2,    3,    0,    0,    0,    0,    0,    0,    0,    0,\n+      0,    0,    0,    4,    0,    0,    0,    0,    0,    0,    0,    5,    0,    0,    0,    0,\n+      0,    0,    0,    0,    0,    0,    0,    6,    7,    0,    0,    8,    0,    0,    0,    0,\n+      0,    9,   10,   11,   12,   13,   14,   15,   16,   17,   18,   19,   20,   21,   22,   23,\n+     24,   25,   26,   27,   28,   29,   30,   31,   32,   33,   34,   35,   36,   37,   38,   39,\n+     40,   41,   42,   43,   36,   44,   45,   46,   47,   48,   49,   50,   51,   52,   53,   54,\n+      0,   55,   56,   57,   58,   59,    0,    0,    0,   60,   61,   62,   63,   55,   64,   65,\n+     66,   67,   55,   55,   68,   69,   70,    0,    0,   71,   72,   73,   74,   55,   75,   76,\n+      0,   77,   55,   78,   79,   80,    0,    0,    0,   81,   82,   83,   84,   85,   86,   55,\n+     87,   55,   88,   89,    0,    0,    0,   90,   91,    0,    0,    0,    0,    0,    0,    0,\n+     92,   93,   94,    0,   95,   96,    0,    0,   97,    0,    0,    0,    0,    0,    0,   98,\n+      0,    0,   99,   55,  100,    0,    0,    0,    0,  101,  102,   55,  103,  104,  105,  106,\n+    107,   55,  108,  109,    0,  110,  111,  112,  113,   55,  114,  115,  116,   55,  117,  118,\n+    119,    0,    0,    0,    0,    0,    0,   55,  120,  121,    0,    0,    0,    0,    0,    0,\n+    122,    0,    0,    0,    0,    0,    0,    0,  123,    0,    0,    0,  124,  125,  126,    0,\n+      0,  127,  128,  129,    0,    0,    0,   50,  130,    0,    0,    0,    0,  131,  132,    0,\n+      0,   55,  133,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   55,  134,    0,\n+      0,    0,   99,  135,   99,  136,  137,  138,    0,  139,  140,  141,  142,  143,  144,  145,\n+      0,  146,  147,  148,  149,  143,  150,  151,  152,  153,  154,  155,    0,  156,  157,  158,\n+    159,  160,  161,  162,  163,    0,    0,    0,    0,   55,  164,  165,  166,  167,  168,  169,\n+      0,    0,    0,    0,    0,   55,  170,  171,    0,   55,  172,  173,    0,   55,  174,   66,\n+      0,  175,  176,  177,    0,    0,    0,    0,    0,   55,  178,    0,    0,    0,    0,    0,\n+      0,  179,  180,  181,    0,    0,  182,  183,  184,  185,  186,  187,   55,  188,    0,    0,\n+      0,  189,  190,  191,  192,  193,  194,    0,    0,  195,  196,  197,  198,  199,   66,    0,\n+      0,    0,    0,    0,    0,    0,    0,    0,  200,  201,  202,  203,    0,    0,    0,    0,\n+      0,   55,   55,   55,   55,   55,   55,   55,   55,   55,  204,  205,    0,    0,    0,    0,\n+      0,    0,    0,    0,    0,    0,    0,   66,    0,   55,  206,    0,    0,    0,    0,    0,\n+      0,   55,   55,  207,  208,  209,    0,    0,  210,   55,   55,   55,   55,   55,   55,  211,\n+      0,   55,   55,   55,  212,  213,    0,    0,    0,    0,    0,    0,  214,    0,    0,    0,\n+      0,   55,  215,  216,    0,    0,    0,    0,    0,    0,    0,    0,    0,   99,  217,   55,\n+    218,    0,    0,    0,    0,    0,    0,   99,  219,   55,   55,  220,    0,    0,    0,    0,\n+      0,  221,  221,  221,  221,  221,  221,  221,  221,  222,  222,  222,  222,  222,  222,  222,\n+    223,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,\n+      0,    2,    2,    2,    2,    2,    0,    0,    0,    3,    0,    0,    0,    0,    0,    4,\n+      0,    0,    5,    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,    0,    0,    0,\n+      0,    0,    0,    0,    0,    0,    0,    0,    6,    7,    0,    0,    0,    0,    0,    0,\n+      0,    0,    0,    0,    0,    0,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    8,    9,    9,    9,    9,    0,    0,    0,    7,   10,\n+      0,    2,    2,    2,    2,   11,   12,    0,    0,    9,   13,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,   14,   15,   16,   17,   18,   19,   20,   14,   21,   22,\n+     23,   10,   24,   25,   18,    2,    2,    2,    2,    2,   18,    0,    2,    2,    2,    2,\n+      2,    0,    2,    2,    2,    2,    2,    2,    2,   26,   27,   28,    2,    2,    2,    7,\n+     28,    7,   28,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    7,    2,    2,\n+      2,    7,    7,    0,    2,    2,    0,   15,   16,   17,   18,   29,   30,   31,   30,   32,\n+      0,    0,    0,    0,   33,    0,    0,    2,   28,    2,    0,    0,    0,    0,    0,    7,\n+     34,   10,   13,   28,    2,    2,    7,    0,   28,    7,    2,   28,    7,    2,    0,   35,\n+     16,   17,   29,    0,   25,   36,   25,   37,    0,   38,    0,    0,    0,   28,    2,    7,\n+      7,    0,    0,    0,    2,    2,    2,    2,    2,   39,   40,   41,    0,    0,    0,    0,\n+      0,   10,   13,   28,    2,    2,    2,    2,   28,    2,   28,    2,    2,    2,    2,    2,\n+      2,    7,    2,   28,    2,    2,    0,   15,   16,   17,   18,   19,   25,   20,   33,   22,\n+      0,    0,    0,    0,    0,   28,   39,   39,   42,   10,   27,   28,    2,    2,    2,    7,\n+     28,    7,    2,   28,    2,    2,    0,   15,   43,    0,    0,   25,   20,    0,    0,    2,\n+     28,   28,    0,    0,    0,    0,    0,    0,    0,    0,   44,   28,    2,    2,    7,    0,\n+      2,    7,    2,    2,    0,   28,    7,    7,    2,    0,   28,    7,    0,    2,    7,    0,\n+      2,    2,    2,    2,    2,    2,    0,    0,   21,   14,   45,    0,   46,   31,   46,   32,\n+      0,    0,    0,    0,   33,    0,    0,    0,    0,   13,   27,   47,    2,    2,    2,    7,\n+      2,    7,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,    0,   15,\n+     20,   14,   21,   45,   20,   36,   20,   37,    0,    0,    0,   25,   29,    2,    7,    0,\n+      0,    8,   27,   28,    2,    2,    2,    7,    2,    2,    2,   28,    2,    2,    0,   15,\n+     43,    0,    0,   33,   45,    0,    0,    0,    7,   48,   49,    0,    0,    0,    0,    0,\n+      0,    9,   27,    2,    2,    2,    2,    7,    2,    2,    2,    2,    2,    2,   50,   51,\n+     21,   21,   17,   29,   46,   31,   46,   32,   52,    0,    0,    0,   33,    0,    0,    0,\n+     28,   10,   27,   28,    2,    2,    2,    2,    2,    2,    2,    2,    7,    0,    2,    2,\n+      2,    2,   28,    2,    2,    2,    2,   28,    0,    2,    2,    2,    7,    0,   53,    0,\n+     33,   21,   20,   29,   29,   16,   46,   46,   23,    0,   21,    0,    0,    0,    0,    0,\n+      0,    2,    0,    2,    7,    0,    0,    0,    0,    0,    0,    0,    0,   18,    0,    0,\n+      0,    2,    2,   54,   54,   55,    0,    0,   16,    2,    2,    2,    2,   28,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,    7,    0,   56,   19,   57,   20,   20,   18,   18,\n+     44,   19,    9,   29,    9,    2,    2,   58,   59,   59,   59,   59,   59,   60,   59,   59,\n+     59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   61,\n+      0,    0,    0,    0,   62,    0,    0,    0,    0,    2,    2,    2,    2,    2,   63,   43,\n+     57,   64,   20,   20,   65,   66,   67,   68,   69,    2,    2,    2,    2,    2,    1,    0,\n+      3,    2,    2,    2,   21,   18,    2,    2,   70,   69,   71,   72,   63,   71,   27,   27,\n+      2,   50,   20,   51,    2,    2,    2,    2,    2,    2,   73,   74,   75,   27,   27,   76,\n+     77,    2,    2,    2,    2,    2,   27,   43,    0,    2,   57,   78,    0,    0,    0,    0,\n+     28,    2,   57,   45,    0,    0,    0,    0,    0,    2,   57,    0,    0,    0,    0,    0,\n+      0,    2,    2,    2,    2,    2,    2,    7,    2,    7,   57,    0,    0,    0,    0,    0,\n+      0,    2,    2,   79,   43,   20,   57,   18,   46,   46,   46,   46,   13,   80,   81,   82,\n+     83,   84,   85,    0,    0,    0,    0,   86,    0,    7,    0,    0,   28,    0,   87,   79,\n+     88,    2,    2,    2,    2,    7,    0,    0,    0,   40,   40,   89,   90,    2,    2,    2,\n+      2,    2,    2,    2,    2,   11,    7,    0,    0,   91,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,    2,    7,   20,   78,   43,   20,   92,   59,    0,\n+      0,   93,   94,   93,   93,   95,   96,    0,    0,    2,    2,    2,    2,    2,    2,    2,\n+      0,    2,    2,    7,    0,    0,    0,    0,    0,    2,    2,    2,    2,    2,    2,    0,\n+      0,    2,    2,    2,    2,   27,    0,    0,    0,    2,    2,    2,    2,    2,    7,    0,\n+      0,    2,    2,    2,   50,   97,   43,    0,    0,    2,    2,   98,   99,  100,  101,   59,\n+     61,  102,   14,   43,   20,   57,   19,   78,   46,   46,   74,    9,    9,    9,  103,   44,\n+     38,    9,  104,   72,    2,    2,    2,    2,    2,    2,    2,  105,   20,   18,   18,   20,\n+     46,   46,   20,  106,    2,    2,    2,    7,    0,    0,    0,    0,    0,    0,  107,  108,\n+    109,  109,  109,    0,    0,    0,    0,    0,    0,  104,   72,    2,    2,    2,    2,    2,\n+      2,   58,   59,   57,   23,   20,  110,   59,    2,    2,    2,    2,  105,   20,   21,   43,\n+     43,  100,   12,    0,    0,    0,    0,    0,    0,    2,    2,   59,   16,   46,   21,  111,\n+    100,  100,  100,  112,  113,    0,    0,    0,    0,    2,    2,    2,    2,    2,    0,   28,\n+      2,    9,   44,  114,  114,  114,    9,  114,  114,   13,  114,  114,  114,   24,    0,   38,\n+      0,    0,    0,  115,   49,    9,    3,    0,    0,    0,    0,    0,    0,    0,  116,    0,\n+      0,    0,    0,    0,    0,    0,    4,  117,  118,   40,   40,    3,    0,    0,    0,    0,\n+      0,    0,    0,    0,    0,    0,  118,  118,  119,  118,  118,  118,  118,  118,  118,  118,\n+    118,    0,    0,  120,    0,    0,    0,    0,    0,    0,    5,  120,    0,    0,    0,    0,\n+      0,   44,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    7,\n+      0,    2,    2,    2,    2,    0,    0,    0,   28,    0,    0,    0,    0,    0,    0,    0,\n+    121,    2,   51,    2,  106,    2,    8,    2,    2,    2,   63,   17,   14,    0,    0,   29,\n+      0,    2,    2,    0,    0,    0,    0,    0,    0,   27,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,  122,   21,   21,   21,   21,   21,   21,   21,  123,    0,    0,    0,    0,\n+      0,    9,    9,    9,    9,    9,    9,    9,    9,    9,    2,    0,    0,    0,    0,    0,\n+     50,    2,    2,    2,   20,   20,  124,  114,    0,    2,    2,    2,  125,   18,   57,   18,\n+    111,  100,  126,    0,    0,    0,    0,    0,    0,    9,  127,    2,    2,    2,    2,    2,\n+      2,    2,  128,   21,   20,   18,   46,  129,  130,  131,    0,    0,    0,    0,    0,    0,\n+      0,    2,    2,   50,   28,    2,    2,    2,    2,    2,    2,    2,    2,    8,   20,   57,\n+     97,   74,  132,  133,  134,    0,    0,    0,    0,    2,  135,    2,    2,    2,    2,  136,\n+      0,   28,    2,   40,    3,    0,   77,   13,    2,   51,   20,  137,   50,   51,    2,    2,\n+    103,    8,    7,    0,    0,    0,    0,    0,    0,    2,    2,    2,    2,    2,  138,   19,\n+     23,    0,    0,  139,  140,    0,    0,    0,    0,    2,   63,   43,   21,   78,   45,  141,\n+      0,   79,   79,   79,   79,   79,   79,   79,   79,    0,    0,    0,    0,    0,    0,    0,\n+      4,  118,  118,  118,  118,  119,    0,    0,    0,    2,    2,    2,    2,    2,    7,    2,\n+      2,    2,    7,    2,   28,    2,    2,    2,    2,    2,   28,    2,    2,    2,   28,    7,\n+      0,  125,   18,   25,   29,    0,    0,  142,  143,    2,    2,   28,    2,   28,    2,    2,\n+      2,    2,    2,    2,    0,   12,   35,    0,  144,    2,    2,   11,   35,    0,   28,    2,\n+      2,    2,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   28,    2,    2,\n+      7,    2,    2,    9,   39,    0,    0,    0,    0,    2,    2,    2,    2,    2,   25,   36,\n+      0,    2,    2,    2,  114,  114,  114,  114,  114,  145,    2,    7,    0,    0,    0,    0,\n+      0,    2,   12,   12,    0,    0,    0,    0,    0,    7,    2,    2,    7,    2,    2,    2,\n+      2,   28,    2,    7,    0,   28,    2,    0,    0,  146,  147,  148,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,   20,   20,   18,   18,   18,   20,   20,  131,    0,    0,    0,\n+      0,    0,  149,  149,  149,  149,  149,  149,  149,  149,  149,  149,    2,    2,    2,    2,\n+      2,   51,   50,   51,    0,    0,    0,    0,  150,    9,   72,    2,    2,    2,    2,    2,\n+      2,   16,   17,   19,   14,   22,   35,    0,    0,    0,   29,    0,    0,    0,    0,    0,\n+      0,    9,   47,    2,    2,    2,    2,    2,    2,    2,    2,    2,  125,   18,   20,  151,\n+     20,   19,  152,  153,    2,    2,    2,    2,    2,    0,    0,   63,  154,    0,    0,    0,\n+      0,    2,   11,    0,    0,    0,    0,    0,    0,    2,   63,   23,   18,   18,   18,   20,\n+     20,  106,  155,    0,    0,   54,  156,   29,  157,   28,    2,    2,    2,    2,    2,    2,\n+      2,    2,    2,    2,    2,    2,    2,   21,   17,   20,   20,  158,   42,    0,    0,    0,\n+     47,  125,    0,    0,    0,    0,    0,    0,    0,    2,    2,    2,    7,    7,    2,    2,\n+     28,    2,    2,    2,    2,    2,    2,    2,   28,    2,    2,    2,    2,    2,    2,    2,\n+      8,   16,   17,   19,   20,  159,   29,    0,    0,    9,    9,   28,    2,    2,    2,    7,\n+     28,    7,    2,   28,    2,    2,   56,   15,   21,   14,   21,   45,   30,   31,   30,   32,\n+      0,    0,    0,    0,   33,    0,    0,    0,    2,    2,   21,    0,    9,    9,    9,   44,\n+      0,    9,    9,   44,    0,    0,    0,    0,    0,    2,    2,   63,   23,   18,   18,   18,\n+     20,   21,  123,   13,   15,    0,    0,    0,    0,    2,    2,    2,    2,    2,    0,    0,\n+    160,  161,    0,    0,    0,    0,    0,    0,    0,   16,   17,   18,   18,   64,   97,   23,\n+    157,    9,  162,    7,    0,    0,    0,    0,    0,    2,    2,    2,    2,    2,    2,    2,\n+     63,   23,   18,   18,    0,   46,   46,    9,  163,   35,    0,    0,    0,    0,    0,    0,\n+      0,    0,    0,    0,    0,    2,    2,   18,    0,   21,   17,   18,   18,   19,   14,   80,\n+    163,   36,    0,    0,    0,    0,    0,    0,    0,    2,    2,    2,    2,    2,    8,  164,\n+     23,   18,   20,   20,  162,    7,    0,    0,    0,    2,    2,    2,    2,    2,    7,   41,\n+    133,   21,   20,   18,   74,   19,   20,    0,    0,    2,    2,    2,    7,    0,    0,    0,\n+      0,    2,    2,    2,    2,    2,    2,   16,   17,   18,   19,   20,  103,  163,   35,    0,\n+      0,    2,    2,    2,    7,   28,    0,    2,    2,    2,    2,   28,    7,    2,    2,    2,\n+      2,   21,   21,   16,   30,   31,   10,  165,  166,  167,  168,    0,    0,    0,    0,    0,\n+      0,    2,    2,    2,    2,    0,    2,    2,    2,   63,   23,   18,   18,    0,   20,   21,\n+     27,  106,    0,   31,    0,    0,    0,    0,    0,   50,   18,   20,   20,   20,  137,    2,\n+      2,    2,  169,  170,    9,   13,  171,   70,  172,    0,    0,    1,  144,    0,    0,    0,\n+      0,   50,   18,   20,   14,   17,   18,    2,    2,    2,    2,  155,  155,  155,  173,  173,\n+    173,  173,  173,  173,   13,  174,    0,   28,    0,   20,   18,   18,   29,   20,   20,    9,\n+    163,    0,   59,   59,   59,   59,   59,   59,   59,   64,   19,   80,   44,    0,    0,    0,\n+      0,    2,    2,    2,    7,    2,   28,    2,    2,   50,   20,   20,   29,    0,   36,   20,\n+     25,    9,  156,  175,  171,    0,    0,    0,    0,    2,    2,    2,   28,    7,    2,    2,\n+      2,    2,    2,    2,    2,    2,   21,   21,   45,   20,   33,   80,   66,    0,    0,    0,\n+      0,    2,  176,   64,   45,    0,    0,    0,    0,    9,  177,    2,    2,    2,    2,    2,\n+      2,    2,    2,   21,   20,   18,   29,    0,   46,   14,  140,    0,    0,    0,    0,    0,\n+      0,  178,  178,  178,  106,  179,  178,    0,    0,  145,    2,    2,  180,  114,  114,  114,\n+    114,  114,  114,  114,    0,    0,    0,    0,    0,    9,    9,    9,   44,    0,    0,    0,\n+      0,    2,    2,    2,    2,    2,    7,    0,   56,  181,   18,   18,   18,   18,   18,   18,\n+     18,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,   18,    0,    0,    0,\n+     38,  114,   24,    0,    0,    0,    0,    0,    0,    0,    0,    7,    0,    0,    0,    0,\n+      0,    2,    2,    2,    0,    0,    0,    0,    0,    2,    2,    2,    2,    2,    0,   56,\n+     35,    0,    4,  118,  118,  118,  119,    0,    0,    9,    9,    9,   47,    2,    2,    2,\n+      0,    2,    2,    2,    2,    2,    0,    0,    2,    2,    2,    2,    2,    2,    2,    2,\n+     44,    2,    2,    2,    2,    2,    2,    9,    9,    2,    2,    2,    2,    2,    2,   20,\n+     20,    2,    2,   42,   42,   42,   90,    0,    0,    O,    O,    O,   GB,    B,    B,   GB,\n+      O,    O,   WJ,FMPst,FMPst,    O,  CGJ,    B,    O,    B,VMAbv,VMAbv,VMAbv,    O,VMAbv,    B,\n+  CMBlw,CMBlw,CMBlw,VMAbv,VMPst, VAbv, VPst,CMBlw,    B, VPst, VPre, VPst, VBlw, VBlw, VBlw, VBlw,\n+   VAbv, VAbv, VAbv, VPst, VPst, VPst,    H, VPre, VPst,VMBlw,    O,    O, VAbv,   GB,VMAbv,VMPst,\n+  VMPst,    O,    B, VBlw,    O,    O, VPre, VPre,    O, VPre,    H,    O, VPst,FMAbv,    O,CMBlw,\n+      O, VAbv,    O, VAbv,    H,    O,VMBlw,VMAbv,CMAbv,   GB,   GB,    O, MBlw,CMAbv,CMAbv, VPst,\n+   VAbv,VMAbv,    O, VPst,    O, VPre, VPre,VMAbv,    B,    O,   CS,   CS,VMPst,    B, VAbv, VAbv,\n+      B,    R,    O,  HVM,    O,    O,FMBlw,    O,CMAbv,    O,CMBlw, VAbv, VBlw,    B,  SUB,  SUB,\n+    SUB,    O,  SUB,  SUB,    O,FMBlw,    O,    B, VPst, VBlw, VPre,VMAbv,VMBlw,VMPst,   IS, VAbv,\n+   MPst, MPre, MBlw, MBlw,    B, MBlw, MBlw, VPst,VMPst,VMPst,    B, MBlw, VPst, VPre, VAbv, VAbv,\n+  VMPst,VMPst,VMBlw,    B,VMPst, VBlw, VPst,  CGJ,  CGJ, VPst,VMAbv,VMAbv,FMAbv, FAbv,CMAbv,FMAbv,\n+  VMAbv,FMAbv, VAbv,   IS,FMAbv,    B,FMAbv,    B,  CGJ,   WJ,  CGJ,   GB,CMAbv,CMAbv,    B,   GB,\n+      B, VAbv,  SUB, FPst, FPst,VMBlw, FPst, FPst, FBlw,VMAbv,FMBlw, VAbv, VPre,    B, MPre, MBlw,\n+    SUB, FAbv, FAbv, MAbv,  SUB,   Sk, VPst, VAbv,VMAbv,VMAbv, FAbv,CMAbv, VPst,    H,    B,    O,\n+  SMAbv,SMBlw,SMAbv,SMAbv,SMAbv, VPst,   IS, VBlw, FAbv,VMPre,VMPre,FMAbv,CMBlw,VMBlw,VMBlw,VMAbv,\n+     CS,    O,FMAbv, ZWNJ,  CGJ,   WJ,   WJ,   WJ,    O,FMPst,    O,    O,    H, MPst, VPst,    H,\n+  VMAbv, VAbv,VMBlw,    B, VBlw, FPst, VPst, FAbv,VMPst,    B,CMAbv, VAbv, MBlw, MPst, MBlw,    H,\n+      O, VBlw, MPst, MPre, MAbv, MBlw,    O,    B, FAbv, FAbv, FPst, VBlw,    B,    B, VPre,    O,\n+  VMPst,   IS,    O,VMPst, VBlw, VPst,VMBlw,VMBlw,VMAbv,    O,   IS,VMBlw,    B,VMPst,VMAbv,VMPst,\n+     CS,   CS,    B,    N,    N,    O,   HN, VPre, VBlw, VAbv,   IS,CMAbv,    O, VPst,    B,    R,\n+      R,CMBlw, VAbv, VPre,VMAbv,VMAbv,    H, VAbv,CMBlw,FMAbv,    B,   CS,   CS,    H,CMBlw,VMPst,\n+      H,VMPst, VAbv,VMAbv, VPst,   IS,    R, MPst,    R, MPst,CMBlw,    B,FMBlw, VBlw,VMAbv,    R,\n+   MBlw, MBlw,   GB, FBlw, FBlw,CMAbv,   IS, VBlw,   IS,   GB, VAbv,    R,VMPst,    H,    H,    B,\n+      H,    B,VMBlw,    O, VBlw,\n+};\n+static const uint16_t\n+hb_use_u16[448] =\n+{\n+    0,  0,  1,  2,  3,  4,  0,  5,  6,  0,  7,  0,  8,  9, 10, 11,\n+    9, 12, 13,  9,  9, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n+   17, 25, 26, 20, 21, 27, 28, 29, 30, 31, 32, 33, 21, 34, 35,  0,\n+   17, 36, 37, 20, 21, 38, 23, 39, 17, 40, 41, 42, 43, 44, 45, 46,\n+   30,  0, 47, 48, 21, 49, 50, 51, 17,  0, 52, 48, 21, 53, 50, 54,\n+   17, 55, 56, 48,  9, 57, 58, 59, 60, 61,  9, 62, 63, 64, 30, 65,\n+   66, 67,  9, 68, 69,  9, 70, 71, 72, 73, 74, 75, 76,  0,  9,  9,\n+   77, 78, 79, 80, 81, 82, 83, 84,  9, 85,  9, 86,  9, 87, 88, 89,\n+    9, 90, 91, 92,  2,  0, 93,  0,  9, 94, 95,  9, 96,  0, 97, 98,\n+   99,100, 30,  9,101,102,103,  9,104,105,  9,106,  9,107,108,109,\n+    2,  2,110,  9,  9,111,112,  2,113,114,115,  9,116,  9,117,118,\n+  119,120,121,  0,  0,122,123,124,  0,125,126,127,128,  0,129,130,\n+  131,  0,  0,132,133,  0,  0,  9,134,135,136,  9,137,  0,  9,138,\n+  139,  9,  9,140,141,  2,142,143,144,  9,145,146,147,  9,  9,148,\n+  149,  2,150, 98,151,152,153,  2,  9,154,  9,155,156,  0,157,158,\n+  159,  2,160,  0,  0,161,  0,162,  0,163,163,164, 33,165,166,167,\n+    9,168, 94,  0,169,  0,  9,170,171,  0,172,  2,173,170,174,175,\n+  176,  0,  0,177,178,  0,179,  9,  9,180,181,182,183,184,185,  9,\n+    9,186,187,  0,188,  9,189,190,191,  9,  9,192,  9,193,194,105,\n+  195,102,  9, 33,196,197,198,  0,199,200, 94,  9,  9,201,202,  2,\n+  203, 20, 21,204,205,206,207,208,  9,209,210,211,212,  0,195,  9,\n+    9,213,214,  2,215,216,217,218,  9,219,220,  2,221,222,  9,223,\n+  224,103,225,  0,226,227,228,229,  9,230,231,  2,232,  9,  9,233,\n+  234,  0,235,  9,  9,236,237,238,239,240, 21,  9,215,241,  7,  9,\n+   70, 18,  9,242, 73,243,244,  9,  9,245,246,  2,247,  9,248,249,\n+    9,250,251, 48,  9,252,253,  2,  9,254,255,256,  9,257,258,259,\n+  260,260,261,262,263,  0,  9,264,105, 70, 94,265,  0,266, 70,267,\n+  268,  0,269,  0,270,  2,271,  2,272,  2,129,129,160,160,160,129,\n+};\n+\n+static inline unsigned\n+hb_use_b4 (const uint8_t* a, unsigned i)\n+{\n+  return (a[i>>1]>>((i&1u)<<2))&15u;\n@@ -1527,0 +622,7 @@\n+static inline uint_fast8_t\n+hb_use_get_category (unsigned u)\n+{\n+  return u<921600u?hb_use_u8[3049+(((hb_use_u8[865+(((hb_use_u16[((hb_use_u8[353+(((hb_use_u8[113+(((hb_use_b4(hb_use_u8,u>>1>>3>>1>>3>>4))<<4)+((u>>1>>3>>1>>3)&15u))])<<3)+((u>>1>>3>>1)&7u))])<<1)+((u>>1>>3)&1u)])<<3)+((u>>1)&7u))])<<1)+((u)&1u))]:O;\n+}\n+\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-use-table.hh","additions":542,"deletions":1440,"binary":false,"changes":1982,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-static void\n+static bool\n@@ -96,1 +96,1 @@\n-static void\n+static bool\n@@ -100,1 +100,1 @@\n-static void\n+static bool\n@@ -104,1 +104,1 @@\n-static void\n+static bool\n@@ -209,1 +209,1 @@\n-    info[i].use_category() = hb_use_get_category (info[i]);\n+    info[i].use_category() = hb_use_get_category (info[i].codepoint);\n@@ -296,1 +296,1 @@\n-static void\n+static bool\n@@ -307,0 +307,1 @@\n+  return false;\n@@ -309,1 +310,1 @@\n-static void\n+static bool\n@@ -317,1 +318,1 @@\n-  if (!mask) return;\n+  if (!mask) return false;\n@@ -330,0 +331,1 @@\n+  return false;\n@@ -332,1 +334,1 @@\n-static void\n+static bool\n@@ -349,0 +351,1 @@\n+  return false;\n@@ -441,1 +444,1 @@\n-static void\n+static bool\n@@ -446,0 +449,1 @@\n+  bool ret = false;\n@@ -448,4 +452,5 @@\n-    hb_syllabic_insert_dotted_circles (font, buffer,\n-                                       use_broken_cluster,\n-                                       USE(B),\n-                                       USE(R));\n+    if (hb_syllabic_insert_dotted_circles (font, buffer,\n+                                           use_broken_cluster,\n+                                           USE(B),\n+                                           USE(R)))\n+      ret = true;\n@@ -460,0 +465,2 @@\n+\n+  return ret;\n@@ -493,1 +500,0 @@\n-  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n@@ -497,1 +503,0 @@\n-  HB_TAG_NONE, \/* gpos_tag *\/\n@@ -499,0 +504,2 @@\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-use.cc","additions":23,"deletions":16,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -13,2 +13,2 @@\n- * # Scripts-14.0.0.txt\n- * # Date: 2021-07-10, 00:35:31 GMT\n+ * # Scripts-15.0.0.txt\n+ * # Date: 2022-04-26, 23:15:02 GMT\n@@ -345,0 +345,34 @@\n+    case HB_SCRIPT_KHOJKI:\n+      for (buffer->idx = 0; buffer->idx + 1 < count && buffer->successful;)\n+      {\n+        bool matched = false;\n+        switch (buffer->cur ().codepoint)\n+        {\n+          case 0x11200u:\n+            switch (buffer->cur (1).codepoint)\n+            {\n+              case 0x1122Cu: case 0x11231u: case 0x11233u:\n+                matched = true;\n+                break;\n+            }\n+            break;\n+          case 0x11206u:\n+            matched = 0x1122Cu == buffer->cur (1).codepoint;\n+            break;\n+          case 0x1122Cu:\n+            switch (buffer->cur (1).codepoint)\n+            {\n+              case 0x11230u: case 0x11231u:\n+                matched = true;\n+                break;\n+            }\n+            break;\n+          case 0x11240u:\n+            matched = 0x1122Eu == buffer->cur (1).codepoint;\n+            break;\n+        }\n+        (void) buffer->next_glyph ();\n+        if (matched) _output_with_dotted_circle (buffer);\n+      }\n+      break;\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-vowel-constraints.cc","additions":36,"deletions":2,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -120,2 +120,0 @@\n-  hb_ot_shape_normalization_mode_t normalization_preference;\n-\n@@ -150,6 +148,0 @@\n-  \/* gpos_tag()\n-   * If not HB_TAG_NONE, then must match found GPOS script tag for\n-   * GPOS to be applied.  Otherwise, fallback positioning will be used.\n-   *\/\n-  hb_tag_t gpos_tag;\n-\n@@ -166,0 +158,8 @@\n+  \/* gpos_tag()\n+   * If not HB_TAG_NONE, then must match found GPOS script tag for\n+   * GPOS to be applied.  Otherwise, fallback positioning will be used.\n+   *\/\n+  hb_tag_t gpos_tag;\n+\n+  hb_ot_shape_normalization_mode_t normalization_preference;\n+\n@@ -265,0 +265,1 @@\n+#ifndef HB_NO_OT_SHAPER_MYANMAR_ZAWGYI\n@@ -270,0 +271,1 @@\n+#endif\n@@ -383,0 +385,4 @@\n+    \/* Unicode-15.0 additions *\/\n+    case HB_SCRIPT_KAWI:\n+    case HB_SCRIPT_NAG_MUNDARI:\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper.hh","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -60,0 +60,25 @@\n+struct StatAxisRecord\n+{\n+  int cmp (hb_tag_t key) const { return tag.cmp (key); }\n+\n+  hb_ot_name_id_t get_name_id () const { return nameID; }\n+\n+  hb_tag_t get_axis_tag () const { return tag; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  protected:\n+  Tag           tag;            \/* A tag identifying the axis of design variation. *\/\n+  NameID        nameID;         \/* The name ID for entries in the 'name' table that\n+                                 * provide a display string for this axis. *\/\n+  HBUINT16      ordering;       \/* A value that applications can use to determine\n+                                 * primary sorting of face names, or for ordering\n+                                 * of descriptors when composing family or face names. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n@@ -67,0 +92,31 @@\n+  hb_tag_t get_axis_tag (const hb_array_t<const StatAxisRecord> axis_records) const\n+  {\n+    unsigned axis_idx = get_axis_index ();\n+    return axis_records[axis_idx].get_axis_tag ();\n+  }\n+\n+  bool keep_axis_value (const hb_array_t<const StatAxisRecord> axis_records,\n+                        const hb_hashmap_t<hb_tag_t, float> *user_axes_location) const\n+  {\n+    hb_tag_t axis_tag = get_axis_tag (axis_records);\n+    float axis_value = get_value ();\n+\n+    if (!user_axes_location->has (axis_tag) ||\n+        fabsf(axis_value - user_axes_location->get (axis_tag)) < 0.001f)\n+      return true;\n+\n+    return false;\n+  }\n+\n+  bool subset (hb_subset_context_t *c,\n+               const hb_array_t<const StatAxisRecord> axis_records) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_hashmap_t<hb_tag_t, float>* user_axes_location = &c->plan->user_axes_location;\n+\n+    if (keep_axis_value (axis_records, user_axes_location))\n+      return_trace (c->serializer->embed (this));\n+\n+    return_trace (false);\n+  }\n+\n@@ -70,1 +126,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n@@ -83,1 +139,1 @@\n-  HBFixed       value;          \/* A numeric value for this attribute value. *\/\n+  F16DOT16      value;          \/* A numeric value for this attribute value. *\/\n@@ -95,0 +151,31 @@\n+  hb_tag_t get_axis_tag (const hb_array_t<const StatAxisRecord> axis_records) const\n+  {\n+    unsigned axis_idx = get_axis_index ();\n+    return axis_records[axis_idx].get_axis_tag ();\n+  }\n+\n+  bool keep_axis_value (const hb_array_t<const StatAxisRecord> axis_records,\n+                        const hb_hashmap_t<hb_tag_t, float> *user_axes_location) const\n+  {\n+    hb_tag_t axis_tag = get_axis_tag (axis_records);\n+    float axis_value = get_value ();\n+\n+    if (!user_axes_location->has (axis_tag) ||\n+        fabsf(axis_value - user_axes_location->get (axis_tag)) < 0.001f)\n+      return true;\n+\n+    return false;\n+  }\n+\n+  bool subset (hb_subset_context_t *c,\n+               const hb_array_t<const StatAxisRecord> axis_records) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_hashmap_t<hb_tag_t, float>* user_axes_location = &c->plan->user_axes_location;\n+\n+    if (keep_axis_value (axis_records, user_axes_location))\n+      return_trace (c->serializer->embed (this));\n+\n+    return_trace (false);\n+  }\n+\n@@ -98,1 +185,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n@@ -111,2 +198,2 @@\n-  HBFixed       nominalValue;   \/* A numeric value for this attribute value. *\/\n-  HBFixed       rangeMinValue;  \/* The minimum value for a range associated\n+  F16DOT16      nominalValue;   \/* A numeric value for this attribute value. *\/\n+  F16DOT16      rangeMinValue;  \/* The minimum value for a range associated\n@@ -114,1 +201,1 @@\n-  HBFixed       rangeMaxValue;  \/* The maximum value for a range associated\n+  F16DOT16      rangeMaxValue;  \/* The maximum value for a range associated\n@@ -127,0 +214,31 @@\n+  hb_tag_t get_axis_tag (const hb_array_t<const StatAxisRecord> axis_records) const\n+  {\n+    unsigned axis_idx = get_axis_index ();\n+    return axis_records[axis_idx].get_axis_tag ();\n+  }\n+\n+  bool keep_axis_value (const hb_array_t<const StatAxisRecord> axis_records,\n+                        const hb_hashmap_t<hb_tag_t, float> *user_axes_location) const\n+  {\n+    hb_tag_t axis_tag = get_axis_tag (axis_records);\n+    float axis_value = get_value ();\n+\n+    if (!user_axes_location->has (axis_tag) ||\n+        fabsf(axis_value - user_axes_location->get (axis_tag)) < 0.001f)\n+      return true;\n+\n+    return false;\n+  }\n+\n+  bool subset (hb_subset_context_t *c,\n+               const hb_array_t<const StatAxisRecord> axis_records) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_hashmap_t<hb_tag_t, float>* user_axes_location = &c->plan->user_axes_location;\n+\n+    if (keep_axis_value (axis_records, user_axes_location))\n+      return_trace (c->serializer->embed (this));\n+\n+    return_trace (false);\n+  }\n+\n@@ -130,1 +248,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n@@ -143,2 +261,2 @@\n-  HBFixed       value;          \/* A numeric value for this attribute value. *\/\n-  HBFixed       linkedValue;    \/* The numeric value for a style-linked mapping\n+  F16DOT16      value;          \/* A numeric value for this attribute value. *\/\n+  F16DOT16      linkedValue;    \/* The numeric value for a style-linked mapping\n@@ -158,1 +276,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (c->check_struct (this));\n@@ -165,1 +283,1 @@\n-  HBFixed       value;          \/* A numeric value for this attribute value. *\/\n+  F16DOT16      value;          \/* A numeric value for this attribute value. *\/\n@@ -175,0 +293,34 @@\n+  bool keep_axis_value (const hb_array_t<const StatAxisRecord> axis_records,\n+                        const hb_hashmap_t<hb_tag_t, float> *user_axes_location) const\n+  {\n+    hb_array_t<const AxisValueRecord> axis_value_records = axisValues.as_array (axisCount);\n+\n+    for (const auto& rec : axis_value_records)\n+    {\n+      unsigned axis_idx = rec.get_axis_index ();\n+      float axis_value = rec.get_value ();\n+      hb_tag_t axis_tag = axis_records[axis_idx].get_axis_tag ();\n+\n+      if (user_axes_location->has (axis_tag) &&\n+          fabsf(axis_value - user_axes_location->get (axis_tag)) > 0.001f)\n+        return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  bool subset (hb_subset_context_t *c,\n+               const hb_array_t<const StatAxisRecord> axis_records) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_hashmap_t<hb_tag_t, float> *user_axes_location = &c->plan->user_axes_location;\n+    if (!keep_axis_value (axis_records, user_axes_location))\n+      return_trace (false);\n+\n+    unsigned total_size = min_size + axisCount * AxisValueRecord::static_size;\n+    auto *out = c->serializer->allocate_size<AxisValueFormat4> (total_size);\n+    if (unlikely (!out)) return_trace (false);\n+    hb_memcpy (out, this, total_size);\n+    return_trace (true);\n+  }\n+\n@@ -180,1 +332,2 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (likely (c->check_struct (this) &&\n+                          axisValues.sanitize (c, axisCount)));\n@@ -237,0 +390,27 @@\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  {\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return c->no_dispatch_return_value ();\n+    TRACE_DISPATCH (this, u.format);\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n+    case 3: return_trace (c->dispatch (u.format3, std::forward<Ts> (ds)...));\n+    case 4: return_trace (c->dispatch (u.format4, std::forward<Ts> (ds)...));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  bool keep_axis_value (const hb_array_t<const StatAxisRecord> axis_records,\n+                        hb_hashmap_t<hb_tag_t, float> *user_axes_location) const\n+  {\n+    switch (u.format)\n+    {\n+    case 1: return u.format1.keep_axis_value (axis_records, user_axes_location);\n+    case 2: return u.format2.keep_axis_value (axis_records, user_axes_location);\n+    case 3: return u.format3.keep_axis_value (axis_records, user_axes_location);\n+    case 4: return u.format4.keep_axis_value (axis_records, user_axes_location);\n+    default:return false;\n+    }\n+  }\n+\n@@ -266,1 +446,1 @@\n-struct StatAxisRecord\n+struct AxisValueOffsetArray: UnsizedArrayOf<Offset16To<AxisValue>>\n@@ -268,1 +448,8 @@\n-  int cmp (hb_tag_t key) const { return tag.cmp (key); }\n+  bool subset (hb_subset_context_t *c,\n+               unsigned axisValueCount,\n+               unsigned& count,\n+               const hb_array_t<const StatAxisRecord> axis_records) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (this);\n+    if (unlikely (!out)) return_trace (false);\n@@ -270,1 +457,15 @@\n-  hb_ot_name_id_t get_name_id () const { return nameID; }\n+    auto axisValueOffsets = as_array (axisValueCount);\n+    count = 0;\n+    for (const auto& offset : axisValueOffsets)\n+    {\n+      if (!offset) continue;\n+      auto o_snap = c->serializer->snapshot ();\n+      auto *o = c->serializer->embed (offset);\n+      if (!o) return_trace (false);\n+      if (!o->serialize_subset (c, offset, this, axis_records))\n+      {\n+        c->serializer->revert (o_snap);\n+        continue;\n+      }\n+      count++;\n+    }\n@@ -272,4 +473,1 @@\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (count);\n@@ -277,10 +475,0 @@\n-\n-  protected:\n-  Tag           tag;            \/* A tag identifying the axis of design variation. *\/\n-  NameID        nameID;         \/* The name ID for entries in the 'name' table that\n-                                 * provide a display string for this axis. *\/\n-  HBUINT16      ordering;       \/* A value that applications can use to determine\n-                                 * primary sorting of face names, or for ordering\n-                                 * of descriptors when composing family or face names. *\/\n-  public:\n-  DEFINE_SIZE_STATIC (8);\n@@ -332,1 +520,2 @@\n-  void collect_name_ids (hb_set_t *nameids_to_retain) const\n+  void collect_name_ids (hb_hashmap_t<hb_tag_t, float> *user_axes_location,\n+                         hb_set_t *nameids_to_retain \/* OUT *\/) const\n@@ -341,0 +530,2 @@\n+    auto designAxes = get_design_axes ();\n+\n@@ -343,0 +534,2 @@\n+    | hb_filter ([&] (const AxisValue& _)\n+                 { return _.keep_axis_value (designAxes, user_axes_location); })\n@@ -348,0 +541,21 @@\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    STAT *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    auto designAxes = get_design_axes ();\n+    for (unsigned i = 0; i < (unsigned)designAxisCount; i++)\n+      if (unlikely (!c->serializer->embed (designAxes[i])))\n+          return_trace (false);\n+\n+    if (designAxisCount)\n+      c->serializer->check_assign (out->designAxesOffset, this->get_size (),\n+                                   HB_SERIALIZE_ERROR_INT_OVERFLOW);\n+\n+    unsigned count = 0;\n+    out->offsetToAxisValueOffsets.serialize_subset (c, offsetToAxisValueOffsets, this,\n+                                                    axisValueCount, count, designAxes);\n+    return_trace (c->serializer->check_assign (out->axisValueCount, count, HB_SERIALIZE_ERROR_INT_OVERFLOW));\n+  }\n+\n@@ -384,1 +598,1 @@\n-  NNOffset32To<UnsizedArrayOf<Offset16To<AxisValue>>>\n+  NNOffset32To<AxisValueOffsetArray>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-stat-table.hh","additions":245,"deletions":31,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -122,0 +122,11 @@\n+\/**\n+ * hb_ot_tags_from_script:\n+ * @script: an #hb_script_t to convert.\n+ * @script_tag_1: (out): output #hb_tag_t.\n+ * @script_tag_2: (out): output #hb_tag_t.\n+ *\n+ * Converts an #hb_script_t to script tags.\n+ *\n+ * Since: 0.6.0\n+ * Deprecated: 2.0.0: use hb_ot_tags_from_script_and_language() instead\n+ **\/\n@@ -217,0 +228,2 @@\n+  \/* Same as hb_language_matches(); duplicated. *\/\n+\n@@ -250,0 +263,9 @@\n+\/**\n+ * hb_ot_tag_from_language:\n+ * @language: an #hb_language_t to convert.\n+ *\n+ * Converts an #hb_language_t to an #hb_tag_t.\n+ *\n+ * Since: 0.6.0\n+ * Deprecated: 2.0.0: use hb_ot_tags_from_script_and_language() instead\n+ **\/\n@@ -308,1 +330,1 @@\n-    unsigned tag_idx = last_tag_idx.get_relaxed ();\n+    unsigned tag_idx = last_tag_idx;\n@@ -313,1 +335,1 @@\n-      last_tag_idx.set_relaxed (tag_idx);\n+      last_tag_idx = tag_idx;\n@@ -578,1 +600,1 @@\n-        memcpy (buf, lang_str, len);\n+        hb_memcpy (buf, lang_str, len);\n@@ -607,1 +629,1 @@\n-      fprintf (stderr, \"ot_languages2 not sorted at index %d: %08x %d %08x\\n\",\n+      fprintf (stderr, \"ot_languages2 not sorted at index %u: %08x %d %08x\\n\",\n@@ -618,1 +640,1 @@\n-      fprintf (stderr, \"ot_languages3 not sorted at index %d: %08x %d %08x\\n\",\n+      fprintf (stderr, \"ot_languages3 not sorted at index %u: %08x %d %08x\\n\",\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-tag.cc","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+#include \"hb-ot-var-common.hh\"\n+\n@@ -43,0 +45,22 @@\n+\/* \"Spec\": https:\/\/github.com\/be-fonts\/boring-expansion-spec\/issues\/14 *\/\n+struct avarV2Tail\n+{\n+  friend struct avar;\n+\n+  bool sanitize (hb_sanitize_context_t *c,\n+                 const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (varIdxMap.sanitize (c, base) &&\n+                  varStore.sanitize (c, base));\n+  }\n+\n+  protected:\n+  Offset32To<DeltaSetIndexMap>  varIdxMap;      \/* Offset from the beginning of 'avar' table. *\/\n+  Offset32To<VariationStore>    varStore;       \/* Offset from the beginning of 'avar' table. *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+\n@@ -65,2 +89,2 @@\n-#define fromCoord coords[from_offset]\n-#define toCoord coords[to_offset]\n+#define fromCoord coords[from_offset].to_int ()\n+#define toCoord coords[to_offset].to_int ()\n@@ -109,0 +133,8 @@\n+  bool has_data () const { return version.to_int (); }\n+\n+  const SegmentMaps* get_segment_maps () const\n+  { return &firstAxisSegmentMaps; }\n+\n+  unsigned get_axis_count () const\n+  { return axisCount; }\n+\n@@ -112,3 +144,7 @@\n-    if (unlikely (!(version.sanitize (c) &&\n-                    version.major == 1 &&\n-                    c->check_struct (this))))\n+    if (!(version.sanitize (c) &&\n+          (version.major == 1\n+#ifndef HB_NO_AVAR2\n+           || version.major == 2\n+#endif\n+           ) &&\n+          c->check_struct (this)))\n@@ -126,0 +162,9 @@\n+#ifndef HB_NO_AVAR2\n+    if (version.major < 2)\n+      return_trace (true);\n+\n+    const auto &v2 = * (const avarV2Tail *) map;\n+    if (unlikely (!v2.sanitize (c, this)))\n+      return_trace (false);\n+#endif\n+\n@@ -139,0 +184,30 @@\n+\n+#ifndef HB_NO_AVAR2\n+    if (version.major < 2)\n+      return;\n+\n+    for (; count < axisCount; count++)\n+      map = &StructAfter<SegmentMaps> (*map);\n+\n+    const auto &v2 = * (const avarV2Tail *) map;\n+\n+    const auto &varidx_map = this+v2.varIdxMap;\n+    const auto &var_store = this+v2.varStore;\n+    auto *var_store_cache = var_store.create_cache ();\n+\n+    hb_vector_t<int> out;\n+    out.alloc (coords_length);\n+    for (unsigned i = 0; i < coords_length; i++)\n+    {\n+      int v = coords[i];\n+      uint32_t varidx = varidx_map.map (i);\n+      float delta = var_store.get_delta (varidx, coords, coords_length, var_store_cache);\n+      v += roundf (delta);\n+      v = hb_clamp (v, -(1<<14), +(1<<14));\n+      out.push (v);\n+    }\n+    for (unsigned i = 0; i < coords_length; i++)\n+      coords[i] = out[i];\n+\n+    OT::VariationStore::destroy_cache (var_store_cache);\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-avar-table.hh","additions":80,"deletions":5,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-struct DeltaSetIndexMapFormat0\n+template <typename MapCountT>\n+struct DeltaSetIndexMapFormat01\n@@ -39,1 +40,1 @@\n-  DeltaSetIndexMapFormat0* copy (hb_serialize_context_t *c) const\n+  DeltaSetIndexMapFormat01* copy (hb_serialize_context_t *c) const\n@@ -49,1 +50,1 @@\n-    memcpy (p, this, HBUINT8::static_size * total_size);\n+    hb_memcpy (p, this, HBUINT8::static_size * total_size);\n@@ -131,1 +132,1 @@\n-  HBUINT16      mapCount;       \/* The number of mapping entries. *\/\n+  MapCountT     mapCount;       \/* The number of mapping entries. *\/\n@@ -136,45 +137,1 @@\n-  DEFINE_SIZE_ARRAY (4, mapDataZ);\n-};\n-\n-struct DeltaSetIndexMapFormat1\n-{\n-  friend struct DeltaSetIndexMap;\n-\n-  private:\n-  DeltaSetIndexMapFormat1* copy (hb_serialize_context_t *c) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    auto *out = c->start_embed (this);\n-    if (unlikely (!out)) return_trace (nullptr);\n-\n-    unsigned total_size = min_size + mapCount * get_width ();\n-    HBUINT8 *p = c->allocate_size<HBUINT8> (total_size);\n-    if (unlikely (!p)) return_trace (nullptr);\n-\n-    memcpy (p, this, HBUINT8::static_size * total_size);\n-    return_trace (out);\n-  }\n-\n-  unsigned get_map_count () const       { return mapCount; }\n-  unsigned get_width () const           { return ((entryFormat >> 4) & 3) + 1; }\n-  unsigned get_inner_bit_count () const { return (entryFormat & 0xF) + 1; }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  c->check_range (mapDataZ.arrayZ,\n-                                  mapCount,\n-                                  get_width ()));\n-  }\n-\n-  protected:\n-  HBUINT8       format;         \/* Format identifier--format = 1 *\/\n-  HBUINT8       entryFormat;    \/* A packed field that describes the compressed\n-                                 * representation of delta-set indices. *\/\n-  HBUINT32      mapCount;       \/* The number of mapping entries. *\/\n-  UnsizedArrayOf<HBUINT8>\n-                mapDataZ;       \/* The delta-set index mapping data. *\/\n-\n-  public:\n-  DEFINE_SIZE_ARRAY (6, mapDataZ);\n+  DEFINE_SIZE_ARRAY (2+MapCountT::static_size, mapDataZ);\n@@ -189,0 +146,2 @@\n+    unsigned length = plan.get_output_map ().length;\n+    u.format = length <= 0xFFFF ? 0 : 1;\n@@ -191,0 +150,1 @@\n+    case 1: return_trace (u.format1.serialize (c, plan));\n@@ -199,0 +159,1 @@\n+    case 1: return (u.format1.map (v));\n@@ -253,3 +214,3 @@\n-  HBUINT8                       format;         \/* Format identifier *\/\n-  DeltaSetIndexMapFormat0       format0;\n-  DeltaSetIndexMapFormat1       format1;\n+  HBUINT8                            format;         \/* Format identifier *\/\n+  DeltaSetIndexMapFormat01<HBUINT16> format0;\n+  DeltaSetIndexMapFormat01<HBUINT32> format1;\n@@ -261,0 +222,19 @@\n+\n+struct VarStoreInstancer\n+{\n+  VarStoreInstancer (const VariationStore &varStore,\n+                     const DeltaSetIndexMap &varIdxMap,\n+                     hb_array_t<int> coords) :\n+    varStore (varStore), varIdxMap (varIdxMap), coords (coords) {}\n+\n+  operator bool () const { return bool (coords); }\n+\n+  float operator() (uint32_t varIdx, unsigned short offset = 0) const\n+  { return varStore.get_delta (varIdxMap.map (VarIdx::add (varIdx, offset)), coords); }\n+\n+  const VariationStore &varStore;\n+  const DeltaSetIndexMap &varIdxMap;\n+  hb_array_t<int> coords;\n+};\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-common.hh","additions":32,"deletions":52,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  hb_array_t<const HBFixed> get_coordinates (unsigned int axis_count) const\n+  hb_array_t<const F16DOT16> get_coordinates (unsigned int axis_count) const\n@@ -50,0 +50,38 @@\n+  bool subset (hb_subset_context_t *c,\n+               unsigned axis_count,\n+               bool has_postscript_nameid) const\n+  {\n+    TRACE_SUBSET (this);\n+    if (unlikely (!c->serializer->embed (subfamilyNameID))) return_trace (false);\n+    if (unlikely (!c->serializer->embed (flags))) return_trace (false);\n+\n+    const hb_array_t<const F16DOT16> coords = get_coordinates (axis_count);\n+    const hb_hashmap_t<hb_tag_t, float> *axes_location = &c->plan->user_axes_location;\n+    for (unsigned i = 0 ; i < axis_count; i++)\n+    {\n+      uint32_t *axis_tag;\n+      \/\/ only keep instances whose coordinates == pinned axis location\n+      if (!c->plan->axes_old_index_tag_map.has (i, &axis_tag)) continue;\n+\n+      if (axes_location->has (*axis_tag) &&\n+          fabsf (axes_location->get (*axis_tag) - coords[i].to_float ()) > 0.001f)\n+        return_trace (false);\n+\n+      if (!c->plan->axes_index_map.has (i))\n+        continue;\n+\n+      if (!c->serializer->embed (coords[i]))\n+        return_trace (false);\n+    }\n+\n+    if (has_postscript_nameid)\n+    {\n+      NameID name_id;\n+      name_id = StructAfter<NameID> (coords);\n+      if (!c->serializer->embed (name_id))\n+        return_trace (false);\n+    }\n+\n+    return_trace (true);\n+  }\n+\n@@ -61,1 +99,1 @@\n-  UnsizedArrayOf<HBFixed>\n+  UnsizedArrayOf<F16DOT16>\n@@ -99,0 +137,2 @@\n+  hb_tag_t get_axis_tag () const { return axisTag; }\n+\n@@ -136,1 +176,0 @@\n-  protected:\n@@ -139,1 +178,1 @@\n-    default_ = defaultValue \/ 65536.f;\n+    default_ = defaultValue.to_float ();\n@@ -141,2 +180,7 @@\n-    min = hb_min (default_, minValue \/ 65536.f);\n-    max = hb_max (default_, maxValue \/ 65536.f);\n+    min = hb_min (default_, minValue.to_float ());\n+    max = hb_max (default_, maxValue.to_float ());\n+  }\n+\n+  float get_default () const\n+  {\n+    return defaultValue.to_float ();\n@@ -148,3 +192,3 @@\n-  HBFixed       minValue;       \/* The minimum coordinate value for the axis. *\/\n-  HBFixed       defaultValue;   \/* The default coordinate value for the axis. *\/\n-  HBFixed       maxValue;       \/* The maximum coordinate value for the axis. *\/\n+  F16DOT16      minValue;       \/* The minimum coordinate value for the axis. *\/\n+  F16DOT16      defaultValue;   \/* The default coordinate value for the axis. *\/\n+  F16DOT16      maxValue;       \/* The maximum coordinate value for the axis. *\/\n@@ -265,1 +309,1 @@\n-      hb_array_t<const HBFixed> instanceCoords = instance->get_coordinates (axisCount)\n+      hb_array_t<const F16DOT16> instanceCoords = instance->get_coordinates (axisCount)\n@@ -273,1 +317,2 @@\n-  void collect_name_ids (hb_set_t *nameids) const\n+  void collect_name_ids (hb_hashmap_t<hb_tag_t, float> *user_axes_location,\n+                         hb_set_t *nameids  \/* IN\/OUT *\/) const\n@@ -276,0 +321,1 @@\n+    hb_map_t pinned_axes;\n@@ -277,4 +323,48 @@\n-    + get_axes ()\n-    | hb_map (&AxisRecord::get_name_id)\n-    | hb_sink (nameids)\n-    ;\n+    auto axis_records = get_axes ();\n+    for (unsigned i = 0 ; i < (unsigned)axisCount; i++)\n+    {\n+      hb_tag_t axis_tag = axis_records[i].get_axis_tag ();\n+      if (user_axes_location->has (axis_tag))\n+      {\n+        pinned_axes.set (i, axis_tag);\n+        continue;\n+      }\n+\n+      nameids->add (axis_records[i].get_name_id ());\n+    }\n+\n+    for (unsigned i = 0 ; i < (unsigned)instanceCount; i++)\n+    {\n+      const InstanceRecord *instance = get_instance (i);\n+\n+      if (hb_any (+ hb_enumerate (instance->get_coordinates (axisCount))\n+                  | hb_filter (pinned_axes, hb_first)\n+                  | hb_map ([&] (const hb_pair_t<unsigned, const F16DOT16&>& _)\n+                            {\n+                              hb_tag_t axis_tag = pinned_axes.get (_.first);\n+                              float location = user_axes_location->get (axis_tag);\n+                              if (fabs ((double)location - (double)_.second.to_float ()) > 0.001) return true;\n+                              return false;\n+                            })\n+                  ))\n+        continue;\n+\n+      nameids->add (instance->subfamilyNameID);\n+\n+      if (instanceSize >= axisCount * 4 + 6)\n+      {\n+        unsigned post_script_name_id = StructAfter<NameID> (instance->get_coordinates (axisCount));\n+        if (post_script_name_id != HB_OT_NAME_ID_INVALID) nameids->add (post_script_name_id);\n+      }\n+    }\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    unsigned retained_axis_count = c->plan->axes_index_map.get_population ();\n+    if (!retained_axis_count) \/\/all axes are pinned\n+      return_trace (false);\n+\n+    fvar *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n@@ -282,4 +372,2 @@\n-    + hb_range ((unsigned) instanceCount)\n-    | hb_map ([this] (const unsigned _) { return get_instance_subfamily_name_id (_); })\n-    | hb_sink (nameids)\n-    ;\n+    if (!c->serializer->check_assign (out->axisCount, retained_axis_count, HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+      return_trace (false);\n@@ -287,4 +375,27 @@\n-    + hb_range ((unsigned) instanceCount)\n-    | hb_map ([this] (const unsigned _) { return get_instance_postscript_name_id (_); })\n-    | hb_sink (nameids)\n-    ;\n+    bool has_postscript_nameid = false;\n+    if (instanceSize >= axisCount * 4 + 6)\n+      has_postscript_nameid = true;\n+\n+    if (!c->serializer->check_assign (out->instanceSize, retained_axis_count * 4 + (has_postscript_nameid ? 6 : 4),\n+                                      HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+      return_trace (false);\n+\n+    auto axes_records = get_axes ();\n+    for (unsigned i = 0 ; i < (unsigned)axisCount; i++)\n+    {\n+      if (!c->plan->axes_index_map.has (i)) continue;\n+      if (unlikely (!c->serializer->embed (axes_records[i])))\n+        return_trace (false);\n+    }\n+\n+    if (!c->serializer->check_assign (out->firstAxis, get_size (), HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+      return_trace (false);\n+\n+    for (unsigned i = 0 ; i < (unsigned)instanceCount; i++)\n+    {\n+      const InstanceRecord *instance = get_instance (i);\n+      auto snap = c->serializer->snapshot ();\n+      if (!instance->subset (c, axisCount, has_postscript_nameid))\n+        c->serializer->revert (snap);\n+    }\n+    return_trace (true);\n@@ -318,2 +429,2 @@\n-                                 * to either axisCount * sizeof(HBFixed) + 4, or to\n-                                 * axisCount * sizeof(HBFixed) + 6. *\/\n+                                 * to either axisCount * sizeof(F16DOT16) + 4, or to\n+                                 * axisCount * sizeof(F16DOT16) + 6. *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-fvar-table.hh","additions":136,"deletions":25,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    if (unlikely (!resize (old_len + a.length)))\n+    if (unlikely (!resize (old_len + a.length, false)))\n@@ -63,2 +63,1 @@\n-    for (unsigned int i = 0; i < count; i++)\n-      arrayZ[i] = a.arrayZ[i];\n+    hb_memcpy (arrayZ, a.arrayZ, count * sizeof (arrayZ[0]));\n@@ -132,1 +131,1 @@\n-      int peak = peak_tuple[i];\n+      int peak = peak_tuple[i].to_int ();\n@@ -137,2 +136,2 @@\n-        int start = start_tuple[i];\n-        int end = end_tuple[i];\n+        int start = start_tuple[i].to_int ();\n+        int end = end_tuple[i].to_int ();\n@@ -234,2 +233,2 @@\n-             var_data_bytes.check_range (current_tuple, hb_max (current_tuple->get_data_size (), current_tuple->get_size (axis_count))) &&\n-             current_tuple->get_size (axis_count);\n+             var_data_bytes.check_range (current_tuple, hb_max (current_tuple->get_data_size (),\n+                                                                current_tuple->get_size (axis_count)));\n@@ -284,1 +283,1 @@\n-    uint16_t count = *p++;\n+    unsigned count = *p++;\n@@ -290,1 +289,1 @@\n-    if (unlikely (!points.resize (count))) return false;\n+    if (unlikely (!points.resize (count, false))) return false;\n@@ -292,2 +291,2 @@\n-    unsigned int n = 0;\n-    uint16_t i = 0;\n+    unsigned n = 0;\n+    unsigned i = 0;\n@@ -297,3 +296,4 @@\n-      uint16_t j;\n-      uint8_t control = *p++;\n-      uint16_t run_count = (control & POINT_RUN_COUNT_MASK) + 1;\n+      unsigned control = *p++;\n+      unsigned run_count = (control & POINT_RUN_COUNT_MASK) + 1;\n+      if (unlikely (i + run_count > count)) return false;\n+      unsigned j;\n@@ -302,1 +302,2 @@\n-        for (j = 0; j < run_count && i < count; j++, i++)\n+        if (unlikely (p + run_count * HBUINT16::static_size > end)) return false;\n+        for (j = 0; j < run_count; j++, i++)\n@@ -304,1 +305,0 @@\n-          if (unlikely (p + HBUINT16::static_size > end)) return false;\n@@ -306,1 +306,1 @@\n-          points[i] = n;\n+          points.arrayZ[i] = n;\n@@ -312,1 +312,2 @@\n-        for (j = 0; j < run_count && i < count; j++, i++)\n+        if (unlikely (p + run_count > end)) return false;\n+        for (j = 0; j < run_count; j++, i++)\n@@ -314,1 +315,0 @@\n-          if (unlikely (p + 1 > end)) return false;\n@@ -316,1 +316,1 @@\n-          points[i] = n;\n+          points.arrayZ[i] = n;\n@@ -319,1 +319,0 @@\n-      if (j < run_count) return false;\n@@ -335,2 +334,2 @@\n-    unsigned int i = 0;\n-    unsigned int count = deltas.length;\n+    unsigned i = 0;\n+    unsigned count = deltas.length;\n@@ -340,3 +339,4 @@\n-      uint8_t control = *p++;\n-      unsigned int run_count = (control & DELTA_RUN_COUNT_MASK) + 1;\n-      unsigned int j;\n+      unsigned control = *p++;\n+      unsigned run_count = (control & DELTA_RUN_COUNT_MASK) + 1;\n+      if (unlikely (i + run_count > count)) return false;\n+      unsigned j;\n@@ -344,2 +344,4 @@\n-        for (j = 0; j < run_count && i < count; j++, i++)\n-          deltas[i] = 0;\n+      {\n+        for (j = 0; j < run_count; j++, i++)\n+          deltas.arrayZ[i] = 0;\n+      }\n@@ -347,1 +349,3 @@\n-        for (j = 0; j < run_count && i < count; j++, i++)\n+      {\n+        if (unlikely (p + run_count * HBUINT16::static_size > end)) return false;\n+        for (j = 0; j < run_count; j++, i++)\n@@ -349,2 +353,1 @@\n-          if (unlikely (p + HBUINT16::static_size > end)) return false;\n-          deltas[i] = *(const HBINT16 *) p;\n+          deltas.arrayZ[i] = * (const HBINT16 *) p;\n@@ -353,0 +356,1 @@\n+      }\n@@ -354,1 +358,3 @@\n-        for (j = 0; j < run_count && i < count; j++, i++)\n+      {\n+        if (unlikely (p + run_count > end)) return false;\n+        for (j = 0; j < run_count; j++, i++)\n@@ -356,2 +362,1 @@\n-          if (unlikely (p + 1 > end)) return false;\n-          deltas[i] = *(const HBINT8 *) p++;\n+          deltas.arrayZ[i] = * (const HBINT8 *) p++;\n@@ -359,2 +364,1 @@\n-      if (j < run_count)\n-        return false;\n+      }\n@@ -453,1 +457,1 @@\n-      memcpy (tuples, this+sharedTuples, shared_tuple_size);\n+      hb_memcpy (tuples, this+sharedTuples, shared_tuple_size);\n@@ -476,1 +480,1 @@\n-        memcpy (subset_data, var_data_bytes.arrayZ, var_data_bytes.length);\n+        hb_memcpy (subset_data, var_data_bytes.arrayZ, var_data_bytes.length);\n@@ -504,0 +508,1 @@\n+    _hb_compiler_memory_r_barrier ();\n@@ -524,5 +529,5 @@\n-      float target_val = points[target].*m;\n-      float prev_val = points[prev].*m;\n-      float next_val = points[next].*m;\n-      float prev_delta =  deltas[prev].*m;\n-      float next_delta =  deltas[next].*m;\n+      float target_val = points.arrayZ[target].*m;\n+      float prev_val = points.arrayZ[prev].*m;\n+      float next_val = points.arrayZ[next].*m;\n+      float prev_delta =  deltas.arrayZ[prev].*m;\n+      float next_delta =  deltas.arrayZ[next].*m;\n@@ -546,1 +551,2 @@\n-    bool apply_deltas_to_points (hb_codepoint_t glyph, hb_font_t *font,\n+    bool apply_deltas_to_points (hb_codepoint_t glyph,\n+                                 hb_array_t<int> coords,\n@@ -549,1 +555,1 @@\n-      if (!font->num_coords) return true;\n+      if (!coords) return true;\n@@ -562,4 +568,4 @@\n-      contour_point_vector_t orig_points;\n-      if (unlikely (!orig_points.resize (points.length))) return false;\n-      for (unsigned int i = 0; i < orig_points.length; i++)\n-        orig_points.arrayZ[i] = points.arrayZ[i];\n+      contour_point_vector_t orig_points_vec;\n+      orig_points_vec.extend (points);\n+      if (unlikely (orig_points_vec.in_error ())) return false;\n+      auto orig_points = orig_points_vec.as_array ();\n@@ -567,2 +573,3 @@\n-      contour_point_vector_t deltas; \/* flag is used to indicate referenced point *\/\n-      if (unlikely (!deltas.resize (points.length))) return false;\n+      contour_point_vector_t deltas_vec; \/* flag is used to indicate referenced point *\/\n+      if (unlikely (!deltas_vec.resize (points.length, false))) return false;\n+      auto deltas = deltas_vec.as_array ();\n@@ -572,1 +579,1 @@\n-        if (points[i].is_end_point)\n+        if (points.arrayZ[i].is_end_point)\n@@ -575,1 +582,0 @@\n-      auto coords = hb_array (font->coords, font->num_coords);\n@@ -601,1 +607,1 @@\n-        if (unlikely (!x_deltas.resize (num_deltas))) return false;\n+        if (unlikely (!x_deltas.resize (num_deltas, false))) return false;\n@@ -603,1 +609,1 @@\n-        if (unlikely (!y_deltas.resize (num_deltas))) return false;\n+        if (unlikely (!y_deltas.resize (num_deltas, false))) return false;\n@@ -606,10 +612,25 @@\n-        for (unsigned int i = 0; i < deltas.length; i++)\n-          deltas[i].init ();\n-        for (unsigned int i = 0; i < num_deltas; i++)\n-        {\n-          unsigned int pt_index = apply_to_all ? i : indices[i];\n-          if (unlikely (pt_index >= deltas.length)) continue;\n-          deltas.arrayZ[pt_index].flag = 1;     \/* this point is referenced, i.e., explicit deltas specified *\/\n-          deltas.arrayZ[pt_index].x += x_deltas.arrayZ[i] * scalar;\n-          deltas.arrayZ[pt_index].y += y_deltas.arrayZ[i] * scalar;\n-        }\n+        hb_memset (deltas.arrayZ, 0, deltas.get_size ());\n+\n+        unsigned ref_points = 0;\n+        if (scalar != 1.0f)\n+          for (unsigned int i = 0; i < num_deltas; i++)\n+          {\n+            unsigned int pt_index = apply_to_all ? i : indices[i];\n+            if (unlikely (pt_index >= deltas.length)) continue;\n+            auto &delta = deltas.arrayZ[pt_index];\n+            ref_points += !delta.flag;\n+            delta.flag = 1;     \/* this point is referenced, i.e., explicit deltas specified *\/\n+            delta.x += x_deltas.arrayZ[i] * scalar;\n+            delta.y += y_deltas.arrayZ[i] * scalar;\n+          }\n+        else\n+          for (unsigned int i = 0; i < num_deltas; i++)\n+          {\n+            unsigned int pt_index = apply_to_all ? i : indices[i];\n+            if (unlikely (pt_index >= deltas.length)) continue;\n+            auto &delta = deltas.arrayZ[pt_index];\n+            ref_points += !delta.flag;\n+            delta.flag = 1;     \/* this point is referenced, i.e., explicit deltas specified *\/\n+            delta.x += x_deltas.arrayZ[i];\n+            delta.y += y_deltas.arrayZ[i];\n+          }\n@@ -618,2 +639,1 @@\n-        unsigned start_point = 0;\n-        for (unsigned c = 0; c < end_points.length; c++)\n+        if (ref_points && ref_points < orig_points.length)\n@@ -621,1 +641,4 @@\n-          unsigned end_point = end_points[c];\n+          unsigned start_point = 0;\n+          for (unsigned c = 0; c < end_points.length; c++)\n+          {\n+            unsigned end_point = end_points.arrayZ[c];\n@@ -623,4 +646,5 @@\n-          \/* Check the number of unreferenced points in a contour. If no unref points or no ref points, nothing to do. *\/\n-          unsigned unref_count = 0;\n-          for (unsigned i = start_point; i <= end_point; i++)\n-            if (!deltas[i].flag) unref_count++;\n+            \/* Check the number of unreferenced points in a contour. If no unref points or no ref points, nothing to do. *\/\n+            unsigned unref_count = 0;\n+            for (unsigned i = start_point; i < end_point + 1; i++)\n+              unref_count += deltas.arrayZ[i].flag;\n+            unref_count = (end_point - start_point + 1) - unref_count;\n@@ -628,3 +652,3 @@\n-          unsigned j = start_point;\n-          if (unref_count == 0 || unref_count > end_point - start_point)\n-            goto no_more_gaps;\n+            unsigned j = start_point;\n+            if (unref_count == 0 || unref_count > end_point - start_point)\n+              goto no_more_gaps;\n@@ -632,22 +656,0 @@\n-          for (;;)\n-          {\n-            \/* Locate the next gap of unreferenced points between two referenced points prev and next.\n-             * Note that a gap may wrap around at left (start_point) and\/or at right (end_point).\n-             *\/\n-            unsigned int prev, next, i;\n-            for (;;)\n-            {\n-              i = j;\n-              j = next_index (i, start_point, end_point);\n-              if (deltas[i].flag && !deltas[j].flag) break;\n-            }\n-            prev = j = i;\n-            for (;;)\n-            {\n-              i = j;\n-              j = next_index (i, start_point, end_point);\n-              if (!deltas[i].flag && deltas[j].flag) break;\n-            }\n-            next = j;\n-            \/* Infer deltas for all unref points in the gap between prev and next *\/\n-            i = prev;\n@@ -656,5 +658,28 @@\n-              i = next_index (i, start_point, end_point);\n-              if (i == next) break;\n-              deltas[i].x = infer_delta (orig_points.as_array (), deltas.as_array (), i, prev, next, &contour_point_t::x);\n-              deltas[i].y = infer_delta (orig_points.as_array (), deltas.as_array (), i, prev, next, &contour_point_t::y);\n-              if (--unref_count == 0) goto no_more_gaps;\n+              \/* Locate the next gap of unreferenced points between two referenced points prev and next.\n+               * Note that a gap may wrap around at left (start_point) and\/or at right (end_point).\n+               *\/\n+              unsigned int prev, next, i;\n+              for (;;)\n+              {\n+                i = j;\n+                j = next_index (i, start_point, end_point);\n+                if (deltas.arrayZ[i].flag && !deltas.arrayZ[j].flag) break;\n+              }\n+              prev = j = i;\n+              for (;;)\n+              {\n+                i = j;\n+                j = next_index (i, start_point, end_point);\n+                if (!deltas.arrayZ[i].flag && deltas.arrayZ[j].flag) break;\n+              }\n+              next = j;\n+              \/* Infer deltas for all unref points in the gap between prev and next *\/\n+              i = prev;\n+              for (;;)\n+              {\n+                i = next_index (i, start_point, end_point);\n+                if (i == next) break;\n+                deltas.arrayZ[i].x = infer_delta (orig_points, deltas, i, prev, next, &contour_point_t::x);\n+                deltas.arrayZ[i].y = infer_delta (orig_points, deltas, i, prev, next, &contour_point_t::y);\n+                if (--unref_count == 0) goto no_more_gaps;\n+              }\n@@ -662,0 +687,2 @@\n+          no_more_gaps:\n+            start_point = end_point + 1;\n@@ -663,2 +690,0 @@\n-        no_more_gaps:\n-          start_point = end_point + 1;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-gvar-table.hh","additions":130,"deletions":105,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -322,3 +322,3 @@\n-  float get_advance_var (hb_codepoint_t  glyph,\n-                         hb_font_t      *font,\n-                         VariationStore::cache_t *store_cache = nullptr) const\n+  float get_advance_delta_unscaled (hb_codepoint_t  glyph,\n+                                    const int *coords, unsigned int coord_count,\n+                                    VariationStore::cache_t *store_cache = nullptr) const\n@@ -328,2 +328,1 @@\n-                                      font->coords,\n-                                      font->num_coords,\n+                                      coords, coord_count,\n@@ -333,2 +332,3 @@\n-  float get_side_bearing_var (hb_codepoint_t glyph,\n-                              const int *coords, unsigned int coord_count) const\n+  bool get_lsb_delta_unscaled (hb_codepoint_t glyph,\n+                               const int *coords, unsigned int coord_count,\n+                               float *lsb) const\n@@ -336,1 +336,1 @@\n-    if (!has_side_bearing_deltas ()) return 0.f;\n+    if (!lsbMap) return false;\n@@ -338,1 +338,2 @@\n-    return (this+varStore).get_delta (varidx, coords, coord_count);\n+    *lsb = (this+varStore).get_delta (varidx, coords, coord_count);\n+    return true;\n@@ -341,2 +342,0 @@\n-  bool has_side_bearing_deltas () const { return lsbMap && rsbMap; }\n-\n@@ -395,0 +394,10 @@\n+  bool get_vorg_delta_unscaled (hb_codepoint_t glyph,\n+                                const int *coords, unsigned int coord_count,\n+                                float *delta) const\n+  {\n+    if (!vorgMap) return false;\n+    uint32_t varidx = (this+vorgMap).map (glyph);\n+    *delta = (this+varStore).get_delta (varidx, coords, coord_count);\n+    return true;\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-hvar-table.hh","additions":20,"deletions":11,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  HBUINT32              varIdx;         \/* Outer\/inner index into VariationStore item. *\/\n+  VarIdx        varIdx;         \/* Outer\/inner index into VariationStore item. *\/\n@@ -119,0 +119,9 @@\n+#define HB_ADD_MVAR_VAR(tag, field) \\\n+       c->serializer->check_assign (table->field, \\\n+                                    roundf (table->field + \\\n+                                            MVAR.get_var (tag, \\\n+                                                          c->plan->normalized_coords.arrayZ, \\\n+                                                          c->plan->normalized_coords.length)), \\\n+                                    HB_SERIALIZE_ERROR_INT_OVERFLOW)\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-mvar-table.hh","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n@@ -165,1 +165,1 @@\n- * Return value: %true if data found, %false otherwise\n+ * Return value: `true` if data found, `false` otherwise\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var.cc","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,322 @@\n+\/*\n+ * Copyright © 2023  Behdad Esfahbod\n+ * Copyright © 1999  David Turner\n+ * Copyright © 2005  Werner Lemberg\n+ * Copyright © 2013-2015  Alexei Podtelezhnikov\n+ *\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#ifndef HB_NO_OUTLINE\n+\n+#include \"hb-outline.hh\"\n+\n+#include \"hb-machinery.hh\"\n+\n+\n+void hb_outline_t::replay (hb_draw_funcs_t *pen, void *pen_data) const\n+{\n+  hb_draw_state_t st = HB_DRAW_STATE_DEFAULT;\n+\n+  unsigned first = 0;\n+  for (unsigned contour : contours)\n+  {\n+    auto it = points.as_array ().sub_array (first, contour - first);\n+    while (it)\n+    {\n+      hb_outline_point_t p1 = *it++;\n+      switch (p1.type)\n+      {\n+        case hb_outline_point_t::type_t::MOVE_TO:\n+        {\n+          pen->move_to (pen_data, st,\n+                           p1.x, p1.y);\n+        }\n+        break;\n+        case hb_outline_point_t::type_t::LINE_TO:\n+        {\n+          pen->line_to (pen_data, st,\n+                           p1.x, p1.y);\n+        }\n+        break;\n+        case hb_outline_point_t::type_t::QUADRATIC_TO:\n+        {\n+          hb_outline_point_t p2 = *it++;\n+          pen->quadratic_to (pen_data, st,\n+                                p1.x, p1.y,\n+                                p2.x, p2.y);\n+        }\n+        break;\n+        case hb_outline_point_t::type_t::CUBIC_TO:\n+        {\n+          hb_outline_point_t p2 = *it++;\n+          hb_outline_point_t p3 = *it++;\n+          pen->cubic_to (pen_data, st,\n+                            p1.x, p1.y,\n+                            p2.x, p2.y,\n+                            p3.x, p3.y);\n+        }\n+        break;\n+      }\n+    }\n+    pen->close_path (pen_data, st);\n+    first = contour;\n+  }\n+}\n+\n+float hb_outline_t::area () const\n+{\n+  float a = 0;\n+  unsigned first = 0;\n+  for (unsigned contour : contours)\n+  {\n+    for (unsigned i = first; i < contour; i++)\n+    {\n+      unsigned j = i + 1 < contour ? i + 1 : first;\n+\n+      auto &pi = points[i];\n+      auto &pj = points[j];\n+      a += pi.x * pj.y - pi.y * pj.x;\n+    }\n+\n+    first = contour;\n+  }\n+  return a * .5f;\n+}\n+\n+void hb_outline_t::embolden (float x_strength, float y_strength,\n+                             float x_shift, float y_shift)\n+{\n+  \/* This function is a straight port of FreeType's FT_Outline_EmboldenXY.\n+   * Permission has been obtained from the FreeType authors of the code\n+   * to relicense it under the HarfBuzz license. *\/\n+\n+  if (!x_strength && !y_strength) return;\n+  if (!points) return;\n+\n+  x_strength \/= 2.f;\n+  y_strength \/= 2.f;\n+\n+  bool orientation_negative = area () < 0;\n+\n+  signed first = 0;\n+  for (unsigned c = 0; c < contours.length; c++)\n+  {\n+    hb_outline_vector_t in, out, anchor, shift;\n+    float l_in, l_out, l_anchor = 0, l, q, d;\n+\n+    l_in = 0;\n+    signed last = (int) contours[c] - 1;\n+\n+    \/* pacify compiler *\/\n+    in.x = in.y = anchor.x = anchor.y = 0;\n+\n+    \/* Counter j cycles though the points; counter i advances only  *\/\n+    \/* when points are moved; anchor k marks the first moved point. *\/\n+    for ( signed i = last, j = first, k = -1;\n+          j != i && i != k;\n+          j = j < last ? j + 1 : first )\n+    {\n+      if ( j != k )\n+      {\n+        out.x = points[j].x - points[i].x;\n+        out.y = points[j].y - points[i].y;\n+        l_out = out.normalize_len ();\n+\n+        if ( l_out == 0 )\n+          continue;\n+      }\n+      else\n+      {\n+        out   = anchor;\n+        l_out = l_anchor;\n+      }\n+\n+      if ( l_in != 0 )\n+      {\n+        if ( k < 0 )\n+        {\n+          k        = i;\n+          anchor   = in;\n+          l_anchor = l_in;\n+        }\n+\n+        d = in.x * out.x + in.y * out.y;\n+\n+        \/* shift only if turn is less than ~160 degrees *\/\n+        if ( d > -15.f\/16.f )\n+        {\n+          d = d + 1.f;\n+\n+          \/* shift components along lateral bisector in proper orientation *\/\n+          shift.x = in.y + out.y;\n+          shift.y = in.x + out.x;\n+\n+          if ( orientation_negative )\n+            shift.x = -shift.x;\n+          else\n+            shift.y = -shift.y;\n+\n+          \/* restrict shift magnitude to better handle collapsing segments *\/\n+          q = out.x * in.y - out.y * in.x;\n+          if ( orientation_negative )\n+            q = -q;\n+\n+          l = hb_min (l_in, l_out);\n+\n+          \/* non-strict inequalities avoid divide-by-zero when q == l == 0 *\/\n+          if (x_strength * q <= l * d)\n+            shift.x = shift.x * x_strength \/ d;\n+          else\n+            shift.x = shift.x * l \/ q;\n+\n+\n+          if (y_strength * q <= l * d)\n+            shift.y = shift.y * y_strength \/ d;\n+          else\n+            shift.y = shift.y * l \/ q;\n+        }\n+        else\n+          shift.x = shift.y = 0;\n+\n+        for ( ;\n+              i != j;\n+              i = i < last ? i + 1 : first )\n+        {\n+          points[i].x += x_shift + shift.x;\n+          points[i].y += y_shift + shift.y;\n+        }\n+      }\n+      else\n+        i = j;\n+\n+      in   = out;\n+      l_in = l_out;\n+    }\n+\n+    first = last + 1;\n+  }\n+}\n+\n+static void\n+hb_outline_recording_pen_move_to (hb_draw_funcs_t *dfuncs HB_UNUSED,\n+                                  void *data,\n+                                  hb_draw_state_t *st,\n+                                  float to_x, float to_y,\n+                                  void *user_data HB_UNUSED)\n+{\n+  hb_outline_t *c = (hb_outline_t *) data;\n+\n+  c->points.push (hb_outline_point_t {to_x, to_y, hb_outline_point_t::type_t::MOVE_TO});\n+}\n+\n+static void\n+hb_outline_recording_pen_line_to (hb_draw_funcs_t *dfuncs HB_UNUSED,\n+                                  void *data,\n+                                  hb_draw_state_t *st,\n+                                  float to_x, float to_y,\n+                                  void *user_data HB_UNUSED)\n+{\n+  hb_outline_t *c = (hb_outline_t *) data;\n+\n+  c->points.push (hb_outline_point_t {to_x, to_y, hb_outline_point_t::type_t::LINE_TO});\n+}\n+\n+static void\n+hb_outline_recording_pen_quadratic_to (hb_draw_funcs_t *dfuncs HB_UNUSED,\n+                                       void *data,\n+                                       hb_draw_state_t *st,\n+                                       float control_x, float control_y,\n+                                       float to_x, float to_y,\n+                                       void *user_data HB_UNUSED)\n+{\n+  hb_outline_t *c = (hb_outline_t *) data;\n+\n+  c->points.push (hb_outline_point_t {control_x, control_y, hb_outline_point_t::type_t::QUADRATIC_TO});\n+  c->points.push (hb_outline_point_t {to_x, to_y, hb_outline_point_t::type_t::QUADRATIC_TO});\n+}\n+\n+static void\n+hb_outline_recording_pen_cubic_to (hb_draw_funcs_t *dfuncs HB_UNUSED,\n+                                   void *data,\n+                                   hb_draw_state_t *st,\n+                                   float control1_x, float control1_y,\n+                                   float control2_x, float control2_y,\n+                                   float to_x, float to_y,\n+                                   void *user_data HB_UNUSED)\n+{\n+  hb_outline_t *c = (hb_outline_t *) data;\n+\n+  c->points.push (hb_outline_point_t {control1_x, control1_y, hb_outline_point_t::type_t::CUBIC_TO});\n+  c->points.push (hb_outline_point_t {control2_x, control2_y, hb_outline_point_t::type_t::CUBIC_TO});\n+  c->points.push (hb_outline_point_t {to_x, to_y, hb_outline_point_t::type_t::CUBIC_TO});\n+}\n+\n+static void\n+hb_outline_recording_pen_close_path (hb_draw_funcs_t *dfuncs HB_UNUSED,\n+                                     void *data,\n+                                     hb_draw_state_t *st,\n+                                     void *user_data HB_UNUSED)\n+{\n+  hb_outline_t *c = (hb_outline_t *) data;\n+\n+  c->contours.push (c->points.length);\n+}\n+\n+static inline void free_static_outline_recording_pen_funcs ();\n+\n+static struct hb_outline_recording_pen_funcs_lazy_loader_t : hb_draw_funcs_lazy_loader_t<hb_outline_recording_pen_funcs_lazy_loader_t>\n+{\n+  static hb_draw_funcs_t *create ()\n+  {\n+    hb_draw_funcs_t *funcs = hb_draw_funcs_create ();\n+\n+    hb_draw_funcs_set_move_to_func (funcs, hb_outline_recording_pen_move_to, nullptr, nullptr);\n+    hb_draw_funcs_set_line_to_func (funcs, hb_outline_recording_pen_line_to, nullptr, nullptr);\n+    hb_draw_funcs_set_quadratic_to_func (funcs, hb_outline_recording_pen_quadratic_to, nullptr, nullptr);\n+    hb_draw_funcs_set_cubic_to_func (funcs, hb_outline_recording_pen_cubic_to, nullptr, nullptr);\n+    hb_draw_funcs_set_close_path_func (funcs, hb_outline_recording_pen_close_path, nullptr, nullptr);\n+\n+    hb_draw_funcs_make_immutable (funcs);\n+\n+    hb_atexit (free_static_outline_recording_pen_funcs);\n+\n+    return funcs;\n+  }\n+} static_outline_recording_pen_funcs;\n+\n+static inline\n+void free_static_outline_recording_pen_funcs ()\n+{\n+  static_outline_recording_pen_funcs.free_instance ();\n+}\n+\n+hb_draw_funcs_t *\n+hb_outline_recording_pen_get_funcs ()\n+{\n+  return static_outline_recording_pen_funcs.get_unconst ();\n+}\n+\n+\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-outline.cc","additions":322,"deletions":0,"binary":false,"changes":322,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright © 2023  Behdad Esfahbod\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_OUTLINE_HH\n+#define HB_OUTLINE_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-draw.hh\"\n+\n+\n+struct hb_outline_point_t\n+{\n+  enum class type_t\n+  {\n+    MOVE_TO,\n+    LINE_TO,\n+    QUADRATIC_TO,\n+    CUBIC_TO,\n+  };\n+\n+  hb_outline_point_t (float x, float y, type_t type) :\n+    x (x), y (y), type (type) {}\n+\n+  float x, y;\n+  type_t type;\n+};\n+\n+struct hb_outline_vector_t\n+{\n+  float normalize_len ()\n+  {\n+    float len = hypotf (x, y);\n+    if (len)\n+    {\n+      x \/= len;\n+      y \/= len;\n+    }\n+    return len;\n+  }\n+\n+  float x, y;\n+};\n+\n+struct hb_outline_t\n+{\n+  void reset () { points.shrink (0, false); contours.resize (0); }\n+\n+  HB_INTERNAL void replay (hb_draw_funcs_t *pen, void *pen_data) const;\n+  HB_INTERNAL float area () const;\n+  HB_INTERNAL void embolden (float x_strength, float y_strength,\n+                             float x_shift, float y_shift);\n+\n+  hb_vector_t<hb_outline_point_t> points;\n+  hb_vector_t<unsigned> contours;\n+};\n+\n+HB_INTERNAL hb_draw_funcs_t *\n+hb_outline_recording_pen_get_funcs ();\n+\n+\n+#endif \/* HB_OUTLINE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-outline.hh","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,330 @@\n+\/*\n+ * Copyright © 2022 Behdad Esfahbod\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#ifndef HB_NO_PAINT\n+\n+#include \"hb-paint-extents.hh\"\n+\n+#include \"hb-draw.h\"\n+\n+#include \"hb-machinery.hh\"\n+\n+\n+\/*\n+ * This file implements bounds-extraction as well as boundedness\n+ * computation of COLRv1 fonts as described in:\n+ *\n+ * https:\/\/learn.microsoft.com\/en-us\/typography\/opentype\/spec\/colr#glyph-metrics-and-boundedness\n+ *\/\n+\n+static void\n+hb_paint_extents_push_transform (hb_paint_funcs_t *funcs HB_UNUSED,\n+                                 void *paint_data,\n+                                 float xx, float yx,\n+                                 float xy, float yy,\n+                                 float dx, float dy,\n+                                 void *user_data HB_UNUSED)\n+{\n+  hb_paint_extents_context_t *c = (hb_paint_extents_context_t *) paint_data;\n+\n+  c->push_transform (hb_transform_t {xx, yx, xy, yy, dx, dy});\n+}\n+\n+static void\n+hb_paint_extents_pop_transform (hb_paint_funcs_t *funcs HB_UNUSED,\n+                                void *paint_data,\n+                                void *user_data HB_UNUSED)\n+{\n+  hb_paint_extents_context_t *c = (hb_paint_extents_context_t *) paint_data;\n+\n+  c->pop_transform ();\n+}\n+\n+static void\n+hb_draw_extents_move_to (hb_draw_funcs_t *dfuncs HB_UNUSED,\n+                         void *data,\n+                         hb_draw_state_t *st,\n+                         float to_x, float to_y,\n+                         void *user_data HB_UNUSED)\n+{\n+  hb_extents_t *extents = (hb_extents_t *) data;\n+\n+  extents->add_point (to_x, to_y);\n+}\n+\n+static void\n+hb_draw_extents_line_to (hb_draw_funcs_t *dfuncs HB_UNUSED,\n+                         void *data,\n+                         hb_draw_state_t *st,\n+                         float to_x, float to_y,\n+                         void *user_data HB_UNUSED)\n+{\n+  hb_extents_t *extents = (hb_extents_t *) data;\n+\n+  extents->add_point (to_x, to_y);\n+}\n+\n+static void\n+hb_draw_extents_quadratic_to (hb_draw_funcs_t *dfuncs HB_UNUSED,\n+                              void *data,\n+                              hb_draw_state_t *st,\n+                              float control_x, float control_y,\n+                              float to_x, float to_y,\n+                              void *user_data HB_UNUSED)\n+{\n+  hb_extents_t *extents = (hb_extents_t *) data;\n+\n+  extents->add_point (control_x, control_y);\n+  extents->add_point (to_x, to_y);\n+}\n+\n+static void\n+hb_draw_extents_cubic_to (hb_draw_funcs_t *dfuncs HB_UNUSED,\n+                          void *data,\n+                          hb_draw_state_t *st,\n+                          float control1_x, float control1_y,\n+                          float control2_x, float control2_y,\n+                          float to_x, float to_y,\n+                          void *user_data HB_UNUSED)\n+{\n+  hb_extents_t *extents = (hb_extents_t *) data;\n+\n+  extents->add_point (control1_x, control1_y);\n+  extents->add_point (control2_x, control2_y);\n+  extents->add_point (to_x, to_y);\n+}\n+\n+static inline void free_static_draw_extents_funcs ();\n+\n+static struct hb_draw_extents_funcs_lazy_loader_t : hb_draw_funcs_lazy_loader_t<hb_draw_extents_funcs_lazy_loader_t>\n+{\n+  static hb_draw_funcs_t *create ()\n+  {\n+    hb_draw_funcs_t *funcs = hb_draw_funcs_create ();\n+\n+    hb_draw_funcs_set_move_to_func (funcs, hb_draw_extents_move_to, nullptr, nullptr);\n+    hb_draw_funcs_set_line_to_func (funcs, hb_draw_extents_line_to, nullptr, nullptr);\n+    hb_draw_funcs_set_quadratic_to_func (funcs, hb_draw_extents_quadratic_to, nullptr, nullptr);\n+    hb_draw_funcs_set_cubic_to_func (funcs, hb_draw_extents_cubic_to, nullptr, nullptr);\n+\n+    hb_draw_funcs_make_immutable (funcs);\n+\n+    hb_atexit (free_static_draw_extents_funcs);\n+\n+    return funcs;\n+  }\n+} static_draw_extents_funcs;\n+\n+static inline\n+void free_static_draw_extents_funcs ()\n+{\n+  static_draw_extents_funcs.free_instance ();\n+}\n+\n+static hb_draw_funcs_t *\n+hb_draw_extents_get_funcs ()\n+{\n+  return static_draw_extents_funcs.get_unconst ();\n+}\n+\n+static void\n+hb_paint_extents_push_clip_glyph (hb_paint_funcs_t *funcs HB_UNUSED,\n+                                  void *paint_data,\n+                                  hb_codepoint_t glyph,\n+                                  hb_font_t *font,\n+                                  void *user_data HB_UNUSED)\n+{\n+  hb_paint_extents_context_t *c = (hb_paint_extents_context_t *) paint_data;\n+\n+  hb_extents_t extents;\n+  hb_draw_funcs_t *draw_extent_funcs = hb_draw_extents_get_funcs ();\n+  hb_font_draw_glyph (font, glyph, draw_extent_funcs, &extents);\n+  c->push_clip (extents);\n+}\n+\n+static void\n+hb_paint_extents_push_clip_rectangle (hb_paint_funcs_t *funcs HB_UNUSED,\n+                                      void *paint_data,\n+                                      float xmin, float ymin, float xmax, float ymax,\n+                                      void *user_data)\n+{\n+  hb_paint_extents_context_t *c = (hb_paint_extents_context_t *) paint_data;\n+\n+  hb_extents_t extents = {xmin, ymin, xmax, ymax};\n+  c->push_clip (extents);\n+}\n+\n+static void\n+hb_paint_extents_pop_clip (hb_paint_funcs_t *funcs HB_UNUSED,\n+                           void *paint_data,\n+                           void *user_data HB_UNUSED)\n+{\n+  hb_paint_extents_context_t *c = (hb_paint_extents_context_t *) paint_data;\n+\n+  c->pop_clip ();\n+}\n+\n+static void\n+hb_paint_extents_push_group (hb_paint_funcs_t *funcs HB_UNUSED,\n+                             void *paint_data,\n+                             void *user_data HB_UNUSED)\n+{\n+  hb_paint_extents_context_t *c = (hb_paint_extents_context_t *) paint_data;\n+\n+  c->push_group ();\n+}\n+\n+static void\n+hb_paint_extents_pop_group (hb_paint_funcs_t *funcs HB_UNUSED,\n+                            void *paint_data,\n+                            hb_paint_composite_mode_t mode,\n+                            void *user_data HB_UNUSED)\n+{\n+  hb_paint_extents_context_t *c = (hb_paint_extents_context_t *) paint_data;\n+\n+  c->pop_group (mode);\n+}\n+\n+static hb_bool_t\n+hb_paint_extents_paint_image (hb_paint_funcs_t *funcs HB_UNUSED,\n+                              void *paint_data,\n+                              hb_blob_t *blob HB_UNUSED,\n+                              unsigned int width HB_UNUSED,\n+                              unsigned int height HB_UNUSED,\n+                              hb_tag_t format HB_UNUSED,\n+                              float slant HB_UNUSED,\n+                              hb_glyph_extents_t *glyph_extents,\n+                              void *user_data HB_UNUSED)\n+{\n+  hb_paint_extents_context_t *c = (hb_paint_extents_context_t *) paint_data;\n+\n+  hb_extents_t extents = {(float) glyph_extents->x_bearing,\n+                          (float) glyph_extents->y_bearing + glyph_extents->height,\n+                          (float) glyph_extents->x_bearing + glyph_extents->width,\n+                          (float) glyph_extents->y_bearing};\n+  c->push_clip (extents);\n+  c->paint ();\n+  c->pop_clip ();\n+\n+  return true;\n+}\n+\n+static void\n+hb_paint_extents_paint_color (hb_paint_funcs_t *funcs HB_UNUSED,\n+                              void *paint_data,\n+                              hb_bool_t use_foreground HB_UNUSED,\n+                              hb_color_t color HB_UNUSED,\n+                              void *user_data HB_UNUSED)\n+{\n+  hb_paint_extents_context_t *c = (hb_paint_extents_context_t *) paint_data;\n+\n+  c->paint ();\n+}\n+\n+static void\n+hb_paint_extents_paint_linear_gradient (hb_paint_funcs_t *funcs HB_UNUSED,\n+                                        void *paint_data,\n+                                        hb_color_line_t *color_line HB_UNUSED,\n+                                        float x0 HB_UNUSED, float y0 HB_UNUSED,\n+                                        float x1 HB_UNUSED, float y1 HB_UNUSED,\n+                                        float x2 HB_UNUSED, float y2 HB_UNUSED,\n+                                        void *user_data HB_UNUSED)\n+{\n+  hb_paint_extents_context_t *c = (hb_paint_extents_context_t *) paint_data;\n+\n+  c->paint ();\n+}\n+\n+static void\n+hb_paint_extents_paint_radial_gradient (hb_paint_funcs_t *funcs HB_UNUSED,\n+                                        void *paint_data,\n+                                        hb_color_line_t *color_line HB_UNUSED,\n+                                        float x0 HB_UNUSED, float y0 HB_UNUSED, float r0 HB_UNUSED,\n+                                        float x1 HB_UNUSED, float y1 HB_UNUSED, float r1 HB_UNUSED,\n+                                        void *user_data HB_UNUSED)\n+{\n+  hb_paint_extents_context_t *c = (hb_paint_extents_context_t *) paint_data;\n+\n+  c->paint ();\n+}\n+\n+static void\n+hb_paint_extents_paint_sweep_gradient (hb_paint_funcs_t *funcs HB_UNUSED,\n+                                       void *paint_data,\n+                                       hb_color_line_t *color_line HB_UNUSED,\n+                                       float cx HB_UNUSED, float cy HB_UNUSED,\n+                                       float start_angle HB_UNUSED,\n+                                       float end_angle HB_UNUSED,\n+                                       void *user_data HB_UNUSED)\n+{\n+  hb_paint_extents_context_t *c = (hb_paint_extents_context_t *) paint_data;\n+\n+  c->paint ();\n+}\n+\n+static inline void free_static_paint_extents_funcs ();\n+\n+static struct hb_paint_extents_funcs_lazy_loader_t : hb_paint_funcs_lazy_loader_t<hb_paint_extents_funcs_lazy_loader_t>\n+{\n+  static hb_paint_funcs_t *create ()\n+  {\n+    hb_paint_funcs_t *funcs = hb_paint_funcs_create ();\n+\n+    hb_paint_funcs_set_push_transform_func (funcs, hb_paint_extents_push_transform, nullptr, nullptr);\n+    hb_paint_funcs_set_pop_transform_func (funcs, hb_paint_extents_pop_transform, nullptr, nullptr);\n+    hb_paint_funcs_set_push_clip_glyph_func (funcs, hb_paint_extents_push_clip_glyph, nullptr, nullptr);\n+    hb_paint_funcs_set_push_clip_rectangle_func (funcs, hb_paint_extents_push_clip_rectangle, nullptr, nullptr);\n+    hb_paint_funcs_set_pop_clip_func (funcs, hb_paint_extents_pop_clip, nullptr, nullptr);\n+    hb_paint_funcs_set_push_group_func (funcs, hb_paint_extents_push_group, nullptr, nullptr);\n+    hb_paint_funcs_set_pop_group_func (funcs, hb_paint_extents_pop_group, nullptr, nullptr);\n+    hb_paint_funcs_set_color_func (funcs, hb_paint_extents_paint_color, nullptr, nullptr);\n+    hb_paint_funcs_set_image_func (funcs, hb_paint_extents_paint_image, nullptr, nullptr);\n+    hb_paint_funcs_set_linear_gradient_func (funcs, hb_paint_extents_paint_linear_gradient, nullptr, nullptr);\n+    hb_paint_funcs_set_radial_gradient_func (funcs, hb_paint_extents_paint_radial_gradient, nullptr, nullptr);\n+    hb_paint_funcs_set_sweep_gradient_func (funcs, hb_paint_extents_paint_sweep_gradient, nullptr, nullptr);\n+\n+    hb_paint_funcs_make_immutable (funcs);\n+\n+    hb_atexit (free_static_paint_extents_funcs);\n+\n+    return funcs;\n+  }\n+} static_paint_extents_funcs;\n+\n+static inline\n+void free_static_paint_extents_funcs ()\n+{\n+  static_paint_extents_funcs.free_instance ();\n+}\n+\n+hb_paint_funcs_t *\n+hb_paint_extents_get_funcs ()\n+{\n+  return static_paint_extents_funcs.get_unconst ();\n+}\n+\n+\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-paint-extents.cc","additions":330,"deletions":0,"binary":false,"changes":330,"status":"added"},{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ * Copyright © 2022 Behdad Esfahbod\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_PAINT_EXTENTS_HH\n+#define HB_PAINT_EXTENTS_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-paint.h\"\n+\n+\n+typedef struct hb_extents_t\n+{\n+  hb_extents_t () {}\n+  hb_extents_t (float xmin, float ymin, float xmax, float ymax) :\n+    xmin (xmin), ymin (ymin), xmax (xmax), ymax (ymax) {}\n+\n+  bool is_empty () const { return xmin >= xmax || ymin >= ymax; }\n+  bool is_void () const { return xmin > xmax; }\n+\n+  void union_ (const hb_extents_t &o)\n+  {\n+    xmin = hb_min (xmin, o.xmin);\n+    ymin = hb_min (ymin, o.ymin);\n+    xmax = hb_max (xmax, o.xmax);\n+    ymax = hb_max (ymax, o.ymax);\n+  }\n+\n+  void intersect (const hb_extents_t &o)\n+  {\n+    xmin = hb_max (xmin, o.xmin);\n+    ymin = hb_max (ymin, o.ymin);\n+    xmax = hb_min (xmax, o.xmax);\n+    ymax = hb_min (ymax, o.ymax);\n+  }\n+\n+  void\n+  add_point (float x, float y)\n+  {\n+    if (unlikely (is_void ()))\n+    {\n+      xmin = xmax = x;\n+      ymin = ymax = y;\n+    }\n+    else\n+    {\n+      xmin = hb_min (xmin, x);\n+      ymin = hb_min (ymin, y);\n+      xmax = hb_max (xmax, x);\n+      ymax = hb_max (ymax, y);\n+    }\n+  }\n+\n+  float xmin = 0.f;\n+  float ymin = 0.f;\n+  float xmax = -1.f;\n+  float ymax = -1.f;\n+} hb_extents_t;\n+\n+typedef struct hb_transform_t\n+{\n+  hb_transform_t () {}\n+  hb_transform_t (float xx, float yx,\n+                  float xy, float yy,\n+                  float x0, float y0) :\n+    xx (xx), yx (yx), xy (xy), yy (yy), x0 (x0), y0 (y0) {}\n+\n+  void multiply (const hb_transform_t &o)\n+  {\n+    \/* Copied from cairo, with \"o\" being \"a\" there and \"this\" being \"b\" there. *\/\n+    hb_transform_t r;\n+\n+    r.xx = o.xx * xx + o.yx * xy;\n+    r.yx = o.xx * yx + o.yx * yy;\n+\n+    r.xy = o.xy * xx + o.yy * xy;\n+    r.yy = o.xy * yx + o.yy * yy;\n+\n+    r.x0 = o.x0 * xx + o.y0 * xy + x0;\n+    r.y0 = o.x0 * yx + o.y0 * yy + y0;\n+\n+    *this = r;\n+  }\n+\n+  void transform_distance (float &dx, float &dy) const\n+  {\n+    float new_x = xx * dx + xy * dy;\n+    float new_y = yx * dx + yy * dy;\n+    dx = new_x;\n+    dy = new_y;\n+  }\n+\n+  void transform_point (float &x, float &y) const\n+  {\n+    transform_distance (x, y);\n+    x += x0;\n+    y += y0;\n+  }\n+\n+  void transform_extents (hb_extents_t &extents) const\n+  {\n+    float quad_x[4], quad_y[4];\n+\n+    quad_x[0] = extents.xmin;\n+    quad_y[0] = extents.ymin;\n+    quad_x[1] = extents.xmin;\n+    quad_y[1] = extents.ymax;\n+    quad_x[2] = extents.xmax;\n+    quad_y[2] = extents.ymin;\n+    quad_x[3] = extents.xmax;\n+    quad_y[3] = extents.ymax;\n+\n+    extents = hb_extents_t {};\n+    for (unsigned i = 0; i < 4; i++)\n+    {\n+      transform_point (quad_x[i], quad_y[i]);\n+      extents.add_point (quad_x[i], quad_y[i]);\n+    }\n+  }\n+\n+  float xx = 1.f;\n+  float yx = 0.f;\n+  float xy = 0.f;\n+  float yy = 1.f;\n+  float x0 = 0.f;\n+  float y0 = 0.f;\n+} hb_transform_t;\n+\n+typedef struct hb_bounds_t\n+{\n+  enum status_t {\n+    UNBOUNDED,\n+    BOUNDED,\n+    EMPTY,\n+  };\n+\n+  hb_bounds_t (status_t status) : status (status) {}\n+  hb_bounds_t (const hb_extents_t &extents) :\n+    status (extents.is_empty () ? EMPTY : BOUNDED), extents (extents) {}\n+\n+  void union_ (const hb_bounds_t &o)\n+  {\n+    if (o.status == UNBOUNDED)\n+      status = UNBOUNDED;\n+    else if (o.status == BOUNDED)\n+    {\n+      if (status == EMPTY)\n+        *this = o;\n+      else if (status == BOUNDED)\n+        extents.union_ (o.extents);\n+    }\n+  }\n+\n+  void intersect (const hb_bounds_t &o)\n+  {\n+    if (o.status == EMPTY)\n+      status = EMPTY;\n+    else if (o.status == BOUNDED)\n+    {\n+      if (status == UNBOUNDED)\n+        *this = o;\n+      else if (status == BOUNDED)\n+      {\n+        extents.intersect (o.extents);\n+        if (extents.is_empty ())\n+          status = EMPTY;\n+      }\n+    }\n+  }\n+\n+  status_t status;\n+  hb_extents_t extents;\n+} hb_bounds_t;\n+\n+typedef struct  hb_paint_extents_context_t hb_paint_extents_context_t;\n+\n+struct hb_paint_extents_context_t\n+{\n+  hb_paint_extents_context_t ()\n+  {\n+    transforms.push (hb_transform_t{});\n+    clips.push (hb_bounds_t{hb_bounds_t::UNBOUNDED});\n+    groups.push (hb_bounds_t{hb_bounds_t::EMPTY});\n+  }\n+\n+  hb_extents_t get_extents ()\n+  {\n+    return groups.tail().extents;\n+  }\n+\n+  bool is_bounded ()\n+  {\n+    return groups.tail().status != hb_bounds_t::UNBOUNDED;\n+  }\n+\n+  void push_transform (const hb_transform_t &trans)\n+  {\n+    hb_transform_t t = transforms.tail ();\n+    t.multiply (trans);\n+    transforms.push (t);\n+  }\n+\n+  void pop_transform ()\n+  {\n+    transforms.pop ();\n+  }\n+\n+  void push_clip (hb_extents_t extents)\n+  {\n+    \/* Transform extents and push a new clip. *\/\n+    const hb_transform_t &t = transforms.tail ();\n+    t.transform_extents (extents);\n+\n+    clips.push (hb_bounds_t {extents});\n+  }\n+\n+  void pop_clip ()\n+  {\n+    clips.pop ();\n+  }\n+\n+  void push_group ()\n+  {\n+    groups.push (hb_bounds_t {hb_bounds_t::EMPTY});\n+  }\n+\n+  void pop_group (hb_paint_composite_mode_t mode)\n+  {\n+    const hb_bounds_t src_bounds = groups.pop ();\n+    hb_bounds_t &backdrop_bounds = groups.tail ();\n+\n+    \/\/ https:\/\/learn.microsoft.com\/en-us\/typography\/opentype\/spec\/colr#format-32-paintcomposite\n+    switch ((int) mode)\n+    {\n+      case HB_PAINT_COMPOSITE_MODE_CLEAR:\n+        backdrop_bounds.status = hb_bounds_t::EMPTY;\n+        break;\n+      case HB_PAINT_COMPOSITE_MODE_SRC:\n+      case HB_PAINT_COMPOSITE_MODE_SRC_OUT:\n+        backdrop_bounds = src_bounds;\n+        break;\n+      case HB_PAINT_COMPOSITE_MODE_DEST:\n+      case HB_PAINT_COMPOSITE_MODE_DEST_OUT:\n+        break;\n+      case HB_PAINT_COMPOSITE_MODE_SRC_IN:\n+      case HB_PAINT_COMPOSITE_MODE_DEST_IN:\n+        backdrop_bounds.intersect (src_bounds);\n+        break;\n+      default:\n+        backdrop_bounds.union_ (src_bounds);\n+        break;\n+     }\n+  }\n+\n+  void paint ()\n+  {\n+    const hb_bounds_t &clip = clips.tail ();\n+    hb_bounds_t &group = groups.tail ();\n+\n+    group.union_ (clip);\n+  }\n+\n+  protected:\n+  hb_vector_t<hb_transform_t> transforms;\n+  hb_vector_t<hb_bounds_t> clips;\n+  hb_vector_t<hb_bounds_t> groups;\n+};\n+\n+HB_INTERNAL hb_paint_funcs_t *\n+hb_paint_extents_get_funcs ();\n+\n+\n+#endif \/* HB_PAINT_EXTENTS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-paint-extents.hh","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"},{"patch":"@@ -0,0 +1,703 @@\n+\/*\n+ * Copyright © 2022 Matthias Clasen\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#ifndef HB_NO_PAINT\n+\n+#include \"hb-paint.hh\"\n+\n+\/**\n+ * SECTION: hb-paint\n+ * @title: hb-paint\n+ * @short_description: Glyph painting\n+ * @include: hb.h\n+ *\n+ * Functions for painting glyphs.\n+ *\n+ * The main purpose of these functions is to paint (extract) color glyph layers\n+ * from the COLRv1 table, but the API works for drawing ordinary outlines and\n+ * images as well.\n+ *\n+ * The #hb_paint_funcs_t struct can be used with hb_font_paint_glyph().\n+ **\/\n+\n+static void\n+hb_paint_push_transform_nil (hb_paint_funcs_t *funcs, void *paint_data,\n+                             float xx, float yx,\n+                             float xy, float yy,\n+                             float dx, float dy,\n+                             void *user_data) {}\n+\n+static void\n+hb_paint_pop_transform_nil (hb_paint_funcs_t *funcs, void *paint_data,\n+                            void *user_data) {}\n+\n+static void\n+hb_paint_push_clip_glyph_nil (hb_paint_funcs_t *funcs, void *paint_data,\n+                              hb_codepoint_t glyph,\n+                              hb_font_t *font,\n+                              void *user_data) {}\n+\n+static void\n+hb_paint_push_clip_rectangle_nil (hb_paint_funcs_t *funcs, void *paint_data,\n+                                  float xmin, float ymin, float xmax, float ymax,\n+                                  void *user_data) {}\n+\n+static void\n+hb_paint_pop_clip_nil (hb_paint_funcs_t *funcs, void *paint_data,\n+                       void *user_data) {}\n+\n+static void\n+hb_paint_color_nil (hb_paint_funcs_t *funcs, void *paint_data,\n+                    hb_bool_t is_foreground,\n+                    hb_color_t color,\n+                    void *user_data) {}\n+\n+static hb_bool_t\n+hb_paint_image_nil (hb_paint_funcs_t *funcs, void *paint_data,\n+                    hb_blob_t *image,\n+                    unsigned int width,\n+                    unsigned int height,\n+                    hb_tag_t format,\n+                    float slant_xy,\n+                    hb_glyph_extents_t *extents,\n+                    void *user_data) { return false; }\n+\n+static void\n+hb_paint_linear_gradient_nil (hb_paint_funcs_t *funcs, void *paint_data,\n+                              hb_color_line_t *color_line,\n+                              float x0, float y0,\n+                              float x1, float y1,\n+                              float x2, float y2,\n+                              void *user_data) {}\n+\n+static void\n+hb_paint_radial_gradient_nil (hb_paint_funcs_t *funcs, void *paint_data,\n+                              hb_color_line_t *color_line,\n+                              float x0, float y0, float r0,\n+                              float x1, float y1, float r1,\n+                              void *user_data) {}\n+\n+static void\n+hb_paint_sweep_gradient_nil (hb_paint_funcs_t *funcs, void *paint_data,\n+                             hb_color_line_t *color_line,\n+                             float x0, float y0,\n+                             float start_angle,\n+                             float end_angle,\n+                             void *user_data) {}\n+\n+static void\n+hb_paint_push_group_nil (hb_paint_funcs_t *funcs, void *paint_data,\n+                         void *user_data) {}\n+\n+static void\n+hb_paint_pop_group_nil (hb_paint_funcs_t *funcs, void *paint_data,\n+                        hb_paint_composite_mode_t mode,\n+                        void *user_data) {}\n+\n+static hb_bool_t\n+hb_paint_custom_palette_color_nil (hb_paint_funcs_t *funcs, void *paint_data,\n+                                   unsigned int color_index,\n+                                   hb_color_t *color,\n+                                   void *user_data) { return false; }\n+\n+static bool\n+_hb_paint_funcs_set_preamble (hb_paint_funcs_t  *funcs,\n+                             bool                func_is_null,\n+                             void              **user_data,\n+                             hb_destroy_func_t  *destroy)\n+{\n+  if (hb_object_is_immutable (funcs))\n+  {\n+    if (*destroy)\n+      (*destroy) (*user_data);\n+    return false;\n+  }\n+\n+  if (func_is_null)\n+  {\n+    if (*destroy)\n+      (*destroy) (*user_data);\n+    *destroy = nullptr;\n+    *user_data = nullptr;\n+  }\n+\n+  return true;\n+}\n+\n+static bool\n+_hb_paint_funcs_set_middle (hb_paint_funcs_t  *funcs,\n+                            void              *user_data,\n+                            hb_destroy_func_t  destroy)\n+{\n+  if (user_data && !funcs->user_data)\n+  {\n+    funcs->user_data = (decltype (funcs->user_data)) hb_calloc (1, sizeof (*funcs->user_data));\n+    if (unlikely (!funcs->user_data))\n+      goto fail;\n+  }\n+  if (destroy && !funcs->destroy)\n+  {\n+    funcs->destroy = (decltype (funcs->destroy)) hb_calloc (1, sizeof (*funcs->destroy));\n+    if (unlikely (!funcs->destroy))\n+      goto fail;\n+  }\n+\n+  return true;\n+\n+fail:\n+  if (destroy)\n+    (destroy) (user_data);\n+  return false;\n+}\n+\n+#define HB_PAINT_FUNC_IMPLEMENT(name)                                           \\\n+                                                                                \\\n+void                                                                            \\\n+hb_paint_funcs_set_##name##_func (hb_paint_funcs_t         *funcs,              \\\n+                                  hb_paint_##name##_func_t  func,               \\\n+                                  void                     *user_data,          \\\n+                                  hb_destroy_func_t         destroy)            \\\n+{                                                                               \\\n+  if (!_hb_paint_funcs_set_preamble (funcs, !func, &user_data, &destroy))       \\\n+      return;                                                                   \\\n+                                                                                \\\n+  if (funcs->destroy && funcs->destroy->name)                                   \\\n+    funcs->destroy->name (!funcs->user_data ? nullptr : funcs->user_data->name);\\\n+                                                                                \\\n+  if (!_hb_paint_funcs_set_middle (funcs, user_data, destroy))                  \\\n+      return;                                                                   \\\n+                                                                                \\\n+  if (func)                                                                     \\\n+    funcs->func.name = func;                                                    \\\n+  else                                                                          \\\n+    funcs->func.name = hb_paint_##name##_nil;                                   \\\n+                                                                                \\\n+  if (funcs->user_data)                                                         \\\n+    funcs->user_data->name = user_data;                                         \\\n+  if (funcs->destroy)                                                           \\\n+    funcs->destroy->name = destroy;                                             \\\n+}\n+\n+HB_PAINT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_PAINT_FUNC_IMPLEMENT\n+\n+\/**\n+ * hb_paint_funcs_create:\n+ *\n+ * Creates a new #hb_paint_funcs_t structure of paint functions.\n+ *\n+ * The initial reference count of 1 should be released with hb_paint_funcs_destroy()\n+ * when you are done using the #hb_paint_funcs_t. This function never returns\n+ * `NULL`. If memory cannot be allocated, a special singleton #hb_paint_funcs_t\n+ * object will be returned.\n+ *\n+ * Returns value: (transfer full): the paint-functions structure\n+ *\n+ * Since: 7.0.0\n+ *\/\n+hb_paint_funcs_t *\n+hb_paint_funcs_create ()\n+{\n+  hb_paint_funcs_t *funcs;\n+  if (unlikely (!(funcs = hb_object_create<hb_paint_funcs_t> ())))\n+    return const_cast<hb_paint_funcs_t *> (&Null (hb_paint_funcs_t));\n+\n+  funcs->func =  Null (hb_paint_funcs_t).func;\n+\n+  return funcs;\n+}\n+\n+DEFINE_NULL_INSTANCE (hb_paint_funcs_t) =\n+{\n+  HB_OBJECT_HEADER_STATIC,\n+\n+  {\n+#define HB_PAINT_FUNC_IMPLEMENT(name) hb_paint_##name##_nil,\n+    HB_PAINT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_PAINT_FUNC_IMPLEMENT\n+  }\n+};\n+\n+\/**\n+ * hb_paint_funcs_get_empty:\n+ *\n+ * Fetches the singleton empty paint-functions structure.\n+ *\n+ * Return value: (transfer full): The empty paint-functions structure\n+ *\n+ * Since: 7.0.0\n+ **\/\n+hb_paint_funcs_t *\n+hb_paint_funcs_get_empty ()\n+{\n+  return const_cast<hb_paint_funcs_t *> (&Null (hb_paint_funcs_t));\n+}\n+\n+\/**\n+ * hb_paint_funcs_reference: (skip)\n+ * @funcs: The paint-functions structure\n+ *\n+ * Increases the reference count on a paint-functions structure.\n+ *\n+ * This prevents @funcs from being destroyed until a matching\n+ * call to hb_paint_funcs_destroy() is made.\n+ *\n+ * Return value: The paint-functions structure\n+ *\n+ * Since: 7.0.0\n+ *\/\n+hb_paint_funcs_t *\n+hb_paint_funcs_reference (hb_paint_funcs_t *funcs)\n+{\n+  return hb_object_reference (funcs);\n+}\n+\n+\/**\n+ * hb_paint_funcs_destroy: (skip)\n+ * @funcs: The paint-functions structure\n+ *\n+ * Decreases the reference count on a paint-functions structure.\n+ *\n+ * When the reference count reaches zero, the structure\n+ * is destroyed, freeing all memory.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+void\n+hb_paint_funcs_destroy (hb_paint_funcs_t *funcs)\n+{\n+  if (!hb_object_destroy (funcs)) return;\n+\n+  if (funcs->destroy)\n+  {\n+#define HB_PAINT_FUNC_IMPLEMENT(name) \\\n+    if (funcs->destroy->name) funcs->destroy->name (!funcs->user_data ? nullptr : funcs->user_data->name);\n+      HB_PAINT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_PAINT_FUNC_IMPLEMENT\n+  }\n+\n+  hb_free (funcs->destroy);\n+  hb_free (funcs->user_data);\n+  hb_free (funcs);\n+}\n+\n+\/**\n+ * hb_paint_funcs_set_user_data: (skip)\n+ * @funcs: The paint-functions structure\n+ * @key: The user-data key\n+ * @data: A pointer to the user data\n+ * @destroy: (nullable): A callback to call when @data is not needed anymore\n+ * @replace: Whether to replace an existing data with the same key\n+ *\n+ * Attaches a user-data key\/data pair to the specified paint-functions structure.\n+ *\n+ * Return value: `true` if success, `false` otherwise\n+ *\n+ * Since: 7.0.0\n+ **\/\n+hb_bool_t\n+hb_paint_funcs_set_user_data (hb_paint_funcs_t *funcs,\n+                             hb_user_data_key_t *key,\n+                             void *              data,\n+                             hb_destroy_func_t   destroy,\n+                             hb_bool_t           replace)\n+{\n+  return hb_object_set_user_data (funcs, key, data, destroy, replace);\n+}\n+\n+\/**\n+ * hb_paint_funcs_get_user_data: (skip)\n+ * @funcs: The paint-functions structure\n+ * @key: The user-data key to query\n+ *\n+ * Fetches the user-data associated with the specified key,\n+ * attached to the specified paint-functions structure.\n+ *\n+ * Return value: (transfer none): A pointer to the user data\n+ *\n+ * Since: 7.0.0\n+ **\/\n+void *\n+hb_paint_funcs_get_user_data (const hb_paint_funcs_t *funcs,\n+                             hb_user_data_key_t       *key)\n+{\n+  return hb_object_get_user_data (funcs, key);\n+}\n+\n+\/**\n+ * hb_paint_funcs_make_immutable:\n+ * @funcs: The paint-functions structure\n+ *\n+ * Makes a paint-functions structure immutable.\n+ *\n+ * After this call, all attempts to set one of the callbacks\n+ * on @funcs will fail.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+void\n+hb_paint_funcs_make_immutable (hb_paint_funcs_t *funcs)\n+{\n+  if (hb_object_is_immutable (funcs))\n+    return;\n+\n+  hb_object_make_immutable (funcs);\n+}\n+\n+\/**\n+ * hb_paint_funcs_is_immutable:\n+ * @funcs: The paint-functions structure\n+ *\n+ * Tests whether a paint-functions structure is immutable.\n+ *\n+ * Return value: `true` if @funcs is immutable, `false` otherwise\n+ *\n+ * Since: 7.0.0\n+ *\/\n+hb_bool_t\n+hb_paint_funcs_is_immutable (hb_paint_funcs_t *funcs)\n+{\n+  return hb_object_is_immutable (funcs);\n+}\n+\n+\n+\/**\n+ * hb_color_line_get_color_stops:\n+ * @color_line: a #hb_color_line_t object\n+ * @start: the index of the first color stop to return\n+ * @count: (inout) (optional): Input = the maximum number of feature tags to return;\n+ *     Output = the actual number of feature tags returned (may be zero)\n+ * @color_stops: (out) (array length=count) (optional): Array of #hb_color_stop_t to populate\n+ *\n+ * Fetches a list of color stops from the given color line object.\n+ *\n+ * Note that due to variations being applied, the returned color stops\n+ * may be out of order. It is the callers responsibility to ensure that\n+ * color stops are sorted by their offset before they are used.\n+ *\n+ * Return value: the total number of color stops in @color_line\n+ *\n+ * Since: 7.0.0\n+ *\/\n+unsigned int\n+hb_color_line_get_color_stops (hb_color_line_t *color_line,\n+                               unsigned int start,\n+                               unsigned int *count,\n+                               hb_color_stop_t *color_stops)\n+{\n+  return color_line->get_color_stops (color_line,\n+                                      color_line->data,\n+                                      start, count,\n+                                      color_stops,\n+                                      color_line->get_color_stops_user_data);\n+}\n+\n+\/**\n+ * hb_color_line_get_extend:\n+ * @color_line: a #hb_color_line_t object\n+ *\n+ * Fetches the extend mode of the color line object.\n+ *\n+ * Return value: the extend mode of @color_line\n+ *\n+ * Since: 7.0.0\n+ *\/\n+hb_paint_extend_t\n+hb_color_line_get_extend (hb_color_line_t *color_line)\n+{\n+  return color_line->get_extend (color_line,\n+                                 color_line->data,\n+                                 color_line->get_extend_user_data);\n+}\n+\n+\n+\/**\n+ * hb_paint_push_transform:\n+ * @funcs: paint functions\n+ * @paint_data: associated data passed by the caller\n+ * @xx: xx component of the transform matrix\n+ * @yx: yx component of the transform matrix\n+ * @xy: xy component of the transform matrix\n+ * @yy: yy component of the transform matrix\n+ * @dx: dx component of the transform matrix\n+ * @dy: dy component of the transform matrix\n+ *\n+ * Perform a \"push-transform\" paint operation.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+void\n+hb_paint_push_transform (hb_paint_funcs_t *funcs, void *paint_data,\n+                         float xx, float yx,\n+                         float xy, float yy,\n+                         float dx, float dy)\n+{\n+  funcs->push_transform (paint_data, xx, yx, xy, yy, dx, dy);\n+}\n+\n+\/**\n+ * hb_paint_pop_transform:\n+ * @funcs: paint functions\n+ * @paint_data: associated data passed by the caller\n+ *\n+ * Perform a \"pop-transform\" paint operation.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+void\n+hb_paint_pop_transform (hb_paint_funcs_t *funcs, void *paint_data)\n+{\n+  funcs->pop_transform (paint_data);\n+}\n+\n+\/**\n+ * hb_paint_push_clip_glyph:\n+ * @funcs: paint functions\n+ * @paint_data: associated data passed by the caller\n+ * @glyph: the glyph ID\n+ * @font: the font\n+ *\n+ * Perform a \"push-clip-glyph\" paint operation.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+void\n+hb_paint_push_clip_glyph (hb_paint_funcs_t *funcs, void *paint_data,\n+                          hb_codepoint_t glyph,\n+                          hb_font_t *font)\n+{\n+  funcs->push_clip_glyph (paint_data, glyph, font);\n+}\n+\n+\/**\n+ * hb_paint_push_clip_rectangle:\n+ * @funcs: paint functions\n+ * @paint_data: associated data passed by the caller\n+ * @xmin: min X for the rectangle\n+ * @ymin: min Y for the rectangle\n+ * @xmax: max X for the rectangle\n+ * @ymax: max Y for the rectangle\n+ *\n+ * Perform a \"push-clip-rect\" paint operation.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+void\n+hb_paint_push_clip_rectangle (hb_paint_funcs_t *funcs, void *paint_data,\n+                              float xmin, float ymin, float xmax, float ymax)\n+{\n+  funcs->push_clip_rectangle (paint_data, xmin, ymin, xmax, ymax);\n+}\n+\n+\/**\n+ * hb_paint_pop_clip:\n+ * @funcs: paint functions\n+ * @paint_data: associated data passed by the caller\n+ *\n+ * Perform a \"pop-clip\" paint operation.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+void\n+hb_paint_pop_clip (hb_paint_funcs_t *funcs, void *paint_data)\n+{\n+  funcs->pop_clip (paint_data);\n+}\n+\n+\/**\n+ * hb_paint_color:\n+ * @funcs: paint functions\n+ * @paint_data: associated data passed by the caller\n+ * @is_foreground: whether the color is the foreground\n+ * @color: The color to use\n+ *\n+ * Perform a \"color\" paint operation.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+void\n+hb_paint_color (hb_paint_funcs_t *funcs, void *paint_data,\n+                hb_bool_t is_foreground,\n+                hb_color_t color)\n+{\n+  funcs->color (paint_data, is_foreground, color);\n+}\n+\n+\/**\n+ * hb_paint_image:\n+ * @funcs: paint functions\n+ * @paint_data: associated data passed by the caller\n+ * @image: image data\n+ * @width: width of the raster image in pixels, or 0\n+ * @height: height of the raster image in pixels, or 0\n+ * @format: the image format as a tag\n+ * @slant: the synthetic slant ratio to be applied to the image during rendering\n+ * @extents: (nullable): the extents of the glyph\n+ *\n+ * Perform a \"image\" paint operation.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+void\n+hb_paint_image (hb_paint_funcs_t *funcs, void *paint_data,\n+                hb_blob_t *image,\n+                unsigned int width,\n+                unsigned int height,\n+                hb_tag_t format,\n+                float slant,\n+                hb_glyph_extents_t *extents)\n+{\n+  funcs->image (paint_data, image, width, height, format, slant, extents);\n+}\n+\n+\/**\n+ * hb_paint_linear_gradient:\n+ * @funcs: paint functions\n+ * @paint_data: associated data passed by the caller\n+ * @color_line: Color information for the gradient\n+ * @x0: X coordinate of the first point\n+ * @y0: Y coordinate of the first point\n+ * @x1: X coordinate of the second point\n+ * @y1: Y coordinate of the second point\n+ * @x2: X coordinate of the third point\n+ * @y2: Y coordinate of the third point\n+ *\n+ * Perform a \"linear-gradient\" paint operation.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+void\n+hb_paint_linear_gradient (hb_paint_funcs_t *funcs, void *paint_data,\n+                          hb_color_line_t *color_line,\n+                          float x0, float y0,\n+                          float x1, float y1,\n+                          float x2, float y2)\n+{\n+  funcs->linear_gradient (paint_data, color_line, x0, y0, x1, y1, x2, y2);\n+}\n+\n+\/**\n+ * hb_paint_radial_gradient:\n+ * @funcs: paint functions\n+ * @paint_data: associated data passed by the caller\n+ * @color_line: Color information for the gradient\n+ * @x0: X coordinate of the first circle's center\n+ * @y0: Y coordinate of the first circle's center\n+ * @r0: radius of the first circle\n+ * @x1: X coordinate of the second circle's center\n+ * @y1: Y coordinate of the second circle's center\n+ * @r1: radius of the second circle\n+ *\n+ * Perform a \"radial-gradient\" paint operation.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+void\n+hb_paint_radial_gradient (hb_paint_funcs_t *funcs, void *paint_data,\n+                          hb_color_line_t *color_line,\n+                          float x0, float y0, float r0,\n+                          float x1, float y1, float r1)\n+{\n+  funcs->radial_gradient (paint_data, color_line, x0, y0, r0, y1, x1, r1);\n+}\n+\n+\/**\n+ * hb_paint_sweep_gradient:\n+ * @funcs: paint functions\n+ * @paint_data: associated data passed by the caller\n+ * @color_line: Color information for the gradient\n+ * @x0: X coordinate of the circle's center\n+ * @y0: Y coordinate of the circle's center\n+ * @start_angle: the start angle\n+ * @end_angle: the end angle\n+ *\n+ * Perform a \"sweep-gradient\" paint operation.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+void\n+hb_paint_sweep_gradient (hb_paint_funcs_t *funcs, void *paint_data,\n+                         hb_color_line_t *color_line,\n+                         float x0, float y0,\n+                         float start_angle, float end_angle)\n+{\n+  funcs->sweep_gradient (paint_data, color_line, x0, y0, start_angle, end_angle);\n+}\n+\n+\/**\n+ * hb_paint_push_group:\n+ * @funcs: paint functions\n+ * @paint_data: associated data passed by the caller\n+ *\n+ * Perform a \"push-group\" paint operation.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+void\n+hb_paint_push_group (hb_paint_funcs_t *funcs, void *paint_data)\n+{\n+  funcs->push_group (paint_data);\n+}\n+\n+\/**\n+ * hb_paint_pop_group:\n+ * @funcs: paint functions\n+ * @paint_data: associated data passed by the caller\n+ * @mode: the compositing mode to use\n+ *\n+ * Perform a \"pop-group\" paint operation.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+void\n+hb_paint_pop_group (hb_paint_funcs_t *funcs, void *paint_data,\n+                    hb_paint_composite_mode_t mode)\n+{\n+  funcs->pop_group (paint_data, mode);\n+}\n+\n+\/**\n+ * hb_paint_custom_palette_color:\n+ * @funcs: paint functions\n+ * @paint_data: associated data passed by the caller\n+ * @color_index: color index\n+ * @color: (out): fetched color\n+ *\n+ * Gets the custom palette color for @color_index.\n+ *\n+ * Return value: `true` if found, `false` otherwise\n+ *\n+ * Since: 7.0.0\n+ *\/\n+hb_bool_t\n+hb_paint_custom_palette_color (hb_paint_funcs_t *funcs, void *paint_data,\n+                               unsigned int color_index,\n+                               hb_color_t *color)\n+{\n+  return funcs->custom_palette_color (paint_data, color_index, color);\n+}\n+\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-paint.cc","additions":703,"deletions":0,"binary":false,"changes":703,"status":"added"},{"patch":"@@ -0,0 +1,987 @@\n+\/*\n+ * Copyright © 2022 Matthias Clasen\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#if !defined(HB_H_IN) && !defined(HB_NO_SINGLE_HEADER_ERROR)\n+#error \"Include <hb.h> instead.\"\n+#endif\n+\n+#ifndef HB_PAINT_H\n+#define HB_PAINT_H\n+\n+#include \"hb-common.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\n+\/**\n+ * hb_paint_funcs_t:\n+ *\n+ * Glyph paint callbacks.\n+ *\n+ * The callbacks assume that the caller maintains a stack\n+ * of current transforms, clips and intermediate surfaces,\n+ * as evidenced by the pairs of push\/pop callbacks. The\n+ * push\/pop calls will be properly nested, so it is fine\n+ * to store the different kinds of object on a single stack.\n+ *\n+ * Not all callbacks are required for all kinds of glyphs.\n+ * For rendering COLRv0 or non-color outline glyphs, the\n+ * gradient callbacks are not needed, and the composite\n+ * callback only needs to handle simple alpha compositing\n+ * (#HB_PAINT_COMPOSITE_MODE_SRC_OVER).\n+ *\n+ * The paint-image callback is only needed for glyphs\n+ * with image blobs in the CBDT, sbix or SVG tables.\n+ *\n+ * The custom-palette-color callback is only necessary if\n+ * you want to override colors from the font palette with\n+ * custom colors.\n+ *\n+ * Since: 7.0.0\n+ **\/\n+typedef struct hb_paint_funcs_t hb_paint_funcs_t;\n+\n+HB_EXTERN hb_paint_funcs_t *\n+hb_paint_funcs_create (void);\n+\n+HB_EXTERN hb_paint_funcs_t *\n+hb_paint_funcs_get_empty (void);\n+\n+HB_EXTERN hb_paint_funcs_t *\n+hb_paint_funcs_reference (hb_paint_funcs_t *funcs);\n+\n+HB_EXTERN void\n+hb_paint_funcs_destroy (hb_paint_funcs_t *funcs);\n+\n+HB_EXTERN hb_bool_t\n+hb_paint_funcs_set_user_data (hb_paint_funcs_t *funcs,\n+                              hb_user_data_key_t *key,\n+                              void *              data,\n+                              hb_destroy_func_t   destroy,\n+                              hb_bool_t           replace);\n+\n+\n+HB_EXTERN void *\n+hb_paint_funcs_get_user_data (const hb_paint_funcs_t *funcs,\n+                              hb_user_data_key_t       *key);\n+\n+HB_EXTERN void\n+hb_paint_funcs_make_immutable (hb_paint_funcs_t *funcs);\n+\n+HB_EXTERN hb_bool_t\n+hb_paint_funcs_is_immutable (hb_paint_funcs_t *funcs);\n+\n+\/**\n+ * hb_paint_push_transform_func_t:\n+ * @funcs: paint functions object\n+ * @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n+ * @xx: xx component of the transform matrix\n+ * @yx: yx component of the transform matrix\n+ * @xy: xy component of the transform matrix\n+ * @yy: yy component of the transform matrix\n+ * @dx: dx component of the transform matrix\n+ * @dy: dy component of the transform matrix\n+ * @user_data: User data pointer passed to hb_paint_funcs_set_push_transform_func()\n+ *\n+ * A virtual method for the #hb_paint_funcs_t to apply\n+ * a transform to subsequent paint calls.\n+ *\n+ * This transform is applied after the current transform,\n+ * and remains in effect until a matching call to\n+ * the #hb_paint_funcs_pop_transform_func_t vfunc.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef void (*hb_paint_push_transform_func_t) (hb_paint_funcs_t *funcs,\n+                                                void *paint_data,\n+                                                float xx, float yx,\n+                                                float xy, float yy,\n+                                                float dx, float dy,\n+                                                void *user_data);\n+\n+\/**\n+ * hb_paint_pop_transform_func_t:\n+ * @funcs: paint functions object\n+ * @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n+ * @user_data: User data pointer passed to hb_paint_funcs_set_pop_transform_func()\n+ *\n+ * A virtual method for the #hb_paint_funcs_t to undo\n+ * the effect of a prior call to the #hb_paint_funcs_push_transform_func_t\n+ * vfunc.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef void (*hb_paint_pop_transform_func_t) (hb_paint_funcs_t *funcs,\n+                                               void *paint_data,\n+                                               void *user_data);\n+\n+\/**\n+ * hb_paint_push_clip_glyph_func_t:\n+ * @funcs: paint functions object\n+ * @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n+ * @glyph: the glyph ID\n+ * @font: the font\n+ * @user_data: User data pointer passed to hb_paint_funcs_set_push_clip_glyph_func()\n+ *\n+ * A virtual method for the #hb_paint_funcs_t to clip\n+ * subsequent paint calls to the outline of a glyph.\n+ *\n+ * The coordinates of the glyph outline are interpreted according\n+ * to the current transform.\n+ *\n+ * This clip is applied in addition to the current clip,\n+ * and remains in effect until a matching call to\n+ * the #hb_paint_funcs_pop_clip_func_t vfunc.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef void (*hb_paint_push_clip_glyph_func_t) (hb_paint_funcs_t *funcs,\n+                                                 void *paint_data,\n+                                                 hb_codepoint_t glyph,\n+                                                 hb_font_t *font,\n+                                                 void *user_data);\n+\n+\/**\n+ * hb_paint_push_clip_rectangle_func_t:\n+ * @funcs: paint functions object\n+ * @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n+ * @xmin: min X for the rectangle\n+ * @ymin: min Y for the rectangle\n+ * @xmax: max X for the rectangle\n+ * @ymax: max Y for the rectangle\n+ * @user_data: User data pointer passed to hb_paint_funcs_set_push_clip_rectangle_func()\n+ *\n+ * A virtual method for the #hb_paint_funcs_t to clip\n+ * subsequent paint calls to a rectangle.\n+ *\n+ * The coordinates of the rectangle are interpreted according\n+ * to the current transform.\n+ *\n+ * This clip is applied in addition to the current clip,\n+ * and remains in effect until a matching call to\n+ * the #hb_paint_funcs_pop_clip_func_t vfunc.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef void (*hb_paint_push_clip_rectangle_func_t) (hb_paint_funcs_t *funcs,\n+                                                     void *paint_data,\n+                                                     float xmin, float ymin,\n+                                                     float xmax, float ymax,\n+                                                     void *user_data);\n+\n+\/**\n+ * hb_paint_pop_clip_func_t:\n+ * @funcs: paint functions object\n+ * @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n+ * @user_data: User data pointer passed to hb_paint_funcs_set_pop_clip_func()\n+ *\n+ * A virtual method for the #hb_paint_funcs_t to undo\n+ * the effect of a prior call to the #hb_paint_funcs_push_clip_glyph_func_t\n+ * or #hb_paint_funcs_push_clip_rectangle_func_t vfuncs.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef void (*hb_paint_pop_clip_func_t) (hb_paint_funcs_t *funcs,\n+                                          void *paint_data,\n+                                          void *user_data);\n+\n+\/**\n+ * hb_paint_color_func_t:\n+ * @funcs: paint functions object\n+ * @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n+ * @is_foreground: whether the color is the foreground\n+ * @color: The color to use, unpremultiplied\n+ * @user_data: User data pointer passed to hb_paint_funcs_set_color_func()\n+ *\n+ * A virtual method for the #hb_paint_funcs_t to paint a\n+ * color everywhere within the current clip.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef void (*hb_paint_color_func_t) (hb_paint_funcs_t *funcs,\n+                                       void *paint_data,\n+                                       hb_bool_t is_foreground,\n+                                       hb_color_t color,\n+                                       void *user_data);\n+\n+\/**\n+ * HB_PAINT_IMAGE_FORMAT_PNG:\n+ *\n+ * Tag identifying PNG images in #hb_paint_image_func_t callbacks.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+#define HB_PAINT_IMAGE_FORMAT_PNG HB_TAG('p','n','g',' ')\n+\n+\/**\n+ * HB_PAINT_IMAGE_FORMAT_SVG:\n+ *\n+ * Tag identifying SVG images in #hb_paint_image_func_t callbacks.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+#define HB_PAINT_IMAGE_FORMAT_SVG HB_TAG('s','v','g',' ')\n+\n+\/**\n+ * HB_PAINT_IMAGE_FORMAT_BGRA:\n+ *\n+ * Tag identifying raw pixel-data images in #hb_paint_image_func_t callbacks.\n+ * The data is in BGRA pre-multiplied sRGBA color-space format.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+#define HB_PAINT_IMAGE_FORMAT_BGRA HB_TAG('B','G','R','A')\n+\n+\/**\n+ * hb_paint_image_func_t:\n+ * @funcs: paint functions object\n+ * @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n+ * @image: the image data\n+ * @width: width of the raster image in pixels, or 0\n+ * @height: height of the raster image in pixels, or 0\n+ * @format: the image format as a tag\n+ * @slant: the synthetic slant ratio to be applied to the image during rendering\n+ * @extents: (nullable): glyph extents for desired rendering\n+ * @user_data: User data pointer passed to hb_paint_funcs_set_image_func()\n+ *\n+ * A virtual method for the #hb_paint_funcs_t to paint a glyph image.\n+ *\n+ * This method is called for glyphs with image blobs in the CBDT,\n+ * sbix or SVG tables. The @format identifies the kind of data that\n+ * is contained in @image. Possible values include #HB_PAINT_IMAGE_FORMAT_PNG,\n+ * #HB_PAINT_IMAGE_FORMAT_SVG and #HB_PAINT_IMAGE_FORMAT_BGRA.\n+ *\n+ * The image dimensions and glyph extents are provided if available,\n+ * and should be used to size and position the image.\n+ *\n+ * Return value: Whether the operation was successful.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef hb_bool_t (*hb_paint_image_func_t) (hb_paint_funcs_t *funcs,\n+                                            void *paint_data,\n+                                            hb_blob_t *image,\n+                                            unsigned int width,\n+                                            unsigned int height,\n+                                            hb_tag_t format,\n+                                            float slant,\n+                                            hb_glyph_extents_t *extents,\n+                                            void *user_data);\n+\n+\/**\n+ * hb_color_stop_t:\n+ * @offset: the offset of the color stop\n+ * @is_foreground: whether the color is the foreground\n+ * @color: the color, unpremultiplied\n+ *\n+ * Information about a color stop on a color line.\n+ *\n+ * Color lines typically have offsets ranging between 0 and 1,\n+ * but that is not required.\n+ *\n+ * Note: despite @color being unpremultiplied here, interpolation in\n+ * gradients shall happen in premultiplied space. See the OpenType spec\n+ * [COLR](https:\/\/learn.microsoft.com\/en-us\/typography\/opentype\/spec\/colr)\n+ * section for details.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef struct {\n+  float offset;\n+  hb_bool_t is_foreground;\n+  hb_color_t color;\n+} hb_color_stop_t;\n+\n+\/**\n+ * hb_paint_extend_t:\n+ * @HB_PAINT_EXTEND_PAD: Outside the defined interval,\n+ *   the color of the closest color stop is used.\n+ * @HB_PAINT_EXTEND_REPEAT: The color line is repeated over\n+ *   repeated multiples of the defined interval\n+ * @HB_PAINT_EXTEND_REFLECT: The color line is repeated over\n+ *      repeated intervals, as for the repeat mode.\n+ *      However, in each repeated interval, the ordering of\n+ *      color stops is the reverse of the adjacent interval.\n+ *\n+ * The values of this enumeration determine how color values\n+ * outside the minimum and maximum defined offset on a #hb_color_line_t\n+ * are determined.\n+ *\n+ * See the OpenType spec [COLR](https:\/\/learn.microsoft.com\/en-us\/typography\/opentype\/spec\/colr)\n+ * section for details.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef enum {\n+  HB_PAINT_EXTEND_PAD,\n+  HB_PAINT_EXTEND_REPEAT,\n+  HB_PAINT_EXTEND_REFLECT\n+} hb_paint_extend_t;\n+\n+typedef struct hb_color_line_t hb_color_line_t;\n+\n+\/**\n+ * hb_color_line_get_color_stops_func_t:\n+ * @color_line: a #hb_color_line_t object\n+ * @color_line_data: the data accompanying @color_line\n+ * @start: the index of the first color stop to return\n+ * @count: (inout) (optional): Input = the maximum number of feature tags to return;\n+ *     Output = the actual number of feature tags returned (may be zero)\n+ * @color_stops: (out) (array length=count) (optional): Array of #hb_color_stop_t to populate\n+ * @user_data: the data accompanying this method\n+ *\n+ * A virtual method for the #hb_color_line_t to fetch color stops.\n+ *\n+ * Return value: the total number of color stops in @color_line\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef unsigned int (*hb_color_line_get_color_stops_func_t) (hb_color_line_t *color_line,\n+                                                              void *color_line_data,\n+                                                              unsigned int start,\n+                                                              unsigned int *count,\n+                                                              hb_color_stop_t *color_stops,\n+                                                              void *user_data);\n+\n+\/**\n+ * hb_color_line_get_extend_func_t:\n+ * @color_line: a #hb_color_line_t object\n+ * @color_line_data: the data accompanying @color_line\n+ * @user_data: the data accompanying this method\n+ *\n+ * A virtual method for the @hb_color_line_t to fetches the extend mode.\n+ *\n+ * Return value: the extend mode of @color_line\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef hb_paint_extend_t (*hb_color_line_get_extend_func_t) (hb_color_line_t *color_line,\n+                                                              void *color_line_data,\n+                                                              void *user_data);\n+\n+\/**\n+ * hb_color_line_t:\n+ *\n+ * A struct containing color information for a gradient.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+struct hb_color_line_t {\n+  void *data;\n+\n+  hb_color_line_get_color_stops_func_t get_color_stops;\n+  void *get_color_stops_user_data;\n+\n+  hb_color_line_get_extend_func_t get_extend;\n+  void *get_extend_user_data;\n+\n+  void *reserved0;\n+  void *reserved1;\n+  void *reserved2;\n+  void *reserved3;\n+  void *reserved5;\n+  void *reserved6;\n+  void *reserved7;\n+  void *reserved8;\n+};\n+\n+HB_EXTERN unsigned int\n+hb_color_line_get_color_stops (hb_color_line_t *color_line,\n+                               unsigned int start,\n+                               unsigned int *count,\n+                               hb_color_stop_t *color_stops);\n+\n+HB_EXTERN hb_paint_extend_t\n+hb_color_line_get_extend (hb_color_line_t *color_line);\n+\n+\/**\n+ * hb_paint_linear_gradient_func_t:\n+ * @funcs: paint functions object\n+ * @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n+ * @color_line: Color information for the gradient\n+ * @x0: X coordinate of the first point\n+ * @y0: Y coordinate of the first point\n+ * @x1: X coordinate of the second point\n+ * @y1: Y coordinate of the second point\n+ * @x2: X coordinate of the third point\n+ * @y2: Y coordinate of the third point\n+ * @user_data: User data pointer passed to hb_paint_funcs_set_linear_gradient_func()\n+ *\n+ * A virtual method for the #hb_paint_funcs_t to paint a linear\n+ * gradient everywhere within the current clip.\n+ *\n+ * The @color_line object contains information about the colors of the gradients.\n+ * It is only valid for the duration of the callback, you cannot keep it around.\n+ *\n+ * The coordinates of the points are interpreted according\n+ * to the current transform.\n+ *\n+ * See the OpenType spec [COLR](https:\/\/learn.microsoft.com\/en-us\/typography\/opentype\/spec\/colr)\n+ * section for details on how the points define the direction\n+ * of the gradient, and how to interpret the @color_line.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef void (*hb_paint_linear_gradient_func_t) (hb_paint_funcs_t *funcs,\n+                                                 void *paint_data,\n+                                                 hb_color_line_t *color_line,\n+                                                 float x0, float y0,\n+                                                 float x1, float y1,\n+                                                 float x2, float y2,\n+                                                 void *user_data);\n+\n+\/**\n+ * hb_paint_radial_gradient_func_t:\n+ * @funcs: paint functions object\n+ * @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n+ * @color_line: Color information for the gradient\n+ * @x0: X coordinate of the first circle's center\n+ * @y0: Y coordinate of the first circle's center\n+ * @r0: radius of the first circle\n+ * @x1: X coordinate of the second circle's center\n+ * @y1: Y coordinate of the second circle's center\n+ * @r1: radius of the second circle\n+ * @user_data: User data pointer passed to hb_paint_funcs_set_radial_gradient_func()\n+ *\n+ * A virtual method for the #hb_paint_funcs_t to paint a radial\n+ * gradient everywhere within the current clip.\n+ *\n+ * The @color_line object contains information about the colors of the gradients.\n+ * It is only valid for the duration of the callback, you cannot keep it around.\n+ *\n+ * The coordinates of the points are interpreted according\n+ * to the current transform.\n+ *\n+ * See the OpenType spec [COLR](https:\/\/learn.microsoft.com\/en-us\/typography\/opentype\/spec\/colr)\n+ * section for details on how the points define the direction\n+ * of the gradient, and how to interpret the @color_line.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef void (*hb_paint_radial_gradient_func_t) (hb_paint_funcs_t *funcs,\n+                                                 void *paint_data,\n+                                                 hb_color_line_t *color_line,\n+                                                 float x0, float y0, float r0,\n+                                                 float x1, float y1, float r1,\n+                                                 void *user_data);\n+\n+\/**\n+ * hb_paint_sweep_gradient_func_t:\n+ * @funcs: paint functions object\n+ * @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n+ * @color_line: Color information for the gradient\n+ * @x0: X coordinate of the circle's center\n+ * @y0: Y coordinate of the circle's center\n+ * @start_angle: the start angle, in radians\n+ * @end_angle: the end angle, in radians\n+ * @user_data: User data pointer passed to hb_paint_funcs_set_sweep_gradient_func()\n+ *\n+ * A virtual method for the #hb_paint_funcs_t to paint a sweep\n+ * gradient everywhere within the current clip.\n+ *\n+ * The @color_line object contains information about the colors of the gradients.\n+ * It is only valid for the duration of the callback, you cannot keep it around.\n+ *\n+ * The coordinates of the points are interpreted according\n+ * to the current transform.\n+ *\n+ * See the OpenType spec [COLR](https:\/\/learn.microsoft.com\/en-us\/typography\/opentype\/spec\/colr)\n+ * section for details on how the points define the direction\n+ * of the gradient, and how to interpret the @color_line.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef void (*hb_paint_sweep_gradient_func_t)  (hb_paint_funcs_t *funcs,\n+                                                 void *paint_data,\n+                                                 hb_color_line_t *color_line,\n+                                                 float x0, float y0,\n+                                                 float start_angle,\n+                                                 float end_angle,\n+                                                 void *user_data);\n+\n+\/**\n+ * hb_paint_composite_mode_t:\n+ * @HB_PAINT_COMPOSITE_MODE_CLEAR: clear destination layer (bounded)\n+ * @HB_PAINT_COMPOSITE_MODE_SRC: replace destination layer (bounded)\n+ * @HB_PAINT_COMPOSITE_MODE_SRC_OVER: draw source layer on top of destination layer\n+ * (bounded)\n+ * @HB_PAINT_COMPOSITE_MODE_SRC_IN: draw source where there was destination content\n+ * (unbounded)\n+ * @HB_PAINT_COMPOSITE_MODE_SRC_OUT: draw source where there was no destination\n+ * content (unbounded)\n+ * @HB_PAINT_COMPOSITE_MODE_SRC_ATOP: draw source on top of destination content and\n+ * only there\n+ * @HB_PAINT_COMPOSITE_MODE_DEST: ignore the source\n+ * @HB_PAINT_COMPOSITE_MODE_DEST_OVER: draw destination on top of source\n+ * @HB_PAINT_COMPOSITE_MODE_DEST_IN: leave destination only where there was\n+ * source content (unbounded)\n+ * @HB_PAINT_COMPOSITE_MODE_DEST_OUT: leave destination only where there was no\n+ * source content\n+ * @HB_PAINT_COMPOSITE_MODE_DEST_ATOP: leave destination on top of source content\n+ * and only there (unbounded)\n+ * @HB_PAINT_COMPOSITE_MODE_XOR: source and destination are shown where there is only\n+ * one of them\n+ * @HB_PAINT_COMPOSITE_MODE_PLUS: source and destination layers are accumulated\n+ * @HB_PAINT_COMPOSITE_MODE_MULTIPLY: source and destination layers are multiplied.\n+ * This causes the result to be at least as dark as the darker inputs.\n+ * @HB_PAINT_COMPOSITE_MODE_SCREEN: source and destination are complemented and\n+ * multiplied. This causes the result to be at least as light as the lighter\n+ * inputs.\n+ * @HB_PAINT_COMPOSITE_MODE_OVERLAY: multiplies or screens, depending on the\n+ * lightness of the destination color.\n+ * @HB_PAINT_COMPOSITE_MODE_DARKEN: replaces the destination with the source if it\n+ * is darker, otherwise keeps the source.\n+ * @HB_PAINT_COMPOSITE_MODE_LIGHTEN: replaces the destination with the source if it\n+ * is lighter, otherwise keeps the source.\n+ * @HB_PAINT_COMPOSITE_MODE_COLOR_DODGE: brightens the destination color to reflect\n+ * the source color.\n+ * @HB_PAINT_COMPOSITE_MODE_COLOR_BURN: darkens the destination color to reflect\n+ * the source color.\n+ * @HB_PAINT_COMPOSITE_MODE_HARD_LIGHT: Multiplies or screens, dependent on source\n+ * color.\n+ * @HB_PAINT_COMPOSITE_MODE_SOFT_LIGHT: Darkens or lightens, dependent on source\n+ * color.\n+ * @HB_PAINT_COMPOSITE_MODE_DIFFERENCE: Takes the difference of the source and\n+ * destination color.\n+ * @HB_PAINT_COMPOSITE_MODE_EXCLUSION: Produces an effect similar to difference, but\n+ * with lower contrast.\n+ * @HB_PAINT_COMPOSITE_MODE_HSL_HUE: Creates a color with the hue of the source\n+ * and the saturation and luminosity of the target.\n+ * @HB_PAINT_COMPOSITE_MODE_HSL_SATURATION: Creates a color with the saturation\n+ * of the source and the hue and luminosity of the target. Painting with\n+ * this mode onto a gray area produces no change.\n+ * @HB_PAINT_COMPOSITE_MODE_HSL_COLOR: Creates a color with the hue and saturation\n+ * of the source and the luminosity of the target. This preserves the gray\n+ * levels of the target and is useful for coloring monochrome images or\n+ * tinting color images.\n+ * @HB_PAINT_COMPOSITE_MODE_HSL_LUMINOSITY: Creates a color with the luminosity of\n+ * the source and the hue and saturation of the target. This produces an\n+ * inverse effect to @HB_PAINT_COMPOSITE_MODE_HSL_COLOR.\n+ *\n+ * The values of this enumeration describe the compositing modes\n+ * that can be used when combining temporary redirected drawing\n+ * with the backdrop.\n+ *\n+ * See the OpenType spec [COLR](https:\/\/learn.microsoft.com\/en-us\/typography\/opentype\/spec\/colr)\n+ * section for details.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef enum {\n+  HB_PAINT_COMPOSITE_MODE_CLEAR,\n+  HB_PAINT_COMPOSITE_MODE_SRC,\n+  HB_PAINT_COMPOSITE_MODE_DEST,\n+  HB_PAINT_COMPOSITE_MODE_SRC_OVER,\n+  HB_PAINT_COMPOSITE_MODE_DEST_OVER,\n+  HB_PAINT_COMPOSITE_MODE_SRC_IN,\n+  HB_PAINT_COMPOSITE_MODE_DEST_IN,\n+  HB_PAINT_COMPOSITE_MODE_SRC_OUT,\n+  HB_PAINT_COMPOSITE_MODE_DEST_OUT,\n+  HB_PAINT_COMPOSITE_MODE_SRC_ATOP,\n+  HB_PAINT_COMPOSITE_MODE_DEST_ATOP,\n+  HB_PAINT_COMPOSITE_MODE_XOR,\n+  HB_PAINT_COMPOSITE_MODE_PLUS,\n+  HB_PAINT_COMPOSITE_MODE_SCREEN,\n+  HB_PAINT_COMPOSITE_MODE_OVERLAY,\n+  HB_PAINT_COMPOSITE_MODE_DARKEN,\n+  HB_PAINT_COMPOSITE_MODE_LIGHTEN,\n+  HB_PAINT_COMPOSITE_MODE_COLOR_DODGE,\n+  HB_PAINT_COMPOSITE_MODE_COLOR_BURN,\n+  HB_PAINT_COMPOSITE_MODE_HARD_LIGHT,\n+  HB_PAINT_COMPOSITE_MODE_SOFT_LIGHT,\n+  HB_PAINT_COMPOSITE_MODE_DIFFERENCE,\n+  HB_PAINT_COMPOSITE_MODE_EXCLUSION,\n+  HB_PAINT_COMPOSITE_MODE_MULTIPLY,\n+  HB_PAINT_COMPOSITE_MODE_HSL_HUE,\n+  HB_PAINT_COMPOSITE_MODE_HSL_SATURATION,\n+  HB_PAINT_COMPOSITE_MODE_HSL_COLOR,\n+  HB_PAINT_COMPOSITE_MODE_HSL_LUMINOSITY,\n+} hb_paint_composite_mode_t;\n+\n+\/**\n+ * hb_paint_push_group_func_t:\n+ * @funcs: paint functions object\n+ * @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n+ * @user_data: User data pointer passed to hb_paint_funcs_set_push_group_func()\n+ *\n+ * A virtual method for the #hb_paint_funcs_t to use\n+ * an intermediate surface for subsequent paint calls.\n+ *\n+ * The drawing will be redirected to an intermediate surface\n+ * until a matching call to the #hb_paint_funcs_pop_group_func_t\n+ * vfunc.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef void (*hb_paint_push_group_func_t) (hb_paint_funcs_t *funcs,\n+                                            void *paint_data,\n+                                            void *user_data);\n+\n+\/**\n+ * hb_paint_pop_group_func_t:\n+ * @funcs: paint functions object\n+ * @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n+ * @mode: the compositing mode to use\n+ * @user_data: User data pointer passed to hb_paint_funcs_set_pop_group_func()\n+ *\n+ * A virtual method for the #hb_paint_funcs_t to undo\n+ * the effect of a prior call to the #hb_paint_funcs_push_group_func_t\n+ * vfunc.\n+ *\n+ * This call stops the redirection to the intermediate surface,\n+ * and then composites it on the previous surface, using the\n+ * compositing mode passed to this call.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef void (*hb_paint_pop_group_func_t) (hb_paint_funcs_t *funcs,\n+                                           void *paint_data,\n+                                           hb_paint_composite_mode_t mode,\n+                                           void *user_data);\n+\n+\/**\n+ * hb_paint_custom_palette_color_func_t:\n+ * @funcs: paint functions object\n+ * @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n+ * @color_index: the color index\n+ * @color: (out): fetched color\n+ * @user_data: User data pointer passed to hb_paint_funcs_set_pop_group_func()\n+ *\n+ * A virtual method for the #hb_paint_funcs_t to fetch a color from the custom\n+ * color palette.\n+ *\n+ * Custom palette colors override the colors from the fonts selected color\n+ * palette. It is not necessary to override all palette entries; for entries\n+ * that should be taken from the font palette, return `false`.\n+ *\n+ * This function might get called multiple times, but the custom palette is\n+ * expected to remain unchanged for duration of a hb_font_paint_glyph() call.\n+ *\n+ * Return value: `true` if found, `false` otherwise\n+ *\n+ * Since: 7.0.0\n+ *\/\n+typedef hb_bool_t (*hb_paint_custom_palette_color_func_t) (hb_paint_funcs_t *funcs,\n+                                                           void *paint_data,\n+                                                           unsigned int color_index,\n+                                                           hb_color_t *color,\n+                                                           void *user_data);\n+\n+\n+\/**\n+ * hb_paint_funcs_set_push_transform_func:\n+ * @funcs: A paint functions struct\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The push-transform callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): Function to call when @user_data is no longer needed\n+ *\n+ * Sets the push-transform callback on the paint functions struct.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+HB_EXTERN void\n+hb_paint_funcs_set_push_transform_func (hb_paint_funcs_t               *funcs,\n+                                        hb_paint_push_transform_func_t  func,\n+                                        void                           *user_data,\n+                                        hb_destroy_func_t               destroy);\n+\n+\/**\n+ * hb_paint_funcs_set_pop_transform_func:\n+ * @funcs: A paint functions struct\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The pop-transform callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): Function to call when @user_data is no longer needed\n+ *\n+ * Sets the pop-transform callback on the paint functions struct.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+HB_EXTERN void\n+hb_paint_funcs_set_pop_transform_func (hb_paint_funcs_t              *funcs,\n+                                       hb_paint_pop_transform_func_t  func,\n+                                       void                          *user_data,\n+                                       hb_destroy_func_t              destroy);\n+\n+\/**\n+ * hb_paint_funcs_set_push_clip_glyph_func:\n+ * @funcs: A paint functions struct\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The push-clip-glyph callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): Function to call when @user_data is no longer needed\n+ *\n+ * Sets the push-clip-glyph callback on the paint functions struct.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+HB_EXTERN void\n+hb_paint_funcs_set_push_clip_glyph_func (hb_paint_funcs_t                *funcs,\n+                                         hb_paint_push_clip_glyph_func_t  func,\n+                                         void                            *user_data,\n+                                         hb_destroy_func_t                destroy);\n+\n+\/**\n+ * hb_paint_funcs_set_push_clip_rectangle_func:\n+ * @funcs: A paint functions struct\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The push-clip-rectangle callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): Function to call when @user_data is no longer needed\n+ *\n+ * Sets the push-clip-rect callback on the paint functions struct.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+HB_EXTERN void\n+hb_paint_funcs_set_push_clip_rectangle_func (hb_paint_funcs_t                    *funcs,\n+                                             hb_paint_push_clip_rectangle_func_t  func,\n+                                             void                                *user_data,\n+                                             hb_destroy_func_t                    destroy);\n+\n+\/**\n+ * hb_paint_funcs_set_pop_clip_func:\n+ * @funcs: A paint functions struct\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The pop-clip callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): Function to call when @user_data is no longer needed\n+ *\n+ * Sets the pop-clip callback on the paint functions struct.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+HB_EXTERN void\n+hb_paint_funcs_set_pop_clip_func (hb_paint_funcs_t         *funcs,\n+                                  hb_paint_pop_clip_func_t  func,\n+                                  void                     *user_data,\n+                                  hb_destroy_func_t         destroy);\n+\n+\/**\n+ * hb_paint_funcs_set_color_func:\n+ * @funcs: A paint functions struct\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The paint-color callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): Function to call when @user_data is no longer needed\n+ *\n+ * Sets the paint-color callback on the paint functions struct.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+HB_EXTERN void\n+hb_paint_funcs_set_color_func (hb_paint_funcs_t      *funcs,\n+                               hb_paint_color_func_t  func,\n+                               void                  *user_data,\n+                               hb_destroy_func_t      destroy);\n+\n+\/**\n+ * hb_paint_funcs_set_image_func:\n+ * @funcs: A paint functions struct\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The paint-image callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): Function to call when @user_data is no longer needed\n+ *\n+ * Sets the paint-image callback on the paint functions struct.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+HB_EXTERN void\n+hb_paint_funcs_set_image_func (hb_paint_funcs_t      *funcs,\n+                               hb_paint_image_func_t  func,\n+                               void                  *user_data,\n+                               hb_destroy_func_t      destroy);\n+\n+\/**\n+ * hb_paint_funcs_set_linear_gradient_func:\n+ * @funcs: A paint functions struct\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The linear-gradient callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): Function to call when @user_data is no longer needed\n+ *\n+ * Sets the linear-gradient callback on the paint functions struct.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+HB_EXTERN void\n+hb_paint_funcs_set_linear_gradient_func (hb_paint_funcs_t                *funcs,\n+                                         hb_paint_linear_gradient_func_t  func,\n+                                         void                            *user_data,\n+                                         hb_destroy_func_t                destroy);\n+\n+\/**\n+ * hb_paint_funcs_set_radial_gradient_func:\n+ * @funcs: A paint functions struct\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The radial-gradient callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): Function to call when @user_data is no longer needed\n+ *\n+ * Sets the radial-gradient callback on the paint functions struct.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+HB_EXTERN void\n+hb_paint_funcs_set_radial_gradient_func (hb_paint_funcs_t                *funcs,\n+                                         hb_paint_radial_gradient_func_t  func,\n+                                         void                            *user_data,\n+                                         hb_destroy_func_t                destroy);\n+\n+\/**\n+ * hb_paint_funcs_set_sweep_gradient_func:\n+ * @funcs: A paint functions struct\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The sweep-gradient callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): Function to call when @user_data is no longer needed\n+ *\n+ * Sets the sweep-gradient callback on the paint functions struct.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+HB_EXTERN void\n+hb_paint_funcs_set_sweep_gradient_func (hb_paint_funcs_t               *funcs,\n+                                        hb_paint_sweep_gradient_func_t  func,\n+                                        void                           *user_data,\n+                                        hb_destroy_func_t               destroy);\n+\n+\/**\n+ * hb_paint_funcs_set_push_group_func:\n+ * @funcs: A paint functions struct\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The push-group callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): Function to call when @user_data is no longer needed\n+ *\n+ * Sets the push-group callback on the paint functions struct.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+HB_EXTERN void\n+hb_paint_funcs_set_push_group_func (hb_paint_funcs_t           *funcs,\n+                                    hb_paint_push_group_func_t  func,\n+                                    void                       *user_data,\n+                                    hb_destroy_func_t           destroy);\n+\n+\/**\n+ * hb_paint_funcs_set_pop_group_func:\n+ * @funcs: A paint functions struct\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The pop-group callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): Function to call when @user_data is no longer needed\n+ *\n+ * Sets the pop-group callback on the paint functions struct.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+HB_EXTERN void\n+hb_paint_funcs_set_pop_group_func (hb_paint_funcs_t          *funcs,\n+                                   hb_paint_pop_group_func_t  func,\n+                                   void                       *user_data,\n+                                   hb_destroy_func_t           destroy);\n+\n+\/**\n+ * hb_paint_funcs_set_custom_palette_color_func:\n+ * @funcs: A paint functions struct\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The custom-palette-color callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): Function to call when @user_data is no longer needed\n+ *\n+ * Sets the custom-palette-color callback on the paint functions struct.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+HB_EXTERN void\n+hb_paint_funcs_set_custom_palette_color_func (hb_paint_funcs_t                     *funcs,\n+                                              hb_paint_custom_palette_color_func_t  func,\n+                                              void                                 *user_data,\n+                                              hb_destroy_func_t                     destroy);\n+\/*\n+ * Manual API\n+ *\/\n+\n+HB_EXTERN void\n+hb_paint_push_transform (hb_paint_funcs_t *funcs, void *paint_data,\n+                         float xx, float yx,\n+                         float xy, float yy,\n+                         float dx, float dy);\n+\n+HB_EXTERN void\n+hb_paint_pop_transform (hb_paint_funcs_t *funcs, void *paint_data);\n+\n+HB_EXTERN void\n+hb_paint_push_clip_glyph (hb_paint_funcs_t *funcs, void *paint_data,\n+                          hb_codepoint_t glyph,\n+                          hb_font_t *font);\n+\n+HB_EXTERN void\n+hb_paint_push_clip_rectangle (hb_paint_funcs_t *funcs, void *paint_data,\n+                              float xmin, float ymin,\n+                              float xmax, float ymax);\n+\n+HB_EXTERN void\n+hb_paint_pop_clip (hb_paint_funcs_t *funcs, void *paint_data);\n+\n+HB_EXTERN void\n+hb_paint_color (hb_paint_funcs_t *funcs, void *paint_data,\n+                hb_bool_t is_foreground,\n+                hb_color_t color);\n+\n+HB_EXTERN void\n+hb_paint_image (hb_paint_funcs_t *funcs, void *paint_data,\n+                hb_blob_t *image,\n+                unsigned int width,\n+                unsigned int height,\n+                hb_tag_t format,\n+                float slant,\n+                hb_glyph_extents_t *extents);\n+\n+HB_EXTERN void\n+hb_paint_linear_gradient (hb_paint_funcs_t *funcs, void *paint_data,\n+                          hb_color_line_t *color_line,\n+                          float x0, float y0,\n+                          float x1, float y1,\n+                          float x2, float y2);\n+\n+HB_EXTERN void\n+hb_paint_radial_gradient (hb_paint_funcs_t *funcs, void *paint_data,\n+                          hb_color_line_t *color_line,\n+                          float x0, float y0,\n+                          float r0,\n+                          float x1, float y1,\n+                          float r1);\n+\n+HB_EXTERN void\n+hb_paint_sweep_gradient (hb_paint_funcs_t *funcs, void *paint_data,\n+                         hb_color_line_t *color_line,\n+                         float x0, float y0,\n+                         float start_angle, float end_angle);\n+\n+HB_EXTERN void\n+hb_paint_push_group (hb_paint_funcs_t *funcs, void *paint_data);\n+\n+HB_EXTERN void\n+hb_paint_pop_group (hb_paint_funcs_t *funcs, void *paint_data,\n+                    hb_paint_composite_mode_t mode);\n+\n+HB_EXTERN hb_bool_t\n+hb_paint_custom_palette_color (hb_paint_funcs_t *funcs, void *paint_data,\n+                               unsigned int color_index,\n+                               hb_color_t *color);\n+\n+HB_END_DECLS\n+\n+#endif  \/* HB_PAINT_H *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-paint.h","additions":987,"deletions":0,"binary":false,"changes":987,"status":"added"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * Copyright © 2022 Matthias Clasen\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_PAINT_HH\n+#define HB_PAINT_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-face.hh\"\n+#include \"hb-font.hh\"\n+\n+#define HB_PAINT_FUNCS_IMPLEMENT_CALLBACKS \\\n+  HB_PAINT_FUNC_IMPLEMENT (push_transform) \\\n+  HB_PAINT_FUNC_IMPLEMENT (pop_transform) \\\n+  HB_PAINT_FUNC_IMPLEMENT (push_clip_glyph) \\\n+  HB_PAINT_FUNC_IMPLEMENT (push_clip_rectangle) \\\n+  HB_PAINT_FUNC_IMPLEMENT (pop_clip) \\\n+  HB_PAINT_FUNC_IMPLEMENT (color) \\\n+  HB_PAINT_FUNC_IMPLEMENT (image) \\\n+  HB_PAINT_FUNC_IMPLEMENT (linear_gradient) \\\n+  HB_PAINT_FUNC_IMPLEMENT (radial_gradient) \\\n+  HB_PAINT_FUNC_IMPLEMENT (sweep_gradient) \\\n+  HB_PAINT_FUNC_IMPLEMENT (push_group) \\\n+  HB_PAINT_FUNC_IMPLEMENT (pop_group) \\\n+  HB_PAINT_FUNC_IMPLEMENT (custom_palette_color) \\\n+  \/* ^--- Add new callbacks here *\/\n+\n+struct hb_paint_funcs_t\n+{\n+  hb_object_header_t header;\n+\n+  struct {\n+#define HB_PAINT_FUNC_IMPLEMENT(name) hb_paint_##name##_func_t name;\n+    HB_PAINT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_PAINT_FUNC_IMPLEMENT\n+  } func;\n+\n+  struct {\n+#define HB_PAINT_FUNC_IMPLEMENT(name) void *name;\n+    HB_PAINT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_PAINT_FUNC_IMPLEMENT\n+  } *user_data;\n+\n+  struct {\n+#define HB_PAINT_FUNC_IMPLEMENT(name) hb_destroy_func_t name;\n+    HB_PAINT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_PAINT_FUNC_IMPLEMENT\n+  } *destroy;\n+\n+  void push_transform (void *paint_data,\n+                       float xx, float yx,\n+                       float xy, float yy,\n+                       float dx, float dy)\n+  { func.push_transform (this, paint_data,\n+                         xx, yx, xy, yy, dx, dy,\n+                         !user_data ? nullptr : user_data->push_transform); }\n+  void pop_transform (void *paint_data)\n+  { func.pop_transform (this, paint_data,\n+                        !user_data ? nullptr : user_data->pop_transform); }\n+  void push_clip_glyph (void *paint_data,\n+                        hb_codepoint_t glyph,\n+                        hb_font_t *font)\n+  { func.push_clip_glyph (this, paint_data,\n+                          glyph,\n+                          font,\n+                          !user_data ? nullptr : user_data->push_clip_glyph); }\n+  void push_clip_rectangle (void *paint_data,\n+                           float xmin, float ymin, float xmax, float ymax)\n+  { func.push_clip_rectangle (this, paint_data,\n+                              xmin, ymin, xmax, ymax,\n+                              !user_data ? nullptr : user_data->push_clip_rectangle); }\n+  void pop_clip (void *paint_data)\n+  { func.pop_clip (this, paint_data,\n+                   !user_data ? nullptr : user_data->pop_clip); }\n+  void color (void *paint_data,\n+              hb_bool_t is_foreground,\n+              hb_color_t color)\n+  { func.color (this, paint_data,\n+                is_foreground, color,\n+                !user_data ? nullptr : user_data->color); }\n+  bool image (void *paint_data,\n+              hb_blob_t *image,\n+              unsigned width, unsigned height,\n+              hb_tag_t format,\n+              float slant,\n+              hb_glyph_extents_t *extents)\n+  { return func.image (this, paint_data,\n+                       image, width, height, format, slant, extents,\n+                       !user_data ? nullptr : user_data->image); }\n+  void linear_gradient (void *paint_data,\n+                        hb_color_line_t *color_line,\n+                        float x0, float y0,\n+                        float x1, float y1,\n+                        float x2, float y2)\n+  { func.linear_gradient (this, paint_data,\n+                          color_line, x0, y0, x1, y1, x2, y2,\n+                          !user_data ? nullptr : user_data->linear_gradient); }\n+  void radial_gradient (void *paint_data,\n+                        hb_color_line_t *color_line,\n+                        float x0, float y0, float r0,\n+                        float x1, float y1, float r1)\n+  { func.radial_gradient (this, paint_data,\n+                          color_line, x0, y0, r0, x1, y1, r1,\n+                          !user_data ? nullptr : user_data->radial_gradient); }\n+  void sweep_gradient (void *paint_data,\n+                       hb_color_line_t *color_line,\n+                       float x0, float y0,\n+                       float start_angle,\n+                       float end_angle)\n+  { func.sweep_gradient (this, paint_data,\n+                         color_line, x0, y0, start_angle, end_angle,\n+                         !user_data ? nullptr : user_data->sweep_gradient); }\n+  void push_group (void *paint_data)\n+  { func.push_group (this, paint_data,\n+                     !user_data ? nullptr : user_data->push_group); }\n+  void pop_group (void *paint_data,\n+                  hb_paint_composite_mode_t mode)\n+  { func.pop_group (this, paint_data,\n+                    mode,\n+                    !user_data ? nullptr : user_data->pop_group); }\n+  bool custom_palette_color (void *paint_data,\n+                             unsigned int color_index,\n+                             hb_color_t *color)\n+  { return func.custom_palette_color (this, paint_data,\n+                                      color_index,\n+                                      color,\n+                                      !user_data ? nullptr : user_data->custom_palette_color); }\n+\n+\n+  \/* Internal specializations. *\/\n+\n+  void push_root_transform (void *paint_data,\n+                            const hb_font_t *font)\n+  {\n+    float upem = font->face->get_upem ();\n+    int xscale = font->x_scale, yscale = font->y_scale;\n+    float slant = font->slant_xy;\n+\n+    push_transform (paint_data,\n+                    xscale\/upem, 0, slant * yscale\/upem, yscale\/upem, 0, 0);\n+  }\n+\n+  void push_inverse_root_transform (void *paint_data,\n+                                    hb_font_t *font)\n+  {\n+    float upem = font->face->get_upem ();\n+    int xscale = font->x_scale ? font->x_scale : upem;\n+    int yscale = font->y_scale ? font->y_scale : upem;\n+    float slant = font->slant_xy;\n+\n+    push_transform (paint_data,\n+                    upem\/xscale, 0, -slant * upem\/xscale, upem\/yscale, 0, 0);\n+  }\n+\n+  HB_NODISCARD\n+  bool push_translate (void *paint_data,\n+                       float dx, float dy)\n+  {\n+    if (!dx && !dy)\n+      return false;\n+\n+    push_transform (paint_data,\n+                    1.f, 0.f, 0.f, 1.f, dx, dy);\n+    return true;\n+  }\n+\n+  HB_NODISCARD\n+  bool push_scale (void *paint_data,\n+                   float sx, float sy)\n+  {\n+    if (sx == 1.f && sy == 1.f)\n+      return false;\n+\n+    push_transform (paint_data,\n+                    sx, 0.f, 0.f, sy, 0.f, 0.f);\n+    return true;\n+  }\n+\n+  HB_NODISCARD\n+  bool push_rotate (void *paint_data,\n+                    float a)\n+  {\n+    if (!a)\n+      return false;\n+\n+    float cc = cosf (a * (float) M_PI);\n+    float ss = sinf (a * (float) M_PI);\n+    push_transform (paint_data, cc, ss, -ss, cc, 0.f, 0.f);\n+    return true;\n+  }\n+\n+  HB_NODISCARD\n+  bool push_skew (void *paint_data,\n+                  float sx, float sy)\n+  {\n+    if (!sx && !sy)\n+      return false;\n+\n+    float x = tanf (-sx * (float) M_PI);\n+    float y = tanf (+sy * (float) M_PI);\n+    push_transform (paint_data, 1.f, y, x, 1.f, 0.f, 0.f);\n+    return true;\n+  }\n+};\n+DECLARE_NULL_INSTANCE (hb_paint_funcs_t);\n+\n+\n+#endif \/* HB_PAINT_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-paint.hh","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n-template <typename T, unsigned ChunkLen = 16>\n+template <typename T, unsigned ChunkLen = 32>\n@@ -38,3 +38,1 @@\n-  ~hb_pool_t () { fini (); }\n-\n-  void fini ()\n+  ~hb_pool_t ()\n@@ -44,3 +42,3 @@\n-    for (chunk_t *_ : chunks) hb_free (_);\n-\n-    chunks.fini ();\n+    + hb_iter (chunks)\n+    | hb_apply (hb_free)\n+    ;\n@@ -63,1 +61,1 @@\n-    memset (obj, 0, sizeof (T));\n+    hb_memset (obj, 0, sizeof (T));\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-pool.hh","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -65,2 +65,4 @@\n-    heap.shrink (heap.length - 1);\n-    bubble_down (0);\n+    heap.resize (heap.length - 1);\n+\n+    if (!is_empty ())\n+      bubble_down (0);\n@@ -103,1 +105,1 @@\n-    assert (index <= heap.length);\n+    assert (index < heap.length);\n@@ -115,1 +117,1 @@\n-        && (!has_right || heap[index].first <= heap.arrayZ[right].first))\n+        && (!has_right || heap.arrayZ[index].first <= heap.arrayZ[right].first))\n@@ -131,1 +133,1 @@\n-    assert (index <= heap.length);\n+    assert (index < heap.length);\n@@ -145,2 +147,2 @@\n-    assert (a <= heap.length);\n-    assert (b <= heap.length);\n+    assert (a < heap.length);\n+    assert (b < heap.length);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-priority-queue.hh","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-#include \"hb-priority-queue.hh\"\n-#include \"hb-serialize.hh\"\n@@ -36,0 +34,1 @@\n+#include \"graph\/gsubgpos-graph.hh\"\n@@ -45,0 +44,137 @@\n+struct lookup_size_t\n+{\n+  unsigned lookup_index;\n+  size_t size;\n+  unsigned num_subtables;\n+\n+  static int cmp (const void* a, const void* b)\n+  {\n+    return cmp ((const lookup_size_t*) a,\n+                (const lookup_size_t*) b);\n+  }\n+\n+  static int cmp (const lookup_size_t* a, const lookup_size_t* b)\n+  {\n+    double subtables_per_byte_a = (double) a->num_subtables \/ (double) a->size;\n+    double subtables_per_byte_b = (double) b->num_subtables \/ (double) b->size;\n+    if (subtables_per_byte_a == subtables_per_byte_b) {\n+      return b->lookup_index - a->lookup_index;\n+    }\n+\n+    double cmp = subtables_per_byte_b - subtables_per_byte_a;\n+    if (cmp < 0) return -1;\n+    if (cmp > 0) return 1;\n+    return 0;\n+  }\n+};\n+\n+static inline\n+bool _presplit_subtables_if_needed (graph::gsubgpos_graph_context_t& ext_context)\n+{\n+  \/\/ For each lookup this will check the size of subtables and split them as needed\n+  \/\/ so that no subtable is at risk of overflowing. (where we support splitting for\n+  \/\/ that subtable type).\n+  \/\/\n+  \/\/ TODO(grieger): de-dup newly added nodes as necessary. Probably just want a full de-dup\n+  \/\/                pass after this processing is done. Not super necessary as splits are\n+  \/\/                only done where overflow is likely, so de-dup probably will get undone\n+  \/\/                later anyways.\n+  for (unsigned lookup_index : ext_context.lookups.keys ())\n+  {\n+    graph::Lookup* lookup = ext_context.lookups.get(lookup_index);\n+    if (!lookup->split_subtables_if_needed (ext_context, lookup_index))\n+      return false;\n+  }\n+\n+  return true;\n+}\n+\n+\/*\n+ * Analyze the lookups in a GSUB\/GPOS table and decide if any should be promoted\n+ * to extension lookups.\n+ *\/\n+static inline\n+bool _promote_extensions_if_needed (graph::gsubgpos_graph_context_t& ext_context)\n+{\n+  \/\/ Simple Algorithm (v1, current):\n+  \/\/ 1. Calculate how many bytes each non-extension lookup consumes.\n+  \/\/ 2. Select up to 64k of those to remain as non-extension (greedy, highest subtables per byte first)\n+  \/\/ 3. Promote the rest.\n+  \/\/\n+  \/\/ Advanced Algorithm (v2, not implemented):\n+  \/\/ 1. Perform connected component analysis using lookups as roots.\n+  \/\/ 2. Compute size of each connected component.\n+  \/\/ 3. Select up to 64k worth of connected components to remain as non-extensions.\n+  \/\/    (greedy, highest subtables per byte first)\n+  \/\/ 4. Promote the rest.\n+\n+  \/\/ TODO(garretrieger): support extension demotion, then consider all lookups. Requires advanced algo.\n+  \/\/ TODO(garretrieger): also support extension promotion during iterative resolution phase, then\n+  \/\/                     we can use a less conservative threshold here.\n+  \/\/ TODO(grieger): skip this for the 24 bit case.\n+  if (!ext_context.lookups) return true;\n+\n+  hb_vector_t<lookup_size_t> lookup_sizes;\n+  lookup_sizes.alloc (ext_context.lookups.get_population (), true);\n+\n+  for (unsigned lookup_index : ext_context.lookups.keys ())\n+  {\n+    const graph::Lookup* lookup = ext_context.lookups.get(lookup_index);\n+    hb_set_t visited;\n+    lookup_sizes.push (lookup_size_t {\n+        lookup_index,\n+        ext_context.graph.find_subgraph_size (lookup_index, visited),\n+        lookup->number_of_subtables (),\n+      });\n+  }\n+\n+  lookup_sizes.qsort ();\n+\n+  size_t lookup_list_size = ext_context.graph.vertices_[ext_context.lookup_list_index].table_size ();\n+  size_t l2_l3_size = lookup_list_size; \/\/ Lookup List + Lookups\n+  size_t l3_l4_size = 0; \/\/ Lookups + SubTables\n+  size_t l4_plus_size = 0; \/\/ SubTables + their descendants\n+\n+  \/\/ Start by assuming all lookups are using extension subtables, this size will be removed later\n+  \/\/ if it's decided to not make a lookup extension.\n+  for (auto p : lookup_sizes)\n+  {\n+    unsigned subtables_size = p.num_subtables * 8;\n+    l3_l4_size += subtables_size;\n+    l4_plus_size += subtables_size;\n+  }\n+\n+  bool layers_full = false;\n+  for (auto p : lookup_sizes)\n+  {\n+    const graph::Lookup* lookup = ext_context.lookups.get(p.lookup_index);\n+    if (lookup->is_extension (ext_context.table_tag))\n+      \/\/ already an extension so size is counted by the loop above.\n+      continue;\n+\n+    if (!layers_full)\n+    {\n+      size_t lookup_size = ext_context.graph.vertices_[p.lookup_index].table_size ();\n+      hb_set_t visited;\n+      size_t subtables_size = ext_context.graph.find_subgraph_size (p.lookup_index, visited, 1) - lookup_size;\n+      size_t remaining_size = p.size - subtables_size - lookup_size;\n+\n+      l2_l3_size   += lookup_size;\n+      l3_l4_size   += lookup_size + subtables_size;\n+      l3_l4_size   -= p.num_subtables * 8;\n+      l4_plus_size += subtables_size + remaining_size;\n+\n+      if (l2_l3_size < (1 << 16)\n+          && l3_l4_size < (1 << 16)\n+          && l4_plus_size < (1 << 16)) continue; \/\/ this lookup fits within all layers groups\n+\n+      layers_full = true;\n+    }\n+\n+    if (!ext_context.lookups.get(p.lookup_index)->make_extension (ext_context, p.lookup_index))\n+      return false;\n+  }\n+\n+  return true;\n+}\n+\n@@ -76,1 +212,1 @@\n-      unsigned root = HB_SET_VALUE_INVALID;\n+      uint32_t root = HB_SET_VALUE_INVALID;\n@@ -83,1 +219,1 @@\n-             \"Overflow in space %d (%d roots). Moving %d roots to space %d.\",\n+             \"Overflow in space %u (%u roots). Moving %u roots to space %u.\",\n@@ -111,1 +247,1 @@\n-      if (!sorted_graph.duplicate (r.parent, r.child)) continue;\n+      if (sorted_graph.duplicate (r.parent, r.child) == (unsigned) -1) continue;\n@@ -143,19 +279,6 @@\n-\/*\n- * Attempts to modify the topological sorting of the provided object graph to\n- * eliminate offset overflows in the links between objects of the graph. If a\n- * non-overflowing ordering is found the updated graph is serialized it into the\n- * provided serialization context.\n- *\n- * If necessary the structure of the graph may be modified in ways that do not\n- * affect the functionality of the graph. For example shared objects may be\n- * duplicated.\n- *\n- * For a detailed writeup describing how the algorithm operates see:\n- * docs\/repacker.md\n- *\/\n-template<typename T>\n-inline hb_blob_t*\n-hb_resolve_overflows (const T& packed,\n-                      hb_tag_t table_tag,\n-                      unsigned max_rounds = 20) {\n-  graph_t sorted_graph (packed);\n+inline bool\n+hb_resolve_graph_overflows (hb_tag_t table_tag,\n+                            unsigned max_rounds ,\n+                            bool recalculate_extensions,\n+                            graph_t& sorted_graph \/* IN\/OUT *\/)\n+{\n@@ -163,0 +286,5 @@\n+  if (sorted_graph.in_error ())\n+  {\n+    DEBUG_MSG (SUBSET_REPACK, nullptr, \"Sorted graph in error state after initial sort.\");\n+    return false;\n+  }\n@@ -166,3 +294,1 @@\n-  {\n-    return graph::serialize (sorted_graph);\n-  }\n+    return true;\n@@ -170,0 +296,1 @@\n+  graph::gsubgpos_graph_context_t ext_context (table_tag, sorted_graph);\n@@ -174,0 +301,15 @@\n+    if (recalculate_extensions)\n+    {\n+      DEBUG_MSG (SUBSET_REPACK, nullptr, \"Splitting subtables if needed.\");\n+      if (!_presplit_subtables_if_needed (ext_context)) {\n+        DEBUG_MSG (SUBSET_REPACK, nullptr, \"Subtable splitting failed.\");\n+        return false;\n+      }\n+\n+      DEBUG_MSG (SUBSET_REPACK, nullptr, \"Promoting lookups to extensions if needed.\");\n+      if (!_promote_extensions_if_needed (ext_context)) {\n+        DEBUG_MSG (SUBSET_REPACK, nullptr, \"Extensions promotion failed.\");\n+        return false;\n+      }\n+    }\n+\n@@ -175,1 +317,1 @@\n-    if (sorted_graph.assign_32bit_spaces ())\n+    if (sorted_graph.assign_spaces ())\n@@ -177,0 +319,2 @@\n+    else\n+      sorted_graph.sort_shortest_distance_if_needed ();\n@@ -184,2 +328,2 @@\n-         && round++ < max_rounds) {\n-    DEBUG_MSG (SUBSET_REPACK, nullptr, \"=== Overflow resolution round %d ===\", round);\n+         && round < max_rounds) {\n+    DEBUG_MSG (SUBSET_REPACK, nullptr, \"=== Overflow resolution round %u ===\", round);\n@@ -192,0 +336,3 @@\n+      \/\/ Don't count space isolation towards round limit. Only increment\n+      \/\/ round counter if space isolation made no changes.\n+      round++;\n@@ -205,1 +352,1 @@\n-    return nullptr;\n+    return false;\n@@ -211,0 +358,35 @@\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+\/*\n+ * Attempts to modify the topological sorting of the provided object graph to\n+ * eliminate offset overflows in the links between objects of the graph. If a\n+ * non-overflowing ordering is found the updated graph is serialized it into the\n+ * provided serialization context.\n+ *\n+ * If necessary the structure of the graph may be modified in ways that do not\n+ * affect the functionality of the graph. For example shared objects may be\n+ * duplicated.\n+ *\n+ * For a detailed writeup describing how the algorithm operates see:\n+ * docs\/repacker.md\n+ *\/\n+template<typename T>\n+inline hb_blob_t*\n+hb_resolve_overflows (const T& packed,\n+                      hb_tag_t table_tag,\n+                      unsigned max_rounds = 20,\n+                      bool recalculate_extensions = false) {\n+  graph_t sorted_graph (packed);\n+  if (sorted_graph.in_error ())\n+  {\n+    \/\/ Invalid graph definition.\n+    return nullptr;\n+  }\n+\n+  if (!sorted_graph.is_fully_connected ())\n+  {\n+    sorted_graph.print_orphaned_nodes ();\n@@ -214,0 +396,11 @@\n+  if (sorted_graph.in_error ())\n+  {\n+    \/\/ Allocations failed somewhere\n+    DEBUG_MSG (SUBSET_REPACK, nullptr,\n+               \"Graph is in error, likely due to a memory allocation error.\");\n+    return nullptr;\n+  }\n+\n+  if (!hb_resolve_graph_overflows (table_tag, max_rounds, recalculate_extensions, sorted_graph))\n+    return nullptr;\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-repacker.hh","additions":224,"deletions":31,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -201,1 +201,2 @@\n-    if (unlikely (hb_unsigned_mul_overflows (this->end - this->start, HB_SANITIZE_MAX_OPS_FACTOR)))\n+    unsigned m;\n+    if (unlikely (hb_unsigned_mul_overflows (this->end - this->start, HB_SANITIZE_MAX_OPS_FACTOR, &m)))\n@@ -204,1 +205,1 @@\n-      this->max_ops = hb_clamp ((unsigned) (this->end - this->start) * HB_SANITIZE_MAX_OPS_FACTOR,\n+      this->max_ops = hb_clamp (m,\n@@ -242,1 +243,1 @@\n-                     \" (%d bytes) in [%p..%p] -> %s\",\n+                     \" (%u bytes) in [%p..%p] -> %s\",\n@@ -255,2 +256,3 @@\n-    return !hb_unsigned_mul_overflows (a, b) &&\n-           this->check_range (base, a * b);\n+    unsigned m;\n+    return !hb_unsigned_mul_overflows (a, b, &m) &&\n+           this->check_range (base, m);\n@@ -265,2 +267,3 @@\n-    return !hb_unsigned_mul_overflows (a, b) &&\n-           this->check_range (base, a * b, c);\n+    unsigned m;\n+    return !hb_unsigned_mul_overflows (a, b, &m) &&\n+           this->check_range (base, m, c);\n@@ -308,1 +311,1 @@\n-       \"may_edit(%u) [%p..%p] (%d bytes) in [%p..%p] -> %s\",\n+       \"may_edit(%u) [%p..%p] (%u bytes) in [%p..%p] -> %s\",\n@@ -353,1 +356,1 @@\n-        DEBUG_MSG_FUNC (SANITIZE, start, \"passed first round with %d edits; going for second round\", edit_count);\n+        DEBUG_MSG_FUNC (SANITIZE, start, \"passed first round with %u edits; going for second round\", edit_count);\n@@ -359,1 +362,1 @@\n-          DEBUG_MSG_FUNC (SANITIZE, start, \"requested %d edits in second round; FAILLING\", edit_count);\n+          DEBUG_MSG_FUNC (SANITIZE, start, \"requested %u edits in second round; FAILLING\", edit_count);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-sanitize.hh","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-      real_links.alloc (o.num_real_links);\n+      real_links.alloc (o.num_real_links, true);\n@@ -88,1 +88,1 @@\n-      virtual_links.alloc (o.num_virtual_links);\n+      virtual_links.alloc (o.num_virtual_links, true);\n@@ -142,0 +142,8 @@\n+\n+      HB_INTERNAL static int cmp (const void* a, const void* b)\n+      {\n+        int cmp = ((const link_t*)a)->position - ((const link_t*)b)->position;\n+        if (cmp) return cmp;\n+\n+        return ((const link_t*)a)->objidx - ((const link_t*)b)->objidx;\n+      }\n@@ -189,1 +197,0 @@\n-    object_pool.fini ();\n@@ -219,0 +226,1 @@\n+    this->zerocopy = nullptr;\n@@ -318,1 +326,1 @@\n-    if (unlikely (in_error())) return;\n+    if (unlikely (in_error() && !only_overflow ())) return;\n@@ -321,1 +329,2 @@\n-    revert (obj->head, obj->tail);\n+    revert (zerocopy ? zerocopy : obj->head, obj->tail);\n+    zerocopy = nullptr;\n@@ -339,0 +348,1 @@\n+    assert (obj->head <= obj->tail);\n@@ -340,1 +350,3 @@\n-    head = obj->head; \/* Rewind head. *\/\n+    head = zerocopy ? zerocopy : obj->head; \/* Rewind head. *\/\n+    bool was_zerocopy = zerocopy;\n+    zerocopy = nullptr;\n@@ -350,0 +362,1 @@\n+    uint32_t hash = 0;\n@@ -352,1 +365,2 @@\n-      objidx = packed_map.get (obj);\n+      hash = hb_hash (obj);\n+      objidx = packed_map.get_with_hash (obj, hash);\n@@ -362,1 +376,4 @@\n-    memmove (tail, obj->head, len);\n+    if (was_zerocopy)\n+      assert (tail == obj->head);\n+    else\n+      memmove (tail, obj->head, len);\n@@ -380,1 +397,1 @@\n-    if (share) packed_map.set (obj, objidx);\n+    if (share) packed_map.set_with_hash (obj, hash, objidx);\n@@ -564,0 +581,18 @@\n+  bool start_zerocopy (size_t size)\n+  {\n+    if (unlikely (in_error ())) return false;\n+\n+    if (unlikely (size > INT_MAX || this->tail - this->head < ptrdiff_t (size)))\n+    {\n+      err (HB_SERIALIZE_ERROR_OUT_OF_ROOM);\n+      return false;\n+    }\n+\n+    assert (!this->zerocopy);\n+    this->zerocopy = this->head;\n+\n+    assert (this->current->head == this->head);\n+    this->current->head = this->current->tail = this->head = this->tail - size;\n+    return true;\n+  }\n+\n@@ -565,1 +600,1 @@\n-  Type *allocate_size (size_t size)\n+  Type *allocate_size (size_t size, bool clear = true)\n@@ -574,1 +609,2 @@\n-    hb_memset (this->head, 0, size);\n+    if (clear)\n+      hb_memset (this->head, 0, size);\n@@ -588,1 +624,1 @@\n-    Type *ret = this->allocate_size<Type> (size);\n+    Type *ret = this->allocate_size<Type> (size, false);\n@@ -590,1 +626,1 @@\n-    memcpy (ret, obj, size);\n+    hb_memcpy (ret, obj, size);\n@@ -596,0 +632,7 @@\n+  char *embed (const char *obj, unsigned size)\n+  {\n+    char *ret = this->allocate_size<char> (size, false);\n+    if (unlikely (!ret)) return nullptr;\n+    hb_memcpy (ret, obj, size);\n+    return ret;\n+  }\n@@ -611,1 +654,1 @@\n-   * instead of memcpy(). *\/\n+   * instead of hb_memcpy(). *\/\n@@ -629,1 +672,1 @@\n-  Type *extend_size (Type *obj, size_t size)\n+  Type *extend_size (Type *obj, size_t size, bool clear = true)\n@@ -637,1 +680,1 @@\n-                  !this->allocate_size<Type> (((char *) obj) + size - this->head))) return nullptr;\n+                  !this->allocate_size<Type> (((char *) obj) + size - this->head, clear))) return nullptr;\n@@ -641,2 +684,2 @@\n-  Type *extend_size (Type &obj, size_t size)\n-  { return extend_size (std::addressof (obj), size); }\n+  Type *extend_size (Type &obj, size_t size, bool clear = true)\n+  { return extend_size (std::addressof (obj), size, clear); }\n@@ -671,2 +714,2 @@\n-    memcpy (p, this->start, this->head - this->start);\n-    memcpy (p + (this->head - this->start), this->tail, this->end - this->tail);\n+    hb_memcpy (p, this->start, this->head - this->start);\n+    hb_memcpy (p + (this->head - this->start), this->tail, this->end - this->tail);\n@@ -699,1 +742,1 @@\n-  char *start, *head, *tail, *end;\n+  char *start, *head, *tail, *end, *zerocopy;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-serialize.hh","additions":64,"deletions":21,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"hb-machinery.hh\"\n@@ -78,0 +79,2 @@\n+  void add (const hb_set_digest_bits_pattern_t &o) { mask |= o.mask; }\n+\n@@ -98,1 +101,1 @@\n-      array = (const T *) (stride + (const char *) array);\n+      array = &StructAtOffsetUnaligned<T> ((const void *) array, stride);\n@@ -106,5 +109,1 @@\n-    for (unsigned int i = 0; i < count; i++)\n-    {\n-      add (*array);\n-      array = (const T *) (stride + (const char *) array);\n-    }\n+    add_array (array, count, stride);\n@@ -116,0 +115,3 @@\n+  bool may_have (const hb_set_digest_bits_pattern_t &o) const\n+  { return mask & o.mask; }\n+\n@@ -135,0 +137,6 @@\n+  void add (const hb_set_digest_combiner_t &o)\n+  {\n+    head.add (o.head);\n+    tail.add (o.tail);\n+  }\n+\n@@ -143,3 +151,2 @@\n-    head.add_range (a, b);\n-    tail.add_range (a, b);\n-    return true;\n+    return head.add_range (a, b) &&\n+           tail.add_range (a, b);\n@@ -158,3 +165,2 @@\n-    head.add_sorted_array (array, count, stride);\n-    tail.add_sorted_array (array, count, stride);\n-    return true;\n+    return head.add_sorted_array (array, count, stride) &&\n+           tail.add_sorted_array (array, count, stride);\n@@ -165,0 +171,5 @@\n+  bool may_have (const hb_set_digest_combiner_t &o) const\n+  {\n+    return head.may_have (o.head) && tail.may_have (o.tail);\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-set-digest.hh","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -59,2 +59,0 @@\n-  set->init_shallow ();\n-\n@@ -110,2 +108,0 @@\n-  set->fini_shallow ();\n-\n@@ -125,1 +121,1 @@\n- * Return value: %true if success, %false otherwise\n+ * Return value: `true` if success, `false` otherwise\n@@ -152,1 +148,1 @@\n-hb_set_get_user_data (hb_set_t           *set,\n+hb_set_get_user_data (const hb_set_t     *set,\n@@ -165,1 +161,1 @@\n- * Return value: %true if allocation succeeded, %false otherwise\n+ * Return value: `true` if allocation succeeded, `false` otherwise\n@@ -181,1 +177,1 @@\n- * Return value: Newly-allocated set.\n+ * Return value: (transfer full): Newly-allocated set.\n@@ -189,1 +185,3 @@\n-  if (unlikely (!copy)) return nullptr;\n+  if (unlikely (copy->in_error ()))\n+    return hb_set_get_empty ();\n+\n@@ -215,1 +213,1 @@\n- * Return value: %true if @set is empty\n+ * Return value: `true` if @set is empty\n@@ -232,1 +230,1 @@\n- * Return value: %true if @codepoint is in @set, %false otherwise\n+ * Return value: `true` if @codepoint is in @set, `false` otherwise\n@@ -351,1 +349,1 @@\n- * Return value: %true if the two sets are equal, %false otherwise.\n+ * Return value: `true` if the two sets are equal, `false` otherwise.\n@@ -386,1 +384,1 @@\n- * Return value: %true if the @set is a subset of (or equal to) @larger_set, %false otherwise.\n+ * Return value: `true` if the @set is a subset of (or equal to) @larger_set, `false` otherwise.\n@@ -498,0 +496,16 @@\n+\/**\n+ * hb_set_is_inverted:\n+ * @set: A set\n+ *\n+ * Returns whether the set is inverted.\n+ *\n+ * Return value: `true` if the set is inverted, `false` otherwise\n+ *\n+ * Since: 7.0.0\n+ **\/\n+hb_bool_t\n+hb_set_is_inverted (const hb_set_t *set)\n+{\n+  return set->is_inverted ();\n+}\n+\n@@ -556,1 +570,1 @@\n- * Return value: %true if there was a next value, %false otherwise\n+ * Return value: `true` if there was a next value, `false` otherwise\n@@ -577,1 +591,1 @@\n- * Return value: %true if there was a previous value, %false otherwise\n+ * Return value: `true` if there was a previous value, `false` otherwise\n@@ -600,1 +614,1 @@\n- * Return value: %true if there was a next range, %false otherwise\n+ * Return value: `true` if there was a next range, `false` otherwise\n@@ -624,1 +638,1 @@\n- * Return value: %true if there was a previous range, %false otherwise\n+ * Return value: `true` if there was a previous range, `false` otherwise\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-set.cc","additions":31,"deletions":17,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-hb_set_get_user_data (hb_set_t           *set,\n+hb_set_get_user_data (const hb_set_t     *set,\n@@ -100,0 +100,3 @@\n+HB_EXTERN hb_bool_t\n+hb_set_is_inverted (const hb_set_t *set);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-set.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-  void init_shallow () { s.init (); }\n@@ -66,1 +65,1 @@\n-    init_shallow ();\n+    s.init ();\n@@ -68,1 +67,0 @@\n-  void fini_shallow () { s.fini (); }\n@@ -72,1 +70,1 @@\n-    fini_shallow ();\n+    s.fini ();\n@@ -84,0 +82,1 @@\n+  bool is_inverted () const { return s.is_inverted (); }\n@@ -110,4 +109,2 @@\n-  static constexpr bool SENTINEL = false;\n-  typedef bool value_t;\n-  value_t operator [] (hb_codepoint_t k) const { return get (k); }\n-  bool has (hb_codepoint_t k) const { return (*this)[k] != SENTINEL; }\n+  bool operator [] (hb_codepoint_t k) const { return get (k); }\n+  bool has (hb_codepoint_t k) const { return (*this)[k]; }\n@@ -177,0 +174,5 @@\n+\n+  hb_set_t& operator << (hb_codepoint_t v)\n+  { sparseset::operator<< (v); return *this; }\n+  hb_set_t& operator << (const hb_pair_t<hb_codepoint_t, hb_codepoint_t>& range)\n+  { sparseset::operator<< (range); return *this; }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-set.hh","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#ifndef HB_NO_SHAPER\n+\n@@ -77,1 +79,1 @@\n-    memcpy (features, user_features, num_user_features * sizeof (hb_feature_t));\n+    hb_memcpy (features, user_features, num_user_features * sizeof (hb_feature_t));\n@@ -120,1 +122,1 @@\n-    const hb_shaper_entry_t *shapers = _hb_shapers_get ();\n+    const HB_UNUSED hb_shaper_entry_t *shapers = _hb_shapers_get ();\n@@ -228,1 +230,1 @@\n-                  \"face=%p num_features=%d num_coords=%d shaper_list=%p\",\n+                  \"face=%p num_features=%u num_coords=%u shaper_list=%p\",\n@@ -321,4 +323,0 @@\n-#ifndef HB_NO_OT_SHAPE\n-  shape_plan->ot.fini ();\n-#endif\n-  shape_plan->key.fini ();\n@@ -338,1 +336,1 @@\n- * Return value: %true if success, %false otherwise.\n+ * Return value: `true` if success, `false` otherwise.\n@@ -365,2 +363,2 @@\n-hb_shape_plan_get_user_data (hb_shape_plan_t    *shape_plan,\n-                             hb_user_data_key_t *key)\n+hb_shape_plan_get_user_data (const hb_shape_plan_t *shape_plan,\n+                             hb_user_data_key_t    *key)\n@@ -396,1 +394,1 @@\n-                  \"num_features=%d shaper_func=%p, shaper_name=%s\",\n+                  \"num_features=%u shaper_func=%p, shaper_name=%s\",\n@@ -443,1 +441,1 @@\n- * Return value: %true if success, %false otherwise.\n+ * Return value: `true` if success, `false` otherwise.\n@@ -525,1 +523,1 @@\n-                  \"face=%p num_features=%d shaper_list=%p\",\n+                  \"face=%p num_features=%u shaper_list=%p\",\n@@ -581,0 +579,3 @@\n+\n+\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-shape-plan.cc","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -105,2 +105,2 @@\n-hb_shape_plan_get_user_data (hb_shape_plan_t    *shape_plan,\n-                             hb_user_data_key_t *key);\n+hb_shape_plan_get_user_data (const hb_shape_plan_t *shape_plan,\n+                             hb_user_data_key_t    *key);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-shape-plan.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  HB_INTERNAL void fini () { hb_free ((void *) user_features); }\n+  HB_INTERNAL void fini () { hb_free ((void *) user_features); user_features = nullptr; }\n@@ -67,0 +67,1 @@\n+  ~hb_shape_plan_t () { key.fini (); }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-shape-plan.hh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+#ifndef HB_NO_SHAPER\n+\n@@ -109,1 +111,1 @@\n- *    specified #hb_feature_t or %NULL\n+ *    specified #hb_feature_t or `NULL`\n@@ -111,2 +113,2 @@\n- * @shaper_list: (array zero-terminated=1) (nullable): a %NULL-terminated\n- *    array of shapers to use or %NULL\n+ * @shaper_list: (array zero-terminated=1) (nullable): a `NULL`-terminated\n+ *    array of shapers to use or `NULL`\n@@ -114,1 +116,1 @@\n- * See hb_shape() for details. If @shaper_list is not %NULL, the specified\n+ * See hb_shape() for details. If @shaper_list is not `NULL`, the specified\n@@ -176,1 +178,1 @@\n- *    specified #hb_feature_t or %NULL\n+ *    specified #hb_feature_t or `NULL`\n@@ -180,1 +182,1 @@\n- * positioned glyphs. If @features is not %NULL, it will be used to control the\n+ * positioned glyphs. If @features is not `NULL`, it will be used to control the\n@@ -195,0 +197,3 @@\n+\n+\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-shape.cc","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    memcpy (shapers, _hb_all_shapers, sizeof (_hb_all_shapers));\n+    hb_memcpy (shapers, _hb_all_shapers, sizeof (_hb_all_shapers));\n@@ -67,1 +67,1 @@\n-      for (unsigned int j = i; j < ARRAY_LENGTH (_hb_all_shapers); j++)\n+      for (unsigned int j = i; j < ARRAY_LENGTH_CONST (_hb_all_shapers); j++)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-shaper.cc","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"OT\/Color\/COLR\/COLR.hh\"\n@@ -41,1 +42,0 @@\n-#include \"hb-ot-name-language-static.hh\"\n@@ -49,1 +49,2 @@\n-DEFINE_NULL_NAMESPACE_BYTES (OT, RangeRecord) = {0x00,0x01, 0x00,0x00, 0x00, 0x00};\n+DEFINE_NULL_NAMESPACE_BYTES (OT, RangeRecord) = {0x01};\n+DEFINE_NULL_NAMESPACE_BYTES (OT, ClipRecord) = {0x01};\n@@ -52,2 +53,1 @@\n-\/* Hand-coded because Lookup is a template.  Sad. *\/\n-const unsigned char _hb_Null_AAT_Lookup[2] = {0xFF, 0xFF};\n+DEFINE_NULL_NAMESPACE_BYTES (AAT, Lookup) = {0xFF,0xFF};\n@@ -62,1 +62,1 @@\n-#ifndef HB_NO_BORING_EXPANSION\n+#ifndef HB_NO_BEYOND_64K\n@@ -92,1 +92,1 @@\n-#ifndef HB_NO_BORING_EXPANSION\n+#ifndef HB_NO_BEYOND_64K\n@@ -98,1 +98,1 @@\n-  num_glyphs.set_relaxed (ret);\n+  num_glyphs = ret;\n@@ -106,1 +106,1 @@\n-  upem.set_relaxed (ret);\n+  upem = ret;\n@@ -111,32 +111,0 @@\n-\/* hb_user_data_array_t *\/\n-\n-bool\n-hb_user_data_array_t::set (hb_user_data_key_t *key,\n-                           void *              data,\n-                           hb_destroy_func_t   destroy,\n-                           hb_bool_t           replace)\n-{\n-  if (!key)\n-    return false;\n-\n-  if (replace) {\n-    if (!data && !destroy) {\n-      items.remove (key, lock);\n-      return true;\n-    }\n-  }\n-  hb_user_data_item_t item = {key, data, destroy};\n-  bool ret = !!items.replace_or_insert (item, lock, (bool) replace);\n-\n-  return ret;\n-}\n-\n-void *\n-hb_user_data_array_t::get (hb_user_data_key_t *key)\n-{\n-  hb_user_data_item_t item = {nullptr, nullptr, nullptr};\n-\n-  return items.find (key, &item, lock) ? item.data : nullptr;\n-}\n-\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-static.cc","additions":8,"deletions":40,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright © 2022  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger\n+ *\/\n+\n+#ifndef HB_SUBSET_ACCELERATOR_HH\n+#define HB_SUBSET_ACCELERATOR_HH\n+\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-map.hh\"\n+#include \"hb-multimap.hh\"\n+#include \"hb-set.hh\"\n+\n+extern HB_INTERNAL hb_user_data_key_t _hb_subset_accelerator_user_data_key;\n+\n+namespace CFF {\n+struct cff_subset_accelerator_t;\n+}\n+\n+namespace OT {\n+struct SubtableUnicodesCache;\n+};\n+\n+struct hb_subset_accelerator_t\n+{\n+  static hb_user_data_key_t* user_data_key()\n+  {\n+    return &_hb_subset_accelerator_user_data_key;\n+  }\n+\n+  static hb_subset_accelerator_t* create(const hb_map_t& unicode_to_gid_,\n+                                         const hb_multimap_t gid_to_unicodes_,\n+                                         const hb_set_t& unicodes_,\n+                                         bool has_seac_) {\n+    hb_subset_accelerator_t* accel =\n+        (hb_subset_accelerator_t*) hb_calloc (1, sizeof(hb_subset_accelerator_t));\n+\n+    new (accel) hb_subset_accelerator_t (unicode_to_gid_,\n+                                         gid_to_unicodes_,\n+                                         unicodes_,\n+                                         has_seac_);\n+\n+    return accel;\n+  }\n+\n+  static void destroy (void* p)\n+  {\n+    if (!p) return;\n+\n+    hb_subset_accelerator_t *accel = (hb_subset_accelerator_t *) p;\n+\n+    accel->~hb_subset_accelerator_t ();\n+\n+    hb_free (accel);\n+  }\n+\n+  hb_subset_accelerator_t (const hb_map_t& unicode_to_gid_,\n+                           const hb_multimap_t& gid_to_unicodes_,\n+                           const hb_set_t& unicodes_,\n+                           bool has_seac_) :\n+    unicode_to_gid(unicode_to_gid_),\n+    gid_to_unicodes (gid_to_unicodes_),\n+    unicodes(unicodes_),\n+    cmap_cache(nullptr),\n+    destroy_cmap_cache(nullptr),\n+    has_seac(has_seac_),\n+    cff_accelerator(nullptr),\n+    destroy_cff_accelerator(nullptr) {}\n+\n+  ~hb_subset_accelerator_t ()\n+  {\n+    if (cff_accelerator && destroy_cff_accelerator)\n+      destroy_cff_accelerator ((void*) cff_accelerator);\n+\n+    if (cmap_cache && destroy_cmap_cache)\n+      destroy_cmap_cache ((void*) cmap_cache);\n+  }\n+\n+  \/\/ Generic\n+\n+  mutable hb_mutex_t sanitized_table_cache_lock;\n+  mutable hb_hashmap_t<hb_tag_t, hb::unique_ptr<hb_blob_t>> sanitized_table_cache;\n+\n+  const hb_map_t unicode_to_gid;\n+  const hb_multimap_t gid_to_unicodes;\n+  const hb_set_t unicodes;\n+\n+  \/\/ cmap\n+  const OT::SubtableUnicodesCache* cmap_cache;\n+  hb_destroy_func_t destroy_cmap_cache;\n+\n+  \/\/ CFF\n+  bool has_seac;\n+  const CFF::cff_subset_accelerator_t* cff_accelerator;\n+  hb_destroy_func_t destroy_cff_accelerator;\n+\n+  \/\/ TODO(garretrieger): cumulative glyf checksum map\n+\n+  bool in_error () const\n+  {\n+    return unicode_to_gid.in_error () ||\n+           gid_to_unicodes.in_error () ||\n+           unicodes.in_error () ||\n+           sanitized_table_cache.in_error ();\n+  }\n+};\n+\n+\n+#endif \/* HB_SUBSET_ACCELERATOR_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-accelerator.hh","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -69,2 +69,1 @@\n-    hb_set_t *set = hb_set_create ();\n-    if (unlikely (set == &Null (hb_set_t))) return false;\n+    hb_set_t set;\n@@ -82,1 +81,1 @@\n-      set->add (fd);\n+      set.add (fd);\n@@ -93,1 +92,1 @@\n-    subset_fd_count = set->get_population ();\n+    subset_fd_count = set.get_population ();\n@@ -98,1 +97,0 @@\n-      hb_set_destroy (set);\n@@ -106,1 +104,1 @@\n-      while (set->next (&fd))\n+      while (set.next (&fd))\n@@ -108,1 +106,0 @@\n-      hb_set_destroy (set);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-cff-common.cc","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-    : buff (buff_), error (false) {}\n+    : buff (buff_) {}\n@@ -47,3 +47,4 @@\n-    buff.push (b);\n-    if (unlikely (buff.in_error ()))\n-      set_error ();\n+    if (likely ((signed) buff.length < buff.allocated))\n+      buff.arrayZ[buff.length++] = b;\n+    else\n+      buff.push (b);\n@@ -83,1 +84,2 @@\n-  void encode_num (const number_t& n)\n+  \/\/ Encode number for CharString\n+  void encode_num_cs (const number_t& n)\n@@ -100,0 +102,85 @@\n+  \/\/ Encode number for TopDict \/ Private\n+  void encode_num_tp (const number_t& n)\n+  {\n+    if (n.in_int_range ())\n+    {\n+      \/\/ TODO longint\n+      encode_int (n.to_int ());\n+    }\n+    else\n+    {\n+      \/\/ Sigh. BCD\n+      \/\/ https:\/\/learn.microsoft.com\/en-us\/typography\/opentype\/spec\/cff2#table-5-nibble-definitions\n+      double v = n.to_real ();\n+      encode_byte (OpCode_BCD);\n+\n+      \/\/ Based on:\n+      \/\/ https:\/\/github.com\/fonttools\/fonttools\/blob\/97ed3a61cde03e17b8be36f866192fbd56f1d1a7\/Lib\/fontTools\/misc\/psCharStrings.py#L265-L294\n+\n+      char buf[16];\n+      \/* FontTools has the following comment:\n+       *\n+       * # Note: 14 decimal digits seems to be the limitation for CFF real numbers\n+       * # in macOS. However, we use 8 here to match the implementation of AFDKO.\n+       *\n+       * We use 8 here to match FontTools X-).\n+       *\/\n+\n+      hb_locale_t clocale HB_UNUSED;\n+      hb_locale_t oldlocale HB_UNUSED;\n+      oldlocale = hb_uselocale (clocale = newlocale (LC_ALL_MASK, \"C\", NULL));\n+      snprintf (buf, sizeof (buf), \"%.8G\", v);\n+      (void) hb_uselocale (((void) freelocale (clocale), oldlocale));\n+\n+      char *s = buf;\n+      if (s[0] == '0' && s[1] == '.')\n+        s++;\n+      else if (s[0] == '-' && s[1] == '0' && s[2] == '.')\n+      {\n+        s[1] = '-';\n+        s++;\n+      }\n+      hb_vector_t<char> nibbles;\n+      while (*s)\n+      {\n+        char c = s[0];\n+        s++;\n+\n+        switch (c)\n+        {\n+          case 'E':\n+          {\n+            char c2 = *s;\n+            if (c2 == '-')\n+            {\n+              s++;\n+              nibbles.push (0x0C); \/\/ E-\n+              continue;\n+            }\n+            if (c2 == '+')\n+              s++;\n+            nibbles.push (0x0B); \/\/ E\n+            continue;\n+          }\n+\n+          case '.': case ',': \/\/ Comma for some European locales in case no uselocale available.\n+            nibbles.push (0x0A); \/\/ .\n+            continue;\n+\n+          case '-':\n+            nibbles.push (0x0E); \/\/ .\n+            continue;\n+        }\n+\n+        nibbles.push (c - '0');\n+      }\n+      nibbles.push (0x0F);\n+      if (nibbles.length % 2)\n+        nibbles.push (0x0F);\n+\n+      unsigned count = nibbles.length;\n+      for (unsigned i = 0; i < count; i += 2)\n+        encode_byte ((nibbles[i] << 4) | nibbles[i+1]);\n+    }\n+  }\n+\n@@ -111,1 +198,1 @@\n-  void copy_str (const hb_ubytes_t &str)\n+  void copy_str (const unsigned char *str, unsigned length)\n@@ -113,10 +200,3 @@\n-    unsigned int  offset = buff.length;\n-    \/* Manually resize buffer since faster. *\/\n-    if ((signed) (buff.length + str.length) <= buff.allocated)\n-      buff.length += str.length;\n-    else if (unlikely (!buff.resize (offset + str.length)))\n-    {\n-      set_error ();\n-      return;\n-    }\n-    memcpy (buff.arrayZ + offset, &str[0], str.length);\n+    assert ((signed) (buff.length + length) <= buff.allocated);\n+    hb_memcpy (buff.arrayZ + buff.length, str, length);\n+    buff.length += length;\n@@ -125,1 +205,1 @@\n-  bool is_error () const { return error; }\n+  bool in_error () const { return buff.in_error (); }\n@@ -128,1 +208,0 @@\n-  void set_error () { error = true; }\n@@ -131,1 +210,0 @@\n-  bool    error;\n@@ -190,1 +268,1 @@\n-      HBUINT8 *d = c->allocate_size<HBUINT8> (opstr.str.length);\n+      unsigned char *d = c->allocate_size<unsigned char> (opstr.length);\n@@ -192,1 +270,4 @@\n-      memcpy (d, &opstr.str[0], opstr.str.length);\n+      \/* Faster than hb_memcpy for small strings. *\/\n+      for (unsigned i = 0; i < opstr.length; i++)\n+        d[i] = opstr.ptr[i];\n+      \/\/hb_memcpy (d, opstr.ptr, opstr.length);\n@@ -198,29 +279,0 @@\n-struct cff_private_dict_op_serializer_t : op_serializer_t\n-{\n-  cff_private_dict_op_serializer_t (bool desubroutinize_, bool drop_hints_)\n-    : desubroutinize (desubroutinize_), drop_hints (drop_hints_) {}\n-\n-  bool serialize (hb_serialize_context_t *c,\n-                  const op_str_t &opstr,\n-                  objidx_t subrs_link) const\n-  {\n-    TRACE_SERIALIZE (this);\n-\n-    if (drop_hints && dict_opset_t::is_hint_op (opstr.op))\n-      return true;\n-    if (opstr.op == OpCode_Subrs)\n-    {\n-      if (desubroutinize || !subrs_link)\n-        return_trace (true);\n-      else\n-        return_trace (FontDict::serialize_link2_op (c, opstr.op, subrs_link));\n-    }\n-    else\n-      return_trace (copy_opstr (c, opstr));\n-  }\n-\n-  protected:\n-  const bool  desubroutinize;\n-  const bool  drop_hints;\n-};\n-\n@@ -231,0 +283,1 @@\n+  const hb_subset_plan_t *plan;\n@@ -242,1 +295,2 @@\n-    if (!flat_charstrings.resize (plan->num_output_glyphs ()))\n+    unsigned count = plan->num_output_glyphs ();\n+    if (!flat_charstrings.resize_exact (count))\n@@ -244,3 +298,1 @@\n-    for (unsigned int i = 0; i < plan->num_output_glyphs (); i++)\n-      flat_charstrings[i].init ();\n-    for (unsigned int i = 0; i < plan->num_output_glyphs (); i++)\n+    for (unsigned int i = 0; i < count; i++)\n@@ -259,1 +311,4 @@\n-      ENV env (str, acc, fd);\n+\n+\n+      ENV env (str, acc, fd,\n+               plan->normalized_coords.arrayZ, plan->normalized_coords.length);\n@@ -262,2 +317,3 @@\n-        flat_charstrings[i],\n-        (bool) (plan->flags & HB_SUBSET_FLAGS_NO_HINTING)\n+        flat_charstrings.arrayZ[i],\n+        (bool) (plan->flags & HB_SUBSET_FLAGS_NO_HINTING),\n+        plan\n@@ -277,1 +333,1 @@\n-  subr_closures_t (unsigned int fd_count) : valid (false), global_closure (), local_closures ()\n+  subr_closures_t (unsigned int fd_count) : global_closure (), local_closures ()\n@@ -279,3 +335,1 @@\n-    valid = true;\n-    if (!local_closures.resize (fd_count))\n-      valid = false;\n+    local_closures.resize_exact (fd_count);\n@@ -291,2 +345,1 @@\n-  bool is_valid () const { return valid; }\n-  bool  valid;\n+  bool in_error () const { return local_closures.in_error (); }\n@@ -299,13 +352,2 @@\n-  void init (unsigned int subr_num_ = 0)\n-  {\n-    subr_num = subr_num_;\n-    drop_flag = false;\n-    keep_flag = false;\n-    skip_flag = false;\n-  }\n-\n-  bool for_drop () const { return drop_flag; }\n-  void set_drop ()       { if (!for_keep ()) drop_flag = true; }\n-\n-  bool for_keep () const { return keep_flag; }\n-  void set_keep ()       { keep_flag = true; }\n+  parsed_cs_op_t (unsigned int subr_num_ = 0) :\n+    subr_num (subr_num_) {}\n@@ -313,2 +355,2 @@\n-  bool for_skip () const { return skip_flag; }\n-  void set_skip ()       { skip_flag = true; }\n+  bool is_hinting () const { return hinting_flag; }\n+  void set_hinting ()       { hinting_flag = true; }\n@@ -316,1 +358,2 @@\n-  unsigned int  subr_num;\n+  \/* The layout of this struct is designed to fit within the\n+   * padding of op_str_t! *\/\n@@ -319,3 +362,4 @@\n-  bool    drop_flag;\n-  bool    keep_flag;\n-  bool    skip_flag;\n+  bool    hinting_flag = false;\n+\n+  public:\n+  uint16_t subr_num;\n@@ -326,1 +370,5 @@\n-  void init ()\n+  parsed_cs_str_t () :\n+    parsed (false),\n+    hint_dropped (false),\n+    has_prefix_ (false),\n+    has_calls_ (false)\n@@ -329,3 +377,0 @@\n-    parsed = false;\n-    hint_dropped = false;\n-    has_prefix_ = false;\n@@ -344,3 +389,4 @@\n-      unsigned int parsed_len = get_count ();\n-      if (likely (parsed_len > 0))\n-        values[parsed_len-1].set_skip ();\n+      has_calls_ = true;\n+\n+      \/* Pop the subroutine number. *\/\n+      values.pop ();\n@@ -348,3 +394,1 @@\n-      parsed_cs_op_t val;\n-      val.init (subr_num);\n-      SUPER::add_op (op, str_ref, val);\n+      SUPER::add_op (op, str_ref, {subr_num});\n@@ -380,0 +424,31 @@\n+  bool has_calls () const          { return has_calls_; }\n+\n+  void compact ()\n+  {\n+    unsigned count = values.length;\n+    if (!count) return;\n+    auto &opstr = values.arrayZ;\n+    unsigned j = 0;\n+    for (unsigned i = 1; i < count; i++)\n+    {\n+      \/* See if we can combine op j and op i. *\/\n+      bool combine =\n+        (opstr[j].op != OpCode_callsubr && opstr[j].op != OpCode_callgsubr) &&\n+        (opstr[i].op != OpCode_callsubr && opstr[i].op != OpCode_callgsubr) &&\n+        (opstr[j].is_hinting () == opstr[i].is_hinting ()) &&\n+        (opstr[j].ptr + opstr[j].length == opstr[i].ptr) &&\n+        (opstr[j].length + opstr[i].length <= 255);\n+\n+      if (combine)\n+      {\n+        opstr[j].length += opstr[i].length;\n+        opstr[j].op = OpCode_Invalid;\n+      }\n+      else\n+      {\n+        opstr[++j] = opstr[i];\n+      }\n+    }\n+    values.shrink (j + 1);\n+  }\n+\n@@ -381,4 +456,5 @@\n-  bool    parsed;\n-  bool    hint_dropped;\n-  bool    vsindex_dropped;\n-  bool    has_prefix_;\n+  bool    parsed : 1;\n+  bool    hint_dropped : 1;\n+  bool    vsindex_dropped : 1;\n+  bool    has_prefix_ : 1;\n+  bool    has_calls_ : 1;\n@@ -398,0 +474,53 @@\n+struct cff_subset_accelerator_t\n+{\n+  static cff_subset_accelerator_t* create (\n+      hb_blob_t* original_blob,\n+      const parsed_cs_str_vec_t& parsed_charstrings,\n+      const parsed_cs_str_vec_t& parsed_global_subrs,\n+      const hb_vector_t<parsed_cs_str_vec_t>& parsed_local_subrs) {\n+    cff_subset_accelerator_t* accel =\n+        (cff_subset_accelerator_t*) hb_malloc (sizeof(cff_subset_accelerator_t));\n+    new (accel) cff_subset_accelerator_t (original_blob,\n+                                          parsed_charstrings,\n+                                          parsed_global_subrs,\n+                                          parsed_local_subrs);\n+    return accel;\n+  }\n+\n+  static void destroy (void* value) {\n+    if (!value) return;\n+\n+    cff_subset_accelerator_t* accel = (cff_subset_accelerator_t*) value;\n+    accel->~cff_subset_accelerator_t ();\n+    hb_free (accel);\n+  }\n+\n+  cff_subset_accelerator_t(\n+      hb_blob_t* original_blob_,\n+      const parsed_cs_str_vec_t& parsed_charstrings_,\n+      const parsed_cs_str_vec_t& parsed_global_subrs_,\n+      const hb_vector_t<parsed_cs_str_vec_t>& parsed_local_subrs_)\n+  {\n+    parsed_charstrings = parsed_charstrings_;\n+    parsed_global_subrs = parsed_global_subrs_;\n+    parsed_local_subrs = parsed_local_subrs_;\n+\n+    \/\/ the parsed charstrings point to memory in the original CFF table so we must hold a reference\n+    \/\/ to it to keep the memory valid.\n+    original_blob = hb_blob_reference (original_blob_);\n+  }\n+\n+  ~cff_subset_accelerator_t() {\n+    hb_blob_destroy (original_blob);\n+    hb_map_destroy (glyph_to_sid_map.get_relaxed ());\n+  }\n+\n+  parsed_cs_str_vec_t parsed_charstrings;\n+  parsed_cs_str_vec_t parsed_global_subrs;\n+  hb_vector_t<parsed_cs_str_vec_t> parsed_local_subrs;\n+  mutable hb_atomic_ptr_t<hb_map_t> glyph_to_sid_map = nullptr;\n+\n+ private:\n+  hb_blob_t* original_blob;\n+};\n+\n@@ -449,0 +578,3 @@\n+    {\n+      if (!parsed_str->is_parsed ())\n+        parsed_str->alloc (env.str_ref.total_size ());\n@@ -450,0 +582,1 @@\n+    }\n@@ -509,1 +642,1 @@\n-      local_remaps[i].create (&closures.local_closures[i]);\n+      local_remaps.arrayZ[i].create (&closures.local_closures[i]);\n@@ -520,1 +653,2 @@\n-      : acc (acc_), plan (plan_), closures(acc_.fdCount), remaps(acc_.fdCount)\n+      : acc (acc_), plan (plan_), closures(acc_.fdCount),\n+        remaps(acc_.fdCount)\n@@ -539,7 +673,5 @@\n-    parsed_charstrings.resize (plan->num_output_glyphs ());\n-    parsed_global_subrs.resize (acc.globalSubrs->count);\n-\n-    if (unlikely (remaps.in_error()\n-                  || parsed_charstrings.in_error ()\n-                  || parsed_global_subrs.in_error ())) {\n-      return false;\n+    unsigned fd_count = acc.fdCount;\n+    const cff_subset_accelerator_t* cff_accelerator = nullptr;\n+    if (plan->accelerator && plan->accelerator->cff_accelerator) {\n+      cff_accelerator = plan->accelerator->cff_accelerator;\n+      fd_count = cff_accelerator->parsed_local_subrs.length;\n@@ -548,1 +680,9 @@\n-    if (unlikely (!parsed_local_subrs.resize (acc.fdCount))) return false;\n+    if (cff_accelerator) {\n+      \/\/ If we are not dropping hinting then charstrings are not modified so we can\n+      \/\/ just use a reference to the cached copies.\n+      cached_charstrings.resize_exact (plan->num_output_glyphs ());\n+      parsed_global_subrs = &cff_accelerator->parsed_global_subrs;\n+      parsed_local_subrs = &cff_accelerator->parsed_local_subrs;\n+    } else {\n+      parsed_charstrings.resize_exact (plan->num_output_glyphs ());\n+      parsed_global_subrs_storage.resize_exact (acc.globalSubrs->count);\n@@ -550,4 +690,11 @@\n-    for (unsigned int i = 0; i < acc.fdCount; i++)\n-    {\n-      parsed_local_subrs[i].resize (acc.privateDicts[i].localSubrs->count);\n-      if (unlikely (parsed_local_subrs[i].in_error ())) return false;\n+      if (unlikely (!parsed_local_subrs_storage.resize (fd_count))) return false;\n+\n+      for (unsigned int i = 0; i < acc.fdCount; i++)\n+      {\n+        unsigned count = acc.privateDicts[i].localSubrs->count;\n+        parsed_local_subrs_storage[i].resize (count);\n+        if (unlikely (parsed_local_subrs_storage[i].in_error ())) return false;\n+      }\n+\n+      parsed_global_subrs = &parsed_global_subrs_storage;\n+      parsed_local_subrs = &parsed_local_subrs_storage;\n@@ -555,1 +702,6 @@\n-    if (unlikely (!closures.valid))\n+\n+    if (unlikely (remaps.in_error()\n+                  || cached_charstrings.in_error ()\n+                  || parsed_charstrings.in_error ()\n+                  || parsed_global_subrs->in_error ()\n+                  || closures.in_error ())) {\n@@ -557,0 +709,1 @@\n+    }\n@@ -564,0 +717,1 @@\n+\n@@ -569,0 +723,12 @@\n+      if (cff_accelerator)\n+      {\n+        \/\/ parsed string already exists in accelerator, copy it and move\n+        \/\/ on.\n+        if (cached_charstrings)\n+          cached_charstrings[i] = &cff_accelerator->parsed_charstrings[glyph];\n+        else\n+          parsed_charstrings[i] = cff_accelerator->parsed_charstrings[glyph];\n+\n+        continue;\n+      }\n+\n@@ -574,2 +740,2 @@\n-                                  &parsed_global_subrs,\n-                                  &parsed_local_subrs[fd],\n+                                  &parsed_global_subrs_storage,\n+                                  &parsed_local_subrs_storage[fd],\n@@ -585,1 +751,0 @@\n-    }\n@@ -587,2 +752,0 @@\n-    if (plan->flags & HB_SUBSET_FLAGS_NO_HINTING)\n-    {\n@@ -590,1 +753,1 @@\n-      for (unsigned int i = 0; i < plan->num_output_glyphs (); i++)\n+      if ((plan->flags & HB_SUBSET_FLAGS_NO_HINTING) || plan->inprogress_accelerator)\n@@ -592,6 +755,0 @@\n-        hb_codepoint_t  glyph;\n-        if (!plan->old_gid_for_new_gid (i, &glyph))\n-          continue;\n-        unsigned int fd = acc.fdSelect->get_fd (glyph);\n-        if (unlikely (fd >= acc.fdCount))\n-          return false;\n@@ -599,2 +756,2 @@\n-                                    &parsed_global_subrs,\n-                                    &parsed_local_subrs[fd],\n+                                    &parsed_global_subrs_storage,\n+                                    &parsed_local_subrs_storage[fd],\n@@ -614,18 +771,7 @@\n-      \/* after dropping hints recreate closures of actually used subrs *\/\n-      closures.reset ();\n-      for (unsigned int i = 0; i < plan->num_output_glyphs (); i++)\n-      {\n-        hb_codepoint_t  glyph;\n-        if (!plan->old_gid_for_new_gid (i, &glyph))\n-          continue;\n-        unsigned int fd = acc.fdSelect->get_fd (glyph);\n-        if (unlikely (fd >= acc.fdCount))\n-          return false;\n-        subr_subset_param_t  param (&parsed_charstrings[i],\n-                                    &parsed_global_subrs,\n-                                    &parsed_local_subrs[fd],\n-                                    &closures.global_closure,\n-                                    &closures.local_closures[fd],\n-                                    plan->flags & HB_SUBSET_FLAGS_NO_HINTING);\n-        collect_subr_refs_in_str (parsed_charstrings[i], param);\n-      }\n+      \/* Doing this here one by one instead of compacting all at the en\n+       * has massive peak-memory saving.\n+       *\n+       * The compacting both saves memory and makes further operations\n+       * faster.\n+       *\/\n+      parsed_charstrings[i].compact ();\n@@ -634,0 +780,12 @@\n+    \/* Since parsed strings were loaded from accelerator, we still need\n+     * to compute the subroutine closures which would have normally happened during\n+     * parsing.\n+     *\n+     * Or if we are dropping hinting, redo closure to get actually used subrs.\n+     *\/\n+    if ((cff_accelerator ||\n+        (!cff_accelerator && plan->flags & HB_SUBSET_FLAGS_NO_HINTING)) &&\n+        !closure_subroutines(*parsed_global_subrs,\n+                             *parsed_local_subrs))\n+      return false;\n+\n@@ -636,0 +794,1 @@\n+    populate_subset_accelerator ();\n@@ -639,1 +798,1 @@\n-  bool encode_charstrings (str_buff_vec_t &buffArray) const\n+  bool encode_charstrings (str_buff_vec_t &buffArray, bool encode_prefix = true) const\n@@ -641,1 +800,1 @@\n-    if (unlikely (!buffArray.resize (plan->num_output_glyphs ())))\n+    if (unlikely (!buffArray.resize_exact (plan->num_output_glyphs ())))\n@@ -649,1 +808,1 @@\n-        if (endchar_op != OpCode_Invalid) buffArray[i].push (endchar_op);\n+        if (endchar_op != OpCode_Invalid) buffArray.arrayZ[i].push (endchar_op);\n@@ -655,1 +814,1 @@\n-      if (unlikely (!encode_str (parsed_charstrings[i], fd, buffArray[i])))\n+      if (unlikely (!encode_str (get_parsed_charstring (i), fd, buffArray.arrayZ[i], encode_prefix)))\n@@ -665,1 +824,1 @@\n-    if (unlikely (!buffArray.resize (count)))\n+    if (unlikely (!buffArray.resize_exact (count)))\n@@ -667,1 +826,1 @@\n-    for (unsigned int old_num = 0; old_num < subrs.length; old_num++)\n+    for (unsigned int new_num = 0; new_num < count; new_num++)\n@@ -669,6 +828,5 @@\n-      hb_codepoint_t new_num = remap[old_num];\n-      if (new_num != CFF_UNDEF_CODE)\n-      {\n-        if (unlikely (!encode_str (subrs[old_num], fd, buffArray[new_num])))\n-          return false;\n-      }\n+      hb_codepoint_t old_num = remap.backward (new_num);\n+      assert (old_num != CFF_UNDEF_CODE);\n+\n+      if (unlikely (!encode_str (subrs[old_num], fd, buffArray[new_num])))\n+        return false;\n@@ -681,1 +839,1 @@\n-    return encode_subrs (parsed_global_subrs, remaps.global_remap, 0, buffArray);\n+    return encode_subrs (*parsed_global_subrs, remaps.global_remap, 0, buffArray);\n@@ -686,1 +844,1 @@\n-    return encode_subrs (parsed_local_subrs[fd], remaps.local_remaps[fd], fd, buffArray);\n+    return encode_subrs ((*parsed_local_subrs)[fd], remaps.local_remaps[fd], fd, buffArray);\n@@ -715,1 +873,1 @@\n-      str.values[pos].set_drop ();\n+      str.values[pos].set_hinting ();\n@@ -723,1 +881,1 @@\n-      str.values[pos].set_drop ();\n+      str.values[pos].set_hinting ();\n@@ -734,1 +892,3 @@\n-    for (unsigned int pos = 0; pos < str.values.length; pos++)\n+    unsigned count = str.values.length;\n+    auto *values = str.values.arrayZ;\n+    for (unsigned int pos = 0; pos < count; pos++)\n@@ -737,1 +897,1 @@\n-      switch (str.values[pos].op)\n+      switch (values[pos].op)\n@@ -741,1 +901,1 @@\n-                                        *param.parsed_local_subrs, str.values[pos].subr_num,\n+                                        *param.parsed_local_subrs, values[pos].subr_num,\n@@ -747,1 +907,1 @@\n-                                        *param.parsed_global_subrs, str.values[pos].subr_num,\n+                                        *param.parsed_global_subrs, values[pos].subr_num,\n@@ -761,1 +921,1 @@\n-            str.values[pos].set_drop ();\n+            values[pos].set_hinting ();\n@@ -771,1 +931,1 @@\n-          str.values[pos].set_drop ();\n+          values[pos].set_hinting ();\n@@ -777,1 +937,1 @@\n-          str.values[pos].set_drop ();\n+          values[pos].set_hinting ();\n@@ -788,2 +948,2 @@\n-          parsed_cs_op_t  &csop = str.values[(unsigned)i];\n-          if (csop.for_drop ())\n+          parsed_cs_op_t  &csop = values[(unsigned)i];\n+          if (csop.is_hinting ())\n@@ -791,1 +951,1 @@\n-          csop.set_drop ();\n+          csop.set_hinting ();\n@@ -804,1 +964,1 @@\n-    for (unsigned int pos = 0; pos < str.values.length; pos++)\n+    for (unsigned int pos = 0; pos < count; pos++)\n@@ -806,1 +966,1 @@\n-      parsed_cs_op_t  &csop = str.values[pos];\n+      parsed_cs_op_t  &csop = values[pos];\n@@ -809,1 +969,1 @@\n-      if (!csop.for_drop ())\n+      if (!csop.is_hinting ())\n@@ -819,2 +979,28 @@\n-  void collect_subr_refs_in_subr (parsed_cs_str_t &str, unsigned int pos,\n-                                  unsigned int subr_num, parsed_cs_str_vec_t &subrs,\n+  bool closure_subroutines (const parsed_cs_str_vec_t& global_subrs,\n+                            const hb_vector_t<parsed_cs_str_vec_t>& local_subrs)\n+  {\n+    closures.reset ();\n+    for (unsigned int i = 0; i < plan->num_output_glyphs (); i++)\n+    {\n+      hb_codepoint_t  glyph;\n+      if (!plan->old_gid_for_new_gid (i, &glyph))\n+        continue;\n+      unsigned int fd = acc.fdSelect->get_fd (glyph);\n+      if (unlikely (fd >= acc.fdCount))\n+        return false;\n+\n+      \/\/ Note: const cast is safe here because the collect_subr_refs_in_str only performs a\n+      \/\/       closure and does not modify any of the charstrings.\n+      subr_subset_param_t  param (const_cast<parsed_cs_str_t*> (&get_parsed_charstring (i)),\n+                                  const_cast<parsed_cs_str_vec_t*> (&global_subrs),\n+                                  const_cast<parsed_cs_str_vec_t*> (&local_subrs[fd]),\n+                                  &closures.global_closure,\n+                                  &closures.local_closures[fd],\n+                                  plan->flags & HB_SUBSET_FLAGS_NO_HINTING);\n+      collect_subr_refs_in_str (get_parsed_charstring (i), param);\n+    }\n+\n+    return true;\n+  }\n+\n+  void collect_subr_refs_in_subr (unsigned int subr_num, parsed_cs_str_vec_t &subrs,\n@@ -824,0 +1010,2 @@\n+    if (closure->has (subr_num))\n+      return;\n@@ -828,1 +1016,2 @@\n-  void collect_subr_refs_in_str (parsed_cs_str_t &str, const subr_subset_param_t &param)\n+  void collect_subr_refs_in_str (const parsed_cs_str_t &str,\n+                                 const subr_subset_param_t &param)\n@@ -830,1 +1019,4 @@\n-    for (unsigned int pos = 0; pos < str.values.length; pos++)\n+    if (!str.has_calls ())\n+      return;\n+\n+    for (auto &opstr : str.values)\n@@ -832,1 +1024,1 @@\n-      if (!str.values[pos].for_drop ())\n+      if (!param.drop_hints || !opstr.is_hinting ())\n@@ -834,1 +1026,1 @@\n-        switch (str.values[pos].op)\n+        switch (opstr.op)\n@@ -837,2 +1029,1 @@\n-            collect_subr_refs_in_subr (str, pos,\n-                                       str.values[pos].subr_num, *param.parsed_local_subrs,\n+            collect_subr_refs_in_subr (opstr.subr_num, *param.parsed_local_subrs,\n@@ -843,2 +1034,1 @@\n-            collect_subr_refs_in_subr (str, pos,\n-                                       str.values[pos].subr_num, *param.parsed_global_subrs,\n+            collect_subr_refs_in_subr (opstr.subr_num, *param.parsed_global_subrs,\n@@ -854,1 +1044,1 @@\n-  bool encode_str (const parsed_cs_str_t &str, const unsigned int fd, str_buff_t &buff) const\n+  bool encode_str (const parsed_cs_str_t &str, const unsigned int fd, str_buff_t &buff, bool encode_prefix = true) const\n@@ -856,1 +1046,0 @@\n-    unsigned count = str.get_count ();\n@@ -859,1 +1048,1 @@\n-    buff.alloc (count * 3);\n+    bool hinting = !(plan->flags & HB_SUBSET_FLAGS_NO_HINTING);\n@@ -862,1 +1051,1 @@\n-    if (str.has_prefix () && str.is_hint_dropped ())\n+    if (encode_prefix && str.has_prefix () && !hinting && str.is_hint_dropped ())\n@@ -864,1 +1053,1 @@\n-      encoder.encode_num (str.prefix_num ());\n+      encoder.encode_num_cs (str.prefix_num ());\n@@ -868,1 +1057,12 @@\n-    for (unsigned int i = 0; i < count; i++)\n+\n+    unsigned size = 0;\n+    for (auto &opstr : str.values)\n+    {\n+      size += opstr.length;\n+      if (opstr.op == OpCode_callsubr || opstr.op == OpCode_callgsubr)\n+        size += 3;\n+    }\n+    if (!buff.alloc (buff.length + size, true))\n+      return false;\n+\n+    for (auto &opstr : str.values)\n@@ -870,2 +1070,1 @@\n-      const parsed_cs_op_t  &opstr = str.values[i];\n-      if (!opstr.for_drop () && !opstr.for_skip ())\n+      if (hinting || !opstr.is_hinting ())\n@@ -877,1 +1076,1 @@\n-            encoder.encode_op (OpCode_callsubr);\n+            encoder.copy_str (opstr.ptr, opstr.length);\n@@ -882,1 +1081,1 @@\n-            encoder.encode_op (OpCode_callgsubr);\n+            encoder.copy_str (opstr.ptr, opstr.length);\n@@ -886,1 +1085,1 @@\n-            encoder.copy_str (opstr.str);\n+            encoder.copy_str (opstr.ptr, opstr.length);\n@@ -891,1 +1090,32 @@\n-    return !encoder.is_error ();\n+    return !encoder.in_error ();\n+  }\n+\n+  void compact_parsed_subrs () const\n+  {\n+    for (auto &cs : parsed_global_subrs_storage)\n+      cs.compact ();\n+    for (auto &vec : parsed_local_subrs_storage)\n+      for (auto &cs : vec)\n+        cs.compact ();\n+  }\n+\n+  void populate_subset_accelerator () const\n+  {\n+    if (!plan->inprogress_accelerator) return;\n+\n+    compact_parsed_subrs ();\n+\n+    plan->inprogress_accelerator->cff_accelerator =\n+        cff_subset_accelerator_t::create(acc.blob,\n+                                         parsed_charstrings,\n+                                         parsed_global_subrs_storage,\n+                                         parsed_local_subrs_storage);\n+    plan->inprogress_accelerator->destroy_cff_accelerator =\n+        cff_subset_accelerator_t::destroy;\n+\n+  }\n+\n+  const parsed_cs_str_t& get_parsed_charstring (unsigned i) const\n+  {\n+    if (cached_charstrings) return *(cached_charstrings[i]);\n+    return parsed_charstrings[i];\n@@ -900,3 +1130,3 @@\n-  parsed_cs_str_vec_t           parsed_charstrings;\n-  parsed_cs_str_vec_t           parsed_global_subrs;\n-  hb_vector_t<parsed_cs_str_vec_t>  parsed_local_subrs;\n+  hb_vector_t<const parsed_cs_str_t*>     cached_charstrings;\n+  const parsed_cs_str_vec_t*              parsed_global_subrs;\n+  const hb_vector_t<parsed_cs_str_vec_t>* parsed_local_subrs;\n@@ -907,0 +1137,4 @@\n+\n+  parsed_cs_str_vec_t           parsed_charstrings;\n+  parsed_cs_str_vec_t           parsed_global_subrs_storage;\n+  hb_vector_t<parsed_cs_str_vec_t>  parsed_local_subrs_storage;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-cff-common.hh","additions":431,"deletions":197,"binary":false,"changes":628,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-          if ( unlikely (!(opstr.str.length >= opstr.last_arg_offset + 3)))\n+          if ( unlikely (!(opstr.length >= opstr.last_arg_offset + 3)))\n@@ -172,1 +172,2 @@\n-          supp_op.str = hb_ubytes_t (&opstr.str + opstr.last_arg_offset, opstr.str.length - opstr.last_arg_offset);\n+          supp_op.ptr = opstr.ptr + opstr.last_arg_offset;\n+          supp_op.length = opstr.length - opstr.last_arg_offset;\n@@ -236,1 +237,1 @@\n-      encoder.encode_num (env.eval_arg (i));\n+      encoder.encode_num_cs (env.eval_arg (i));\n@@ -250,1 +251,1 @@\n-    encoder.encode_num (env.width);\n+    encoder.encode_num_cs (env.width);\n@@ -337,0 +338,30 @@\n+struct cff1_private_dict_op_serializer_t : op_serializer_t\n+{\n+  cff1_private_dict_op_serializer_t (bool desubroutinize_, bool drop_hints_)\n+    : desubroutinize (desubroutinize_), drop_hints (drop_hints_) {}\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  const op_str_t &opstr,\n+                  objidx_t subrs_link) const\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    if (drop_hints && dict_opset_t::is_hint_op (opstr.op))\n+      return_trace (true);\n+\n+    if (opstr.op == OpCode_Subrs)\n+    {\n+      if (desubroutinize || !subrs_link)\n+        return_trace (true);\n+      else\n+        return_trace (FontDict::serialize_link2_op (c, opstr.op, subrs_link));\n+    }\n+\n+    return_trace (copy_opstr (c, opstr));\n+  }\n+\n+  protected:\n+  const bool desubroutinize;\n+  const bool drop_hints;\n+};\n+\n@@ -445,2 +476,11 @@\n-    bool use_glyph_to_sid_map = plan->num_output_glyphs () > plan->source->get_num_glyphs () \/ 8.;\n-    hb_map_t *glyph_to_sid_map = use_glyph_to_sid_map ? acc.create_glyph_to_sid_map () : nullptr;\n+    hb_map_t *glyph_to_sid_map = (plan->accelerator && plan->accelerator->cff_accelerator) ?\n+                                  plan->accelerator->cff_accelerator->glyph_to_sid_map :\n+                                  nullptr;\n+    bool created_map = false;\n+    if (!glyph_to_sid_map &&\n+        ((plan->accelerator && plan->accelerator->cff_accelerator) ||\n+         plan->num_output_glyphs () > plan->source->get_num_glyphs () \/ 8.))\n+    {\n+      created_map = true;\n+      glyph_to_sid_map = acc.create_glyph_to_sid_map ();\n+    }\n@@ -470,2 +510,6 @@\n-    if (glyph_to_sid_map)\n-      hb_map_destroy (glyph_to_sid_map);\n+    if (created_map)\n+    {\n+      if (!(plan->accelerator && plan->accelerator->cff_accelerator) ||\n+          !plan->accelerator->cff_accelerator->glyph_to_sid_map.cmpexch (nullptr, glyph_to_sid_map))\n+        hb_map_destroy (glyph_to_sid_map);\n+    }\n@@ -710,1 +754,1 @@\n-      cff_private_dict_op_serializer_t privSzr (plan.desubroutinize, plan.drop_hints);\n+      cff1_private_dict_op_serializer_t privSzr (plan.desubroutinize, plan.drop_hints);\n@@ -731,0 +775,6 @@\n+    c->push<CFF1CharStrings> ();\n+\n+    unsigned total_size = CFF1CharStrings::total_size (plan.subset_charstrings);\n+    if (unlikely (!c->start_zerocopy (total_size)))\n+       return false;\n+\n@@ -733,1 +783,1 @@\n-    c->push ();\n+\n@@ -735,1 +785,1 @@\n-      plan.info.char_strings_link = c->pop_pack ();\n+      plan.info.char_strings_link = c->pop_pack (false);\n@@ -818,1 +868,1 @@\n-      c->pop_pack ();\n+      c->pop_pack (false);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-cff1.cc","additions":62,"deletions":12,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -62,1 +62,4 @@\n-        return_trace (FontDict::serialize_link4_op(c, opstr.op, info.var_store_link));\n+        if (info.var_store_link)\n+          return_trace (FontDict::serialize_link4_op(c, opstr.op, info.var_store_link));\n+        else\n+          return_trace (true);\n@@ -118,1 +121,1 @@\n-        encoder.encode_num (arg);\n+        encoder.encode_num_cs (arg);\n@@ -138,1 +141,1 @@\n-      encoder.encode_num (arg1);\n+      encoder.encode_num_cs (arg1);\n@@ -145,1 +148,1 @@\n-        encoder.encode_num (arg1.deltas[k]);\n+        encoder.encode_num_cs (arg1.deltas[k]);\n@@ -165,0 +168,11 @@\n+  static void flush_hintmask (op_code_t op, cff2_cs_interp_env_t<blend_arg_t> &env, flatten_param_t& param)\n+  {\n+    SUPER::flush_hintmask (op, env, param);\n+    if (!param.drop_hints)\n+    {\n+      str_encoder_t  encoder (param.flatStr);\n+      for (unsigned int i = 0; i < env.hintmask_size; i++)\n+        encoder.encode_byte (env.str_ref[i]);\n+    }\n+  }\n+\n@@ -235,1 +249,103 @@\n-struct cff2_subset_plan {\n+struct cff2_private_blend_encoder_param_t\n+{\n+  cff2_private_blend_encoder_param_t (hb_serialize_context_t *c,\n+                                      const CFF2VariationStore *varStore,\n+                                      hb_array_t<int> normalized_coords) :\n+    c (c), varStore (varStore), normalized_coords (normalized_coords) {}\n+\n+  void init () {}\n+\n+  void process_blend ()\n+  {\n+    if (!seen_blend)\n+    {\n+      region_count = varStore->varStore.get_region_index_count (ivs);\n+      scalars.resize_exact (region_count);\n+      varStore->varStore.get_region_scalars (ivs, normalized_coords.arrayZ, normalized_coords.length,\n+                                             &scalars[0], region_count);\n+      seen_blend = true;\n+    }\n+  }\n+\n+  double blend_deltas (hb_array_t<const number_t> deltas) const\n+  {\n+    double v = 0;\n+    if (likely (scalars.length == deltas.length))\n+    {\n+      unsigned count = scalars.length;\n+      for (unsigned i = 0; i < count; i++)\n+        v += (double) scalars.arrayZ[i] * deltas.arrayZ[i].to_real ();\n+    }\n+    return v;\n+  }\n+\n+\n+  hb_serialize_context_t *c = nullptr;\n+  bool seen_blend = false;\n+  unsigned ivs = 0;\n+  unsigned region_count = 0;\n+  hb_vector_t<float> scalars;\n+  const  CFF2VariationStore *varStore = nullptr;\n+  hb_array_t<int> normalized_coords;\n+};\n+\n+struct cff2_private_dict_blend_opset_t : dict_opset_t\n+{\n+  static void process_arg_blend (cff2_private_blend_encoder_param_t& param,\n+                                 number_t &arg,\n+                                 const hb_array_t<const number_t> blends,\n+                                 unsigned n, unsigned i)\n+  {\n+    arg.set_int (round (arg.to_real () + param.blend_deltas (blends)));\n+  }\n+\n+  static void process_blend (cff2_priv_dict_interp_env_t& env, cff2_private_blend_encoder_param_t& param)\n+  {\n+    unsigned int n, k;\n+\n+    param.process_blend ();\n+    k = param.region_count;\n+    n = env.argStack.pop_uint ();\n+    \/* copy the blend values into blend array of the default values *\/\n+    unsigned int start = env.argStack.get_count () - ((k+1) * n);\n+    \/* let an obvious error case fail, but note CFF2 spec doesn't forbid n==0 *\/\n+    if (unlikely (start > env.argStack.get_count ()))\n+    {\n+      env.set_error ();\n+      return;\n+    }\n+    for (unsigned int i = 0; i < n; i++)\n+    {\n+      const hb_array_t<const number_t> blends = env.argStack.sub_array (start + n + (i * k), k);\n+      process_arg_blend (param, env.argStack[start + i], blends, n, i);\n+    }\n+\n+    \/* pop off blend values leaving default values now adorned with blend values *\/\n+    env.argStack.pop (k * n);\n+  }\n+\n+  static void process_op (op_code_t op, cff2_priv_dict_interp_env_t& env, cff2_private_blend_encoder_param_t& param)\n+  {\n+    switch (op) {\n+      case OpCode_StdHW:\n+      case OpCode_StdVW:\n+      case OpCode_BlueScale:\n+      case OpCode_BlueShift:\n+      case OpCode_BlueFuzz:\n+      case OpCode_ExpansionFactor:\n+      case OpCode_LanguageGroup:\n+      case OpCode_BlueValues:\n+      case OpCode_OtherBlues:\n+      case OpCode_FamilyBlues:\n+      case OpCode_FamilyOtherBlues:\n+      case OpCode_StemSnapH:\n+      case OpCode_StemSnapV:\n+        break;\n+      case OpCode_vsindexdict:\n+        env.process_vsindex ();\n+        param.ivs = env.get_ivs ();\n+        env.clear_args ();\n+        return;\n+      case OpCode_blenddict:\n+        process_blend (env, param);\n+        return;\n@@ -237,0 +353,74 @@\n+      default:\n+        dict_opset_t::process_op (op, env);\n+        if (!env.argStack.is_empty ()) return;\n+        break;\n+    }\n+\n+    if (unlikely (env.in_error ())) return;\n+\n+    \/\/ Write args then op\n+\n+    str_buff_t str;\n+    str_encoder_t encoder (str);\n+\n+    unsigned count = env.argStack.get_count ();\n+    for (unsigned i = 0; i < count; i++)\n+      encoder.encode_num_tp (env.argStack[i]);\n+\n+    encoder.encode_op (op);\n+\n+    auto bytes = str.as_bytes ();\n+    param.c->embed (&bytes, bytes.length);\n+\n+    env.clear_args ();\n+  }\n+};\n+\n+struct cff2_private_dict_op_serializer_t : op_serializer_t\n+{\n+  cff2_private_dict_op_serializer_t (bool desubroutinize_, bool drop_hints_, bool pinned_,\n+                                     const CFF::CFF2VariationStore* varStore_,\n+                                     hb_array_t<int> normalized_coords_)\n+    : desubroutinize (desubroutinize_), drop_hints (drop_hints_), pinned (pinned_),\n+      varStore (varStore_), normalized_coords (normalized_coords_) {}\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  const op_str_t &opstr,\n+                  objidx_t subrs_link) const\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    if (drop_hints && dict_opset_t::is_hint_op (opstr.op))\n+      return_trace (true);\n+\n+    if (opstr.op == OpCode_Subrs)\n+    {\n+      if (desubroutinize || !subrs_link)\n+        return_trace (true);\n+      else\n+        return_trace (FontDict::serialize_link2_op (c, opstr.op, subrs_link));\n+    }\n+\n+    if (pinned)\n+    {\n+      \/\/ Reinterpret opstr and process blends.\n+      cff2_priv_dict_interp_env_t env {hb_ubytes_t (opstr.ptr, opstr.length)};\n+      cff2_private_blend_encoder_param_t param (c, varStore, normalized_coords);\n+      dict_interpreter_t<cff2_private_dict_blend_opset_t, cff2_private_blend_encoder_param_t, cff2_priv_dict_interp_env_t> interp (env);\n+      return_trace (interp.interpret (param));\n+    }\n+\n+    return_trace (copy_opstr (c, opstr));\n+  }\n+\n+  protected:\n+  const bool desubroutinize;\n+  const bool drop_hints;\n+  const bool pinned;\n+  const CFF::CFF2VariationStore* varStore;\n+  hb_array_t<int> normalized_coords;\n+};\n+\n+\n+struct cff2_subset_plan\n+{\n@@ -243,1 +433,3 @@\n-    desubroutinize = plan->flags & HB_SUBSET_FLAGS_DESUBROUTINIZE;\n+    pinned = (bool) plan->normalized_coords;\n+    desubroutinize = plan->flags & HB_SUBSET_FLAGS_DESUBROUTINIZE ||\n+                     pinned; \/\/ For instancing we need this path\n@@ -262,1 +454,1 @@\n-      if (!subr_subsetter.encode_charstrings (subset_charstrings))\n+      if (!subr_subsetter.encode_charstrings (subset_charstrings, !pinned))\n@@ -304,0 +496,1 @@\n+  bool            pinned = false;\n@@ -319,1 +512,2 @@\n-                             unsigned int num_glyphs)\n+                             unsigned int num_glyphs,\n+                             hb_array_t<int> normalized_coords)\n@@ -337,1 +531,1 @@\n-          subrs_link = c->pop_pack ();\n+          subrs_link = c->pop_pack (false);\n@@ -347,1 +541,2 @@\n-      cff_private_dict_op_serializer_t privSzr (plan.desubroutinize, plan.drop_hints);\n+      cff2_private_dict_op_serializer_t privSzr (plan.desubroutinize, plan.drop_hints, plan.pinned,\n+                                                 acc.varStore, normalized_coords);\n@@ -364,0 +559,6 @@\n+    c->push ();\n+\n+    unsigned total_size = CFF2CharStrings::total_size (plan.subset_charstrings);\n+    if (unlikely (!c->start_zerocopy (total_size)))\n+       return false;\n+\n@@ -366,1 +567,1 @@\n-    c->push ();\n+\n@@ -368,1 +569,1 @@\n-      plan.info.char_strings_link = c->pop_pack ();\n+      plan.info.char_strings_link = c->pop_pack (false);\n@@ -380,3 +581,4 @@\n-    if (likely (hb_serialize_cff_fdselect (c, num_glyphs, *(const FDSelect *)acc.fdSelect,                                            plan.orig_fdcount,\n-                                            plan.subset_fdselect_format, plan.subset_fdselect_size,\n-                                            plan.subset_fdselect_ranges)))\n+    if (likely (hb_serialize_cff_fdselect (c, num_glyphs, *(const FDSelect *)acc.fdSelect,\n+                                           plan.orig_fdcount,\n+                                           plan.subset_fdselect_format, plan.subset_fdselect_size,\n+                                           plan.subset_fdselect_ranges)))\n@@ -404,1 +606,1 @@\n-    plan.info.fd_array_link = c->pop_pack ();\n+    plan.info.fd_array_link = c->pop_pack (false);\n@@ -408,1 +610,2 @@\n-  if (acc.varStore != &Null (CFF2VariationStore))\n+  if (acc.varStore != &Null (CFF2VariationStore) &&\n+      !plan.pinned)\n@@ -413,1 +616,1 @@\n-    plan.info.var_store_link = c->pop_pack ();\n+    plan.info.var_store_link = c->pop_pack (false);\n@@ -447,1 +650,2 @@\n-  return _serialize_cff2 (c->serializer, cff2_plan, acc, c->plan->num_output_glyphs ());\n+  return _serialize_cff2 (c->serializer, cff2_plan, acc, c->plan->num_output_glyphs (),\n+                          c->plan->normalized_coords.as_array ());\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-cff2.cc","additions":223,"deletions":19,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"hb-utf.hh\"\n@@ -30,14 +31,0 @@\n-\/**\n- * hb_subset_input_create_or_fail:\n- *\n- * Creates a new subset input object.\n- *\n- * Return value: (transfer full): New subset input, or %NULL if failed. Destroy\n- * with hb_subset_input_destroy().\n- *\n- * Since: 1.8.0\n- **\/\n-hb_subset_input_t *\n-hb_subset_input_create_or_fail (void)\n-{\n-  hb_subset_input_t *input = hb_object_create<hb_subset_input_t>();\n@@ -45,5 +32,4 @@\n-  if (unlikely (!input))\n-    return nullptr;\n-\n-  for (auto& set : input->sets_iter ())\n-    set = hb_set_create ();\n+hb_subset_input_t::hb_subset_input_t ()\n+{\n+  for (auto& set : sets_iter ())\n+    set = hb::shared_ptr<hb_set_t> (hb_set_create ());\n@@ -51,5 +37,2 @@\n-  if (input->in_error ())\n-  {\n-    hb_subset_input_destroy (input);\n-    return nullptr;\n-  }\n+  if (in_error ())\n+    return;\n@@ -57,1 +40,1 @@\n-  input->flags = HB_SUBSET_FLAGS_DEFAULT;\n+  flags = HB_SUBSET_FLAGS_DEFAULT;\n@@ -59,2 +42,2 @@\n-  hb_set_add_range (input->sets.name_ids, 0, 6);\n-  hb_set_add (input->sets.name_languages, 0x0409);\n+  hb_set_add_range (sets.name_ids, 0, 6);\n+  hb_set_add (sets.name_languages, 0x0409);\n@@ -86,1 +69,1 @@\n-  input->sets.drop_tables->add_array (default_drop_tables, ARRAY_LENGTH (default_drop_tables));\n+  sets.drop_tables->add_array (default_drop_tables, ARRAY_LENGTH (default_drop_tables));\n@@ -90,1 +73,0 @@\n-    HB_TAG ('f', 'v', 'a', 'r'),\n@@ -99,1 +81,0 @@\n-    HB_TAG ('S', 'T', 'A', 'T'),\n@@ -101,1 +82,1 @@\n-  input->sets.no_subset_tables->add_array (default_no_subset_tables,\n+  sets.no_subset_tables->add_array (default_no_subset_tables,\n@@ -204,1 +185,22 @@\n-  input->sets.layout_features->add_array (default_layout_features, ARRAY_LENGTH (default_layout_features));\n+  sets.layout_features->add_array (default_layout_features, ARRAY_LENGTH (default_layout_features));\n+\n+  sets.layout_scripts->invert (); \/\/ Default to all scripts.\n+}\n+\n+\/**\n+ * hb_subset_input_create_or_fail:\n+ *\n+ * Creates a new subset input object.\n+ *\n+ * Return value: (transfer full): New subset input, or `NULL` if failed. Destroy\n+ * with hb_subset_input_destroy().\n+ *\n+ * Since: 1.8.0\n+ **\/\n+hb_subset_input_t *\n+hb_subset_input_create_or_fail (void)\n+{\n+  hb_subset_input_t *input = hb_object_create<hb_subset_input_t>();\n+\n+  if (unlikely (!input))\n+    return nullptr;\n@@ -211,0 +213,1 @@\n+\n@@ -244,3 +247,0 @@\n-  for (hb_set_t* set : input->sets_iter ())\n-    hb_set_destroy (set);\n-\n@@ -345,1 +345,1 @@\n- * Return value: %true if success, %false otherwise\n+ * Return value: `true` if success, `false` otherwise\n@@ -377,0 +377,216 @@\n+\n+\/**\n+ * hb_subset_input_keep_everything:\n+ * @input: a #hb_subset_input_t object\n+ *\n+ * Configure input object to keep everything in the font face.\n+ * That is, all Unicodes, glyphs, names, layout items,\n+ * glyph names, etc.\n+ *\n+ * The input can be tailored afterwards by the caller.\n+ *\n+ * Since: 7.0.0\n+ *\/\n+void\n+hb_subset_input_keep_everything (hb_subset_input_t *input)\n+{\n+  const hb_subset_sets_t indices[] = {HB_SUBSET_SETS_UNICODE,\n+                                      HB_SUBSET_SETS_GLYPH_INDEX,\n+                                      HB_SUBSET_SETS_NAME_ID,\n+                                      HB_SUBSET_SETS_NAME_LANG_ID,\n+                                      HB_SUBSET_SETS_LAYOUT_FEATURE_TAG,\n+                                      HB_SUBSET_SETS_LAYOUT_SCRIPT_TAG};\n+\n+  for (auto idx : hb_iter (indices))\n+  {\n+    hb_set_t *set = hb_subset_input_set (input, idx);\n+    hb_set_clear (set);\n+    hb_set_invert (set);\n+  }\n+\n+  \/\/ Don't drop any tables\n+  hb_set_clear (hb_subset_input_set (input, HB_SUBSET_SETS_DROP_TABLE_TAG));\n+\n+  hb_subset_input_set_flags (input,\n+                             HB_SUBSET_FLAGS_NOTDEF_OUTLINE |\n+                             HB_SUBSET_FLAGS_GLYPH_NAMES |\n+                             HB_SUBSET_FLAGS_NO_PRUNE_UNICODE_RANGES |\n+                             HB_SUBSET_FLAGS_PASSTHROUGH_UNRECOGNIZED);\n+}\n+\n+#ifndef HB_NO_VAR\n+\/**\n+ * hb_subset_input_pin_axis_to_default: (skip)\n+ * @input: a #hb_subset_input_t object.\n+ * @face: a #hb_face_t object.\n+ * @axis_tag: Tag of the axis to be pinned\n+ *\n+ * Pin an axis to its default location in the given subset input object.\n+ *\n+ * All axes in a font must be pinned. Additionally, `CFF2` table, if present,\n+ * will be de-subroutinized.\n+ *\n+ * Return value: `true` if success, `false` otherwise\n+ *\n+ * Since: 6.0.0\n+ **\/\n+HB_EXTERN hb_bool_t\n+hb_subset_input_pin_axis_to_default (hb_subset_input_t  *input,\n+                                     hb_face_t          *face,\n+                                     hb_tag_t            axis_tag)\n+{\n+  hb_ot_var_axis_info_t axis_info;\n+  if (!hb_ot_var_find_axis_info (face, axis_tag, &axis_info))\n+    return false;\n+\n+  return input->axes_location.set (axis_tag, axis_info.default_value);\n+}\n+\n+\/**\n+ * hb_subset_input_pin_axis_location: (skip)\n+ * @input: a #hb_subset_input_t object.\n+ * @face: a #hb_face_t object.\n+ * @axis_tag: Tag of the axis to be pinned\n+ * @axis_value: Location on the axis to be pinned at\n+ *\n+ * Pin an axis to a fixed location in the given subset input object.\n+ *\n+ * All axes in a font must be pinned. Additionally, `CFF2` table, if present,\n+ * will be de-subroutinized.\n+ *\n+ * Return value: `true` if success, `false` otherwise\n+ *\n+ * Since: 6.0.0\n+ **\/\n+HB_EXTERN hb_bool_t\n+hb_subset_input_pin_axis_location (hb_subset_input_t  *input,\n+                                   hb_face_t          *face,\n+                                   hb_tag_t            axis_tag,\n+                                   float               axis_value)\n+{\n+  hb_ot_var_axis_info_t axis_info;\n+  if (!hb_ot_var_find_axis_info (face, axis_tag, &axis_info))\n+    return false;\n+\n+  float val = hb_clamp(axis_value, axis_info.min_value, axis_info.max_value);\n+  return input->axes_location.set (axis_tag, val);\n+}\n+#endif\n+\n+\/**\n+ * hb_subset_preprocess:\n+ * @source: a #hb_face_t object.\n+ *\n+ * Preprocesses the face and attaches data that will be needed by the\n+ * subsetter. Future subsetting operations can then use the precomputed data\n+ * to speed up the subsetting operation.\n+ *\n+ * See [subset-preprocessing](https:\/\/github.com\/harfbuzz\/harfbuzz\/blob\/main\/docs\/subset-preprocessing.md)\n+ * for more information.\n+ *\n+ * Note: the preprocessed face may contain sub-blobs that reference the memory\n+ * backing the source #hb_face_t. Therefore in the case that this memory is not\n+ * owned by the source face you will need to ensure that memory lives\n+ * as long as the returned #hb_face_t.\n+ *\n+ * Returns: a new #hb_face_t.\n+ *\n+ * Since: 6.0.0\n+ **\/\n+\n+HB_EXTERN hb_face_t *\n+hb_subset_preprocess (hb_face_t *source)\n+{\n+  hb_subset_input_t* input = hb_subset_input_create_or_fail ();\n+  if (!input)\n+    return hb_face_reference (source);\n+\n+  hb_subset_input_keep_everything (input);\n+\n+  input->attach_accelerator_data = true;\n+\n+  \/\/ Always use long loca in the preprocessed version. This allows\n+  \/\/ us to store the glyph bytes unpadded which allows the future subset\n+  \/\/ operation to run faster by skipping the trim padding step.\n+  input->force_long_loca = true;\n+\n+  hb_face_t* new_source = hb_subset_or_fail (source, input);\n+  hb_subset_input_destroy (input);\n+\n+  if (!new_source) {\n+    DEBUG_MSG (SUBSET, nullptr, \"Preprocessing failed due to subset failure.\");\n+    return hb_face_reference (source);\n+  }\n+\n+  return new_source;\n+}\n+\n+#ifdef HB_EXPERIMENTAL_API\n+\/**\n+ * hb_subset_input_override_name_table:\n+ * @input: a #hb_subset_input_t object.\n+ * @name_id: name_id of a nameRecord\n+ * @platform_id: platform ID of a nameRecord\n+ * @encoding_id: encoding ID of a nameRecord\n+ * @language_id: language ID of a nameRecord\n+ * @name_str: pointer to name string new value or null to indicate should remove\n+ * @str_len: the size of @name_str, or -1 if it is `NULL`-terminated\n+ *\n+ * Override the name string of the NameRecord identified by name_id,\n+ * platform_id, encoding_id and language_id. If a record with that name_id\n+ * doesn't exist, create it and insert to the name table.\n+ *\n+ * Note: for mac platform, we only support name_str with all ascii characters,\n+ * name_str with non-ascii characters will be ignored.\n+ *\n+ * XSince: EXPERIMENTAL\n+ **\/\n+HB_EXTERN hb_bool_t\n+hb_subset_input_override_name_table (hb_subset_input_t  *input,\n+                                     hb_ot_name_id_t     name_id,\n+                                     unsigned            platform_id,\n+                                     unsigned            encoding_id,\n+                                     unsigned            language_id,\n+                                     const char         *name_str,\n+                                     int                 str_len \/* -1 means nul-terminated *\/)\n+{\n+  if (!name_str)\n+  {\n+    str_len = 0;\n+  }\n+  else if (str_len == -1)\n+  {\n+      str_len = strlen (name_str);\n+  }\n+\n+  hb_bytes_t name_bytes (nullptr, 0);\n+  if (str_len)\n+  {\n+    if (platform_id == 1)\n+    {\n+      const uint8_t *src = reinterpret_cast<const uint8_t*> (name_str);\n+      const uint8_t *src_end = src + str_len;\n+\n+      hb_codepoint_t unicode;\n+      const hb_codepoint_t replacement = HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT;\n+      while (src < src_end)\n+      {\n+        src = hb_utf8_t::next (src, src_end, &unicode, replacement);\n+        if (unicode >= 0x0080u)\n+        {\n+          printf (\"Non-ascii character detected, ignored...This API supports acsii characters only for mac platform\\n\");\n+          return false;\n+        }\n+      }\n+    }\n+    char *override_name = (char *) hb_malloc (str_len);\n+    if (unlikely (!override_name)) return false;\n+\n+    hb_memcpy (override_name, name_str, str_len);\n+    name_bytes = hb_bytes_t (override_name, str_len);\n+  }\n+  input->name_table_overrides.set (hb_ot_name_record_ids_t (platform_id, encoding_id, language_id, name_id), name_bytes);\n+  return true;\n+}\n+\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-input.cc","additions":252,"deletions":36,"binary":false,"changes":288,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-\n+#include \"hb-cplusplus.hh\"\n@@ -39,0 +39,42 @@\n+struct hb_ot_name_record_ids_t\n+{\n+  hb_ot_name_record_ids_t () = default;\n+  hb_ot_name_record_ids_t (unsigned platform_id_,\n+                           unsigned encoding_id_,\n+                           unsigned language_id_,\n+                           unsigned name_id_)\n+      :platform_id (platform_id_),\n+      encoding_id (encoding_id_),\n+      language_id (language_id_),\n+      name_id (name_id_) {}\n+\n+  bool operator != (const hb_ot_name_record_ids_t o) const\n+  { return !(*this == o); }\n+\n+  inline bool operator == (const hb_ot_name_record_ids_t& o) const\n+  {\n+    return platform_id == o.platform_id &&\n+           encoding_id == o.encoding_id &&\n+           language_id == o.language_id &&\n+           name_id == o.name_id;\n+  }\n+\n+  inline uint32_t hash () const\n+  {\n+    uint32_t current = 0;\n+    current = current * 31 + hb_hash (platform_id);\n+    current = current * 31 + hb_hash (encoding_id);\n+    current = current * 31 + hb_hash (language_id);\n+    current = current * 31 + hb_hash (name_id);\n+    return current;\n+  }\n+\n+  unsigned platform_id;\n+  unsigned encoding_id;\n+  unsigned language_id;\n+  unsigned name_id;\n+};\n+\n+typedef struct hb_ot_name_record_ids_t hb_ot_name_record_ids_t;\n+\n+\n@@ -43,0 +85,12 @@\n+  HB_INTERNAL hb_subset_input_t ();\n+\n+  ~hb_subset_input_t ()\n+  {\n+    sets.~sets_t ();\n+\n+#ifdef HB_EXPERIMENTAL_API\n+    for (auto _ : name_table_overrides.values ())\n+      _.fini ();\n+#endif\n+  }\n+\n@@ -46,7 +100,8 @@\n-    hb_set_t *glyphs;\n-    hb_set_t *unicodes;\n-    hb_set_t *no_subset_tables;\n-    hb_set_t *drop_tables;\n-    hb_set_t *name_ids;\n-    hb_set_t *name_languages;\n-    hb_set_t *layout_features;\n+    hb::shared_ptr<hb_set_t> glyphs;\n+    hb::shared_ptr<hb_set_t> unicodes;\n+    hb::shared_ptr<hb_set_t> no_subset_tables;\n+    hb::shared_ptr<hb_set_t> drop_tables;\n+    hb::shared_ptr<hb_set_t> name_ids;\n+    hb::shared_ptr<hb_set_t> name_languages;\n+    hb::shared_ptr<hb_set_t> layout_features;\n+    hb::shared_ptr<hb_set_t> layout_scripts;\n@@ -57,1 +112,1 @@\n-    hb_set_t* set_ptrs[sizeof (sets_t) \/ sizeof (hb_set_t*)];\n+    hb::shared_ptr<hb_set_t> set_ptrs[sizeof (sets_t) \/ sizeof (hb_set_t*)];\n@@ -61,0 +116,9 @@\n+  bool attach_accelerator_data = false;\n+\n+  \/\/ If set loca format will always be the long version.\n+  bool force_long_loca = false;\n+\n+  hb_hashmap_t<hb_tag_t, float> axes_location;\n+#ifdef HB_EXPERIMENTAL_API\n+  hb_hashmap_t<hb_ot_name_record_ids_t, hb_bytes_t> name_table_overrides;\n+#endif\n@@ -67,1 +131,1 @@\n-  inline hb_array_t<hb_set_t*> sets_iter ()\n+  inline hb_array_t<hb::shared_ptr<hb_set_t>> sets_iter ()\n@@ -69,1 +133,1 @@\n-    return hb_array_t<hb_set_t*> (set_ptrs, num_sets ());\n+    return hb_array (set_ptrs);\n@@ -79,1 +143,6 @@\n-    return false;\n+\n+    return axes_location.in_error ()\n+#ifdef HB_EXPERIMENTAL_API\n+        || name_table_overrides.in_error ()\n+#endif\n+        ;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-input.hh","additions":81,"deletions":12,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"hb-subset-accelerator.hh\"\n@@ -29,0 +30,1 @@\n+#include \"hb-multimap.hh\"\n@@ -37,2 +39,2 @@\n-#include \"hb-ot-color-colr-table.hh\"\n-#include \"hb-ot-color-colrv1-closure.hh\"\n+#include \"OT\/Color\/COLR\/COLR.hh\"\n+#include \"OT\/Color\/COLR\/colrv1-closure.hh\"\n@@ -40,0 +42,1 @@\n+#include \"hb-ot-var-avar-table.hh\"\n@@ -43,1 +46,1 @@\n-using OT::Layout::GSUB::GSUB;\n+using OT::Layout::GSUB;\n@@ -48,1 +51,1 @@\n-static inline void\n+static inline bool\n@@ -58,0 +61,1 @@\n+    return true;\n@@ -59,0 +63,1 @@\n+  return false;\n@@ -83,4 +88,2 @@\n-  unsigned count = indexes->get_population ();\n-\n-  for (auto _ : + hb_zip (indexes->iter (), hb_range (count)))\n-    mapping->set (_.first, _.second);\n+  for (auto _ : + hb_enumerate (indexes->iter ()))\n+    mapping->set (_.second, _.first);\n@@ -91,1 +94,0 @@\n-typedef void (*layout_collect_func_t) (hb_face_t *face, hb_tag_t table_tag, const hb_tag_t *scripts, const hb_tag_t *languages, const hb_tag_t *features, hb_set_t *lookup_indexes \/* OUT *\/);\n@@ -93,0 +95,34 @@\n+\/*\n+ * Removes all tags from 'tags' that are not in filter. Additionally eliminates any duplicates.\n+ * Returns true if anything was removed (not including duplicates).\n+ *\/\n+static bool _filter_tag_list(hb_vector_t<hb_tag_t>* tags, \/* IN\/OUT *\/\n+                             const hb_set_t* filter)\n+{\n+  hb_vector_t<hb_tag_t> out;\n+  out.alloc (tags->get_size() + 1); \/\/ +1 is to allocate room for the null terminator.\n+\n+  bool removed = false;\n+  hb_set_t visited;\n+\n+  for (hb_tag_t tag : *tags)\n+  {\n+    if (!tag) continue;\n+    if (visited.has (tag)) continue;\n+\n+    if (!filter->has (tag))\n+    {\n+      removed = true;\n+      continue;\n+    }\n+\n+    visited.add (tag);\n+    out.push (tag);\n+  }\n+\n+  \/\/ The collect function needs a null element to signal end of the array.\n+  out.push (HB_TAG_NONE);\n+\n+  hb_swap (out, *tags);\n+  return removed;\n+}\n@@ -95,1 +131,1 @@\n-static void _collect_layout_indices (hb_face_t            *face,\n+static void _collect_layout_indices (hb_subset_plan_t     *plan,\n@@ -97,3 +133,4 @@\n-                                     const hb_set_t       *layout_features_to_retain,\n-                                     layout_collect_func_t layout_collect_func,\n-                                     hb_set_t             *indices \/* OUT *\/)\n+                                     hb_set_t             *lookup_indices, \/* OUT *\/\n+                                     hb_set_t             *feature_indices, \/* OUT *\/\n+                                     hb_hashmap_t<unsigned, hb::shared_ptr<hb_set_t>> *feature_record_cond_idx_map, \/* OUT *\/\n+                                     hb_hashmap_t<unsigned, const OT::Feature*> *feature_substitutes_map \/* OUT *\/)\n@@ -101,0 +138,1 @@\n+  unsigned num_features = table.get_feature_count ();\n@@ -102,1 +140,12 @@\n-  if (!features.alloc (table.get_feature_count () + 1))\n+  if (!plan->check_success (features.resize (num_features))) return;\n+  table.get_feature_tags (0, &num_features, features.arrayZ);\n+  bool retain_all_features = !_filter_tag_list (&features, &plan->layout_features);\n+\n+  unsigned num_scripts = table.get_script_count ();\n+  hb_vector_t<hb_tag_t> scripts;\n+  if (!plan->check_success (scripts.resize (num_scripts))) return;\n+  table.get_script_tags (0, &num_scripts, scripts.arrayZ);\n+  bool retain_all_scripts = !_filter_tag_list (&scripts, &plan->layout_scripts);\n+\n+  if (!plan->check_success (!features.in_error ()) || !features\n+      || !plan->check_success (!scripts.in_error ()) || !scripts)\n@@ -105,3 +154,10 @@\n-  hb_set_t visited_features;\n-  bool retain_all_features = true;\n-  for (unsigned i = 0; i < table.get_feature_count (); i++)\n+  hb_ot_layout_collect_features (plan->source,\n+                                 T::tableTag,\n+                                 retain_all_scripts ? nullptr : scripts.arrayZ,\n+                                 nullptr,\n+                                 retain_all_features ? nullptr : features.arrayZ,\n+                                 feature_indices);\n+\n+#ifndef HB_NO_VAR\n+  \/\/ collect feature substitutes with variations\n+  if (!plan->user_axes_location.is_empty ())\n@@ -109,3 +165,2 @@\n-    hb_tag_t tag = table.get_feature_tag (i);\n-    if (!tag) continue;\n-    if (!layout_features_to_retain->has (tag))\n+    hb_hashmap_t<hb::shared_ptr<hb_map_t>, unsigned> conditionset_map;\n+    OT::hb_collect_feature_substitutes_with_var_context_t c =\n@@ -113,3 +168,12 @@\n-      retain_all_features = false;\n-      continue;\n-    }\n+      &plan->axes_old_index_tag_map,\n+      &plan->axes_location,\n+      feature_record_cond_idx_map,\n+      feature_substitutes_map,\n+      feature_indices,\n+      true,\n+      0,\n+      &conditionset_map\n+    };\n+    table.collect_feature_substitutes_with_variations (&c);\n+  }\n+#endif\n@@ -117,2 +181,6 @@\n-    if (visited_features.has (tag))\n-      continue;\n+  for (unsigned feature_index : *feature_indices)\n+  {\n+    const OT::Feature* f = &(table.get_feature (feature_index));\n+    const OT::Feature **p = nullptr;\n+    if (feature_substitutes_map->has (feature_index, &p))\n+      f = *p;\n@@ -120,2 +188,1 @@\n-    features.push (tag);\n-    visited_features.add (tag);\n+    f->add_lookup_indexes_to (lookup_indices);\n@@ -124,2 +191,12 @@\n-  if (!features)\n-    return;\n+  \/\/ If all axes are pinned then all feature variations will be dropped so there's no need\n+  \/\/ to collect lookups from them.\n+  if (!plan->all_axes_pinned)\n+  {\n+    \/\/ TODO(qxliu76): this collection doesn't work correctly for feature variations that are dropped\n+    \/\/                but not applied. The collection will collect and retain the lookup indices\n+    \/\/                associated with those dropped but not activated rules. Since partial instancing\n+    \/\/                isn't yet supported this isn't an issue yet but will need to be fixed for\n+    \/\/                partial instancing.\n+    table.feature_variation_collect_lookups (feature_indices, feature_substitutes_map, lookup_indices);\n+  }\n+}\n@@ -127,2 +204,0 @@\n-  \/\/ The collect function needs a null element to signal end of the array.\n-  features.push (0);\n@@ -130,1 +205,11 @@\n-  if (retain_all_features)\n+static inline void\n+_GSUBGPOS_find_duplicate_features (const OT::GSUBGPOS &g,\n+                                   const hb_map_t *lookup_indices,\n+                                   const hb_set_t *feature_indices,\n+                                   const hb_hashmap_t<unsigned, const OT::Feature*> *feature_substitutes_map,\n+                                   hb_map_t *duplicate_feature_map \/* OUT *\/)\n+{\n+  if (feature_indices->is_empty ()) return;\n+  hb_hashmap_t<hb_tag_t, hb::unique_ptr<hb_set_t>> unique_features;\n+  \/\/find out duplicate features after subset\n+  for (unsigned i : feature_indices->iter ())\n@@ -132,9 +217,45 @@\n-    \/\/ Looking for all features, trigger the faster collection method.\n-    layout_collect_func (face,\n-                         T::tableTag,\n-                         nullptr,\n-                         nullptr,\n-                         nullptr,\n-                         indices);\n-    return;\n-  }\n+    hb_tag_t t = g.get_feature_tag (i);\n+    if (t == HB_MAP_VALUE_INVALID) continue;\n+    if (!unique_features.has (t))\n+    {\n+      if (unlikely (!unique_features.set (t, hb::unique_ptr<hb_set_t> {hb_set_create ()})))\n+        return;\n+      if (unique_features.has (t))\n+        unique_features.get (t)->add (i);\n+      duplicate_feature_map->set (i, i);\n+      continue;\n+    }\n+\n+    bool found = false;\n+\n+    hb_set_t* same_tag_features = unique_features.get (t);\n+    for (unsigned other_f_index : same_tag_features->iter ())\n+    {\n+      const OT::Feature* f = &(g.get_feature (i));\n+      const OT::Feature **p = nullptr;\n+      if (feature_substitutes_map->has (i, &p))\n+        f = *p;\n+\n+      const OT::Feature* other_f = &(g.get_feature (other_f_index));\n+      if (feature_substitutes_map->has (other_f_index, &p))\n+        other_f = *p;\n+\n+      auto f_iter =\n+      + hb_iter (f->lookupIndex)\n+      | hb_filter (lookup_indices)\n+      ;\n+\n+      auto other_f_iter =\n+      + hb_iter (other_f->lookupIndex)\n+      | hb_filter (lookup_indices)\n+      ;\n+\n+      bool is_equal = true;\n+      for (; f_iter && other_f_iter; f_iter++, other_f_iter++)\n+      {\n+        unsigned a = *f_iter;\n+        unsigned b = *other_f_iter;\n+        if (a != b) { is_equal = false; break; }\n+      }\n+\n+      if (is_equal == false || f_iter || other_f_iter) continue;\n@@ -142,6 +263,11 @@\n-  layout_collect_func (face,\n-                       T::tableTag,\n-                       nullptr,\n-                       nullptr,\n-                       features.arrayZ,\n-                       indices);\n+      found = true;\n+      duplicate_feature_map->set (i, other_f_index);\n+      break;\n+    }\n+\n+    if (found == false)\n+    {\n+      same_tag_features->add (i);\n+      duplicate_feature_map->set (i, i);\n+    }\n+  }\n@@ -152,1 +278,1 @@\n-_closure_glyphs_lookups_features (hb_face_t          *face,\n+_closure_glyphs_lookups_features (hb_subset_plan_t   *plan,\n@@ -154,1 +280,0 @@\n-                                  const hb_set_t     *layout_features_to_retain,\n@@ -157,1 +282,3 @@\n-                                  script_langsys_map *langsys_map)\n+                                  script_langsys_map *langsys_map,\n+                                  hb_hashmap_t<unsigned, hb::shared_ptr<hb_set_t>> *feature_record_cond_idx_map,\n+                                  hb_hashmap_t<unsigned, const OT::Feature*> *feature_substitutes_map)\n@@ -159,1 +286,1 @@\n-  hb_blob_ptr_t<T> table = hb_sanitize_context_t ().reference_table<T> (face);\n+  hb_blob_ptr_t<T> table = plan->source_table<T> ();\n@@ -161,2 +288,2 @@\n-  hb_set_t lookup_indices;\n-  _collect_layout_indices<T> (face,\n+  hb_set_t lookup_indices, feature_indices;\n+  _collect_layout_indices<T> (plan,\n@@ -164,3 +291,4 @@\n-                              layout_features_to_retain,\n-                              hb_ot_layout_collect_lookups,\n-                              &lookup_indices);\n+                              &lookup_indices,\n+                              &feature_indices,\n+                              feature_record_cond_idx_map,\n+                              feature_substitutes_map);\n@@ -169,2 +297,2 @@\n-    hb_ot_layout_lookups_substitute_closure (face,\n-                                            &lookup_indices,\n+    hb_ot_layout_lookups_substitute_closure (plan->source,\n+                                             &lookup_indices,\n@@ -172,1 +300,1 @@\n-  table->closure_lookups (face,\n+  table->closure_lookups (plan->source,\n@@ -174,1 +302,1 @@\n-                         &lookup_indices);\n+                          &lookup_indices);\n@@ -177,9 +305,5 @@\n-  \/\/ Collect and prune features\n-  hb_set_t feature_indices;\n-  _collect_layout_indices<T> (face,\n-                              *table,\n-                              layout_features_to_retain,\n-                              hb_ot_layout_collect_features,\n-                              &feature_indices);\n-\n-  table->prune_features (lookups, &feature_indices);\n+  \/\/ prune features\n+  table->prune_features (lookups,\n+                         plan->user_axes_location.is_empty () ? nullptr : feature_record_cond_idx_map,\n+                         feature_substitutes_map,\n+                         &feature_indices);\n@@ -187,1 +311,1 @@\n-  table->find_duplicate_features (lookups, &feature_indices, &duplicate_feature_map);\n+  _GSUBGPOS_find_duplicate_features (*table, lookups, &feature_indices, feature_substitutes_map, &duplicate_feature_map);\n@@ -190,1 +314,1 @@\n-  table->prune_langsys (&duplicate_feature_map, langsys_map, &feature_indices);\n+  table->prune_langsys (&duplicate_feature_map, &plan->layout_scripts, langsys_map, &feature_indices);\n@@ -200,5 +324,3 @@\n-  _collect_layout_variation_indices (hb_face_t *face,\n-                                     const hb_set_t *glyphset,\n-                                     const hb_map_t *gpos_lookups,\n-                                     hb_set_t  *layout_variation_indices,\n-                                     hb_map_t  *layout_variation_idx_map)\n+_generate_varstore_inner_maps (const hb_set_t& varidx_set,\n+                               unsigned subtable_count,\n+                               hb_vector_t<hb_inc_bimap_t> &inner_maps \/* OUT *\/)\n@@ -206,2 +328,41 @@\n-  hb_blob_ptr_t<OT::GDEF> gdef = hb_sanitize_context_t ().reference_table<OT::GDEF> (face);\n-  hb_blob_ptr_t<GPOS> gpos = hb_sanitize_context_t ().reference_table<GPOS> (face);\n+  if (varidx_set.is_empty () || subtable_count == 0) return;\n+\n+  inner_maps.resize (subtable_count);\n+  for (unsigned idx : varidx_set)\n+  {\n+    uint16_t major = idx >> 16;\n+    uint16_t minor = idx & 0xFFFF;\n+\n+    if (major >= subtable_count)\n+      continue;\n+    inner_maps[major].add (minor);\n+  }\n+}\n+\n+static inline hb_font_t*\n+_get_hb_font_with_variations (const hb_subset_plan_t *plan)\n+{\n+  hb_font_t *font = hb_font_create (plan->source);\n+\n+  hb_vector_t<hb_variation_t> vars;\n+  vars.alloc (plan->user_axes_location.get_population ());\n+\n+  for (auto _ : plan->user_axes_location)\n+  {\n+    hb_variation_t var;\n+    var.tag = _.first;\n+    var.value = _.second;\n+    vars.push (var);\n+  }\n+\n+#ifndef HB_NO_VAR\n+  hb_font_set_variations (font, vars.arrayZ, plan->user_axes_location.get_population ());\n+#endif\n+  return font;\n+}\n+\n+static inline void\n+_collect_layout_variation_indices (hb_subset_plan_t* plan)\n+{\n+  hb_blob_ptr_t<OT::GDEF> gdef = plan->source_table<OT::GDEF> ();\n+  hb_blob_ptr_t<GPOS> gpos = plan->source_table<GPOS> ();\n@@ -215,1 +376,22 @@\n-  OT::hb_collect_variation_indices_context_t c (layout_variation_indices, glyphset, gpos_lookups);\n+\n+  const OT::VariationStore *var_store = nullptr;\n+  hb_set_t varidx_set;\n+  hb_font_t *font = nullptr;\n+  float *store_cache = nullptr;\n+  bool collect_delta = plan->pinned_at_default ? false : true;\n+  if (collect_delta)\n+  {\n+    font = _get_hb_font_with_variations (plan);\n+    if (gdef->has_var_store ())\n+    {\n+      var_store = &(gdef->get_var_store ());\n+      store_cache = var_store->create_cache ();\n+    }\n+  }\n+\n+  OT::hb_collect_variation_indices_context_t c (&varidx_set,\n+                                                &plan->layout_variation_idx_delta_map,\n+                                                font, var_store,\n+                                                &plan->_glyphset_gsub,\n+                                                &plan->gpos_lookups,\n+                                                store_cache);\n@@ -218,1 +400,1 @@\n-  if (hb_ot_layout_has_positioning (face))\n+  if (hb_ot_layout_has_positioning (plan->source))\n@@ -221,1 +403,7 @@\n-  gdef->remap_layout_variation_indices (layout_variation_indices, layout_variation_idx_map);\n+  hb_font_destroy (font);\n+  var_store->destroy_cache (store_cache);\n+\n+  gdef->remap_layout_variation_indices (&varidx_set, &plan->layout_variation_idx_delta_map);\n+\n+  unsigned subtable_count = gdef->has_var_store () ? gdef->get_var_store ().get_sub_table_count () : 0;\n+  _generate_varstore_inner_maps (varidx_set, subtable_count, plan->gdef_varstore_inner_maps);\n@@ -245,1 +433,0 @@\n-  unsigned iteration_count = 0;\n@@ -247,7 +434,4 @@\n-  unsigned glyphs_num;\n-  {\n-    glyphs_num = glyphs_colred->get_population ();\n-    \/\/ Collect all glyphs referenced by COLRv0\n-    hb_set_t glyphset_colrv0;\n-    for (hb_codepoint_t gid : glyphs_colred->iter ())\n-      colr.closure_glyphs (gid, &glyphset_colrv0);\n+  \/\/ Collect all glyphs referenced by COLRv0\n+  hb_set_t glyphset_colrv0;\n+  for (hb_codepoint_t gid : *glyphs_colred)\n+    colr.closure_glyphs (gid, &glyphset_colrv0);\n@@ -255,1 +439,1 @@\n-    glyphs_colred->union_ (glyphset_colrv0);\n+  glyphs_colred->union_ (glyphset_colrv0);\n@@ -257,4 +441,2 @@\n-    \/\/closure for COLRv1\n-    colr.closure_forV1 (glyphs_colred, &layer_indices, &palette_indices);\n-  } while (iteration_count++ <= HB_CLOSURE_MAX_STAGES &&\n-           glyphs_num != glyphs_colred->get_population ());\n+  \/\/closure for COLRv1\n+  colr.closure_forV1 (glyphs_colred, &layer_indices, &palette_indices);\n@@ -268,2 +450,2 @@\n-_math_closure (hb_face_t           *face,\n-               hb_set_t            *glyphset)\n+_math_closure (hb_subset_plan_t *plan,\n+               hb_set_t         *glyphset)\n@@ -271,1 +453,1 @@\n-  hb_blob_ptr_t<OT::MATH> math = hb_sanitize_context_t ().reference_table<OT::MATH> (face);\n+  hb_blob_ptr_t<OT::MATH> math = plan->source_table<OT::MATH> ();\n@@ -291,1 +473,0 @@\n-\n@@ -295,0 +476,5 @@\n+\n+    const hb_map_t* unicode_to_gid = nullptr;\n+    if (plan->accelerator)\n+      unicode_to_gid = &plan->accelerator->unicode_to_gid;\n+\n@@ -299,4 +485,2 @@\n-    for (hb_codepoint_t cp : *unicodes)\n-    {\n-      hb_codepoint_t gid;\n-      if (!cmap.get_nominal_glyph (cp, &gid))\n+    if (!unicode_to_gid) {\n+      for (hb_codepoint_t cp : *unicodes)\n@@ -304,2 +488,26 @@\n-        DEBUG_MSG(SUBSET, nullptr, \"Drop U+%04X; no gid\", cp);\n-        continue;\n+        hb_codepoint_t gid;\n+        if (!cmap.get_nominal_glyph (cp, &gid))\n+        {\n+          DEBUG_MSG(SUBSET, nullptr, \"Drop U+%04X; no gid\", cp);\n+          continue;\n+        }\n+\n+        plan->codepoint_to_glyph->set (cp, gid);\n+        plan->unicode_to_new_gid_list.push (hb_pair (cp, gid));\n+      }\n+    } else {\n+      \/\/ Use in memory unicode to gid map it's faster then looking up from\n+      \/\/ the map. This code is mostly duplicated from above to avoid doing\n+      \/\/ conditionals on the presence of the unicode_to_gid map each\n+      \/\/ iteration.\n+      for (hb_codepoint_t cp : *unicodes)\n+      {\n+        hb_codepoint_t gid = unicode_to_gid->get (cp);\n+        if (gid == HB_MAP_VALUE_INVALID)\n+        {\n+          DEBUG_MSG(SUBSET, nullptr, \"Drop U+%04X; no gid\", cp);\n+          continue;\n+        }\n+\n+        plan->codepoint_to_glyph->set (cp, gid);\n+        plan->unicode_to_new_gid_list.push (hb_pair (cp, gid));\n@@ -307,3 +515,0 @@\n-\n-      plan->codepoint_to_glyph->set (cp, gid);\n-      plan->unicode_to_new_gid_list.push (hb_pair (cp, gid));\n@@ -316,8 +521,19 @@\n-    hb_map_t unicode_glyphid_map;\n-    hb_set_t cmap_unicodes;\n-    cmap.collect_mapping (&cmap_unicodes, &unicode_glyphid_map);\n-    plan->unicode_to_new_gid_list.alloc (hb_min(unicodes->get_population ()\n-                                                + glyphs->get_population (),\n-                                                cmap_unicodes.get_population ()));\n-\n-    for (hb_codepoint_t cp : cmap_unicodes)\n+\n+    hb_map_t unicode_glyphid_map_storage;\n+    hb_set_t cmap_unicodes_storage;\n+    const hb_map_t* unicode_glyphid_map = &unicode_glyphid_map_storage;\n+    const hb_set_t* cmap_unicodes = &cmap_unicodes_storage;\n+\n+    if (!plan->accelerator) {\n+      cmap.collect_mapping (&cmap_unicodes_storage, &unicode_glyphid_map_storage);\n+      plan->unicode_to_new_gid_list.alloc (hb_min(unicodes->get_population ()\n+                                                  + glyphs->get_population (),\n+                                                  cmap_unicodes->get_population ()));\n+    } else {\n+      unicode_glyphid_map = &plan->accelerator->unicode_to_gid;\n+      cmap_unicodes = &plan->accelerator->unicodes;\n+    }\n+\n+    if (plan->accelerator &&\n+        unicodes->get_population () < cmap_unicodes->get_population () &&\n+        glyphs->get_population () < cmap_unicodes->get_population ())\n@@ -325,3 +541,16 @@\n-      hb_codepoint_t gid = unicode_glyphid_map[cp];\n-      if (!unicodes->has (cp) && !glyphs->has (gid))\n-        continue;\n+      auto &gid_to_unicodes = plan->accelerator->gid_to_unicodes;\n+      for (hb_codepoint_t gid : *glyphs)\n+      {\n+        auto unicodes = gid_to_unicodes.get (gid);\n+\n+        for (hb_codepoint_t cp : unicodes)\n+        {\n+          plan->codepoint_to_glyph->set (cp, gid);\n+          plan->unicode_to_new_gid_list.push (hb_pair (cp, gid));\n+        }\n+      }\n+      for (hb_codepoint_t cp : *unicodes)\n+      {\n+        \/* Don't double-add entry. *\/\n+        if (plan->codepoint_to_glyph->has (cp))\n+          continue;\n@@ -329,2 +558,17 @@\n-      plan->codepoint_to_glyph->set (cp, gid);\n-      plan->unicode_to_new_gid_list.push (hb_pair (cp, gid));\n+        hb_codepoint_t gid = (*unicode_glyphid_map)[cp];\n+        plan->codepoint_to_glyph->set (cp, gid);\n+        plan->unicode_to_new_gid_list.push (hb_pair (cp, gid));\n+      }\n+      plan->unicode_to_new_gid_list.qsort ();\n+    }\n+    else\n+    {\n+      for (hb_codepoint_t cp : *cmap_unicodes)\n+      {\n+        hb_codepoint_t gid = (*unicode_glyphid_map)[cp];\n+        if (!unicodes->has (cp) && !glyphs->has (gid))\n+          continue;\n+\n+        plan->codepoint_to_glyph->set (cp, gid);\n+        plan->unicode_to_new_gid_list.push (hb_pair (cp, gid));\n+      }\n@@ -338,1 +582,1 @@\n-      plan->_glyphset_gsub->add (gid);\n+      plan->_glyphset_gsub.add (gid);\n@@ -345,2 +589,2 @@\n-    plan->unicodes->add_sorted_array (&arr.arrayZ->first, arr.length, sizeof (*arr.arrayZ));\n-    plan->_glyphset_gsub->add_array (&arr.arrayZ->second, arr.length, sizeof (*arr.arrayZ));\n+    plan->unicodes.add_sorted_array (&arr.arrayZ->first, arr.length, sizeof (*arr.arrayZ));\n+    plan->_glyphset_gsub.add_array (&arr.arrayZ->second, arr.length, sizeof (*arr.arrayZ));\n@@ -371,1 +615,1 @@\n-                                  item.glyphIndex,\n+                                  item.get_gid (),\n@@ -381,3 +625,1 @@\n-                          bool close_over_gsub,\n-                          bool close_over_gpos,\n-                          bool close_over_gdef)\n+                          hb_set_t* drop_tables)\n@@ -390,1 +632,1 @@\n-  plan->_glyphset_gsub->add (0); \/\/ Not-def\n+  plan->_glyphset_gsub.add (0); \/\/ Not-def\n@@ -392,1 +634,1 @@\n-  _cmap_closure (plan->source, plan->unicodes, plan->_glyphset_gsub);\n+  _cmap_closure (plan->source, &plan->unicodes, &plan->_glyphset_gsub);\n@@ -395,1 +637,1 @@\n-  if (close_over_gsub)\n+  if (!drop_tables->has (HB_OT_TAG_GSUB))\n@@ -398,8 +640,9 @@\n-        plan->source,\n-        plan->_glyphset_gsub,\n-        plan->layout_features,\n-        plan->gsub_lookups,\n-        plan->gsub_features,\n-        plan->gsub_langsys);\n-\n-  if (close_over_gpos)\n+        plan,\n+        &plan->_glyphset_gsub,\n+        &plan->gsub_lookups,\n+        &plan->gsub_features,\n+        &plan->gsub_langsys,\n+        &plan->gsub_feature_record_cond_idx_map,\n+        &plan->gsub_feature_substitutes_map);\n+\n+  if (!drop_tables->has (HB_OT_TAG_GPOS))\n@@ -407,6 +650,7 @@\n-        plan->source,\n-        plan->_glyphset_gsub,\n-        plan->layout_features,\n-        plan->gpos_lookups,\n-        plan->gpos_features,\n-        plan->gpos_langsys);\n+        plan,\n+        &plan->_glyphset_gsub,\n+        &plan->gpos_lookups,\n+        &plan->gpos_features,\n+        &plan->gpos_langsys,\n+        &plan->gpos_feature_record_cond_idx_map,\n+        &plan->gpos_feature_substitutes_map);\n@@ -414,1 +658,1 @@\n-  _remove_invalid_gids (plan->_glyphset_gsub, plan->source->get_num_glyphs ());\n+  _remove_invalid_gids (&plan->_glyphset_gsub, plan->source->get_num_glyphs ());\n@@ -416,3 +660,6 @@\n-  hb_set_set (plan->_glyphset_mathed, plan->_glyphset_gsub);\n-  _math_closure (plan->source, plan->_glyphset_mathed);\n-  _remove_invalid_gids (plan->_glyphset_mathed, plan->source->get_num_glyphs ());\n+  plan->_glyphset_mathed = plan->_glyphset_gsub;\n+  if (!drop_tables->has (HB_OT_TAG_MATH))\n+  {\n+    _math_closure (plan, &plan->_glyphset_mathed);\n+    _remove_invalid_gids (&plan->_glyphset_mathed, plan->source->get_num_glyphs ());\n+  }\n@@ -420,3 +667,6 @@\n-  hb_set_t cur_glyphset = *plan->_glyphset_mathed;\n-  _colr_closure (plan->source, plan->colrv1_layers, plan->colr_palettes, &cur_glyphset);\n-  _remove_invalid_gids (&cur_glyphset, plan->source->get_num_glyphs ());\n+  hb_set_t cur_glyphset = plan->_glyphset_mathed;\n+  if (!drop_tables->has (HB_OT_TAG_COLR))\n+  {\n+    _colr_closure (plan->source, &plan->colrv1_layers, &plan->colr_palettes, &cur_glyphset);\n+    _remove_invalid_gids (&cur_glyphset, plan->source->get_num_glyphs ());\n+  }\n@@ -424,1 +674,1 @@\n-  hb_set_set (plan->_glyphset_colred, &cur_glyphset);\n+  plan->_glyphset_colred = cur_glyphset;\n@@ -430,1 +680,1 @@\n-      _glyf_add_gid_and_children (glyf, gid, plan->_glyphset,\n+      _glyf_add_gid_and_children (glyf, gid, &plan->_glyphset,\n@@ -433,1 +683,1 @@\n-    plan->_glyphset->union_ (cur_glyphset);\n+    plan->_glyphset.union_ (cur_glyphset);\n@@ -435,3 +685,9 @@\n-  if (cff.is_valid ())\n-    for (hb_codepoint_t gid : cur_glyphset)\n-      _add_cff_seac_components (cff, gid, plan->_glyphset);\n+  if (!plan->accelerator || plan->accelerator->has_seac)\n+  {\n+    bool has_seac = false;\n+    if (cff.is_valid ())\n+      for (hb_codepoint_t gid : cur_glyphset)\n+        if (_add_cff_seac_components (cff, gid, &plan->_glyphset))\n+          has_seac = true;\n+    plan->has_seac = has_seac;\n+  }\n@@ -440,1 +696,1 @@\n-  _remove_invalid_gids (plan->_glyphset, plan->source->get_num_glyphs ());\n+  _remove_invalid_gids (&plan->_glyphset, plan->source->get_num_glyphs ());\n@@ -444,6 +700,2 @@\n-  if (close_over_gdef)\n-    _collect_layout_variation_indices (plan->source,\n-                                       plan->_glyphset_gsub,\n-                                       plan->gpos_lookups,\n-                                       plan->layout_variation_indices,\n-                                       plan->layout_variation_idx_map);\n+  if (!drop_tables->has (HB_OT_TAG_GDEF))\n+    _collect_layout_variation_indices (plan);\n@@ -509,1 +761,3 @@\n-                 hb_set_t  *nameids)\n+                 hb_set_t  *nameids,\n+                 bool all_axes_pinned,\n+                 hb_hashmap_t<hb_tag_t, float> *user_axes_location)\n@@ -512,1 +766,1 @@\n-  face->table.STAT->collect_name_ids (nameids);\n+  face->table.STAT->collect_name_ids (user_axes_location, nameids);\n@@ -515,1 +769,2 @@\n-  face->table.fvar->collect_name_ids (nameids);\n+  if (!all_axes_pinned)\n+    face->table.fvar->collect_name_ids (user_axes_location, nameids);\n@@ -519,0 +774,158 @@\n+#ifndef HB_NO_VAR\n+static void\n+_normalize_axes_location (hb_face_t *face, hb_subset_plan_t *plan)\n+{\n+  if (plan->user_axes_location.is_empty ())\n+    return;\n+\n+  hb_array_t<const OT::AxisRecord> axes = face->table.fvar->get_axes ();\n+  plan->normalized_coords.resize (axes.length);\n+\n+  bool has_avar = face->table.avar->has_data ();\n+  const OT::SegmentMaps *seg_maps = nullptr;\n+  if (has_avar)\n+    seg_maps = face->table.avar->get_segment_maps ();\n+\n+  bool axis_not_pinned = false;\n+  unsigned old_axis_idx = 0, new_axis_idx = 0;\n+  unsigned int i = 0;\n+  for (const auto& axis : axes)\n+  {\n+    hb_tag_t axis_tag = axis.get_axis_tag ();\n+    plan->axes_old_index_tag_map.set (old_axis_idx, axis_tag);\n+\n+    if (!plan->user_axes_location.has (axis_tag))\n+    {\n+      axis_not_pinned = true;\n+      plan->axes_index_map.set (old_axis_idx, new_axis_idx);\n+      new_axis_idx++;\n+    }\n+    else\n+    {\n+      int normalized_v = axis.normalize_axis_value (plan->user_axes_location.get (axis_tag));\n+      if (has_avar && old_axis_idx < face->table.avar->get_axis_count ())\n+      {\n+        normalized_v = seg_maps->map (normalized_v);\n+      }\n+      plan->axes_location.set (axis_tag, normalized_v);\n+      if (normalized_v != 0)\n+        plan->pinned_at_default = false;\n+\n+      plan->normalized_coords[i] = normalized_v;\n+    }\n+    if (has_avar)\n+      seg_maps = &StructAfter<OT::SegmentMaps> (*seg_maps);\n+\n+    old_axis_idx++;\n+\n+    i++;\n+  }\n+  plan->all_axes_pinned = !axis_not_pinned;\n+}\n+#endif\n+\n+hb_subset_plan_t::hb_subset_plan_t (hb_face_t *face,\n+                                    const hb_subset_input_t *input)\n+{\n+  successful = true;\n+  flags = input->flags;\n+\n+  unicode_to_new_gid_list.init ();\n+\n+  name_ids = *input->sets.name_ids;\n+  name_languages = *input->sets.name_languages;\n+  layout_features = *input->sets.layout_features;\n+  layout_scripts = *input->sets.layout_scripts;\n+  glyphs_requested = *input->sets.glyphs;\n+  drop_tables = *input->sets.drop_tables;\n+  no_subset_tables = *input->sets.no_subset_tables;\n+  source = hb_face_reference (face);\n+  dest = hb_face_builder_create ();\n+\n+  codepoint_to_glyph = hb_map_create ();\n+  glyph_map = hb_map_create ();\n+  reverse_glyph_map = hb_map_create ();\n+\n+  gdef_varstore_inner_maps.init ();\n+\n+  user_axes_location = input->axes_location;\n+  all_axes_pinned = false;\n+  pinned_at_default = true;\n+\n+#ifdef HB_EXPERIMENTAL_API\n+  for (auto _ : input->name_table_overrides)\n+  {\n+    hb_bytes_t name_bytes = _.second;\n+    unsigned len = name_bytes.length;\n+    char *name_str = (char *) hb_malloc (len);\n+    if (unlikely (!check_success (name_str)))\n+      break;\n+\n+    hb_memcpy (name_str, name_bytes.arrayZ, len);\n+    name_table_overrides.set (_.first, hb_bytes_t (name_str, len));\n+  }\n+#endif\n+\n+  void* accel = hb_face_get_user_data(face, hb_subset_accelerator_t::user_data_key());\n+\n+  attach_accelerator_data = input->attach_accelerator_data;\n+  force_long_loca = input->force_long_loca;\n+  if (accel)\n+    accelerator = (hb_subset_accelerator_t*) accel;\n+\n+\n+  if (unlikely (in_error ()))\n+    return;\n+\n+#ifndef HB_NO_VAR\n+  _normalize_axes_location (face, this);\n+#endif\n+\n+  _populate_unicodes_to_retain (input->sets.unicodes, input->sets.glyphs, this);\n+\n+  _populate_gids_to_retain (this, input->sets.drop_tables);\n+\n+  _create_old_gid_to_new_gid_map (face,\n+                                  input->flags & HB_SUBSET_FLAGS_RETAIN_GIDS,\n+                                  &_glyphset,\n+                                  glyph_map,\n+                                  reverse_glyph_map,\n+                                  &_num_output_glyphs);\n+\n+  _create_glyph_map_gsub (\n+      &_glyphset_gsub,\n+      glyph_map,\n+      &glyph_map_gsub);\n+\n+  \/\/ Now that we have old to new gid map update the unicode to new gid list.\n+  for (unsigned i = 0; i < unicode_to_new_gid_list.length; i++)\n+  {\n+    \/\/ Use raw array access for performance.\n+    unicode_to_new_gid_list.arrayZ[i].second =\n+        glyph_map->get(unicode_to_new_gid_list.arrayZ[i].second);\n+  }\n+\n+  _nameid_closure (face, &name_ids, all_axes_pinned, &user_axes_location);\n+  if (unlikely (in_error ()))\n+    return;\n+\n+  if (attach_accelerator_data)\n+  {\n+    hb_multimap_t gid_to_unicodes;\n+\n+    hb_map_t &unicode_to_gid = *codepoint_to_glyph;\n+\n+    for (auto unicode : unicodes)\n+    {\n+      auto gid = unicode_to_gid[unicode];\n+      gid_to_unicodes.add (gid, unicode);\n+    }\n+\n+    inprogress_accelerator =\n+      hb_subset_accelerator_t::create (*codepoint_to_glyph,\n+                                       gid_to_unicodes,\n+                                       unicodes,\n+                                       has_seac);\n+  }\n+}\n+\n@@ -539,44 +952,1 @@\n-  if (unlikely (!(plan = hb_object_create<hb_subset_plan_t> ())))\n-    return nullptr;\n-\n-  plan->successful = true;\n-  plan->flags = input->flags;\n-  plan->unicodes = hb_set_create ();\n-\n-  plan->unicode_to_new_gid_list.init ();\n-\n-  plan->name_ids = hb_set_copy (input->sets.name_ids);\n-  _nameid_closure (face, plan->name_ids);\n-  plan->name_languages = hb_set_copy (input->sets.name_languages);\n-  plan->layout_features = hb_set_copy (input->sets.layout_features);\n-  plan->glyphs_requested = hb_set_copy (input->sets.glyphs);\n-  plan->drop_tables = hb_set_copy (input->sets.drop_tables);\n-  plan->no_subset_tables = hb_set_copy (input->sets.no_subset_tables);\n-  plan->source = hb_face_reference (face);\n-  plan->dest = hb_face_builder_create ();\n-\n-  plan->_glyphset = hb_set_create ();\n-  plan->_glyphset_gsub = hb_set_create ();\n-  plan->_glyphset_mathed = hb_set_create ();\n-  plan->_glyphset_colred = hb_set_create ();\n-  plan->codepoint_to_glyph = hb_map_create ();\n-  plan->glyph_map = hb_map_create ();\n-  plan->reverse_glyph_map = hb_map_create ();\n-  plan->glyph_map_gsub = hb_map_create ();\n-  plan->gsub_lookups = hb_map_create ();\n-  plan->gpos_lookups = hb_map_create ();\n-\n-  if (plan->check_success (plan->gsub_langsys = hb_object_create<script_langsys_map> ()))\n-    plan->gsub_langsys->init_shallow ();\n-  if (plan->check_success (plan->gpos_langsys = hb_object_create<script_langsys_map> ()))\n-    plan->gpos_langsys->init_shallow ();\n-\n-  plan->gsub_features = hb_map_create ();\n-  plan->gpos_features = hb_map_create ();\n-  plan->colrv1_layers = hb_map_create ();\n-  plan->colr_palettes = hb_map_create ();\n-  plan->layout_variation_indices = hb_set_create ();\n-  plan->layout_variation_idx_map = hb_map_create ();\n-\n-  if (unlikely (plan->in_error ())) {\n-    hb_subset_plan_destroy (plan);\n+  if (unlikely (!(plan = hb_object_create<hb_subset_plan_t> (face, input))))\n@@ -584,20 +954,0 @@\n-  }\n-\n-  _populate_unicodes_to_retain (input->sets.unicodes, input->sets.glyphs, plan);\n-\n-  _populate_gids_to_retain (plan,\n-                            !input->sets.drop_tables->has (HB_OT_TAG_GSUB),\n-                            !input->sets.drop_tables->has (HB_OT_TAG_GPOS),\n-                            !input->sets.drop_tables->has (HB_OT_TAG_GDEF));\n-\n-  _create_old_gid_to_new_gid_map (face,\n-                                  input->flags & HB_SUBSET_FLAGS_RETAIN_GIDS,\n-                                  plan->_glyphset,\n-                                  plan->glyph_map,\n-                                  plan->reverse_glyph_map,\n-                                  &plan->_num_output_glyphs);\n-\n-  _create_glyph_map_gsub (\n-      plan->_glyphset_gsub,\n-      plan->glyph_map,\n-      plan->glyph_map_gsub);\n@@ -605,2 +955,1 @@\n-  \/\/ Now that we have old to new gid map update the unicode to new gid list.\n-  for (unsigned i = 0; i < plan->unicode_to_new_gid_list.length; i++)\n+  if (unlikely (plan->in_error ()))\n@@ -608,6 +957,0 @@\n-    \/\/ Use raw array access for performance.\n-    plan->unicode_to_new_gid_list.arrayZ[i].second =\n-        plan->glyph_map->get(plan->unicode_to_new_gid_list.arrayZ[i].second);\n-  }\n-\n-  if (unlikely (plan->in_error ())) {\n@@ -617,0 +960,1 @@\n+\n@@ -634,41 +978,0 @@\n-  hb_set_destroy (plan->unicodes);\n-  plan->unicode_to_new_gid_list.fini ();\n-  hb_set_destroy (plan->name_ids);\n-  hb_set_destroy (plan->name_languages);\n-  hb_set_destroy (plan->layout_features);\n-  hb_set_destroy (plan->glyphs_requested);\n-  hb_set_destroy (plan->drop_tables);\n-  hb_set_destroy (plan->no_subset_tables);\n-  hb_face_destroy (plan->source);\n-  hb_face_destroy (plan->dest);\n-  hb_map_destroy (plan->codepoint_to_glyph);\n-  hb_map_destroy (plan->glyph_map);\n-  hb_map_destroy (plan->reverse_glyph_map);\n-  hb_map_destroy (plan->glyph_map_gsub);\n-  hb_set_destroy (plan->_glyphset);\n-  hb_set_destroy (plan->_glyphset_gsub);\n-  hb_set_destroy (plan->_glyphset_mathed);\n-  hb_set_destroy (plan->_glyphset_colred);\n-  hb_map_destroy (plan->gsub_lookups);\n-  hb_map_destroy (plan->gpos_lookups);\n-  hb_map_destroy (plan->gsub_features);\n-  hb_map_destroy (plan->gpos_features);\n-  hb_map_destroy (plan->colrv1_layers);\n-  hb_map_destroy (plan->colr_palettes);\n-  hb_set_destroy (plan->layout_variation_indices);\n-  hb_map_destroy (plan->layout_variation_idx_map);\n-\n-  if (plan->gsub_langsys)\n-  {\n-    hb_object_destroy (plan->gsub_langsys);\n-    plan->gsub_langsys->fini_shallow ();\n-    hb_free (plan->gsub_langsys);\n-  }\n-\n-  if (plan->gpos_langsys)\n-  {\n-    hb_object_destroy (plan->gpos_langsys);\n-    plan->gpos_langsys->fini_shallow ();\n-    hb_free (plan->gpos_langsys);\n-  }\n-\n@@ -690,1 +993,1 @@\n-const hb_map_t*\n+hb_map_t *\n@@ -708,1 +1011,1 @@\n-const hb_map_t*\n+hb_map_t *\n@@ -726,1 +1029,1 @@\n-const hb_map_t*\n+hb_map_t *\n@@ -758,1 +1061,1 @@\n- * Return value: %true if success, %false otherwise\n+ * Return value: `true` if success, `false` otherwise\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-plan.cc","additions":587,"deletions":284,"binary":false,"changes":871,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"hb-subset-accelerator.hh\"\n@@ -36,0 +37,1 @@\n+#include \"hb-bimap.hh\"\n@@ -38,0 +40,30 @@\n+namespace OT {\n+struct Feature;\n+}\n+\n+struct head_maxp_info_t\n+{\n+  head_maxp_info_t ()\n+      :xMin (0x7FFF), xMax (-0x7FFF), yMin (0x7FFF), yMax (-0x7FFF),\n+      maxPoints (0), maxContours (0),\n+      maxCompositePoints (0),\n+      maxCompositeContours (0),\n+      maxComponentElements (0),\n+      maxComponentDepth (0),\n+      allXMinIsLsb (true) {}\n+\n+  int xMin;\n+  int xMax;\n+  int yMin;\n+  int yMax;\n+  unsigned maxPoints;\n+  unsigned maxContours;\n+  unsigned maxCompositePoints;\n+  unsigned maxCompositeContours;\n+  unsigned maxComponentElements;\n+  unsigned maxComponentDepth;\n+  bool allXMinIsLsb;\n+};\n+\n+typedef struct head_maxp_info_t head_maxp_info_t;\n+\n@@ -40,0 +72,21 @@\n+  HB_INTERNAL hb_subset_plan_t (hb_face_t *,\n+                                const hb_subset_input_t *input);\n+\n+  ~hb_subset_plan_t()\n+  {\n+    hb_face_destroy (source);\n+    hb_face_destroy (dest);\n+\n+    hb_map_destroy (codepoint_to_glyph);\n+    hb_map_destroy (glyph_map);\n+    hb_map_destroy (reverse_glyph_map);\n+\n+#ifdef HB_EXPERIMENTAL_API\n+    for (auto _ : name_table_overrides)\n+      _.second.fini ();\n+#endif\n+\n+    if (inprogress_accelerator)\n+      hb_subset_accelerator_t::destroy ((void*) inprogress_accelerator);\n+  }\n+\n@@ -44,0 +97,2 @@\n+  bool attach_accelerator_data = false;\n+  bool force_long_loca = false;\n@@ -46,2 +101,2 @@\n-  hb_set_t *unicodes;\n-  hb_vector_t<hb_pair_t<hb_codepoint_t, hb_codepoint_t>> unicode_to_new_gid_list;\n+  hb_set_t unicodes;\n+  hb_sorted_vector_t<hb_pair_t<hb_codepoint_t, hb_codepoint_t>> unicode_to_new_gid_list;\n@@ -50,1 +105,1 @@\n-  hb_set_t *name_ids;\n+  hb_set_t name_ids;\n@@ -53,1 +108,1 @@\n-  hb_set_t *name_languages;\n+  hb_set_t name_languages;\n@@ -56,1 +111,4 @@\n-  hb_set_t *layout_features;\n+  hb_set_t layout_features;\n+\n+  \/\/ layout scripts which will be preserved.\n+  hb_set_t layout_scripts;\n@@ -59,1 +117,1 @@\n-  hb_set_t *glyphs_requested;\n+  hb_set_t glyphs_requested;\n@@ -62,1 +120,1 @@\n-  hb_set_t *no_subset_tables;\n+  hb_set_t no_subset_tables;\n@@ -65,1 +123,1 @@\n-  hb_set_t *drop_tables;\n+  hb_set_t drop_tables;\n@@ -68,1 +126,1 @@\n-  hb_map_t *codepoint_to_glyph;\n+  hb_map_t *codepoint_to_glyph; \/\/ Needs to be heap-allocated\n@@ -71,3 +129,3 @@\n-  hb_map_t *glyph_map;\n-  hb_map_t *reverse_glyph_map;\n-  hb_map_t *glyph_map_gsub;\n+  hb_map_t *glyph_map; \/\/ Needs to be heap-allocated\n+  hb_map_t *reverse_glyph_map; \/\/ Needs to be heap-allocated\n+  hb_map_t glyph_map_gsub;\n@@ -80,4 +138,4 @@\n-  hb_set_t *_glyphset;\n-  hb_set_t *_glyphset_gsub;\n-  hb_set_t *_glyphset_mathed;\n-  hb_set_t *_glyphset_colred;\n+  hb_set_t _glyphset;\n+  hb_set_t _glyphset_gsub;\n+  hb_set_t _glyphset_mathed;\n+  hb_set_t _glyphset_colred;\n@@ -86,2 +144,2 @@\n-  hb_map_t *gsub_lookups;\n-  hb_map_t *gpos_lookups;\n+  hb_map_t gsub_lookups;\n+  hb_map_t gpos_lookups;\n@@ -90,2 +148,2 @@\n-  hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> *gsub_langsys;\n-  hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> *gpos_langsys;\n+  hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> gsub_langsys;\n+  hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> gpos_langsys;\n@@ -94,2 +152,2 @@\n-  hb_map_t *gsub_features;\n-  hb_map_t *gpos_features;\n+  hb_map_t gsub_features;\n+  hb_map_t gpos_features;\n@@ -97,3 +155,8 @@\n-  \/\/active layers\/palettes we'd like to retain\n-  hb_map_t *colrv1_layers;\n-  hb_map_t *colr_palettes;\n+  \/\/active feature variation records\/condition index with variations\n+  hb_hashmap_t<unsigned, hb::shared_ptr<hb_set_t>> gsub_feature_record_cond_idx_map;\n+  hb_hashmap_t<unsigned, hb::shared_ptr<hb_set_t>> gpos_feature_record_cond_idx_map;\n+\n+  \/\/feature index-> address of substituation feature table mapping with\n+  \/\/variations\n+  hb_hashmap_t<unsigned, const OT::Feature*> gsub_feature_substitutes_map;\n+  hb_hashmap_t<unsigned, const OT::Feature*> gpos_feature_substitutes_map;\n@@ -101,4 +164,44 @@\n-  \/\/The set of layout item variation store delta set indices to be retained\n-  hb_set_t *layout_variation_indices;\n-  \/\/Old -> New layout item variation store delta set index mapping\n-  hb_map_t *layout_variation_idx_map;\n+  \/\/active layers\/palettes we'd like to retain\n+  hb_map_t colrv1_layers;\n+  hb_map_t colr_palettes;\n+\n+  \/\/Old layout item variation index -> (New varidx, delta) mapping\n+  hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> layout_variation_idx_delta_map;\n+\n+  \/\/gdef varstore retained varidx mapping\n+  hb_vector_t<hb_inc_bimap_t> gdef_varstore_inner_maps;\n+\n+  hb_hashmap_t<hb_tag_t, hb::unique_ptr<hb_blob_t>> sanitized_table_cache;\n+  \/\/normalized axes location map\n+  hb_hashmap_t<hb_tag_t, int> axes_location;\n+  hb_vector_t<int> normalized_coords;\n+  \/\/user specified axes location map\n+  hb_hashmap_t<hb_tag_t, float> user_axes_location;\n+  \/\/retained old axis index -> new axis index mapping in fvar axis array\n+  hb_map_t axes_index_map;\n+  \/\/axis_index->axis_tag mapping in fvar axis array\n+  hb_map_t axes_old_index_tag_map;\n+  bool all_axes_pinned;\n+  bool pinned_at_default;\n+  bool has_seac;\n+\n+  \/\/hmtx metrics map: new gid->(advance, lsb)\n+  mutable hb_hashmap_t<hb_codepoint_t, hb_pair_t<unsigned, int>> hmtx_map;\n+  \/\/vmtx metrics map: new gid->(advance, lsb)\n+  mutable hb_hashmap_t<hb_codepoint_t, hb_pair_t<unsigned, int>> vmtx_map;\n+  \/\/boundsWidth map: new gid->boundsWidth, boundWidth=xMax - xMin\n+  mutable hb_map_t bounds_width_map;\n+  \/\/boundsHeight map: new gid->boundsHeight, boundsHeight=yMax - yMin\n+  mutable hb_map_t bounds_height_map;\n+\n+  \/\/recalculated head\/maxp table info after instancing\n+  mutable head_maxp_info_t head_maxp_info;\n+\n+#ifdef HB_EXPERIMENTAL_API\n+  \/\/ name table overrides map: hb_ot_name_record_ids_t-> name string new value or\n+  \/\/ None to indicate should remove\n+  hb_hashmap_t<hb_ot_name_record_ids_t, hb_bytes_t> name_table_overrides;\n+#endif\n+\n+  const hb_subset_accelerator_t* accelerator;\n+  hb_subset_accelerator_t* inprogress_accelerator;\n@@ -108,0 +211,21 @@\n+  template<typename T>\n+  hb_blob_ptr_t<T> source_table()\n+  {\n+    hb_lock_t (accelerator ? &accelerator->sanitized_table_cache_lock : nullptr);\n+\n+    auto *cache = accelerator ? &accelerator->sanitized_table_cache : &sanitized_table_cache;\n+    if (cache\n+        && !cache->in_error ()\n+        && cache->has (+T::tableTag)) {\n+      return hb_blob_reference (cache->get (+T::tableTag).get ());\n+    }\n+\n+    hb::unique_ptr<hb_blob_t> table_blob {hb_sanitize_context_t ().reference_table<T> (source)};\n+    hb_blob_t* ret = hb_blob_reference (table_blob.get ());\n+\n+    if (likely (cache))\n+      cache->set (+T::tableTag, std::move (table_blob));\n+\n+    return ret;\n+  }\n+\n@@ -124,1 +248,1 @@\n-    return _glyphset;\n+    return &_glyphset;\n@@ -133,1 +257,1 @@\n-    return _glyphset_gsub;\n+    return &_glyphset_gsub;\n@@ -151,1 +275,1 @@\n-    return !_glyphset->has (gid);\n+    return !_glyphset.has (gid);\n@@ -193,1 +317,1 @@\n-      DEBUG_MSG(SUBSET, nullptr, \"add table %c%c%c%c, dest %d bytes, source %d bytes\",\n+      DEBUG_MSG(SUBSET, nullptr, \"add table %c%c%c%c, dest %u bytes, source %u bytes\",\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-plan.hh","additions":157,"deletions":33,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -40,3 +40,4 @@\n-#include \"hb-ot-color-sbix-table.hh\"\n-#include \"hb-ot-color-colr-table.hh\"\n-#include \"hb-ot-color-cpal-table.hh\"\n+#include \"OT\/Color\/CBDT\/CBDT.hh\"\n+#include \"OT\/Color\/COLR\/COLR.hh\"\n+#include \"OT\/Color\/CPAL\/CPAL.hh\"\n+#include \"OT\/Color\/sbix\/sbix.hh\"\n@@ -50,1 +51,0 @@\n-#include \"hb-ot-color-cbdt-table.hh\"\n@@ -53,0 +53,1 @@\n+#include \"hb-ot-var-fvar-table.hh\"\n@@ -56,0 +57,1 @@\n+#include \"hb-ot-stat-table.hh\"\n@@ -57,0 +59,1 @@\n+#include \"hb-subset-accelerator.hh\"\n@@ -58,1 +61,1 @@\n-using OT::Layout::GSUB::GSUB;\n+using OT::Layout::GSUB;\n@@ -82,0 +85,4 @@\n+\n+hb_user_data_key_t _hb_subset_accelerator_user_data_key = {};\n+\n+\n@@ -164,1 +171,1 @@\n-            return !_table_is_empty (plan->source, tag) && !plan->no_subset_tables->has (tag);\n+            return !_table_is_empty (plan->source, tag) && !plan->no_subset_tables.has (tag);\n@@ -168,1 +175,1 @@\n-          plan->no_subset_tables->iter ()\n+          plan->no_subset_tables.iter ()\n@@ -204,7 +211,0 @@\n-  if (tag != HB_OT_TAG_GPOS\n-      &&  tag != HB_OT_TAG_GSUB)\n-  {\n-    \/\/ Check for overflow in a non-handled table.\n-    return c.successful () ? c.copy_blob () : nullptr;\n-  }\n-\n@@ -245,0 +245,4 @@\n+\n+\n+\n+\n@@ -248,1 +252,2 @@\n-  if (unlikely (!buf->alloc (buf_size)))\n+  if (unlikely (buf_size > c->source_blob->length * 16 ||\n+                !buf->alloc (buf_size, true)))\n@@ -263,2 +268,2 @@\n-  hb_blob_t *source_blob = hb_sanitize_context_t ().reference_table<TableType> (plan->source);\n-  const TableType *table = source_blob->as<TableType> ();\n+  hb_blob_ptr_t<TableType> source_blob = plan->source_table<TableType> ();\n+  const TableType *table = source_blob.get ();\n@@ -267,1 +272,1 @@\n-  if (!source_blob->data)\n+  if (!source_blob.get_blob()->data)\n@@ -271,1 +276,1 @@\n-    hb_blob_destroy (source_blob);\n+    source_blob.destroy ();\n@@ -281,1 +286,1 @@\n-  unsigned buf_size = _plan_estimate_subset_table_size (plan, source_blob->length, same_size_table);\n+  unsigned buf_size = _plan_estimate_subset_table_size (plan, source_blob.get_length (), same_size_table);\n@@ -287,1 +292,1 @@\n-    hb_blob_destroy (source_blob);\n+    source_blob.destroy ();\n@@ -294,1 +299,1 @@\n-    hb_subset_context_t c (source_blob, plan, &serializer, tag);\n+    hb_subset_context_t c (source_blob.get_blob (), plan, &serializer, tag);\n@@ -297,1 +302,1 @@\n-  hb_blob_destroy (source_blob);\n+  source_blob.destroy ();\n@@ -353,1 +358,1 @@\n-  if (plan->drop_tables->has (tag))\n+  if (plan->drop_tables.has (tag))\n@@ -359,0 +364,2 @@\n+    return plan->all_axes_pinned || (plan->flags & HB_SUBSET_FLAGS_NO_HINTING);\n+\n@@ -378,0 +385,8 @@\n+  case HB_TAG ('a','v','a','r'):\n+  case HB_TAG ('f','v','a','r'):\n+  case HB_TAG ('g','v','a','r'):\n+  case HB_OT_TAG_HVAR:\n+  case HB_OT_TAG_VVAR:\n+  case HB_TAG ('M','V','A','R'):\n+    return plan->all_axes_pinned;\n+\n@@ -392,0 +407,16 @@\n+static bool\n+_dependencies_satisfied (hb_subset_plan_t *plan, hb_tag_t tag,\n+                         const hb_set_t &subsetted_tags,\n+                         const hb_set_t &pending_subset_tags)\n+{\n+  switch (tag)\n+  {\n+  case HB_OT_TAG_hmtx:\n+  case HB_OT_TAG_vmtx:\n+  case HB_OT_TAG_maxp:\n+    return !plan->normalized_coords || !pending_subset_tags.has (HB_OT_TAG_glyf);\n+  default:\n+    return true;\n+  }\n+}\n+\n@@ -397,1 +428,1 @@\n-  if (plan->no_subset_tables->has (tag)) {\n+  if (plan->no_subset_tables.has (tag)) {\n@@ -441,0 +472,8 @@\n+  case HB_OT_TAG_fvar:\n+    if (plan->user_axes_location.is_empty ()) return _passthrough (plan, tag);\n+    return _subset<const OT::fvar> (plan, buf);\n+  case HB_OT_TAG_STAT:\n+    \/*TODO(qxliu): change the condition as we support more complex\n+     * instancing operation*\/\n+    if (plan->all_axes_pinned) return _subset<const OT::STAT> (plan, buf);\n+    else return _passthrough (plan, tag);\n@@ -451,0 +490,28 @@\n+static void _attach_accelerator_data (hb_subset_plan_t* plan,\n+                                      hb_face_t* face \/* IN\/OUT *\/)\n+{\n+  if (!plan->inprogress_accelerator) return;\n+\n+  \/\/ Transfer the accelerator from the plan to us.\n+  hb_subset_accelerator_t* accel = plan->inprogress_accelerator;\n+  plan->inprogress_accelerator = nullptr;\n+\n+  if (accel->in_error ())\n+  {\n+    hb_subset_accelerator_t::destroy (accel);\n+    return;\n+  }\n+\n+  \/\/ Populate caches that need access to the final tables.\n+  hb_blob_ptr_t<OT::cmap> cmap_ptr (hb_sanitize_context_t ().reference_table<OT::cmap> (face));\n+  accel->cmap_cache = OT::cmap::create_filled_cache (cmap_ptr);\n+  accel->destroy_cmap_cache = OT::SubtableUnicodesCache::destroy;\n+\n+  if (!hb_face_set_user_data(face,\n+                             hb_subset_accelerator_t::user_data_key(),\n+                             accel,\n+                             hb_subset_accelerator_t::destroy,\n+                             true))\n+    hb_subset_accelerator_t::destroy (accel);\n+}\n+\n@@ -496,2 +563,0 @@\n-  hb_set_t tags_set;\n-  bool success = true;\n@@ -500,2 +565,0 @@\n-  hb_vector_t<char> buf;\n-  buf.alloc (4096 - 16);\n@@ -503,0 +566,1 @@\n+  hb_set_t subsetted_tags, pending_subset_tags;\n@@ -508,2 +572,38 @@\n-      if (_should_drop_table (plan, tag) && !tags_set.has (tag)) continue;\n-      tags_set.add (tag);\n+      if (_should_drop_table (plan, tag)) continue;\n+      pending_subset_tags.add (tag);\n+    }\n+\n+    offset += num_tables;\n+  }\n+\n+  hb_vector_t<char> buf;\n+  buf.alloc (4096 - 16);\n+\n+\n+  bool success = true;\n+\n+  while (!pending_subset_tags.is_empty ())\n+  {\n+    if (subsetted_tags.in_error ()\n+        || pending_subset_tags.in_error ()) {\n+      success = false;\n+      goto end;\n+    }\n+\n+    bool made_changes = false;\n+    for (hb_tag_t tag : pending_subset_tags)\n+    {\n+      if (!_dependencies_satisfied (plan, tag,\n+                                    subsetted_tags,\n+                                    pending_subset_tags))\n+      {\n+        \/\/ delayed subsetting for some tables since they might have dependency on other tables\n+        \/\/ in some cases: e.g: during instantiating glyf tables, hmetrics\/vmetrics are updated\n+        \/\/ and saved in subset plan, hmtx\/vmtx subsetting need to use these updated metrics values\n+        continue;\n+      }\n+\n+      pending_subset_tags.del (tag);\n+      subsetted_tags.add (tag);\n+      made_changes = true;\n+\n@@ -513,1 +613,11 @@\n-    offset += num_tables;\n+\n+    if (!made_changes)\n+    {\n+      DEBUG_MSG (SUBSET, nullptr, \"Table dependencies unable to be satisfied. Subset failed.\");\n+      success = false;\n+      goto end;\n+    }\n+  }\n+\n+  if (success && plan->attach_accelerator_data) {\n+    _attach_accelerator_data (plan, plan->dest);\n@@ -519,0 +629,5 @@\n+\n+#ifndef HB_NO_VISIBILITY\n+\/* If NO_VISIBILITY, libharfbuzz has this. *\/\n+#include \"hb-ot-name-language-static.hh\"\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset.cc","additions":147,"deletions":32,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"hb-ot.h\"\n@@ -103,0 +104,2 @@\n+ * @HB_SUBSET_SETS_LAYOUT_SCRIPT_TAG: the set of layout script tags that will be retained\n+ * in the subset. Defaults to all tags. Since: 5.0.0\n@@ -116,0 +119,1 @@\n+  HB_SUBSET_SETS_LAYOUT_SCRIPT_TAG,\n@@ -138,0 +142,3 @@\n+HB_EXTERN void\n+hb_subset_input_keep_everything (hb_subset_input_t *input);\n+\n@@ -154,0 +161,26 @@\n+HB_EXTERN hb_bool_t\n+hb_subset_input_pin_axis_to_default (hb_subset_input_t  *input,\n+                                     hb_face_t          *face,\n+                                     hb_tag_t            axis_tag);\n+\n+HB_EXTERN hb_bool_t\n+hb_subset_input_pin_axis_location (hb_subset_input_t  *input,\n+                                   hb_face_t          *face,\n+                                   hb_tag_t            axis_tag,\n+                                   float               axis_value);\n+\n+#ifdef HB_EXPERIMENTAL_API\n+HB_EXTERN hb_bool_t\n+hb_subset_input_override_name_table (hb_subset_input_t  *input,\n+                                     hb_ot_name_id_t     name_id,\n+                                     unsigned            platform_id,\n+                                     unsigned            encoding_id,\n+                                     unsigned            language_id,\n+                                     const char         *name_str,\n+                                     int                 str_len);\n+\n+#endif\n+\n+HB_EXTERN hb_face_t *\n+hb_subset_preprocess (hb_face_t *source);\n+\n@@ -167,1 +200,1 @@\n-HB_EXTERN const hb_map_t*\n+HB_EXTERN hb_map_t *\n@@ -170,1 +203,1 @@\n-HB_EXTERN const hb_map_t*\n+HB_EXTERN hb_map_t *\n@@ -173,1 +206,1 @@\n-HB_EXTERN const hb_map_t*\n+HB_EXTERN hb_map_t *\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset.h","additions":36,"deletions":3,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"hb-serialize.hh\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset.hh","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * on file with this description: Unicode 14.0.0\n+ * on file with this description: Unicode 15.0.0\n@@ -16,1 +16,1 @@\n-_hb_ucd_sc_map[163] =\n+_hb_ucd_sc_map[165] =\n@@ -99,1 +99,2 @@\n-                     HB_SCRIPT_MATH,\n+                     HB_SCRIPT_MATH,                   HB_SCRIPT_KAWI,\n+              HB_SCRIPT_NAG_MUNDARI,\n@@ -1071,1 +1072,1 @@\n-_hb_ucd_u8[33120] =\n+_hb_ucd_u8[17868] =\n@@ -1073,184 +1074,4 @@\n-    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n-   16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 27, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   28, 26, 29, 30, 31, 32, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 33, 34, 34, 34, 34,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 36, 37, 38, 39,\n-   40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,\n-   26, 56, 57, 58, 58, 58, 58, 59, 26, 26, 60, 58, 58, 58, 58, 58,\n-   58, 58, 26, 61, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 26, 62, 58, 63, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 64, 26, 26, 65, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 66, 67, 68, 58, 58, 58, 58, 69, 58,\n-   58, 58, 58, 58, 58, 58, 58, 70, 71, 72, 73, 74, 75, 76, 58, 77,\n-   78, 79, 58, 80, 81, 58, 82, 83, 84, 85, 75, 86, 87, 88, 58, 58,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 89, 26, 26, 26, 26, 26, 26, 26, 90, 91, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 92, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 93, 58, 58, 58, 58, 58, 58, 26, 94, 58, 58,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 95, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   96, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 97,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 98,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-   29, 21, 21, 21, 23, 21, 21, 21, 22, 18, 21, 25, 21, 17, 21, 21,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 21, 21, 25, 25, 25, 21,\n-   21,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 22, 21, 18, 24, 16,\n-   24,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 22, 25, 18, 25,  0,\n-   29, 21, 23, 23, 23, 23, 26, 21, 24, 26,  7, 20, 25,  1, 26, 24,\n-   26, 25, 15, 15, 24,  5, 21, 21, 24, 15,  7, 19, 15, 15, 15, 21,\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n-    9,  9,  9,  9,  9,  9,  9, 25,  9,  9,  9,  9,  9,  9,  9,  5,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n-    5,  5,  5,  5,  5,  5,  5, 25,  5,  5,  5,  5,  5,  5,  5,  5,\n-    9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,\n-    9,  5,  9,  5,  9,  5,  9,  5,  5,  9,  5,  9,  5,  9,  5,  9,\n-    5,  9,  5,  9,  5,  9,  5,  9,  5,  5,  9,  5,  9,  5,  9,  5,\n-    9,  5,  9,  5,  9,  5,  9,  5,  9,  9,  5,  9,  5,  9,  5,  5,\n-    5,  9,  9,  5,  9,  5,  9,  9,  5,  9,  9,  9,  5,  5,  9,  9,\n-    9,  9,  5,  9,  9,  5,  9,  9,  9,  5,  5,  5,  9,  9,  5,  9,\n-    9,  5,  9,  5,  9,  5,  9,  9,  5,  9,  5,  5,  9,  5,  9,  9,\n-    5,  9,  9,  9,  5,  9,  5,  9,  9,  5,  5,  7,  9,  5,  5,  5,\n-    7,  7,  7,  7,  9,  8,  5,  9,  8,  5,  9,  8,  5,  9,  5,  9,\n-    5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  5,  9,  5,\n-    5,  9,  8,  5,  9,  5,  9,  9,  9,  5,  9,  5,  9,  5,  9,  5,\n-    9,  5,  9,  5,  5,  5,  5,  5,  5,  5,  9,  9,  5,  9,  9,  5,\n-    5,  9,  5,  9,  9,  9,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,\n-    5,  5,  5,  5,  7,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n-    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n-    6,  6, 24, 24, 24, 24,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n-    6,  6, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n-    6,  6,  6,  6,  6, 24, 24, 24, 24, 24, 24, 24,  6, 24,  6, 24,\n-   24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-    9,  5,  9,  5,  6, 24,  9,  5,  2,  2,  6,  5,  5,  5, 21,  9,\n-    2,  2,  2,  2, 24, 24,  9, 21,  9,  9,  9,  2,  9,  2,  9,  9,\n-    5,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n-    9,  9,  2,  9,  9,  9,  9,  9,  9,  9,  9,  9,  5,  5,  5,  5,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  9,\n-    5,  5,  9,  9,  9,  5,  5,  5,  9,  5,  9,  5,  9,  5,  9,  5,\n-    5,  5,  5,  5,  9,  5, 25,  9,  5,  9,  9,  5,  5,  9,  9,  9,\n-    9,  5, 26, 12, 12, 12, 12, 12, 11, 11,  9,  5,  9,  5,  9,  5,\n-    9,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  5,\n-    2,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n-    9,  9,  9,  9,  9,  9,  9,  2,  2,  6, 21, 21, 21, 21, 21, 21,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5, 21, 17,  2,  2, 26, 26, 23,\n-    2, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 17, 12,\n-   21, 12, 12, 21, 12, 12, 21, 12,  2,  2,  2,  2,  2,  2,  2,  2,\n+    0,  1,  2,  3,  4,  5,  6,  7,  7,  8,  7,  7,  7,  7,  7,  7,\n+    7,  7,  7,  7,  9, 10,  7,  7,  7,  7, 11, 12, 13, 13, 13, 14,\n+   15, 16, 17, 18, 19, 20, 21, 22, 23, 22, 22, 22, 22, 24,  7,  7,\n+   25, 26, 22, 22, 22, 27, 28, 29, 22, 30, 31, 32, 33, 34, 35, 36,\n@@ -1258,573 +1079,25 @@\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  7,\n-    7,  7,  7, 21, 21,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    1,  1,  1,  1,  1,  1, 25, 25, 25, 21, 21, 23, 21, 21, 26, 26,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 21,  1, 21, 21, 21,\n-    6,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 12, 12, 12, 12, 12,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 21, 21, 21, 21,  7,  7,\n-   12,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7, 21,  7, 12, 12, 12, 12, 12, 12, 12,  1, 26, 12,\n-   12, 12, 12, 12, 12,  6,  6, 12, 12, 26, 12, 12, 12, 12,  7,  7,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13,  7,  7,  7, 26, 26,  7,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,  2,  1,\n-    7, 12,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,  2,  2,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12,  7,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12,  6,  6, 26, 21, 21, 21,  6,  2,  2, 12, 23, 23,\n-    7,  7,  7,  7,  7,  7, 12, 12, 12, 12,  6, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12,  6, 12, 12, 12,  6, 12, 12, 12, 12, 12,  2,  2,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7, 12, 12, 12,  2,  2, 21,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7, 24,  7,  7,  7,  7,  7,  7,  2,\n-    1,  1,  2,  2,  2,  2,  2,  2, 12, 12, 12, 12, 12, 12, 12, 12,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  6, 12, 12, 12, 12, 12, 12,\n-   12, 12,  1, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 10,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 12, 10, 12,  7, 10, 10,\n-   10, 12, 12, 12, 12, 12, 12, 12, 12, 10, 10, 10, 10, 12, 10, 10,\n-    7, 12, 12, 12, 12, 12, 12, 12,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7, 12, 12, 21, 21, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n-   21,  6,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7, 12, 10, 10,  2,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  7,\n-    7,  2,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  7,  7,  7,  7,  7,  7,\n-    7,  2,  7,  2,  2,  2,  7,  7,  7,  7,  2,  2, 12,  7, 10, 10,\n-   10, 12, 12, 12, 12,  2,  2, 10, 10,  2,  2, 10, 10, 12,  7,  2,\n-    2,  2,  2,  2,  2,  2,  2, 10,  2,  2,  2,  2,  7,  7,  2,  7,\n-    7,  7, 12, 12,  2,  2, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n-    7,  7, 23, 23, 15, 15, 15, 15, 15, 15, 26, 23,  7, 21, 12,  2,\n-    2, 12, 12, 10,  2,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  7,\n-    7,  2,  7,  7,  2,  7,  7,  2,  7,  7,  2,  2, 12,  2, 10, 10,\n-   10, 12, 12,  2,  2,  2,  2, 12, 12,  2,  2, 12, 12, 12,  2,  2,\n-    2, 12,  2,  2,  2,  2,  2,  2,  2,  7,  7,  7,  7,  2,  7,  2,\n-    2,  2,  2,  2,  2,  2, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n-   12, 12,  7,  7,  7, 12, 21,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2, 12, 12, 10,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  7,\n-    7,  7,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  2,  7,  7,  2,  7,  7,  7,  7,  7,  2,  2, 12,  7, 10, 10,\n-   10, 12, 12, 12, 12, 12,  2, 12, 12, 10,  2, 10, 10, 12,  2,  2,\n-    7,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   21, 23,  2,  2,  2,  2,  2,  2,  2,  7, 12, 12, 12, 12, 12, 12,\n-    2, 12, 10, 10,  2,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  7,\n-    7,  2,  7,  7,  2,  7,  7,  7,  7,  7,  2,  2, 12,  7, 10, 12,\n-   10, 12, 12, 12, 12,  2,  2, 10, 10,  2,  2, 10, 10, 12,  2,  2,\n-    2,  2,  2,  2,  2, 12, 12, 10,  2,  2,  2,  2,  7,  7,  2,  7,\n-   26,  7, 15, 15, 15, 15, 15, 15,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2, 12,  7,  2,  7,  7,  7,  7,  7,  7,  2,  2,  2,  7,  7,\n-    7,  2,  7,  7,  7,  7,  2,  2,  2,  7,  7,  2,  7,  2,  7,  7,\n-    2,  2,  2,  7,  7,  2,  2,  2,  7,  7,  7,  2,  2,  2,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2, 10, 10,\n-   12, 10, 10,  2,  2,  2, 10, 10, 10,  2, 10, 10, 10, 12,  2,  2,\n-    7,  2,  2,  2,  2,  2,  2, 10,  2,  2,  2,  2,  2,  2,  2,  2,\n-   15, 15, 15, 26, 26, 26, 26, 26, 26, 23, 26,  2,  2,  2,  2,  2,\n-   12, 10, 10, 10, 12,  7,  7,  7,  7,  7,  7,  7,  7,  2,  7,  7,\n-    7,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2, 12,  7, 12, 12,\n-   12, 10, 10, 10, 10,  2, 12, 12, 12,  2, 12, 12, 12, 12,  2,  2,\n-    2,  2,  2,  2,  2, 12, 12,  2,  7,  7,  7,  2,  2,  7,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2, 21, 15, 15, 15, 15, 15, 15, 15, 26,\n-    7, 12, 10, 10, 21,  7,  7,  7,  7,  7,  7,  7,  7,  2,  7,  7,\n-    7,  7,  7,  7,  2,  7,  7,  7,  7,  7,  2,  2, 12,  7, 10, 12,\n-   10, 10, 10, 10, 10,  2, 12, 10, 10,  2, 10, 10, 12, 12,  2,  2,\n-    2,  2,  2,  2,  2, 10, 10,  2,  2,  2,  2,  2,  2,  7,  7,  2,\n-    2,  7,  7,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   12, 12, 10, 10,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 12, 12,  7, 10, 10,\n-   10, 12, 12, 12, 12,  2, 10, 10, 10,  2, 10, 10, 10, 12,  7, 26,\n-    2,  2,  2,  2,  7,  7,  7, 10, 15, 15, 15, 15, 15, 15, 15,  7,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 26,  7,  7,  7,  7,  7,  7,\n-    2, 12, 10, 10,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  7,  7,  7,  7,  7,  7,\n-    7,  7,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  7,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  2,  2,  2, 12,  2,  2,  2,  2, 10,\n-   10, 10, 12, 12, 12,  2, 12,  2, 10, 10, 10, 10, 10, 10, 10, 10,\n-    2,  2, 10, 10, 21,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7, 12,  7,  7, 12, 12, 12, 12, 12, 12, 12,  2,  2,  2,  2, 23,\n-    7,  7,  7,  7,  7,  7,  6, 12, 12, 12, 12, 12, 12, 12, 12, 21,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 21, 21,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  7,  7,  2,  7,  2,  7,  7,  7,  7,  7,  2,  7,  7,  7,  7,\n-    7,  7,  7,  7,  2,  7,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7, 12,  7,  7, 12, 12, 12, 12, 12, 12, 12, 12, 12,  7,  2,  2,\n-    7,  7,  7,  7,  7,  2,  6,  2, 12, 12, 12, 12, 12, 12,  2,  2,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13,  2,  2,  7,  7,  7,  7,\n-    7, 26, 26, 26, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 26, 21, 26, 26, 26, 12, 12, 26, 26, 26, 26, 26, 26,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 26, 12, 26, 12, 26, 12, 22, 18, 22, 18, 10, 10,\n-    7,  7,  7,  7,  7,  7,  7,  7,  2,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,\n-    2, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 10,\n-   12, 12, 12, 12, 12, 21, 12, 12,  7,  7,  7,  7,  7, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12,  2, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,  2, 26, 26,\n-   26, 26, 26, 26, 26, 26, 12, 26, 26, 26, 26, 26, 26,  2, 26, 26,\n-   21, 21, 21, 21, 21, 26, 26, 26, 26, 21, 21,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 10, 10, 12, 12, 12,\n-   12, 10, 12, 12, 12, 12, 12, 12, 10, 12, 12, 10, 10, 12, 12,  7,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 21, 21, 21, 21, 21, 21,\n-    7,  7,  7,  7,  7,  7, 10, 10, 12, 12,  7,  7,  7,  7, 12, 12,\n-   12,  7, 10, 10, 10,  7,  7, 10, 10, 10, 10, 10, 10, 10,  7,  7,\n-    7, 12, 12, 12, 12,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7, 12, 10, 10, 12, 12, 10, 10, 10, 10, 10, 10, 12,  7, 10,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 10, 10, 10, 12, 26, 26,\n-    9,  9,  9,  9,  9,  9,  2,  9,  2,  2,  2,  2,  2,  9,  2,  2,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 21,  6,  5,  5,  5,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  7,  7,  7,  7,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  2,  7,  2,  7,  7,  7,  7,  2,  2,\n-    7,  2,  7,  7,  7,  7,  2,  2,  7,  7,  7,  7,  7,  7,  7,  2,\n-    7,  2,  7,  7,  7,  7,  2,  2,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  2,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2, 12, 12, 12,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  2,  2,  2,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26,  2,  2,  2,  2,  2,  2,\n-    9,  9,  9,  9,  9,  9,  2,  2,  5,  5,  5,  5,  5,  5,  2,  2,\n-   17,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 26, 21,  7,\n-   29,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 22, 18,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 21, 21, 21, 14, 14,\n-   14,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7, 12, 12, 12, 10,  2,  2,  2,  2,  2,  2,  2,  2,  2,  7,\n-    7,  7, 12, 12, 10, 21, 21,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7, 12, 12,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  7,  7,\n-    7,  2, 12, 12,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7, 12, 12, 10, 12, 12, 12, 12, 12, 12, 12, 10, 10,\n-   10, 10, 10, 10, 10, 10, 12, 10, 10, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 21, 21, 21,  6, 21, 21, 21, 23,  7, 12,  2,  2,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13,  2,  2,  2,  2,  2,  2,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  2,  2,  2,  2,  2,  2,\n-   21, 21, 21, 21, 21, 21, 17, 21, 21, 21, 21, 12, 12, 12,  1, 12,\n-    7,  7,  7,  6,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7, 12, 12,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7, 12,  7,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,\n-   12, 12, 12, 10, 10, 10, 10, 12, 12, 10, 10, 10,  2,  2,  2,  2,\n-   10, 10, 12, 10, 10, 10, 10, 10, 10, 12, 12, 12,  2,  2,  2,  2,\n-   26,  2,  2,  2, 21, 21, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,\n-    7,  7,  7,  7,  7,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  2,  2,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 15,  2,  2,  2, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-    7,  7,  7,  7,  7,  7,  7, 12, 12, 10, 10, 12,  2,  2, 21, 21,\n-    7,  7,  7,  7,  7, 10, 12, 10, 12, 12, 12, 12, 12, 12, 12,  2,\n-   12, 10, 12, 10, 10, 12, 12, 12, 12, 12, 12, 12, 12, 10, 10, 10,\n-   10, 10, 10, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,  2,  2, 12,\n-   21, 21, 21, 21, 21, 21, 21,  6, 21, 21, 21, 21, 21, 21,  2,  2,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,  2,\n-   12, 12, 12, 12, 10,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7, 12, 10, 12, 12, 12, 12, 12, 10, 12, 10, 10, 10,\n-   10, 10, 12, 10, 10,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,\n-   21, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 26, 26, 26, 26, 26, 26, 26, 26, 26, 21, 21,  2,\n-   12, 12, 10,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7, 10, 12, 12, 12, 12, 10, 10, 12, 12, 10, 12, 12, 12,  7,  7,\n-    7,  7,  7,  7,  7,  7, 12, 10, 12, 12, 10, 10, 10, 12, 10, 12,\n-   12, 12, 10, 10,  2,  2,  2,  2,  2,  2,  2,  2, 21, 21, 21, 21,\n-    7,  7,  7,  7, 10, 10, 10, 10, 10, 10, 10, 10, 12, 12, 12, 12,\n-   12, 12, 12, 12, 10, 10, 12, 12,  2,  2,  2, 21, 21, 21, 21, 21,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13,  2,  2,  2,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  6,  6,  6,  6,  6,  6, 21, 21,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  2,  2,  2,  2,  2,  2,  2,\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  2,  2,  9,  9,  9,\n-   21, 21, 21, 21, 21, 21, 21, 21,  2,  2,  2,  2,  2,  2,  2,  2,\n-   12, 12, 12, 21, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 10, 12, 12, 12, 12, 12, 12, 12,  7,  7,  7,  7, 12,  7,  7,\n-    7,  7,  7,  7, 12,  7,  7, 10, 12, 12,  7,  2,  2,  2,  2,  2,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,\n-    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  5,  5,  5,  5,  5,\n-    5,  5,  5,  5,  5,  5,  5,  5,  6,  5,  5,  5,  5,  5,  5,  5,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,\n-    9,  5,  9,  5,  9,  5,  5,  5,  5,  5,  5,  5,  5,  5,  9,  5,\n-    5,  5,  5,  5,  5,  5,  5,  5,  9,  9,  9,  9,  9,  9,  9,  9,\n-    5,  5,  5,  5,  5,  5,  2,  2,  9,  9,  9,  9,  9,  9,  2,  2,\n-    5,  5,  5,  5,  5,  5,  5,  5,  2,  9,  2,  9,  2,  9,  2,  9,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  2,  2,\n-    5,  5,  5,  5,  5,  5,  5,  5,  8,  8,  8,  8,  8,  8,  8,  8,\n-    5,  5,  5,  5,  5,  2,  5,  5,  9,  9,  9,  9,  8, 24,  5, 24,\n-   24, 24,  5,  5,  5,  2,  5,  5,  9,  9,  9,  9,  8, 24, 24, 24,\n-    5,  5,  5,  5,  2,  2,  5,  5,  9,  9,  9,  9,  2, 24, 24, 24,\n-    5,  5,  5,  5,  5,  5,  5,  5,  9,  9,  9,  9,  9, 24, 24, 24,\n-    2,  2,  5,  5,  5,  2,  5,  5,  9,  9,  9,  9,  8, 24, 24,  2,\n-   29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,  1,  1,  1,  1,  1,\n-   17, 17, 17, 17, 17, 17, 21, 21, 20, 19, 22, 20, 20, 19, 22, 20,\n-   21, 21, 21, 21, 21, 21, 21, 21, 27, 28,  1,  1,  1,  1,  1, 29,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 20, 19, 21, 21, 21, 21, 16,\n-   16, 21, 21, 21, 25, 22, 18, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 25, 21, 16, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 29,\n-    1,  1,  1,  1,  1,  2,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n-   15,  6,  2,  2, 15, 15, 15, 15, 15, 15, 25, 25, 25, 22, 18,  6,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 25, 25, 25, 22, 18,  2,\n-    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  2,  2,  2,\n-   23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n-   23,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11,\n-   11, 12, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   26, 26,  9, 26, 26, 26, 26,  9, 26, 26,  5,  9,  9,  9,  5,  5,\n-    9,  9,  9,  5, 26,  9, 26, 26, 25,  9,  9,  9,  9,  9, 26, 26,\n-   26, 26, 26, 26,  9, 26,  9, 26,  9, 26,  9,  9,  9,  9, 26,  5,\n-    9,  9,  9,  9,  5,  7,  7,  7,  7,  5, 26, 26,  5,  5,  9,  9,\n-   25, 25, 25, 25, 25,  9,  5,  5,  5,  5, 26, 25, 26, 26,  5, 26,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14,  9,  5, 14, 14, 14, 14, 15, 26, 26,  2,  2,  2,  2,\n-   25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 25, 25, 26, 26, 26, 26,\n-   25, 26, 26, 25, 26, 26, 25, 26, 26, 26, 26, 26, 26, 26, 25, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 25, 25,\n-   26, 26, 25, 26, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n-   25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n-   26, 26, 26, 26, 26, 26, 26, 26, 22, 18, 22, 18, 26, 26, 26, 26,\n-   25, 25, 26, 26, 26, 26, 26, 26, 26, 22, 18, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 25, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 25, 25, 25, 25, 25,\n-   25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 25, 25, 25, 25,\n-   25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,  2,  2,  2,  2,  2,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 15, 15, 15, 15, 15, 15,\n-   26, 26, 26, 26, 26, 26, 26, 25, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 25, 25, 25, 25, 25, 25, 25, 25,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 25,\n-   26, 26, 26, 26, 26, 26, 26, 26, 22, 18, 22, 18, 22, 18, 22, 18,\n-   22, 18, 22, 18, 22, 18, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   25, 25, 25, 25, 25, 22, 18, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n-   25, 25, 25, 25, 25, 25, 22, 18, 22, 18, 22, 18, 22, 18, 22, 18,\n-   25, 25, 25, 22, 18, 22, 18, 22, 18, 22, 18, 22, 18, 22, 18, 22,\n-   18, 22, 18, 22, 18, 22, 18, 22, 18, 25, 25, 25, 25, 25, 25, 25,\n-   25, 25, 25, 25, 25, 25, 25, 25, 22, 18, 22, 18, 25, 25, 25, 25,\n-   25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 22, 18, 25, 25,\n-   25, 25, 25, 25, 25, 26, 26, 25, 25, 25, 25, 25, 25, 26, 26, 26,\n-   26, 26, 26, 26,  2,  2, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26,  2, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-    9,  5,  9,  9,  9,  5,  5,  9,  5,  9,  5,  9,  5,  9,  9,  9,\n-    9,  5,  9,  5,  5,  9,  5,  5,  5,  5,  5,  5,  6,  6,  9,  9,\n-    9,  5,  9,  5,  5, 26, 26, 26, 26, 26, 26,  9,  5,  9,  5, 12,\n-   12, 12,  9,  5,  2,  2,  2,  2,  2, 21, 21, 21, 21, 15, 21, 21,\n-    5,  5,  5,  5,  5,  5,  2,  5,  2,  2,  2,  2,  2,  5,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  2,  2,  2,  6,\n-   21,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 12,\n-    7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  2,  7,  7,  7,  7,  7,  7,  7,  2,\n-   21, 21, 20, 19, 20, 19, 21, 21, 21, 20, 19, 21, 20, 19, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 17, 21, 21, 17, 21, 20, 19, 21, 21,\n-   20, 19, 22, 18, 22, 18, 22, 18, 22, 18, 21, 21, 21, 21, 21,  6,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 17, 17, 21, 21, 21, 21,\n-   17, 21, 22, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   26, 26, 21, 21, 21, 22, 18, 22, 18, 22, 18, 22, 18, 17,  2,  2,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26,  2, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   26, 26, 26, 26, 26, 26,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,  2,  2,  2,  2,\n-   29, 21, 21, 21, 26,  6,  7, 14, 22, 18, 22, 18, 22, 18, 22, 18,\n-   22, 18, 26, 26, 22, 18, 22, 18, 22, 18, 22, 18, 17, 22, 18, 18,\n-   26, 14, 14, 14, 14, 14, 14, 14, 14, 14, 12, 12, 12, 12, 10, 10,\n-   17,  6,  6,  6,  6,  6, 26, 26, 14, 14, 14,  6,  7, 21, 26, 26,\n-    7,  7,  7,  7,  7,  7,  7,  2,  2, 12, 12, 24, 24,  6,  6,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 21,  6,  6,  6,  7,\n-    2,  2,  2,  2,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-   26, 26, 15, 15, 15, 15, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,  2,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 15, 15, 15, 15, 15, 15, 15, 15,\n-   26, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-    7,  7,  7,  7,  7,  6,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  6, 21, 21, 21,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13,  7,  7,  2,  2,  2,  2,\n-    9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  7, 12,\n-   11, 11, 11, 21, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 21,  6,\n-    9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  6,  6, 12, 12,\n-    7,  7,  7,  7,  7,  7, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   12, 12, 21, 21, 21, 21, 21, 21,  2,  2,  2,  2,  2,  2,  2,  2,\n-   24, 24, 24, 24, 24, 24, 24,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n-   24, 24,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,\n-    5,  5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,\n-    6,  5,  5,  5,  5,  5,  5,  5,  5,  9,  5,  9,  5,  9,  9,  5,\n-    9,  5,  9,  5,  9,  5,  9,  5,  6, 24, 24,  9,  5,  9,  5,  7,\n-    9,  5,  9,  5,  5,  5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,\n-    9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  9,  9,  9,  9,  5,\n-    9,  9,  9,  9,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,  9,  5,\n-    9,  5,  9,  5,  9,  9,  9,  9,  5,  9,  5,  2,  2,  2,  2,  2,\n-    9,  5,  2,  5,  2,  5,  9,  5,  9,  5,  2,  2,  2,  2,  2,  2,\n-    2,  2,  6,  6,  6,  9,  5,  7,  6,  6,  5,  7,  7,  7,  7,  7,\n-    7,  7, 12,  7,  7,  7, 12,  7,  7,  7,  7, 12,  7,  7,  7,  7,\n-    7,  7,  7, 10, 10, 12, 12, 10, 26, 26, 26, 26, 12,  2,  2,  2,\n-   15, 15, 15, 15, 15, 15, 26, 26, 23, 26,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7, 21, 21, 21, 21,  2,  2,  2,  2,  2,  2,  2,  2,\n-   10, 10,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n-   10, 10, 10, 10, 12, 12,  2,  2,  2,  2,  2,  2,  2,  2, 21, 21,\n-   12, 12,  7,  7,  7,  7,  7,  7, 21, 21, 21,  7, 21,  7,  7, 12,\n-    7,  7,  7,  7,  7,  7, 12, 12, 12, 12, 12, 12, 12, 12, 21, 21,\n-    7,  7,  7,  7,  7,  7,  7, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 10, 10,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 21,\n-    7,  7,  7, 12, 10, 10, 12, 12, 12, 12, 10, 10, 12, 12, 10, 10,\n-   10, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,  2,  6,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13,  2,  2,  2,  2, 21, 21,\n-    7,  7,  7,  7,  7, 12,  6,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13,  7,  7,  7,  7,  7,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7, 12, 12, 12, 12, 12, 12, 10,\n-   10, 12, 12, 10, 10, 12, 12,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7, 12,  7,  7,  7,  7,  7,  7,  7,  7, 12, 10,  2,  2,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13,  2,  2, 21, 21, 21, 21,\n-    6,  7,  7,  7,  7,  7,  7, 26, 26, 26,  7, 10, 12, 10,  7,  7,\n-   12,  7, 12, 12, 12,  7,  7, 12, 12,  7,  7,  7,  7,  7, 12, 12,\n-    7, 12,  7,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  7,  7,  6, 21, 21,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 10, 12, 12, 10, 10,\n-   21, 21,  7,  6,  6, 10, 12,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  7,  7,  7,  7,  7,  7,  2,  2,  7,  7,  7,  7,  7,  7,  2,\n-    2,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 24,  6,  6,  6,  6,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  6, 24, 24,  2,  2,  2,  2,\n-    7,  7,  7, 10, 10, 12, 10, 10, 12, 10, 10, 21, 10, 12,  2,  2,\n-    7,  7,  7,  7,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  7,  7,  7,  7,  7,\n-    4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,\n-    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    5,  5,  5,  5,  5,  5,  5,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  5,  5,  5,  5,  5,  2,  2,  2,  2,  2,  7, 12,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7, 25,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  2,  7,  7,  7,  7,  7,  2,  7,  2,\n-    7,  7,  2,  7,  7,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n-   24, 24, 24,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 18, 22,\n-    2,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  2,  2,  2, 26,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 23, 26, 26, 26,\n-   21, 21, 21, 21, 21, 21, 21, 22, 18, 21,  2,  2,  2,  2,  2,  2,\n-   21, 17, 17, 16, 16, 22, 18, 22, 18, 22, 18, 22, 18, 22, 18, 22,\n-   18, 22, 18, 22, 18, 21, 21, 22, 18, 21, 21, 21, 21, 16, 16, 16,\n-   21, 21, 21,  2, 21, 21, 21, 21, 17, 22, 18, 22, 18, 22, 18, 21,\n-   21, 21, 25, 17, 25, 25, 25,  2, 21, 23, 21, 21,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  1,\n-    2, 21, 21, 21, 23, 21, 21, 21, 22, 18, 21, 25, 21, 17, 21, 21,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 22, 25, 18, 25, 22,\n-   18, 21, 22, 18, 21, 21,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    6,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  6,  6,\n-    2,  2,  7,  7,  7,  7,  7,  7,  2,  2,  7,  7,  7,  7,  7,  7,\n-    2,  2,  7,  7,  7,  7,  7,  7,  2,  2,  7,  7,  7,  2,  2,  2,\n-   23, 23, 25, 24, 26, 23, 23,  2, 26, 25, 25, 25, 25, 26, 26,  2,\n-    2,  2,  2,  2,  2,  2,  2,  2,  2,  1,  1,  1, 26, 26,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  7,  7,  2,  7,\n-   21, 21, 21,  2,  2,  2,  2, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15,  2,  2,  2, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   14, 14, 14, 14, 14, 15, 15, 15, 15, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 15, 15, 26, 26, 26,  2,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,  2,  2,  2,\n-   26,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 12,  2,  2,\n-   12, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  2,  2,  2,  2,\n-   15, 15, 15, 15,  2,  2,  2,  2,  2,  2,  2,  2,  2,  7,  7,  7,\n-    7, 14,  7,  7,  7,  7,  7,  7,  7,  7, 14,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7, 12, 12, 12, 12, 12,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2, 21,\n-    7,  7,  7,  7,  2,  2,  2,  2,  7,  7,  7,  7,  7,  7,  7,  7,\n-   21, 14, 14, 14, 14, 14,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    9,  9,  9,  9,  9,  9,  9,  9,  5,  5,  5,  5,  5,  5,  5,  5,\n-    9,  9,  9,  9,  2,  2,  2,  2,  5,  5,  5,  5,  5,  5,  5,  5,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 21,\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  2,  9,  9,  9,  9,\n-    9,  9,  9,  2,  9,  9,  2,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n-    5,  5,  2,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n-    5,  5,  2,  5,  5,  5,  5,  5,  5,  5,  2,  5,  5,  2,  2,  2,\n-    6,  6,  6,  6,  6,  6,  2,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n-    6,  2,  6,  6,  6,  6,  6,  6,  6,  6,  6,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  2,  2,  7,  2,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  2,  7,  7,  2,  2,  2,  7,  2,  2,  7,\n-    7,  7,  7,  7,  7,  7,  2, 21, 15, 15, 15, 15, 15, 15, 15, 15,\n-    7,  7,  7,  7,  7,  7,  7, 26, 26, 15, 15, 15, 15, 15, 15, 15,\n-    2,  2,  2,  2,  2,  2,  2, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-    7,  7,  7,  2,  7,  7,  2,  2,  2,  2,  2, 15, 15, 15, 15, 15,\n-    7,  7,  7,  7,  7,  7, 15, 15, 15, 15, 15, 15,  2,  2,  2, 21,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  2, 21,\n-    7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2, 15, 15,  7,  7,\n-    2,  2, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-    7, 12, 12, 12,  2, 12, 12,  2,  2,  2,  2,  2, 12, 12, 12, 12,\n-    7,  7,  7,  7,  2,  7,  7,  7,  2,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  2,  2, 12, 12, 12,  2,  2,  2,  2, 12,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15,  2,  2,  2,  2,  2,  2,  2,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 15, 15, 21,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 15, 15, 15,\n-    7,  7,  7,  7,  7,  7,  7,  7, 26,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7, 12, 12,  2,  2,  2,  2, 15, 15, 15, 15, 15,\n-   21, 21, 21, 21, 21, 21, 21,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  2,  2,  2, 21, 21, 21, 21, 21, 21, 21,\n-    7,  7,  7,  7,  7,  7,  2,  2, 15, 15, 15, 15, 15, 15, 15, 15,\n-    7,  7,  7,  2,  2,  2,  2,  2, 15, 15, 15, 15, 15, 15, 15, 15,\n-    7,  7,  2,  2,  2,  2,  2,  2,  2, 21, 21, 21, 21,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2,  2,  2, 15, 15, 15, 15, 15, 15, 15,\n-    9,  9,  9,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    5,  5,  5,  2,  2,  2,  2,  2,  2,  2, 15, 15, 15, 15, 15, 15,\n-    7,  7,  7,  7, 12, 12, 12, 12,  2,  2,  2,  2,  2,  2,  2,  2,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2, 12, 12, 17,  2,  2,\n-    7,  7,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   15, 15, 15, 15, 15, 15, 15,  7,  2,  2,  2,  2,  2,  2,  2,  2,\n-   12, 15, 15, 15, 15, 21, 21, 21, 21, 21,  2,  2,  2,  2,  2,  2,\n-    7,  7, 12, 12, 12, 12, 21, 21, 21, 21,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7, 15, 15, 15, 15, 15, 15, 15,  2,  2,  2,  2,\n-   10, 12, 10,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 21, 21, 21, 21, 21, 21, 21,  2,  2,\n-   15, 15, 15, 15, 15, 15, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n-   12,  7,  7, 12, 12,  7,  2,  2,  2,  2,  2,  2,  2,  2,  2, 12,\n-   10, 10, 10, 12, 12, 12, 12, 10, 10, 12, 12, 21, 21,  1, 21, 21,\n-   21, 21, 12,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  1,  2,  2,\n-   12, 12, 12,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7, 12, 12, 12, 12, 12, 10, 12, 12, 12,\n-   12, 12, 12, 12, 12,  2, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n-   21, 21, 21, 21,  7, 10, 10,  7,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7, 12, 21, 21,  7,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7, 10, 10, 10, 12, 12, 12, 12, 12, 12, 12, 12, 12, 10,\n-   10,  7,  7,  7,  7, 21, 21, 21, 21, 12, 12, 12, 12, 21, 10, 12,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13,  7, 21,  7, 21, 21, 21,\n-    2, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 15,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 10, 10, 10, 12,\n-   12, 12, 10, 10, 12, 10, 12, 12, 21, 21, 21, 21, 21, 21, 12,  2,\n-    7,  7,  7,  7,  7,  7,  7,  2,  7,  2,  7,  7,  7,  7,  2,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7, 21,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 12,\n-   10, 10, 10, 12, 12, 12, 12, 12, 12, 12, 12,  2,  2,  2,  2,  2,\n-   12, 12, 10, 10,  2,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  7,\n-    7,  2,  7,  7,  2,  7,  7,  7,  7,  7,  2, 12, 12,  7, 10, 10,\n-   12, 10, 10, 10, 10,  2,  2, 10, 10,  2,  2, 10, 10, 10,  2,  2,\n-    7,  2,  2,  2,  2,  2,  2, 10,  2,  2,  2,  2,  2,  7,  7,  7,\n-    7,  7, 10, 10,  2,  2, 12, 12, 12, 12, 12, 12, 12,  2,  2,  2,\n-   12, 12, 12, 12, 12,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7, 10, 10, 10, 12, 12, 12, 12, 12, 12, 12, 12,\n-   10, 10, 12, 12, 12, 10, 12,  7,  7,  7,  7, 21, 21, 21, 21, 21,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 21, 21,  2, 21, 12,  7,\n-   10, 10, 10, 12, 12, 12, 12, 12, 12, 10, 12, 10, 10, 10, 10, 12,\n-   12, 10, 12, 12,  7,  7, 21,  7,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 10,\n-   10, 10, 12, 12, 12, 12,  2,  2, 10, 10, 10, 10, 12, 12, 10, 12,\n-   12, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21,  7,  7,  7,  7, 12, 12,  2,  2,\n-   10, 10, 10, 12, 12, 12, 12, 12, 12, 12, 12, 10, 10, 12, 10, 12,\n-   12, 21, 21, 21,  7,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 12, 10, 12, 10, 10,\n-   12, 12, 12, 12, 12, 12, 10, 12,  7, 21,  2,  2,  2,  2,  2,  2,\n-   10, 10, 12, 12, 12, 12, 10, 12, 12, 12, 12, 12,  2,  2,  2,  2,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 15, 15, 21, 21, 21, 26,\n-   12, 12, 12, 12, 12, 12, 12, 12, 10, 12, 12, 21,  2,  2,  2,  2,\n-   15, 15, 15,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  7,\n-    7,  7,  7,  7,  7,  7,  7,  2,  2,  7,  2,  2,  7,  7,  7,  7,\n-    7,  7,  7,  7,  2,  7,  7,  2,  7,  7,  7,  7,  7,  7,  7,  7,\n-   10, 10, 10, 10, 10, 10,  2, 10, 10,  2,  2, 12, 12, 10, 12,  7,\n-   10,  7, 10, 12, 21, 21, 21,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  7,  7,  7,  7,  7,  7,\n-    7, 10, 10, 10, 12, 12, 12, 12,  2,  2, 12, 12, 10, 10, 10, 10,\n-   12,  7, 21,  7, 10,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,  7,  7,  7,  7,  7,\n-    7,  7,  7, 12, 12, 12, 12, 12, 12, 10,  7, 12, 12, 12, 12, 21,\n-   21, 21, 21, 21, 21, 21, 21, 12,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7, 12, 12, 12, 12, 12, 12, 10, 10, 12, 12, 12,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 10, 12, 12, 21, 21, 21,  7, 21, 21,\n-   21, 21, 21,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   12, 12, 12, 12, 12, 12, 12,  2, 12, 12, 12, 12, 12, 12, 10, 12,\n-    7, 21, 21, 21, 21, 21,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   21, 21,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    2,  2, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12,  2, 10, 12, 12, 12, 12, 12, 12,\n-   12, 10, 12, 12, 10, 12, 12,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  2,  7,  7,  2,  7,  7,  7,  7,  7,\n-    7, 12, 12, 12, 12, 12, 12,  2,  2,  2, 12,  2, 12, 12,  2, 12,\n-   12, 12, 12, 12, 12, 12,  7, 12,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  2,  7,  7,  2,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 10, 10, 10, 10, 10,  2,\n-   12, 12,  2, 10, 10, 12, 10, 12,  7,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7, 12, 12, 10, 10, 21, 21,  2,  2,  2,  2,  2,  2,  2,\n-   15, 15, 15, 15, 15, 26, 26, 26, 26, 26, 26, 26, 26, 23, 23, 23,\n-   23, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 21,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,  2,\n-   21, 21, 21, 21, 21,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7, 21, 21,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,\n-   12, 12, 12, 12, 12, 21,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   12, 12, 12, 12, 12, 12, 12, 21, 21, 21, 21, 21, 26, 26, 26, 26,\n-    6,  6,  6,  6, 21, 26,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13,  2, 15, 15, 15, 15, 15,\n-   15, 15,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  2,  7,  7,  7,\n-   15, 15, 15, 15, 15, 15, 15, 21, 21, 21, 21,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2, 12,\n-    7, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n-   10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n-   10, 10, 10, 10, 10, 10, 10, 10,  2,  2,  2,  2,  2,  2,  2, 12,\n-   12, 12, 12,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n-    6,  6, 21,  6, 12,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   10, 10,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    6,  6,  6,  6,  2,  6,  6,  6,  6,  6,  6,  6,  2,  6,  6,  2,\n-    7,  7,  7,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  7,  7,  7,  7,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2, 26, 12, 12, 21,\n-    1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,  2,  2,\n-   12, 12, 12, 12, 12, 12, 12,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   26, 26, 26, 26, 26, 26, 26,  2,  2, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 10, 10, 12, 12, 12, 26, 26, 26, 10, 10, 10,\n-   10, 10, 10,  1,  1,  1,  1,  1,  1,  1,  1, 12, 12, 12, 12, 12,\n-   12, 12, 12, 26, 26, 12, 12, 12, 12, 12, 12, 12, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 12, 12, 12, 12, 26, 26,\n-   26, 26, 12, 12, 12, 26,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   15, 15, 15, 15,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  5,  5,  5,  5,  5,  5,\n-    5,  5,  5,  5,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  5,  5,\n-    5,  5,  5,  5,  5,  2,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n-    9,  9,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  9,  2,  9,  9,\n-    2,  2,  9,  2,  2,  9,  9,  2,  2,  9,  9,  9,  9,  2,  9,  9,\n-    9,  9,  9,  9,  9,  9,  5,  5,  5,  5,  2,  5,  2,  5,  5,  5,\n-    5,  5,  5,  5,  2,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n-    5,  5,  5,  5,  9,  9,  2,  9,  9,  9,  9,  2,  2,  9,  9,  9,\n-    9,  9,  9,  9,  9,  2,  9,  9,  9,  9,  9,  9,  9,  2,  5,  5,\n-    5,  5,  5,  5,  5,  5,  5,  5,  9,  9,  2,  9,  9,  9,  9,  2,\n-    9,  9,  9,  9,  9,  2,  9,  2,  2,  2,  9,  9,  9,  9,  9,  9,\n-    9,  2,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  9,  9,  9,  9,\n-    9,  9,  9,  9,  9,  9,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n-    5,  5,  5,  5,  5,  5,  2,  2,  9,  9,  9,  9,  9,  9,  9,  9,\n-    9, 25,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 25,  5,  5,  5,  5,\n-    5,  5,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 25,  5,  5,  5,  5,\n-    5,  5,  5,  5,  5, 25,  5,  5,  5,  5,  5,  5,  9,  9,  9,  9,\n-    9,  9,  9,  9,  9, 25,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 25,\n-    5,  5,  5,  5,  5,  5,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 25,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5, 25,  5,  5,  5,  5,  5,  5,\n-    9,  9,  9,  9,  9,  9,  9,  9,  9, 25,  5,  5,  5,  5,  5,  5,\n-    5,  5,  5, 25,  5,  5,  5,  5,  5,  5,  9,  5,  2,  2, 13, 13,\n+    7,  7,  7,  7, 37,  7, 38, 39,  7, 40,  7,  7,  7, 41, 22, 42,\n+    7,  7, 43,  7, 44, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   45, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n@@ -1832,455 +1105,10 @@\n-   12, 12, 12, 12, 12, 12, 12, 26, 26, 26, 26, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 26, 26, 26,\n-   26, 26, 26, 26, 26, 12, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 12, 26, 26, 21, 21, 21, 21, 21,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 12, 12, 12, 12, 12,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  7,  5,  5,  5,  5,  5,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  2,\n-   12, 12, 12, 12, 12, 12, 12,  2, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12,  2,  2, 12, 12, 12, 12, 12,\n-   12, 12,  2, 12, 12,  2, 12, 12, 12, 12, 12,  2,  2,  2,  2,  2,\n-   12, 12, 12, 12, 12, 12, 12,  6,  6,  6,  6,  6,  6,  6,  2,  2,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13,  2,  2,  2,  2,  7, 26,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 12,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 12, 12, 12, 12,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13,  2,  2,  2,  2,  2, 23,\n-    7,  7,  7,  7,  7,  7,  7,  2,  7,  7,  7,  7,  2,  7,  7,  2,\n-    7,  7,  7,  7,  7,  2,  2, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-    5,  5,  5,  5, 12, 12, 12, 12, 12, 12, 12,  6,  2,  2,  2,  2,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 26, 15, 15, 15,\n-   23, 15, 15, 15, 15,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 26, 15,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  2,  2,\n-    7,  7,  7,  7,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    2,  7,  7,  2,  7,  2,  2,  7,  2,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  2,  7,  7,  7,  7,  2,  7,  2,  7,  2,  2,  2,  2,\n-    2,  2,  7,  2,  2,  2,  2,  7,  2,  7,  2,  7,  2,  7,  7,  7,\n-    2,  7,  7,  2,  7,  2,  2,  7,  2,  7,  2,  7,  2,  7,  2,  7,\n-    2,  7,  7,  2,  7,  2,  2,  7,  7,  7,  7,  2,  7,  7,  7,  7,\n-    7,  7,  7,  2,  7,  7,  7,  7,  2,  7,  7,  7,  7,  2,  7,  2,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  7,  7,  7,  7,  7,\n-    2,  7,  7,  7,  2,  7,  7,  7,  7,  7,  2,  7,  7,  7,  7,  7,\n-   25, 25,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,  2,  2,\n-    2,  2,  2,  2,  2,  2, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26,  2,  2,  2,  2,  2,  2,  2,\n-   26, 26,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 24, 24, 24, 24, 24,\n-   26, 26, 26, 26, 26, 26, 26, 26,  2,  2,  2,  2,  2, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26,  2,  2,  2,  2,  2,  2,  2,  2,\n-   26, 26, 26, 26, 26,  2,  2,  2, 26, 26, 26, 26, 26,  2,  2,  2,\n-   26, 26, 26,  2, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-    2,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n-    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  2,  2,\n-    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  0,  0,\n-    0,  0,  0,  0,  0,  0,  1,  0,  0,  2,  0,  3,  4,  5,  6,  7,\n-    8,  9, 10, 11, 12, 12, 12, 13, 14, 12, 15, 16, 17, 18, 19, 20,\n-   21, 22,  0,  0,  0,  0, 23,  0,  0,  0,  0,  0,  0,  0, 24, 25,\n-    0, 26, 27,  0, 28, 29, 30, 31, 32, 33,  0, 34,  0,  0,  0,  0,\n-    0, 35,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0, 36, 37, 38,  0,  0,  0,  0,\n-   39, 40,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 41, 42,  0,  0,\n-   43, 44, 45, 46,  0, 47,  0, 48,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 49,  0,  0,  0,  0,  0, 50,  0,  0,  0,\n-    0,  0,  0, 51,  0, 52, 53,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0, 54, 55,  0,  0,  0,  0, 56,  0,  0, 57, 58, 59,\n-   60, 61, 62, 63, 64, 65, 66,  0, 67, 68,  0, 69, 70, 71, 72,  0,\n-   61,  0, 73, 74, 75, 76,  0,  0, 70,  0, 77, 78,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0, 79, 80,  0,  0,  0,  0,  0,  0,  0,  0, 81,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0, 82,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0, 83, 84, 85,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-   86,  0, 80,  0,  0, 87,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0, 88, 89,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  1,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,\n-   12,  1,  0,  0, 13,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 14, 15, 16, 17, 18, 19, 20,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  1, 21,  0,  0,  0,  0,  0, 22, 23, 24,\n-    0,  0, 25,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 26, 27,\n-   28, 29,  0,  0,  0,  0, 30,  0,  0,  0, 31, 32, 33, 34,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0, 13, 35, 36,  0,  0, 26, 37, 38, 39,  0,  0,  0,  0,  0, 40,\n-    0,  0,  0,  0,  0,  0,  0, 41,  0,  0,  0,  0,  0, 42, 43,  1,\n-   44, 45, 46, 47,  0,  0,  0,  0,  0,  0,  0, 48,  0, 49, 50,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 48,  0, 49,  0,  0,\n-    0,  0,  0, 51,  0,  0,  0,  0,  0,  0,  0, 48,  0, 49,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 49,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 48,  0, 49, 52,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 53,  0, 49,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 54,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 55,  0, 56,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 57,  0, 58,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 59,  0,  0, 60, 61,  0,  0,  0,  0,\n-    0,  0, 62, 63, 64,  0,  0,  0,  0,  0,  0,  0, 65,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 66, 67,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0, 36,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 68,\n-    0,  0,  0,  0,  0,  0, 69,  0,  0,  0, 70,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 54, 71,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0, 72,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 73,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 74, 75,  0,  0,  0,  0,  0,  0,  0,  0,\n-   76,  0, 68, 77,  0,  0,  0,  0,  0,  0, 78, 79, 80, 81,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 48,  0, 70,  0,  0,  0,\n-    0, 82, 83,  0,  0,  0,  0,  0,  0, 84,  0,  0,  0,  0,  0,  0,\n-   85,  0, 84,  0,  0,  0,  0,  0,  0,  0, 66,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 86, 87,\n-   88, 89, 90, 91,  0,  0,  0,  0,  0,  0,  0,  0, 92, 93, 94,  1,\n-    1,  1, 95, 96,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 97, 98,\n-   99,100,101,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0, 74, 91,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,102,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    1,  1,  1,  1,  0,  0,  0,  0,  0,103,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,104,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0, 74,105,106,  0,  0,  0, 26,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0, 91,  0,107,  0,  0,  0,  0, 70,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 70,  0,  0,  0,\n-    1,  1, 91,  0,  0,  0,  0,  0,  0,108,  0,  0,  0,  0,109,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,110,  0, 76,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,111,112,113,  0,  0,  0,\n-    0,  0,107,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0, 49,  0,  0,  0,  0,  0,114,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,115,116,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0, 36,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-   75,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0, 26,117,  0,118,  0,  0,  0,  0,  0,119,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-  120,  0,  0,  0,  0,  0,  0,  0,105,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,121,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,122,123, 75,  0,\n-    0,  0,  0,  0,124,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,107,  0,  0,  0,\n-    0,  0, 76,102,  0,  0,  0,  0,  0,  0,  0,125,  0,  0,  0,  0,\n-    0,  0,  0,  0,117,  0,  0,  0,  0,  0, 53,  0,  0,  0,  0,  0,\n-    0,  0,110,  0,  0,  0,  0,  0,  0,  0,  0,  0, 76,126,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,127,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,128,  0,  0,  0,  0,  0,  0,  0,  0,  0,129,  0, 49,  0,  0,\n-   26,130,130,  0,  0,  0,  0,  0,  0,  0,  0,  0,131,  0,  0, 51,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,132,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,102,133,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,102,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,134,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,109,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,135,110,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-   76,  0,  0,  0,  0,  0,  0,  0,  0,  0, 70,  0,102,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,136,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,137,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,102,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,138,  0,  0,  0,  0,  0,  0,  0,139,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,140,  0,  0,  0,  0,141,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-  142,143,144,145,146,147,  0,  0,  0,148,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,149,  0,  0,  0,\n-    0,  0,  0,  0,139,  1,  1,150,151,117,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0, 51,  0,  0,  0,  0,  0,  0,\n-    0,105,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,152,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,105,153,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,230,230,230,230,\n-  230,230,230,230,230,230,230,230,230,232,220,220,220,220,232,216,\n-  220,220,220,220,220,202,202,220,220,220,220,202,202,220,220,220,\n-  220,220,220,220,220,220,220,220,  1,  1,  1,  1,  1,220,220,220,\n-  220,230,230,230,230,230,230,230,230,240,230,220,220,220,230,230,\n-  230,220,220,  0,230,230,230,220,220,220,220,230,232,220,220,230,\n-  233,234,234,233,234,234,233,230,230,230,230,230,  0,  0,  0,230,\n-  230,230,230,230,  0,220,230,230,230,230,220,230,230,230,222,220,\n-  230,230,230,230,230,230,220,220,220,220,220,220,230,230,220,230,\n-  230,222,228,230, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20,\n-   21, 22,  0, 23,  0, 24, 25,  0,230,220,  0, 18, 30, 31, 32,  0,\n-    0,  0,  0,  0,  0,  0,  0, 27, 28, 29, 30, 31, 32, 33, 34,230,\n-  230,220,220,230,230,230,230,230,220,230,230,220, 35,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,230,230,230,230,230,230,\n-  230,  0,  0,230,230,230,230,220,230,  0,  0,230,230,  0,220,230,\n-  230,220,  0,  0,  0, 36,  0,  0,  0,  0,  0,  0,230,220,230,230,\n-  220,230,230,220,220,220,230,220,220,230,220,230,230,230,220,230,\n-  220,230,220,230,220,230,230,  0,  0,  0,  0,  0,230,230,220,230,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,220,  0,  0,230,230,  0,230,\n-  230,230,230,230,230,230,230,230,  0,230,230,230,  0,230,230,230,\n-  230,230,  0,  0,  0,220,220,220,  0,  0,  0,  0,230,220,220,220,\n-  230,230,230,230,  0,  0,230,230,230,230,230,220,220,220,220,220,\n-  230,230,230,230,230,230,  0,220,230,230,220,230,230,220,230,230,\n-  230,220,220,220, 27, 28, 29,230,230,230,220,230,230,220,220,230,\n-  230,230,230,230,  0,  0,  0,  0,  7,  0,  0,  0,  0,  0,  0,  0,\n-    0,  9,  0,  0,  0,230,220,230,230,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,230,  0,  0,  0,  0,  0,  0, 84, 91,  0,  0,  0,  0,  9,\n-    9,  0,  0,  0,  0,  0,  9,  0,  0,  0,  0,  0,103,103,  9,  0,\n-    0,  0,  0,  0,107,107,107,107,  0,  0,  0,  0,118,118,  9,  0,\n-    0,  0,  0,  0,122,122,122,122,  0,  0,  0,  0,220,220,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,220,  0,220,  0,216,  0,  0,\n-    0,  0,  0,  0,  0,129,130,  0,132,  0,  0,  0,  0,  0,130,130,\n-  130,130,  0,  0,130,  0,230,230,  9,  0,230,230,  0,  0,  0,  0,\n-    0,  0,220,  0,  0,  0,  0,  0,  0,  0,  0,  7,  0,  9,  9,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,230,230,230,  0,  0,  0,  0,\n-    9,  9,  0,  0,  0,  0,  0,  0,  9,  0,  0,  0,  0,  0,  0,  0,\n-    0,230,  0,  0,  0,228,  0,  0,  0,  0,  0,  0,  0,222,230,220,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,230,220,  0,  0,  0,\n-    0,  0,  0,  0,  9,  0,  0,  0,  0,  0,  0,  0,230,230,230,230,\n-  230,  0,  0,220,230,230,230,230,230,220,220,220,220,220,220,230,\n-  230,220,  0,220,220,230,230,220,220,230,230,230,230,230,220,230,\n-  230,230,230,  0,  0,  0,  0,230,220,230,230,230,230,230,230,230,\n-    0,  0,  0,  0,  0,  0,  9,  9,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  7,  0,230,230,230,  0,  1,220,220,220,220,220,230,230,\n-  220,220,220,220,230,  0,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,\n-    0,220,  0,  0,  0,  0,  0,  0,230,  0,  0,  0,230,230,  0,  0,\n-    0,  0,  0,  0,230,230,220,230,230,230,230,230,230,230,220,230,\n-  230,234,214,220,202,230,230,230,230,230,230,230,230,230,230,230,\n-  230,230,232,228,228,220,218,230,233,220,230,220,230,230,  1,  1,\n-  230,230,230,230,  1,  1,  1,230,230,  0,  0,  0,  0,230,  0,  0,\n-    0,  1,  1,230,220,230,  1,  1,220,220,220,220,230,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  9,  0,  0,218,228,\n-  232,222,224,224,  0,  8,  8,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-  230,230,230,230,230,230,230,230,230,230,  0,  0,  0,  0,  0,  0,\n-    0,  0,  9,  0,  0,  0,  0,220,220,220,  0,  0,  0,  0,  0,  9,\n-    0,  0,  0,  0,  0,  0,  0,  7,  0,  0,  0,  0,230,  0,230,230,\n-  220,  0,  0,230,230,  0,  0,  0,  0,  0,230,230,  0,230,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 26,  0,230,230,230,230,\n-  230,230,230,220,220,220,220,220,220,220,230,230,230,230,230,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,220,  0,230,230,  1,220,  0,\n-    0,  0,  0,  9,  0,  0,  0,  0,  0,230,220,  0,  0,  0,  0,230,\n-  230,  0,  0,  0,  0,  0,  0,  0,  0,  0,220,220,230,230,230,220,\n-  230,220,220,220,  0,  0,230,220,230,220,  0,  0,  0,  9,  7,  0,\n-    0,  0,  0,  0,  0,  0,  7,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  9,  7,  0,  0,  7,  9,  0,  0,  0,  0,  0,  0,  0,  0,  7,\n-    7,  0,  0,  0,230,230,230,230,230,  0,  0,  0,  0,  0,  9,  0,\n-    0,  0,  7,  0,  0,  0,  9,  7,  0,  0,  0,  0,  7,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  9,  7,  0,  0,  0,  0,\n-    0,  9,  9,  0,  0,  9,  0,  0,  0,  0,  0,  0,  0,  0,  7,  0,\n-    9,  9,  0,  0,  1,  1,  1,  1,  1,  0,  0,  0,230,230,230,230,\n-  230,230,230,  0,  6,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  1,  0,  0,  0,  0,  0,  0,216,216,  1,  1,  1,  0,  0,\n-    0,226,216,216,216,216,216,  0,  0,  0,  0,  0,  0,  0,  0,220,\n-  220,220,220,220,220,220,220,  0,  0,230,230,230,230,230,220,220,\n-    0,  0,  0,  0,  0,  0,230,230,230,230,  0,  0,  0,  0,230,230,\n-  230,  0,  0,  0,230,  0,  0,230,230,230,230,230,230,230,  0,230,\n-  230,  0,230,230,220,220,220,220,220,220,220,  0,230,230,  7,  0,\n-    0,  0,  0,  0, 16, 17, 17, 17, 17, 17, 17, 33, 17, 17, 17, 19,\n-   17, 17, 17, 17, 20,101, 17,113,129,169, 17, 27, 28, 17, 17, 17,\n-   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n-   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n-   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n-   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n-   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n-   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n-   17, 17, 17,237,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,\n-    0,  0,  0,  2,  0,  0,  0,  0,  0,  0,  3,  4,  0,  0,  0,  0,\n-    0,  0,  3,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,\n-    0,  0,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  7,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8,  9,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0, 10,  0,  0, 10,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0, 10,  0,  0,  0, 10,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 11, 12,  0, 13,  0, 14, 15, 16,  0,  0,\n-    0,  0,  0,  1, 17, 18,  0, 19,  7,  1,  0,  0,  0, 20, 20,  7,\n-   20, 20, 20, 20, 20, 20, 20,  8, 21,  0, 22,  0,  7, 23, 24,  0,\n-   20, 20, 25,  0,  0,  0, 26, 27,  1,  7, 20, 20, 20, 20, 20,  1,\n-   28, 29, 30, 31,  0,  0, 20,  0,  0,  0,  0,  0,  0,  0, 10,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 20, 20,\n-   20,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  8, 21, 32,  4,  0, 10,  0, 33,  7, 20, 20, 20,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  8, 34, 34, 35, 36, 34, 37,  0, 38,  1, 20, 20,\n-    0,  0, 39,  0,  1,  1,  0,  8, 21,  1, 20,  0,  0,  0,  1,  0,\n-    0, 40,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8, 21,\n-    0,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,\n-    0,  0, 26, 34, 34, 34, 34, 34, 34, 34, 34, 34, 21,  7, 20, 41,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 21,  0, 42, 43, 44,  0, 45,\n-    0,  8, 21,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0, 46,  7,  1, 10,  1,  0,  0,  0,  1, 20, 20,  1,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0, 26, 34,  9,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 20, 20,  1, 20, 20,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 26, 21,  0,  1,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  2,  0,  0,  0,  0,\n-    0,  0,  3,  4,  0,  0,  0,  0,  0,  0,  3, 47, 48,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,\n-    0,  0,  0,  2,  0,  0,  0,  0,  0,  0,  3,  4,  0,  0,  0,  0,\n-    0,  0,  3,  4,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,\n-   12, 13, 14, 15, 16, 17, 18, 17, 19, 20, 21, 22, 23, 24, 25, 25,\n-   25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 25, 25, 25, 25, 25,\n-   25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n-   25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n-   25, 25, 25, 25, 27, 27, 28, 29, 30, 31, 32, 32, 32, 32, 32, 32,\n-   32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,\n-   51, 52, 53, 54, 55, 56, 57, 34, 34, 34, 34, 58, 59, 59, 60, 34,\n-   34, 34, 34, 34, 34, 34, 61, 62, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 63, 64, 34, 65, 66, 66, 66, 66,\n-   66, 66, 66, 66, 66, 66, 66, 67, 66, 68, 69, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 70, 71, 72, 34, 34,\n-   34, 34, 73, 34, 34, 34, 34, 34, 34, 34, 34, 74, 75, 76, 77, 78,\n-   79, 80, 34, 81, 82, 83, 34, 84, 85, 34, 86, 87, 88, 89, 17, 90,\n-   91, 92, 34, 34, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n-   25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n-   25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n-   25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n-   25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n-   25, 25, 25, 25, 25, 25, 25, 93, 25, 25, 25, 25, 25, 25, 25, 94,\n-   95, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 96, 25, 25, 25, 25,\n-   25, 25, 25, 25, 25, 25, 25, 25, 25, 97, 34, 34, 34, 34, 34, 34,\n-   25, 98, 34, 34, 25, 25, 25, 25, 25, 25, 25, 25, 25, 99, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 46,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 47,\n+    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n+   16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n+   32, 33, 34, 34, 35, 36, 37, 38, 39, 34, 34, 34, 40, 41, 42, 43,\n+   44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n+   60, 61, 62, 63, 64, 64, 65, 66, 67, 68, 69, 70, 71, 69, 72, 73,\n+   69, 69, 64, 74, 64, 64, 75, 76, 77, 78, 79, 80, 81, 82, 69, 83,\n+   84, 85, 86, 87, 88, 89, 69, 69, 34, 34, 34, 34, 34, 34, 34, 34,\n@@ -2288,2 +1116,650 @@\n-   34, 34, 34, 34,100,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 90, 34, 34, 34, 34,\n+   91, 34, 34, 34, 34, 34, 34, 34, 34, 92, 34, 34, 93, 94, 95, 96,\n+   97, 98, 99,100,101,102,103,104, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,105,\n+  106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,\n+  107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,\n+  107,107, 34, 34,108,109,110,111, 34, 34,112,113,114,115,116,117,\n+  118,119,120,121,122,123,124,125,126,127,128,129, 34, 34,130,131,\n+  132,133,134,135,136,137,138,139,140,141,142,122,143,144,145,146,\n+  147,148,149,150,151,152,153,122,154,155,122,156,157,158,159,122,\n+  160,161,162,163,164,165,166,122,167,168,169,170,122,171,172,173,\n+   34, 34, 34, 34, 34, 34, 34,174,175, 34,176,122,122,122,122,122,\n+  122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,177,\n+   34, 34, 34, 34, 34, 34, 34, 34,178,122,122,122,122,122,122,122,\n+  122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,\n+  122,122,122,122,122,122,122,122, 34, 34, 34, 34,179,122,122,122,\n+   34, 34, 34, 34,180,181,182,183,122,122,122,122,184,185,186,187,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,188,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34,189,190,122,122,122,122,122,\n+  122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,191,\n+   34, 34,192, 34, 34,193,122,122,122,122,122,122,122,122,122,122,\n+  122,122,122,122,122,122,122,122,194,195,122,122,122,122,122,122,\n+  122,122,122,122,122,122,122,122,122,122,122,122,122,122,196,197,\n+   69,198,199,200,201,202,203,122,204,205,206,207,208,209,210,211,\n+   69, 69, 69, 69,212,213,122,122,122,122,122,122,122,122,214,122,\n+  215,216,217,122,122,218,122,122,122,219,122,122,122,122,122,220,\n+   34,221,222,122,122,122,122,122,223,224,225,122,226,227,122,122,\n+  228,229,230,231,232,122, 69,233, 69, 69, 69, 69, 69,234,235,236,\n+  237,238, 69, 69,239,240, 69,241,122,122,122,122,122,122,122,122,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,242, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,243, 34,\n+  244, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,245, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34,246,122,122,122,122,122,122,122,122,\n+   34, 34, 34, 34,247,122,122,122,122,122,122,122,122,122,122,122,\n+   34, 34, 34, 34, 34, 34,248, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34,249,122,122,122,122,122,122,122,122,\n+  250,122,251,252,122,122,122,122,122,122,122,122,122,122,122,122,\n+  107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,253,\n+  107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,254,\n+    0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  2,  4,  5,  6,  2,\n+    7,  7,  7,  7,  7,  2,  8,  9, 10, 11, 11, 11, 11, 11, 11, 11,\n+   11, 11, 11, 11, 11, 12, 13, 14, 15, 16, 16, 16, 16, 16, 16, 16,\n+   16, 16, 16, 16, 16, 17, 18, 19,  1, 20, 20, 21, 22, 23, 24, 25,\n+   26, 27, 15,  2, 28, 29, 27, 30, 11, 11, 11, 11, 11, 11, 11, 11,\n+   11, 11, 11, 31, 11, 11, 11, 32, 16, 16, 16, 16, 16, 16, 16, 16,\n+   16, 16, 16, 33, 16, 16, 16, 16, 32, 32, 32, 32, 32, 32, 32, 32,\n+   32, 32, 32, 32, 34, 34, 34, 34, 34, 34, 34, 34, 16, 32, 32, 32,\n+   32, 32, 32, 32, 11, 34, 34, 16, 34, 32, 32, 11, 34, 11, 16, 11,\n+   11, 34, 32, 11, 32, 16, 11, 34, 32, 32, 32, 11, 34, 16, 32, 11,\n+   34, 11, 34, 34, 32, 35, 32, 16, 36, 36, 37, 34, 38, 37, 34, 34,\n+   34, 34, 34, 34, 34, 34, 16, 32, 34, 38, 32, 11, 32, 32, 32, 32,\n+   32, 32, 16, 16, 16, 11, 34, 32, 34, 34, 11, 32, 32, 32, 32, 32,\n+   16, 16, 39, 16, 16, 16, 16, 16, 40, 40, 40, 40, 40, 40, 40, 40,\n+   40, 41, 41, 40, 40, 40, 40, 40, 40, 41, 41, 41, 41, 41, 41, 41,\n+   40, 40, 42, 41, 41, 41, 42, 42, 41, 41, 41, 41, 41, 41, 41, 41,\n+   43, 43, 43, 43, 43, 43, 43, 43, 32, 32, 42, 32, 44, 45, 16, 10,\n+   44, 44, 41, 46, 11, 47, 47, 11, 34, 11, 11, 11, 11, 11, 11, 11,\n+   11, 48, 11, 11, 11, 11, 16, 16, 16, 16, 16, 16, 16, 16, 16, 34,\n+   16, 11, 32, 16, 32, 32, 32, 32, 16, 16, 32, 49, 34, 32, 34, 11,\n+   32, 50, 43, 43, 51, 32, 32, 32, 11, 34, 34, 34, 34, 34, 34, 16,\n+   48, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 47, 52,  2,  2,  2,\n+   16, 16, 16, 16, 53, 54, 55, 56, 57, 43, 43, 43, 43, 43, 43, 43,\n+   43, 43, 43, 43, 43, 43, 43, 58, 59, 60, 43, 59, 44, 44, 44, 44,\n+   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 61, 44, 62,\n+   36, 63, 64, 44, 44, 44, 44, 44, 65, 65, 65,  8,  9, 66,  2, 67,\n+   43, 43, 43, 43, 43, 60, 68,  2, 69, 36, 36, 36, 36, 70, 43, 43,\n+    7,  7,  7,  7,  7,  2,  2, 36, 71, 36, 36, 36, 36, 36, 36, 36,\n+   36, 36, 72, 43, 43, 43, 73, 50, 43, 43, 74, 75, 76, 43, 43, 36,\n+    7,  7,  7,  7,  7, 36, 77, 78,  2,  2,  2,  2,  2,  2,  2, 79,\n+   70, 36, 36, 36, 36, 36, 36, 36, 43, 43, 43, 43, 43, 80, 62, 36,\n+   36, 36, 36, 43, 43, 43, 43, 43, 71, 44, 44, 44, 44, 44, 44, 44,\n+    7,  7,  7,  7,  7, 36, 36, 36, 36, 36, 36, 36, 36, 70, 43, 43,\n+   43, 43, 40, 21,  2, 81, 57, 20, 36, 36, 36, 43, 43, 75, 43, 43,\n+   43, 43, 75, 43, 75, 43, 43, 44,  2,  2,  2,  2,  2,  2,  2, 64,\n+   36, 36, 36, 36, 70, 43, 44, 64, 36, 36, 36, 36, 36, 61, 44, 44,\n+   36, 36, 36, 36, 82, 36, 36, 61, 65, 44, 44, 44, 43, 43, 43, 43,\n+   36, 36, 36, 36, 83, 43, 43, 43, 43, 84, 43, 43, 43, 43, 43, 43,\n+   43, 85, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 85, 71, 86,\n+   87, 43, 43, 43, 85, 86, 87, 86, 70, 43, 43, 43, 36, 36, 36, 36,\n+   36, 43,  2,  7,  7,  7,  7,  7, 88, 36, 36, 36, 36, 36, 36, 36,\n+   70, 86, 62, 36, 36, 36, 61, 62, 61, 62, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 61, 36, 36, 36, 61, 61, 44, 36, 36, 44, 71, 86,\n+   87, 43, 80, 89, 90, 89, 87, 61, 44, 44, 44, 89, 44, 44, 36, 62,\n+   36, 43, 44,  7,  7,  7,  7,  7, 36, 20, 27, 27, 27, 56, 63, 80,\n+   57, 85, 62, 36, 36, 61, 44, 62, 61, 36, 62, 61, 36, 44, 80, 86,\n+   87, 80, 44, 57, 80, 57, 43, 44, 57, 44, 44, 44, 62, 36, 61, 61,\n+   44, 44, 44,  7,  7,  7,  7,  7, 43, 36, 70, 64, 44, 44, 44, 44,\n+   57, 85, 62, 36, 36, 36, 36, 62, 36, 62, 36, 36, 36, 36, 36, 36,\n+   61, 36, 62, 36, 36, 44, 71, 86, 87, 43, 43, 57, 85, 89, 87, 44,\n+   61, 44, 44, 44, 44, 44, 44, 44, 66, 44, 44, 44, 62, 43, 43, 43,\n+   57, 86, 62, 36, 36, 36, 61, 62, 61, 36, 62, 36, 36, 44, 71, 87,\n+   87, 43, 80, 89, 90, 89, 87, 44, 44, 44, 57, 85, 44, 44, 36, 62,\n+   78, 27, 27, 27, 44, 44, 44, 44, 44, 71, 62, 36, 36, 61, 44, 36,\n+   61, 36, 36, 44, 62, 61, 61, 36, 44, 62, 61, 44, 36, 61, 44, 36,\n+   36, 36, 36, 36, 36, 44, 44, 86, 85, 90, 44, 86, 90, 86, 87, 44,\n+   61, 44, 44, 89, 44, 44, 44, 44, 27, 91, 67, 67, 56, 92, 44, 44,\n+   85, 86, 71, 36, 36, 36, 61, 36, 61, 36, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 36, 44, 71, 43, 85, 86, 90, 43, 80, 43, 43, 44,\n+   44, 44, 57, 80, 36, 61, 62, 44, 44, 44, 44, 93, 27, 27, 27, 91,\n+   70, 86, 72, 36, 36, 36, 61, 36, 36, 36, 62, 36, 36, 44, 71, 87,\n+   86, 86, 90, 85, 90, 86, 43, 44, 44, 44, 89, 90, 44, 44, 62, 61,\n+   62, 94, 44, 44, 44, 44, 44, 44, 43, 86, 36, 36, 36, 36, 61, 36,\n+   36, 36, 36, 36, 36, 70, 71, 86, 87, 43, 80, 86, 90, 86, 87, 77,\n+   44, 44, 36, 94, 27, 27, 27, 95, 27, 27, 27, 27, 91, 36, 36, 36,\n+   57, 86, 62, 36, 36, 36, 36, 36, 36, 36, 36, 61, 44, 36, 36, 36,\n+   36, 62, 36, 36, 36, 36, 62, 44, 36, 36, 36, 61, 44, 80, 44, 89,\n+   86, 43, 80, 80, 86, 86, 86, 86, 44, 86, 64, 44, 44, 44, 44, 44,\n+   62, 36, 36, 36, 36, 36, 36, 36, 70, 36, 43, 43, 43, 80, 44, 96,\n+   36, 36, 36, 75, 43, 43, 43, 60,  7,  7,  7,  7,  7,  2, 44, 44,\n+   44, 44, 44, 44, 44, 44, 44, 44, 62, 61, 61, 36, 36, 61, 36, 36,\n+   36, 36, 62, 62, 36, 36, 36, 36, 70, 36, 43, 43, 43, 43, 71, 44,\n+   36, 36, 61, 81, 43, 43, 43, 80,  7,  7,  7,  7,  7, 44, 36, 36,\n+   77, 67,  2,  2,  2,  2,  2,  2,  2, 97, 97, 67, 43, 67, 67, 67,\n+    7,  7,  7,  7,  7, 27, 27, 27, 27, 27, 50, 50, 50,  4,  4, 86,\n+   36, 36, 36, 36, 62, 36, 36, 36, 36, 36, 36, 36, 36, 36, 61, 44,\n+   57, 43, 43, 43, 43, 43, 43, 85, 43, 43, 60, 43, 36, 36, 70, 43,\n+   43, 43, 43, 43, 57, 43, 43, 43, 43, 43, 43, 43, 43, 43, 80, 67,\n+   67, 67, 67, 76, 67, 67, 92, 67,  2,  2, 97, 67, 21, 64, 44, 44,\n+   36, 36, 36, 36, 36, 94, 87, 43, 85, 43, 43, 43, 87, 85, 87, 71,\n+    7,  7,  7,  7,  7,  2,  2,  2, 36, 36, 36, 86, 43, 36, 36, 43,\n+   71, 86, 98, 94, 86, 86, 86, 36, 70, 43, 71, 36, 36, 36, 36, 36,\n+   36, 85, 87, 85, 86, 86, 87, 94,  7,  7,  7,  7,  7, 86, 87, 67,\n+   11, 11, 11, 48, 44, 44, 48, 44, 16, 16, 16, 16, 16, 53, 45, 16,\n+   36, 36, 36, 36, 61, 36, 36, 44, 36, 36, 36, 61, 61, 36, 36, 44,\n+   61, 36, 36, 44, 36, 36, 36, 61, 61, 36, 36, 44, 36, 36, 36, 36,\n+   36, 36, 36, 61, 36, 36, 36, 36, 36, 36, 36, 36, 36, 61, 57, 43,\n+    2,  2,  2,  2, 99, 27, 27, 27, 27, 27, 27, 27, 27, 27,100, 44,\n+   67, 67, 67, 67, 67, 44, 44, 44, 11, 11, 11, 44, 16, 16, 16, 44,\n+  101, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 77, 72,\n+  102, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,103,104, 44,\n+   36, 36, 36, 36, 36, 63,  2,105,106, 36, 36, 36, 61, 44, 44, 44,\n+   36, 43, 85, 44, 44, 44, 44, 62, 36, 43,107, 64, 44, 44, 44, 44,\n+   36, 43, 44, 44, 44, 44, 44, 44, 36, 36, 36, 36, 36, 36, 61, 36,\n+   61, 43, 44, 44, 44, 44, 44, 44, 36, 36, 43, 87, 43, 43, 43, 86,\n+   86, 86, 86, 85, 87, 43, 43, 43, 43, 43,  2, 88,  2, 66, 70, 44,\n+    7,  7,  7,  7,  7, 44, 44, 44, 27, 27, 27, 27, 27, 44, 44, 44,\n+    2,  2,  2,108,  2, 59, 43, 84, 36, 83, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 61, 44, 44, 44, 36, 36, 70, 71, 36, 36, 36, 36,\n+   36, 36, 36, 36, 70, 61, 44, 44, 36, 36, 36, 44, 44, 44, 44, 44,\n+   36, 36, 36, 36, 36, 36, 36, 61, 43, 85, 86, 87, 85, 86, 44, 44,\n+   86, 85, 86, 86, 87, 43, 44, 44, 92, 44,  2,  7,  7,  7,  7,  7,\n+   36, 36, 36, 36, 36, 36, 36, 44, 36, 36, 61, 44, 44, 44, 44, 44,\n+   36, 36, 36, 36, 36, 36, 44, 44, 36, 36, 36, 36, 36, 44, 44, 44,\n+    7,  7,  7,  7,  7,100, 44, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n+   36, 36, 36, 70, 85, 87, 44,  2, 36, 36, 94, 85, 43, 43, 43, 80,\n+   85, 85, 87, 43, 43, 43, 85, 86, 86, 87, 43, 43, 43, 43, 80, 57,\n+    2,  2,  2, 88,  2,  2,  2, 44, 43, 43, 43, 43, 43, 43, 43,109,\n+   43, 43, 43, 43, 43, 43, 43, 80, 43, 43, 98, 36, 36, 36, 36, 36,\n+   36, 36, 85, 43, 43, 85, 85, 86, 86, 85, 98, 36, 36, 36, 61, 44,\n+   97, 67, 67, 67, 67, 50, 43, 43, 43, 43, 67, 67, 67, 67, 21, 64,\n+   43, 98, 36, 36, 36, 36, 36, 36, 94, 43, 43, 86, 43, 87, 43, 36,\n+   36, 36, 36, 85, 43, 86, 87, 87, 43, 86, 44, 44, 44, 44,  2,  2,\n+   36, 36, 86, 86, 86, 86, 43, 43, 43, 43, 86, 43, 44, 93,  2,  2,\n+    7,  7,  7,  7,  7, 44, 62, 36, 36, 36, 36, 36, 40, 40, 40,  2,\n+   16, 16, 16, 16,110, 44, 44, 44, 11, 11, 11, 11, 11, 47, 48, 11,\n+    2,  2,  2,  2, 44, 44, 44, 44, 43, 60, 43, 43, 43, 43, 43, 43,\n+   85, 43, 43, 43, 71, 36, 70, 36, 36, 36, 71, 94, 43, 61, 44, 44,\n+   16, 16, 16, 16, 16, 16, 40, 40, 40, 40, 40, 40, 40, 45, 16, 16,\n+   16, 16, 16, 16, 45, 16, 16, 16, 16, 16, 16, 16, 16,111, 40, 40,\n+   32, 32, 32, 16, 16, 16, 16, 32, 16, 16, 16, 16, 11, 11, 11, 11,\n+   16, 16, 16, 44, 11, 11, 11, 44, 16, 16, 16, 16, 48, 48, 48, 48,\n+   16, 16, 16, 16, 16, 16, 16, 44, 16, 16, 16, 16,112,112,112,112,\n+   16, 16,110, 16, 11, 11,113,114, 41, 16,110, 16, 11, 11,113, 41,\n+   16, 16, 44, 16, 11, 11,115, 41, 16, 16, 16, 16, 11, 11,116, 41,\n+   44, 16,110, 16, 11, 11,113,117,118,118,118,118,118,119, 65, 65,\n+  120,120,120,  2,121,122,121,122,  2,  2,  2,  2,123, 65, 65,124,\n+    2,  2,  2,  2,125,126,  2,127,128,  2,129,130,  2,  2,  2,  2,\n+    2,  9,128,  2,  2,  2,  2,131, 65, 65,132, 65, 65, 65, 65, 65,\n+  133, 44, 27, 27, 27,  8,129,134, 27, 27, 27, 27, 27,  8,129,104,\n+   40, 40, 40, 40, 40, 40, 81, 44, 20, 20, 20, 20, 20, 20, 20, 20,\n+  135, 44, 44, 44, 44, 44, 44, 44, 43, 43, 43, 43, 43, 43,136, 51,\n+  109, 51,109, 43, 43, 43, 43, 43, 80, 44, 44, 44, 44, 44, 44, 44,\n+   67,137, 67,138, 67, 34, 11, 16, 11, 32,138, 67, 49, 11, 11, 67,\n+   67, 67,137,137,137, 11, 11,139, 11, 11, 35, 36, 39, 67, 16, 11,\n+    8,  8, 49, 16, 16, 26, 67,140, 27, 27, 27, 27, 27, 27, 27, 27,\n+  105,105,105,105,105,105,105,105,105,141,142,105,143, 67, 44, 44,\n+    8,  8,144, 67, 67,  8, 67, 67,144, 26, 67,144, 67, 67, 67,144,\n+   67, 67, 67, 67, 67, 67, 67,  8, 67,144,144, 67, 67, 67, 67, 67,\n+   67, 67,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n+   67, 67, 67, 67,  4,  4, 67, 67,  8, 67, 67, 67,145,146, 67, 67,\n+   67, 67, 67, 67, 67, 67,144, 67, 67, 67, 67, 67, 67, 26,  8,  8,\n+    8,  8, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67,  8,  8,\n+    8, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 92, 44, 44, 44, 44,\n+   67, 67, 67, 67, 67, 92, 44, 44, 27, 27, 27, 27, 27, 27, 67, 67,\n+   67, 67, 67, 67, 67, 27, 27, 27, 67, 67, 67, 26, 67, 67, 67, 67,\n+   26, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67,  8,  8,  8,  8,\n+   67, 67, 67, 67, 67, 67, 67, 26, 67, 67, 67, 67,  4,  4,  4,  4,\n+    4,  4,  4, 27, 27, 27, 27, 27, 27, 27, 67, 67, 67, 67, 67, 67,\n+    8,  8,129,147,  8,  8,  8,  8,  8,  8,  8,  4,  4,  4,  4,  4,\n+    8,129,148,148,148,148,148,148,148,148,148,148,147,  8,  8,  8,\n+    8,  8,  8,  8,  4,  4,  8,  8,  8,  8,  8,  8,  8,  8,  4,  8,\n+    8,  8,144, 26,  8,  8,144, 67, 67, 67, 44, 67, 67, 67, 67, 67,\n+   67, 67, 67, 55, 67, 67, 67, 67, 32, 11, 32, 34, 34, 34, 34, 11,\n+   32, 32, 34, 16, 16, 16, 40, 11, 32, 32,140, 67, 67,138, 34,149,\n+   43, 32, 44, 44, 93,  2, 99,  2, 16, 16, 16,150, 44, 44,150, 44,\n+   36, 36, 36, 36, 44, 44, 44, 52, 64, 44, 44, 44, 44, 44, 44, 57,\n+   36, 36, 36, 61, 44, 44, 44, 44, 36, 36, 36, 61, 36, 36, 36, 61,\n+    2,121,121,  2,125,126,121,  2,  2,  2,  2,  6,  2,108,121,  2,\n+  121,  4,  4,  4,  4,  2,  2, 88,  2,  2,  2,  2,  2,120,  2,  2,\n+  108,151,  2,  2,  2,  2,  2,  2, 67,  2,152,148,148,148,153, 44,\n+   67, 67, 67, 67, 67, 55, 67, 67, 67, 67, 44, 44, 44, 44, 44, 44,\n+   67, 67, 67, 44, 44, 44, 44, 44, 67, 67, 67, 67, 67, 67, 44, 44,\n+    1,  2,154,155,  4,  4,  4,  4,  4, 67,  4,  4,  4,  4,156,157,\n+  158,105,105,105,105, 43, 43, 86,159, 40, 40, 67,105,160, 63, 67,\n+   36, 36, 36, 61, 57,161,162, 69, 36, 36, 36, 36, 36, 63, 40, 69,\n+   44, 44, 62, 36, 36, 36, 36, 36, 67, 27, 27, 67, 67, 67, 67, 67,\n+   67, 67, 67, 67, 67, 67, 67, 92, 27, 27, 27, 27, 27, 67, 67, 67,\n+   67, 67, 67, 67, 27, 27, 27, 27,163, 27, 27, 27, 27, 27, 27, 27,\n+   36, 36, 83, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,164,  2,\n+    7,  7,  7,  7,  7, 36, 44, 44, 32, 32, 32, 32, 32, 32, 32, 70,\n+   51,165, 43, 43, 43, 43, 43, 88, 32, 32, 32, 32, 32, 32, 40, 43,\n+   36, 36, 36,105,105,105,105,105, 43,  2,  2,  2, 44, 44, 44, 44,\n+   41, 41, 41,162, 40, 40, 40, 40, 41, 32, 32, 32, 32, 32, 32, 32,\n+   16, 32, 32, 32, 32, 32, 32, 32, 45, 16, 16, 16, 34, 34, 34, 32,\n+   32, 32, 32, 32, 42,166, 34, 35, 32, 32, 16, 32, 32, 32, 32, 32,\n+   32, 32, 32, 32, 32, 11, 11, 32, 11, 11, 32, 32, 32, 32, 32, 32,\n+   32, 32, 11, 11, 34,110, 44, 44, 32,150,150, 32, 32, 44, 44, 44,\n+   44, 40,167, 35, 40, 35, 36, 36, 36, 71, 36, 71, 36, 70, 36, 36,\n+   36, 94, 87, 85, 67, 67, 80, 44, 27, 27, 27, 67,168, 44, 44, 44,\n+   36, 36,  2,  2, 44, 44, 44, 44, 86, 36, 36, 36, 36, 36, 36, 36,\n+   36, 36, 86, 86, 86, 86, 86, 86, 86, 86, 43, 44, 44, 44, 44,  2,\n+   43, 36, 36, 36,  2, 72, 72, 70, 36, 36, 36, 43, 43, 43, 43,  2,\n+   36, 36, 36, 70, 43, 43, 43, 43, 43, 86, 44, 44, 44, 44, 44, 93,\n+   36, 70, 86, 43, 43, 86, 43, 86,107,  2,  2,  2,  2,  2,  2, 52,\n+    7,  7,  7,  7,  7, 44, 44,  2, 36, 36, 70, 69, 36, 36, 36, 36,\n+    7,  7,  7,  7,  7, 36, 36, 61, 36, 36, 36, 36, 70, 43, 43, 85,\n+   87, 85, 87, 80, 44, 44, 44, 44, 36, 70, 36, 36, 36, 36, 85, 44,\n+    7,  7,  7,  7,  7, 44,  2,  2, 69, 36, 36, 77, 67, 94, 85, 36,\n+   71, 43, 71, 70, 71, 36, 36, 43, 70, 61, 44, 44, 44, 44, 44, 44,\n+   44, 44, 44, 44, 44, 62, 83,  2, 36, 36, 36, 36, 36, 94, 43, 86,\n+    2, 83,169, 80, 44, 44, 44, 44, 62, 36, 36, 61, 62, 36, 36, 61,\n+   62, 36, 36, 61, 44, 44, 44, 44, 16, 16, 16, 16, 16,114, 40, 40,\n+   16, 16, 16, 16,111, 41, 44, 44, 36, 94, 87, 86, 85,107, 87, 44,\n+   36, 36, 44, 44, 44, 44, 44, 44, 36, 36, 36, 61, 44, 62, 36, 36,\n+  170,170,170,170,170,170,170,170,171,171,171,171,171,171,171,171,\n+   16, 16, 16,110, 44, 44, 44, 44, 44,150, 16, 16, 44, 44, 62, 71,\n+   36, 36, 36, 36,172, 36, 36, 36, 36, 36, 36, 61, 36, 36, 61, 61,\n+   36, 62, 61, 36, 36, 36, 36, 36, 36, 41, 41, 41, 41, 41, 41, 41,\n+   41,117, 44, 44, 44, 44, 44, 44, 44, 62, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 36, 36, 36,148, 44, 36, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 44, 44, 44, 55, 36, 36, 36, 36, 36, 36,168, 67,\n+    2,  2,  2,152,130, 44, 44, 44,  6,173,174,148,148,148,148,148,\n+  148,148,130,152,130,  2,127,175,  2, 64,  2,  2,156,148,148,130,\n+    2,176,  8,177, 66,  2, 44, 44, 36, 36, 61, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 36, 36, 61, 79, 93,  2,  3,  2,  4,  5,  6,  2,\n+   16, 16, 16, 16, 16, 17, 18,129,130,  4,  2, 36, 36, 36, 36, 36,\n+   69, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 40,\n+   44, 36, 36, 36, 44, 36, 36, 36, 44, 36, 36, 36, 44, 36, 61, 44,\n+   20,178, 56,135, 26,  8,144, 92, 44, 44, 44, 44, 79, 65, 67, 44,\n+   36, 36, 36, 36, 36, 36, 62, 36, 36, 36, 36, 36, 36, 61, 36, 62,\n+    2, 64, 44,179, 27, 27, 27, 27, 27, 27, 44, 55, 67, 67, 67, 67,\n+  105,105,143, 27, 91, 67, 67, 67, 67, 67, 67, 67, 67, 27, 67, 92,\n+   67, 67, 67, 67, 67, 67, 92, 44, 92, 44, 44, 44, 44, 44, 44, 44,\n+   67, 67, 67, 67, 67, 67, 50, 44,180, 27, 27, 27, 27, 27, 27, 27,\n+   27, 27, 27, 27, 27, 27, 44, 44, 27, 27, 44, 44, 44, 44, 62, 36,\n+  155, 36, 36, 36, 36,181, 44, 44, 36, 36, 36, 43, 43, 80, 44, 44,\n+   36, 36, 36, 36, 36, 36, 36, 93, 36, 36, 44, 44, 36, 36, 36, 36,\n+  182,105,105, 44, 44, 44, 44, 44, 11, 11, 11, 11, 16, 16, 16, 16,\n+   11, 11, 44, 44, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 44, 44,\n+   36, 36, 36, 36, 44, 44, 44, 44, 36, 36, 44, 44, 44, 44, 44, 93,\n+   11, 11, 11, 11, 11, 47, 11, 11, 11, 47, 11,150, 16, 16, 16, 16,\n+   16,150, 16, 16, 16, 16, 16, 16, 16,150, 16, 16, 16,150,110, 44,\n+   40, 40, 40, 52, 40, 40, 40, 40, 81, 40, 40, 40, 40, 81, 44, 44,\n+   36, 36, 36, 44, 61, 36, 36, 36, 36, 36, 36, 62, 61, 44, 61, 62,\n+   36, 36, 36, 93, 27, 27, 27, 27, 36, 36, 36, 77,163, 27, 27, 27,\n+   44, 44, 44,179, 27, 27, 27, 27, 36, 61, 36, 44, 44,179, 27, 27,\n+   36, 36, 36, 27, 27, 27, 44, 93, 36, 36, 36, 36, 36, 44, 44, 93,\n+   36, 36, 36, 36, 44, 44, 27, 36, 44, 27, 27, 27, 27, 27, 27, 27,\n+   70, 43, 57, 80, 44, 44, 43, 43, 36, 36, 62, 36, 62, 36, 36, 36,\n+   36, 36, 36, 44, 43, 80, 44, 57, 27, 27, 27, 27,100, 44, 44, 44,\n+    2,  2,  2,  2, 64, 44, 44, 44, 36, 36, 36, 36, 36, 36,183, 30,\n+   36, 36, 36, 36, 36, 36,183, 27, 36, 36, 36, 36, 78, 36, 36, 36,\n+   36, 36, 70, 80, 44,179, 27, 27,  2,  2,  2, 64, 44, 44, 44, 44,\n+   36, 36, 36, 44, 93,  2,  2,  2, 36, 36, 36, 44, 27, 27, 27, 27,\n+   36, 61, 44, 44, 27, 27, 27, 27, 36, 44, 44, 44, 93,  2, 64, 44,\n+   44, 44, 44, 44,179, 27, 27, 27, 11, 47, 44, 44, 44, 44, 44, 44,\n+   16,110, 44, 44, 44, 27, 27, 27, 36, 36, 43, 43, 44, 44, 44, 44,\n+   27, 27, 27, 27, 27, 27, 27,100, 36, 36, 36, 36, 36, 57,184, 44,\n+   36, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 57, 43,\n+   27, 27, 27, 95, 44, 44, 44, 44,180, 27, 30,  2,  2, 44, 44, 44,\n+   36, 43, 43,  2,  2, 44, 44, 44, 36, 36,183, 27, 27, 27, 44, 44,\n+   87, 98, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 43, 43, 43, 43,\n+   43, 43, 43, 60,  2,  2,  2, 44, 27, 27, 27,  7,  7,  7,  7,  7,\n+   71, 70, 71, 44, 44, 44, 44, 57, 86, 87, 43, 85, 87, 60,185,  2,\n+    2, 80, 44, 44, 44, 44, 79, 44, 43, 71, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 70, 43, 43, 87, 43, 43, 43, 80,  7,  7,  7,  7,  7,\n+    2,  2, 94, 98, 44, 44, 44, 44, 36, 70,  2, 61, 44, 44, 44, 44,\n+   36, 94, 86, 43, 43, 43, 43, 85, 98, 36, 63,  2, 59, 43, 60, 87,\n+    7,  7,  7,  7,  7, 63, 63,  2,179, 27, 27, 27, 27, 27, 27, 27,\n+   27, 27,100, 44, 44, 44, 44, 44, 36, 36, 36, 36, 36, 36, 86, 87,\n+   43, 86, 85, 43,  2,  2,  2, 71, 70, 44, 44, 44, 44, 44, 44, 44,\n+   36, 36, 36, 61, 61, 36, 36, 62, 36, 36, 36, 36, 36, 36, 36, 62,\n+   36, 36, 36, 36, 63, 44, 44, 44, 36, 36, 36, 36, 36, 36, 36, 70,\n+   86, 87, 43, 43, 43, 80, 44, 44, 43, 86, 62, 36, 36, 36, 61, 62,\n+   61, 36, 62, 36, 36, 57, 71, 86, 85, 86, 90, 89, 90, 89, 86, 44,\n+   61, 44, 44, 89, 44, 44, 62, 36, 36, 86, 44, 43, 43, 43, 80, 44,\n+   43, 43, 80, 44, 44, 44, 44, 44, 36, 36, 94, 86, 43, 43, 43, 43,\n+   86, 43, 85, 71, 36, 63,  2,  2,  7,  7,  7,  7,  7,  2, 93, 71,\n+   86, 87, 43, 43, 85, 85, 86, 87, 85, 43, 36, 72, 44, 44, 44, 44,\n+   36, 36, 36, 36, 36, 36, 36, 94, 86, 43, 43, 44, 86, 86, 43, 87,\n+   60,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 36, 36, 43, 44,\n+   86, 87, 43, 43, 43, 85, 87, 87, 60,  2, 61, 44, 44, 44, 44, 44,\n+    2,  2,  2,  2,  2,  2, 64, 44, 36, 36, 36, 36, 36, 70, 87, 86,\n+   43, 43, 43, 87, 63, 44, 44, 44, 86, 43, 43, 87, 43, 43, 44, 44,\n+    7,  7,  7,  7,  7, 27,  2, 97, 43, 43, 43, 43, 87, 60, 44, 44,\n+   27,100, 44, 44, 44, 44, 44, 62, 36, 36, 36, 61, 62, 44, 36, 36,\n+   36, 36, 62, 61, 36, 36, 36, 36, 86, 86, 86, 89, 90, 57, 85, 71,\n+   98, 87,  2, 64, 44, 44, 44, 44, 36, 36, 36, 36, 44, 36, 36, 36,\n+   94, 86, 43, 43, 44, 43, 86, 86, 71, 72, 90, 44, 44, 44, 44, 44,\n+   70, 43, 43, 43, 43, 71, 36, 36, 36, 70, 43, 43, 85, 70, 43, 60,\n+    2,  2,  2, 59, 44, 44, 44, 44, 70, 43, 43, 85, 87, 43, 36, 36,\n+   36, 36, 36, 36, 36, 43, 43, 43, 43, 43, 43, 85, 43,  2, 72,  2,\n+    2, 64, 44, 44, 44, 44, 44, 44,  2,  2,  2,  2,  2, 44, 44, 44,\n+   43, 43, 43, 80, 43, 43, 43, 87, 63,  2,  2, 44, 44, 44, 44, 44,\n+    2, 36, 36, 36, 36, 36, 36, 36, 44, 43, 43, 43, 43, 43, 43, 43,\n+   43, 43, 43, 43, 89, 43, 43, 43, 85, 43, 87, 80, 44, 44, 44, 44,\n+   36, 36, 36, 61, 36, 62, 36, 36, 70, 43, 43, 80, 44, 80, 43, 57,\n+   43, 43, 43, 70, 44, 44, 44, 44, 36, 36, 36, 62, 61, 36, 36, 36,\n+   36, 36, 36, 36, 36, 86, 86, 90, 43, 89, 87, 87, 61, 44, 44, 44,\n+   36, 70, 85,107, 64, 44, 44, 44, 43, 94, 36, 36, 36, 36, 36, 36,\n+   36, 36, 86, 43, 43, 80, 44, 86, 85, 60,  2,  2,  2,  2,  2,  2,\n+   27, 27, 91, 67, 67, 67, 56, 20,168, 67, 67, 67, 67, 67, 67, 67,\n+   67, 44, 44, 44, 44, 44, 44, 93,105,105,105,105,105,105,105,181,\n+    2,  2, 64, 44, 44, 44, 44, 44, 63, 64, 44, 44, 44, 44, 44, 44,\n+   65, 65, 65, 65, 65, 65, 65, 65, 71, 36, 36, 70, 43, 43, 43, 43,\n+   43, 43, 43, 44, 44, 44, 44, 44, 43, 43, 60, 44, 44, 44, 44, 44,\n+   43, 43, 43, 60,  2,  2, 67, 67, 40, 40, 97, 44, 44, 44, 44, 44,\n+    7,  7,  7,  7,  7,179, 27, 27, 27, 62, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 44, 44, 62, 36, 27, 27, 27, 30,  2, 64, 44, 44,\n+   36, 36, 36, 36, 36, 61, 44, 57, 94, 86, 86, 86, 86, 86, 86, 86,\n+   86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 44, 44, 44, 57,\n+   43, 74, 40, 40, 40, 40, 40, 40, 40, 88, 80, 44, 44, 44, 44, 44,\n+   86, 44, 44, 44, 44, 44, 44, 44, 40, 40, 52, 40, 40, 40, 52, 81,\n+   36, 61, 44, 44, 44, 44, 44, 44, 44, 61, 44, 44, 44, 44, 44, 44,\n+   36, 61, 62, 44, 44, 44, 44, 44, 44, 44, 36, 36, 44, 44, 44, 44,\n+   36, 36, 36, 36, 36, 44, 50, 60, 65, 65, 44, 44, 44, 44, 44, 44,\n+   43, 43, 43, 43, 43, 43, 43, 44, 43, 43, 43, 80, 44, 44, 44, 44,\n+   67, 67, 67, 92, 55, 67, 67, 67, 67, 67,186, 87, 43, 67,186, 86,\n+   86,187, 65, 65, 65, 84, 43, 43, 43, 76, 50, 43, 43, 43, 67, 67,\n+   67, 67, 67, 67, 67, 43, 43, 67, 67, 43, 76, 44, 44, 44, 44, 44,\n+   27, 27, 44, 44, 44, 44, 44, 44, 11, 11, 11, 11, 11, 16, 16, 16,\n+   16, 16, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 16,\n+   16, 16,110, 16, 16, 16, 16, 16, 11, 16, 16, 16, 16, 16, 16, 16,\n+   16, 16, 16, 16, 16, 16, 47, 11, 44, 47, 48, 47, 48, 11, 47, 11,\n+   11, 11, 11, 16, 16,150,150, 16, 16, 16,150, 16, 16, 16, 16, 16,\n+   16, 16, 11, 48, 11, 47, 48, 11, 11, 11, 47, 11, 11, 11, 47, 16,\n+   16, 16, 16, 16, 11, 48, 11, 47, 11, 11, 47, 47, 44, 11, 11, 11,\n+   47, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 11, 11,\n+   11, 11, 11, 16, 16, 16, 16, 16, 16, 16, 16, 44, 11, 11, 11, 11,\n+   31, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 33, 16, 16,\n+   16, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 31, 16, 16,\n+   16, 16, 33, 16, 16, 16, 11, 11, 11, 11, 31, 16, 16, 16, 16, 16,\n+   16, 16, 16, 16, 16, 16, 16, 33, 16, 16, 16, 11, 11, 11, 11, 11,\n+   11, 11, 11, 11, 11, 11, 11, 31, 16, 16, 16, 16, 33, 16, 16, 16,\n+   11, 11, 11, 11, 31, 16, 16, 16, 16, 33, 16, 16, 16, 32, 44,  7,\n+    7,  7,  7,  7,  7,  7,  7,  7, 43, 43, 43, 76, 67, 50, 43, 43,\n+   43, 43, 43, 43, 43, 43, 76, 67, 67, 67, 50, 67, 67, 67, 67, 67,\n+   67, 67, 76, 21,  2,  2, 44, 44, 44, 44, 44, 44, 44, 57, 43, 43,\n+   16, 16, 16, 16, 16, 39, 16, 16, 16, 16, 16, 16, 16, 16, 16,110,\n+   44, 44,150, 16, 16,110, 44, 44, 43, 43, 43, 80, 43, 43, 43, 43,\n+   43, 43, 43, 43, 80, 57, 43, 43, 43, 57, 80, 43, 43, 80, 44, 44,\n+   40, 40, 40, 40, 40, 40, 40, 44, 44, 44, 44, 44, 44, 44, 44, 57,\n+   43, 43, 43, 74, 40, 40, 40, 44,  7,  7,  7,  7,  7, 44, 44, 77,\n+   36, 36, 36, 36, 36, 36, 36, 80, 36, 36, 36, 36, 36, 36, 43, 43,\n+    7,  7,  7,  7,  7, 44, 44, 96, 36, 36, 36, 36, 36, 83, 43, 43,\n+   36, 36, 36, 61, 36, 36, 62, 61, 36, 36, 61,179, 27, 27, 27, 27,\n+   16, 16, 43, 43, 43, 74, 44, 44, 27, 27, 27, 27, 27, 27,163, 27,\n+  188, 27,100, 44, 44, 44, 44, 44, 27, 27, 27, 27, 27, 27, 27,163,\n+   27, 27, 27, 27, 27, 27, 27, 44, 36, 36, 62, 36, 36, 36, 36, 36,\n+   62, 61, 61, 62, 62, 36, 36, 36, 36, 61, 36, 36, 62, 62, 44, 44,\n+   44, 61, 44, 62, 62, 62, 62, 36, 62, 61, 61, 62, 62, 62, 62, 62,\n+   62, 61, 61, 62, 36, 61, 36, 36, 36, 61, 36, 36, 62, 36, 61, 61,\n+   36, 36, 36, 36, 36, 62, 36, 36, 62, 36, 62, 36, 36, 62, 36, 36,\n+    8, 44, 44, 44, 44, 44, 44, 44, 55, 67, 67, 67, 67, 67, 67, 67,\n+   27, 27, 27, 27, 27, 27, 91, 67, 67, 67, 67, 67, 67, 67, 67, 44,\n+   44, 44, 44, 67, 67, 67, 67, 67, 67, 92, 44, 44, 44, 44, 44, 44,\n+   67, 67, 67, 67, 92, 44, 44, 44, 67, 44, 44, 44, 44, 44, 44, 44,\n+   67, 67, 67, 67, 67, 25, 41, 41, 67, 67, 67, 67, 44, 44, 67, 67,\n+   67, 67, 67, 92, 44, 55, 67, 67, 67, 67, 67, 67, 44, 44, 44, 44,\n+   67, 67, 67, 67, 67, 67, 67, 55, 67, 67, 67, 44, 44, 44, 44, 67,\n+   67, 92, 67, 67, 67, 67, 67, 67, 79, 44, 44, 44, 44, 44, 44, 44,\n+  171,171,171,171,171,171,171, 44,171,171,171,171,171,171,171,  0,\n+    0,  0, 29, 21, 21, 21, 23, 21, 22, 18, 21, 25, 21, 17, 13, 13,\n+   25, 25, 25, 21, 21,  9,  9,  9,  9, 22, 21, 18, 24, 16, 24,  5,\n+    5,  5,  5, 22, 25, 18, 25,  0, 23, 23, 26, 21, 24, 26,  7, 20,\n+   25,  1, 26, 24, 26, 25, 15, 15, 24, 15,  7, 19, 15, 21,  9, 25,\n+    9,  5,  5, 25,  5,  9,  5,  7,  7,  7,  9,  8,  8,  5,  7,  5,\n+    6,  6, 24, 24,  6, 24, 12, 12,  2,  2,  6,  5,  9, 21,  9,  2,\n+    2,  9, 25,  9, 26, 12, 11, 11,  2,  6,  5, 21, 17,  2,  2, 26,\n+   26, 23,  2, 12, 17, 12, 21, 12, 12, 21,  7,  2,  2,  7,  7, 21,\n+   21,  2,  1,  1, 21, 23, 26, 26,  1, 21,  6,  7,  7, 12, 12,  7,\n+   21,  7, 12,  1, 12,  6,  6, 12, 12, 26,  7, 26, 26,  7,  2,  1,\n+   12,  2,  6,  2, 24,  7,  7,  6,  1, 12, 12, 10, 10, 10, 10, 12,\n+   21,  6,  2, 10, 10,  2, 15, 26, 26,  2,  2, 21,  7, 10, 15,  7,\n+    2, 23, 21, 26, 10,  7, 21, 15, 15,  2, 17,  7, 29,  7,  7, 22,\n+   18,  2, 14, 14, 14,  7, 10, 21, 17, 21, 11, 12,  5,  2,  5,  6,\n+    8,  8,  8, 24,  5, 24,  2, 24,  9, 24, 24,  2, 29, 29, 29,  1,\n+   17, 17, 20, 19, 22, 20, 27, 28,  1, 29, 21, 20, 19, 21, 21, 16,\n+   16, 21, 25, 22, 18, 21, 21, 29,  1,  2, 15,  6, 18,  6, 23,  2,\n+   12, 11,  9, 26, 26,  9, 26,  5,  5, 26, 14,  9,  5, 14, 14, 15,\n+   25, 26, 26, 22, 18, 26, 18, 25, 18, 22,  5, 12,  2,  5, 22, 21,\n+   21, 22, 18, 17, 26,  6,  7, 14, 17, 22, 18, 18, 26, 14, 17,  6,\n+   14,  6, 12, 24, 24,  6, 26, 15,  6, 21, 11, 21, 24,  9,  6,  9,\n+   23, 26,  6, 10,  4,  4,  3,  3,  7, 25, 17, 16, 16, 22, 16, 16,\n+   25, 17, 25,  2, 25, 24,  2, 15, 12, 15, 14,  2, 21, 14,  7, 15,\n+   12, 17, 21,  1, 26, 10, 10,  1, 23, 15,  0,  1,  2,  3,  4,  5,\n+    6,  7,  8,  9,  0, 10, 11, 12, 13,  0, 14,  0,  0,  0,  0,  0,\n+   15,  0, 16,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 17, 18, 19,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0, 20,  0, 21, 22, 23,  0,  0,  0, 24,\n+   25, 26, 27, 28, 29, 30, 31, 32, 33, 34,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 35,\n+    0, 36,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0, 37,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0, 38, 39,  0,  0,  0,  0,  0,  0, 40, 41, 42,  0, 43,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  0,  0,\n+    0,  0,  3,  0,  0,  0,  4,  5,  6,  7,  0,  8,  9, 10,  0, 11,\n+   12, 13, 14, 15, 16, 17, 16, 18, 16, 19, 16, 19, 16, 19,  0, 19,\n+   16, 20, 16, 19, 21, 19,  0, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+   31,  0, 32,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 33,  0,  0,\n+    0,  0,  0,  0, 34,  0,  0, 35,  0,  0, 36,  0, 37,  0,  0,  0,\n+   38, 39, 40, 41, 42, 43, 44, 45, 46,  0,  0, 47,  0,  0,  0, 48,\n+    0,  0,  0, 49,  0,  0,  0,  0,  0,  0,  0, 50,  0, 51,  0, 52,\n+   53,  0, 54,  0,  0,  0,  0,  0,  0, 55, 56, 57,  0,  0,  0,  0,\n+   58,  0,  0, 59, 60, 61, 62, 63,  0,  0, 64, 65,  0,  0,  0, 66,\n+    0,  0,  0,  0, 67,  0,  0,  0, 68,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0, 69,  0,  0,  0, 70,  0, 71,  0,  0,\n+   72,  0,  0, 73,  0,  0,  0,  0,  0,  0,  0,  0, 74,  0,  0,  0,\n+    0,  0, 75, 76,  0, 77, 78,  0,  0, 79, 80,  0, 81, 62,  0, 82,\n+   83,  0,  0, 84, 85, 86,  0,  0,  0, 87,  0, 88,  0,  0, 51, 89,\n+   51,  0, 90,  0, 91,  0,  0,  0, 80,  0,  0,  0, 92, 93,  0, 94,\n+   95, 96, 97,  0,  0,  0,  0,  0, 51,  0,  0,  0,  0, 98, 99,  0,\n+    0,  0,  0,  0,  0,100,  0,  0,  0,  0,  0,101,102,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,103,  0,  0,104,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,105,106,  0,  0,107,  0,  0,  0,  0,  0,  0,\n+  108,  0,109,  0,102,  0,  0,  0,  0,  0,110,111,  0,  0,  0,  0,\n+    0,  0,  0,112,  0,  0,  0,  0,  0,  0,  0,113,  0,114,  0,  0,\n+    0,  0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  0,  8,  0,  0,  0,\n+    0,  9, 10, 11, 12,  0,  0,  0,  0, 13,  0,  0, 14, 15,  0, 16,\n+    0, 17, 18,  0,  0, 19,  0, 20, 21,  0,  0,  0,  0,  0, 22, 23,\n+    0, 24, 25,  0,  0, 26,  0,  0,  0, 27,  0,  0, 28, 29, 30, 31,\n+    0,  0,  0, 32, 33, 34,  0,  0, 33,  0,  0, 35, 33,  0,  0,  0,\n+   33, 36,  0,  0,  0,  0,  0, 37, 38,  0,  0,  0,  0,  0,  0, 39,\n+   40,  0,  0,  0,  0,  0,  0, 41, 42,  0,  0,  0,  0, 43,  0, 44,\n+    0,  0,  0, 45, 46,  0,  0,  0, 47,  0,  0,  0,  0,  0,  0, 48,\n+   49,  0,  0,  0,  0, 50,  0,  0,  0, 51,  0, 52,  0, 53,  0,  0,\n+    0,  0, 54,  0,  0,  0,  0, 55,  0, 56,  0,  0,  0,  0, 57, 58,\n+    0,  0,  0, 59, 60,  0,  0,  0,  0,  0,  0, 61, 52,  0, 62, 63,\n+    0,  0, 64,  0,  0,  0, 65, 66,  0,  0,  0, 67,  0, 68, 69, 70,\n+   71, 72,  1, 73,  0, 74, 75, 76,  0,  0, 77, 78,  0,  0,  0, 79,\n+    0,  0,  1,  1,  0,  0, 80,  0,  0, 81,  0,  0,  0,  0, 77, 82,\n+    0, 83,  0,  0,  0,  0,  0, 78, 84,  0, 85,  0, 52,  0,  1, 78,\n+    0,  0, 86,  0,  0, 87,  0,  0,  0,  0,  0, 88, 57,  0,  0,  0,\n+    0,  0,  0, 89, 90,  0,  0, 84,  0,  0, 33,  0,  0, 91,  0,  0,\n+    0,  0, 92,  0,  0,  0,  0, 49,  0,  0, 93,  0,  0,  0,  0, 94,\n+   95,  0,  0, 96,  0,  0, 97,  0,  0,  0, 98,  0,  0,  0, 99,  0,\n+    0,  0,  0,100,101, 93,  0,  0,102,  0,  0,  0, 84,  0,  0,103,\n+    0,  0,  0,104,105,  0,  0,106,107,  0,  0,  0,  0,  0,  0,108,\n+    0,  0,109,  0,  0,  0,  0,110, 33,  0,111,112,113, 35,  0,  0,\n+  114,  0,  0,  0,115,  0,  0,  0,  0,  0,  0,116,  0,  0,117,  0,\n+    0,  0,  0,118, 88,  0,  0,  0,  0,  0, 57,  0,  0,  0,  0, 52,\n+  119,  0,  0,  0,  0,120,  0,  0,121,  0,  0,  0,  0,119,  0,  0,\n+  122,  0,  0,  0,  0,  0,  0,123,  0,  0,  0,124,  0,  0,  0,125,\n+    0,126,  0,  0,  0,  0,127,128,129,  0,130,  0,131,  0,  0,  0,\n+  132,133,134,  0, 77,  0,  0,  0,  0,  0, 35,  0,  0,  0,135,  0,\n+    0,  0,136,  0,  0,137,  0,  0,138,  0,  0,  0,  0,  0,  0,  0,\n+    1,  1,  1,  1,  1,  2,  3,  4,  5,  6,  7,  4,  4,  8,  9, 10,\n+    1, 11, 12, 13, 14, 15, 16, 17, 18,  1,  1,  1, 19,  1,  0,  0,\n+   20, 21, 22,  1, 23,  4, 21, 24, 25, 26, 27, 28, 29, 30,  0,  0,\n+    1,  1, 31,  0,  0,  0, 32, 33, 34, 35,  1, 36, 37,  0,  0,  0,\n+    0, 38,  1, 39, 14, 39, 40, 41, 42,  0,  0,  0, 43, 36, 44, 45,\n+   21, 45, 46,  0,  0,  0, 19,  1, 21,  0,  0, 47,  0, 38, 48,  1,\n+    1, 49, 49, 50,  0,  0, 51,  0,  0,  0, 52,  1,  0,  0, 38, 14,\n+    4,  1,  1,  1, 53, 21, 43, 52, 54, 21, 35,  1,  0,  0,  0, 55,\n+    0,  0,  0, 56, 57, 58,  0,  0,  0,  0,  0, 59,  0, 60,  0,  0,\n+    0,  0, 61, 62,  0,  0, 63,  0,  0,  0, 64,  0,  0,  0, 65,  0,\n+    0,  0, 66,  0,  0,  0, 67,  0,  0,  0, 68,  0,  0, 69, 70,  0,\n+   71, 72, 73, 74, 75, 76,  0,  0,  0, 77,  0,  0,  0, 78, 79,  0,\n+    0,  0,  0, 47,  0,  0,  0, 49,  0, 80,  0,  0,  0, 62,  0,  0,\n+   63,  0,  0, 81,  0,  0, 82,  0,  0,  0, 83,  0,  0, 19, 84,  0,\n+   62,  0,  0,  0,  0, 49,  1, 85,  1, 52, 15, 86, 36, 10, 21, 87,\n+    0, 55,  0,  0,  0,  0, 19, 10,  1,  0,  0,  0,  0,  0, 88,  0,\n+    0, 89,  0,  0, 88,  0,  0,  0,  0, 78,  0,  0, 87,  9, 12,  4,\n+   90,  8, 91, 47,  0, 58, 50,  0, 21,  1, 21, 92, 93,  1,  1,  1,\n+    1, 94, 95, 96, 97,  1, 98, 58, 81, 99,100,  4, 58,  0,  0,  0,\n+    0,  0,  0, 19, 50,  0,  0,  0,  0,  0,  0, 61,  0,  0,101,102,\n+    0,  0,103,  0,  0,  1,  1, 50,  0,  0,  0, 38,  0, 63,  0,  0,\n+    0,  0,  0, 62,  0,  0,104, 68, 61,  0,  0,  0, 78,  0,  0,  0,\n+  105,106, 58, 38, 81,  0,  0,  0,  0,  0,  0,107,  1, 14,  4, 12,\n+   84,  0,  0,  0,  0, 38, 87,  0,  0,  0,  0,108,  0,  0,109, 61,\n+    0,110,  0,  0,  0,  1,  0,  0,  0,  0, 19, 58,  0,  0,  0, 51,\n+    0,111, 14, 52,112, 41,  0,  0, 62,  0,  0, 61,  0,  0,113,  0,\n+   87,  0,  0,  0, 61, 62,  0,  0, 62,  0, 89,  0,  0,113,  0,  0,\n+    0,  0,114,  0,  0,  0, 78, 55,  0, 38,  1, 58,  1, 58,  0,  0,\n+   63, 89,  0,  0,115,  0,  0,  0, 55,  0,  0,  0,  0,115,  0,  0,\n+    0,  0, 61,  0,  0,  0,  0, 79,  0, 61,  0,  0,  0,  0, 56,  0,\n+   89, 80,  0,  0, 79,  0,  0,  0,  8, 91,  0,  0,  1, 87,  0,  0,\n+  116,  0,  0,  0,  0,  0,  0,117,  0,118,119,120,121,  0,104,  4,\n+  122, 49, 23,  0,  0,  0, 38, 50, 38, 58,  0,  0,  1, 87,  1,  1,\n+    1,  1, 39,  1, 48,105, 87,  0,  0,  0,  0,  1,  0,  0,  0,123,\n+    4,122,  0,  0,  0,  1,124,  0,  0,  0,  0,  0,230,230,230,230,\n+  230,232,220,220,220,220,232,216,220,220,220,220,220,202,202,220,\n+  220,220,220,202,202,220,220,220,  1,  1,  1,  1,  1,220,220,220,\n+  220,230,230,230,230,240,230,220,220,220,230,230,230,220,220,  0,\n+  230,230,230,220,220,220,220,230,232,220,220,230,233,234,234,233,\n+  234,234,233,230,  0,  0,  0,230,  0,220,230,230,230,230,220,230,\n+  230,230,222,220,230,230,220,220,230,222,228,230, 10, 11, 12, 13,\n+   14, 15, 16, 17, 18, 19, 19, 20, 21, 22,  0, 23,  0, 24, 25,  0,\n+  230,220,  0, 18, 30, 31, 32,  0,  0,  0,  0, 27, 28, 29, 30, 31,\n+   32, 33, 34,230,230,220,220,230,220,230,230,220, 35,  0,  0,  0,\n+    0,  0,230,230,230,  0,  0,230,230,  0,220,230,230,220,  0,  0,\n+    0, 36,  0,  0,230,220,230,230,220,220,230,220,220,230,220,230,\n+  220,230,230,  0,  0,220,  0,  0,230,230,  0,230,  0,230,230,230,\n+  230,230,  0,  0,  0,220,220,220,230,220,220,220,230,230,  0,220,\n+   27, 28, 29,230,  7,  0,  0,  0,  0,  9,  0,  0,  0,230,220,230,\n+  230,  0,  0,  0,  0,  0,230,  0,  0, 84, 91,  0,  0,  0,  0,  9,\n+    9,  0,  0,  0,  0,  0,  9,  0,103,103,  9,  0,107,107,107,107,\n+  118,118,  9,  0,122,122,122,122,220,220,  0,  0,  0,220,  0,220,\n+    0,216,  0,  0,  0,129,130,  0,132,  0,  0,  0,  0,  0,130,130,\n+  130,130,  0,  0,130,  0,230,230,  9,  0,230,230,  0,  0,220,  0,\n+    0,  0,  0,  7,  0,  9,  9,  0,  9,  9,  0,  0,  0,230,  0,  0,\n+    0,228,  0,  0,  0,222,230,220,220,  0,  0,  0,230,  0,  0,220,\n+  230,220,  0,220,230,230,230,  0,  0,  0,  9,  9,  0,  0,  7,  0,\n+  230,  0,  1,  1,  1,  0,  0,  0,230,234,214,220,202,230,230,230,\n+  230,230,232,228,228,220,218,230,233,220,230,220,230,230,  1,  1,\n+    1,  1,  1,230,  0,  1,  1,230,220,230,  1,  1,  0,  0,218,228,\n+  232,222,224,224,  0,  8,  8,  0,  0,  0,  0,220,230,  0,230,230,\n+  220,  0,  0,230,  0,  0, 26,  0,  0,220,  0,230,230,  1,220,  0,\n+    0,230,220,  0,  0,  0,220,220,  0,  0,230,220,  0,  9,  7,  0,\n+    0,  7,  9,  0,  0,  0,  9,  7,  6,  6,  0,  0,  0,  0,  1,  0,\n+    0,216,216,  1,  1,  1,  0,  0,  0,226,216,216,216,216,216,  0,\n+  220,220,220,  0,232,232,220,230,230,230,  7,  0, 16, 17, 17, 17,\n+   17, 17, 17, 33, 17, 17, 17, 19, 17, 17, 17, 17, 20,101, 17,113,\n+  129,169, 17, 27, 28, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,237,  0,  1,  2,  2,\n+    0,  3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  4,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  6,  7,  8,\n+    9,  0,  0,  0, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0, 20,  0,  0, 21, 22,  0,  0,  0,  0,\n+   23, 24, 25, 26,  0, 27,  0, 28, 29, 30, 31, 32,  0,  0,  0,  0,\n+    0,  0,  0, 33, 34, 35, 36,  0,  0,  0,  0,  0, 37,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0, 38, 39,  0,  0,  0,  0,  1,  2, 40, 41,\n+    0,  1,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,\n+    0,  0,  0,  2,  0,  0,  0,  0,  0,  0,  3,  4,  0,  0,  5,  0,\n+    0,  0,  6,  0,  0,  0,  0,  0,  0,  0,  7,  1,  0,  0,  0,  0,\n+    0,  0,  8,  9,  0,  0,  0,  0,  0,  0, 10,  0,  0, 10,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10,  0,  0,  0, 10,\n+    0,  0,  0,  0,  0,  0, 11, 12,  0, 13,  0, 14, 15, 16,  0,  0,\n+    0,  0,  0,  1, 17, 18,  0, 19,  7,  1,  0,  0,  0, 20, 20,  7,\n+   20, 20, 20, 20, 20, 20, 20,  8, 21,  0, 22,  0,  7, 23, 24,  0,\n+   20, 20, 25,  0,  0,  0, 26, 27,  1,  7, 20, 20, 20, 20, 20,  1,\n+   28, 29, 30, 31,  0,  0, 20,  0,  0,  0,  0,  0,  0,  0, 10,  0,\n+    0,  0,  0,  0,  0,  0, 20, 20, 20,  1,  0,  0,  8, 21, 32,  4,\n+    0, 10,  0, 33,  7, 20, 20, 20,  0,  0,  0,  0,  8, 34, 34, 35,\n+   36, 34, 37,  0, 38,  1, 20, 20,  0,  0, 39,  0,  1,  1,  0,  8,\n+   21,  1, 20,  0,  0,  0,  1,  0,  0, 40,  1,  1,  0,  0,  8, 21,\n+    0,  1,  0,  1,  0,  1,  0,  0,  0,  0, 26, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 21,  7, 20, 41, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 21,  0, 42, 43, 44,  0, 45,  0,  8, 21,  0,  0,  0,  0,  0,\n+    0,  0,  0, 46,  7,  1, 10,  1,  0,  0,  0,  1, 20, 20,  1,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0, 26, 34,  9,  0,  0, 20, 20,\n+    1, 20, 20,  0,  0,  0,  0,  0,  0,  0, 26, 21,  0,  1,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  3, 47, 48,  0,  0,  0,\n+    0,  0,  0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  7,  8,  7,  7,\n+    7,  7,  7,  7,  7,  7,  7,  7,  9, 10, 11, 11, 11, 11, 12, 13,\n+   13, 13, 13, 14, 15, 16, 17, 18, 19, 20, 21, 13, 22, 13, 13, 13,\n+   13, 23, 24, 24, 25, 26, 13, 13, 13, 27, 28, 29, 13, 30, 31, 32,\n+   33, 34, 35, 36,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n+    7,  7,  7,  7,  7,  7,  7,  7, 37,  7, 38, 39,  7, 40,  7,  7,\n+    7, 41, 13, 42,  7,  7, 43,  7, 44, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 45,  0,  0,  1,  2,  2,  2,  3,  4,  5,  6,  7,\n+    8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n+   24, 25, 26, 27, 28, 29, 30, 31, 32, 32, 33, 34, 35, 36, 37, 37,\n+   37, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,\n+   51, 52,  2,  2, 53, 54, 55, 56, 57, 58, 59, 59, 59, 59, 60, 59,\n+   59, 59, 59, 59, 59, 59, 61, 61, 59, 59, 59, 59, 62, 63, 64, 65,\n+   66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 59, 70, 70,\n+   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n+   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n+   70, 79, 70, 70, 70, 70, 80, 80, 80, 80, 80, 80, 80, 80, 80, 81,\n+   82, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 32, 32,\n+   32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+   32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+   32, 32, 32, 32, 32, 95, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n+   96, 96, 96, 96, 96, 96, 96, 96, 70, 70, 97, 98, 99,100,101,101,\n+  102,103,104,105,106,107,108,109,110,111, 96,112,113,114,115,116,\n+  117,118,119,119,120,121,122,123,124,125,126,127,128,129,130,131,\n+  132, 96,133,134,135,136,137,138,139,140,141,142,143, 96,144,145,\n+   96,146,147,148,149, 96,150,151,152,153,154,155,156, 96,157,158,\n+  159,160, 96,161,162,163,164,164,164,164,164,164,164,165,166,164,\n+  167, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n+   96, 96, 96, 96, 96,168,169,169,169,169,169,169,169,169,170, 96,\n+   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,171,171,\n+  171,171,172, 96, 96, 96,173,173,173,173,174,175,176,177, 96, 96,\n+   96, 96,178,179,180,181,182,182,182,182,182,182,182,182,182,182,\n+  182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,\n+  182,182,182,182,182,183,182,182,182,182,182,182,184,184,184,185,\n+  186, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n+   96, 96, 96, 96, 96,187,188,189,190,191,191,192, 96, 96, 96, 96,\n+   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,193,194,\n+   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n+   96, 96, 96, 96,195,196, 59,197,198,199,200,201,202, 96,203,204,\n+  205, 59, 59,206, 59,207,208,208,208,208,208,209, 96, 96, 96, 96,\n+   96, 96, 96, 96,210, 96,211,212,213, 96, 96,214, 96, 96, 96,215,\n+   96, 96, 96, 96, 96,216,217,218,219, 96, 96, 96, 96, 96,220,221,\n+  222, 96,223,224, 96, 96,225,226, 59,227,228, 96, 59, 59, 59, 59,\n+   59, 59, 59,229,230,231,232,233, 59, 59,234,235, 59,236, 96, 96,\n+   96, 96, 96, 96, 96, 96, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n+   70, 70, 70,237, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n+   70, 70, 70, 70,238, 70,239, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n+   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n+   70, 70, 70,240, 70, 70, 70, 70, 70, 70, 70, 70, 70,241, 96, 96,\n+   96, 96, 96, 96, 96, 96, 70, 70, 70, 70,242, 96, 96, 96, 96, 96,\n+   96, 96, 96, 96, 96, 96, 70, 70, 70, 70, 70, 70,243, 70, 70, 70,\n+   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,244, 96, 96,\n+   96, 96, 96, 96, 96, 96,245, 96,246,247,  0,  1,  2,  2,  0,  1,\n+    2,  2,  2,  3,  4,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0, 19,\n@@ -2291,6 +1767,3 @@\n-   19,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-   19,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n-   19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,  0, 19, 19,\n-   19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,  0,\n-    0,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19,  0,  0,  0,  0,  0,\n-   26, 26,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n+   19,  0,  0,  0,  0,  0,  0,  0, 19,  0,  0,  0,  0,  0, 19, 19,\n+   19, 19, 19, 19, 19,  0, 19,  0,  0,  0,  0,  0,  0,  0, 19, 19,\n+   19, 19, 19,  0,  0,  0,  0,  0, 26, 26,  0,  0,  0,  0,  1,  1,\n@@ -2300,2 +1773,1 @@\n-    9,  9,  9,  9,  9,  9,  9,  9,  2,  9,  9,  9,  9,  9,  9,  9,\n-    9,  9,  9,  9,  9,  9,  9,  9, 55, 55, 55, 55, 55, 55, 55, 55,\n+    2,  9,  9,  9,  9,  9,  9,  9, 55, 55, 55, 55, 55, 55, 55, 55,\n@@ -2303,5 +1775,2 @@\n-    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  1,  1,  6,  6,  6,\n-    6,  6,  6,  6,  6,  6,  2,  4,  4,  4,  4,  4,  4,  4,  4,  4,\n-    4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,\n-    4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  2,  2,  4,\n-    4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,\n+    6,  6,  6,  1,  1,  6,  2,  4,  4,  4,  4,  4,  4,  4,  4,  4,\n+    4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  2,  4,  4,\n@@ -2309,14 +1778,7 @@\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,  2,  2,\n-    2,  2,  2,  2,  2,  2, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14,  2,  2,  2,  2, 14, 14, 14, 14, 14, 14,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  0,  3,  3,  3,  3,\n-    3,  3,  0,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    3,  0,  3,  3,  3,  0,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    3,  3,  3,  3,  3,  3,  0,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    3,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  3,  3,  3,  3,\n-    3,  3,  3,  3,  3,  3,  1,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    3,  3,  3,  0,  3,  3, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,\n-   37, 37, 37, 37,  2, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,\n-   37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,\n+   14, 14, 14, 14, 14, 14,  2,  2,  2,  2,  2,  2,  2,  2, 14, 14,\n+   14,  2,  2,  2,  2, 14, 14, 14, 14, 14, 14,  2,  2,  2,  3,  3,\n+    3,  3,  3,  0,  3,  3,  3,  3,  3,  3,  0,  3,  3,  3,  3,  3,\n+    3,  3,  3,  3,  3,  3,  3,  3,  3,  0,  3,  3,  3,  0,  0,  3,\n+    3,  3,  3,  3,  3,  3,  3,  3,  3,  1,  1,  1,  1,  1,  1,  1,\n+    1,  1,  1,  1,  3,  3,  1,  3,  3,  3,  3,  3,  3,  3, 37, 37,\n+   37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,  2, 37, 37, 37,\n@@ -2324,1 +1786,0 @@\n-   38, 38, 38, 38, 38, 38, 38, 38,  2,  2,  2,  2,  2,  2,  2,  2,\n@@ -2326,1 +1787,0 @@\n-   64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n@@ -2328,9 +1788,4 @@\n-   90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,\n-   90, 90, 90, 90,  2,  2, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,\n-   90, 90, 90, 90, 90,  2, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95,\n-   95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95,\n-   95, 95,  2,  2, 95,  2, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,\n-   37,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    3,  3,  3,  3,  3,  2,  3,  3,  2,  2,  2,  2,  2,  2,  3,  3,\n-    3,  3,  3,  3,  3,  3,  3,  3,  0,  3,  3,  3,  3,  3,  3,  3,\n-    3,  3,  3,  3,  3,  3,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n+   90, 90, 90, 90,  2,  2, 90, 90, 90, 90, 90, 90, 90,  2, 95, 95,\n+   95, 95, 95, 95, 95, 95, 95, 95, 95, 95,  2,  2, 95,  2, 37, 37,\n+   37,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  2,  3,  3,\n+    2,  2,  2,  2,  2,  2,  3,  3,  0,  3,  3,  3,  3,  3,  7,  7,\n@@ -2338,2 +1793,1 @@\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  0,  0,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  5,  5,  5,  5,  2,  5,  5,  5,  5,  5,\n+    7,  7,  0,  0,  7,  7,  5,  5,  5,  5,  2,  5,  5,  5,  5,  5,\n@@ -2341,3 +1795,2 @@\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  2,\n-    5,  5,  5,  5,  5,  5,  5,  2,  5,  2,  2,  2,  5,  5,  5,  5,\n-    2,  2,  5,  5,  5,  5,  5,  5,  5,  5,  5,  2,  2,  5,  5,  2,\n+    5,  5,  5,  5,  5,  5,  5,  2,  5,  5,  5,  5,  5,  5,  5,  2,\n+    5,  2,  2,  2,  5,  5,  5,  5,  2,  2,  5,  5,  5,  5,  5,  2,\n@@ -2346,1 +1799,0 @@\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n@@ -2349,3 +1801,2 @@\n-   11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  2,\n-   11, 11, 11, 11, 11, 11, 11,  2, 11, 11,  2, 11, 11,  2, 11, 11,\n-    2,  2, 11,  2, 11, 11, 11, 11, 11,  2,  2,  2,  2, 11, 11,  2,\n+   11, 11, 11, 11, 11, 11, 11,  2, 11, 11, 11, 11, 11, 11, 11,  2,\n+   11, 11,  2, 11, 11,  2, 11, 11,  2,  2, 11,  2, 11, 11, 11,  2,\n@@ -2354,2 +1805,1 @@\n-   11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2, 10, 10, 10,  2, 10, 10, 10, 10, 10,\n+   11, 11, 11, 11, 11,  2,  2, 10, 10, 10,  2, 10, 10, 10, 10, 10,\n@@ -2357,6 +1807,4 @@\n-   10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,  2,\n-   10, 10, 10, 10, 10, 10, 10,  2, 10, 10,  2, 10, 10, 10, 10, 10,\n-    2,  2, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,  2, 10, 10, 10,\n-    2, 10, 10, 10,  2,  2, 10,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 10, 10, 10, 10,  2,  2, 10, 10, 10, 10,\n-   10, 10, 10, 10, 10, 10, 10, 10,  2,  2,  2,  2,  2,  2,  2, 10,\n+   10, 10, 10, 10, 10, 10, 10,  2, 10, 10, 10, 10, 10, 10, 10,  2,\n+   10, 10,  2, 10, 10, 10, 10, 10,  2,  2, 10, 10, 10, 10, 10, 10,\n+    2, 10, 10, 10,  2,  2, 10,  2,  2,  2,  2,  2,  2,  2, 10, 10,\n+   10, 10,  2,  2, 10, 10, 10, 10,  2,  2,  2,  2,  2,  2,  2, 10,\n@@ -2365,3 +1813,2 @@\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,  2,\n-   21, 21, 21, 21, 21, 21, 21,  2, 21, 21,  2, 21, 21, 21, 21, 21,\n-    2,  2, 21, 21, 21, 21, 21, 21, 21, 21, 21,  2,  2, 21, 21,  2,\n+   21, 21, 21, 21, 21, 21, 21,  2, 21, 21, 21, 21, 21, 21, 21,  2,\n+   21, 21,  2, 21, 21, 21, 21, 21,  2,  2, 21, 21, 21, 21, 21,  2,\n@@ -2369,15 +1816,8 @@\n-    2,  2, 21, 21,  2, 21, 21, 21, 21, 21,  2,  2, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2,  2, 22, 22,  2, 22, 22, 22, 22, 22,\n-   22,  2,  2,  2, 22, 22, 22,  2, 22, 22, 22, 22,  2,  2,  2, 22,\n-   22,  2, 22,  2, 22, 22,  2,  2,  2, 22, 22,  2,  2,  2, 22, 22,\n-   22,  2,  2,  2, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n-    2,  2,  2,  2, 22, 22, 22, 22, 22,  2,  2,  2, 22, 22, 22,  2,\n-   22, 22, 22, 22,  2,  2, 22,  2,  2,  2,  2,  2,  2, 22,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 22, 22, 22, 22,\n-   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n-   22,  2,  2,  2,  2,  2, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n-   23, 23, 23,  2, 23, 23, 23,  2, 23, 23, 23, 23, 23, 23, 23, 23,\n-   23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,  2,\n-   23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n-    2,  2, 23, 23, 23, 23, 23, 23, 23, 23, 23,  2, 23, 23, 23,  2,\n+    2,  2, 21, 21,  2, 21, 21, 21, 21, 21,  2,  2, 21, 21,  2,  2,\n+   22, 22,  2, 22, 22, 22, 22, 22, 22,  2,  2,  2, 22, 22, 22,  2,\n+   22, 22, 22, 22,  2,  2,  2, 22, 22,  2, 22,  2, 22, 22,  2,  2,\n+    2, 22, 22,  2,  2,  2, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+    2,  2,  2,  2, 22, 22, 22,  2,  2,  2,  2,  2,  2, 22,  2,  2,\n+    2,  2,  2,  2, 22, 22, 22, 22, 22,  2,  2,  2,  2,  2, 23, 23,\n+   23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,  2, 23, 23, 23,  2,\n+   23, 23, 23, 23, 23, 23, 23, 23,  2,  2, 23, 23, 23, 23, 23,  2,\n@@ -2385,3 +1825,2 @@\n-   23,  2,  2, 23,  2,  2, 23, 23, 23, 23,  2,  2, 23, 23, 23, 23,\n-   23, 23, 23, 23, 23, 23,  2,  2,  2,  2,  2,  2,  2, 23, 23, 23,\n-   23, 23, 23, 23, 23, 23, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n+   23,  2,  2, 23,  2,  2, 23, 23, 23, 23,  2,  2, 23, 23,  2,  2,\n+    2,  2,  2,  2,  2, 23, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n@@ -2389,9 +1828,3 @@\n-   16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,  2,\n-   16, 16, 16, 16, 16, 16, 16, 16, 16, 16,  2, 16, 16, 16, 16, 16,\n-    2,  2, 16, 16, 16, 16, 16, 16, 16, 16, 16,  2, 16, 16, 16,  2,\n-   16, 16, 16, 16,  2,  2,  2,  2,  2,  2,  2, 16, 16,  2,  2,  2,\n-    2,  2,  2, 16, 16,  2, 16, 16, 16, 16,  2,  2, 16, 16, 16, 16,\n-   16, 16, 16, 16, 16, 16,  2, 16, 16,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n-   20, 20, 20,  2, 20, 20, 20,  2, 20, 20, 20, 20, 20, 20, 20, 20,\n-   20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\n+   16, 16,  2, 16, 16, 16, 16, 16,  2,  2, 16, 16, 16, 16, 16,  2,\n+   16, 16, 16, 16,  2,  2,  2,  2,  2,  2,  2, 16, 16,  2, 16, 16,\n+   16, 16,  2,  2, 16, 16,  2, 16, 16, 16,  2,  2,  2,  2, 20, 20,\n@@ -2400,2 +1833,1 @@\n-   20, 20, 20, 20, 20, 20, 20, 20, 20, 20,  2,  2, 20, 20, 20, 20,\n-   20, 20, 20, 20, 20, 20,  2, 36, 36, 36,  2, 36, 36, 36, 36, 36,\n+   20, 20,  2,  2, 20, 20,  2, 36, 36, 36,  2, 36, 36, 36, 36, 36,\n@@ -2403,1 +1835,0 @@\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n@@ -2405,10 +1836,5 @@\n-   36, 36,  2, 36,  2,  2, 36, 36, 36, 36, 36, 36, 36,  2,  2,  2,\n-   36,  2,  2,  2,  2, 36, 36, 36, 36, 36, 36,  2, 36,  2, 36, 36,\n-   36, 36, 36, 36, 36, 36,  2,  2,  2,  2,  2,  2, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36,  2,  2, 36, 36, 36,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n-   24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n-   24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n-   24,  2,  2,  2,  2,  0, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n-   24, 24,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2, 18, 18,  2, 18,  2, 18, 18, 18, 18,\n+   36, 36,  2, 36,  2,  2,  2,  2, 36,  2,  2,  2,  2, 36, 36, 36,\n+   36, 36, 36,  2, 36,  2,  2,  2,  2,  2,  2,  2, 36, 36,  2,  2,\n+   36, 36, 36,  2,  2,  2,  2, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+   24, 24, 24, 24, 24, 24, 24, 24, 24,  2,  2,  2,  2,  0, 24, 24,\n+   24, 24,  2,  2,  2,  2,  2, 18, 18,  2, 18,  2, 18, 18, 18, 18,\n@@ -2416,9 +1842,4 @@\n-   18, 18, 18, 18, 18, 18, 18, 18, 18, 18,  2, 18,  2, 18, 18, 18,\n-   18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n-   18, 18, 18, 18,  2,  2, 18, 18, 18, 18, 18,  2, 18,  2, 18, 18,\n-   18, 18, 18, 18,  2,  2, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n-    2,  2, 18, 18, 18, 18, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n-   25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,  2, 25,\n-   25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n-   25, 25, 25,  2,  2,  2,  2, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n-   25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n+   18, 18,  2, 18,  2, 18, 18, 18, 18, 18, 18, 18,  2,  2, 18, 18,\n+   18, 18, 18,  2, 18,  2, 18, 18, 18, 18, 18, 18, 18,  2, 18, 18,\n+    2,  2, 18, 18, 18, 18, 25, 25, 25, 25, 25, 25, 25, 25,  2, 25,\n+   25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,  2,  2,  2, 25, 25,\n@@ -2426,2 +1847,1 @@\n-   25,  2,  2,  2,  2,  2, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,\n-   33, 33, 33, 33, 33, 33,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n+   25,  2,  2,  2,  2,  2, 33, 33, 33, 33, 33, 33, 33, 33,  8,  8,\n@@ -2429,11 +1849,4 @@\n-    2,  2,  2,  8,  2,  2,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n-    8,  0,  8,  8,  8,  8, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n-   30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,  2,\n-   30, 30, 30, 30,  2,  2, 30, 30, 30, 30, 30, 30, 30,  2, 30,  2,\n-   30, 30, 30, 30,  2,  2, 30,  2, 30, 30, 30, 30,  2,  2, 30, 30,\n-   30, 30, 30, 30, 30,  2, 30,  2, 30, 30, 30, 30,  2,  2, 30, 30,\n-   30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,  2, 30, 30,\n-   30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n-   30,  2,  2, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n-   30, 30, 30,  2,  2,  2, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+    2,  2,  2,  8,  2,  2,  8,  8,  8,  0,  8,  8,  8,  8, 12, 12,\n+   12, 12, 12, 12, 12, 12, 30, 30, 30, 30, 30, 30, 30, 30, 30,  2,\n+   30, 30, 30, 30,  2,  2, 30, 30, 30, 30, 30, 30, 30,  2, 30, 30,\n+   30,  2,  2, 30, 30, 30, 30, 30, 30, 30, 30,  2,  2,  2, 30, 30,\n@@ -2441,7 +1854,3 @@\n-   29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,  2,  2, 29, 29,\n-   29, 29, 29, 29,  2,  2, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n-   28, 28, 28, 28, 28, 28, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34,  2,  2,  2, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35,  0,  0,  0, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,  2,\n+   29, 29, 29, 29,  2,  2, 28, 28, 28, 28, 28, 28, 28, 28, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,  2,  2,  2, 35, 35,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35,  0,  0,  0, 35, 35, 35,  2,\n@@ -2449,27 +1858,14 @@\n-   45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2, 45, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44,\n-   44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44,  0,  0,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n-   43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,\n-   46, 46, 46,  2, 46, 46, 46,  2, 46, 46,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n-   31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n-   31, 31, 31, 31,  2,  2, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n-    2,  2,  2,  2,  2,  2, 32, 32,  0,  0, 32,  0, 32, 32, 32, 32,\n-   32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n-    2,  2,  2,  2,  2,  2, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n-   32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,  2,\n-    2,  2,  2,  2,  2,  2, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n-   32,  2,  2,  2,  2,  2, 28, 28, 28, 28, 28, 28,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n-   48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n-   48, 48, 48, 48, 48,  2, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n-   48, 48,  2,  2,  2,  2, 48,  2,  2,  2, 48, 48, 48, 48, 48, 48,\n-   48, 48, 48, 48, 48, 48, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n-   52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n-   52, 52, 52, 52,  2,  2, 52, 52, 52, 52, 52,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58,  2,  2,  2,  2, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-    2,  2,  2,  2,  2,  2, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   45, 45, 45, 45,  2,  2,  2,  2,  2,  2,  2,  2,  2, 45, 44, 44,\n+   44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44,  0,  0,  2, 43, 43,\n+   43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  2,  2,  2,  2, 46, 46,\n+   46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,  2, 46, 46, 46,  2,\n+   46, 46,  2,  2,  2,  2, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n+   31, 31, 31, 31,  2,  2, 31, 31,  2,  2,  2,  2,  2,  2, 32, 32,\n+    0,  0, 32,  0, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+    2,  2,  2,  2,  2,  2, 32,  2,  2,  2,  2,  2,  2,  2, 32, 32,\n+   32,  2,  2,  2,  2,  2, 28, 28, 28, 28, 28, 28,  2,  2, 48, 48,\n+   48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,  2, 48, 48,\n+   48, 48,  2,  2,  2,  2, 48,  2,  2,  2, 48, 48, 48, 48, 52, 52,\n+   52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,  2,  2, 52, 52,\n+   52, 52, 52,  2,  2,  2, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58,  2,  2,  2,  2, 58, 58,  2,  2,  2,  2,  2,  2, 58, 58,\n@@ -2477,1 +1873,0 @@\n-   54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,\n@@ -2479,5 +1874,2 @@\n-   91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,\n-   91, 91, 91, 91, 91,  2, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,\n-   91, 91, 91,  2,  2, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,\n-    2,  2,  2,  2,  2,  2, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,\n-   91, 91, 91, 91,  2,  2,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n+   91, 91, 91, 91, 91,  2, 91, 91, 91, 91, 91,  2,  2, 91, 91, 91,\n+    2,  2,  2,  2,  2,  2, 91, 91, 91, 91, 91, 91,  2,  2,  1,  1,\n@@ -2485,3 +1877,1 @@\n-   62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62,\n-   62, 62, 62,  2,  2,  2, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62,\n-   62, 62, 62, 62, 62,  2, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76,\n+   62, 62, 62,  2,  2,  2, 62, 62, 62, 62, 62, 62, 62,  2, 76, 76,\n@@ -2489,10 +1879,5 @@\n-   93, 93, 93, 93, 93, 93, 93, 93, 93, 93,  2,  2,  2,  2,  2,  2,\n-    2,  2, 93, 93, 93, 93, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n-   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,  2,  2,\n-    2, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n-    2,  2,  2, 70, 70, 70, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73,\n-   73, 73, 73, 73, 73, 73,  6,  6,  6,  6,  6,  6,  6,  6,  6,  2,\n-    2,  2,  2,  2,  2,  2,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n-    8,  2,  2,  8,  8,  8, 76, 76, 76, 76, 76, 76, 76, 76,  2,  2,\n-    2,  2,  2,  2,  2,  2,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,\n-    1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  0,\n+   93, 93,  2,  2,  2,  2,  2,  2,  2,  2, 93, 93, 93, 93, 70, 70,\n+   70, 70, 70, 70, 70, 70,  2,  2,  2, 70, 70, 70, 70, 70, 70, 70,\n+    2,  2,  2, 70, 70, 70, 73, 73, 73, 73, 73, 73, 73, 73,  6,  2,\n+    2,  2,  2,  2,  2,  2,  8,  8,  8,  2,  2,  8,  8,  8,  1,  1,\n+    1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  0,\n@@ -2501,9 +1886,5 @@\n-    9,  6, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n-   19, 19, 19,  9,  9,  9,  9,  9, 19, 19, 19, 19,  9,  9,  9,  9,\n-    9, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,  6, 19,\n-   19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n-   19, 19, 19, 19, 19,  9,  9,  9,  9,  9,  9,  9,  2,  2,  9,  9,\n-    9,  9,  9,  9,  2,  2,  9,  9,  9,  9,  9,  9,  9,  9,  2,  9,\n-    2,  9,  2,  9,  2,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n-    9,  9,  9,  9,  2,  2,  9,  9,  9,  9,  9,  2,  9,  9,  9,  9,\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  2,  2,  9,  9,  9,  9,\n+    9,  6, 19, 19, 19, 19, 19, 19, 19, 19, 19,  9,  9,  9,  9,  9,\n+   19, 19, 19, 19,  9,  9,  9,  9,  9, 19, 19, 19, 19, 19,  6, 19,\n+   19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,  9,  9,  9,\n+    9,  9,  9,  9,  2,  2,  2,  9,  2,  9,  2,  9,  2,  9,  9,  9,\n+    9,  9,  9,  2,  9,  9,  9,  9,  9,  9,  2,  2,  9,  9,  9,  9,\n@@ -2511,7 +1892,4 @@\n-    9,  9,  9,  9,  9,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  2,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 19,  2,  2,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0, 19,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  2, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n-   19, 19, 19,  2,  2,  2,  0,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n+    9,  9,  9,  9,  9,  2,  0,  0,  0,  0,  1,  1,  0,  0,  0,  0,\n+    0,  0,  0,  2,  0,  0,  0, 19,  2,  2,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0, 19,  0,  0,  0,  0,  0,  0,  0,  2, 19, 19,\n+   19, 19, 19,  2,  2,  2,  0,  2,  2,  2,  2,  2,  2,  2,  1,  2,\n@@ -2519,6 +1897,2 @@\n-   19, 19,  0,  0,  0,  0,  0,  0, 19,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0, 19,  0, 19, 19, 19, 19, 19, 19, 19, 19, 19,  0,\n-    0,  0,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  2,  2,  2,  2,  2, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n+   19, 19,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 19,  0, 19,  0,\n+    0,  0,  2,  2,  2,  2,  0,  0,  0,  2,  2,  2,  2,  2, 27, 27,\n@@ -2526,18 +1900,8 @@\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n-   56, 56, 56, 56, 56, 56, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55,\n-   55, 55, 55, 55, 55, 55, 55, 55, 55, 55,  2,  2,  2,  2,  2, 55,\n-   55, 55, 55, 55, 55, 55, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,\n-   61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  2,  2,\n-    2,  2,  2,  2,  2, 61, 61,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2, 61, 30, 30, 30, 30, 30, 30, 30,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 30, 30, 30, 30, 30, 30, 30,  2, 30, 30,\n-   30, 30, 30, 30, 30,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  2,  2, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n-    2, 13, 13, 13, 13, 13, 13, 13, 13, 13,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 13, 13, 13, 13, 13, 13,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  2,  2,  2,  2,  0,  0,  0,  0,  0, 13,  0, 13,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n-    1,  1,  1,  1, 12, 12,  0,  0,  0,  0,  0,  0,  0,  0, 13, 13,\n+    0,  0,  0,  0,  2,  0, 56, 56, 56, 56, 56, 56, 56, 56, 55, 55,\n+   55, 55,  2,  2,  2,  2,  2, 55, 55, 55, 55, 55, 55, 55, 61, 61,\n+   61, 61, 61, 61, 61, 61,  2,  2,  2,  2,  2,  2,  2, 61, 61,  2,\n+    2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,  2,  2, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13,  2, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13,  2,  2,  2,  2, 13, 13, 13, 13, 13, 13,  2,  2,  0,  0,\n+    0,  0,  2,  2,  2,  2,  0,  0,  0,  0,  0, 13,  0, 13,  0, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13,  1,  1,  1,  1, 12, 12, 13, 13,\n@@ -2545,1 +1909,0 @@\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n@@ -2548,23 +1911,10 @@\n-   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n-   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n-   17,  0,  0, 17, 17, 17,  2,  2,  2,  2,  2, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26,  2, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12,  2,  0,  0,  0,  0,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12,  0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n-   17, 17, 17, 17, 17,  0, 17, 17, 17, 17, 17, 17, 17, 17,  0,  0,\n-    0,  0,  0,  0,  0,  0, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,\n-   39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,\n-   39, 39, 39,  2,  2,  2, 39, 39, 39, 39, 39, 39, 39,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\n-   86, 86, 86, 86, 86, 86, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n-   77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n-   77, 77,  2,  2,  2,  2, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79,\n-   79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79,  2,  2,\n-    2,  2,  2,  2,  2,  2,  0,  0, 19, 19, 19, 19, 19, 19, 19, 19,\n-   19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,  0,  0,\n-    0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n-   19,  2,  2,  2,  2,  2, 19, 19,  2, 19,  2, 19, 19, 19, 19, 19,\n-    2,  2,  2,  2,  2,  2,  2,  2, 19, 19, 19, 19, 19, 19, 19, 19,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17,  0,  0, 17, 17, 17,  2,  2,\n+    2,  2,  2, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,  2, 12,\n+   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,  2, 12, 12,\n+   12, 12, 12, 12, 12,  0, 17, 17, 17, 17, 17, 17, 17,  0, 39, 39,\n+   39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,  2,  2,  2, 39, 39,\n+   39, 39, 39, 39, 39,  2, 86, 86, 86, 86, 86, 86, 86, 86, 77, 77,\n+   77, 77, 77, 77, 77, 77, 77, 77, 77, 77,  2,  2,  2,  2, 79, 79,\n+   79, 79, 79, 79, 79, 79,  0,  0, 19, 19, 19, 19, 19, 19,  0,  0,\n+    0, 19, 19, 19, 19, 19, 19, 19, 19,  2,  2,  2,  2,  2, 19, 19,\n+    2, 19,  2, 19, 19, 19, 19, 19,  2,  2,  2,  2,  2,  2,  2,  2,\n@@ -2572,7 +1922,3 @@\n-   60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n-   60, 60, 60,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    2,  2,  2,  2,  2,  2, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65,\n-   65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65,  2,  2,\n-    2,  2,  2,  2,  2,  2, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75,\n-   75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75,  2,  2,  2,  2,\n-    2,  2,  2,  2, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75,\n+   60, 60, 60,  2,  2,  2,  0,  0,  2,  2,  2,  2,  2,  2, 65, 65,\n+   65, 65, 65, 65, 65, 65, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75,\n+   75, 75, 75, 75,  2,  2,  2,  2,  2,  2,  2,  2, 75, 75, 75, 75,\n@@ -2580,1 +1926,0 @@\n-   69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69,\n@@ -2582,2 +1927,1 @@\n-   74, 74, 74, 74, 74, 74, 74, 74, 74, 74,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2, 74, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n+   74, 74,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 74, 12, 12,\n@@ -2585,3 +1929,1 @@\n-   84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84,\n-   84, 84, 84, 84,  2,  0, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84,\n-    2,  2,  2,  2, 84, 84, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,\n+   84, 84, 84, 84,  2,  0, 84, 84,  2,  2,  2,  2, 84, 84, 33, 33,\n@@ -2589,3 +1931,1 @@\n-   68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68,\n-   68, 68, 68, 68,  2,  2, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68,\n+   68, 68, 68, 68, 68,  2, 68, 68, 68, 68, 68, 68,  2,  2, 68, 68,\n@@ -2593,15 +1933,6 @@\n-   92, 92, 92, 92, 92, 92, 92, 92, 92,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2, 92, 92, 92, 92, 92, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n-   87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2, 30, 30, 30, 30, 30, 30,  2,  2, 30,\n-   30, 30, 30, 30, 30,  2,  2, 30, 30, 30, 30, 30, 30,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n-   19,  0, 19, 19, 19, 19, 19, 19, 19, 19, 19,  9, 19, 19, 19, 19,\n-    0,  0,  2,  2,  2,  2, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n-   87, 87, 87, 87,  2,  2, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n-    2,  2,  2,  2,  2,  2, 12, 12, 12, 12,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 12, 12, 12, 12, 12, 12, 12,  2,  2,  2,\n-    2, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12,  2,  2,  2,  2, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n-   13, 13, 13, 13,  2,  2, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   92,  2,  2,  2,  2,  2,  2,  2,  2, 92, 92, 92, 92, 92, 87, 87,\n+   87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,  2,  2, 30,\n+   30, 30, 30, 30, 30,  2, 19, 19, 19,  0, 19, 19, 19, 19, 19, 19,\n+   19, 19, 19,  9, 19, 19, 19, 19,  0,  0,  2,  2,  2,  2, 87, 87,\n+   87, 87, 87, 87,  2,  2, 87, 87,  2,  2,  2,  2,  2,  2, 12, 12,\n+   12, 12,  2,  2,  2,  2,  2,  2,  2, 12, 12, 12, 12, 12, 13, 13,\n@@ -2609,14 +1940,7 @@\n-    2,  2,  2,  2,  2,  2,  2,  2,  2,  4,  4,  4,  4,  4,  2,  2,\n-    2,  2,  2, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,  2, 14, 14,\n-   14, 14, 14,  2, 14,  2, 14, 14,  2, 14, 14,  2, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14,  3,  3,  3,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,\n-    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    3,  3,  3,  3,  0,  0,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,\n-    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  2,  2,\n-    2,  2,  2,  2,  2,  3,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n-    1,  1,  1,  1,  6,  6,  0,  0,  0,  2,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  0,  0,\n-    0,  0,  2,  2,  2,  2,  3,  3,  3,  3,  3,  2,  3,  3,  3,  3,\n-    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    3,  3,  3,  2,  2,  0,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    2,  4,  4,  4,  4,  4,  2,  2,  2,  2,  2, 14, 14, 14, 14, 14,\n+   14, 14, 14, 14, 14,  2, 14, 14, 14, 14, 14,  2, 14,  2, 14, 14,\n+    2, 14, 14,  2, 14, 14,  3,  3,  3,  2,  2,  2,  2,  2,  2,  2,\n+    2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  0,  0,  2,  2,\n+    3,  3,  3,  3,  3,  3,  2,  2,  2,  2,  2,  2,  2,  3,  1,  1,\n+    1,  1,  1,  1,  6,  6,  0,  0,  0,  2,  0,  0,  0,  0,  3,  3,\n+    3,  3,  3,  2,  3,  3,  3,  3,  3,  3,  3,  2,  2,  0,  2,  0,\n@@ -2624,1 +1948,0 @@\n-   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n@@ -2626,15 +1949,6 @@\n-   12, 12, 12, 12, 12, 12,  2,  2, 12, 12, 12, 12, 12, 12,  2,  2,\n-   12, 12, 12,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  2,  0,  0,\n-    0,  0,  0,  0,  0,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  0,\n-    0,  0,  0,  0,  2,  2, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\n-   49, 49,  2, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\n-   49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,  2, 49, 49,\n-   49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\n-   49,  2, 49, 49,  2, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\n-   49, 49, 49, 49,  2,  2, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\n-   49,  2,  2,  2,  2,  2,  0,  0,  0,  2,  2,  2,  2,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  2,  2,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n-    9,  9,  9,  9,  9,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  2,  2,  2,  9,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+   12, 12, 12,  2,  2,  2,  2,  0,  0,  0,  0,  0,  2,  2, 49, 49,\n+   49, 49, 49, 49, 49, 49, 49, 49, 49, 49,  2, 49, 49, 49, 49, 49,\n+   49, 49, 49, 49, 49,  2, 49, 49, 49,  2, 49, 49,  2, 49, 49, 49,\n+   49, 49, 49, 49,  2,  2, 49, 49, 49,  2,  2,  2,  2,  2,  0,  0,\n+    0,  2,  2,  2,  2,  0,  0,  0,  0,  0,  2,  2,  2,  0,  0,  0,\n+    0,  0,  0,  2,  2,  2,  9,  2,  2,  2,  2,  2,  2,  2,  0,  0,\n@@ -2642,5 +1956,2 @@\n-   71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71,\n-   71, 71, 71,  2,  2,  2, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n-   67, 67, 67, 67, 67, 67, 67,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,\n+   71, 71, 71,  2,  2,  2, 67, 67, 67, 67, 67, 67, 67, 67, 67,  2,\n+    2,  2,  2,  2,  2,  2,  1,  0,  0,  0,  0,  0,  0,  0, 42, 42,\n@@ -2649,1 +1960,0 @@\n-   41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41,\n@@ -2651,1 +1961,0 @@\n-  118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,\n@@ -2653,1 +1962,0 @@\n-   53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53,\n@@ -2655,7 +1963,3 @@\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59,  2,  2,  2,  2, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,\n-   40, 40, 40, 40, 40, 40, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,\n-   51, 51, 51, 51, 51, 51, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n-   50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n-   50, 50, 50, 50,  2,  2, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n+   59, 59,  2,  2,  2,  2, 59, 59, 59, 59, 59, 59,  2,  2, 40, 40,\n+   40, 40, 40, 40, 40, 40, 51, 51, 51, 51, 51, 51, 51, 51, 50, 50,\n+   50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,  2,  2, 50, 50,\n@@ -2663,5 +1967,1 @@\n-  135,135,135,135,135,135,135,135,135,135,  2,  2,  2,  2,135,135,\n-  135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,\n-  135,135,  2,  2,  2,  2,106,106,106,106,106,106,106,106,106,106,\n-  106,106,106,106,106,106,106,106,106,106,106,106,106,106,  2,  2,\n-    2,  2,  2,  2,  2,  2,104,104,104,104,104,104,104,104,104,104,\n+  135,135,  2,  2,  2,  2,106,106,106,106,106,106,106,106,104,104,\n@@ -2671,9 +1971,4 @@\n-  161,161,161,161,161,161,161,161,  2,161,161,161,161,161,161,161,\n-  161,161,161,161,161,161,161,161,  2,161,161,161,161,161,161,161,\n-    2,161,161,  2,  2,  2,110,110,110,110,110,110,110,110,110,110,\n-  110,110,110,110,110,110,110,110,110,110,110,110,110,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,110,110,110,110,110,110,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,110,110,110,110,110,110,110,110,  2,  2,\n-    2,  2,  2,  2,  2,  2, 19, 19, 19, 19, 19, 19,  2, 19, 19, 19,\n-   19, 19, 19, 19, 19, 19, 19,  2, 19, 19, 19, 19, 19, 19, 19, 19,\n-   19,  2,  2,  2,  2,  2, 47, 47, 47, 47, 47, 47,  2,  2, 47,  2,\n+    2,161,161,161,161,161,161,161,  2,161,161,  2,  2,  2,110,110,\n+  110,110,110,110,110,110,110,110,110,110,110,110,110,  2,110,110,\n+  110,110,110,110,  2,  2, 19, 19, 19, 19, 19, 19,  2, 19, 19,  2,\n+   19, 19, 19, 19, 19, 19, 47, 47, 47, 47, 47, 47,  2,  2, 47,  2,\n@@ -2681,4 +1976,2 @@\n-   47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47,  2, 47, 47,  2,\n-    2,  2, 47,  2,  2, 47, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81,\n-   81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81,  2, 81, 81, 81,\n-   81, 81, 81, 81, 81, 81,120,120,120,120,120,120,120,120,120,120,\n+   47, 47, 47, 47,  2, 47, 47,  2,  2,  2, 47,  2,  2, 47, 81, 81,\n+   81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81,  2, 81,120,120,\n@@ -2686,3 +1979,1 @@\n-  116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,\n-  116,116,116,116,116,  2,  2,  2,  2,  2,  2,  2,  2,116,116,116,\n-  116,116,116,116,116,116,128,128,128,128,128,128,128,128,128,128,\n+  116,116,116,116,116,  2,  2,  2,  2,  2,  2,  2,  2,116,128,128,\n@@ -2691,1 +1982,0 @@\n-   66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66,\n@@ -2693,434 +1983,160 @@\n-   72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72,\n-    2,  2,  2,  2,  2, 72, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98,\n-   98, 98, 98, 98, 98, 98, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,\n-   97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,  2,  2,\n-    2,  2, 97, 97, 97, 97,  2,  2, 97, 97, 97, 97, 97, 97, 97, 97,\n-   97, 97, 97, 97, 97, 97, 57, 57, 57, 57,  2, 57, 57,  2,  2,  2,\n-    2,  2, 57, 57, 57, 57, 57, 57, 57, 57,  2, 57, 57, 57,  2, 57,\n-   57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,\n-   57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,  2,  2, 57, 57,\n-   57,  2,  2,  2,  2, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,  2,\n-    2,  2,  2,  2,  2,  2, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88,\n-   88, 88, 88, 88, 88, 88,117,117,117,117,117,117,117,117,117,117,\n-  117,117,117,117,117,117,112,112,112,112,112,112,112,112,112,112,\n-  112,112,112,112,112,112,112,112,112,112,112,112,112,  2,  2,  2,\n-    2,112,112,112,112,112,112,112,112,112,112,112,112,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,\n-   78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,  2,  2,  2, 78,\n-   78, 78, 78, 78, 78, 78, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83,\n-   83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83,  2,  2, 83, 83,\n-   83, 83, 83, 83, 83, 83, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82,\n-   82, 82, 82, 82, 82, 82, 82, 82, 82,  2,  2,  2,  2,  2, 82, 82,\n-   82, 82, 82, 82, 82, 82,122,122,122,122,122,122,122,122,122,122,\n-  122,122,122,122,122,122,122,122,  2,  2,  2,  2,  2,  2,  2,122,\n-  122,122,122,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,122,\n-  122,122,122,122,122,122, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89,\n-   89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89,  2,\n-    2,  2,  2,  2,  2,  2,130,130,130,130,130,130,130,130,130,130,\n-  130,130,130,130,130,130,130,130,130,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,130,130,130,  2,  2,  2,  2,  2,  2,  2,\n-  130,130,130,130,130,130,144,144,144,144,144,144,144,144,144,144,\n-  144,144,144,144,144,144,144,144,144,144,144,144,144,144,  2,  2,\n-    2,  2,  2,  2,  2,  2,144,144,144,144,144,144,144,144,144,144,\n-    2,  2,  2,  2,  2,  2,156,156,156,156,156,156,156,156,156,156,\n-  156,156,156,156,156,156,156,156,156,156,156,156,156,156,156,156,\n-    2,156,156,156,  2,  2,156,156,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,147,147,147,147,147,147,147,147,147,147,\n-  147,147,147,147,147,147,147,147,147,147,147,147,147,147,  2,  2,\n-    2,  2,  2,  2,  2,  2,148,148,148,148,148,148,148,148,148,148,\n-  148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,\n-    2,  2,  2,  2,  2,  2,158,158,158,158,158,158,158,158,158,158,\n-  158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,\n-    2,  2,  2,  2,  2,  2,153,153,153,153,153,153,153,153,153,153,\n-  153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,\n-  153,153,  2,  2,  2,  2,149,149,149,149,149,149,149,149,149,149,\n-  149,149,149,149,149,149,149,149,149,149,149,149,149,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94,\n-   94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94,\n-   94, 94, 94, 94,  2,  2,  2,  2, 94, 94, 94, 94, 94, 94, 94, 94,\n-   94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2, 94, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85,\n-   85, 85, 85, 85, 85, 85, 85, 85, 85,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2, 85,  2,  2,101,101,101,101,101,101,101,101,101,101,\n-  101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,  2,\n-    2,  2,  2,  2,  2,  2,101,101,101,101,101,101,101,101,101,101,\n-    2,  2,  2,  2,  2,  2, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n-   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,  2, 96, 96, 96, 96,\n-   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,  2,  2,\n-    2,  2,  2,  2,  2,  2,111,111,111,111,111,111,111,111,111,111,\n-  111,111,111,111,111,111,111,111,111,111,111,111,111,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,100,100,100,100,100,100,100,100,100,100,\n-  100,100,100,100,100,100,  2, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,108,108,108,108,108,108,108,108,108,108,\n-  108,108,108,108,108,108,108,108,  2,108,108,108,108,108,108,108,\n-  108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,\n-  108,108,108,108,108,  2,129,129,129,129,129,129,129,  2,129,  2,\n-  129,129,129,129,  2,129,129,129,129,129,129,129,129,129,129,129,\n-  129,129,129,129,  2,129,129,129,129,129,129,129,129,129,129,129,\n-    2,  2,  2,  2,  2,  2,109,109,109,109,109,109,109,109,109,109,\n-  109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,\n-  109,  2,  2,  2,  2,  2,109,109,109,109,109,109,109,109,109,109,\n-    2,  2,  2,  2,  2,  2,107,107,107,107,  2,107,107,107,107,107,\n-  107,107,107,  2,  2,107,107,  2,  2,107,107,107,107,107,107,107,\n-  107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,  2,\n-  107,107,107,107,107,107,107,  2,107,107,  2,107,107,107,107,107,\n-    2,  1,107,107,107,107,107,107,107,107,107,  2,  2,107,107,  2,\n-    2,107,107,107,  2,  2,107,  2,  2,  2,  2,  2,  2,107,  2,  2,\n-    2,  2,  2,107,107,107,107,107,107,107,  2,  2,107,107,107,107,\n-  107,107,107,  2,  2,  2,107,107,107,107,107,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,137,137,137,137,137,137,137,137,137,137,\n-  137,137,137,137,137,137,137,137,137,137,137,137,137,137,137,137,\n-  137,137,  2,137,137,137,137,137,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,124,124,124,124,124,124,124,124,124,124,\n-  124,124,124,124,124,124,124,124,124,124,124,124,124,124,  2,  2,\n-    2,  2,  2,  2,  2,  2,124,124,124,124,124,124,124,124,124,124,\n-    2,  2,  2,  2,  2,  2,123,123,123,123,123,123,123,123,123,123,\n-  123,123,123,123,123,123,123,123,123,123,123,123,  2,  2,123,123,\n-  123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,\n-  123,123,123,123,  2,  2,114,114,114,114,114,114,114,114,114,114,\n-  114,114,114,114,114,114,114,114,114,114,114,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,114,114,114,114,114,114,114,114,114,114,\n-    2,  2,  2,  2,  2,  2, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n-   32, 32, 32,  2,  2,  2,102,102,102,102,102,102,102,102,102,102,\n-  102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,\n-    2,  2,  2,  2,  2,  2,126,126,126,126,126,126,126,126,126,126,\n-  126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,126,\n-  126,  2,  2,126,126,126,126,126,126,126,126,126,126,126,126,126,\n-  126,126,  2,  2,  2,  2,126,126,126,126,126,126,126,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,142,142,142,142,142,142,142,142,142,142,\n-  142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,\n-  142,142,  2,  2,  2,  2,125,125,125,125,125,125,125,125,125,125,\n-  125,125,125,125,125,125,125,125,125,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,125,154,154,154,154,154,154,154,  2,  2,154,\n-    2,  2,154,154,154,154,154,154,154,154,  2,154,154,  2,154,154,\n-  154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,\n-  154,154,154,154,154,154,154,154,154,154,154,154,  2,154,154,  2,\n-    2,154,154,154,154,154,154,154,154,154,154,154,154,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,154,154,154,154,154,154,154,154,154,154,\n-    2,  2,  2,  2,  2,  2,150,150,150,150,150,150,150,150,  2,  2,\n-  150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,\n-  150,150,150,150,150,150,150,150,150,150,150,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,141,141,141,141,141,141,141,141,141,141,\n-  141,141,141,141,141,141,141,141,141,141,141,141,141,141,  2,  2,\n-    2,  2,  2,  2,  2,  2,140,140,140,140,140,140,140,140,140,140,\n-  140,140,140,140,140,140,140,140,140,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,121,121,121,121,121,121,121,121,121,121,\n-  121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,  2,\n-    2,  2,  2,  2,  2,  2,133,133,133,133,133,133,133,133,133,  2,\n-  133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,\n-  133,133,133,133,133,133,133,133,133,133,133,133,133,  2,133,133,\n-  133,133,133,133,133,133,133,133,133,133,133,133,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,133,133,133,133,133,133,133,133,133,133,\n-  133,133,133,  2,  2,  2,134,134,134,134,134,134,134,134,134,134,\n-  134,134,134,134,134,134,  2,  2,134,134,134,134,134,134,134,134,\n-  134,134,134,134,134,134,134,134,134,134,134,134,134,134,  2,134,\n-  134,134,134,134,134,134,134,134,134,134,134,134,134,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,138,138,138,138,138,138,138,  2,138,138,\n-    2,138,138,138,138,138,138,138,138,138,138,138,138,138,138,138,\n-  138,138,138,138,138,138,138,138,138,138,138,138,138,  2,  2,  2,\n-  138,  2,138,138,  2,138,138,138,138,138,138,138,138,138,  2,  2,\n-    2,  2,  2,  2,  2,  2,138,138,138,138,138,138,138,138,138,138,\n-    2,  2,  2,  2,  2,  2,143,143,143,143,143,143,  2,143,143,  2,\n-  143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,\n-  143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,\n-  143,143,143,143,143,  2,143,143,  2,143,143,143,143,143,143,  2,\n-    2,  2,  2,  2,  2,  2,143,143,143,143,143,143,143,143,143,143,\n-    2,  2,  2,  2,  2,  2,145,145,145,145,145,145,145,145,145,145,\n-  145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,  2,\n-    2,  2,  2,  2,  2,  2, 86,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n-   22, 22, 22, 22, 22, 22, 22, 22,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2, 22, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,\n-   63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,\n-    2,  2,  2,  2,  2,  2, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,\n-   63, 63, 63, 63, 63,  2, 63, 63, 63, 63, 63,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 63, 63, 63, 63,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,157,157,157,157,157,157,157,157,157,157,\n-  157,157,157,157,157,157,157,157,157,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80,\n-   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80,\n-   80, 80, 80, 80, 80,  2, 80, 80, 80, 80, 80, 80, 80, 80, 80,  2,\n-    2,  2,  2,  2,  2,  2,127,127,127,127,127,127,127,127,127,127,\n-  127,127,127,127,127,127,127,127,127,127,127,127,127,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 79, 79, 79, 79, 79, 79, 79, 79, 79,  2,\n-    2,  2,  2,  2,  2,  2,115,115,115,115,115,115,115,115,115,115,\n-  115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,115,\n-  115,115,115,115,115,  2,115,115,115,115,115,115,115,115,115,115,\n-    2,  2,  2,  2,115,115,159,159,159,159,159,159,159,159,159,159,\n-  159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,\n-  159,159,159,159,159,  2,159,159,159,159,159,159,159,159,159,159,\n-    2,  2,  2,  2,  2,  2,103,103,103,103,103,103,103,103,103,103,\n-  103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,\n-  103,103,103,103,  2,  2,103,103,103,103,103,103,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,119,119,119,119,119,119,119,119,119,119,\n-  119,119,119,119,119,119,119,119,119,119,119,119,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,119,119,119,119,119,119,119,119,119,119,\n-    2,119,119,119,119,119,119,119,  2,119,119,119,119,119,119,119,\n-  119,119,119,119,119,119,119,119,119,119,119,119,119,119,  2,  2,\n-    2,  2,  2,119,119,119,146,146,146,146,146,146,146,146,146,146,\n-  146,146,146,146,146,146,146,146,146,146,146,146,146,146,146,146,\n-  146,  2,  2,  2,  2,  2, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,\n-   99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,\n-   99,  2,  2,  2,  2, 99, 99, 99, 99, 99, 99, 99, 99, 99,  2,  2,\n-    2,  2,  2,  2,  2, 99,136,139, 13, 13,155,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 13, 13,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,136,136,136,136,136,136,136,136,136,136,\n-  136,136,136,136,136,136,136,136,136,136,136,136,136,136,  2,  2,\n-    2,  2,  2,  2,  2,  2,155,155,155,155,155,155,155,155,155,155,\n-  155,155,155,155,155,155,155,155,155,155,155,155,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,136,136,136,136,136,136,136,136,136,  2,\n-    2,  2,  2,  2,  2,  2, 17, 17, 17, 17,  2, 17, 17, 17, 17, 17,\n-   17, 17,  2, 17, 17,  2, 17, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 15, 15, 17, 17, 17,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 15, 15, 15,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 17, 17, 17, 17,  2,  2,\n-    2,  2,  2,  2,  2,  2,139,139,139,139,139,139,139,139,139,139,\n-  139,139,139,139,139,139,139,139,139,139,139,139,139,139,139,139,\n-  139,139,  2,  2,  2,  2,105,105,105,105,105,105,105,105,105,105,\n-  105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,\n-  105,  2,  2,  2,  2,  2,105,105,105,105,105,105,105,105,105,105,\n-  105,105,105,  2,  2,  2,105,105,105,105,105,105,105,105,105,  2,\n-    2,  2,  2,  2,  2,  2,105,105,105,105,105,105,105,105,105,105,\n-    2,  2,105,105,105,105,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n-    1,  1,  1,  1,  2,  2,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  2,  2,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  1,  1,  1,\n-    1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    1,  1,  1,  1,  0,  0,  9,  9,  9,  9,  9,  9,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,\n-    2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  2,  0,  0,  2,  2,  0,  2,  2,  0,  0,  2,  2,  0,\n-    0,  0,  0,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    2,  0,  2,  0,  0,  0,  0,  0,  0,  0,  2,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  0,  0,  0,\n-    0,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  2,  0,  0,  0,  0,\n-    0,  0,  0,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    2,  0,  0,  0,  0,  2,  0,  0,  0,  0,  0,  2,  0,  2,  2,  2,\n-    0,  0,  0,  0,  0,  0,  0,  2,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  2,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  2,  2,  0,  0,131,131,131,131,131,131,131,131,131,131,\n-  131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,\n-  131,131,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,131,131,131,131,131,  2,131,131,131,131,131,131,131,131,131,\n-  131,131,131,131,131,131, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n-   19, 19, 19, 19, 19,  2, 56, 56, 56, 56, 56, 56, 56,  2, 56, 56,\n-   56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56,  2,\n-    2, 56, 56, 56, 56, 56, 56, 56,  2, 56, 56,  2, 56, 56, 56, 56,\n-   56,  2,  2,  2,  2,  2,151,151,151,151,151,151,151,151,151,151,\n-  151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,\n-  151,151,151,  2,  2,  2,151,151,151,151,151,151,151,151,151,151,\n-  151,151,151,151,  2,  2,151,151,151,151,151,151,151,151,151,151,\n-    2,  2,  2,  2,151,151,160,160,160,160,160,160,160,160,160,160,\n-  160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,\n-  160,160,160,160,160,  2,152,152,152,152,152,152,152,152,152,152,\n-  152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,\n-    2,  2,  2,  2,  2,152, 30, 30, 30, 30, 30, 30, 30,  2, 30, 30,\n-   30, 30,  2, 30, 30,  2, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n-   30, 30, 30, 30, 30,  2,113,113,113,113,113,113,113,113,113,113,\n-  113,113,113,113,113,113,113,113,113,113,113,  2,  2,113,113,113,\n-  113,113,113,113,113,113,113,113,113,113,113,113,113,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,132,132,132,132,132,132,132,132,132,132,\n-  132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,\n-  132,132,  2,  2,  2,  2,132,132,132,132,132,132,132,132,132,132,\n-    2,  2,  2,  2,132,132,  0,  0,  0,  0,  0,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  2,  3,  3,  3,  3,  3,\n-    3,  3,  3,  3,  3,  3,  2,  3,  3,  2,  3,  2,  2,  3,  2,  3,\n-    3,  3,  3,  3,  3,  3,  3,  3,  3,  2,  3,  3,  3,  3,  2,  3,\n-    2,  3,  2,  2,  2,  2,  2,  2,  3,  2,  2,  2,  2,  3,  2,  3,\n-    2,  3,  2,  3,  3,  3,  2,  3,  3,  2,  3,  2,  2,  3,  2,  3,\n-    2,  3,  2,  3,  2,  3,  2,  3,  3,  2,  3,  2,  2,  3,  3,  3,\n-    3,  2,  3,  3,  3,  3,  3,  3,  3,  2,  3,  3,  3,  3,  2,  3,\n-    3,  3,  3,  2,  3,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    3,  3,  2,  2,  2,  2,  2,  3,  3,  3,  2,  3,  3,  3,  3,  3,\n-    2,  3,  3,  3,  3,  3,  3,  3,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 15,  0,  0,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  0,  0,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  2,  2,\n-    2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  2,\n-    2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  2,  2,  2,  0,  0,\n-    0,  0,  0,  2,  2,  2, 13, 13, 13, 13, 13, 13, 13, 13, 13,  2,\n-    2,  2,  2,  2,  2,  2, 13,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n-   13,  2,  2,  2,  2,  2,  2,  0,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  0,  0,  0,  1,  2,  3,  4,  5,  6,  0,\n-    0,  0,  0,  7,  8,  9, 10, 11,  0, 12,  0,  0,  0,  0, 13,  0,\n-    0, 14,  0,  0,  0,  0,  0,  0,  0,  0, 15, 16,  0, 17, 18, 19,\n-    0,  0,  0, 20, 21, 22,  0, 23,  0, 24,  0, 25,  0, 26,  0,  0,\n-    0,  0,  0, 27, 28,  0, 29,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0, 30, 31,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 32, 33,\n-   34, 35, 36, 37, 38, 39, 40,  0,  0,  0, 41,  0, 42, 43, 44, 45,\n-   46, 47, 48,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0, 49,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 50, 51, 52,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 53, 54, 55, 56, 57, 58,\n-   59, 60, 61, 62,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0, 63,  0, 64,  0,  0,  0,  0,  0,\n-    0,  0,  0, 65,  0,  0,  0,  0, 66,  0,  0,  0, 67,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 68,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 69, 70, 71,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    2,  2,  2,  2,  2, 72, 98, 98, 98, 98, 98, 98, 98, 98, 97, 97,\n+   97, 97, 97, 97, 97, 97,  2,  2,  2,  2, 97, 97, 97, 97,  2,  2,\n+   97, 97, 97, 97, 97, 97, 57, 57, 57, 57,  2, 57, 57,  2,  2,  2,\n+    2,  2, 57, 57, 57, 57, 57, 57, 57, 57,  2, 57, 57, 57,  2, 57,\n+   57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,\n+   57, 57, 57, 57,  2,  2, 57, 57, 57,  2,  2,  2,  2, 57, 57,  2,\n+    2,  2,  2,  2,  2,  2, 88, 88, 88, 88, 88, 88, 88, 88,117,117,\n+  117,117,117,117,117,117,112,112,112,112,112,112,112,112,112,112,\n+  112,112,112,112,112,  2,  2,  2,  2,112,112,112,112,112, 78, 78,\n+   78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,  2,  2,  2, 78,\n+   78, 78, 78, 78, 78, 78, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83,\n+   83, 83, 83, 83,  2,  2, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82,\n+   82,  2,  2,  2,  2,  2,122,122,122,122,122,122,122,122,122,122,\n+    2,  2,  2,  2,  2,  2,  2,122,122,122,122,  2,  2,  2,  2,122,\n+  122,122,122,122,122,122, 89, 89, 89, 89, 89, 89, 89, 89, 89,  2,\n+    2,  2,  2,  2,  2,  2,130,130,130,130,130,130,130,130,130,130,\n+  130,  2,  2,  2,  2,  2,  2,  2,130,130,130,130,130,130,144,144,\n+  144,144,144,144,144,144,144,144,  2,  2,  2,  2,  2,  2,156,156,\n+  156,156,156,156,156,156,156,156,  2,156,156,156,  2,  2,156,156,\n+    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  3,  3,  3,147,147,\n+  147,147,147,147,147,147,148,148,148,148,148,148,148,148,148,148,\n+    2,  2,  2,  2,  2,  2,158,158,158,158,158,158,158,158,158,158,\n+    2,  2,  2,  2,  2,  2,153,153,153,153,153,153,153,153,153,153,\n+  153,153,  2,  2,  2,  2,149,149,149,149,149,149,149,149,149,149,\n+  149,149,149,149,149,  2, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94,\n+   94, 94, 94, 94,  2,  2,  2,  2, 94, 94, 94, 94, 94, 94,  2,  2,\n+    2,  2,  2,  2,  2, 94, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85,\n+   85,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 85,  2,  2,101,101,\n+  101,101,101,101,101,101,101,  2,  2,  2,  2,  2,  2,  2,101,101,\n+    2,  2,  2,  2,  2,  2, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n+   96, 96, 96,  2, 96, 96,111,111,111,111,111,111,111,111,111,111,\n+  111,111,111,111,111,  2,100,100,100,100,100,100,100,100,  2, 36,\n+   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,  2,  2,  2,108,108,\n+  108,108,108,108,108,108,108,108,  2,108,108,108,108,108,108,108,\n+    2,  2,  2,  2,  2,  2,129,129,129,129,129,129,129,  2,129,  2,\n+  129,129,129,129,  2,129,129,129,129,129,129,129,129,129,129,129,\n+  129,129,129,129,  2,129,129,129,  2,  2,  2,  2,  2,  2,109,109,\n+  109,109,109,109,109,109,109,109,109,  2,  2,  2,  2,  2,109,109,\n+    2,  2,  2,  2,  2,  2,107,107,107,107,  2,107,107,107,107,107,\n+  107,107,107,  2,  2,107,107,  2,  2,107,107,107,107,107,107,107,\n+  107,107,107,107,107,107,107,  2,107,107,107,107,107,107,107,  2,\n+  107,107,  2,107,107,107,107,107,  2,  1,107,107,107,107,107,  2,\n+    2,107,107,107,  2,  2,107,  2,  2,  2,  2,  2,  2,107,  2,  2,\n+    2,  2,  2,107,107,107,107,107,107,107,  2,  2,107,107,107,107,\n+  107,107,107,  2,  2,  2,137,137,137,137,137,137,137,137,137,137,\n+  137,137,  2,137,137,137,137,137,  2,  2,  2,  2,  2,  2,124,124,\n+  124,124,124,124,124,124,124,124,  2,  2,  2,  2,  2,  2,123,123,\n+  123,123,123,123,123,123,123,123,123,123,123,123,  2,  2,114,114,\n+  114,114,114,114,114,114,114,114,114,114,114,  2,  2,  2,114,114,\n+    2,  2,  2,  2,  2,  2, 32, 32, 32, 32, 32,  2,  2,  2,102,102,\n+  102,102,102,102,102,102,102,102,  2,  2,  2,  2,  2,  2,126,126,\n+  126,126,126,126,126,126,126,126,126,  2,  2,126,126,126,126,126,\n+  126,126,  2,  2,  2,  2,126,126,126,126,126,126,126,  2,142,142,\n+  142,142,142,142,142,142,142,142,142,142,  2,  2,  2,  2,125,125,\n+  125,125,125,125,125,125,125,125,125,  2,  2,  2,  2,  2,  2,  2,\n+    2,  2,  2,  2,  2,125,154,154,154,154,154,154,154,  2,  2,154,\n+    2,  2,154,154,154,154,154,154,154,154,  2,154,154,  2,154,154,\n+  154,154,154,154,154,154,154,154,154,154,154,154,  2,154,154,  2,\n+    2,154,154,154,154,154,154,154,  2,  2,  2,  2,  2,  2,150,150,\n+  150,150,150,150,150,150,  2,  2,150,150,150,150,150,150,150,150,\n+  150,150,150,  2,  2,  2,141,141,141,141,141,141,141,141,140,140,\n+  140,140,140,140,140,140,140,140,140,  2,  2,  2,  2,  2,121,121,\n+  121,121,121,121,121,121,121,  2,  2,  2,  2,  2,  2,  2,  7,  7,\n+    2,  2,  2,  2,  2,  2,133,133,133,133,133,133,133,133,133,  2,\n+  133,133,133,133,133,133,133,133,133,133,133,133,133,  2,133,133,\n+  133,133,133,133,  2,  2,133,133,133,133,133,  2,  2,  2,134,134,\n+  134,134,134,134,134,134,  2,  2,134,134,134,134,134,134,  2,134,\n+  134,134,134,134,134,134,134,134,134,134,134,134,134,  2,138,138,\n+  138,138,138,138,138,  2,138,138,  2,138,138,138,138,138,138,138,\n+  138,138,138,138,138,138,  2,  2,138,  2,138,138,  2,138,138,138,\n+    2,  2,  2,  2,  2,  2,143,143,143,143,143,143,  2,143,143,  2,\n+  143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,\n+  143,143,143,143,143,  2,143,143,  2,143,143,143,143,143,143,  2,\n+    2,  2,  2,  2,  2,  2,143,143,  2,  2,  2,  2,  2,  2,145,145,\n+  145,145,145,145,145,145,145,  2,  2,  2,  2,  2,  2,  2,163,163,\n+  163,163,163,163,163,163,163,  2,163,163,163,163,163,163,163,163,\n+  163,  2,  2,  2,163,163,163,163,  2,  2,  2,  2,  2,  2, 86,  2,\n+    2,  2,  2,  2,  2,  2, 22, 22,  2,  2,  2,  2,  2,  2,  2,  2,\n+    2,  2,  2,  2,  2, 22, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,\n+    2,  2,  2,  2,  2,  2, 63, 63, 63, 63, 63, 63, 63,  2, 63, 63,\n+   63, 63, 63,  2,  2,  2, 63, 63, 63, 63,  2,  2,  2,  2,157,157,\n+  157,157,157,157,157,157,157,157,157,  2,  2,  2,  2,  2, 80, 80,\n+   80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80,  2,  2,127,127,\n+  127,127,127,127,127,127,127,127,127,127,127,127,127,  2, 79,  2,\n+    2,  2,  2,  2,  2,  2,115,115,115,115,115,115,115,115,115,115,\n+  115,115,115,115,115,  2,115,115,  2,  2,  2,  2,115,115,159,159,\n+  159,159,159,159,159,159,159,159,159,159,159,159,159,  2,159,159,\n+    2,  2,  2,  2,  2,  2,103,103,103,103,103,103,103,103,103,103,\n+  103,103,103,103,  2,  2,119,119,119,119,119,119,119,119,119,119,\n+  119,119,119,119,  2,  2,119,119,  2,119,119,119,119,119,  2,  2,\n+    2,  2,  2,119,119,119,146,146,146,146,146,146,146,146,146,146,\n+  146,  2,  2,  2,  2,  2, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,\n+   99,  2,  2,  2,  2, 99,  2,  2,  2,  2,  2,  2,  2, 99,136,139,\n+   13, 13,155,  2,  2,  2,136,136,136,136,136,136,136,136,155,155,\n+  155,155,155,155,155,155,155,155,155,155,155,155,  2,  2,136,  2,\n+    2,  2,  2,  2,  2,  2, 17, 17, 17, 17,  2, 17, 17, 17, 17, 17,\n+   17, 17,  2, 17, 17,  2, 17, 15, 15, 15, 15, 15, 15, 15, 17, 17,\n+   17,  2,  2,  2,  2,  2,  2,  2, 15,  2,  2,  2,  2,  2, 15, 15,\n+   15,  2,  2, 17,  2,  2,  2,  2,  2,  2, 17, 17, 17, 17,139,139,\n+  139,139,139,139,139,139,139,139,139,139,  2,  2,  2,  2,105,105,\n+  105,105,105,105,105,105,105,105,105,  2,  2,  2,  2,  2,105,105,\n+  105,105,105,  2,  2,  2,105,  2,  2,  2,  2,  2,  2,  2,105,105,\n+    2,  2,105,105,105,105,  1,  1,  1,  1,  1,  1,  2,  2,  0,  0,\n+    0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  1,  1,  1,\n+    1,  1,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  0,  0,  2,  2,\n+    0,  2,  2,  0,  0,  2,  2,  0,  0,  0,  0,  2,  0,  0,  0,  0,\n+    2,  0,  2,  0,  0,  0,  0,  0,  0,  0,  2,  0,  0,  0,  0,  0,\n+    0,  2,  2,  0,  0,  0,  0,  0,  2,  0,  0,  0,  0,  2,  0,  0,\n+    0,  0,  0,  2,  0,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  2,\n+    0,  0,  0,  0,  0,  0,131,131,131,131,131,131,131,131,131,131,\n+  131,131,  2,  2,  2,  2,  2,  2,  2,131,131,131,131,131,  2,131,\n+  131,131,131,131,131,131,  2,  2,  2,  2,  2, 19, 19, 19, 56, 56,\n+   56, 56, 56, 56, 56,  2, 56,  2,  2, 56, 56, 56, 56, 56, 56, 56,\n+    2, 56, 56,  2, 56, 56, 56, 56, 56,  2,  2,  2,  2,  2,  6,  6,\n+    6,  6,  6,  6,  2,  2,  2,  2,  2,  2,  2,  2,  2,  6,151,151,\n+  151,151,151,151,151,151,151,151,151,151,151,  2,  2,  2,151,151,\n+  151,151,151,151,  2,  2,151,151,  2,  2,  2,  2,151,151,160,160,\n+  160,160,160,160,160,160,160,160,160,160,160,160,160,  2,152,152,\n+  152,152,152,152,152,152,152,152,  2,  2,  2,  2,  2,152,164,164,\n+  164,164,164,164,164,164,164,164,  2,  2,  2,  2,  2,  2, 30, 30,\n+   30, 30,  2, 30, 30,  2,113,113,113,113,113,113,113,113,113,113,\n+  113,113,113,  2,  2,113,113,113,113,113,113,113,113,  2,132,132,\n+  132,132,132,132,132,132,132,132,132,132,  2,  2,  2,  2,132,132,\n+    2,  2,  2,  2,132,132,  3,  3,  3,  3,  2,  3,  3,  3,  2,  3,\n+    3,  2,  3,  2,  2,  3,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n+    3,  2,  3,  3,  3,  3,  2,  3,  2,  3,  2,  2,  2,  2,  2,  2,\n+    3,  2,  2,  2,  2,  3,  2,  3,  2,  3,  2,  3,  3,  3,  2,  3,\n+    2,  3,  2,  3,  2,  3,  2,  3,  3,  3,  3,  2,  3,  2,  3,  3,\n+    2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  2,  2,  2,  2,  2,  3,\n+    3,  3,  2,  3,  3,  3,  2,  2,  2,  2,  2,  2,  0,  0, 15,  0,\n+    0,  2,  2,  2,  2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  2,  2,\n+    2,  0,  0,  0,  0,  0, 13,  2,  2,  2,  2,  2,  2,  2, 13, 13,\n+   13,  2,  2,  2,  2,  2,  2,  0,  2,  2,  2,  2,  2,  2,  0,  1,\n+    2,  3,  4,  5,  6,  7,  8,  9,  9,  9,  9, 10,  9, 11, 12, 13,\n+    9,  9,  9, 14,  9,  9, 15,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 16, 17,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9, 18, 19, 20,  9, 21,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9, 22,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 23, 24,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,\n+    9, 10, 11, 12,  0,  0, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n@@ -3128,0 +2144,4 @@\n+   23,  0,  0, 24, 25, 26, 27, 28, 29, 30,  0,  0, 31, 32,  0, 33,\n+    0, 34,  0, 35,  0,  0,  0,  0, 36, 37, 38, 39,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 40,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0, 41, 42,  0,  0,  0,  0,  0,  0,\n@@ -3129,0 +2149,6 @@\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43, 44,\n+    0, 45,  0,  0,  0,  0,  0,  0, 46, 47,  0,  0,  0,  0,  0, 48,\n+    0, 49,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+   50, 51,  0,  0,  0, 52,  0,  0, 53,  0,  0,  0,  0,  0,  0,  0,\n+   54,  0,  0,  0,  0,  0,  0,  0, 55,  0,  0,  0,  0,  0,  0,  0,\n+   56,  0,  0,  0,  0,  0,  0,  0,  0, 57,  0,  0,  0,  0,  0,  0,\n@@ -3130,0 +2156,1 @@\n+   58, 59, 60, 61, 62, 63, 64, 65,  0,  0,  0,  0,  0,  0, 66,  0,\n@@ -3134,0 +2161,7 @@\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 67, 68,  0, 69,\n+   70,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 71, 72, 73, 74,\n+   75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,\n+   91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,104,  0,\n+    0,  0,  0,  0,  0,105,106,  0,107,  0,  0,  0,108,  0,109,  0,\n+  110,  0,111,112,113,  0,114,  0,  0,  0,115,  0,  0,  0,116,  0,\n@@ -3135,0 +2169,1 @@\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,117,  0,  0,  0,  0,  0,  0,\n@@ -3136,0 +2171,1 @@\n+  118,119,120,121,  0,122,123,124,125,126,  0,127,  0,  0,  0,  0,\n@@ -3137,0 +2173,5 @@\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,128,129,130,131,\n+  132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,\n+  148,149,150,151,152,153,154,155,156,157,  0,  0,  0,158,159,160,\n+  161,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,162,163,  0,  0,  0,  0,  0,  0,  0,164,  0,\n@@ -3139,0 +2180,4 @@\n+  165,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,166,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,167,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,168,\n@@ -3141,0 +2186,3 @@\n+    0,169,170,  0,  0,  0,  0,171,172,  0,  0,  0,173,174,175,176,\n+  177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,\n+  193,194,195,196,197,198,199,200,201,202,203,204,205,206,  0,  0,\n@@ -3142,1 +2190,1 @@\n-    0,  0,  0,  0,  0,  0, 72, 73, 74, 75, 76, 77, 78, 79, 80,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,\n@@ -3145,1 +2193,1 @@\n-_hb_ucd_u16[11584] =\n+_hb_ucd_u16[9320] =\n@@ -3164,5 +2212,3 @@\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48, 168, 169,  48,  48, 168,  48,  48, 170, 171, 172,  48,  48,\n-    48, 171,  48,  48,  48, 173, 174, 175,  48, 176,   9,   9,   9,   9,   9, 177,\n-   178,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n+    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 168, 169,  48,  48,\n+   168,  48,  48, 170, 171, 172,  48,  48,  48, 171,  48,  48,  48, 173, 174, 175,\n+    48, 176,   9,   9,   9,   9,   9, 177, 178,  48,  48,  48,  48,  48,  48,  48,\n@@ -3181,5 +2227,4 @@\n-   279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279,\n-   280, 209, 281, 209, 209, 209, 209, 282, 209, 283, 279, 284, 209, 285, 286, 209,\n-   209, 209, 287, 140, 288, 140, 271, 271, 271, 289, 209, 209, 209, 209, 290, 271,\n-   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 291, 292, 209, 209, 293,\n-   209, 209, 209, 209, 209, 209, 294, 209, 209, 209, 209, 209, 209, 209, 209, 209,\n+   279, 279, 279, 279, 279, 279, 279, 279, 280, 209, 281, 209, 209, 209, 209, 282,\n+   209, 283, 279, 284, 209, 285, 286, 209, 209, 209, 287, 140, 288, 140, 271, 271,\n+   271, 289, 209, 209, 209, 209, 290, 271, 209, 209, 209, 209, 209, 209, 209, 209,\n+   209, 209, 209, 291, 292, 209, 209, 293, 209, 209, 209, 209, 209, 209, 294, 209,\n@@ -3187,8 +2232,5 @@\n-   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209,\n-   279, 279, 279, 279, 279, 279, 279, 279, 300, 301, 279, 279, 279, 302, 279, 303,\n-   279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279,\n-   209, 209, 209, 279, 304, 209, 209, 305, 209, 306, 209, 209, 209, 209, 209, 209,\n-     9,   9,   9,  11,  11,  11, 307, 308,  13,  13,  13,  13,  13,  13, 309, 310,\n-    11,  11, 311,  48,  48,  48, 312, 313,  48, 314, 315, 315, 315, 315,  32,  32,\n-   316, 317, 318, 319, 320, 321, 140, 140, 209, 322, 209, 209, 209, 209, 209, 323,\n-   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 324, 140, 325,\n+   300, 301, 279, 279, 279, 302, 279, 303, 209, 209, 209, 279, 304, 209, 209, 305,\n+   209, 306, 209, 209, 209, 209, 209, 209,   9,   9,   9,  11,  11,  11, 307, 308,\n+    13,  13,  13,  13,  13,  13, 309, 310,  11,  11, 311,  48,  48,  48, 312, 313,\n+    48, 314, 315, 315, 315, 315,  32,  32, 316, 317, 318, 319, 320, 321, 140, 140,\n+   209, 322, 209, 209, 209, 209, 209, 323, 209, 209, 209, 209, 209, 324, 140, 325,\n@@ -3198,23 +2240,9 @@\n-   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 209, 209, 209, 209,\n-    48, 338,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48,  48,  48,  48,  48, 151, 209, 209, 209, 287,  48,  48, 229,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-   339,  48, 340, 140,  13,  13, 341, 342,  13, 343,  48,  48,  48,  48, 344, 345,\n-    31, 346, 347, 348,  13,  13,  13, 349, 350, 351, 352, 353, 354, 355, 140, 356,\n-   357,  48, 358, 359,  48,  48,  48, 360, 361,  48,  48, 362, 363, 192,  32, 364,\n-    64,  48, 365,  48, 366, 367,  48, 151,  76,  48,  48, 368, 369, 370, 371, 372,\n-    48,  48, 373, 374, 375, 376,  48, 377,  48,  48,  48, 378, 379, 380, 381, 382,\n-   383, 384, 315,  11,  11, 385, 386,  11,  11,  11,  11,  11,  48,  48, 387, 192,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 388,  48, 389,  48,  48, 206,\n-   390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390,\n-   390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390,\n-   391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391,\n-   391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391,\n-   391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n+    48,  48,  48,  48, 209, 209, 209, 209,  48, 338,  48,  48,  48,  48,  48,  48,\n+   151, 209, 209, 209, 287,  48,  48, 229, 339,  48, 340, 140,  13,  13, 341, 342,\n+    13, 343,  48,  48,  48,  48, 344, 345,  31, 346, 347, 348,  13,  13,  13, 349,\n+   350, 351, 352, 353, 354, 355, 140, 356, 357,  48, 358, 359,  48,  48,  48, 360,\n+   361,  48,  48, 362, 363, 192,  32, 364,  64,  48, 365,  48, 366, 367,  48, 151,\n+    76,  48,  48, 368, 369, 370, 371, 372,  48,  48, 373, 374, 375, 376,  48, 377,\n+    48,  48,  48, 378, 379, 380, 381, 382, 383, 384, 315,  11,  11, 385, 386,  11,\n+    11,  11,  11,  11,  48,  48, 387, 192,  48,  48, 388,  48, 389,  48,  48, 206,\n+   390, 390, 390, 390, 390, 390, 390, 390, 391, 391, 391, 391, 391, 391, 391, 391,\n@@ -3223,1 +2251,0 @@\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n@@ -3233,1 +2260,0 @@\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n@@ -3240,586 +2266,319 @@\n-    48,  48, 475, 192, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 271, 476,  48,  48, 477, 478, 140, 140, 140, 140,\n-    48, 464, 479,  48,  62, 480, 140,  48, 481, 140, 140,  48, 482, 140,  48, 314,\n-   483,  48,  48, 484, 485, 457, 486, 487, 222,  48,  48, 488, 489,  48, 196, 192,\n-   490,  48, 491, 492, 493,  48,  48, 494, 222,  48,  48, 495, 496, 497, 498, 499,\n-    48,  97, 500, 501, 140, 140, 140, 140, 502, 503, 504,  48,  48, 505, 506, 192,\n-   507,  83,  84, 508, 509, 510, 511, 512, 140, 140, 140, 140, 140, 140, 140, 140,\n-    48,  48,  48, 513, 514, 515, 478, 140,  48,  48,  48, 516, 517, 192, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140,  48,  48, 518, 519, 520, 521, 140, 140,\n-    48,  48,  48, 522, 523, 192, 524, 140,  48,  48, 525, 526, 192, 140, 140, 140,\n-    48, 173, 527, 528, 314, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-    48,  48, 500, 529, 140, 140, 140, 140, 140, 140,   9,   9,  11,  11, 148, 530,\n-   531, 532,  48, 533, 534, 192, 140, 140, 140, 140, 535,  48,  48, 536, 537, 140,\n-   538,  48,  48, 539, 540, 541,  48,  48, 542, 543, 544,  48,  48,  48,  48, 196,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-    84,  48, 518, 545, 546, 148, 175, 547,  48, 548, 549, 550, 140, 140, 140, 140,\n-   551,  48,  48, 552, 553, 192, 554,  48, 555, 556, 192, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,  48, 557,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 100, 271, 558, 559, 560,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48, 207, 140, 140, 140, 140, 140, 140,\n-   272, 272, 272, 272, 272, 272, 561, 562,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48, 388, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140,  48,  48,  48,  48,  48,  48, 563,\n-    48,  48, 200, 564, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-    48,  48,  48,  48, 314, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-    48,  48,  48, 196,  48, 200, 370,  48,  48,  48,  48, 200, 192,  48, 204, 565,\n-    48,  48,  48, 566, 567, 568, 569, 570,  48, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140,   9,   9,  11,  11, 271, 571, 140, 140, 140, 140, 140, 140,\n-    48,  48,  48,  48, 572, 573, 574, 574, 575, 576, 140, 140, 140, 140, 577, 578,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 440,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 199, 140, 140,\n-   196, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 579,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48, 580, 140, 140, 580, 581,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 206,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-    48,  48,  48,  48,  48,  48,  71, 151, 196, 582, 583, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-    32,  32, 584,  32, 585, 209, 209, 209, 209, 209, 209, 209, 323, 140, 140, 140,\n-   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 324,\n-   209, 209, 586, 209, 209, 209, 587, 588, 589, 209, 590, 209, 209, 209, 288, 140,\n-   209, 209, 209, 209, 591, 140, 140, 140, 140, 140, 140, 140, 140, 140, 271, 592,\n-   209, 209, 209, 209, 209, 287, 271, 461, 140, 140, 140, 140, 140, 140, 140, 140,\n-     9, 593,  11, 594, 595, 596, 241,   9, 597, 598, 599, 600, 601,   9, 593,  11,\n-   602, 603,  11, 604, 605, 606, 607,   9, 608,  11,   9, 593,  11, 594, 595,  11,\n-   241,   9, 597, 607,   9, 608,  11,   9, 593,  11, 609,   9, 610, 611, 612, 613,\n-    11, 614,   9, 615, 616, 617, 618,  11, 619,   9, 620,  11, 621, 622, 622, 622,\n-   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209,\n-   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209,\n-    32,  32,  32, 623,  32,  32, 624, 625, 626, 627,  45, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   628, 629, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   630, 631, 632, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-    48,  48, 151, 633, 634, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140,  48, 635, 140,  48,  48, 636, 637,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 638, 200,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 639, 585, 140, 140,\n-     9,   9, 597,  11, 640, 370, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 498, 271, 271, 641, 642, 140, 140, 140, 140,\n-   498, 271, 643, 644, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   645,  48, 646, 647, 648, 649, 650, 651, 652, 206, 653, 206, 140, 140, 140, 654,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   209, 209, 325, 209, 209, 209, 209, 209, 209, 323, 334, 655, 655, 655, 209, 324,\n-   656, 209, 209, 209, 209, 209, 209, 209, 209, 209, 657, 140, 140, 140, 658, 209,\n-   659, 209, 209, 325, 660, 661, 324, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 662,\n-   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 663, 426, 426,\n-   209, 209, 209, 209, 209, 209, 209, 323, 209, 209, 209, 209, 209, 660, 325, 427,\n-   325, 209, 209, 209, 664, 176, 209, 209, 664, 209, 657, 661, 140, 140, 140, 140,\n-   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209,\n-   209, 209, 209, 209, 209, 323, 657, 665, 287, 209, 426, 288, 324, 176, 664, 287,\n-   209, 209, 209, 209, 209, 209, 209, 209, 209, 666, 209, 209, 288, 140, 140, 192,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 140, 140,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48, 196,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48, 204,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 478,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 100, 140,\n-    48, 204, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48,  71, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n-   667, 140, 668, 668, 668, 668, 668, 668, 140, 140, 140, 140, 140, 140, 140, 140,\n-    32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 140,\n-   391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391,\n-   391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 669,\n-   391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391,\n-   391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 670,\n-     0,   0,   0,   0,   1,   2,   1,   2,   0,   0,   3,   3,   4,   5,   4,   5,\n-     4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,\n-     4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   6,   0,   0,   7,   0,\n-     8,   8,   8,   8,   8,   8,   8,   9,  10,  11,  12,  11,  11,  11,  13,  11,\n-    14,  14,  14,  14,  14,  14,  14,  14,  15,  14,  14,  14,  14,  14,  14,  14,\n-    14,  14,  14,  16,  17,  18,  17,  17,  19,  20,  21,  21,  22,  21,  23,  24,\n-    25,  26,  27,  27,  28,  29,  27,  30,  27,  27,  27,  27,  27,  31,  27,  27,\n-    32,  33,  33,  33,  34,  27,  27,  27,  35,  35,  35,  36,  37,  37,  37,  38,\n-    39,  39,  40,  41,  42,  43,  44,  27,  45,  46,  27,  27,  27,  27,  47,  27,\n-    48,  48,  48,  48,  48,  49,  50,  48,  51,  52,  53,  54,  55,  56,  57,  58,\n-    59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,\n-    75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,\n-    91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106,\n-   107, 108, 109, 109, 110, 111, 112, 109, 113, 114, 115, 116, 117, 118, 119, 120,\n-   121, 122, 122, 123, 122, 124, 125, 125, 126, 127, 128, 129, 130, 131, 125, 125,\n-   132, 132, 132, 132, 133, 132, 134, 135, 132, 133, 132, 136, 136, 137, 125, 125,\n-   138, 138, 138, 138, 138, 138, 138, 138, 138, 138, 139, 139, 140, 139, 139, 141,\n-   142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n-   143, 143, 143, 143, 144, 145, 143, 143, 144, 143, 143, 146, 147, 148, 143, 143,\n-   143, 147, 143, 143, 143, 149, 143, 150, 143, 151, 152, 152, 152, 152, 152, 153,\n-   154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154,\n-   154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154,\n-   154, 154, 154, 154, 154, 154, 154, 154, 155, 156, 157, 157, 157, 157, 158, 159,\n-   160, 161, 162, 163, 164, 165, 166, 167, 168, 168, 168, 168, 168, 169, 170, 170,\n-   171, 172, 173, 173, 173, 173, 173, 174, 173, 173, 175, 154, 154, 154, 154, 176,\n-   177, 178, 179, 179, 180, 181, 182, 183, 184, 184, 185, 184, 186, 187, 168, 168,\n-   188, 189, 190, 190, 190, 191, 190, 192, 193, 193, 194,   8, 195, 125, 125, 125,\n-   196, 196, 196, 196, 197, 196, 196, 198, 199, 199, 199, 199, 200, 200, 200, 201,\n-   202, 202, 202, 203, 204, 205, 205, 205, 206, 139, 139, 207, 208, 209, 210, 211,\n-     4,   4, 212,   4,   4, 213, 214, 215,   4,   4,   4, 216,   8,   8,   8,   8,\n-     4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,\n-    11, 217,  11,  11, 217, 218,  11, 219,  11,  11,  11, 220, 220, 221,  11, 222,\n-   223,   0,   0,   0,   0,   0, 224, 225, 226, 227,   0,   0, 228,   8,   8, 229,\n-     0,   0, 230, 231, 232,   0,   4,   4, 233,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0, 234, 125, 235, 125,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-   236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0, 237,   0, 238,   0,   0,   0,   0,   0,   0,\n-   239, 239, 239, 239, 239, 239,   4,   4, 240, 240, 240, 240, 240, 240, 240, 241,\n-   139, 139, 140, 242, 242, 242, 243, 244, 143, 245, 246, 246, 246, 246,  14,  14,\n-     0,   0,   0,   0,   0, 247, 125, 125, 248, 249, 248, 248, 248, 248, 248, 250,\n-   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 251, 125, 252,\n-   253,   0, 254, 255, 256, 257, 257, 257, 257, 258, 259, 260, 260, 260, 260, 261,\n-   262, 263, 263, 264, 142, 142, 142, 142, 265,   0, 263, 263,   0,   0, 266, 260,\n-   142, 265,   0,   0,   0,   0, 142, 267,   0,   0,   0,   0,   0, 260, 260, 268,\n-   260, 260, 260, 260, 260, 269,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n-   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n-   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n-   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,   0,   0,   0,   0,\n-   270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270,\n-   270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270,\n-   270, 270, 270, 270, 270, 270, 270, 270, 271, 270, 270, 270, 272, 273, 273, 273,\n-   274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274,\n-   274, 274, 275, 125,  14,  14,  14,  14,  14,  14, 276, 276, 276, 276, 276, 277,\n-     0,   0, 278,   4,   4,   4,   4,   4, 279,   4,   4,   4, 280, 281, 125, 282,\n-   283, 283, 284, 285, 286, 286, 286, 287, 288, 288, 288, 288, 289, 290,  48,  48,\n-   291, 291, 292, 293, 293, 294, 142, 295, 296, 296, 296, 296, 297, 298, 138, 299,\n-   300, 300, 300, 301, 302, 303, 138, 138, 304, 304, 304, 304, 305, 306, 307, 308,\n-   309, 310, 246,   4,   4, 311, 312, 152, 152, 152, 152, 152, 307, 307, 313, 314,\n-   142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n-   142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n-   142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n-   142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 315, 142, 316, 142, 142, 317,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n-   248, 248, 248, 248, 248, 248, 318, 248, 248, 248, 248, 248, 248, 319, 125, 125,\n-   320, 321,  21, 322, 323,  27,  27,  27,  27,  27,  27,  27, 324, 325,  27,  27,\n-    27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,\n-    27,  27,  27, 326,  27,  27,  27,  27,  27, 327,  27,  27, 328, 125, 125,  27,\n-     8, 285, 329,   0,   0, 330, 331, 332,  27,  27,  27,  27,  27,  27,  27, 333,\n-   334,   0,   1,   2,   1,   2, 335, 259, 260, 336, 142, 265, 337, 338, 339, 340,\n-   341, 342, 343, 344, 345, 345, 125, 125, 342, 342, 342, 342, 342, 342, 342, 346,\n-   347,   0,   0, 348,  11,  11,  11,  11, 349, 350, 351, 125, 125,   0,   0, 352,\n-   125, 125, 125, 125, 125, 125, 125, 125, 353, 354, 355, 355, 355, 356, 357, 252,\n-   358, 358, 359, 360, 361, 362, 362, 363, 364, 365, 366, 366, 367, 368, 125, 125,\n-   369, 369, 369, 369, 369, 370, 370, 370, 371, 372, 373, 374, 374, 375, 374, 376,\n-   377, 377, 378, 379, 379, 379, 380, 381, 381, 382, 383, 384, 125, 125, 125, 125,\n-   385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385,\n-   385, 385, 385, 386, 385, 387, 388, 125, 389,   4,   4, 390, 125, 125, 125, 125,\n-   391, 392, 392, 393, 394, 395, 396, 396, 397, 398, 399, 125, 125, 125, 400, 401,\n-   402, 403, 404, 405, 125, 125, 125, 125, 406, 406, 407, 408, 407, 409, 407, 407,\n-   410, 411, 412, 413, 414, 414, 415, 415, 416, 416, 125, 125, 417, 417, 418, 419,\n-   420, 420, 420, 421, 422, 423, 424, 425, 426, 427, 428, 125, 125, 125, 125, 125,\n-   429, 429, 429, 429, 430, 125, 125, 125, 431, 431, 431, 432, 431, 431, 431, 433,\n-   434, 434, 435, 436, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125,  27,  45, 437, 437, 438, 439, 125, 125, 125, 125,\n-   440, 440, 441, 442, 442, 443, 125, 444, 445, 125, 125, 446, 447, 125, 448, 449,\n-   450, 450, 450, 450, 451, 452, 450, 453, 454, 454, 454, 454, 455, 456, 457, 458,\n-   459, 459, 459, 460, 461, 462, 462, 463, 464, 464, 464, 464, 464, 464, 465, 466,\n-   467, 468, 467, 469, 125, 125, 125, 125, 470, 471, 472, 473, 473, 473, 474, 475,\n-   476, 477, 478, 479, 480, 481, 482, 483, 125, 125, 125, 125, 125, 125, 125, 125,\n-   484, 484, 484, 484, 484, 485, 486, 125, 487, 487, 487, 487, 488, 489, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 490, 490, 490, 491, 490, 492, 125, 125,\n-   493, 493, 493, 493, 494, 495, 496, 125, 497, 497, 497, 498, 498, 125, 125, 125,\n-   499, 500, 501, 499, 502, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   503, 503, 503, 504, 125, 125, 125, 125, 125, 125, 505, 505, 505, 505, 505, 506,\n-   507, 508, 509, 510, 511, 512, 125, 125, 125, 125, 513, 514, 514, 513, 515, 125,\n-   516, 516, 516, 516, 517, 518, 518, 518, 518, 518, 519, 154, 520, 520, 520, 521,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   522, 523, 523, 524, 525, 523, 526, 527, 527, 528, 529, 530, 125, 125, 125, 125,\n-   531, 532, 532, 533, 534, 535, 536, 537, 538, 539, 540, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 541, 542,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 543, 544, 544, 544, 545,\n-   546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546,\n-   546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546,\n-   546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546,\n-   546, 546, 546, 546, 546, 546, 546, 546, 546, 547, 125, 125, 125, 125, 125, 125,\n-   546, 546, 546, 546, 546, 546, 548, 549, 546, 546, 546, 546, 546, 546, 546, 546,\n-   546, 546, 546, 546, 550, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 551, 551, 551, 551, 551, 551, 552,\n-   553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553,\n-   553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553,\n-   553, 553, 554, 555, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556,\n-   556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556,\n-   556, 556, 556, 556, 557, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276,\n-   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276,\n-   276, 276, 276, 558, 559, 560, 561, 562, 562, 562, 562, 563, 564, 565, 566, 567,\n-   568, 568, 568, 568, 569, 570, 571, 572, 568, 125, 125, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 573, 573, 573, 573, 573, 574, 125, 125, 125, 125, 125, 125,\n-   575, 575, 575, 575, 576, 575, 575, 575, 577, 575, 125, 125, 125, 125, 578, 579,\n-   580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580,\n-   580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580,\n-   580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580,\n-   580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 581,\n-   580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580,\n-   582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582,\n-   582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 583, 125, 125,\n-   584, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 585,\n-   586, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257,\n-   257, 257, 587, 125, 125, 588, 589, 590, 590, 590, 590, 590, 590, 590, 590, 590,\n-   590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 591,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   592, 592, 592, 592, 592, 592, 593, 594, 595, 596, 266, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-     8,   8, 597,   8, 598,   0,   0,   0,   0,   0,   0,   0, 266, 125, 125, 125,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 599,\n-     0,   0, 600,   0,   0,   0, 601, 602, 603,   0, 604,   0,   0,   0, 235, 125,\n-    11,  11,  11,  11, 605, 125, 125, 125, 125, 125, 125, 125, 125, 125,   0, 266,\n-     0,   0,   0,   0,   0, 234,   0, 606, 125, 125, 125, 125, 125, 125, 125, 125,\n-     0,   0,   0,   0,   0, 224,   0,   0,   0, 607, 608, 609, 610,   0,   0,   0,\n-   611, 612,   0, 613, 614, 615,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 616,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 617,   0,   0,   0,\n-   618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618,\n-   618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618,\n-   618, 618, 618, 618, 618, 618, 618, 618, 619, 620, 621, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-     4, 622, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   623, 624, 625, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   626, 626, 627, 628, 629, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 630, 631, 125, 632, 632, 632, 633,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 634, 635,\n-   636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 637, 638, 125, 125,\n-   639, 639, 639, 639, 640, 641, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 334,   0,   0,   0, 642, 125, 125, 125, 125,\n-   334,   0,   0, 247, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   643,  27, 644, 645, 646, 647, 648, 649, 650, 651, 652, 651, 125, 125, 125, 653,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-     0,   0, 252,   0,   0,   0,   0,   0,   0, 266, 226, 334, 334, 334,   0, 599,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 247, 125, 125, 125, 654,   0,\n-   655,   0,   0, 252, 606, 656, 599, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 657, 350, 350,\n-     0,   0,   0,   0,   0,   0,   0, 266,   0,   0,   0,   0,   0, 606, 252, 228,\n-   252,   0,   0,   0, 658, 285,   0,   0, 658,   0, 247, 656, 125, 125, 125, 125,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0, 266, 247, 659, 234,   0, 350, 235, 599, 285, 658, 234,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0, 330,   0,   0, 235, 125, 125, 285,\n-   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 125, 125,\n-   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n-   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n-   248, 248, 248, 660, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n-   248, 318, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n-   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n-   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 579, 248, 248, 248, 248, 248,\n-   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n-   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n-   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 661, 125,\n-   248, 318, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n-   248, 248, 248, 248, 662, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n-   663, 125,   0,   0,   0,   0,   0,   0, 125, 125, 125, 125, 125, 125, 125, 125,\n-     8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-   939, 940, 941, 942, 946, 948,   0, 962, 969, 970, 971, 976,1001,1002,1003,1008,\n-     0,1033,1040,1041,1042,1043,1047,   0,   0,1080,1081,1082,1086,1110,   0,   0,\n-  1124,1125,1126,1127,1131,1133,   0,1147,1154,1155,1156,1161,1187,1188,1189,1193,\n-     0,1219,1226,1227,1228,1229,1233,   0,   0,1267,1268,1269,1273,1298,   0,1303,\n-   943,1128, 944,1129, 954,1139, 958,1143, 959,1144, 960,1145, 961,1146, 964,1149,\n-     0,   0, 973,1158, 974,1159, 975,1160, 983,1168, 978,1163, 988,1173, 990,1175,\n-   991,1176, 993,1178, 994,1179,   0,   0,1004,1190,1005,1191,1006,1192,1014,1199,\n-  1007,   0,   0,   0,1016,1201,1020,1206,   0,1022,1208,1025,1211,1023,1209,   0,\n-     0,   0,   0,1032,1218,1037,1223,1035,1221,   0,   0,   0,1044,1230,1045,1231,\n-  1049,1235,   0,   0,1058,1244,1064,1250,1060,1246,1066,1252,1067,1253,1072,1258,\n-  1069,1255,1077,1264,1074,1261,   0,   0,1083,1270,1084,1271,1085,1272,1088,1275,\n-  1089,1276,1096,1283,1103,1290,1111,1299,1115,1118,1307,1120,1309,1121,1310,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-  1053,1239,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1093,\n-  1280,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 949,1134,1010,\n-  1195,1050,1236,1090,1277,1341,1368,1340,1367,1342,1369,1339,1366,   0,1320,1347,\n-  1418,1419,1323,1350,   0,   0, 992,1177,1018,1204,1055,1241,1416,1417,1415,1424,\n-  1202,   0,   0,   0, 987,1172,   0,   0,1031,1217,1321,1348,1322,1349,1338,1365,\n-   950,1135, 951,1136, 979,1164, 980,1165,1011,1196,1012,1197,1051,1237,1052,1238,\n-  1061,1247,1062,1248,1091,1278,1092,1279,1071,1257,1076,1263,   0,   0, 997,1182,\n-     0,   0,   0,   0,   0,   0, 945,1130, 982,1167,1337,1364,1335,1362,1046,1232,\n-  1422,1423,1113,1301,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     8,   9,   0,  10,1425,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,\n-     0,   0,   0,   0,   0,1314,1427,   5,1434,1438,1443,   0,1450,   0,1455,1461,\n-  1514,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1446,1458,1468,1476,1480,1486,\n-  1517,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1489,1503,1494,1500,1508,   0,\n-     0,   0,   0,1520,1521,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-  1526,1528,   0,1525,   0,   0,   0,1522,   0,   0,   0,   0,1536,1532,1539,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1534,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1556,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-  1548,1550,   0,1547,   0,   0,   0,1567,   0,   0,   0,   0,1558,1554,1561,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,1568,1569,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,1529,1551,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-  1523,1545,1524,1546,   0,   0,1527,1549,   0,   0,1570,1571,1530,1552,1531,1553,\n-     0,   0,1533,1555,1535,1557,1537,1559,   0,   0,1572,1573,1544,1566,1538,1560,\n-  1540,1562,1541,1563,1542,1564,   0,   0,1543,1565,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,1606,1607,1609,1608,1610,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-  1613,   0,1611,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,1612,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1620,   0,   0,   0,   0,   0,   0,\n-     0,1623,   0,   0,1624,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,1614,1615,1616,1617,1618,1619,1621,1622,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1628,1629,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1625,1626,   0,1627,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,1634,   0,   0,1635,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1630,1631,1632,   0,   0,1633,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,1639,   0,   0,1638,1640,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1636,1637,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,1641,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1642,1644,1643,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,1645,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-  1646,   0,   0,   0,   0,   0,   0,1648,1649,   0,1647,1650,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1651,1653,1652,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1654,   0,1655,1657,1656,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,1659,   0,   0,   0,   0,   0,   0,   0,   0,   0,1660,   0,   0,\n-     0,   0,1661,   0,   0,   0,   0,1662,   0,   0,   0,   0,1663,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1658,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,1664,   0,1665,1673,   0,1674,   0,   0,   0,   0,   0,   0,   0,\n-     0,1666,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,1668,   0,   0,   0,   0,   0,   0,   0,   0,   0,1669,   0,   0,\n-     0,   0,1670,   0,   0,   0,   0,1671,   0,   0,   0,   0,1672,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1667,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,1675,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,1676,   0,1677,   0,1678,   0,1679,   0,1680,   0,\n-     0,   0,1681,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1682,   0,1683,   0,   0,\n-  1684,1685,   0,1686,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-   953,1138, 955,1140, 956,1141, 957,1142,1324,1351, 963,1148, 965,1150, 968,1153,\n-   966,1151, 967,1152,1378,1380,1379,1381, 984,1169, 985,1170,1420,1421, 986,1171,\n-   989,1174, 995,1180, 998,1183, 996,1181, 999,1184,1000,1185,1015,1200,1329,1356,\n-  1017,1203,1019,1205,1021,1207,1024,1210,1687,1688,1027,1213,1026,1212,1028,1214,\n-  1029,1215,1030,1216,1034,1220,1036,1222,1039,1225,1038,1224,1334,1361,1336,1363,\n-  1382,1384,1383,1385,1056,1242,1057,1243,1059,1245,1063,1249,1689,1690,1065,1251,\n-  1068,1254,1070,1256,1386,1387,1388,1389,1691,1692,1073,1259,1075,1262,1079,1266,\n-  1078,1265,1095,1282,1098,1285,1097,1284,1390,1391,1392,1393,1099,1286,1100,1287,\n-  1101,1288,1102,1289,1105,1292,1104,1291,1106,1294,1107,1295,1108,1296,1114,1302,\n-  1119,1308,1122,1311,1123,1312,1186,1260,1293,1305,   0,1394,   0,   0,   0,   0,\n-   952,1137, 947,1132,1317,1344,1316,1343,1319,1346,1318,1345,1693,1695,1371,1375,\n-  1370,1374,1373,1377,1372,1376,1694,1696, 981,1166, 977,1162, 972,1157,1326,1353,\n-  1325,1352,1328,1355,1327,1354,1697,1698,1009,1194,1013,1198,1054,1240,1048,1234,\n-  1331,1358,1330,1357,1333,1360,1332,1359,1699,1700,1396,1401,1395,1400,1398,1403,\n-  1397,1402,1399,1404,1094,1281,1087,1274,1406,1411,1405,1410,1408,1413,1407,1412,\n-  1409,1414,1109,1297,1117,1306,1116,1304,1112,1300,   0,   0,   0,   0,   0,   0,\n-  1471,1472,1701,1705,1702,1706,1703,1707,1430,1431,1715,1719,1716,1720,1717,1721,\n-  1477,1478,1729,1731,1730,1732,   0,   0,1435,1436,1733,1735,1734,1736,   0,   0,\n-  1481,1482,1737,1741,1738,1742,1739,1743,1439,1440,1751,1755,1752,1756,1753,1757,\n-  1490,1491,1765,1768,1766,1769,1767,1770,1447,1448,1771,1774,1772,1775,1773,1776,\n-  1495,1496,1777,1779,1778,1780,   0,   0,1451,1452,1781,1783,1782,1784,   0,   0,\n-  1504,1505,1785,1788,1786,1789,1787,1790,   0,1459,   0,1791,   0,1792,   0,1793,\n-  1509,1510,1794,1798,1795,1799,1796,1800,1462,1463,1808,1812,1809,1813,1810,1814,\n-  1467,  21,1475,  22,1479,  23,1485,  24,1493,  27,1499,  28,1507,  29,   0,   0,\n-  1704,1708,1709,1710,1711,1712,1713,1714,1718,1722,1723,1724,1725,1726,1727,1728,\n-  1740,1744,1745,1746,1747,1748,1749,1750,1754,1758,1759,1760,1761,1762,1763,1764,\n-  1797,1801,1802,1803,1804,1805,1806,1807,1811,1815,1816,1817,1818,1819,1820,1821,\n-  1470,1469,1822,1474,1465,   0,1473,1825,1429,1428,1426,  12,1432,   0,  26,   0,\n-     0,1315,1823,1484,1466,   0,1483,1829,1433,  13,1437,  14,1441,1826,1827,1828,\n-  1488,1487,1513,  19,   0,   0,1492,1515,1445,1444,1442,  15,   0,1831,1832,1833,\n-  1502,1501,1516,  25,1497,1498,1506,1518,1457,1456,1454,  17,1453,1313,  11,   3,\n-     0,   0,1824,1512,1519,   0,1511,1830,1449,  16,1460,  18,1464,   4,   0,   0,\n-    30,  31,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,  20,   0,   0,   0,   2,   6,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1834,1835,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1836,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1837,1839,1838,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,1840,   0,   0,   0,   0,1841,   0,   0,1842,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,1843,   0,1844,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,1845,   0,   0,1846,   0,   0,1847,   0,1848,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-   937,   0,1850,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1849, 936, 938,\n-  1851,1852,   0,   0,1853,1854,   0,   0,1855,1856,   0,   0,   0,   0,   0,   0,\n-  1857,1858,   0,   0,1861,1862,   0,   0,1863,1864,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1867,1868,1869,1870,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-  1859,1860,1865,1866,   0,   0,   0,   0,   0,   0,1871,1872,1873,1874,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,  32,  33,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1875,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1877,   0,1878,   0,\n-  1879,   0,1880,   0,1881,   0,1882,   0,1883,   0,1884,   0,1885,   0,1886,   0,\n-  1887,   0,1888,   0,   0,1889,   0,1890,   0,1891,   0,   0,   0,   0,   0,   0,\n-  1892,1893,   0,1894,1895,   0,1896,1897,   0,1898,1899,   0,1900,1901,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,1876,   0,   0,   0,   0,   0,   0,   0,   0,   0,1902,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1904,   0,1905,   0,\n-  1906,   0,1907,   0,1908,   0,1909,   0,1910,   0,1911,   0,1912,   0,1913,   0,\n-  1914,   0,1915,   0,   0,1916,   0,1917,   0,1918,   0,   0,   0,   0,   0,   0,\n-  1919,1920,   0,1921,1922,   0,1923,1924,   0,1925,1926,   0,1927,1928,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,1903,   0,   0,1929,1930,1931,1932,   0,   0,   0,1933,   0,\n-   710, 385, 724, 715, 455, 103, 186, 825, 825, 242, 751, 205, 241, 336, 524, 601,\n-   663, 676, 688, 738, 411, 434, 474, 500, 649, 746, 799, 108, 180, 416, 482, 662,\n-   810, 275, 462, 658, 692, 344, 618, 679, 293, 388, 440, 492, 740, 116, 146, 168,\n-   368, 414, 481, 527, 606, 660, 665, 722, 781, 803, 809, 538, 553, 588, 642, 758,\n-   811, 701, 233, 299, 573, 612, 487, 540, 714, 779, 232, 267, 412, 445, 457, 585,\n-   594, 766, 167, 613, 149, 148, 560, 589, 648, 768, 708, 345, 411, 704, 105, 259,\n-   313, 496, 518, 174, 542, 120, 307, 101, 430, 372, 584, 183, 228, 529, 650, 697,\n-   424, 732, 428, 349, 632, 355, 517, 110, 135, 147, 403, 580, 624, 700, 750, 170,\n-   193, 245, 297, 374, 463, 543, 763, 801, 812, 815, 162, 384, 420, 730, 287, 330,\n-   337, 366, 459, 476, 509, 558, 591, 610, 726, 652, 734, 759, 154, 163, 198, 473,\n-   683, 697, 292, 311, 353, 423, 572, 494, 113, 217, 259, 280, 314, 499, 506, 603,\n-   608, 752, 778, 782, 788, 117, 557, 748, 774, 320, 109, 126, 260, 265, 373, 411,\n-   479, 523, 655, 737, 823, 380, 765, 161, 395, 398, 438, 451, 502, 516, 537, 583,\n-   791, 136, 340, 769, 122, 273, 446, 727, 305, 322, 400, 496, 771, 155, 190, 269,\n-   377, 391, 406, 432, 501, 519, 599, 684, 687, 749, 776, 175, 452, 191, 480, 510,\n-   659, 772, 805, 813, 397, 444, 619, 566, 568, 575, 491, 471, 707, 111, 636, 156,\n-   153, 288, 346, 578, 256, 435, 383, 729, 680, 767, 694, 295, 128, 210,   0,   0,\n-   227,   0, 379,   0,   0, 150, 493, 525, 544, 551, 552, 556, 783, 576, 604,   0,\n-   661,   0, 703,   0,   0, 735, 743,   0,   0,   0, 793, 794, 795, 808, 741, 773,\n-   118, 127, 130, 166, 169, 177, 207, 213, 215, 226, 229, 268, 270, 317, 327, 329,\n-   335, 369, 375, 381, 404, 441, 448, 458, 477, 484, 503, 539, 545, 547, 546, 548,\n-   549, 550, 554, 555, 561, 564, 569, 591, 593, 595, 598, 607, 620, 625, 625, 651,\n-   690, 695, 705, 706, 716, 717, 733, 735, 777, 786, 790, 315, 869, 623,   0,   0,\n-   102, 145, 134, 115, 129, 138, 165, 171, 207, 202, 206, 212, 227, 231, 240, 243,\n-   250, 254, 294, 296, 303, 308, 319, 325, 321, 329, 326, 335, 341, 357, 360, 362,\n-   370, 379, 388, 389, 393, 421, 424, 438, 456, 454, 458, 465, 477, 535, 485, 490,\n-   493, 507, 512, 514, 521, 522, 525, 526, 528, 533, 532, 541, 565, 569, 574, 586,\n-   591, 597, 607, 637, 647, 674, 691, 693, 695, 698, 703, 699, 705, 704, 702, 706,\n-   709, 717, 728, 736, 747, 754, 770, 777, 783, 784, 786, 787, 790, 802, 825, 848,\n-   847, 857,  55,  65,  66, 883, 892, 916, 822, 824,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1586,   0,1605,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1602,1603,1934,1935,1574,1575,\n-  1576,1577,1579,1580,1581,1583,1584,   0,1585,1587,1588,1589,1591,   0,1592,   0,\n-  1593,1594,   0,1595,1596,   0,1598,1599,1600,1601,1604,1582,1578,1590,1597,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1936,   0,1937,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1938,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1939,1940,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1941,1942,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1944,1943,   0,1945,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1946,1947,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,1948,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1949,1950,\n-  1951,1952,1953,1954,1955,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+    48,  48, 475, 192, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 271, 476,\n+    48,  48, 477, 478, 140, 140, 140, 479,  48, 464, 480,  48,  62, 481, 140,  48,\n+   482, 140, 140,  48, 483, 140,  48, 314, 484,  48,  48, 485, 486, 457, 487, 488,\n+   222,  48,  48, 489, 490,  48, 196, 192, 491,  48, 492, 493, 494,  48,  48, 495,\n+   222,  48,  48, 496, 497, 498, 499, 500,  48,  97, 501, 502, 503, 140, 140, 140,\n+   504, 505, 506,  48,  48, 507, 508, 192, 509,  83,  84, 510, 511, 512, 513, 514,\n+    48,  48,  48, 515, 516, 517, 478, 140,  48,  48,  48, 518, 519, 192, 140, 140,\n+    48,  48, 520, 521, 522, 523, 140, 140,  48,  48,  48, 524, 525, 192, 526, 140,\n+    48,  48, 527, 528, 192, 140, 140, 140,  48, 173, 529, 530, 314, 140, 140, 140,\n+    48,  48, 501, 531, 140, 140, 140, 140, 140, 140,   9,   9,  11,  11, 148, 532,\n+   533, 534,  48, 535, 536, 192, 140, 140, 140, 140, 537,  48,  48, 538, 539, 140,\n+   540,  48,  48, 541, 542, 543,  48,  48, 544, 545, 546,  48,  48,  48,  48, 196,\n+   547, 140, 140, 140, 140, 140, 140, 140,  84,  48, 520, 548, 549, 148, 175, 550,\n+    48, 551, 552, 553, 140, 140, 140, 140, 554,  48,  48, 555, 556, 192, 557,  48,\n+   558, 559, 192, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,  48, 560,\n+   561, 115,  48, 562, 563, 192, 140, 140, 140, 140, 140, 100, 271, 564, 565, 566,\n+    48, 207, 140, 140, 140, 140, 140, 140, 272, 272, 272, 272, 272, 272, 567, 568,\n+    48,  48,  48,  48, 388, 140, 140, 140, 140,  48,  48,  48,  48,  48,  48, 569,\n+    48,  48,  48, 570, 571, 572, 140, 140,  48,  48,  48,  48, 314, 140, 140, 140,\n+    48,  48,  48, 196,  48, 200, 370,  48,  48,  48,  48, 200, 192,  48, 204, 573,\n+    48,  48,  48, 574, 575, 576, 577, 578,  48, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140,   9,   9,  11,  11, 271, 579, 140, 140, 140, 140, 140, 140,\n+    48,  48,  48,  48, 580, 581, 582, 582, 583, 584, 140, 140, 140, 140, 585, 586,\n+    48,  48,  48,  48,  48,  48,  48, 440,  48,  48,  48,  48,  48, 199, 140, 140,\n+   196, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 587,\n+    48,  48, 588, 589, 140, 590, 591,  48,  48,  48,  48,  48,  48,  48,  48, 206,\n+    48,  48,  48,  48,  48,  48,  71, 151, 196, 592, 593, 140, 140, 140, 140, 140,\n+    32,  32, 594,  32, 595, 209, 209, 209, 209, 209, 209, 209, 323, 140, 140, 140,\n+   209, 209, 209, 209, 209, 209, 209, 324, 209, 209, 596, 209, 209, 209, 597, 598,\n+   599, 209, 600, 209, 209, 209, 288, 140, 209, 209, 209, 209, 601, 140, 140, 140,\n+   140, 140, 140, 140, 271, 602, 271, 602, 209, 209, 209, 209, 209, 287, 271, 461,\n+     9, 603,  11, 604, 605, 606, 241,   9, 607, 608, 609, 610, 611,   9, 603,  11,\n+   612, 613,  11, 614, 615, 616, 617,   9, 618,  11,   9, 603,  11, 604, 605,  11,\n+   241,   9, 607, 617,   9, 618,  11,   9, 603,  11, 619,   9, 620, 621, 622, 623,\n+    11, 624,   9, 625, 626, 627, 628,  11, 629,   9, 630,  11, 631, 632, 632, 632,\n+    32,  32,  32, 633,  32,  32, 634, 635, 636, 637,  45, 140, 140, 140, 140, 140,\n+   638, 639, 640, 140, 140, 140, 140, 140, 641, 642, 643,  27,  27,  27, 644, 140,\n+   645, 140, 140, 140, 140, 140, 140, 140,  48,  48, 151, 646, 647, 140, 140, 140,\n+   140,  48, 648, 140,  48,  48, 649, 650, 140, 140, 140, 140, 140,  48, 651, 192,\n+   140, 140, 140, 140, 140, 140, 652, 200,  48,  48,  48,  48, 653, 595, 140, 140,\n+     9,   9, 607,  11, 654, 370, 140, 140, 140, 140, 140, 140, 140, 140, 140, 499,\n+   271, 271, 655, 656, 140, 140, 140, 140, 499, 271, 657, 658, 140, 140, 140, 140,\n+   659,  48, 660, 661, 662, 663, 664, 665, 666, 206, 667, 206, 140, 140, 140, 668,\n+   209, 209, 325, 209, 209, 209, 209, 209, 209, 323, 334, 669, 669, 669, 209, 324,\n+   670, 209, 209, 209, 209, 209, 209, 209, 209, 209, 671, 140, 140, 140, 672, 209,\n+   673, 209, 209, 325, 674, 675, 324, 140, 209, 209, 209, 209, 209, 209, 209, 676,\n+   209, 209, 209, 209, 209, 677, 426, 426, 209, 209, 209, 209, 209, 209, 209, 678,\n+   209, 209, 209, 209, 209, 176, 325, 427, 325, 209, 209, 209, 679, 176, 209, 209,\n+   679, 209, 671, 675, 140, 140, 140, 140, 209, 209, 209, 209, 209, 323, 671, 426,\n+   674, 209, 209, 680, 681, 325, 674, 674, 209, 682, 209, 209, 288, 140, 140, 192,\n+    48,  48,  48,  48,  48,  48, 140, 140,  48,  48,  48, 207,  48,  48,  48,  48,\n+    48, 204,  48,  48,  48,  48,  48,  48,  48,  48, 478,  48,  48,  48,  48,  48,\n+    48,  48,  48,  48,  48,  48, 100, 140,  48, 204, 140, 140, 140, 140, 140, 140,\n+    48,  48,  48,  48,  71,  48,  48,  48,  48,  48,  48, 140, 140, 140, 140, 140,\n+   683, 140, 570, 570, 570, 570, 570, 570,  32,  32,  32,  32,  32,  32,  32,  32,\n+    32,  32,  32,  32,  32,  32,  32, 140, 391, 391, 391, 391, 391, 391, 391, 684,\n+   391, 391, 391, 391, 391, 391, 391, 685,   0,   0,   0,   0,   0,   0,   0,   0,\n+     1,   2,   2,   3,   1,   2,   2,   3,   0,   0,   0,   0,   0,   4,   0,   4,\n+     2,   2,   5,   2,   2,   2,   5,   2,   2,   2,   2,   2,   2,   2,   2,   2,\n+     2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   6,\n+     0,   0,   0,   0,   7,   8,   0,   0,   9,   9,   9,   9,   9,   9,   9,   9,\n+     9,   9,   9,   9,   9,   9,  10,  11,  12,  13,  14,  14,  15,  14,  14,  14,\n+    14,  14,  14,  14,  16,  17,  14,  14,  18,  18,  18,  18,  18,  18,  18,  18,\n+    18,  18,  18,  18,  18,  18,  18,  18,  19,  18,  18,  18,  18,  18,  18,  18,\n+    18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  20,  21,\n+    21,  21,  22,  20,  21,  21,  21,  21,  21,  23,  24,  25,  25,  25,  25,  25,\n+    25,  26,  25,  25,  25,  27,  28,  26,  29,  30,  31,  32,  31,  31,  31,  31,\n+    33,  34,  35,  31,  31,  31,  36,  31,  31,  31,  31,  31,  31,  31,  31,  31,\n+    31,  31,  31,  29,  31,  31,  31,  31,  37,  38,  37,  37,  37,  37,  37,  37,\n+    37,  39,  31,  31,  31,  31,  31,  31,  40,  40,  40,  40,  40,  40,  41,  26,\n+    42,  42,  42,  42,  42,  42,  42,  43,  44,  44,  44,  44,  44,  45,  44,  46,\n+    47,  47,  47,  48,  37,  49,  31,  31,  31,  50,  51,  31,  31,  31,  31,  31,\n+    31,  31,  31,  31,  52,  31,  31,  31,  53,  53,  53,  53,  53,  53,  53,  53,\n+    53,  53,  54,  53,  55,  53,  53,  53,  56,  57,  58,  59,  59,  60,  61,  62,\n+    57,  63,  64,  65,  66,  59,  59,  67,  68,  69,  70,  71,  71,  72,  73,  74,\n+    69,  75,  76,  77,  78,  71,  79,  26,  80,  81,  82,  83,  83,  84,  85,  86,\n+    81,  87,  88,  26,  89,  83,  90,  91,  92,  93,  94,  95,  95,  96,  97,  98,\n+    93,  99, 100, 101, 102,  95,  95,  26, 103, 104, 105, 106, 107, 104, 108, 109,\n+   104, 105, 110,  26, 111, 108, 108, 112, 113, 114, 115, 113, 113, 115, 113, 116,\n+   114, 117, 118, 119, 120, 113, 121, 113, 122, 123, 124, 122, 122, 124, 125, 126,\n+   123, 127, 128, 128, 129, 122, 130,  26, 131, 132, 133, 131, 131, 131, 131, 131,\n+   132, 133, 134, 131, 135, 131, 131, 131, 136, 137, 138, 139, 137, 137, 140, 141,\n+   138, 142, 143, 137, 144, 137, 145,  26, 146, 147, 147, 147, 147, 147, 147, 148,\n+   147, 147, 147, 149,  26,  26,  26,  26, 150, 151, 152, 152, 153, 152, 152, 154,\n+   155, 156, 152, 157,  26,  26,  26,  26, 158, 158, 158, 158, 158, 158, 158, 158,\n+   158, 159, 158, 158, 158, 160, 159, 158, 158, 158, 158, 159, 158, 158, 158, 161,\n+   158, 161, 162, 163,  26,  26,  26,  26, 164, 164, 164, 164, 164, 164, 164, 164,\n+   164, 164, 164, 164, 164, 164, 164, 164, 164, 164, 164, 164, 165, 165, 165, 165,\n+   166, 167, 165, 165, 165, 165, 165, 168, 169, 169, 169, 169, 169, 169, 169, 169,\n+   169, 169, 169, 169, 169, 169, 169, 169, 170, 170, 170, 170, 170, 170, 170, 170,\n+   170, 171, 172, 171, 170, 170, 170, 170, 170, 171, 170, 170, 170, 170, 171, 172,\n+   171, 170, 172, 170, 170, 170, 170, 170, 170, 170, 171, 170, 170, 170, 170, 170,\n+   170, 170, 170, 173, 170, 170, 170, 174, 170, 170, 170, 175, 176, 176, 176, 176,\n+   176, 176, 176, 176, 176, 176, 177, 177, 178, 178, 178, 178, 178, 178, 178, 178,\n+   178, 178, 178, 178, 178, 178, 178, 178, 179, 179, 179, 180, 181, 181, 181, 181,\n+   181, 181, 181, 181, 181, 182, 181, 183, 184, 184, 185, 186, 187, 187, 188,  26,\n+   189, 189, 190,  26, 191, 192, 193,  26, 194, 194, 194, 194, 194, 194, 194, 194,\n+   194, 194, 194, 195, 194, 196, 194, 196, 197, 198, 198, 199, 198, 198, 198, 198,\n+   198, 198, 198, 198, 198, 198, 198, 200, 198, 198, 198, 198, 198, 201, 178, 178,\n+   178, 178, 178, 178, 178, 178, 202,  26, 203, 203, 203, 204, 203, 205, 203, 205,\n+   206, 203, 207, 207, 207, 208, 209,  26, 210, 210, 210, 210, 210, 211, 210, 210,\n+   210, 212, 210, 213, 194, 194, 194, 194, 214, 214, 214, 215, 216, 216, 216, 216,\n+   216, 216, 216, 217, 216, 216, 216, 218, 216, 219, 216, 219, 216, 220,   9,   9,\n+     9, 221,  26,  26,  26,  26,  26,  26, 222, 222, 222, 222, 222, 222, 222, 222,\n+   222, 223, 222, 222, 222, 222, 222, 224, 225, 225, 225, 225, 225, 225, 225, 225,\n+   226, 226, 226, 226, 226, 226, 227, 228, 229, 229, 229, 229, 229, 229, 229, 230,\n+   229, 231, 232, 232, 232, 232, 232, 232,  18, 233, 165, 165, 165, 165, 165, 234,\n+   225,  26, 235,   9, 236, 237, 238, 239,   2,   2,   2,   2, 240, 241,   2,   2,\n+     2,   2,   2, 242, 243, 244,   2, 245,   2,   2,   2,   2,   2,   2,   2, 246,\n+     9,   9,   9,   9,   9,   9,   9,   9,  14,  14, 247, 247,  14,  14,  14,  14,\n+   247, 247,  14, 248,  14,  14,  14, 247,  14,  14,  14,  14,  14,  14, 249,  14,\n+   249,  14, 250, 251,  14,  14, 252, 253,   0, 254,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0, 255,   0, 256, 257,   0, 258,   2, 259,   0,   0,   0,   0,\n+   260,  26,   9,   9,   9,   9, 261,  26,   0,   0,   0,   0, 262, 263,   4,   0,\n+     0, 264,   0,   0,   2,   2,   2,   2,   2, 265,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 258,  26,  26,  26,\n+     0, 266,  26,  26,   0,   0,   0,   0, 267, 267, 267, 267, 267, 267, 267, 267,\n+   267, 267, 267, 267, 267, 267, 267, 267,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0, 268,   0,   0,   0, 269,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0, 270, 270, 270, 270, 270, 270, 270, 270,\n+   270, 270, 270, 270,   2,   2,   2,   2,  17,  17,  17,  17,  17,  17,  17,  17,\n+    17,  17,  17,  17,  17,  17, 271, 272, 165, 165, 165, 165, 166, 167, 273, 273,\n+   273, 273, 273, 273, 273, 274, 275, 274, 170, 170, 172,  26, 172, 172, 172, 172,\n+   172, 172, 172, 172,  18,  18,  18,  18,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0, 276,  26,  26,  26,  26, 277, 277, 277, 278, 277, 277, 277, 277,\n+   277, 277, 277, 277, 277, 277, 279,  26, 277, 277, 277, 277, 277, 277, 277, 277,\n+   277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,\n+   277, 277, 280,  26,  26,  26,   0, 281, 282,   0,   0,   0, 283, 284,   0, 285,\n+   286, 287, 287, 287, 287, 287, 287, 287, 287, 287, 288, 289, 290, 291, 291, 291,\n+   291, 291, 291, 291, 291, 291, 291, 292, 293, 294, 294, 294, 294, 294, 295, 169,\n+   169, 169, 169, 169, 169, 169, 169, 169, 169, 296,   0,   0, 294, 294, 294, 294,\n+     0,   0,   0,   0, 281,  26, 291, 291, 169, 169, 169, 296,   0,   0,   0,   0,\n+     0,   0,   0,   0, 169, 169, 169, 297,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0, 291, 291, 291, 291, 291, 298, 291, 291, 291, 291, 291, 291, 291, 291,\n+   291, 291, 291,   0,   0,   0,   0,   0, 277, 277, 277, 277, 277, 277, 277, 277,\n+     0,   0,   0,   0,   0,   0,   0,   0, 299, 299, 299, 299, 299, 299, 299, 299,\n+   299, 299, 299, 299, 299, 299, 299, 299, 299, 300, 299, 299, 299, 299, 299, 299,\n+   301,  26, 302, 302, 302, 302, 302, 302, 303, 303, 303, 303, 303, 303, 303, 303,\n+   303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 304,  26,  26,\n+    18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18, 305, 305, 305, 305,\n+   305, 305, 305, 305, 305, 305, 305,  26,   0,   0,   0,   0, 306,   2,   2,   2,\n+     2,   2,   2,   2,   2,   2,   2,   2,   2, 307,   2,   2,   2,   2,   2,   2,\n+     2, 308, 309, 310,  26,  26, 311,   2, 312, 312, 312, 312, 312, 313,   0, 314,\n+   315, 315, 315, 315, 315, 315, 315,  26, 316, 316, 316, 316, 316, 316, 316, 316,\n+   317, 318, 316, 319,  53,  53,  53,  53, 320, 320, 320, 320, 320, 321, 322, 322,\n+   322, 322, 323, 324, 169, 169, 169, 325, 326, 326, 326, 326, 326, 326, 326, 326,\n+   326, 327, 326, 328, 164, 164, 164, 329, 330, 330, 330, 330, 330, 330, 331,  26,\n+   330, 332, 330, 333, 164, 164, 164, 164, 334, 334, 334, 334, 334, 334, 334, 334,\n+   335,  26,  26, 336, 337, 337, 338,  26, 339, 339, 339,  26, 172, 172,   2,   2,\n+     2,   2,   2, 340, 341, 342, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176,\n+   337, 337, 337, 337, 337, 343, 337, 344, 169, 169, 169, 169, 345,  26, 169, 169,\n+   296, 346, 169, 169, 169, 169, 169, 345,  26,  26,  26,  26,  26,  26,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26, 277, 277, 277, 277, 277, 277, 277, 277,\n+   277, 277, 277, 277, 277, 280, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,\n+   277, 277, 277, 347,  26,  26,  26,  26, 348,  26, 349, 350,  25,  25, 351, 352,\n+   353,  25,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,\n+   354,  26, 355,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,\n+    31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31, 356,\n+    31,  31,  31,  31,  31,  31,  31,  31,  31,  31, 357,  31,  31,  31,  31,  31,\n+    31, 358,  26,  26,  26,  26,  31,  31,   9,   9,   0, 314,   9, 359,   0,   0,\n+     0,   0, 360,   0, 258, 281, 361,  31,  31,  31,  31,  31,  31,  31,  31,  31,\n+    31,  31,  31,  31,  31,  31,  31, 362, 363,   0,   0,   0,   1,   2,   2,   3,\n+     1,   2,   2,   3, 364, 291, 290, 291, 291, 291, 291, 365, 169, 169, 169, 296,\n+   366, 366, 366, 367, 258, 258,  26, 368, 369, 370, 369, 369, 371, 369, 369, 372,\n+   369, 373, 369, 373,  26,  26,  26,  26, 369, 369, 369, 369, 369, 369, 369, 369,\n+   369, 369, 369, 369, 369, 369, 369, 374, 375,   0,   0,   0,   0,   0, 376,   0,\n+    14,  14,  14,  14,  14,  14,  14,  14,  14, 253,   0, 377, 378,  26,  26,  26,\n+    26,  26,   0,   0,   0,   0,   0, 379, 380, 380, 380, 381, 382, 382, 382, 382,\n+   382, 382, 383,  26, 384,   0,   0, 281, 385, 385, 385, 385, 386, 387, 388, 388,\n+   388, 389, 390, 390, 390, 390, 390, 391, 392, 392, 392, 393, 394, 394, 394, 394,\n+   395, 394, 396,  26,  26,  26,  26,  26, 397, 397, 397, 397, 397, 397, 397, 397,\n+   397, 397, 398, 398, 398, 398, 398, 398, 399, 399, 399, 400, 399, 401, 402, 402,\n+   402, 402, 403, 402, 402, 402, 402, 403, 404, 404, 404, 404, 404,  26, 405, 405,\n+   405, 405, 405, 405, 406, 407, 408, 409, 408, 409, 410, 408, 411, 408, 411, 412,\n+    26,  26,  26,  26,  26,  26,  26,  26, 413, 413, 413, 413, 413, 413, 413, 413,\n+   413, 413, 413, 413, 413, 413, 413, 413, 413, 413, 413, 413, 413, 413, 414,  26,\n+   413, 413, 415,  26, 413,  26,  26,  26, 416,   2,   2,   2,   2,   2, 417, 308,\n+    26,  26,  26,  26,  26,  26,  26,  26, 418, 419, 420, 420, 420, 420, 421, 422,\n+   423, 423, 424, 423, 425, 425, 425, 425, 426, 426, 426, 427, 428, 426,  26,  26,\n+    26,  26,  26,  26, 429, 429, 430, 431, 432, 432, 432, 433, 434, 434, 434, 435,\n+    26,  26,  26,  26,  26,  26,  26,  26, 436, 436, 436, 436, 437, 437, 437, 438,\n+   437, 437, 439, 437, 437, 437, 437, 437, 440, 441, 442, 443, 444, 444, 445, 446,\n+   444, 447, 444, 447, 448, 448, 448, 448, 449, 449, 449, 449,  26,  26,  26,  26,\n+   450, 450, 450, 450, 451, 452, 451,  26, 453, 453, 453, 453, 453, 453, 454, 455,\n+   456, 456, 457, 456, 458, 458, 459, 458, 460, 460, 461, 462,  26, 463,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26, 464, 464, 464, 464, 464, 464, 464, 464,\n+   464, 465,  26,  26,  26,  26,  26,  26, 466, 466, 466, 466, 466, 466, 467,  26,\n+   466, 466, 466, 466, 466, 466, 467, 468, 469, 469, 469, 469, 469,  26, 469, 470,\n+    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+    26,  26,  26,  26,  31,  31,  31,  50, 471, 471, 471, 471, 471, 472, 473,  26,\n+    26,  26,  26,  26,  26,  26,  26, 474, 475, 475, 475, 475, 475,  26, 476, 476,\n+   476, 476, 476, 477,  26,  26, 478, 478, 478, 479,  26,  26,  26,  26, 480, 480,\n+   480, 481,  26,  26, 482, 482, 483,  26, 484, 484, 484, 484, 484, 484, 484, 484,\n+   484, 485, 486, 484, 484, 484, 485, 487, 488, 488, 488, 488, 488, 488, 488, 488,\n+   489, 490, 491, 491, 491, 492, 491, 493, 494, 494, 494, 494, 494, 494, 495, 494,\n+   494,  26, 496, 496, 496, 496, 497,  26, 498, 498, 498, 498, 498, 498, 498, 498,\n+   498, 498, 498, 498, 499, 137, 500,  26, 501, 501, 502, 501, 501, 501, 501, 501,\n+   503,  26,  26,  26,  26,  26,  26,  26, 504, 505, 506, 507, 506, 508, 509, 509,\n+   509, 509, 509, 509, 509, 510, 509, 511, 512, 513, 514, 515, 515, 516, 517, 518,\n+   513, 519, 520, 521, 522, 523, 523,  26, 524, 524, 524, 524, 524, 524, 524, 524,\n+   524, 524, 524, 525, 526,  26,  26,  26, 527, 527, 527, 527, 527, 527, 527, 527,\n+   527,  26, 527, 528,  26,  26,  26,  26, 529, 529, 529, 529, 529, 529, 530, 529,\n+   529, 529, 529, 530,  26,  26,  26,  26, 531, 531, 531, 531, 531, 531, 531, 531,\n+   532,  26, 531, 533, 198, 534,  26,  26, 535, 535, 535, 535, 535, 535, 535, 536,\n+   535, 536,  26,  26,  26,  26,  26,  26, 537, 537, 537, 538, 537, 539, 537, 537,\n+   540,  26,  26,  26,  26,  26,  26,  26, 541, 541, 541, 541, 541, 541, 541, 542,\n+    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26, 543, 543, 543, 543,\n+   543, 543, 543, 543, 543, 543, 544, 545, 546, 547, 548, 549, 549, 549, 550, 551,\n+   546,  26, 549, 552,  26,  26,  26,  26,  26,  26,  26,  26, 553, 554, 553, 553,\n+   553, 553, 553, 554, 555,  26,  26,  26, 556, 556, 556, 556, 556, 556, 556, 556,\n+   556,  26, 557, 557, 557, 557, 557, 557, 557, 557, 557, 557, 558,  26, 178, 178,\n+   559, 559, 559, 559, 559, 559, 559, 560,  53, 561,  26,  26,  26,  26,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26, 562, 563, 562, 562, 562, 562, 564, 562,\n+   565,  26, 562, 562, 562, 566, 567, 567, 567, 567, 568, 567, 567, 569, 570,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26, 571, 572, 573, 573, 573, 573, 571, 574,\n+   573,  26, 573, 575, 576, 577, 578, 578, 578, 579, 580, 581, 578, 582,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+    26,  26,  26,  26, 583, 583, 583, 584, 585, 585, 586, 585, 585, 585, 585, 587,\n+   585, 585, 585, 588,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26, 589,  26,\n+   108, 108, 108, 108, 108, 108, 590, 591, 592, 592, 592, 592, 592, 592, 592, 592,\n+   592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 593,  26,  26,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26, 592, 592, 592, 592, 592, 592, 592, 592,\n+   592, 592, 592, 592, 592, 594, 595,  26, 592, 592, 592, 592, 592, 592, 592, 592,\n+   596,  26,  26,  26,  26,  26,  26,  26,  26,  26, 597, 597, 597, 597, 597, 597,\n+   597, 597, 597, 597, 597, 597, 598,  26, 599, 599, 599, 599, 599, 599, 599, 599,\n+   599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599, 599,\n+   599, 599, 600,  26,  26,  26,  26,  26, 601, 601, 601, 601, 601, 601, 601, 601,\n+   601, 601, 601, 601, 601, 601, 601, 601, 601, 601, 601, 601, 601, 601, 601, 601,\n+   602,  26,  26,  26,  26,  26,  26,  26, 305, 305, 305, 305, 305, 305, 305, 305,\n+   305, 305, 305, 305, 305, 305, 305, 305, 305, 305, 305, 305, 305, 305, 305, 603,\n+   604, 604, 604, 605, 604, 606, 607, 607, 607, 607, 607, 607, 607, 607, 607, 608,\n+   607, 609, 610, 610, 610, 611, 611,  26, 612, 612, 612, 612, 612, 612, 612, 612,\n+   613,  26, 612, 614, 614, 612, 612, 615, 612, 612,  26,  26,  26,  26,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+   616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 617,  26,  26,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26, 618, 618, 618, 618, 618, 618, 618, 618,\n+   618, 619, 618, 618, 618, 618, 618, 618, 618, 620, 618, 618,  26,  26,  26,  26,\n+    26,  26,  26,  26, 621,  26, 347,  26, 622, 622, 622, 622, 622, 622, 622, 622,\n+   622, 622, 622, 622, 622, 622, 622, 622, 622, 622, 622, 622, 622, 622, 622, 622,\n+   622, 622, 622, 622, 622, 622, 622,  26, 623, 623, 623, 623, 623, 623, 623, 623,\n+   623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623,\n+   623, 623, 624,  26,  26,  26,  26,  26, 622, 625,  26,  26,  26,  26,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+    26,  26,  26,  26,  26,  26, 626, 627, 628, 287, 287, 287, 287, 287, 287, 287,\n+   287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287,\n+   287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 629,  26, 630,  26,\n+    26,  26, 631,  26, 632,  26, 633, 633, 633, 633, 633, 633, 633, 633, 633, 633,\n+   633, 633, 633, 633, 633, 633, 633, 633, 633, 633, 633, 633, 633, 633, 633, 633,\n+   633, 633, 633, 633, 633, 633, 633, 634, 635, 635, 635, 635, 635, 635, 635, 635,\n+   635, 635, 635, 635, 635, 636, 635, 637, 635, 638, 635, 639, 281,  26,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26,   9,   9,   9,   9,   9, 640,   9,   9,\n+   221,  26,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+   281,  26,  26,  26,  26,  26,  26,  26,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0, 276,  26,   0,   0,   0,   0, 258, 363,   0,   0,\n+     0,   0,   0,   0, 641, 642,   0, 643, 644, 645,   0,   0,   0, 646,   0,   0,\n+     0,   0,   0,   0,   0, 266,  26,  26,  14,  14,  14,  14,  14,  14,  14,  14,\n+   247,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+     0,   0, 281,  26,   0,   0, 281,  26,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0, 258,  26,   0,   0,   0, 260,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0, 255,   0,   0,   0,   0,   0,   0,   0,   0, 255, 647, 648,   0, 649,\n+   650,   0,   0,   0,   0,   0,   0,   0, 269, 651, 255, 255,   0,   0,   0, 652,\n+   653, 654, 655,   0,   0,   0,   0,   0,   0,   0,   0,   0, 276,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0, 268,   0,   0,   0,   0,   0,   0, 656, 656, 656, 656, 656, 656, 656, 656,\n+   656, 656, 656, 656, 656, 656, 656, 656, 656, 657,  26, 658, 659, 656,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26,   2,   2,   2, 348, 660, 308,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26, 661, 270, 270, 662, 663, 664,  18,  18,\n+    18,  18,  18,  18,  18, 665,  26,  26,  26, 666,  26,  26,  26,  26,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26, 667, 667, 667, 667, 667, 668, 667, 669,\n+   667, 670,  26,  26,  26,  26,  26,  26,  26,  26, 671, 671, 671, 672,  26,  26,\n+   673, 673, 673, 673, 673, 673, 673, 674,  26,  26,  26,  26,  26,  26,  26,  26,\n+    26,  26, 675, 675, 675, 675, 675, 676,  26,  26,  26,  26,  26,  26,  26,  26,\n+    26,  26,  26,  26, 172, 677, 170, 172, 678, 678, 678, 678, 678, 678, 678, 678,\n+   678, 678, 678, 678, 678, 678, 678, 678, 678, 678, 678, 678, 678, 678, 678, 678,\n+   679, 678, 680,  26,  26,  26,  26,  26, 681, 681, 681, 681, 681, 681, 681, 681,\n+   681, 682, 681, 683,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+    26,  26,  26,  26,  26,  26, 363,   0,   0,   0,   0,   0,   0,   0, 377,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26, 363,   0,   0,   0,   0,   0,   0, 276,\n+    26,  26,  26,  26,  26,  26,  26,  26, 684,  31,  31,  31, 685, 686, 687, 688,\n+   689, 690, 685, 691, 685, 687, 687, 692,  31, 693,  31, 694, 695, 693,  31, 694,\n+    26,  26,  26,  26,  26,  26,  51,  26,   0,   0,   0,   0,   0, 281,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 281,  26,   0, 258, 363,   0,\n+   363,   0, 363,   0,   0,   0, 276,  26,   0,   0,   0,   0,   0, 276,  26,  26,\n+    26,  26,  26,  26, 696,   0,   0,   0, 697,  26,   0,   0,   0,   0,   0, 281,\n+     0, 260, 314,  26, 276,  26,  26,  26,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0, 698,   0, 377,   0, 377,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0, 258, 699,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0, 314,   0, 281, 260,  26,   0, 281,   0,   0,   0,   0,   0,   0,\n+     0,  26,   0, 314,   0,   0,   0,   0,   0,  26,   0,   0,   0, 276, 314,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0, 281,  26,   0, 276,   0, 377,   0, 260,   0,   0,   0,   0,   0, 269,\n+   276, 696,   0, 281,   0, 260,   0, 260,   0,   0, 360,   0,   0,   0,   0,   0,\n+     0, 266,  26,  26,  26,  26,   0, 314, 277, 277, 277, 277, 277, 277, 277, 277,\n+   277, 277, 277, 277,  26,  26,  26,  26, 277, 277, 277, 277, 277, 277, 277, 347,\n+   277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 280, 277, 277, 277, 277,\n+   277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 347,  26, 277, 277,\n+   277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,\n+   277, 277, 277, 277, 700,  26,  26,  26, 277, 277, 277, 280,  26,  26,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26, 277, 277, 277, 277, 277, 277, 277, 277,\n+   277, 701, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26, 702,  26,  26,  26,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   9,   9,   9,   9,   9,   9,   9,   9,\n+     9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,\n+     9,   9,   9,   9,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0, 939, 940, 941, 942, 946, 948,   0, 962,\n+   969, 970, 971, 976,1001,1002,1003,1008,   0,1033,1040,1041,1042,1043,1047,   0,\n+     0,1080,1081,1082,1086,1110,   0,   0,1124,1125,1126,1127,1131,1133,   0,1147,\n+  1154,1155,1156,1161,1187,1188,1189,1193,   0,1219,1226,1227,1228,1229,1233,   0,\n+     0,1267,1268,1269,1273,1298,   0,1303, 943,1128, 944,1129, 954,1139, 958,1143,\n+   959,1144, 960,1145, 961,1146, 964,1149,   0,   0, 973,1158, 974,1159, 975,1160,\n+   983,1168, 978,1163, 988,1173, 990,1175, 991,1176, 993,1178, 994,1179,   0,   0,\n+  1004,1190,1005,1191,1006,1192,1014,1199,1007,   0,   0,   0,1016,1201,1020,1206,\n+     0,1022,1208,1025,1211,1023,1209,   0,   0,   0,   0,1032,1218,1037,1223,1035,\n+  1221,   0,   0,   0,1044,1230,1045,1231,1049,1235,   0,   0,1058,1244,1064,1250,\n+  1060,1246,1066,1252,1067,1253,1072,1258,1069,1255,1077,1264,1074,1261,   0,   0,\n+  1083,1270,1084,1271,1085,1272,1088,1275,1089,1276,1096,1283,1103,1290,1111,1299,\n+  1115,1118,1307,1120,1309,1121,1310,   0,1053,1239,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,1093,1280,   0,   0,   0,   0,   0,   0,   0,\n@@ -3827,0 +2586,11 @@\n+     0,   0,   0,   0,   0, 949,1134,1010,1195,1050,1236,1090,1277,1341,1368,1340,\n+  1367,1342,1369,1339,1366,   0,1320,1347,1418,1419,1323,1350,   0,   0, 992,1177,\n+  1018,1204,1055,1241,1416,1417,1415,1424,1202,   0,   0,   0, 987,1172,   0,   0,\n+  1031,1217,1321,1348,1322,1349,1338,1365, 950,1135, 951,1136, 979,1164, 980,1165,\n+  1011,1196,1012,1197,1051,1237,1052,1238,1061,1247,1062,1248,1091,1278,1092,1279,\n+  1071,1257,1076,1263,   0,   0, 997,1182,   0,   0,   0,   0,   0,   0, 945,1130,\n+   982,1167,1337,1364,1335,1362,1046,1232,1422,1423,1113,1301,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   8,   9,   0,  10,1425,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,1314,1427,   5,\n+  1434,1438,1443,   0,1450,   0,1455,1461,1514,   0,   0,   0,   0,   0,   0,   0,\n@@ -3828,0 +2598,1 @@\n+     0,   0,1446,1458,1468,1476,1480,1486,1517,   0,   0,   0,   0,   0,   0,   0,\n@@ -3829,0 +2600,13 @@\n+     0,   0,1489,1503,1494,1500,1508,   0,   0,   0,   0,1520,1521,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,1526,1528,   0,1525,   0,   0,   0,1522,\n+     0,   0,   0,   0,1536,1532,1539,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1534,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1556,   0,   0,   0,   0,   0,   0,1548,1550,   0,1547,   0,   0,   0,1567,\n+     0,   0,   0,   0,1558,1554,1561,   0,   0,   0,   0,   0,   0,   0,1568,1569,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,1529,1551,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,1523,1545,1524,1546,   0,   0,1527,1549,\n+     0,   0,1570,1571,1530,1552,1531,1553,   0,   0,1533,1555,1535,1557,1537,1559,\n+     0,   0,1572,1573,1544,1566,1538,1560,1540,1562,1541,1563,1542,1564,   0,   0,\n+  1543,1565,   0,   0,   0,   0,   0,   0,   0,   0,1606,1607,1609,1608,1610,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,1613,   0,1611,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1612,   0,   0,   0,   0,\n@@ -3830,2 +2614,1 @@\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1956,1957,1958,1960,1959,\n-  1961,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1620,   0,   0,   0,   0,   0,   0,   0,1623,   0,   0,1624,   0,   0,   0,\n@@ -3833,0 +2616,3 @@\n+  1614,1615,1616,1617,1618,1619,1621,1622,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,1628,1629,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1625,1626,   0,1627,   0,   0,   0,1634,   0,   0,1635,   0,\n@@ -3834,0 +2620,3 @@\n+     0,1630,1631,1632,   0,   0,1633,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+  1639,   0,   0,1638,1640,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1636,1637,   0,   0,   0,   0,   0,   0,1641,   0,   0,   0,\n@@ -3835,34 +2624,15 @@\n-   106, 104, 107, 826, 114, 118, 119, 121, 123, 124, 127, 125,  34, 830, 130, 131,\n-   132, 137, 827,  35, 133, 139, 829, 142, 143, 112, 144, 145, 924, 151, 152,  37,\n-   157, 158, 159, 160,  38, 165, 166, 169, 171, 172, 173, 174, 176, 177, 178, 179,\n-   181, 182, 182, 182, 833, 468, 184, 185, 834, 187, 188, 189, 196, 192, 194, 195,\n-   197, 199, 200, 201, 203, 204, 204, 206, 208, 209, 211, 218, 213, 219, 214, 216,\n-   153, 234, 221, 222, 223, 220, 225, 224, 230, 835, 235, 236, 237, 238, 239, 244,\n-   836, 837, 247, 248, 249, 246, 251,  39,  40, 253, 255, 255, 838, 257, 258, 259,\n-   261, 839, 262, 263, 301, 264,  41, 266, 270, 272, 271, 841, 274, 842, 277, 276,\n-   278, 281, 282,  42, 283, 284, 285, 286,  43, 843,  44, 289, 290, 291, 293, 934,\n-   298, 845, 845, 621, 300, 300,  45, 852, 894, 302, 304,  46, 306, 309, 310, 312,\n-   316,  48,  47, 317, 846, 318, 323, 324, 325, 324, 328, 329, 333, 331, 332, 334,\n-   335, 336, 338, 339, 342, 343, 347, 351, 849, 350, 348, 352, 354, 359, 850, 361,\n-   358, 356,  49, 363, 365, 367, 364,  50, 369, 371, 851, 376, 386, 378,  53, 381,\n-    52,  51, 140, 141, 387, 382, 614,  78, 388, 389, 390, 394, 392, 856,  54, 399,\n-   396, 402, 404, 858, 405, 401, 407,  55, 408, 409, 410, 413, 859, 415,  56, 417,\n-   860, 418,  57, 419, 422, 424, 425, 861, 840, 862, 426, 863, 429, 431, 427, 433,\n-   437, 441, 438, 439, 442, 443, 864, 436, 449, 450,  58, 454, 453, 865, 447, 460,\n-   866, 867, 461, 466, 465, 464,  59, 467, 470, 469, 472, 828, 475, 868, 478, 870,\n-   483, 485, 486, 871, 488, 489, 872, 873, 495, 497,  60, 498,  61,  61, 504, 505,\n-   507, 508, 511,  62, 513, 874, 515, 875, 518, 844, 520, 876, 877, 878,  63,  64,\n-   528, 880, 879, 881, 882, 530, 531, 531, 533,  66, 534,  67,  68, 884, 536, 538,\n-   541,  69, 885, 549, 886, 887, 556, 559,  70, 561, 562, 563, 888, 889, 889, 567,\n-    71, 890, 570, 571,  72, 891, 577,  73, 581, 579, 582, 893, 587,  74, 590, 592,\n-   596,  75, 895, 896,  76, 897, 600, 898, 602, 605, 607, 899, 900, 609, 901, 611,\n-   853,  77, 615, 616,  79, 617, 252, 902, 903, 854, 855, 621, 622, 731,  80, 627,\n-   626, 628, 164, 629, 630, 631, 633, 904, 632, 634, 639, 640, 635, 641, 646, 651,\n-   638, 643, 644, 645, 905, 907, 906,  81, 653, 654, 656, 911, 657, 908,  82,  83,\n-   909, 910,  84, 664, 665, 666, 667, 669, 668, 671, 670, 674, 672, 673, 675,  85,\n-   677, 678,  86, 681, 682, 912, 685, 686,  87, 689,  36, 913, 914,  88,  89, 696,\n-   702, 709, 711, 915, 712, 713, 718, 719, 917, 831, 721, 720, 723, 832, 725, 728,\n-   918, 919, 739, 742, 744, 920, 745, 753, 756, 757, 755, 760, 761, 921, 762,  90,\n-   764, 922,  91, 775, 279, 780, 923, 925,  92,  93, 785, 926,  94, 927, 787, 787,\n-   789, 928, 792,  95, 796, 797, 798, 800,  96, 929, 802, 804, 806,  97,  98, 807,\n-   930,  99, 931, 932, 933, 814, 100, 816, 817, 818, 819, 820, 821, 935,   0,   0,\n+     0,   0,1642,1644,1643,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+  1645,   0,   0,   0,   0,   0,   0,   0,1646,   0,   0,   0,   0,   0,   0,1648,\n+  1649,   0,1647,1650,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1651,1653,1652,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1654,   0,1655,1657,1656,   0,   0,   0,   0,1659,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,1660,   0,   0,   0,   0,1661,   0,   0,   0,   0,1662,\n+     0,   0,   0,   0,1663,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1658,   0,   0,   0,   0,   0,   0,   0,   0,   0,1664,   0,1665,1673,   0,\n+  1674,   0,   0,   0,   0,   0,   0,   0,   0,1666,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1668,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,1669,   0,   0,   0,   0,1670,   0,   0,   0,   0,1671,\n+     0,   0,   0,   0,1672,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1667,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1675,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1676,   0,\n+  1677,   0,1678,   0,1679,   0,1680,   0,   0,   0,1681,   0,   0,   0,   0,   0,\n@@ -3870,0 +2640,101 @@\n+     0,   0,   0,1682,   0,1683,   0,   0,1684,1685,   0,1686,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0, 953,1138, 955,1140, 956,1141, 957,1142,\n+  1324,1351, 963,1148, 965,1150, 968,1153, 966,1151, 967,1152,1378,1380,1379,1381,\n+   984,1169, 985,1170,1420,1421, 986,1171, 989,1174, 995,1180, 998,1183, 996,1181,\n+   999,1184,1000,1185,1015,1200,1329,1356,1017,1203,1019,1205,1021,1207,1024,1210,\n+  1687,1688,1027,1213,1026,1212,1028,1214,1029,1215,1030,1216,1034,1220,1036,1222,\n+  1039,1225,1038,1224,1334,1361,1336,1363,1382,1384,1383,1385,1056,1242,1057,1243,\n+  1059,1245,1063,1249,1689,1690,1065,1251,1068,1254,1070,1256,1386,1387,1388,1389,\n+  1691,1692,1073,1259,1075,1262,1079,1266,1078,1265,1095,1282,1098,1285,1097,1284,\n+  1390,1391,1392,1393,1099,1286,1100,1287,1101,1288,1102,1289,1105,1292,1104,1291,\n+  1106,1294,1107,1295,1108,1296,1114,1302,1119,1308,1122,1311,1123,1312,1186,1260,\n+  1293,1305,   0,1394,   0,   0,   0,   0, 952,1137, 947,1132,1317,1344,1316,1343,\n+  1319,1346,1318,1345,1693,1695,1371,1375,1370,1374,1373,1377,1372,1376,1694,1696,\n+   981,1166, 977,1162, 972,1157,1326,1353,1325,1352,1328,1355,1327,1354,1697,1698,\n+  1009,1194,1013,1198,1054,1240,1048,1234,1331,1358,1330,1357,1333,1360,1332,1359,\n+  1699,1700,1396,1401,1395,1400,1398,1403,1397,1402,1399,1404,1094,1281,1087,1274,\n+  1406,1411,1405,1410,1408,1413,1407,1412,1409,1414,1109,1297,1117,1306,1116,1304,\n+  1112,1300,   0,   0,   0,   0,   0,   0,1471,1472,1701,1705,1702,1706,1703,1707,\n+  1430,1431,1715,1719,1716,1720,1717,1721,1477,1478,1729,1731,1730,1732,   0,   0,\n+  1435,1436,1733,1735,1734,1736,   0,   0,1481,1482,1737,1741,1738,1742,1739,1743,\n+  1439,1440,1751,1755,1752,1756,1753,1757,1490,1491,1765,1768,1766,1769,1767,1770,\n+  1447,1448,1771,1774,1772,1775,1773,1776,1495,1496,1777,1779,1778,1780,   0,   0,\n+  1451,1452,1781,1783,1782,1784,   0,   0,1504,1505,1785,1788,1786,1789,1787,1790,\n+     0,1459,   0,1791,   0,1792,   0,1793,1509,1510,1794,1798,1795,1799,1796,1800,\n+  1462,1463,1808,1812,1809,1813,1810,1814,1467,  21,1475,  22,1479,  23,1485,  24,\n+  1493,  27,1499,  28,1507,  29,   0,   0,1704,1708,1709,1710,1711,1712,1713,1714,\n+  1718,1722,1723,1724,1725,1726,1727,1728,1740,1744,1745,1746,1747,1748,1749,1750,\n+  1754,1758,1759,1760,1761,1762,1763,1764,1797,1801,1802,1803,1804,1805,1806,1807,\n+  1811,1815,1816,1817,1818,1819,1820,1821,1470,1469,1822,1474,1465,   0,1473,1825,\n+  1429,1428,1426,  12,1432,   0,  26,   0,   0,1315,1823,1484,1466,   0,1483,1829,\n+  1433,  13,1437,  14,1441,1826,1827,1828,1488,1487,1513,  19,   0,   0,1492,1515,\n+  1445,1444,1442,  15,   0,1831,1832,1833,1502,1501,1516,  25,1497,1498,1506,1518,\n+  1457,1456,1454,  17,1453,1313,  11,   3,   0,   0,1824,1512,1519,   0,1511,1830,\n+  1449,  16,1460,  18,1464,   4,   0,   0,  30,  31,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  20,   0,\n+     0,   0,   2,   6,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1834,1835,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,1836,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,1837,1839,1838,   0,   0,   0,   0,1840,   0,   0,   0,\n+     0,1841,   0,   0,1842,   0,   0,   0,   0,   0,   0,   0,1843,   0,1844,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,1845,   0,   0,1846,   0,   0,1847,\n+     0,1848,   0,   0,   0,   0,   0,   0, 937,   0,1850,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,1849, 936, 938,1851,1852,   0,   0,1853,1854,   0,   0,\n+  1855,1856,   0,   0,   0,   0,   0,   0,1857,1858,   0,   0,1861,1862,   0,   0,\n+  1863,1864,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1867,1868,1869,1870,1859,1860,1865,1866,   0,   0,   0,   0,\n+     0,   0,1871,1872,1873,1874,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,  32,  33,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1875,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1877,   0,1878,   0,1879,   0,1880,   0,1881,   0,1882,   0,\n+  1883,   0,1884,   0,1885,   0,1886,   0,1887,   0,1888,   0,   0,1889,   0,1890,\n+     0,1891,   0,   0,   0,   0,   0,   0,1892,1893,   0,1894,1895,   0,1896,1897,\n+     0,1898,1899,   0,1900,1901,   0,   0,   0,   0,   0,   0,1876,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,1902,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1904,   0,1905,   0,1906,   0,1907,   0,1908,   0,1909,   0,\n+  1910,   0,1911,   0,1912,   0,1913,   0,1914,   0,1915,   0,   0,1916,   0,1917,\n+     0,1918,   0,   0,   0,   0,   0,   0,1919,1920,   0,1921,1922,   0,1923,1924,\n+     0,1925,1926,   0,1927,1928,   0,   0,   0,   0,   0,   0,1903,   0,   0,1929,\n+  1930,1931,1932,   0,   0,   0,1933,   0, 710, 385, 724, 715, 455, 103, 186, 825,\n+   825, 242, 751, 205, 241, 336, 524, 601, 663, 676, 688, 738, 411, 434, 474, 500,\n+   649, 746, 799, 108, 180, 416, 482, 662, 810, 275, 462, 658, 692, 344, 618, 679,\n+   293, 388, 440, 492, 740, 116, 146, 168, 368, 414, 481, 527, 606, 660, 665, 722,\n+   781, 803, 809, 538, 553, 588, 642, 758, 811, 701, 233, 299, 573, 612, 487, 540,\n+   714, 779, 232, 267, 412, 445, 457, 585, 594, 766, 167, 613, 149, 148, 560, 589,\n+   648, 768, 708, 345, 411, 704, 105, 259, 313, 496, 518, 174, 542, 120, 307, 101,\n+   430, 372, 584, 183, 228, 529, 650, 697, 424, 732, 428, 349, 632, 355, 517, 110,\n+   135, 147, 403, 580, 624, 700, 750, 170, 193, 245, 297, 374, 463, 543, 763, 801,\n+   812, 815, 162, 384, 420, 730, 287, 330, 337, 366, 459, 476, 509, 558, 591, 610,\n+   726, 652, 734, 759, 154, 163, 198, 473, 683, 697, 292, 311, 353, 423, 572, 494,\n+   113, 217, 259, 280, 314, 499, 506, 603, 608, 752, 778, 782, 788, 117, 557, 748,\n+   774, 320, 109, 126, 260, 265, 373, 411, 479, 523, 655, 737, 823, 380, 765, 161,\n+   395, 398, 438, 451, 502, 516, 537, 583, 791, 136, 340, 769, 122, 273, 446, 727,\n+   305, 322, 400, 496, 771, 155, 190, 269, 377, 391, 406, 432, 501, 519, 599, 684,\n+   687, 749, 776, 175, 452, 191, 480, 510, 659, 772, 805, 813, 397, 444, 619, 566,\n+   568, 575, 491, 471, 707, 111, 636, 156, 153, 288, 346, 578, 256, 435, 383, 729,\n+   680, 767, 694, 295, 128, 210,   0,   0, 227,   0, 379,   0,   0, 150, 493, 525,\n+   544, 551, 552, 556, 783, 576, 604,   0, 661,   0, 703,   0,   0, 735, 743,   0,\n+     0,   0, 793, 794, 795, 808, 741, 773, 118, 127, 130, 166, 169, 177, 207, 213,\n+   215, 226, 229, 268, 270, 317, 327, 329, 335, 369, 375, 381, 404, 441, 448, 458,\n+   477, 484, 503, 539, 545, 547, 546, 548, 549, 550, 554, 555, 561, 564, 569, 591,\n+   593, 595, 598, 607, 620, 625, 625, 651, 690, 695, 705, 706, 716, 717, 733, 735,\n+   777, 786, 790, 315, 869, 623,   0,   0, 102, 145, 134, 115, 129, 138, 165, 171,\n+   207, 202, 206, 212, 227, 231, 240, 243, 250, 254, 294, 296, 303, 308, 319, 325,\n+   321, 329, 326, 335, 341, 357, 360, 362, 370, 379, 388, 389, 393, 421, 424, 438,\n+   456, 454, 458, 465, 477, 535, 485, 490, 493, 507, 512, 514, 521, 522, 525, 526,\n+   528, 533, 532, 541, 565, 569, 574, 586, 591, 597, 607, 637, 647, 674, 691, 693,\n+   695, 698, 703, 699, 705, 704, 702, 706, 709, 717, 728, 736, 747, 754, 770, 777,\n+   783, 784, 786, 787, 790, 802, 825, 848, 847, 857,  55,  65,  66, 883, 892, 916,\n+   822, 824,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,1586,   0,1605,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1602,1603,1934,1935,1574,1575,1576,1577,1579,1580,1581,1583,1584,   0,\n+  1585,1587,1588,1589,1591,   0,1592,   0,1593,1594,   0,1595,1596,   0,1598,1599,\n+  1600,1601,1604,1582,1578,1590,1597,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1936,   0,1937,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,1938,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,1939,1940,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,1941,1942,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,1944,1943,   0,1945,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1946,1947,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+  1948,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,1949,1950,1951,1952,1953,1954,1955,   0,   0,   0,\n@@ -3871,0 +2742,36 @@\n+     0,   0,   0,1956,1957,1958,1960,1959,1961,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0, 106, 104, 107, 826, 114, 118, 119, 121,\n+   123, 124, 127, 125,  34, 830, 130, 131, 132, 137, 827,  35, 133, 139, 829, 142,\n+   143, 112, 144, 145, 924, 151, 152,  37, 157, 158, 159, 160,  38, 165, 166, 169,\n+   171, 172, 173, 174, 176, 177, 178, 179, 181, 182, 182, 182, 833, 468, 184, 185,\n+   834, 187, 188, 189, 196, 192, 194, 195, 197, 199, 200, 201, 203, 204, 204, 206,\n+   208, 209, 211, 218, 213, 219, 214, 216, 153, 234, 221, 222, 223, 220, 225, 224,\n+   230, 835, 235, 236, 237, 238, 239, 244, 836, 837, 247, 248, 249, 246, 251,  39,\n+    40, 253, 255, 255, 838, 257, 258, 259, 261, 839, 262, 263, 301, 264,  41, 266,\n+   270, 272, 271, 841, 274, 842, 277, 276, 278, 281, 282,  42, 283, 284, 285, 286,\n+    43, 843,  44, 289, 290, 291, 293, 934, 298, 845, 845, 621, 300, 300,  45, 852,\n+   894, 302, 304,  46, 306, 309, 310, 312, 316,  48,  47, 317, 846, 318, 323, 324,\n+   325, 324, 328, 329, 333, 331, 332, 334, 335, 336, 338, 339, 342, 343, 347, 351,\n+   849, 350, 348, 352, 354, 359, 850, 361, 358, 356,  49, 363, 365, 367, 364,  50,\n+   369, 371, 851, 376, 386, 378,  53, 381,  52,  51, 140, 141, 387, 382, 614,  78,\n+   388, 389, 390, 394, 392, 856,  54, 399, 396, 402, 404, 858, 405, 401, 407,  55,\n+   408, 409, 410, 413, 859, 415,  56, 417, 860, 418,  57, 419, 422, 424, 425, 861,\n+   840, 862, 426, 863, 429, 431, 427, 433, 437, 441, 438, 439, 442, 443, 864, 436,\n+   449, 450,  58, 454, 453, 865, 447, 460, 866, 867, 461, 466, 465, 464,  59, 467,\n+   470, 469, 472, 828, 475, 868, 478, 870, 483, 485, 486, 871, 488, 489, 872, 873,\n+   495, 497,  60, 498,  61,  61, 504, 505, 507, 508, 511,  62, 513, 874, 515, 875,\n+   518, 844, 520, 876, 877, 878,  63,  64, 528, 880, 879, 881, 882, 530, 531, 531,\n+   533,  66, 534,  67,  68, 884, 536, 538, 541,  69, 885, 549, 886, 887, 556, 559,\n+    70, 561, 562, 563, 888, 889, 889, 567,  71, 890, 570, 571,  72, 891, 577,  73,\n+   581, 579, 582, 893, 587,  74, 590, 592, 596,  75, 895, 896,  76, 897, 600, 898,\n+   602, 605, 607, 899, 900, 609, 901, 611, 853,  77, 615, 616,  79, 617, 252, 902,\n+   903, 854, 855, 621, 622, 731,  80, 627, 626, 628, 164, 629, 630, 631, 633, 904,\n+   632, 634, 639, 640, 635, 641, 646, 651, 638, 643, 644, 645, 905, 907, 906,  81,\n+   653, 654, 656, 911, 657, 908,  82,  83, 909, 910,  84, 664, 665, 666, 667, 669,\n+   668, 671, 670, 674, 672, 673, 675,  85, 677, 678,  86, 681, 682, 912, 685, 686,\n+    87, 689,  36, 913, 914,  88,  89, 696, 702, 709, 711, 915, 712, 713, 718, 719,\n+   917, 831, 721, 720, 723, 832, 725, 728, 918, 919, 739, 742, 744, 920, 745, 753,\n+   756, 757, 755, 760, 761, 921, 762,  90, 764, 922,  91, 775, 279, 780, 923, 925,\n+    92,  93, 785, 926,  94, 927, 787, 787, 789, 928, 792,  95, 796, 797, 798, 800,\n+    96, 929, 802, 804, 806,  97,  98, 807, 930,  99, 931, 932, 933, 814, 100, 816,\n+   817, 818, 819, 820, 821, 935,   0,   0,\n@@ -3893,1 +2800,1 @@\n-  return u<1114110u?_hb_ucd_u8[2176+(((_hb_ucd_u16[((_hb_ucd_u8[u>>4>>5])<<5)+((u>>4)&31u)])<<4)+((u)&15u))]:2;\n+  return u<1114110u?_hb_ucd_u8[6800+(((_hb_ucd_u8[1312+(((_hb_ucd_u16[((_hb_ucd_u8[544+(((_hb_ucd_u8[u>>1>>3>>3>>4])<<4)+((u>>1>>3>>3)&15u))])<<3)+((u>>1>>3)&7u)])<<3)+((u>>1)&7u))])<<1)+((u)&1u))]:2;\n@@ -3898,1 +2805,1 @@\n-  return u<125259u?_hb_ucd_u8[15332+(((_hb_ucd_u8[13892+(((_hb_ucd_u8[12912+(u>>3>>4)])<<4)+((u>>3)&15u))])<<3)+((u)&7u))]:0;\n+  return u<125259u?_hb_ucd_u8[8792+(((_hb_ucd_u8[8236+(((_hb_ucd_u8[7776+(((_hb_ucd_u8[7424+(((_hb_ucd_u8[7178+(u>>2>>2>>2>>3)])<<3)+((u>>2>>2>>2)&7u))])<<2)+((u>>2>>2)&3u))])<<2)+((u>>2)&3u))])<<2)+((u)&3u))]:0;\n@@ -3908,1 +2815,1 @@\n-  return u<65380u?_hb_ucd_i16[((_hb_ucd_u8[16692+(((_hb_ucd_b4(16564+_hb_ucd_u8,u>>2>>6))<<6)+((u>>2)&63u))])<<2)+((u)&3u)]:0;\n+  return u<65380u?_hb_ucd_i16[((_hb_ucd_u8[9540+(((_hb_ucd_u8[9420+(((_hb_ucd_b4(9292+_hb_ucd_u8,u>>2>>3>>3))<<3)+((u>>2>>3)&7u))])<<3)+((u>>2)&7u))])<<2)+((u)&3u)]:0;\n@@ -3913,1 +2820,1 @@\n-  return u<918000u?_hb_ucd_u8[19446+(((_hb_ucd_u16[3168+(((_hb_ucd_u8[17652+(u>>4>>5)])<<5)+((u>>4)&31u))])<<4)+((u)&15u))]:2;\n+  return u<918000u?_hb_ucd_u8[11062+(((_hb_ucd_u16[2040+(((_hb_ucd_u8[10326+(((_hb_ucd_u8[9876+(u>>3>>4>>4)])<<4)+((u>>3>>4)&15u))])<<4)+((u>>3)&15u))])<<3)+((u)&7u))]:2;\n@@ -3918,1 +2825,1 @@\n-  return u<195102u?_hb_ucd_u16[6400+(((_hb_ucd_u8[30070+(u>>6)])<<6)+((u)&63u))]:0;\n+  return u<195102u?_hb_ucd_u16[6008+(((_hb_ucd_u8[17068+(((_hb_ucd_u8[16686+(u>>4>>5)])<<5)+((u>>4)&31u))])<<4)+((u)&15u))]:0;\n@@ -3925,1 +2832,1 @@\n-_hb_ucd_u8[17936] =\n+_hb_ucd_u8[14744] =\n@@ -3933,1 +2840,1 @@\n-    7,  7, 43, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+    7,  7, 43,  7, 44, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n@@ -3955,1 +2862,1 @@\n-   44, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   45, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n@@ -3958,2 +2865,0 @@\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 45,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n@@ -3961,0 +2866,2 @@\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 47,\n@@ -3979,4 +2886,4 @@\n-  160,161,162,163,164,165,122,122,166,167,168,169,122,170,122,171,\n-   34, 34, 34, 34, 34, 34, 34,172,173, 34,174,122,122,122,122,122,\n-  122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,175,\n-   34, 34, 34, 34, 34, 34, 34, 34,176,122,122,122,122,122,122,122,\n+  160,161,162,163,164,165,166,122,167,168,169,170,122,171,172,173,\n+   34, 34, 34, 34, 34, 34, 34,174,175, 34,176,122,122,122,122,122,\n+  122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,177,\n+   34, 34, 34, 34, 34, 34, 34, 34,178,122,122,122,122,122,122,122,\n@@ -3984,24 +2891,25 @@\n-  122,122,122,122,122,122,122,122, 34, 34, 34, 34,177,122,122,122,\n-   34, 34, 34, 34,178,179,180,181,122,122,122,122,182,183,184,185,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,186,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34,187,188,122,122,122,122,122,\n-  122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,189,\n-   34, 34,190, 34, 34,191,122,122,122,122,122,122,122,122,122,122,\n-  122,122,122,122,122,122,122,122,192,193,122,122,122,122,122,122,\n-  122,122,122,122,122,122,122,122,122,122,122,122,122,122,194,195,\n-   69,196,197,198,199,200,201,122,202,203,204,205,206,207,208,209,\n-   69, 69, 69, 69,210,211,122,122,122,122,122,122,122,122,212,122,\n-  213,122,214,122,122,215,122,122,122,122,122,122,122,122,122,216,\n-   34,217,218,122,122,122,122,122,219,220,221,122,222,223,122,122,\n-  224,225,226,227,228,122, 69,229, 69, 69, 69, 69, 69,230,231,232,\n-  233,234, 69, 69,235,236, 69,237,122,122,122,122,122,122,122,122,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,238, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,239, 34,\n-  240, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,241, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34,242,122,122,122,122,122,122,122,122,\n-   34, 34, 34, 34,243,122,122,122,122,122,122,122,122,122,122,122,\n-   34, 34, 34, 34, 34, 34,244,122,122,122,122,122,122,122,122,122,\n-  245,122,246,247,122,122,122,122,122,122,122,122,122,122,122,122,\n-  107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,248,\n-  107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,249,\n+  122,122,122,122,122,122,122,122, 34, 34, 34, 34,179,122,122,122,\n+   34, 34, 34, 34,180,181,182,183,122,122,122,122,184,185,186,187,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,188,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34,189,190,122,122,122,122,122,\n+  122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,191,\n+   34, 34,192, 34, 34,193,122,122,122,122,122,122,122,122,122,122,\n+  122,122,122,122,122,122,122,122,194,195,122,122,122,122,122,122,\n+  122,122,122,122,122,122,122,122,122,122,122,122,122,122,196,197,\n+   69,198,199,200,201,202,203,122,204,205,206,207,208,209,210,211,\n+   69, 69, 69, 69,212,213,122,122,122,122,122,122,122,122,214,122,\n+  215,216,217,122,122,218,122,122,122,219,122,122,122,122,122,220,\n+   34,221,222,122,122,122,122,122,223,224,225,122,226,227,122,122,\n+  228,229,230,231,232,122, 69,233, 69, 69, 69, 69, 69,234,235,236,\n+  237,238, 69, 69,239,240, 69,241,122,122,122,122,122,122,122,122,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,242, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,243, 34,\n+  244, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,245, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34,246,122,122,122,122,122,122,122,122,\n+   34, 34, 34, 34,247,122,122,122,122,122,122,122,122,122,122,122,\n+   34, 34, 34, 34, 34, 34,248, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34,249,122,122,122,122,122,122,122,122,\n+  250,122,251,252,122,122,122,122,122,122,122,122,122,122,122,122,\n+  107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,253,\n+  107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,254,\n@@ -4070,1 +2978,1 @@\n-   62, 61, 44, 44, 44, 44, 44, 44, 43, 86, 36, 36, 36, 36, 61, 36,\n+   62, 94, 44, 44, 44, 44, 44, 44, 43, 86, 36, 36, 36, 36, 61, 36,\n@@ -4080,1 +2988,1 @@\n-   36, 36, 61, 81, 43, 43, 43, 44,  7,  7,  7,  7,  7, 44, 36, 36,\n+   36, 36, 61, 81, 43, 43, 43, 80,  7,  7,  7,  7,  7, 44, 36, 36,\n@@ -4247,12 +3155,13 @@\n-   36, 44, 44, 44, 44, 44, 44, 44, 27, 27, 27, 95, 44, 44, 44, 44,\n-  180, 27, 30,  2,  2, 44, 44, 44, 36, 43, 43,  2,  2, 44, 44, 44,\n-   36, 36,183, 27, 27, 27, 44, 44, 87, 98, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 43, 43, 43, 43, 43, 43, 43, 60,  2,  2,  2, 44,\n-   27, 27, 27,  7,  7,  7,  7,  7, 71, 70, 71, 44, 44, 44, 44, 57,\n-   86, 87, 43, 85, 87, 60,185,  2,  2, 80, 44, 44, 44, 44, 79, 44,\n-   43, 71, 36, 36, 36, 36, 36, 36, 36, 36, 36, 70, 43, 43, 87, 43,\n-   43, 43, 80,  7,  7,  7,  7,  7,  2,  2, 94, 98, 44, 44, 44, 44,\n-   36, 70,  2, 61, 44, 44, 44, 44, 36, 94, 86, 43, 43, 43, 43, 85,\n-   98, 36, 63,  2, 59, 43, 60, 87,  7,  7,  7,  7,  7, 63, 63,  2,\n-  179, 27, 27, 27, 27, 27, 27, 27, 27, 27,100, 44, 44, 44, 44, 44,\n-   36, 36, 36, 36, 36, 36, 86, 87, 43, 86, 85, 43,  2,  2,  2, 80,\n+   36, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 57, 43,\n+   27, 27, 27, 95, 44, 44, 44, 44,180, 27, 30,  2,  2, 44, 44, 44,\n+   36, 43, 43,  2,  2, 44, 44, 44, 36, 36,183, 27, 27, 27, 44, 44,\n+   87, 98, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 43, 43, 43, 43,\n+   43, 43, 43, 60,  2,  2,  2, 44, 27, 27, 27,  7,  7,  7,  7,  7,\n+   71, 70, 71, 44, 44, 44, 44, 57, 86, 87, 43, 85, 87, 60,185,  2,\n+    2, 80, 44, 44, 44, 44, 79, 44, 43, 71, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 70, 43, 43, 87, 43, 43, 43, 80,  7,  7,  7,  7,  7,\n+    2,  2, 94, 98, 44, 44, 44, 44, 36, 70,  2, 61, 44, 44, 44, 44,\n+   36, 94, 86, 43, 43, 43, 43, 85, 98, 36, 63,  2, 59, 43, 60, 87,\n+    7,  7,  7,  7,  7, 63, 63,  2,179, 27, 27, 27, 27, 27, 27, 27,\n+   27, 27,100, 44, 44, 44, 44, 44, 36, 36, 36, 36, 36, 36, 86, 87,\n+   43, 86, 85, 43,  2,  2,  2, 71, 70, 44, 44, 44, 44, 44, 44, 44,\n@@ -4280,7 +3189,9 @@\n-    2, 64, 44, 44, 44, 44, 44, 44, 43, 43, 43, 80, 43, 43, 43, 87,\n-   63,  2,  2, 44, 44, 44, 44, 44,  2, 36, 36, 36, 36, 36, 36, 36,\n-   44, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 89, 43, 43, 43,\n-   85, 43, 87, 80, 44, 44, 44, 44, 36, 36, 36, 61, 36, 62, 36, 36,\n-   70, 43, 43, 80, 44, 80, 43, 57, 43, 43, 43, 70, 44, 44, 44, 44,\n-   36, 36, 36, 62, 61, 36, 36, 36, 36, 36, 36, 36, 36, 86, 86, 90,\n-   43, 89, 87, 87, 61, 44, 44, 44, 36, 70, 85,107, 64, 44, 44, 44,\n+    2, 64, 44, 44, 44, 44, 44, 44,  2,  2,  2,  2,  2, 44, 44, 44,\n+   43, 43, 43, 80, 43, 43, 43, 87, 63,  2,  2, 44, 44, 44, 44, 44,\n+    2, 36, 36, 36, 36, 36, 36, 36, 44, 43, 43, 43, 43, 43, 43, 43,\n+   43, 43, 43, 43, 89, 43, 43, 43, 85, 43, 87, 80, 44, 44, 44, 44,\n+   36, 36, 36, 61, 36, 62, 36, 36, 70, 43, 43, 80, 44, 80, 43, 57,\n+   43, 43, 43, 70, 44, 44, 44, 44, 36, 36, 36, 62, 61, 36, 36, 36,\n+   36, 36, 36, 36, 36, 86, 86, 90, 43, 89, 87, 87, 61, 44, 44, 44,\n+   36, 70, 85,107, 64, 44, 44, 44, 43, 94, 36, 36, 36, 36, 36, 36,\n+   36, 36, 86, 43, 43, 80, 44, 86, 85, 60,  2,  2,  2,  2,  2,  2,\n@@ -4290,1 +3201,2 @@\n-   65, 65, 65, 65,132, 44, 44, 44, 43, 43, 60, 44, 44, 44, 44, 44,\n+   65, 65, 65, 65, 65, 65, 65, 65, 71, 36, 36, 70, 43, 43, 43, 43,\n+   43, 43, 43, 44, 44, 44, 44, 44, 43, 43, 60, 44, 44, 44, 44, 44,\n@@ -4298,1 +3210,2 @@\n-   36, 61, 44, 44, 44, 44, 44, 44, 44, 44, 36, 36, 44, 44, 44, 44,\n+   36, 61, 44, 44, 44, 44, 44, 44, 44, 61, 44, 44, 44, 44, 44, 44,\n+   36, 61, 62, 44, 44, 44, 44, 44, 44, 44, 36, 36, 44, 44, 44, 44,\n@@ -4323,4 +3236,6 @@\n-   43, 43, 43, 80, 43, 43, 43, 43, 43, 43, 43, 43, 80, 57, 43, 43,\n-   43, 57, 80, 43, 43, 80, 44, 44, 43, 43, 43, 74, 40, 40, 40, 44,\n-    7,  7,  7,  7,  7, 44, 44, 77, 36, 36, 36, 36, 36, 36, 36, 80,\n-   36, 36, 36, 36, 36, 36, 43, 43,  7,  7,  7,  7,  7, 44, 44, 96,\n+   44, 44,150, 16, 16,110, 44, 44, 43, 43, 43, 80, 43, 43, 43, 43,\n+   43, 43, 43, 43, 80, 57, 43, 43, 43, 57, 80, 43, 43, 80, 44, 44,\n+   40, 40, 40, 40, 40, 40, 40, 44, 44, 44, 44, 44, 44, 44, 44, 57,\n+   43, 43, 43, 74, 40, 40, 40, 44,  7,  7,  7,  7,  7, 44, 44, 77,\n+   36, 36, 36, 36, 36, 36, 36, 80, 36, 36, 36, 36, 36, 36, 43, 43,\n+    7,  7,  7,  7,  7, 44, 44, 96, 36, 36, 36, 36, 36, 83, 43, 43,\n@@ -4339,2 +3254,3 @@\n-   67, 67, 67, 67, 67, 25, 41, 41, 67, 67, 67, 67, 44, 44, 55, 67,\n-   67, 67, 67, 67, 44, 44, 44, 44, 67, 67, 92, 44, 67, 67, 92, 44,\n+   67, 67, 67, 67, 67, 25, 41, 41, 67, 67, 67, 67, 44, 44, 67, 67,\n+   67, 67, 67, 92, 44, 55, 67, 67, 67, 67, 67, 67, 44, 44, 44, 44,\n+   67, 67, 67, 67, 67, 67, 67, 55, 67, 67, 67, 44, 44, 44, 44, 67,\n@@ -4342,83 +3258,91 @@\n-   65, 65, 65, 65, 65, 65, 65, 65,171,171,171,171,171,171,171, 44,\n-  171,171,171,171,171,171,171,  0,  0,  0, 29, 21, 21, 21, 23, 21,\n-   22, 18, 21, 25, 21, 17, 13, 13, 25, 25, 25, 21, 21,  9,  9,  9,\n-    9, 22, 21, 18, 24, 16, 24,  5,  5,  5,  5, 22, 25, 18, 25,  0,\n-   23, 23, 26, 21, 24, 26,  7, 20, 25,  1, 26, 24, 26, 25, 15, 15,\n-   24, 15,  7, 19, 15, 21,  9, 25,  9,  5,  5, 25,  5,  9,  5,  7,\n-    7,  7,  9,  8,  8,  5,  7,  5,  6,  6, 24, 24,  6, 24, 12, 12,\n-    2,  2,  6,  5,  9, 21,  9,  2,  2,  9, 25,  9, 26, 12, 11, 11,\n-    2,  6,  5, 21, 17,  2,  2, 26, 26, 23,  2, 12, 17, 12, 21, 12,\n-   12, 21,  7,  2,  2,  7,  7, 21, 21,  2,  1,  1, 21, 23, 26, 26,\n-    1, 21,  6,  7,  7, 12, 12,  7, 21,  7, 12,  1, 12,  6,  6, 12,\n-   12, 26,  7, 26, 26,  7,  2,  1, 12,  2,  6,  2, 24,  7,  7,  6,\n-    1, 12, 12, 10, 10, 10, 10, 12, 21,  6,  2, 10, 10,  2, 15, 26,\n-   26,  2,  2, 21,  7, 10, 15,  7,  2, 23, 21, 26, 10,  7, 21, 15,\n-   15,  2, 17,  7, 29,  7,  7, 22, 18,  2, 14, 14, 14,  7, 10, 21,\n-   17, 21, 11, 12,  5,  2,  5,  6,  8,  8,  8, 24,  5, 24,  2, 24,\n-    9, 24, 24,  2, 29, 29, 29,  1, 17, 17, 20, 19, 22, 20, 27, 28,\n-    1, 29, 21, 20, 19, 21, 21, 16, 16, 21, 25, 22, 18, 21, 21, 29,\n-    1,  2, 15,  6, 18,  6, 23,  2, 12, 11,  9, 26, 26,  9, 26,  5,\n-    5, 26, 14,  9,  5, 14, 14, 15, 25, 26, 26, 22, 18, 26, 18, 25,\n-   18, 22,  5, 12,  2,  5, 22, 21, 21, 22, 18, 17, 26,  6,  7, 14,\n-   17, 22, 18, 18, 26, 14, 17,  6, 14,  6, 12, 24, 24,  6, 26, 15,\n-    6, 21, 11, 21, 24,  9,  6,  9, 23, 26,  6, 10,  4,  4,  3,  3,\n-    7, 25, 17, 16, 16, 22, 16, 16, 25, 17, 25,  2, 25, 24,  2, 15,\n-   12, 15, 14,  2, 21, 14,  7, 15, 12, 17, 21,  1, 26, 10, 10,  1,\n-   23, 15,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  0, 10, 11, 12,\n-   13,  0, 14,  0,  0,  0,  0,  0, 15,  0, 16,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0, 17, 18, 19,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 20,\n-    0, 21, 22, 23,  0,  0,  0, 24, 25, 26, 27, 28, 29, 30, 31, 32,\n-   33,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 34,  0, 35,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-   36,  0,  0,  0,  0,  0,  0,  0,  0,  0, 37, 38,  0,  0,  0,  0,\n-    0,  0, 39, 40,  0,  0, 41,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    1,  2,  3,  4,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,\n-    0,  0,  0,  0,  6,  7,  8,  0,  9,  0, 10, 11,  0,  0, 12, 13,\n-   14, 15, 16,  0,  0,  0,  0, 17, 18, 19, 20,  0, 21,  0, 22, 23,\n-    0, 24, 25,  0,  0, 24, 26, 27,  0, 24, 26,  0,  0, 24, 26,  0,\n-    0, 24, 26,  0,  0,  0, 26,  0,  0, 24, 28,  0,  0, 24, 26,  0,\n-    0, 29, 26,  0,  0,  0, 30,  0,  0, 31, 32,  0,  0, 33, 34,  0,\n-   35, 36,  0, 37, 38,  0, 39,  0,  0, 40,  0,  0, 41,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0, 42,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-   43, 44,  0,  0,  0,  0, 45,  0,  0,  0,  0,  0,  0, 46,  0,  0,\n-    0, 47,  0,  0,  0,  0,  0,  0, 48,  0,  0, 49,  0, 50, 51,  0,\n-    0, 52, 53, 54,  0, 55,  0, 56,  0, 57,  0,  0,  0,  0, 58, 59,\n-    0,  0,  0,  0,  0,  0, 60, 61,  0,  0,  0,  0,  0,  0, 62, 63,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 64,\n-    0,  0,  0, 65,  0,  0,  0, 66,  0, 67,  0,  0, 68,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 69, 70,  0,  0, 71,\n-    0,  0,  0,  0,  0,  0,  0,  0, 72, 73,  0,  0,  0,  0, 53, 74,\n-    0, 75, 76,  0,  0, 77, 78,  0,  0,  0,  0,  0,  0, 79, 80, 81,\n-    0,  0,  0,  0,  0,  0,  0, 26,  0,  0,  0,  0,  0,  0,  0,  0,\n-   82,  0,  0,  0,  0,  0,  0,  0,  0, 83,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 84,  0,  0,  0,  0,  0,  0,  0, 85,\n-    0,  0,  0, 86,  0,  0,  0,  0, 87, 88,  0,  0,  0,  0,  0, 89,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0, 90,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 91,  0,  0,\n-    0,  0, 92,  0, 93,  0,  0,  0,  0,  0, 72, 94,  0, 95,  0,  0,\n-   96, 97,  0, 77,  0,  0, 98,  0,  0, 99,  0,  0,  0,  0,  0,100,\n-    0,101, 26,102,  0,  0,  0,  0,  0,  0,103,  0,  0,  0,104,  0,\n-    0,  0,  0,  0,  0, 65,105,  0,  0, 65,  0,  0,  0,106,  0,  0,\n-    0,107,  0,  0,  0,  0,  0,  0,  0, 95,  0,  0,  0,  0,  0,  0,\n-    0,108,109,  0,  0,  0,  0, 78,  0, 44,110,  0,111,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0, 65,  0,  0,  0,  0,  0,  0,\n-    0,  0,112,  0,113,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,114,\n-    0,115,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,116,  0,  0,  0,  0,117,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,118,119,120,  0,  0,  0,  0,121,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,122,123,  0,  0,  0,  0,  0,  0,\n-    0,115,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,124,  0,125,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,126,  0,\n-    0,  0,127,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+  171,171,171,171,171,171,171, 44,171,171,171,171,171,171,171,  0,\n+    0,  0, 29, 21, 21, 21, 23, 21, 22, 18, 21, 25, 21, 17, 13, 13,\n+   25, 25, 25, 21, 21,  9,  9,  9,  9, 22, 21, 18, 24, 16, 24,  5,\n+    5,  5,  5, 22, 25, 18, 25,  0, 23, 23, 26, 21, 24, 26,  7, 20,\n+   25,  1, 26, 24, 26, 25, 15, 15, 24, 15,  7, 19, 15, 21,  9, 25,\n+    9,  5,  5, 25,  5,  9,  5,  7,  7,  7,  9,  8,  8,  5,  7,  5,\n+    6,  6, 24, 24,  6, 24, 12, 12,  2,  2,  6,  5,  9, 21,  9,  2,\n+    2,  9, 25,  9, 26, 12, 11, 11,  2,  6,  5, 21, 17,  2,  2, 26,\n+   26, 23,  2, 12, 17, 12, 21, 12, 12, 21,  7,  2,  2,  7,  7, 21,\n+   21,  2,  1,  1, 21, 23, 26, 26,  1, 21,  6,  7,  7, 12, 12,  7,\n+   21,  7, 12,  1, 12,  6,  6, 12, 12, 26,  7, 26, 26,  7,  2,  1,\n+   12,  2,  6,  2, 24,  7,  7,  6,  1, 12, 12, 10, 10, 10, 10, 12,\n+   21,  6,  2, 10, 10,  2, 15, 26, 26,  2,  2, 21,  7, 10, 15,  7,\n+    2, 23, 21, 26, 10,  7, 21, 15, 15,  2, 17,  7, 29,  7,  7, 22,\n+   18,  2, 14, 14, 14,  7, 10, 21, 17, 21, 11, 12,  5,  2,  5,  6,\n+    8,  8,  8, 24,  5, 24,  2, 24,  9, 24, 24,  2, 29, 29, 29,  1,\n+   17, 17, 20, 19, 22, 20, 27, 28,  1, 29, 21, 20, 19, 21, 21, 16,\n+   16, 21, 25, 22, 18, 21, 21, 29,  1,  2, 15,  6, 18,  6, 23,  2,\n+   12, 11,  9, 26, 26,  9, 26,  5,  5, 26, 14,  9,  5, 14, 14, 15,\n+   25, 26, 26, 22, 18, 26, 18, 25, 18, 22,  5, 12,  2,  5, 22, 21,\n+   21, 22, 18, 17, 26,  6,  7, 14, 17, 22, 18, 18, 26, 14, 17,  6,\n+   14,  6, 12, 24, 24,  6, 26, 15,  6, 21, 11, 21, 24,  9,  6,  9,\n+   23, 26,  6, 10,  4,  4,  3,  3,  7, 25, 17, 16, 16, 22, 16, 16,\n+   25, 17, 25,  2, 25, 24,  2, 15, 12, 15, 14,  2, 21, 14,  7, 15,\n+   12, 17, 21,  1, 26, 10, 10,  1, 23, 15,  0,  1,  2,  3,  4,  5,\n+    6,  7,  8,  9,  0, 10, 11, 12, 13,  0, 14,  0,  0,  0,  0,  0,\n+   15,  0, 16,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 17, 18, 19,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0, 20,  0, 21, 22, 23,  0,  0,  0, 24,\n+   25, 26, 27, 28, 29, 30, 31, 32, 33, 34,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 35,\n+    0, 36,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0, 37,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0, 38, 39,  0,  0,  0,  0,  0,  0, 40, 41, 42,  0, 43,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  0,  0,\n+    0,  0,  3,  0,  0,  0,  4,  5,  6,  7,  0,  8,  9, 10,  0, 11,\n+   12, 13, 14, 15, 16, 17, 16, 18, 16, 19, 16, 19, 16, 19,  0, 19,\n+   16, 20, 16, 19, 21, 19,  0, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+   31,  0, 32,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 33,  0,  0,\n+    0,  0,  0,  0, 34,  0,  0, 35,  0,  0, 36,  0, 37,  0,  0,  0,\n+   38, 39, 40, 41, 42, 43, 44, 45, 46,  0,  0, 47,  0,  0,  0, 48,\n+    0,  0,  0, 49,  0,  0,  0,  0,  0,  0,  0, 50,  0, 51,  0, 52,\n+   53,  0, 54,  0,  0,  0,  0,  0,  0, 55, 56, 57,  0,  0,  0,  0,\n+   58,  0,  0, 59, 60, 61, 62, 63,  0,  0, 64, 65,  0,  0,  0, 66,\n+    0,  0,  0,  0, 67,  0,  0,  0, 68,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0, 69,  0,  0,  0, 70,  0, 71,  0,  0,\n+   72,  0,  0, 73,  0,  0,  0,  0,  0,  0,  0,  0, 74,  0,  0,  0,\n+    0,  0, 75, 76,  0, 77, 78,  0,  0, 79, 80,  0, 81, 62,  0, 82,\n+   83,  0,  0, 84, 85, 86,  0,  0,  0, 87,  0, 88,  0,  0, 51, 89,\n+   51,  0, 90,  0, 91,  0,  0,  0, 80,  0,  0,  0, 92, 93,  0, 94,\n+   95, 96, 97,  0,  0,  0,  0,  0, 51,  0,  0,  0,  0, 98, 99,  0,\n+    0,  0,  0,  0,  0,100,  0,  0,  0,  0,  0,101,102,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,103,  0,  0,104,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,105,106,  0,  0,107,  0,  0,  0,  0,  0,  0,\n+  108,  0,109,  0,102,  0,  0,  0,  0,  0,110,111,  0,  0,  0,  0,\n+    0,  0,  0,112,  0,  0,  0,  0,  0,  0,  0,113,  0,114,  0,  0,\n+    0,  0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  0,  8,  0,  0,  0,\n+    0,  9, 10, 11, 12,  0,  0,  0,  0, 13,  0,  0, 14, 15,  0, 16,\n+    0, 17, 18,  0,  0, 19,  0, 20, 21,  0,  0,  0,  0,  0, 22, 23,\n+    0, 24, 25,  0,  0, 26,  0,  0,  0, 27,  0,  0, 28, 29, 30, 31,\n+    0,  0,  0, 32, 33, 34,  0,  0, 33,  0,  0, 35, 33,  0,  0,  0,\n+   33, 36,  0,  0,  0,  0,  0, 37, 38,  0,  0,  0,  0,  0,  0, 39,\n+   40,  0,  0,  0,  0,  0,  0, 41, 42,  0,  0,  0,  0, 43,  0, 44,\n+    0,  0,  0, 45, 46,  0,  0,  0, 47,  0,  0,  0,  0,  0,  0, 48,\n+   49,  0,  0,  0,  0, 50,  0,  0,  0, 51,  0, 52,  0, 53,  0,  0,\n+    0,  0, 54,  0,  0,  0,  0, 55,  0, 56,  0,  0,  0,  0, 57, 58,\n+    0,  0,  0, 59, 60,  0,  0,  0,  0,  0,  0, 61, 52,  0, 62, 63,\n+    0,  0, 64,  0,  0,  0, 65, 66,  0,  0,  0, 67,  0, 68, 69, 70,\n+   71, 72,  1, 73,  0, 74, 75, 76,  0,  0, 77, 78,  0,  0,  0, 79,\n+    0,  0,  1,  1,  0,  0, 80,  0,  0, 81,  0,  0,  0,  0, 77, 82,\n+    0, 83,  0,  0,  0,  0,  0, 78, 84,  0, 85,  0, 52,  0,  1, 78,\n+    0,  0, 86,  0,  0, 87,  0,  0,  0,  0,  0, 88, 57,  0,  0,  0,\n+    0,  0,  0, 89, 90,  0,  0, 84,  0,  0, 33,  0,  0, 91,  0,  0,\n+    0,  0, 92,  0,  0,  0,  0, 49,  0,  0, 93,  0,  0,  0,  0, 94,\n+   95,  0,  0, 96,  0,  0, 97,  0,  0,  0, 98,  0,  0,  0, 99,  0,\n+    0,  0,  0,100,101, 93,  0,  0,102,  0,  0,  0, 84,  0,  0,103,\n+    0,  0,  0,104,105,  0,  0,106,107,  0,  0,  0,  0,  0,  0,108,\n+    0,  0,109,  0,  0,  0,  0,110, 33,  0,111,112,113, 35,  0,  0,\n+  114,  0,  0,  0,115,  0,  0,  0,  0,  0,  0,116,  0,  0,117,  0,\n+    0,  0,  0,118, 88,  0,  0,  0,  0,  0, 57,  0,  0,  0,  0, 52,\n+  119,  0,  0,  0,  0,120,  0,  0,121,  0,  0,  0,  0,119,  0,  0,\n+  122,  0,  0,  0,  0,  0,  0,123,  0,  0,  0,124,  0,  0,  0,125,\n+    0,126,  0,  0,  0,  0,127,128,129,  0,130,  0,131,  0,  0,  0,\n+  132,133,134,  0, 77,  0,  0,  0,  0,  0, 35,  0,  0,  0,135,  0,\n+    0,  0,136,  0,  0,137,  0,  0,138,  0,  0,  0,  0,  0,  0,  0,\n@@ -4426,28 +3350,16 @@\n-    1, 11, 12, 13, 14, 15, 16, 17, 18,  1,  1,  1,  0,  0,  0,  0,\n-   19,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 20, 21, 22,  1,\n-   23,  4, 21, 24, 25, 26, 27, 28, 29, 30,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  1,  1, 31,  0,  0,  0, 32, 33, 34, 35,  1, 36,\n-    0,  0,  0,  0, 37,  0,  0,  0,  0,  0,  0,  0,  0, 38,  1, 39,\n-   14, 39, 40, 41,  0,  0,  0,  0,  0,  0,  0,  0, 42,  0,  0,  0,\n-    0,  0,  0,  0, 43, 36, 44, 45, 21, 45, 46,  0,  0,  0,  0,  0,\n-    0,  0, 19,  1, 21,  0,  0, 47,  0,  0,  0,  0,  0, 38, 48,  1,\n-    1, 49, 49, 50,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 51,  0,\n-    0,  0,  0,  0,  0,  0, 52,  1,  0,  0, 38, 14,  4,  1,  1,  1,\n-   53, 21, 43, 52, 54, 21, 35,  1,  0,  0,  0,  0,  0,  0,  0, 55,\n-    0,  0,  0, 56, 57, 58,  0,  0,  0,  0,  0, 56,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 59,  0,  0,  0, 56,  0, 60,  0,  0,\n-    0,  0,  0,  0,  0,  0, 61, 62,  0,  0, 63,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 64,  0,  0,  0, 65,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 66,  0,  0,  0, 67,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 68,  0,  0,  0,  0,  0,  0, 69, 70,  0,\n-    0,  0,  0,  0, 71, 72, 73, 74, 75, 76,  0,  0,  0,  0,  0,  0,\n-    0, 77,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 78, 79,  0,\n-    0,  0,  0, 47,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 49,\n-    0,  0,  0,  0,  0, 80,  0,  0,  0,  0,  0,  0,  0, 62,  0,  0,\n-    0,  0,  0,  0, 63,  0,  0, 81,  0,  0, 82,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 83,  0,  0,  0,  0,  0,  0, 19, 84,  0,\n-   62,  0,  0,  0,  0, 49,  1, 85,  0,  0,  0,  0,  1, 52, 15, 86,\n-   36, 10, 21, 87,  0,  0,  0,  0,  0,  0,  0,  0,  0, 55,  0,  0,\n-    0, 62,  0,  0,  0,  0,  0,  0,  0,  0, 19, 10,  1,  0,  0,  0,\n-    0,  0, 88,  0,  0,  0,  0,  0,  0, 89,  0,  0, 88,  0,  0,  0,\n-    0,  0,  0,  0,  0, 78,  0,  0,  0,  0,  0,  0, 87,  9, 12,  4,\n+    1, 11, 12, 13, 14, 15, 16, 17, 18,  1,  1,  1, 19,  1,  0,  0,\n+   20, 21, 22,  1, 23,  4, 21, 24, 25, 26, 27, 28, 29, 30,  0,  0,\n+    1,  1, 31,  0,  0,  0, 32, 33, 34, 35,  1, 36, 37,  0,  0,  0,\n+    0, 38,  1, 39, 14, 39, 40, 41, 42,  0,  0,  0, 43, 36, 44, 45,\n+   21, 45, 46,  0,  0,  0, 19,  1, 21,  0,  0, 47,  0, 38, 48,  1,\n+    1, 49, 49, 50,  0,  0, 51,  0,  0,  0, 52,  1,  0,  0, 38, 14,\n+    4,  1,  1,  1, 53, 21, 43, 52, 54, 21, 35,  1,  0,  0,  0, 55,\n+    0,  0,  0, 56, 57, 58,  0,  0,  0,  0,  0, 59,  0, 60,  0,  0,\n+    0,  0, 61, 62,  0,  0, 63,  0,  0,  0, 64,  0,  0,  0, 65,  0,\n+    0,  0, 66,  0,  0,  0, 67,  0,  0,  0, 68,  0,  0, 69, 70,  0,\n+   71, 72, 73, 74, 75, 76,  0,  0,  0, 77,  0,  0,  0, 78, 79,  0,\n+    0,  0,  0, 47,  0,  0,  0, 49,  0, 80,  0,  0,  0, 62,  0,  0,\n+   63,  0,  0, 81,  0,  0, 82,  0,  0,  0, 83,  0,  0, 19, 84,  0,\n+   62,  0,  0,  0,  0, 49,  1, 85,  1, 52, 15, 86, 36, 10, 21, 87,\n+    0, 55,  0,  0,  0,  0, 19, 10,  1,  0,  0,  0,  0,  0, 88,  0,\n+    0, 89,  0,  0, 88,  0,  0,  0,  0, 78,  0,  0, 87,  9, 12,  4,\n@@ -4455,34 +3367,17 @@\n-    1,  1,  1,  1,  1, 94, 95, 96,  0,  0,  0,  0, 97,  1, 98, 58,\n-   81, 99,100,  4, 58,  0,  0,  0,  0,  0,  0, 19, 50,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 61,  1,  1,  1,  1,  1,  1,  1,  1,\n-    0,  0,101,102,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,103,  0,\n-    0,  0,  0, 19,  0,  1,  1, 50,  0,  0,  0,  0,  0,  0,  0, 38,\n-    0,  0,  0,  0, 50,  0,  0,  0,  0, 63,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0, 62,  0,  0,  0,  0,  1,  1,  1,  1, 50,  0,  0,  0,\n-    0,  0,104, 68,  0,  0,  0,  0,  0,  0,  0,  0, 61,  0,  0,  0,\n-    0,  0,  0,  0, 78,  0,  0,  0, 62,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,105,106, 58, 38, 81,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0, 63,  0,  0,  0,  0,  0,  0,  0,  0,  0,107,\n-    1, 14,  4, 12,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 47,\n-   84,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 38, 87,  0,\n-    0,  0,  0,108,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,109, 61,\n-    0,110,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,\n-    0,  0, 19, 58,  0,  0,  0,  0,  0,111, 14, 52, 84,  0,  0,  0,\n-  112, 41,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 62,  0,  0, 61,\n-    0,  0,  0,  0,  0,  0,113,  0, 87,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0, 61, 62,  0,  0, 62,  0, 89,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,113,  0,  0,  0,  0,114,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 78, 55,  0, 38,  1, 58,  1, 58,  0,  0,\n-   63, 89,  0,  0,  0,  0,  0, 59,115,  0,  0,  0,  0,  0,  0,  0,\n-   55,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,115,  0,  0,\n-    0,  0, 61,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 79,\n-   78,  0,  0,  0,  0,  0,  0,  0,  0, 61,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 56,  0, 89, 80,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0, 61,  0,  0,  0,  0,  0,  0,  8, 91,  0,  0,\n-    0,  0,  0,  0,  1, 87,  0,  0,  0,  0,  0,  0,116,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,117,  0,118,119,120,121,  0,104,  4,\n-  122, 49, 23,  0,  0,  0,  0,  0,  0,  0, 38, 50,  0,  0,  0,  0,\n-   38, 58,  0,  0,  0,  0,  0,  0,  1, 87,  1,  1,  1,  1, 39,  1,\n-   48,105, 87,  0,  0,  0,  0,  0,  0,  0,  0, 59,  0,  0,  0,  0,\n-    0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  4,122,  0,  0,\n-    0,  1,123,  0,  0,  0,  0,  0,  0,  0,  0,  0,230,230,230,230,\n+    1, 94, 95, 96, 97,  1, 98, 58, 81, 99,100,  4, 58,  0,  0,  0,\n+    0,  0,  0, 19, 50,  0,  0,  0,  0,  0,  0, 61,  0,  0,101,102,\n+    0,  0,103,  0,  0,  1,  1, 50,  0,  0,  0, 38,  0, 63,  0,  0,\n+    0,  0,  0, 62,  0,  0,104, 68, 61,  0,  0,  0, 78,  0,  0,  0,\n+  105,106, 58, 38, 81,  0,  0,  0,  0,  0,  0,107,  1, 14,  4, 12,\n+   84,  0,  0,  0,  0, 38, 87,  0,  0,  0,  0,108,  0,  0,109, 61,\n+    0,110,  0,  0,  0,  1,  0,  0,  0,  0, 19, 58,  0,  0,  0, 51,\n+    0,111, 14, 52,112, 41,  0,  0, 62,  0,  0, 61,  0,  0,113,  0,\n+   87,  0,  0,  0, 61, 62,  0,  0, 62,  0, 89,  0,  0,113,  0,  0,\n+    0,  0,114,  0,  0,  0, 78, 55,  0, 38,  1, 58,  1, 58,  0,  0,\n+   63, 89,  0,  0,115,  0,  0,  0, 55,  0,  0,  0,  0,115,  0,  0,\n+    0,  0, 61,  0,  0,  0,  0, 79,  0, 61,  0,  0,  0,  0, 56,  0,\n+   89, 80,  0,  0, 79,  0,  0,  0,  8, 91,  0,  0,  1, 87,  0,  0,\n+  116,  0,  0,  0,  0,  0,  0,117,  0,118,119,120,121,  0,104,  4,\n+  122, 49, 23,  0,  0,  0, 38, 50, 38, 58,  0,  0,  1, 87,  1,  1,\n+    1,  1, 39,  1, 48,105, 87,  0,  0,  0,  0,  1,  0,  0,  0,123,\n+    4,122,  0,  0,  0,  1,124,  0,  0,  0,  0,  0,230,230,230,230,\n@@ -4519,3 +3414,2 @@\n-  220,220,220,  0,230,230,  7,  0, 16, 17, 17, 17, 17, 17, 17, 33,\n-   17, 17, 17, 19, 17, 17, 17, 17, 20,101, 17,113,129,169, 17, 27,\n-   28, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+  220,220,220,  0,232,232,220,230,230,230,  7,  0, 16, 17, 17, 33,\n+   17, 49, 17, 17, 84, 97,135,145, 26, 17, 17, 17, 17, 17, 17, 17,\n@@ -4524,36 +3418,41 @@\n-   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n-   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n-   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n-   17, 17, 17, 17, 17, 17, 17,237,  0,  1,  2,  2,  0,  3,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  4,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  5,  0,  0,  0,  0,  6,  7,  8,  9,  0,  0,  0,\n-   10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0, 20,  0,  0, 21, 22,  0,  0,  0,  0, 23, 24, 25, 26,\n-    0, 27,  0, 28, 29, 30, 31, 32,  0,  0,  0,  0,  0,  0,  0, 33,\n-   34, 35, 36,  0,  0,  0,  0,  0, 37,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0, 38, 39,  0,  0,  0,  0,  1,  2, 40, 41,  0,  1,  2,  2,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  2,\n-    0,  0,  0,  0,  0,  0,  3,  4,  0,  0,  5,  0,  0,  0,  6,  0,\n-    0,  0,  0,  0,  0,  0,  7,  1,  0,  0,  0,  0,  0,  0,  8,  9,\n-    0,  0,  0,  0,  0,  0, 10,  0,  0, 10,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 10,  0,  0,  0, 10,  0,  0,  0,  0,\n-    0,  0, 11, 12,  0, 13,  0, 14, 15, 16,  0,  0,  0,  0,  0,  1,\n-   17, 18,  0, 19,  7,  1,  0,  0,  0, 20, 20,  7, 20, 20, 20, 20,\n-   20, 20, 20,  8, 21,  0, 22,  0,  7, 23, 24,  0, 20, 20, 25,  0,\n-    0,  0, 26, 27,  1,  7, 20, 20, 20, 20, 20,  1, 28, 29, 30, 31,\n-    0,  0, 20,  0,  0,  0,  0,  0,  0,  0, 10,  0,  0,  0,  0,  0,\n-    0,  0, 20, 20, 20,  1,  0,  0,  8, 21, 32,  4,  0, 10,  0, 33,\n-    7, 20, 20, 20,  0,  0,  0,  0,  8, 34, 34, 35, 36, 34, 37,  0,\n-   38,  1, 20, 20,  0,  0, 39,  0,  1,  1,  0,  8, 21,  1, 20,  0,\n-    0,  0,  1,  0,  0, 40,  1,  1,  0,  0,  8, 21,  0,  1,  0,  1,\n-    0,  1,  0,  0,  0,  0, 26, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   21,  7, 20, 41, 34, 34, 34, 34, 34, 34, 34, 34, 34, 21,  0, 42,\n-   43, 44,  0, 45,  0,  8, 21,  0,  0,  0,  0,  0,  0,  0,  0, 46,\n-    7,  1, 10,  1,  0,  0,  0,  1, 20, 20,  1,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0, 26, 34,  9,  0,  0, 20, 20,  1, 20, 20,  0,\n-    0,  0,  0,  0,  0,  0, 26, 21,  0,  1,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  3, 47, 48,  0,  0,  0,  0,  0,  0,  0,\n-    0,  1,  2,  3,  4,  5,  6,  7,  7,  8,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  9, 10, 11, 11, 11, 11, 12, 13, 13, 13, 13, 14,\n-   15, 16, 17, 18, 19, 20, 21, 13, 22, 13, 13, 13, 13, 23, 24, 24,\n-   25, 26, 13, 13, 13, 27, 28, 29, 13, 30, 31, 32, 33, 34, 35, 36,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,177,  0,  1,  2,  3,\n+    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n+    4,  3,  3,  3,  3,  3,  5,  3,  3,  3,  3,  3,  6,  7,  8,  3,\n+    3,  3,  3,  3,  9, 10, 11, 12, 13,  3,  3,  3,  3,  3,  3,  3,\n+    3, 14,  3, 15,  3,  3,  3,  3,  3,  3, 16, 17, 18, 19, 20, 21,\n+    3,  3,  3, 22, 23, 24,  3,  3,  3,  3,  3,  3, 25,  3,  3,  3,\n+    3,  3,  3,  3,  3, 26,  3,  3, 27, 28,  0,  1,  0,  0,  0,  0,\n+    0,  1,  0,  2,  0,  0,  0,  3,  0,  0,  0,  3,  0,  0,  0,  0,\n+    0,  4,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  6,  0,  0,  0,  7,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  8,  9,  0,  0,  0,  0,  0,  0,  9,  0,  9,  0,  0,\n+    0,  0,  0,  0,  0, 10, 11, 12, 13,  0,  0, 14, 15, 16,  6,  0,\n+   17, 18, 19, 19, 19, 20, 21, 22, 23, 24, 19, 25,  0, 26, 27, 19,\n+   19, 28, 29, 30,  0, 31,  0,  0,  0,  8,  0,  0,  0,  0,  0,  0,\n+    0, 19, 28,  0, 32, 33,  9, 34, 35, 19,  0,  0, 36, 37, 38, 39,\n+   40, 19,  0, 41, 42, 43, 44, 31,  0,  1, 45, 42,  0,  0,  0,  0,\n+    0, 32, 14, 14,  0,  0,  0,  0, 14,  0,  0, 46, 47, 47, 47, 47,\n+   48, 49, 47, 47, 47, 47, 50, 51, 52, 53, 43, 21,  0,  0,  0,  0,\n+    0,  0,  0, 54,  6, 55,  0, 14, 19,  1,  0,  0,  0,  0, 56, 57,\n+    0,  0,  0,  0,  0, 19, 58, 31,  0,  0,  0,  0,  0,  0,  0, 59,\n+   14,  0,  0,  0,  0,  1,  0,  2,  0,  0,  0,  3,  0,  0,  0, 60,\n+   61,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  2,  3,\n+    0,  4,  5,  0,  0,  6,  0,  0,  0,  7,  0,  0,  0,  1,  1,  0,\n+    0,  8,  9,  0,  8,  9,  0,  0,  0,  0,  8,  9, 10, 11, 12,  0,\n+    0,  0, 13,  0,  0,  0,  0, 14, 15, 16, 17,  0,  0,  0,  1,  0,\n+    0, 18, 19,  0,  0,  0, 20,  0,  0,  0,  1,  1,  1,  1,  0,  1,\n+    1,  1,  1,  1,  1,  1,  0,  8, 21,  9,  0,  0, 22,  0,  0,  0,\n+    0,  1,  0, 23, 24, 25,  0,  0, 26,  0,  0,  0,  8, 21, 27,  0,\n+    1,  0,  0,  1,  1,  1,  1,  0,  1, 28, 29, 30,  0, 31, 32, 20,\n+    1,  1,  0,  0,  0,  8, 21,  9,  1,  4,  5,  0,  0,  0, 33,  9,\n+    0,  1,  1,  1,  0,  8, 21, 21, 21, 21, 34,  1, 35, 21, 21, 21,\n+    9, 36,  0,  0, 37, 38,  1,  0, 39,  0,  0,  0,  1,  0,  1,  0,\n+    0,  0,  0,  8, 21,  9,  1,  0,  0,  0, 40,  0,  8, 21, 21, 21,\n+   21, 21, 21, 21, 21,  9,  0,  1,  1,  1,  1,  8, 21, 21, 21,  9,\n+    0,  0,  0, 41,  0, 42, 43,  0,  0,  0,  1, 44,  0,  0,  0, 45,\n+    8,  9,  1,  0,  0,  0,  8, 21, 21, 21,  9,  0,  1,  0,  1,  1,\n+    8, 21, 21,  9,  0,  4,  5,  8,  9,  1,  0,  0,  0,  1,  2,  3,\n+    4,  5,  6,  7,  7,  8,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n+    9, 10, 11, 11, 11, 11, 12, 13, 13, 13, 13, 14, 15, 16, 17, 18,\n+   19, 20, 21, 13, 22, 13, 13, 13, 13, 23, 24, 24, 25, 26, 13, 13,\n+   13, 27, 28, 29, 13, 30, 31, 32, 33, 34, 35, 36,  7,  7,  7,  7,\n@@ -4561,3 +3460,2 @@\n-    7,  7,  7,  7, 37,  7, 38, 39,  7, 40,  7,  7,  7, 41, 13, 42,\n-    7,  7, 43, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   37,  7, 38, 39,  7, 40,  7,  7,  7, 41, 13, 42,  7,  7, 43,  7,\n+   44, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n@@ -4584,7 +3482,8 @@\n-   44,  0,  0,  1,  2,  2,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,\n-   12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\n-   28, 29, 30, 31, 32, 32, 33, 34, 35, 36, 37, 37, 37, 37, 37, 38,\n-   39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,  2,  2,\n-   53, 54, 55, 56, 57, 58, 59, 59, 59, 59, 60, 59, 59, 59, 59, 59,\n-   59, 59, 61, 61, 59, 59, 59, 59, 62, 63, 64, 65, 66, 67, 68, 69,\n-   70, 71, 72, 73, 74, 75, 76, 77, 78, 59, 70, 70, 70, 70, 70, 70,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 45,  0,  0,  1,\n+    2,  2,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n+   16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n+   32, 32, 33, 34, 35, 36, 37, 37, 37, 37, 37, 38, 39, 40, 41, 42,\n+   43, 44, 45, 46, 47, 48, 49, 50, 51, 52,  2,  2, 53, 54, 55, 56,\n+   57, 58, 59, 59, 59, 59, 60, 59, 59, 59, 59, 59, 59, 59, 61, 61,\n+   59, 59, 59, 59, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73,\n+   74, 75, 76, 77, 78, 59, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n@@ -4592,4 +3491,3 @@\n-   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 79, 70, 70,\n-   70, 70, 80, 80, 80, 80, 80, 80, 80, 80, 80, 81, 82, 82, 83, 84,\n-   85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 32, 32, 32, 32, 32, 32,\n-   32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+   70, 70, 70, 70, 70, 70, 70, 70, 70, 79, 70, 70, 70, 70, 80, 80,\n+   80, 80, 80, 80, 80, 80, 80, 81, 82, 82, 83, 84, 85, 86, 87, 88,\n+   89, 90, 91, 92, 93, 94, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n@@ -4597,7 +3495,1 @@\n-   32, 95, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n-   96, 96, 96, 96, 70, 70, 97, 98, 99,100,101,101,102,103,104,105,\n-  106,107,108,109,110,111, 96,112,113,114,115,116,117,118,119,119,\n-  120,121,122,123,124,125,126,127,128,129,130,131,132, 96,133,134,\n-  135,136,137,138,139,140,141,142,143, 96,144,145, 96,146,147,148,\n-  149, 96,150,151,152,153,154,155, 96, 96,156,157,158,159, 96,160,\n-   96,161,162,162,162,162,162,162,162,163,164,162,165, 96, 96, 96,\n+   32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 95, 96, 96,\n@@ -4605,17 +3497,25 @@\n-   96,166,167,167,167,167,167,167,167,167,168, 96, 96, 96, 96, 96,\n-   96, 96, 96, 96, 96, 96, 96, 96, 96, 96,169,169,169,169,170, 96,\n-   96, 96,171,171,171,171,172,173,174,175, 96, 96, 96, 96,176,177,\n-  178,179,180,180,180,180,180,180,180,180,180,180,180,180,180,180,\n-  180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,\n-  180,181,180,180,180,180,180,180,182,182,182,183,184, 96, 96, 96,\n-   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n-   96,185,186,187,188,189,189,190, 96, 96, 96, 96, 96, 96, 96, 96,\n-   96, 96, 96, 96, 96, 96, 96, 96, 96, 96,191,192, 96, 96, 96, 96,\n-   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n-  193,194, 59,195,196,197,198,199,200, 96,201,202,203, 59, 59,204,\n-   59,205,206,206,206,206,206,207, 96, 96, 96, 96, 96, 96, 96, 96,\n-  208, 96,209, 96,210, 96, 96,211, 96, 96, 96, 96, 96, 96, 96, 96,\n-   96,212,213,214,215, 96, 96, 96, 96, 96,216,217,218, 96,219,220,\n-   96, 96,221,222, 59,223,224, 96, 59, 59, 59, 59, 59, 59, 59,225,\n-  226,227,228,229, 59, 59,230,231, 59,232, 96, 96, 96, 96, 96, 96,\n-   96, 96, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,233,\n+   70, 70, 97, 98, 99,100,101,101,102,103,104,105,106,107,108,109,\n+  110,111, 96,112,113,114,115,116,117,118,119,119,120,121,122,123,\n+  124,125,126,127,128,129,130,131,132, 96,133,134,135,136,137,138,\n+  139,140,141,142,143, 96,144,145, 96,146,147,148,149, 96,150,151,\n+  152,153,154,155,156, 96,157,158,159,160, 96,161,162,163,164,164,\n+  164,164,164,164,164,165,166,164,167, 96, 96, 96, 96, 96, 96, 96,\n+   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,168,169,169,\n+  169,169,169,169,169,169,170, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n+   96, 96, 96, 96, 96, 96,171,171,171,171,172, 96, 96, 96,173,173,\n+  173,173,174,175,176,177, 96, 96, 96, 96,178,179,180,181,182,182,\n+  182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,182,\n+  182,182,182,182,182,182,182,182,182,182,182,182,182,183,182,182,\n+  182,182,182,182,184,184,184,185,186, 96, 96, 96, 96, 96, 96, 96,\n+   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,187,188,189,\n+  190,191,191,192, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n+   96, 96, 96, 96, 96, 96,193,194, 96, 96, 96, 96, 96, 96, 96, 96,\n+   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,195,196, 59,197,\n+  198,199,200,201,202, 96,203,204,205, 59, 59,206, 59,207,208,208,\n+  208,208,208,209, 96, 96, 96, 96, 96, 96, 96, 96,210, 96,211,212,\n+  213, 96, 96,214, 96, 96, 96,215, 96, 96, 96, 96, 96,216,217,218,\n+  219, 96, 96, 96, 96, 96,220,221,222, 96,223,224, 96, 96,225,226,\n+   59,227,228, 96, 59, 59, 59, 59, 59, 59, 59,229,230,231,232,233,\n+   59, 59,234,235, 59,236, 96, 96, 96, 96, 96, 96, 96, 96, 70, 70,\n+   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,237, 70, 70, 70, 70,\n+   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,238, 70,239, 70,\n@@ -4623,150 +3523,70 @@\n-  234, 70,235, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n-   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,236,\n-   70, 70, 70, 70, 70, 70, 70, 70, 70,237, 96, 96, 96, 96, 96, 96,\n-   96, 96, 70, 70, 70, 70,238, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n-   96, 96, 70, 70, 70, 70, 70, 70,239, 96, 96, 96, 96, 96, 96, 96,\n-   96, 96,240, 96,241,242,  0,  1,  2,  2,  0,  1,  2,  2,  2,  3,\n-    4,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19,\n-   19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,  0,  0,  0,\n-    0,  0,  0,  0, 19,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19, 19,\n-   19,  0, 19,  0,  0,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19,  0,\n-    0,  0,  0,  0, 26, 26,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,\n-    1,  1,  9,  9,  9,  9,  0,  9,  9,  9,  2,  2,  9,  9,  9,  9,\n-    0,  9,  2,  2,  2,  2,  9,  0,  9,  0,  9,  9,  9,  2,  9,  2,\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  2,  9,  9,  9,\n-    9,  9,  9,  9, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55,\n-   55, 55,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  1,\n-    1,  6,  2,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,\n-    4,  4,  4,  4,  4,  4,  4,  4,  4,  2,  4,  4,  4,  2,  2,  4,\n-    4,  4,  2, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14,  2,  2,  2,  2,  2,  2,  2,  2, 14, 14, 14,  2,  2,  2,\n-    2, 14, 14, 14, 14, 14, 14,  2,  2,  2,  3,  3,  3,  3,  3,  0,\n-    3,  3,  3,  3,  3,  3,  0,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    3,  3,  3,  3,  3,  0,  3,  3,  3,  0,  0,  3,  3,  3,  3,  3,\n-    3,  3,  3,  3,  3,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n-    3,  3,  1,  3,  3,  3,  3,  3,  3,  3, 37, 37, 37, 37, 37, 37,\n-   37, 37, 37, 37, 37, 37, 37, 37,  2, 37, 37, 37, 37,  2,  2, 37,\n-   37, 37, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38,  2,  2,  2,  2,\n-    2,  2, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,  2,  2, 64,\n-   64, 64, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,\n-    2,  2, 90, 90, 90, 90, 90, 90, 90,  2, 95, 95, 95, 95, 95, 95,\n-   95, 95, 95, 95, 95, 95,  2,  2, 95,  2, 37, 37, 37,  2,  2,  2,\n-    2,  2,  3,  3,  3,  3,  3,  3,  3,  2,  3,  3,  2,  2,  2,  2,\n-    2,  2,  3,  3,  0,  3,  3,  3,  3,  3,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  1,  1,  1,  1,  7,  7,  7,  7,  7,  7,  7,  0,  0,\n-    7,  7,  5,  5,  5,  5,  2,  5,  5,  5,  5,  5,  5,  5,  5,  2,\n-    2,  5,  5,  2,  2,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n-    5,  5,  5,  2,  5,  5,  5,  5,  5,  5,  5,  2,  5,  2,  2,  2,\n-    5,  5,  5,  5,  2,  2,  5,  5,  5,  5,  5,  2,  2,  5,  5,  5,\n-    5,  2,  2,  2,  2,  2,  2,  2,  2,  5,  2,  2,  2,  2,  5,  5,\n-    2,  5,  5,  5,  5,  5,  2,  2,  5,  5,  5,  5,  5,  5,  5,  5,\n-    5,  2,  2, 11, 11, 11,  2, 11, 11, 11, 11, 11, 11,  2,  2,  2,\n-    2, 11, 11,  2,  2, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n-   11, 11, 11,  2, 11, 11, 11, 11, 11, 11, 11,  2, 11, 11,  2, 11,\n-   11,  2, 11, 11,  2,  2, 11,  2, 11, 11, 11,  2,  2, 11, 11, 11,\n-    2,  2,  2, 11,  2,  2,  2,  2,  2,  2,  2, 11, 11, 11, 11,  2,\n-   11,  2,  2,  2,  2,  2,  2,  2, 11, 11, 11, 11, 11, 11, 11, 11,\n-   11,  2,  2, 10, 10, 10,  2, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n-    2, 10, 10, 10,  2, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n-   10, 10, 10,  2, 10, 10, 10, 10, 10, 10, 10,  2, 10, 10,  2, 10,\n-   10, 10, 10, 10,  2,  2, 10, 10, 10, 10, 10, 10,  2, 10, 10, 10,\n-    2,  2, 10,  2,  2,  2,  2,  2,  2,  2, 10, 10, 10, 10,  2,  2,\n-   10, 10, 10, 10,  2,  2,  2,  2,  2,  2,  2, 10, 10, 10, 10, 10,\n-   10, 10,  2, 21, 21, 21,  2, 21, 21, 21, 21, 21, 21, 21, 21,  2,\n-    2, 21, 21,  2,  2, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21,  2, 21, 21, 21, 21, 21, 21, 21,  2, 21, 21,  2, 21,\n-   21, 21, 21, 21,  2,  2, 21, 21, 21, 21, 21,  2,  2, 21, 21, 21,\n-    2,  2,  2,  2,  2,  2,  2, 21, 21, 21,  2,  2,  2,  2, 21, 21,\n-    2, 21, 21, 21, 21, 21,  2,  2, 21, 21,  2,  2, 22, 22,  2, 22,\n-   22, 22, 22, 22, 22,  2,  2,  2, 22, 22, 22,  2, 22, 22, 22, 22,\n-    2,  2,  2, 22, 22,  2, 22,  2, 22, 22,  2,  2,  2, 22, 22,  2,\n-    2,  2, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,  2,  2,  2,  2,\n-   22, 22, 22,  2,  2,  2,  2,  2,  2, 22,  2,  2,  2,  2,  2,  2,\n-   22, 22, 22, 22, 22,  2,  2,  2,  2,  2, 23, 23, 23, 23, 23, 23,\n-   23, 23, 23, 23, 23, 23, 23,  2, 23, 23, 23,  2, 23, 23, 23, 23,\n-   23, 23, 23, 23,  2,  2, 23, 23, 23, 23, 23,  2, 23, 23, 23, 23,\n-    2,  2,  2,  2,  2,  2,  2, 23, 23,  2, 23, 23, 23,  2,  2, 23,\n-    2,  2, 23, 23, 23, 23,  2,  2, 23, 23,  2,  2,  2,  2,  2,  2,\n-    2, 23, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,  2,\n-   16, 16, 16,  2, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,  2, 16,\n-   16, 16, 16, 16,  2,  2, 16, 16, 16, 16, 16,  2, 16, 16, 16, 16,\n-    2,  2,  2,  2,  2,  2,  2, 16, 16,  2, 16, 16, 16, 16,  2,  2,\n-   16, 16,  2, 16, 16,  2,  2,  2,  2,  2, 20, 20, 20, 20, 20, 20,\n-   20, 20, 20, 20, 20, 20, 20,  2, 20, 20, 20,  2, 20, 20, 20, 20,\n-   20, 20,  2,  2,  2,  2, 20, 20, 20, 20, 20, 20, 20, 20,  2,  2,\n-   20, 20,  2, 36, 36, 36,  2, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36,  2,  2,  2, 36, 36, 36, 36,\n-   36, 36, 36, 36,  2, 36, 36, 36, 36, 36, 36, 36, 36, 36,  2, 36,\n-    2,  2,  2,  2, 36,  2,  2,  2,  2, 36, 36, 36, 36, 36, 36,  2,\n-   36,  2,  2,  2,  2,  2,  2,  2, 36, 36,  2,  2, 36, 36, 36,  2,\n-    2,  2,  2, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n-   24, 24, 24, 24, 24,  2,  2,  2,  2,  0, 24, 24, 24, 24,  2,  2,\n-    2,  2,  2, 18, 18,  2, 18,  2, 18, 18, 18, 18, 18,  2, 18, 18,\n-   18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,  2, 18,\n-    2, 18, 18, 18, 18, 18, 18, 18,  2,  2, 18, 18, 18, 18, 18,  2,\n-   18,  2, 18, 18,  2,  2, 18, 18, 18, 18, 25, 25, 25, 25, 25, 25,\n-   25, 25,  2, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,  2,\n-    2,  2, 25, 25, 25, 25, 25,  2, 25, 25, 25, 25, 25, 25, 25,  0,\n-    0,  0,  0, 25, 25,  2,  2,  2,  2,  2, 33, 33, 33, 33, 33, 33,\n-   33, 33,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n-    2,  8,  2,  2,  2,  2,  2,  8,  2,  2,  8,  8,  8,  0,  8,  8,\n-    8,  8, 12, 12, 12, 12, 12, 12, 12, 12, 30, 30, 30, 30, 30, 30,\n-   30, 30, 30,  2, 30, 30, 30, 30,  2,  2, 30, 30, 30, 30, 30, 30,\n-   30,  2, 30, 30, 30,  2,  2, 30, 30, 30, 30, 30, 30, 30, 30,  2,\n-    2,  2, 30, 30,  2,  2,  2,  2,  2,  2, 29, 29, 29, 29, 29, 29,\n-   29, 29, 29, 29, 29, 29, 29, 29,  2,  2, 28, 28, 28, 28, 28, 28,\n-   28, 28, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,  2,\n-    2,  2, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,  0,  0,  0,\n-   35, 35, 35,  2,  2,  2,  2,  2,  2,  2, 45, 45, 45, 45, 45, 45,\n-   45, 45, 45, 45, 45, 45, 45, 45,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2, 45, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44,  0,\n-    0,  2, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  2,  2,\n-    2,  2, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,  2,\n-   46, 46, 46,  2, 46, 46,  2,  2,  2,  2, 31, 31, 31, 31, 31, 31,\n-   31, 31, 31, 31, 31, 31, 31, 31,  2,  2, 31, 31,  2,  2,  2,  2,\n-    2,  2, 32, 32,  0,  0, 32,  0, 32, 32, 32, 32, 32, 32, 32, 32,\n-   32, 32, 32, 32,  2,  2,  2,  2,  2,  2, 32,  2,  2,  2,  2,  2,\n-    2,  2, 32, 32, 32,  2,  2,  2,  2,  2, 28, 28, 28, 28, 28, 28,\n-    2,  2, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n-   48,  2, 48, 48, 48, 48,  2,  2,  2,  2, 48,  2,  2,  2, 48, 48,\n-   48, 48, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n-    2,  2, 52, 52, 52, 52, 52,  2,  2,  2, 58, 58, 58, 58, 58, 58,\n-   58, 58, 58, 58, 58, 58,  2,  2,  2,  2, 58, 58,  2,  2,  2,  2,\n-    2,  2, 58, 58, 58,  2,  2,  2, 58, 58, 54, 54, 54, 54, 54, 54,\n-   54, 54, 54, 54, 54, 54,  2,  2, 54, 54, 91, 91, 91, 91, 91, 91,\n-   91, 91, 91, 91, 91, 91, 91, 91, 91,  2, 91, 91, 91, 91, 91,  2,\n-    2, 91, 91, 91,  2,  2,  2,  2,  2,  2, 91, 91, 91, 91, 91, 91,\n-    2,  2,  1,  1,  1,  1,  1,  1,  1,  2, 62, 62, 62, 62, 62, 62,\n-   62, 62, 62, 62, 62, 62, 62,  2,  2,  2, 62, 62, 62, 62, 62, 62,\n-   62,  2, 76, 76, 76, 76, 76, 76, 76, 76, 93, 93, 93, 93, 93, 93,\n-   93, 93, 93, 93, 93, 93,  2,  2,  2,  2,  2,  2,  2,  2, 93, 93,\n-   93, 93, 70, 70, 70, 70, 70, 70, 70, 70,  2,  2,  2, 70, 70, 70,\n-   70, 70, 70, 70,  2,  2,  2, 70, 70, 70, 73, 73, 73, 73, 73, 73,\n-   73, 73,  6,  2,  2,  2,  2,  2,  2,  2,  8,  8,  8,  2,  2,  8,\n-    8,  8,  1,  1,  1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,\n-    1,  1,  1,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  0,\n-    0,  0,  1,  1,  0,  2,  2,  2,  2,  2, 19, 19, 19, 19, 19, 19,\n-    9,  9,  9,  9,  9,  6, 19, 19, 19, 19, 19, 19, 19, 19, 19,  9,\n-    9,  9,  9,  9, 19, 19, 19, 19,  9,  9,  9,  9,  9, 19, 19, 19,\n-   19, 19,  6, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n-   19,  9,  9,  9,  9,  9,  9,  9,  2,  2,  2,  9,  2,  9,  2,  9,\n-    2,  9,  9,  9,  9,  9,  9,  2,  9,  9,  9,  9,  9,  9,  2,  2,\n-    9,  9,  9,  9,  9,  9,  2,  9,  9,  9,  2,  2,  9,  9,  9,  2,\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  2,  0,  0,  0,  0,  1,  1,\n-    0,  0,  0,  0,  0,  0,  0,  2,  0,  0,  0, 19,  2,  2,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0, 19,  0,  0,  0,  0,  0,  0,\n-    0,  2, 19, 19, 19, 19, 19,  2,  2,  2,  0,  2,  2,  2,  2,  2,\n-    2,  2,  1,  2,  2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,\n-    9,  0,  0,  0, 19, 19,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-   19,  0, 19,  0,  0,  0,  2,  2,  2,  2,  0,  0,  0,  2,  2,  2,\n-    2,  2, 27, 27, 27, 27, 27, 27, 27, 27,  0,  0,  0,  0,  2,  2,\n-    0,  0,  0,  0,  0,  0,  0,  0,  2,  0, 56, 56, 56, 56, 56, 56,\n-   56, 56, 55, 55, 55, 55,  2,  2,  2,  2,  2, 55, 55, 55, 55, 55,\n-   55, 55, 61, 61, 61, 61, 61, 61, 61, 61,  2,  2,  2,  2,  2,  2,\n-    2, 61, 61,  2,  2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,\n-    2,  2, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,  2, 13, 13, 13,\n-   13, 13, 13, 13, 13, 13,  2,  2,  2,  2, 13, 13, 13, 13, 13, 13,\n-    2,  2,  0,  0,  0,  0,  2,  2,  2,  2,  0,  0,  0,  0,  0, 13,\n-    0, 13,  0, 13, 13, 13, 13, 13, 13, 13, 13, 13,  1,  1,  1,  1,\n-   12, 12, 13, 13, 13, 13,  0,  0,  0,  0,  2, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n+   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,240, 70, 70, 70, 70,\n+   70, 70, 70, 70, 70,241, 96, 96, 96, 96, 96, 96, 96, 96, 70, 70,\n+   70, 70,242, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 70, 70,\n+   70, 70, 70, 70,243, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n+   70, 70, 70, 70, 70,244, 96, 96, 96, 96, 96, 96, 96, 96,245, 96,\n+  246,247,  0,  1,  2,  2,  0,  1,  2,  2,  2,  3,  4,  5,  0,  0,\n+    0,  0,  0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,  0,  0,  0,\n+   19,  0, 19,  0,  0,  0,  0,  0, 26, 26,  1,  1,  1,  1,  9,  9,\n+    9,  9,  0,  9,  9,  9,  2,  2,  9,  9,  9,  9,  0,  9,  2,  2,\n+    2,  2,  9,  0,  9,  0,  9,  9,  9,  2,  9,  2,  9,  9,  9,  9,\n+    2,  9,  9,  9, 55, 55, 55, 55, 55, 55,  6,  6,  6,  6,  6,  1,\n+    1,  6,  2,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  2,  2, 14,\n+   14, 14, 14, 14, 14, 14, 14, 14, 14,  2,  2,  2,  2, 14, 14,  2,\n+    2,  2,  3,  3,  3,  3,  3,  0,  3,  3,  0,  3,  3,  3,  3,  3,\n+    3,  0,  3,  3,  3,  1,  1,  1,  3,  3,  1,  3,  3,  3, 37, 37,\n+   37, 37, 37, 37,  2, 37, 37, 37, 37,  2,  2, 37, 37, 37, 38, 38,\n+   38, 38, 38, 38,  2,  2, 64, 64, 64, 64, 64, 64, 64,  2,  2, 64,\n+   64, 64, 90, 90, 90, 90, 90, 90,  2,  2, 90, 90, 90,  2, 95, 95,\n+   95, 95,  2,  2, 95,  2,  3,  3,  3,  2,  3,  3,  2,  2,  3,  3,\n+    0,  3,  7,  7,  7,  7,  7,  1,  1,  1,  1,  7,  7,  7,  0,  0,\n+    7,  7,  5,  5,  5,  5,  2,  5,  5,  5,  5,  2,  2,  5,  5,  2,\n+    5,  5,  5,  2,  5,  2,  2,  2,  5,  5,  5,  5,  2,  2,  5,  5,\n+    5,  2,  2,  2,  2,  5,  5,  5,  2,  5,  2, 11, 11, 11, 11, 11,\n+   11,  2,  2,  2,  2, 11, 11,  2,  2, 11, 11, 11, 11, 11, 11,  2,\n+   11, 11,  2, 11, 11,  2, 11, 11,  2,  2,  2, 11,  2,  2, 11,  2,\n+   11,  2,  2,  2, 11, 11,  2, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n+    2, 10, 10,  2, 10, 10, 10, 10,  2,  2, 10,  2,  2,  2,  2,  2,\n+   10, 10,  2, 21, 21, 21, 21, 21, 21, 21, 21,  2,  2, 21, 21,  2,\n+   21, 21, 21, 21,  2,  2, 21, 21,  2, 21,  2,  2, 21, 21,  2,  2,\n+   22, 22,  2, 22, 22, 22, 22, 22, 22,  2, 22,  2, 22, 22, 22, 22,\n+    2,  2,  2, 22, 22,  2,  2,  2,  2, 22, 22,  2,  2,  2, 22, 22,\n+   22, 22, 23, 23, 23, 23, 23,  2, 23, 23, 23, 23,  2,  2,  2, 23,\n+   23,  2, 23, 23, 23,  2,  2, 23,  2,  2,  2,  2, 23, 23,  2,  2,\n+    2, 23, 16, 16, 16, 16, 16,  2, 16, 16,  2, 16, 16, 16, 16, 16,\n+    2,  2,  2, 16, 16,  2,  2,  2, 16, 16, 20, 20, 20, 20, 20,  2,\n+   20, 20,  2,  2, 20, 20,  2, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n+   36,  2,  2,  2, 36, 36, 36, 36,  2, 36,  2, 36,  2,  2,  2,  2,\n+   36,  2,  2,  2,  2, 36, 36,  2, 36,  2, 36,  2,  2,  2,  2, 24,\n+   24, 24, 24, 24, 24, 24, 24, 24, 24,  2,  2,  2,  2,  0,  2, 18,\n+   18,  2, 18,  2, 18, 18, 18, 18, 18,  2, 18, 18, 18, 18,  2, 18,\n+    2, 18, 18, 18,  2,  2, 18,  2, 18,  2, 25, 25, 25, 25,  2, 25,\n+   25, 25, 25,  2,  2,  2, 25,  2, 25, 25, 25,  0,  0,  0,  0, 25,\n+   25,  2, 33, 33, 33, 33,  8,  8,  8,  8,  8,  8,  2,  8,  2,  8,\n+    2,  2,  8,  8,  8,  0, 12, 12, 12, 12, 30, 30, 30, 30, 30,  2,\n+   30, 30, 30, 30,  2,  2, 30, 30, 30,  2,  2, 30, 30, 30, 30,  2,\n+    2,  2, 29, 29, 29, 29, 29, 29,  2,  2, 28, 28, 28, 28, 34, 34,\n+   34, 34, 34,  2,  2,  2, 35, 35, 35, 35, 35, 35, 35,  0,  0,  0,\n+   35, 35, 35,  2,  2,  2, 45, 45, 45, 45, 45, 45,  2,  2,  2,  2,\n+    2, 45, 44, 44, 44, 44, 44,  0,  0,  2, 43, 43, 43, 43, 46, 46,\n+   46, 46, 46,  2, 46, 46, 31, 31, 31, 31, 31, 31,  2,  2, 32, 32,\n+    0,  0, 32,  0, 32, 32, 32, 32, 32, 32, 32, 32,  2,  2, 32,  2,\n+    2,  2, 32, 32, 32,  2, 28, 28,  2,  2, 48, 48, 48, 48, 48, 48,\n+   48,  2, 48,  2,  2,  2, 52, 52, 52, 52, 52, 52,  2,  2, 52,  2,\n+    2,  2, 58, 58, 58, 58, 58, 58,  2,  2, 58, 58, 58,  2,  2,  2,\n+   58, 58, 54, 54, 54, 54,  2,  2, 54, 54, 91, 91, 91, 91, 91, 91,\n+   91,  2, 91,  2,  2, 91, 91, 91,  2,  2,  1,  1,  1,  2, 62, 62,\n+   62, 62, 62,  2,  2,  2, 62, 62, 62,  2, 76, 76, 76, 76, 93, 93,\n+   93, 93, 70, 70, 70, 70,  2,  2,  2, 70, 70, 70,  2,  2,  2, 70,\n+   70, 70, 73, 73, 73, 73,  6,  2,  2,  2,  8,  8,  8,  2,  2,  8,\n+    8,  8,  1,  1,  1,  0,  1,  0,  1,  1,  1,  0,  0,  0,  0,  1,\n+    0,  0,  1,  1,  0,  2, 19, 19,  9,  9,  9,  9,  9,  6, 19,  9,\n+    9,  9,  9,  9, 19, 19,  9,  9,  9, 19,  6, 19, 19, 19, 19, 19,\n+   19,  9,  9,  9,  2,  2,  2,  9,  2,  9,  2,  9,  9,  9,  1,  1,\n+    0,  0,  0,  2,  0,  0,  0, 19,  2,  2,  0,  0,  0, 19,  0,  0,\n+    0,  2, 19,  2,  2,  2,  0,  2,  2,  2,  1,  2,  2,  2,  0,  0,\n+    9,  0,  0,  0, 19, 19, 27, 27, 27, 27,  2,  2,  0,  0,  0,  0,\n+    2,  0, 56, 56, 56, 56,  2, 55, 55, 55, 61, 61, 61, 61,  2,  2,\n+    2, 61, 61,  2,  2,  2,  0,  0,  2,  2, 13, 13, 13, 13, 13, 13,\n+    2, 13, 13, 13,  2,  2,  0, 13,  0, 13,  0, 13, 13, 13, 13, 13,\n+    1,  1,  1,  1, 12, 12,  2, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n@@ -4774,185 +3594,81 @@\n-   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,  0,  0, 17,\n-   17, 17,  2,  2,  2,  2,  2, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26,  2, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12,  2, 12, 12, 12, 12, 12, 12, 12,  0, 17, 17, 17, 17, 17, 17,\n-   17,  0, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,  2,\n-    2,  2, 39, 39, 39, 39, 39, 39, 39,  2, 86, 86, 86, 86, 86, 86,\n-   86, 86, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,  2,  2,\n-    2,  2, 79, 79, 79, 79, 79, 79, 79, 79,  0,  0, 19, 19, 19, 19,\n-   19, 19,  0,  0,  0, 19, 19, 19, 19, 19, 19, 19, 19,  2,  2,  2,\n-    2,  2, 19, 19,  2, 19,  2, 19, 19, 19, 19, 19,  2,  2,  2,  2,\n-    2,  2,  2,  2, 19, 19, 19, 19, 19, 19, 60, 60, 60, 60, 60, 60,\n-   60, 60, 60, 60, 60, 60, 60,  2,  2,  2,  0,  0,  2,  2,  2,  2,\n-    2,  2, 65, 65, 65, 65, 65, 65, 65, 65, 75, 75, 75, 75, 75, 75,\n-   75, 75, 75, 75, 75, 75, 75, 75,  2,  2,  2,  2,  2,  2,  2,  2,\n-   75, 75, 75, 75,  2,  2,  2,  2,  2,  2, 69, 69, 69, 69, 69, 69,\n-   69, 69, 69, 69, 69, 69, 69, 69,  0, 69, 74, 74, 74, 74, 74, 74,\n-   74, 74, 74, 74, 74, 74,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2, 74, 12, 12, 12, 12, 12,  2,  2,  2, 84, 84, 84, 84, 84, 84,\n-   84, 84, 84, 84, 84, 84, 84, 84,  2,  0, 84, 84,  2,  2,  2,  2,\n-   84, 84, 33, 33, 33, 33, 33, 33, 33,  2, 68, 68, 68, 68, 68, 68,\n-   68, 68, 68, 68, 68, 68, 68, 68, 68,  2, 68, 68, 68, 68, 68, 68,\n-    2,  2, 68, 68,  2,  2, 68, 68, 68, 68, 92, 92, 92, 92, 92, 92,\n-   92, 92, 92, 92, 92,  2,  2,  2,  2,  2,  2,  2,  2, 92, 92, 92,\n-   92, 92, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n-   87,  2,  2, 30, 30, 30, 30, 30, 30,  2, 19, 19, 19,  0, 19, 19,\n-   19, 19, 19, 19, 19, 19, 19,  9, 19, 19, 19, 19,  0,  0,  2,  2,\n-    2,  2, 87, 87, 87, 87, 87, 87,  2,  2, 87, 87,  2,  2,  2,  2,\n-    2,  2, 12, 12, 12, 12,  2,  2,  2,  2,  2,  2,  2, 12, 12, 12,\n-   12, 12, 13, 13,  2,  2,  2,  2,  2,  2, 19, 19, 19, 19, 19, 19,\n-   19,  2,  2,  2,  2,  4,  4,  4,  4,  4,  2,  2,  2,  2,  2, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14,  2, 14, 14, 14, 14, 14,  2,\n-   14,  2, 14, 14,  2, 14, 14,  2, 14, 14,  3,  3,  3,  2,  2,  2,\n-    2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    0,  0,  2,  2,  3,  3,  3,  3,  3,  3,  2,  2,  2,  2,  2,  2,\n-    2,  3,  1,  1,  1,  1,  1,  1,  6,  6,  0,  0,  0,  2,  0,  0,\n-    0,  0,  3,  3,  3,  3,  3,  2,  3,  3,  3,  3,  3,  3,  3,  2,\n-    2,  0,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-   17, 17, 17, 17, 17, 17, 17, 17,  0,  0,  2,  2, 12, 12, 12, 12,\n-   12, 12,  2,  2, 12, 12, 12,  2,  2,  2,  2,  0,  0,  0,  0,  0,\n-    2,  2, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,  2, 49,\n-   49, 49, 49, 49, 49, 49, 49, 49, 49,  2, 49, 49, 49,  2, 49, 49,\n-    2, 49, 49, 49, 49, 49, 49, 49,  2,  2, 49, 49, 49,  2,  2,  2,\n-    2,  2,  0,  0,  0,  2,  2,  2,  2,  0,  0,  0,  0,  0,  2,  2,\n-    2,  0,  0,  0,  0,  0,  0,  2,  2,  2,  9,  2,  2,  2,  2,  2,\n-    2,  2,  0,  0,  0,  0,  0,  1,  2,  2, 71, 71, 71, 71, 71, 71,\n-   71, 71, 71, 71, 71, 71, 71,  2,  2,  2, 67, 67, 67, 67, 67, 67,\n-   67, 67, 67,  2,  2,  2,  2,  2,  2,  2,  1,  0,  0,  0,  0,  0,\n-    0,  0, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2, 42, 42, 42, 41, 41, 41, 41, 41, 41,\n-   41, 41, 41, 41, 41,  2,  2,  2,  2,  2,118,118,118,118,118,118,\n-  118,118,118,118,118,  2,  2,  2,  2,  2, 53, 53, 53, 53, 53, 53,\n-   53, 53, 53, 53, 53, 53, 53, 53,  2, 53, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59,  2,  2,  2,  2, 59, 59, 59, 59, 59, 59,\n-    2,  2, 40, 40, 40, 40, 40, 40, 40, 40, 51, 51, 51, 51, 51, 51,\n-   51, 51, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n-    2,  2, 50, 50,  2,  2,  2,  2,  2,  2,135,135,135,135,135,135,\n-  135,135,135,135,135,135,  2,  2,  2,  2,106,106,106,106,106,106,\n-  106,106,104,104,104,104,104,104,104,104,104,104,104,104,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2,  2,  2,104,161,161,161,161,161,161,\n-  161,161,161,161,161,  2,161,161,161,161,161,161,161,  2,161,161,\n-    2,161,161,161,  2,161,161,161,161,161,161,161,  2,161,161,  2,\n-    2,  2,110,110,110,110,110,110,110,110,110,110,110,110,110,110,\n-  110,  2,110,110,110,110,110,110,  2,  2, 19, 19, 19, 19, 19, 19,\n-    2, 19, 19,  2, 19, 19, 19, 19, 19, 19, 47, 47, 47, 47, 47, 47,\n-    2,  2, 47,  2, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47,\n-   47, 47, 47, 47, 47, 47, 47, 47,  2, 47, 47,  2,  2,  2, 47,  2,\n-    2, 47, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81,\n-    2, 81,120,120,120,120,120,120,120,120,116,116,116,116,116,116,\n-  116,116,116,116,116,116,116,116,116,  2,  2,  2,  2,  2,  2,  2,\n-    2,116,128,128,128,128,128,128,128,128,128,128,128,  2,128,128,\n-    2,  2,  2,  2,  2,128,128,128,128,128, 66, 66, 66, 66, 66, 66,\n-   66, 66, 66, 66, 66, 66,  2,  2,  2, 66, 72, 72, 72, 72, 72, 72,\n-   72, 72, 72, 72,  2,  2,  2,  2,  2, 72, 98, 98, 98, 98, 98, 98,\n-   98, 98, 97, 97, 97, 97, 97, 97, 97, 97,  2,  2,  2,  2, 97, 97,\n-   97, 97,  2,  2, 97, 97, 97, 97, 97, 97, 57, 57, 57, 57,  2, 57,\n-   57,  2,  2,  2,  2,  2, 57, 57, 57, 57, 57, 57, 57, 57,  2, 57,\n-   57, 57,  2, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,\n-   57, 57, 57, 57, 57, 57, 57, 57,  2,  2, 57, 57, 57,  2,  2,  2,\n-    2, 57, 57,  2,  2,  2,  2,  2,  2,  2, 88, 88, 88, 88, 88, 88,\n-   88, 88,117,117,117,117,117,117,117,117,112,112,112,112,112,112,\n-  112,112,112,112,112,112,112,112,112,  2,  2,  2,  2,112,112,112,\n-  112,112, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,\n-    2,  2,  2, 78, 78, 78, 78, 78, 78, 78, 83, 83, 83, 83, 83, 83,\n-   83, 83, 83, 83, 83, 83, 83, 83,  2,  2, 82, 82, 82, 82, 82, 82,\n-   82, 82, 82, 82, 82,  2,  2,  2,  2,  2,122,122,122,122,122,122,\n-  122,122,122,122,  2,  2,  2,  2,  2,  2,  2,122,122,122,122,  2,\n-    2,  2,  2,122,122,122,122,122,122,122, 89, 89, 89, 89, 89, 89,\n-   89, 89, 89,  2,  2,  2,  2,  2,  2,  2,130,130,130,130,130,130,\n-  130,130,130,130,130,  2,  2,  2,  2,  2,  2,  2,130,130,130,130,\n-  130,130,144,144,144,144,144,144,144,144,144,144,  2,  2,  2,  2,\n-    2,  2,156,156,156,156,156,156,156,156,156,156,  2,156,156,156,\n-    2,  2,156,156,  2,  2,  2,  2,  2,  2,147,147,147,147,147,147,\n-  147,147,148,148,148,148,148,148,148,148,148,148,  2,  2,  2,  2,\n-    2,  2,158,158,158,158,158,158,158,158,158,158,  2,  2,  2,  2,\n-    2,  2,153,153,153,153,153,153,153,153,153,153,153,153,  2,  2,\n-    2,  2,149,149,149,149,149,149,149,149,149,149,149,149,149,149,\n-  149,  2, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94,\n-    2,  2,  2,  2, 94, 94, 94, 94, 94, 94,  2,  2,  2,  2,  2,  2,\n-    2, 94, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2, 85,  2,  2,101,101,101,101,101,101,\n-  101,101,101,  2,  2,  2,  2,  2,  2,  2,101,101,  2,  2,  2,  2,\n-    2,  2, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,  2,\n-   96, 96,111,111,111,111,111,111,111,111,111,111,111,111,111,111,\n-  111,  2,100,100,100,100,100,100,100,100,  2, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36,  2,  2,  2,108,108,108,108,108,108,\n-  108,108,108,108,  2,108,108,108,108,108,108,108,108,108,108,108,\n-  108,  2,129,129,129,129,129,129,129,  2,129,  2,129,129,129,129,\n-    2,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,\n-    2,129,129,129,  2,  2,  2,  2,  2,  2,109,109,109,109,109,109,\n-  109,109,109,109,109,  2,  2,  2,  2,  2,109,109,  2,  2,  2,  2,\n-    2,  2,107,107,107,107,  2,107,107,107,107,107,107,107,107,  2,\n-    2,107,107,  2,  2,107,107,107,107,107,107,107,107,107,107,107,\n-  107,107,107,  2,107,107,107,107,107,107,107,  2,107,107,  2,107,\n-  107,107,107,107,  2,  1,107,107,107,107,107,  2,  2,107,107,107,\n-    2,  2,107,  2,  2,  2,  2,  2,  2,107,  2,  2,  2,  2,  2,107,\n-  107,107,107,107,107,107,  2,  2,107,107,107,107,107,107,107,  2,\n-    2,  2,137,137,137,137,137,137,137,137,137,137,137,137,  2,137,\n-  137,137,137,137,  2,  2,  2,  2,  2,  2,124,124,124,124,124,124,\n-  124,124,124,124,  2,  2,  2,  2,  2,  2,123,123,123,123,123,123,\n-  123,123,123,123,123,123,123,123,  2,  2,114,114,114,114,114,114,\n-  114,114,114,114,114,114,114,  2,  2,  2,114,114,  2,  2,  2,  2,\n-    2,  2, 32, 32, 32, 32, 32,  2,  2,  2,102,102,102,102,102,102,\n-  102,102,102,102,  2,  2,  2,  2,  2,  2,126,126,126,126,126,126,\n-  126,126,126,126,126,  2,  2,126,126,126,126,126,126,126,  2,  2,\n-    2,  2,126,126,126,126,126,126,126,  2,142,142,142,142,142,142,\n-  142,142,142,142,142,142,  2,  2,  2,  2,125,125,125,125,125,125,\n-  125,125,125,125,125,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,125,154,154,154,154,154,154,154,  2,  2,154,  2,  2,154,154,\n-  154,154,154,154,154,154,  2,154,154,  2,154,154,154,154,154,154,\n-  154,154,154,154,154,154,154,154,  2,154,154,  2,  2,154,154,154,\n-  154,154,154,154,  2,  2,  2,  2,  2,  2,150,150,150,150,150,150,\n-  150,150,  2,  2,150,150,150,150,150,150,150,150,150,150,150,  2,\n-    2,  2,141,141,141,141,141,141,141,141,140,140,140,140,140,140,\n-  140,140,140,140,140,  2,  2,  2,  2,  2,121,121,121,121,121,121,\n-  121,121,121,  2,  2,  2,  2,  2,  2,  2,133,133,133,133,133,133,\n-  133,133,133,  2,133,133,133,133,133,133,133,133,133,133,133,133,\n-  133,  2,133,133,133,133,133,133,  2,  2,133,133,133,133,133,  2,\n-    2,  2,134,134,134,134,134,134,134,134,  2,  2,134,134,134,134,\n-  134,134,  2,134,134,134,134,134,134,134,134,134,134,134,134,134,\n-  134,  2,138,138,138,138,138,138,138,  2,138,138,  2,138,138,138,\n-  138,138,138,138,138,138,138,138,138,138,  2,  2,138,  2,138,138,\n-    2,138,138,138,  2,  2,  2,  2,  2,  2,143,143,143,143,143,143,\n-    2,143,143,  2,143,143,143,143,143,143,143,143,143,143,143,143,\n-  143,143,143,143,143,143,143,143,143,  2,143,143,  2,143,143,143,\n-  143,143,143,  2,  2,  2,  2,  2,  2,  2,143,143,  2,  2,  2,  2,\n-    2,  2,145,145,145,145,145,145,145,145,145,  2,  2,  2,  2,  2,\n-    2,  2, 86,  2,  2,  2,  2,  2,  2,  2, 22, 22,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2,  2,  2, 22, 63, 63, 63, 63, 63, 63,\n-   63, 63, 63, 63,  2,  2,  2,  2,  2,  2, 63, 63, 63, 63, 63, 63,\n-   63,  2, 63, 63, 63, 63, 63,  2,  2,  2, 63, 63, 63, 63,  2,  2,\n-    2,  2,157,157,157,157,157,157,157,157,157,157,157,  2,  2,  2,\n-    2,  2, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80,\n-   80,  2, 80,  2,  2,  2,  2,  2,  2,  2,127,127,127,127,127,127,\n-  127,127,127,127,127,127,127,127,127,  2, 79,  2,  2,  2,  2,  2,\n-    2,  2,115,115,115,115,115,115,115,115,115,115,115,115,115,115,\n-  115,  2,115,115,  2,  2,  2,  2,115,115,159,159,159,159,159,159,\n-  159,159,159,159,159,159,159,159,159,  2,159,159,  2,  2,  2,  2,\n-    2,  2,103,103,103,103,103,103,103,103,103,103,103,103,103,103,\n-    2,  2,119,119,119,119,119,119,119,119,119,119,119,119,119,119,\n-    2,  2,119,119,  2,119,119,119,119,119,  2,  2,  2,  2,  2,119,\n-  119,119,146,146,146,146,146,146,146,146,146,146,146,  2,  2,  2,\n-    2,  2, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,  2,  2,  2,\n-    2, 99,  2,  2,  2,  2,  2,  2,  2, 99,136,139, 13, 13,155,  2,\n-    2,  2,136,136,136,136,136,136,136,136,155,155,155,155,155,155,\n-  155,155,155,155,155,155,155,155,  2,  2,136,  2,  2,  2,  2,  2,\n-    2,  2, 17, 17, 17, 17,  2, 17, 17, 17, 17, 17, 17, 17,  2, 17,\n-   17,  2, 17, 15, 15, 15, 15, 15, 15, 15, 17, 17, 17,  2,  2,  2,\n-    2,  2, 15, 15, 15,  2,  2,  2,  2,  2,  2,  2,  2,  2, 17, 17,\n-   17, 17,139,139,139,139,139,139,139,139,139,139,139,139,  2,  2,\n-    2,  2,105,105,105,105,105,105,105,105,105,105,105,  2,  2,  2,\n-    2,  2,105,105,105,105,105,  2,  2,  2,105,  2,  2,  2,  2,  2,\n-    2,  2,105,105,  2,  2,105,105,105,105,  1,  1,  1,  1,  1,  1,\n-    2,  2,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,\n-    1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,\n-    0,  0,  2,  2,  0,  2,  2,  0,  0,  2,  2,  0,  0,  0,  0,  2,\n-    0,  0,  0,  0,  2,  0,  2,  0,  0,  0,  0,  0,  0,  0,  2,  0,\n-    0,  0,  0,  0,  0,  2,  2,  0,  0,  0,  0,  0,  2,  0,  0,  0,\n-    0,  2,  0,  0,  0,  0,  0,  2,  0,  2,  2,  2,  0,  0,  0,  0,\n-    0,  0,  0,  2,  0,  0,  0,  0,  0,  0,131,131,131,131,131,131,\n-  131,131,131,131,131,131,  2,  2,  2,  2,  2,  2,  2,131,131,131,\n-  131,131,  2,131,131,131,131,131,131,131, 56, 56, 56, 56, 56, 56,\n-   56,  2, 56,  2,  2, 56, 56, 56, 56, 56, 56, 56,  2, 56, 56,  2,\n-   56, 56, 56, 56, 56,  2,  2,  2,  2,  2,151,151,151,151,151,151,\n-  151,151,151,151,151,151,151,  2,  2,  2,151,151,151,151,151,151,\n+   17, 17, 17, 17, 17,  0,  2, 26, 26, 26, 26, 26, 26, 26,  2, 12,\n+   12, 12, 12, 12, 12,  2, 12, 12, 12,  0, 39, 39, 39, 39, 39,  2,\n+    2,  2, 39, 39, 39,  2, 86, 86, 86, 86, 77, 77, 77, 77, 79, 79,\n+   79, 79, 19, 19, 19,  2, 19, 19,  2, 19,  2, 19, 19, 19, 19, 19,\n+    2,  2,  2,  2, 19, 19, 60, 60, 60, 60, 60,  2,  2,  2, 65, 65,\n+   65, 65, 75, 75, 75, 75, 75, 75,  2,  2,  2,  2, 75, 75, 69, 69,\n+   69, 69, 69, 69,  0, 69, 74, 74, 74, 74,  2,  2,  2, 74, 12,  2,\n+    2,  2, 84, 84, 84, 84, 84, 84,  2,  0, 84, 84,  2,  2,  2,  2,\n+   84, 84, 33, 33, 33,  2, 68, 68, 68, 68, 68, 68, 68,  2, 68, 68,\n+    2,  2, 92, 92, 92, 92, 92, 92, 92,  2,  2,  2,  2, 92, 87, 87,\n+   87, 87, 87, 87, 87,  2, 19,  9, 19, 19, 19, 19,  0,  0, 87, 87,\n+    2,  2,  2,  2,  2, 12,  2,  2,  2,  4, 14,  2, 14,  2, 14, 14,\n+    2, 14, 14,  2, 14, 14,  2,  2,  2,  3,  3,  3,  0,  0,  2,  2,\n+    3,  3,  1,  1,  6,  6,  3,  2,  3,  3,  3,  2,  2,  0,  2,  0,\n+    0,  0,  0,  0, 17, 17, 17, 17,  0,  0,  2,  2, 12, 12, 49, 49,\n+   49, 49,  2, 49, 49, 49, 49, 49, 49,  2, 49, 49,  2, 49, 49, 49,\n+    2,  2,  9,  2,  2,  2,  0,  1,  2,  2, 71, 71, 71, 71, 71,  2,\n+    2,  2, 67, 67, 67, 67, 67,  2,  2,  2, 42, 42, 42, 42,  2, 42,\n+   42, 42, 41, 41, 41, 41, 41, 41, 41,  2,118,118,118,118,118,118,\n+  118,  2, 53, 53, 53, 53, 53, 53,  2, 53, 59, 59, 59, 59, 59, 59,\n+    2,  2, 40, 40, 40, 40, 51, 51, 51, 51, 50, 50, 50, 50, 50, 50,\n+    2,  2,135,135,135,135,106,106,106,106,104,104,104,104,  2,  2,\n+    2,104,161,161,161,161,161,161,161,  2,161,161,  2,161,161,  2,\n+    2,  2,110,110,110,110,110,110,110,  2,110,110,  2,  2, 19,  2,\n+   19, 19, 47, 47, 47, 47, 47, 47,  2,  2, 47,  2, 47, 47, 47, 47,\n+    2, 47, 47,  2,  2,  2, 47,  2,  2, 47, 81, 81, 81, 81, 81, 81,\n+    2, 81,120,120,120,120,116,116,116,116,116,116,116,  2,  2,  2,\n+    2,116,128,128,128,128,128,128,128,  2,128,128,  2,  2,  2,  2,\n+    2,128, 66, 66, 66, 66,  2,  2,  2, 66, 72, 72, 72, 72, 72, 72,\n+    2,  2,  2,  2,  2, 72, 98, 98, 98, 98, 97, 97, 97, 97,  2,  2,\n+   97, 97, 57, 57, 57, 57,  2, 57, 57,  2,  2, 57, 57, 57, 57, 57,\n+    2,  2, 57, 57, 57,  2,  2,  2,  2, 57, 57,  2,  2,  2, 88, 88,\n+   88, 88,117,117,117,117,112,112,112,112,112,112,112,  2,  2,  2,\n+    2,112, 78, 78, 78, 78, 78, 78,  2,  2,  2, 78, 78, 78, 83, 83,\n+   83, 83, 83, 83,  2,  2, 82, 82, 82, 82, 82, 82, 82,  2,122,122,\n+  122,122,122,122,  2,  2,  2,122,122,122,122,  2,  2,  2, 89, 89,\n+   89, 89, 89,  2,  2,  2,130,130,130,130,130,130,130,  2,  2,  2,\n+  130,130,144,144,144,144,144,144,  2,  2,156,156,156,156,156,156,\n+    2,156,156,156,  2,  2,  2,  3,  3,  3,147,147,147,147,148,148,\n+  148,148,148,148,  2,  2,158,158,158,158,158,158,  2,  2,153,153,\n+  153,153,149,149,149,149,149,149,149,  2, 94, 94, 94, 94, 94, 94,\n+    2,  2,  2,  2, 94, 94,  2,  2,  2, 94, 85, 85, 85, 85, 85, 85,\n+   85,  2,  2, 85,  2,  2,101,101,101,101,101,  2,  2,  2,101,101,\n+    2,  2, 96, 96, 96, 96, 96,  2, 96, 96,111,111,111,111,111,111,\n+  111,  2,100,100,100,100,108,108,108,108,108,108,  2,108,108,108,\n+    2,  2,129,129,129,129,129,129,129,  2,129,  2,129,129,129,129,\n+    2,129,129,129,  2,  2,109,109,109,109,109,109,109,  2,109,109,\n+    2,  2,107,107,107,107,  2,107,107,107,107,  2,  2,107,107,  2,\n+  107,107,107,107,  2,  1,107,107,  2,  2,107,  2,  2,  2,  2,  2,\n+    2,107,  2,  2,107,107,137,137,137,137,  2,137,137,137,137,137,\n+    2,  2,124,124,124,124,124,124,  2,  2,123,123,123,123,123,123,\n+    2,  2,114,114,114,114,114,  2,  2,  2,114,114,  2,  2,102,102,\n+  102,102,102,102,  2,  2,126,126,126,126,126,126,126,  2,  2,126,\n+  126,126,142,142,142,142,125,125,125,125,125,125,125,  2,  2,  2,\n+    2,125,154,154,154,154,154,154,154,  2,  2,154,  2,  2,  2,154,\n+  154,  2,154,154,  2,154,154,  2,  2,154,154,154,  2,  2,150,150,\n+  150,150,  2,  2,150,150,150,  2,  2,  2,141,141,141,141,140,140,\n+  140,140,140,140,140,  2,121,121,121,121,121,  2,  2,  2,  7,  7,\n+    2,  2,133,133,133,133,133,  2,133,133,133,133,133,  2,133,133,\n+    2,  2,133,  2,  2,  2,134,134,134,134,  2,  2,134,134,  2,134,\n+  134,134,134,134,134,  2,138,138,138,138,138,138,138,  2,138,138,\n+    2,138,  2,  2,138,  2,138,138,  2,  2,143,143,143,143,143,143,\n+    2,143,143,  2,143,143,143,143,143,  2,143,  2,  2,  2,143,143,\n+    2,  2,145,145,145,145,145,  2,  2,  2,163,163,163,163,163,  2,\n+  163,163,163,163,163,  2,  2,  2,163,163,163,163,  2,  2, 86,  2,\n+    2,  2, 63, 63, 63, 63, 63, 63,  2,  2, 63, 63, 63,  2, 63,  2,\n+    2,  2,157,157,157,157,157,157,157,  2, 80, 80, 80, 80, 80, 80,\n+    2,  2,127,127,127,127,127,127,127,  2, 79,  2,  2,  2,115,115,\n+  115,115,115,115,115,  2,115,115,  2,  2,  2,  2,115,115,159,159,\n+  159,159,159,159,159,  2,159,159,  2,  2,103,103,103,103,103,103,\n+    2,  2,119,119,119,119,119,119,  2,  2,119,119,  2,119,  2,119,\n+  119,119,146,146,146,146,146,146,146,  2, 99, 99, 99, 99, 99, 99,\n+   99,  2,  2,  2,  2, 99,136,139, 13, 13,155,  2,  2,  2,136,136,\n+  136,136,155,155,155,155,155,155,  2,  2,136,  2,  2,  2,  2, 17,\n+   17, 17,  2, 17, 17,  2, 17, 15, 15, 15, 17, 17, 17,  2,  2,  2,\n+   15,  2,  2, 17,  2,  2,139,139,139,139,105,105,105,105,105,105,\n+  105,  2,105,  2,  2,  2,105,105,  2,  2,  1,  1,  2,  2,  0,  0,\n+    0,  1,  0,  1,  1,  1,  0,  0,  1,  1,  2,  2,  0,  2,  2,  0,\n+    0,  2,  0,  2,  0,  2,131,131,131,131,  2,  2,  2,131,  2,131,\n+  131,131, 56, 56, 56,  2, 56,  2,  2, 56, 56, 56,  2, 56, 56,  2,\n+   56, 56,  6,  6,  2,  2,  2,  2,  2,  6,151,151,151,151,151,  2,\n@@ -4960,16 +3676,8 @@\n-  160,160,160,160,160,160,160,160,160,  2,152,152,152,152,152,152,\n-  152,152,152,152,  2,  2,  2,  2,  2,152, 30, 30, 30, 30,  2, 30,\n-   30,  2,113,113,113,113,113,113,113,113,113,113,113,113,113,  2,\n-    2,113,113,113,113,113,113,113,113,  2,132,132,132,132,132,132,\n-  132,132,132,132,132,132,  2,  2,  2,  2,132,132,  2,  2,  2,  2,\n-  132,132,  3,  3,  3,  3,  2,  3,  3,  3,  2,  3,  3,  2,  3,  2,\n-    2,  3,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  2,  3,  3,\n-    3,  3,  2,  3,  2,  3,  2,  2,  2,  2,  2,  2,  3,  2,  2,  2,\n-    2,  3,  2,  3,  2,  3,  2,  3,  3,  3,  2,  3,  2,  3,  2,  3,\n-    2,  3,  2,  3,  3,  3,  3,  2,  3,  2,  3,  3,  2,  3,  3,  3,\n-    3,  3,  3,  3,  3,  3,  2,  2,  2,  2,  2,  3,  3,  3,  2,  3,\n-    3,  3,  2,  2,  2,  2,  2,  2,  0,  0, 15,  0,  0,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2,  0,  0,  0, 13,  2,  2,  2,  2,  2,\n-    2,  2, 13, 13, 13,  2,  2,  2,  2,  2,  2,  0,  2,  2,  2,  2,\n-    2,  2,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  9,  9,  9, 10,\n-    9, 11, 12, 13,  9,  9,  9, 14,  9,  9, 15,  9,  9,  9,  9,  9,\n+  160,  2,152,152,152,152,152,152,  2,  2,  2,  2,  2,152,164,164,\n+  164,164,164,164,  2,  2,  2, 30, 30,  2,113,113,113,113,113,  2,\n+    2,113,113,113,113,  2,132,132,132,132,132,132,  2,  2,  2,  2,\n+  132,132,  2,  3,  3,  2,  3,  2,  2,  3,  2,  3,  2,  3,  2,  2,\n+    3,  2,  3,  2,  3,  2,  3,  3,  2,  3, 15,  0,  0,  2, 13,  2,\n+    2,  2, 13, 13, 13,  2,  2,  0,  2,  2,  0,  1,  2,  3,  4,  5,\n+    6,  7,  8,  9,  9,  9,  9, 10,  9, 11, 12, 13,  9,  9,  9, 14,\n+    9,  9, 15,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n@@ -4981,2 +3689,2 @@\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 16, 17,\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 18, 19, 20,  9, 21,  9,\n+    9,  9,  9,  9,  9,  9, 16, 17,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9, 18, 19, 20,  9, 21,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n@@ -4988,1 +3696,1 @@\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 22,  9,  9,  9,  9,  9,\n+    9,  9, 22,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n@@ -4997,9 +3705,8 @@\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 23, 24,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,\n-    5,  6,  7,  8,  9, 10, 11, 12,  0,  0, 13, 14, 15, 16, 17, 18,\n-   19, 20, 21, 22,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0, 23,  0,  0, 24, 25, 26, 27, 28, 29, 30,  0,  0,\n-   31, 32,  0, 33,  0, 34,  0, 35,  0,  0,  0,  0, 36, 37, 38, 39,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0, 40,  0,  0,  0,  0,  0,  0,  0,  0,  0, 41, 42,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    9,  9,  9,  9,  9,  9, 23, 24,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,\n+    0,  0, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 23,  0,  0, 24,\n+   25, 26, 27, 28, 29, 30,  0,  0, 31, 32,  0, 33,  0, 34,  0, 35,\n+    0,  0,  0,  0, 36, 37, 38, 39,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 40,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0, 41, 42,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n@@ -5007,5 +3714,8 @@\n-    0,  0, 43, 44,  0, 45,  0,  0,  0,  0,  0,  0, 46, 47,  0,  0,\n-    0,  0,  0, 48,  0, 49,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0, 50, 51,  0,  0,  0, 52,  0,  0, 53,  0,  0,  0,\n-    0,  0,  0,  0, 54,  0,  0,  0,  0,  0,  0,  0, 55,  0,  0,  0,\n-    0,  0,  0,  0, 56,  0,  0,  0,  0,  0,  0,  0,  0, 57,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43, 44,  0, 45,  0,  0,\n+    0,  0,  0,  0, 46, 47,  0,  0,  0,  0,  0, 48,  0, 49,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 50, 51,  0,  0,\n+    0, 52,  0,  0, 53,  0,  0,  0,  0,  0,  0,  0, 54,  0,  0,  0,\n+    0,  0,  0,  0, 55,  0,  0,  0,  0,  0,  0,  0, 56,  0,  0,  0,\n+    0,  0,  0,  0,  0, 57,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 58, 59, 60, 61,\n+   62, 63, 64, 65,  0,  0,  0,  0,  0,  0, 66,  0,  0,  0,  0,  0,\n@@ -5013,2 +3723,0 @@\n-    0,  0,  0,  0, 58, 59, 60, 61, 62, 63, 64, 65,  0,  0,  0,  0,\n-    0,  0, 66,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n@@ -5018,0 +3726,7 @@\n+    0,  0,  0,  0,  0,  0,  0,  0, 67, 68,  0, 69, 70,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0, 71, 72, 73, 74, 75, 76, 77, 78,\n+   79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,\n+   95, 96, 97, 98, 99,100,101,102,103,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,104,  0,  0,  0,  0,  0,\n+    0,105,106,  0,107,  0,  0,  0,108,  0,109,  0,110,  0,111,112,\n+  113,  0,114,  0,  0,  0,115,  0,  0,  0,116,  0,  0,  0,  0,  0,\n@@ -5019,8 +3734,3 @@\n-   67, 68,  0, 69, 70,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-   71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,\n-   87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,\n-  103,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,104,  0,  0,  0,  0,  0,  0,105,106,  0,107,  0,  0,  0,\n-  108,  0,109,  0,110,  0,111,112,113,  0,114,  0,  0,  0,115,  0,\n-    0,  0,116,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,117,  0,  0,\n+    0,  0,  0,  0,  0,117,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,118,119,120,121,\n+    0,122,123,124,125,126,  0,127,  0,  0,  0,  0,  0,  0,  0,  0,\n@@ -5028,1 +3738,3 @@\n-    0,  0,  0,  0,118,119,120,121,  0,122,123,124,125,126,  0,127,\n+    0,  0,  0,  0,  0,  0,  0,  0,128,129,130,131,132,133,134,135,\n+  136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,\n+  152,153,154,155,156,157,  0,  0,  0,158,159,160,161,  0,  0,  0,\n@@ -5030,0 +3742,1 @@\n+    0,162,163,  0,  0,  0,  0,  0,  0,  0,164,  0,  0,  0,  0,  0,\n@@ -5031,5 +3744,1 @@\n-  128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,\n-  144,145,146,147,148,149,150,151,152,153,154,155,156,157,  0,  0,\n-    0,158,159,160,161,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,162,163,  0,  0,  0,  0,  0,\n-    0,  0,164,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,165,  0,  0,  0,\n@@ -5037,3 +3746,3 @@\n-    0,  0,  0,  0,165,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,166,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,167,  0,  0,  0,  0,\n+    0,  0,  0,166,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,167,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,168,  0,  0,  0,  0,\n@@ -5041,1 +3750,4 @@\n-    0,  0,  0,168,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,169,170,  0,\n+    0,  0,  0,171,172,  0,  0,  0,173,174,175,176,177,178,179,180,\n+  181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,\n+  197,198,199,200,201,202,203,204,205,206,  0,  0,  0,  0,  0,  0,\n@@ -5043,5 +3755,1 @@\n-    0,  0,  0,  0,  0,169,170,  0,  0,  0,  0,171,172,  0,  0,  0,\n-  173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,\n-  189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,\n-  205,206,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,\n+    0,  0,  0,  0,  1,  2,  3,  4,\n@@ -5050,1 +3758,1 @@\n-_hb_ucd_u16[9200] =\n+_hb_ucd_u16[10040] =\n@@ -5124,21 +3832,22 @@\n-    48,  48, 477, 478, 140, 140, 140, 140,  48, 464, 479,  48,  62, 480, 140,  48,\n-   481, 140, 140,  48, 482, 140,  48, 314, 483,  48,  48, 484, 485, 457, 486, 487,\n-   222,  48,  48, 488, 489,  48, 196, 192, 490,  48, 491, 492, 493,  48,  48, 494,\n-   222,  48,  48, 495, 496, 497, 498, 499,  48,  97, 500, 501, 140, 140, 140, 140,\n-   502, 503, 504,  48,  48, 505, 506, 192, 507,  83,  84, 508, 509, 510, 511, 512,\n-    48,  48,  48, 513, 514, 515, 478, 140,  48,  48,  48, 516, 517, 192, 140, 140,\n-    48,  48, 518, 519, 520, 521, 140, 140,  48,  48,  48, 522, 523, 192, 524, 140,\n-    48,  48, 525, 526, 192, 140, 140, 140,  48, 173, 527, 528, 314, 140, 140, 140,\n-    48,  48, 500, 529, 140, 140, 140, 140, 140, 140,   9,   9,  11,  11, 148, 530,\n-   531, 532,  48, 533, 534, 192, 140, 140, 140, 140, 535,  48,  48, 536, 537, 140,\n-   538,  48,  48, 539, 540, 541,  48,  48, 542, 543, 544,  48,  48,  48,  48, 196,\n-    84,  48, 518, 545, 546, 148, 175, 547,  48, 548, 549, 550, 140, 140, 140, 140,\n-   551,  48,  48, 552, 553, 192, 554,  48, 555, 556, 192, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140,  48, 557, 140, 140, 140, 100, 271, 558, 559, 560,\n-    48, 207, 140, 140, 140, 140, 140, 140, 272, 272, 272, 272, 272, 272, 561, 562,\n-    48,  48,  48,  48, 388, 140, 140, 140, 140,  48,  48,  48,  48,  48,  48, 563,\n-    48,  48, 200, 564, 140, 140, 140, 140,  48,  48,  48,  48, 314, 140, 140, 140,\n-    48,  48,  48, 196,  48, 200, 370,  48,  48,  48,  48, 200, 192,  48, 204, 565,\n-    48,  48,  48, 566, 567, 568, 569, 570,  48, 140, 140, 140, 140, 140, 140, 140,\n-   140, 140, 140, 140,   9,   9,  11,  11, 271, 571, 140, 140, 140, 140, 140, 140,\n-    48,  48,  48,  48, 572, 573, 574, 574, 575, 576, 140, 140, 140, 140, 577, 578,\n+    48,  48, 477, 478, 140, 140, 140, 479,  48, 464, 480,  48,  62, 481, 140,  48,\n+   482, 140, 140,  48, 483, 140,  48, 314, 484,  48,  48, 485, 486, 457, 487, 488,\n+   222,  48,  48, 489, 490,  48, 196, 192, 491,  48, 492, 493, 494,  48,  48, 495,\n+   222,  48,  48, 496, 497, 498, 499, 500,  48,  97, 501, 502, 503, 140, 140, 140,\n+   504, 505, 506,  48,  48, 507, 508, 192, 509,  83,  84, 510, 511, 512, 513, 514,\n+    48,  48,  48, 515, 516, 517, 478, 140,  48,  48,  48, 518, 519, 192, 140, 140,\n+    48,  48, 520, 521, 522, 523, 140, 140,  48,  48,  48, 524, 525, 192, 526, 140,\n+    48,  48, 527, 528, 192, 140, 140, 140,  48, 173, 529, 530, 314, 140, 140, 140,\n+    48,  48, 501, 531, 140, 140, 140, 140, 140, 140,   9,   9,  11,  11, 148, 532,\n+   533, 534,  48, 535, 536, 192, 140, 140, 140, 140, 537,  48,  48, 538, 539, 140,\n+   540,  48,  48, 541, 542, 543,  48,  48, 544, 545, 546,  48,  48,  48,  48, 196,\n+   547, 140, 140, 140, 140, 140, 140, 140,  84,  48, 520, 548, 549, 148, 175, 550,\n+    48, 551, 552, 553, 140, 140, 140, 140, 554,  48,  48, 555, 556, 192, 557,  48,\n+   558, 559, 192, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,  48, 560,\n+   561, 115,  48, 562, 563, 192, 140, 140, 140, 140, 140, 100, 271, 564, 565, 566,\n+    48, 207, 140, 140, 140, 140, 140, 140, 272, 272, 272, 272, 272, 272, 567, 568,\n+    48,  48,  48,  48, 388, 140, 140, 140, 140,  48,  48,  48,  48,  48,  48, 569,\n+    48,  48,  48, 570, 571, 572, 140, 140,  48,  48,  48,  48, 314, 140, 140, 140,\n+    48,  48,  48, 196,  48, 200, 370,  48,  48,  48,  48, 200, 192,  48, 204, 573,\n+    48,  48,  48, 574, 575, 576, 577, 578,  48, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140,   9,   9,  11,  11, 271, 579, 140, 140, 140, 140, 140, 140,\n+    48,  48,  48,  48, 580, 581, 582, 582, 583, 584, 140, 140, 140, 140, 585, 586,\n@@ -5146,26 +3855,27 @@\n-   196, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 579,\n-    48,  48, 580, 140, 140, 580, 581,  48,  48,  48,  48,  48,  48,  48,  48, 206,\n-    48,  48,  48,  48,  48,  48,  71, 151, 196, 582, 583, 140, 140, 140, 140, 140,\n-    32,  32, 584,  32, 585, 209, 209, 209, 209, 209, 209, 209, 323, 140, 140, 140,\n-   209, 209, 209, 209, 209, 209, 209, 324, 209, 209, 586, 209, 209, 209, 587, 588,\n-   589, 209, 590, 209, 209, 209, 288, 140, 209, 209, 209, 209, 591, 140, 140, 140,\n-   140, 140, 140, 140, 140, 140, 271, 592, 209, 209, 209, 209, 209, 287, 271, 461,\n-     9, 593,  11, 594, 595, 596, 241,   9, 597, 598, 599, 600, 601,   9, 593,  11,\n-   602, 603,  11, 604, 605, 606, 607,   9, 608,  11,   9, 593,  11, 594, 595,  11,\n-   241,   9, 597, 607,   9, 608,  11,   9, 593,  11, 609,   9, 610, 611, 612, 613,\n-    11, 614,   9, 615, 616, 617, 618,  11, 619,   9, 620,  11, 621, 622, 622, 622,\n-    32,  32,  32, 623,  32,  32, 624, 625, 626, 627,  45, 140, 140, 140, 140, 140,\n-   628, 629, 140, 140, 140, 140, 140, 140, 630, 631, 632, 140, 140, 140, 140, 140,\n-    48,  48, 151, 633, 634, 140, 140, 140, 140,  48, 635, 140,  48,  48, 636, 637,\n-   140, 140, 140, 140, 140, 140, 638, 200,  48,  48,  48,  48, 639, 585, 140, 140,\n-     9,   9, 597,  11, 640, 370, 140, 140, 140, 140, 140, 140, 140, 140, 140, 498,\n-   271, 271, 641, 642, 140, 140, 140, 140, 498, 271, 643, 644, 140, 140, 140, 140,\n-   645,  48, 646, 647, 648, 649, 650, 651, 652, 206, 653, 206, 140, 140, 140, 654,\n-   209, 209, 325, 209, 209, 209, 209, 209, 209, 323, 334, 655, 655, 655, 209, 324,\n-   656, 209, 209, 209, 209, 209, 209, 209, 209, 209, 657, 140, 140, 140, 658, 209,\n-   659, 209, 209, 325, 660, 661, 324, 140, 209, 209, 209, 209, 209, 209, 209, 662,\n-   209, 209, 209, 209, 209, 663, 426, 426, 209, 209, 209, 209, 209, 209, 209, 323,\n-   209, 209, 209, 209, 209, 660, 325, 427, 325, 209, 209, 209, 664, 176, 209, 209,\n-   664, 209, 657, 661, 140, 140, 140, 140, 209, 209, 209, 209, 209, 323, 657, 665,\n-   287, 209, 426, 288, 324, 176, 664, 287, 209, 666, 209, 209, 288, 140, 140, 192,\n-    48,  48,  48,  48,  48,  48, 140, 140,  48,  48,  48, 196,  48,  48,  48,  48,\n+   196, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 587,\n+    48,  48, 588, 589, 140, 590, 591,  48,  48,  48,  48,  48,  48,  48,  48, 206,\n+    48,  48,  48,  48,  48,  48,  71, 151, 196, 592, 593, 140, 140, 140, 140, 140,\n+    32,  32, 594,  32, 595, 209, 209, 209, 209, 209, 209, 209, 323, 140, 140, 140,\n+   209, 209, 209, 209, 209, 209, 209, 324, 209, 209, 596, 209, 209, 209, 597, 598,\n+   599, 209, 600, 209, 209, 209, 288, 140, 209, 209, 209, 209, 601, 140, 140, 140,\n+   140, 140, 140, 140, 271, 602, 271, 602, 209, 209, 209, 209, 209, 287, 271, 461,\n+     9, 603,  11, 604, 605, 606, 241,   9, 607, 608, 609, 610, 611,   9, 603,  11,\n+   612, 613,  11, 614, 615, 616, 617,   9, 618,  11,   9, 603,  11, 604, 605,  11,\n+   241,   9, 607, 617,   9, 618,  11,   9, 603,  11, 619,   9, 620, 621, 622, 623,\n+    11, 624,   9, 625, 626, 627, 628,  11, 629,   9, 630,  11, 631, 632, 632, 632,\n+    32,  32,  32, 633,  32,  32, 634, 635, 636, 637,  45, 140, 140, 140, 140, 140,\n+   638, 639, 640, 140, 140, 140, 140, 140, 641, 642, 643,  27,  27,  27, 644, 140,\n+   645, 140, 140, 140, 140, 140, 140, 140,  48,  48, 151, 646, 647, 140, 140, 140,\n+   140,  48, 648, 140,  48,  48, 649, 650, 140, 140, 140, 140, 140,  48, 651, 192,\n+   140, 140, 140, 140, 140, 140, 652, 200,  48,  48,  48,  48, 653, 595, 140, 140,\n+     9,   9, 607,  11, 654, 370, 140, 140, 140, 140, 140, 140, 140, 140, 140, 499,\n+   271, 271, 655, 656, 140, 140, 140, 140, 499, 271, 657, 658, 140, 140, 140, 140,\n+   659,  48, 660, 661, 662, 663, 664, 665, 666, 206, 667, 206, 140, 140, 140, 668,\n+   209, 209, 325, 209, 209, 209, 209, 209, 209, 323, 334, 669, 669, 669, 209, 324,\n+   670, 209, 209, 209, 209, 209, 209, 209, 209, 209, 671, 140, 140, 140, 672, 209,\n+   673, 209, 209, 325, 674, 675, 324, 140, 209, 209, 209, 209, 209, 209, 209, 676,\n+   209, 209, 209, 209, 209, 677, 426, 426, 209, 209, 209, 209, 209, 209, 209, 678,\n+   209, 209, 209, 209, 209, 176, 325, 427, 325, 209, 209, 209, 679, 176, 209, 209,\n+   679, 209, 671, 675, 140, 140, 140, 140, 209, 209, 209, 209, 209, 323, 671, 426,\n+   674, 209, 209, 680, 681, 325, 674, 674, 209, 682, 209, 209, 288, 140, 140, 192,\n+    48,  48,  48,  48,  48,  48, 140, 140,  48,  48,  48, 207,  48,  48,  48,  48,\n@@ -5174,62 +3884,325 @@\n-    48,  48,  48,  48,  71, 140, 140, 140, 667, 140, 668, 668, 668, 668, 668, 668,\n-    32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 140,\n-   391, 391, 391, 391, 391, 391, 391, 669, 391, 391, 391, 391, 391, 391, 391, 670,\n-     0,   0,   0,   0,   0,   0,   0,   0,   1,   2,   2,   3,   1,   2,   2,   3,\n-     0,   0,   0,   0,   0,   4,   0,   4,   2,   2,   5,   2,   2,   2,   5,   2,\n-     2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,\n-     2,   2,   2,   2,   2,   2,   2,   6,   0,   0,   0,   0,   7,   8,   0,   0,\n-     9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  11,\n-    12,  13,  14,  14,  15,  14,  14,  14,  14,  14,  14,  14,  16,  17,  14,  14,\n-    18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,\n-    19,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,\n-    18,  18,  18,  18,  18,  18,  20,  21,  21,  21,  22,  20,  21,  21,  21,  21,\n-    21,  23,  24,  25,  25,  25,  25,  25,  25,  26,  25,  25,  25,  27,  28,  26,\n-    29,  30,  31,  32,  31,  31,  31,  31,  33,  34,  35,  31,  31,  31,  36,  31,\n-    31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  29,  31,  31,  31,  31,\n-    37,  38,  37,  37,  37,  37,  37,  37,  37,  39,  31,  31,  31,  31,  31,  31,\n-    40,  40,  40,  40,  40,  40,  41,  26,  42,  42,  42,  42,  42,  42,  42,  43,\n-    44,  44,  44,  44,  44,  45,  44,  46,  47,  47,  47,  48,  37,  49,  31,  31,\n-    31,  50,  51,  31,  31,  31,  31,  31,  31,  31,  31,  31,  52,  31,  31,  31,\n-    53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  54,  53,  55,  53,  53,  53,\n-    56,  57,  58,  59,  59,  60,  61,  62,  57,  63,  64,  65,  66,  59,  59,  67,\n-    68,  69,  70,  71,  71,  72,  73,  74,  69,  75,  76,  77,  78,  71,  79,  26,\n-    80,  81,  82,  83,  83,  84,  85,  86,  81,  87,  88,  26,  89,  83,  90,  91,\n-    92,  93,  94,  95,  95,  96,  97,  98,  93,  99, 100, 101, 102,  95,  95,  26,\n-   103, 104, 105, 106, 107, 104, 108, 109, 104, 105, 110,  26, 111, 108, 108, 112,\n-   113, 114, 115, 113, 113, 115, 113, 116, 114, 117, 118, 119, 120, 113, 121, 113,\n-   122, 123, 124, 122, 122, 124, 125, 126, 123, 127, 128, 128, 129, 122, 130,  26,\n-   131, 132, 133, 131, 131, 131, 131, 131, 132, 133, 134, 131, 135, 131, 131, 131,\n-   136, 137, 138, 139, 137, 137, 140, 141, 138, 142, 143, 137, 144, 137, 145,  26,\n-   146, 147, 147, 147, 147, 147, 147, 148, 147, 147, 147, 149,  26,  26,  26,  26,\n-   150, 151, 152, 152, 153, 152, 152, 154, 155, 154, 152, 156,  26,  26,  26,  26,\n-   157, 157, 157, 157, 157, 157, 157, 157, 157, 158, 157, 157, 157, 159, 158, 157,\n-   157, 157, 157, 158, 157, 157, 157, 160, 157, 160, 161, 162,  26,  26,  26,  26,\n-   163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n-   163, 163, 163, 163, 164, 164, 164, 164, 165, 166, 164, 164, 164, 164, 164, 167,\n-   168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168,\n-   169, 169, 169, 169, 169, 169, 169, 169, 169, 170, 171, 170, 169, 169, 169, 169,\n-   169, 170, 169, 169, 169, 169, 170, 171, 170, 169, 171, 169, 169, 169, 169, 169,\n-   169, 169, 170, 169, 169, 169, 169, 169, 169, 169, 169, 172, 169, 169, 169, 173,\n-   169, 169, 169, 174, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 176, 176,\n-   177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177,\n-   178, 178, 178, 179, 180, 180, 180, 180, 180, 180, 180, 180, 180, 181, 180, 182,\n-   183, 183, 184, 185, 186, 186, 187,  26, 188, 188, 189,  26, 190, 191, 192,  26,\n-   193, 193, 193, 193, 193, 193, 193, 193, 193, 193, 193, 194, 193, 195, 193, 195,\n-   196, 197, 197, 198, 197, 197, 197, 197, 197, 197, 197, 197, 197, 197, 197, 199,\n-   197, 197, 197, 197, 197, 200, 177, 177, 177, 177, 177, 177, 177, 177, 201,  26,\n-   202, 202, 202, 203, 202, 204, 202, 204, 205, 202, 206, 206, 206, 207, 208,  26,\n-   209, 209, 209, 209, 209, 210, 209, 209, 209, 211, 209, 212, 193, 193, 193, 193,\n-   213, 213, 213, 214, 215, 215, 215, 215, 215, 215, 215, 216, 215, 215, 215, 217,\n-   215, 218, 215, 218, 215, 219,   9,   9,   9, 220,  26,  26,  26,  26,  26,  26,\n-   221, 221, 221, 221, 221, 221, 221, 221, 221, 222, 221, 221, 221, 221, 221, 223,\n-   224, 224, 224, 224, 224, 224, 224, 224, 225, 225, 225, 225, 225, 225, 226, 227,\n-   228, 228, 228, 228, 228, 228, 228, 229, 228, 230, 231, 231, 231, 231, 231, 231,\n-    18, 232, 164, 164, 164, 164, 164, 233, 224,  26, 234,   9, 235, 236, 237, 238,\n-     2,   2,   2,   2, 239, 240,   2,   2,   2,   2,   2, 241, 242, 243,   2, 244,\n-     2,   2,   2,   2,   2,   2,   2, 245,   9,   9,   9,   9,   9,   9,   9,   9,\n-    14,  14, 246, 246,  14,  14,  14,  14, 246, 246,  14, 247,  14,  14,  14, 246,\n-    14,  14,  14,  14,  14,  14, 248,  14, 248,  14, 249, 250,  14,  14, 251, 252,\n-     0, 253,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 254,   0, 255, 256,\n-     0, 257,   2, 258,   0,   0,   0,   0, 259,  26,   9,   9,   9,   9, 260,  26,\n-     0,   0,   0,   0, 261, 262,   4,   0,   0, 263,   0,   0,   2,   2,   2,   2,\n-     2, 264,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+    48,  48,  48,  48,  71,  48,  48,  48,  48,  48,  48, 140, 140, 140, 140, 140,\n+   683, 140, 570, 570, 570, 570, 570, 570,  32,  32,  32,  32,  32,  32,  32,  32,\n+    32,  32,  32,  32,  32,  32,  32, 140, 391, 391, 391, 391, 391, 391, 391, 684,\n+   391, 391, 391, 391, 391, 391, 391, 685,   0,   0,   0,   0,   1,   2,   1,   2,\n+     0,   0,   3,   3,   4,   5,   4,   5,   4,   4,   4,   4,   4,   4,   4,   4,\n+     4,   4,   4,   6,   0,   0,   7,   0,   8,   8,   8,   8,   8,   8,   8,   9,\n+    10,  11,  12,  11,  11,  11,  13,  11,  14,  14,  14,  14,  14,  14,  14,  14,\n+    15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  16,  17,  18,  17,  17,\n+    19,  20,  21,  21,  22,  21,  23,  24,  25,  26,  27,  27,  28,  29,  27,  30,\n+    27,  27,  27,  27,  27,  31,  27,  27,  32,  33,  33,  33,  34,  27,  27,  27,\n+    35,  35,  35,  36,  37,  37,  37,  38,  39,  39,  40,  41,  42,  43,  44,  27,\n+    45,  46,  27,  27,  27,  27,  47,  27,  48,  48,  48,  48,  48,  49,  50,  48,\n+    51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,\n+    67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,\n+    83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,\n+    99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 109, 110, 111, 112, 109,\n+   113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 122, 123, 122, 124, 125, 125,\n+   126, 127, 128, 129, 130, 131, 125, 125, 132, 132, 132, 132, 133, 132, 134, 135,\n+   132, 133, 132, 136, 136, 137, 125, 125, 138, 138, 138, 138, 138, 138, 138, 138,\n+   138, 138, 139, 139, 140, 139, 139, 141, 142, 142, 142, 142, 142, 142, 142, 142,\n+   143, 143, 143, 143, 144, 145, 143, 143, 144, 143, 143, 146, 147, 148, 143, 143,\n+   143, 147, 143, 143, 143, 149, 143, 150, 143, 151, 152, 152, 152, 152, 152, 153,\n+   154, 154, 154, 154, 154, 154, 154, 154, 155, 156, 157, 157, 157, 157, 158, 159,\n+   160, 161, 162, 163, 164, 165, 166, 167, 168, 168, 168, 168, 168, 169, 170, 170,\n+   171, 172, 173, 173, 173, 173, 173, 174, 173, 173, 175, 154, 154, 154, 154, 176,\n+   177, 178, 179, 179, 180, 181, 182, 183, 184, 184, 185, 184, 186, 187, 168, 168,\n+   188, 189, 190, 190, 190, 191, 190, 192, 193, 193, 194,   8, 195, 125, 125, 125,\n+   196, 196, 196, 196, 197, 196, 196, 198, 199, 199, 199, 199, 200, 200, 200, 201,\n+   202, 202, 202, 203, 204, 205, 205, 205, 206, 139, 139, 207, 208, 209, 210, 211,\n+     4,   4, 212,   4,   4, 213, 214, 215,   4,   4,   4, 216,   8,   8,   8,   8,\n+    11, 217,  11,  11, 217, 218,  11, 219,  11,  11,  11, 220, 220, 221,  11, 222,\n+   223,   0,   0,   0,   0,   0, 224, 225, 226, 227,   0,   0, 228,   8,   8, 229,\n+     0,   0, 230, 231, 232,   0,   4,   4, 233,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 234, 125, 235, 125,   0,   0,\n+   236, 236, 236, 236, 236, 236, 236, 236,   0,   0,   0,   0,   0,   0,   0, 237,\n+     0, 238,   0,   0,   0,   0,   0,   0, 239, 239, 239, 239, 239, 239,   4,   4,\n+   240, 240, 240, 240, 240, 240, 240, 241, 139, 139, 140, 242, 242, 242, 243, 244,\n+   143, 245, 246, 246, 246, 246,  14,  14,   0,   0,   0,   0,   0, 247, 125, 125,\n+   248, 249, 248, 248, 248, 248, 248, 250, 248, 248, 248, 248, 248, 248, 248, 248,\n+   248, 248, 248, 248, 248, 251, 125, 252, 253,   0, 254, 255, 256, 257, 257, 257,\n+   257, 258, 259, 260, 260, 260, 260, 261, 262, 263, 263, 264, 142, 142, 142, 142,\n+   265,   0, 263, 263,   0,   0, 266, 260, 142, 265,   0,   0,   0,   0, 142, 267,\n+     0,   0,   0,   0,   0, 260, 260, 268, 260, 260, 260, 260, 260, 269,   0,   0,\n+   248, 248, 248, 248,   0,   0,   0,   0, 270, 270, 270, 270, 270, 270, 270, 270,\n+   271, 270, 270, 270, 272, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274,\n+   274, 274, 275, 125,  14,  14,  14,  14,  14,  14, 276, 276, 276, 276, 276, 277,\n+     0,   0, 278,   4,   4,   4,   4,   4, 279,   4,   4,   4, 280, 281, 125, 282,\n+   283, 283, 284, 285, 286, 286, 286, 287, 288, 288, 288, 288, 289, 290,  48,  48,\n+   291, 291, 292, 293, 293, 294, 142, 295, 296, 296, 296, 296, 297, 298, 138, 299,\n+   300, 300, 300, 301, 302, 303, 138, 138, 304, 304, 304, 304, 305, 306, 307, 308,\n+   309, 310, 246,   4,   4, 311, 312, 152, 152, 152, 152, 152, 307, 307, 313, 314,\n+   142, 142, 315, 142, 316, 142, 142, 317, 125, 125, 125, 125, 125, 125, 125, 125,\n+   248, 248, 248, 248, 248, 248, 318, 248, 248, 248, 248, 248, 248, 319, 125, 125,\n+   320, 321,  21, 322, 323,  27,  27,  27,  27,  27,  27,  27, 324, 325,  27,  27,\n+    27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27, 326,  27,  27,  27,  27,\n+    27, 327,  27,  27, 328, 125, 125,  27,   8, 285, 329,   0,   0, 330, 331, 332,\n+    27,  27,  27,  27,  27,  27,  27, 333, 334,   0,   1,   2,   1,   2, 335, 259,\n+   260, 336, 142, 265, 337, 338, 339, 340, 341, 342, 343, 344, 345, 345, 125, 125,\n+   342, 342, 342, 342, 342, 342, 342, 346, 347,   0,   0, 348,  11,  11,  11,  11,\n+   349, 350, 351, 125, 125,   0,   0, 352, 353, 354, 355, 355, 355, 356, 357, 252,\n+   358, 358, 359, 360, 361, 362, 362, 363, 364, 365, 366, 366, 367, 368, 125, 125,\n+   369, 369, 369, 369, 369, 370, 370, 370, 371, 372, 373, 374, 374, 375, 374, 376,\n+   377, 377, 378, 379, 379, 379, 380, 381, 381, 382, 383, 384, 125, 125, 125, 125,\n+   385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 386, 385, 387, 388, 125,\n+   389,   4,   4, 390, 125, 125, 125, 125, 391, 392, 392, 393, 394, 395, 396, 396,\n+   397, 398, 399, 125, 125, 125, 400, 401, 402, 403, 404, 405, 125, 125, 125, 125,\n+   406, 406, 407, 408, 407, 409, 407, 407, 410, 411, 412, 413, 414, 414, 415, 415,\n+   416, 416, 125, 125, 417, 417, 418, 419, 420, 420, 420, 421, 422, 423, 424, 425,\n+   426, 427, 428, 125, 125, 125, 125, 125, 429, 429, 429, 429, 430, 125, 125, 125,\n+   431, 431, 431, 432, 431, 431, 431, 433, 434, 434, 435, 436, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125,  27,  45, 437, 437, 438, 439, 125, 125, 125, 440,\n+   441, 441, 442, 443, 443, 444, 125, 445, 446, 125, 125, 447, 448, 125, 449, 450,\n+   451, 451, 451, 451, 452, 453, 451, 454, 455, 455, 455, 455, 456, 457, 458, 459,\n+   460, 460, 460, 461, 462, 463, 463, 464, 465, 465, 465, 465, 465, 465, 466, 467,\n+   468, 469, 468, 468, 470, 125, 125, 125, 471, 472, 473, 474, 474, 474, 475, 476,\n+   477, 478, 479, 480, 481, 482, 483, 484, 485, 485, 485, 485, 485, 486, 487, 125,\n+   488, 488, 488, 488, 489, 490, 125, 125, 491, 491, 491, 492, 491, 493, 125, 125,\n+   494, 494, 494, 494, 495, 496, 497, 125, 498, 498, 498, 499, 499, 125, 125, 125,\n+   500, 501, 502, 500, 503, 125, 125, 125, 504, 504, 504, 505, 125, 125, 125, 125,\n+   125, 125, 506, 506, 506, 506, 506, 507, 508, 509, 510, 511, 512, 513, 125, 125,\n+   125, 125, 514, 515, 515, 514, 516, 125, 517, 517, 517, 517, 518, 519, 519, 519,\n+   519, 519, 520, 154, 521, 521, 521, 522, 523, 125, 125, 125, 125, 125, 125, 125,\n+   524, 525, 525, 526, 527, 525, 528, 529, 529, 530, 531, 532, 125, 125, 125, 125,\n+   533, 534, 534, 535, 536, 537, 538, 539, 540, 541, 542, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 543, 544, 545, 546, 545, 547, 545, 548, 125, 125,\n+   125, 125, 125, 549, 550, 550, 550, 551, 552, 552, 552, 552, 552, 552, 552, 552,\n+   552, 553, 125, 125, 125, 125, 125, 125, 552, 552, 552, 552, 552, 552, 554, 555,\n+   552, 552, 552, 552, 556, 125, 125, 125, 125, 557, 557, 557, 557, 557, 557, 558,\n+   559, 559, 559, 559, 559, 559, 559, 559, 559, 559, 559, 559, 559, 560, 125, 125,\n+   561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 562, 125, 125, 125,\n+   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 563, 564, 565, 566, 567,\n+   567, 567, 567, 568, 569, 570, 571, 572, 573, 573, 573, 573, 574, 575, 576, 577,\n+   573, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 578, 578, 578, 578,\n+   578, 579, 125, 125, 125, 125, 125, 125, 580, 580, 580, 580, 581, 580, 580, 580,\n+   582, 580, 125, 125, 125, 125, 583, 584, 585, 585, 585, 585, 585, 585, 585, 585,\n+   585, 585, 585, 585, 585, 585, 585, 586, 587, 587, 587, 587, 587, 587, 587, 587,\n+   587, 587, 587, 587, 587, 588, 125, 125, 589, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 590, 591, 257, 257, 257, 257, 257, 257, 257,\n+   257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 592, 593, 125, 594, 595, 596,\n+   596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 597,\n+   598, 598, 598, 598, 598, 598, 599, 600, 601, 602, 266, 125, 125, 125, 125, 125,\n+     8,   8, 603,   8, 604,   0,   0,   0,   0,   0,   0,   0, 266, 125, 125, 125,\n+     0,   0,   0,   0,   0,   0,   0, 605,   0,   0, 606,   0,   0,   0, 607, 608,\n+   609,   0, 610,   0,   0,   0, 235, 125,  11,  11,  11,  11, 611, 125, 125, 125,\n+   125, 125, 125, 125,   0, 266,   0, 266,   0,   0,   0,   0,   0, 234,   0, 612,\n+     0,   0,   0,   0,   0, 224,   0,   0,   0, 613, 614, 615, 616,   0,   0,   0,\n+   617, 618,   0, 619, 620, 621,   0,   0,   0,   0, 622,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0, 623,   0,   0,   0, 624, 624, 624, 624, 624, 624, 624, 624,\n+   625, 626, 627, 125, 125, 125, 125, 125,   4, 628, 629, 125, 125, 125, 125, 125,\n+   630, 631, 632,  14,  14,  14, 633, 125, 634, 125, 125, 125, 125, 125, 125, 125,\n+   635, 635, 636, 637, 638, 125, 125, 125, 125, 639, 640, 125, 641, 641, 641, 642,\n+   125, 125, 125, 125, 125, 643, 643, 644, 125, 125, 125, 125, 125, 125, 645, 646,\n+   647, 647, 647, 647, 647, 647, 647, 647, 647, 647, 647, 647, 648, 649, 125, 125,\n+   650, 650, 650, 650, 651, 652, 125, 125, 125, 125, 125, 125, 125, 125, 125, 334,\n+     0,   0,   0, 653, 125, 125, 125, 125, 334,   0,   0, 247, 125, 125, 125, 125,\n+   654,  27, 655, 656, 657, 658, 659, 660, 661, 662, 663, 662, 125, 125, 125, 664,\n+     0,   0, 252,   0,   0,   0,   0,   0,   0, 266, 226, 334, 334, 334,   0, 605,\n+     0,   0, 247, 125, 125, 125, 665,   0, 666,   0,   0, 252, 612, 667, 605, 125,\n+     0,   0,   0,   0,   0, 668, 350, 350,   0,   0,   0,   0,   0,   0,   0, 669,\n+     0,   0,   0,   0,   0, 285, 252, 228, 252,   0,   0,   0, 670, 285,   0,   0,\n+   670,   0, 247, 667, 125, 125, 125, 125,   0,   0,   0,   0,   0, 266, 247, 350,\n+   612,   0,   0, 671, 672, 252, 612, 612,   0, 330,   0,   0, 235, 125, 125, 285,\n+   248, 248, 248, 248, 248, 248, 125, 125, 248, 248, 248, 319, 248, 248, 248, 248,\n+   248, 318, 248, 248, 248, 248, 248, 248, 248, 248, 584, 248, 248, 248, 248, 248,\n+   248, 248, 248, 248, 248, 248, 673, 125, 248, 318, 125, 125, 125, 125, 125, 125,\n+   248, 248, 248, 248, 674, 248, 248, 248, 248, 248, 248, 125, 125, 125, 125, 125,\n+   675, 125,   0,   0,   0,   0,   0,   0,   8,   8,   8,   8,   8,   8,   8,   8,\n+     8,   8,   8,   8,   8,   8,   8,   0,   0,   0,   0,   0,   1,   2,   2,   2,\n+     2,   2,   3,   0,   0,   0,   4,   0,   2,   2,   2,   2,   2,   3,   2,   2,\n+     2,   2,   5,   0,   2,   5,   6,   0,   7,   7,   7,   7,   8,   9,  10,  11,\n+    12,  13,  14,  15,   8,   8,   8,   8,  16,   8,   8,   8,  17,  18,  18,  18,\n+    19,  19,  19,  19,  19,  20,  19,  19,  21,  22,  22,  22,  22,  22,  22,  22,\n+    22,  23,  21,  22,  22,  22,  23,  21,  24,  25,  25,  25,  25,  25,  25,  25,\n+    25,  25,  12,  12,  25,  25,  26,  27,  25,  28,  12,  12,  29,  30,  29,  31,\n+    29,  29,  32,  32,  29,  29,  29,  29,  31,  29,  33,   7,   7,  34,  29,  29,\n+    35,  29,  29,  29,  29,  29,  29,  30,  36,  36,  36,  37,  36,  36,  36,  36,\n+    36,  36,  38,  39,  40,  40,  40,  40,  41,  12,  12,  12,  42,  42,  42,  42,\n+    42,  42,  43,  44,  45,  45,  45,  45,  45,  45,  45,  46,  45,  45,  45,  47,\n+    48,  48,  48,  48,  48,  48,  48,  49,  36,  36,  38,  12,  29,  29,  29,  50,\n+    51,  12,  29,  29,  52,  29,  29,  29,  53,  53,  53,  53,  54,  55,  53,  53,\n+    53,  56,  53,  53,  57,  58,  57,  59,  59,  57,  57,  57,  57,  57,  60,  57,\n+    61,  62,  63,  57,  57,  59,  59,  64,  12,  65,  12,  66,  57,  62,  57,  57,\n+    57,  57,  57,  64,  67,  67,  68,  69,  70,  71,  71,  71,  71,  71,  72,  71,\n+    72,  73,  74,  72,  68,  69,  70,  74,  75,  12,  67,  76,  12,  77,  71,  71,\n+    71,  68,  12,  12,  78,  78,  79,  80,  80,  79,  79,  79,  79,  79,  81,  79,\n+    81,  78,  82,  79,  79,  80,  80,  82,  83,  12,  12,  12,  79,  84,  79,  79,\n+    82,  12,  78,  79,  85,  85,  86,  87,  87,  86,  86,  86,  86,  86,  88,  86,\n+    88,  85,  89,  86,  86,  87,  87,  89,  12,  85,  12,  90,  86,  91,  86,  86,\n+    86,  86,  12,  12,  92,  93,  94,  92,  95,  96,  97,  95,  98,  99,  94,  92,\n+   100, 100,  96,  92,  94,  92,  95,  96,  99,  98,  12,  12,  12,  92, 100, 100,\n+   100, 100,  94,  12, 101, 101, 101, 102, 102, 101, 101, 101, 101, 101, 102, 101,\n+   101, 101, 103, 101, 101, 102, 102, 103,  12, 104, 105, 106, 101, 107, 101, 101,\n+    12, 108, 101, 101, 109, 109, 109, 110, 110, 109, 109, 109, 109, 109, 110, 109,\n+   109, 111, 112, 109, 109, 110, 110, 112,  12, 113,  12, 113, 109, 114, 109, 109,\n+   111,  12,  12,  12, 115, 115, 115, 116, 116, 115, 115, 115, 115, 115, 115, 115,\n+   115, 116, 116, 115,  12, 115, 115, 115, 115, 117, 115, 115, 118, 118, 119, 119,\n+   119, 120, 121, 119, 119, 119, 119, 119, 122, 119, 119, 123, 119, 120, 124, 125,\n+   119, 126, 119, 119,  12, 121, 119, 119, 121, 127,  12,  12, 128, 129, 129, 129,\n+   129, 129, 129, 129, 129, 129, 130, 131, 129, 129, 129,  12,  12,  12,  12,  12,\n+   132, 133, 134, 135, 135, 135, 135, 135, 135, 136, 135, 135, 135, 135, 135, 137,\n+   135, 138, 135, 134, 135, 135, 137, 135, 139, 139, 139, 139, 139, 139, 140, 139,\n+   139, 139, 139, 141, 140, 139, 139, 139, 139, 139, 139, 142, 139, 143, 144,  12,\n+   145, 145, 145, 145, 146, 146, 146, 146, 146, 147,  12, 148, 146, 146, 149, 146,\n+   150, 150, 150, 150, 151, 151, 151, 151, 151, 151, 152, 153, 151, 154, 152, 153,\n+   152, 153, 151, 154, 152, 153, 151, 151, 151, 154, 151, 151, 151, 151, 154, 155,\n+   151, 151, 151, 156, 151, 151, 153,  12, 157, 157, 157, 157, 157, 158, 157, 158,\n+   159, 159, 159, 159, 160, 160, 160, 160, 160, 160, 160, 161, 162, 162, 162, 162,\n+   162, 162, 163, 164, 162, 162, 165,  12, 166, 166, 166, 166, 166, 167,  12, 168,\n+   169, 169, 169, 169, 169, 170,  12,  12, 171, 171, 171, 171, 171,  12,  12,  12,\n+   172, 172, 172, 173, 173,  12,  12,  12, 174, 174, 174, 174, 174, 174, 174, 175,\n+   174, 174, 175,  12, 176, 177, 178, 178, 178, 178, 179,  12, 178, 178, 178, 178,\n+   178, 178, 180,  12, 178, 178, 181,  12, 159, 182,  12,  12, 183, 183, 183, 183,\n+   183, 183, 183, 184, 183, 183, 183,  12, 185, 183, 183, 183, 186, 186, 186, 186,\n+   186, 186, 186, 187, 186, 188,  12,  12, 189, 189, 189, 189, 189, 189, 189,  12,\n+   189, 189, 190,  12, 189, 189, 191, 192, 193, 193, 193, 193, 193, 193, 193, 194,\n+   195, 195, 195, 195, 195, 195, 195, 196, 195, 195, 195, 197, 195, 195, 198,  12,\n+   195, 195, 195, 198,   7,   7,   7, 199, 200, 200, 200, 200, 200, 200, 200, 201,\n+   200, 200, 200, 202, 203, 203, 203, 203, 204, 204, 204, 204, 204,  12,  12, 204,\n+   205, 205, 205, 205, 205, 205, 206, 205, 205, 205, 207, 208, 209, 209, 209, 209,\n+    19,  19, 210,  12, 146, 146, 211, 212, 203, 203,  12,  12, 213,   7,   7,   7,\n+   214,   7, 215, 216,   0, 215, 217,  12,   2, 218, 219,   2,   2,   2,   2, 220,\n+   221, 218, 222,   2,   2,   2, 223,   2,   2,   2,   2, 224,   8, 225,   8, 225,\n+     8,   8, 226, 226,   8,   8,   8, 225,   8,  15,   8,   8,   8,  10,   8, 227,\n+    10,  15,   8,  14,   0,   0,   0, 228,   0, 229,   0,   0, 230,   0,   0, 231,\n+     0,   0,   0, 232,   2,   2,   2, 233, 234,  12,  12,  12, 235,  12,  12,  12,\n+     0, 236, 237,   0,   4,   0,   0,   0,   0,   0,   0,   4,   2,   2,   5,  12,\n+     0, 232,  12,  12,   0,   0, 232,  12, 238, 238, 238, 238,   0, 239,   0,   0,\n+     0, 240,   0,   0, 241, 241, 241, 241,  18,  18,  18,  18,  18,  12, 242,  18,\n+   243, 243, 243, 243, 243, 243,  12, 244, 245,  12,  12, 244, 151, 154,  12,  12,\n+   151, 154, 151, 154,   0,   0,   0, 246, 247, 247, 247, 247, 247, 247, 248, 247,\n+   247,  12,  12,  12, 247, 249,  12,  12,   0,   0,   0,  12,   0, 250,   0,   0,\n+   251, 247, 252, 253,   0,   0, 247,   0, 254, 255, 255, 255, 255, 255, 255, 255,\n+   255, 256, 257, 258, 259, 260, 260, 260, 260, 260, 260, 260, 260, 260, 261, 259,\n+    12, 262, 263, 263, 263, 263, 263, 263, 264, 150, 150, 150, 150, 150, 150, 265,\n+     0,  12,  12,  12, 150, 150, 150, 266, 260, 260, 260, 261, 260, 260,   0,   0,\n+   267, 267, 267, 267, 267, 267, 267, 268, 267, 269,  12,  12, 270, 270, 270, 270,\n+   271, 271, 271, 271, 271, 271, 271,  12, 272, 272, 272, 272, 272, 272,  12,  12,\n+   237,   2,   2,   2,   2,   2, 231,   2,   2,   2, 273,  12, 274, 275, 276,  12,\n+   277,   2,   2,   2, 278, 278, 278, 278, 278, 278, 278, 279,   0,   0, 246,  12,\n+   280, 280, 280, 280, 280, 280,  12,  12, 281, 281, 281, 281, 281, 282,  12, 283,\n+   281, 281, 282,  12, 284, 284, 284, 284, 284, 284, 284, 285, 286, 286, 286, 286,\n+   286,  12,  12, 287, 150, 150, 150, 288, 289, 289, 289, 289, 289, 289, 289, 290,\n+   289, 289, 291, 292, 145, 145, 145, 293, 294, 294, 294, 294, 294, 295,  12,  12,\n+   294, 294, 294, 296, 294, 294, 296, 294, 297, 297, 297, 297, 298,  12,  12,  12,\n+    12,  12, 299, 297, 300, 300, 300, 300, 300, 301,  12,  12, 155, 154, 155, 154,\n+   155, 154,  12,  12,   2,   2,   3,   2,   2, 302, 303,  12, 300, 300, 300, 304,\n+   300, 300, 304,  12, 150,  12,  12,  12, 150, 265, 305, 150, 150, 150, 150,  12,\n+   247, 247, 247, 249, 247, 247, 249,  12,   2, 273,  12,  12, 306,  22,  12,  24,\n+    25,  26,  25, 307, 308, 309,  25,  25,  50,  12,  12,  12, 310,  29,  29,  29,\n+    29,  29,  29, 311, 312,  29,  29,  29,  29,  29,  12, 310,   7,   7,   7, 313,\n+   232,   0,   0,   0,   0, 232,   0,  12,  29, 314,  29,  29,  29,  29,  29, 315,\n+   316,   0,   0,   0,   0, 317, 260, 260, 260, 260, 260, 318, 319, 150, 319, 150,\n+   319, 150, 319, 288,   0, 232,   0, 232,  12,  12, 316, 246, 320, 320, 320, 321,\n+   320, 320, 320, 320, 320, 322, 320, 320, 320, 320, 322, 323, 320, 320, 320, 324,\n+   320, 320, 322,  12, 232, 131,   0,   0,   0, 131,   0,   0,   8,   8,   8,  14,\n+     0,   0,   0, 234, 325,  12,  12,  12,   0,   0,   0, 326, 327, 327, 327, 327,\n+   327, 327, 327, 328, 329, 329, 329, 329, 330,  12,  12,  12, 215,   0,   0,   0,\n+   331, 331, 331, 331, 331,  12,  12, 332, 333, 333, 333, 333, 333, 333, 334,  12,\n+   335, 335, 335, 335, 335, 335, 336,  12, 337, 337, 337, 337, 337, 337, 337, 338,\n+   339, 339, 339, 339, 339,  12, 339, 339, 339, 340,  12,  12, 341, 341, 341, 341,\n+   342, 342, 342, 342, 343, 343, 343, 343, 343, 343, 343, 344, 343, 343, 344,  12,\n+   345, 345, 345, 345, 345,  12, 345, 345, 345, 345, 345,  12, 346, 346, 346, 346,\n+   346, 346,  12,  12, 347, 347, 347, 347, 347,  12,  12, 348, 349, 349, 350, 349,\n+   350, 351, 349, 349, 351, 349, 349, 349, 351, 349, 351, 352, 353, 353, 353, 353,\n+   353, 354,  12,  12, 353, 355,  12,  12, 353, 353,  12,  12,   2, 274,   2,   2,\n+   356,   2, 273,  12, 357, 358, 359, 357, 357, 357, 357, 357, 357, 360, 361, 362,\n+   363, 363, 363, 363, 363, 364, 363, 363, 365, 365, 365, 365, 366, 366, 366, 366,\n+   366, 366, 366, 367,  12, 368, 366, 366, 369, 369, 369, 369, 370, 371, 372, 369,\n+   373, 373, 373, 373, 373, 373, 373, 374, 375, 375, 375, 375, 375, 375, 376, 377,\n+   378, 378, 378, 378, 379, 379, 379, 379, 379, 379,  12, 379, 380, 379, 379, 379,\n+   381, 382,  12, 381, 381, 383, 383, 381, 381, 381, 381, 381, 381, 384, 385, 386,\n+   381, 381, 387,  12, 388, 388, 388, 388, 389, 389, 389, 389, 390, 390, 390, 390,\n+   390, 391, 392, 390, 390, 391,  12,  12, 393, 393, 393, 393, 393, 394, 395, 393,\n+   396, 396, 396, 396, 396, 397, 396, 396, 398, 398, 398, 398, 399,  12, 398, 398,\n+   400, 400, 400, 400, 401,  12, 402, 403,  12,  12, 402, 400, 404, 404, 404, 404,\n+   404, 404, 405,  12, 406, 406, 406, 406, 407,  12,  12,  12, 407,  12, 408, 406,\n+   409, 409, 409, 409, 409, 409,  12,  12, 409, 409, 410,  12, 411, 411, 411, 411,\n+   411, 411, 412, 413, 413,  12,  12,  12,  12,  12,  12, 414, 415, 415, 415, 415,\n+   415, 415,  12,  12, 416, 416, 416, 416, 416, 416, 417,  12, 418, 418, 418, 418,\n+   418, 418, 419,  12, 420, 420, 420, 420, 420, 420, 420,  12, 421, 421, 421, 421,\n+   421, 422,  12,  12, 423, 423, 423, 423, 423, 423, 423, 424, 425, 423, 423, 423,\n+   423, 424,  12, 426, 427, 427, 427, 427, 428,  12,  12, 429, 430, 430, 430, 430,\n+   430, 430, 431,  12, 430, 430, 432,  12, 433, 433, 433, 433, 433, 434, 433, 433,\n+   433, 433,  12,  12, 435, 435, 435, 435, 435, 436,  12,  12, 437, 437, 437, 437,\n+   118, 119, 119, 119, 119, 127,  12,  12, 438, 438, 438, 438, 439, 438, 438, 438,\n+   440,  12,  12,  12, 441, 442, 443, 444, 441, 441, 441, 444, 441, 441, 445,  12,\n+   446, 446, 446, 446, 446, 446, 447,  12, 446, 446, 448,  12, 449, 450, 449, 451,\n+   451, 449, 449, 449, 449, 449, 452, 449, 452, 450, 453, 449, 449, 451, 451, 454,\n+   455, 456,  12, 450, 449, 457, 449, 455, 449, 455,  12,  12, 458, 458, 458, 458,\n+   458, 458, 458, 459, 460,  12,  12,  12, 461, 461, 461, 461, 461, 461,  12,  12,\n+   461, 461, 462,  12, 463, 463, 463, 463, 463, 464, 463, 463, 463, 463, 463, 464,\n+   465, 465, 465, 465, 465, 466,  12,  12, 465, 465, 467,  12, 178, 178, 178, 180,\n+   468, 468, 468, 468, 468, 468, 469,  12, 470, 470, 470, 470, 470, 470, 471, 472,\n+   470, 470, 470,  12, 470, 471,  12,  12, 473, 473, 473, 473, 473, 473, 473,  12,\n+   474, 474, 474, 474, 475,  12,  12, 476, 477, 478, 479, 477, 477, 480, 477, 477,\n+   477, 477, 477, 477, 477, 481, 482, 477, 477, 478,  12,  12, 477, 477, 483,  12,\n+   484, 484, 485, 484, 484, 484, 484, 484, 484, 486,  12,  12, 487, 487, 487, 487,\n+   487, 487,  12,  12, 488, 488, 488, 488, 489,  12,  12,  12, 490, 490, 490, 490,\n+   490, 490, 491,  12,  53,  53, 492,  12, 493, 493, 494, 493, 493, 493, 493, 493,\n+   493, 495, 493, 493, 493, 496,  12,  12, 493, 493, 493, 497, 498, 498, 498, 498,\n+   499, 498, 498, 498, 498, 498, 500, 498, 498, 501,  12,  12, 502, 503, 504, 502,\n+   502, 502, 502, 502, 502, 503, 505, 504, 502, 502,  12,  12, 502, 502, 506,  12,\n+   507, 508, 509, 507, 507, 507, 507, 507, 507, 507, 507, 510, 508, 507, 511,  12,\n+   507, 507, 512,  12, 513, 513, 513, 513, 513, 513, 514,  12, 515, 515, 515, 515,\n+   516, 515, 515, 515, 515, 515, 517, 518, 515, 515, 519,  12, 520,  12,  12,  12,\n+   100, 100, 100, 100,  96,  12,  12,  98, 521, 521, 521, 521, 521, 521, 522,  12,\n+   521, 521, 521, 523, 521, 524,  12,  12, 521,  12,  12,  12, 525, 525, 525, 525,\n+   526,  12,  12,  12, 527, 527, 527, 527, 527, 528,  12,  12, 529, 529, 529, 529,\n+   529, 530,  12,  12, 272, 272, 531,  12, 532, 532, 532, 532, 532, 532, 532, 533,\n+   532, 532, 534, 535, 536, 536, 536, 536, 536, 536, 536, 537, 536, 536, 538,  12,\n+   539, 539, 539, 539, 539, 539, 539, 540, 539, 540,  12,  12, 541, 541, 541, 541,\n+   541, 542,  12,  12, 541, 541, 543, 541, 543, 541, 541, 541, 541, 541,  12, 544,\n+   545, 545, 545, 545, 545, 545, 546,  12, 547, 547, 547, 547, 547, 547, 548, 549,\n+   547, 547,  12, 549, 550, 551,  12,  12, 249,  12,  12,  12, 552, 552, 552, 552,\n+   552, 552,  12,  12, 553, 553, 553, 553, 553, 554,  12,  12, 552, 552, 555,  12,\n+   260, 556, 260, 557, 558, 255, 255, 255, 559,  12,  12,  12, 560,  12,  12,  12,\n+   256, 561,  12,  12,  12, 260,  12,  12, 562, 562, 562, 562, 562, 562, 562,  12,\n+   563, 563, 563, 563, 563, 563, 564,  12, 563, 563, 563, 565, 563, 563, 565,  12,\n+   563, 563, 566, 563,   7,   7,   7, 567,   7, 199,  12,  12,   0, 246,  12,  12,\n+     0, 232, 316,   0,   0, 568, 228,   0,   0,   0, 568,   7, 213, 569,   7,   0,\n+     0,   0, 570, 228,   8, 225,  12,  12,   0,   0, 234,  12,   0,   0,   0, 229,\n+   571, 572, 316, 229,   0,   0, 240, 316,   0, 316,   0,   0,   0, 240, 232, 316,\n+     0, 229,   0, 229,   0,   0, 240, 232,   0, 573, 239,   0, 229,   0,   0,   0,\n+     0, 246,   0,   0,   0,   0,   0, 239, 574, 574, 574, 574, 574, 574, 574,  12,\n+    12,  12, 575, 574, 576, 574, 574, 574,   2,   2,   2, 273,  12, 275, 273,  12,\n+   241, 577, 241, 241, 241, 241, 578, 241, 579, 580, 577,  12,  19,  19,  19, 581,\n+    12,  12,  12, 582, 583, 583, 583, 583, 583, 583, 583, 584, 583, 583, 583, 585,\n+   583, 583, 585, 586, 587, 587, 587, 587, 587, 587, 587, 588, 589, 589, 589, 589,\n+   589, 589, 590, 591, 592, 592, 592, 592, 592, 592, 593,  12, 151, 154, 151, 594,\n+   151, 151, 151, 154, 595, 595, 595, 595, 595, 596, 595, 595, 595, 597,  12,  12,\n+   598, 598, 598, 598, 598, 598, 598,  12, 598, 598, 599, 600,   0, 234,  12,  12,\n+    29, 414,  29,  29, 601, 602, 414,  29,  50,  29, 603,  12, 604, 310, 603, 414,\n+   601, 602, 603, 603, 601, 602,  50,  29,  50,  29, 414, 605,  29,  29, 606,  29,\n+    29,  29,  29,  12, 414, 414, 606,  29,  51,  12,  12,  12,  12, 239,   0,   0,\n+   607,  12,  12,  12, 246,  12,  12,  12,   0,   0,  12,   0,   0, 232, 131,   0,\n+     0,   0,  12,  12,   0,   0,   0, 240,   0, 246,  12, 239, 608,  12,  12,  12,\n+   247, 247, 609,  12, 610,  12,  12,  12,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0, 939, 940, 941, 942, 946, 948,   0, 962,\n+   969, 970, 971, 976,1001,1002,1003,1008,   0,1033,1040,1041,1042,1043,1047,   0,\n+     0,1080,1081,1082,1086,1110,   0,   0,1124,1125,1126,1127,1131,1133,   0,1147,\n+  1154,1155,1156,1161,1187,1188,1189,1193,   0,1219,1226,1227,1228,1229,1233,   0,\n+     0,1267,1268,1269,1273,1298,   0,1303, 943,1128, 944,1129, 954,1139, 958,1143,\n+   959,1144, 960,1145, 961,1146, 964,1149,   0,   0, 973,1158, 974,1159, 975,1160,\n+   983,1168, 978,1163, 988,1173, 990,1175, 991,1176, 993,1178, 994,1179,   0,   0,\n+  1004,1190,1005,1191,1006,1192,1014,1199,1007,   0,   0,   0,1016,1201,1020,1206,\n+     0,1022,1208,1025,1211,1023,1209,   0,   0,   0,   0,1032,1218,1037,1223,1035,\n+  1221,   0,   0,   0,1044,1230,1045,1231,1049,1235,   0,   0,1058,1244,1064,1250,\n+  1060,1246,1066,1252,1067,1253,1072,1258,1069,1255,1077,1264,1074,1261,   0,   0,\n+  1083,1270,1084,1271,1085,1272,1088,1275,1089,1276,1096,1283,1103,1290,1111,1299,\n+  1115,1118,1307,1120,1309,1121,1310,   0,1053,1239,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,1093,1280,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0, 949,1134,1010,1195,1050,1236,1090,1277,1341,1368,1340,\n+  1367,1342,1369,1339,1366,   0,1320,1347,1418,1419,1323,1350,   0,   0, 992,1177,\n+  1018,1204,1055,1241,1416,1417,1415,1424,1202,   0,   0,   0, 987,1172,   0,   0,\n+  1031,1217,1321,1348,1322,1349,1338,1365, 950,1135, 951,1136, 979,1164, 980,1165,\n+  1011,1196,1012,1197,1051,1237,1052,1238,1061,1247,1062,1248,1091,1278,1092,1279,\n+  1071,1257,1076,1263,   0,   0, 997,1182,   0,   0,   0,   0,   0,   0, 945,1130,\n+   982,1167,1337,1364,1335,1362,1046,1232,1422,1423,1113,1301,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   8,   9,   0,  10,1425,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,1314,1427,   5,\n+  1434,1438,1443,   0,1450,   0,1455,1461,1514,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1446,1458,1468,1476,1480,1486,1517,   0,   0,   0,   0,   0,   0,   0,\n@@ -5237,183 +4210,141 @@\n-     0,   0,   0,   0, 257,  26,  26,  26,   0, 265,  26,  26,   0,   0,   0,   0,\n-   266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 267,   0,\n-     0,   0, 268,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-   269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269,   2,   2,   2,   2,\n-    17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17, 270, 271,\n-   164, 164, 164, 164, 165, 166, 272, 272, 272, 272, 272, 272, 272, 273, 274, 273,\n-   169, 169, 171,  26, 171, 171, 171, 171, 171, 171, 171, 171,  18,  18,  18,  18,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 275,  26,  26,  26,  26,\n-   276, 276, 276, 277, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 278,  26,\n-   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276,\n-   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 279,  26,  26,  26,   0, 280,\n-   281,   0,   0,   0, 282, 283,   0, 284, 285, 286, 286, 286, 286, 286, 286, 286,\n-   286, 286, 287, 288, 289, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 291,\n-   292, 293, 293, 293, 293, 293, 294, 168, 168, 168, 168, 168, 168, 168, 168, 168,\n-   168, 295,   0,   0, 293, 293, 293, 293,   0,   0,   0,   0, 280,  26, 290, 290,\n-   168, 168, 168, 295,   0,   0,   0,   0,   0,   0,   0,   0, 168, 168, 168, 296,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 290, 290, 290, 290, 290, 297,\n-   290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290,   0,   0,   0,   0,   0,\n-   276, 276, 276, 276, 276, 276, 276, 276,   0,   0,   0,   0,   0,   0,   0,   0,\n-   298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298,\n-   298, 299, 298, 298, 298, 298, 298, 298, 300,  26, 301, 301, 301, 301, 301, 301,\n-   302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-   302, 302, 302, 302, 302, 303,  26,  26,  18,  18,  18,  18,  18,  18,  18,  18,\n-    18,  18,  18,  18, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304,  26,\n-     0,   0,   0,   0, 305,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,\n-     2, 306,   2,   2,   2,   2,   2,   2,   2, 307, 308, 309,  26,  26, 310,   2,\n-   311, 311, 311, 311, 311, 312,   0, 313, 314, 314, 314, 314, 314, 314, 314,  26,\n-   315, 315, 315, 315, 315, 315, 315, 315, 316, 317, 315, 318,  53,  53,  53,  53,\n-   319, 319, 319, 319, 319, 320, 321, 321, 321, 321, 322, 323, 168, 168, 168, 324,\n-   325, 325, 325, 325, 325, 325, 325, 325, 325, 326, 325, 327, 163, 163, 163, 328,\n-   329, 329, 329, 329, 329, 329, 330,  26, 329, 331, 329, 332, 163, 163, 163, 163,\n-   333, 333, 333, 333, 333, 333, 333, 333, 334,  26,  26, 335, 336, 336, 337,  26,\n-   338, 338, 338,  26, 171, 171,   2,   2,   2,   2,   2, 339, 340, 341, 175, 175,\n-   175, 175, 175, 175, 175, 175, 175, 175, 336, 336, 336, 336, 336, 342, 336, 343,\n-   168, 168, 168, 168, 344,  26, 168, 168, 295, 345, 168, 168, 168, 168, 168, 344,\n-    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 279, 276, 276,\n-   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 346,  26,  26,  26,  26,\n-   347,  26, 348, 349,  25,  25, 350, 351, 352,  25,  31,  31,  31,  31,  31,  31,\n-    31,  31,  31,  31,  31,  31,  31,  31, 353,  26, 354,  31,  31,  31,  31,  31,\n-    31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,\n-    31,  31,  31,  31,  31,  31,  31, 355,  31,  31,  31,  31,  31,  31,  31,  31,\n-    31,  31, 356,  31,  31,  31,  31,  31,  31, 357,  26,  26,  26,  26,  31,  31,\n-     9,   9,   0, 313,   9, 358,   0,   0,   0,   0, 359,   0, 257, 280, 360,  31,\n-    31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31, 361,\n-   362,   0,   0,   0,   1,   2,   2,   3,   1,   2,   2,   3, 363, 290, 289, 290,\n-   290, 290, 290, 364, 168, 168, 168, 295, 365, 365, 365, 366, 257, 257,  26, 367,\n-   368, 369, 368, 368, 370, 368, 368, 371, 368, 372, 368, 372,  26,  26,  26,  26,\n-   368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 373,\n-   374,   0,   0,   0,   0,   0, 375,   0,  14,  14,  14,  14,  14,  14,  14,  14,\n-    14, 252,   0, 376, 377,  26,  26,  26,  26,  26,   0,   0,   0,   0,   0, 378,\n-   379, 379, 379, 380, 381, 381, 381, 381, 381, 381, 382,  26, 383,   0,   0, 280,\n-   384, 384, 384, 384, 385, 386, 387, 387, 387, 388, 389, 389, 389, 389, 389, 390,\n-   391, 391, 391, 392, 393, 393, 393, 393, 394, 393, 395,  26,  26,  26,  26,  26,\n-   396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 397, 397, 397, 397, 397, 397,\n-   398, 398, 398, 399, 398, 400, 401, 401, 401, 401, 402, 401, 401, 401, 401, 402,\n-   403, 403, 403, 403, 403,  26, 404, 404, 404, 404, 404, 404, 405, 406, 407, 408,\n-   407, 408, 409, 407, 410, 407, 410, 411,  26,  26,  26,  26,  26,  26,  26,  26,\n-   412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412,\n-   412, 412, 412, 412, 412, 412, 413,  26, 412, 412, 414,  26, 412,  26,  26,  26,\n-   415,   2,   2,   2,   2,   2, 416, 307,  26,  26,  26,  26,  26,  26,  26,  26,\n-   417, 418, 419, 419, 419, 419, 420, 421, 422, 422, 423, 422, 424, 424, 424, 424,\n-   425, 425, 425, 426, 427, 425,  26,  26,  26,  26,  26,  26, 428, 428, 429, 430,\n-   431, 431, 431, 432, 433, 433, 433, 434,  26,  26,  26,  26,  26,  26,  26,  26,\n-   435, 435, 435, 435, 436, 436, 436, 437, 436, 436, 438, 436, 436, 436, 436, 436,\n-   439, 440, 441, 442, 443, 443, 444, 445, 443, 446, 443, 446, 447, 447, 447, 447,\n-   448, 448, 448, 448,  26,  26,  26,  26, 449, 449, 449, 449, 450, 451, 450,  26,\n-   452, 452, 452, 452, 452, 452, 453, 454, 455, 455, 456, 455, 457, 457, 458, 457,\n-   459, 459, 460, 461,  26, 462,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-   463, 463, 463, 463, 463, 463, 463, 463, 463, 464,  26,  26,  26,  26,  26,  26,\n-   465, 465, 465, 465, 465, 465, 466,  26, 465, 465, 465, 465, 465, 465, 466, 467,\n-   468, 468, 468, 468, 468,  26, 468, 469,  26,  26,  26,  26,  26,  26,  26,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  31,  31,  31,  50,\n-   470, 470, 470, 470, 470, 471, 472,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-   473, 473, 473, 473, 473,  26, 474, 474, 474, 474, 474, 475,  26,  26, 476, 476,\n-   476, 477,  26,  26,  26,  26, 478, 478, 478, 479,  26,  26, 480, 480, 481,  26,\n-   482, 482, 482, 482, 482, 482, 482, 482, 482, 483, 484, 482, 482, 482, 483, 485,\n-   486, 486, 486, 486, 486, 486, 486, 486, 487, 488, 489, 489, 489, 490, 489, 491,\n-   492, 492, 492, 492, 492, 492, 493, 492, 492,  26, 494, 494, 494, 494, 495,  26,\n-   496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 497, 137, 498,  26,\n-   499, 499, 500, 499, 499, 499, 499, 501,  26,  26,  26,  26,  26,  26,  26,  26,\n-   502, 503, 504, 505, 504, 506, 507, 507, 507, 507, 507, 507, 507, 508, 507, 509,\n-   510, 511, 512, 513, 513, 514, 515, 516, 511, 517, 518, 519, 520, 521, 521,  26,\n-   522, 522, 522, 522, 522, 522, 522, 522, 522, 522, 522, 523, 524,  26,  26,  26,\n-   525, 525, 525, 525, 525, 525, 525, 525, 525,  26, 525, 526,  26,  26,  26,  26,\n-   527, 527, 527, 527, 527, 527, 528, 527, 527, 527, 527, 528,  26,  26,  26,  26,\n-   529, 529, 529, 529, 529, 529, 529, 529, 530,  26, 529, 531, 197, 532,  26,  26,\n-   533, 533, 533, 533, 533, 533, 533, 534, 533, 534,  26,  26,  26,  26,  26,  26,\n-   535, 535, 535, 536, 535, 537, 535, 535, 538,  26,  26,  26,  26,  26,  26,  26,\n-   539, 539, 539, 539, 539, 539, 539, 540,  26,  26,  26,  26,  26,  26,  26,  26,\n-    26,  26,  26,  26, 541, 541, 541, 541, 541, 541, 541, 541, 541, 541, 542, 543,\n-   544, 545, 546, 547, 547, 547, 548, 549, 544,  26, 547, 550,  26,  26,  26,  26,\n-    26,  26,  26,  26, 551, 552, 551, 551, 551, 551, 551, 552, 553,  26,  26,  26,\n-   554, 554, 554, 554, 554, 554, 554, 554, 554,  26, 555, 555, 555, 555, 555, 555,\n-   555, 555, 555, 555, 556,  26, 177, 177, 557, 557, 557, 557, 557, 557, 557, 558,\n-   559, 560, 559, 559, 559, 559, 561, 559, 562,  26, 559, 559, 559, 563, 564, 564,\n-   564, 564, 565, 564, 564, 566, 567,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-   568, 569, 570, 570, 570, 570, 568, 571, 570,  26, 570, 572, 573, 574, 575, 575,\n-   575, 576, 577, 578, 575, 579,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26, 580, 580, 580, 581,\n-    26,  26,  26,  26,  26,  26, 582,  26, 108, 108, 108, 108, 108, 108, 583, 584,\n-   585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585,\n-   585, 585, 585, 586,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-   585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 587, 588,  26,\n-   585, 585, 585, 585, 585, 585, 585, 585, 589,  26,  26,  26,  26,  26,  26,  26,\n-    26,  26, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 591,  26,\n-   592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592,\n-   592, 592, 592, 592, 592, 593, 592, 594,  26,  26,  26,  26,  26,  26,  26,  26,\n-   595, 595, 595, 595, 595, 595, 595, 595, 595, 595, 595, 595, 595, 595, 595, 595,\n-   595, 595, 595, 595, 595, 595, 595, 595, 596,  26,  26,  26,  26,  26,  26,  26,\n-   304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304,\n-   304, 304, 304, 304, 304, 304, 304, 597, 598, 598, 598, 599, 598, 600, 601, 601,\n-   601, 601, 601, 601, 601, 601, 601, 602, 601, 603, 604, 604, 604, 605, 605,  26,\n-   606, 606, 606, 606, 606, 606, 606, 606, 607,  26, 606, 608, 608, 606, 606, 609,\n-   606, 606,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26, 610, 610, 610, 610, 610, 610, 610, 610,\n-   610, 610, 610, 611,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-   612, 612, 612, 612, 612, 612, 612, 612, 612, 613, 612, 612, 612, 612, 612, 612,\n-   612, 614, 612, 612,  26,  26,  26,  26,  26,  26,  26,  26, 615,  26, 346,  26,\n-   616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616,\n-   616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616,  26,\n-   617, 617, 617, 617, 617, 617, 617, 617, 617, 617, 617, 617, 617, 617, 617, 617,\n-   617, 617, 617, 617, 617, 617, 617, 617, 617, 617, 618,  26,  26,  26,  26,  26,\n-   616, 619,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26, 620, 621,\n-   622, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286,\n-   286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286,\n-   286, 286, 286, 286, 623,  26,  26,  26,  26,  26, 624,  26, 625,  26, 626, 626,\n-   626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626,\n-   626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 627,\n-   628, 628, 628, 628, 628, 628, 628, 628, 628, 628, 628, 628, 628, 629, 628, 630,\n-   628, 631, 628, 632, 280,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-     9,   9,   9,   9,   9, 633,   9,   9, 220,  26,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0, 280,  26,  26,  26,  26,  26,  26,  26,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 275,  26,\n-     0,   0,   0,   0, 257, 362,   0,   0,   0,   0,   0,   0, 634, 635,   0, 636,\n-   637, 638,   0,   0,   0, 639,   0,   0,   0,   0,   0,   0,   0, 265,  26,  26,\n-    14,  14,  14,  14,  14,  14,  14,  14, 246,  26,  26,  26,  26,  26,  26,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,   0,   0, 280,  26,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 257,  26,   0,   0,   0, 259,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 254,   0,   0,   0,   0,   0,\n-     0,   0,   0, 254, 640, 641,   0, 642, 643,   0,   0,   0,   0,   0,   0,   0,\n-   268, 644, 254, 254,   0,   0,   0, 645, 646, 647, 648,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0, 275,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0, 267,   0,   0,   0,   0,   0,   0,\n-   649, 649, 649, 649, 649, 649, 649, 649, 649, 649, 649, 649, 649, 649, 649, 649,\n-   649, 650,  26, 651, 652, 649,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-     2,   2,   2, 347,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-   653, 269, 269, 654, 655, 656,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-   657, 657, 657, 657, 657, 658, 657, 659, 657, 660,  26,  26,  26,  26,  26,  26,\n-    26,  26, 661, 661, 661, 662,  26,  26, 663, 663, 663, 663, 663, 663, 663, 664,\n-    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26, 171, 665, 169, 171,\n-   666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666,\n-   666, 666, 666, 666, 666, 666, 666, 666, 667, 666, 668,  26,  26,  26,  26,  26,\n-   669, 669, 669, 669, 669, 669, 669, 669, 669, 670, 669, 671,  26,  26,  26,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26, 362,   0,\n-     0,   0,   0,   0,   0,   0, 376,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-   362,   0,   0,   0,   0,   0,   0, 275,  26,  26,  26,  26,  26,  26,  26,  26,\n-   672,  31,  31,  31, 673, 674, 675, 676, 677, 678, 673, 679, 673, 675, 675, 680,\n-    31, 681,  31, 682, 683, 681,  31, 682,  26,  26,  26,  26,  26,  26,  51,  26,\n-     0,   0,   0,   0,   0, 280,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0, 280,  26,   0, 257, 362,   0, 362,   0, 362,   0,   0,   0, 275,  26,\n-     0,   0,   0,   0,   0, 275,  26,  26,  26,  26,  26,  26, 684,   0,   0,   0,\n-   685,  26,   0,   0,   0,   0,   0, 280,   0, 259, 313,  26, 275,  26,  26,  26,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 686,   0, 376,   0, 376,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 280,  26,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 259,   0, 280, 259,  26,\n-     0, 280,   0,   0,   0,   0,   0,   0,   0,  26,   0, 313,   0,   0,   0,   0,\n-     0,  26,   0,   0,   0, 275, 313,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 280,  26,   0, 275, 376, 376,\n-   257,  26,   0,   0,   0, 376,   0, 265, 275,  26,   0, 313,   0,  26, 257,  26,\n-     0,   0, 359,   0,   0,   0,   0,   0,   0, 265,  26,  26,  26,  26,   0, 313,\n-   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276,  26,  26,  26,  26,\n-   276, 276, 276, 276, 276, 276, 276, 687, 276, 276, 276, 276, 276, 276, 276, 276,\n-   276, 276, 276, 279, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276,\n-   276, 276, 276, 276, 346,  26, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276,\n-   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 687,  26,  26,  26,\n-   276, 276, 276, 279,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-   276, 276, 276, 276, 276, 276, 276, 276, 276, 688,  26,  26,  26,  26,  26,  26,\n-   689,  26,  26,  26,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,\n-     9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   0,   0,\n+     0,   0,1489,1503,1494,1500,1508,   0,   0,   0,   0,1520,1521,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,1526,1528,   0,1525,   0,   0,   0,1522,\n+     0,   0,   0,   0,1536,1532,1539,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1534,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1556,   0,   0,   0,   0,   0,   0,1548,1550,   0,1547,   0,   0,   0,1567,\n+     0,   0,   0,   0,1558,1554,1561,   0,   0,   0,   0,   0,   0,   0,1568,1569,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,1529,1551,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,1523,1545,1524,1546,   0,   0,1527,1549,\n+     0,   0,1570,1571,1530,1552,1531,1553,   0,   0,1533,1555,1535,1557,1537,1559,\n+     0,   0,1572,1573,1544,1566,1538,1560,1540,1562,1541,1563,1542,1564,   0,   0,\n+  1543,1565,   0,   0,   0,   0,   0,   0,   0,   0,1606,1607,1609,1608,1610,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,1613,   0,1611,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1612,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1620,   0,   0,   0,   0,   0,   0,   0,1623,   0,   0,1624,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+  1614,1615,1616,1617,1618,1619,1621,1622,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,1628,1629,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1625,1626,   0,1627,   0,   0,   0,1634,   0,   0,1635,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1630,1631,1632,   0,   0,1633,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+  1639,   0,   0,1638,1640,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1636,1637,   0,   0,   0,   0,   0,   0,1641,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1642,1644,1643,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+  1645,   0,   0,   0,   0,   0,   0,   0,1646,   0,   0,   0,   0,   0,   0,1648,\n+  1649,   0,1647,1650,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1651,1653,1652,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1654,   0,1655,1657,1656,   0,   0,   0,   0,1659,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,1660,   0,   0,   0,   0,1661,   0,   0,   0,   0,1662,\n+     0,   0,   0,   0,1663,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1658,   0,   0,   0,   0,   0,   0,   0,   0,   0,1664,   0,1665,1673,   0,\n+  1674,   0,   0,   0,   0,   0,   0,   0,   0,1666,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1668,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,1669,   0,   0,   0,   0,1670,   0,   0,   0,   0,1671,\n+     0,   0,   0,   0,1672,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1667,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1675,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1676,   0,\n+  1677,   0,1678,   0,1679,   0,1680,   0,   0,   0,1681,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,1682,   0,1683,   0,   0,1684,1685,   0,1686,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0, 953,1138, 955,1140, 956,1141, 957,1142,\n+  1324,1351, 963,1148, 965,1150, 968,1153, 966,1151, 967,1152,1378,1380,1379,1381,\n+   984,1169, 985,1170,1420,1421, 986,1171, 989,1174, 995,1180, 998,1183, 996,1181,\n+   999,1184,1000,1185,1015,1200,1329,1356,1017,1203,1019,1205,1021,1207,1024,1210,\n+  1687,1688,1027,1213,1026,1212,1028,1214,1029,1215,1030,1216,1034,1220,1036,1222,\n+  1039,1225,1038,1224,1334,1361,1336,1363,1382,1384,1383,1385,1056,1242,1057,1243,\n+  1059,1245,1063,1249,1689,1690,1065,1251,1068,1254,1070,1256,1386,1387,1388,1389,\n+  1691,1692,1073,1259,1075,1262,1079,1266,1078,1265,1095,1282,1098,1285,1097,1284,\n+  1390,1391,1392,1393,1099,1286,1100,1287,1101,1288,1102,1289,1105,1292,1104,1291,\n+  1106,1294,1107,1295,1108,1296,1114,1302,1119,1308,1122,1311,1123,1312,1186,1260,\n+  1293,1305,   0,1394,   0,   0,   0,   0, 952,1137, 947,1132,1317,1344,1316,1343,\n+  1319,1346,1318,1345,1693,1695,1371,1375,1370,1374,1373,1377,1372,1376,1694,1696,\n+   981,1166, 977,1162, 972,1157,1326,1353,1325,1352,1328,1355,1327,1354,1697,1698,\n+  1009,1194,1013,1198,1054,1240,1048,1234,1331,1358,1330,1357,1333,1360,1332,1359,\n+  1699,1700,1396,1401,1395,1400,1398,1403,1397,1402,1399,1404,1094,1281,1087,1274,\n+  1406,1411,1405,1410,1408,1413,1407,1412,1409,1414,1109,1297,1117,1306,1116,1304,\n+  1112,1300,   0,   0,   0,   0,   0,   0,1471,1472,1701,1705,1702,1706,1703,1707,\n+  1430,1431,1715,1719,1716,1720,1717,1721,1477,1478,1729,1731,1730,1732,   0,   0,\n+  1435,1436,1733,1735,1734,1736,   0,   0,1481,1482,1737,1741,1738,1742,1739,1743,\n+  1439,1440,1751,1755,1752,1756,1753,1757,1490,1491,1765,1768,1766,1769,1767,1770,\n+  1447,1448,1771,1774,1772,1775,1773,1776,1495,1496,1777,1779,1778,1780,   0,   0,\n+  1451,1452,1781,1783,1782,1784,   0,   0,1504,1505,1785,1788,1786,1789,1787,1790,\n+     0,1459,   0,1791,   0,1792,   0,1793,1509,1510,1794,1798,1795,1799,1796,1800,\n+  1462,1463,1808,1812,1809,1813,1810,1814,1467,  21,1475,  22,1479,  23,1485,  24,\n+  1493,  27,1499,  28,1507,  29,   0,   0,1704,1708,1709,1710,1711,1712,1713,1714,\n+  1718,1722,1723,1724,1725,1726,1727,1728,1740,1744,1745,1746,1747,1748,1749,1750,\n+  1754,1758,1759,1760,1761,1762,1763,1764,1797,1801,1802,1803,1804,1805,1806,1807,\n+  1811,1815,1816,1817,1818,1819,1820,1821,1470,1469,1822,1474,1465,   0,1473,1825,\n+  1429,1428,1426,  12,1432,   0,  26,   0,   0,1315,1823,1484,1466,   0,1483,1829,\n+  1433,  13,1437,  14,1441,1826,1827,1828,1488,1487,1513,  19,   0,   0,1492,1515,\n+  1445,1444,1442,  15,   0,1831,1832,1833,1502,1501,1516,  25,1497,1498,1506,1518,\n+  1457,1456,1454,  17,1453,1313,  11,   3,   0,   0,1824,1512,1519,   0,1511,1830,\n+  1449,  16,1460,  18,1464,   4,   0,   0,  30,  31,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  20,   0,\n+     0,   0,   2,   6,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1834,1835,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,1836,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,1837,1839,1838,   0,   0,   0,   0,1840,   0,   0,   0,\n+     0,1841,   0,   0,1842,   0,   0,   0,   0,   0,   0,   0,1843,   0,1844,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,1845,   0,   0,1846,   0,   0,1847,\n+     0,1848,   0,   0,   0,   0,   0,   0, 937,   0,1850,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,1849, 936, 938,1851,1852,   0,   0,1853,1854,   0,   0,\n+  1855,1856,   0,   0,   0,   0,   0,   0,1857,1858,   0,   0,1861,1862,   0,   0,\n+  1863,1864,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1867,1868,1869,1870,1859,1860,1865,1866,   0,   0,   0,   0,\n+     0,   0,1871,1872,1873,1874,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,  32,  33,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1875,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1877,   0,1878,   0,1879,   0,1880,   0,1881,   0,1882,   0,\n+  1883,   0,1884,   0,1885,   0,1886,   0,1887,   0,1888,   0,   0,1889,   0,1890,\n+     0,1891,   0,   0,   0,   0,   0,   0,1892,1893,   0,1894,1895,   0,1896,1897,\n+     0,1898,1899,   0,1900,1901,   0,   0,   0,   0,   0,   0,1876,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,1902,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1904,   0,1905,   0,1906,   0,1907,   0,1908,   0,1909,   0,\n+  1910,   0,1911,   0,1912,   0,1913,   0,1914,   0,1915,   0,   0,1916,   0,1917,\n+     0,1918,   0,   0,   0,   0,   0,   0,1919,1920,   0,1921,1922,   0,1923,1924,\n+     0,1925,1926,   0,1927,1928,   0,   0,   0,   0,   0,   0,1903,   0,   0,1929,\n+  1930,1931,1932,   0,   0,   0,1933,   0, 710, 385, 724, 715, 455, 103, 186, 825,\n+   825, 242, 751, 205, 241, 336, 524, 601, 663, 676, 688, 738, 411, 434, 474, 500,\n+   649, 746, 799, 108, 180, 416, 482, 662, 810, 275, 462, 658, 692, 344, 618, 679,\n+   293, 388, 440, 492, 740, 116, 146, 168, 368, 414, 481, 527, 606, 660, 665, 722,\n+   781, 803, 809, 538, 553, 588, 642, 758, 811, 701, 233, 299, 573, 612, 487, 540,\n+   714, 779, 232, 267, 412, 445, 457, 585, 594, 766, 167, 613, 149, 148, 560, 589,\n+   648, 768, 708, 345, 411, 704, 105, 259, 313, 496, 518, 174, 542, 120, 307, 101,\n+   430, 372, 584, 183, 228, 529, 650, 697, 424, 732, 428, 349, 632, 355, 517, 110,\n+   135, 147, 403, 580, 624, 700, 750, 170, 193, 245, 297, 374, 463, 543, 763, 801,\n+   812, 815, 162, 384, 420, 730, 287, 330, 337, 366, 459, 476, 509, 558, 591, 610,\n+   726, 652, 734, 759, 154, 163, 198, 473, 683, 697, 292, 311, 353, 423, 572, 494,\n+   113, 217, 259, 280, 314, 499, 506, 603, 608, 752, 778, 782, 788, 117, 557, 748,\n+   774, 320, 109, 126, 260, 265, 373, 411, 479, 523, 655, 737, 823, 380, 765, 161,\n+   395, 398, 438, 451, 502, 516, 537, 583, 791, 136, 340, 769, 122, 273, 446, 727,\n+   305, 322, 400, 496, 771, 155, 190, 269, 377, 391, 406, 432, 501, 519, 599, 684,\n+   687, 749, 776, 175, 452, 191, 480, 510, 659, 772, 805, 813, 397, 444, 619, 566,\n+   568, 575, 491, 471, 707, 111, 636, 156, 153, 288, 346, 578, 256, 435, 383, 729,\n+   680, 767, 694, 295, 128, 210,   0,   0, 227,   0, 379,   0,   0, 150, 493, 525,\n+   544, 551, 552, 556, 783, 576, 604,   0, 661,   0, 703,   0,   0, 735, 743,   0,\n+     0,   0, 793, 794, 795, 808, 741, 773, 118, 127, 130, 166, 169, 177, 207, 213,\n+   215, 226, 229, 268, 270, 317, 327, 329, 335, 369, 375, 381, 404, 441, 448, 458,\n+   477, 484, 503, 539, 545, 547, 546, 548, 549, 550, 554, 555, 561, 564, 569, 591,\n+   593, 595, 598, 607, 620, 625, 625, 651, 690, 695, 705, 706, 716, 717, 733, 735,\n+   777, 786, 790, 315, 869, 623,   0,   0, 102, 145, 134, 115, 129, 138, 165, 171,\n+   207, 202, 206, 212, 227, 231, 240, 243, 250, 254, 294, 296, 303, 308, 319, 325,\n+   321, 329, 326, 335, 341, 357, 360, 362, 370, 379, 388, 389, 393, 421, 424, 438,\n+   456, 454, 458, 465, 477, 535, 485, 490, 493, 507, 512, 514, 521, 522, 525, 526,\n+   528, 533, 532, 541, 565, 569, 574, 586, 591, 597, 607, 637, 647, 674, 691, 693,\n+   695, 698, 703, 699, 705, 704, 702, 706, 709, 717, 728, 736, 747, 754, 770, 777,\n+   783, 784, 786, 787, 790, 802, 825, 848, 847, 857,  55,  65,  66, 883, 892, 916,\n+   822, 824,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,1586,   0,1605,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1602,1603,1934,1935,1574,1575,1576,1577,1579,1580,1581,1583,1584,   0,\n+  1585,1587,1588,1589,1591,   0,1592,   0,1593,1594,   0,1595,1596,   0,1598,1599,\n+  1600,1601,1604,1582,1578,1590,1597,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1936,   0,1937,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,1938,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,1939,1940,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,1941,1942,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,1944,1943,   0,1945,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1946,1947,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+  1948,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,1949,1950,1951,1952,1953,1954,1955,   0,   0,   0,\n@@ -5421,206 +4352,36 @@\n-   939, 940, 941, 942, 946, 948,   0, 962, 969, 970, 971, 976,1001,1002,1003,1008,\n-     0,1033,1040,1041,1042,1043,1047,   0,   0,1080,1081,1082,1086,1110,   0,   0,\n-  1124,1125,1126,1127,1131,1133,   0,1147,1154,1155,1156,1161,1187,1188,1189,1193,\n-     0,1219,1226,1227,1228,1229,1233,   0,   0,1267,1268,1269,1273,1298,   0,1303,\n-   943,1128, 944,1129, 954,1139, 958,1143, 959,1144, 960,1145, 961,1146, 964,1149,\n-     0,   0, 973,1158, 974,1159, 975,1160, 983,1168, 978,1163, 988,1173, 990,1175,\n-   991,1176, 993,1178, 994,1179,   0,   0,1004,1190,1005,1191,1006,1192,1014,1199,\n-  1007,   0,   0,   0,1016,1201,1020,1206,   0,1022,1208,1025,1211,1023,1209,   0,\n-     0,   0,   0,1032,1218,1037,1223,1035,1221,   0,   0,   0,1044,1230,1045,1231,\n-  1049,1235,   0,   0,1058,1244,1064,1250,1060,1246,1066,1252,1067,1253,1072,1258,\n-  1069,1255,1077,1264,1074,1261,   0,   0,1083,1270,1084,1271,1085,1272,1088,1275,\n-  1089,1276,1096,1283,1103,1290,1111,1299,1115,1118,1307,1120,1309,1121,1310,   0,\n-  1053,1239,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1093,\n-  1280,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 949,1134,1010,\n-  1195,1050,1236,1090,1277,1341,1368,1340,1367,1342,1369,1339,1366,   0,1320,1347,\n-  1418,1419,1323,1350,   0,   0, 992,1177,1018,1204,1055,1241,1416,1417,1415,1424,\n-  1202,   0,   0,   0, 987,1172,   0,   0,1031,1217,1321,1348,1322,1349,1338,1365,\n-   950,1135, 951,1136, 979,1164, 980,1165,1011,1196,1012,1197,1051,1237,1052,1238,\n-  1061,1247,1062,1248,1091,1278,1092,1279,1071,1257,1076,1263,   0,   0, 997,1182,\n-     0,   0,   0,   0,   0,   0, 945,1130, 982,1167,1337,1364,1335,1362,1046,1232,\n-  1422,1423,1113,1301,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     8,   9,   0,  10,1425,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,\n-     0,   0,   0,   0,   0,1314,1427,   5,1434,1438,1443,   0,1450,   0,1455,1461,\n-  1514,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1446,1458,1468,1476,1480,1486,\n-  1517,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1489,1503,1494,1500,1508,   0,\n-     0,   0,   0,1520,1521,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-  1526,1528,   0,1525,   0,   0,   0,1522,   0,   0,   0,   0,1536,1532,1539,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1534,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1556,   0,   0,   0,   0,   0,   0,\n-  1548,1550,   0,1547,   0,   0,   0,1567,   0,   0,   0,   0,1558,1554,1561,   0,\n-     0,   0,   0,   0,   0,   0,1568,1569,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,1529,1551,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-  1523,1545,1524,1546,   0,   0,1527,1549,   0,   0,1570,1571,1530,1552,1531,1553,\n-     0,   0,1533,1555,1535,1557,1537,1559,   0,   0,1572,1573,1544,1566,1538,1560,\n-  1540,1562,1541,1563,1542,1564,   0,   0,1543,1565,   0,   0,   0,   0,   0,   0,\n-     0,   0,1606,1607,1609,1608,1610,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-  1613,   0,1611,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,1612,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1620,   0,   0,   0,   0,   0,   0,\n-     0,1623,   0,   0,1624,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,1614,1615,1616,1617,1618,1619,1621,1622,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1628,1629,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1625,1626,   0,1627,\n-     0,   0,   0,1634,   0,   0,1635,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1630,1631,1632,   0,   0,1633,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,1639,   0,   0,1638,1640,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1636,1637,   0,   0,\n-     0,   0,   0,   0,1641,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1642,1644,1643,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,1645,   0,   0,   0,   0,   0,   0,   0,\n-  1646,   0,   0,   0,   0,   0,   0,1648,1649,   0,1647,1650,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1651,1653,1652,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1654,   0,1655,1657,1656,   0,\n-     0,   0,   0,1659,   0,   0,   0,   0,   0,   0,   0,   0,   0,1660,   0,   0,\n-     0,   0,1661,   0,   0,   0,   0,1662,   0,   0,   0,   0,1663,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1658,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,1664,   0,1665,1673,   0,1674,   0,   0,   0,   0,   0,   0,   0,\n-     0,1666,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,1668,   0,   0,   0,   0,   0,   0,   0,   0,   0,1669,   0,   0,\n-     0,   0,1670,   0,   0,   0,   0,1671,   0,   0,   0,   0,1672,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1667,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,1675,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,1676,   0,1677,   0,1678,   0,1679,   0,1680,   0,\n-     0,   0,1681,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1682,   0,1683,   0,   0,\n-  1684,1685,   0,1686,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-   953,1138, 955,1140, 956,1141, 957,1142,1324,1351, 963,1148, 965,1150, 968,1153,\n-   966,1151, 967,1152,1378,1380,1379,1381, 984,1169, 985,1170,1420,1421, 986,1171,\n-   989,1174, 995,1180, 998,1183, 996,1181, 999,1184,1000,1185,1015,1200,1329,1356,\n-  1017,1203,1019,1205,1021,1207,1024,1210,1687,1688,1027,1213,1026,1212,1028,1214,\n-  1029,1215,1030,1216,1034,1220,1036,1222,1039,1225,1038,1224,1334,1361,1336,1363,\n-  1382,1384,1383,1385,1056,1242,1057,1243,1059,1245,1063,1249,1689,1690,1065,1251,\n-  1068,1254,1070,1256,1386,1387,1388,1389,1691,1692,1073,1259,1075,1262,1079,1266,\n-  1078,1265,1095,1282,1098,1285,1097,1284,1390,1391,1392,1393,1099,1286,1100,1287,\n-  1101,1288,1102,1289,1105,1292,1104,1291,1106,1294,1107,1295,1108,1296,1114,1302,\n-  1119,1308,1122,1311,1123,1312,1186,1260,1293,1305,   0,1394,   0,   0,   0,   0,\n-   952,1137, 947,1132,1317,1344,1316,1343,1319,1346,1318,1345,1693,1695,1371,1375,\n-  1370,1374,1373,1377,1372,1376,1694,1696, 981,1166, 977,1162, 972,1157,1326,1353,\n-  1325,1352,1328,1355,1327,1354,1697,1698,1009,1194,1013,1198,1054,1240,1048,1234,\n-  1331,1358,1330,1357,1333,1360,1332,1359,1699,1700,1396,1401,1395,1400,1398,1403,\n-  1397,1402,1399,1404,1094,1281,1087,1274,1406,1411,1405,1410,1408,1413,1407,1412,\n-  1409,1414,1109,1297,1117,1306,1116,1304,1112,1300,   0,   0,   0,   0,   0,   0,\n-  1471,1472,1701,1705,1702,1706,1703,1707,1430,1431,1715,1719,1716,1720,1717,1721,\n-  1477,1478,1729,1731,1730,1732,   0,   0,1435,1436,1733,1735,1734,1736,   0,   0,\n-  1481,1482,1737,1741,1738,1742,1739,1743,1439,1440,1751,1755,1752,1756,1753,1757,\n-  1490,1491,1765,1768,1766,1769,1767,1770,1447,1448,1771,1774,1772,1775,1773,1776,\n-  1495,1496,1777,1779,1778,1780,   0,   0,1451,1452,1781,1783,1782,1784,   0,   0,\n-  1504,1505,1785,1788,1786,1789,1787,1790,   0,1459,   0,1791,   0,1792,   0,1793,\n-  1509,1510,1794,1798,1795,1799,1796,1800,1462,1463,1808,1812,1809,1813,1810,1814,\n-  1467,  21,1475,  22,1479,  23,1485,  24,1493,  27,1499,  28,1507,  29,   0,   0,\n-  1704,1708,1709,1710,1711,1712,1713,1714,1718,1722,1723,1724,1725,1726,1727,1728,\n-  1740,1744,1745,1746,1747,1748,1749,1750,1754,1758,1759,1760,1761,1762,1763,1764,\n-  1797,1801,1802,1803,1804,1805,1806,1807,1811,1815,1816,1817,1818,1819,1820,1821,\n-  1470,1469,1822,1474,1465,   0,1473,1825,1429,1428,1426,  12,1432,   0,  26,   0,\n-     0,1315,1823,1484,1466,   0,1483,1829,1433,  13,1437,  14,1441,1826,1827,1828,\n-  1488,1487,1513,  19,   0,   0,1492,1515,1445,1444,1442,  15,   0,1831,1832,1833,\n-  1502,1501,1516,  25,1497,1498,1506,1518,1457,1456,1454,  17,1453,1313,  11,   3,\n-     0,   0,1824,1512,1519,   0,1511,1830,1449,  16,1460,  18,1464,   4,   0,   0,\n-    30,  31,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,  20,   0,   0,   0,   2,   6,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1834,1835,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1836,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1837,1839,1838,\n-     0,   0,   0,   0,1840,   0,   0,   0,   0,1841,   0,   0,1842,   0,   0,   0,\n-     0,   0,   0,   0,1843,   0,1844,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,1845,   0,   0,1846,   0,   0,1847,   0,1848,   0,   0,   0,   0,   0,   0,\n-   937,   0,1850,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1849, 936, 938,\n-  1851,1852,   0,   0,1853,1854,   0,   0,1855,1856,   0,   0,   0,   0,   0,   0,\n-  1857,1858,   0,   0,1861,1862,   0,   0,1863,1864,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1867,1868,1869,1870,\n-  1859,1860,1865,1866,   0,   0,   0,   0,   0,   0,1871,1872,1873,1874,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,  32,  33,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1875,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1877,   0,1878,   0,\n-  1879,   0,1880,   0,1881,   0,1882,   0,1883,   0,1884,   0,1885,   0,1886,   0,\n-  1887,   0,1888,   0,   0,1889,   0,1890,   0,1891,   0,   0,   0,   0,   0,   0,\n-  1892,1893,   0,1894,1895,   0,1896,1897,   0,1898,1899,   0,1900,1901,   0,   0,\n-     0,   0,   0,   0,1876,   0,   0,   0,   0,   0,   0,   0,   0,   0,1902,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1904,   0,1905,   0,\n-  1906,   0,1907,   0,1908,   0,1909,   0,1910,   0,1911,   0,1912,   0,1913,   0,\n-  1914,   0,1915,   0,   0,1916,   0,1917,   0,1918,   0,   0,   0,   0,   0,   0,\n-  1919,1920,   0,1921,1922,   0,1923,1924,   0,1925,1926,   0,1927,1928,   0,   0,\n-     0,   0,   0,   0,1903,   0,   0,1929,1930,1931,1932,   0,   0,   0,1933,   0,\n-   710, 385, 724, 715, 455, 103, 186, 825, 825, 242, 751, 205, 241, 336, 524, 601,\n-   663, 676, 688, 738, 411, 434, 474, 500, 649, 746, 799, 108, 180, 416, 482, 662,\n-   810, 275, 462, 658, 692, 344, 618, 679, 293, 388, 440, 492, 740, 116, 146, 168,\n-   368, 414, 481, 527, 606, 660, 665, 722, 781, 803, 809, 538, 553, 588, 642, 758,\n-   811, 701, 233, 299, 573, 612, 487, 540, 714, 779, 232, 267, 412, 445, 457, 585,\n-   594, 766, 167, 613, 149, 148, 560, 589, 648, 768, 708, 345, 411, 704, 105, 259,\n-   313, 496, 518, 174, 542, 120, 307, 101, 430, 372, 584, 183, 228, 529, 650, 697,\n-   424, 732, 428, 349, 632, 355, 517, 110, 135, 147, 403, 580, 624, 700, 750, 170,\n-   193, 245, 297, 374, 463, 543, 763, 801, 812, 815, 162, 384, 420, 730, 287, 330,\n-   337, 366, 459, 476, 509, 558, 591, 610, 726, 652, 734, 759, 154, 163, 198, 473,\n-   683, 697, 292, 311, 353, 423, 572, 494, 113, 217, 259, 280, 314, 499, 506, 603,\n-   608, 752, 778, 782, 788, 117, 557, 748, 774, 320, 109, 126, 260, 265, 373, 411,\n-   479, 523, 655, 737, 823, 380, 765, 161, 395, 398, 438, 451, 502, 516, 537, 583,\n-   791, 136, 340, 769, 122, 273, 446, 727, 305, 322, 400, 496, 771, 155, 190, 269,\n-   377, 391, 406, 432, 501, 519, 599, 684, 687, 749, 776, 175, 452, 191, 480, 510,\n-   659, 772, 805, 813, 397, 444, 619, 566, 568, 575, 491, 471, 707, 111, 636, 156,\n-   153, 288, 346, 578, 256, 435, 383, 729, 680, 767, 694, 295, 128, 210,   0,   0,\n-   227,   0, 379,   0,   0, 150, 493, 525, 544, 551, 552, 556, 783, 576, 604,   0,\n-   661,   0, 703,   0,   0, 735, 743,   0,   0,   0, 793, 794, 795, 808, 741, 773,\n-   118, 127, 130, 166, 169, 177, 207, 213, 215, 226, 229, 268, 270, 317, 327, 329,\n-   335, 369, 375, 381, 404, 441, 448, 458, 477, 484, 503, 539, 545, 547, 546, 548,\n-   549, 550, 554, 555, 561, 564, 569, 591, 593, 595, 598, 607, 620, 625, 625, 651,\n-   690, 695, 705, 706, 716, 717, 733, 735, 777, 786, 790, 315, 869, 623,   0,   0,\n-   102, 145, 134, 115, 129, 138, 165, 171, 207, 202, 206, 212, 227, 231, 240, 243,\n-   250, 254, 294, 296, 303, 308, 319, 325, 321, 329, 326, 335, 341, 357, 360, 362,\n-   370, 379, 388, 389, 393, 421, 424, 438, 456, 454, 458, 465, 477, 535, 485, 490,\n-   493, 507, 512, 514, 521, 522, 525, 526, 528, 533, 532, 541, 565, 569, 574, 586,\n-   591, 597, 607, 637, 647, 674, 691, 693, 695, 698, 703, 699, 705, 704, 702, 706,\n-   709, 717, 728, 736, 747, 754, 770, 777, 783, 784, 786, 787, 790, 802, 825, 848,\n-   847, 857,  55,  65,  66, 883, 892, 916, 822, 824,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1586,   0,1605,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1602,1603,1934,1935,1574,1575,\n-  1576,1577,1579,1580,1581,1583,1584,   0,1585,1587,1588,1589,1591,   0,1592,   0,\n-  1593,1594,   0,1595,1596,   0,1598,1599,1600,1601,1604,1582,1578,1590,1597,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1936,   0,1937,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1938,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1939,1940,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1941,1942,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1944,1943,   0,1945,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1946,1947,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,1948,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1949,1950,\n-  1951,1952,1953,1954,1955,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1956,1957,1958,1960,1959,\n-  1961,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-   106, 104, 107, 826, 114, 118, 119, 121, 123, 124, 127, 125,  34, 830, 130, 131,\n-   132, 137, 827,  35, 133, 139, 829, 142, 143, 112, 144, 145, 924, 151, 152,  37,\n-   157, 158, 159, 160,  38, 165, 166, 169, 171, 172, 173, 174, 176, 177, 178, 179,\n-   181, 182, 182, 182, 833, 468, 184, 185, 834, 187, 188, 189, 196, 192, 194, 195,\n-   197, 199, 200, 201, 203, 204, 204, 206, 208, 209, 211, 218, 213, 219, 214, 216,\n-   153, 234, 221, 222, 223, 220, 225, 224, 230, 835, 235, 236, 237, 238, 239, 244,\n-   836, 837, 247, 248, 249, 246, 251,  39,  40, 253, 255, 255, 838, 257, 258, 259,\n-   261, 839, 262, 263, 301, 264,  41, 266, 270, 272, 271, 841, 274, 842, 277, 276,\n-   278, 281, 282,  42, 283, 284, 285, 286,  43, 843,  44, 289, 290, 291, 293, 934,\n-   298, 845, 845, 621, 300, 300,  45, 852, 894, 302, 304,  46, 306, 309, 310, 312,\n-   316,  48,  47, 317, 846, 318, 323, 324, 325, 324, 328, 329, 333, 331, 332, 334,\n-   335, 336, 338, 339, 342, 343, 347, 351, 849, 350, 348, 352, 354, 359, 850, 361,\n-   358, 356,  49, 363, 365, 367, 364,  50, 369, 371, 851, 376, 386, 378,  53, 381,\n-    52,  51, 140, 141, 387, 382, 614,  78, 388, 389, 390, 394, 392, 856,  54, 399,\n-   396, 402, 404, 858, 405, 401, 407,  55, 408, 409, 410, 413, 859, 415,  56, 417,\n-   860, 418,  57, 419, 422, 424, 425, 861, 840, 862, 426, 863, 429, 431, 427, 433,\n-   437, 441, 438, 439, 442, 443, 864, 436, 449, 450,  58, 454, 453, 865, 447, 460,\n-   866, 867, 461, 466, 465, 464,  59, 467, 470, 469, 472, 828, 475, 868, 478, 870,\n-   483, 485, 486, 871, 488, 489, 872, 873, 495, 497,  60, 498,  61,  61, 504, 505,\n-   507, 508, 511,  62, 513, 874, 515, 875, 518, 844, 520, 876, 877, 878,  63,  64,\n-   528, 880, 879, 881, 882, 530, 531, 531, 533,  66, 534,  67,  68, 884, 536, 538,\n-   541,  69, 885, 549, 886, 887, 556, 559,  70, 561, 562, 563, 888, 889, 889, 567,\n-    71, 890, 570, 571,  72, 891, 577,  73, 581, 579, 582, 893, 587,  74, 590, 592,\n-   596,  75, 895, 896,  76, 897, 600, 898, 602, 605, 607, 899, 900, 609, 901, 611,\n-   853,  77, 615, 616,  79, 617, 252, 902, 903, 854, 855, 621, 622, 731,  80, 627,\n-   626, 628, 164, 629, 630, 631, 633, 904, 632, 634, 639, 640, 635, 641, 646, 651,\n-   638, 643, 644, 645, 905, 907, 906,  81, 653, 654, 656, 911, 657, 908,  82,  83,\n-   909, 910,  84, 664, 665, 666, 667, 669, 668, 671, 670, 674, 672, 673, 675,  85,\n-   677, 678,  86, 681, 682, 912, 685, 686,  87, 689,  36, 913, 914,  88,  89, 696,\n-   702, 709, 711, 915, 712, 713, 718, 719, 917, 831, 721, 720, 723, 832, 725, 728,\n-   918, 919, 739, 742, 744, 920, 745, 753, 756, 757, 755, 760, 761, 921, 762,  90,\n-   764, 922,  91, 775, 279, 780, 923, 925,  92,  93, 785, 926,  94, 927, 787, 787,\n-   789, 928, 792,  95, 796, 797, 798, 800,  96, 929, 802, 804, 806,  97,  98, 807,\n-   930,  99, 931, 932, 933, 814, 100, 816, 817, 818, 819, 820, 821, 935,   0,   0,\n+     0,   0,   0,1956,1957,1958,1960,1959,1961,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0, 106, 104, 107, 826, 114, 118, 119, 121,\n+   123, 124, 127, 125,  34, 830, 130, 131, 132, 137, 827,  35, 133, 139, 829, 142,\n+   143, 112, 144, 145, 924, 151, 152,  37, 157, 158, 159, 160,  38, 165, 166, 169,\n+   171, 172, 173, 174, 176, 177, 178, 179, 181, 182, 182, 182, 833, 468, 184, 185,\n+   834, 187, 188, 189, 196, 192, 194, 195, 197, 199, 200, 201, 203, 204, 204, 206,\n+   208, 209, 211, 218, 213, 219, 214, 216, 153, 234, 221, 222, 223, 220, 225, 224,\n+   230, 835, 235, 236, 237, 238, 239, 244, 836, 837, 247, 248, 249, 246, 251,  39,\n+    40, 253, 255, 255, 838, 257, 258, 259, 261, 839, 262, 263, 301, 264,  41, 266,\n+   270, 272, 271, 841, 274, 842, 277, 276, 278, 281, 282,  42, 283, 284, 285, 286,\n+    43, 843,  44, 289, 290, 291, 293, 934, 298, 845, 845, 621, 300, 300,  45, 852,\n+   894, 302, 304,  46, 306, 309, 310, 312, 316,  48,  47, 317, 846, 318, 323, 324,\n+   325, 324, 328, 329, 333, 331, 332, 334, 335, 336, 338, 339, 342, 343, 347, 351,\n+   849, 350, 348, 352, 354, 359, 850, 361, 358, 356,  49, 363, 365, 367, 364,  50,\n+   369, 371, 851, 376, 386, 378,  53, 381,  52,  51, 140, 141, 387, 382, 614,  78,\n+   388, 389, 390, 394, 392, 856,  54, 399, 396, 402, 404, 858, 405, 401, 407,  55,\n+   408, 409, 410, 413, 859, 415,  56, 417, 860, 418,  57, 419, 422, 424, 425, 861,\n+   840, 862, 426, 863, 429, 431, 427, 433, 437, 441, 438, 439, 442, 443, 864, 436,\n+   449, 450,  58, 454, 453, 865, 447, 460, 866, 867, 461, 466, 465, 464,  59, 467,\n+   470, 469, 472, 828, 475, 868, 478, 870, 483, 485, 486, 871, 488, 489, 872, 873,\n+   495, 497,  60, 498,  61,  61, 504, 505, 507, 508, 511,  62, 513, 874, 515, 875,\n+   518, 844, 520, 876, 877, 878,  63,  64, 528, 880, 879, 881, 882, 530, 531, 531,\n+   533,  66, 534,  67,  68, 884, 536, 538, 541,  69, 885, 549, 886, 887, 556, 559,\n+    70, 561, 562, 563, 888, 889, 889, 567,  71, 890, 570, 571,  72, 891, 577,  73,\n+   581, 579, 582, 893, 587,  74, 590, 592, 596,  75, 895, 896,  76, 897, 600, 898,\n+   602, 605, 607, 899, 900, 609, 901, 611, 853,  77, 615, 616,  79, 617, 252, 902,\n+   903, 854, 855, 621, 622, 731,  80, 627, 626, 628, 164, 629, 630, 631, 633, 904,\n+   632, 634, 639, 640, 635, 641, 646, 651, 638, 643, 644, 645, 905, 907, 906,  81,\n+   653, 654, 656, 911, 657, 908,  82,  83, 909, 910,  84, 664, 665, 666, 667, 669,\n+   668, 671, 670, 674, 672, 673, 675,  85, 677, 678,  86, 681, 682, 912, 685, 686,\n+    87, 689,  36, 913, 914,  88,  89, 696, 702, 709, 711, 915, 712, 713, 718, 719,\n+   917, 831, 721, 720, 723, 832, 725, 728, 918, 919, 739, 742, 744, 920, 745, 753,\n+   756, 757, 755, 760, 761, 921, 762,  90, 764, 922,  91, 775, 279, 780, 923, 925,\n+    92,  93, 785, 926,  94, 927, 787, 787, 789, 928, 792,  95, 796, 797, 798, 800,\n+    96, 929, 802, 804, 806,  97,  98, 807, 930,  99, 931, 932, 933, 814, 100, 816,\n+   817, 818, 819, 820, 821, 935,   0,   0,\n@@ -5629,1 +4390,1 @@\n-_hb_ucd_i16[196] =\n+_hb_ucd_i16[92] =\n@@ -5631,13 +4392,6 @@\n-      0,    0,    0,    0,    1,   -1,    0,    0,    2,    0,   -2,    0,    0,    0,    0,    2,\n-      0,   -2,    0,    0,    0,    0,    0,   16,    0,    0,    0,  -16,    0,    0,    1,   -1,\n-      0,    0,    0,    1,   -1,    0,    0,    0,    0,    1,   -1,    0,    3,    3,    3,   -3,\n-     -3,   -3,    0,    0,    0, 2016,    0,    0,    0,    0,    0, 2527, 1923, 1914, 1918,    0,\n-   2250,    0,    0,    0,    0,    0,    0,  138,    0,    7,    0,    0,   -7,    0,    0,    0,\n-      1,   -1,    1,   -1,   -1,    1,   -1,    0, 1824,    0,    0,    0,    0,    0, 2104,    0,\n-   2108, 2106,    0, 2106, 1316,    0,    0,    0,    0,    1,   -1,    1,   -1, -138,    0,    0,\n-      1,   -1,    8,    8,    8,    0,    7,    7,    0,    0,   -8,   -8,   -8,   -7,   -7,    0,\n-      1,   -1,    0,    2,-1316,    1,   -1,    0,   -1,    1,   -1,    1,   -1,    3,    1,   -1,\n-     -3,    1,   -1,    1,   -1,    0,    0,-1914,-1918,    0,    0,-1923,-1824,    0,    0,    0,\n-      0,-2016,    0,    0,    1,   -1,    0,    1,    0,    0,-2104,    0,    0,    0,    0,-2106,\n-  -2108,-2106,    0,    0,    1,   -1,-2250,    0,    0,    0,-2527,    0,    0,   -2,    0,    1,\n-     -1,    0,    1,   -1,\n+      0,    0,    1,   -1,    2,    0,   -2,    0,    0,    2,    0,   -2,    0,   16,    0,  -16,\n+      0,    1,   -1,    0,    3,    3,    3,   -3,   -3,   -3,    0, 2016,    0, 2527, 1923, 1914,\n+   1918,    0, 2250,    0,    0,  138,    0,    7,   -7,    0,   -1,    1, 1824,    0, 2104,    0,\n+   2108, 2106,    0, 2106, 1316,    0,   -1, -138,    8,    8,    8,    0,    7,    7,   -8,   -8,\n+     -8,   -7,-1316,    1,   -1,    3,   -3,    1,    0,-1914,-1918,    0,    0,-1923,-1824,    0,\n+      0,-2016,-2104,    0,    0,-2106,-2108,-2106,-2250,    0,-2527,    0,\n@@ -5649,1 +4403,1 @@\n-  return u<1114110u?_hb_ucd_u8[6664+(((_hb_ucd_u8[1296+(((_hb_ucd_u16[((_hb_ucd_u8[544+(((_hb_ucd_u8[u>>1>>3>>3>>4])<<4)+((u>>1>>3>>3)&15u))])<<3)+((u>>1>>3)&7u)])<<3)+((u>>1)&7u))])<<1)+((u)&1u))]:2;\n+  return u<1114110u?_hb_ucd_u8[6800+(((_hb_ucd_u8[1312+(((_hb_ucd_u16[((_hb_ucd_u8[544+(((_hb_ucd_u8[u>>1>>3>>3>>4])<<4)+((u>>1>>3>>3)&15u))])<<3)+((u>>1>>3)&7u)])<<3)+((u>>1)&7u))])<<1)+((u)&1u))]:2;\n@@ -5654,1 +4408,1 @@\n-  return u<125259u?_hb_ucd_u8[8984+(((_hb_ucd_u8[7960+(((_hb_ucd_u8[7288+(((_hb_ucd_u8[7042+(u>>2>>3>>4)])<<4)+((u>>2>>3)&15u))])<<3)+((u>>2)&7u))])<<2)+((u)&3u))]:0;\n+  return u<125259u?_hb_ucd_u8[8792+(((_hb_ucd_u8[8236+(((_hb_ucd_u8[7776+(((_hb_ucd_u8[7424+(((_hb_ucd_u8[7178+(u>>2>>2>>2>>3)])<<3)+((u>>2>>2>>2)&7u))])<<2)+((u>>2>>2)&3u))])<<2)+((u>>2)&3u))])<<2)+((u)&3u))]:0;\n@@ -5664,1 +4418,1 @@\n-  return u<65380u?_hb_ucd_i16[((_hb_ucd_u8[9728+(((_hb_ucd_u8[9608+(((_hb_ucd_b4(9480+_hb_ucd_u8,u>>2>>3>>3))<<3)+((u>>2>>3)&7u))])<<3)+((u>>2)&7u))])<<2)+((u)&3u)]:0;\n+  return u<65380u?_hb_ucd_i16[((_hb_ucd_u8[9684+(((_hb_ucd_u8[9452+(((_hb_ucd_u8[9356+(((_hb_ucd_b4(9292+_hb_ucd_u8,u>>1>>2>>3>>3))<<3)+((u>>1>>2>>3)&7u))])<<3)+((u>>1>>2)&7u))])<<2)+((u>>1)&3u))])<<1)+((u)&1u)]:0;\n@@ -5669,1 +4423,1 @@\n-  return u<918000u?_hb_ucd_u8[11234+(((_hb_ucd_u16[2000+(((_hb_ucd_u8[10514+(((_hb_ucd_u8[10064+(u>>3>>4>>4)])<<4)+((u>>3>>4)&15u))])<<4)+((u>>3)&15u))])<<3)+((u)&7u))]:2;\n+  return u<918000u?_hb_ucd_u8[11118+(((_hb_ucd_u16[4024+(((_hb_ucd_u16[2040+(((_hb_ucd_u8[10382+(((_hb_ucd_u8[9932+(u>>2>>2>>3>>4)])<<4)+((u>>2>>2>>3)&15u))])<<3)+((u>>2>>2)&7u))])<<2)+((u>>2)&3u))])<<2)+((u)&3u))]:2;\n@@ -5674,1 +4428,1 @@\n-  return u<195102u?_hb_ucd_u16[5888+(((_hb_ucd_u8[17136+(((_hb_ucd_u8[16754+(u>>4>>5)])<<5)+((u>>4)&31u))])<<4)+((u)&15u))]:0;\n+  return u<195102u?_hb_ucd_u16[6728+(((_hb_ucd_u8[13944+(((_hb_ucd_u8[13562+(u>>4>>5)])<<5)+((u>>4)&31u))])<<4)+((u)&15u))]:0;\n@@ -5681,1 +4435,1 @@\n-_hb_ucd_u8[13602] =\n+_hb_ucd_u8[13370] =\n@@ -5689,1 +4443,1 @@\n-    7,  7, 37, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+    7,  7,  7,  7, 35, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n@@ -5711,1 +4465,1 @@\n-   38, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   37, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n@@ -5734,4 +4488,4 @@\n-  147,148,149,150,151,152,111,111,153,154,155,156,111,157,111,158,\n-   34, 34, 34, 34, 34, 34, 34, 34,159, 34, 34,111,111,111,111,111,\n-  111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,160,\n-   34, 34, 34, 34, 34, 34, 34, 34,161,111,111,111,111,111,111,111,\n+  147,148,149,150,151,152,153,111,154,155,156,157,111,158,159,160,\n+   34, 34, 34, 34, 34, 34, 34, 34,161, 34, 34,111,111,111,111,111,\n+  111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,162,\n+   34, 34, 34, 34, 34, 34, 34, 34,163,111,111,111,111,111,111,111,\n@@ -5740,1 +4494,1 @@\n-   34, 34, 34, 34,162,163,164, 34,111,111,111,111,165,166,167,168,\n+   34, 34, 34, 34,164,165,166, 34,111,111,111,111,167,168,169,170,\n@@ -5744,8 +4498,8 @@\n-  111,111,111,111,111,111,111,111, 34,169,111,111,111,111,111,111,\n-  111,111,111,111,111,111,111,111,111,111,111,111,111,111,170, 67,\n-   67, 67,171,172,173,130, 65,111,174,175,176,177,178,179,180,181,\n-   67, 67, 67, 67,182,183,111,111,111,111,111,111,111,111,184,111,\n-  185,111,186,111,111,187,111,111,111,111,111,111,111,111,111, 34,\n-   34,188,189,111,111,111,111,111,130,190,191,111, 34,192,111,111,\n-   67, 67,193, 67, 67,111, 67,194, 67, 67, 67, 67, 67, 67, 67, 67,\n-   67, 67, 67, 67, 67, 67, 67,195,111,111,111,111,111,111,111,111,\n+  111,111,111,111,111,111,111,111, 34,171,111,111,111,111,111,111,\n+  111,111,111,111,111,111,111,111,111,111,111,111,111,111,172, 67,\n+   67, 67,173,174,175,130, 65,111,176,177,178,179,180,181,182,183,\n+   67, 67, 67, 67,184,185,111,111,111,111,111,111,111,111,186,111,\n+  187,188,189,111,111,190,111,111,111,191,111,111,111,111,111, 34,\n+   34,192,193,111,111,111,111,111,130,194,195,111, 34,196,111,111,\n+   67, 67,197, 67, 67,111, 67,198, 67, 67, 67, 67, 67, 67, 67, 67,\n+   67, 67, 67, 67, 67, 67, 67,199,111,111,111,111,111,111,111,111,\n@@ -5754,2 +4508,1 @@\n-   34, 34, 34, 34, 34, 34, 34,111,111,111,111,111,111,111,111,111,\n-  196,111,185,185,111,111,111,111,111,111,111,111,111,111,111,111,\n+  200,111,188,188,111,111,111,111,111,111,111,111,111,111,111,111,\n@@ -5811,1 +4564,1 @@\n-   43, 43, 77, 78, 78, 78, 81, 36, 86, 36, 36, 36, 36, 36, 36, 36,\n+   43, 43, 77, 78, 78, 78, 81, 36, 86, 82, 78, 78, 78, 78, 78, 78,\n@@ -5951,1 +4704,1 @@\n-   43, 78, 77, 43,  2,  2,  2, 43, 36, 36, 36, 36, 36, 36, 36, 64,\n+   43, 78, 77, 43,  2,  2,  2, 65, 36, 36, 36, 36, 36, 36, 36, 64,\n@@ -5972,2 +4725,4 @@\n-   27, 27, 84, 61, 61, 61, 53, 20,150, 61, 61, 61, 61, 61, 61, 61,\n-   61, 61, 61, 61, 61, 61, 61, 21, 43, 43, 57,  2,  2,  2,  2,  2,\n+   43, 82, 36, 36, 36, 36, 36, 36, 36, 36, 78, 43, 43, 43, 43, 78,\n+   77, 57,  2,  2,  2,  2,  2,  2, 27, 27, 84, 61, 61, 61, 53, 20,\n+  150, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 21,\n+   65, 36, 36, 64, 43, 43, 43, 43, 43, 43, 57,  2,  2,  2,  2,  2,\n@@ -5996,119 +4751,122 @@\n-   16, 16, 43, 43, 43, 68, 40, 40, 27, 27, 27, 27, 27, 27,145, 27,\n-  171, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,145,\n-   27, 27, 27, 27, 27, 27, 84, 61, 61, 61, 61, 61, 61, 25, 41, 41,\n-    0,  0, 29, 21, 21, 21, 23, 21, 22, 18, 21, 25, 21, 17, 13, 13,\n-   25, 25, 25, 21, 21,  9,  9,  9,  9, 22, 21, 18, 24, 16, 24,  5,\n-    5,  5,  5, 22, 25, 18, 25,  0, 23, 23, 26, 21, 24, 26,  7, 20,\n-   25,  1, 26, 24, 26, 25, 15, 15, 24, 15,  7, 19, 15, 21,  9, 25,\n-    9,  5,  5, 25,  5,  9,  5,  7,  7,  7,  9,  8,  8,  5,  7,  5,\n-    6,  6, 24, 24,  6, 24, 12, 12,  6,  5,  9, 21, 25,  9, 26, 12,\n-   11, 11,  9,  6,  5, 21, 17, 17, 17, 26, 26, 23, 23, 12, 17, 12,\n-   21, 12, 12, 21,  7, 21,  1,  1, 21, 23, 26, 26,  1, 21,  6,  7,\n-    7, 12, 12,  7, 21,  7, 12,  1, 12,  6,  6, 12, 12, 26,  7, 26,\n-   26,  7, 21,  1, 24,  7,  7,  6,  1, 12, 12, 10, 10, 10, 10, 12,\n-   21,  6, 10,  7,  7, 10, 23,  7, 15, 26, 13, 21, 13,  7, 15,  7,\n-   12, 23, 21, 26, 21, 15, 17,  7, 29,  7,  7, 22, 18, 18, 14, 14,\n-   14,  7, 10, 21, 17, 21, 11, 12,  5,  6,  8,  8,  8, 24,  5, 24,\n-    9, 24, 29, 29, 29,  1, 20, 19, 22, 20, 27, 28,  1, 29, 21, 20,\n-   19, 21, 21, 16, 16, 21, 25, 22, 18, 21, 21, 29, 15,  6, 18,  6,\n-   12, 11,  9, 26, 26,  9, 26,  5,  5, 26, 14,  9,  5, 14, 14, 15,\n-   25, 26, 26, 22, 18, 26, 18, 25, 18, 22,  5, 12, 22, 21, 21, 22,\n-   18, 17, 26,  6,  7, 14, 17, 22, 26, 14, 17,  6, 14,  6, 12, 24,\n-   24,  6, 26, 15,  6, 21, 11, 21, 24,  9,  6,  9, 23, 26,  6, 10,\n-    4,  4,  3,  3,  7, 25, 17, 16, 16, 22, 16, 16, 25, 17,  7,  1,\n-   25, 24, 26,  1,  2,  2, 12, 15, 21, 14,  7, 15, 12, 17, 13, 15,\n-   26, 10, 10,  1, 13, 23, 23, 15,  0,  1,  2,  3,  4,  5,  6,  7,\n-    8,  9,  0, 10, 11, 12, 13,  0, 14,  0,  0,  0,  0,  0, 15,  0,\n-   16,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 17, 18, 19,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0, 20,  0, 21, 22, 23,  0,  0,  0, 24, 25, 26,\n-   27, 28, 29, 30, 31, 32, 33,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 34,  0, 35,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 36,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-   37, 38,  0,  0,  0,  0,  0,  0, 39, 40,  0,  0, 41,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  0,  0,  0,  0,\n-    3,  0,  0,  0,  4,  5,  6,  7,  0,  8,  9, 10,  0, 11, 12, 13,\n-   14, 15, 16, 17, 16, 18, 16, 19, 16, 19, 16, 19,  0, 19, 16, 20,\n-   16, 19, 21, 19,  0, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,  0,\n-   32,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 33,  0,  0,  0,  0,\n-    0,  0, 34,  0,  0, 35,  0,  0, 36,  0, 37,  0,  0,  0, 38, 39,\n-   40, 41, 42, 43, 44, 45, 46,  0,  0, 47,  0,  0,  0, 48,  0,  0,\n-    0, 49,  0,  0,  0,  0,  0,  0,  0, 50,  0, 51,  0, 52, 53,  0,\n-   54,  0,  0,  0,  0,  0,  0, 55, 56, 57,  0,  0,  0,  0, 58,  0,\n-    0, 59, 60, 61, 62, 63,  0,  0, 64, 65,  0,  0,  0, 66,  0,  0,\n-    0,  0, 67,  0,  0,  0, 68,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0, 69,  0,  0,  0, 70,  0, 71,  0,  0, 72,  0,\n-    0, 73,  0,  0,  0,  0,  0,  0,  0,  0, 74,  0,  0,  0,  0,  0,\n-   75,  0,  0, 76, 77,  0,  0, 78, 79,  0, 80, 62,  0, 81, 82,  0,\n-    0, 83, 84, 85,  0,  0,  0, 86,  0, 87,  0,  0, 51, 88, 51,  0,\n-   89,  0, 90,  0,  0,  0, 79,  0,  0,  0, 91, 92,  0, 93, 94, 95,\n-   96,  0,  0,  0,  0,  0, 51,  0,  0,  0,  0, 97, 98,  0,  0,  0,\n-    0, 99,100,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,101,  0,  0,\n-  102,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,103,104,  0,  0,105,\n-    0,  0,  0,  0,  0,  0,106,  0,  0,  0,100,  0,  0,  0,  0,  0,\n-  107,108,  0,  0,  0,  0,  0,  0,  0,109,  0,110,  0,  0,  0,  0,\n-    0,  0,  1,  2,  3,  4,  5,  6,  7,  0,  8,  0,  0,  0,  0,  9,\n-   10, 11, 12,  0,  0,  0,  0, 13,  0,  0, 14, 15,  0, 16,  0, 17,\n-   18,  0,  0, 19,  0, 20, 21,  0,  0,  0,  0,  0, 22, 23,  0, 24,\n-   25,  0,  0, 26,  0,  0,  0, 27,  0,  0, 28, 29, 30, 31,  0,  0,\n-    0, 32, 33, 34,  0,  0, 33,  0,  0, 35, 33,  0,  0,  0, 33, 36,\n-    0,  0,  0,  0,  0, 37, 38,  0,  0,  0,  0,  0,  0, 39, 40,  0,\n-    0,  0,  0,  0,  0, 41, 42,  0,  0,  0,  0, 43,  0, 44,  0,  0,\n-    0, 45, 46,  0,  0,  0, 47,  0,  0,  0,  0,  0,  0, 48, 49,  0,\n-    0,  0,  0, 50,  0,  0,  0, 51,  0, 52,  0, 53,  0,  0,  0,  0,\n-   54,  0,  0,  0,  0, 55,  0, 56,  0,  0,  0,  0, 57, 58,  0,  0,\n-    0, 59, 60,  0,  0,  0,  0,  0,  0, 61, 52,  0, 62, 63,  0,  0,\n-   64,  0,  0,  0, 65, 66,  0,  0,  0, 67,  0, 68, 69, 70, 71, 72,\n-    1, 73,  0, 74, 75, 76,  0,  0, 77, 78,  0,  0,  0, 79,  0,  0,\n-    1,  1,  0,  0, 80,  0,  0, 81,  0,  0,  0,  0, 77, 82,  0, 83,\n-    0,  0,  0,  0,  0, 78, 84,  0, 85,  0, 52,  0,  1, 78,  0,  0,\n-   86,  0,  0, 87,  0,  0,  0,  0,  0, 88, 57,  0,  0,  0,  0,  0,\n-    0, 89, 90,  0,  0, 84,  0,  0, 33,  0,  0, 91,  0,  0,  0,  0,\n-   92,  0,  0,  0,  0, 49,  0,  0, 93,  0,  0,  0,  0, 94, 95,  0,\n-    0, 96,  0,  0, 97,  0,  0,  0, 98,  0,  0,  0, 99,  0,100, 93,\n-    0,  0,101,  0,  0,  0, 84,  0,  0,102,  0,  0,  0,103,104,  0,\n-    0,105,106,  0,  0,  0,  0,  0,  0,107,  0,  0,108,  0,  0,  0,\n-    0,109, 33,  0,110,111,112, 35,  0,  0,113,  0,  0,  0,114,  0,\n-    0,  0,  0,  0,  0,115,  0,  0,116,  0,  0,  0,  0,117, 88,  0,\n-    0,  0,  0,  0, 57,  0,  0,  0,  0, 52,118,  0,  0,  0,  0,119,\n-    0,  0,120,  0,  0,  0,  0,118,  0,  0,  0,  0,  0,121,  0,  0,\n-    0,122,  0,  0,  0,123,  0,124,  0,  0,  0,  0,125,126,127,  0,\n-  128,  0,129,  0,  0,  0,130,131,132,  0,  0,  0, 35,  0,  0,  0,\n-  133,  0,  0,134,  0,  0,135,  0,  0,  0,  0,  0,  0,  0,  1,  1,\n-    1,  1,  1,  2,  3,  4,  5,  6,  7,  4,  4,  8,  9, 10,  1, 11,\n-   12, 13, 14, 15, 16, 17, 18,  1,  1,  1, 19,  1,  0,  0, 20, 21,\n-   22,  1, 23,  4, 21, 24, 25, 26, 27, 28, 29, 30,  0,  0,  1,  1,\n-   31,  0,  0,  0, 32, 33, 34, 35,  1, 36, 37,  0,  0,  0,  0, 38,\n-    1, 39, 14, 39, 40, 41, 42,  0,  0,  0, 43, 36, 44, 45, 21, 45,\n-   46,  0,  0,  0, 19,  1, 21,  0,  0, 47,  0, 38, 48,  1,  1, 49,\n-   49, 50,  0,  0, 51,  0,  0,  0, 52,  1,  0,  0, 38, 14,  4,  1,\n-    1,  1, 53, 21, 43, 52, 54, 21, 35,  1,  0,  0,  0, 55,  0,  0,\n-    0, 56, 57, 58,  0,  0,  0,  0,  0, 59,  0, 60,  0,  0,  0,  0,\n-   61, 62,  0,  0, 63,  0,  0,  0, 64,  0,  0,  0, 65,  0,  0,  0,\n-   66,  0,  0,  0, 67,  0,  0,  0, 68,  0,  0, 69, 70,  0, 71, 72,\n-   73, 74, 75, 76,  0,  0,  0, 77,  0,  0,  0, 78, 79,  0,  0,  0,\n-    0, 47,  0,  0,  0, 49,  0, 80,  0,  0,  0, 62,  0,  0, 63,  0,\n-    0, 81,  0,  0, 82,  0,  0,  0, 83,  0,  0, 19, 84,  0, 62,  0,\n-    0,  0,  0, 49,  1, 85,  1, 52, 15, 86, 36, 10, 21, 87,  0, 55,\n-    0,  0,  0,  0, 19, 10,  1,  0,  0,  0,  0,  0, 88,  0,  0, 89,\n-    0,  0, 88,  0,  0,  0,  0, 78,  0,  0, 87,  9, 12,  4, 90,  8,\n-   91, 47,  0, 58, 50,  0, 21,  1, 21, 92, 93,  1,  1,  1,  1, 94,\n-   95, 96, 97,  1, 98, 58, 81, 99,100,  4, 58,  0,  0,  0,  0,  0,\n-    0, 19, 50,  0,  0,  0,  0,  0,  0, 61,  0,  0,101,102,  0,  0,\n-  103,  0,  0,  1,  1, 50,  0,  0,  0, 38,  0, 63,  0,  0,  0,  0,\n-    0, 62,  0,  0,104, 68, 61,  0,  0,  0, 78,  0,  0,  0,105,106,\n-   58, 38, 81,  0,  0,  0,  0,  0,  0,107,  1, 14,  4, 12, 84,  0,\n-    0,  0,  0, 38, 87,  0,  0,  0,  0,108,  0,  0,109, 61,  0,110,\n-    0,  0,  0,  1,  0,  0,  0,  0, 19, 58,  0,111, 14, 52,112, 41,\n-    0,  0, 62,  0,  0, 61,  0,  0,113,  0, 87,  0,  0,  0, 61, 62,\n-    0,  0, 62,  0, 89,  0,  0,113,  0,  0,  0,  0,114,  0,  0,  0,\n-   78, 55,  0, 38,  1, 58,  1, 58,  0,  0, 63, 89,  0,  0,115,  0,\n-    0,  0, 55,  0,  0,  0,  0,115,  0,  0,  0,  0, 61,  0,  0,  0,\n-    0, 79,  0, 61,  0,  0,  0,  0, 56,  0, 89, 80,  0,  0,  8, 91,\n+   36, 36, 36, 36, 36, 75, 43, 43, 16, 16, 43, 43, 43, 68, 40, 40,\n+   27, 27, 27, 27, 27, 27,145, 27,171, 27, 27, 27, 27, 27, 27, 27,\n+   27, 27, 27, 27, 27, 27, 27,145, 27, 27, 27, 27, 27, 27, 84, 61,\n+   61, 61, 61, 61, 61, 25, 41, 41,  0,  0, 29, 21, 21, 21, 23, 21,\n+   22, 18, 21, 25, 21, 17, 13, 13, 25, 25, 25, 21, 21,  9,  9,  9,\n+    9, 22, 21, 18, 24, 16, 24,  5,  5,  5,  5, 22, 25, 18, 25,  0,\n+   23, 23, 26, 21, 24, 26,  7, 20, 25,  1, 26, 24, 26, 25, 15, 15,\n+   24, 15,  7, 19, 15, 21,  9, 25,  9,  5,  5, 25,  5,  9,  5,  7,\n+    7,  7,  9,  8,  8,  5,  7,  5,  6,  6, 24, 24,  6, 24, 12, 12,\n+    6,  5,  9, 21, 25,  9, 26, 12, 11, 11,  9,  6,  5, 21, 17, 17,\n+   17, 26, 26, 23, 23, 12, 17, 12, 21, 12, 12, 21,  7, 21,  1,  1,\n+   21, 23, 26, 26,  1, 21,  6,  7,  7, 12, 12,  7, 21,  7, 12,  1,\n+   12,  6,  6, 12, 12, 26,  7, 26, 26,  7, 21,  1, 24,  7,  7,  6,\n+    1, 12, 12, 10, 10, 10, 10, 12, 21,  6, 10,  7,  7, 10, 23,  7,\n+   15, 26, 13, 21, 13,  7, 15,  7, 12, 23, 21, 26, 21, 15, 17,  7,\n+   29,  7,  7, 22, 18, 18, 14, 14, 14,  7, 10, 21, 17, 21, 11, 12,\n+    5,  6,  8,  8,  8, 24,  5, 24,  9, 24, 29, 29, 29,  1, 20, 19,\n+   22, 20, 27, 28,  1, 29, 21, 20, 19, 21, 21, 16, 16, 21, 25, 22,\n+   18, 21, 21, 29, 15,  6, 18,  6, 12, 11,  9, 26, 26,  9, 26,  5,\n+    5, 26, 14,  9,  5, 14, 14, 15, 25, 26, 26, 22, 18, 26, 18, 25,\n+   18, 22,  5, 12, 22, 21, 21, 22, 18, 17, 26,  6,  7, 14, 17, 22,\n+   26, 14, 17,  6, 14,  6, 12, 24, 24,  6, 26, 15,  6, 21, 11, 21,\n+   24,  9,  6,  9, 23, 26,  6, 10,  4,  4,  3,  3,  7, 25, 17, 16,\n+   16, 22, 16, 16, 25, 17,  7,  1, 25, 24, 26,  1,  2,  2, 12, 15,\n+   21, 14,  7, 15, 12, 17, 13, 15, 26, 10, 10,  1, 13, 23, 23, 15,\n+    0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  0, 10, 11, 12, 13,  0,\n+   14,  0,  0,  0,  0,  0, 15,  0, 16,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0, 17, 18, 19,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 20,  0, 21,\n+   22, 23,  0,  0,  0, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0, 35,  0, 36,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 37,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0, 38, 39,  0,  0,  0,  0,  0,  0,\n+   40, 41, 42,  0, 43,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  1,  2,  0,  0,  0,  0,  3,  0,  0,  0,  4,  5,  6,  7,\n+    0,  8,  9, 10,  0, 11, 12, 13, 14, 15, 16, 17, 16, 18, 16, 19,\n+   16, 19, 16, 19,  0, 19, 16, 20, 16, 19, 21, 19,  0, 22, 23, 24,\n+   25, 26, 27, 28, 29, 30, 31,  0, 32,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0, 33,  0,  0,  0,  0,  0,  0, 34,  0,  0, 35,  0,  0,\n+   36,  0, 37,  0,  0,  0, 38, 39, 40, 41, 42, 43, 44, 45, 46,  0,\n+    0, 47,  0,  0,  0, 48,  0,  0,  0, 49,  0,  0,  0,  0,  0,  0,\n+    0, 50,  0, 51,  0, 52, 53,  0, 54,  0,  0,  0,  0,  0,  0, 55,\n+   56, 57,  0,  0,  0,  0, 58,  0,  0, 59, 60, 61, 62, 63,  0,  0,\n+   64, 65,  0,  0,  0, 66,  0,  0,  0,  0, 67,  0,  0,  0, 68,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 69,  0,  0,\n+    0, 70,  0, 71,  0,  0, 72,  0,  0, 73,  0,  0,  0,  0,  0,  0,\n+    0,  0, 74,  0,  0,  0,  0,  0, 75, 76,  0, 77, 78,  0,  0, 79,\n+   80,  0, 81, 62,  0, 82, 83,  0,  0, 84, 85, 86,  0,  0,  0, 87,\n+    0, 88,  0,  0, 51, 89, 51,  0, 90,  0, 91,  0,  0,  0, 80,  0,\n+    0,  0, 92, 93,  0, 94, 95, 96, 97,  0,  0,  0,  0,  0, 51,  0,\n+    0,  0,  0, 98, 99,  0,  0,  0,  0,  0,  0,100,  0,  0,  0,  0,\n+    0,101,102,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,103,  0,  0,\n+  104,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,105,106,  0,  0,107,\n+    0,  0,  0,  0,  0,  0,108,  0,109,  0,102,  0,  0,  0,  0,  0,\n+  110,111,  0,  0,  0,  0,  0,  0,  0,112,  0,  0,  0,  0,  0,  0,\n+    0,113,  0,114,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,  5,  6,\n+    7,  0,  8,  0,  0,  0,  0,  9, 10, 11, 12,  0,  0,  0,  0, 13,\n+    0,  0, 14, 15,  0, 16,  0, 17, 18,  0,  0, 19,  0, 20, 21,  0,\n+    0,  0,  0,  0, 22, 23,  0, 24, 25,  0,  0, 26,  0,  0,  0, 27,\n+    0,  0, 28, 29, 30, 31,  0,  0,  0, 32, 33, 34,  0,  0, 33,  0,\n+    0, 35, 33,  0,  0,  0, 33, 36,  0,  0,  0,  0,  0, 37, 38,  0,\n+    0,  0,  0,  0,  0, 39, 40,  0,  0,  0,  0,  0,  0, 41, 42,  0,\n+    0,  0,  0, 43,  0, 44,  0,  0,  0, 45, 46,  0,  0,  0, 47,  0,\n+    0,  0,  0,  0,  0, 48, 49,  0,  0,  0,  0, 50,  0,  0,  0, 51,\n+    0, 52,  0, 53,  0,  0,  0,  0, 54,  0,  0,  0,  0, 55,  0, 56,\n+    0,  0,  0,  0, 57, 58,  0,  0,  0, 59, 60,  0,  0,  0,  0,  0,\n+    0, 61, 52,  0, 62, 63,  0,  0, 64,  0,  0,  0, 65, 66,  0,  0,\n+    0, 67,  0, 68, 69, 70, 71, 72,  1, 73,  0, 74, 75, 76,  0,  0,\n+   77, 78,  0,  0,  0, 79,  0,  0,  1,  1,  0,  0, 80,  0,  0, 81,\n+    0,  0,  0,  0, 77, 82,  0, 83,  0,  0,  0,  0,  0, 78, 84,  0,\n+   85,  0, 52,  0,  1, 78,  0,  0, 86,  0,  0, 87,  0,  0,  0,  0,\n+    0, 88, 57,  0,  0,  0,  0,  0,  0, 89, 90,  0,  0, 84,  0,  0,\n+   33,  0,  0, 91,  0,  0,  0,  0, 92,  0,  0,  0,  0, 49,  0,  0,\n+   93,  0,  0,  0,  0, 94, 95,  0,  0, 96,  0,  0, 97,  0,  0,  0,\n+   98,  0,  0,  0, 99,  0,  0,  0,  0,100,101, 93,  0,  0,102,  0,\n+    0,  0, 84,  0,  0,103,  0,  0,  0,104,105,  0,  0,106,107,  0,\n+    0,  0,  0,  0,  0,108,  0,  0,109,  0,  0,  0,  0,110, 33,  0,\n+  111,112,113, 35,  0,  0,114,  0,  0,  0,115,  0,  0,  0,  0,  0,\n+    0,116,  0,  0,117,  0,  0,  0,  0,118, 88,  0,  0,  0,  0,  0,\n+   57,  0,  0,  0,  0, 52,119,  0,  0,  0,  0,120,  0,  0,121,  0,\n+    0,  0,  0,119,  0,  0,122,  0,  0,  0,  0,  0,  0,123,  0,  0,\n+    0,124,  0,  0,  0,125,  0,126,  0,  0,  0,  0,127,128,129,  0,\n+  130,  0,131,  0,  0,  0,132,133,134,  0, 77,  0,  0,  0,  0,  0,\n+   35,  0,  0,  0,135,  0,  0,  0,136,  0,  0,137,  0,  0,138,  0,\n+    0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  2,  3,  4,  5,  6,\n+    7,  4,  4,  8,  9, 10,  1, 11, 12, 13, 14, 15, 16, 17, 18,  1,\n+    1,  1, 19,  1,  0,  0, 20, 21, 22,  1, 23,  4, 21, 24, 25, 26,\n+   27, 28, 29, 30,  0,  0,  1,  1, 31,  0,  0,  0, 32, 33, 34, 35,\n+    1, 36, 37,  0,  0,  0,  0, 38,  1, 39, 14, 39, 40, 41, 42,  0,\n+    0,  0, 43, 36, 44, 45, 21, 45, 46,  0,  0,  0, 19,  1, 21,  0,\n+    0, 47,  0, 38, 48,  1,  1, 49, 49, 50,  0,  0, 51,  0,  0,  0,\n+   52,  1,  0,  0, 38, 14,  4,  1,  1,  1, 53, 21, 43, 52, 54, 21,\n+   35,  1,  0,  0,  0, 55,  0,  0,  0, 56, 57, 58,  0,  0,  0,  0,\n+    0, 59,  0, 60,  0,  0,  0,  0, 61, 62,  0,  0, 63,  0,  0,  0,\n+   64,  0,  0,  0, 65,  0,  0,  0, 66,  0,  0,  0, 67,  0,  0,  0,\n+   68,  0,  0, 69, 70,  0, 71, 72, 73, 74, 75, 76,  0,  0,  0, 77,\n+    0,  0,  0, 78, 79,  0,  0,  0,  0, 47,  0,  0,  0, 49,  0, 80,\n+    0,  0,  0, 62,  0,  0, 63,  0,  0, 81,  0,  0, 82,  0,  0,  0,\n+   83,  0,  0, 19, 84,  0, 62,  0,  0,  0,  0, 49,  1, 85,  1, 52,\n+   15, 86, 36, 10, 21, 87,  0, 55,  0,  0,  0,  0, 19, 10,  1,  0,\n+    0,  0,  0,  0, 88,  0,  0, 89,  0,  0, 88,  0,  0,  0,  0, 78,\n+    0,  0, 87,  9, 12,  4, 90,  8, 91, 47,  0, 58, 50,  0, 21,  1,\n+   21, 92, 93,  1,  1,  1,  1, 94, 95, 96, 97,  1, 98, 58, 81, 99,\n+  100,  4, 58,  0,  0,  0,  0,  0,  0, 19, 50,  0,  0,  0,  0,  0,\n+    0, 61,  0,  0,101,102,  0,  0,103,  0,  0,  1,  1, 50,  0,  0,\n+    0, 38,  0, 63,  0,  0,  0,  0,  0, 62,  0,  0,104, 68, 61,  0,\n+    0,  0, 78,  0,  0,  0,105,106, 58, 38, 81,  0,  0,  0,  0,  0,\n+    0,107,  1, 14,  4, 12, 84,  0,  0,  0,  0, 38, 87,  0,  0,  0,\n+    0,108,  0,  0,109, 61,  0,110,  0,  0,  0,  1,  0,  0,  0,  0,\n+   19, 58,  0,  0,  0, 51,  0,111, 14, 52,112, 41,  0,  0, 62,  0,\n+    0, 61,  0,  0,113,  0, 87,  0,  0,  0, 61, 62,  0,  0, 62,  0,\n+   89,  0,  0,113,  0,  0,  0,  0,114,  0,  0,  0, 78, 55,  0, 38,\n+    1, 58,  1, 58,  0,  0, 63, 89,  0,  0,115,  0,  0,  0, 55,  0,\n+    0,  0,  0,115,  0,  0,  0,  0, 61,  0,  0,  0,  0, 79,  0, 61,\n+    0,  0,  0,  0, 56,  0, 89, 80,  0,  0, 79,  0,  0,  0,  8, 91,\n@@ -6118,34 +4876,33 @@\n-    0,  1,  4,122,  0,  0,  0,  1,123,  0,  0,  0,  0,  0,230,230,\n-  230,230,230,232,220,220,220,220,232,216,220,220,220,220,220,202,\n-  202,220,220,220,220,202,202,220,220,220,  1,  1,  1,  1,  1,220,\n-  220,220,220,230,230,230,230,240,230,220,220,220,230,230,230,220,\n-  220,  0,230,230,230,220,220,220,220,230,232,220,220,230,233,234,\n-  234,233,234,234,233,230,  0,  0,  0,230,  0,220,230,230,230,230,\n-  220,230,230,230,222,220,230,230,220,220,230,222,228,230, 10, 11,\n-   12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22,  0, 23,  0, 24,\n-   25,  0,230,220,  0, 18, 30, 31, 32,  0,  0,  0,  0, 27, 28, 29,\n-   30, 31, 32, 33, 34,230,230,220,220,230,220,230,230,220, 35,  0,\n-    0,  0,  0,  0,230,230,230,  0,  0,230,230,  0,220,230,230,220,\n-    0,  0,  0, 36,  0,  0,230,220,230,230,220,220,230,220,220,230,\n-  220,230,220,230,230,  0,  0,220,  0,  0,230,230,  0,230,  0,230,\n-  230,230,230,230,  0,  0,  0,220,220,220,230,220,220,220,230,230,\n-    0,220, 27, 28, 29,230,  7,  0,  0,  0,  0,  9,  0,  0,  0,230,\n-  220,230,230,  0,  0,  0,  0,  0,230,  0,  0, 84, 91,  0,  0,  0,\n-    0,  9,  9,  0,  0,  0,  0,  0,  9,  0,103,103,  9,  0,107,107,\n-  107,107,118,118,  9,  0,122,122,122,122,220,220,  0,  0,  0,220,\n-    0,220,  0,216,  0,  0,  0,129,130,  0,132,  0,  0,  0,  0,  0,\n-  130,130,130,130,  0,  0,130,  0,230,230,  9,  0,230,230,  0,  0,\n-  220,  0,  0,  0,  0,  7,  0,  9,  9,  0,  9,  9,  0,  0,  0,230,\n-    0,  0,  0,228,  0,  0,  0,222,230,220,220,  0,  0,  0,230,  0,\n-    0,220,230,220,  0,220,230,230,230,  0,  0,  0,  9,  9,  0,  0,\n-    7,  0,230,  0,  1,  1,  1,  0,  0,  0,230,234,214,220,202,230,\n-  230,230,230,230,232,228,228,220,218,230,233,220,230,220,230,230,\n-    1,  1,  1,  1,  1,230,  0,  1,  1,230,220,230,  1,  1,  0,  0,\n-  218,228,232,222,224,224,  0,  8,  8,  0,  0,  0,  0,220,230,  0,\n-  230,230,220,  0,  0,230,  0,  0, 26,  0,  0,220,  0,230,230,  1,\n-  220,  0,  0,230,220,  0,  0,  0,220,220,  0,  0,230,220,  0,  9,\n-    7,  0,  0,  7,  9,  0,  0,  0,  9,  7,  6,  6,  0,  0,  0,  0,\n-    1,  0,  0,216,216,  1,  1,  1,  0,  0,  0,226,216,216,216,216,\n-  216,  0,220,220,220,  0,230,230,  7,  0, 16, 17, 17, 17, 17, 17,\n-   17, 33, 17, 17, 17, 19, 17, 17, 17, 17, 20,101, 17,113,129,169,\n-   17, 27, 28, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+    0,  1,  0,  0,  0,123,  4,122,  0,  0,  0,  1,124,  0,  0,  0,\n+    0,  0,230,230,230,230,230,232,220,220,220,220,232,216,220,220,\n+  220,220,220,202,202,220,220,220,220,202,202,220,220,220,  1,  1,\n+    1,  1,  1,220,220,220,220,230,230,230,230,240,230,220,220,220,\n+  230,230,230,220,220,  0,230,230,230,220,220,220,220,230,232,220,\n+  220,230,233,234,234,233,234,234,233,230,  0,  0,  0,230,  0,220,\n+  230,230,230,230,220,230,230,230,222,220,230,230,220,220,230,222,\n+  228,230, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22,\n+    0, 23,  0, 24, 25,  0,230,220,  0, 18, 30, 31, 32,  0,  0,  0,\n+    0, 27, 28, 29, 30, 31, 32, 33, 34,230,230,220,220,230,220,230,\n+  230,220, 35,  0,  0,  0,  0,  0,230,230,230,  0,  0,230,230,  0,\n+  220,230,230,220,  0,  0,  0, 36,  0,  0,230,220,230,230,220,220,\n+  230,220,220,230,220,230,220,230,230,  0,  0,220,  0,  0,230,230,\n+    0,230,  0,230,230,230,230,230,  0,  0,  0,220,220,220,230,220,\n+  220,220,230,230,  0,220, 27, 28, 29,230,  7,  0,  0,  0,  0,  9,\n+    0,  0,  0,230,220,230,230,  0,  0,  0,  0,  0,230,  0,  0, 84,\n+   91,  0,  0,  0,  0,  9,  9,  0,  0,  0,  0,  0,  9,  0,103,103,\n+    9,  0,107,107,107,107,118,118,  9,  0,122,122,122,122,220,220,\n+    0,  0,  0,220,  0,220,  0,216,  0,  0,  0,129,130,  0,132,  0,\n+    0,  0,  0,  0,130,130,130,130,  0,  0,130,  0,230,230,  9,  0,\n+  230,230,  0,  0,220,  0,  0,  0,  0,  7,  0,  9,  9,  0,  9,  9,\n+    0,  0,  0,230,  0,  0,  0,228,  0,  0,  0,222,230,220,220,  0,\n+    0,  0,230,  0,  0,220,230,220,  0,220,230,230,230,  0,  0,  0,\n+    9,  9,  0,  0,  7,  0,230,  0,  1,  1,  1,  0,  0,  0,230,234,\n+  214,220,202,230,230,230,230,230,232,228,228,220,218,230,233,220,\n+  230,220,230,230,  1,  1,  1,  1,  1,230,  0,  1,  1,230,220,230,\n+    1,  1,  0,  0,218,228,232,222,224,224,  0,  8,  8,  0,  0,  0,\n+    0,220,230,  0,230,230,220,  0,  0,230,  0,  0, 26,  0,  0,220,\n+    0,230,230,  1,220,  0,  0,230,220,  0,  0,  0,220,220,  0,  0,\n+  230,220,  0,  9,  7,  0,  0,  7,  9,  0,  0,  0,  9,  7,  6,  6,\n+    0,  0,  0,  0,  1,  0,  0,216,216,  1,  1,  1,  0,  0,  0,226,\n+  216,216,216,216,216,  0,220,220,220,  0,232,232,220,230,230,230,\n+    7,  0, 16, 17, 17, 33, 17, 49, 17, 17, 84, 97,135,145, 26, 17,\n@@ -6155,0 +4912,38 @@\n+   17,177,  0,  1,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n+    3,  3,  3,  3,  3,  3,  4,  3,  3,  3,  3,  3,  5,  3,  3,  3,\n+    3,  3,  6,  7,  8,  3,  3,  3,  3,  3,  9, 10, 11, 12, 13,  3,\n+    3,  3,  3,  3,  3,  3,  3, 14,  3, 15,  3,  3,  3,  3,  3,  3,\n+   16, 17, 18, 19, 20, 21,  3,  3,  3, 22, 23, 24,  3,  3,  3,  3,\n+    3,  3, 25,  3,  3,  3,  3,  3,  3,  3,  3, 26,  3,  3, 27, 28,\n+    0,  1,  0,  0,  0,  0,  0,  1,  0,  2,  0,  0,  0,  3,  0,  0,\n+    0,  3,  0,  0,  0,  0,  0,  4,  0,  5,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  0,  7,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  8,  9,  0,  0,  0,  0,  0,\n+    0,  9,  0,  9,  0,  0,  0,  0,  0,  0,  0, 10, 11, 12, 13,  0,\n+    0, 14, 15, 16,  6,  0, 17, 18, 19, 19, 19, 20, 21, 22, 23, 24,\n+   19, 25,  0, 26, 27, 19, 19, 28, 29, 30,  0, 31,  0,  0,  0,  8,\n+    0,  0,  0,  0,  0,  0,  0, 19, 28,  0, 32, 33,  9, 34, 35, 19,\n+    0,  0, 36, 37, 38, 39, 40, 19,  0, 41, 42, 43, 44, 31,  0,  1,\n+   45, 42,  0,  0,  0,  0,  0, 32, 14, 14,  0,  0,  0,  0, 14,  0,\n+    0, 46, 47, 47, 47, 47, 48, 49, 47, 47, 47, 47, 50, 51, 52, 53,\n+   43, 21,  0,  0,  0,  0,  0,  0,  0, 54,  6, 55,  0, 14, 19,  1,\n+    0,  0,  0,  0, 56, 57,  0,  0,  0,  0,  0, 19, 58, 31,  0,  0,\n+    0,  0,  0,  0,  0, 59, 14,  0,  0,  0,  0,  1,  0,  2,  0,  0,\n+    0,  3,  0,  0,  0, 60, 61,  0,  0,  0,  0,  0,  0,  0,  1,  0,\n+    0,  0,  0,  0,  2,  3,  0,  4,  5,  0,  0,  6,  0,  0,  0,  7,\n+    0,  0,  0,  1,  1,  0,  0,  8,  9,  0,  8,  9,  0,  0,  0,  0,\n+    8,  9, 10, 11, 12,  0,  0,  0, 13,  0,  0,  0,  0, 14, 15, 16,\n+   17,  0,  0,  0,  1,  0,  0, 18, 19,  0,  0,  0, 20,  0,  0,  0,\n+    1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  0,  8, 21,  9,\n+    0,  0, 22,  0,  0,  0,  0,  1,  0, 23, 24, 25,  0,  0, 26,  0,\n+    0,  0,  8, 21, 27,  0,  1,  0,  0,  1,  1,  1,  1,  0,  1, 28,\n+   29, 30,  0, 31, 32, 20,  1,  1,  0,  0,  0,  8, 21,  9,  1,  4,\n+    5,  0,  0,  0, 33,  9,  0,  1,  1,  1,  0,  8, 21, 21, 21, 21,\n+   34,  1, 35, 21, 21, 21,  9, 36,  0,  0, 37, 38,  1,  0, 39,  0,\n+    0,  0,  1,  0,  1,  0,  0,  0,  0,  8, 21,  9,  1,  0,  0,  0,\n+   40,  0,  8, 21, 21, 21, 21, 21, 21, 21, 21,  9,  0,  1,  1,  1,\n+    1,  8, 21, 21, 21,  9,  0,  0,  0, 41,  0, 42, 43,  0,  0,  0,\n+    1, 44,  0,  0,  0, 45,  8,  9,  1,  0,  0,  0,  8, 21, 21, 21,\n+    9,  0,  1,  0,  1,  1,  8, 21, 21,  9,  0,  4,  5,  8,  9,  1,\n+    0,  0,  0,  1,  2,  3,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,\n+   13, 14,  3,  3,  3,  3,  3,  3,  3, 15,  3, 16, 17, 17, 17, 17,\n@@ -6157,117 +4952,80 @@\n-   17, 17, 17, 17, 17, 17, 17, 17, 17,237,  0,  1,  2,  2,  0,  3,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  4,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  6,  7,  8,  9,  0,\n-    0,  0, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0, 20,  0,  0, 21, 22,  0,  0,  0,  0, 23, 24,\n-   25, 26,  0, 27,  0, 28, 29, 30, 31, 32,  0,  0,  0,  0,  0,  0,\n-    0, 33, 34, 35, 36,  0,  0,  0,  0,  0, 37,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0, 38, 39,  0,  0,  0,  0,  1,  2, 40, 41,  0,  1,\n-    2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,\n-    0,  2,  0,  0,  0,  0,  0,  0,  3,  4,  0,  0,  5,  0,  0,  0,\n-    6,  0,  0,  0,  0,  0,  0,  0,  7,  1,  0,  0,  0,  0,  0,  0,\n-    8,  9,  0,  0,  0,  0,  0,  0, 10,  0,  0, 10,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0, 10,  0,  0,  0, 10,  0,  0,\n-    0,  0,  0,  0, 11, 12,  0, 13,  0, 14, 15, 16,  0,  0,  0,  0,\n-    0,  1, 17, 18,  0, 19,  7,  1,  0,  0,  0, 20, 20,  7, 20, 20,\n-   20, 20, 20, 20, 20,  8, 21,  0, 22,  0,  7, 23, 24,  0, 20, 20,\n-   25,  0,  0,  0, 26, 27,  1,  7, 20, 20, 20, 20, 20,  1, 28, 29,\n-   30, 31,  0,  0, 20,  0,  0,  0,  0,  0,  0,  0, 10,  0,  0,  0,\n-    0,  0,  0,  0, 20, 20, 20,  1,  0,  0,  8, 21, 32,  4,  0, 10,\n-    0, 33,  7, 20, 20, 20,  0,  0,  0,  0,  8, 34, 34, 35, 36, 34,\n-   37,  0, 38,  1, 20, 20,  0,  0, 39,  0,  1,  1,  0,  8, 21,  1,\n-   20,  0,  0,  0,  1,  0,  0, 40,  1,  1,  0,  0,  8, 21,  0,  1,\n-    0,  1,  0,  1,  0,  0,  0,  0, 26, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 21,  7, 20, 41, 34, 34, 34, 34, 34, 34, 34, 34, 34, 21,\n-    0, 42, 43, 44,  0, 45,  0,  8, 21,  0,  0,  0,  0,  0,  0,  0,\n-    0, 46,  7,  1, 10,  1,  0,  0,  0,  1, 20, 20,  1,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 26, 34,  9,  0,  0, 20, 20,  1, 20,\n-   20,  0,  0,  0,  0,  0,  0,  0, 26, 21,  0,  1,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  3, 47, 48,  0,  0,  0,  0,  0,\n-    0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  7,  8,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  9, 10, 11, 11, 11, 11, 11, 12, 12, 12,\n-   12, 13, 14, 15, 16, 17, 18, 19, 20, 12, 21, 12, 12, 12, 12, 22,\n-   23, 23, 23, 24, 12, 12, 12, 25, 26, 27, 12, 28, 29, 30, 31, 32,\n-   33, 34,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 35,\n-   12, 36,  7,  7, 37, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 38,  0,  0,  1,  2,  2,  2,  3,  4,  5,  6,  7,  8,  9,\n-   10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\n-   26, 27, 28, 29, 30, 31, 32, 32, 33, 33, 33, 34, 35, 35, 35, 35,\n-   35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,\n-    2,  2, 51, 51, 52, 53, 54, 55, 56, 56, 56, 56, 56, 56, 56, 56,\n-   56, 56, 56, 56, 57, 57, 56, 56, 56, 56, 56, 56, 58, 59, 60, 61,\n-   56, 62, 62, 63, 64, 65, 66, 67, 68, 69, 70, 56, 62, 62, 62, 62,\n-   62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62,\n-   62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 71,\n-   62, 62, 62, 62, 72, 72, 72, 72, 72, 72, 72, 72, 72, 73, 74, 74,\n-   75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 32, 32, 32, 32,\n-   32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n-   32, 32, 32, 32, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n-   87, 87, 87, 87, 87, 87, 62, 62, 62, 62, 88, 89, 89, 89, 90, 89,\n-   91, 92, 93, 94, 95, 95, 96, 97, 87, 98, 99,100,101,102,103,104,\n-  105,105,105,  2,106,107,108,109,110,111,112,113,114,115,116, 87,\n-   89,117,118,119,120,121,122,123,124,125,126, 87,127,128, 87,129,\n-  130,131,132, 87,133,134,135,136,137,138, 87, 87,139,140,141,142,\n-   87,143, 87,144,145,145,145,145,145,145,145,145,145,145,145, 87,\n-   87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n-   87, 87, 87,146,147,147,147,147,147,147,147,147,147, 87, 87, 87,\n-   87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,148,148,148,148,\n-  148, 87, 87, 87,149,149,149,149,150,151,152,152, 87, 87, 87, 87,\n-  153,153,154,155,156,156,156,156,156,156,156,156,156,156,156,156,\n-  156,156,156,156,156,156,156,156,156,156,157,157,157,157,156, 87,\n-   87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n-   87, 87, 87,158,159,160,161,162,162,162, 87, 87, 87, 87, 87, 87,\n-   87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,163,164, 87, 87,\n-   87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n-   87, 87,165, 56, 56, 56,166,167, 51, 56, 56, 87, 56, 56, 56, 56,\n-   56, 56, 56, 56,168,168,168,168,168,168, 87, 87, 87, 87, 87, 87,\n-   87, 87,  2, 87,169, 87,170, 87, 87,171, 87, 87, 87, 87, 87, 87,\n-   87, 87, 87, 33,172,172,173, 87, 87, 87, 87, 87, 56, 56, 56, 87,\n-   89, 89, 87, 87, 56, 56, 56, 56,174, 87, 56, 56, 56, 56, 56, 56,\n-   56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 87, 87, 87, 87,\n-   87, 87, 87, 87, 62, 62, 62, 62, 62, 62, 62, 62, 87, 87, 87, 87,\n-   87, 87, 87, 87, 62, 62, 62, 62, 62, 87, 87, 87, 87, 87, 87, 87,\n-   87, 87, 87, 87, 62, 62, 62, 62, 62, 62, 62, 87, 87, 87, 87, 87,\n-   87, 87, 87, 87, 56, 87,175,175,  0,  1,  2,  2,  0,  1,  2,  2,\n-    2,  3,  4,  5,  0,  0,  0,  0,  1,  2,  1,  2,  0,  0,  3,  3,\n-    4,  5,  4,  5,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  6,\n-    0,  0,  7,  0,  8,  8,  8,  8,  8,  8,  8,  9, 10, 11, 11, 11,\n-   11, 11, 12, 11, 13, 13, 13, 13, 13, 13, 13, 13, 14, 13, 13, 13,\n-   13, 13, 13, 13, 13, 13, 13, 15, 16, 16, 16, 16, 16, 17, 18, 18,\n-   18, 18, 18, 18, 19, 20, 21, 21, 22, 23, 21, 24, 21, 21, 21, 21,\n-   21, 25, 21, 21, 26, 26, 26, 26, 26, 21, 21, 21, 27, 27, 27, 27,\n-   28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 26, 21, 21, 21, 21, 21,\n-   21, 21, 31, 21, 32, 32, 32, 32, 32, 33, 34, 32, 35, 35, 35, 35,\n-   35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37,\n-   37, 37, 37, 37, 38, 38, 38, 38, 38, 38, 38, 38, 39, 39, 39, 39,\n-   39, 39, 39, 39, 40, 40, 40, 40, 40, 40, 40, 40, 41, 41, 41, 41,\n-   41, 41, 41, 41, 42, 42, 42, 42, 42, 42, 42, 42, 43, 43, 43, 43,\n-   43, 43, 43, 43, 44, 44, 44, 45, 44, 44, 44, 44, 46, 46, 46, 46,\n-   46, 46, 46, 46, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47,\n-   47, 48, 47, 47, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 50, 50,\n-   50, 50, 50, 51, 52, 52, 52, 52, 52, 52, 52, 52, 53, 53, 53, 53,\n-   53, 53, 53, 53, 53, 53, 54, 54, 54, 54, 54, 54, 55, 55, 55, 55,\n-   55, 55, 55, 55, 56, 56, 57, 57, 57, 57, 58, 57, 59, 59, 60, 61,\n-   62, 62, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 65, 66, 66, 66,\n-   66, 66, 66, 66, 66, 66, 66, 55, 55, 55, 55, 55, 67, 67, 67, 67,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+   17, 17, 18,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,\n+   12, 13, 14, 15, 16, 17, 17, 17, 18, 17, 19, 20, 21, 22, 23, 23,\n+   23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 23, 23, 23, 23, 23,\n+   23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n+   23, 23, 23, 23, 25, 25, 26, 27, 28, 29, 30, 30, 30, 30, 30, 30,\n+   30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+   31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n+   32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n+   48, 49, 50, 51, 52, 52, 53, 31, 31, 31, 31, 54, 55, 55, 56, 31,\n+   31, 31, 31, 31, 31, 31, 57, 58, 31, 31, 31, 31, 31, 31, 31, 31,\n+   31, 31, 31, 31, 31, 31, 31, 31, 59, 60, 31, 61, 62, 62, 62, 62,\n+   62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 64, 31, 31, 31, 31, 31,\n+   31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 65, 66, 67, 31, 31,\n+   31, 31, 68, 31, 31, 31, 31, 31, 31, 31, 31, 69, 70, 71, 17, 17,\n+   72, 73, 31, 74, 75, 76, 77, 78, 79, 31, 80, 81, 17, 82, 17, 17,\n+   17, 17, 31, 31, 23, 23, 23, 23, 23, 23, 31, 31, 31, 31, 31, 31,\n+   23, 83, 31, 31, 23, 23, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n+   31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n+   31, 31, 31, 31, 84,  0,  0,  1,  0,  1,  2,  3,  0,  1,  2,  3,\n+    4,  5,  6,  7,  0,  1,  2,  3,  4,  4,  4,  4,  4,  4,  5,  6,\n+    7,  8,  9, 10, 11, 11, 12, 11, 13, 14, 15, 16, 17, 18, 19, 20,\n+   21, 22, 23, 24, 25, 26, 19, 27, 28, 29, 30, 30, 31, 31, 32, 32,\n+   33, 33, 34, 34, 35, 35, 36, 36, 37, 37, 38, 38, 39, 40, 41, 41,\n+   42, 42, 42, 43, 44, 44, 45, 46, 47, 47, 47, 47, 48, 48, 48, 48,\n+   48, 48, 49, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 53,\n+   54, 55, 56, 56, 57, 58, 59, 51, 60, 61, 62, 63, 64, 65, 66,  7,\n+   67, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,  7,  4,  4,  4,  4,\n+   77, 77, 77, 77, 78, 79, 80, 81, 82, 83, 84,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0, 85, 85, 85, 85,  0,  0,  0,  0, 86, 87, 88, 88,\n+   89, 90, 48, 91,  0,  0, 92, 92, 92, 92, 92, 93, 94, 95, 96, 97,\n+   98, 47, 99,100,101,102,  0,103,104,105,  0,  0, 92, 92, 92, 92,\n+   92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,  0,106,106,106,106,\n+  106,106,106,106,106,106,106,107,108,108,108,108,108, 11,109,110,\n+  111,  4,112,  4,113,114,115,116,117,118,119,120,121,122,123,124,\n+  125,126, 50,127, 47, 47, 47, 47, 47, 47, 47, 47,128,128,128,128,\n+  128,128,128,128,128,128,128,128, 92, 92, 92, 92, 92, 92, 92, 92,\n+  129,130, 19, 19, 19, 19, 19, 19,131, 19, 19, 19,132,133, 19,134,\n+  135,136,137,101,138,138,138,138,  0, 77,139,140,128,128,141,142,\n+  143,144,145,146,147,148,149,150,151,152,153,153,154,154,154,154,\n+  154,154,  4,  4,155,156,157,158,159,160,161,162,163,164,165,166,\n+  167,168,169,169,170,170,171,171,172,172,128,128, 19, 19,173,174,\n+  175,176,177,178,179,179,180,181,182,183,184,185,186,186,187,188,\n+  189,190,128,128,191,191,192,192,128,128,193,193,194,195,196,196,\n+  197,197,128,128,198,198,199,199,200,200,201,201,202,203,204,205,\n+   28, 28,128,128,206,207,208,208,209,210,211,211,128,128,212,212,\n+  213,213,214, 34,215,215,215,215,215,215,215,215,215,215,215,215,\n+  215,215,128,128,128,128,128,128,128,128,216,216,217,217,217,217,\n+  217,217,217,217,217,217,128,128,128,128,128,128,218,218,218,218,\n+  218,218,218,218,218,218,128,128,128,128,128,128,110,110,110,110,\n+  110,110,110,110,110,219,220,221,222,222,222,222,223,223,223,223,\n+  224,224,224,225,226,226,226,226,226,226,226,226,226,226,226,226,\n+  227,227,227,227,227,227,227,227,226,226,128,128,128,128,128,128,\n+  128,128,104,104,228,229,229,229,230,231,232,232,232,232,232,232,\n+  128,128,128,128,233,233,234,  0,128,128,128,128,128,128,128,128,\n+    7,235,  0,  0,  0,  0,  0,  0,  0,236,237,  0, 77, 77,  0,  0,\n+    0,  0,128,128,238,238,238,238,238,238,238,238,238,238,238,238,\n+  128,128,128,128,128,128,128,128,  4,  4,128,128,239, 11, 11, 11,\n+  240,240,128,128,128,128,241,242,128,128,128,128,128,128,243,243,\n+  128,128,128,128,128,128,128,128,128,128, 48, 48,244,244,244,244,\n+  245,245,128,128,  0,  0,  0,  0,  0,  0,128,128, 19, 19, 19, 19,\n+  128,128,128,128,246,  0,128,128,  0,  0,  0,  0, 92, 92,128,128,\n+  128,128,128,128,  0,  0,128,128,  7,  7,  7,  7,  0,  0,  0,  0,\n+    1,  2,  1,  2,  0,  0,  3,  3,  4,  5,  4,  5,  4,  4,  4,  4,\n+    4,  4,  4,  6,  0,  0,  7,  0,  8,  8,  8,  8,  8,  8,  8,  9,\n+   10, 11, 11, 11, 11, 11, 12, 11, 13, 13, 13, 13, 14, 13, 13, 13,\n+   13, 13, 13, 15, 16, 16, 16, 16, 16, 17, 18, 18, 18, 18, 18, 18,\n+   19, 20, 21, 21, 22, 23, 21, 24, 21, 21, 21, 21, 21, 25, 21, 21,\n+   26, 26, 26, 26, 26, 21, 21, 21, 27, 27, 27, 27, 28, 28, 28, 28,\n+   29, 29, 29, 29, 30, 30, 26, 21, 21, 21, 31, 21, 32, 32, 32, 32,\n+   32, 33, 34, 32, 35, 35, 35, 35, 36, 36, 36, 36, 37, 37, 37, 37,\n+   38, 38, 38, 38, 39, 39, 39, 39, 40, 40, 40, 40, 41, 41, 41, 41,\n+   42, 42, 42, 42, 43, 43, 43, 43, 44, 44, 44, 45, 44, 44, 44, 44,\n+   46, 46, 46, 46, 47, 47, 47, 47, 47, 48, 47, 47, 49, 49, 49, 49,\n+   49, 49, 50, 50, 50, 50, 50, 51, 52, 52, 52, 52, 53, 53, 53, 53,\n+   53, 53, 54, 54, 54, 54, 54, 54, 55, 55, 55, 55, 56, 56, 57, 57,\n+   57, 57, 58, 57, 59, 59, 60, 61, 62, 62, 63, 63, 64, 64, 64, 64,\n+   65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 55, 67, 67, 67, 67,\n@@ -6275,4 +5033,3 @@\n-   71, 71, 71, 71, 71, 71, 71,  8,  8,  8,  8,  8, 72, 72, 72, 72,\n-   72, 72, 72, 72, 73, 73, 73, 73, 74, 74, 74, 74, 75, 75, 75, 75,\n-   75, 76, 76, 76, 13, 50, 50, 50, 73, 77, 78, 79,  4,  4, 80,  4,\n-    4, 81, 82, 83,  4,  4,  4, 84,  8,  8,  8,  8, 11, 11, 11, 11,\n+   71, 71, 71, 71, 71, 71, 71,  8, 72, 72, 72, 72, 73, 73, 73, 73,\n+   74, 74, 74, 74, 75, 75, 75, 75, 75, 76, 76, 76, 13, 50, 50, 50,\n+   73, 77, 78, 79,  4,  4, 80,  4,  4, 81, 82, 83,  4,  4,  4, 84,\n@@ -6281,1 +5038,0 @@\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 90, 90, 90, 90,\n@@ -6283,2 +5039,1 @@\n-   92, 92, 92, 92, 50, 50, 50, 93, 93, 93, 93, 93, 53, 53, 53, 53,\n-   53, 53, 13, 13, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94,\n+   50, 50, 50, 93, 93, 93, 93, 93, 53, 53, 13, 13, 94, 94, 94, 94,\n@@ -6286,176 +5041,160 @@\n-  102,102,102,103,104,104,104,105, 52, 52, 52, 52, 52,  0,104,104,\n-    0,  0,  0,102, 52, 52,  0,  0,  0,  0, 52,106,  0,  0,  0,  0,\n-    0,102,102,107,102,102,102,102,102,108,  0,  0, 94, 94, 94, 94,\n-    0,  0,  0,  0,109,109,109,109,109,109,109,109,109,109,109,109,\n-  109,110,110,110,111,111,111,111,111,111,111,111,111,111,111,111,\n-   13, 13, 13, 13, 13, 13,112,112,112,112,112,112,  0,  0,113,  4,\n-    4,  4,  4,  4,114,  4,  4,  4,  4,  4,  4,  4,115,115,115,  0,\n-  116,116,116,116,117,117,117,117,117,117, 32, 32,118,118,119,120,\n-  120,120, 52, 52,121,121,121,121,122,121, 49, 49,123,123,123,123,\n-  123,123, 49, 49,124,124,124,124,124,124,125,125, 53, 53, 53,  4,\n-    4,126,127, 54, 54, 54, 54, 54,125,125,125,125,128,128,128,128,\n-  128,128,128,128,  4,129, 18, 18, 18, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21,130, 21, 21, 21, 21,  8,  0,131,  0,\n-    0,  0,  0, 21, 21, 21, 21, 21, 21, 21, 21,132,  0,  0,  1,  2,\n-    1,  2,133,101,102,134, 52, 52, 52, 52,  0,  0,135,135,135,135,\n-  135,135,135,135,  0,  0,  0,  0, 11, 11, 11, 11, 11,  0, 11, 11,\n-   11,  0,  0,136,137,137,138,138,138,138,139,  0,140,140,140,141,\n-  141,142,142,142,143,143,144,144,144,144,144,144,145,145,145,145,\n-  145,146,146,146,147,147,147,148,148,148,148,148,149,149,149,150,\n-  150,150,150,151,151,151,151,151,151,151,151,151,152,152,152,152,\n-  152,152,152,152,153,153,153,153,154,154,155,155,156,156,156,156,\n-  156,156,157,157,158,158,159,159,159,159,159,159,160,160,161,161,\n-  161,161,161,161,162,162,162,162,162,162,163,163,164,164,164,164,\n-  165,165,165,165,166,166,166,166,167,167,168,168,169,169,169,169,\n-  169,169,169,169,170,170,170,170,170,170,170,170,171,171,171,171,\n-  171,171,171,171,172,172,172,172,172,172,172,172,173,173,173,173,\n-  173,173,173,173,174,174,174,175,175,175,175,176,176,176,176,177,\n-  177,177,178,178,179,179,179,179,179,179,179,179,180,180,180,180,\n-  180,181,181,181,182,182,182,182,182,183,183,183,184,184,184,184,\n-  184,184,185, 43,186,186,186,186,186,186,186,186,187,187,187,188,\n-  188,188,188,188,189,189,189,190,189,189,189,189,191,191,191,191,\n-  191,191,191,191,192,192,192,192,192,192,192,192,193,193,193,193,\n-  193,193,193,193,194,194,194,194,194,194, 66, 66,195,195,195,195,\n-  195,195,195,195,196,196,196,196,196,196,196,196,197,197,197,197,\n-  197,197,197,197,198,198,198,198,198,198,198,198,199,199,199,199,\n-  199,199,199,199,200,200,200,200,200,200,200,200,201,201,201,201,\n-  201,202,202,202,202,202,202, 55,203,203,203,203,204,204,204,204,\n-  204,204,204,205,205,205,205,205,205,205,205,205,206,206,206,206,\n-  206,206,207,207,207,207,207,207,207,207,207,207,208,208,208,208,\n-  208,208,208,208,110,110,110,110, 39, 39, 39, 39,209,209,209,209,\n-  209,209,209,209,210,210,210,210,210,210,210,210,211,211,211,211,\n-  211,211,211,211,212,212,212,212,212,212,212,212,112,112,112,112,\n-  112,112,112,112,112,112,112,112,213,213,213,214,214,214,214,214,\n-  214,215,215,215,216,216,216,216,216,216,216,216,217,217,217,217,\n-  217,217,217,217,218,218,218,218,218,218,218,218,218,218,218,218,\n-  218,218,219, 94,220,220,220,220,220,220,220,220,221,221,221,221,\n-  221,221,221,221,102,102,102,102,102,102,102,102,222, 99, 99, 99,\n-   99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,102,102,\n-  102, 99,223,224,224,224,224,224,224,224,224,224,225,225,225,225,\n-  225,225,225,225,225,225,  0,  0,  0,  0,  0,  0,  8,  8,  8,  8,\n-    8,  0,  0,  0,  0,  0,  0,  0,  0,  0,226,227,228,  0,229,  0,\n-    0,  0,  0,  0,230,230,230,230,230,230,230,230, 91, 91, 91, 91,\n-   91, 91, 91, 91,231,231,231,231,231,231,231,231,232,232,232,232,\n-  233,233,233,233,234,234,234,234,234,234,234,234,235,235,235,235,\n-  235,235,235,235,236,  0,  0,  0,  0,  0,  0,  0,  8,  8,  8,  8,\n-    8,  8,  8,  8,  0,  0,  0,  0,  1,  2,  2,  2,  2,  2,  3,  0,\n-    0,  0,  4,  0,  2,  2,  2,  2,  2,  3,  2,  2,  2,  2,  5,  0,\n-    2,  5,  6,  0,  7,  7,  7,  7,  8,  9,  8, 10,  8, 11,  8,  8,\n-    8,  8,  8,  8, 12, 13, 13, 13, 14, 14, 14, 14, 14, 15, 14, 14,\n-   16, 17, 17, 17, 17, 17, 17, 17, 18, 19, 19, 19, 19, 19, 19, 19,\n-   20, 21, 20, 22, 20, 20, 23, 23, 20, 20, 20, 20, 22, 20, 24,  7,\n-    7, 25, 20, 20, 26, 20, 20, 20, 20, 20, 20, 21, 27, 27, 27, 27,\n-   28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31,\n-   32, 20, 20, 20, 33, 33, 33, 33, 34, 35, 33, 33, 33, 36, 33, 33,\n-   37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39, 40, 40, 40, 40,\n-   41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43, 44, 44, 44, 44,\n-   45, 45, 45, 45, 46, 46, 46, 46, 46, 46, 46, 47, 48, 48, 48, 48,\n-   49, 49, 49, 49, 49, 50, 51, 49, 52, 52, 52, 52, 53, 53, 53, 53,\n-   53, 53, 54, 53, 55, 55, 55, 55, 56, 56, 56, 56, 57, 57, 57, 57,\n-   58, 58, 58, 58, 59, 59, 59, 59, 60, 60, 60, 60, 60, 60, 61, 62,\n-   63, 63, 63, 63, 64, 64, 64, 64, 64, 65,  0,  0, 66, 66, 66, 66,\n-   67, 67, 67, 67, 68, 68, 68, 68, 69, 70, 71, 71, 71, 71, 71, 71,\n-   72, 72, 72, 72, 73, 73, 73, 73, 74, 74, 74, 74, 75, 75, 75, 75,\n-   76, 76, 76, 76, 77, 77, 77, 77, 78, 78, 78, 78, 79, 79, 79, 79,\n-   80, 80, 80, 80, 81, 81, 81, 81, 82,  7,  7,  7, 83,  7, 84, 85,\n-    0, 84, 86,  0,  2, 87, 88,  2,  2,  2,  2, 89, 90, 87, 91,  2,\n-    2,  2, 92,  2,  2,  2,  2, 93,  0,  0,  0, 86,  1,  0,  0, 94,\n-    0, 95, 96,  0,  4,  0,  0,  0,  0,  0,  0,  4, 97, 97, 97, 97,\n-   98, 98, 98, 98, 13, 13, 13, 13, 99, 99, 99, 99,100,100,100,100,\n-    0,101,  0,  0,102,100,103,104,  0,  0,100,  0,105,106,106,106,\n-  106,106,106,106,106,106,107,105,108,109,109,109,109,109,109,109,\n-  109,109,110,108,111,111,111,111,112, 55, 55, 55, 55, 55, 55,113,\n-  109,109,109,110,109,109,  0,  0,114,114,114,114,115,115,115,115,\n-  116,116,116,116,117,117,117,117, 96,  2,  2,  2,  2,  2, 94,  2,\n-  118,118,118,118,119,119,119,119,120,120,120,120,121,121,121,121,\n-  121,121,121,122,123,123,123,123,124,124,124,124,124,124,124,125,\n-  126,126,126,126,127,127,127,127,128,128,128,128,  2,  2,  3,  2,\n-    2,129,130,  0,131,131,131,131,132, 17, 17, 18, 20, 20, 20,133,\n-    7,  7,  7,134, 20, 20, 20, 23,  0,135,109,109,109,109,109,136,\n-  137,137,137,137,  0,  0,  0,138,139,139,139,139,140,140,140,140,\n-   84,  0,  0,  0,141,141,141,141,142,142,142,142,143,143,143,143,\n-  144,144,144,144,145,145,145,145,146,146,146,146,147,147,147,147,\n-  148,148,148,148,149,149,149,149,150,150,150,150,151,151,151,151,\n-  152,152,152,152,153,153,153,153,154,154,154,154,155,155,155,155,\n-  156,156,156,156,157,157,157,157,158,158,158,158,159,159,159,159,\n-  160,160,160,160,161,161,161,161,162,162,162,162,163,163,163,163,\n-  164,164,164,164,165,165,165,165,166,166,166,166,167,167,167,167,\n-  168,168,168,168,169,169,169,169,170,170,170,170,171,171,171,171,\n-  172,172,172,172,173,173,173,173,174,174,174,174,175,175,175,175,\n-  176,176,176,176,177,177,177,177,178,178,178,178,179,179,179,179,\n-  180,180,180,180,181,181,181,181,182,182,182,182,183,183,183,183,\n-  184,184,184,184,185,185,185,185,186, 45, 45, 45,187,187,187,187,\n-  188,188,188,188,189,189,189,189,190,190,190,190,190,190,191,190,\n-  192,192,192,192,193,193,193,193,194,194,194,194,195,195,195,195,\n-  196,196,196,196,197,197,197,197,198,198,198,198,199,199,199,199,\n-  200,200,200,200,201,201,201,201,202,202,202,202,203,203,203,203,\n-  204,204,204,204,205,205,205,205,206,206,206,206,207,207,207,207,\n-  208,208,208,208,209,209,209,209,210,210,210,210,211,211,211,211,\n-  212,212,212,212,213,213,213,213,214,214,214,214,215,215,215,215,\n-  216,216,216,216,217,217,217,217,218,218,218,218,219,219,219,219,\n-  220,221,221,221,222,222,222,222,221,221,221,221,223,106,106,106,\n-  106,109,109,109,224,224,224,224,225,225,225,225,  0,226, 86,  0,\n-    0,  0,226,  7, 82,138,  7,  0,  0,  0,227, 86,228,228,228,228,\n-  229,229,229,229,230,230,230,230,231,231,231,231,232,232,232,232,\n-  233,233,233,233,234,  0,  0,  0,  0,  0,  0,  0,  0, 19, 19, 19,\n-   19, 19, 19, 19, 19, 19, 19,  0,  0,  0, 19,  0, 19,  0,  0,  0,\n-    0,  0, 26, 26,  1,  1,  1,  1,  9,  9,  9,  9,  0,  9,  9,  9,\n-    9,  9,  0,  9,  9,  0,  9,  0,  9,  9, 55, 55, 55, 55, 55, 55,\n-    6,  6,  6,  6,  6,  1,  1,  6,  6,  4,  4,  4,  4,  4,  4,  4,\n-    4, 14, 14, 14, 14, 14, 14, 14,  3,  3,  3,  3,  3,  0,  3,  3,\n-    0,  3,  3,  3,  3,  3,  3,  0,  3,  3,  3,  1,  1,  1,  3,  3,\n-    1,  3,  3,  3, 37, 37, 37, 37, 38, 38, 38, 38, 64, 64, 64, 64,\n-   90, 90, 90, 90, 95, 95, 95, 95,  3,  3,  0,  3,  7,  7,  7,  7,\n-    7,  1,  1,  1,  1,  7,  7,  7,  0,  0,  7,  7,  5,  5,  5,  5,\n-   11, 11, 11, 11, 10, 10, 10, 10, 21, 21, 21, 21, 22, 22, 22, 22,\n-   23, 23, 23, 23, 16, 16, 16, 16, 20, 20, 20, 20, 36, 36, 36, 36,\n-   24, 24, 24, 24, 24, 24, 24,  0, 18, 18, 18, 18, 25, 25, 25, 25,\n-   25,  0,  0,  0,  0, 25, 25, 25, 33, 33, 33, 33,  8,  8,  8,  8,\n-    8,  8,  8,  0, 12, 12, 12, 12, 30, 30, 30, 30, 29, 29, 29, 29,\n-   28, 28, 28, 28, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35,  0,\n-    0,  0, 35, 35, 45, 45, 45, 45, 44, 44, 44, 44, 44,  0,  0,  0,\n-   43, 43, 43, 43, 46, 46, 46, 46, 31, 31, 31, 31, 32, 32,  0,  0,\n-   32,  0, 32, 32, 32, 32, 32, 32, 48, 48, 48, 48, 52, 52, 52, 52,\n-   58, 58, 58, 58, 54, 54, 54, 54, 91, 91, 91, 91, 62, 62, 62, 62,\n-   76, 76, 76, 76, 93, 93, 93, 93, 70, 70, 70, 70, 73, 73, 73, 73,\n-    1,  1,  1,  0,  1,  0,  1,  1,  1,  0,  0,  0,  0,  1,  0,  0,\n-    1,  1,  0,  0, 19, 19,  9,  9,  9,  9,  9,  6, 19,  9,  9,  9,\n-    9,  9, 19, 19,  9,  9,  9, 19,  6, 19, 19, 19, 19, 19, 19,  9,\n-    0,  0,  0, 19,  0,  0,  9,  0,  0,  0, 19, 19, 27, 27, 27, 27,\n-   56, 56, 56, 56, 61, 61, 61, 61, 13, 13, 13, 13,  0, 13,  0, 13,\n-    0, 13, 13, 13, 13, 13,  1,  1,  1,  1, 12, 12,  0, 15, 15, 15,\n-   15, 15, 15, 15, 15,  1,  1,  0,  0, 17, 17, 17, 17, 17, 17, 17,\n-   17, 17, 17,  0, 26, 26, 26, 26, 26, 12, 12, 12, 12, 12, 12,  0,\n-   39, 39, 39, 39, 86, 86, 86, 86, 77, 77, 77, 77, 79, 79, 79, 79,\n-   60, 60, 60, 60, 65, 65, 65, 65, 75, 75, 75, 75, 69, 69, 69, 69,\n-   69, 69,  0, 69, 74, 74, 74, 74, 84, 84, 84, 84, 84, 84, 84,  0,\n-   68, 68, 68, 68, 92, 92, 92, 92, 87, 87, 87, 87, 19,  9, 19, 19,\n-   19, 19,  0,  0,  2,  2,  2,  2, 19, 19, 19,  4,  3,  3,  0,  0,\n-    1,  1,  6,  6,  0,  0, 17, 17, 17, 17,  0,  0, 49, 49, 49, 49,\n-    0,  1,  1,  1, 71, 71, 71, 71, 67, 67, 67, 67, 42, 42, 42, 42,\n-   41, 41, 41, 41,118,118,118,118, 53, 53, 53, 53, 59, 59, 59, 59,\n-   40, 40, 40, 40, 51, 51, 51, 51, 50, 50, 50, 50,135,135,135,135,\n-  106,106,106,106,104,104,104,104,161,161,161,161,110,110,110,110,\n-   47, 47, 47, 47, 81, 81, 81, 81,120,120,120,120,116,116,116,116,\n-  128,128,128,128, 66, 66, 66, 66, 72, 72, 72, 72, 98, 98, 98, 98,\n-   97, 97, 97, 97, 57, 57, 57, 57, 88, 88, 88, 88,117,117,117,117,\n-  112,112,112,112, 78, 78, 78, 78, 83, 83, 83, 83, 82, 82, 82, 82,\n-  122,122,122,122, 89, 89, 89, 89,130,130,130,130,144,144,144,144,\n-  156,156,156,156,147,147,147,147,148,148,148,148,158,158,158,158,\n-  153,153,153,153,149,149,149,149, 94, 94, 94, 94, 85, 85, 85, 85,\n-  101,101,101,101, 96, 96, 96, 96,111,111,111,111,100,100,100,100,\n-  100, 36, 36, 36,108,108,108,108,129,129,129,129,109,109,109,109,\n-  107,107,107,107,107,107,107,  1,137,137,137,137,124,124,124,124,\n-  123,123,123,123,114,114,114,114,102,102,102,102,126,126,126,126,\n-  142,142,142,142,125,125,125,125,154,154,154,154,150,150,150,150,\n-  141,141,141,141,140,140,140,140,121,121,121,121,133,133,133,133,\n-  134,134,134,134,138,138,138,138,143,143,143,143,145,145,145,145,\n-   63, 63, 63, 63,157,157,157,157, 80, 80, 80, 80,127,127,127,127,\n-  115,115,115,115,159,159,159,159,103,103,103,103,119,119,119,119,\n-  146,146,146,146, 99, 99, 99, 99,136,139, 13, 13,155,155,155,155,\n-  136,136,136,136, 17, 15, 15, 15,139,139,139,139,105,105,105,105,\n-    0,  0,  0,  1,  0,  0,  1,  1,131,131,131,131,151,151,151,151,\n-  160,160,160,160,152,152,152,152,113,113,113,113,132,132,132,132,\n-   15,  0,  0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  9,  9,\n-    9, 10,  9, 11, 12, 13,  9,  9,  9, 14,  9,  9, 15,  9,  9,  9,\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+  102,102,102,103,104,104,104,105, 52,  0,104,104,  0,  0,  0,102,\n+   52, 52,  0,  0,  0,  0, 52,106,  0,102,102,107,102,102,102,102,\n+  102,108,  0,  0,109,109,109,109,109,110,110,110,111,111,111,111,\n+   13, 13,112,112,112,112,112,112,  0,  0,113,  4,114,  4,  4,  4,\n+  115,115,115,  0,116,116,116,116,117,117,117,117,117,117, 32, 32,\n+  118,118,119,120,120,120, 52, 52,121,121,121,121,122,121, 49, 49,\n+  123,123,123,123,123,123, 49, 49,124,124,124,124,124,124,125,125,\n+   53, 53, 53,  4,  4,126,127, 54,125,125,125,125,128,128,128,128,\n+    4,129, 18, 18, 18, 21, 21, 21, 21, 21, 21,130,  8,  0,131,  0,\n+    0,  0,  0, 21, 21, 21, 21,132,  0,  0,  1,  2,  1,  2,133,101,\n+  102,134, 52, 52,135,135,135,135, 11,  0, 11, 11, 11,  0,  0,136,\n+  137,137,138,138,138,138,139,  0,140,140,140,141,141,142,142,142,\n+  143,143,144,144,144,144,144,144,145,145,145,145,145,146,146,146,\n+  147,147,147,148,148,148,148,148,149,149,149,150,150,150,150,151,\n+  151,151,151,151,152,152,152,152,153,153,153,153,154,154,155,155,\n+  156,156,156,156,156,156,157,157,158,158,159,159,159,159,159,159,\n+  160,160,161,161,161,161,161,161,162,162,162,162,162,162,163,163,\n+  164,164,164,164,165,165,165,165,166,166,166,166,167,167,168,168,\n+  169,169,169,169,170,170,170,170,171,171,171,171,172,172,172,172,\n+  173,173,173,173,173,173,173,174,175,175,175,176,176,176,176,177,\n+  177,177,177,178,178,178,179,179,180,180,180,180,181,181,181,181,\n+  181,182,182,182,183,183,183,183,183,184,184,184,185,185,185,185,\n+  185,185,186, 43,187,187,187,187,188,188,188,189,189,189,189,189,\n+  190,190,190,191,190,190,190,190,192,192,192,192,193,193,193,193,\n+  194,194,194,194,195,195,195,195,195,195, 66, 66,196,196,196,196,\n+  197,197,197,197,198,198,198,198,199,199,199,199,200,200,200,200,\n+  201,201,201,201,202,202,202,202,202,203,203,203,203,203,203, 55,\n+  204,204,204,204,205,205,205,205,205,205,205,206,206,206,206,206,\n+  207,207,207,207,207,207,208,208,208,208,208,208,209,209,209,209,\n+  210,210,210,210,110,110,110,110,211,211,211,211,212,212,212,212,\n+  213,213,213,213,214,214,214,214,215,215,215,216,216,216,216,216,\n+  216,217,217,217,218,218,218,218,219,219,219,219,220,220,220,220,\n+  220,220,221, 94,222,222,222,222,223,223,223,223,224, 99, 99, 99,\n+   99, 99, 99, 99, 99, 99,102,225, 99,226,102,227,227,227,227,227,\n+  228,228,228,228,228,228,  0,  0,  8,  0,  0,  0,  0,  0,229,230,\n+  231,  0,232,  0,233,233,233,233, 91, 91, 91, 13,234,234,234,234,\n+  235,235,235,235,236,236,236,236,237,237,237,237,238,238,238,238,\n+  239,239,239,239,240,  0,  0,  0,  0,  0,  0,  0,  1,  2,  2,  2,\n+    2,  2,  3,  0,  0,  0,  4,  0,  2,  2,  2,  2,  2,  3,  2,  2,\n+    2,  2,  5,  0,  2,  5,  6,  0,  7,  7,  7,  7,  8,  9,  8, 10,\n+    8, 11,  8,  8,  8,  8,  8,  8, 12, 13, 13, 13, 14, 14, 14, 14,\n+   14, 15, 14, 14, 16, 17, 17, 17, 17, 17, 17, 17, 18, 19, 19, 19,\n+   19, 19, 19, 19, 20, 21, 20, 22, 20, 20, 23, 23, 20, 20, 20, 20,\n+   22, 20, 24,  7,  7, 25, 20, 20, 26, 20, 20, 20, 20, 20, 20, 21,\n+   27, 27, 27, 27, 28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30,\n+   31, 31, 31, 31, 32, 20, 20, 20, 33, 33, 33, 33, 34, 35, 33, 33,\n+   33, 36, 33, 33, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39,\n+   40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43,\n+   44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 46, 46, 46, 47,\n+   48, 48, 48, 48, 49, 49, 49, 49, 49, 50, 51, 49, 52, 52, 52, 52,\n+   53, 53, 53, 53, 53, 53, 54, 53, 55, 55, 55, 55, 56, 56, 56, 56,\n+   57, 57, 57, 57, 58, 58, 58, 58, 59, 59, 59, 59, 60, 60, 60, 60,\n+   60, 60, 61, 62, 63, 63, 63, 63, 64, 64, 64, 64, 64, 65,  0,  0,\n+   66, 66, 66, 66, 67, 67, 67, 67, 68, 68, 68, 68, 69, 70, 71, 71,\n+   71, 71, 71, 71, 72, 72, 72, 72, 73, 73, 73, 73, 74, 74, 74, 74,\n+   75, 75, 75, 75, 76, 76, 76, 76, 77, 77, 77, 77, 78, 78, 78, 78,\n+   79, 79, 79, 79, 80, 80, 80, 80, 81, 81, 81, 81, 82,  7,  7,  7,\n+   83,  7, 84, 85,  0, 84, 86,  0,  2, 87, 88,  2,  2,  2,  2, 89,\n+   90, 87, 91,  2,  2,  2, 92,  2,  2,  2,  2, 93,  0,  0,  0, 86,\n+    1,  0,  0, 94,  0, 95, 96,  0,  4,  0,  0,  0,  0,  0,  0,  4,\n+   97, 97, 97, 97, 98, 98, 98, 98, 13, 13, 13, 13, 99, 99, 99, 99,\n+  100,100,100,100,  0,101,  0,  0,102,100,103,104,  0,  0,100,  0,\n+  105,106,106,106,106,106,106,106,106,106,107,105,108,109,109,109,\n+  109,109,109,109,109,109,110,108,111,111,111,111,112, 55, 55, 55,\n+   55, 55, 55,113,109,109,109,110,109,109,  0,  0,114,114,114,114,\n+  115,115,115,115,116,116,116,116,117,117,117,117, 96,  2,  2,  2,\n+    2,  2, 94,  2,118,118,118,118,119,119,119,119,120,120,120,120,\n+  121,121,121,121,121,121,121,122,123,123,123,123,124,124,124,124,\n+  124,124,124,125,126,126,126,126,127,127,127,127,128,128,128,128,\n+    2,  2,  3,  2,  2,129,130,  0,131,131,131,131,132, 17, 17, 18,\n+   20, 20, 20,133,  7,  7,  7,134, 20, 20, 20, 23,  0,135,109,109,\n+  109,109,109,136,137,137,137,137,  0,  0,  0,138,139,139,139,139,\n+  140,140,140,140, 84,  0,  0,  0,141,141,141,141,142,142,142,142,\n+  143,143,143,143,144,144,144,144,145,145,145,145,146,146,146,146,\n+  147,147,147,147,148,148,148,148,149,149,149,149,150,150,150,150,\n+  151,151,151,151,152,152,152,152,153,153,153,153,154,154,154,154,\n+  155,155,155,155,156,156,156,156,157,157,157,157,158,158,158,158,\n+  159,159,159,159,160,160,160,160,161,161,161,161,162,162,162,162,\n+  163,163,163,163,164,164,164,164,165,165,165,165,166,166,166,166,\n+  167,167,167,167,168,168,168,168,169,169,169,169,170,170,170,170,\n+  171,171,171,171,172,172,172,172,173,173,173,173,174,174,174,174,\n+  174,174,174,175,176,176,176,176,177,177,177,177,178,178,178,178,\n+  179,179,179,179,180,180,180,180,181,181,181,181,182,182,182,182,\n+  183,183,183,183,184,184,184,184,185,185,185,185,186,186,186,186,\n+  187, 45, 45, 45,188,188,188,188,189,189,189,189,190,190,190,190,\n+  191,191,191,191,191,191,192,191,193,193,193,193,194,194,194,194,\n+  195,195,195,195,196,196,196,196,197,197,197,197,198,198,198,198,\n+  199,199,199,199,200,200,200,200,201,201,201,201,202,202,202,202,\n+  203,203,203,203,204,204,204,204,205,205,205,205,206,206,206,206,\n+  207,207,207,207,208,208,208,208,209,209,209,209,210,210,210,210,\n+  211,211,211,211,212,212,212,212,213,213,213,213,214,214,214,214,\n+  215,215,215,215,216,216,216,216,217,217,217,217,218,218,218,218,\n+  219,219,219,219,220,220,220,220,221,221,221,221,222,223,223,223,\n+  224,224,224,224,223,223,223,223,225,106,106,106,226,106,106,106,\n+  106,227,109,109,228,228,228,228,229,229,229,229,  0,230, 86,  0,\n+    0,  0,230,  7, 82,138,  7,  0,  0,  0,231, 86,232,232,232,232,\n+  233,233,233,233,234,234,234,234,235,235,235,235,236,236,236,236,\n+  237,237,237,237,238,238,238,238,239,  0,  0,  0,  0,  0,  0,  0,\n+    0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,  0,  0,  0, 19,  0,\n+   19,  0,  0,  0,  0,  0, 26, 26,  1,  1,  1,  1,  9,  9,  9,  9,\n+    0,  9,  9,  9,  9,  9,  0,  9,  9,  0,  9,  0,  9,  9, 55, 55,\n+   55, 55, 55, 55,  6,  6,  6,  6,  6,  1,  1,  6,  6,  4,  4,  4,\n+    4,  4,  4,  4,  4, 14, 14, 14, 14, 14, 14, 14,  3,  3,  3,  3,\n+    3,  0,  3,  3,  0,  3,  3,  3,  3,  3,  3,  0,  3,  3,  3,  1,\n+    1,  1,  3,  3,  1,  3,  3,  3, 37, 37, 37, 37, 38, 38, 38, 38,\n+   64, 64, 64, 64, 90, 90, 90, 90, 95, 95, 95, 95,  3,  3,  0,  3,\n+    7,  7,  7,  7,  7,  1,  1,  1,  1,  7,  7,  7,  0,  0,  7,  7,\n+    5,  5,  5,  5, 11, 11, 11, 11, 10, 10, 10, 10, 21, 21, 21, 21,\n+   22, 22, 22, 22, 23, 23, 23, 23, 16, 16, 16, 16, 20, 20, 20, 20,\n+   36, 36, 36, 36, 24, 24, 24, 24, 24, 24, 24,  0, 18, 18, 18, 18,\n+   25, 25, 25, 25, 25,  0,  0,  0,  0, 25, 25, 25, 33, 33, 33, 33,\n+    8,  8,  8,  8,  8,  8,  8,  0, 12, 12, 12, 12, 30, 30, 30, 30,\n+   29, 29, 29, 29, 28, 28, 28, 28, 34, 34, 34, 34, 35, 35, 35, 35,\n+   35, 35, 35,  0,  0,  0, 35, 35, 45, 45, 45, 45, 44, 44, 44, 44,\n+   44,  0,  0,  0, 43, 43, 43, 43, 46, 46, 46, 46, 31, 31, 31, 31,\n+   32, 32,  0,  0, 32,  0, 32, 32, 32, 32, 32, 32, 48, 48, 48, 48,\n+   52, 52, 52, 52, 58, 58, 58, 58, 54, 54, 54, 54, 91, 91, 91, 91,\n+   62, 62, 62, 62, 76, 76, 76, 76, 93, 93, 93, 93, 70, 70, 70, 70,\n+   73, 73, 73, 73,  1,  1,  1,  0,  1,  0,  1,  1,  1,  0,  0,  0,\n+    0,  1,  0,  0,  1,  1,  0,  0, 19, 19,  9,  9,  9,  9,  9,  6,\n+   19,  9,  9,  9,  9,  9, 19, 19,  9,  9,  9, 19,  6, 19, 19, 19,\n+   19, 19, 19,  9,  0,  0,  0, 19,  0,  0,  9,  0,  0,  0, 19, 19,\n+   27, 27, 27, 27, 56, 56, 56, 56, 61, 61, 61, 61, 13, 13, 13, 13,\n+    0, 13,  0, 13,  0, 13, 13, 13, 13, 13,  1,  1,  1,  1, 12, 12,\n+    0, 15, 15, 15, 15, 15, 15, 15, 15,  1,  1,  0,  0, 17, 17, 17,\n+   17, 17, 17, 17, 17, 17, 17,  0, 26, 26, 26, 26, 26, 12, 12, 12,\n+   12, 12, 12,  0, 39, 39, 39, 39, 86, 86, 86, 86, 77, 77, 77, 77,\n+   79, 79, 79, 79, 60, 60, 60, 60, 65, 65, 65, 65, 75, 75, 75, 75,\n+   69, 69, 69, 69, 69, 69,  0, 69, 74, 74, 74, 74, 84, 84, 84, 84,\n+   84, 84, 84,  0, 68, 68, 68, 68, 92, 92, 92, 92, 87, 87, 87, 87,\n+   19,  9, 19, 19, 19, 19,  0,  0,  2,  2,  2,  2, 19, 19, 19,  4,\n+    3,  3,  0,  0,  1,  1,  6,  6,  0,  0, 17, 17, 17, 17,  0,  0,\n+   49, 49, 49, 49,  0,  1,  1,  1, 71, 71, 71, 71, 67, 67, 67, 67,\n+   42, 42, 42, 42, 41, 41, 41, 41,118,118,118,118, 53, 53, 53, 53,\n+   59, 59, 59, 59, 40, 40, 40, 40, 51, 51, 51, 51, 50, 50, 50, 50,\n+  135,135,135,135,106,106,106,106,104,104,104,104,161,161,161,161,\n+  110,110,110,110, 47, 47, 47, 47, 81, 81, 81, 81,120,120,120,120,\n+  116,116,116,116,128,128,128,128, 66, 66, 66, 66, 72, 72, 72, 72,\n+   98, 98, 98, 98, 97, 97, 97, 97, 57, 57, 57, 57, 88, 88, 88, 88,\n+  117,117,117,117,112,112,112,112, 78, 78, 78, 78, 83, 83, 83, 83,\n+   82, 82, 82, 82,122,122,122,122, 89, 89, 89, 89,130,130,130,130,\n+  144,144,144,144,156,156,156,156,156,  3,  3,  3,147,147,147,147,\n+  148,148,148,148,158,158,158,158,153,153,153,153,149,149,149,149,\n+   94, 94, 94, 94, 85, 85, 85, 85,101,101,101,101, 96, 96, 96, 96,\n+  111,111,111,111,100,100,100,100,100, 36, 36, 36,108,108,108,108,\n+  129,129,129,129,109,109,109,109,107,107,107,107,107,107,107,  1,\n+  137,137,137,137,124,124,124,124,123,123,123,123,114,114,114,114,\n+  102,102,102,102,126,126,126,126,142,142,142,142,125,125,125,125,\n+  154,154,154,154,150,150,150,150,141,141,141,141,140,140,140,140,\n+  121,121,121,121,133,133,133,133,134,134,134,134,138,138,138,138,\n+  143,143,143,143,145,145,145,145,163,163,163,163, 63, 63, 63, 63,\n+  157,157,157,157, 80, 80, 80, 80,127,127,127,127,115,115,115,115,\n+  159,159,159,159,103,103,103,103,119,119,119,119,146,146,146,146,\n+   99, 99, 99, 99,136,139, 13, 13,155,155,155,155,136,136,136,136,\n+   17, 15, 15, 15, 17, 17, 15, 15, 15, 17, 17, 17,139,139,139,139,\n+  105,105,105,105,  0,  0,  0,  1,  0,  0,  1,  1,131,131,131,131,\n+  151,151,151,151,160,160,160,160,152,152,152,152,164,164,164,164,\n+  113,113,113,113,132,132,132,132, 15,  0,  0,  0,  0,  1,  2,  3,\n+    4,  5,  6,  7,  8,  9,  9,  9,  9, 10,  9, 11, 12, 13,  9,  9,\n+    9, 14,  9,  9, 15,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n@@ -6467,2 +5206,2 @@\n-   16, 17,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 18, 19, 20,  9,\n-   21,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9, 16, 17,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9, 18, 19, 20,  9, 21,  9,  9,  9,  9,  9,  9,  9,\n@@ -6473,1 +5212,0 @@\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 22,  9,  9,  9,\n@@ -6475,0 +5213,1 @@\n+    9,  9,  9,  9, 22,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n@@ -6483,7 +5222,8 @@\n-   23, 24,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,\n-    3,  4,  5,  6,  7,  8,  9, 10, 11, 12,  0,  0, 13, 14, 15, 16,\n-   17, 18, 19, 20, 21, 22,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 23,  0,  0, 24, 25, 26, 27, 28, 29, 30,\n-    0,  0, 31, 32,  0, 33,  0, 34,  0, 35,  0,  0,  0,  0, 36, 37,\n-   38, 39,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0, 40,  0,  0,  0,  0,  0,  0,  0,  0,  0, 41, 42,\n+    9,  9,  9,  9,  9,  9,  9,  9, 23, 24,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10,\n+   11, 12,  0,  0, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 23,  0,\n+    0, 24, 25, 26, 27, 28, 29, 30,  0,  0, 31, 32,  0, 33,  0, 34,\n+    0, 35,  0,  0,  0,  0, 36, 37, 38, 39,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 40,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0, 41, 42,  0,  0,  0,  0,  0,  0,  0,  0,\n@@ -6491,0 +5231,8 @@\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43, 44,  0, 45,\n+    0,  0,  0,  0,  0,  0, 46, 47,  0,  0,  0,  0,  0, 48,  0, 49,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 50, 51,\n+    0,  0,  0, 52,  0,  0, 53,  0,  0,  0,  0,  0,  0,  0, 54,  0,\n+    0,  0,  0,  0,  0,  0, 55,  0,  0,  0,  0,  0,  0,  0, 56,  0,\n+    0,  0,  0,  0,  0,  0,  0, 57,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 58, 59,\n+   60, 61, 62, 63, 64, 65,  0,  0,  0,  0,  0,  0, 66,  0,  0,  0,\n@@ -6492,5 +5240,0 @@\n-    0,  0,  0,  0, 43, 44,  0, 45,  0,  0,  0,  0,  0,  0, 46, 47,\n-    0,  0,  0,  0,  0, 48,  0, 49,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 50, 51,  0,  0,  0, 52,  0,  0, 53,  0,\n-    0,  0,  0,  0,  0,  0, 54,  0,  0,  0,  0,  0,  0,  0, 55,  0,\n-    0,  0,  0,  0,  0,  0, 56,  0,  0,  0,  0,  0,  0,  0,  0, 57,\n@@ -6498,2 +5241,0 @@\n-    0,  0,  0,  0,  0,  0, 58, 59, 60, 61, 62, 63, 64, 65,  0,  0,\n-    0,  0,  0,  0, 66,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n@@ -6502,0 +5243,7 @@\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 67, 68,  0, 69, 70,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 71, 72, 73, 74, 75, 76,\n+   77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92,\n+   93, 94, 95, 96, 97, 98, 99,100,101,102,103,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,104,  0,  0,  0,\n+    0,  0,  0,105,106,  0,107,  0,  0,  0,108,  0,109,  0,110,  0,\n+  111,112,113,  0,114,  0,  0,  0,115,  0,  0,  0,116,  0,  0,  0,\n@@ -6503,0 +5251,3 @@\n+    0,  0,  0,  0,  0,  0,  0,117,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,118,119,\n+  120,121,  0,122,123,124,125,126,  0,127,  0,  0,  0,  0,  0,  0,\n@@ -6504,8 +5255,3 @@\n-    0,  0, 67, 68,  0, 69, 70,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,\n-   85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,\n-  101,102,103,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,104,  0,  0,  0,  0,  0,  0,105,106,  0,107,  0,\n-    0,  0,108,  0,109,  0,110,  0,111,112,113,  0,114,  0,  0,  0,\n-  115,  0,  0,  0,116,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,117,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,128,129,130,131,132,133,\n+  134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,\n+  150,151,152,153,154,155,156,157,  0,  0,  0,158,159,160,161,  0,\n@@ -6513,2 +5259,1 @@\n-    0,  0,  0,  0,  0,  0,118,119,120,121,  0,122,123,124,125,126,\n-    0,127,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,162,163,  0,  0,  0,  0,  0,  0,  0,164,  0,  0,  0,\n@@ -6516,5 +5261,1 @@\n-    0,  0,128,129,130,131,132,133,134,135,136,137,138,139,140,141,\n-  142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,\n-    0,  0,  0,158,159,160,161,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,162,163,  0,  0,  0,\n-    0,  0,  0,  0,164,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,165,  0,\n@@ -6522,3 +5263,3 @@\n-    0,  0,  0,  0,  0,  0,165,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,166,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,167,  0,  0,\n+    0,  0,  0,  0,  0,166,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,167,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,168,  0,  0,\n@@ -6526,1 +5267,4 @@\n-    0,  0,  0,  0,  0,168,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,169,\n+  170,  0,  0,  0,  0,171,172,  0,  0,  0,173,174,175,176,177,178,\n+  179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,\n+  195,196,197,198,199,200,201,202,203,204,205,206,  0,  0,  0,  0,\n@@ -6528,6 +5272,1 @@\n-    0,  0,  0,  0,  0,  0,  0,169,170,  0,  0,  0,  0,171,172,  0,\n-    0,  0,173,174,175,176,177,178,179,180,181,182,183,184,185,186,\n-  187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,\n-  203,204,205,206,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,\n-    3,  4,\n+    0,  0,  0,  0,  0,  0,  1,  2,  3,  4,\n@@ -6536,1 +5275,1 @@\n-_hb_ucd_u16[4888] =\n+_hb_ucd_u16[4920] =\n@@ -6603,1 +5342,1 @@\n-   145, 145, 145, 145, 145, 145, 145, 145,  47,  47, 369,  47,  47,  47,  47,  47,\n+   145, 145, 145, 145, 145, 145, 145, 145,  47,  47, 369,  47,  47,  47,  47, 143,\n@@ -6607,1 +5346,1 @@\n-    47,  47, 389, 390,  32,  32,  32,  32,  47,  47, 365,  47,  47, 391, 172, 160,\n+    47,  47, 389, 390, 359,  32,  32,  32,  47,  47, 365,  47,  47, 391, 172, 160,\n@@ -6614,22 +5353,24 @@\n-   421, 422,  66,  47,  47,  47,  47,  47,  47,  47, 400, 423, 424, 128, 145, 425,\n-    47, 156, 426, 427,  32,  32,  32,  32,  47,  47,  47, 359, 428, 160,  47,  47,\n-   429, 430, 160, 160, 160, 160, 160, 160,  47,  47,  47,  47,  47,  47,  47, 431,\n-    47,  47,  47,  47, 145, 432, 433, 434, 219, 219, 219, 219, 219, 219, 219,  66,\n-    47,  47,  47,  47,  47,  47,  47, 424,  47,  47,  47, 208, 208, 208, 208, 208,\n-    47,  47,  47,  47,  47,  47, 305,  47,  47,  47,  47,  47, 160,  47,  47, 435,\n-    47,  47,  47, 436, 437, 438, 439,  47,   9,   9,   9,   9,   9,   9,  11,  11,\n-   145, 440,  66,  66,  66,  66,  66,  66,  47,  47,  47,  47, 391, 441, 416, 416,\n-   442, 443,  27,  27,  27,  27, 444, 416,  47, 445, 208, 208, 208, 208, 208, 208,\n-    32,  32,  32,  32,  32, 146, 146, 146, 146, 146, 146, 146, 146, 146, 446, 447,\n-   448, 146, 449, 146, 146, 146, 146, 146, 146, 146, 146, 146, 450, 146, 146, 146,\n-     9, 451,  11, 452, 453,  11, 196,   9, 454, 455,   9, 456,  11,   9, 451,  11,\n-   452, 453,  11, 196,   9, 454, 455,   9, 456,  11,   9, 451,  11, 452, 453,  11,\n-   196,   9, 454, 455,   9, 456,  11,   9, 451,  11, 196,   9, 457, 458, 459, 460,\n-    11, 461,   9, 462, 463, 464, 465,  11, 466,   9, 467,  11, 468, 160, 160, 160,\n-    32,  32,  32, 469,  32,  32, 470, 471, 472, 473,  32,  32,  32,  32,  32,  32,\n-   474,  11,  11,  11,  11,  11,  11,  11,  32,  32,  32,  32,  32,  32,  32,  32,\n-    47,  47,  47, 475, 476, 146, 146, 146,  47,  47, 477,  32,  47,  47, 478, 479,\n-    47,  47,  47,  47, 355,  32,  32,  32,   9,   9, 454,  11, 480, 305,  66,  66,\n-   145, 145, 481, 482, 145, 145, 145, 145, 145, 145, 483, 145, 145, 145, 145, 145,\n-    47,  47,  47,  47,  47,  47,  47, 226, 484, 146, 146, 146, 146, 146, 146, 146,\n-   146, 146, 146, 146, 146, 146, 146, 485, 146, 146, 146, 146, 146, 146, 146, 160,\n+   421, 422,  66,  47,  47,  47,  47,  47,  66,  66,  66,  66,  66,  66,  66,  66,\n+    47,  47, 400, 423, 424, 128, 145, 425,  47, 156, 426, 427,  32,  32,  32,  32,\n+    47,  47,  47, 359, 428, 160,  47,  47, 429, 430, 160, 160, 160, 160, 160, 160,\n+    47,  47,  47,  47,  47,  47,  47, 431, 432,  47,  47, 433, 434, 160, 160, 160,\n+    47,  47,  47,  47, 145, 435, 436, 437, 219, 219, 219, 219, 219, 219, 219,  66,\n+    47,  47,  47,  47,  47,  47,  47, 424,  47,  47,  47, 208, 438,  32,  32,  32,\n+    47,  47,  47,  47,  47,  47, 305,  47,  47,  47,  47,  47, 160,  47,  47, 439,\n+    47,  47,  47, 440, 441, 442, 443,  47,   9,   9,   9,   9,   9,   9,  11,  11,\n+   145, 444,  66,  66,  66,  66,  66,  66,  47,  47,  47,  47, 391, 445, 416, 416,\n+   446, 447,  27,  27,  27,  27, 448, 416,  47, 449, 208, 208, 208, 208, 208, 208,\n+    32,  32,  32,  32,  32, 146, 146, 146, 146, 146, 146, 146, 146, 146, 450, 451,\n+   452, 146, 453, 146, 146, 146, 146, 146, 146, 146, 146, 146, 454, 146, 146, 146,\n+     9, 455,  11, 456, 457,  11, 196,   9, 458, 459,   9, 460,  11,   9, 455,  11,\n+   456, 457,  11, 196,   9, 458, 459,   9, 460,  11,   9, 455,  11, 456, 457,  11,\n+   196,   9, 458, 459,   9, 460,  11,   9, 455,  11, 196,   9, 461, 462, 463, 464,\n+    11, 465,   9, 466, 467, 468, 469,  11, 470,   9, 471,  11, 472, 160, 160, 160,\n+    32,  32,  32, 473,  32,  32, 474, 475, 476, 477,  32,  32,  32,  32,  32,  32,\n+   478,  11,  11,  11,  11,  11,  11,  11,  32,  32,  32,  27,  27,  27,  27,  27,\n+    32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  47, 479, 480, 146, 146, 146,\n+    47,  47, 481,  32,  47,  47, 482, 483,  47,  47,  47,  47,  47,  47, 484, 160,\n+    47,  47,  47,  47, 355,  32,  32,  32,   9,   9, 458,  11, 485, 305,  66,  66,\n+   145, 145, 486, 487, 145, 145, 145, 145, 145, 145, 488, 145, 145, 145, 145, 145,\n+    47,  47,  47,  47,  47,  47,  47, 226, 489, 146, 146, 146, 146, 146, 146, 146,\n+   146, 146, 146, 146, 146, 146, 146, 490, 146, 146, 146, 146, 146, 146, 146, 160,\n@@ -6846,1 +5587,1 @@\n-_hb_ucd_i16[196] =\n+_hb_ucd_i16[92] =\n@@ -6848,13 +5589,6 @@\n-      0,    0,    0,    0,    1,   -1,    0,    0,    2,    0,   -2,    0,    0,    0,    0,    2,\n-      0,   -2,    0,    0,    0,    0,    0,   16,    0,    0,    0,  -16,    0,    0,    1,   -1,\n-      0,    0,    0,    1,   -1,    0,    0,    0,    0,    1,   -1,    0,    3,    3,    3,   -3,\n-     -3,   -3,    0,    0,    0, 2016,    0,    0,    0,    0,    0, 2527, 1923, 1914, 1918,    0,\n-   2250,    0,    0,    0,    0,    0,    0,  138,    0,    7,    0,    0,   -7,    0,    0,    0,\n-      1,   -1,    1,   -1,   -1,    1,   -1,    0, 1824,    0,    0,    0,    0,    0, 2104,    0,\n-   2108, 2106,    0, 2106, 1316,    0,    0,    0,    0,    1,   -1,    1,   -1, -138,    0,    0,\n-      1,   -1,    8,    8,    8,    0,    7,    7,    0,    0,   -8,   -8,   -8,   -7,   -7,    0,\n-      1,   -1,    0,    2,-1316,    1,   -1,    0,   -1,    1,   -1,    1,   -1,    3,    1,   -1,\n-     -3,    1,   -1,    1,   -1,    0,    0,-1914,-1918,    0,    0,-1923,-1824,    0,    0,    0,\n-      0,-2016,    0,    0,    1,   -1,    0,    1,    0,    0,-2104,    0,    0,    0,    0,-2106,\n-  -2108,-2106,    0,    0,    1,   -1,-2250,    0,    0,    0,-2527,    0,    0,   -2,    0,    1,\n-     -1,    0,    1,   -1,\n+      0,    0,    1,   -1,    2,    0,   -2,    0,    0,    2,    0,   -2,    0,   16,    0,  -16,\n+      0,    1,   -1,    0,    3,    3,    3,   -3,   -3,   -3,    0, 2016,    0, 2527, 1923, 1914,\n+   1918,    0, 2250,    0,    0,  138,    0,    7,   -7,    0,   -1,    1, 1824,    0, 2104,    0,\n+   2108, 2106,    0, 2106, 1316,    0,   -1, -138,    8,    8,    8,    0,    7,    7,   -8,   -8,\n+     -8,   -7,-1316,    1,   -1,    3,   -3,    1,    0,-1914,-1918,    0,    0,-1923,-1824,    0,\n+      0,-2016,-2104,    0,    0,-2106,-2108,-2106,-2250,    0,-2527,    0,\n@@ -6866,1 +5600,1 @@\n-  return u<1114112u?_hb_ucd_u8[5056+(((_hb_ucd_u8[1168+(((_hb_ucd_u16[((_hb_ucd_u8[544+(((_hb_ucd_u8[u>>1>>3>>3>>4])<<4)+((u>>1>>3>>3)&15u))])<<3)+((u>>1>>3)&7u)])<<3)+((u>>1)&7u))])<<1)+((u)&1u))]:2;\n+  return u<1114112u?_hb_ucd_u8[5080+(((_hb_ucd_u8[1152+(((_hb_ucd_u16[((_hb_ucd_u8[544+(((_hb_ucd_u8[u>>1>>3>>3>>4])<<4)+((u>>1>>3>>3)&15u))])<<3)+((u>>1>>3)&7u)])<<3)+((u>>1)&7u))])<<1)+((u)&1u))]:2;\n@@ -6871,1 +5605,1 @@\n-  return u<125259u?_hb_ucd_u8[6970+(((_hb_ucd_u8[6426+(((_hb_ucd_u8[5982+(((_hb_ucd_u8[5646+(((_hb_ucd_u8[5400+(u>>2>>2>>2>>3)])<<3)+((u>>2>>2>>2)&7u))])<<2)+((u>>2>>2)&3u))])<<2)+((u>>2)&3u))])<<2)+((u)&3u))]:0;\n+  return u<125259u?_hb_ucd_u8[7038+(((_hb_ucd_u8[6482+(((_hb_ucd_u8[6022+(((_hb_ucd_u8[5670+(((_hb_ucd_u8[5424+(u>>2>>2>>2>>3)])<<3)+((u>>2>>2>>2)&7u))])<<2)+((u>>2>>2)&3u))])<<2)+((u>>2)&3u))])<<2)+((u)&3u))]:0;\n@@ -6881,1 +5615,1 @@\n-  return u<65380u?_hb_ucd_i16[((_hb_ucd_u8[7714+(((_hb_ucd_u8[7594+(((_hb_ucd_b4(7466+_hb_ucd_u8,u>>2>>3>>3))<<3)+((u>>2>>3)&7u))])<<3)+((u>>2)&7u))])<<2)+((u)&3u)]:0;\n+  return u<65380u?_hb_ucd_i16[((_hb_ucd_u8[7930+(((_hb_ucd_u8[7698+(((_hb_ucd_u8[7602+(((_hb_ucd_b4(7538+_hb_ucd_u8,u>>1>>2>>3>>3))<<3)+((u>>1>>2>>3)&7u))])<<3)+((u>>1>>2)&7u))])<<2)+((u>>1)&3u))])<<1)+((u)&1u)]:0;\n@@ -6886,1 +5620,1 @@\n-  return u<918016u?_hb_ucd_u8[11480+(((_hb_ucd_u8[10532+(((_hb_ucd_u8[9124+(((_hb_ucd_u8[8500+(((_hb_ucd_u8[8050+(u>>2>>2>>3>>4)])<<4)+((u>>2>>2>>3)&15u))])<<3)+((u>>2>>2)&7u))])<<2)+((u>>2)&3u))])<<2)+((u)&3u))]:2;\n+  return u<918016u?_hb_ucd_u8[11228+(((_hb_ucd_u8[10264+(((_hb_ucd_u8[9276+(((_hb_ucd_u8[8596+(((_hb_ucd_u8[8292+(((_hb_ucd_u8[8178+(u>>2>>2>>2>>3>>4)])<<4)+((u>>2>>2>>2>>3)&15u))])<<3)+((u>>2>>2>>2)&7u))])<<2)+((u>>2>>2)&3u))])<<2)+((u>>2)&3u))])<<2)+((u)&3u))]:2;\n@@ -6891,1 +5625,1 @@\n-  return u<195102u?_hb_ucd_u16[1576+(((_hb_ucd_u8[12802+(((_hb_ucd_u8[12420+(u>>4>>5)])<<5)+((u>>4)&31u))])<<4)+((u)&15u))]:0;\n+  return u<195102u?_hb_ucd_u16[1608+(((_hb_ucd_u8[12570+(((_hb_ucd_u8[12188+(u>>4>>5)])<<5)+((u>>4)&31u))])<<4)+((u)&15u))]:0;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ucd-table.hh","additions":3149,"deletions":4415,"binary":false,"changes":7564,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+  \/\/ Hangul is handled algorithmically.\n@@ -138,0 +139,3 @@\n+    \/* If \"a\" is small enough and \"b\" is in the U+0300 range,\n+     * the composition data is encoded in a 32bit array sorted\n+     * by \"a,b\" pair. *\/\n@@ -149,0 +153,2 @@\n+    \/* Otherwise it is stored in a 64bit array sorted by\n+     * \"a,b\" pair. *\/\n@@ -173,0 +179,1 @@\n+  \/* If no data, there's no decomposition. *\/\n@@ -176,0 +183,1 @@\n+  \/* Check if it's a single-character decomposition. *\/\n@@ -178,0 +186,1 @@\n+    \/* Single-character decompositions currently are only in plane 0 or plane 2. *\/\n@@ -179,0 +188,2 @@\n+    {\n+      \/* Plane 0. *\/\n@@ -180,0 +191,1 @@\n+    }\n@@ -182,0 +194,1 @@\n+      \/* Plane 2. *\/\n@@ -190,0 +203,1 @@\n+  \/* Otherwise they are encoded either in a 32bit array or a 64bit array. *\/\n@@ -192,0 +206,1 @@\n+    \/* 32bit array. *\/\n@@ -199,0 +214,1 @@\n+  \/* 64bit array. *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ucd.cc","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -9,3 +9,3 @@\n- * # emoji-data-14.0.0.txt\n- * # Date: 2021-08-26, 17:22:22 GMT\n- * # © 2021 Unicode®, Inc.\n+ * # emoji-data.txt\n+ * # Date: 2022-08-02, 00:26:10 GMT\n+ * # © 2022 Unicode®, Inc.\n@@ -13,1 +13,1 @@\n- * # For terms of use, see http:\/\/www.unicode.org\/terms_of_use.html\n+ * # For terms of use, see https:\/\/www.unicode.org\/terms_of_use.html\n@@ -16,1 +16,1 @@\n- * # Used with Emoji Version 14.0 and subsequent minor revisions (if any)\n+ * # Used with Emoji Version 15.0 and subsequent minor revisions (if any)\n@@ -18,1 +18,1 @@\n- * # For documentation and usage, see http:\/\/www.unicode.org\/reports\/tr51\n+ * # For documentation and usage, see https:\/\/www.unicode.org\/reports\/tr51\n@@ -27,1 +27,1 @@\n-_hb_emoji_u8[544] =\n+_hb_emoji_u8[464] =\n@@ -33,30 +33,25 @@\n-    0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    2,  3,  0,  0,  4,  0,  5,  0,  0,  0,  0,  0,  6,  0,  7,  8,\n-    0,  0,  0,  9,  0,  0, 10, 11, 12, 13, 14, 13, 15, 16, 17,  0,\n-    0,  0,  0,  0, 18,  0,  0,  0,  0,  0,  0,  0, 19, 20,  0,  0,\n-   21,  0,  0,  0,  0,  0,  0,  0,  0,  0, 22,  0,  0,  0,  0,  0,\n-   13, 13, 13, 13, 23, 24, 25, 26, 27, 28, 13, 13, 13, 13, 13, 29,\n-   13, 13, 13, 13, 30, 31, 13, 13, 13, 32, 13, 13,  0, 33,  0, 34,\n-   35, 36, 37, 13, 38, 39, 13, 13, 13, 13, 13, 13,  0,  0,  0,  0,\n-   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 30,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 66,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 16,  0,  2,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  4,  0,  0,  2,  0,  0,240,  3,  0,  6,  0,  0,\n-    0,  0,  0, 12,  0,  1,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,\n-    0,128,  0,  0,  0,254, 15,  7,  4,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0, 12, 64,  0,  1,  0,  0,  0,  0,  0,  0,120,\n-  191,255,247,255,255,255,255,255,255,255,255,255,255,255,255,255,\n-   63,  0,255,255,255,255,255,255, 63,255, 87, 32,  2,  1, 24,  0,\n-  144, 80,184,  0,248,  0,  0,  0,  0,  0,224,  0,  2,  0,  1,128,\n-    0,  0,  0,  0,  0,  0, 48,  0,224,  0,  0, 24,  0,  0,  0,  0,\n-    0,  0, 33,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1, 32,\n-    0,  0,128,  2,  0,  0,  0,  0,  0,224,  0,  0,  0,128,  0,  0,\n-    0,  0,  0,  0,  0,240,  3,192,  0, 64,254,  7,  0,224,255,255,\n-  255,255,255,255, 63,  0,  0,  0,254,255,  0,  4,  0,128,252,247,\n-    0,254,255,255,255,255,255,255,255,255,255,255,255,255,255,  7,\n-  255,255,255,255,255,255,255, 63,192,255,255,255,255,255,255,255,\n-  255,255,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,240,255,\n-    0,  0,224,255,255,255,255,255,  0,240,  0,  0,  0,  0,  0,  0,\n-    0,255,  0,252,  0,  0,  0,  0,  0,255,  0,  0,  0,192,255,255,\n-    0,240,255,255,255,255,255,247,191,255,255,255,255,255,255,255,\n+    0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    2,  0,  3,  4,  0,  0,  5,  6,  0,  7,  0,  8,  9, 10, 11, 12,\n+    0,  0, 13,  0,  0,  0, 14,  0, 15,  0,  0,  0,  0, 16,  0,  0,\n+   17, 17, 18, 19, 20, 17, 17, 21, 17, 17, 22, 17, 23, 17, 24, 25,\n+   26, 27, 28, 17, 17, 17,  0,  0, 17, 17, 17, 17, 17, 17, 17, 29,\n+    0,  0,  0,  0,  0,  1,  0,  0,  0,  2,  3,  0,  0,  4,  0,  0,\n+    5,  6,  0,  0,  7,  8,  0,  0,  8,  0,  9, 10,  0,  0, 11,  0,\n+    0, 12, 13, 14, 15, 16, 16, 16, 17, 16, 16, 16, 18, 19, 20, 21,\n+   22, 23,  0,  0,  0, 24,  0,  0, 25,  0, 26,  0,  0, 27,  0,  0,\n+   28,  0,  0,  0, 16, 16, 16, 16, 29,  9,  0, 30, 31, 32, 16, 33,\n+   34, 35, 36, 16, 16, 16, 16, 37, 16, 38, 39, 16, 16, 16, 40,  0,\n+    0,  0,  0, 41,  0,  0, 42, 16, 43,  0, 44,  0, 45, 46, 16, 16,\n+   47, 48, 49, 16, 16, 16, 16, 38,  0,  0,  0,  0,  0, 66,  0,  0,\n+    0,  0,  0, 16,  0,  2,  0,  0,  4,  0,  0,  2,  0,  0,240,  3,\n+    0,  6,  0,  0,  0,  0,  0, 12,  0,  1,  0,  0,  0,128,  0,  0,\n+    0,254, 15,  7,  4,  0,  0,  0,  0, 12, 64,  0,  1,  0,  0,  0,\n+    0,  0,  0,120,191,255,247,255,255,255,255,255, 63,  0,255,255,\n+   63,255, 87, 32,  2,  1, 24,  0,144, 80,184,  0,248,  0,  0,  0,\n+    0,  0,224,  0,  2,  0,  1,128,  0,  0, 48,  0,224,  0,  0, 24,\n+    0,  0, 33,  0,  0,  0,  1, 32,  0,  0,128,  2,  0,224,  0,  0,\n+    0,240,  3,192,  0, 64,254,  7,  0,224,255,255, 63,  0,  0,  0,\n+  254,255,  0,  4,  0,128,252,247,  0,254,255,255,255,255,255,  7,\n+  255,255,255, 63,192,255,255,255,255,255,  0,  0,  0,  0,240,255,\n+    0,  0,224,255,  0,240,  0,  0,  0,255,  0,252,  0,255,  0,  0,\n+    0,192,255,255,  0,240,255,255,255,255,255,247,191,255,255,255,\n@@ -78,1 +73,1 @@\n-  return u<131070u?_hb_emoji_b1(224+_hb_emoji_u8,((_hb_emoji_u8[64+(((_hb_emoji_b4(_hb_emoji_u8,u>>6>>4))<<4)+((u>>6)&15u))])<<6)+((u)&63u)):0;\n+  return u<131070u?_hb_emoji_b1(264+_hb_emoji_u8,((_hb_emoji_u8[144+(((_hb_emoji_u8[64+(((_hb_emoji_b4(_hb_emoji_u8,u>>5>>2>>3))<<3)+((u>>5>>2)&7u))])<<2)+((u>>5)&3u))])<<5)+((u)&31u)):0;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-unicode-emoji-table.hh","additions":33,"deletions":38,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-#error \"Consider building hb-ucd.cc.  If you absolutely want to build without any, check the code.\"\n+#error \"Consider building hb-ucd.cc.  If you absolutely want to build without any, define HB_NO_UNICODE_FUNCS.\"\n@@ -284,1 +284,1 @@\n- * Return value: %true if success, %false otherwise\n+ * Return value: `true` if success, `false` otherwise\n@@ -311,2 +311,2 @@\n-hb_unicode_funcs_get_user_data (hb_unicode_funcs_t *ufuncs,\n-                                hb_user_data_key_t *key)\n+hb_unicode_funcs_get_user_data (const hb_unicode_funcs_t *ufuncs,\n+                                hb_user_data_key_t       *key)\n@@ -343,1 +343,1 @@\n- * Return value: %true if @ufuncs is immutable, %false otherwise\n+ * Return value: `true` if @ufuncs is immutable, `false` otherwise\n@@ -380,1 +380,9 @@\n-    return;                                                                     \\\n+    goto fail;                                                                  \\\n+                                                                                \\\n+  if (!func)                                                                    \\\n+  {                                                                             \\\n+    if (destroy)                                                                \\\n+      destroy (user_data);                                                      \\\n+    destroy = nullptr;                                                          \\\n+    user_data = ufuncs->parent->user_data.name;                                 \\\n+  }                                                                             \\\n@@ -385,1 +393,1 @@\n-  if (func) {                                                                   \\\n+  if (func)                                                                     \\\n@@ -387,3 +395,1 @@\n-    ufuncs->user_data.name = user_data;                                         \\\n-    ufuncs->destroy.name = destroy;                                             \\\n-  } else {                                                                      \\\n+  else                                                                          \\\n@@ -391,3 +397,7 @@\n-    ufuncs->user_data.name = ufuncs->parent->user_data.name;                    \\\n-    ufuncs->destroy.name = nullptr;                                             \\\n-  }                                                                             \\\n+  ufuncs->user_data.name = user_data;                                           \\\n+  ufuncs->destroy.name = destroy;                                               \\\n+  return;                                                                       \\\n+                                                                                \\\n+fail:                                                                           \\\n+  if (destroy)                                                                  \\\n+    destroy (user_data);                                                        \\\n@@ -424,1 +434,1 @@\n- * Return value: %true if @a and @b composed, %false otherwise\n+ * Return value: `true` if @a and @b composed, `false` otherwise\n@@ -449,1 +459,1 @@\n- * Return value: %true if @ab was decomposed, %false otherwise\n+ * Return value: `true` if @ab was decomposed, `false` otherwise\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-unicode.cc","additions":25,"deletions":15,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -320,2 +320,2 @@\n-hb_unicode_funcs_get_user_data (hb_unicode_funcs_t *ufuncs,\n-                                hb_user_data_key_t *key);\n+hb_unicode_funcs_get_user_data (const hb_unicode_funcs_t *ufuncs,\n+                                hb_user_data_key_t       *key);\n@@ -432,1 +432,1 @@\n- * Return value: %true is @a,@b composed, %false otherwise\n+ * Return value: `true` is @a,@b composed, `false` otherwise\n@@ -456,1 +456,1 @@\n- * Return value: %true if @ab decomposed, %false otherwise\n+ * Return value: `true` if @ab decomposed, `false` otherwise\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-unicode.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+  static constexpr unsigned max_len = 4;\n@@ -185,0 +186,1 @@\n+  static constexpr unsigned max_len = 2;\n@@ -293,0 +295,1 @@\n+  static constexpr unsigned max_len = 1;\n@@ -351,0 +354,1 @@\n+  static constexpr unsigned max_len = 1;\n@@ -402,0 +406,1 @@\n+  static constexpr unsigned max_len = 1;\n@@ -407,1 +412,1 @@\n-        hb_codepoint_t replacement HB_UNUSED)\n+        hb_codepoint_t replacement)\n@@ -453,0 +458,23 @@\n+template <typename utf_t>\n+static inline const typename utf_t::codepoint_t *\n+hb_utf_offset_to_pointer (const typename utf_t::codepoint_t *start,\n+                          signed offset)\n+{\n+  hb_codepoint_t unicode;\n+\n+  while (offset-- > 0)\n+    start = utf_t::next (start,\n+                         start + utf_t::max_len,\n+                         &unicode,\n+                         HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT);\n+\n+  while (offset++ < 0)\n+    start = utf_t::prev (start,\n+                         start - utf_t::max_len,\n+                         &unicode,\n+                         HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT);\n+\n+  return start;\n+}\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-utf.hh","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-struct hb_vector_t : std::conditional<sorted, hb_vector_t<Type, false>, hb_empty_t>::type\n+struct hb_vector_t\n@@ -46,1 +46,0 @@\n-  hb_vector_t (std::nullptr_t) : hb_vector_t () {}\n@@ -49,1 +48,1 @@\n-    alloc (lst.size ());\n+    alloc (lst.size (), true);\n@@ -57,3 +56,4 @@\n-    if (hb_iter (o).is_random_access_iterator)\n-      alloc (hb_len (hb_iter (o)));\n-    hb_copy (o, *this);\n+    auto iter = hb_iter (o);\n+    if (iter.is_random_access_iterator)\n+      alloc (hb_len (iter), true);\n+    hb_copy (iter, *this);\n@@ -63,1 +63,1 @@\n-    alloc (o.length);\n+    alloc (o.length, true);\n@@ -87,0 +87,3 @@\n+  void init0 ()\n+  {\n+  }\n@@ -98,1 +101,5 @@\n-      allocated = length; \/\/ Big hack!\n+      \/* Big Hack! We don't know the true allocated size before\n+       * an allocation failure happened. But we know it was at\n+       * least as big as length. Restore it to that and continue\n+       * as if error did not happen. *\/\n+      allocated = length;\n@@ -112,1 +119,1 @@\n-    alloc (o.length);\n+    alloc (o.length, true);\n@@ -126,1 +133,1 @@\n-  { return hb_bytes_t ((const char *) arrayZ, length * item_size); }\n+  { return hb_bytes_t ((const char *) arrayZ, get_size ()); }\n@@ -168,8 +175,4 @@\n-  c_array_t sub_array (unsigned int start_offset, unsigned int count) const\n-  { return as_array ().sub_array (start_offset, count); }\n-  c_array_t sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/) const\n-  { return as_array ().sub_array (start_offset, count); }\n-  array_t sub_array (unsigned int start_offset, unsigned int count)\n-  { return as_array ().sub_array (start_offset, count); }\n-  array_t sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/)\n-  { return as_array ().sub_array (start_offset, count); }\n+  \/* Faster range-based for loop. *\/\n+  Type *begin () const { return arrayZ; }\n+  Type *end () const { return arrayZ + length; }\n+\n@@ -233,0 +236,5 @@\n+    if (!new_allocated)\n+    {\n+      hb_free (arrayZ);\n+      return nullptr;\n+    }\n@@ -240,0 +248,5 @@\n+    if (!new_allocated)\n+    {\n+      hb_free (arrayZ);\n+      return nullptr;\n+    }\n@@ -244,0 +257,1 @@\n+      {\n@@ -245,1 +259,0 @@\n-      for (unsigned i = 0; i < (unsigned) length; i++)\n@@ -247,3 +260,2 @@\n-      unsigned old_length = length;\n-      shrink_vector (0);\n-      length = old_length;\n+        arrayZ[i].~Type ();\n+      }\n@@ -281,1 +293,8 @@\n-    hb_memcpy ((void *) arrayZ, (const void *) other.arrayZ, length * item_size);\n+#ifndef HB_OPTIMIZE_SIZE\n+    if (sizeof (T) >= sizeof (long long))\n+      \/* This runs faster because of alignment. *\/\n+      for (unsigned i = 0; i < length; i++)\n+        arrayZ[i] = other.arrayZ[i];\n+    else\n+#endif\n+       hb_memcpy ((void *) arrayZ, (const void *) other.arrayZ, length * item_size);\n@@ -313,9 +332,0 @@\n-  template <typename T = Type,\n-            hb_enable_if (hb_is_trivially_destructible(T))>\n-  void\n-  shrink_vector (unsigned size)\n-  {\n-    length = size;\n-  }\n-  template <typename T = Type,\n-            hb_enable_if (!hb_is_trivially_destructible(T))>\n@@ -332,11 +342,0 @@\n-  template <typename T = Type,\n-            hb_enable_if (hb_is_trivially_copy_assignable(T))>\n-  void\n-  shift_down_vector (unsigned i)\n-  {\n-    memmove (static_cast<void *> (&arrayZ[i - 1]),\n-             static_cast<void *> (&arrayZ[i]),\n-             (length - i) * sizeof (Type));\n-  }\n-  template <typename T = Type,\n-            hb_enable_if (!hb_is_trivially_copy_assignable(T))>\n@@ -351,1 +350,1 @@\n-  bool alloc (unsigned int size)\n+  bool alloc (unsigned int size, bool exact=false)\n@@ -356,2 +355,8 @@\n-    if (likely (size <= (unsigned) allocated))\n-      return true;\n+    unsigned int new_allocated;\n+    if (exact)\n+    {\n+      \/* If exact was specified, we allow shrinking the storage. *\/\n+      size = hb_max (size, length);\n+      if (size <= (unsigned) allocated &&\n+          size >= (unsigned) allocated >> 2)\n+        return true;\n@@ -359,1 +364,11 @@\n-    \/* Reallocate *\/\n+      new_allocated = size;\n+    }\n+    else\n+    {\n+      if (likely (size <= (unsigned) allocated))\n+        return true;\n+\n+      new_allocated = allocated;\n+      while (size > new_allocated)\n+        new_allocated += (new_allocated >> 1) + 8;\n+    }\n@@ -361,3 +376,0 @@\n-    unsigned int new_allocated = allocated;\n-    while (size >= new_allocated)\n-      new_allocated += (new_allocated >> 1) + 8;\n@@ -365,1 +377,2 @@\n-    Type *new_array = nullptr;\n+    \/* Reallocate *\/\n+\n@@ -368,1 +381,1 @@\n-      (new_allocated < (unsigned) allocated) ||\n+      (new_allocated < size) ||\n@@ -370,2 +383,0 @@\n-    if (likely (!overflows))\n-      new_array = realloc_vector (new_allocated);\n@@ -373,1 +384,9 @@\n-    if (unlikely (!new_array))\n+    if (unlikely (overflows))\n+    {\n+      allocated = -1;\n+      return false;\n+    }\n+\n+    Type *new_array = realloc_vector (new_allocated);\n+\n+    if (unlikely (new_allocated && !new_array))\n@@ -375,0 +394,3 @@\n+      if (new_allocated <= (unsigned) allocated)\n+        return true; \/\/ shrinking failed; it's okay; happens in our fuzzer\n+\n@@ -385,1 +407,1 @@\n-  bool resize (int size_)\n+  bool resize (int size_, bool initialize = true, bool exact = false)\n@@ -388,1 +410,1 @@\n-    if (!alloc (size))\n+    if (!alloc (size, exact))\n@@ -392,1 +414,4 @@\n-      grow_vector (size);\n+    {\n+      if (initialize)\n+        grow_vector (size);\n+    }\n@@ -394,1 +419,4 @@\n-      shrink_vector (size);\n+    {\n+      if (initialize)\n+        shrink_vector (size);\n+    }\n@@ -399,0 +427,4 @@\n+  bool resize_exact (int size_, bool initialize = true)\n+  {\n+    return resize (size_, initialize, true);\n+  }\n@@ -403,1 +435,1 @@\n-    Type v = arrayZ[length - 1];\n+    Type v {std::move (arrayZ[length - 1])};\n@@ -409,1 +441,1 @@\n-  void remove (unsigned int i)\n+  void remove_ordered (unsigned int i)\n@@ -418,1 +450,13 @@\n-  void shrink (int size_)\n+  template <bool Sorted = sorted,\n+            hb_enable_if (!Sorted)>\n+  void remove_unordered (unsigned int i)\n+  {\n+    if (unlikely (i >= length))\n+      return;\n+    if (i != length - 1)\n+      arrayZ[i] = std::move (arrayZ[length - 1]);\n+    arrayZ[length - 1].~Type ();\n+    length--;\n+  }\n+\n+  void shrink (int size_, bool shrink_memory = true)\n@@ -425,0 +469,3 @@\n+\n+    if (shrink_memory)\n+      alloc (size, true); \/* To force shrinking memory if needed. *\/\n@@ -429,1 +476,1 @@\n-  void qsort (int (*cmp)(const void*, const void*))\n+  void qsort (int (*cmp)(const void*, const void*) = Type::cmp)\n@@ -431,2 +478,0 @@\n-  void qsort (unsigned int start = 0, unsigned int end = (unsigned int) -1)\n-  { as_array ().qsort (start, end); }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-vector.hh","additions":110,"deletions":65,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-#define HB_VERSION_MAJOR 4\n+#define HB_VERSION_MAJOR 7\n@@ -50,1 +50,1 @@\n-#define HB_VERSION_MINOR 4\n+#define HB_VERSION_MINOR 0\n@@ -63,1 +63,1 @@\n-#define HB_VERSION_STRING \"4.4.1\"\n+#define HB_VERSION_STRING \"7.0.1\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-version.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"hb-paint.h\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+#pragma GCC diagnostic warning \"-Wformat-signedness\"\n@@ -111,0 +112,1 @@\n+#pragma GCC diagnostic warning \"-Wunsafe-loop-optimizations\"\n@@ -117,1 +119,0 @@\n-#pragma GCC diagnostic ignored \"-Wformat-signedness\"            \/\/ TODO fix\n@@ -119,1 +120,0 @@\n-#pragma GCC diagnostic ignored \"-Wunsafe-loop-optimizations\"    \/\/ TODO fix\n@@ -129,0 +129,2 @@\n+#pragma GCC diagnostic ignored \"-Wcast-function-type-strict\" \/\/ https:\/\/github.com\/harfbuzz\/harfbuzz\/pull\/3859#issuecomment-1295409126\n+#pragma GCC diagnostic ignored \"-Wdangling-reference\" \/\/ https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/4043\n@@ -144,0 +146,1 @@\n+#include \"hb-limits.hh\"\n@@ -463,0 +466,31 @@\n+\n+\/\/ Locale business\n+\n+#if !defined(HB_NO_SETLOCALE) && (!defined(HAVE_NEWLOCALE) || !defined(HAVE_USELOCALE))\n+#define HB_NO_SETLOCALE 1\n+#endif\n+\n+#ifndef HB_NO_SETLOCALE\n+\n+#include <locale.h>\n+#ifdef HAVE_XLOCALE_H\n+#include <xlocale.h> \/\/ Needed on BSD\/OS X for uselocale\n+#endif\n+\n+#ifdef WIN32\n+#define hb_locale_t _locale_t\n+#else\n+#define hb_locale_t locale_t\n+#endif\n+#define hb_setlocale setlocale\n+#define hb_uselocale uselocale\n+\n+#else\n+\n+#define hb_locale_t void *\n+#define hb_setlocale(Category, Locale) \"C\"\n+#define hb_uselocale(Locale) ((hb_locale_t) 0)\n+\n+#endif\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb.hh","additions":36,"deletions":2,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsalpha.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -356,1 +356,1 @@\n-    M[8] = (( 0.0030 *  0.201908) + (0.0136 * 0.000008) + 0.9834);;\n+    M[8] = (( 0.0030 *  0.201908) + (0.0136 * 0.000008) + 0.9834);\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmscam02.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -1971,1 +1971,1 @@\n-    sd.Base   = (cmsUInt8Number*)  MemPtr;\n+    sd.Base   = (cmsUInt8Number*) MemPtr;\n@@ -1976,2 +1976,4 @@\n-    if (sd.Base)\n-        sd.Max  = *BytesNeeded;     \/\/ Write to memory?\n+    if (sd.Base && (*BytesNeeded > 0)) {\n+\n+        sd.Max = (*BytesNeeded) - 1;     \/\/ Write to memory?\n+    }\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmscgats.c","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -402,2 +402,2 @@\n-        _cmsReadMediaWhitePoint(&WhitePointIn,  hProfiles[i-1]);\n-        _cmsReadCHAD(&ChromaticAdaptationMatrixIn, hProfiles[i-1]);\n+        if (!_cmsReadMediaWhitePoint(&WhitePointIn, hProfiles[i - 1])) return FALSE;\n+        if (!_cmsReadCHAD(&ChromaticAdaptationMatrixIn, hProfiles[i - 1])) return FALSE;\n@@ -405,2 +405,2 @@\n-        _cmsReadMediaWhitePoint(&WhitePointOut,  hProfiles[i]);\n-        _cmsReadCHAD(&ChromaticAdaptationMatrixOut, hProfiles[i]);\n+        if (!_cmsReadMediaWhitePoint(&WhitePointOut, hProfiles[i])) return FALSE;\n+        if (!_cmsReadCHAD(&ChromaticAdaptationMatrixOut, hProfiles[i])) return FALSE;\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmscnvrt.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmserr.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -855,0 +855,4 @@\n+    \/\/ Do some housekeeping\n+    if (nEntries == 0 || values == NULL)\n+        return NULL;\n+\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsgamma.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmshalf.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsintrp.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -1954,1 +1954,1 @@\n-                goto Error;\n+                TagSize = BufferSize;\n@@ -1967,1 +1967,1 @@\n-    \/\/ The data has been already read, or written. But wait!, maybe the user chose to save as\n+    \/\/ The data has been already read, or written. But wait!, maybe the user choose to save as\n@@ -1976,1 +1976,1 @@\n-                goto Error;\n+                TagSize = BufferSize;\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsio0.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -883,0 +883,4 @@\n+    \/\/ Extended intents are not strictly CLUT-based\n+    if (Intent > INTENT_ABSOLUTE_COLORIMETRIC)\n+        return FALSE;\n+\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsio1.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmslut.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsmd5.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsmtrx.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -402,0 +402,2 @@\n+    if (v->StrW + v->Len > mlu->PoolSize) return NULL;\n+\n@@ -793,1 +795,7 @@\n-    cmsStage* mpe  = v ->Lut->Elements;\n+    cmsStage* mpe;\n+\n+    if (v == NULL) return NULL;\n+    if (v->Lut == NULL) return NULL;\n+\n+    mpe = v->Lut->Elements;\n+    if (mpe == NULL) return NULL;\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsnamed.c","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -1727,0 +1727,4 @@\n+              \/\/ Only RGB to RGB\n+              if (Matrix1->InputChannels != 3 || Matrix1->OutputChannels != 3 ||\n+                  Matrix2->InputChannels != 3 || Matrix2->OutputChannels != 3) return FALSE;\n+\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsopt.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -1739,1 +1739,1 @@\n-        if (Premul && alpha_factor != 0)\n+        if (Premul)\n@@ -1808,1 +1808,1 @@\n-        if (Premul && alpha_factor != 0)\n+        if (Premul)\n@@ -1875,1 +1875,1 @@\n-        if (Premul && alpha_factor != 0)\n+        if (Premul)\n@@ -1935,1 +1935,1 @@\n-        if (Premul && alpha_factor != 0)\n+        if (Premul)\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmspack.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmspcs.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -828,2 +828,0 @@\n-    struct _cmsContext_struct* ctx = _cmsGetContext(ContextID);\n-\n@@ -843,3 +841,0 @@\n-   if (ctx->MemPool != NULL)\n-       _cmsSubAllocDestroy(ctx->MemPool);\n-   ctx->MemPool = NULL;\n@@ -1013,1 +1008,8 @@\n-    if (ContextID != NULL) {\n+    if (ContextID == NULL) {\n+\n+        cmsUnregisterPlugins();\n+        if (globalContext.MemPool != NULL)\n+            _cmsSubAllocDestroy(globalContext.MemPool);\n+        globalContext.MemPool = NULL;\n+    }\n+    else {\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsplugin.c","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsps2.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -155,1 +155,1 @@\n-    \/\/ Force it to be neutral, clip to max. L* of 50\n+    \/\/ Force it to be neutral, check for inconsistences\n@@ -157,2 +157,1 @@\n-    if (Lab.L > 50) Lab.L = 50;\n-    if (Lab.L < 0) Lab.L = 0;\n+    if (Lab.L > 50 || Lab.L < 0) Lab.L = 0;\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmssamp.c","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmssm.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -1552,0 +1552,6 @@\n+        \/\/ Offset MUST be even because it indexes a block of utf16 chars.\n+        \/\/ Tricky profiles that uses odd positions will not work anyway\n+        \/\/ because the whole utf16 block is previously converted to wchar_t\n+        \/\/ and sizeof this type may be of 4 bytes. On Linux systems, for example.\n+        if (Offset & 1) goto Error;\n+\n@@ -1579,1 +1585,4 @@\n-        Block = (wchar_t*) _cmsMalloc(self ->ContextID, SizeOfTag);\n+        \/\/ Make sure this is an even utf16 size.\n+        if (SizeOfTag & 1) goto Error;\n+\n+        Block = (wchar_t*) _cmsCalloc(self ->ContextID, 1, SizeOfTag);\n@@ -1581,0 +1590,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmstypes.c","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsvirt.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -247,0 +247,4 @@\n+    if ((fabs(ConeSourceRGB.n[0]) < MATRIX_DET_TOLERANCE) ||\n+        (fabs(ConeSourceRGB.n[1]) < MATRIX_DET_TOLERANCE) ||\n+        (fabs(ConeSourceRGB.n[2]) < MATRIX_DET_TOLERANCE)) return FALSE;\n+\n@@ -252,1 +256,0 @@\n-\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmswtpnt.c","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsxform.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n@@ -55,1 +55,1 @@\n-\/\/ Version 2.14\n+\/\/ Version 2.15\n@@ -113,1 +113,1 @@\n-#define LCMS_VERSION        2140\n+#define LCMS_VERSION        2150\n@@ -259,1 +259,1 @@\n-#ifdef CMS_IS_WINDOWS_\n+#if defined(CMS_IS_WINDOWS_) && !defined(__GNUC__)\n","filename":"src\/java.desktop\/share\/native\/liblcms\/lcms2.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-\n@@ -33,1 +32,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n","filename":"src\/java.desktop\/share\/native\/liblcms\/lcms2_internal.h","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\/\/  Copyright (c) 1998-2022 Marti Maria Saguer\n+\/\/  Copyright (c) 1998-2023 Marti Maria Saguer\n","filename":"src\/java.desktop\/share\/native\/liblcms\/lcms2_plugin.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -393,0 +393,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.management.rmi\/share\/classes\/javax\/management\/remote\/rmi\/RMIConnector.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,0 +171,5 @@\n+     *\n+     * @deprecated This method supported the legacy Subject Delegation feature,\n+     * and is only useful in conjunction with other APIs which are deprecated and\n+     * subject to removal in a future release. Consequently, this method is also\n+     * deprecated and subject to removal. There is no replacement.\n@@ -172,0 +177,1 @@\n+    @Deprecated(since=\"21\", forRemoval=true)\n","filename":"src\/java.management\/share\/classes\/javax\/management\/remote\/JMXConnector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -633,1 +633,1 @@\n-                            Stream<T> s = c.getStream(1);\n+                            Stream<T> s = c.getInitialStream();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import jdk.internal.net.http.common.HeaderDecoder;\n@@ -66,0 +67,1 @@\n+import jdk.internal.net.http.common.ValidatingHeadersConsumer;\n@@ -320,0 +322,1 @@\n+    private volatile Stream<?> initialStream;\n@@ -373,0 +376,1 @@\n+        this.initialStream = initialStream;\n@@ -811,1 +815,1 @@\n-                    DecodingCallback decoder = new ValidatingHeadersConsumer();\n+                    DecodingCallback decoder = new ValidatingHeadersConsumer()::onDecoded;\n@@ -913,1 +917,1 @@\n-        decodeHeaders(pp, decoder);\n+        decodeHeaders(pp, decoder::onDecoded);\n@@ -925,1 +929,1 @@\n-        decodeHeaders(cf, pcs.pushContDecoder);\n+        decodeHeaders(cf, pcs.pushContDecoder::onDecoded);\n@@ -1207,0 +1211,15 @@\n+    \/**\n+     * Called to get the initial stream after a connection upgrade.\n+     * If the stream was cancelled, it might no longer be in the\n+     * stream map. Therefore - we use the initialStream field\n+     * instead, and reset it to null after returning it.\n+     * @param <T> the response type\n+     * @return the initial stream created during the upgrade.\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    <T> Stream<T> getInitialStream() {\n+         var s = (Stream<T>) initialStream;\n+         initialStream = null;\n+         return s;\n+    }\n+\n@@ -1539,70 +1558,0 @@\n-    static class HeaderDecoder extends ValidatingHeadersConsumer {\n-\n-        HttpHeadersBuilder headersBuilder;\n-\n-        HeaderDecoder() {\n-            this.headersBuilder = new HttpHeadersBuilder();\n-        }\n-\n-        @Override\n-        public void onDecoded(CharSequence name, CharSequence value) {\n-            String n = name.toString();\n-            String v = value.toString();\n-            super.onDecoded(n, v);\n-            headersBuilder.addHeader(n, v);\n-        }\n-\n-        HttpHeaders headers() {\n-            return headersBuilder.build();\n-        }\n-    }\n-\n-    \/*\n-     * Checks RFC 7540 rules (relaxed) compliance regarding pseudo-headers.\n-     *\/\n-    static class ValidatingHeadersConsumer implements DecodingCallback {\n-\n-        private static final Set<String> PSEUDO_HEADERS =\n-                Set.of(\":authority\", \":method\", \":path\", \":scheme\", \":status\");\n-\n-        \/** Used to check that if there are pseudo-headers, they go first *\/\n-        private boolean pseudoHeadersEnded;\n-\n-        \/**\n-         * Called when END_HEADERS was received. This consumer may be invoked\n-         * again after reset() is called, but for a whole new set of headers.\n-         *\/\n-        void reset() {\n-            pseudoHeadersEnded = false;\n-        }\n-\n-        @Override\n-        public void onDecoded(CharSequence name, CharSequence value)\n-                throws UncheckedIOException\n-        {\n-            String n = name.toString();\n-            if (n.startsWith(\":\")) {\n-                if (pseudoHeadersEnded) {\n-                    throw newException(\"Unexpected pseudo-header '%s'\", n);\n-                } else if (!PSEUDO_HEADERS.contains(n)) {\n-                    throw newException(\"Unknown pseudo-header '%s'\", n);\n-                }\n-            } else {\n-                pseudoHeadersEnded = true;\n-                if (!Utils.isValidName(n)) {\n-                    throw newException(\"Bad header name '%s'\", n);\n-                }\n-            }\n-            String v = value.toString();\n-            if (!Utils.isValidValue(v)) {\n-                throw newException(\"Bad header value '%s'\", v);\n-            }\n-        }\n-\n-        private UncheckedIOException newException(String message, String header)\n-        {\n-            return new UncheckedIOException(\n-                    new IOException(String.format(message, header)));\n-        }\n-    }\n-\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":22,"deletions":73,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -503,1 +503,1 @@\n-        return rspHeadersConsumer;\n+        return rspHeadersConsumer::onDecoded;\n@@ -1580,1 +1580,1 @@\n-    private class HeadersConsumer extends Http2Connection.ValidatingHeadersConsumer {\n+    private class HeadersConsumer extends ValidatingHeadersConsumer {\n@@ -1582,1 +1582,2 @@\n-        void reset() {\n+        @Override\n+        public void reset() {\n@@ -1592,7 +1593,15 @@\n-            String n = name.toString();\n-            String v = value.toString();\n-            super.onDecoded(n, v);\n-            responseHeadersBuilder.addHeader(n, v);\n-            if (Log.headers() && Log.trace()) {\n-                Log.logTrace(\"RECEIVED HEADER (streamid={0}): {1}: {2}\",\n-                             streamid, n, v);\n+            try {\n+                String n = name.toString();\n+                String v = value.toString();\n+                super.onDecoded(n, v);\n+                responseHeadersBuilder.addHeader(n, v);\n+                if (Log.headers() && Log.trace()) {\n+                    Log.logTrace(\"RECEIVED HEADER (streamid={0}): {1}: {2}\",\n+                            streamid, n, v);\n+                }\n+            } catch (UncheckedIOException uio) {\n+                \/\/ reset stream: From RFC 9113, section 8.1\n+                \/\/ Malformed requests or responses that are detected MUST be\n+                \/\/ treated as a stream error (Section 5.4.2) of type\n+                \/\/ PROTOCOL_ERROR.\n+                onProtocolError(uio.getCause());\n@@ -1601,0 +1610,5 @@\n+\n+        @Override\n+        protected String formatMessage(String message, String header) {\n+            return \"malformed response: \" + super.formatMessage(message, header);\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.net.http.common;\n+\n+import java.net.http.HttpHeaders;\n+\n+public class HeaderDecoder extends ValidatingHeadersConsumer {\n+\n+    private final HttpHeadersBuilder headersBuilder;\n+\n+    public HeaderDecoder() {\n+        this.headersBuilder = new HttpHeadersBuilder();\n+    }\n+\n+    @Override\n+    public void onDecoded(CharSequence name, CharSequence value) {\n+        String n = name.toString();\n+        String v = value.toString();\n+        super.onDecoded(n, v);\n+        headersBuilder.addHeader(n, v);\n+    }\n+\n+    public HttpHeaders headers() {\n+        return headersBuilder.build();\n+    }\n+}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/HeaderDecoder.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -434,0 +434,2 @@\n+    private static final boolean[] LOWER_CASE_CHARS = new boolean[128];\n+\n@@ -439,5 +441,8 @@\n-        char[] allowedTokenChars =\n-                (\"!#$%&'*+-.^_`|~0123456789\" +\n-                 \"abcdefghijklmnopqrstuvwxyz\" +\n-                 \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").toCharArray();\n-        for (char c : allowedTokenChars) {\n+        char[] lcase = (\"!#$%&'*+-.^_`|~0123456789\" +\n+                \"abcdefghijklmnopqrstuvwxyz\").toCharArray();\n+        for (char c : lcase) {\n+            tchar[c] = true;\n+            LOWER_CASE_CHARS[c] = true;\n+        }\n+        char[] ucase = (\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").toCharArray();\n+        for (char c : ucase) {\n@@ -452,0 +457,10 @@\n+    public static boolean isValidLowerCaseName(String token) {\n+        for (int i = 0; i < token.length(); i++) {\n+            char c = token.charAt(i);\n+            if (c > 255 || !LOWER_CASE_CHARS[c]) {\n+                return false;\n+            }\n+        }\n+        return !token.isEmpty();\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.net.http.common;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Set;\n+\n+\/*\n+ * Checks RFC 9113 rules (relaxed) compliance regarding pseudo-headers.\n+ *\/\n+public class ValidatingHeadersConsumer {\n+\n+    private static final Set<String> PSEUDO_HEADERS =\n+            Set.of(\":authority\", \":method\", \":path\", \":scheme\", \":status\");\n+\n+    \/** Used to check that if there are pseudo-headers, they go first *\/\n+    private boolean pseudoHeadersEnded;\n+\n+    \/**\n+     * Called when END_HEADERS was received. This consumer may be invoked\n+     * again after reset() is called, but for a whole new set of headers.\n+     *\/\n+    public void reset() {\n+        pseudoHeadersEnded = false;\n+    }\n+\n+    \/**\n+     * Called when a header field (name, value) pair has been decoded\n+     * @param name    the decoded name\n+     * @param value   the decoded value\n+     * @throws UncheckedIOException if the name or value are illegal\n+     *\/\n+    public void onDecoded(CharSequence name, CharSequence value)\n+            throws UncheckedIOException\n+    {\n+        String n = name.toString();\n+        if (n.startsWith(\":\")) {\n+            if (pseudoHeadersEnded) {\n+                throw newException(\"Unexpected pseudo-header '%s'\", n);\n+            } else if (!PSEUDO_HEADERS.contains(n)) {\n+                throw newException(\"Unknown pseudo-header '%s'\", n);\n+            }\n+        } else {\n+            pseudoHeadersEnded = true;\n+            \/\/ RFC-9113, section 8.2.1 for HTTP\/2 and RFC-9114, section 4.2 state that\n+            \/\/ header name MUST be lowercase (and allowed characters)\n+            if (!Utils.isValidLowerCaseName(n)) {\n+                throw newException(\"Bad header name '%s'\", n);\n+            }\n+        }\n+        String v = value.toString();\n+        if (!Utils.isValidValue(v)) {\n+            throw newException(\"Bad header value '%s'\", v);\n+        }\n+    }\n+\n+    protected String formatMessage(String message, String header) {\n+        return String.format(message, header);\n+    }\n+\n+    protected UncheckedIOException newException(String message, String header)\n+    {\n+        return new UncheckedIOException(\n+                new IOException(formatMessage(message, header)));\n+    }\n+}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/ValidatingHeadersConsumer.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -130,0 +130,5 @@\n+            try {\n+                disposeContext();\n+            } catch (Exception ex) {\n+                \/\/dispose context silently\n+            }\n@@ -152,0 +157,3 @@\n+            if (context == null) {\n+                throw new IOException(\"Negotiate support cannot continue. Context is invalidated\");\n+            }\n@@ -161,0 +169,22 @@\n+\n+    \/**\n+     * Releases any system resources and cryptographic information stored in\n+     * the context object and invalidates the context.\n+     *\n+     * @throws IOException containing a reason of failure in the cause\n+     *\/\n+    @Override\n+    public void disposeContext() throws IOException {\n+        try {\n+            if (context != null) {\n+                context.dispose();\n+            }\n+        } catch (GSSException e) {\n+            if (DEBUG) {\n+                System.out.println(\"Cannot release resources. Reason:\");\n+                e.printStackTrace();\n+            }\n+            throw new IOException(\"Cannot release resources\", e);\n+        };\n+        context = null;\n+    }\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/net\/www\/protocol\/http\/spnego\/NegotiatorImpl.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,3 @@\n-        SunNativeProvider.debug(\"Created GSSLibStub for mech \" + mech);\n+        if (SunNativeProvider.DEBUG) {\n+            SunNativeProvider.debug(\"Created GSSLibStub for mech \" + mech);\n+        }\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/wrapper\/GSSLibStub.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,2 +76,4 @@\n-                        SunNativeProvider.debug(\"Name type list unavailable: \" +\n-                            ge2.getMajorString());\n+                        if (SunNativeProvider.DEBUG) {\n+                            SunNativeProvider.debug(\"Name type list unavailable: \" +\n+                                    ge2.getMajorString());\n+                        }\n@@ -80,2 +82,4 @@\n-                    SunNativeProvider.debug(\"Name type list unavailable: \" +\n-                        ge.getMajorString());\n+                    if (SunNativeProvider.DEBUG) {\n+                        SunNativeProvider.debug(\"Name type list unavailable: \" +\n+                                ge.getMajorString());\n+                    }\n@@ -89,2 +93,4 @@\n-                SunNativeProvider.debug(\"Override \" + nameType +\n-                    \" with mechanism default(null)\");\n+                if (SunNativeProvider.DEBUG) {\n+                    SunNativeProvider.debug(\"Override \" + nameType +\n+                            \" with mechanism default(null)\");\n+                }\n@@ -188,2 +194,4 @@\n-        SunNativeProvider.debug(\"Imported \" + printableName + \" w\/ type \" +\n-                                printableType);\n+        if (SunNativeProvider.DEBUG) {\n+            SunNativeProvider.debug(\"Imported \" + printableName + \" w\/ type \" +\n+                    printableType);\n+        }\n@@ -214,1 +222,3 @@\n-        SunNativeProvider.debug(\"Got kerberized name: \" + printables2[0]);\n+        if (SunNativeProvider.DEBUG) {\n+            SunNativeProvider.debug(\"Got kerberized name: \" + printables2[0]);\n+        }\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/wrapper\/GSSNameElement.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,2 +56,4 @@\n-            SunNativeProvider.debug(\"Checking ServicePermission(\" +\n-                                    target + \", \" + action + \")\");\n+            if (SunNativeProvider.DEBUG) {\n+                SunNativeProvider.debug(\"Checking ServicePermission(\" +\n+                        target + \", \" + action + \")\");\n+            }\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/wrapper\/Krb5Util.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,2 +151,4 @@\n-            SunNativeProvider.debug(\"Checking DelegationPermission (\" +\n-                                    krbPrincPair + \")\");\n+            if (SunNativeProvider.DEBUG) {\n+                SunNativeProvider.debug(\"Checking DelegationPermission (\" +\n+                        krbPrincPair + \")\");\n+            }\n@@ -166,2 +168,4 @@\n-                SunNativeProvider.debug(\"Precomputed mechToken length: \" +\n-                                         mechTokenLen);\n+                if (SunNativeProvider.DEBUG) {\n+                    SunNativeProvider.debug(\"Precomputed mechToken length: \" +\n+                            mechTokenLen);\n+                }\n@@ -185,2 +189,4 @@\n-            SunNativeProvider.debug(\"Complete Token length: \" +\n-                                    result.length);\n+            if (SunNativeProvider.DEBUG) {\n+                SunNativeProvider.debug(\"Complete Token length: \" +\n+                        result.length);\n+            }\n@@ -276,2 +282,4 @@\n-                SunNativeProvider.debug(\"initSecContext=> inToken len=\" +\n-                    inToken.length);\n+                if (SunNativeProvider.DEBUG) {\n+                    SunNativeProvider.debug(\"initSecContext=> inToken len=\" +\n+                            inToken.length);\n+                }\n@@ -289,2 +297,4 @@\n-            SunNativeProvider.debug(\"initSecContext=> outToken len=\" +\n-                (outToken == null ? 0 : outToken.length));\n+            if (SunNativeProvider.DEBUG) {\n+                SunNativeProvider.debug(\"initSecContext=> outToken len=\" +\n+                        (outToken == null ? 0 : outToken.length));\n+            }\n@@ -324,2 +334,4 @@\n-            SunNativeProvider.debug(\"acceptSecContext=> inToken len=\" +\n-                                    inToken.length);\n+            if (SunNativeProvider.DEBUG) {\n+                SunNativeProvider.debug(\"acceptSecContext=> inToken len=\" +\n+                        inToken.length);\n+            }\n@@ -329,2 +341,4 @@\n-            SunNativeProvider.debug(\"acceptSecContext=> outToken len=\" +\n-                                    (outToken == null? 0 : outToken.length));\n+            if (SunNativeProvider.DEBUG) {\n+                SunNativeProvider.debug(\"acceptSecContext=> outToken len=\" +\n+                        (outToken == null ? 0 : outToken.length));\n+            }\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/wrapper\/NativeGSSContext.java","additions":29,"deletions":15,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,2 @@\n-    private static final boolean DEBUG =\n+\n+    static final boolean DEBUG =\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/wrapper\/SunNativeProvider.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.Optional;\n@@ -38,1 +39,2 @@\n-import com.sun.tools.javac.code.TypeMetadata.Entry;\n+import com.sun.tools.javac.code.TypeMetadata.Annotations;\n+import com.sun.tools.javac.code.TypeMetadata.ConstantValue;\n@@ -89,9 +91,1 @@\n-    protected final TypeMetadata metadata;\n-\n-    public TypeMetadata getMetadata() {\n-        return metadata;\n-    }\n-\n-    public Entry getMetadataOfKind(final Entry.Kind kind) {\n-        return metadata != null ? metadata.get(kind) : null;\n-    }\n+    protected final List<TypeMetadata> metadata;\n@@ -191,1 +185,2 @@\n-        return null;\n+        return getMetadata(TypeMetadata.ConstantValue.class)\n+                .map(ConstantValue::value).orElse(null);\n@@ -233,1 +228,1 @@\n-    public Type(TypeSymbol tsym, TypeMetadata metadata) {\n+    public Type(TypeSymbol tsym, List<TypeMetadata> metadata) {\n@@ -348,1 +343,1 @@\n-        return metadata == TypeMetadata.EMPTY ? this : baseType();\n+        return metadata.isEmpty() ? this : baseType();\n@@ -353,0 +348,27 @@\n+     * Only to be used internally!\n+     *\/\n+    protected Type cloneWithMetadata(List<TypeMetadata> metadata) {\n+        throw new AssertionError(\"Cannot add metadata to this type: \" + getTag());\n+    }\n+\n+    \/**\n+     * Get all the type metadata associated with this type.\n+     *\/\n+    public List<TypeMetadata> getMetadata() {\n+        return metadata;\n+    }\n+\n+    \/**\n+     * Get the type metadata of the given kind associated with this type (if any).\n+     *\/\n+    public <M extends TypeMetadata> Optional<M> getMetadata(Class<M> metadataClass) {\n+        return metadata.stream()\n+                .filter(m -> metadataClass.isAssignableFrom(m.getClass()))\n+                .map(metadataClass::cast)\n+                .findFirst();\n+    }\n+\n+    \/**\n+     * Create a new copy of this type but with the specified type metadata.\n+     * If this type is already associated with a type metadata of the same class,\n+     * an exception is thrown.\n@@ -354,1 +376,14 @@\n-    public abstract Type cloneWithMetadata(TypeMetadata metadata);\n+    public Type addMetadata(TypeMetadata md) {\n+        Assert.check(getMetadata(md.getClass()).isEmpty());\n+        return cloneWithMetadata(metadata.append(md));\n+    }\n+\n+    \/**\n+     * Create a new copy of this type but without the specified type metadata.\n+     *\/\n+    public Type dropMetadata(Class<? extends TypeMetadata> metadataClass) {\n+        List<TypeMetadata> newMetadata = metadata.stream()\n+                .filter(m -> !metadataClass.isAssignableFrom(m.getClass()))\n+                .collect(List.collector());\n+        return cloneWithMetadata(newMetadata);\n+    }\n@@ -401,0 +436,4 @@\n+    public Type preannotatedType() {\n+        return addMetadata(new Annotations());\n+    }\n+\n@@ -402,2 +441,1 @@\n-        final Entry annoMetadata = new TypeMetadata.Annotations(annos);\n-        return cloneWithMetadata(metadata.combine(annoMetadata));\n+        return addMetadata(new Annotations(annos));\n@@ -407,4 +445,1 @@\n-        final TypeMetadata.Annotations metadata =\n-            (TypeMetadata.Annotations)getMetadataOfKind(Entry.Kind.ANNOTATIONS);\n-\n-        return null != metadata && !metadata.getAnnotations().isEmpty();\n+        return getMetadata(TypeMetadata.Annotations.class).isPresent();\n@@ -415,4 +450,2 @@\n-        final TypeMetadata.Annotations metadata =\n-            (TypeMetadata.Annotations)getMetadataOfKind(Entry.Kind.ANNOTATIONS);\n-\n-        return metadata == null ? List.nil() : metadata.getAnnotations();\n+        return getMetadata(TypeMetadata.Annotations.class)\n+                .map(Annotations::annotations).orElse(List.nil());\n@@ -691,1 +724,1 @@\n-            this(tag, tsym, TypeMetadata.EMPTY);\n+            this(tag, tsym, List.nil());\n@@ -694,1 +727,1 @@\n-        private JCPrimitiveType(TypeTag tag, TypeSymbol tsym, TypeMetadata metadata) {\n+        private JCPrimitiveType(TypeTag tag, TypeSymbol tsym, List<TypeMetadata> metadata) {\n@@ -701,1 +734,1 @@\n-        public JCPrimitiveType cloneWithMetadata(TypeMetadata md) {\n+        protected JCPrimitiveType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -747,11 +780,1 @@\n-            final Object value = constValue;\n-            return new JCPrimitiveType(tag, tsym, metadata) {\n-                    @Override\n-                    public Object constValue() {\n-                        return value;\n-                    }\n-                    @Override\n-                    public Type baseType() {\n-                        return tsym.type;\n-                    }\n-                };\n+            return addMetadata(new ConstantValue(constValue));\n@@ -832,1 +855,1 @@\n-            this(type, kind, tsym, null, TypeMetadata.EMPTY);\n+            this(type, kind, tsym, null, List.nil());\n@@ -836,1 +859,1 @@\n-                            TypeMetadata metadata) {\n+                            List<TypeMetadata> metadata) {\n@@ -842,1 +865,1 @@\n-            this(type, kind, tsym, bound, TypeMetadata.EMPTY);\n+            this(type, kind, tsym, bound, List.nil());\n@@ -846,1 +869,1 @@\n-                            TypeVar bound, TypeMetadata metadata) {\n+                            TypeVar bound, List<TypeMetadata> metadata) {\n@@ -854,1 +877,1 @@\n-        public WildcardType cloneWithMetadata(TypeMetadata md) {\n+        protected WildcardType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -981,1 +1004,1 @@\n-            this(outer, typarams, tsym, TypeMetadata.EMPTY);\n+            this(outer, typarams, tsym, List.nil());\n@@ -985,1 +1008,1 @@\n-                         TypeMetadata metadata) {\n+                         List<TypeMetadata> metadata) {\n@@ -999,1 +1022,1 @@\n-        public ClassType cloneWithMetadata(TypeMetadata md) {\n+        protected ClassType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -1017,11 +1040,1 @@\n-            final Object value = constValue;\n-            return new ClassType(getEnclosingType(), typarams_field, tsym, metadata) {\n-                    @Override\n-                    public Object constValue() {\n-                        return value;\n-                    }\n-                    @Override\n-                    public Type baseType() {\n-                        return tsym.type;\n-                    }\n-                };\n+            return addMetadata(new ConstantValue(constValue));\n@@ -1193,1 +1206,1 @@\n-                               TypeMetadata metadata) {\n+                               List<TypeMetadata> metadata) {\n@@ -1218,5 +1231,0 @@\n-        @Override\n-        public UnionClassType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a union type\");\n-        }\n-\n@@ -1274,5 +1282,0 @@\n-        @Override\n-        public IntersectionClassType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to an intersection type\");\n-        }\n-\n@@ -1321,1 +1324,1 @@\n-            this(elemtype, arrayClass, TypeMetadata.EMPTY);\n+            this(elemtype, arrayClass, List.nil());\n@@ -1325,1 +1328,1 @@\n-                         TypeMetadata metadata) {\n+                         List<TypeMetadata> metadata) {\n@@ -1341,1 +1344,1 @@\n-        public ArrayType cloneWithMetadata(TypeMetadata md) {\n+        protected ArrayType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -1466,1 +1469,1 @@\n-            super(methodClass, TypeMetadata.EMPTY);\n+            super(methodClass, List.nil());\n@@ -1472,5 +1475,0 @@\n-        @Override\n-        public MethodType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a method type\");\n-        }\n-\n@@ -1563,6 +1561,1 @@\n-            super(tsym, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public PackageType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a package type\");\n+            super(tsym, List.nil());\n@@ -1601,6 +1594,1 @@\n-            super(tsym, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public ModuleType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a module type\");\n+            super(tsym, List.nil());\n@@ -1662,1 +1650,1 @@\n-            super(null, TypeMetadata.EMPTY);\n+            super(null, List.nil());\n@@ -1670,1 +1658,1 @@\n-            this(tsym, bound, lower, TypeMetadata.EMPTY);\n+            this(tsym, bound, lower, List.nil());\n@@ -1674,1 +1662,1 @@\n-                       TypeMetadata metadata) {\n+                       List<TypeMetadata> metadata) {\n@@ -1682,1 +1670,1 @@\n-        public TypeVar cloneWithMetadata(TypeMetadata md) {\n+        protected TypeVar cloneWithMetadata(List<TypeMetadata> md) {\n@@ -1765,1 +1753,1 @@\n-                            TypeMetadata metadata) {\n+                            List<TypeMetadata> metadata) {\n@@ -1771,1 +1759,1 @@\n-        public CapturedType cloneWithMetadata(TypeMetadata md) {\n+        protected CapturedType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -1810,1 +1798,1 @@\n-            this(tag, qtype, TypeMetadata.EMPTY);\n+            this(tag, qtype, List.nil());\n@@ -1814,1 +1802,1 @@\n-                             TypeMetadata metadata) {\n+                             List<TypeMetadata> metadata) {\n@@ -1847,5 +1835,0 @@\n-        @Override\n-        public ForAll cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a forall type\");\n-        }\n-\n@@ -2080,5 +2063,0 @@\n-        @Override\n-        public UndetVar cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to an UndetVar type\");\n-        }\n-\n@@ -2227,6 +2205,1 @@\n-            super(null, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public JCNoType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a JCNoType\");\n+            super(null, List.nil());\n@@ -2260,6 +2233,1 @@\n-            super(null, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public JCVoidType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a void type\");\n+            super(null, List.nil());\n@@ -2295,6 +2263,1 @@\n-            super(null, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public BottomType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a bottom type\");\n+            super(null, List.nil());\n@@ -2357,1 +2320,1 @@\n-                          TypeMetadata metadata) {\n+                          List<TypeMetadata> metadata) {\n@@ -2364,1 +2327,1 @@\n-        public ErrorType cloneWithMetadata(TypeMetadata md) {\n+        protected ErrorType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -2435,6 +2398,1 @@\n-            super(null, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public UnknownType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to an unknown type\");\n+            super(null, List.nil());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":92,"deletions":134,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import com.sun.tools.javac.util.Assert;\n@@ -30,3 +29,1 @@\n-import java.util.EnumMap;\n-import java.util.HashSet;\n-import java.util.Set;\n+import com.sun.tools.javac.util.ListBuffer;\n@@ -35,8 +32,15 @@\n- * TypeMetadata is essentially an immutable {@code EnumMap<Entry.Kind, <? extends Entry>>}\n- *\n- * A metadata class represented by a subtype of Entry can express a property on a Type instance.\n- * There should be at most one instance of an Entry per Entry.Kind on any given Type instance.\n- *\n- * Metadata classes of a specific kind are responsible for how they combine themselves.\n- *\n- * @implNote {@code Entry:combine} need not be commutative.\n+ * A type metadata is an object that can be stapled on a type. This is typically done using\n+ * {@link Type#addMetadata(TypeMetadata)}. Metadata associated to a type can also be removed,\n+ * typically using {@link Type#dropMetadata(Class)}. To drop <em>all<\/em> metadata from a given type,\n+ * the {@link Type#baseType()} method can also be used. This can be useful when comparing two\n+ * using reference equality (see also {@link Type#equalsIgnoreMetadata(Type)}).\n+ * <p>\n+ * There are no constraints on how a type metadata should be defined. Typically, a type\n+ * metadata will be defined as a small record, storing additional information (see {@link ConstantValue}).\n+ * In other cases, type metadata can be mutable and support complex state transitions\n+ * (see {@link Annotations}).\n+ * <p>\n+ * The only invariant the implementation requires is that there must be <em>one<\/em> metadata\n+ * of a given kind attached to a type, as this makes accessing and dropping metadata simpler.\n+ * If clients wish to store multiple metadata values that are logically related, they should\n+ * define a metadata type that collects such values in e.g. a list.\n@@ -44,32 +48,1 @@\n-public class TypeMetadata {\n-    public static final TypeMetadata EMPTY = new TypeMetadata();\n-\n-    private final EnumMap<Entry.Kind, Entry> contents;\n-\n-    \/**\n-     * Create a new empty TypeMetadata map.\n-     *\/\n-    private TypeMetadata() {\n-        contents = new EnumMap<>(Entry.Kind.class);\n-    }\n-\n-    \/**\n-     * Create a new TypeMetadata map containing the Entry {@code elem}.\n-     *\n-     * @param elem the sole contents of this map\n-     *\/\n-    public TypeMetadata(Entry elem) {\n-        this();\n-        Assert.checkNonNull(elem);\n-        contents.put(elem.kind(), elem);\n-    }\n-\n-    \/**\n-     * Creates a copy of TypeMetadata {@code other} with a shallow copy the other's metadata contents.\n-     *\n-     * @param other the TypeMetadata to copy contents from.\n-     *\/\n-    public TypeMetadata(TypeMetadata other) {\n-        Assert.checkNonNull(other);\n-        contents = other.contents.clone();\n-    }\n+public sealed interface TypeMetadata {\n@@ -78,5 +51,6 @@\n-     * Return a copy of this TypeMetadata with the metadata entry for {@code elem.kind()} combined\n-     * with {@code elem}.\n-     *\n-     * @param elem the new value\n-     * @return a new TypeMetadata updated with {@code Entry elem}\n+     * A type metadata object holding type annotations. This metadata needs to be mutable,\n+     * because type annotations are sometimes set in two steps. That is, a type can be created with\n+     * an empty set of annotations (e.g. during member enter). At some point later, the type\n+     * is then updated to contain the correct annotations. At this point we need to augment\n+     * the existing type (rather than creating a new one), as the type might already have been\n+     * saved inside other symbols.\n@@ -84,2 +58,1 @@\n-    public TypeMetadata combine(Entry elem) {\n-        Assert.checkNonNull(elem);\n+    record Annotations(ListBuffer<Attribute.TypeCompound> annotationBuffer) implements TypeMetadata {\n@@ -87,6 +60,2 @@\n-        TypeMetadata out = new TypeMetadata(this);\n-        Entry.Kind key = elem.kind();\n-        if (contents.containsKey(key)) {\n-            out.add(key, this.contents.get(key).combine(elem));\n-        } else {\n-            out.add(key, elem);\n+        Annotations() {\n+            this(new ListBuffer<>());\n@@ -94,2 +63,0 @@\n-        return out;\n-    }\n@@ -97,24 +64,3 @@\n-    \/**\n-     * Return a copy of this TypeMetadata with the metadata entry for all kinds from {@code other}\n-     * combined with the same kind from this.\n-     *\n-     * @param other the TypeMetadata to combine with this\n-     * @return a new TypeMetadata updated with all entries from {@code other}\n-     *\/\n-    public TypeMetadata combineAll(TypeMetadata other) {\n-        Assert.checkNonNull(other);\n-\n-        TypeMetadata out = new TypeMetadata();\n-        Set<Entry.Kind> keys = new HashSet<>(contents.keySet());\n-        keys.addAll(other.contents.keySet());\n-\n-        for(Entry.Kind key : keys) {\n-            if (contents.containsKey(key)) {\n-                if (other.contents.containsKey(key)) {\n-                    out.add(key, contents.get(key).combine(other.contents.get(key)));\n-                } else {\n-                    out.add(key, contents.get(key));\n-                }\n-            } else if (other.contents.containsKey(key)) {\n-                out.add(key, other.contents.get(key));\n-            }\n+        Annotations(List<Attribute.TypeCompound> annotations) {\n+            this();\n+            annotationBuffer.appendList(annotations);\n@@ -122,2 +68,0 @@\n-        return out;\n-    }\n@@ -125,29 +69,2 @@\n-    \/**\n-     * Return a TypeMetadata with the metadata entry for {@code kind} removed.\n-     *\n-     * This may be the same instance or a new TypeMetadata.\n-     *\n-     * @param kind the {@code Kind} to remove metadata for\n-     * @return a new TypeMetadata without {@code Kind kind}\n-     *\/\n-    public TypeMetadata without(Entry.Kind kind) {\n-        if (this == EMPTY || contents.get(kind) == null)\n-            return this;\n-\n-        TypeMetadata out = new TypeMetadata(this);\n-        out.contents.remove(kind);\n-        return out.contents.isEmpty() ? EMPTY : out;\n-    }\n-\n-    public Entry get(Entry.Kind kind) {\n-        return contents.get(kind);\n-    }\n-\n-    private void add(Entry.Kind kind, Entry elem) {\n-        contents.put(kind, elem);\n-    }\n-\n-    public interface Entry {\n-\n-        public enum Kind {\n-            ANNOTATIONS\n+        List<Attribute.TypeCompound> annotations() {\n+            return annotationBuffer.toList();\n@@ -155,14 +72,0 @@\n-\n-        \/**\n-         * Get the kind of metadata this object represents\n-         *\/\n-        public Kind kind();\n-\n-        \/**\n-         * Combine this type metadata with another metadata of the\n-         * same kind.\n-         *\n-         * @param other The metadata with which to combine this one.\n-         * @return The combined metadata.\n-         *\/\n-        public Entry combine(Entry other);\n@@ -172,1 +75,2 @@\n-     * A type metadata object holding type annotations.\n+     * A type metadata holding a constant value. This can be used to describe constant types,\n+     * such as the type of a string literal, or that of a numeric constant.\n@@ -174,31 +78,1 @@\n-    public static class Annotations implements Entry {\n-        private List<Attribute.TypeCompound> annos;\n-\n-        public static final List<Attribute.TypeCompound> TO_BE_SET = List.nil();\n-\n-        public Annotations(List<Attribute.TypeCompound> annos) {\n-            this.annos = annos;\n-        }\n-\n-        \/**\n-         * Get the type annotations contained in this metadata.\n-         *\n-         * @return The annotations.\n-         *\/\n-        public List<Attribute.TypeCompound> getAnnotations() {\n-            return annos;\n-        }\n-\n-        @Override\n-        public Annotations combine(Entry other) {\n-            Assert.check(annos == TO_BE_SET);\n-            annos = ((Annotations)other).annos;\n-            return this;\n-        }\n-\n-        @Override\n-        public Kind kind() { return Kind.ANNOTATIONS; }\n-\n-        @Override\n-        public String toString() { return \"ANNOTATIONS [ \" + annos + \" ]\"; }\n-    }\n+    record ConstantValue(Object value) implements TypeMetadata { }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeMetadata.java","additions":35,"deletions":161,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;\n+import com.sun.tools.javac.code.TypeMetadata.Annotations;\n@@ -2402,1 +2402,1 @@\n-                if (t.getMetadata() != TypeMetadata.EMPTY) {\n+                if (t.getMetadata().nonEmpty()) {\n@@ -2413,1 +2413,1 @@\n-                        default: return s.cloneWithMetadata(s.getMetadata().without(Kind.ANNOTATIONS));\n+                        default: return s.dropMetadata(Annotations.class);\n@@ -2440,1 +2440,1 @@\n-                            t.getMetadata().without(Kind.ANNOTATIONS));\n+                            t.dropMetadata(Annotations.class).getMetadata());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;\n+import com.sun.tools.javac.code.TypeMetadata.Annotations;\n@@ -1052,1 +1052,4 @@\n-            storeAt.getMetadataOfKind(Kind.ANNOTATIONS).combine(new TypeMetadata.Annotations(compounds));\n+            \/\/ the type already has annotation metadata, but it's empty\n+            Annotations metadata = storeAt.getMetadata(Annotations.class).orElseThrow(AssertionError::new);\n+            Assert.check(metadata.annotationBuffer().isEmpty());\n+            metadata.annotationBuffer().appendList(compounds);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import com.sun.tools.javac.code.TypeMetadata.Annotations;\n@@ -5213,1 +5212,1 @@\n-        Type annotatedType = underlyingType.annotatedType(Annotations.TO_BE_SET);\n+        Type annotatedType = underlyingType.preannotatedType();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-            super(null, TypeMetadata.EMPTY);\n+            super(null, List.nil());\n@@ -230,5 +230,0 @@\n-        @Override\n-        public DeferredType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a deferred type\");\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/DeferredAttr.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2928,1 +2928,1 @@\n-            super(syms.noSymbol, TypeMetadata.EMPTY);\n+            super(syms.noSymbol, List.nil());\n@@ -2937,5 +2937,0 @@\n-        @Override\n-        public Type cloneWithMetadata(TypeMetadata metadata) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-                              TypeMetadata metadata) {\n+                              List<TypeMetadata> metadata) {\n@@ -62,1 +62,1 @@\n-    public UninitializedType cloneWithMetadata(final TypeMetadata md) {\n+    protected UninitializedType cloneWithMetadata(final List<TypeMetadata> md) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/UninitializedType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Collections;\n@@ -42,0 +43,9 @@\n+    \/\/ cache the result of java.util.Collections.emptyIterator(), which\n+    \/\/ explicitly does not guarantee to return the same instance\n+    private static final Iterator<?> EMPTY = Collections.emptyIterator();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Iterator<T> emptyIterator() {\n+        return (Iterator<T>) EMPTY;\n+    }\n+\n@@ -50,2 +60,1 @@\n-        @SuppressWarnings(\"unchecked\")\n-        private Iterator<O> currentIterator = EMPTY;\n+        private Iterator<O> currentIterator = emptyIterator();\n@@ -58,0 +67,1 @@\n+        @Override\n@@ -59,2 +69,9 @@\n-            if (currentIterator != null && !currentIterator.hasNext()) {\n-                update();\n+            \/\/ if there's no element currently available, advance until there\n+            \/\/ is one or the input is exhausted\n+            for (;;) {\n+                if (currentIterator.hasNext())\n+                    return true;\n+                else if (inputs.hasNext())\n+                    currentIterator = converter.apply(inputs.next());\n+                else\n+                    return false;\n@@ -62,1 +79,0 @@\n-            return currentIterator != null;\n@@ -65,0 +81,1 @@\n+        @Override\n@@ -66,12 +83,4 @@\n-            if (currentIterator == EMPTY && !hasNext()) {\n-                throw new NoSuchElementException();\n-            }\n-            return currentIterator.next();\n-        }\n-\n-        public void remove() {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        private void update() {\n-            while (inputs.hasNext()) {\n+            \/\/ next() cannot assume hasNext() was called immediately before:\n+            \/\/ next() must itself be able to find the next available element\n+            \/\/ if there is one\n+            while (!currentIterator.hasNext() && inputs.hasNext()) {\n@@ -79,1 +88,0 @@\n-                if (currentIterator.hasNext()) return;\n@@ -81,1 +89,1 @@\n-            currentIterator = null;\n+            return currentIterator.next();\n@@ -85,12 +93,1 @@\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final Iterator EMPTY = new Iterator() {\n-        public boolean hasNext() {\n-            return false;\n-        }\n-\n-        @Override\n-        public Object next() {\n-            return null;\n-        }\n-    };\n-\n+    \/\/ input.next() is assumed to never return null\n@@ -98,1 +95,1 @@\n-        return new Iterator<E>() {\n+        return new Iterator<>() {\n@@ -117,0 +114,3 @@\n+                if (current == null) {\n+                    throw new NoSuchElementException();\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Iterators.java","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -441,17 +441,0 @@\n-    private static final Iterator<?> EMPTYITERATOR = new Iterator<Object>() {\n-            public boolean hasNext() {\n-                return false;\n-            }\n-            public Object next() {\n-                throw new java.util.NoSuchElementException();\n-            }\n-            public void remove() {\n-                throw new UnsupportedOperationException();\n-            }\n-        };\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <A> Iterator<A> emptyIterator() {\n-        return (Iterator<A>)EMPTYITERATOR;\n-    }\n-\n@@ -461,1 +444,1 @@\n-            return emptyIterator();\n+            return Iterators.emptyIterator();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/List.java","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,0 @@\n-  const char *error_message = NULL;\n@@ -89,1 +88,0 @@\n-  char buffer[JVM_MAXPATHLEN];\n@@ -107,2 +105,1 @@\n-    getLastErrorString(buffer, sizeof(buffer));\n-    error_message = buffer;\n+    JNU_ThrowByNameWithLastError(env, \"sun\/jvm\/hotspot\/debugger\/DebuggerException\", \"GetProcAddress failed\");\n@@ -116,1 +113,1 @@\n-    error_message = dlerror();\n+    JNU_ThrowByName(env, \"sun\/jvm\/hotspot\/debugger\/DebuggerException\", dlerror());\n@@ -121,13 +118,0 @@\n-\n-  if (func == 0) {\n-    \/* Couldn't find entry point.  error_message should contain some\n-     * platform dependent error message.\n-     *\/\n-    jstring s = JNU_NewStringPlatform(env, error_message);\n-    if (s != NULL) {\n-      jobject x = JNU_NewObjectByName(env, \"sun\/jvm\/hotspot\/debugger\/DebuggerException\", \"(Ljava\/lang\/String;)V\", s);\n-      if (x != NULL) {\n-        (*env)->Throw(env, x);\n-      }\n-    }\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/native\/libsaproc\/sadis.c","additions":3,"deletions":19,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -252,0 +252,2 @@\n+    native HotSpotResolvedJavaType lookupJClass(long jclass);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -839,0 +839,20 @@\n+    \/**\n+     * Converts a HotSpot heap JNI {@code hotspot_jclass_value} to a {@link ResolvedJavaType},\n+     * provided that the {@code hotspot_jclass_value} is a valid JNI reference to a Java Class. If\n+     * this requirement is not met, {@link IllegalArgumentException} is thrown.\n+     *\n+     * @param hotspot_jclass_value a JNI reference to a {@link Class} value in the HotSpot heap\n+     * @return a {@link ResolvedJavaType} for the referenced type\n+     * @throws IllegalArgumentException if {@code hotspot_jclass_value} is not a valid JNI reference\n+     *             to a {@link Class} object in the HotSpot heap. It is the responsibility of the\n+     *             caller to make sure the argument is valid. The checks performed by this method\n+     *             are best effort. Hence, the caller must not rely on the checks and corresponding\n+     *             exceptions!\n+     *\/\n+    public HotSpotResolvedJavaType asResolvedJavaType(long hotspot_jclass_value) {\n+        if (hotspot_jclass_value == 0L) {\n+            return null;\n+        }\n+        return compilerToVm.lookupJClass(hotspot_jclass_value);\n+    }\n+\n@@ -861,0 +881,20 @@\n+    \/**\n+     * Gets the {@code jobject} value wrapped by {@code peerObject}. The returned \"naked\" value is\n+     * only valid as long as {@code peerObject} is valid. Note that the latter may be shorter than\n+     * the lifetime of {@code peerObject}. As such, this method should only be used to pass an\n+     * object parameter across a JNI call from the JVMCI shared library to HotSpot. This method must\n+     * only be called from within the JVMCI shared library.\n+     *\n+     * @param peerObject a reference to an object in the peer runtime\n+     * @return the {@code jobject} value wrapped by {@code peerObject}\n+     * @throws IllegalArgumentException if the current runtime is not the JVMCI shared library or\n+     *             {@code peerObject} is not a peer object reference\n+     *\/\n+    public long getJObjectValue(HotSpotObjectConstant peerObject) {\n+        if (peerObject instanceof IndirectHotSpotObjectConstantImpl) {\n+            IndirectHotSpotObjectConstantImpl remote = (IndirectHotSpotObjectConstantImpl) peerObject;\n+            return remote.getHandle();\n+        }\n+        throw new IllegalArgumentException(\"Cannot get jobject value for \" + peerObject + \" (\" + peerObject.getClass().getName() + \")\");\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.jarsigner;\n-\n-import java.io.IOException;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.cert.CertificateException;\n-\n-\/**\n- * This class defines a content signing service.\n- * Implementations must be instantiable using a zero-argument constructor.\n- *\n- * @since 1.5\n- * @author Vincent Ryan\n- * @deprecated This class has been deprecated.\n- *\/\n-\n-@Deprecated(since=\"9\", forRemoval=true)\n-public abstract class ContentSigner {\n-\n-    \/**\n-     * Generates a PKCS #7 signed data message.\n-     * This method is used when the signature has already been generated.\n-     * The signature, the signer's details, and optionally a signature\n-     * timestamp and the content that was signed, are all packaged into a\n-     * signed data message.\n-     *\n-     * @param parameters The non-null input parameters.\n-     * @param omitContent true if the content should be omitted from the\n-     *         signed data message. Otherwise the content is included.\n-     * @param applyTimestamp true if the signature should be timestamped.\n-     *         Otherwise timestamping is not performed.\n-     * @return A PKCS #7 signed data message.\n-     * @throws NoSuchAlgorithmException The exception is thrown if the signature\n-     *         algorithm is unrecognised.\n-     * @throws CertificateException The exception is thrown if an error occurs\n-     *         while processing the signer's certificate or the TSA's\n-     *         certificate.\n-     * @throws IOException The exception is thrown if an error occurs while\n-     *         generating the signature timestamp or while generating the signed\n-     *         data message.\n-     * @throws NullPointerException The exception is thrown if parameters is\n-     *         null.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    public abstract byte[] generateSignedData(\n-        ContentSignerParameters parameters, boolean omitContent,\n-        boolean applyTimestamp)\n-            throws NoSuchAlgorithmException, CertificateException, IOException;\n-}\n","filename":"src\/jdk.jartool\/share\/classes\/com\/sun\/jarsigner\/ContentSigner.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.jarsigner;\n-\n-import java.net.URI;\n-import java.security.cert.X509Certificate;\n-import java.util.zip.ZipFile;\n-\n-\/**\n- * This interface encapsulates the parameters for a ContentSigner object.\n- *\n- * @since 1.5\n- * @author Vincent Ryan\n- * @deprecated This class has been deprecated.\n- *\/\n-@Deprecated(since=\"9\", forRemoval=true)\n-public interface ContentSignerParameters {\n-\n-    \/**\n-     * Retrieves the command-line arguments passed to the jarsigner tool.\n-     *\n-     * @return The command-line arguments. May be null.\n-     *\/\n-    public String[] getCommandLine();\n-\n-    \/**\n-     * Retrieves the identifier for a Timestamping Authority (TSA).\n-     *\n-     * @return The TSA identifier. May be null.\n-     *\/\n-    public URI getTimestampingAuthority();\n-\n-    \/**\n-     * Retrieves the certificate for a Timestamping Authority (TSA).\n-     *\n-     * @return The TSA certificate. May be null.\n-     *\/\n-    public X509Certificate getTimestampingAuthorityCertificate();\n-\n-    \/**\n-     * Retrieves the TSAPolicyID for a Timestamping Authority (TSA).\n-     *\n-     * @return The TSAPolicyID. May be null.\n-     *\/\n-    public default String getTSAPolicyID() {\n-        return null;\n-    }\n-\n-    \/**\n-     * Retreives the message digest algorithm that is used to generate\n-     * the message imprint to be sent to the TSA server.\n-     *\n-     * @since 9\n-     * @return The non-null string of the message digest algorithm name.\n-     *\/\n-    public default String getTSADigestAlg() {\n-        return \"SHA-256\";\n-    }\n-\n-    \/**\n-     * Retrieves the JAR file's signature.\n-     *\n-     * @return The non-null array of signature bytes.\n-     *\/\n-    public byte[] getSignature();\n-\n-    \/**\n-     * Retrieves the name of the signature algorithm.\n-     *\n-     * @return The non-null string name of the signature algorithm.\n-     *\/\n-    public String getSignatureAlgorithm();\n-\n-    \/**\n-     * Retrieves the signer's X.509 certificate chain.\n-     *\n-     * @return The non-null array of X.509 public-key certificates.\n-     *\/\n-    public X509Certificate[] getSignerCertificateChain();\n-\n-    \/**\n-     * Retrieves the content that was signed.\n-     * The content is the JAR file's signature file.\n-     *\n-     * @return The content bytes. May be null.\n-     *\/\n-    public byte[] getContent();\n-\n-    \/**\n-     * Retrieves the original source ZIP file before it was signed.\n-     *\n-     * @return The original ZIP file. May be null.\n-     *\/\n-    public ZipFile getSource();\n-}\n","filename":"src\/jdk.jartool\/share\/classes\/com\/sun\/jarsigner\/ContentSignerParameters.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/**\n- * This package comprises the interfaces and classes used to define the\n- * signing mechanism used by the {@code jarsigner} tool.\n- * <p>\n- * Clients may override the default signing mechanism of the {@code jarsigner}\n- * tool by supplying an alternative implementation of\n- * {@link com.sun.jarsigner.ContentSigner}.\n- *\n- * The classes in this package have been deprecated and will be removed in\n- * a future release. New classes should not be added to this package.\n- * Use the {@link jdk.security.jarsigner.JarSigner} API to sign JAR files.\n- *\/\n-\n-package com.sun.jarsigner;\n","filename":"src\/jdk.jartool\/share\/classes\/com\/sun\/jarsigner\/package-info.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -28,2 +28,0 @@\n-import com.sun.jarsigner.ContentSigner;\n-import com.sun.jarsigner.ContentSignerParameters;\n@@ -126,2 +124,0 @@\n-        String altSignerPath;\n-        String altSigner;\n@@ -394,6 +390,0 @@\n-                case \"altsignerpath\":\n-                    altSignerPath = value;\n-                    break;\n-                case \"altsigner\":\n-                    altSigner = value;\n-                    break;\n@@ -505,5 +495,0 @@\n-\n-    @Deprecated(since=\"16\", forRemoval=true)\n-    private final String altSignerPath;\n-    @Deprecated(since=\"16\", forRemoval=true)\n-    private final String altSigner;\n@@ -552,9 +537,0 @@\n-        this.altSigner = builder.altSigner;\n-        this.altSignerPath = builder.altSignerPath;\n-\n-        \/\/ altSigner cannot support modern algorithms like RSASSA-PSS and EdDSA\n-        if (altSigner != null\n-                && !sigalg.toUpperCase(Locale.ENGLISH).contains(\"WITH\")) {\n-            throw new IllegalArgumentException(\n-                    \"Customized ContentSigner is not supported for \" + sigalg);\n-        }\n@@ -661,4 +637,0 @@\n-            case \"altsignerpath\":\n-                return altSignerPath;\n-            case \"altsigner\":\n-                return altSigner;\n@@ -857,39 +829,17 @@\n-        if (altSigner == null) {\n-            Function<byte[], PKCS9Attributes> timestamper = null;\n-            if (tsaUrl != null) {\n-                timestamper = s -> {\n-                    try {\n-                        \/\/ Timestamp the signature\n-                        HttpTimestamper tsa = new HttpTimestamper(tsaUrl);\n-                        byte[] tsToken = PKCS7.generateTimestampToken(\n-                                tsa, tSAPolicyID, tSADigestAlg, s);\n-\n-                        return new PKCS9Attributes(new PKCS9Attribute[]{\n-                                new PKCS9Attribute(\n-                                        PKCS9Attribute.SIGNATURE_TIMESTAMP_TOKEN_OID,\n-                                        tsToken)});\n-                    } catch (IOException | CertificateException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                };\n-            }\n-            \/\/ We now create authAttrs in block data, so \"direct == false\".\n-            block = PKCS7.generateNewSignedData(sigalg, sigProvider, privateKey, certChain,\n-                    content, internalsf, false, timestamper);\n-        } else {\n-            Signature signer = SignatureUtil.fromKey(sigalg, privateKey, sigProvider);\n-            signer.update(content);\n-            byte[] signature = signer.sign();\n-\n-            @SuppressWarnings(\"removal\")\n-            ContentSignerParameters params =\n-                    new JarSignerParameters(null, tsaUrl, tSAPolicyID,\n-                            tSADigestAlg, signature,\n-                            signer.getAlgorithm(), certChain, content, zipFile);\n-            @SuppressWarnings(\"removal\")\n-            ContentSigner signingMechanism = loadSigningMechanism(altSigner, altSignerPath);\n-            block = signingMechanism.generateSignedData(\n-                    params,\n-                    !internalsf,\n-                    params.getTimestampingAuthority() != null\n-                            || params.getTimestampingAuthorityCertificate() != null);\n+        Function<byte[], PKCS9Attributes> timestamper = null;\n+        if (tsaUrl != null) {\n+            timestamper = s -> {\n+                try {\n+                    \/\/ Timestamp the signature\n+                    HttpTimestamper tsa = new HttpTimestamper(tsaUrl);\n+                    byte[] tsToken = PKCS7.generateTimestampToken(\n+                            tsa, tSAPolicyID, tSADigestAlg, s);\n+\n+                    return new PKCS9Attributes(new PKCS9Attribute[]{\n+                            new PKCS9Attribute(\n+                                    PKCS9Attribute.SIGNATURE_TIMESTAMP_TOKEN_OID,\n+                                    tsToken)});\n+                } catch (IOException | CertificateException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            };\n@@ -897,0 +847,3 @@\n+        \/\/ We now create authAttrs in block data, so \"direct == false\".\n+        block = PKCS7.generateNewSignedData(sigalg, sigProvider, privateKey, certChain,\n+                content, internalsf, false, timestamper);\n@@ -1104,38 +1057,0 @@\n-    \/*\n-     * Try to load the specified signing mechanism.\n-     * The URL class loader is used.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private ContentSigner loadSigningMechanism(String signerClassName,\n-                                               String signerClassPath) {\n-\n-        \/\/ If there is no signerClassPath provided, search from here\n-        if (signerClassPath == null) {\n-            signerClassPath = \".\";\n-        }\n-\n-        \/\/ construct class loader\n-        String cpString;   \/\/ make sure env.class.path defaults to dot\n-\n-        \/\/ do prepends to get correct ordering\n-        cpString = PathList.appendPath(\n-                System.getProperty(\"env.class.path\"), null);\n-        cpString = PathList.appendPath(\n-                System.getProperty(\"java.class.path\"), cpString);\n-        cpString = PathList.appendPath(signerClassPath, cpString);\n-        URL[] urls = PathList.pathToURLs(cpString);\n-        ClassLoader appClassLoader = new URLClassLoader(urls);\n-\n-        try {\n-            \/\/ attempt to find signer\n-            Class<?> signerClass = appClassLoader.loadClass(signerClassName);\n-            Object signer = signerClass.getDeclaredConstructor().newInstance();\n-            return (ContentSigner) signer;\n-        } catch (ClassNotFoundException|InstantiationException|\n-                IllegalAccessException|ClassCastException|\n-                NoSuchMethodException| InvocationTargetException e) {\n-            throw new IllegalArgumentException(\n-                    \"Invalid altSigner or altSignerPath\", e);\n-        }\n-    }\n-\n@@ -1229,77 +1144,0 @@\n-\n-    @SuppressWarnings(\"removal\")\n-    @Deprecated(since=\"16\", forRemoval=true)\n-    class JarSignerParameters implements ContentSignerParameters {\n-\n-        private String[] args;\n-        private URI tsa;\n-        private byte[] signature;\n-        private String signatureAlgorithm;\n-        private X509Certificate[] signerCertificateChain;\n-        private byte[] content;\n-        private ZipFile source;\n-        private String tSAPolicyID;\n-        private String tSADigestAlg;\n-\n-        JarSignerParameters(String[] args, URI tsa,\n-                            String tSAPolicyID, String tSADigestAlg,\n-                            byte[] signature, String signatureAlgorithm,\n-                            X509Certificate[] signerCertificateChain,\n-                            byte[] content, ZipFile source) {\n-\n-            Objects.requireNonNull(signature);\n-            Objects.requireNonNull(signatureAlgorithm);\n-            Objects.requireNonNull(signerCertificateChain);\n-\n-            this.args = args;\n-            this.tsa = tsa;\n-            this.tSAPolicyID = tSAPolicyID;\n-            this.tSADigestAlg = tSADigestAlg;\n-            this.signature = signature;\n-            this.signatureAlgorithm = signatureAlgorithm;\n-            this.signerCertificateChain = signerCertificateChain;\n-            this.content = content;\n-            this.source = source;\n-        }\n-\n-        public String[] getCommandLine() {\n-            return args;\n-        }\n-\n-        public URI getTimestampingAuthority() {\n-            return tsa;\n-        }\n-\n-        public X509Certificate getTimestampingAuthorityCertificate() {\n-            \/\/ We don't use this param. Always provide tsaURI.\n-            return null;\n-        }\n-\n-        public String getTSAPolicyID() {\n-            return tSAPolicyID;\n-        }\n-\n-        public String getTSADigestAlg() {\n-            return tSADigestAlg;\n-        }\n-\n-        public byte[] getSignature() {\n-            return signature;\n-        }\n-\n-        public String getSignatureAlgorithm() {\n-            return signatureAlgorithm;\n-        }\n-\n-        public X509Certificate[] getSignerCertificateChain() {\n-            return signerCertificateChain;\n-        }\n-\n-        public byte[] getContent() {\n-            return content;\n-        }\n-\n-        public ZipFile getSource() {\n-            return source;\n-        }\n-    }\n","filename":"src\/jdk.jartool\/share\/classes\/jdk\/security\/jarsigner\/JarSigner.java","additions":20,"deletions":182,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import jdk.internal.javac.ParticipatesInPreview;\n+\n@@ -50,0 +52,1 @@\n+@ParticipatesInPreview\n@@ -53,1 +56,0 @@\n-    exports com.sun.jarsigner;\n","filename":"src\/jdk.jartool\/share\/classes\/module-info.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -182,2 +182,0 @@\n-    private String altSignerClass = null;\n-    private String altSignerClasspath = null;\n@@ -486,12 +484,0 @@\n-            } else if (collator.compare(flags, \"-altsigner\") ==0) {\n-                if (++n == args.length) usageNoArg();\n-                altSignerClass = args[n];\n-                System.err.println(\n-                        rb.getString(\"This.option.is.forremoval\") +\n-                                \"-altsigner\");\n-            } else if (collator.compare(flags, \"-altsignerpath\") ==0) {\n-                if (++n == args.length) usageNoArg();\n-                altSignerClasspath = args[n];\n-                System.err.println(\n-                        rb.getString(\"This.option.is.forremoval\") +\n-                                \"-altsignerpath\");\n@@ -701,6 +687,0 @@\n-        System.out.println(rb.getString\n-                (\".altsigner.class.class.name.of.an.alternative.signing.mechanism\"));\n-        System.out.println();\n-        System.out.println(rb.getString\n-                (\".altsignerpath.pathlist.location.of.an.alternative.signing.mechanism\"));\n-        System.out.println();\n@@ -1951,12 +1931,0 @@\n-        if (altSignerClass != null) {\n-            builder.setProperty(\"altSigner\", altSignerClass);\n-            if (verbose != null) {\n-                System.out.println(\n-                        rb.getString(\"using.an.alternative.signing.mechanism\"));\n-            }\n-        }\n-\n-        if (altSignerClasspath != null) {\n-            builder.setProperty(\"altSignerPath\", altSignerClasspath);\n-        }\n-\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-        {\"This.option.is.forremoval\", \"This option is deprecated and will be removed in a future release: \"},\n@@ -100,6 +99,0 @@\n-        {\".altsigner.class.class.name.of.an.alternative.signing.mechanism\",\n-                \"[-altsigner <class>]        class name of an alternative signing mechanism\\n\" +\n-                \"                            (This option is deprecated and will be removed in a future release.)\"},\n-        {\".altsignerpath.pathlist.location.of.an.alternative.signing.mechanism\",\n-                \"[-altsignerpath <pathlist>] location of an alternative signing mechanism\\n\" +\n-                \"                            (This option is deprecated and will be removed in a future release.)\"},\n@@ -243,2 +236,0 @@\n-        {\"using.an.alternative.signing.mechanism\",\n-                \"using an alternative signing mechanism\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-        {\"This.option.is.forremoval\", \"Diese Option ist veraltet und wird in einem zuk\\u00FCnftigen Release entfernt: \"},\n@@ -100,4 +99,0 @@\n-        {\".altsigner.class.class.name.of.an.alternative.signing.mechanism\",\n-                \"[-altsigner <Klasse>]        Klassenname eines alternativen Signiermechanismus\\n                            (Diese Option ist veraltet und wird in einem zuk\\u00FCnftigen Release entfernt.)\"},\n-        {\".altsignerpath.pathlist.location.of.an.alternative.signing.mechanism\",\n-                \"[-altsignerpath <Pfadliste>] Speicherort eines alternativen Signiermechanismus\\n                            (Diese Option ist veraltet und wird in einem zuk\\u00FCnftigen Release entfernt.)\"},\n@@ -239,2 +234,0 @@\n-        {\"using.an.alternative.signing.mechanism\",\n-                \"Verwendung eines alternativen Signaturmechanismus\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources_de.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-        {\"This.option.is.forremoval\", \"\\u3053\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306F\\u975E\\u63A8\\u5968\\u3067\\u3042\\u308A\\u3001\\u5C06\\u6765\\u306E\\u30EA\\u30EA\\u30FC\\u30B9\\u3067\\u524A\\u9664\\u3055\\u308C\\u308B\\u4E88\\u5B9A\\u3067\\u3059: \"},\n@@ -100,4 +99,0 @@\n-        {\".altsigner.class.class.name.of.an.alternative.signing.mechanism\",\n-                \"[-altsigner <class>]        \\u4EE3\\u66FF\\u7F72\\u540D\\u30E1\\u30AB\\u30CB\\u30BA\\u30E0\\u306E\\u30AF\\u30E9\\u30B9\\u540D\\n                            (\\u3053\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306F\\u975E\\u63A8\\u5968\\u3067\\u3042\\u308A\\u3001\\u5C06\\u6765\\u306E\\u30EA\\u30EA\\u30FC\\u30B9\\u3067\\u524A\\u9664\\u3055\\u308C\\u308B\\u4E88\\u5B9A\\u3067\\u3059\\u3002)\"},\n-        {\".altsignerpath.pathlist.location.of.an.alternative.signing.mechanism\",\n-                \"[-altsignerpath <pathlist>] \\u4EE3\\u66FF\\u7F72\\u540D\\u30E1\\u30AB\\u30CB\\u30BA\\u30E0\\u306E\\u5834\\u6240\\n                            (\\u3053\\u306E\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306F\\u975E\\u63A8\\u5968\\u3067\\u3042\\u308A\\u3001\\u5C06\\u6765\\u306E\\u30EA\\u30EA\\u30FC\\u30B9\\u3067\\u524A\\u9664\\u3055\\u308C\\u308B\\u4E88\\u5B9A\\u3067\\u3059\\u3002)\"},\n@@ -239,2 +234,0 @@\n-        {\"using.an.alternative.signing.mechanism\",\n-                \"\\u4EE3\\u66FF\\u7F72\\u540D\\u30E1\\u30AB\\u30CB\\u30BA\\u30E0\\u306E\\u4F7F\\u7528\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources_ja.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-        {\"This.option.is.forremoval\", \"\\u8BE5\\u9009\\u9879\\u5DF2\\u8FC7\\u65F6\\uFF0C\\u5728\\u5C06\\u6765\\u7684\\u53D1\\u884C\\u7248\\u4E2D\\u5C06\\u88AB\\u5220\\u9664\\uFF1A\"},\n@@ -100,4 +99,0 @@\n-        {\".altsigner.class.class.name.of.an.alternative.signing.mechanism\",\n-                \"[-altsigner <class>]        \\u66FF\\u4EE3\\u7B7E\\u540D\\u673A\\u5236\\u7684\\u7C7B\\u540D\\n                            \\uFF08\\u8BE5\\u9009\\u9879\\u5DF2\\u8FC7\\u65F6\\uFF0C\\u5728\\u5C06\\u6765\\u7684\\u53D1\\u884C\\u7248\\u4E2D\\u5C06\\u88AB\\u5220\\u9664\\u3002\\uFF09\"},\n-        {\".altsignerpath.pathlist.location.of.an.alternative.signing.mechanism\",\n-                \"[-altsignerpath <pathlist>] \\u66FF\\u4EE3\\u7B7E\\u540D\\u673A\\u5236\\u7684\\u4F4D\\u7F6E\\n                            \\uFF08\\u8BE5\\u9009\\u9879\\u5DF2\\u8FC7\\u65F6\\uFF0C\\u5728\\u5C06\\u6765\\u7684\\u53D1\\u884C\\u7248\\u4E2D\\u5C06\\u88AB\\u5220\\u9664\\u3002\\uFF09\"},\n@@ -239,2 +234,0 @@\n-        {\"using.an.alternative.signing.mechanism\",\n-                \"\\u6B63\\u5728\\u4F7F\\u7528\\u66FF\\u4EE3\\u7684\\u7B7E\\u540D\\u673A\\u5236\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources_zh_CN.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n-\n@@ -31,1 +29,1 @@\n-import java.io.InputStream;\n+import java.lang.reflect.AccessFlag;\n@@ -34,1 +32,0 @@\n-import java.util.HashMap;\n@@ -36,1 +33,0 @@\n-import java.util.Map;\n@@ -38,0 +34,10 @@\n+import java.util.function.Consumer;\n+import jdk.internal.classfile.AccessFlags;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.attribute.EnclosingMethodAttribute;\n+import jdk.internal.classfile.attribute.InnerClassesAttribute;\n@@ -94,1 +100,1 @@\n-        return attrs.nestedClass;\n+        return attrs.maybeNestedClass && attrs.outerClassName != null;\n@@ -162,4 +168,8 @@\n-    private ClassAttributes getClassAttributes(byte[] bytes) {\n-        ClassReader rdr = new ClassReader(bytes);\n-        ClassAttributes attrs = new ClassAttributes();\n-        rdr.accept(attrs, 0);\n+    private static ClassAttributes getClassAttributes(byte[] bytes) {\n+        var cm = Classfile.parse(bytes);\n+        ClassAttributes attrs = new ClassAttributes(\n+                cm.flags(),\n+                cm.thisClass().asInternalName(),\n+                cm.superclass().map(ClassEntry::asInternalName).orElse(null),\n+                cm.majorVersion());\n+        cm.forEachElement(attrs);\n@@ -235,2 +245,2 @@\n-    private static final class ClassAttributes extends ClassVisitor {\n-        private String name;\n+    private static final class ClassAttributes implements Consumer<ClassElement> {\n+        private final String name;\n@@ -238,5 +248,5 @@\n-        private String superName;\n-        private int majorVersion;\n-        private int access;\n-        private boolean publicClass;\n-        private boolean nestedClass;\n+        private final String superName;\n+        private final int majorVersion;\n+        private final int access;\n+        private final boolean publicClass;\n+        private final boolean maybeNestedClass;\n@@ -246,14 +256,3 @@\n-        public ClassAttributes() {\n-            super(Opcodes.ASM9);\n-        }\n-\n-        private boolean isPublic(int access) {\n-            return ((access & Opcodes.ACC_PUBLIC) == Opcodes.ACC_PUBLIC)\n-                    || ((access & Opcodes.ACC_PROTECTED) == Opcodes.ACC_PROTECTED);\n-        }\n-\n-        @Override\n-        public void visit(int version, int access, String name, String signature,\n-                          String superName, String[] interfaces) {\n-            this.majorVersion = version & 0xFFFF; \/\/ JDK-8296329: extract major version only\n-            this.access = access;\n+        public ClassAttributes(AccessFlags access, String name, String superName, int majorVersion) {\n+            this.majorVersion = majorVersion; \/\/ JDK-8296329: extract major version only\n+            this.access = access.flagsMask();\n@@ -261,1 +260,1 @@\n-            this.nestedClass = name.contains(\"$\");\n+            this.maybeNestedClass = name.contains(\"$\");\n@@ -267,31 +266,9 @@\n-        public void visitOuterClass(String owner, String name, String desc) {\n-            if (!this.nestedClass) return;\n-            this.outerClassName = owner;\n-        }\n-\n-        @Override\n-        public void visitInnerClass(String name, String outerName, String innerName,\n-                                    int access) {\n-            if (!this.nestedClass) return;\n-            if (outerName == null) return;\n-            if (!this.name.equals(name)) return;\n-            if (this.outerClassName == null) this.outerClassName = outerName;\n-        }\n-\n-        @Override\n-        public FieldVisitor visitField(int access, String name, String desc,\n-                                       String signature, Object value) {\n-            if (isPublic(access)) {\n-                fields.add(new Field(access, name, desc));\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public MethodVisitor visitMethod(int access, String name, String desc,\n-                                         String signature, String[] exceptions) {\n-            if (isPublic(access)) {\n-                Set<String> exceptionSet = new HashSet<>();\n-                if (exceptions != null) {\n-                    for (String e : exceptions) {\n-                        exceptionSet.add(e);\n+        public void accept(ClassElement cle) {\n+            switch (cle) {\n+                case InnerClassesAttribute ica -> {\n+                    for (var icm : ica.classes()) {\n+                        if (this.maybeNestedClass && icm.outerClass().isPresent()\n+                                && this.name.equals(icm.innerClass().asInternalName())\n+                                && this.outerClassName == null) {\n+                            this.outerClassName = icm.outerClass().get().asInternalName();\n+                        }\n@@ -300,6 +277,23 @@\n-                \/\/ treat type descriptor as a proxy for signature because signature\n-                \/\/ is usually null, need to strip off the return type though\n-                int n;\n-                if (desc != null && (n = desc.lastIndexOf(')')) != -1) {\n-                    desc = desc.substring(0, n + 1);\n-                    methods.add(new Method(access, name, desc, exceptionSet));\n+                case FieldModel fm -> {\n+                    if (isPublic(fm.flags())) {\n+                        fields.add(new Field(fm.flags().flagsMask(),\n+                                             fm.fieldName().stringValue(),\n+                                             fm.fieldType().stringValue()));\n+                    }\n+                }\n+                case MethodModel mm -> {\n+                    if (isPublic(mm.flags())) {\n+                        Set<String> exceptionSet = new HashSet<>();\n+                        mm.findAttribute(Attributes.EXCEPTIONS).ifPresent(ea ->\n+                                ea.exceptions().forEach(e ->\n+                                        exceptionSet.add(e.asInternalName())));\n+                        \/\/ treat type descriptor as a proxy for signature because signature\n+                        \/\/ is usually null, need to strip off the return type though\n+                        int n;\n+                        var desc = mm.methodType().stringValue();\n+                        if (desc != null && (n = desc.lastIndexOf(')')) != -1) {\n+                            desc = desc.substring(0, n + 1);\n+                            methods.add(new Method(mm.flags().flagsMask(),\n+                                    mm.methodName().stringValue(), desc, exceptionSet));\n+                        }\n+                    }\n@@ -307,0 +301,6 @@\n+                case EnclosingMethodAttribute ema -> {\n+                    if (this.maybeNestedClass) {\n+                        this.outerClassName = ema.enclosingClass().asInternalName();\n+                    }\n+                }\n+                default -> {}\n@@ -308,1 +308,0 @@\n-            return null;\n@@ -311,3 +310,2 @@\n-        @Override\n-        public void visitEnd() {\n-            this.nestedClass = this.outerClassName != null;\n+        private static boolean isPublic(AccessFlags access) {\n+            return access.has(AccessFlag.PUBLIC) || access.has(AccessFlag.PROTECTED);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/FingerPrint.java","additions":71,"deletions":73,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,4 +82,7 @@\n- *   <dd>An element is considered to be <em>included<\/em>, if it is\n- *       <em>specified<\/em> if it contains a <em>specified<\/em> element,\n- *       or it is enclosed in a <em>specified<\/em> element, and is <em>selected<\/em>.\n- *       Included elements will be documented.\n+ *   <dd>An element is considered to be <em>included<\/em>, if it is <em>selected<\/em> and any of the following is true:\n+ *     <ul>\n+ *       <li>the element is <em>specified<\/em>, or\n+ *       <li>the element contains a <em>specified<\/em> element, or\n+ *       <li>the element is enclosed in a <em>specified<\/em> element.\n+ *     <\/ul>\n+ *     Included elements will be documented.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/doclet\/package-info.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -75,3 +75,3 @@\n-        HtmlLinkInfo linkInfo = new HtmlLinkInfo(configuration, LINK_TYPE_PARAMS_AND_BOUNDS, member);\n-        linkInfo.addLineBreaksInTypeParameters = true;\n-        linkInfo.showTypeParameterAnnotations = true;\n+        HtmlLinkInfo linkInfo = new HtmlLinkInfo(configuration, LINK_TYPE_PARAMS_AND_BOUNDS, member)\n+                .addLineBreaksInTypeParameters(true)\n+                .showTypeParameterAnnotations(true);\n@@ -124,3 +124,3 @@\n-        HtmlLinkInfo linkInfo = new HtmlLinkInfo(configuration, LINK_TYPE_PARAMS,\n-                paramType).varargs(isVarArg);\n-        linkInfo.showTypeParameterAnnotations = true;\n+        HtmlLinkInfo linkInfo = new HtmlLinkInfo(configuration, LINK_TYPE_PARAMS, paramType)\n+                .varargs(isVarArg)\n+                .showTypeParameterAnnotations(true);\n@@ -145,2 +145,2 @@\n-        var info = new HtmlLinkInfo(configuration, SHOW_TYPE_PARAMS_AND_BOUNDS, rcvrType);\n-        info.linkToSelf = false;\n+        var info = new HtmlLinkInfo(configuration, SHOW_TYPE_PARAMS_AND_BOUNDS, rcvrType)\n+                .linkToSelf(false);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractExecutableMemberWriter.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-                configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, klass));\n+                configuration, HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_IN_LABEL, klass));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AllClassesIndexWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,3 +118,2 @@\n-                HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_AND_BOUNDS, typeElement);\n-        \/\/Let's not link to ourselves in the header.\n-        linkInfo.linkToSelf = false;\n+                HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_AND_BOUNDS, typeElement)\n+                .linkToSelf(false);  \/\/ Let's not link to ourselves in the header\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriterImpl.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-                    HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, typeElement)) :\n+                    HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_IN_LABEL, typeElement)) :\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstantsSummaryWriterImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -292,17 +292,24 @@\n-        TypeElement enclosing = utils.getEnclosingTypeElement(method);\n-        List<? extends TypeMirror> intfacs = enclosing.getInterfaces();\n-        ExecutableElement overriddenMethod = utils.overriddenMethod(method);\n-        VisibleMemberTable vmt = configuration.getVisibleMemberTable(enclosing);\n-        \/\/ Check whether there is any implementation or overridden info to be\n-        \/\/ printed. If no overridden or implementation info needs to be\n-        \/\/ printed, do not print this section.\n-        if ((!intfacs.isEmpty()\n-                && !vmt.getImplementedMethods(method).isEmpty())\n-                || overriddenMethod != null) {\n-            MethodWriterImpl.addImplementsInfo(this, method, dl);\n-            if (overriddenMethod != null) {\n-                MethodWriterImpl.addOverridden(this,\n-                        utils.overriddenType(method),\n-                        overriddenMethod,\n-                        dl);\n-            }\n+        var enclosing = (TypeElement) method.getEnclosingElement();\n+        var overrideInfo = utils.overriddenMethod(method);\n+        var enclosingVmt = configuration.getVisibleMemberTable(enclosing);\n+        var implementedMethods = enclosingVmt.getImplementedMethods(method);\n+        if ((!enclosing.getInterfaces().isEmpty()\n+                && !implementedMethods.isEmpty())\n+                || overrideInfo != null) {\n+            \/\/ TODO note that if there are any overridden interface methods throughout the\n+            \/\/   hierarchy, !enclosingVmt.getImplementedMethods(method).isEmpty(), their information\n+            \/\/   will be printed if *any* of the below is true:\n+            \/\/     * the enclosing has _directly_ implemented interfaces\n+            \/\/     * the overridden method is not null\n+            \/\/   If both are false, the information will not be printed: there will be no\n+            \/\/   \"Specified by\" documentation. The examples of that can be seen in documentation\n+            \/\/   for these methods:\n+            \/\/     * ForkJoinPool.execute(java.lang.Runnable)\n+            \/\/  This is a long-standing bug, which must be fixed separately: JDK-8302316\n+            MethodWriterImpl.addImplementsInfo(this, method, implementedMethods, dl);\n+        }\n+        if (overrideInfo != null) {\n+            MethodWriterImpl.addOverridden(this,\n+                    overrideInfo.overriddenMethodOwner(),\n+                    overrideInfo.overriddenMethod(),\n+                    dl);\n@@ -1783,1 +1790,1 @@\n-        linkInfo.label = Text.of(\"@\" + annotationDoc.getSimpleName());\n+        linkInfo.label(\"@\" + annotationDoc.getSimpleName());\n@@ -1899,1 +1906,1 @@\n-                        linkInfo.label = Text.of(name + utils.getDimension(t) + \".class\");\n+                        linkInfo.label(name + utils.getDimension(t) + \".class\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":26,"deletions":19,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.type.ArrayType;\n@@ -38,0 +40,3 @@\n+import javax.lang.model.type.TypeVariable;\n+import javax.lang.model.type.WildcardType;\n+import javax.lang.model.util.SimpleTypeVisitor14;\n@@ -48,0 +53,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n@@ -49,2 +55,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.links.LinkFactory;\n-import jdk.javadoc.internal.doclets.toolkit.util.links.LinkInfo;\n@@ -55,1 +59,1 @@\n-public class HtmlLinkFactory extends LinkFactory {\n+public class HtmlLinkFactory {\n@@ -59,0 +63,1 @@\n+    private final Utils utils;\n@@ -60,0 +65,5 @@\n+    \/**\n+     * Constructs a new link factory.\n+     *\n+     * @param writer the HTML doclet writer\n+     *\/\n@@ -61,1 +71,0 @@\n-        super(writer.configuration.utils);\n@@ -64,0 +73,1 @@\n+        utils = writer.configuration.utils;\n@@ -66,1 +76,3 @@\n-    @Override\n+    \/**\n+     * {@return a new instance of a content object}\n+     *\/\n@@ -71,2 +83,136 @@\n-    @Override\n-    protected Content getClassLink(LinkInfo linkInfo) {\n+    \/**\n+     * Constructs a link from the given link information.\n+     *\n+     * @param linkInfo the information about the link.\n+     * @return the link.\n+     *\/\n+    public Content getLink(HtmlLinkInfo linkInfo) {\n+        if (linkInfo.getType() != null) {\n+            SimpleTypeVisitor14<Content, HtmlLinkInfo> linkVisitor = new SimpleTypeVisitor14<>() {\n+\n+                final Content link = newContent();\n+\n+                \/\/ handles primitives, no types and error types\n+                @Override\n+                protected Content defaultAction(TypeMirror type, HtmlLinkInfo linkInfo) {\n+                    link.add(utils.getTypeName(type, false));\n+                    return link;\n+                }\n+\n+                int currentDepth = 0;\n+                @Override\n+                public Content visitArray(ArrayType type, HtmlLinkInfo linkInfo) {\n+                    \/\/ keep track of the dimension depth and replace the last dimension\n+                    \/\/ specifier with varargs, when the stack is fully unwound.\n+                    currentDepth++;\n+                    var componentType = type.getComponentType();\n+                    visit(componentType, linkInfo.forType(componentType));\n+                    currentDepth--;\n+                    if (utils.isAnnotated(type)) {\n+                        link.add(\" \");\n+                        link.add(getTypeAnnotationLinks(linkInfo));\n+                    }\n+                    \/\/ use vararg if required\n+                    if (linkInfo.isVarArg() && currentDepth == 0) {\n+                        link.add(\"...\");\n+                    } else {\n+                        link.add(\"[]\");\n+                    }\n+                    return link;\n+                }\n+\n+                @Override\n+                public Content visitWildcard(WildcardType type, HtmlLinkInfo linkInfo) {\n+                    link.add(getTypeAnnotationLinks(linkInfo));\n+                    link.add(\"?\");\n+                    TypeMirror extendsBound = type.getExtendsBound();\n+                    if (extendsBound != null) {\n+                        link.add(\" extends \");\n+                        link.add(getLink(getBoundsLinkInfo(linkInfo, extendsBound)));\n+                    }\n+                    TypeMirror superBound = type.getSuperBound();\n+                    if (superBound != null) {\n+                        link.add(\" super \");\n+                        link.add(getLink(getBoundsLinkInfo(linkInfo, superBound)));\n+                    }\n+                    return link;\n+                }\n+\n+                @Override\n+                public Content visitTypeVariable(TypeVariable type, HtmlLinkInfo linkInfo) {\n+                    link.add(getTypeAnnotationLinks(linkInfo));\n+                    TypeVariable typevariable = (utils.isArrayType(type))\n+                            ? (TypeVariable) utils.getComponentType(type)\n+                            : type;\n+                    Element owner = typevariable.asElement().getEnclosingElement();\n+                    if (linkInfo.linkTypeParameters() && utils.isTypeElement(owner)) {\n+                        linkInfo.setTypeElement((TypeElement) owner);\n+                        Content label = newContent();\n+                        label.add(utils.getTypeName(type, false));\n+                        linkInfo.label(label).skipPreview(true);\n+                        link.add(getClassLink(linkInfo));\n+                    } else {\n+                        \/\/ No need to link method type parameters.\n+                        link.add(utils.getTypeName(typevariable, false));\n+                    }\n+\n+                    if (linkInfo.showTypeBounds()) {\n+                        linkInfo.showTypeBounds(false);\n+                        TypeParameterElement tpe = ((TypeParameterElement) typevariable.asElement());\n+                        boolean more = false;\n+                        List<? extends TypeMirror> bounds = utils.getBounds(tpe);\n+                        for (TypeMirror bound : bounds) {\n+                            \/\/ we get everything as extends java.lang.Object we suppress\n+                            \/\/ all of them except those that have multiple extends\n+                            if (bounds.size() == 1 &&\n+                                    utils.typeUtils.isSameType(bound, utils.getObjectType()) &&\n+                                    !utils.isAnnotated(bound)) {\n+                                continue;\n+                            }\n+                            link.add(more ? \" & \" : \" extends \");\n+                            link.add(getLink(getBoundsLinkInfo(linkInfo, bound)));\n+                            more = true;\n+                        }\n+                    }\n+                    return link;\n+                }\n+\n+                @Override\n+                public Content visitDeclared(DeclaredType type, HtmlLinkInfo linkInfo) {\n+                    TypeMirror enc = type.getEnclosingType();\n+                    if (enc instanceof DeclaredType dt && utils.isGenericType(dt)) {\n+                        \/\/ If an enclosing type has type parameters render them as separate links as\n+                        \/\/ otherwise this information is lost. On the other hand, plain enclosing types\n+                        \/\/ are not linked separately as they are easy to reach from the nested type.\n+                        visitDeclared(dt, linkInfo.forType(dt));\n+                        link.add(\".\");\n+                    }\n+                    link.add(getTypeAnnotationLinks(linkInfo));\n+                    linkInfo.setTypeElement(utils.asTypeElement(type));\n+                    link.add(getClassLink(linkInfo));\n+                    if (linkInfo.showTypeParameters()) {\n+                        link.add(getTypeParameterLinks(linkInfo));\n+                    }\n+                    return link;\n+                }\n+            };\n+            return linkVisitor.visit(linkInfo.getType(), linkInfo);\n+        } else if (linkInfo.getTypeElement() != null) {\n+            Content link = newContent();\n+            link.add(getClassLink(linkInfo));\n+            if (linkInfo.showTypeParameters()) {\n+                link.add(getTypeParameterLinks(linkInfo));\n+            }\n+            return link;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a link to the given class.\n+     *\n+     * @param linkInfo the information about the link to construct\n+     * @return the link for the given class.\n+     *\/\n+    protected Content getClassLink(HtmlLinkInfo linkInfo) {\n@@ -74,2 +220,1 @@\n-        HtmlLinkInfo classLinkInfo = (HtmlLinkInfo) linkInfo;\n-        TypeElement typeElement = classLinkInfo.typeElement;\n+        TypeElement typeElement = linkInfo.getTypeElement();\n@@ -79,4 +224,5 @@\n-        boolean hasWhere = classLinkInfo.fragment != null && classLinkInfo.fragment.length() != 0;\n-        if (!hasWhere) {\n-            boolean isTypeLink = classLinkInfo.type != null &&\n-                     utils.isTypeVariable(utils.getComponentType(classLinkInfo.type));\n+        String fragment = linkInfo.getFragment();\n+        boolean hasFragment = fragment != null && !fragment.isEmpty();\n+        if (!hasFragment) {\n+            boolean isTypeLink = linkInfo.getType() != null &&\n+                     utils.isTypeVariable(utils.getComponentType(linkInfo.getType()));\n@@ -85,1 +231,6 @@\n-        Content label = classLinkInfo.getClassLinkLabel(configuration);\n+        Content label = linkInfo.getClassLinkLabel(configuration);\n+        if (linkInfo.getContext() == HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_IN_LABEL) {\n+            \/\/ For this kind of link, type parameters are included in the link label\n+            \/\/ (and obviously not added after the link).\n+            label.add(getTypeParameterLinks(linkInfo));\n+        }\n@@ -88,2 +239,2 @@\n-        boolean showPreview = !classLinkInfo.skipPreview;\n-        if (!hasWhere && showPreview) {\n+        boolean showPreview = !linkInfo.isSkipPreview();\n+        if (!hasFragment && showPreview) {\n@@ -92,4 +243,4 @@\n-        } else if (classLinkInfo.context == HtmlLinkInfo.Kind.SHOW_PREVIEW\n-                && classLinkInfo.targetMember != null && showPreview) {\n-            flags = utils.elementFlags(classLinkInfo.targetMember);\n-            TypeElement enclosing = utils.getEnclosingTypeElement(classLinkInfo.targetMember);\n+        } else if (linkInfo.getContext() == HtmlLinkInfo.Kind.SHOW_PREVIEW\n+                && linkInfo.getTargetMember() != null && showPreview) {\n+            flags = utils.elementFlags(linkInfo.getTargetMember());\n+            TypeElement enclosing = utils.getEnclosingTypeElement(linkInfo.getTargetMember());\n@@ -105,1 +256,1 @@\n-                previewTarget = classLinkInfo.targetMember;\n+                previewTarget = linkInfo.getTargetMember();\n@@ -115,2 +266,2 @@\n-                DocPath filename = getPath(classLinkInfo);\n-                if (linkInfo.linkToSelf || typeElement != m_writer.getCurrentPageElement()) {\n+                DocPath filename = getPath(linkInfo);\n+                if (linkInfo.linkToSelf() || typeElement != m_writer.getCurrentPageElement()) {\n@@ -118,1 +269,1 @@\n-                                filename.fragment(classLinkInfo.fragment),\n+                                filename.fragment(linkInfo.getFragment()),\n@@ -120,1 +271,1 @@\n-                                classLinkInfo.style,\n+                                linkInfo.getStyle(),\n@@ -132,2 +283,2 @@\n-                typeElement, classLinkInfo.fragment,\n-                label, classLinkInfo.style, true);\n+                typeElement, linkInfo.getFragment(),\n+                label, linkInfo.getStyle(), true);\n@@ -154,2 +305,7 @@\n-    @Override\n-    protected Content getTypeParameterLinks(LinkInfo linkInfo) {\n+    \/**\n+     * Returns links to the type parameters.\n+     *\n+     * @param linkInfo the information about the link to construct\n+     * @return the links to the type parameters\n+     *\/\n+    protected Content getTypeParameterLinks(HtmlLinkInfo linkInfo) {\n@@ -158,2 +314,2 @@\n-        TypeMirror ctype = linkInfo.type != null\n-                ? utils.getComponentType(linkInfo.type)\n+        TypeMirror ctype = linkInfo.getType() != null\n+                ? utils.getComponentType(linkInfo.getType())\n@@ -161,4 +317,4 @@\n-        if (linkInfo.executableElement != null) {\n-            linkInfo.executableElement.getTypeParameters().forEach(t -> vars.add(t.asType()));\n-        } else if (linkInfo.type != null && utils.isDeclaredType(linkInfo.type)) {\n-            vars.addAll(((DeclaredType) linkInfo.type).getTypeArguments());\n+        if (linkInfo.getExecutableElement() != null) {\n+            linkInfo.getExecutableElement().getTypeParameters().forEach(t -> vars.add(t.asType()));\n+        } else if (linkInfo.getType() != null && utils.isDeclaredType(linkInfo.getType())) {\n+            vars.addAll(((DeclaredType) linkInfo.getType()).getTypeArguments());\n@@ -167,2 +323,2 @@\n-        } else if (ctype == null && linkInfo.typeElement != null) {\n-            linkInfo.typeElement.getTypeParameters().forEach(t -> vars.add(t.asType()));\n+        } else if (ctype == null && linkInfo.getTypeElement() != null) {\n+            linkInfo.getTypeElement().getTypeParameters().forEach(t -> vars.add(t.asType()));\n@@ -180,1 +336,1 @@\n-                    if (linkInfo.addLineBreaksInTypeParameters) {\n+                    if (linkInfo.addLineBreaksInTypeParameters()) {\n@@ -184,1 +340,1 @@\n-                links.add(getTypeParameterLink(linkInfo, t));\n+                links.add(getLink(linkInfo.forType(t)));\n@@ -193,1 +349,1 @@\n-     * Returns a link to the given type parameter.\n+     * Returns links to the type annotations.\n@@ -195,3 +351,2 @@\n-     * @param linkInfo     the information about the link to construct\n-     * @param typeParam the type parameter to link to\n-     * @return the link\n+     * @param linkInfo the information about the link to construct\n+     * @return the links to the type annotations\n@@ -199,13 +354,1 @@\n-    protected Content getTypeParameterLink(LinkInfo linkInfo, TypeMirror typeParam) {\n-        HtmlLinkInfo typeLinkInfo = new HtmlLinkInfo(m_writer.configuration,\n-                ((HtmlLinkInfo) linkInfo).getContext(), typeParam);\n-        typeLinkInfo.showTypeBounds = linkInfo.showTypeBounds;\n-        typeLinkInfo.linkTypeParameters = linkInfo.linkTypeParameters;\n-        typeLinkInfo.linkToSelf = linkInfo.linkToSelf;\n-        typeLinkInfo.addLineBreaksInTypeParameters = linkInfo.addLineBreaksInTypeParameters;\n-        typeLinkInfo.showTypeParameterAnnotations = linkInfo.showTypeParameterAnnotations;\n-        return getLink(typeLinkInfo);\n-    }\n-\n-    @Override\n-    public Content getTypeAnnotationLinks(LinkInfo linkInfo) {\n+    public Content getTypeAnnotationLinks(HtmlLinkInfo linkInfo) {\n@@ -214,4 +357,4 @@\n-        if (utils.isAnnotated(linkInfo.type)) {\n-            annotations = linkInfo.type.getAnnotationMirrors();\n-        } else if (utils.isTypeVariable(linkInfo.type) && linkInfo.showTypeParameterAnnotations) {\n-            Element element = utils.typeUtils.asElement(linkInfo.type);\n+        if (utils.isAnnotated(linkInfo.getType())) {\n+            annotations = linkInfo.getType().getAnnotationMirrors();\n+        } else if (utils.isTypeVariable(linkInfo.getType()) && linkInfo.showTypeParameterAnnotations()) {\n+            Element element = utils.typeUtils.asElement(linkInfo.getType());\n@@ -235,0 +378,7 @@\n+    \/*\n+     * Returns a link info for a type bounds link.\n+     *\/\n+    private HtmlLinkInfo getBoundsLinkInfo(HtmlLinkInfo linkInfo, TypeMirror bound) {\n+        return linkInfo.forType(bound).skipPreview(false);\n+    }\n+\n@@ -270,1 +420,1 @@\n-        return m_writer.pathToRoot.resolve(docPaths.forClass(linkInfo.typeElement));\n+        return m_writer.pathToRoot.resolve(docPaths.forClass(linkInfo.getTypeElement()));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlLinkFactory.java","additions":211,"deletions":61,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import javax.lang.model.type.DeclaredType;\n@@ -36,0 +37,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -38,1 +40,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.links.LinkInfo;\n@@ -44,1 +45,1 @@\n-public class HtmlLinkInfo extends LinkInfo {\n+public class HtmlLinkInfo {\n@@ -46,0 +47,3 @@\n+    \/**\n+     * Enumeration of different kinds of links.\n+     *\/\n@@ -56,1 +60,1 @@\n-         * Link with additional type parameters as plain text if appropriate.\n+         * Link with optional type parameters appended as plain text.\n@@ -59,0 +63,1 @@\n+\n@@ -60,1 +65,6 @@\n-         * Link with additional type parameters and bounds as plain text if appropriate.\n+         * Link with optional type parameters included in the link label.\n+         *\/\n+        SHOW_TYPE_PARAMS_IN_LABEL,\n+\n+        \/**\n+         * Link with optional type parameters and bounds appended as plain text.\n@@ -64,1 +74,1 @@\n-         * Link with additional type parameters as separate link if appropriate.\n+         * Link with optional type parameters but no bounds rendered as separate links.\n@@ -68,1 +78,1 @@\n-         * Link with additional type parameters and bounds as separate links if approprate.\n+         * Link with optional type parameters and bounds rendered as separate links.\n@@ -73,1 +83,1 @@\n-    public final HtmlConfiguration configuration;\n+    private final HtmlConfiguration configuration;\n@@ -75,4 +85,2 @@\n-    \/**\n-     * The context of the link.\n-     *\/\n-    public Kind context = Kind.PLAIN;\n+    \/\/ The context of the link.\n+    private Kind context = Kind.PLAIN;\n@@ -80,4 +88,2 @@\n-    \/**\n-     * The fragment of the link.\n-     *\/\n-    public String fragment = \"\";\n+    \/\/ The fragment of the link.\n+    private String fragment = \"\";\n@@ -85,4 +91,2 @@\n-    \/**\n-     * The member this link points to (if any).\n-     *\/\n-    public Element targetMember;\n+    \/\/ The member this link points to (if any).\n+    private Element targetMember;\n@@ -90,4 +94,11 @@\n-    \/**\n-     * Optional style for the link.\n-     *\/\n-    public HtmlStyle style = null;\n+    \/\/ Optional style for the link.\n+    private HtmlStyle style = null;\n+\n+    \/\/ The class we want to link to. Null if we are not linking to a class.\n+    private TypeElement typeElement;\n+\n+    \/\/ The executable element we want to link to. Null if we are not linking to an executable element.\n+    private ExecutableElement executableElement;\n+\n+    \/\/ The Type we want to link to. Null if we are not linking to a type.\n+    private TypeMirror type;\n@@ -95,1 +106,24 @@\n-    public final Utils utils;\n+    \/\/ True if this is a link to a VarArg.\n+    private boolean isVarArg = false;\n+\n+    \/\/ The label for the link.\n+    private Content label;\n+\n+    \/\/ True if we should print the type bounds for the type parameter.\n+    private boolean showTypeBounds = true;\n+\n+    \/\/ True if type parameters should be rendered as links.\n+    private boolean linkTypeParameters = true;\n+\n+    \/\/ By default, the link can be to the page it's already on.  However,\n+    \/\/ there are cases where we don't want this (e.g. heading of class page).\n+    private boolean linkToSelf = true;\n+\n+    \/\/ True iff the preview flags should be skipped for this link.\n+    private boolean skipPreview;\n+\n+    \/\/ True if type parameters should be separated by line breaks.\n+    private boolean addLineBreaksInTypeParameters = false;\n+\n+    \/\/ True if annotations on type parameters should be shown.\n+    private boolean showTypeParameterAnnotations = false;\n@@ -106,1 +140,0 @@\n-        this.utils = configuration.utils;\n@@ -111,5 +144,0 @@\n-    @Override\n-    protected Content newContent() {\n-        return new ContentBuilder();\n-    }\n-\n@@ -125,1 +153,0 @@\n-        this.utils = configuration.utils;\n@@ -139,1 +166,0 @@\n-        this.utils = configuration.utils;\n@@ -144,0 +170,49 @@\n+    \/**\n+     * Creates a copy of this HtmlLinkInfo instance with a different TypeMirror.\n+     * This is used for contained types such as type parameters or array components.\n+     *\n+     * @param type the type mirror\n+     * @return the new link info\n+     *\/\n+    public HtmlLinkInfo forType(TypeMirror type) {\n+        HtmlLinkInfo linkInfo = new HtmlLinkInfo(configuration, context, type);\n+        linkInfo.showTypeBounds = showTypeBounds;\n+        linkInfo.linkTypeParameters = linkTypeParameters;\n+        linkInfo.linkToSelf = linkToSelf;\n+        linkInfo.addLineBreaksInTypeParameters = addLineBreaksInTypeParameters;\n+        linkInfo.showTypeParameterAnnotations = showTypeParameterAnnotations;\n+        linkInfo.skipPreview = skipPreview;\n+        return linkInfo;\n+    }\n+\n+    \/**\n+     * Sets the typeElement\n+     * @param typeElement the new typeElement object\n+     *\/\n+    public void setTypeElement(TypeElement typeElement) {\n+        this.typeElement = typeElement;\n+    }\n+\n+    \/**\n+     * The class we want to link to.  Null if we are not linking\n+     * to a class.\n+     *\/\n+    public TypeElement getTypeElement() {\n+        return typeElement;\n+    }\n+\n+    \/**\n+     * The executable element we want to link to.  Null if we are not linking\n+     * to an executable element.\n+     *\/\n+    public ExecutableElement getExecutableElement() {\n+        return executableElement;\n+    }\n+\n+    \/**\n+     * The Type we want to link to.  Null if we are not linking to a type.\n+     *\/\n+    public TypeMirror getType() {\n+        return type;\n+    }\n+\n@@ -147,0 +222,1 @@\n+     * @return this object\n@@ -155,0 +231,2 @@\n+     * @param label the new value\n+     * @return this object\n@@ -161,0 +239,7 @@\n+    \/**\n+     * {@return the label for the link}\n+     *\/\n+    public Content getLabel() {\n+        return label;\n+    }\n+\n@@ -163,0 +248,2 @@\n+     * @param style the new style value\n+     * @return this object\n@@ -169,0 +256,7 @@\n+    \/**\n+     * {@return the optional style for the link}\n+     *\/\n+    public HtmlStyle getStyle() {\n+        return style;\n+    }\n+\n@@ -171,0 +265,2 @@\n+     * @param varargs the new value\n+     * @return this object\n@@ -177,0 +273,7 @@\n+    \/**\n+     * {@return true if this is a link to a vararg member}\n+     *\/\n+    public boolean isVarArg() {\n+        return isVarArg;\n+    }\n+\n@@ -179,0 +282,2 @@\n+     * @param fragment the new fragment value\n+     * @return this object\n@@ -185,0 +290,80 @@\n+    \/**\n+     * {@return the fragment of the link}\n+     *\/\n+    public String getFragment() {\n+        return fragment;\n+    }\n+\n+    \/**\n+     * Sets the addLineBreaksInTypeParameters flag for this link.\n+     * @param addLineBreaksInTypeParameters the new value\n+     * @return this object\n+     *\/\n+    public HtmlLinkInfo addLineBreaksInTypeParameters(boolean addLineBreaksInTypeParameters) {\n+        this.addLineBreaksInTypeParameters = addLineBreaksInTypeParameters;\n+        return this;\n+    }\n+\n+    \/**\n+     * {@return true if type parameters should be separated by line breaks}\n+     *\/\n+    public boolean addLineBreaksInTypeParameters() {\n+        return addLineBreaksInTypeParameters;\n+    }\n+\n+    \/**\n+     * Set the linkToSelf flag for this link.\n+     * @param linkToSelf the new value\n+     * @return this object\n+     *\/\n+    public HtmlLinkInfo linkToSelf(boolean linkToSelf) {\n+        this.linkToSelf = linkToSelf;\n+        return this;\n+    }\n+\n+    \/**\n+     * {@return true if we should generate links to the current page}\n+     *\/\n+    public boolean linkToSelf() {\n+        return linkToSelf;\n+    }\n+\n+    \/**\n+     * {@return true if type parameters should be rendered as links}\n+     *\/\n+    public boolean linkTypeParameters() {\n+        return linkTypeParameters;\n+    }\n+\n+    \/**\n+     * Set the showTypeBounds flag for this link\n+     * @param showTypeBounds the new value\n+     *\/\n+    public void showTypeBounds(boolean showTypeBounds) {\n+        this.showTypeBounds = showTypeBounds;\n+    }\n+\n+    \/**\n+     * {@return true if we should print the type bounds for the type parameter}\n+     *\/\n+    public boolean showTypeBounds() {\n+        return showTypeBounds;\n+    }\n+\n+    \/**\n+     * Set the showTypeParameterAnnotations flag for this link.\n+     * @param showTypeParameterAnnotations the new value\n+     * @return this object\n+     *\/\n+    public HtmlLinkInfo showTypeParameterAnnotations(boolean showTypeParameterAnnotations) {\n+        this.showTypeParameterAnnotations = showTypeParameterAnnotations;\n+        return this;\n+    }\n+\n+    \/**\n+     * {@return true if annotations on type parameters should be shown}\n+     *\/\n+    public boolean showTypeParameterAnnotations() {\n+        return showTypeParameterAnnotations;\n+    }\n+\n@@ -187,0 +372,2 @@\n+     * @param el the new member value\n+     * @return this object\n@@ -193,0 +380,7 @@\n+    \/**\n+     * {@return the member this link points to (if any)}\n+     *\/\n+    public Element getTargetMember() {\n+        return targetMember;\n+    }\n+\n@@ -195,0 +389,2 @@\n+     * @param skipPreview the new value\n+     * @return this object\n@@ -201,0 +397,10 @@\n+    \/**\n+     * {@return true iff the preview flags should be skipped for this link}\n+     *\/\n+    public boolean isSkipPreview() {\n+        return skipPreview;\n+    }\n+\n+    \/**\n+     * {@return the link context}\n+     *\/\n@@ -211,1 +417,1 @@\n-    public final void setContext(Kind c) {\n+    private void setContext(Kind c) {\n@@ -224,1 +430,0 @@\n-    @Override\n@@ -229,1 +434,5 @@\n-    @Override\n+    \/**\n+     * Returns true if links to declared types should include type parameters.\n+     *\n+     * @return true if type parameter links should be included\n+     *\/\n@@ -231,1 +440,35 @@\n-        return context != Kind.PLAIN && context != Kind.SHOW_PREVIEW;\n+        \/\/ Type parameters for these kinds of links are either not desired\n+        \/\/ or already included in the link label.\n+        return context != Kind.PLAIN && context != Kind.SHOW_PREVIEW\n+                && context != Kind.SHOW_TYPE_PARAMS_IN_LABEL;\n+    }\n+\n+    \/**\n+     * Return the label for this class link.\n+     *\n+     * @param configuration the current configuration of the doclet.\n+     * @return the label for this class link.\n+     *\/\n+    public Content getClassLinkLabel(BaseConfiguration configuration) {\n+        if (label != null && !label.isEmpty()) {\n+            return label;\n+        } else if (isLinkable()) {\n+            Content tlabel = newContent();\n+            Utils utils = configuration.utils;\n+            tlabel.add(type instanceof DeclaredType dt && utils.isGenericType(dt.getEnclosingType())\n+                    \/\/ If enclosing type is rendered as separate links only use own class name\n+                    ? typeElement.getSimpleName().toString()\n+                    : configuration.utils.getSimpleName(typeElement));\n+            return tlabel;\n+        } else {\n+            Content tlabel = newContent();\n+            tlabel.add(configuration.getClassName(typeElement));\n+            return tlabel;\n+        }\n+    }\n+\n+    \/**\n+     * {@return a new instance of a content object}\n+     *\/\n+    protected Content newContent() {\n+        return new ContentBuilder();\n@@ -237,1 +480,11 @@\n-                \"context=\" + context +\n+                \"typeElement=\" + typeElement +\n+                \", executableElement=\" + executableElement +\n+                \", type=\" + type +\n+                \", isVarArg=\" + isVarArg +\n+                \", label=\" + label +\n+                \", showTypeBounds=\" + showTypeBounds +\n+                \", linkTypeParameters=\" + linkTypeParameters +\n+                \", linkToSelf=\" + linkToSelf +\n+                \", addLineBreaksInTypeParameters=\" + addLineBreaksInTypeParameters +\n+                \", showTypeParameterAnnotations=\" + showTypeParameterAnnotations +\n+                \", context=\" + context +\n@@ -239,2 +492,1 @@\n-                \", style=\" + style +\n-                super.toString() + '}';\n+                \", style=\" + style + '}';\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlLinkInfo.java","additions":291,"deletions":39,"binary":false,"changes":330,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-                        HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, (TypeElement) element).style(HtmlStyle.typeNameLink)));\n+                        HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_IN_LABEL, (TypeElement) element).style(HtmlStyle.typeNameLink)));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/IndexWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Collection;\n@@ -296,3 +297,4 @@\n-     * @param writer the writer for the method\n-     * @param method the method\n-     * @param dl     the definition list\n+     * @param writer  the writer for the method\n+     * @param method  the method\n+     * @param methods implemented methods\n+     * @param dl      the definition list\n@@ -302,0 +304,1 @@\n+                                            Collection<ExecutableElement> methods,\n@@ -304,1 +307,1 @@\n-        if (utils.isStatic(method) || writer.options.noComment()) {\n+        if (writer.options.noComment()) {\n@@ -308,2 +311,2 @@\n-        VisibleMemberTable vmt = writer.configuration\n-                .getVisibleMemberTable(utils.getEnclosingTypeElement(method));\n+        var enclosing = (TypeElement) method.getEnclosingElement();\n+        VisibleMemberTable vmt = writer.configuration.getVisibleMemberTable(enclosing);\n@@ -312,1 +315,1 @@\n-        implementedMethods.addAll(vmt.getImplementedMethods(method));\n+        implementedMethods.addAll(methods);\n@@ -315,1 +318,1 @@\n-            intfac = utils.getDeclaredType(utils.getEnclosingTypeElement(method), intfac);\n+            intfac = utils.getDeclaredType(enclosing, intfac);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriterImpl.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -138,4 +138,3 @@\n-                    HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_AND_BOUNDS, typeElement);\n-            linkInfo.showTypeParameterAnnotations = true;\n-            \/\/Let's not link to ourselves in the signature.\n-            linkInfo.linkToSelf = false;\n+                    HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_AND_BOUNDS, typeElement)\n+                    .linkToSelf(false)  \/\/ Let's not link to ourselves in the signature\n+                    .showTypeParameterAnnotations(true);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Signatures.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -576,1 +576,1 @@\n-                if (overriddenMethod != null)\n+                if (overriddenMethod != null) {\n@@ -578,0 +578,1 @@\n+                }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -197,68 +197,0 @@\n-    \/\/ TODO:  need to re-implement this using j.l.m. correctly!, this has\n-    \/\/        implications on testInterface, the note here is that javac's supertype\n-    \/\/        does the right thing returning Parameters in scope.\n-    \/*\n-     * Returns the closest superclass (not the superinterface) that contains\n-     * a method that is both:\n-     *\n-     *   - overridden by the specified method, and\n-     *   - is not itself a *simple* override\n-     *\n-     * If no such class can be found, returns null.\n-     *\n-     * If the specified method belongs to an interface, the only considered\n-     * superclass is java.lang.Object no matter how many other interfaces\n-     * that interface extends.\n-     *\/\n-    public DeclaredType overriddenType(ExecutableElement method) {\n-        if (utils.isStatic(method)) {\n-            return null;\n-        }\n-        MethodSymbol sym = (MethodSymbol) method;\n-        ClassSymbol origin = (ClassSymbol) sym.owner;\n-        for (Type t = javacTypes.supertype(origin.type);\n-             t.hasTag(TypeTag.CLASS);\n-             t = javacTypes.supertype(t)) {\n-            ClassSymbol c = (ClassSymbol) t.tsym;\n-            for (Symbol sym2 : c.members().getSymbolsByName(sym.name)) {\n-                if (sym.overrides(sym2, origin, javacTypes, true)) {\n-                    \/\/ Ignore those methods that may be a simple override\n-                    \/\/ and allow the real API method to be found.\n-                    if (utils.isSimpleOverride((MethodSymbol)sym2)) {\n-                        continue;\n-                    }\n-                    assert t.hasTag(TypeTag.CLASS) && !t.isInterface();\n-                    return (Type.ClassType) t;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    \/\/ TODO: the method jx.l.m.Elements::overrides does not check\n-    \/\/ the return type, see JDK-8174840 until that is resolved,\n-    \/\/ use a  copy of the same method, with a return type check.\n-\n-    \/\/ Note: the rider.overrides call in this method *must* be consistent\n-    \/\/ with the call in overrideType(....), the method above.\n-    public boolean overrides(ExecutableElement e1, ExecutableElement e2, TypeElement cls) {\n-        MethodSymbol rider = (MethodSymbol)e1;\n-        MethodSymbol ridee = (MethodSymbol)e2;\n-        ClassSymbol origin = (ClassSymbol)cls;\n-\n-        return rider.name == ridee.name &&\n-\n-               \/\/ not reflexive as per JLS\n-               rider != ridee &&\n-\n-               \/\/ we don't care if ridee is static, though that wouldn't\n-               \/\/ compile\n-               !rider.isStatic() &&\n-\n-               \/\/ Symbol.overrides assumes the following\n-               ridee.isMemberOf(origin, javacTypes) &&\n-\n-               \/\/ check access, signatures and check return types\n-               rider.overrides(ridee, origin, javacTypes, true);\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -187,57 +187,0 @@\n-    \/**\n-     * Search for the given method in the given class.\n-     *\n-     * @param te     Class to search into.\n-     * @param method Method to be searched.\n-     *\n-     * @return Method found, null otherwise.\n-     *\/\n-    public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {\n-        for (ExecutableElement m : getMethods(te)) {\n-            if (executableMembersEqual(method, m)) {\n-                return m;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * Test whether a class is a subclass of another class.\n-     *\n-     * @param t1 the candidate subclass\n-     * @param t2 the candidate superclass\n-     * @return true if t1 is a superclass of t2\n-     *\/\n-    public boolean isSubclassOf(TypeElement t1, TypeElement t2) {\n-        return typeUtils.isSubtype(typeUtils.erasure(t1.asType()), typeUtils.erasure(t2.asType()));\n-    }\n-\n-    \/**\n-     * @param e1 the first method to compare.\n-     * @param e2 the second method to compare.\n-     * @return true if member1 overrides\/hides or is overridden\/hidden by member2.\n-     *\/\n-    public boolean executableMembersEqual(ExecutableElement e1, ExecutableElement e2) {\n-        \/\/ TODO: investigate if Elements.hides(..) will work here.\n-        if (isStatic(e1) && isStatic(e2)) {\n-            List<? extends VariableElement> parameters1 = e1.getParameters();\n-            List<? extends VariableElement> parameters2 = e2.getParameters();\n-            if (e1.getSimpleName().equals(e2.getSimpleName()) &&\n-                    parameters1.size() == parameters2.size()) {\n-                for (int j = 0; j < parameters1.size(); j++) {\n-                    VariableElement v1 = parameters1.get(j);\n-                    VariableElement v2 = parameters2.get(j);\n-                    if (!typeUtils.isSameType(v1.asType(), v2.asType())) {\n-                        return false;\n-                    }\n-                }\n-                return true;\n-            }\n-            return false;\n-        } else {\n-            return elementUtils.overrides(e1, e2, getEnclosingTypeElement(e1)) ||\n-                    elementUtils.overrides(e2, e1, getEnclosingTypeElement(e2)) ||\n-                    e1.equals(e2);\n-        }\n-    }\n-\n@@ -335,0 +278,8 @@\n+    \/*\n+     * A contemporary JLS term for \"package private\" or \"default access\" is\n+     * \"package access\". For example: \"a member is declared with package\n+     * access\" or \"a member has package access\".\n+     *\n+     * This is to avoid confusion with unrelated _default_ methods which\n+     * appeared in JDK 8.\n+     *\/\n@@ -336,1 +287,4 @@\n-        return !(isPublic(e) || isPrivate(e) || isProtected(e));\n+        var m = e.getModifiers();\n+        return !m.contains(Modifier.PUBLIC)\n+                && !m.contains(Modifier.PROTECTED)\n+                && !m.contains(Modifier.PRIVATE);\n@@ -425,4 +379,0 @@\n-    public boolean isNoType(TypeMirror t) {\n-        return t.getKind() == NONE;\n-    }\n-\n@@ -662,0 +612,8 @@\n+    \/*\n+     * The record is used to pass the method along with the type where that method is visible.\n+     * Passing the type explicitly allows to preserve a complete type information, including\n+     * parameterization.\n+     *\/\n+    public record OverrideInfo(ExecutableElement overriddenMethod,\n+                               DeclaredType overriddenMethodOwner) { }\n+\n@@ -675,23 +633,8 @@\n-    public DeclaredType overriddenType(ExecutableElement method) {\n-        return configuration.workArounds.overriddenType(method);\n-    }\n-\n-    private  TypeMirror getType(TypeMirror t) {\n-        return (isNoType(t)) ? getObjectType() : t;\n-    }\n-\n-    public TypeMirror getSuperType(TypeElement te) {\n-        TypeMirror t = te.getSuperclass();\n-        return getType(t);\n-    }\n-\n-    public ExecutableElement overriddenMethod(ExecutableElement method) {\n-        if (isStatic(method)) {\n-            return null;\n-        }\n-        final TypeElement origin = getEnclosingTypeElement(method);\n-        for (TypeMirror t = getSuperType(origin);\n-             t.getKind() == DECLARED;\n-             t = getSuperType(asTypeElement(t))) {\n-            TypeElement te = asTypeElement(t);\n-            if (te == null) {\n+    public OverrideInfo overriddenMethod(ExecutableElement method) {\n+        var t = method.getEnclosingElement().asType();\n+        \/\/ in this context, consider java.lang.Object to be the superclass of an interface\n+        while (true) {\n+            var supertypes = typeUtils.directSupertypes(t);\n+            if (supertypes.isEmpty()) {\n+                \/\/ reached the top of the hierarchy\n+                assert typeUtils.isSameType(getObjectType(), t);\n@@ -700,0 +643,4 @@\n+            t = supertypes.get(0);\n+            \/\/ if non-empty, the first element is always the superclass\n+            var te = (TypeElement) ((DeclaredType) t).asElement();\n+            assert te.getKind().isClass();\n@@ -702,2 +649,2 @@\n-                ExecutableElement ee = (ExecutableElement)e;\n-                if (configuration.workArounds.overrides(method, ee, origin) &&\n+                var ee = (ExecutableElement) e;\n+                if (elementUtils.overrides(method, ee, (TypeElement) method.getEnclosingElement()) &&\n@@ -705,1 +652,1 @@\n-                    return ee;\n+                    return new OverrideInfo(ee, (DeclaredType) t);\n@@ -708,2 +655,0 @@\n-            if (typeUtils.isSameType(t, getObjectType()))\n-                return null;\n@@ -711,1 +656,0 @@\n-        return null;\n@@ -1065,11 +1009,0 @@\n-    public TypeElement getSuperClass(TypeElement te) {\n-        if (checkType(te)) {\n-            return null;\n-        }\n-        TypeMirror superclass = te.getSuperclass();\n-        if (isNoType(superclass) && isClass(te)) {\n-            superclass = getObjectType();\n-        }\n-        return asTypeElement(superclass);\n-    }\n-\n@@ -1095,17 +1028,16 @@\n-        List<? extends TypeMirror> superTypes = typeUtils.directSupertypes(type);\n-        TypeMirror superType = superTypes.isEmpty() ? getObjectType() : superTypes.get(0);\n-        TypeElement superClass = asTypeElement(superType);\n-        \/\/ skip \"hidden\" classes\n-        while ((superClass != null && hasHiddenTag(superClass))\n-                || (superClass != null &&  !isPublic(superClass) && !isLinkable(superClass))) {\n-            TypeMirror supersuperType = superClass.getSuperclass();\n-            TypeElement supersuperClass = asTypeElement(supersuperType);\n-            if (supersuperClass == null\n-                    || supersuperClass.getQualifiedName().equals(superClass.getQualifiedName())) {\n-                break;\n-            }\n-            superType = supersuperType;\n-            superClass = supersuperClass;\n-        }\n-        if (typeUtils.isSameType(type, superType)) {\n-            return null;\n+        \/\/ TODO: this computation should be eventually delegated to VisibleMemberTable\n+        Set<TypeElement> alreadySeen = null;\n+        \/\/ create a set iff assertions are enabled, to assert that no class\n+        \/\/ appears more than once in a superclass hierarchy\n+        assert (alreadySeen = new HashSet<>()) != null;\n+        for (var t = type; ;) {\n+            var supertypes = typeUtils.directSupertypes(t);\n+            if (supertypes.isEmpty()) { \/\/ end of hierarchy\n+                return null;\n+            }\n+            t = supertypes.get(0); \/\/ if non-empty, the first element is always the superclass\n+            var te = asTypeElement(t);\n+            assert alreadySeen.add(te); \/\/ it should be the first time we see `te`\n+            if (!hasHiddenTag(te) && (isPublic(te) || isLinkable(te))) {\n+                return t;\n+            }\n@@ -1113,1 +1045,0 @@\n-        return superType;\n@@ -1116,1 +1047,0 @@\n-\n@@ -2457,0 +2387,6 @@\n+        \/\/ TODO: remove this short-circuit after JDK-8302545 has been fixed\n+        \/\/  or --ignore-source-errors has been removed\n+        if (e.getKind() == ElementKind.PACKAGE\n+                && e.getEnclosingElement() == null) {\n+            return null;\n+        }\n@@ -2461,0 +2397,5 @@\n+        \/\/ TODO: remove this short-circuit after JDK-8302545 has been fixed\n+        \/\/  or --ignore-source-errors has been removed\n+        if (e.getKind() == ElementKind.PACKAGE) {\n+            return (PackageElement) e;\n+        }\n@@ -2804,1 +2745,4 @@\n-        return new DocFinder(this::overriddenMethod, this::implementedMethods);\n+        return new DocFinder(e -> {\n+            var i = overriddenMethod(e);\n+            return i == null ? null : i.overriddenMethod();\n+        }, this::implementedMethods);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":66,"deletions":122,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import javax.lang.model.element.Name;\n@@ -42,1 +43,0 @@\n-import javax.lang.model.util.SimpleElementVisitor14;\n@@ -59,0 +59,1 @@\n+import java.util.stream.Collectors;\n@@ -144,0 +145,1 @@\n+    \/** The class or interface described by this table. *\/\n@@ -145,0 +147,4 @@\n+    \/**\n+     * The superclass of {@link #te} or null if {@code te} is an\n+     * interface or {@code java.lang.Object}.\n+     *\/\n@@ -152,1 +158,13 @@\n-    private final List<VisibleMemberTable> allSuperclasses;\n+    \/**\n+     * Tables for direct and indirect superclasses.\n+     *\n+     * Tables for superclasses must be unique: no class can appear multiple\n+     * times in the inheritance hierarchy for some other class.\n+     *\/\n+    private final Set<VisibleMemberTable> allSuperclasses;\n+    \/**\n+     * Tables for direct and indirect superinterfaces.\n+     *\n+     * Tables for superinterfaces might not be unique (i.e. an interface\n+     * may be added from different lineages).\n+     *\/\n@@ -154,1 +172,6 @@\n-    private final List<VisibleMemberTable> parents;\n+    \/**\n+     * Tables for direct superclass and direct superinterfaces.\n+     *\n+     * The position of a table for the superclass in the list is unspecified.\n+     *\/\n+    private final Set<VisibleMemberTable> parents;\n@@ -159,2 +182,6 @@\n-    \/\/ Keeps track of method overrides\n-    private final Map<ExecutableElement, OverriddenMethodInfo> overriddenMethodTable\n+    \/\/  FIXME: Figure out why it is one-one and not one-to-many.\n+    \/**\n+     * Maps a method m declared in {@code te} to a visible method m' in a\n+     * {@code te}'s supertype such that m overrides m'.\n+     *\/\n+    private final Map<ExecutableElement, OverrideInfo> overriddenMethodTable\n@@ -169,1 +196,1 @@\n-        parent = utils.getSuperClass(te);\n+        parent = (TypeElement) utils.typeUtils.asElement(te.getSuperclass());\n@@ -171,1 +198,1 @@\n-        allSuperclasses = new ArrayList<>();\n+        allSuperclasses = new LinkedHashSet<>();\n@@ -173,1 +200,1 @@\n-        parents = new ArrayList<>();\n+        parents = new LinkedHashSet<>();\n@@ -188,1 +215,1 @@\n-    List<VisibleMemberTable> getAllSuperclasses() {\n+    private Set<VisibleMemberTable> getAllSuperclasses() {\n@@ -193,1 +220,1 @@\n-    List<VisibleMemberTable> getAllSuperinterfaces() {\n+    private List<VisibleMemberTable> getAllSuperinterfaces() {\n@@ -230,1 +257,0 @@\n-\n@@ -264,3 +290,11 @@\n-     * Returns the overridden method, if it is simply overriding or the\n-     * method is a member of a package private type, this method is\n-     * primarily used to determine the location of a possible comment.\n+     * Returns the method overridden by the provided method, or {@code null}.\n+     *\n+     * Sometimes it's not possible to link to a method that a link, linkplain,\n+     * or see tag mentions. This is because the method is a \"simple override\"\n+     * and, thus, has no useful documentation, or because the method is\n+     * declared in a type that has package access and, thus, has no visible\n+     * documentation.\n+     *\n+     * Call this method to determine if any of the above is the case. If the\n+     * call returns a method element, link to that method element instead of\n+     * the provided method.\n@@ -269,1 +303,1 @@\n-     * @return the method found or null\n+     * @return the method found or {@code null}\n@@ -272,0 +306,1 @@\n+        \/\/ TODO: consider possible ambiguities: multiple overridden methods\n@@ -273,2 +308,2 @@\n-\n-        OverriddenMethodInfo found = overriddenMethodTable.get(e);\n+        assert !overriddenMethodTable.containsKey(null);\n+        OverrideInfo found = overriddenMethodTable.get(e);\n@@ -288,1 +323,1 @@\n-    public boolean isNotSimpleOverride(ExecutableElement e) {\n+    private boolean isNotSimpleOverride(ExecutableElement e) {\n@@ -414,1 +449,2 @@\n-                parents.add(vmt);\n+                boolean added = parents.add(vmt);\n+                assert added; \/\/ no duplicates\n@@ -422,0 +458,1 @@\n+            assert Collections.disjoint(allSuperclasses, vmt.getAllSuperclasses()); \/\/ no duplicates\n@@ -423,1 +460,1 @@\n-            \/\/ Add direct superinterfaces of a superclass, if any.\n+            \/\/ Add direct and indirect superinterfaces of a superclass.\n@@ -425,1 +462,2 @@\n-            parents.add(vmt);\n+            boolean added = parents.add(vmt);\n+            assert added; \/\/ no duplicates\n@@ -472,1 +510,1 @@\n-        return isInherited(e) && !isMemberHidden(e, kind, lmt);\n+        return isAccessible(e) && !isMemberHidden(e, kind, lmt);\n@@ -475,1 +513,1 @@\n-    private boolean isInherited(Element e) {\n+    private boolean isAccessible(Element e) {\n@@ -490,1 +528,1 @@\n-                List<Element> list = lmt.getMembers(inheritedMember, kind);\n+                List<Element> list = lmt.getMembers(inheritedMember.getSimpleName(), kind);\n@@ -519,0 +557,11 @@\n+    \/\/ This method computes data structures related to method members\n+    \/\/ of a class or an interface.\n+    \/\/\n+    \/\/ TODO The computation is performed manually, by applying JLS rules.\n+    \/\/  While jdk.javadoc does need custom and specialized data structures,\n+    \/\/  this method does not feel DRY. It should be possible to improve\n+    \/\/  it by delegating some, if not most, of the JLS wrestling to\n+    \/\/  javax.lang.model. For example, while it cannot help us get the\n+    \/\/  structures, such as overriddenMethodTable, javax.lang.model can\n+    \/\/  help us get all method members of a class or an interface t by calling\n+    \/\/  ElementFilter.methodsIn(Elements.getAllMembers(t)).\n@@ -520,1 +569,23 @@\n-        Set<Element> inheritedMethods = new LinkedHashSet<>();\n+        \/\/ parentMethods is a union of visible methods from all parents.\n+        \/\/ It is used to figure out which methods this type should inherit.\n+        \/\/ Inherited methods are those parent methods that remain after all\n+        \/\/ methods that cannot be inherited are eliminated.\n+        Set<Element> parentMethods = new LinkedHashSet<>();\n+        for (var p : parents) {\n+            \/\/ Lists of visible methods from different parents may share some\n+            \/\/ methods. These are the methods that the parents inherited from\n+            \/\/ their common ancestor.\n+            \/\/\n+            \/\/ Such methods won't result in duplicates in parentMethods as we\n+            \/\/ purposefully don't track duplicates.\n+            \/\/ FIXME: add a test to assert the order (LinkedHashSet)\n+            parentMethods.addAll(p.getAllVisibleMembers(Kind.METHODS));\n+        }\n+\n+        \/\/ overriddenByTable maps an ancestor (grandparent and above) method\n+        \/\/ to parent methods that override it:\n+        \/\/\n+        \/\/ key\n+        \/\/ : a method overridden by one or more parent methods\n+        \/\/ value\n+        \/\/ : a list of parent methods that override the key\n@@ -522,1 +593,1 @@\n-        for (VisibleMemberTable pvmt : parents) {\n+        for (var p : parents) {\n@@ -524,1 +595,1 @@\n-            pvmt.overriddenMethodTable.forEach((method, methodInfo) -> {\n+            p.overriddenMethodTable.forEach((method, methodInfo) -> {\n@@ -526,1 +597,1 @@\n-                    List<ExecutableElement> list = overriddenByTable.computeIfAbsent(methodInfo.overriddenMethod,\n+                    var list = overriddenByTable.computeIfAbsent(methodInfo.overriddenMethod,\n@@ -531,1 +602,0 @@\n-            inheritedMethods.addAll(pvmt.getAllVisibleMembers(Kind.METHODS));\n@@ -534,5 +604,2 @@\n-        \/\/ Filter out inherited methods that:\n-        \/\/ a. cannot be overridden (private instance members)\n-        \/\/ b. are overridden and should not be visible in this type\n-        \/\/ c. are hidden in the type being considered\n-        \/\/ see allowInheritedMethod, which performs the above actions\n+        \/\/ filter out methods that aren't inherited\n+        \/\/\n@@ -542,1 +609,1 @@\n-        List<Element> inheritedMethodsList = inheritedMethods.stream()\n+        List<Element> inheritedMethods = parentMethods.stream()\n@@ -546,6 +613,4 @@\n-        \/\/ Filter out the local methods, that do not override or simply\n-        \/\/ overrides a super method, or those methods that should not\n-        \/\/ be visible.\n-        Predicate<ExecutableElement> isVisible = m -> {\n-            OverriddenMethodInfo p = overriddenMethodTable.getOrDefault(m, null);\n-            return p == null || !p.simpleOverride;\n+        \/\/ filter out \"simple overrides\" from local methods\n+        Predicate<ExecutableElement> nonSimpleOverride = m -> {\n+            OverrideInfo i = overriddenMethodTable.get(m);\n+            return i == null || !i.simpleOverride;\n@@ -557,1 +622,1 @@\n-                .filter(isVisible);\n+                .filter(nonSimpleOverride);\n@@ -561,1 +626,2 @@\n-        List<Element> list = Stream.concat(localStream, inheritedMethodsList.stream())\n+        \/\/ FIXME add a test to assert the order or remove that part of the comment above ^\n+        List<Element> list = Stream.concat(localStream, inheritedMethods.stream())\n@@ -567,1 +633,1 @@\n-        \/\/ Copy over overridden tables from the lineage, and finish up.\n+        \/\/ copy over overridden tables from the lineage\n@@ -569,0 +635,7 @@\n+            \/\/ a key in overriddenMethodTable is a method _declared_ in the respective parent;\n+            \/\/ no two _different_ parents can share a declared method, by definition;\n+            \/\/ if parents in the list are different (i.e. the list of parents doesn't contain duplicates),\n+            \/\/   then no keys are equal and thus no replace happens\n+            \/\/ if the list of parents contains duplicates, values for the equal keys are equal,\n+            \/\/   so no harm if they are replaced in the map\n+            assert putAllIsNonReplacing(overriddenMethodTable, pvmt.overriddenMethodTable);\n@@ -573,3 +646,8 @@\n-    boolean isEnclosureInterface(Element e) {\n-        TypeElement enclosing = utils.getEnclosingTypeElement(e);\n-        return utils.isPlainInterface(enclosing);\n+    private static <K, V> boolean putAllIsNonReplacing(Map<K, V> dst, Map<K, V> src) {\n+        for (var e : src.entrySet()) {\n+            if (dst.containsKey(e.getKey())\n+                    && !Objects.equals(dst.get(e.getKey()), e.getValue())) {\n+                return false;\n+            }\n+        }\n+        return true;\n@@ -578,4 +656,16 @@\n-    boolean allowInheritedMethod(ExecutableElement inheritedMethod,\n-                                 Map<ExecutableElement, List<ExecutableElement>> overriddenByTable,\n-                                 LocalMemberTable lmt) {\n-        if (!isInherited(inheritedMethod))\n+    private boolean allowInheritedMethod(ExecutableElement inheritedMethod,\n+                                         Map<ExecutableElement, List<ExecutableElement>> overriddenByTable,\n+                                         LocalMemberTable lmt) {\n+        \/\/ JLS 8.4.8: A class does not inherit private or static methods from\n+        \/\/ its superinterface types.\n+        \/\/\n+        \/\/ JLS 9.4.1: An interface does not inherit private or static methods\n+        \/\/ from its superinterfaces.\n+        \/\/\n+        \/\/ JLS 8.4.8: m is public, protected, or declared with package access\n+        \/\/ in the same package as C\n+        \/\/\n+        \/\/ JLS 9.4: A method in the body of an interface declaration may be\n+        \/\/ declared public or private. If no access modifier is given, the\n+        \/\/ method is implicitly public.\n+        if (!isAccessible(inheritedMethod))\n@@ -585,1 +675,1 @@\n-        final boolean inInterface = isEnclosureInterface(inheritedMethod);\n+        final boolean inInterface = isDeclaredInInterface(inheritedMethod);\n@@ -587,1 +677,1 @@\n-        \/\/ Static methods in interfaces are never documented.\n+        \/\/ Static interface methods are never inherited (JLS 8.4.8 and 9.1.3)\n@@ -604,1 +694,1 @@\n-                        .anyMatch(this::isEnclosureInterface);\n+                        .anyMatch(this::isDeclaredInInterface);\n@@ -613,1 +703,2 @@\n-        List<Element> lMethods = lmt.getMembers(inheritedMethod, Kind.METHODS);\n+        \/\/ List contains overloads and probably something else, but one match is enough, hence short-circuiting\n+        List<Element> lMethods = lmt.getMembers(inheritedMethod.getSimpleName(), Kind.METHODS);\n@@ -617,1 +708,1 @@\n-            \/\/ a \"hidden\" tag.\n+            \/\/ a \"hidden\" tag. \/\/ FIXME I cannot see where @hidden is ignored\n@@ -631,0 +722,2 @@\n+                assert utils.getEnclosingTypeElement(lMethod).equals(te);\n+\n@@ -634,0 +727,3 @@\n+                    \/\/ FIXME\n+                    \/\/  is simpleOverride=false here to force to be used because\n+                    \/\/  it cannot be linked to, because package-private?\n@@ -635,1 +731,1 @@\n-                            l -> new OverriddenMethodInfo(inheritedMethod, false));\n+                            l -> new OverrideInfo(inheritedMethod, false));\n@@ -647,1 +743,1 @@\n-                        l -> new OverriddenMethodInfo(inheritedMethod, simpleOverride));\n+                        l -> new OverrideInfo(inheritedMethod, simpleOverride));\n@@ -654,0 +750,4 @@\n+    private boolean isDeclaredInInterface(ExecutableElement e) {\n+        return e.getEnclosingElement().getKind() == ElementKind.INTERFACE;\n+    }\n+\n@@ -739,6 +839,3 @@\n-     * This class encapsulates the details of local members, orderedMembers\n-     * contains the members in the declaration order, additionally a\n-     * HashMap is maintained for performance optimization to lookup\n-     * members. As a future enhancement is perhaps to consolidate the ordering\n-     * into a Map, capturing the insertion order, thereby eliminating an\n-     * ordered list.\n+     * A container of members declared in this class or interface. Members of\n+     * the same kind stored in declaration order. The container supports\n+     * efficient lookup by a member's simple name.\n@@ -746,4 +843,1 @@\n-    class LocalMemberTable {\n-\n-        \/\/ Maintains declaration order\n-        private final Map<Kind, List<Element>> orderedMembers;\n+    private class LocalMemberTable {\n@@ -751,2 +845,2 @@\n-        \/\/ Performance optimization\n-        private final Map<Kind, Map<String, List<Element>>> memberMap;\n+        final Map<Kind, List<Element>> orderedMembers = new EnumMap<>(Kind.class);\n+        final Map<Kind, Map<Name, List<Element>>> namedMembers = new EnumMap<>(Kind.class);\n@@ -755,3 +849,2 @@\n-            orderedMembers = new EnumMap<>(Kind.class);\n-            memberMap = new EnumMap<>(Kind.class);\n-\n+            \/\/ elements directly declared by this class or interface,\n+            \/\/ listed in declaration order\n@@ -774,0 +867,3 @@\n+                    case ENUM_CONSTANT:\n+                        addMember(e, Kind.ENUM_CONSTANTS);\n+                        break;\n@@ -776,1 +872,0 @@\n-                            ExecutableElement ee = (ExecutableElement) e;\n@@ -778,1 +873,1 @@\n-                            addMember(e, ee.getDefaultValue() == null\n+                            addMember(e, ((ExecutableElement) e).getDefaultValue() == null\n@@ -786,4 +881,1 @@\n-                            addMember(e, Kind.CONSTRUCTORS);\n-                        break;\n-                    case ENUM_CONSTANT:\n-                        addMember(e, Kind.ENUM_CONSTANTS);\n+                        addMember(e, Kind.CONSTRUCTORS);\n@@ -794,8 +886,3 @@\n-            \/\/ Freeze the data structures\n-            for (Kind kind : Kind.values()) {\n-                orderedMembers.computeIfPresent(kind, (k, v) -> Collections.unmodifiableList(v));\n-                orderedMembers.computeIfAbsent(kind, t -> List.of());\n-\n-                memberMap.computeIfPresent(kind, (k, v) -> Collections.unmodifiableMap(v));\n-                memberMap.computeIfAbsent(kind, t -> Map.of());\n-            }\n+            \/\/ protect element lists from unintended changes by clients\n+            orderedMembers.replaceAll(this::sealList);\n+            namedMembers.values().forEach(m -> m.replaceAll(this::sealList));\n@@ -804,12 +891,2 @@\n-        String getMemberKey(Element e) {\n-            return new SimpleElementVisitor14<String, Void>() {\n-                @Override\n-                public String visitExecutable(ExecutableElement e, Void aVoid) {\n-                    return e.getSimpleName() + \":\" + e.getParameters().size();\n-                }\n-\n-                @Override\n-                protected String defaultAction(Element e, Void aVoid) {\n-                    return e.getSimpleName().toString();\n-                }\n-            }.visit(e);\n+        private <K, V> List<V> sealList(K unusedKey, List<V> v) {\n+            return Collections.unmodifiableList(v);\n@@ -819,6 +896,4 @@\n-            List<Element> list = orderedMembers.computeIfAbsent(kind, k -> new ArrayList<>());\n-            list.add(e);\n-\n-            Map<String, List<Element>> map = memberMap.computeIfAbsent(kind, k -> new HashMap<>());\n-            list = map.computeIfAbsent(getMemberKey(e), l -> new ArrayList<>());\n-            list.add(e);\n+            orderedMembers.computeIfAbsent(kind, k -> new ArrayList<>()).add(e);\n+            namedMembers.computeIfAbsent(kind, k -> new HashMap<>())\n+                    .computeIfAbsent(e.getSimpleName(), l -> new ArrayList<>())\n+                    .add(e);\n@@ -828,1 +903,1 @@\n-            return orderedMembers.get(kind);\n+            return orderedMembers.getOrDefault(kind, List.of());\n@@ -831,3 +906,3 @@\n-        List<Element> getMembers(Element e, Kind kind) {\n-            String key = getMemberKey(e);\n-            return getMembers(key, kind);\n+        List<Element> getMembers(Name simpleName, Kind kind) {\n+            return namedMembers.getOrDefault(kind, Map.of())\n+                    .getOrDefault(simpleName, List.of());\n@@ -836,8 +911,2 @@\n-        List<Element> getMembers(String key, Kind kind) {\n-            Map<String, List<Element>> map = memberMap.get(kind);\n-            return map.getOrDefault(key, List.of());\n-        }\n-\n-        <T extends Element> List<T> getMembers(String key, Kind kind, Class<T> clazz) {\n-            Map<String, List<Element>> map = memberMap.get(kind);\n-            return map.getOrDefault(key, List.of())\n+        <T extends Element> List<T> getMembers(Name simpleName, Kind kind, Class<T> clazz) {\n+            return getMembers(simpleName, kind)\n@@ -849,2 +918,2 @@\n-        List<ExecutableElement> getPropertyMethods(String methodName, int argcount) {\n-            return getMembers(methodName + \":\" + argcount, Kind.METHODS).stream()\n+        List<ExecutableElement> getPropertyMethods(Name simpleName) {\n+            return getMembers(simpleName, Kind.METHODS).stream()\n@@ -857,2 +926,2 @@\n-    record PropertyMembers(ExecutableElement propertyMethod, VariableElement field,\n-                           ExecutableElement getter, ExecutableElement setter) { }\n+    private record PropertyMembers(ExecutableElement propertyMethod, VariableElement field,\n+                                   ExecutableElement getter, ExecutableElement setter) { }\n@@ -914,1 +983,1 @@\n-            List<VariableElement> flist = lmt.getMembers(baseName, Kind.FIELDS, VariableElement.class);\n+            List<VariableElement> flist = lmt.getMembers(utils.elementUtils.getName(baseName), Kind.FIELDS, VariableElement.class);\n@@ -917,7 +986,8 @@\n-            ExecutableElement getter = null, setter = null;\n-            List<ExecutableElement> found = lmt.getPropertyMethods(pUtils.getGetName(propertyMethod), 0);\n-            if (!found.isEmpty()) {\n-                \/\/ Getters have zero params, no overloads! pick the first.\n-                getter = found.get(0);\n-            }\n-            if (getter == null) {\n+            \/\/ TODO: this code does not seem to be covered by tests well (JDK-8304170)\n+            ExecutableElement getter = null;\n+            var g = lmt.getPropertyMethods(utils.elementUtils.getName(pUtils.getGetName(propertyMethod))).stream()\n+                    .filter(m -> m.getParameters().isEmpty()) \/\/ Getters have zero params, no overloads!\n+                    .findAny();\n+            if (g.isPresent()) {\n+                getter = g.get();\n+            } else {\n@@ -925,2 +995,4 @@\n-                found = lmt.getPropertyMethods(pUtils.getIsName(propertyMethod), 0);\n-                if (!found.isEmpty()) {\n+                var i = lmt.getPropertyMethods(utils.elementUtils.getName(pUtils.getIsName(propertyMethod))).stream()\n+                        .filter(m -> m.getParameters().isEmpty())\n+                        .findAny();\n+                if (i.isPresent()) {\n@@ -929,11 +1001,2 @@\n-                        \/\/ Getters have zero params, no overloads!, pick the first.\n-                        getter = found.get(0);\n-                    }\n-                }\n-            }\n-            found = lmt.getPropertyMethods(pUtils.getSetName(propertyMethod), 1);\n-            if (found != null) {\n-                for (ExecutableElement e : found) {\n-                    if (pUtils.isValidSetterMethod(e)) {\n-                        setter = e;\n-                        break;\n+                        \/\/ Getters have zero params, no overloads!\n+                        getter = i.get();\n@@ -944,0 +1007,6 @@\n+            var setter = lmt.getPropertyMethods(utils.elementUtils.getName(pUtils.getSetName(propertyMethod))).stream()\n+                    \/\/ TODO: the number and the types of parameters a setter takes is not tested (JDK-8304170)\n+                    .filter(m -> m.getParameters().size() == 1 && pUtils.isValidSetterMethod(m))\n+                    .findAny()\n+                    .orElse(null);\n+\n@@ -991,15 +1060,9 @@\n-        private final Map<ExecutableElement, TypeMirror> interfaces = new HashMap<>();\n-        private final LinkedHashSet<ExecutableElement> methods = new LinkedHashSet<>();\n-\n-        public ImplementedMethods(ExecutableElement method) {\n-            \/\/ ExecutableElement.getEnclosingElement() returns \"the class or\n-            \/\/ interface defining the executable\", which has to be TypeElement\n-            TypeElement typeElement = (TypeElement) method.getEnclosingElement();\n-            Set<TypeMirror> intfacs = utils.getAllInterfaces(typeElement);\n-            for (TypeMirror interfaceType : intfacs) {\n-                \/\/ TODO: this method also finds static methods which are pseudo-inherited;\n-                \/\/  this needs to be fixed\n-                ExecutableElement found = utils.findMethod(utils.asTypeElement(interfaceType), method);\n-                if (found != null && !methods.contains(found)) {\n-                    methods.add(found);\n-                    interfaces.put(found, interfaceType);\n+        private final Map<ExecutableElement, TypeMirror> interfaces = new LinkedHashMap<>();\n+\n+        public ImplementedMethods(ExecutableElement implementer) {\n+            var typeElement = (TypeElement) implementer.getEnclosingElement();\n+            for (TypeMirror i : utils.getAllInterfaces(typeElement)) {\n+                TypeElement dst = utils.asTypeElement(i); \/\/ a type element to look an implemented method in\n+                ExecutableElement implemented = findImplementedMethod(dst, implementer);\n+                if (implemented == null) {\n+                    continue;\n@@ -1007,0 +1070,7 @@\n+                var prev = interfaces.put(implemented, i);\n+                \/\/ no two type elements declare the same method\n+                assert prev == null;\n+                \/\/ dst can be generic, while i might be parameterized; but they\n+                \/\/ must the same type element. For example, if dst is Set<T>,\n+                \/\/ then i is Set<String>\n+                assert Objects.equals(((DeclaredType) i).asElement(), dst);\n@@ -1010,0 +1080,10 @@\n+        private ExecutableElement findImplementedMethod(TypeElement te, ExecutableElement implementer) {\n+            var typeElement = (TypeElement) implementer.getEnclosingElement();\n+            for (var m : utils.getMethods(te)) {\n+                if (utils.elementUtils.overrides(implementer, m, typeElement)) {\n+                    return m;\n+                }\n+            }\n+            return null;\n+        }\n+\n@@ -1023,1 +1103,1 @@\n-            return methods;\n+            return interfaces.keySet();\n@@ -1031,2 +1111,30 @@\n-    private record OverriddenMethodInfo(ExecutableElement overriddenMethod,\n-                                        boolean simpleOverride) {\n+    \/*\n+     * (Here \"override\" used as a noun, not a verb, for a short and descriptive\n+     * name. Sadly, we cannot use \"Override\" as a complete name because a clash\n+     * with @java.lang.Override would make it inconvenient.)\n+     *\n+     * Used to provide additional attributes to the otherwise boolean\n+     * \"overrides(a, b)\" relationship.\n+     *\n+     * Overriding method could be a key in a map and an instance of this\n+     * record could be the value.\n+     *\/\n+    private record OverrideInfo(ExecutableElement overriddenMethod,\n+                                boolean simpleOverride) {\n+        @Override \/\/ for debugging\n+        public String toString() {\n+            return overriddenMethod.getEnclosingElement()\n+                    + \"::\" + overriddenMethod + \", simple=\" + simpleOverride;\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return te.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof VisibleMemberTable other))\n+            return false;\n+        return te.equals(other.te);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java","additions":268,"deletions":160,"binary":false,"changes":428,"status":"modified"},{"patch":"@@ -1,230 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.util.links;\n-\n-import java.util.List;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.TypeParameterElement;\n-import javax.lang.model.type.ArrayType;\n-import javax.lang.model.type.DeclaredType;\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.type.TypeVariable;\n-import javax.lang.model.type.WildcardType;\n-import javax.lang.model.util.SimpleTypeVisitor14;\n-\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A factory that constructs links from given link information.\n- *\/\n-public abstract class LinkFactory {\n-    protected final Utils utils;\n-\n-    protected LinkFactory(Utils utils) {\n-        this.utils = utils;\n-    }\n-\n-    \/**\n-     * {@return a new instance of a content object}\n-     *\/\n-    protected abstract Content newContent();\n-\n-    \/**\n-     * Constructs a link from the given link information.\n-     *\n-     * @param linkInfo the information about the link.\n-     * @return the link.\n-     *\/\n-    public Content getLink(LinkInfo linkInfo) {\n-        if (linkInfo.type != null) {\n-            SimpleTypeVisitor14<Content, LinkInfo> linkVisitor = new SimpleTypeVisitor14<>() {\n-\n-                final Content link = newContent();\n-\n-                \/\/ handles primitives, no types and error types\n-                @Override\n-                protected Content defaultAction(TypeMirror type, LinkInfo linkInfo) {\n-                    link.add(utils.getTypeName(type, false));\n-                    return link;\n-                }\n-\n-                int currentDepth = 0;\n-                @Override\n-                public Content visitArray(ArrayType type, LinkInfo linkInfo) {\n-                    \/\/ keep track of the dimension depth and replace the last dimension\n-                    \/\/ specifier with varargs, when the stack is fully unwound.\n-                    currentDepth++;\n-                    linkInfo.type = type.getComponentType();\n-                    visit(linkInfo.type, linkInfo);\n-                    currentDepth--;\n-                    if (utils.isAnnotated(type)) {\n-                        linkInfo.type = type;\n-                        link.add(\" \");\n-                        link.add(getTypeAnnotationLinks(linkInfo));\n-                    }\n-                    \/\/ use vararg if required\n-                    if (linkInfo.isVarArg && currentDepth == 0) {\n-                        link.add(\"...\");\n-                    } else {\n-                        link.add(\"[]\");\n-                    }\n-                    return link;\n-                }\n-\n-                @Override\n-                public Content visitWildcard(WildcardType type, LinkInfo linkInfo) {\n-                    link.add(getTypeAnnotationLinks(linkInfo));\n-                    link.add(\"?\");\n-                    TypeMirror extendsBound = type.getExtendsBound();\n-                    if (extendsBound != null) {\n-                        link.add(\" extends \");\n-                        setBoundsLinkInfo(linkInfo, extendsBound);\n-                        link.add(getLink(linkInfo));\n-                    }\n-                    TypeMirror superBound = type.getSuperBound();\n-                    if (superBound != null) {\n-                        link.add(\" super \");\n-                        setBoundsLinkInfo(linkInfo, superBound);\n-                        link.add(getLink(linkInfo));\n-                    }\n-                    return link;\n-                }\n-\n-                @Override\n-                public Content visitTypeVariable(TypeVariable type, LinkInfo linkInfo) {\n-                    link.add(getTypeAnnotationLinks(linkInfo));\n-                    TypeVariable typevariable = (utils.isArrayType(type))\n-                            ? (TypeVariable) utils.getComponentType(type)\n-                            : type;\n-                    Element owner = typevariable.asElement().getEnclosingElement();\n-                    if (linkInfo.linkTypeParameters && utils.isTypeElement(owner)) {\n-                        linkInfo.typeElement = (TypeElement) owner;\n-                        Content label = newContent();\n-                        label.add(utils.getTypeName(type, false));\n-                        linkInfo.label = label;\n-                        linkInfo.skipPreview = true;\n-                        link.add(getClassLink(linkInfo));\n-                    } else {\n-                        \/\/ No need to link method type parameters.\n-                        link.add(utils.getTypeName(typevariable, false));\n-                    }\n-\n-                    if (linkInfo.showTypeBounds) {\n-                        linkInfo.showTypeBounds = false;\n-                        TypeParameterElement tpe = ((TypeParameterElement) typevariable.asElement());\n-                        boolean more = false;\n-                        List<? extends TypeMirror> bounds = utils.getBounds(tpe);\n-                        for (TypeMirror bound : bounds) {\n-                            \/\/ we get everything as extends java.lang.Object we suppress\n-                            \/\/ all of them except those that have multiple extends\n-                            if (bounds.size() == 1 &&\n-                                    utils.typeUtils.isSameType(bound, utils.getObjectType()) &&\n-                                    !utils.isAnnotated(bound)) {\n-                                continue;\n-                            }\n-                            link.add(more ? \" & \" : \" extends \");\n-                            setBoundsLinkInfo(linkInfo, bound);\n-                            link.add(getLink(linkInfo));\n-                            more = true;\n-                        }\n-                    }\n-                    return link;\n-                }\n-\n-                @Override\n-                public Content visitDeclared(DeclaredType type, LinkInfo linkInfo) {\n-                    TypeMirror enc = type.getEnclosingType();\n-                    if (enc instanceof DeclaredType dt && utils.isGenericType(dt)) {\n-                        \/\/ If an enclosing type has type parameters render them as separate links as\n-                        \/\/ otherwise this information is lost. On the other hand, plain enclosing types\n-                        \/\/ are not linked separately as they are easy to reach from the nested type.\n-                        setEnclosingTypeLinkInfo(linkInfo, dt);\n-                        visitDeclared(dt, linkInfo);\n-                        link.add(\".\");\n-                        setEnclosingTypeLinkInfo(linkInfo, type);\n-                    }\n-                    link.add(getTypeAnnotationLinks(linkInfo));\n-                    linkInfo.typeElement = utils.asTypeElement(type);\n-                    link.add(getClassLink(linkInfo));\n-                    if (linkInfo.showTypeParameters()) {\n-                        link.add(getTypeParameterLinks(linkInfo));\n-                    }\n-                    return link;\n-                }\n-            };\n-            return linkVisitor.visit(linkInfo.type, linkInfo);\n-        } else if (linkInfo.typeElement != null) {\n-            Content link = newContent();\n-            link.add(getClassLink(linkInfo));\n-            if (linkInfo.showTypeParameters()) {\n-                link.add(getTypeParameterLinks(linkInfo));\n-            }\n-            return link;\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    private void setBoundsLinkInfo(LinkInfo linkInfo, TypeMirror bound) {\n-        linkInfo.typeElement = null;\n-        linkInfo.label = null;\n-        linkInfo.type = bound;\n-        linkInfo.skipPreview = false;\n-    }\n-\n-    private void setEnclosingTypeLinkInfo(LinkInfo linkinfo, DeclaredType enclosing) {\n-        linkinfo.typeElement = null;\n-        linkinfo.label = null;\n-        linkinfo.type = enclosing;\n-    }\n-\n-    \/**\n-     * Returns a link to the given class.\n-     *\n-     * @param linkInfo the information about the link to construct\n-     * @return the link for the given class.\n-     *\/\n-    protected abstract Content getClassLink(LinkInfo linkInfo);\n-\n-    \/**\n-     * Returns links to the type parameters.\n-     *\n-     * @param linkInfo the information about the link to construct\n-     * @return the links to the type parameters\n-     *\/\n-    protected abstract Content getTypeParameterLinks(LinkInfo linkInfo);\n-\n-    \/**\n-     * Returns links to the type annotations.\n-     *\n-     * @param linkInfo the information about the link to construct\n-     * @return the links to the type annotations\n-     *\/\n-    public abstract Content getTypeAnnotationLinks(LinkInfo linkInfo);\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/links\/LinkFactory.java","additions":0,"deletions":230,"binary":false,"changes":230,"status":"deleted"},{"patch":"@@ -1,158 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.util.links;\n-\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.type.DeclaredType;\n-import javax.lang.model.type.TypeMirror;\n-\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * Encapsulates information about a link.\n- *\/\n-public abstract class LinkInfo {\n-\n-    \/**\n-     * The class we want to link to.  Null if we are not linking\n-     * to a class.\n-     *\/\n-    public TypeElement typeElement;\n-\n-    \/**\n-     * The executable element we want to link to.  Null if we are not linking\n-     * to an executable element.\n-     *\/\n-    public ExecutableElement executableElement;\n-\n-    \/**\n-     * The Type we want to link to.  Null if we are not linking to a type.\n-     *\/\n-    public TypeMirror type;\n-\n-    \/**\n-     * True if this is a link to a VarArg.\n-     *\/\n-    public boolean isVarArg = false;\n-\n-    \/**\n-     * The label for the link.\n-     *\/\n-    public Content label;\n-\n-    \/**\n-     * True if we should print the type bounds for the type parameter.\n-     *\/\n-    public boolean showTypeBounds = true;\n-\n-    \/**\n-     * True if type parameters should be rendered as links.\n-     *\/\n-    public boolean linkTypeParameters = true;\n-\n-    \/**\n-     * By default, the link can be to the page it's already on.  However,\n-     * there are cases where we don't want this (e.g. heading of class page).\n-     *\/\n-    public boolean linkToSelf = true;\n-\n-    \/**\n-     * True iff the preview flags should be skipped for this link.\n-     *\/\n-    public boolean skipPreview;\n-\n-    \/**\n-     * True if type parameters should be separated by line breaks.\n-     *\/\n-    public boolean addLineBreaksInTypeParameters = false;\n-\n-    \/**\n-     * True if annotations on type parameters should be shown.\n-     *\/\n-    public boolean showTypeParameterAnnotations = false;\n-\n-    \/**\n-     * {@return a new instance of a content object}\n-     *\/\n-    protected abstract Content newContent();\n-\n-    \/**\n-     * Returns true if this link is linkable and false if we can't link to the\n-     * desired place.\n-     *\n-     * @return true if this link is linkable and false if we can't link to the\n-     * desired place.\n-     *\/\n-    public abstract boolean isLinkable();\n-\n-    \/**\n-     * Returns true if links to declared types should include type parameters.\n-     *\n-     * @return true if type parameter links should be included\n-     *\/\n-    public abstract boolean showTypeParameters();\n-\n-    \/**\n-     * Return the label for this class link.\n-     *\n-     * @param configuration the current configuration of the doclet.\n-     * @return the label for this class link.\n-     *\/\n-    public Content getClassLinkLabel(BaseConfiguration configuration) {\n-        if (label != null && !label.isEmpty()) {\n-            return label;\n-        } else if (isLinkable()) {\n-            Content tlabel = newContent();\n-            Utils utils = configuration.utils;\n-            tlabel.add(type instanceof DeclaredType dt && utils.isGenericType(dt.getEnclosingType())\n-                    \/\/ If enclosing type is rendered as separate links only use own class name\n-                    ? typeElement.getSimpleName().toString()\n-                    : configuration.utils.getSimpleName(typeElement));\n-            return tlabel;\n-        } else {\n-            Content tlabel = newContent();\n-            tlabel.add(configuration.getClassName(typeElement));\n-            return tlabel;\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"LinkInfo{\" + \"typeElement=\" + typeElement +\n-                \", executableElement=\" + executableElement +\n-                \", type=\" + type +\n-                \", isVarArg=\" + isVarArg +\n-                \", label=\" + label +\n-                \", showTypeBounds=\" + showTypeBounds +\n-                \", linkTypeParameters=\" + linkTypeParameters +\n-                \", linkToSelf=\" + linkToSelf +\n-                \", addLineBreaksInTypeParameters=\" + addLineBreaksInTypeParameters +\n-                \", showTypeParameterAnnotations=\" + showTypeParameterAnnotations + '}';\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/links\/LinkInfo.java","additions":0,"deletions":158,"binary":false,"changes":158,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Provides a factory for constructing links.\n- *\/\n-package jdk.javadoc.internal.doclets.toolkit.util.links;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/links\/package-info.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,1 @@\n-     * Argument for command-line option {@code -xclasses}.\n+     * Argument for command-line option {@code -Xclasses}.\n@@ -796,1 +796,1 @@\n-     * Argument for command-line option {@code -xclasses}.\n+     * Argument for command-line option {@code -Xclasses}.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ToolOptions.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-    private final TypeLibrary typeLibrary = TypeLibrary.getInstance();\n@@ -73,1 +72,2 @@\n-        for (Type type : new ArrayList<>(typeLibrary.getTypes())) {\n+        TypeLibrary.initialize();\n+        for (Type type : TypeLibrary.getTypes()) {\n@@ -155,1 +155,1 @@\n-        typeLibrary.addType(configuration.getPlatformEventType());\n+        TypeLibrary.addType(configuration.getPlatformEventType());\n@@ -172,1 +172,1 @@\n-        typeLibrary.removeType(et.getId());\n+        TypeLibrary.removeType(et.getId());\n@@ -263,1 +263,1 @@\n-            List<Type> types = typeLibrary.getVisibleTypes();\n+            List<Type> types = TypeLibrary.getVisibleTypes();\n@@ -306,1 +306,1 @@\n-            if (typeLibrary.clearUnregistered()) {\n+            if (TypeLibrary.clearUnregistered()) {\n@@ -323,1 +323,1 @@\n-            for (Type type : typeLibrary.getTypes()) {\n+            for (Type type : TypeLibrary.getTypes()) {\n@@ -357,1 +357,1 @@\n-        for (Type t : TypeLibrary.getInstance().getTypes()) {\n+        for (Type t : TypeLibrary.getTypes()) {\n@@ -370,1 +370,1 @@\n-        return typeLibrary.getVisibleTypes();\n+        return TypeLibrary.getVisibleTypes();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -63,2 +63,0 @@\n-\n-    private static TypeLibrary instance;\n@@ -67,0 +65,1 @@\n+\n@@ -72,6 +71,2 @@\n-    private TypeLibrary(List<Type> jvmTypes) {\n-        visitReachable(jvmTypes, t -> !types.containsKey(t.getId()), t -> types.put(t.getId(), t));\n-        if (Logger.shouldLog(LogTag.JFR_SYSTEM_METADATA, LogLevel.INFO)) {\n-            Stream<Type> s = types.values().stream().sorted((x, y) -> Long.compare(x.getId(), y.getId()));\n-            s.forEach(t -> t.log(\"Added\", LogTag.JFR_SYSTEM_METADATA, LogLevel.INFO));\n-        }\n+    private TypeLibrary() {\n+        throw new InternalError(\"Don't instantiate\");\n@@ -85,1 +80,0 @@\n-\n@@ -106,13 +100,12 @@\n-    public static TypeLibrary getInstance() {\n-        synchronized (TypeLibrary.class) {\n-            if (instance == null) {\n-                List<Type> jvmTypes;\n-                try {\n-                    jvmTypes = MetadataLoader.createTypes();\n-                    jvmTypes.sort(Comparator.comparingLong(Type::getId));\n-                } catch (IOException e) {\n-                    throw new Error(\"JFR: Could not read metadata\");\n-                }\n-                instance = new TypeLibrary(jvmTypes);\n-            }\n-            return instance;\n+    public static synchronized void initialize() {\n+        List<Type> jvmTypes;\n+        try {\n+            jvmTypes = MetadataLoader.createTypes();\n+            jvmTypes.sort(Comparator.comparingLong(Type::getId));\n+        } catch (IOException e) {\n+            throw new Error(\"JFR: Could not read metadata\");\n+        }\n+        visitReachable(jvmTypes, t -> !types.containsKey(t.getId()), t -> types.put(t.getId(), t));\n+        if (Logger.shouldLog(LogTag.JFR_SYSTEM_METADATA, LogLevel.INFO)) {\n+            Stream<Type> s = types.values().stream().sorted((x, y) -> Long.compare(x.getId(), y.getId()));\n+            s.forEach(t -> t.log(\"Added\", LogTag.JFR_SYSTEM_METADATA, LogLevel.INFO));\n@@ -122,2 +115,2 @@\n-    public Collection<Type> getTypes() {\n-        return types.values();\n+    public static synchronized Collection<Type> getTypes() {\n+        return new ArrayList<>(types.values());\n@@ -127,1 +120,1 @@\n-    public List<Type> getVisibleTypes() {\n+    public static synchronized List<Type> getVisibleTypes() {\n@@ -137,1 +130,1 @@\n-    public static Type createAnnotationType(Class<? extends Annotation> a) {\n+    public static synchronized Type createAnnotationType(Class<? extends Annotation> a) {\n@@ -159,1 +152,1 @@\n-    static AnnotationElement createAnnotation(Annotation annotation) {\n+    public static synchronized AnnotationElement createAnnotation(Annotation annotation) {\n@@ -222,1 +215,2 @@\n-    public static Type createType(Class<?> clazz) {\n+\n+    public static synchronized Type createType(Class<?> clazz) {\n@@ -226,1 +220,1 @@\n-    public static Type createType(Class<?> clazz, List<AnnotationElement> dynamicAnnotations, List<ValueDescriptor> dynamicFields) {\n+    public static synchronized Type createType(Class<?> clazz, List<AnnotationElement> dynamicAnnotations, List<ValueDescriptor> dynamicFields) {\n@@ -330,1 +324,1 @@\n-    static void addImplicitFields(Type type, boolean requestable, boolean hasDuration, boolean hasThread, boolean hasStackTrace, boolean hasCutoff) {\n+    public synchronized static void addImplicitFields(Type type, boolean requestable, boolean hasDuration, boolean hasThread, boolean hasStackTrace, boolean hasCutoff) {\n@@ -426,1 +420,1 @@\n-    public boolean clearUnregistered() {\n+    public static synchronized boolean clearUnregistered() {\n@@ -455,1 +449,1 @@\n-    public void addType(Type type) {\n+    public static synchronized void addType(Type type) {\n@@ -459,1 +453,1 @@\n-    public static void addTypes(List<Type> ts) {\n+    public static synchronized void addTypes(List<Type> ts) {\n@@ -507,1 +501,1 @@\n-    public void removeType(long id) {\n+    public static synchronized void removeType(long id) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/TypeLibrary.java","additions":28,"deletions":34,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n@@ -32,6 +35,3 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.instruction.BranchInstruction;\n@@ -77,0 +77,5 @@\n+    private static final String CANCEL_CLASS = \"REPL.$Cancel$\";\n+    private static final ClassDesc CD_Cancel = ClassDesc.of(CANCEL_CLASS);\n+    private static final ClassDesc CD_ThreadDeath = ClassDesc.of(\"java.lang.ThreadDeath\");\n+    private static final MethodTypeDesc MTD_void = MethodTypeDesc.of(ConstantDescs.CD_void);\n+\n@@ -78,15 +83,6 @@\n-        var reader  = new ClassReader(classFile);\n-        var writer = new ClassWriter(reader, 0);\n-        reader.accept(new ClassVisitor(Opcodes.ASM9, writer) {\n-            @Override\n-            public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n-                return new MethodVisitor(Opcodes.ASM9, super.visitMethod(access, name, descriptor, signature, exceptions)) {\n-                    @Override\n-                    public void visitJumpInsn(int opcode, Label label) {\n-                        visitMethodInsn(Opcodes.INVOKESTATIC, \"REPL\/$Cancel$\", \"stopCheck\", \"()V\", false);\n-                        super.visitJumpInsn(opcode, label);\n-                    }\n-                };\n-            }\n-        }, 0);\n-        return writer.toByteArray();\n+        return Classfile.parse(classFile)\n+                        .transform(ClassTransform.transformingMethodBodies((cob, coe) -> {\n+                            if (coe instanceof BranchInstruction)\n+                                cob.invokestatic(CD_Cancel, \"stopCheck\", MTD_void);\n+                            cob.with(coe);\n+                        }));\n@@ -96,18 +92,10 @@\n-        var cancelWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);\n-        cancelWriter.visit(Opcodes.V19, Opcodes.ACC_PUBLIC, \"REPL\/$Cancel$\", null, \"java\/lang\/Object\", null);\n-        cancelWriter.visitField(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_VOLATILE, \"allStop\", \"Z\", null, null);\n-        var checkVisitor = cancelWriter.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, \"stopCheck\", \"()V\", null, null);\n-            checkVisitor.visitCode();\n-            checkVisitor.visitFieldInsn(Opcodes.GETSTATIC, \"REPL\/$Cancel$\", \"allStop\", \"Z\");\n-            var skip = new Label();\n-            checkVisitor.visitJumpInsn(Opcodes.IFEQ, skip);\n-            checkVisitor.visitTypeInsn(Opcodes.NEW, \"java\/lang\/ThreadDeath\");\n-            checkVisitor.visitInsn(Opcodes.DUP);\n-            checkVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, \"java\/lang\/ThreadDeath\", \"<init>\", \"()V\", false);\n-            checkVisitor.visitInsn(Opcodes.ATHROW);\n-            checkVisitor.visitLabel(skip);\n-            checkVisitor.visitInsn(Opcodes.RETURN);\n-            checkVisitor.visitMaxs(0, 0);\n-            checkVisitor.visitEnd();\n-        cancelWriter.visitEnd();\n-        return new ClassBytecodes(\"REPL.$Cancel$\", cancelWriter.toByteArray());\n+        return new ClassBytecodes(CANCEL_CLASS, Classfile.build(CD_Cancel, clb ->\n+             clb.withFlags(Classfile.ACC_PUBLIC)\n+                .withField(\"allStop\", ConstantDescs.CD_boolean, Classfile.ACC_PUBLIC | Classfile.ACC_STATIC | Classfile.ACC_VOLATILE)\n+                .withMethodBody(\"stopCheck\", MTD_void, Classfile.ACC_PUBLIC | Classfile.ACC_STATIC, cob ->\n+                        cob.getstatic(CD_Cancel, \"allStop\", ConstantDescs.CD_boolean)\n+                           .ifThenElse(tb -> tb.new_(CD_ThreadDeath)\n+                                               .dup()\n+                                               .invokespecial(CD_ThreadDeath, \"<init>\", MTD_void)\n+                                               .athrow(),\n+                                       eb -> eb.return_()))));\n@@ -121,1 +109,1 @@\n-            allStop = findClass(\"REPL.$Cancel$\").getDeclaredField(\"allStop\");\n+            allStop = findClass(CANCEL_CLASS).getDeclaredField(\"allStop\");\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/LocalExecutionControl.java","additions":28,"deletions":40,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -1388,0 +1388,24 @@\n+class NEONVectorCompare(ThreeRegNEONOp):\n+    def __init__(self, args):\n+        self._name, self.arrangement, self.condition = args\n+        self.insname = self._name + (self.condition).lower()\n+\n+    def cstr(self):\n+        return (\"%s(%s, %s, %s, %s, %s);\"\n+                % (\"__ \" + self._name,\n+                   \"Assembler::\" + self.condition,\n+                   self._firstSIMDreg,\n+                   \"__ T\" + self.arrangement,\n+                   self._firstSIMDreg.nextReg(),\n+                   self._firstSIMDreg.nextReg().nextReg()))\n+\n+    def astr(self):\n+        return (\"%s\\t%s.%s, %s.%s, %s.%s\"\n+                % (self.insname,\n+                   self._firstSIMDreg,\n+                   self.arrangement,\n+                   self._firstSIMDreg.nextReg(),\n+                   self.arrangement,\n+                   self._firstSIMDreg.nextReg().nextReg(),\n+                   self.arrangement))\n+\n@@ -1696,26 +1720,0 @@\n-          [\"cmeq\", \"cmeq\", \"8B\"], [\"cmeq\", \"cmeq\", \"16B\"],\n-          [\"cmeq\", \"cmeq\", \"4H\"], [\"cmeq\", \"cmeq\", \"8H\"],\n-          [\"cmeq\", \"cmeq\", \"2S\"], [\"cmeq\", \"cmeq\", \"4S\"],\n-          [\"cmeq\", \"cmeq\", \"2D\"],\n-          [\"fcmeq\", \"fcmeq\", \"2S\"], [\"fcmeq\", \"fcmeq\", \"4S\"],\n-          [\"fcmeq\", \"fcmeq\", \"2D\"],\n-          [\"cmgt\", \"cmgt\", \"8B\"], [\"cmgt\", \"cmgt\", \"16B\"],\n-          [\"cmgt\", \"cmgt\", \"4H\"], [\"cmgt\", \"cmgt\", \"8H\"],\n-          [\"cmgt\", \"cmgt\", \"2S\"], [\"cmgt\", \"cmgt\", \"4S\"],\n-          [\"cmgt\", \"cmgt\", \"2D\"],\n-          [\"cmhi\", \"cmhi\", \"8B\"], [\"cmhi\", \"cmhi\", \"16B\"],\n-          [\"cmhi\", \"cmhi\", \"4H\"], [\"cmhi\", \"cmhi\", \"8H\"],\n-          [\"cmhi\", \"cmhi\", \"2S\"], [\"cmhi\", \"cmhi\", \"4S\"],\n-          [\"cmhi\", \"cmhi\", \"2D\"],\n-          [\"cmhs\", \"cmhs\", \"8B\"], [\"cmhs\", \"cmhs\", \"16B\"],\n-          [\"cmhs\", \"cmhs\", \"4H\"], [\"cmhs\", \"cmhs\", \"8H\"],\n-          [\"cmhs\", \"cmhs\", \"2S\"], [\"cmhs\", \"cmhs\", \"4S\"],\n-          [\"cmhs\", \"cmhs\", \"2D\"],\n-          [\"fcmgt\", \"fcmgt\", \"2S\"], [\"fcmgt\", \"fcmgt\", \"4S\"],\n-          [\"fcmgt\", \"fcmgt\", \"2D\"],\n-          [\"cmge\", \"cmge\", \"8B\"], [\"cmge\", \"cmge\", \"16B\"],\n-          [\"cmge\", \"cmge\", \"4H\"], [\"cmge\", \"cmge\", \"8H\"],\n-          [\"cmge\", \"cmge\", \"2S\"], [\"cmge\", \"cmge\", \"4S\"],\n-          [\"cmge\", \"cmge\", \"2D\"],\n-          [\"fcmge\", \"fcmge\", \"2S\"], [\"fcmge\", \"fcmge\", \"4S\"],\n-          [\"fcmge\", \"fcmge\", \"2D\"],\n@@ -1726,0 +1724,16 @@\n+neonVectorCompareInstructionPrefix = ['cm', 'fcm']\n+neonIntegerVectorCompareConditions = ['GT', 'GE', 'EQ', 'HI', 'HS']\n+neonFloatVectorCompareConditions = ['EQ', 'GT', 'GE']\n+neonIntegerArrangement = ['8B', '16B', '4H', '8H', '2S', '4S', '2D']\n+neonFloatArrangement = ['2S', '4S', '2D']\n+neonVectorCompareArgs = []\n+for pre in neonVectorCompareInstructionPrefix:\n+    conditions = neonFloatVectorCompareConditions if pre == 'fcm' else neonIntegerVectorCompareConditions\n+    arrangements = neonFloatArrangement if pre == 'fcm' else neonIntegerArrangement\n+    for condition in conditions:\n+        for currentArrangement in arrangements:\n+            currentArgs = [pre, currentArrangement, condition]\n+            neonVectorCompareArgs.append(currentArgs)\n+\n+generate(NEONVectorCompare, neonVectorCompareArgs)\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":40,"deletions":26,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -751,47 +751,49 @@\n-    __ cmeq(v29, __ T8B, v30, v31);                    \/\/       cmeq    v29.8B, v30.8B, v31.8B\n-    __ cmeq(v3, __ T16B, v4, v5);                      \/\/       cmeq    v3.16B, v4.16B, v5.16B\n-    __ cmeq(v10, __ T4H, v11, v12);                    \/\/       cmeq    v10.4H, v11.4H, v12.4H\n-    __ cmeq(v22, __ T8H, v23, v24);                    \/\/       cmeq    v22.8H, v23.8H, v24.8H\n-    __ cmeq(v10, __ T2S, v11, v12);                    \/\/       cmeq    v10.2S, v11.2S, v12.2S\n-    __ cmeq(v4, __ T4S, v5, v6);                       \/\/       cmeq    v4.4S, v5.4S, v6.4S\n-    __ cmeq(v17, __ T2D, v18, v19);                    \/\/       cmeq    v17.2D, v18.2D, v19.2D\n-    __ fcmeq(v1, __ T2S, v2, v3);                      \/\/       fcmeq   v1.2S, v2.2S, v3.2S\n-    __ fcmeq(v11, __ T4S, v12, v13);                   \/\/       fcmeq   v11.4S, v12.4S, v13.4S\n-    __ fcmeq(v7, __ T2D, v8, v9);                      \/\/       fcmeq   v7.2D, v8.2D, v9.2D\n-    __ cmgt(v10, __ T8B, v11, v12);                    \/\/       cmgt    v10.8B, v11.8B, v12.8B\n-    __ cmgt(v15, __ T16B, v16, v17);                   \/\/       cmgt    v15.16B, v16.16B, v17.16B\n-    __ cmgt(v16, __ T4H, v17, v18);                    \/\/       cmgt    v16.4H, v17.4H, v18.4H\n-    __ cmgt(v2, __ T8H, v3, v4);                       \/\/       cmgt    v2.8H, v3.8H, v4.8H\n-    __ cmgt(v9, __ T2S, v10, v11);                     \/\/       cmgt    v9.2S, v10.2S, v11.2S\n-    __ cmgt(v11, __ T4S, v12, v13);                    \/\/       cmgt    v11.4S, v12.4S, v13.4S\n-    __ cmgt(v12, __ T2D, v13, v14);                    \/\/       cmgt    v12.2D, v13.2D, v14.2D\n-    __ cmhi(v14, __ T8B, v15, v16);                    \/\/       cmhi    v14.8B, v15.8B, v16.8B\n-    __ cmhi(v13, __ T16B, v14, v15);                   \/\/       cmhi    v13.16B, v14.16B, v15.16B\n-    __ cmhi(v2, __ T4H, v3, v4);                       \/\/       cmhi    v2.4H, v3.4H, v4.4H\n-    __ cmhi(v6, __ T8H, v7, v8);                       \/\/       cmhi    v6.8H, v7.8H, v8.8H\n-    __ cmhi(v19, __ T2S, v20, v21);                    \/\/       cmhi    v19.2S, v20.2S, v21.2S\n-    __ cmhi(v25, __ T4S, v26, v27);                    \/\/       cmhi    v25.4S, v26.4S, v27.4S\n-    __ cmhi(v15, __ T2D, v16, v17);                    \/\/       cmhi    v15.2D, v16.2D, v17.2D\n-    __ cmhs(v4, __ T8B, v5, v6);                       \/\/       cmhs    v4.8B, v5.8B, v6.8B\n-    __ cmhs(v2, __ T16B, v3, v4);                      \/\/       cmhs    v2.16B, v3.16B, v4.16B\n-    __ cmhs(v4, __ T4H, v5, v6);                       \/\/       cmhs    v4.4H, v5.4H, v6.4H\n-    __ cmhs(v11, __ T8H, v12, v13);                    \/\/       cmhs    v11.8H, v12.8H, v13.8H\n-    __ cmhs(v17, __ T2S, v18, v19);                    \/\/       cmhs    v17.2S, v18.2S, v19.2S\n-    __ cmhs(v20, __ T4S, v21, v22);                    \/\/       cmhs    v20.4S, v21.4S, v22.4S\n-    __ cmhs(v16, __ T2D, v17, v18);                    \/\/       cmhs    v16.2D, v17.2D, v18.2D\n-    __ fcmgt(v17, __ T2S, v18, v19);                   \/\/       fcmgt   v17.2S, v18.2S, v19.2S\n-    __ fcmgt(v10, __ T4S, v11, v12);                   \/\/       fcmgt   v10.4S, v11.4S, v12.4S\n-    __ fcmgt(v20, __ T2D, v21, v22);                   \/\/       fcmgt   v20.2D, v21.2D, v22.2D\n-    __ cmge(v22, __ T8B, v23, v24);                    \/\/       cmge    v22.8B, v23.8B, v24.8B\n-    __ cmge(v12, __ T16B, v13, v14);                   \/\/       cmge    v12.16B, v13.16B, v14.16B\n-    __ cmge(v25, __ T4H, v26, v27);                    \/\/       cmge    v25.4H, v26.4H, v27.4H\n-    __ cmge(v23, __ T8H, v24, v25);                    \/\/       cmge    v23.8H, v24.8H, v25.8H\n-    __ cmge(v28, __ T2S, v29, v30);                    \/\/       cmge    v28.2S, v29.2S, v30.2S\n-    __ cmge(v14, __ T4S, v15, v16);                    \/\/       cmge    v14.4S, v15.4S, v16.4S\n-    __ cmge(v10, __ T2D, v11, v12);                    \/\/       cmge    v10.2D, v11.2D, v12.2D\n-    __ fcmge(v24, __ T2S, v25, v26);                   \/\/       fcmge   v24.2S, v25.2S, v26.2S\n-    __ fcmge(v1, __ T4S, v2, v3);                      \/\/       fcmge   v1.4S, v2.4S, v3.4S\n-    __ fcmge(v11, __ T2D, v12, v13);                   \/\/       fcmge   v11.2D, v12.2D, v13.2D\n-    __ facgt(v30, __ T2S, v31, v0);                    \/\/       facgt   v30.2S, v31.2S, v0.2S\n-    __ facgt(v10, __ T4S, v11, v12);                   \/\/       facgt   v10.4S, v11.4S, v12.4S\n-    __ facgt(v15, __ T2D, v16, v17);                   \/\/       facgt   v15.2D, v16.2D, v17.2D\n+    __ facgt(v29, __ T2S, v30, v31);                   \/\/       facgt   v29.2S, v30.2S, v31.2S\n+    __ facgt(v3, __ T4S, v4, v5);                      \/\/       facgt   v3.4S, v4.4S, v5.4S\n+    __ facgt(v10, __ T2D, v11, v12);                   \/\/       facgt   v10.2D, v11.2D, v12.2D\n+\n+\/\/ NEONVectorCompare\n+    __ cm(Assembler::GT, v22, __ T8B, v23, v24);       \/\/       cmgt    v22.8B, v23.8B, v24.8B\n+    __ cm(Assembler::GT, v10, __ T16B, v11, v12);      \/\/       cmgt    v10.16B, v11.16B, v12.16B\n+    __ cm(Assembler::GT, v4, __ T4H, v5, v6);          \/\/       cmgt    v4.4H, v5.4H, v6.4H\n+    __ cm(Assembler::GT, v17, __ T8H, v18, v19);       \/\/       cmgt    v17.8H, v18.8H, v19.8H\n+    __ cm(Assembler::GT, v1, __ T2S, v2, v3);          \/\/       cmgt    v1.2S, v2.2S, v3.2S\n+    __ cm(Assembler::GT, v11, __ T4S, v12, v13);       \/\/       cmgt    v11.4S, v12.4S, v13.4S\n+    __ cm(Assembler::GT, v7, __ T2D, v8, v9);          \/\/       cmgt    v7.2D, v8.2D, v9.2D\n+    __ cm(Assembler::GE, v10, __ T8B, v11, v12);       \/\/       cmge    v10.8B, v11.8B, v12.8B\n+    __ cm(Assembler::GE, v15, __ T16B, v16, v17);      \/\/       cmge    v15.16B, v16.16B, v17.16B\n+    __ cm(Assembler::GE, v16, __ T4H, v17, v18);       \/\/       cmge    v16.4H, v17.4H, v18.4H\n+    __ cm(Assembler::GE, v2, __ T8H, v3, v4);          \/\/       cmge    v2.8H, v3.8H, v4.8H\n+    __ cm(Assembler::GE, v9, __ T2S, v10, v11);        \/\/       cmge    v9.2S, v10.2S, v11.2S\n+    __ cm(Assembler::GE, v11, __ T4S, v12, v13);       \/\/       cmge    v11.4S, v12.4S, v13.4S\n+    __ cm(Assembler::GE, v12, __ T2D, v13, v14);       \/\/       cmge    v12.2D, v13.2D, v14.2D\n+    __ cm(Assembler::EQ, v14, __ T8B, v15, v16);       \/\/       cmeq    v14.8B, v15.8B, v16.8B\n+    __ cm(Assembler::EQ, v13, __ T16B, v14, v15);      \/\/       cmeq    v13.16B, v14.16B, v15.16B\n+    __ cm(Assembler::EQ, v2, __ T4H, v3, v4);          \/\/       cmeq    v2.4H, v3.4H, v4.4H\n+    __ cm(Assembler::EQ, v6, __ T8H, v7, v8);          \/\/       cmeq    v6.8H, v7.8H, v8.8H\n+    __ cm(Assembler::EQ, v19, __ T2S, v20, v21);       \/\/       cmeq    v19.2S, v20.2S, v21.2S\n+    __ cm(Assembler::EQ, v25, __ T4S, v26, v27);       \/\/       cmeq    v25.4S, v26.4S, v27.4S\n+    __ cm(Assembler::EQ, v15, __ T2D, v16, v17);       \/\/       cmeq    v15.2D, v16.2D, v17.2D\n+    __ cm(Assembler::HI, v4, __ T8B, v5, v6);          \/\/       cmhi    v4.8B, v5.8B, v6.8B\n+    __ cm(Assembler::HI, v2, __ T16B, v3, v4);         \/\/       cmhi    v2.16B, v3.16B, v4.16B\n+    __ cm(Assembler::HI, v4, __ T4H, v5, v6);          \/\/       cmhi    v4.4H, v5.4H, v6.4H\n+    __ cm(Assembler::HI, v11, __ T8H, v12, v13);       \/\/       cmhi    v11.8H, v12.8H, v13.8H\n+    __ cm(Assembler::HI, v17, __ T2S, v18, v19);       \/\/       cmhi    v17.2S, v18.2S, v19.2S\n+    __ cm(Assembler::HI, v20, __ T4S, v21, v22);       \/\/       cmhi    v20.4S, v21.4S, v22.4S\n+    __ cm(Assembler::HI, v16, __ T2D, v17, v18);       \/\/       cmhi    v16.2D, v17.2D, v18.2D\n+    __ cm(Assembler::HS, v17, __ T8B, v18, v19);       \/\/       cmhs    v17.8B, v18.8B, v19.8B\n+    __ cm(Assembler::HS, v10, __ T16B, v11, v12);      \/\/       cmhs    v10.16B, v11.16B, v12.16B\n+    __ cm(Assembler::HS, v20, __ T4H, v21, v22);       \/\/       cmhs    v20.4H, v21.4H, v22.4H\n+    __ cm(Assembler::HS, v22, __ T8H, v23, v24);       \/\/       cmhs    v22.8H, v23.8H, v24.8H\n+    __ cm(Assembler::HS, v12, __ T2S, v13, v14);       \/\/       cmhs    v12.2S, v13.2S, v14.2S\n+    __ cm(Assembler::HS, v25, __ T4S, v26, v27);       \/\/       cmhs    v25.4S, v26.4S, v27.4S\n+    __ cm(Assembler::HS, v23, __ T2D, v24, v25);       \/\/       cmhs    v23.2D, v24.2D, v25.2D\n+    __ fcm(Assembler::EQ, v28, __ T2S, v29, v30);      \/\/       fcmeq   v28.2S, v29.2S, v30.2S\n+    __ fcm(Assembler::EQ, v14, __ T4S, v15, v16);      \/\/       fcmeq   v14.4S, v15.4S, v16.4S\n+    __ fcm(Assembler::EQ, v10, __ T2D, v11, v12);      \/\/       fcmeq   v10.2D, v11.2D, v12.2D\n+    __ fcm(Assembler::GT, v24, __ T2S, v25, v26);      \/\/       fcmgt   v24.2S, v25.2S, v26.2S\n+    __ fcm(Assembler::GT, v1, __ T4S, v2, v3);         \/\/       fcmgt   v1.4S, v2.4S, v3.4S\n+    __ fcm(Assembler::GT, v11, __ T2D, v12, v13);      \/\/       fcmgt   v11.2D, v12.2D, v13.2D\n+    __ fcm(Assembler::GE, v30, __ T2S, v31, v0);       \/\/       fcmge   v30.2S, v31.2S, v0.2S\n+    __ fcm(Assembler::GE, v10, __ T4S, v11, v12);      \/\/       fcmge   v10.4S, v11.4S, v12.4S\n+    __ fcm(Assembler::GE, v15, __ T2D, v16, v17);      \/\/       fcmge   v15.2D, v16.2D, v17.2D\n@@ -1432,12 +1434,12 @@\n-    0x2e3f8fdd,     0x6e258c83,     0x2e6c8d6a,     0x6e788ef6,\n-    0x2eac8d6a,     0x6ea68ca4,     0x6ef38e51,     0x0e23e441,\n-    0x4e2de58b,     0x4e69e507,     0x0e2c356a,     0x4e31360f,\n-    0x0e723630,     0x4e643462,     0x0eab3549,     0x4ead358b,\n-    0x4eee35ac,     0x2e3035ee,     0x6e2f35cd,     0x2e643462,\n-    0x6e6834e6,     0x2eb53693,     0x6ebb3759,     0x6ef1360f,\n-    0x2e263ca4,     0x6e243c62,     0x2e663ca4,     0x6e6d3d8b,\n-    0x2eb33e51,     0x6eb63eb4,     0x6ef23e30,     0x2eb3e651,\n-    0x6eace56a,     0x6ef6e6b4,     0x0e383ef6,     0x4e2e3dac,\n-    0x0e7b3f59,     0x4e793f17,     0x0ebe3fbc,     0x4eb03dee,\n-    0x4eec3d6a,     0x2e3ae738,     0x6e23e441,     0x6e6de58b,\n-    0x2ea0effe,     0x6eaced6a,     0x6ef1ee0f,     0x65922c43,\n+    0x2ebfefdd,     0x6ea5ec83,     0x6eeced6a,     0x0e3836f6,\n+    0x4e2c356a,     0x0e6634a4,     0x4e733651,     0x0ea33441,\n+    0x4ead358b,     0x4ee93507,     0x0e2c3d6a,     0x4e313e0f,\n+    0x0e723e30,     0x4e643c62,     0x0eab3d49,     0x4ead3d8b,\n+    0x4eee3dac,     0x2e308dee,     0x6e2f8dcd,     0x2e648c62,\n+    0x6e688ce6,     0x2eb58e93,     0x6ebb8f59,     0x6ef18e0f,\n+    0x2e2634a4,     0x6e243462,     0x2e6634a4,     0x6e6d358b,\n+    0x2eb33651,     0x6eb636b4,     0x6ef23630,     0x2e333e51,\n+    0x6e2c3d6a,     0x2e763eb4,     0x6e783ef6,     0x2eae3dac,\n+    0x6ebb3f59,     0x6ef93f17,     0x0e3ee7bc,     0x4e30e5ee,\n+    0x4e6ce56a,     0x2ebae738,     0x6ea3e441,     0x6eede58b,\n+    0x2e20e7fe,     0x6e2ce56a,     0x6e71e60f,     0x65922c43,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":61,"deletions":59,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,4 +115,4 @@\n-  \/\/ Test get_next_one_offset with full range of map.\n-  EXPECT_EQ(left, test_ones.get_next_one_offset(0));\n-  EXPECT_EQ(right, test_ones.get_next_one_offset(left + 1));\n-  EXPECT_EQ(BITMAP_SIZE, test_ones.get_next_one_offset(right + 1));\n+  \/\/ Test find_first_set_bit with full range of map.\n+  EXPECT_EQ(left, test_ones.find_first_set_bit(0));\n+  EXPECT_EQ(right, test_ones.find_first_set_bit(left + 1));\n+  EXPECT_EQ(BITMAP_SIZE, test_ones.find_first_set_bit(right + 1));\n@@ -120,4 +120,4 @@\n-  \/\/ Test get_next_one_offset_aligned_right with full range of map.\n-  EXPECT_EQ(left, test_ones.get_next_one_offset_aligned_right(0, BITMAP_SIZE));\n-  EXPECT_EQ(right, test_ones.get_next_one_offset_aligned_right(left + 1, BITMAP_SIZE));\n-  EXPECT_EQ(BITMAP_SIZE, test_ones.get_next_one_offset_aligned_right(right + 1, BITMAP_SIZE));\n+  \/\/ Test find_first_set_bit_aligned_right with full range of map.\n+  EXPECT_EQ(left, test_ones.find_first_set_bit_aligned_right(0, BITMAP_SIZE));\n+  EXPECT_EQ(right, test_ones.find_first_set_bit_aligned_right(left + 1, BITMAP_SIZE));\n+  EXPECT_EQ(BITMAP_SIZE, test_ones.find_first_set_bit_aligned_right(right + 1, BITMAP_SIZE));\n@@ -125,4 +125,4 @@\n-  \/\/ Test get_next_zero_offset with full range of map.\n-  EXPECT_EQ(left, test_zeros.get_next_zero_offset(0));\n-  EXPECT_EQ(right, test_zeros.get_next_zero_offset(left + 1));\n-  EXPECT_EQ(BITMAP_SIZE, test_zeros.get_next_zero_offset(right + 1));\n+  \/\/ Test find_first_clear_bit with full range of map.\n+  EXPECT_EQ(left, test_zeros.find_first_clear_bit(0));\n+  EXPECT_EQ(right, test_zeros.find_first_clear_bit(left + 1));\n+  EXPECT_EQ(BITMAP_SIZE, test_zeros.find_first_clear_bit(right + 1));\n@@ -173,2 +173,2 @@\n-          EXPECT_EQ(expected, test_ones.get_next_one_offset(start, end));\n-          EXPECT_EQ(expected, test_zeros.get_next_zero_offset(start, end));\n+          EXPECT_EQ(expected, test_ones.find_first_set_bit(start, end));\n+          EXPECT_EQ(expected, test_zeros.find_first_clear_bit(start, end));\n@@ -178,1 +178,1 @@\n-              test_ones.get_next_one_offset_aligned_right(start, end));\n+              test_ones.find_first_set_bit_aligned_right(start, end));\n@@ -184,2 +184,2 @@\n-          EXPECT_EQ(expected2, test_ones.get_next_one_offset(start2, end));\n-          EXPECT_EQ(expected2, test_zeros.get_next_zero_offset(start2, end));\n+          EXPECT_EQ(expected2, test_ones.find_first_set_bit(start2, end));\n+          EXPECT_EQ(expected2, test_zeros.find_first_clear_bit(start2, end));\n@@ -189,1 +189,1 @@\n-              test_ones.get_next_one_offset_aligned_right(start2, end));\n+              test_ones.find_first_set_bit_aligned_right(start2, end));\n@@ -207,2 +207,2 @@\n-  EXPECT_EQ(BITMAP_SIZE, test_ones.get_next_one_offset(0));\n-  EXPECT_EQ(BITMAP_SIZE, test_zeros.get_next_zero_offset(0));\n+  EXPECT_EQ(BITMAP_SIZE, test_ones.find_first_set_bit(0));\n+  EXPECT_EQ(BITMAP_SIZE, test_zeros.find_first_clear_bit(0));\n","filename":"test\/hotspot\/gtest\/utilities\/test_bitMap_search.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+serviceability\/AsyncGetCallTrace\/MyPackage\/ASGCTBaseTest.java 8303168 linux-x64\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+compiler\/vectorapi\/VectorLogicalOpIdentityTest.java 8302459 linux-x64,windows-x64\n+\n@@ -100,0 +102,1 @@\n+runtime\/StackGuardPages\/TestStackGuardPagesNative.java 8303612 linux-all\n@@ -123,1 +126,1 @@\n-serviceability\/sa\/UniqueVtableTest.java 8303921 linux-all\n+serviceability\/sa\/UniqueVtableTest.java 8303921 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @bug 8297384\n+ * @bug 8297384 8303238\n@@ -40,1 +40,1 @@\n-    @Run(test = { \"test1\", \"test2\" })\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\" })\n@@ -43,0 +43,3 @@\n+        int b = RunInfo.getRandom().nextInt();\n+        int c = RunInfo.getRandom().nextInt();\n+        int d = RunInfo.getRandom().nextInt();\n@@ -49,0 +52,3 @@\n+        assertResult(b);\n+        assertResult(c);\n+        assertResult(d);\n@@ -57,0 +63,6 @@\n+        Asserts.assertEQ((a >> 4) << 8, test3(a));\n+        Asserts.assertEQ((a >>> 4) << 8, test4(a));\n+        Asserts.assertEQ((a >> 8) << 4, test5(a));\n+        Asserts.assertEQ((a >>> 8) << 4, test6(a));\n+        Asserts.assertEQ(((a >> 4) & 0xFF) << 8, test7(a));\n+        Asserts.assertEQ(((a >>> 4) & 0xFF) << 8, test8(a));\n@@ -74,0 +86,48 @@\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.LSHIFT, \"1\" })\n+    \/\/ Checks (x >> 4) << 8 => (x << 4) & -16\n+    public int test3(int x) {\n+        return (x >> 4) << 8;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.URSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.LSHIFT, \"1\" })\n+    \/\/ Checks (x >>> 4) << 8 => (x << 4) & -16\n+    public int test4(int x) {\n+        return (x >>> 4) << 8;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.RSHIFT, \"1\" })\n+    \/\/ Checks (x >> 8) << 4 => (x >> 4) & -16\n+    public int test5(int x) {\n+        return (x >> 8) << 4;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.URSHIFT, \"1\" })\n+    \/\/ Checks (x >>> 8) << 4 => (x >>> 4) & -16\n+    public int test6(int x) {\n+        return (x >>> 8) << 4;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.LSHIFT, \"1\" })\n+    \/\/ Checks ((x >> 4) & 0xFF) << 8 => (x << 4) & 0xFF00\n+    public int test7(int x) {\n+        return ((x >> 4) & 0xFF) << 8;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.URSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.LSHIFT, \"1\" })\n+    \/\/ Checks ((x >>> 4) & 0xFF) << 8 => (x << 4) & 0xFF00\n+    public int test8(int x) {\n+        return ((x >>> 4) & 0xFF) << 8;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftINodeIdealizationTests.java","additions":63,"deletions":3,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8303238\n+ * @summary Test that Ideal transformations of LShiftLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.LShiftLNodeIdealizationTests\n+ *\/\n+public class LShiftLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = { \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\" })\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        long b = RunInfo.getRandom().nextLong();\n+        long c = RunInfo.getRandom().nextLong();\n+        long d = RunInfo.getRandom().nextLong();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0);\n+        assertResult(a);\n+        assertResult(b);\n+        assertResult(c);\n+        assertResult(d);\n+        assertResult(min);\n+        assertResult(max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a) {\n+        Asserts.assertEQ((a >> 4L) << 8L, test3(a));\n+        Asserts.assertEQ((a >>> 4L) << 8L, test4(a));\n+        Asserts.assertEQ((a >> 8L) << 4L, test5(a));\n+        Asserts.assertEQ((a >>> 8L) << 4L, test6(a));\n+        Asserts.assertEQ(((a >> 4L) & 0xFFL) << 8L, test7(a));\n+        Asserts.assertEQ(((a >>> 4L) & 0xFFL) << 8L, test8(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.LSHIFT, \"1\" })\n+    \/\/ Checks (x >> 4) << 8 => (x << 4) & -16\n+    public long test3(long x) {\n+        return (x >> 4L) << 8L;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.URSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.LSHIFT, \"1\" })\n+    \/\/ Checks (x >>> 4) << 8 => (x << 4) & -16\n+    public long test4(long x) {\n+        return (x >>> 4L) << 8L;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.RSHIFT, \"1\" })\n+    \/\/ Checks (x >> 8) << 4 => (x >> 4) & -16\n+    public long test5(long x) {\n+        return (x >> 8L) << 4L;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.URSHIFT, \"1\" })\n+    \/\/ Checks (x >>> 8) << 4 => (x >>> 4) & -16\n+    public long test6(long x) {\n+        return (x >>> 8L) << 4L;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.LSHIFT, \"1\" })\n+    \/\/ Checks ((x >> 4) & 0xFF) << 8 => (x << 4) & 0xFF00\n+    public long test7(long x) {\n+        return ((x >> 4L) & 0xFFL) << 8L;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.URSHIFT })\n+    @IR(counts = { IRNode.AND, \"1\", IRNode.LSHIFT, \"1\" })\n+    \/\/ Checks ((x >>> 4) & 0xFF) << 8 => (x << 4) & 0xFF00\n+    public long test8(long x) {\n+        return ((x >>> 4L) & 0xFFL) << 8L;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftLNodeIdealizationTests.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,820 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.igvn;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8299546\n+ * @summary Test that IntegerMulRing works correctly and returns correct (and optimized) types.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.igvn.TestIntegerMulRing\n+ *\/\n+public class TestIntegerMulRing {\n+    public static int iFld, iFld2, iFld3, iFld4;\n+    public static long lFld, lFld2, lFld3, lFld4;\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:-SplitIfBlocks\");\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_I, IRNode.IF}, counts = {IRNode.STORE_L, \"2\"})\n+    public static void testLongPositive() {\n+        long l = 111111111111111111L;\n+        if (l * 81 == 1L) {\n+            iFld = 23;\n+        }\n+        if (l * 81 == 8999999999999999991L) {\n+            lFld = 23;\n+        }\n+        if (l * 83 == 1L) {\n+            iFld2 = 34;\n+        }\n+        if (l * 83 == 9222222222222222213L) {\n+            lFld2 = 23;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_I, IRNode.IF}, counts = {IRNode.STORE_L, \"2\"})\n+    public static void testLongPositive2() {\n+        long l = -111111111111111111L;\n+        if (l * -81 == 1L) {\n+            iFld = 23;\n+        }\n+        if (l * -81 == 8999999999999999991L) {\n+            lFld = 23;\n+        }\n+        if (l * -83 == 1L) {\n+            iFld2 = 34;\n+        }\n+        if (l * -83 == 9222222222222222213L) {\n+            lFld2 = 23;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_I, IRNode.IF}, counts = {IRNode.STORE_L, \"2\"})\n+    public static void testLongNegative() {\n+        long l = -111111111111111111L;\n+        if (l * 81 == 1L) {\n+            iFld = 23;\n+        }\n+        if (l * 81 == -8999999999999999991L) {\n+            lFld = 23;\n+        }\n+        if (l * 83 == 1L) {\n+            iFld2 = 34;\n+        }\n+        if (l * 83 == -9222222222222222213L) {\n+            lFld2 = 23;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_I, IRNode.IF}, counts = {IRNode.STORE_L, \"2\"})\n+    public static void testLongNegative2() {\n+        long l = 111111111111111111L;\n+        if (l * -81 == 1L) {\n+            iFld = 23;\n+        }\n+        if (l * -81 == -8999999999999999991L) {\n+            lFld = 23;\n+        }\n+        if (l * -83 == 1L) {\n+            iFld2 = 34;\n+        }\n+        if (l * -83 == -9222222222222222213L) {\n+            lFld2 = 23;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongMinValueMinus1(boolean flag, boolean flag2) {\n+        long l = flag ? -1 : Long.MIN_VALUE;\n+        int x = flag2 ? -1 : 0;\n+\n+        if (l * x != 2L) { \/\/ Type of multiplication is LONG as Long.MIN_VALUE * -1 does overflow. If cannot be removed.\n+            lFld = 23;\n+        } else {\n+            lFld = 34; \/\/ Emits StoreL since warmup is 0 and no UCT will be emitted.\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_L, IRNode.STORE_L}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testLongMinValuePlus1(boolean flag, boolean flag2) {\n+        long l = flag ? -1 : Long.MIN_VALUE;\n+        int x = flag2 ? 1 : 0;\n+\n+        if (l * x <= 0L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_L, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testLongMinValueUnderflowOnce(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MIN_VALUE\/2 : Long.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 4 : 6;\n+\n+        if (l * x <= 4L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\", IRNode.MUL_L, \"1\"})\n+    public static void testLongMinValueUnderflowOnceTwice(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MIN_VALUE\/2 : Long.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 6 : 8;\n+\n+        if (l * x <= 4L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_L, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testLongMinValueUnderflowTwice(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MIN_VALUE\/2 : Long.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 8 : 10;\n+\n+        if (l * x <= 8L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_L, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testLongMaxValueOverflowOnce(boolean flag, boolean flag2) {\n+        long l = flag2 ? Long.MAX_VALUE\/2 - 1 : Long.MAX_VALUE\/2;\n+        int x = flag ? 4 : 6;\n+\n+        if (l * x >= -8L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\", IRNode.MUL_L, \"1\"})\n+    public static void testLongMaxValueOverflowOnceTwice(boolean flag, boolean flag2) {\n+        long l = flag2 ? Long.MAX_VALUE\/2 - 1 : Long.MAX_VALUE\/2;\n+        int x = flag ? 6 : 8;\n+\n+        if (l * x >= -8L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_L, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testLongMaxValueOverflowTwice(boolean flag, boolean flag2) {\n+        long l = flag2 ? Long.MAX_VALUE\/2 - 1 : Long.MAX_VALUE\/2;\n+        int x = flag ? 8 : 10;\n+\n+        if (l * x >= -16L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_L, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testLongProductsOverflowOnceAtMin(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MAX_VALUE\/2 + 1 : Long.MAX_VALUE\/2 + 2;\n+        int x = flag2 ? 2 : 3;\n+\n+        \/\/ [MAX_VALUE\/2 + 1, MAX_VALUE\/2 + 2] * [2,3]: All cross products overflow exactly once.\n+        \/\/ Result: [MIN_VALUE, MIN_VALUE\/2 + 3] -> 2L outside range and If can be optimized away.\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_L, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testLongProductsOverflowOnceAtMax(boolean flag, boolean flag2) {\n+        \/\/ 88971434439113593 * 311 = Long.MAX_VALUE*3 + 2 --cast to long--> Long.MAX_VALUE\n+        long l = flag ? 88971434439113592L : 88971434439113593L;\n+        int x = flag2 ? 310 : 311;\n+\n+        \/\/ All cross products overflow exactly once.\n+        \/\/ Result: [y, MAX_VALUE], where y > 2 -> 2L outside range and If can be optimized away.\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_L, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testLongProductsUnderflowOnceAtMin(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MIN_VALUE\/3 - 1 : Long.MIN_VALUE\/3 - 2;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ [MIN_VALUE\/3 - 1, MIN_VALUE\/3 - 2] * [3,4]: All cross products underflow exactly once.\n+        \/\/ Result: [MAX_VALUE + MIN_VALUE\/3 - 5, MAX_VALUE] -> 2L outside range and If can be optimized away.\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_L, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testLongProductsUnderflowOnceAtMax(boolean flag, boolean flag2) {\n+        \/\/ -6917529027641081856 * 4 = Long.MIN_VALUE*3 --cast to long--> Long.MIN_VALUE\n+        long l = flag ? -6917529027641081856L : -6917529027641081855L;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ All cross products underflow exactly once.\n+        \/\/ Result: [MIN_VALUE, y], where y < 2 -> 2L outside range and If can be optimized away.\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongProductsDifferentNumberOfOverflow(boolean flag, boolean flag2) {\n+        \/\/ 88971434439113593 * 311 = Long.MAX_VALUE*3 + 2 --cast to long--> Long.MAX_VALUE \/\/ Overflown once\n+        \/\/ 88971434439113594 * 311 = (Long.MAX_VALUE*3 + 311) + 2 --cast to long--> Long.MIN_VALUE + 310 \/\/ Overflown twice\n+        long l = flag ? 88971434439113593L : 88971434439113594L;\n+        int x = flag2 ? 310 : 311;\n+\n+        \/\/ Different number of overflows -> cannot optimize If away\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongProductsDifferentNumberOfUnderflows(boolean flag, boolean flag2) {\n+        \/\/ -6917529027641081856 * 4 = Long.MIN_VALUE*3 --cast to long--> Long.MIN_VALUE \/\/ Underflown once\n+        \/\/ -6917529027641081857 * 4 = (Long.MIN_VALUE*3 - 4) --cast to long--> Long.MAX_VALUE - 3 \/\/ Underflown twice\n+        long l = flag ? -6917529027641081856L : -6917529027641081857L;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ Different number of underflows -> cannot optimize If away\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongNotSameOverflow1(boolean flag, boolean flag2) {\n+        long l = flag ? 1 : Long.MAX_VALUE;\n+        int x = flag2 ? -1 : 2;\n+\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongNotSameOverflow2(boolean flag, boolean flag2) {\n+        long l = flag ? 1 : Long.MIN_VALUE;\n+        int x = flag2 ? -1 : 2;\n+\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongNotSameOverflow3(boolean flag, boolean flag2) {\n+        long l = flag ? -1 : Long.MIN_VALUE;\n+        long x = flag2 ? Long.MIN_VALUE : -1;\n+\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongNotSameOverflow4(boolean flag, boolean flag2) {\n+        long l = flag ? -1 : Long.MAX_VALUE;\n+        long x = flag2 ? Long.MAX_VALUE : -1;\n+\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongNotSameOverflow5(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MIN_VALUE : Long.MAX_VALUE;\n+        long x = flag2 ? Long.MAX_VALUE : -1;\n+\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    \/\/ Int cases\n+    @Test\n+    @IR(failOn = IRNode.IF, counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\"})\n+    public static void testIntPositive() {\n+        int i = 26000000;\n+        if (i * 81 == 1) {\n+            iFld = 23;\n+        }\n+        if (i * 81 == 2106000000) {\n+            iFld = 34;\n+        }\n+\n+        if (i * 83 == 1) {\n+            lFld = 23;\n+        }\n+        if (i * 83 == -2136967296) {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.IF, counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\"})\n+    public static void testIntPositive2() {\n+        int i = -26000000;\n+        if (i * -81 == 1) {\n+            iFld = 23;\n+        }\n+        if (i * -81 == 2106000000) {\n+            iFld = 34;\n+        }\n+\n+        if (i * -83 == 1) {\n+            lFld = 23;\n+        }\n+        if (i * -83 == -2136967296) {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.IF, counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\"})\n+    public static void testIntNegative() {\n+        int i = 26000000;\n+        if (i * -81 == 1) {\n+            iFld = 23;\n+        }\n+        if (i * -81 == -2106000000) {\n+            iFld = 34;\n+        }\n+\n+        if (i * -83 == 1) {\n+            lFld = 23;\n+        }\n+        if (i * -83 == 2136967296) {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.IF, counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\"})\n+    public static void testIntNegative2() {\n+        int i = -26000000;\n+        if (i * 81 == 1) {\n+            iFld = 23;\n+        }\n+        if (i * 81 == -2106000000) {\n+            iFld = 34;\n+        }\n+\n+        if (i * 83 == 1) {\n+            lFld = 23;\n+        }\n+        if (i * 83 == 2136967296) {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntMinValueMinus1(boolean flag, boolean flag2) {\n+        int l = flag ? -1 : Integer.MIN_VALUE;\n+        int x = flag2 ? -1 : 0;\n+\n+        if (l * x != 2) { \/\/ Type of multiplication is INT as Integer.MIN_VALUE * -1 does overflow. If cannot be removed.\n+            lFld = 23;\n+        } else {\n+            lFld = 34; \/\/ Emits StoreL since warmup is 0 and no UCT will be emitted.\n+        }\n+    }\n+\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_I, IRNode.STORE_L}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testIntMinValuePlus1(boolean flag, boolean flag2) {\n+        int l = flag ? -1 : Integer.MIN_VALUE;\n+        int x = flag2 ? 1 : 0;\n+\n+        if (l * x <= 0) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_I, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testIntMinValueUnderflowOnce(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MIN_VALUE\/2 : Integer.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 4 : 6;\n+\n+        if (l * x <= 4) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\", IRNode.MUL_I, \"1\"})\n+    public static void testIntMinValueUnderflowOnceTwice(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MIN_VALUE\/2 : Integer.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 6 : 8;\n+\n+        if (l * x <= 4) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_I, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testIntMinValueUnderflowTwice(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MIN_VALUE\/2 : Integer.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 8 : 10;\n+\n+        if (l * x <= 8) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_I, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testIntMaxValueOverflowOnce(boolean flag, boolean flag2) {\n+        int l = flag2 ? Integer.MAX_VALUE\/2 - 1 : Integer.MAX_VALUE\/2;\n+        int x = flag ? 4 : 6;\n+\n+        if (l * x >= -8) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\", IRNode.MUL_I, \"1\"})\n+    public static void testIntMaxValueOverflowOnceTwice(boolean flag, boolean flag2) {\n+        int l = flag2 ? Integer.MAX_VALUE\/2 - 1 : Integer.MAX_VALUE\/2;\n+        int x = flag ? 6 : 8;\n+\n+        if (l * x >= -8) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_I, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testIntMaxValueOverflowTwice(boolean flag, boolean flag2) {\n+        int l = flag2 ? Integer.MAX_VALUE\/2 - 1 : Integer.MAX_VALUE\/2;\n+        int x = flag ? 8 : 10;\n+\n+        if (l * x >= -16L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_I, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testIntProductsOverflowOnceAtMin(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MAX_VALUE\/2 + 1 : Integer.MAX_VALUE\/2 + 2;\n+        int x = flag2 ? 2 : 3;\n+\n+        \/\/ [MAX_VALUE\/2 + 1, MAX_VALUE\/2 + 2] * [2,3]: All cross products overflow exactly once.\n+        \/\/ Result: [MIN_VALUE, MIN_VALUE\/2 + 3] -> 2 outside range and If can be optimized away.\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_I, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testIntProductsOverflowOnceAtMax(boolean flag, boolean flag2) {\n+        \/\/ 63786643 * 101 = Integer.MAX_VALUE*3 + 2 --cast to int--> Integer.MAX_VALUE\n+        int l = flag ? 63786642 : 63786643;\n+        int x = flag2 ? 100 : 101;\n+\n+        \/\/ All cross products overflow exactly once.\n+        \/\/ Result: [y, MAX_VALUE], where y > 2 -> 2 outside range and If can be optimized away.\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_I, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testIntProductsUnderflowOnceAtMin(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MIN_VALUE\/3 - 1 : Integer.MIN_VALUE\/3 - 2;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ [MIN_VALUE\/3 - 1, MIN_VALUE\/3 - 2] * [3,4]: All cross products underflow exactly once.\n+        \/\/ Result: [MAX_VALUE + MIN_VALUE\/3 - 5, MAX_VALUE] -> 2 outside range and If can be optimized away.\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_I, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testIntProductsUnderflowOnceAtMax(boolean flag, boolean flag2) {\n+        \/\/ -1610612736 * 4 = Integer.MIN_VALUE*3 --cast to int--> Integer.MIN_VALUE\n+        int l = flag ? -1610612736 : -1610612735;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ All cross products underflow exactly once.\n+        \/\/ Result: [MIN_VALUE, y], where y < 2 -> 2 outside range and If can be optimized away.\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntProductsDifferentNumberOfOverflow(boolean flag, boolean flag2) {\n+        \/\/ 63786643 * 101 = Integer.MAX_VALUE*3 + 2 --cast to int--> Integer.MAX_VALUE \/\/ Overflown once\n+        \/\/ 63786644 * 101 = (Integer.MAX_VALUE*3 + 101) + 2 --cast to int--> Integer.MIN_VALUE + 100 \/\/ Overflown twice\n+        int l = flag ? 63786643 : 63786644;\n+        int x = flag2 ? 100 : 101;\n+\n+        \/\/ Different number of overflows -> cannot optimize If away\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntProductsDifferentNumberOfUnderflows(boolean flag, boolean flag2) {\n+        \/\/ -1610612736 * 4 = Integer.MIN_VALUE*3 --cast to int--> Integer.MIN_VALUE \/\/ Underflown once\n+        \/\/ -1610612737 * 4 = (Integer.MIN_VALUE*3 - 4) --cast to int--> Integer.MAX_VALUE - 3 \/\/ Underflown twice\n+        int l = flag ? -1610612736 : -1610612737;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ Different number of underflows -> cannot optimize If away\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntNotSameOverflow1(boolean flag, boolean flag2) {\n+        int l = flag ? 1 : Integer.MAX_VALUE;\n+        int x = flag2 ? -1 : 2;\n+\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntNotSameOverflow2(boolean flag, boolean flag2) {\n+        int l = flag ? 1 : Integer.MIN_VALUE;\n+        int x = flag2 ? -1 : 2;\n+\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntNotSameOverflow3(boolean flag, boolean flag2) {\n+        int l = flag ? -1 : Integer.MIN_VALUE;\n+        int x = flag2 ? Integer.MIN_VALUE : -1;\n+\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntNotSameOverflow4(boolean flag, boolean flag2) {\n+        int l = flag ? -1 : Integer.MAX_VALUE;\n+        int x = flag2 ? Integer.MAX_VALUE : -1;\n+\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntNotSameOverflow5(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n+        int x = flag2 ? Integer.MAX_VALUE : -1;\n+\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    \/\/ Just some sanity testing.\n+    @Test\n+    public static void test() {\n+        iFld = 1073741823 * 2;\n+        iFld2 = 1073741824 * 2; \/\/ overflow\n+        iFld3 = -1073741824 * 2;\n+        iFld4 = -1073741825 * 2; \/\/ underflow\n+        lFld = 4611686018427387903L * 2;\n+        lFld2 = 4611686018427387904L * 2; \/\/ overflow\n+        lFld3 = -4611686018427387904L * 2;\n+        lFld4 = -4611686018427387905L * 2; \/\/ underflow\n+    }\n+\n+    @Run(test = \"test\")\n+    public static void run() {\n+        test();\n+        Asserts.assertEQ(iFld, 2147483646);\n+        Asserts.assertEQ(iFld2, -2147483648);\n+        Asserts.assertEQ(iFld3, -2147483648);\n+        Asserts.assertEQ(iFld4, 2147483646);\n+        Asserts.assertEQ(lFld, 9223372036854775806L);\n+        Asserts.assertEQ(lFld2, -9223372036854775808L);\n+        Asserts.assertEQ(lFld3, -9223372036854775808L);\n+        Asserts.assertEQ(lFld4, 9223372036854775806L);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/igvn\/TestIntegerMulRing.java","additions":820,"deletions":0,"binary":false,"changes":820,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8299546\n+ * @summary Tests that MulL::Value() does not return bottom type and then an optimized type again in CCP.\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.ccp.TestMissingMulLOptimization::*\n+ *                   -XX:CompileCommand=dontinline,compiler.ccp.TestMissingMulLOptimization::*\n+ *                   compiler.ccp.TestMissingMulLOptimization\n+ *\/\n+package compiler.ccp;\n+\n+public class TestMissingMulLOptimization {\n+    static int N;\n+    static long x;\n+\n+    public static void main(String[] strArr) {\n+        try {\n+            test();\n+        } catch (RuntimeException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static int test() {\n+        int i6 = 2, i10 = 3, i11, iArr[] = new int[N];\n+        long l = 3151638515L;\n+        double dArr[] = new double[N];\n+        dontInline();\n+        int i;\n+        for (i = 7; i < 221; i++) {\n+            i6 *= i6;\n+        }\n+        for (int j = 9; 83 > j; ) {\n+            for (i11 = 1; i11 < 6; ++i11) {\n+                l *= i;\n+                l += 3;\n+            }\n+        }\n+        x += i6;\n+        return 34;\n+    }\n+\n+    static int dontInline() {\n+        throw new RuntimeException();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ccp\/TestMissingMulLOptimization.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -86,2 +86,3 @@\n-            expectStableFloats = (sse >= 1);\n-            expectStableDoubles = (sse >= 2);\n+            boolean stubsPresent = WHITE_BOX.getBooleanVMFlag(\"InlineIntrinsics\");\n+            expectStableFloats = (sse >= 1) && stubsPresent;\n+            expectStableDoubles = (sse >= 2) && stubsPresent;\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/NaNTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -169,0 +169,5 @@\n+    public static final String ADD_VF = PREFIX + \"ADD_VF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_VF, \"AddVF\");\n+    }\n+\n@@ -184,0 +189,10 @@\n+    public static final String ADD_REDUCTION_VI = PREFIX + \"ADD_REDUCTION_VI\" + POSTFIX;\n+    static {\n+        superWordNodes(ADD_REDUCTION_VI, \"AddReductionVI\");\n+    }\n+\n+    public static final String ADD_REDUCTION_VL = PREFIX + \"ADD_REDUCTION_VL\" + POSTFIX;\n+    static {\n+        superWordNodes(ADD_REDUCTION_VL, \"AddReductionVL\");\n+    }\n+\n@@ -233,0 +248,5 @@\n+    public static final String AND_REDUCTION_V = PREFIX + \"AND_REDUCTION_V\" + POSTFIX;\n+    static {\n+        superWordNodes(AND_REDUCTION_V, \"AndReductionV\");\n+    }\n+\n@@ -702,0 +722,5 @@\n+    public static final String MUL_VI = PREFIX + \"MUL_VI\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_VI, \"MulVI\");\n+    }\n+\n@@ -712,0 +737,10 @@\n+    public static final String MUL_REDUCTION_VI = PREFIX + \"MUL_REDUCTION_VI\" + POSTFIX;\n+    static {\n+        superWordNodes(MUL_REDUCTION_VI, \"MulReductionVI\");\n+    }\n+\n+    public static final String MUL_REDUCTION_VL = PREFIX + \"MUL_REDUCTION_VL\" + POSTFIX;\n+    static {\n+        superWordNodes(MUL_REDUCTION_VL, \"MulReductionVL\");\n+    }\n+\n@@ -737,0 +772,5 @@\n+    public static final String OR_REDUCTION_V = PREFIX + \"OR_REDUCTION_V\" + POSTFIX;\n+    static {\n+        superWordNodes(OR_REDUCTION_V, \"OrReductionV\");\n+    }\n+\n@@ -1356,0 +1396,5 @@\n+    public static final String XOR_REDUCTION_V = PREFIX + \"XOR_REDUCTION_V\" + POSTFIX;\n+    static {\n+        superWordNodes(XOR_REDUCTION_V, \"XorReductionV\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,45 +28,2 @@\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.ProdRed_Double\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.ProdRed_Double\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.ProdRed_Double\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.ProdRed_Double\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.ProdRed_Double\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.ProdRed_Double\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.ProdRed_Double\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.ProdRed_Double\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.ProdRed_Double\n@@ -77,0 +34,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -79,0 +38,21 @@\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\",\n+                           \"-XX:LoopUnrollLimit=250\",\n+                           \"-XX:CompileThresholdScaling=0.1\");\n+        int i = 0;\n+        Scenario[] scenarios = new Scenario[6];\n+        for (String reductionSign : new String[] {\"+\", \"-\"}) {\n+            for (int maxUnroll : new int[] {4, 8, 16}) {\n+                scenarios[i] = new Scenario(i, \"-XX:\" + reductionSign + \"SuperWordReductions\",\n+                                               \"-XX:LoopMaxUnroll=\" + maxUnroll);\n+                i++;\n+            }\n+        }\n+        framework.addScenarios(scenarios);\n+        framework.start();\n+    }\n+\n+    @Run(test = {\"prodReductionImplement\",\n+                 \"prodReductionWithStoreImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public void runTests() throws Exception {\n@@ -81,0 +61,1 @@\n+        double[] c = new double[256 * 1024];\n@@ -88,6 +69,5 @@\n-        if (total == valid) {\n-            System.out.println(\"Success\");\n-        } else {\n-            System.out.println(\"Invalid sum of elements variable in total: \" + total);\n-            System.out.println(\"Expected value = \" + valid);\n-            throw new Exception(\"Failed\");\n+        testCorrectness(valid, total, \"prodReduction\");\n+        total = 0;\n+        for (int j = 0; j < 2000; j++) {\n+            total = j + 1;\n+            total = prodReductionWithStoreImplement(a, b, c, total);\n@@ -95,0 +75,1 @@\n+        testCorrectness(valid, total, \"prodReductionWithStore\");\n@@ -104,0 +85,5 @@\n+    \/* Vectorization is expected but not enabled (SuperWord::implemented).\n+       A positive @IR test should be added later. *\/\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.MUL_REDUCTION_VD})\n@@ -111,0 +97,25 @@\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.MUL_REDUCTION_VD})\n+    @IR(applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        applyIfCPUFeature = {\"sse2\", \"true\"},\n+        counts = {IRNode.MUL_REDUCTION_VD, \">= 1\"})\n+    public static double prodReductionWithStoreImplement(double[] a, double[] b, double[] c, double total) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = a[i] - b[i];\n+            total *= c[i];\n+        }\n+        return total;\n+    }\n+\n+    public static void testCorrectness(\n+            double total,\n+            double valid,\n+            String op) throws Exception {\n+        if (total != valid) {\n+            throw new Exception(\n+                \"Invalid total: \" + total + \" \" +\n+                \"Expected value = \" + valid + \" \" + op + \": Failed\");\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Double.java","additions":63,"deletions":52,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,45 +28,2 @@\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.ProdRed_Float\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.ProdRed_Float\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.ProdRed_Float\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.ProdRed_Float\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.ProdRed_Float\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.ProdRed_Float\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.ProdRed_Float\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.ProdRed_Float\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.ProdRed_Float\n@@ -77,0 +34,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -79,0 +38,20 @@\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\",\n+                           \"-XX:LoopUnrollLimit=250\",\n+                           \"-XX:CompileThresholdScaling=0.1\");\n+        int i = 0;\n+        Scenario[] scenarios = new Scenario[6];\n+        for (String reductionSign : new String[] {\"+\", \"-\"}) {\n+            for (int maxUnroll : new int[] {4, 8, 16}) {\n+                scenarios[i] = new Scenario(i, \"-XX:\" + reductionSign + \"SuperWordReductions\",\n+                                               \"-XX:LoopMaxUnroll=\" + maxUnroll);\n+                i++;\n+            }\n+        }\n+        framework.addScenarios(scenarios);\n+        framework.start();\n+    }\n+\n+    @Run(test = {\"prodReductionImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public void runTests() throws Exception {\n@@ -104,0 +83,6 @@\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.MUL_REDUCTION_VF})\n+    @IR(applyIfCPUFeature = {\"sse4.1\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.MUL_REDUCTION_VF, \">= 1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Float.java","additions":31,"deletions":46,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,45 +28,2 @@\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.ProdRed_Int\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.ProdRed_Int\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.ProdRed_Int\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.ProdRed_Int\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.ProdRed_Int\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.ProdRed_Int\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.ProdRed_Int\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.ProdRed_Int\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.ProdRed_Int\n@@ -77,0 +34,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -79,0 +38,20 @@\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\",\n+                           \"-XX:LoopUnrollLimit=250\",\n+                           \"-XX:CompileThresholdScaling=0.1\");\n+        int i = 0;\n+        Scenario[] scenarios = new Scenario[6];\n+        for (String reductionSign : new String[] {\"+\", \"-\"}) {\n+            for (int maxUnroll : new int[] {4, 8, 16}) {\n+                scenarios[i] = new Scenario(i, \"-XX:\" + reductionSign + \"SuperWordReductions\",\n+                                               \"-XX:LoopMaxUnroll=\" + maxUnroll);\n+                i++;\n+            }\n+        }\n+        framework.addScenarios(scenarios);\n+        framework.start();\n+    }\n+\n+    @Run(test = {\"prodReductionImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public void runTests() throws Exception {\n@@ -103,0 +82,6 @@\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.MUL_REDUCTION_VI})\n+    @IR(applyIfCPUFeature = {\"sse4.1\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.MUL_REDUCTION_VI, \">= 1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Int.java","additions":31,"deletions":46,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,48 +28,2 @@\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-TieredCompilation\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.RedTest_int\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.RedTest_int\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-TieredCompilation\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.RedTest_int\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.RedTest_int\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-TieredCompilation\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.RedTest_int\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.RedTest_int\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-TieredCompilation\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.RedTest_int\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.RedTest_int\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.RedTest_int\n@@ -80,0 +34,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -84,0 +40,28 @@\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\",\n+                           \"-XX:LoopUnrollLimit=250\",\n+                           \"-XX:CompileThresholdScaling=0.1\");\n+        int i = 0;\n+        Scenario[] scenarios = new Scenario[6];\n+        for (int maxUnroll : new int[] {4, 8, 16}) {\n+            scenarios[i] = new Scenario(i, \"-XX:+SuperWordReductions\",\n+                                           \"-XX:LoopMaxUnroll=\" + maxUnroll,\n+                                           \"-XX:-TieredCompilation\");\n+            i++;\n+        }\n+        for (int maxUnroll : new int[] {4, 8, 16}) {\n+            scenarios[i] = new Scenario(i, \"-XX:-SuperWordReductions\",\n+                                           \"-XX:LoopMaxUnroll=\" + maxUnroll);\n+            i++;\n+        }\n+        framework.addScenarios(scenarios);\n+        framework.start();\n+    }\n+\n+    @Run(test = {\"sumReductionImplement\",\n+                 \"orReductionImplement\",\n+                 \"andReductionImplement\",\n+                 \"xorReductionImplement\",\n+                 \"mulReductionImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public void runTests() throws Exception {\n@@ -87,1 +71,0 @@\n-        int[] d = new int[NUM];\n@@ -90,1 +73,1 @@\n-        int valid = 0;\n+        int valid = 1454604288;\n@@ -92,4 +75,1 @@\n-            total = sumReductionImplement(a, b, c, d);\n-        }\n-        for (int j = 0; j < d.length; j++) {\n-            valid += d[j];\n+            total = sumReductionImplement(a, b, c, total);\n@@ -99,1 +79,2 @@\n-        valid = 0;\n+        total = 0;\n+        valid = 91586175;\n@@ -101,4 +82,1 @@\n-            total = orReductionImplement(a, b, c, d);\n-        }\n-        for (int j = 0; j < d.length; j++) {\n-            valid |= d[j];\n+            total = orReductionImplement(a, b, c, total);\n@@ -108,1 +86,2 @@\n-        valid = -1;\n+        total = -1;\n+        valid = 91492404;\n@@ -110,4 +89,1 @@\n-            total = andReductionImplement(a, b, c, d);\n-        }\n-        for (int j = 0; j < d.length; j++) {\n-            valid &= d[j];\n+            total = andReductionImplement(a, b, c, total);\n@@ -117,0 +93,1 @@\n+        total = -1;\n@@ -119,4 +96,1 @@\n-            total = xorReductionImplement(a, b, c, d);\n-        }\n-        for (int j = 0; j < d.length; j++) {\n-            valid ^= d[j];\n+            total = xorReductionImplement(a, b, c, total);\n@@ -127,1 +101,2 @@\n-        valid = 1;\n+        total = 1;\n+        valid = 1690042369;\n@@ -129,4 +104,1 @@\n-            total = mulReductionImplement(a, b, c, d);\n-        }\n-        for (int j = 0; j < d.length; j++) {\n-            valid *= d[j];\n+            total = mulReductionImplement(a, b, c, total);\n@@ -160,0 +132,6 @@\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.ADD_REDUCTION_VI})\n+    @IR(applyIfCPUFeature = {\"sse4.1\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.ADD_REDUCTION_VI, \">= 1\"})\n@@ -164,2 +142,1 @@\n-            int[] d) {\n-        int total = 0;\n+            int total) {\n@@ -167,2 +144,1 @@\n-            d[i] = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n-            total += d[i];\n+            total += (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n@@ -173,0 +149,6 @@\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.OR_REDUCTION_V})\n+    @IR(applyIfCPUFeature = {\"sse4.1\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.OR_REDUCTION_V, \">= 1\"})\n@@ -177,2 +159,1 @@\n-            int[] d) {\n-        int total = 0;\n+            int total) {\n@@ -180,2 +161,1 @@\n-            d[i] = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n-            total |= d[i];\n+            total |= (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n@@ -186,0 +166,6 @@\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.AND_REDUCTION_V})\n+    @IR(applyIfCPUFeature = {\"sse4.1\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.AND_REDUCTION_V, \">= 1\"})\n@@ -190,2 +176,1 @@\n-            int[] d) {\n-        int total = -1;\n+            int total) {\n@@ -193,2 +178,1 @@\n-            d[i] = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n-            total &= d[i];\n+            total &= (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n@@ -199,0 +183,6 @@\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.XOR_REDUCTION_V})\n+    @IR(applyIfCPUFeature = {\"sse4.1\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.XOR_REDUCTION_V, \">= 1\"})\n@@ -203,2 +193,1 @@\n-            int[] d) {\n-        int total = -1;\n+            int total) {\n@@ -206,2 +195,1 @@\n-            d[i] = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n-            total ^= d[i];\n+            total ^= (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n@@ -212,0 +200,6 @@\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.MUL_REDUCTION_VI})\n+    @IR(applyIfCPUFeature = {\"sse4.1\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.MUL_REDUCTION_VI, \">= 1\"})\n@@ -216,2 +210,1 @@\n-            int[] d) {\n-        int total = 1;\n+            int total) {\n@@ -219,2 +212,1 @@\n-            d[i] = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n-            total = total*d[i];\n+            total *= (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n@@ -229,6 +221,4 @@\n-        if (total == valid) {\n-            System.out.println(op + \": Success\");\n-        } else {\n-            System.out.println(\"Invalid total: \" + total);\n-            System.out.println(\"Expected value = \" + valid);\n-            throw new Exception(op + \": Failed\");\n+        if (total != valid) {\n+            throw new Exception(\n+                \"Invalid total: \" + total + \" \" +\n+                \"Expected value = \" + valid + \" \" + op + \": Failed\");\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/RedTest_int.java","additions":90,"deletions":100,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,48 +28,3 @@\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-TieredCompilation\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.RedTest_long\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.RedTest_long\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-TieredCompilation\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.RedTest_long\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.RedTest_long\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-TieredCompilation\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.RedTest_long\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.RedTest_long\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-TieredCompilation\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.RedTest_long\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.RedTest_long\n+ * @requires vm.bits == \"64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.RedTest_long\n@@ -80,0 +35,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -84,0 +41,28 @@\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\",\n+                           \"-XX:LoopUnrollLimit=250\",\n+                           \"-XX:CompileThresholdScaling=0.1\");\n+        int i = 0;\n+        Scenario[] scenarios = new Scenario[6];\n+        for (int maxUnroll : new int[] {4, 8, 16}) {\n+            scenarios[i] = new Scenario(i, \"-XX:+SuperWordReductions\",\n+                                           \"-XX:LoopMaxUnroll=\" + maxUnroll,\n+                                           \"-XX:-TieredCompilation\");\n+            i++;\n+        }\n+        for (int maxUnroll : new int[] {4, 8, 16}) {\n+            scenarios[i] = new Scenario(i, \"-XX:-SuperWordReductions\",\n+                                           \"-XX:LoopMaxUnroll=\" + maxUnroll);\n+            i++;\n+        }\n+        framework.addScenarios(scenarios);\n+        framework.start();\n+    }\n+\n+    @Run(test = {\"sumReductionImplement\",\n+                 \"orReductionImplement\",\n+                 \"andReductionImplement\",\n+                 \"xorReductionImplement\",\n+                 \"mulReductionImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public static void runTests() throws Exception {\n@@ -87,1 +72,0 @@\n-        long[] d = new long[NUM];\n@@ -90,1 +74,1 @@\n-        long valid = 0;\n+        long valid = 374944929792000L;\n@@ -92,4 +76,1 @@\n-            total = sumReductionImplement(a, b, c, d);\n-        }\n-        for (int j = 0; j < d.length; j++) {\n-            valid += d[j];\n+            total = sumReductionImplement(a, b, c, total);\n@@ -99,1 +80,2 @@\n-        valid = 0;\n+        total = 0;\n+        valid = 91586175;\n@@ -101,4 +83,1 @@\n-            total = orReductionImplement(a, b, c, d);\n-        }\n-        for (int j = 0; j < d.length; j++) {\n-            valid |= d[j];\n+            total = orReductionImplement(a, b, c, total);\n@@ -108,1 +87,2 @@\n-        valid = -1;\n+        total = -1;\n+        valid = 91492404;\n@@ -110,4 +90,1 @@\n-            total = andReductionImplement(a, b, c, d);\n-        }\n-        for (int j = 0; j < d.length; j++) {\n-            valid &= d[j];\n+            total = andReductionImplement(a, b, c, total);\n@@ -117,0 +94,1 @@\n+        total = -1;\n@@ -119,4 +97,1 @@\n-            total = xorReductionImplement(a, b, c, d);\n-        }\n-        for (int j = 0; j < d.length; j++) {\n-            valid ^= d[j];\n+            total = xorReductionImplement(a, b, c, total);\n@@ -127,1 +102,2 @@\n-        valid = 1;\n+        total = 1;\n+        valid = 2953257964269338625L;\n@@ -129,4 +105,1 @@\n-            total = mulReductionImplement(a, b, c, d);\n-        }\n-        for (int j = 0; j < d.length; j++) {\n-            valid *= d[j];\n+            total = mulReductionImplement(a, b, c, total);\n@@ -160,0 +133,8 @@\n+    \/* Require avx2 due to filtering out small vector lengths\n+       for long and int (SuperWord::implemented). *\/\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.ADD_REDUCTION_VL})\n+    @IR(applyIfCPUFeature = {\"avx2\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.ADD_REDUCTION_VL, \">= 1\"})\n@@ -164,2 +145,1 @@\n-            long[] d) {\n-        long total = 0;\n+            long total) {\n@@ -167,2 +147,1 @@\n-            d[i] = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n-            total += d[i];\n+            total += (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n@@ -173,0 +152,6 @@\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.OR_REDUCTION_V})\n+    @IR(applyIfCPUFeature = {\"avx2\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.OR_REDUCTION_V, \">= 1\"})\n@@ -177,2 +162,1 @@\n-            long[] d) {\n-        long total = 0;\n+            long total) {\n@@ -180,2 +164,1 @@\n-            d[i] = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n-            total |= d[i];\n+            total |= (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n@@ -186,0 +169,6 @@\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.AND_REDUCTION_V})\n+    @IR(applyIfCPUFeature = {\"avx2\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.AND_REDUCTION_V, \">= 1\"})\n@@ -190,2 +179,1 @@\n-            long[] d) {\n-        long total = -1;\n+            long total) {\n@@ -193,2 +181,1 @@\n-            d[i] = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n-            total &= d[i];\n+            total &= (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n@@ -199,0 +186,6 @@\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.XOR_REDUCTION_V})\n+    @IR(applyIfCPUFeature = {\"avx2\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.XOR_REDUCTION_V, \">= 1\"})\n@@ -203,2 +196,1 @@\n-            long[] d) {\n-        long total = -1;\n+            long total) {\n@@ -206,2 +198,1 @@\n-            d[i] = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n-            total ^= d[i];\n+            total ^= (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n@@ -212,0 +203,6 @@\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.MUL_REDUCTION_VL})\n+    @IR(applyIfCPUFeature = {\"avx512dq\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.MUL_REDUCTION_VL, \">= 1\"})\n@@ -216,2 +213,1 @@\n-            long[] d) {\n-        long total = 1;\n+            long total) {\n@@ -219,2 +215,1 @@\n-            d[i] = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n-            total = total*d[i];\n+            total *= (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n@@ -229,6 +224,4 @@\n-        if (total == valid) {\n-            System.out.println(op + \": Success\");\n-        } else {\n-            System.out.println(\"Invalid total: \" + total);\n-            System.out.println(\"Expected value = \" + valid);\n-            throw new Exception(op + \": Failed\");\n+        if (total != valid) {\n+            throw new Exception(\n+                \"Invalid total: \" + total + \" \" +\n+                \"Expected value = \" + valid + \" \" + op + \": Failed\");\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/RedTest_long.java","additions":93,"deletions":100,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,45 +28,2 @@\n- * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\"\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.SumRedAbsNeg_Double\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.SumRedAbsNeg_Double\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.SumRedAbsNeg_Double\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.SumRedAbsNeg_Double\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.SumRedAbsNeg_Double\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.SumRedAbsNeg_Double\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.SumRedAbsNeg_Double\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.SumRedAbsNeg_Double\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.SumRedAbsNeg_Double\n@@ -77,0 +34,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -79,0 +38,20 @@\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\",\n+                           \"-XX:LoopUnrollLimit=250\",\n+                           \"-XX:CompileThresholdScaling=0.1\");\n+        int i = 0;\n+        Scenario[] scenarios = new Scenario[6];\n+        for (String reductionSign : new String[] {\"+\", \"-\"}) {\n+            for (int maxUnroll : new int[] {4, 8, 16}) {\n+                scenarios[i] = new Scenario(i, \"-XX:\" + reductionSign + \"SuperWordReductions\",\n+                                               \"-XX:LoopMaxUnroll=\" + maxUnroll);\n+                i++;\n+            }\n+        }\n+        framework.addScenarios(scenarios);\n+        framework.start();\n+    }\n+\n+    @Run(test = {\"sumReductionImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public void runTests() throws Exception {\n@@ -82,1 +61,0 @@\n-        double[] d = new double[256 * 1024];\n@@ -88,1 +66,1 @@\n-            total = sumReductionImplement(a, b, c, d, total);\n+            total = sumReductionImplement(a, b, c, total);\n@@ -113,0 +91,5 @@\n+    \/* Does not vectorize due to profitability heuristic\n+       (with or without store) in SuperWord::profitable. *\/\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.ADD_REDUCTION_VD, IRNode.ABS_V, IRNode.NEG_V})\n@@ -117,1 +100,0 @@\n-            double[] d,\n@@ -120,2 +102,1 @@\n-            d[i] = Math.abs(-a[i] * -b[i]) + Math.abs(-a[i] * -c[i]) + Math.abs(-b[i] * -c[i]);\n-            total += d[i];\n+            total += Math.abs(-a[i] * -b[i]) + Math.abs(-a[i] * -c[i]) + Math.abs(-b[i] * -c[i]);\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRedAbsNeg_Double.java","additions":32,"deletions":51,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,45 +28,2 @@\n- * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\"\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.SumRedAbsNeg_Float\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.SumRedAbsNeg_Float\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.SumRedAbsNeg_Float\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.SumRedAbsNeg_Float\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.SumRedAbsNeg_Float\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.SumRedAbsNeg_Float\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.SumRedAbsNeg_Float\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.SumRedAbsNeg_Float\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.SumRedAbsNeg_Float\n@@ -77,0 +34,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -79,0 +38,20 @@\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\",\n+                           \"-XX:LoopUnrollLimit=250\",\n+                           \"-XX:CompileThresholdScaling=0.1\");\n+        int i = 0;\n+        Scenario[] scenarios = new Scenario[6];\n+        for (String reductionSign : new String[] {\"+\", \"-\"}) {\n+            for (int maxUnroll : new int[] {4, 8, 16}) {\n+                scenarios[i] = new Scenario(i, \"-XX:\" + reductionSign + \"SuperWordReductions\",\n+                                               \"-XX:LoopMaxUnroll=\" + maxUnroll);\n+                i++;\n+            }\n+        }\n+        framework.addScenarios(scenarios);\n+        framework.start();\n+    }\n+\n+    @Run(test = {\"sumReductionImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public void runTests() throws Exception {\n@@ -82,1 +61,0 @@\n-        float[] d = new float[256 * 1024];\n@@ -88,1 +66,1 @@\n-            total = sumReductionImplement(a, b, c, d, total);\n+            total = sumReductionImplement(a, b, c, total);\n@@ -113,0 +91,6 @@\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.ADD_REDUCTION_VF, IRNode.ABS_V, IRNode.NEG_V})\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.ADD_REDUCTION_VF, \">= 1\", IRNode.ABS_V, \">= 1\", IRNode.NEG_V, \">= 1\"})\n@@ -117,1 +101,0 @@\n-            float[] d,\n@@ -120,2 +103,1 @@\n-            d[i] = Math.abs(-a[i] * -b[i]) + Math.abs(-a[i] * -c[i]) + Math.abs(-b[i] * -c[i]);\n-            total += d[i];\n+            total += Math.abs(-a[i] * -b[i]) + Math.abs(-a[i] * -c[i]) + Math.abs(-b[i] * -c[i]);\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRedAbsNeg_Float.java","additions":33,"deletions":51,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,45 +28,2 @@\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.SumRedSqrt_Double\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.SumRedSqrt_Double\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.SumRedSqrt_Double\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.SumRedSqrt_Double\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.SumRedSqrt_Double\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.SumRedSqrt_Double\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.SumRedSqrt_Double\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.SumRedSqrt_Double\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.SumRedSqrt_Double\n@@ -78,0 +35,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -80,0 +39,20 @@\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\",\n+                           \"-XX:LoopUnrollLimit=250\",\n+                           \"-XX:CompileThresholdScaling=0.1\");\n+        int i = 0;\n+        Scenario[] scenarios = new Scenario[6];\n+        for (String reductionSign : new String[] {\"+\", \"-\"}) {\n+            for (int maxUnroll : new int[] {4, 8, 16}) {\n+                scenarios[i] = new Scenario(i, \"-XX:\" + reductionSign + \"SuperWordReductions\",\n+                                               \"-XX:LoopMaxUnroll=\" + maxUnroll);\n+                i++;\n+            }\n+        }\n+        framework.addScenarios(scenarios);\n+        framework.start();\n+    }\n+\n+    @Run(test = {\"sumReductionWithStoreImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public void runTests() throws Exception {\n@@ -88,8 +67,1 @@\n-            total = sumReductionImplement(a, b, c, d, total);\n-        }\n-        if (total == valid) {\n-            System.out.println(\"Success\");\n-        } else {\n-            System.out.println(\"Invalid sum of elements variable in total: \" + total);\n-            System.out.println(\"Expected value = \" + valid);\n-            throw new Exception(\"Failed\");\n+            total = sumReductionWithStoreImplement(a, b, c, d, total);\n@@ -97,0 +69,1 @@\n+        testCorrectness(total, valid, \"sumReductionWithStore\");\n@@ -112,1 +85,10 @@\n-    public static double sumReductionImplement(\n+    \/* Vectorization is expected but not enabled without store.\n+       The store could be removed later.\n+       Require avx for SQRT_VD. *\/\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.ADD_REDUCTION_VD, IRNode.SQRT_V})\n+    @IR(applyIfCPUFeature = {\"avx\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.ADD_REDUCTION_VD, \">= 1\", IRNode.SQRT_V, \">= 1\"})\n+    public static double sumReductionWithStoreImplement(\n@@ -125,0 +107,11 @@\n+    public static void testCorrectness(\n+            double total,\n+            double valid,\n+            String op) throws Exception {\n+        if (total != valid) {\n+            throw new Exception(\n+                \"Invalid total: \" + total + \" \" +\n+                \"Expected value = \" + valid + \" \" + op + \": Failed\");\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRedSqrt_Double.java","additions":48,"deletions":55,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,45 +28,2 @@\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.SumRed_Double\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.SumRed_Double\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.SumRed_Double\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.SumRed_Double\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.SumRed_Double\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.SumRed_Double\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.SumRed_Double\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.SumRed_Double\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.SumRed_Double\n@@ -77,0 +34,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -79,0 +38,21 @@\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\",\n+                           \"-XX:LoopUnrollLimit=250\",\n+                           \"-XX:CompileThresholdScaling=0.1\");\n+        int i = 0;\n+        Scenario[] scenarios = new Scenario[6];\n+        for (String reductionSign : new String[] {\"+\", \"-\"}) {\n+            for (int maxUnroll : new int[] {4, 8, 16}) {\n+                scenarios[i] = new Scenario(i, \"-XX:\" + reductionSign + \"SuperWordReductions\",\n+                                               \"-XX:LoopMaxUnroll=\" + maxUnroll);\n+                i++;\n+            }\n+        }\n+        framework.addScenarios(scenarios);\n+        framework.start();\n+    }\n+\n+    @Run(test = {\"sumReductionImplement\",\n+                 \"sumReductionWithStoreImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public static void runTests() throws Exception {\n@@ -87,1 +67,1 @@\n-            total = sumReductionImplement(a, b, c, d, total);\n+            total = sumReductionImplement(a, b, c, total);\n@@ -89,6 +69,4 @@\n-        if (total == valid) {\n-            System.out.println(\"Success\");\n-        } else {\n-            System.out.println(\"Invalid sum of elements variable in total: \" + total);\n-            System.out.println(\"Expected value = \" + valid);\n-            throw new Exception(\"Failed\");\n+        testCorrectness(total, valid, \"sumReduction\");\n+        total = 0;\n+        for (int j = 0; j < 2000; j++) {\n+            total = sumReductionWithStoreImplement(a, b, c, d, total);\n@@ -96,0 +74,1 @@\n+        testCorrectness(total, valid, \"sumReductionWithStore\");\n@@ -111,0 +90,5 @@\n+    \/* Vectorization is expected but not enabled.\n+       A positive IR rule should be added later. *\/\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.ADD_REDUCTION_VD})\n@@ -112,0 +96,17 @@\n+            double[] a,\n+            double[] b,\n+            double[] c,\n+            double total) {\n+        for (int i = 0; i < a.length; i++) {\n+            total += (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n+        }\n+        return total;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.ADD_REDUCTION_VD})\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.ADD_REDUCTION_VD, \">= 1\"})\n+    public static double sumReductionWithStoreImplement(\n@@ -124,0 +125,11 @@\n+    public static void testCorrectness(\n+            double total,\n+            double valid,\n+            String op) throws Exception {\n+        if (total != valid) {\n+            throw new Exception(\n+                \"Invalid total: \" + total + \" \" +\n+                \"Expected value = \" + valid + \" \" + op + \": Failed\");\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Double.java","additions":65,"deletions":53,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,45 +28,2 @@\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.SumRed_Float\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.SumRed_Float\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.SumRed_Float\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.SumRed_Float\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.SumRed_Float\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.SumRed_Float\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.SumRed_Float\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.SumRed_Float\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.SumRed_Float\n@@ -77,0 +34,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -79,0 +38,20 @@\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\",\n+                           \"-XX:LoopUnrollLimit=250\",\n+                           \"-XX:CompileThresholdScaling=0.1\");\n+        int i = 0;\n+        Scenario[] scenarios = new Scenario[6];\n+        for (String reductionSign : new String[] {\"+\", \"-\"}) {\n+            for (int maxUnroll : new int[] {4, 8, 16}) {\n+                scenarios[i] = new Scenario(i, \"-XX:\" + reductionSign + \"SuperWordReductions\",\n+                                               \"-XX:LoopMaxUnroll=\" + maxUnroll);\n+                i++;\n+            }\n+        }\n+        framework.addScenarios(scenarios);\n+        framework.start();\n+    }\n+\n+    @Run(test = {\"sumReductionImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public static void runTests() throws Exception {\n@@ -82,1 +61,0 @@\n-        float[] d = new float[256 * 1024];\n@@ -87,1 +65,1 @@\n-            total = sumReductionImplement(a, b, c, d, total);\n+            total = sumReductionImplement(a, b, c, total);\n@@ -111,0 +89,6 @@\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.ADD_REDUCTION_VF})\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.ADD_REDUCTION_VF, \">= 1\"})\n@@ -115,1 +99,0 @@\n-            float[] d,\n@@ -118,2 +101,1 @@\n-            d[i] = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n-            total += d[i];\n+            total += (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Float.java","additions":33,"deletions":51,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,45 +28,2 @@\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.SumRed_Int\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=2\n- *      compiler.loopopts.superword.SumRed_Int\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.SumRed_Int\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.SumRed_Int\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.SumRed_Int\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.SumRed_Int\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.SumRed_Int\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=16\n- *      compiler.loopopts.superword.SumRed_Int\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.SumRed_Int\n@@ -77,0 +34,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -79,0 +38,20 @@\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\",\n+                           \"-XX:LoopUnrollLimit=250\",\n+                           \"-XX:CompileThresholdScaling=0.1\");\n+        int i = 0;\n+        Scenario[] scenarios = new Scenario[6];\n+        for (String reductionSign : new String[] {\"+\", \"-\"}) {\n+            for (int maxUnroll : new int[] {4, 8, 16}) {\n+                scenarios[i] = new Scenario(i, \"-XX:\" + reductionSign + \"SuperWordReductions\",\n+                                               \"-XX:LoopMaxUnroll=\" + maxUnroll);\n+                i++;\n+            }\n+        }\n+        framework.addScenarios(scenarios);\n+        framework.start();\n+    }\n+\n+    @Run(test = {\"sumReductionImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public static void runTests() throws Exception {\n@@ -82,1 +61,0 @@\n-        int[] d = new int[256 * 1024];\n@@ -87,1 +65,1 @@\n-            total = sumReductionImplement(a, b, c, d, total);\n+            total = sumReductionImplement(a, b, c, total);\n@@ -111,0 +89,6 @@\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.ADD_REDUCTION_VI})\n+    @IR(applyIfCPUFeature = {\"sse4.1\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.ADD_REDUCTION_VI, \">= 1\"})\n@@ -115,1 +99,0 @@\n-            int[] d,\n@@ -118,2 +101,1 @@\n-            d[i] = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n-            total += d[i];\n+            total += (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Int.java","additions":33,"deletions":51,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,23 +28,3 @@\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\"\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.SumRed_Long\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=4\n- *      compiler.loopopts.superword.SumRed_Long\n- *\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:+SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.SumRed_Long\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=250\n- *      -XX:CompileThresholdScaling=0.1\n- *      -XX:-SuperWordReductions\n- *      -XX:LoopMaxUnroll=8\n- *      compiler.loopopts.superword.SumRed_Long\n+ * @requires vm.bits == \"64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.SumRed_Long\n@@ -55,0 +35,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -57,0 +39,20 @@\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\",\n+                           \"-XX:LoopUnrollLimit=250\",\n+                           \"-XX:CompileThresholdScaling=0.1\");\n+        int i = 0;\n+        Scenario[] scenarios = new Scenario[4];\n+        for (String reductionSign : new String[] {\"+\", \"-\"}) {\n+            for (int maxUnroll : new int[] {4, 8}) {\n+                scenarios[i] = new Scenario(i, \"-XX:\" + reductionSign + \"SuperWordReductions\",\n+                                               \"-XX:LoopMaxUnroll=\" + maxUnroll);\n+                i++;\n+            }\n+        }\n+        framework.addScenarios(scenarios);\n+        framework.start();\n+    }\n+\n+    @Run(test = {\"sumReductionImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public static void runTests() throws Exception {\n@@ -60,1 +62,0 @@\n-        long[] d = new long[256 * 1024];\n@@ -65,1 +66,1 @@\n-            total = sumReductionImplement(a, b, c, d, total);\n+            total = sumReductionImplement(a, b, c, total);\n@@ -90,0 +91,8 @@\n+    \/* Require avx2 due to filtering out small vector lengths\n+       for long and int (SuperWord::implemented). *\/\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"false\"},\n+        failOn = {IRNode.ADD_REDUCTION_VL})\n+    @IR(applyIfCPUFeature = {\"avx2\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.ADD_REDUCTION_VL, \">= 1\"})\n@@ -94,1 +103,0 @@\n-            long[] d,\n@@ -97,2 +105,1 @@\n-            d[i] = (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n-            total += d[i];\n+            total += (a[i] * b[i]) + (a[i] * c[i]) + (b[i] * c[i]);\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Long.java","additions":36,"deletions":29,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,399 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298935\n+ * @summary Writing forward on array creates cyclic dependency\n+ *          which leads to wrong result, when ignored.\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib \/\n+ * @run driver TestCyclicDependency\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestCyclicDependency {\n+    static final int RANGE = 512;\n+    static final int ITER  = 100;\n+    int[] goldI0 = new int[RANGE];\n+    float[] goldF0 = new float[RANGE];\n+    int[] goldI1 = new int[RANGE];\n+    float[] goldF1 = new float[RANGE];\n+    int[] goldI2 = new int[RANGE];\n+    float[] goldF2 = new float[RANGE];\n+    int[] goldI3 = new int[RANGE];\n+    float[] goldF3 = new float[RANGE];\n+    int[] goldI4 = new int[RANGE];\n+    float[] goldF4 = new float[RANGE];\n+    int[] goldI5a = new int[RANGE];\n+    float[] goldF5a = new float[RANGE];\n+    int[] goldI5b = new int[RANGE];\n+    float[] goldF5b = new float[RANGE];\n+    int[] goldI6a = new int[RANGE];\n+    float[] goldF6a = new float[RANGE];\n+    int[] goldI6b = new int[RANGE];\n+    float[] goldF6b = new float[RANGE];\n+    int[] goldI7 = new int[RANGE];\n+    float[] goldF7 = new float[RANGE];\n+    int[] goldI8 = new int[RANGE];\n+    float[] goldF8 = new float[RANGE];\n+    int[] goldI9 = new int[RANGE];\n+    float[] goldF9 = new float[RANGE];\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"-XX:CompileCommand=compileonly,TestCyclicDependency::test*\");\n+    }\n+\n+    TestCyclicDependency() {\n+        \/\/ compute the gold standard in interpreter mode\n+        \/\/ test0\n+        init(goldI0, goldF0);\n+        test0(goldI0, goldF0);\n+        \/\/ test1\n+        init(goldI1, goldF1);\n+        test1(goldI1, goldF1);\n+        \/\/ test2\n+        init(goldI2, goldF2);\n+        test2(goldI2, goldF2);\n+        \/\/ test3\n+        init(goldI3, goldF3);\n+        test3(goldI3, goldF3);\n+        \/\/ test4\n+        init(goldI4, goldF4);\n+        test4(goldI4, goldF4);\n+        \/\/ test5a\n+        init(goldI5a, goldF5a);\n+        test5a(goldI5a, goldF5a);\n+        \/\/ test5b\n+        init(goldI5b, goldF5b);\n+        test5b(goldI5b, goldF5b);\n+        \/\/ test6a\n+        init(goldI6a, goldF6a);\n+        test6a(goldI6a, goldF6a);\n+        \/\/ test6b\n+        init(goldI6b, goldF6b);\n+        test6b(goldI6b, goldF6b);\n+        \/\/ test7\n+        init(goldI7, goldF7);\n+        test7(goldI7, goldF7);\n+        \/\/ test8\n+        init(goldI8, goldF8);\n+        test8(goldI8, goldF8);\n+        \/\/ test9\n+        init(goldI9, goldF9);\n+        test9(goldI9, goldF9);\n+    }\n+\n+    @Run(test = \"test0\")\n+    @Warmup(100)\n+    public void runTest0() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test0(dataI, dataF);\n+        verifyI(\"test0\", dataI, goldI0);\n+        verifyF(\"test0\", dataF, goldF0);\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(100)\n+    public void runTest1() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test1(dataI, dataF);\n+        verifyI(\"test1\", dataI, goldI1);\n+        verifyF(\"test1\", dataF, goldF1);\n+    }\n+\n+    @Run(test = \"test2\")\n+    @Warmup(100)\n+    public void runTest2() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test2(dataI, dataF);\n+        verifyI(\"test2\", dataI, goldI2);\n+        verifyF(\"test2\", dataF, goldF2);\n+    }\n+\n+    @Run(test = \"test3\")\n+    @Warmup(100)\n+    public void runTest3() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test3(dataI, dataF);\n+        verifyI(\"test3\", dataI, goldI3);\n+        verifyF(\"test3\", dataF, goldF3);\n+    }\n+\n+    @Run(test = \"test4\")\n+    @Warmup(100)\n+    public void runTest4() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test4(dataI, dataF);\n+        verifyI(\"test4\", dataI, goldI4);\n+        verifyF(\"test4\", dataF, goldF4);\n+    }\n+\n+    @Run(test = \"test5a\")\n+    @Warmup(100)\n+    public void runTest5a() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test5a(dataI, dataF);\n+        verifyI(\"test5a\", dataI, goldI5a);\n+        verifyF(\"test5a\", dataF, goldF5a);\n+    }\n+\n+    @Run(test = \"test5b\")\n+    @Warmup(100)\n+    public void runTest5b() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test5b(dataI, dataF);\n+        verifyI(\"test5b\", dataI, goldI5b);\n+        verifyF(\"test5b\", dataF, goldF5b);\n+    }\n+\n+    @Run(test = \"test6a\")\n+    @Warmup(100)\n+    public void runTest6a() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test6a(dataI, dataF);\n+        verifyI(\"test6a\", dataI, goldI6a);\n+        verifyF(\"test6a\", dataF, goldF6a);\n+    }\n+\n+    @Run(test = \"test6b\")\n+    @Warmup(100)\n+    public void runTest6b() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test6b(dataI, dataF);\n+        verifyI(\"test6b\", dataI, goldI6b);\n+        verifyF(\"test6b\", dataF, goldF6b);\n+    }\n+\n+    @Run(test = \"test7\")\n+    @Warmup(100)\n+    public void runTest7() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test7(dataI, dataF);\n+        verifyI(\"test7\", dataI, goldI7);\n+        verifyF(\"test7\", dataF, goldF7);\n+    }\n+\n+    @Run(test = \"test8\")\n+    @Warmup(100)\n+    public void runTest8() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test8(dataI, dataF);\n+        verifyI(\"test8\", dataI, goldI8);\n+        verifyF(\"test8\", dataF, goldF8);\n+    }\n+\n+    @Run(test = \"test9\")\n+    @Warmup(100)\n+    public void runTest9() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test9(dataI, dataF);\n+        verifyI(\"test9\", dataI, goldI9);\n+        verifyF(\"test9\", dataF, goldF9);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test0(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ All perfectly aligned, expect vectorization\n+            int v = dataI[i];\n+            dataI[i] = v + 5;\n+        }\n+    }\n+\n+    @Test\n+    static void test1(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE - 1; i++) {\n+            \/\/ dataI has cyclic dependency of distance 1\n+            int v = dataI[i];\n+            dataI[i + 1] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    static void test2(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE - 2; i++) {\n+            \/\/ dataI has cyclic dependency of distance 2\n+            int v = dataI[i];\n+            dataI[i + 2] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    static void test3(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE - 3; i++) {\n+            \/\/ dataI has cyclic dependency of distance 3\n+            int v = dataI[i];\n+            dataI[i + 3] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    static void test4(int[] dataI, float[] dataF) {\n+        for (int i = 1; i < RANGE - 1; i++) {\n+            \/\/ dataI has cyclic dependency of distance 2\n+            int v = dataI[i - 1];\n+            dataI[i + 1] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    static void test5a(int[] dataI, float[] dataF) {\n+        for (int i = 2; i < RANGE; i++) {\n+            \/\/ dataI has read \/ write distance 1, but no cyclic dependency\n+            int v = dataI[i];\n+            dataI[i - 1] = v + 5;\n+        }\n+    }\n+\n+    @Test\n+    static void test5b(int[] dataI, float[] dataF) {\n+        for (int i = 1; i < RANGE; i++) {\n+            \/\/ dataI has read \/ write distance 1, but no cyclic dependency\n+            int v = dataI[i];\n+            dataI[i - 1] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    static void test6a(int[] dataI, float[] dataF) {\n+        for (int i = 2; i < RANGE; i++) {\n+            \/\/ dataI has read \/ write distance 2, but no cyclic dependency\n+            int v = dataI[i];\n+            dataI[i - 2] = v + 5;\n+        }\n+    }\n+\n+    @Test\n+    static void test6b(int[] dataI, float[] dataF) {\n+        for (int i = 2; i < RANGE; i++) {\n+            \/\/ dataI has read \/ write distance 2, but no cyclic dependency\n+            int v = dataI[i];\n+            dataI[i - 2] = v;\n+            dataF[i] = v; \/\/ let's not get confused by another type\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Some aarch64 machines have AlignVector == true, like ThunderX2\n+    static void test7(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE - 32; i++) {\n+            \/\/ write forward 32 -> more than vector size -> can vectorize\n+            \/\/ write forward 3 -> cannot vectorize\n+            \/\/ separate types should make decision separately if they vectorize or not\n+            int v = dataI[i];\n+            dataI[i + 32] = v + 5;\n+            float f = dataF[i];\n+            dataF[i + 3] = f + 3.5f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VF, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Some aarch64 machines have AlignVector == true, like ThunderX2\n+    static void test8(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE - 32; i++) {\n+            \/\/ write forward 32 -> more than vector size -> can vectorize\n+            \/\/ write forward 3 -> cannot vectorize\n+            \/\/ separate types should make decision separately if they vectorize or not\n+            int v = dataI[i];\n+            dataI[i + 3] = v + 5;\n+            float f = dataF[i];\n+            dataF[i + 32] = f + 3.5f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_REDUCTION_VI, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test9(int[] dataI, float[] dataF) {\n+        int sI = 666;\n+        for (int i = 0; i < RANGE; i++) {\n+            \/\/ self-cycle allowed for reduction\n+            sI += dataI[i] * 2; \/\/ factor necessary to make it profitable\n+        }\n+        dataI[0] = sI; \/\/ write back\n+    }\n+\n+    public static void init(int[] dataI, float[] dataF) {\n+        for (int j = 0; j < RANGE; j++) {\n+            dataI[j] = j;\n+            dataF[j] = j * 0.5f;\n+        }\n+    }\n+\n+    static void verifyI(String name, int[] data, int[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: dataI[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verifyF(String name, float[] data, float[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: dataF[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCyclicDependency.java","additions":399,"deletions":0,"binary":false,"changes":399,"status":"added"},{"patch":"@@ -0,0 +1,11389 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * Summary:\n+ *   Test SuperWord vectorization with different access offsets\n+ *   and various MaxVectorSize values, and +- AlignVector.\n+ *   Note: CompileCommand Option Vectorize is enabled.\n+ *\n+ * Note: this test is auto-generated. Please modify \/ generate with script:\n+ *       https:\/\/bugs.openjdk.org\/browse\/JDK-8298935\n+ *\n+ * Types: int, long, short, char, byte, float, double\n+ * Offsets: 0, -1, 1, -2, 2, -3, 3, -4, 4, -7, 7, -8, 8, -14, 14, -16, 16, -18, 18, -20, 20, -31, 31, -32, 32, -63, 63, -64, 64, -65, 65, -128, 128, -129, 129, -192, 192\n+ *\n+ * Checking if we should vectorize is a bit complicated. It depends on\n+ * Matcher::vector_width_in_bytes, of the respective platforms (eg. x86.ad)\n+ * This vector_width can be further constrained by MaxVectorSize.\n+ *\n+ * With '-XX:-AlignVector', we vectorize if:\n+ *  - Vectors have at least 4 bytes:    vector_width >= 4\n+ *  - Vectors hold at least 2 elements: vector_width >= 2 * sizeofop(velt_type)\n+ *    -> min_vector_width = max(4, 2 * sizeofop(velt_type))\n+ *    -> simplifies to: vector_width >= min_vector_width\n+ *  - No cyclic dependency:\n+ *    - Access: data[i + offset] = data[i] * fac;\n+ *    - byte_offset = offset * sizeofop(type)\n+ *    - Cyclic dependency if: 0 < byte_offset < vector_width\n+ *\n+ * Note: sizeofop(type) = sizeof(type), except sizeofop(char) = 2\n+ *\n+ * Different types can lead to different vector_width. This depends on\n+ * the CPU-features. Thus, we have a positive and negative IR rule per\n+ * CPU-feature for each test.\n+ *\n+ * Definition:\n+ *     MaxVectorSize: limit through flag\n+ *     vector_width: limit given by specific CPU feature for a specific velt_type\n+ *     actual_vector_width: what is actually vectorized with\n+ *     min_vector_width: what is minimally required for vectorization\n+ *\n+ *     min_vector_width = max(4, 2 * sizeofop(velt_type))\n+ *     MaxVectorSize >= vector_width >= actual_vector_width >= min_vector_width\n+ *\n+ * In general, we cannot easily specify negative IR rules, that require no\n+ * vectorization to happen. We may improve the SuperWord algorithm later,\n+ * or some additional optimization collapses some Loads, and suddenly cyclic\n+ * dependency disappears, and we can vectorize.\n+ *\n+ * With '-XX:+AlignVector', we would like to check that we vectorize exactly iff:\n+ *     byte_offset % actual_vector_width == 0\n+ * Because all vector_widths are powers of 2, this is equivalent to:\n+ *     pow2_factor(byte_offset) >= actual_vector_width\n+ * where pow2_factor computes the largest power of 2 that is a factor of the number.\n+ *\n+ * Under these assumptions, we know there must be vectorization:\n+ *     pow2_factor(byte_offset) >= vector_width\n+ *       implies\n+ *         pow2_factor(byte_offset) >= actual_vector_width\n+ *     MaxVectorSize >= min_vector_size\n+ *       else any vectorization is impossible.\n+ *\n+ * And under the following conditions no vectorization is possible:\n+ *     byte_offset < 0: No cyclic dependency.\n+ *       Cyclic dependency could lead to Load removals, then only the store is vectorized.\n+ *     byte_offset % min_vector_width != 0\n+ *       implies\n+ *         byte_offset % actual_vector_width != 0\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=vanilla-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets vanilla-A\n+ *\/\n+\n+\/*\n+ * @test id=vanilla-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets vanilla-U\n+ *\/\n+\n+\/*\n+ * @test id=sse4-v016-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*sse4.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v016-A\n+ *\/\n+\n+\/*\n+ * @test id=sse4-v016-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*sse4.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v016-U\n+ *\/\n+\n+\/*\n+ * @test id=sse4-v008-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*sse4.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v008-A\n+ *\/\n+\n+\/*\n+ * @test id=sse4-v008-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*sse4.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v008-U\n+ *\/\n+\n+\/*\n+ * @test id=sse4-v004-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*sse4.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v004-A\n+ *\/\n+\n+\/*\n+ * @test id=sse4-v004-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*sse4.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v004-U\n+ *\/\n+\n+\/*\n+ * @test id=sse4-v002-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*sse4.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v002-A\n+ *\/\n+\n+\/*\n+ * @test id=sse4-v002-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*sse4.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v002-U\n+ *\/\n+\n+\/*\n+ * @test id=avx1-v032-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*avx.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets avx1-v032-A\n+ *\/\n+\n+\/*\n+ * @test id=avx1-v032-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*avx.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets avx1-v032-U\n+ *\/\n+\n+\/*\n+ * @test id=avx1-v016-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*avx.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets avx1-v016-A\n+ *\/\n+\n+\/*\n+ * @test id=avx1-v016-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*avx.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets avx1-v016-U\n+ *\/\n+\n+\/*\n+ * @test id=avx2-v032-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*avx2.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets avx2-v032-A\n+ *\/\n+\n+\/*\n+ * @test id=avx2-v032-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*avx2.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets avx2-v032-U\n+ *\/\n+\n+\/*\n+ * @test id=avx2-v016-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*avx2.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets avx2-v016-A\n+ *\/\n+\n+\/*\n+ * @test id=avx2-v016-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*avx2.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets avx2-v016-U\n+ *\/\n+\n+\/*\n+ * @test id=avx512-v064-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*avx512.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512-v064-A\n+ *\/\n+\n+\/*\n+ * @test id=avx512-v064-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*avx512.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512-v064-U\n+ *\/\n+\n+\/*\n+ * @test id=avx512-v032-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*avx512.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512-v032-A\n+ *\/\n+\n+\/*\n+ * @test id=avx512-v032-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*avx512.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512-v032-U\n+ *\/\n+\n+\/*\n+ * @test id=avx512bw-v064-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*avx512bw.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512bw-v064-A\n+ *\/\n+\n+\/*\n+ * @test id=avx512bw-v064-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*avx512bw.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512bw-v064-U\n+ *\/\n+\n+\/*\n+ * @test id=avx512bw-v032-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*avx512bw.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512bw-v032-A\n+ *\/\n+\n+\/*\n+ * @test id=avx512bw-v032-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cpu.features ~= \".*avx512bw.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512bw-v032-U\n+ *\/\n+\n+\/*\n+ * @test id=vec-v064-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch!=\"x86\" & os.arch!=\"i386\" & os.arch!=\"amd64\" & os.arch!=\"x86_64\")\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v064-A\n+ *\/\n+\n+\/*\n+ * @test id=vec-v064-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch!=\"x86\" & os.arch!=\"i386\" & os.arch!=\"amd64\" & os.arch!=\"x86_64\")\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v064-U\n+ *\/\n+\n+\/*\n+ * @test id=vec-v032-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch!=\"x86\" & os.arch!=\"i386\" & os.arch!=\"amd64\" & os.arch!=\"x86_64\")\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v032-A\n+ *\/\n+\n+\/*\n+ * @test id=vec-v032-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch!=\"x86\" & os.arch!=\"i386\" & os.arch!=\"amd64\" & os.arch!=\"x86_64\")\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v032-U\n+ *\/\n+\n+\/*\n+ * @test id=vec-v016-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch!=\"x86\" & os.arch!=\"i386\" & os.arch!=\"amd64\" & os.arch!=\"x86_64\")\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v016-A\n+ *\/\n+\n+\/*\n+ * @test id=vec-v016-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch!=\"x86\" & os.arch!=\"i386\" & os.arch!=\"amd64\" & os.arch!=\"x86_64\")\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v016-U\n+ *\/\n+\n+\/*\n+ * @test id=vec-v008-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch!=\"x86\" & os.arch!=\"i386\" & os.arch!=\"amd64\" & os.arch!=\"x86_64\")\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v008-A\n+ *\/\n+\n+\/*\n+ * @test id=vec-v008-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch!=\"x86\" & os.arch!=\"i386\" & os.arch!=\"amd64\" & os.arch!=\"x86_64\")\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v008-U\n+ *\/\n+\n+\/*\n+ * @test id=vec-v004-A\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch!=\"x86\" & os.arch!=\"i386\" & os.arch!=\"amd64\" & os.arch!=\"x86_64\")\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v004-A\n+ *\/\n+\n+\/*\n+ * @test id=vec-v004-U\n+ * @bug 8298935\n+ * @summary Test SuperWord: vector size, offsets, dependencies, alignment.\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.arch!=\"x86\" & os.arch!=\"i386\" & os.arch!=\"amd64\" & os.arch!=\"x86_64\")\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v004-U\n+ *\/\n+\n+package compiler.loopopts.superword;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestDependencyOffsets {\n+    static final int RANGE = 512;\n+\n+    static int[] goldIntP0 = new int[RANGE];\n+    static int[] goldIntM1 = new int[RANGE];\n+    static int[] goldIntP1 = new int[RANGE];\n+    static int[] goldIntM2 = new int[RANGE];\n+    static int[] goldIntP2 = new int[RANGE];\n+    static int[] goldIntM3 = new int[RANGE];\n+    static int[] goldIntP3 = new int[RANGE];\n+    static int[] goldIntM4 = new int[RANGE];\n+    static int[] goldIntP4 = new int[RANGE];\n+    static int[] goldIntM7 = new int[RANGE];\n+    static int[] goldIntP7 = new int[RANGE];\n+    static int[] goldIntM8 = new int[RANGE];\n+    static int[] goldIntP8 = new int[RANGE];\n+    static int[] goldIntM14 = new int[RANGE];\n+    static int[] goldIntP14 = new int[RANGE];\n+    static int[] goldIntM16 = new int[RANGE];\n+    static int[] goldIntP16 = new int[RANGE];\n+    static int[] goldIntM18 = new int[RANGE];\n+    static int[] goldIntP18 = new int[RANGE];\n+    static int[] goldIntM20 = new int[RANGE];\n+    static int[] goldIntP20 = new int[RANGE];\n+    static int[] goldIntM31 = new int[RANGE];\n+    static int[] goldIntP31 = new int[RANGE];\n+    static int[] goldIntM32 = new int[RANGE];\n+    static int[] goldIntP32 = new int[RANGE];\n+    static int[] goldIntM63 = new int[RANGE];\n+    static int[] goldIntP63 = new int[RANGE];\n+    static int[] goldIntM64 = new int[RANGE];\n+    static int[] goldIntP64 = new int[RANGE];\n+    static int[] goldIntM65 = new int[RANGE];\n+    static int[] goldIntP65 = new int[RANGE];\n+    static int[] goldIntM128 = new int[RANGE];\n+    static int[] goldIntP128 = new int[RANGE];\n+    static int[] goldIntM129 = new int[RANGE];\n+    static int[] goldIntP129 = new int[RANGE];\n+    static int[] goldIntM192 = new int[RANGE];\n+    static int[] goldIntP192 = new int[RANGE];\n+    static long[] goldLongP0 = new long[RANGE];\n+    static long[] goldLongM1 = new long[RANGE];\n+    static long[] goldLongP1 = new long[RANGE];\n+    static long[] goldLongM2 = new long[RANGE];\n+    static long[] goldLongP2 = new long[RANGE];\n+    static long[] goldLongM3 = new long[RANGE];\n+    static long[] goldLongP3 = new long[RANGE];\n+    static long[] goldLongM4 = new long[RANGE];\n+    static long[] goldLongP4 = new long[RANGE];\n+    static long[] goldLongM7 = new long[RANGE];\n+    static long[] goldLongP7 = new long[RANGE];\n+    static long[] goldLongM8 = new long[RANGE];\n+    static long[] goldLongP8 = new long[RANGE];\n+    static long[] goldLongM14 = new long[RANGE];\n+    static long[] goldLongP14 = new long[RANGE];\n+    static long[] goldLongM16 = new long[RANGE];\n+    static long[] goldLongP16 = new long[RANGE];\n+    static long[] goldLongM18 = new long[RANGE];\n+    static long[] goldLongP18 = new long[RANGE];\n+    static long[] goldLongM20 = new long[RANGE];\n+    static long[] goldLongP20 = new long[RANGE];\n+    static long[] goldLongM31 = new long[RANGE];\n+    static long[] goldLongP31 = new long[RANGE];\n+    static long[] goldLongM32 = new long[RANGE];\n+    static long[] goldLongP32 = new long[RANGE];\n+    static long[] goldLongM63 = new long[RANGE];\n+    static long[] goldLongP63 = new long[RANGE];\n+    static long[] goldLongM64 = new long[RANGE];\n+    static long[] goldLongP64 = new long[RANGE];\n+    static long[] goldLongM65 = new long[RANGE];\n+    static long[] goldLongP65 = new long[RANGE];\n+    static long[] goldLongM128 = new long[RANGE];\n+    static long[] goldLongP128 = new long[RANGE];\n+    static long[] goldLongM129 = new long[RANGE];\n+    static long[] goldLongP129 = new long[RANGE];\n+    static long[] goldLongM192 = new long[RANGE];\n+    static long[] goldLongP192 = new long[RANGE];\n+    static short[] goldShortP0 = new short[RANGE];\n+    static short[] goldShortM1 = new short[RANGE];\n+    static short[] goldShortP1 = new short[RANGE];\n+    static short[] goldShortM2 = new short[RANGE];\n+    static short[] goldShortP2 = new short[RANGE];\n+    static short[] goldShortM3 = new short[RANGE];\n+    static short[] goldShortP3 = new short[RANGE];\n+    static short[] goldShortM4 = new short[RANGE];\n+    static short[] goldShortP4 = new short[RANGE];\n+    static short[] goldShortM7 = new short[RANGE];\n+    static short[] goldShortP7 = new short[RANGE];\n+    static short[] goldShortM8 = new short[RANGE];\n+    static short[] goldShortP8 = new short[RANGE];\n+    static short[] goldShortM14 = new short[RANGE];\n+    static short[] goldShortP14 = new short[RANGE];\n+    static short[] goldShortM16 = new short[RANGE];\n+    static short[] goldShortP16 = new short[RANGE];\n+    static short[] goldShortM18 = new short[RANGE];\n+    static short[] goldShortP18 = new short[RANGE];\n+    static short[] goldShortM20 = new short[RANGE];\n+    static short[] goldShortP20 = new short[RANGE];\n+    static short[] goldShortM31 = new short[RANGE];\n+    static short[] goldShortP31 = new short[RANGE];\n+    static short[] goldShortM32 = new short[RANGE];\n+    static short[] goldShortP32 = new short[RANGE];\n+    static short[] goldShortM63 = new short[RANGE];\n+    static short[] goldShortP63 = new short[RANGE];\n+    static short[] goldShortM64 = new short[RANGE];\n+    static short[] goldShortP64 = new short[RANGE];\n+    static short[] goldShortM65 = new short[RANGE];\n+    static short[] goldShortP65 = new short[RANGE];\n+    static short[] goldShortM128 = new short[RANGE];\n+    static short[] goldShortP128 = new short[RANGE];\n+    static short[] goldShortM129 = new short[RANGE];\n+    static short[] goldShortP129 = new short[RANGE];\n+    static short[] goldShortM192 = new short[RANGE];\n+    static short[] goldShortP192 = new short[RANGE];\n+    static char[] goldCharP0 = new char[RANGE];\n+    static char[] goldCharM1 = new char[RANGE];\n+    static char[] goldCharP1 = new char[RANGE];\n+    static char[] goldCharM2 = new char[RANGE];\n+    static char[] goldCharP2 = new char[RANGE];\n+    static char[] goldCharM3 = new char[RANGE];\n+    static char[] goldCharP3 = new char[RANGE];\n+    static char[] goldCharM4 = new char[RANGE];\n+    static char[] goldCharP4 = new char[RANGE];\n+    static char[] goldCharM7 = new char[RANGE];\n+    static char[] goldCharP7 = new char[RANGE];\n+    static char[] goldCharM8 = new char[RANGE];\n+    static char[] goldCharP8 = new char[RANGE];\n+    static char[] goldCharM14 = new char[RANGE];\n+    static char[] goldCharP14 = new char[RANGE];\n+    static char[] goldCharM16 = new char[RANGE];\n+    static char[] goldCharP16 = new char[RANGE];\n+    static char[] goldCharM18 = new char[RANGE];\n+    static char[] goldCharP18 = new char[RANGE];\n+    static char[] goldCharM20 = new char[RANGE];\n+    static char[] goldCharP20 = new char[RANGE];\n+    static char[] goldCharM31 = new char[RANGE];\n+    static char[] goldCharP31 = new char[RANGE];\n+    static char[] goldCharM32 = new char[RANGE];\n+    static char[] goldCharP32 = new char[RANGE];\n+    static char[] goldCharM63 = new char[RANGE];\n+    static char[] goldCharP63 = new char[RANGE];\n+    static char[] goldCharM64 = new char[RANGE];\n+    static char[] goldCharP64 = new char[RANGE];\n+    static char[] goldCharM65 = new char[RANGE];\n+    static char[] goldCharP65 = new char[RANGE];\n+    static char[] goldCharM128 = new char[RANGE];\n+    static char[] goldCharP128 = new char[RANGE];\n+    static char[] goldCharM129 = new char[RANGE];\n+    static char[] goldCharP129 = new char[RANGE];\n+    static char[] goldCharM192 = new char[RANGE];\n+    static char[] goldCharP192 = new char[RANGE];\n+    static byte[] goldByteP0 = new byte[RANGE];\n+    static byte[] goldByteM1 = new byte[RANGE];\n+    static byte[] goldByteP1 = new byte[RANGE];\n+    static byte[] goldByteM2 = new byte[RANGE];\n+    static byte[] goldByteP2 = new byte[RANGE];\n+    static byte[] goldByteM3 = new byte[RANGE];\n+    static byte[] goldByteP3 = new byte[RANGE];\n+    static byte[] goldByteM4 = new byte[RANGE];\n+    static byte[] goldByteP4 = new byte[RANGE];\n+    static byte[] goldByteM7 = new byte[RANGE];\n+    static byte[] goldByteP7 = new byte[RANGE];\n+    static byte[] goldByteM8 = new byte[RANGE];\n+    static byte[] goldByteP8 = new byte[RANGE];\n+    static byte[] goldByteM14 = new byte[RANGE];\n+    static byte[] goldByteP14 = new byte[RANGE];\n+    static byte[] goldByteM16 = new byte[RANGE];\n+    static byte[] goldByteP16 = new byte[RANGE];\n+    static byte[] goldByteM18 = new byte[RANGE];\n+    static byte[] goldByteP18 = new byte[RANGE];\n+    static byte[] goldByteM20 = new byte[RANGE];\n+    static byte[] goldByteP20 = new byte[RANGE];\n+    static byte[] goldByteM31 = new byte[RANGE];\n+    static byte[] goldByteP31 = new byte[RANGE];\n+    static byte[] goldByteM32 = new byte[RANGE];\n+    static byte[] goldByteP32 = new byte[RANGE];\n+    static byte[] goldByteM63 = new byte[RANGE];\n+    static byte[] goldByteP63 = new byte[RANGE];\n+    static byte[] goldByteM64 = new byte[RANGE];\n+    static byte[] goldByteP64 = new byte[RANGE];\n+    static byte[] goldByteM65 = new byte[RANGE];\n+    static byte[] goldByteP65 = new byte[RANGE];\n+    static byte[] goldByteM128 = new byte[RANGE];\n+    static byte[] goldByteP128 = new byte[RANGE];\n+    static byte[] goldByteM129 = new byte[RANGE];\n+    static byte[] goldByteP129 = new byte[RANGE];\n+    static byte[] goldByteM192 = new byte[RANGE];\n+    static byte[] goldByteP192 = new byte[RANGE];\n+    static float[] goldFloatP0 = new float[RANGE];\n+    static float[] goldFloatM1 = new float[RANGE];\n+    static float[] goldFloatP1 = new float[RANGE];\n+    static float[] goldFloatM2 = new float[RANGE];\n+    static float[] goldFloatP2 = new float[RANGE];\n+    static float[] goldFloatM3 = new float[RANGE];\n+    static float[] goldFloatP3 = new float[RANGE];\n+    static float[] goldFloatM4 = new float[RANGE];\n+    static float[] goldFloatP4 = new float[RANGE];\n+    static float[] goldFloatM7 = new float[RANGE];\n+    static float[] goldFloatP7 = new float[RANGE];\n+    static float[] goldFloatM8 = new float[RANGE];\n+    static float[] goldFloatP8 = new float[RANGE];\n+    static float[] goldFloatM14 = new float[RANGE];\n+    static float[] goldFloatP14 = new float[RANGE];\n+    static float[] goldFloatM16 = new float[RANGE];\n+    static float[] goldFloatP16 = new float[RANGE];\n+    static float[] goldFloatM18 = new float[RANGE];\n+    static float[] goldFloatP18 = new float[RANGE];\n+    static float[] goldFloatM20 = new float[RANGE];\n+    static float[] goldFloatP20 = new float[RANGE];\n+    static float[] goldFloatM31 = new float[RANGE];\n+    static float[] goldFloatP31 = new float[RANGE];\n+    static float[] goldFloatM32 = new float[RANGE];\n+    static float[] goldFloatP32 = new float[RANGE];\n+    static float[] goldFloatM63 = new float[RANGE];\n+    static float[] goldFloatP63 = new float[RANGE];\n+    static float[] goldFloatM64 = new float[RANGE];\n+    static float[] goldFloatP64 = new float[RANGE];\n+    static float[] goldFloatM65 = new float[RANGE];\n+    static float[] goldFloatP65 = new float[RANGE];\n+    static float[] goldFloatM128 = new float[RANGE];\n+    static float[] goldFloatP128 = new float[RANGE];\n+    static float[] goldFloatM129 = new float[RANGE];\n+    static float[] goldFloatP129 = new float[RANGE];\n+    static float[] goldFloatM192 = new float[RANGE];\n+    static float[] goldFloatP192 = new float[RANGE];\n+    static double[] goldDoubleP0 = new double[RANGE];\n+    static double[] goldDoubleM1 = new double[RANGE];\n+    static double[] goldDoubleP1 = new double[RANGE];\n+    static double[] goldDoubleM2 = new double[RANGE];\n+    static double[] goldDoubleP2 = new double[RANGE];\n+    static double[] goldDoubleM3 = new double[RANGE];\n+    static double[] goldDoubleP3 = new double[RANGE];\n+    static double[] goldDoubleM4 = new double[RANGE];\n+    static double[] goldDoubleP4 = new double[RANGE];\n+    static double[] goldDoubleM7 = new double[RANGE];\n+    static double[] goldDoubleP7 = new double[RANGE];\n+    static double[] goldDoubleM8 = new double[RANGE];\n+    static double[] goldDoubleP8 = new double[RANGE];\n+    static double[] goldDoubleM14 = new double[RANGE];\n+    static double[] goldDoubleP14 = new double[RANGE];\n+    static double[] goldDoubleM16 = new double[RANGE];\n+    static double[] goldDoubleP16 = new double[RANGE];\n+    static double[] goldDoubleM18 = new double[RANGE];\n+    static double[] goldDoubleP18 = new double[RANGE];\n+    static double[] goldDoubleM20 = new double[RANGE];\n+    static double[] goldDoubleP20 = new double[RANGE];\n+    static double[] goldDoubleM31 = new double[RANGE];\n+    static double[] goldDoubleP31 = new double[RANGE];\n+    static double[] goldDoubleM32 = new double[RANGE];\n+    static double[] goldDoubleP32 = new double[RANGE];\n+    static double[] goldDoubleM63 = new double[RANGE];\n+    static double[] goldDoubleP63 = new double[RANGE];\n+    static double[] goldDoubleM64 = new double[RANGE];\n+    static double[] goldDoubleP64 = new double[RANGE];\n+    static double[] goldDoubleM65 = new double[RANGE];\n+    static double[] goldDoubleP65 = new double[RANGE];\n+    static double[] goldDoubleM128 = new double[RANGE];\n+    static double[] goldDoubleP128 = new double[RANGE];\n+    static double[] goldDoubleM129 = new double[RANGE];\n+    static double[] goldDoubleP129 = new double[RANGE];\n+    static double[] goldDoubleM192 = new double[RANGE];\n+    static double[] goldDoubleP192 = new double[RANGE];\n+\n+    static {\n+        \/\/ compute the gold standard in interpreter mode\n+        init(goldIntP0);\n+        testIntP0(goldIntP0);\n+        init(goldIntM1);\n+        testIntM1(goldIntM1);\n+        init(goldIntP1);\n+        testIntP1(goldIntP1);\n+        init(goldIntM2);\n+        testIntM2(goldIntM2);\n+        init(goldIntP2);\n+        testIntP2(goldIntP2);\n+        init(goldIntM3);\n+        testIntM3(goldIntM3);\n+        init(goldIntP3);\n+        testIntP3(goldIntP3);\n+        init(goldIntM4);\n+        testIntM4(goldIntM4);\n+        init(goldIntP4);\n+        testIntP4(goldIntP4);\n+        init(goldIntM7);\n+        testIntM7(goldIntM7);\n+        init(goldIntP7);\n+        testIntP7(goldIntP7);\n+        init(goldIntM8);\n+        testIntM8(goldIntM8);\n+        init(goldIntP8);\n+        testIntP8(goldIntP8);\n+        init(goldIntM14);\n+        testIntM14(goldIntM14);\n+        init(goldIntP14);\n+        testIntP14(goldIntP14);\n+        init(goldIntM16);\n+        testIntM16(goldIntM16);\n+        init(goldIntP16);\n+        testIntP16(goldIntP16);\n+        init(goldIntM18);\n+        testIntM18(goldIntM18);\n+        init(goldIntP18);\n+        testIntP18(goldIntP18);\n+        init(goldIntM20);\n+        testIntM20(goldIntM20);\n+        init(goldIntP20);\n+        testIntP20(goldIntP20);\n+        init(goldIntM31);\n+        testIntM31(goldIntM31);\n+        init(goldIntP31);\n+        testIntP31(goldIntP31);\n+        init(goldIntM32);\n+        testIntM32(goldIntM32);\n+        init(goldIntP32);\n+        testIntP32(goldIntP32);\n+        init(goldIntM63);\n+        testIntM63(goldIntM63);\n+        init(goldIntP63);\n+        testIntP63(goldIntP63);\n+        init(goldIntM64);\n+        testIntM64(goldIntM64);\n+        init(goldIntP64);\n+        testIntP64(goldIntP64);\n+        init(goldIntM65);\n+        testIntM65(goldIntM65);\n+        init(goldIntP65);\n+        testIntP65(goldIntP65);\n+        init(goldIntM128);\n+        testIntM128(goldIntM128);\n+        init(goldIntP128);\n+        testIntP128(goldIntP128);\n+        init(goldIntM129);\n+        testIntM129(goldIntM129);\n+        init(goldIntP129);\n+        testIntP129(goldIntP129);\n+        init(goldIntM192);\n+        testIntM192(goldIntM192);\n+        init(goldIntP192);\n+        testIntP192(goldIntP192);\n+        init(goldLongP0);\n+        testLongP0(goldLongP0);\n+        init(goldLongM1);\n+        testLongM1(goldLongM1);\n+        init(goldLongP1);\n+        testLongP1(goldLongP1);\n+        init(goldLongM2);\n+        testLongM2(goldLongM2);\n+        init(goldLongP2);\n+        testLongP2(goldLongP2);\n+        init(goldLongM3);\n+        testLongM3(goldLongM3);\n+        init(goldLongP3);\n+        testLongP3(goldLongP3);\n+        init(goldLongM4);\n+        testLongM4(goldLongM4);\n+        init(goldLongP4);\n+        testLongP4(goldLongP4);\n+        init(goldLongM7);\n+        testLongM7(goldLongM7);\n+        init(goldLongP7);\n+        testLongP7(goldLongP7);\n+        init(goldLongM8);\n+        testLongM8(goldLongM8);\n+        init(goldLongP8);\n+        testLongP8(goldLongP8);\n+        init(goldLongM14);\n+        testLongM14(goldLongM14);\n+        init(goldLongP14);\n+        testLongP14(goldLongP14);\n+        init(goldLongM16);\n+        testLongM16(goldLongM16);\n+        init(goldLongP16);\n+        testLongP16(goldLongP16);\n+        init(goldLongM18);\n+        testLongM18(goldLongM18);\n+        init(goldLongP18);\n+        testLongP18(goldLongP18);\n+        init(goldLongM20);\n+        testLongM20(goldLongM20);\n+        init(goldLongP20);\n+        testLongP20(goldLongP20);\n+        init(goldLongM31);\n+        testLongM31(goldLongM31);\n+        init(goldLongP31);\n+        testLongP31(goldLongP31);\n+        init(goldLongM32);\n+        testLongM32(goldLongM32);\n+        init(goldLongP32);\n+        testLongP32(goldLongP32);\n+        init(goldLongM63);\n+        testLongM63(goldLongM63);\n+        init(goldLongP63);\n+        testLongP63(goldLongP63);\n+        init(goldLongM64);\n+        testLongM64(goldLongM64);\n+        init(goldLongP64);\n+        testLongP64(goldLongP64);\n+        init(goldLongM65);\n+        testLongM65(goldLongM65);\n+        init(goldLongP65);\n+        testLongP65(goldLongP65);\n+        init(goldLongM128);\n+        testLongM128(goldLongM128);\n+        init(goldLongP128);\n+        testLongP128(goldLongP128);\n+        init(goldLongM129);\n+        testLongM129(goldLongM129);\n+        init(goldLongP129);\n+        testLongP129(goldLongP129);\n+        init(goldLongM192);\n+        testLongM192(goldLongM192);\n+        init(goldLongP192);\n+        testLongP192(goldLongP192);\n+        init(goldShortP0);\n+        testShortP0(goldShortP0);\n+        init(goldShortM1);\n+        testShortM1(goldShortM1);\n+        init(goldShortP1);\n+        testShortP1(goldShortP1);\n+        init(goldShortM2);\n+        testShortM2(goldShortM2);\n+        init(goldShortP2);\n+        testShortP2(goldShortP2);\n+        init(goldShortM3);\n+        testShortM3(goldShortM3);\n+        init(goldShortP3);\n+        testShortP3(goldShortP3);\n+        init(goldShortM4);\n+        testShortM4(goldShortM4);\n+        init(goldShortP4);\n+        testShortP4(goldShortP4);\n+        init(goldShortM7);\n+        testShortM7(goldShortM7);\n+        init(goldShortP7);\n+        testShortP7(goldShortP7);\n+        init(goldShortM8);\n+        testShortM8(goldShortM8);\n+        init(goldShortP8);\n+        testShortP8(goldShortP8);\n+        init(goldShortM14);\n+        testShortM14(goldShortM14);\n+        init(goldShortP14);\n+        testShortP14(goldShortP14);\n+        init(goldShortM16);\n+        testShortM16(goldShortM16);\n+        init(goldShortP16);\n+        testShortP16(goldShortP16);\n+        init(goldShortM18);\n+        testShortM18(goldShortM18);\n+        init(goldShortP18);\n+        testShortP18(goldShortP18);\n+        init(goldShortM20);\n+        testShortM20(goldShortM20);\n+        init(goldShortP20);\n+        testShortP20(goldShortP20);\n+        init(goldShortM31);\n+        testShortM31(goldShortM31);\n+        init(goldShortP31);\n+        testShortP31(goldShortP31);\n+        init(goldShortM32);\n+        testShortM32(goldShortM32);\n+        init(goldShortP32);\n+        testShortP32(goldShortP32);\n+        init(goldShortM63);\n+        testShortM63(goldShortM63);\n+        init(goldShortP63);\n+        testShortP63(goldShortP63);\n+        init(goldShortM64);\n+        testShortM64(goldShortM64);\n+        init(goldShortP64);\n+        testShortP64(goldShortP64);\n+        init(goldShortM65);\n+        testShortM65(goldShortM65);\n+        init(goldShortP65);\n+        testShortP65(goldShortP65);\n+        init(goldShortM128);\n+        testShortM128(goldShortM128);\n+        init(goldShortP128);\n+        testShortP128(goldShortP128);\n+        init(goldShortM129);\n+        testShortM129(goldShortM129);\n+        init(goldShortP129);\n+        testShortP129(goldShortP129);\n+        init(goldShortM192);\n+        testShortM192(goldShortM192);\n+        init(goldShortP192);\n+        testShortP192(goldShortP192);\n+        init(goldCharP0);\n+        testCharP0(goldCharP0);\n+        init(goldCharM1);\n+        testCharM1(goldCharM1);\n+        init(goldCharP1);\n+        testCharP1(goldCharP1);\n+        init(goldCharM2);\n+        testCharM2(goldCharM2);\n+        init(goldCharP2);\n+        testCharP2(goldCharP2);\n+        init(goldCharM3);\n+        testCharM3(goldCharM3);\n+        init(goldCharP3);\n+        testCharP3(goldCharP3);\n+        init(goldCharM4);\n+        testCharM4(goldCharM4);\n+        init(goldCharP4);\n+        testCharP4(goldCharP4);\n+        init(goldCharM7);\n+        testCharM7(goldCharM7);\n+        init(goldCharP7);\n+        testCharP7(goldCharP7);\n+        init(goldCharM8);\n+        testCharM8(goldCharM8);\n+        init(goldCharP8);\n+        testCharP8(goldCharP8);\n+        init(goldCharM14);\n+        testCharM14(goldCharM14);\n+        init(goldCharP14);\n+        testCharP14(goldCharP14);\n+        init(goldCharM16);\n+        testCharM16(goldCharM16);\n+        init(goldCharP16);\n+        testCharP16(goldCharP16);\n+        init(goldCharM18);\n+        testCharM18(goldCharM18);\n+        init(goldCharP18);\n+        testCharP18(goldCharP18);\n+        init(goldCharM20);\n+        testCharM20(goldCharM20);\n+        init(goldCharP20);\n+        testCharP20(goldCharP20);\n+        init(goldCharM31);\n+        testCharM31(goldCharM31);\n+        init(goldCharP31);\n+        testCharP31(goldCharP31);\n+        init(goldCharM32);\n+        testCharM32(goldCharM32);\n+        init(goldCharP32);\n+        testCharP32(goldCharP32);\n+        init(goldCharM63);\n+        testCharM63(goldCharM63);\n+        init(goldCharP63);\n+        testCharP63(goldCharP63);\n+        init(goldCharM64);\n+        testCharM64(goldCharM64);\n+        init(goldCharP64);\n+        testCharP64(goldCharP64);\n+        init(goldCharM65);\n+        testCharM65(goldCharM65);\n+        init(goldCharP65);\n+        testCharP65(goldCharP65);\n+        init(goldCharM128);\n+        testCharM128(goldCharM128);\n+        init(goldCharP128);\n+        testCharP128(goldCharP128);\n+        init(goldCharM129);\n+        testCharM129(goldCharM129);\n+        init(goldCharP129);\n+        testCharP129(goldCharP129);\n+        init(goldCharM192);\n+        testCharM192(goldCharM192);\n+        init(goldCharP192);\n+        testCharP192(goldCharP192);\n+        init(goldByteP0);\n+        testByteP0(goldByteP0);\n+        init(goldByteM1);\n+        testByteM1(goldByteM1);\n+        init(goldByteP1);\n+        testByteP1(goldByteP1);\n+        init(goldByteM2);\n+        testByteM2(goldByteM2);\n+        init(goldByteP2);\n+        testByteP2(goldByteP2);\n+        init(goldByteM3);\n+        testByteM3(goldByteM3);\n+        init(goldByteP3);\n+        testByteP3(goldByteP3);\n+        init(goldByteM4);\n+        testByteM4(goldByteM4);\n+        init(goldByteP4);\n+        testByteP4(goldByteP4);\n+        init(goldByteM7);\n+        testByteM7(goldByteM7);\n+        init(goldByteP7);\n+        testByteP7(goldByteP7);\n+        init(goldByteM8);\n+        testByteM8(goldByteM8);\n+        init(goldByteP8);\n+        testByteP8(goldByteP8);\n+        init(goldByteM14);\n+        testByteM14(goldByteM14);\n+        init(goldByteP14);\n+        testByteP14(goldByteP14);\n+        init(goldByteM16);\n+        testByteM16(goldByteM16);\n+        init(goldByteP16);\n+        testByteP16(goldByteP16);\n+        init(goldByteM18);\n+        testByteM18(goldByteM18);\n+        init(goldByteP18);\n+        testByteP18(goldByteP18);\n+        init(goldByteM20);\n+        testByteM20(goldByteM20);\n+        init(goldByteP20);\n+        testByteP20(goldByteP20);\n+        init(goldByteM31);\n+        testByteM31(goldByteM31);\n+        init(goldByteP31);\n+        testByteP31(goldByteP31);\n+        init(goldByteM32);\n+        testByteM32(goldByteM32);\n+        init(goldByteP32);\n+        testByteP32(goldByteP32);\n+        init(goldByteM63);\n+        testByteM63(goldByteM63);\n+        init(goldByteP63);\n+        testByteP63(goldByteP63);\n+        init(goldByteM64);\n+        testByteM64(goldByteM64);\n+        init(goldByteP64);\n+        testByteP64(goldByteP64);\n+        init(goldByteM65);\n+        testByteM65(goldByteM65);\n+        init(goldByteP65);\n+        testByteP65(goldByteP65);\n+        init(goldByteM128);\n+        testByteM128(goldByteM128);\n+        init(goldByteP128);\n+        testByteP128(goldByteP128);\n+        init(goldByteM129);\n+        testByteM129(goldByteM129);\n+        init(goldByteP129);\n+        testByteP129(goldByteP129);\n+        init(goldByteM192);\n+        testByteM192(goldByteM192);\n+        init(goldByteP192);\n+        testByteP192(goldByteP192);\n+        init(goldFloatP0);\n+        testFloatP0(goldFloatP0);\n+        init(goldFloatM1);\n+        testFloatM1(goldFloatM1);\n+        init(goldFloatP1);\n+        testFloatP1(goldFloatP1);\n+        init(goldFloatM2);\n+        testFloatM2(goldFloatM2);\n+        init(goldFloatP2);\n+        testFloatP2(goldFloatP2);\n+        init(goldFloatM3);\n+        testFloatM3(goldFloatM3);\n+        init(goldFloatP3);\n+        testFloatP3(goldFloatP3);\n+        init(goldFloatM4);\n+        testFloatM4(goldFloatM4);\n+        init(goldFloatP4);\n+        testFloatP4(goldFloatP4);\n+        init(goldFloatM7);\n+        testFloatM7(goldFloatM7);\n+        init(goldFloatP7);\n+        testFloatP7(goldFloatP7);\n+        init(goldFloatM8);\n+        testFloatM8(goldFloatM8);\n+        init(goldFloatP8);\n+        testFloatP8(goldFloatP8);\n+        init(goldFloatM14);\n+        testFloatM14(goldFloatM14);\n+        init(goldFloatP14);\n+        testFloatP14(goldFloatP14);\n+        init(goldFloatM16);\n+        testFloatM16(goldFloatM16);\n+        init(goldFloatP16);\n+        testFloatP16(goldFloatP16);\n+        init(goldFloatM18);\n+        testFloatM18(goldFloatM18);\n+        init(goldFloatP18);\n+        testFloatP18(goldFloatP18);\n+        init(goldFloatM20);\n+        testFloatM20(goldFloatM20);\n+        init(goldFloatP20);\n+        testFloatP20(goldFloatP20);\n+        init(goldFloatM31);\n+        testFloatM31(goldFloatM31);\n+        init(goldFloatP31);\n+        testFloatP31(goldFloatP31);\n+        init(goldFloatM32);\n+        testFloatM32(goldFloatM32);\n+        init(goldFloatP32);\n+        testFloatP32(goldFloatP32);\n+        init(goldFloatM63);\n+        testFloatM63(goldFloatM63);\n+        init(goldFloatP63);\n+        testFloatP63(goldFloatP63);\n+        init(goldFloatM64);\n+        testFloatM64(goldFloatM64);\n+        init(goldFloatP64);\n+        testFloatP64(goldFloatP64);\n+        init(goldFloatM65);\n+        testFloatM65(goldFloatM65);\n+        init(goldFloatP65);\n+        testFloatP65(goldFloatP65);\n+        init(goldFloatM128);\n+        testFloatM128(goldFloatM128);\n+        init(goldFloatP128);\n+        testFloatP128(goldFloatP128);\n+        init(goldFloatM129);\n+        testFloatM129(goldFloatM129);\n+        init(goldFloatP129);\n+        testFloatP129(goldFloatP129);\n+        init(goldFloatM192);\n+        testFloatM192(goldFloatM192);\n+        init(goldFloatP192);\n+        testFloatP192(goldFloatP192);\n+        init(goldDoubleP0);\n+        testDoubleP0(goldDoubleP0);\n+        init(goldDoubleM1);\n+        testDoubleM1(goldDoubleM1);\n+        init(goldDoubleP1);\n+        testDoubleP1(goldDoubleP1);\n+        init(goldDoubleM2);\n+        testDoubleM2(goldDoubleM2);\n+        init(goldDoubleP2);\n+        testDoubleP2(goldDoubleP2);\n+        init(goldDoubleM3);\n+        testDoubleM3(goldDoubleM3);\n+        init(goldDoubleP3);\n+        testDoubleP3(goldDoubleP3);\n+        init(goldDoubleM4);\n+        testDoubleM4(goldDoubleM4);\n+        init(goldDoubleP4);\n+        testDoubleP4(goldDoubleP4);\n+        init(goldDoubleM7);\n+        testDoubleM7(goldDoubleM7);\n+        init(goldDoubleP7);\n+        testDoubleP7(goldDoubleP7);\n+        init(goldDoubleM8);\n+        testDoubleM8(goldDoubleM8);\n+        init(goldDoubleP8);\n+        testDoubleP8(goldDoubleP8);\n+        init(goldDoubleM14);\n+        testDoubleM14(goldDoubleM14);\n+        init(goldDoubleP14);\n+        testDoubleP14(goldDoubleP14);\n+        init(goldDoubleM16);\n+        testDoubleM16(goldDoubleM16);\n+        init(goldDoubleP16);\n+        testDoubleP16(goldDoubleP16);\n+        init(goldDoubleM18);\n+        testDoubleM18(goldDoubleM18);\n+        init(goldDoubleP18);\n+        testDoubleP18(goldDoubleP18);\n+        init(goldDoubleM20);\n+        testDoubleM20(goldDoubleM20);\n+        init(goldDoubleP20);\n+        testDoubleP20(goldDoubleP20);\n+        init(goldDoubleM31);\n+        testDoubleM31(goldDoubleM31);\n+        init(goldDoubleP31);\n+        testDoubleP31(goldDoubleP31);\n+        init(goldDoubleM32);\n+        testDoubleM32(goldDoubleM32);\n+        init(goldDoubleP32);\n+        testDoubleP32(goldDoubleP32);\n+        init(goldDoubleM63);\n+        testDoubleM63(goldDoubleM63);\n+        init(goldDoubleP63);\n+        testDoubleP63(goldDoubleP63);\n+        init(goldDoubleM64);\n+        testDoubleM64(goldDoubleM64);\n+        init(goldDoubleP64);\n+        testDoubleP64(goldDoubleP64);\n+        init(goldDoubleM65);\n+        testDoubleM65(goldDoubleM65);\n+        init(goldDoubleP65);\n+        testDoubleP65(goldDoubleP65);\n+        init(goldDoubleM128);\n+        testDoubleM128(goldDoubleM128);\n+        init(goldDoubleP128);\n+        testDoubleP128(goldDoubleP128);\n+        init(goldDoubleM129);\n+        testDoubleM129(goldDoubleM129);\n+        init(goldDoubleP129);\n+        testDoubleP129(goldDoubleP129);\n+        init(goldDoubleM192);\n+        testDoubleM192(goldDoubleM192);\n+        init(goldDoubleP192);\n+        testDoubleP192(goldDoubleP192);\n+    }\n+\n+    public static void main(String args[]) {\n+        TestFramework framework = new TestFramework(TestDependencyOffsets.class);\n+        framework.addFlags(\"-XX:-TieredCompilation\",\n+                           \"-XX:CompileCommand=option,compiler.loopopts.superword.TestDependencyOffsets::test*,Vectorize\",\n+                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestDependencyOffsets::init\",\n+                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestDependencyOffsets::test*\",\n+                           \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestDependencyOffsets::verify\",\n+                           \"-XX:LoopUnrollLimit=250\");\n+\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Test requires exactly one argument!\");\n+        }\n+\n+        switch (args[0]) {\n+        case \"vanilla-A\":\n+            framework.addFlags(\"-XX:+AlignVector\");\n+            break;\n+        case \"vanilla-U\":\n+            framework.addFlags(\"-XX:-AlignVector\");\n+            break;\n+        case \"sse4-v016-A\":\n+            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\");\n+            break;\n+        case \"sse4-v016-U\":\n+            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\");\n+            break;\n+        case \"sse4-v008-A\":\n+            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=8\", \"-XX:+AlignVector\");\n+            break;\n+        case \"sse4-v008-U\":\n+            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=8\", \"-XX:-AlignVector\");\n+            break;\n+        case \"sse4-v004-A\":\n+            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=4\", \"-XX:+AlignVector\");\n+            break;\n+        case \"sse4-v004-U\":\n+            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=4\", \"-XX:-AlignVector\");\n+            break;\n+        case \"sse4-v002-A\":\n+            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=4\", \"-XX:+AlignVector\");\n+            break;\n+        case \"sse4-v002-U\":\n+            framework.addFlags(\"-XX:UseSSE=4\", \"-XX:MaxVectorSize=4\", \"-XX:-AlignVector\");\n+            break;\n+        case \"avx1-v032-A\":\n+            framework.addFlags(\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\");\n+            break;\n+        case \"avx1-v032-U\":\n+            framework.addFlags(\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\");\n+            break;\n+        case \"avx1-v016-A\":\n+            framework.addFlags(\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\");\n+            break;\n+        case \"avx1-v016-U\":\n+            framework.addFlags(\"-XX:UseAVX=1\", \"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\");\n+            break;\n+        case \"avx2-v032-A\":\n+            framework.addFlags(\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\");\n+            break;\n+        case \"avx2-v032-U\":\n+            framework.addFlags(\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\");\n+            break;\n+        case \"avx2-v016-A\":\n+            framework.addFlags(\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\");\n+            break;\n+        case \"avx2-v016-U\":\n+            framework.addFlags(\"-XX:UseAVX=2\", \"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\");\n+            break;\n+        case \"avx512-v064-A\":\n+            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=64\", \"-XX:+AlignVector\");\n+            break;\n+        case \"avx512-v064-U\":\n+            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=64\", \"-XX:-AlignVector\");\n+            break;\n+        case \"avx512-v032-A\":\n+            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\");\n+            break;\n+        case \"avx512-v032-U\":\n+            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:+UseKNLSetting\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\");\n+            break;\n+        case \"avx512bw-v064-A\":\n+            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=64\", \"-XX:+AlignVector\");\n+            break;\n+        case \"avx512bw-v064-U\":\n+            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=64\", \"-XX:-AlignVector\");\n+            break;\n+        case \"avx512bw-v032-A\":\n+            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\");\n+            break;\n+        case \"avx512bw-v032-U\":\n+            framework.addFlags(\"-XX:UseAVX=3\", \"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\");\n+            break;\n+        case \"vec-v064-A\":\n+            framework.addFlags(\"-XX:MaxVectorSize=64\", \"-XX:+AlignVector\");\n+            break;\n+        case \"vec-v064-U\":\n+            framework.addFlags(\"-XX:MaxVectorSize=64\", \"-XX:-AlignVector\");\n+            break;\n+        case \"vec-v032-A\":\n+            framework.addFlags(\"-XX:MaxVectorSize=32\", \"-XX:+AlignVector\");\n+            break;\n+        case \"vec-v032-U\":\n+            framework.addFlags(\"-XX:MaxVectorSize=32\", \"-XX:-AlignVector\");\n+            break;\n+        case \"vec-v016-A\":\n+            framework.addFlags(\"-XX:MaxVectorSize=16\", \"-XX:+AlignVector\");\n+            break;\n+        case \"vec-v016-U\":\n+            framework.addFlags(\"-XX:MaxVectorSize=16\", \"-XX:-AlignVector\");\n+            break;\n+        case \"vec-v008-A\":\n+            framework.addFlags(\"-XX:MaxVectorSize=8\", \"-XX:+AlignVector\");\n+            break;\n+        case \"vec-v008-U\":\n+            framework.addFlags(\"-XX:MaxVectorSize=8\", \"-XX:-AlignVector\");\n+            break;\n+        case \"vec-v004-A\":\n+            framework.addFlags(\"-XX:MaxVectorSize=4\", \"-XX:+AlignVector\");\n+            break;\n+        case \"vec-v004-U\":\n+            framework.addFlags(\"-XX:MaxVectorSize=4\", \"-XX:-AlignVector\");\n+            break;\n+        default:\n+            throw new RuntimeException(\"Test argument not recognized: \" + args[0]);\n+        }\n+        framework.start();\n+    }\n+\n+    \/\/ ------------------- Tests -------------------\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP0(int[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j + 0] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP0\")\n+    @Warmup(0)\n+    public static void runIntP0() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP0(data);\n+        verify(\"testIntP0\", data, goldIntP0);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM1(int[] data) {\n+        for (int j = 1; j < RANGE; j++) {\n+            data[j + -1] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM1\")\n+    @Warmup(0)\n+    public static void runIntM1() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM1(data);\n+        verify(\"testIntM1\", data, goldIntM1);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    public static void testIntP1(int[] data) {\n+        for (int j = 0; j < RANGE - 1; j++) {\n+            data[j + 1] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP1\")\n+    @Warmup(0)\n+    public static void runIntP1() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP1(data);\n+        verify(\"testIntP1\", data, goldIntP1);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM2(int[] data) {\n+        for (int j = 2; j < RANGE; j++) {\n+            data[j + -2] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM2\")\n+    @Warmup(0)\n+    public static void runIntM2() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM2(data);\n+        verify(\"testIntM2\", data, goldIntM2);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP2(int[] data) {\n+        for (int j = 0; j < RANGE - 2; j++) {\n+            data[j + 2] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP2\")\n+    @Warmup(0)\n+    public static void runIntP2() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP2(data);\n+        verify(\"testIntP2\", data, goldIntP2);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM3(int[] data) {\n+        for (int j = 3; j < RANGE; j++) {\n+            data[j + -3] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM3\")\n+    @Warmup(0)\n+    public static void runIntM3() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM3(data);\n+        verify(\"testIntM3\", data, goldIntM3);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    \/\/   positive byte_offset 12 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 12 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/   positive byte_offset 12 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 12 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP3(int[] data) {\n+        for (int j = 0; j < RANGE - 3; j++) {\n+            data[j + 3] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP3\")\n+    @Warmup(0)\n+    public static void runIntP3() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP3(data);\n+        verify(\"testIntP3\", data, goldIntP3);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM4(int[] data) {\n+        for (int j = 4; j < RANGE; j++) {\n+            data[j + -4] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM4\")\n+    @Warmup(0)\n+    public static void runIntM4() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM4(data);\n+        verify(\"testIntM4\", data, goldIntM4);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP4(int[] data) {\n+        for (int j = 0; j < RANGE - 4; j++) {\n+            data[j + 4] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP4\")\n+    @Warmup(0)\n+    public static void runIntP4() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP4(data);\n+        verify(\"testIntP4\", data, goldIntP4);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM7(int[] data) {\n+        for (int j = 7; j < RANGE; j++) {\n+            data[j + -7] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM7\")\n+    @Warmup(0)\n+    public static void runIntM7() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM7(data);\n+        verify(\"testIntM7\", data, goldIntM7);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/   positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP7(int[] data) {\n+        for (int j = 0; j < RANGE - 7; j++) {\n+            data[j + 7] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP7\")\n+    @Warmup(0)\n+    public static void runIntP7() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP7(data);\n+        verify(\"testIntP7\", data, goldIntP7);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM8(int[] data) {\n+        for (int j = 8; j < RANGE; j++) {\n+            data[j + -8] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM8\")\n+    @Warmup(0)\n+    public static void runIntM8() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM8(data);\n+        verify(\"testIntM8\", data, goldIntM8);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/   positive byte_offset 32 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP8(int[] data) {\n+        for (int j = 0; j < RANGE - 8; j++) {\n+            data[j + 8] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP8\")\n+    @Warmup(0)\n+    public static void runIntP8() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP8(data);\n+        verify(\"testIntP8\", data, goldIntP8);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM14(int[] data) {\n+        for (int j = 14; j < RANGE; j++) {\n+            data[j + -14] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM14\")\n+    @Warmup(0)\n+    public static void runIntM14() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM14(data);\n+        verify(\"testIntM14\", data, goldIntM14);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/   positive byte_offset 56 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP14(int[] data) {\n+        for (int j = 0; j < RANGE - 14; j++) {\n+            data[j + 14] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP14\")\n+    @Warmup(0)\n+    public static void runIntP14() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP14(data);\n+        verify(\"testIntP14\", data, goldIntP14);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM16(int[] data) {\n+        for (int j = 16; j < RANGE; j++) {\n+            data[j + -16] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM16\")\n+    @Warmup(0)\n+    public static void runIntM16() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM16(data);\n+        verify(\"testIntM16\", data, goldIntM16);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP16(int[] data) {\n+        for (int j = 0; j < RANGE - 16; j++) {\n+            data[j + 16] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP16\")\n+    @Warmup(0)\n+    public static void runIntP16() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP16(data);\n+        verify(\"testIntP16\", data, goldIntP16);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM18(int[] data) {\n+        for (int j = 18; j < RANGE; j++) {\n+            data[j + -18] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM18\")\n+    @Warmup(0)\n+    public static void runIntM18() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM18(data);\n+        verify(\"testIntM18\", data, goldIntM18);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP18(int[] data) {\n+        for (int j = 0; j < RANGE - 18; j++) {\n+            data[j + 18] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP18\")\n+    @Warmup(0)\n+    public static void runIntP18() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP18(data);\n+        verify(\"testIntP18\", data, goldIntP18);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM20(int[] data) {\n+        for (int j = 20; j < RANGE; j++) {\n+            data[j + -20] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM20\")\n+    @Warmup(0)\n+    public static void runIntM20() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM20(data);\n+        verify(\"testIntM20\", data, goldIntM20);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP20(int[] data) {\n+        for (int j = 0; j < RANGE - 20; j++) {\n+            data[j + 20] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP20\")\n+    @Warmup(0)\n+    public static void runIntP20() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP20(data);\n+        verify(\"testIntP20\", data, goldIntP20);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM31(int[] data) {\n+        for (int j = 31; j < RANGE; j++) {\n+            data[j + -31] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM31\")\n+    @Warmup(0)\n+    public static void runIntM31() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM31(data);\n+        verify(\"testIntM31\", data, goldIntM31);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP31(int[] data) {\n+        for (int j = 0; j < RANGE - 31; j++) {\n+            data[j + 31] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP31\")\n+    @Warmup(0)\n+    public static void runIntP31() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP31(data);\n+        verify(\"testIntP31\", data, goldIntP31);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM32(int[] data) {\n+        for (int j = 32; j < RANGE; j++) {\n+            data[j + -32] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM32\")\n+    @Warmup(0)\n+    public static void runIntM32() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM32(data);\n+        verify(\"testIntM32\", data, goldIntM32);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP32(int[] data) {\n+        for (int j = 0; j < RANGE - 32; j++) {\n+            data[j + 32] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP32\")\n+    @Warmup(0)\n+    public static void runIntP32() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP32(data);\n+        verify(\"testIntP32\", data, goldIntP32);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM63(int[] data) {\n+        for (int j = 63; j < RANGE; j++) {\n+            data[j + -63] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM63\")\n+    @Warmup(0)\n+    public static void runIntM63() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM63(data);\n+        verify(\"testIntM63\", data, goldIntM63);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP63(int[] data) {\n+        for (int j = 0; j < RANGE - 63; j++) {\n+            data[j + 63] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP63\")\n+    @Warmup(0)\n+    public static void runIntP63() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP63(data);\n+        verify(\"testIntP63\", data, goldIntP63);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM64(int[] data) {\n+        for (int j = 64; j < RANGE; j++) {\n+            data[j + -64] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM64\")\n+    @Warmup(0)\n+    public static void runIntM64() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM64(data);\n+        verify(\"testIntM64\", data, goldIntM64);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP64(int[] data) {\n+        for (int j = 0; j < RANGE - 64; j++) {\n+            data[j + 64] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP64\")\n+    @Warmup(0)\n+    public static void runIntP64() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP64(data);\n+        verify(\"testIntP64\", data, goldIntP64);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM65(int[] data) {\n+        for (int j = 65; j < RANGE; j++) {\n+            data[j + -65] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM65\")\n+    @Warmup(0)\n+    public static void runIntM65() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM65(data);\n+        verify(\"testIntM65\", data, goldIntM65);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP65(int[] data) {\n+        for (int j = 0; j < RANGE - 65; j++) {\n+            data[j + 65] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP65\")\n+    @Warmup(0)\n+    public static void runIntP65() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP65(data);\n+        verify(\"testIntP65\", data, goldIntP65);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM128(int[] data) {\n+        for (int j = 128; j < RANGE; j++) {\n+            data[j + -128] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM128\")\n+    @Warmup(0)\n+    public static void runIntM128() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM128(data);\n+        verify(\"testIntM128\", data, goldIntM128);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP128(int[] data) {\n+        for (int j = 0; j < RANGE - 128; j++) {\n+            data[j + 128] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP128\")\n+    @Warmup(0)\n+    public static void runIntP128() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP128(data);\n+        verify(\"testIntP128\", data, goldIntP128);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM129(int[] data) {\n+        for (int j = 129; j < RANGE; j++) {\n+            data[j + -129] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM129\")\n+    @Warmup(0)\n+    public static void runIntM129() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM129(data);\n+        verify(\"testIntM129\", data, goldIntM129);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP129(int[] data) {\n+        for (int j = 0; j < RANGE - 129; j++) {\n+            data[j + 129] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP129\")\n+    @Warmup(0)\n+    public static void runIntP129() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP129(data);\n+        verify(\"testIntP129\", data, goldIntP129);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntM192(int[] data) {\n+        for (int j = 192; j < RANGE; j++) {\n+            data[j + -192] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntM192\")\n+    @Warmup(0)\n+    public static void runIntM192() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntM192(data);\n+        verify(\"testIntM192\", data, goldIntM192);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testIntP192(int[] data) {\n+        for (int j = 0; j < RANGE - 192; j++) {\n+            data[j + 192] = (int)(data[j] * (int)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testIntP192\")\n+    @Warmup(0)\n+    public static void runIntP192() {\n+        int[] data = new int[RANGE];\n+        init(data);\n+        testIntP192(data);\n+        verify(\"testIntP192\", data, goldIntP192);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP0(long[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j + 0] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP0\")\n+    @Warmup(0)\n+    public static void runLongP0() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP0(data);\n+        verify(\"testLongP0\", data, goldLongP0);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM1(long[] data) {\n+        for (int j = 1; j < RANGE; j++) {\n+            data[j + -1] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM1\")\n+    @Warmup(0)\n+    public static void runLongM1() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM1(data);\n+        verify(\"testLongM1\", data, goldLongM1);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    public static void testLongP1(long[] data) {\n+        for (int j = 0; j < RANGE - 1; j++) {\n+            data[j + 1] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP1\")\n+    @Warmup(0)\n+    public static void runLongP1() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP1(data);\n+        verify(\"testLongP1\", data, goldLongP1);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM2(long[] data) {\n+        for (int j = 2; j < RANGE; j++) {\n+            data[j + -2] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM2\")\n+    @Warmup(0)\n+    public static void runLongM2() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM2(data);\n+        verify(\"testLongM2\", data, goldLongM2);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP2(long[] data) {\n+        for (int j = 0; j < RANGE - 2; j++) {\n+            data[j + 2] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP2\")\n+    @Warmup(0)\n+    public static void runLongP2() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP2(data);\n+        verify(\"testLongP2\", data, goldLongP2);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM3(long[] data) {\n+        for (int j = 3; j < RANGE; j++) {\n+            data[j + -3] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM3\")\n+    @Warmup(0)\n+    public static void runLongM3() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM3(data);\n+        verify(\"testLongM3\", data, goldLongM3);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    \/\/   positive byte_offset 24 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/   positive byte_offset 24 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    \/\/   positive byte_offset 24 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP3(long[] data) {\n+        for (int j = 0; j < RANGE - 3; j++) {\n+            data[j + 3] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP3\")\n+    @Warmup(0)\n+    public static void runLongP3() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP3(data);\n+        verify(\"testLongP3\", data, goldLongP3);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM4(long[] data) {\n+        for (int j = 4; j < RANGE; j++) {\n+            data[j + -4] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM4\")\n+    @Warmup(0)\n+    public static void runLongM4() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM4(data);\n+        verify(\"testLongM4\", data, goldLongM4);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/   positive byte_offset 32 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP4(long[] data) {\n+        for (int j = 0; j < RANGE - 4; j++) {\n+            data[j + 4] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP4\")\n+    @Warmup(0)\n+    public static void runLongP4() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP4(data);\n+        verify(\"testLongP4\", data, goldLongP4);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM7(long[] data) {\n+        for (int j = 7; j < RANGE; j++) {\n+            data[j + -7] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM7\")\n+    @Warmup(0)\n+    public static void runLongM7() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM7(data);\n+        verify(\"testLongM7\", data, goldLongM7);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/   positive byte_offset 56 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP7(long[] data) {\n+        for (int j = 0; j < RANGE - 7; j++) {\n+            data[j + 7] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP7\")\n+    @Warmup(0)\n+    public static void runLongP7() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP7(data);\n+        verify(\"testLongP7\", data, goldLongP7);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM8(long[] data) {\n+        for (int j = 8; j < RANGE; j++) {\n+            data[j + -8] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM8\")\n+    @Warmup(0)\n+    public static void runLongM8() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM8(data);\n+        verify(\"testLongM8\", data, goldLongM8);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP8(long[] data) {\n+        for (int j = 0; j < RANGE - 8; j++) {\n+            data[j + 8] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP8\")\n+    @Warmup(0)\n+    public static void runLongP8() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP8(data);\n+        verify(\"testLongP8\", data, goldLongP8);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM14(long[] data) {\n+        for (int j = 14; j < RANGE; j++) {\n+            data[j + -14] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM14\")\n+    @Warmup(0)\n+    public static void runLongM14() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM14(data);\n+        verify(\"testLongM14\", data, goldLongM14);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP14(long[] data) {\n+        for (int j = 0; j < RANGE - 14; j++) {\n+            data[j + 14] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP14\")\n+    @Warmup(0)\n+    public static void runLongP14() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP14(data);\n+        verify(\"testLongP14\", data, goldLongP14);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM16(long[] data) {\n+        for (int j = 16; j < RANGE; j++) {\n+            data[j + -16] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM16\")\n+    @Warmup(0)\n+    public static void runLongM16() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM16(data);\n+        verify(\"testLongM16\", data, goldLongM16);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP16(long[] data) {\n+        for (int j = 0; j < RANGE - 16; j++) {\n+            data[j + 16] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP16\")\n+    @Warmup(0)\n+    public static void runLongP16() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP16(data);\n+        verify(\"testLongP16\", data, goldLongP16);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM18(long[] data) {\n+        for (int j = 18; j < RANGE; j++) {\n+            data[j + -18] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM18\")\n+    @Warmup(0)\n+    public static void runLongM18() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM18(data);\n+        verify(\"testLongM18\", data, goldLongM18);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP18(long[] data) {\n+        for (int j = 0; j < RANGE - 18; j++) {\n+            data[j + 18] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP18\")\n+    @Warmup(0)\n+    public static void runLongP18() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP18(data);\n+        verify(\"testLongP18\", data, goldLongP18);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM20(long[] data) {\n+        for (int j = 20; j < RANGE; j++) {\n+            data[j + -20] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM20\")\n+    @Warmup(0)\n+    public static void runLongM20() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM20(data);\n+        verify(\"testLongM20\", data, goldLongM20);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP20(long[] data) {\n+        for (int j = 0; j < RANGE - 20; j++) {\n+            data[j + 20] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP20\")\n+    @Warmup(0)\n+    public static void runLongP20() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP20(data);\n+        verify(\"testLongP20\", data, goldLongP20);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM31(long[] data) {\n+        for (int j = 31; j < RANGE; j++) {\n+            data[j + -31] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM31\")\n+    @Warmup(0)\n+    public static void runLongM31() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM31(data);\n+        verify(\"testLongM31\", data, goldLongM31);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP31(long[] data) {\n+        for (int j = 0; j < RANGE - 31; j++) {\n+            data[j + 31] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP31\")\n+    @Warmup(0)\n+    public static void runLongP31() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP31(data);\n+        verify(\"testLongP31\", data, goldLongP31);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM32(long[] data) {\n+        for (int j = 32; j < RANGE; j++) {\n+            data[j + -32] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM32\")\n+    @Warmup(0)\n+    public static void runLongM32() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM32(data);\n+        verify(\"testLongM32\", data, goldLongM32);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP32(long[] data) {\n+        for (int j = 0; j < RANGE - 32; j++) {\n+            data[j + 32] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP32\")\n+    @Warmup(0)\n+    public static void runLongP32() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP32(data);\n+        verify(\"testLongP32\", data, goldLongP32);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM63(long[] data) {\n+        for (int j = 63; j < RANGE; j++) {\n+            data[j + -63] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM63\")\n+    @Warmup(0)\n+    public static void runLongM63() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM63(data);\n+        verify(\"testLongM63\", data, goldLongM63);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP63(long[] data) {\n+        for (int j = 0; j < RANGE - 63; j++) {\n+            data[j + 63] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP63\")\n+    @Warmup(0)\n+    public static void runLongP63() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP63(data);\n+        verify(\"testLongP63\", data, goldLongP63);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM64(long[] data) {\n+        for (int j = 64; j < RANGE; j++) {\n+            data[j + -64] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM64\")\n+    @Warmup(0)\n+    public static void runLongM64() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM64(data);\n+        verify(\"testLongM64\", data, goldLongM64);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP64(long[] data) {\n+        for (int j = 0; j < RANGE - 64; j++) {\n+            data[j + 64] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP64\")\n+    @Warmup(0)\n+    public static void runLongP64() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP64(data);\n+        verify(\"testLongP64\", data, goldLongP64);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM65(long[] data) {\n+        for (int j = 65; j < RANGE; j++) {\n+            data[j + -65] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM65\")\n+    @Warmup(0)\n+    public static void runLongM65() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM65(data);\n+        verify(\"testLongM65\", data, goldLongM65);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP65(long[] data) {\n+        for (int j = 0; j < RANGE - 65; j++) {\n+            data[j + 65] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP65\")\n+    @Warmup(0)\n+    public static void runLongP65() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP65(data);\n+        verify(\"testLongP65\", data, goldLongP65);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM128(long[] data) {\n+        for (int j = 128; j < RANGE; j++) {\n+            data[j + -128] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM128\")\n+    @Warmup(0)\n+    public static void runLongM128() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM128(data);\n+        verify(\"testLongM128\", data, goldLongM128);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP128(long[] data) {\n+        for (int j = 0; j < RANGE - 128; j++) {\n+            data[j + 128] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP128\")\n+    @Warmup(0)\n+    public static void runLongP128() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP128(data);\n+        verify(\"testLongP128\", data, goldLongP128);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.ADD_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM129(long[] data) {\n+        for (int j = 129; j < RANGE; j++) {\n+            data[j + -129] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM129\")\n+    @Warmup(0)\n+    public static void runLongM129() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM129(data);\n+        verify(\"testLongM129\", data, goldLongM129);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP129(long[] data) {\n+        for (int j = 0; j < RANGE - 129; j++) {\n+            data[j + 129] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP129\")\n+    @Warmup(0)\n+    public static void runLongP129() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP129(data);\n+        verify(\"testLongP129\", data, goldLongP129);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongM192(long[] data) {\n+        for (int j = 192; j < RANGE; j++) {\n+            data[j + -192] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongM192\")\n+    @Warmup(0)\n+    public static void runLongM192() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongM192(data);\n+        verify(\"testLongM192\", data, goldLongM192);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLongP192(long[] data) {\n+        for (int j = 0; j < RANGE - 192; j++) {\n+            data[j + 192] = (long)(data[j] + (long)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testLongP192\")\n+    @Warmup(0)\n+    public static void runLongP192() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        testLongP192(data);\n+        verify(\"testLongP192\", data, goldLongP192);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP0(short[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j + 0] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP0\")\n+    @Warmup(0)\n+    public static void runShortP0() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP0(data);\n+        verify(\"testShortP0\", data, goldShortP0);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM1(short[] data) {\n+        for (int j = 1; j < RANGE; j++) {\n+            data[j + -1] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM1\")\n+    @Warmup(0)\n+    public static void runShortM1() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM1(data);\n+        verify(\"testShortM1\", data, goldShortM1);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/   positive byte_offset 2 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 2 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 2 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 2 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    public static void testShortP1(short[] data) {\n+        for (int j = 0; j < RANGE - 1; j++) {\n+            data[j + 1] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP1\")\n+    @Warmup(0)\n+    public static void runShortP1() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP1(data);\n+        verify(\"testShortP1\", data, goldShortP1);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM2(short[] data) {\n+        for (int j = 2; j < RANGE; j++) {\n+            data[j + -2] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM2\")\n+    @Warmup(0)\n+    public static void runShortM2() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM2(data);\n+        verify(\"testShortM2\", data, goldShortM2);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP2(short[] data) {\n+        for (int j = 0; j < RANGE - 2; j++) {\n+            data[j + 2] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP2\")\n+    @Warmup(0)\n+    public static void runShortP2() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP2(data);\n+        verify(\"testShortP2\", data, goldShortP2);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM3(short[] data) {\n+        for (int j = 3; j < RANGE; j++) {\n+            data[j + -3] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM3\")\n+    @Warmup(0)\n+    public static void runShortM3() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM3(data);\n+        verify(\"testShortM3\", data, goldShortM3);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/   positive byte_offset 6 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 6 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 6 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 6 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP3(short[] data) {\n+        for (int j = 0; j < RANGE - 3; j++) {\n+            data[j + 3] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP3\")\n+    @Warmup(0)\n+    public static void runShortP3() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP3(data);\n+        verify(\"testShortP3\", data, goldShortP3);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM4(short[] data) {\n+        for (int j = 4; j < RANGE; j++) {\n+            data[j + -4] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM4\")\n+    @Warmup(0)\n+    public static void runShortM4() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM4(data);\n+        verify(\"testShortM4\", data, goldShortM4);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP4(short[] data) {\n+        for (int j = 0; j < RANGE - 4; j++) {\n+            data[j + 4] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP4\")\n+    @Warmup(0)\n+    public static void runShortP4() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP4(data);\n+        verify(\"testShortP4\", data, goldShortP4);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM7(short[] data) {\n+        for (int j = 7; j < RANGE; j++) {\n+            data[j + -7] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM7\")\n+    @Warmup(0)\n+    public static void runShortM7() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM7(data);\n+        verify(\"testShortM7\", data, goldShortM7);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/   positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP7(short[] data) {\n+        for (int j = 0; j < RANGE - 7; j++) {\n+            data[j + 7] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP7\")\n+    @Warmup(0)\n+    public static void runShortP7() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP7(data);\n+        verify(\"testShortP7\", data, goldShortP7);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM8(short[] data) {\n+        for (int j = 8; j < RANGE; j++) {\n+            data[j + -8] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM8\")\n+    @Warmup(0)\n+    public static void runShortM8() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM8(data);\n+        verify(\"testShortM8\", data, goldShortM8);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP8(short[] data) {\n+        for (int j = 0; j < RANGE - 8; j++) {\n+            data[j + 8] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP8\")\n+    @Warmup(0)\n+    public static void runShortP8() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP8(data);\n+        verify(\"testShortP8\", data, goldShortP8);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM14(short[] data) {\n+        for (int j = 14; j < RANGE; j++) {\n+            data[j + -14] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM14\")\n+    @Warmup(0)\n+    public static void runShortM14() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM14(data);\n+        verify(\"testShortM14\", data, goldShortM14);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP14(short[] data) {\n+        for (int j = 0; j < RANGE - 14; j++) {\n+            data[j + 14] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP14\")\n+    @Warmup(0)\n+    public static void runShortP14() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP14(data);\n+        verify(\"testShortP14\", data, goldShortP14);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM16(short[] data) {\n+        for (int j = 16; j < RANGE; j++) {\n+            data[j + -16] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM16\")\n+    @Warmup(0)\n+    public static void runShortM16() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM16(data);\n+        verify(\"testShortM16\", data, goldShortM16);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 32 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP16(short[] data) {\n+        for (int j = 0; j < RANGE - 16; j++) {\n+            data[j + 16] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP16\")\n+    @Warmup(0)\n+    public static void runShortP16() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP16(data);\n+        verify(\"testShortP16\", data, goldShortP16);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM18(short[] data) {\n+        for (int j = 18; j < RANGE; j++) {\n+            data[j + -18] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM18\")\n+    @Warmup(0)\n+    public static void runShortM18() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM18(data);\n+        verify(\"testShortM18\", data, goldShortM18);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 36 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 36\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP18(short[] data) {\n+        for (int j = 0; j < RANGE - 18; j++) {\n+            data[j + 18] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP18\")\n+    @Warmup(0)\n+    public static void runShortP18() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP18(data);\n+        verify(\"testShortP18\", data, goldShortP18);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM20(short[] data) {\n+        for (int j = 20; j < RANGE; j++) {\n+            data[j + -20] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM20\")\n+    @Warmup(0)\n+    public static void runShortM20() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM20(data);\n+        verify(\"testShortM20\", data, goldShortM20);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 40 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP20(short[] data) {\n+        for (int j = 0; j < RANGE - 20; j++) {\n+            data[j + 20] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP20\")\n+    @Warmup(0)\n+    public static void runShortP20() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP20(data);\n+        verify(\"testShortP20\", data, goldShortP20);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM31(short[] data) {\n+        for (int j = 31; j < RANGE; j++) {\n+            data[j + -31] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM31\")\n+    @Warmup(0)\n+    public static void runShortM31() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM31(data);\n+        verify(\"testShortM31\", data, goldShortM31);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 62 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 62\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP31(short[] data) {\n+        for (int j = 0; j < RANGE - 31; j++) {\n+            data[j + 31] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP31\")\n+    @Warmup(0)\n+    public static void runShortP31() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP31(data);\n+        verify(\"testShortP31\", data, goldShortP31);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM32(short[] data) {\n+        for (int j = 32; j < RANGE; j++) {\n+            data[j + -32] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM32\")\n+    @Warmup(0)\n+    public static void runShortM32() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM32(data);\n+        verify(\"testShortM32\", data, goldShortM32);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP32(short[] data) {\n+        for (int j = 0; j < RANGE - 32; j++) {\n+            data[j + 32] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP32\")\n+    @Warmup(0)\n+    public static void runShortP32() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP32(data);\n+        verify(\"testShortP32\", data, goldShortP32);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM63(short[] data) {\n+        for (int j = 63; j < RANGE; j++) {\n+            data[j + -63] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM63\")\n+    @Warmup(0)\n+    public static void runShortM63() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM63(data);\n+        verify(\"testShortM63\", data, goldShortM63);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP63(short[] data) {\n+        for (int j = 0; j < RANGE - 63; j++) {\n+            data[j + 63] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP63\")\n+    @Warmup(0)\n+    public static void runShortP63() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP63(data);\n+        verify(\"testShortP63\", data, goldShortP63);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM64(short[] data) {\n+        for (int j = 64; j < RANGE; j++) {\n+            data[j + -64] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM64\")\n+    @Warmup(0)\n+    public static void runShortM64() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM64(data);\n+        verify(\"testShortM64\", data, goldShortM64);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP64(short[] data) {\n+        for (int j = 0; j < RANGE - 64; j++) {\n+            data[j + 64] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP64\")\n+    @Warmup(0)\n+    public static void runShortP64() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP64(data);\n+        verify(\"testShortP64\", data, goldShortP64);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM65(short[] data) {\n+        for (int j = 65; j < RANGE; j++) {\n+            data[j + -65] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM65\")\n+    @Warmup(0)\n+    public static void runShortM65() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM65(data);\n+        verify(\"testShortM65\", data, goldShortM65);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP65(short[] data) {\n+        for (int j = 0; j < RANGE - 65; j++) {\n+            data[j + 65] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP65\")\n+    @Warmup(0)\n+    public static void runShortP65() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP65(data);\n+        verify(\"testShortP65\", data, goldShortP65);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM128(short[] data) {\n+        for (int j = 128; j < RANGE; j++) {\n+            data[j + -128] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM128\")\n+    @Warmup(0)\n+    public static void runShortM128() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM128(data);\n+        verify(\"testShortM128\", data, goldShortM128);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP128(short[] data) {\n+        for (int j = 0; j < RANGE - 128; j++) {\n+            data[j + 128] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP128\")\n+    @Warmup(0)\n+    public static void runShortP128() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP128(data);\n+        verify(\"testShortP128\", data, goldShortP128);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM129(short[] data) {\n+        for (int j = 129; j < RANGE; j++) {\n+            data[j + -129] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM129\")\n+    @Warmup(0)\n+    public static void runShortM129() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM129(data);\n+        verify(\"testShortM129\", data, goldShortM129);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP129(short[] data) {\n+        for (int j = 0; j < RANGE - 129; j++) {\n+            data[j + 129] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP129\")\n+    @Warmup(0)\n+    public static void runShortP129() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP129(data);\n+        verify(\"testShortP129\", data, goldShortP129);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortM192(short[] data) {\n+        for (int j = 192; j < RANGE; j++) {\n+            data[j + -192] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortM192\")\n+    @Warmup(0)\n+    public static void runShortM192() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortM192(data);\n+        verify(\"testShortM192\", data, goldShortM192);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testShortP192(short[] data) {\n+        for (int j = 0; j < RANGE - 192; j++) {\n+            data[j + 192] = (short)(data[j] * (short)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testShortP192\")\n+    @Warmup(0)\n+    public static void runShortP192() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        testShortP192(data);\n+        verify(\"testShortP192\", data, goldShortP192);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP0(char[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j + 0] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP0\")\n+    @Warmup(0)\n+    public static void runCharP0() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP0(data);\n+        verify(\"testCharP0\", data, goldCharP0);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM1(char[] data) {\n+        for (int j = 1; j < RANGE; j++) {\n+            data[j + -1] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM1\")\n+    @Warmup(0)\n+    public static void runCharM1() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM1(data);\n+        verify(\"testCharM1\", data, goldCharM1);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/   positive byte_offset 2 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 2 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 2 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 2 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    public static void testCharP1(char[] data) {\n+        for (int j = 0; j < RANGE - 1; j++) {\n+            data[j + 1] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP1\")\n+    @Warmup(0)\n+    public static void runCharP1() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP1(data);\n+        verify(\"testCharP1\", data, goldCharP1);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM2(char[] data) {\n+        for (int j = 2; j < RANGE; j++) {\n+            data[j + -2] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM2\")\n+    @Warmup(0)\n+    public static void runCharM2() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM2(data);\n+        verify(\"testCharM2\", data, goldCharM2);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP2(char[] data) {\n+        for (int j = 0; j < RANGE - 2; j++) {\n+            data[j + 2] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP2\")\n+    @Warmup(0)\n+    public static void runCharP2() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP2(data);\n+        verify(\"testCharP2\", data, goldCharP2);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM3(char[] data) {\n+        for (int j = 3; j < RANGE; j++) {\n+            data[j + -3] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM3\")\n+    @Warmup(0)\n+    public static void runCharM3() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM3(data);\n+        verify(\"testCharM3\", data, goldCharM3);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/   positive byte_offset 6 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 6 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 6 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 6 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 6\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP3(char[] data) {\n+        for (int j = 0; j < RANGE - 3; j++) {\n+            data[j + 3] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP3\")\n+    @Warmup(0)\n+    public static void runCharP3() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP3(data);\n+        verify(\"testCharP3\", data, goldCharP3);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM4(char[] data) {\n+        for (int j = 4; j < RANGE; j++) {\n+            data[j + -4] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM4\")\n+    @Warmup(0)\n+    public static void runCharM4() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM4(data);\n+        verify(\"testCharM4\", data, goldCharM4);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP4(char[] data) {\n+        for (int j = 0; j < RANGE - 4; j++) {\n+            data[j + 4] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP4\")\n+    @Warmup(0)\n+    public static void runCharP4() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP4(data);\n+        verify(\"testCharP4\", data, goldCharP4);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM7(char[] data) {\n+        for (int j = 7; j < RANGE; j++) {\n+            data[j + -7] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM7\")\n+    @Warmup(0)\n+    public static void runCharM7() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM7(data);\n+        verify(\"testCharM7\", data, goldCharM7);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    \/\/   positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP7(char[] data) {\n+        for (int j = 0; j < RANGE - 7; j++) {\n+            data[j + 7] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP7\")\n+    @Warmup(0)\n+    public static void runCharP7() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP7(data);\n+        verify(\"testCharP7\", data, goldCharP7);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM8(char[] data) {\n+        for (int j = 8; j < RANGE; j++) {\n+            data[j + -8] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM8\")\n+    @Warmup(0)\n+    public static void runCharM8() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM8(data);\n+        verify(\"testCharM8\", data, goldCharM8);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP8(char[] data) {\n+        for (int j = 0; j < RANGE - 8; j++) {\n+            data[j + 8] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP8\")\n+    @Warmup(0)\n+    public static void runCharP8() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP8(data);\n+        verify(\"testCharP8\", data, goldCharP8);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM14(char[] data) {\n+        for (int j = 14; j < RANGE; j++) {\n+            data[j + -14] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM14\")\n+    @Warmup(0)\n+    public static void runCharM14() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM14(data);\n+        verify(\"testCharM14\", data, goldCharM14);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    \/\/   positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP14(char[] data) {\n+        for (int j = 0; j < RANGE - 14; j++) {\n+            data[j + 14] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP14\")\n+    @Warmup(0)\n+    public static void runCharP14() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP14(data);\n+        verify(\"testCharP14\", data, goldCharP14);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM16(char[] data) {\n+        for (int j = 16; j < RANGE; j++) {\n+            data[j + -16] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM16\")\n+    @Warmup(0)\n+    public static void runCharM16() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM16(data);\n+        verify(\"testCharM16\", data, goldCharM16);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 32 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP16(char[] data) {\n+        for (int j = 0; j < RANGE - 16; j++) {\n+            data[j + 16] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP16\")\n+    @Warmup(0)\n+    public static void runCharP16() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP16(data);\n+        verify(\"testCharP16\", data, goldCharP16);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM18(char[] data) {\n+        for (int j = 18; j < RANGE; j++) {\n+            data[j + -18] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM18\")\n+    @Warmup(0)\n+    public static void runCharM18() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM18(data);\n+        verify(\"testCharM18\", data, goldCharM18);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 36 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 36\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP18(char[] data) {\n+        for (int j = 0; j < RANGE - 18; j++) {\n+            data[j + 18] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP18\")\n+    @Warmup(0)\n+    public static void runCharP18() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP18(data);\n+        verify(\"testCharP18\", data, goldCharP18);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM20(char[] data) {\n+        for (int j = 20; j < RANGE; j++) {\n+            data[j + -20] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM20\")\n+    @Warmup(0)\n+    public static void runCharM20() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM20(data);\n+        verify(\"testCharM20\", data, goldCharM20);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 40 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 40\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP20(char[] data) {\n+        for (int j = 0; j < RANGE - 20; j++) {\n+            data[j + 20] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP20\")\n+    @Warmup(0)\n+    public static void runCharP20() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP20(data);\n+        verify(\"testCharP20\", data, goldCharP20);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM31(char[] data) {\n+        for (int j = 31; j < RANGE; j++) {\n+            data[j + -31] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM31\")\n+    @Warmup(0)\n+    public static void runCharM31() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM31(data);\n+        verify(\"testCharM31\", data, goldCharM31);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    \/\/   positive byte_offset 62 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 62\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP31(char[] data) {\n+        for (int j = 0; j < RANGE - 31; j++) {\n+            data[j + 31] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP31\")\n+    @Warmup(0)\n+    public static void runCharP31() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP31(data);\n+        verify(\"testCharP31\", data, goldCharP31);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM32(char[] data) {\n+        for (int j = 32; j < RANGE; j++) {\n+            data[j + -32] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM32\")\n+    @Warmup(0)\n+    public static void runCharM32() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM32(data);\n+        verify(\"testCharM32\", data, goldCharM32);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP32(char[] data) {\n+        for (int j = 0; j < RANGE - 32; j++) {\n+            data[j + 32] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP32\")\n+    @Warmup(0)\n+    public static void runCharP32() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP32(data);\n+        verify(\"testCharP32\", data, goldCharP32);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM63(char[] data) {\n+        for (int j = 63; j < RANGE; j++) {\n+            data[j + -63] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM63\")\n+    @Warmup(0)\n+    public static void runCharM63() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM63(data);\n+        verify(\"testCharM63\", data, goldCharM63);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP63(char[] data) {\n+        for (int j = 0; j < RANGE - 63; j++) {\n+            data[j + 63] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP63\")\n+    @Warmup(0)\n+    public static void runCharP63() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP63(data);\n+        verify(\"testCharP63\", data, goldCharP63);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM64(char[] data) {\n+        for (int j = 64; j < RANGE; j++) {\n+            data[j + -64] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM64\")\n+    @Warmup(0)\n+    public static void runCharM64() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM64(data);\n+        verify(\"testCharM64\", data, goldCharM64);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP64(char[] data) {\n+        for (int j = 0; j < RANGE - 64; j++) {\n+            data[j + 64] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP64\")\n+    @Warmup(0)\n+    public static void runCharP64() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP64(data);\n+        verify(\"testCharP64\", data, goldCharP64);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM65(char[] data) {\n+        for (int j = 65; j < RANGE; j++) {\n+            data[j + -65] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM65\")\n+    @Warmup(0)\n+    public static void runCharM65() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM65(data);\n+        verify(\"testCharM65\", data, goldCharM65);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP65(char[] data) {\n+        for (int j = 0; j < RANGE - 65; j++) {\n+            data[j + 65] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP65\")\n+    @Warmup(0)\n+    public static void runCharP65() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP65(data);\n+        verify(\"testCharP65\", data, goldCharP65);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM128(char[] data) {\n+        for (int j = 128; j < RANGE; j++) {\n+            data[j + -128] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM128\")\n+    @Warmup(0)\n+    public static void runCharM128() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM128(data);\n+        verify(\"testCharM128\", data, goldCharM128);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP128(char[] data) {\n+        for (int j = 0; j < RANGE - 128; j++) {\n+            data[j + 128] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP128\")\n+    @Warmup(0)\n+    public static void runCharP128() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP128(data);\n+        verify(\"testCharP128\", data, goldCharP128);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM129(char[] data) {\n+        for (int j = 129; j < RANGE; j++) {\n+            data[j + -129] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM129\")\n+    @Warmup(0)\n+    public static void runCharM129() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM129(data);\n+        verify(\"testCharM129\", data, goldCharM129);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP129(char[] data) {\n+        for (int j = 0; j < RANGE - 129; j++) {\n+            data[j + 129] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP129\")\n+    @Warmup(0)\n+    public static void runCharP129() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP129(data);\n+        verify(\"testCharP129\", data, goldCharP129);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharM192(char[] data) {\n+        for (int j = 192; j < RANGE; j++) {\n+            data[j + -192] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharM192\")\n+    @Warmup(0)\n+    public static void runCharM192() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharM192(data);\n+        verify(\"testCharM192\", data, goldCharM192);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testCharP192(char[] data) {\n+        for (int j = 0; j < RANGE - 192; j++) {\n+            data[j + 192] = (char)(data[j] * (char)-11);\n+        }\n+    }\n+\n+    @Run(test = \"testCharP192\")\n+    @Warmup(0)\n+    public static void runCharP192() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        testCharP192(data);\n+        verify(\"testCharP192\", data, goldCharP192);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP0(byte[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j + 0] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP0\")\n+    @Warmup(0)\n+    public static void runByteP0() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP0(data);\n+        verify(\"testByteP0\", data, goldByteP0);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM1(byte[] data) {\n+        for (int j = 1; j < RANGE; j++) {\n+            data[j + -1] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM1\")\n+    @Warmup(0)\n+    public static void runByteM1() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM1(data);\n+        verify(\"testByteM1\", data, goldByteM1);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    \/\/   positive byte_offset 1 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 1 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/   positive byte_offset 1 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 1 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    public static void testByteP1(byte[] data) {\n+        for (int j = 0; j < RANGE - 1; j++) {\n+            data[j + 1] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP1\")\n+    @Warmup(0)\n+    public static void runByteP1() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP1(data);\n+        verify(\"testByteP1\", data, goldByteP1);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM2(byte[] data) {\n+        for (int j = 2; j < RANGE; j++) {\n+            data[j + -2] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM2\")\n+    @Warmup(0)\n+    public static void runByteM2() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM2(data);\n+        verify(\"testByteM2\", data, goldByteM2);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    \/\/   positive byte_offset 2 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 2 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/   positive byte_offset 2 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 2 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    public static void testByteP2(byte[] data) {\n+        for (int j = 0; j < RANGE - 2; j++) {\n+            data[j + 2] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP2\")\n+    @Warmup(0)\n+    public static void runByteP2() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP2(data);\n+        verify(\"testByteP2\", data, goldByteP2);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM3(byte[] data) {\n+        for (int j = 3; j < RANGE; j++) {\n+            data[j + -3] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM3\")\n+    @Warmup(0)\n+    public static void runByteM3() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM3(data);\n+        verify(\"testByteM3\", data, goldByteM3);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    \/\/   positive byte_offset 3 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 3 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/   positive byte_offset 3 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 3 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    public static void testByteP3(byte[] data) {\n+        for (int j = 0; j < RANGE - 3; j++) {\n+            data[j + 3] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP3\")\n+    @Warmup(0)\n+    public static void runByteP3() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP3(data);\n+        verify(\"testByteP3\", data, goldByteP3);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM4(byte[] data) {\n+        for (int j = 4; j < RANGE; j++) {\n+            data[j + -4] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM4\")\n+    @Warmup(0)\n+    public static void runByteM4() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM4(data);\n+        verify(\"testByteM4\", data, goldByteM4);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP4(byte[] data) {\n+        for (int j = 0; j < RANGE - 4; j++) {\n+            data[j + 4] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP4\")\n+    @Warmup(0)\n+    public static void runByteP4() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP4(data);\n+        verify(\"testByteP4\", data, goldByteP4);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM7(byte[] data) {\n+        for (int j = 7; j < RANGE; j++) {\n+            data[j + -7] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM7\")\n+    @Warmup(0)\n+    public static void runByteM7() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM7(data);\n+        verify(\"testByteM7\", data, goldByteM7);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    \/\/   positive byte_offset 7 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 7 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/   positive byte_offset 7 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 7 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 7\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP7(byte[] data) {\n+        for (int j = 0; j < RANGE - 7; j++) {\n+            data[j + 7] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP7\")\n+    @Warmup(0)\n+    public static void runByteP7() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP7(data);\n+        verify(\"testByteP7\", data, goldByteP7);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM8(byte[] data) {\n+        for (int j = 8; j < RANGE; j++) {\n+            data[j + -8] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM8\")\n+    @Warmup(0)\n+    public static void runByteM8() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM8(data);\n+        verify(\"testByteM8\", data, goldByteM8);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP8(byte[] data) {\n+        for (int j = 0; j < RANGE - 8; j++) {\n+            data[j + 8] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP8\")\n+    @Warmup(0)\n+    public static void runByteP8() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP8(data);\n+        verify(\"testByteP8\", data, goldByteP8);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM14(byte[] data) {\n+        for (int j = 14; j < RANGE; j++) {\n+            data[j + -14] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM14\")\n+    @Warmup(0)\n+    public static void runByteM14() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM14(data);\n+        verify(\"testByteM14\", data, goldByteM14);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    \/\/   positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/   positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 14 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 14\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP14(byte[] data) {\n+        for (int j = 0; j < RANGE - 14; j++) {\n+            data[j + 14] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP14\")\n+    @Warmup(0)\n+    public static void runByteP14() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP14(data);\n+        verify(\"testByteP14\", data, goldByteP14);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM16(byte[] data) {\n+        for (int j = 16; j < RANGE; j++) {\n+            data[j + -16] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM16\")\n+    @Warmup(0)\n+    public static void runByteM16() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM16(data);\n+        verify(\"testByteM16\", data, goldByteM16);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP16(byte[] data) {\n+        for (int j = 0; j < RANGE - 16; j++) {\n+            data[j + 16] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP16\")\n+    @Warmup(0)\n+    public static void runByteP16() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP16(data);\n+        verify(\"testByteP16\", data, goldByteP16);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM18(byte[] data) {\n+        for (int j = 18; j < RANGE; j++) {\n+            data[j + -18] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM18\")\n+    @Warmup(0)\n+    public static void runByteM18() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM18(data);\n+        verify(\"testByteM18\", data, goldByteM18);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 18 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 18\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/   positive byte_offset 18 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 18\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 18 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 18\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP18(byte[] data) {\n+        for (int j = 0; j < RANGE - 18; j++) {\n+            data[j + 18] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP18\")\n+    @Warmup(0)\n+    public static void runByteP18() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP18(data);\n+        verify(\"testByteP18\", data, goldByteP18);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM20(byte[] data) {\n+        for (int j = 20; j < RANGE; j++) {\n+            data[j + -20] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM20\")\n+    @Warmup(0)\n+    public static void runByteM20() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM20(data);\n+        verify(\"testByteM20\", data, goldByteM20);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 20 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 20\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/   positive byte_offset 20 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 20\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 20 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 20\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP20(byte[] data) {\n+        for (int j = 0; j < RANGE - 20; j++) {\n+            data[j + 20] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP20\")\n+    @Warmup(0)\n+    public static void runByteP20() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP20(data);\n+        verify(\"testByteP20\", data, goldByteP20);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM31(byte[] data) {\n+        for (int j = 31; j < RANGE; j++) {\n+            data[j + -31] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM31\")\n+    @Warmup(0)\n+    public static void runByteM31() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM31(data);\n+        verify(\"testByteM31\", data, goldByteM31);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 31 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 31\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/   positive byte_offset 31 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 31\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    \/\/   positive byte_offset 31 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 31\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP31(byte[] data) {\n+        for (int j = 0; j < RANGE - 31; j++) {\n+            data[j + 31] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP31\")\n+    @Warmup(0)\n+    public static void runByteP31() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP31(data);\n+        verify(\"testByteP31\", data, goldByteP31);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM32(byte[] data) {\n+        for (int j = 32; j < RANGE; j++) {\n+            data[j + -32] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM32\")\n+    @Warmup(0)\n+    public static void runByteM32() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM32(data);\n+        verify(\"testByteM32\", data, goldByteM32);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/   positive byte_offset 32 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP32(byte[] data) {\n+        for (int j = 0; j < RANGE - 32; j++) {\n+            data[j + 32] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP32\")\n+    @Warmup(0)\n+    public static void runByteP32() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP32(data);\n+        verify(\"testByteP32\", data, goldByteP32);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM63(byte[] data) {\n+        for (int j = 63; j < RANGE; j++) {\n+            data[j + -63] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM63\")\n+    @Warmup(0)\n+    public static void runByteM63() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM63(data);\n+        verify(\"testByteM63\", data, goldByteM63);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    \/\/   positive byte_offset 63 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\", \"MaxVectorSize\", \"<= 63\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP63(byte[] data) {\n+        for (int j = 0; j < RANGE - 63; j++) {\n+            data[j + 63] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP63\")\n+    @Warmup(0)\n+    public static void runByteP63() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP63(data);\n+        verify(\"testByteP63\", data, goldByteP63);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM64(byte[] data) {\n+        for (int j = 64; j < RANGE; j++) {\n+            data[j + -64] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM64\")\n+    @Warmup(0)\n+    public static void runByteM64() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM64(data);\n+        verify(\"testByteM64\", data, goldByteM64);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP64(byte[] data) {\n+        for (int j = 0; j < RANGE - 64; j++) {\n+            data[j + 64] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP64\")\n+    @Warmup(0)\n+    public static void runByteP64() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP64(data);\n+        verify(\"testByteP64\", data, goldByteP64);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM65(byte[] data) {\n+        for (int j = 65; j < RANGE; j++) {\n+            data[j + -65] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM65\")\n+    @Warmup(0)\n+    public static void runByteM65() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM65(data);\n+        verify(\"testByteM65\", data, goldByteM65);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP65(byte[] data) {\n+        for (int j = 0; j < RANGE - 65; j++) {\n+            data[j + 65] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP65\")\n+    @Warmup(0)\n+    public static void runByteP65() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP65(data);\n+        verify(\"testByteP65\", data, goldByteP65);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM128(byte[] data) {\n+        for (int j = 128; j < RANGE; j++) {\n+            data[j + -128] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM128\")\n+    @Warmup(0)\n+    public static void runByteM128() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM128(data);\n+        verify(\"testByteM128\", data, goldByteM128);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP128(byte[] data) {\n+        for (int j = 0; j < RANGE - 128; j++) {\n+            data[j + 128] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP128\")\n+    @Warmup(0)\n+    public static void runByteP128() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP128(data);\n+        verify(\"testByteP128\", data, goldByteP128);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM129(byte[] data) {\n+        for (int j = 129; j < RANGE; j++) {\n+            data[j + -129] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM129\")\n+    @Warmup(0)\n+    public static void runByteM129() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM129(data);\n+        verify(\"testByteM129\", data, goldByteM129);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP129(byte[] data) {\n+        for (int j = 0; j < RANGE - 129; j++) {\n+            data[j + 129] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP129\")\n+    @Warmup(0)\n+    public static void runByteP129() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP129(data);\n+        verify(\"testByteP129\", data, goldByteP129);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteM192(byte[] data) {\n+        for (int j = 192; j < RANGE; j++) {\n+            data[j + -192] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteM192\")\n+    @Warmup(0)\n+    public static void runByteM192() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteM192(data);\n+        verify(\"testByteM192\", data, goldByteM192);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 to avx -> vector_width: 16 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"false\"})\n+    \/\/ CPU: avx2 to avx512 without avx512bw -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeatureAnd = {\"avx2\", \"true\", \"avx512bw\", \"false\"})\n+    \/\/ CPU: avx512bw -> vector_width: 64 -> elements in vector: 64\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"avx512bw\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 32\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 4\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testByteP192(byte[] data) {\n+        for (int j = 0; j < RANGE - 192; j++) {\n+            data[j + 192] = (byte)(data[j] * (byte)11);\n+        }\n+    }\n+\n+    @Run(test = \"testByteP192\")\n+    @Warmup(0)\n+    public static void runByteP192() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        testByteP192(data);\n+        verify(\"testByteP192\", data, goldByteP192);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP0(float[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j + 0] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP0\")\n+    @Warmup(0)\n+    public static void runFloatP0() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP0(data);\n+        verify(\"testFloatP0\", data, goldFloatP0);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM1(float[] data) {\n+        for (int j = 1; j < RANGE; j++) {\n+            data[j + -1] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM1\")\n+    @Warmup(0)\n+    public static void runFloatM1() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM1(data);\n+        verify(\"testFloatM1\", data, goldFloatM1);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 4 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    public static void testFloatP1(float[] data) {\n+        for (int j = 0; j < RANGE - 1; j++) {\n+            data[j + 1] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP1\")\n+    @Warmup(0)\n+    public static void runFloatP1() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP1(data);\n+        verify(\"testFloatP1\", data, goldFloatP1);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM2(float[] data) {\n+        for (int j = 2; j < RANGE; j++) {\n+            data[j + -2] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM2\")\n+    @Warmup(0)\n+    public static void runFloatM2() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM2(data);\n+        verify(\"testFloatM2\", data, goldFloatM2);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP2(float[] data) {\n+        for (int j = 0; j < RANGE - 2; j++) {\n+            data[j + 2] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP2\")\n+    @Warmup(0)\n+    public static void runFloatP2() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP2(data);\n+        verify(\"testFloatP2\", data, goldFloatP2);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM3(float[] data) {\n+        for (int j = 3; j < RANGE; j++) {\n+            data[j + -3] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM3\")\n+    @Warmup(0)\n+    public static void runFloatM3() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM3(data);\n+        verify(\"testFloatM3\", data, goldFloatM3);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    \/\/   positive byte_offset 12 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 12 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/   positive byte_offset 12 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 12 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 12\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP3(float[] data) {\n+        for (int j = 0; j < RANGE - 3; j++) {\n+            data[j + 3] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP3\")\n+    @Warmup(0)\n+    public static void runFloatP3() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP3(data);\n+        verify(\"testFloatP3\", data, goldFloatP3);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM4(float[] data) {\n+        for (int j = 4; j < RANGE; j++) {\n+            data[j + -4] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM4\")\n+    @Warmup(0)\n+    public static void runFloatM4() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM4(data);\n+        verify(\"testFloatM4\", data, goldFloatM4);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP4(float[] data) {\n+        for (int j = 0; j < RANGE - 4; j++) {\n+            data[j + 4] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP4\")\n+    @Warmup(0)\n+    public static void runFloatP4() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP4(data);\n+        verify(\"testFloatP4\", data, goldFloatP4);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM7(float[] data) {\n+        for (int j = 7; j < RANGE; j++) {\n+            data[j + -7] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM7\")\n+    @Warmup(0)\n+    public static void runFloatM7() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM7(data);\n+        verify(\"testFloatM7\", data, goldFloatM7);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/   positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    \/\/   positive byte_offset 28 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 28\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP7(float[] data) {\n+        for (int j = 0; j < RANGE - 7; j++) {\n+            data[j + 7] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP7\")\n+    @Warmup(0)\n+    public static void runFloatP7() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP7(data);\n+        verify(\"testFloatP7\", data, goldFloatP7);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM8(float[] data) {\n+        for (int j = 8; j < RANGE; j++) {\n+            data[j + -8] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM8\")\n+    @Warmup(0)\n+    public static void runFloatM8() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM8(data);\n+        verify(\"testFloatM8\", data, goldFloatM8);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/   positive byte_offset 32 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP8(float[] data) {\n+        for (int j = 0; j < RANGE - 8; j++) {\n+            data[j + 8] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP8\")\n+    @Warmup(0)\n+    public static void runFloatP8() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP8(data);\n+        verify(\"testFloatP8\", data, goldFloatP8);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM14(float[] data) {\n+        for (int j = 14; j < RANGE; j++) {\n+            data[j + -14] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM14\")\n+    @Warmup(0)\n+    public static void runFloatM14() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM14(data);\n+        verify(\"testFloatM14\", data, goldFloatM14);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    \/\/   positive byte_offset 56 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP14(float[] data) {\n+        for (int j = 0; j < RANGE - 14; j++) {\n+            data[j + 14] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP14\")\n+    @Warmup(0)\n+    public static void runFloatP14() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP14(data);\n+        verify(\"testFloatP14\", data, goldFloatP14);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM16(float[] data) {\n+        for (int j = 16; j < RANGE; j++) {\n+            data[j + -16] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM16\")\n+    @Warmup(0)\n+    public static void runFloatM16() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM16(data);\n+        verify(\"testFloatM16\", data, goldFloatM16);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP16(float[] data) {\n+        for (int j = 0; j < RANGE - 16; j++) {\n+            data[j + 16] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP16\")\n+    @Warmup(0)\n+    public static void runFloatP16() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP16(data);\n+        verify(\"testFloatP16\", data, goldFloatP16);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM18(float[] data) {\n+        for (int j = 18; j < RANGE; j++) {\n+            data[j + -18] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM18\")\n+    @Warmup(0)\n+    public static void runFloatM18() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM18(data);\n+        verify(\"testFloatM18\", data, goldFloatM18);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP18(float[] data) {\n+        for (int j = 0; j < RANGE - 18; j++) {\n+            data[j + 18] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP18\")\n+    @Warmup(0)\n+    public static void runFloatP18() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP18(data);\n+        verify(\"testFloatP18\", data, goldFloatP18);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM20(float[] data) {\n+        for (int j = 20; j < RANGE; j++) {\n+            data[j + -20] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM20\")\n+    @Warmup(0)\n+    public static void runFloatM20() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM20(data);\n+        verify(\"testFloatM20\", data, goldFloatM20);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP20(float[] data) {\n+        for (int j = 0; j < RANGE - 20; j++) {\n+            data[j + 20] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP20\")\n+    @Warmup(0)\n+    public static void runFloatP20() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP20(data);\n+        verify(\"testFloatP20\", data, goldFloatP20);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM31(float[] data) {\n+        for (int j = 31; j < RANGE; j++) {\n+            data[j + -31] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM31\")\n+    @Warmup(0)\n+    public static void runFloatM31() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM31(data);\n+        verify(\"testFloatM31\", data, goldFloatM31);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP31(float[] data) {\n+        for (int j = 0; j < RANGE - 31; j++) {\n+            data[j + 31] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP31\")\n+    @Warmup(0)\n+    public static void runFloatP31() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP31(data);\n+        verify(\"testFloatP31\", data, goldFloatP31);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM32(float[] data) {\n+        for (int j = 32; j < RANGE; j++) {\n+            data[j + -32] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM32\")\n+    @Warmup(0)\n+    public static void runFloatM32() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM32(data);\n+        verify(\"testFloatM32\", data, goldFloatM32);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP32(float[] data) {\n+        for (int j = 0; j < RANGE - 32; j++) {\n+            data[j + 32] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP32\")\n+    @Warmup(0)\n+    public static void runFloatP32() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP32(data);\n+        verify(\"testFloatP32\", data, goldFloatP32);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM63(float[] data) {\n+        for (int j = 63; j < RANGE; j++) {\n+            data[j + -63] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM63\")\n+    @Warmup(0)\n+    public static void runFloatM63() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM63(data);\n+        verify(\"testFloatM63\", data, goldFloatM63);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP63(float[] data) {\n+        for (int j = 0; j < RANGE - 63; j++) {\n+            data[j + 63] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP63\")\n+    @Warmup(0)\n+    public static void runFloatP63() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP63(data);\n+        verify(\"testFloatP63\", data, goldFloatP63);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM64(float[] data) {\n+        for (int j = 64; j < RANGE; j++) {\n+            data[j + -64] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM64\")\n+    @Warmup(0)\n+    public static void runFloatM64() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM64(data);\n+        verify(\"testFloatM64\", data, goldFloatM64);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP64(float[] data) {\n+        for (int j = 0; j < RANGE - 64; j++) {\n+            data[j + 64] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP64\")\n+    @Warmup(0)\n+    public static void runFloatP64() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP64(data);\n+        verify(\"testFloatP64\", data, goldFloatP64);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM65(float[] data) {\n+        for (int j = 65; j < RANGE; j++) {\n+            data[j + -65] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM65\")\n+    @Warmup(0)\n+    public static void runFloatM65() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM65(data);\n+        verify(\"testFloatM65\", data, goldFloatM65);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP65(float[] data) {\n+        for (int j = 0; j < RANGE - 65; j++) {\n+            data[j + 65] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP65\")\n+    @Warmup(0)\n+    public static void runFloatP65() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP65(data);\n+        verify(\"testFloatP65\", data, goldFloatP65);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM128(float[] data) {\n+        for (int j = 128; j < RANGE; j++) {\n+            data[j + -128] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM128\")\n+    @Warmup(0)\n+    public static void runFloatM128() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM128(data);\n+        verify(\"testFloatM128\", data, goldFloatM128);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP128(float[] data) {\n+        for (int j = 0; j < RANGE - 128; j++) {\n+            data[j + 128] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP128\")\n+    @Warmup(0)\n+    public static void runFloatP128() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP128(data);\n+        verify(\"testFloatP128\", data, goldFloatP128);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM129(float[] data) {\n+        for (int j = 129; j < RANGE; j++) {\n+            data[j + -129] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM129\")\n+    @Warmup(0)\n+    public static void runFloatM129() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM129(data);\n+        verify(\"testFloatM129\", data, goldFloatM129);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP129(float[] data) {\n+        for (int j = 0; j < RANGE - 129; j++) {\n+            data[j + 129] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP129\")\n+    @Warmup(0)\n+    public static void runFloatP129() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP129(data);\n+        verify(\"testFloatP129\", data, goldFloatP129);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatM192(float[] data) {\n+        for (int j = 192; j < RANGE; j++) {\n+            data[j + -192] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatM192\")\n+    @Warmup(0)\n+    public static void runFloatM192() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatM192(data);\n+        verify(\"testFloatM192\", data, goldFloatM192);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 16\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 8\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloatP192(float[] data) {\n+        for (int j = 0; j < RANGE - 192; j++) {\n+            data[j + 192] = (float)(data[j] * (float)1.001f);\n+        }\n+    }\n+\n+    @Run(test = \"testFloatP192\")\n+    @Warmup(0)\n+    public static void runFloatP192() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        testFloatP192(data);\n+        verify(\"testFloatP192\", data, goldFloatP192);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP0(double[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j + 0] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP0\")\n+    @Warmup(0)\n+    public static void runDoubleP0() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP0(data);\n+        verify(\"testDoubleP0\", data, goldDoubleP0);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM1(double[] data) {\n+        for (int j = 1; j < RANGE; j++) {\n+            data[j + -1] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM1\")\n+    @Warmup(0)\n+    public static void runDoubleM1() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM1(data);\n+        verify(\"testDoubleM1\", data, goldDoubleM1);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    \/\/   positive byte_offset 8 can lead to cyclic dependency\n+    \/\/   No positive IR rule: conditions impossible.\n+    public static void testDoubleP1(double[] data) {\n+        for (int j = 0; j < RANGE - 1; j++) {\n+            data[j + 1] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP1\")\n+    @Warmup(0)\n+    public static void runDoubleP1() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP1(data);\n+        verify(\"testDoubleP1\", data, goldDoubleP1);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM2(double[] data) {\n+        for (int j = 2; j < RANGE; j++) {\n+            data[j + -2] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM2\")\n+    @Warmup(0)\n+    public static void runDoubleM2() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM2(data);\n+        verify(\"testDoubleM2\", data, goldDoubleM2);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    \/\/   positive byte_offset 16 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP2(double[] data) {\n+        for (int j = 0; j < RANGE - 2; j++) {\n+            data[j + 2] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP2\")\n+    @Warmup(0)\n+    public static void runDoubleP2() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP2(data);\n+        verify(\"testDoubleP2\", data, goldDoubleP2);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM3(double[] data) {\n+        for (int j = 3; j < RANGE; j++) {\n+            data[j + -3] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM3\")\n+    @Warmup(0)\n+    public static void runDoubleM3() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM3(data);\n+        verify(\"testDoubleM3\", data, goldDoubleM3);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    \/\/   positive byte_offset 24 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/   positive byte_offset 24 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    \/\/   positive byte_offset 24 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 24\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP3(double[] data) {\n+        for (int j = 0; j < RANGE - 3; j++) {\n+            data[j + 3] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP3\")\n+    @Warmup(0)\n+    public static void runDoubleP3() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP3(data);\n+        verify(\"testDoubleP3\", data, goldDoubleP3);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM4(double[] data) {\n+        for (int j = 4; j < RANGE; j++) {\n+            data[j + -4] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM4\")\n+    @Warmup(0)\n+    public static void runDoubleM4() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM4(data);\n+        verify(\"testDoubleM4\", data, goldDoubleM4);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/   positive byte_offset 32 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 32\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP4(double[] data) {\n+        for (int j = 0; j < RANGE - 4; j++) {\n+            data[j + 4] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP4\")\n+    @Warmup(0)\n+    public static void runDoubleP4() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP4(data);\n+        verify(\"testDoubleP4\", data, goldDoubleP4);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM7(double[] data) {\n+        for (int j = 7; j < RANGE; j++) {\n+            data[j + -7] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM7\")\n+    @Warmup(0)\n+    public static void runDoubleM7() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM7(data);\n+        verify(\"testDoubleM7\", data, goldDoubleM7);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    \/\/   positive byte_offset 56 can lead to cyclic dependency\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\", \"MaxVectorSize\", \"<= 56\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP7(double[] data) {\n+        for (int j = 0; j < RANGE - 7; j++) {\n+            data[j + 7] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP7\")\n+    @Warmup(0)\n+    public static void runDoubleP7() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP7(data);\n+        verify(\"testDoubleP7\", data, goldDoubleP7);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM8(double[] data) {\n+        for (int j = 8; j < RANGE; j++) {\n+            data[j + -8] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM8\")\n+    @Warmup(0)\n+    public static void runDoubleM8() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM8(data);\n+        verify(\"testDoubleM8\", data, goldDoubleM8);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP8(double[] data) {\n+        for (int j = 0; j < RANGE - 8; j++) {\n+            data[j + 8] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP8\")\n+    @Warmup(0)\n+    public static void runDoubleP8() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP8(data);\n+        verify(\"testDoubleP8\", data, goldDoubleP8);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM14(double[] data) {\n+        for (int j = 14; j < RANGE; j++) {\n+            data[j + -14] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM14\")\n+    @Warmup(0)\n+    public static void runDoubleM14() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM14(data);\n+        verify(\"testDoubleM14\", data, goldDoubleM14);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP14(double[] data) {\n+        for (int j = 0; j < RANGE - 14; j++) {\n+            data[j + 14] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP14\")\n+    @Warmup(0)\n+    public static void runDoubleP14() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP14(data);\n+        verify(\"testDoubleP14\", data, goldDoubleP14);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM16(double[] data) {\n+        for (int j = 16; j < RANGE; j++) {\n+            data[j + -16] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM16\")\n+    @Warmup(0)\n+    public static void runDoubleM16() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM16(data);\n+        verify(\"testDoubleM16\", data, goldDoubleM16);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP16(double[] data) {\n+        for (int j = 0; j < RANGE - 16; j++) {\n+            data[j + 16] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP16\")\n+    @Warmup(0)\n+    public static void runDoubleP16() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP16(data);\n+        verify(\"testDoubleP16\", data, goldDoubleP16);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM18(double[] data) {\n+        for (int j = 18; j < RANGE; j++) {\n+            data[j + -18] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM18\")\n+    @Warmup(0)\n+    public static void runDoubleM18() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM18(data);\n+        verify(\"testDoubleM18\", data, goldDoubleM18);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP18(double[] data) {\n+        for (int j = 0; j < RANGE - 18; j++) {\n+            data[j + 18] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP18\")\n+    @Warmup(0)\n+    public static void runDoubleP18() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP18(data);\n+        verify(\"testDoubleP18\", data, goldDoubleP18);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM20(double[] data) {\n+        for (int j = 20; j < RANGE; j++) {\n+            data[j + -20] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM20\")\n+    @Warmup(0)\n+    public static void runDoubleM20() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM20(data);\n+        verify(\"testDoubleM20\", data, goldDoubleM20);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP20(double[] data) {\n+        for (int j = 0; j < RANGE - 20; j++) {\n+            data[j + 20] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP20\")\n+    @Warmup(0)\n+    public static void runDoubleP20() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP20(data);\n+        verify(\"testDoubleP20\", data, goldDoubleP20);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM31(double[] data) {\n+        for (int j = 31; j < RANGE; j++) {\n+            data[j + -31] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM31\")\n+    @Warmup(0)\n+    public static void runDoubleM31() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM31(data);\n+        verify(\"testDoubleM31\", data, goldDoubleM31);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP31(double[] data) {\n+        for (int j = 0; j < RANGE - 31; j++) {\n+            data[j + 31] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP31\")\n+    @Warmup(0)\n+    public static void runDoubleP31() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP31(data);\n+        verify(\"testDoubleP31\", data, goldDoubleP31);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM32(double[] data) {\n+        for (int j = 32; j < RANGE; j++) {\n+            data[j + -32] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM32\")\n+    @Warmup(0)\n+    public static void runDoubleM32() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM32(data);\n+        verify(\"testDoubleM32\", data, goldDoubleM32);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP32(double[] data) {\n+        for (int j = 0; j < RANGE - 32; j++) {\n+            data[j + 32] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP32\")\n+    @Warmup(0)\n+    public static void runDoubleP32() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP32(data);\n+        verify(\"testDoubleP32\", data, goldDoubleP32);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM63(double[] data) {\n+        for (int j = 63; j < RANGE; j++) {\n+            data[j + -63] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM63\")\n+    @Warmup(0)\n+    public static void runDoubleM63() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM63(data);\n+        verify(\"testDoubleM63\", data, goldDoubleM63);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP63(double[] data) {\n+        for (int j = 0; j < RANGE - 63; j++) {\n+            data[j + 63] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP63\")\n+    @Warmup(0)\n+    public static void runDoubleP63() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP63(data);\n+        verify(\"testDoubleP63\", data, goldDoubleP63);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM64(double[] data) {\n+        for (int j = 64; j < RANGE; j++) {\n+            data[j + -64] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM64\")\n+    @Warmup(0)\n+    public static void runDoubleM64() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM64(data);\n+        verify(\"testDoubleM64\", data, goldDoubleM64);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP64(double[] data) {\n+        for (int j = 0; j < RANGE - 64; j++) {\n+            data[j + 64] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP64\")\n+    @Warmup(0)\n+    public static void runDoubleP64() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP64(data);\n+        verify(\"testDoubleP64\", data, goldDoubleP64);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM65(double[] data) {\n+        for (int j = 65; j < RANGE; j++) {\n+            data[j + -65] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM65\")\n+    @Warmup(0)\n+    public static void runDoubleM65() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM65(data);\n+        verify(\"testDoubleM65\", data, goldDoubleM65);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP65(double[] data) {\n+        for (int j = 0; j < RANGE - 65; j++) {\n+            data[j + 65] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP65\")\n+    @Warmup(0)\n+    public static void runDoubleP65() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP65(data);\n+        verify(\"testDoubleP65\", data, goldDoubleP65);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM128(double[] data) {\n+        for (int j = 128; j < RANGE; j++) {\n+            data[j + -128] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM128\")\n+    @Warmup(0)\n+    public static void runDoubleM128() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM128(data);\n+        verify(\"testDoubleM128\", data, goldDoubleM128);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP128(double[] data) {\n+        for (int j = 0; j < RANGE - 128; j++) {\n+            data[j + 128] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP128\")\n+    @Warmup(0)\n+    public static void runDoubleP128() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP128(data);\n+        verify(\"testDoubleP128\", data, goldDoubleP128);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Strict alignment not possible.\n+    @IR(failOn = {IRNode.LOAD_VECTOR, IRNode.MUL_V, IRNode.STORE_VECTOR},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM129(double[] data) {\n+        for (int j = 129; j < RANGE; j++) {\n+            data[j + -129] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM129\")\n+    @Warmup(0)\n+    public static void runDoubleM129() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM129(data);\n+        verify(\"testDoubleM129\", data, goldDoubleM129);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP129(double[] data) {\n+        for (int j = 0; j < RANGE - 129; j++) {\n+            data[j + 129] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP129\")\n+    @Warmup(0)\n+    public static void runDoubleP129() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP129(data);\n+        verify(\"testDoubleP129\", data, goldDoubleP129);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleM192(double[] data) {\n+        for (int j = 192; j < RANGE; j++) {\n+            data[j + -192] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleM192\")\n+    @Warmup(0)\n+    public static void runDoubleM192() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleM192(data);\n+        verify(\"testDoubleM192\", data, goldDoubleM192);\n+    }\n+\n+    @Test\n+    \/\/ CPU: sse4.1 -> vector_width: 16 -> elements in vector: 2\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx\", \"false\"})\n+    \/\/ CPU: avx and avx2 -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeatureAnd = {\"avx\", \"true\", \"avx512\", \"false\"})\n+    \/\/ CPU: avx512 -> vector_width: 64 -> elements in vector: 8\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"avx512\", \"true\"})\n+    \/\/ CPU: asimd -> vector_width: 32 -> elements in vector: 4\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    \/\/   Vectorize when strict alignment guaranteed.\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.MUL_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"AlignVector\", \"true\", \"MaxVectorSize\", \">= 16\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDoubleP192(double[] data) {\n+        for (int j = 0; j < RANGE - 192; j++) {\n+            data[j + 192] = (double)(data[j] * (double)1.001);\n+        }\n+    }\n+\n+    @Run(test = \"testDoubleP192\")\n+    @Warmup(0)\n+    public static void runDoubleP192() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        testDoubleP192(data);\n+        verify(\"testDoubleP192\", data, goldDoubleP192);\n+    }\n+\n+    \/\/ ------------------- Initialization -------------------\n+\n+    static void init(int[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j] = (int)j;\n+        }\n+    }\n+\n+    static void init(long[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j] = (long)j;\n+        }\n+    }\n+\n+    static void init(short[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j] = (short)j;\n+        }\n+    }\n+\n+    static void init(char[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j] = (char)j;\n+        }\n+    }\n+\n+    static void init(byte[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j] = (byte)j;\n+        }\n+    }\n+\n+    static void init(float[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j] = (float)j;\n+        }\n+    }\n+\n+    static void init(double[] data) {\n+        for (int j = 0; j < RANGE; j++) {\n+            data[j] = (double)j;\n+        }\n+    }\n+\n+    \/\/ ------------------- Verification -------------------\n+\n+    static void verify(String context, int[] data, int[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+    static void verify(String context, long[] data, long[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+    static void verify(String context, short[] data, short[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+    static void verify(String context, char[] data, char[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+    static void verify(String context, byte[] data, byte[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+    static void verify(String context, float[] data, float[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+    static void verify(String context, double[] data, double[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + context + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDependencyOffsets.java","additions":11389,"deletions":0,"binary":false,"changes":11389,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,4 +30,6 @@\n- * @run main compiler.vectorization.TestForEachRem test1\n- * @run main compiler.vectorization.TestForEachRem test2\n- * @run main compiler.vectorization.TestForEachRem test3\n- * @run main compiler.vectorization.TestForEachRem test4\n+ * @run main\/othervm -Xbatch compiler.vectorization.TestForEachRem test1\n+ * @run main\/othervm -Xbatch compiler.vectorization.TestForEachRem test2\n+ * @run main\/othervm -Xbatch compiler.vectorization.TestForEachRem test3\n+ * @run main\/othervm -Xbatch compiler.vectorization.TestForEachRem test4\n+ * @run main\/othervm -Xbatch compiler.vectorization.TestForEachRem test5\n+ * @run main\/othervm -Xbatch compiler.vectorization.TestForEachRem test6\n@@ -68,0 +70,19 @@\n+    static void test5(int[] data) {\n+       IntStream.range(0, RANGE - 2).forEach(j -> {\n+           data[j + 2] = data[j];\n+       });\n+    }\n+\n+    static void initByte(byte[] data) {\n+       IntStream.range(0, RANGE).parallel().forEach(j -> {\n+           data[j] = (byte)j;\n+       });\n+    }\n+\n+    static void test6(byte[] data) {\n+       \/\/ 2-byte offset -> can only vectorize if alignment not required by hardware\n+       IntStream.range(0, RANGE - 2).forEach(j -> {\n+           data[j] = data[j + 2];\n+       });\n+    }\n+\n@@ -76,0 +97,8 @@\n+    static void verify(String name, byte[] data, byte[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n@@ -79,0 +108,2 @@\n+        byte[] dataB = new byte[RANGE];\n+        byte[] goldB = new byte[RANGE];\n@@ -81,1 +112,1 @@\n-            throw new RuntimeException(\" Missing test name: test1, test2, test3, test4\");\n+            throw new RuntimeException(\" Missing test name: test1, test2, test3, test4, test5\");\n@@ -129,0 +160,25 @@\n+\n+        if (args[0].equals(\"test5\")) {\n+            System.out.println(\" Run test5 ...\");\n+            test1(gold); \/\/ reset\n+            test5(gold);\n+            for (int i = 0; i < ITER; i++) {\n+                test1(data); \/\/ reset\n+                test5(data);\n+            }\n+            verify(\"test5\", data, gold);\n+            System.out.println(\" Finished test5.\");\n+        }\n+\n+        if (args[0].equals(\"test6\")) {\n+            System.out.println(\" Run test6 ...\");\n+            initByte(goldB); \/\/ reset\n+            test6(goldB);\n+            for (int i = 0; i < ITER; i++) {\n+                initByte(dataB); \/\/ reset\n+                test6(dataB);\n+            }\n+            verify(\"test6\", dataB, goldB);\n+            System.out.println(\" Finished test6.\");\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestForEachRem.java","additions":62,"deletions":6,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,803 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298935\n+ * @summary Test forced vectorization, and check IR for vector instructions\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorization.TestOptionVectorizeIR\n+ *\/\n+\n+package compiler.vectorization;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestOptionVectorizeIR {\n+    static final int RANGE = 512;\n+    static final int ITER  = 100;\n+    int[] gold1 = new int[RANGE];\n+    int[] gold2 = new int[RANGE];\n+    int[] gold3 = new int[RANGE];\n+    int[] gold4 = new int[RANGE];\n+    int[] gold5 = new int[RANGE];\n+    int[] gold6 = new int[RANGE];\n+\n+    long[] gold10 = new long[RANGE];\n+    long[] gold11 = new long[RANGE];\n+    long[] gold12 = new long[RANGE];\n+    long[] gold13 = new long[RANGE];\n+\n+    short[] gold20 = new short[RANGE];\n+    short[] gold21 = new short[RANGE];\n+    short[] gold22 = new short[RANGE];\n+    short[] gold23 = new short[RANGE];\n+\n+    byte[] gold30 = new byte[RANGE];\n+    byte[] gold31 = new byte[RANGE];\n+    byte[] gold32 = new byte[RANGE];\n+    byte[] gold33 = new byte[RANGE];\n+\n+    char[] gold40 = new char[RANGE];\n+    char[] gold41 = new char[RANGE];\n+    char[] gold42 = new char[RANGE];\n+    char[] gold43 = new char[RANGE];\n+\n+    float[] gold50 = new float[RANGE];\n+    float[] gold51 = new float[RANGE];\n+    float[] gold52 = new float[RANGE];\n+    float[] gold53 = new float[RANGE];\n+\n+    double[] gold60 = new double[RANGE];\n+    double[] gold61 = new double[RANGE];\n+    double[] gold62 = new double[RANGE];\n+    double[] gold63 = new double[RANGE];\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"-XX:CompileCommand=option,compiler.vectorization.TestOptionVectorizeIR::test*,Vectorize\");\n+    }\n+\n+    TestOptionVectorizeIR() {\n+        \/\/ compute the gold standard in interpreter mode\n+        \/\/ test1\n+        test1(gold1);\n+        \/\/ test2\n+        test1(gold2);\n+        test2(gold2);\n+        \/\/ test3\n+        test1(gold3);\n+        test3(gold3, 2, 3);\n+        \/\/ test4\n+        test1(gold4);\n+        test4(gold4);\n+        \/\/ test5\n+        test1(gold5);\n+        test5(gold5);\n+        \/\/ test6\n+        test1(gold6);\n+        test6(gold6);\n+\n+        \/\/ long\n+        init(gold10);\n+        test10(gold10);\n+        init(gold11);\n+        test11(gold11);\n+        init(gold12);\n+        test12(gold12);\n+        init(gold13);\n+        test13(gold13);\n+\n+        \/\/ short\n+        init(gold20);\n+        test20(gold20);\n+        init(gold21);\n+        test21(gold21);\n+        init(gold22);\n+        test22(gold22);\n+        init(gold23);\n+        test23(gold23);\n+\n+        \/\/ byte\n+        init(gold30);\n+        test30(gold30);\n+        init(gold31);\n+        test31(gold31);\n+        init(gold32);\n+        test32(gold32);\n+        init(gold33);\n+        test33(gold33);\n+\n+        \/\/ char\n+        init(gold40);\n+        test40(gold40);\n+        init(gold41);\n+        test41(gold41);\n+        init(gold42);\n+        test42(gold42);\n+        init(gold43);\n+        test43(gold43);\n+\n+        \/\/ float\n+        init(gold50);\n+        test50(gold50);\n+        init(gold51);\n+        test51(gold51);\n+        init(gold52);\n+        test52(gold52);\n+        init(gold53);\n+        test53(gold53);\n+\n+        \/\/ double\n+        init(gold60);\n+        test60(gold60);\n+        init(gold61);\n+        test61(gold61);\n+        init(gold62);\n+        test62(gold62);\n+        init(gold63);\n+        test63(gold63);\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(100)\n+    public void runTest1() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        verify(\"test1\", data, gold1);\n+    }\n+\n+    @Run(test = \"test2\")\n+    @Warmup(100)\n+    public void runTest2() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        test2(data);\n+        verify(\"test2\", data, gold2);\n+    }\n+\n+    @Run(test = \"test3\")\n+    @Warmup(100)\n+    public void runTest3() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        test3(data, 2, 3);\n+        verify(\"test3\", data, gold3);\n+    }\n+\n+    @Run(test = \"test4\")\n+    @Warmup(100)\n+    public void runTest4() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        test4(data);\n+        verify(\"test4\", data, gold4);\n+    }\n+\n+    @Run(test = \"test5\")\n+    @Warmup(100)\n+    public void runTest5() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        test5(data);\n+        verify(\"test5\", data, gold5);\n+    }\n+\n+    @Run(test = \"test6\")\n+    @Warmup(100)\n+    public void runTest6() {\n+        int[] data = new int[RANGE];\n+        test1(data);\n+        test6(data);\n+        verify(\"test6\", data, gold6);\n+    }\n+\n+    @Test\n+    static void test1(int[] data) {\n+       for (int j = 0; j < RANGE; j++) {\n+           \/\/ Vectorizes even if it is not forced\n+           data[j] = j;\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test2(int[] data) {\n+       for (int j = 0; j < RANGE - 1; j++) {\n+           \/\/ Only vectorizes if forced, because of offset by 1\n+           data[j] = data[j] + data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.REPLICATE_I, \"> 0\", IRNode.ADD_VI, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test3(int[] data, int A, int B) {\n+       for (int j = 0; j < RANGE - 1; j++) {\n+           \/\/ Only vectorizes if forced, because of offset by 1\n+           data[j] = A * data[j] + B * data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test4(int[] data) {\n+       for (int j = 0; j < RANGE - 1; j++) {\n+           \/\/ write forward -> cyclic dependency -> cannot vectorize\n+           \/\/ independent(s1, s2) for adjacent loads should detect this\n+           data[j + 1] = data[j];\n+       }\n+    }\n+\n+    @Test\n+    static void test5(int[] data) {\n+       for (int j = 0; j < RANGE - 3; j++) {\n+           \/\/ write forward -> cyclic dependency -> cannot vectorize\n+           \/\/ independent(s1, s2) for adjacent loads cannot detect this\n+           \/\/ Checks with memory_alignment are disabled via compile option\n+           data[j + 2] = data[j];\n+       }\n+    }\n+\n+    @Test\n+    static void test6(int[] data) {\n+       for (int j = 0; j < RANGE - 3; j++) {\n+           \/\/ write forward -> cyclic dependency -> cannot vectorize\n+           \/\/ independent(s1, s2) for adjacent loads cannot detect this\n+           \/\/ Checks with memory_alignment are disabled via compile option\n+           data[j + 3] = data[j];\n+       }\n+    }\n+\n+    \/\/ ------------------------- Long -----------------------------\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test10(long[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 2];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test11(long[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test12(long[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test13(long[] data) {\n+       \/\/ 128-bit vectors -> can vectorize because only 2 elements\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 2];\n+       }\n+    }\n+\n+    @Run(test = \"test10\")\n+    @Warmup(100)\n+    public void runTest10() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        test10(data);\n+        verify(\"test10\", data, gold10);\n+    }\n+\n+    @Run(test = \"test11\")\n+    @Warmup(100)\n+    public void runTest11() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        test11(data);\n+        verify(\"test11\", data, gold11);\n+    }\n+\n+    @Run(test = \"test12\")\n+    @Warmup(100)\n+    public void runTest12() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        test12(data);\n+        verify(\"test12\", data, gold12);\n+    }\n+\n+    @Run(test = \"test13\")\n+    @Warmup(100)\n+    public void runTest13() {\n+        long[] data = new long[RANGE];\n+        init(data);\n+        test13(data);\n+        verify(\"test13\", data, gold13);\n+    }\n+\n+\n+    \/\/ ------------------------- Short -----------------------------\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test20(short[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 2];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test21(short[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test22(short[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test23(short[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 2];\n+       }\n+    }\n+\n+    @Run(test = \"test20\")\n+    @Warmup(100)\n+    public void runTest20() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        test20(data);\n+        verify(\"test20\", data, gold20);\n+    }\n+\n+    @Run(test = \"test21\")\n+    @Warmup(100)\n+    public void runTest21() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        test21(data);\n+        verify(\"test21\", data, gold21);\n+    }\n+\n+    @Run(test = \"test22\")\n+    @Warmup(100)\n+    public void runTest22() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        test22(data);\n+        verify(\"test22\", data, gold22);\n+    }\n+\n+    @Run(test = \"test23\")\n+    @Warmup(100)\n+    public void runTest23() {\n+        short[] data = new short[RANGE];\n+        init(data);\n+        test23(data);\n+        verify(\"test23\", data, gold23);\n+    }\n+\n+\n+    \/\/ ------------------------- Byte -----------------------------\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test30(byte[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 2];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test31(byte[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test32(byte[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test33(byte[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 2];\n+       }\n+    }\n+\n+    @Run(test = \"test30\")\n+    @Warmup(100)\n+    public void runTest30() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        test30(data);\n+        verify(\"test30\", data, gold30);\n+    }\n+\n+    @Run(test = \"test31\")\n+    @Warmup(100)\n+    public void runTest31() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        test31(data);\n+        verify(\"test31\", data, gold31);\n+    }\n+\n+    @Run(test = \"test32\")\n+    @Warmup(100)\n+    public void runTest32() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        test32(data);\n+        verify(\"test32\", data, gold32);\n+    }\n+\n+    @Run(test = \"test33\")\n+    @Warmup(100)\n+    public void runTest33() {\n+        byte[] data = new byte[RANGE];\n+        init(data);\n+        test33(data);\n+        verify(\"test33\", data, gold33);\n+    }\n+\n+\n+    \/\/ ------------------------- Char -----------------------------\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test40(char[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 2];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test41(char[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test42(char[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test43(char[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 2];\n+       }\n+    }\n+\n+    @Run(test = \"test40\")\n+    @Warmup(100)\n+    public void runTest40() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        test40(data);\n+        verify(\"test40\", data, gold40);\n+    }\n+\n+    @Run(test = \"test41\")\n+    @Warmup(100)\n+    public void runTest41() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        test41(data);\n+        verify(\"test41\", data, gold41);\n+    }\n+\n+    @Run(test = \"test42\")\n+    @Warmup(100)\n+    public void runTest42() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        test42(data);\n+        verify(\"test42\", data, gold42);\n+    }\n+\n+    @Run(test = \"test43\")\n+    @Warmup(100)\n+    public void runTest43() {\n+        char[] data = new char[RANGE];\n+        init(data);\n+        test43(data);\n+        verify(\"test43\", data, gold43);\n+    }\n+\n+    \/\/ ------------------------- Float -----------------------------\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test50(float[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 2];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test51(float[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test52(float[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test53(float[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 2];\n+       }\n+    }\n+\n+    @Run(test = \"test50\")\n+    @Warmup(100)\n+    public void runTest50() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        test50(data);\n+        verify(\"test50\", data, gold50);\n+    }\n+\n+    @Run(test = \"test51\")\n+    @Warmup(100)\n+    public void runTest51() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        test51(data);\n+        verify(\"test51\", data, gold51);\n+    }\n+\n+    @Run(test = \"test52\")\n+    @Warmup(100)\n+    public void runTest52() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        test52(data);\n+        verify(\"test52\", data, gold52);\n+    }\n+\n+    @Run(test = \"test53\")\n+    @Warmup(100)\n+    public void runTest53() {\n+        float[] data = new float[RANGE];\n+        init(data);\n+        test53(data);\n+        verify(\"test53\", data, gold53);\n+    }\n+\n+    \/\/ ------------------------- Double -----------------------------\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test60(double[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 2];\n+       }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\", IRNode.ADD_V, \"> 0\", IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test61(double[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j + 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test62(double[] data) {\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 1];\n+       }\n+    }\n+\n+    @Test\n+    static void test63(double[] data) {\n+       \/\/ 128-bit vectors -> can vectorize because only 2 elements\n+       for (int j = 2; j < RANGE - 2; j++) {\n+           data[j] += data[j - 2];\n+       }\n+    }\n+\n+    @Run(test = \"test60\")\n+    @Warmup(100)\n+    public void runTest60() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        test60(data);\n+        verify(\"test60\", data, gold60);\n+    }\n+\n+    @Run(test = \"test61\")\n+    @Warmup(100)\n+    public void runTest61() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        test61(data);\n+        verify(\"test61\", data, gold61);\n+    }\n+\n+    @Run(test = \"test62\")\n+    @Warmup(100)\n+    public void runTest62() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        test62(data);\n+        verify(\"test62\", data, gold62);\n+    }\n+\n+    @Run(test = \"test63\")\n+    @Warmup(100)\n+    public void runTest63() {\n+        double[] data = new double[RANGE];\n+        init(data);\n+        test63(data);\n+        verify(\"test63\", data, gold63);\n+    }\n+\n+    static void init(long[] data) {\n+       for (int j = 0; j < RANGE; j++) {\n+           data[j] = j;\n+       }\n+    }\n+\n+    static void init(short[] data) {\n+       for (int j = 0; j < RANGE; j++) {\n+           data[j] = (short)j;\n+       }\n+    }\n+\n+    static void init(byte[] data) {\n+       for (int j = 0; j < RANGE; j++) {\n+           data[j] = (byte)j;\n+       }\n+    }\n+\n+    static void init(char[] data) {\n+       for (int j = 0; j < RANGE; j++) {\n+           data[j] = (char)j;\n+       }\n+    }\n+\n+\n+    static void init(float[] data) {\n+       for (int j = 0; j < RANGE; j++) {\n+           data[j] = j;\n+       }\n+    }\n+\n+\n+    static void init(double[] data) {\n+       for (int j = 0; j < RANGE; j++) {\n+           data[j] = j;\n+       }\n+    }\n+\n+    static void verify(String name, int[] data, int[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, long[] data, long[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, short[] data, short[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, byte[] data, byte[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, char[] data, char[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, float[] data, float[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, double[] data, double[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestOptionVectorizeIR.java","additions":803,"deletions":0,"binary":false,"changes":803,"status":"added"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,0 +168,12 @@\n+ \/*\n+ * @test id=g1\n+ * @summary Make sure G1 can recover from humongous allocation fragmentation\n+ * @key randomness\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -Xlog:gc+region=trace -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:VerifyGCType=full -XX:+VerifyDuringGC -XX:+VerifyAfterGC\n+ *      TestAllocHumongousFragment\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/TestAllocHumongousFragment.java","additions":13,"deletions":0,"binary":false,"changes":13,"previous_filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocHumongousFragment.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,1 +174,1 @@\n-        Pattern pattern = Pattern.compile(\"[CV][\\\\s\\\\t]+\\\\[([a-zA-Z0-9_.]+)\\\\+0x.+]\");\n+        Pattern pattern = Pattern.compile(\"[CV][\\\\s\\\\t]+\\\\[([a-zA-Z0-9_.-]+)\\\\+0x.+]\");\n@@ -176,1 +176,1 @@\n-        Asserts.assertTrue(matcher.find(), \"Must find library in \\\"\" + line + \"\\\"\");\n+        Asserts.assertTrue(matcher.find(), \"Must find library name in \\\"\" + line + \"\\\"\");\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestDwarf.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n@@ -29,0 +30,3 @@\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n@@ -36,1 +40,1 @@\n- * @test\n+ * @test id=default\n@@ -46,0 +50,10 @@\n+\/*\n+ * @test id=with-on-error\n+ * @bug 8303861\n+ * @summary Error handling step timeouts should never be blocked by OnError etc.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @requires (vm.debug == true) & (os.family != \"windows\")\n+ * @run driver TimeoutInErrorHandlingTest with-on-error\n+ *\/\n+\n@@ -74,8 +88,22 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-            \"-XX:+UnlockDiagnosticVMOptions\",\n-            \"-Xmx100M\",\n-            \"-XX:ErrorHandlerTest=14\",\n-            \"-XX:+TestUnresponsiveErrorHandler\",\n-            \"-XX:ErrorLogTimeout=\" + ERROR_LOG_TIMEOUT,\n-            \"-XX:-CreateCoredumpOnCrash\",\n-            \"-version\");\n+        boolean withOnError = false;\n+\n+        if (args.length > 0) {\n+            switch (args[0]) {\n+                case \"with-on-error\": withOnError = true; break;\n+                default: throw new RuntimeException(\"Invalid argument \" + args[1]);\n+            }\n+        }\n+\n+        List<String> arguments = new ArrayList<>();\n+        Collections.addAll(arguments,\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-Xmx100M\",\n+                \"-XX:ErrorHandlerTest=14\",\n+                \"-XX:+TestUnresponsiveErrorHandler\",\n+                \"-XX:ErrorLogTimeout=\" + ERROR_LOG_TIMEOUT,\n+                \"-XX:-CreateCoredumpOnCrash\");\n+        if (withOnError) {\n+            arguments.add(\"-XX:OnError=echo hi\");\n+        }\n+        arguments.add(\"-version\");\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(arguments);\n@@ -95,2 +123,4 @@\n-        \/\/ VM should have been aborted by WatcherThread\n-        output_detail.shouldMatch(\".*timer expired, abort.*\");\n+        \/\/ Unless we specified OnError, VM should have been aborted by WatcherThread\n+        if (!withOnError) {\n+            output_detail.shouldMatch(\".*timer expired, abort.*\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TimeoutInErrorHandlingTest.java","additions":41,"deletions":11,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8302795\n+ * @summary CDS support of old classes with major version < JDK_6 (50) for static archive.\n+ *          Test old class with jsr bytecode.\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile test-classes\/OldClassWithjsrApp.jasm\n+ * @run driver OldClassWithjsr\n+ *\/\n+\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class OldClassWithjsr {\n+    public static void main(String[] args) throws Exception {\n+        String mainClass = \"OldClassWithjsrApp\";\n+        String namePrefix = \"oldclasswithjsr\";\n+        String appClasses[] = TestCommon.list(mainClass);\n+        JarBuilder.build(namePrefix, appClasses);\n+        String appJar = TestCommon.getTestJar(namePrefix + \".jar\");\n+\n+        boolean dynamicMode = CDSTestUtils.DYNAMIC_DUMP;\n+\n+        \/\/ create archive with class list\n+        OutputAnalyzer output = TestCommon.dump(appJar, appClasses, \"-Xlog:class+load,cds=debug,verification=trace\");\n+        TestCommon.checkExecReturn(output, 0,\n+                                   dynamicMode ? true : false,\n+                                   \"Skipping \" + mainClass + \": Old class has been linked\");\n+\n+        \/\/ run with archive\n+        TestCommon.run(\n+            \"-cp\", appJar,\n+            \"-Xlog:class+load,cds=debug,verification=trace\",\n+            mainClass, \"1\")\n+          .assertNormalExit(out -> {\n+              out.shouldContain(\"Verifying class \" + mainClass + \" with old format\");\n+              if (!dynamicMode) {\n+                  out.shouldContain(mainClass + \" source: shared objects file\");\n+              } else {\n+                  \/\/ Old classes were already linked before dynamic dump happened,\n+                  \/\/ so they couldn't be archived.\n+                  out.shouldMatch(\".class.load.*\" + mainClass + \" source:.*\" + namePrefix + \".jar\");\n+              }\n+          });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/OldClassWithjsr.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -47,1 +47,1 @@\n-    String warning = \"VM warning: Archived non-system classes are disabled because the java.system.class.loader property is specified\";\n+    String warning = \"Archived non-system classes are disabled because the java.system.class.loader property is specified\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SpecifySysLoaderProp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -245,1 +245,1 @@\n-                output.shouldContain(\"VM warning: -XX:ArchiveClassesAtExit is unsupported when base CDS archive is not loaded\");\n+                output.shouldContain(\"-XX:ArchiveClassesAtExit is unsupported when base CDS archive is not loaded\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArchiveConsistency.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class OldClassWithjsrApp\n+        version 49:0\n+{\n+\n+\n+public Method \"<init>\":\"()V\"\n+        stack 1 locals 1\n+{\n+\/\/ null\n+                aload_0;\n+                invokespecial   Method java\/lang\/Object.\"<init>\":\"()V\";\n+                return;\n+}\n+\n+public static Method main:\"([Ljava\/lang\/String;)V\"\n+        stack 6 locals 2\n+{\n+                aload_0;\n+                iconst_0;\n+                aaload;\n+                invokestatic    Method java\/lang\/Integer.parseInt:\"(Ljava\/lang\/String;)I\";\n+                istore_1;\n+        L12:    return;\n+        L13:    iload_1;\n+                ifeq    L12;\n+                jsr     L23;\n+                goto    L24;\n+        L23:    return;\n+        L24:    aconst_null;\n+                goto    L13;\n+                return;\n+}\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/OldClassWithjsrApp.jasm","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -142,1 +142,1 @@\n-            if (count - k > 2) {\n+            if (count - k > 3) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace015.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-com\/sun\/jdi\/InvokeHangTest.java 8290200 macosx-x64\n+com\/sun\/jdi\/InvokeHangTest.java 8290200 macosx-x64,windows-x64\n","filename":"test\/jdk\/ProblemList-svc-vthread.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -540,0 +540,2 @@\n+java\/net\/SocketOption\/OptionsTest.java                          8304286 windows-all\n+\n@@ -611,1 +613,0 @@\n-sun\/security\/provider\/certpath\/OCSP\/OCSPNoContentLength.java    8300939 generic-all\n@@ -667,0 +668,3 @@\n+javax\/swing\/JColorChooser\/Test6827032.java 8224968 windows-x64\n+java\/awt\/dnd\/MissingDragExitEventTest\/MissingDragExitEventTest.java 8288839 windows-x64\n+\n@@ -735,1 +739,0 @@\n-javax\/script\/Test7.java                                         8239361 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-#  Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -220,1 +220,0 @@\n-    com\/sun\/jarsigner \\\n","filename":"test\/jdk\/TEST.groups","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8039358\n- * @summary com.sun.jarsigner.ContentSignerParameters.getTSAPolicyID() should be default\n- * @modules jdk.jartool\n- * @compile DefaultMethod.java\n- *\/\n-\n-import com.sun.jarsigner.ContentSignerParameters;\n-\n-import java.net.URI;\n-import java.security.cert.X509Certificate;\n-import java.util.zip.ZipFile;\n-\n-public class DefaultMethod implements ContentSignerParameters {\n-\n-    @Override\n-    public String[] getCommandLine() {\n-        return new String[0];\n-    }\n-\n-    @Override\n-    public URI getTimestampingAuthority() {\n-        return null;\n-    }\n-\n-    @Override\n-    public X509Certificate getTimestampingAuthorityCertificate() {\n-        return null;\n-    }\n-\n-    @Override\n-    public byte[] getSignature() {\n-        return new byte[0];\n-    }\n-\n-    @Override\n-    public String getSignatureAlgorithm() {\n-        return null;\n-    }\n-\n-    @Override\n-    public X509Certificate[] getSignerCertificateChain() {\n-        return new X509Certificate[0];\n-    }\n-\n-    @Override\n-    public byte[] getContent() {\n-        return new byte[0];\n-    }\n-\n-    @Override\n-    public ZipFile getSource() {\n-        return null;\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/jarsigner\/DefaultMethod.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -59,1 +59,1 @@\n-    public static int started = 0;\n+    public static volatile int started = 0;\n","filename":"test\/jdk\/com\/sun\/jdi\/JdbLockTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,9 @@\n-\/**\n+import java.awt.Frame;\n+import java.awt.List;\n+import java.lang.ref.PhantomReference;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+\n+import jdk.test.lib.util.ForceGC;\n+\n+\/*\n@@ -29,1 +37,3 @@\n- * @run main\/othervm -Xmx100m AwtListGarbageCollectionTest\n+ * @library \/test\/lib\/\n+ * @build jdk.test.lib.util.ForceGC\n+ * @run main\/othervm -Xmx100m -Xlog:gc=debug AwtListGarbageCollectionTest\n@@ -31,0 +41,1 @@\n+public class AwtListGarbageCollectionTest {\n@@ -32,4 +43,1 @@\n-import java.awt.*;\n-import java.awt.event.WindowAdapter;\n-import java.awt.event.WindowEvent;\n-import java.lang.ref.WeakReference;\n+    private static final long ENQUEUE_TIMEOUT = 50;\n@@ -37,2 +45,1 @@\n-public class AwtListGarbageCollectionTest {\n-    public static void main(String[] args) {\n+    public static void main(String[] args) throws InterruptedException {\n@@ -48,4 +55,2 @@\n-        WeakReference<List> weakListRef = null;\n-        try {\n-            frame.setSize(300, 200);\n-            frame.setVisible(true);\n+        frame.setSize(300, 200);\n+        frame.setVisible(true);\n@@ -53,6 +58,4 @@\n-            List strongListRef = new List();\n-            frame.add(strongListRef);\n-            strongListRef.setMultipleMode(true);\n-            frame.remove(strongListRef);\n-            weakListRef = new WeakReference<List>(strongListRef);\n-            strongListRef = null;\n+        List strongListRef = new List();\n+        frame.add(strongListRef);\n+        strongListRef.setMultipleMode(true);\n+        frame.remove(strongListRef);\n@@ -60,11 +63,18 @@\n-            \/\/make out of memory to force gc\n-            String veryLongString = new String(new char[100]);\n-            while (true) {\n-                veryLongString += veryLongString;\n-            }\n-        } catch (OutOfMemoryError e) {\n-            if (weakListRef == null) {\n-                throw new RuntimeException(\"Weak list ref wasn't created\");\n-            } else if (weakListRef.get() != null) {\n-                throw new RuntimeException(\"List wasn't garbage collected\");\n-            }\n+        final ReferenceQueue<List> referenceQueue = new ReferenceQueue<>();\n+        final PhantomReference<List> phantomListRef =\n+                new PhantomReference<>(strongListRef, referenceQueue);\n+        System.out.println(\"phantomListRef: \" + phantomListRef);\n+\n+        strongListRef = null; \/\/ Clear the strong reference\n+\n+        System.out.println(\"Waiting for the reference to be cleared\");\n+        if (!ForceGC.wait(() -> phantomListRef == remove(referenceQueue))) {\n+            throw new RuntimeException(\"List wasn't garbage collected\");\n+        }\n+    }\n+\n+    private static Reference<?> remove(ReferenceQueue<?> queue) {\n+        try {\n+            return queue.remove(ENQUEUE_TIMEOUT);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n","filename":"test\/jdk\/java\/awt\/List\/ListGarbageCollectionTest\/AwtListGarbageCollectionTest.java","additions":40,"deletions":30,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library ..\/\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestLargeStub\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.util.stream.Stream;\n+\n+public class TestLargeStub extends NativeTestHelper {\n+    @Test\n+    public void testDowncall() {\n+        \/\/ Link a handle with a large number of arguments, to try and overflow the code buffer\n+        Linker.nativeLinker().downcallHandle(\n+                FunctionDescriptor.of(C_LONG_LONG,\n+                        Stream.generate(() -> C_DOUBLE).limit(50).toArray(MemoryLayout[]::new)),\n+                Linker.Option.captureCallState(\"errno\"));\n+    }\n+\n+    @Test\n+    public void testUpcall() {\n+        \/\/ Link a handle with a large number of arguments, to try and overflow the code buffer\n+        Linker.nativeLinker().downcallHandle(\n+                FunctionDescriptor.of(C_LONG_LONG,\n+                        Stream.generate(() -> C_DOUBLE).limit(50).toArray(MemoryLayout[]::new)));\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/largestub\/TestLargeStub.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n+ * @library \/test\/lib\n+ * @library ..\/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   TestReentrantUpcalls\n+ *\/\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemorySegment;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+import static java.lang.invoke.MethodHandles.lookup;\n+\n+public class TestReentrantUpcalls extends NativeTestHelper {\n+    static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    static final MethodHandle MH_m;\n+\n+    static {\n+        System.loadLibrary(\"ReentrantUpcalls\");\n+        try {\n+            MH_m = lookup().findStatic(TestReentrantUpcalls.class, \"m\",\n+                    MethodType.methodType(void.class, int.class, MemorySegment.class, MethodHandle.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        FunctionDescriptor descriptor = FunctionDescriptor.ofVoid(C_INT, C_POINTER);\n+        MethodHandle downcallHandle = downcallHandle(\"do_recurse\", descriptor);\n+\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment stub = LINKER.upcallStub(\n+                    MethodHandles.insertArguments(MH_m, 2, downcallHandle), descriptor, arena.scope());\n+\n+            downcallHandle.invokeExact(0, stub);\n+        }\n+    }\n+\n+    static void m(int depth, MemorySegment thisStub, MethodHandle downcallHandle) throws Throwable {\n+        if (depth < 100) {\n+            downcallHandle.invokeExact(depth + 1, thisStub);\n+        } else {\n+            WB.verifyFrames(\/*log=*\/true, \/*updateRegisterMap=*\/true);\n+            WB.verifyFrames(\/*log=*\/true, \/*updateRegisterMap=*\/false); \/\/ triggers different code paths\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestReentrantUpcalls.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void do_recurse(int depth, void (*cb)(int, void*)) {\n+    cb(depth, cb);\n+}\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/libReentrantUpcalls.c","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.ConstantBootstraps;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Field;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static org.testng.Assert.assertEquals;\n+\n+\/*\n+ * @test\n+ * @compile ConstantDescsTest.java\n+ * @run testng ConstantDescsTest\n+ * @summary unit tests for java.lang.constant.ConstantDescs\n+ *\/\n+public class ConstantDescsTest {\n+\n+    @DataProvider(name = \"validateFields\")\n+    public Object[][] knownFieldsData() {\n+        return new Object[][]{\n+                {CD_Object, Object.class},\n+                {CD_String, String.class},\n+                {CD_Class, Class.class},\n+                {CD_Number, Number.class},\n+                {CD_Integer, Integer.class},\n+                {CD_Long, Long.class},\n+                {CD_Float, Float.class},\n+                {CD_Double, Double.class},\n+                {CD_Short, Short.class},\n+                {CD_Byte, Byte.class},\n+                {CD_Character, Character.class},\n+                {CD_Boolean, Boolean.class},\n+                {CD_Void, Void.class},\n+                {CD_Exception, Exception.class},\n+                {CD_Throwable, Throwable.class},\n+                {CD_Enum, Enum.class},\n+                {CD_VarHandle, VarHandle.class},\n+                {CD_MethodHandles, MethodHandles.class},\n+                {CD_MethodHandles_Lookup, MethodHandles.Lookup.class},\n+                {CD_MethodHandle, MethodHandle.class},\n+                {CD_MethodType, MethodType.class},\n+                {CD_CallSite, CallSite.class},\n+                {CD_Collection, Collection.class},\n+                {CD_List, List.class},\n+                {CD_Set, Set.class},\n+                {CD_Map, Map.class},\n+                {CD_ConstantDesc, ConstantDesc.class},\n+                {CD_ClassDesc, ClassDesc.class},\n+                {CD_EnumDesc, Enum.EnumDesc.class},\n+                {CD_MethodTypeDesc, MethodTypeDesc.class},\n+                {CD_MethodHandleDesc, MethodHandleDesc.class},\n+                {CD_DirectMethodHandleDesc, DirectMethodHandleDesc.class},\n+                {CD_VarHandleDesc, VarHandle.VarHandleDesc.class},\n+                {CD_MethodHandleDesc_Kind, DirectMethodHandleDesc.Kind.class},\n+                {CD_DynamicConstantDesc, DynamicConstantDesc.class},\n+                {CD_DynamicCallSiteDesc, DynamicCallSiteDesc.class},\n+                {CD_ConstantBootstraps, ConstantBootstraps.class},\n+                {CD_int, int.class},\n+                {CD_long, long.class},\n+                {CD_float, float.class},\n+                {CD_double, double.class},\n+                {CD_short, short.class},\n+                {CD_byte, byte.class},\n+                {CD_char, char.class},\n+                {CD_boolean, boolean.class},\n+                {CD_void, void.class},\n+                {NULL, null},\n+                {TRUE, Boolean.TRUE},\n+                {FALSE, Boolean.FALSE},\n+        };\n+    }\n+\n+    \/**\n+     * Checks that ConstantDescs descriptor fields resolve to the right\n+     * constants.\n+     * @throws ReflectiveOperationException if the test fails\n+     *\/\n+    @Test(dataProvider = \"validateFields\")\n+    public void validateFields(ConstantDesc desc, Object value) throws ReflectiveOperationException {\n+        \/\/ Use a minimally-trusted lookup\n+        assertEquals(desc.resolveConstantDesc(MethodHandles.publicLookup()), value);\n+    }\n+\n+    \/**\n+     * Ensures all public static final descriptor fields in ConstantDescs\n+     * are resolvable.\n+     * @throws ReflectiveOperationException if the test fails\n+     *\/\n+    @Test\n+    public void checkFieldsResolvable() throws ReflectiveOperationException {\n+        \/\/ minimally trusted lookup\n+        var lookup = MethodHandles.publicLookup();\n+        var fields = Stream.of(ConstantDescs.class.getFields())\n+                .filter(f -> f.accessFlags().contains(AccessFlag.STATIC)\n+                        && ConstantDesc.class.isAssignableFrom(f.getType()))\n+                .toArray(Field[]::new);\n+        for (var field : fields) {\n+            var desc = (ConstantDesc) field.get(null);\n+            desc.resolveConstantDesc(lookup);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/constant\/ConstantDescsTest.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -29,0 +29,3 @@\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.java.lang.constant\n@@ -60,0 +63,4 @@\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.java.lang.constant.PackageDesc;\n+import jdk.internal.classfile.java.lang.constant.ModuleDesc;\n@@ -1365,8 +1372,5 @@\n-        ModuleDescriptor descriptor = ModuleDescriptor.newModule(\"foo\")\n-                .requires(\"java.base\")\n-                .exports(\"p\")\n-                .build();\n-\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        ModuleInfoWriter.write(descriptor, baos);\n-        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());\n+        ByteBuffer bb = ByteBuffer.wrap(Classfile.buildModule(\n+                ModuleAttribute.of(\n+                        ModuleDesc.of(\"foo\"),\n+                        mb -> mb.requires(ModuleDesc.of(\"java.base\"), 0, null)\n+                                .exports(PackageDesc.of(\"p\"), 0))));\n","filename":"test\/jdk\/java\/lang\/module\/ModuleDescriptorTest.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8303965\n@@ -205,14 +206,20 @@\n-        assertTrue(throwable instanceof IOException,\n-                   \"Expected IOException, got, \" + throwable);\n-        assertTrue(throwable.getMessage().contains(\"protocol error\"),\n-                \"Expected \\\"protocol error\\\" in: \" + throwable.getMessage());\n-\n-        if (iterationIndex == 0) { \/\/ unknown\n-            assertTrue(throwable.getMessage().contains(\"Unknown pseudo-header\"),\n-                    \"Expected \\\"Unknown pseudo-header\\\" in: \" + throwable.getMessage());\n-        } else if (iterationIndex == 4) { \/\/ unexpected\n-            assertTrue(throwable.getMessage().contains(\" Unexpected pseudo-header\"),\n-                    \"Expected \\\" Unexpected pseudo-header\\\" in: \" + throwable.getMessage());\n-        } else {\n-            assertTrue(throwable.getMessage().contains(\"Bad header\"),\n-                    \"Expected \\\"Bad header\\\" in: \" + throwable.getMessage());\n+        try {\n+            assertTrue(throwable instanceof IOException,\n+                    \"Expected IOException, got, \" + throwable);\n+            assertTrue(throwable.getMessage().contains(\"malformed response\"),\n+                    \"Expected \\\"malformed response\\\" in: \" + throwable.getMessage());\n+\n+            if (iterationIndex == 0) { \/\/ unknown\n+                assertTrue(throwable.getMessage().contains(\"Unknown pseudo-header\"),\n+                        \"Expected \\\"Unknown pseudo-header\\\" in: \" + throwable.getMessage());\n+            } else if (iterationIndex == 4) { \/\/ unexpected\n+                assertTrue(throwable.getMessage().contains(\" Unexpected pseudo-header\"),\n+                        \"Expected \\\" Unexpected pseudo-header\\\" in: \" + throwable.getMessage());\n+            } else {\n+                assertTrue(throwable.getMessage().contains(\"Bad header\"),\n+                        \"Expected \\\"Bad header\\\" in: \" + throwable.getMessage());\n+            }\n+        } catch (AssertionError e) {\n+            System.out.println(\"Exception does not match expectation: \" + throwable);\n+            throwable.printStackTrace(System.out);\n+            throw e;\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/BadHeadersTest.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -324,1 +324,1 @@\n-        return dumpHexBytes(data, 16, \"\\n\", \" \");\n+        return dumpHexBytes(data, data.length, 16, \"\\n\", \" \");\n@@ -329,1 +329,2 @@\n-     * @param data the array of bytes to dump to stdout.\n+     * @param data the array of bytes to dump to stdout\n+     * @param dataLen the length of the data to be displayed\n@@ -338,2 +339,2 @@\n-    private static String dumpHexBytes(byte[] data, int itemsPerLine,\n-            String lineDelim, String itemDelim) {\n+    private static String dumpHexBytes(byte[] data, int dataLen,\n+            int itemsPerLine, String lineDelim, String itemDelim) {\n@@ -342,1 +343,1 @@\n-            for (int i = 0; i < data.length; i++) {\n+            for (int i = 0; i < dataLen; i++) {\n@@ -492,0 +493,1 @@\n+            log(\"Signature algorithm set to \" + sigAlgId.getName());\n@@ -555,0 +557,2 @@\n+            log(\"Response Content-Length field \" +\n+                    (isDisabled ? \"disabled\" : \"enabled\"));\n@@ -729,0 +733,4 @@\n+\n+                \/\/ Read in the first line which will be the request line.\n+                \/\/ This will be tokenized so we know if we are dealing with\n+                \/\/ a GET or POST.\n@@ -737,1 +745,1 @@\n-                        switch (headerTokens[0]) {\n+                        switch (headerTokens[0].toUpperCase()) {\n@@ -742,1 +750,1 @@\n-                                ocspReq = parseHttpOcspGet(headerTokens);\n+                                ocspReq = parseHttpOcspGet(headerTokens, in);\n@@ -776,0 +784,3 @@\n+                out.flush();\n+\n+                log(\"Closing \" + ocspSocket);\n@@ -873,0 +884,2 @@\n+         * @param inStream the input stream from the socket bound to this\n+         * {@code OcspHandler}.\n@@ -881,2 +894,20 @@\n-        private LocalOcspRequest parseHttpOcspGet(String[] headerTokens)\n-                throws IOException, CertificateException {\n+        private LocalOcspRequest parseHttpOcspGet(String[] headerTokens,\n+                InputStream inStream) throws IOException, CertificateException {\n+            \/\/ Before we process the remainder of the GET URL, we should drain\n+            \/\/ the InputStream of any other header data.  We (for now) won't\n+            \/\/ use it, but will display the contents if logging is enabled.\n+            boolean endOfHeader = false;\n+            while (!endOfHeader) {\n+                String[] lineTokens = readLine(inStream).split(\":\", 2);\n+                \/\/ We expect to see a type and value pair delimited by a colon.\n+                if (lineTokens[0].isEmpty()) {\n+                    endOfHeader = true;\n+                } else if (lineTokens.length == 2) {\n+                    log(String.format(\"ReqHdr: %s: %s\", lineTokens[0].trim(),\n+                            lineTokens[1].trim()));\n+                } else {\n+                    \/\/ A colon wasn't found and token 0 should be the whole line\n+                    log(\"ReqHdr: \" + lineTokens[0].trim());\n+                }\n+            }\n+\n@@ -1203,1 +1234,3 @@\n-                sb.append(dumpHexBytes(cid.getIssuerNameHash(), 256, \"\", \"\"));\n+                byte[] cidHashBuf = cid.getIssuerNameHash();\n+                sb.append(dumpHexBytes(cidHashBuf, cidHashBuf.length,\n+                        256, \"\", \"\"));\n@@ -1206,1 +1239,3 @@\n-                sb.append(dumpHexBytes(cid.getIssuerKeyHash(), 256, \"\", \"\"));\n+                cidHashBuf = cid.getIssuerKeyHash();\n+                sb.append(dumpHexBytes(cidHashBuf, cidHashBuf.length,\n+                        256, \"\", \"\"));\n@@ -1546,1 +1581,3 @@\n-                sb.append(dumpHexBytes(certId.getIssuerNameHash(), 256, \"\", \"\"));\n+                byte[] cidHashBuf = certId.getIssuerNameHash();\n+                sb.append(dumpHexBytes(cidHashBuf, cidHashBuf.length,\n+                        256, \"\", \"\"));\n@@ -1549,1 +1586,3 @@\n-                sb.append(dumpHexBytes(certId.getIssuerKeyHash(), 256, \"\", \"\"));\n+                cidHashBuf = certId.getIssuerKeyHash();\n+                sb.append(dumpHexBytes(cidHashBuf, cidHashBuf.length,\n+                        256, \"\", \"\"));\n","filename":"test\/jdk\/java\/security\/testlibrary\/SimpleOCSPServer.java","additions":52,"deletions":13,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1,138 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.Socket;\n-import java.security.Principal;\n-import java.security.PrivateKey;\n-import java.security.cert.X509Certificate;\n-import javax.net.ssl.SSLEngine;\n-import javax.net.ssl.SSLSocket;\n-import javax.net.ssl.X509ExtendedKeyManager;\n-\n-public class MyX509ExtendedKeyManager extends X509ExtendedKeyManager {\n-\n-    static final String ERROR = \"ERROR\";\n-    X509ExtendedKeyManager akm;\n-    String expectedAP;\n-    boolean doCheck = true;\n-\n-    MyX509ExtendedKeyManager(X509ExtendedKeyManager akm) {\n-        this.akm = akm;\n-    }\n-\n-    public MyX509ExtendedKeyManager(\n-            X509ExtendedKeyManager akm, String expectedAP, boolean doCheck) {\n-        this.akm = akm;\n-        this.expectedAP = expectedAP;\n-        this.doCheck = doCheck;\n-\n-    }\n-\n-    @Override\n-    public String[] getClientAliases(String keyType, Principal[] issuers) {\n-        return akm.getClientAliases(keyType, issuers);\n-    }\n-\n-    @Override\n-    public String chooseClientAlias(String[] keyType, Principal[] issuers,\n-            Socket socket) {\n-        String nap = ((SSLSocket) socket).getHandshakeApplicationProtocol();\n-        checkALPN(nap);\n-\n-        return akm.chooseClientAlias(keyType, issuers, socket);\n-    }\n-\n-    @Override\n-    public String[] getServerAliases(String keyType, Principal[] issuers) {\n-        return akm.getServerAliases(keyType, issuers);\n-    }\n-\n-    @Override\n-    public String chooseServerAlias(String keyType, Principal[] issuers,\n-            Socket socket) {\n-        String nap = ((SSLSocket) socket).getHandshakeApplicationProtocol();\n-        checkALPN(nap);\n-\n-        return akm.chooseServerAlias(keyType, issuers, socket);\n-    }\n-\n-    @Override\n-    public X509Certificate[] getCertificateChain(String alias) {\n-        return akm.getCertificateChain(alias);\n-    }\n-\n-    @Override\n-    public PrivateKey getPrivateKey(String alias) {\n-        return akm.getPrivateKey(alias);\n-    }\n-\n-    @Override\n-    public String chooseEngineClientAlias(String[] keyType, Principal[] issuers,\n-            SSLEngine engine) {\n-        String nap = engine.getHandshakeApplicationProtocol();\n-        checkALPN(nap);\n-\n-        return akm.chooseEngineClientAlias(keyType, issuers, engine);\n-    }\n-\n-    @Override\n-    public String chooseEngineServerAlias(String keyType, Principal[] issuers,\n-            SSLEngine engine) {\n-        String nap = engine.getHandshakeApplicationProtocol();\n-        checkALPN(nap);\n-\n-        return akm.chooseEngineServerAlias(keyType, issuers, engine);\n-    }\n-\n-    private void checkALPN(String ap) {\n-\n-        if (!doCheck) {\n-            System.out.println(\"Skipping KeyManager checks \" +\n-                \"because a callback has been registered\");\n-            return;\n-        }\n-\n-        if (ERROR.equals(expectedAP)) {\n-            throw new RuntimeException(\"Should not reach here\");\n-        }\n-\n-        System.out.println(\"Expected ALPN value: \" + expectedAP\n-                + \" Got: \" + ap);\n-\n-        if (ap == null) {\n-            throw new RuntimeException(\n-                    \"ALPN should be negotiated, but null was received\");\n-        }\n-        if (expectedAP.equals(\"NONE\")) {\n-            if (!ap.isEmpty()) {\n-                throw new RuntimeException(\"Expected no ALPN value\");\n-            } else {\n-                System.out.println(\"No ALPN value negotiated, as expected\");\n-            }\n-        } else if (!expectedAP.equals(ap)) {\n-            throw new RuntimeException(expectedAP\n-                    + \" ALPN value not available on negotiated connection\");\n-        }\n-\n-    }\n-}\n","filename":"test\/jdk\/javax\/net\/ssl\/ALPN\/MyX509ExtendedKeyManager.java","additions":0,"deletions":138,"binary":false,"changes":138,"status":"deleted"},{"patch":"@@ -31,1 +31,0 @@\n- * @compile MyX509ExtendedKeyManager.java\n@@ -240,4 +239,0 @@\n-        kms = new KeyManager[] { new MyX509ExtendedKeyManager(\n-                (X509ExtendedKeyManager) kms[0], expectedAP,\n-                !hasCallback && hasServerAPs) };\n-\n","filename":"test\/jdk\/javax\/net\/ssl\/ALPN\/SSLEngineAlpnTest.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @compile MyX509ExtendedKeyManager.java\n+ * @library \/javax\/net\/ssl\/templates\n@@ -82,1 +82,0 @@\n-import java.security.KeyStore;\n@@ -87,1 +86,1 @@\n-public class SSLServerSocketAlpnTest {\n+public class SSLServerSocketAlpnTest extends SSLSocketTemplate {\n@@ -89,27 +88,0 @@\n-    \/*\n-     * =============================================================\n-     * Set the various variables needed for the tests, then\n-     * specify what tests to run on each side.\n-     *\/\n-\n-    \/*\n-     * Should we run the client or server in a separate thread?\n-     * Both sides can throw exceptions, but do you have a preference\n-     * as to which side should be the main thread.\n-     *\/\n-    static boolean separateServerThread = false;\n-\n-    \/*\n-     * Where do we find the keystores?\n-     *\/\n-    static String pathToStores = \"..\/etc\";\n-    static String keyStoreFile = \"keystore\";\n-    static String trustStoreFile = \"truststore\";\n-    static String passwd = \"passphrase\";\n-\n-    static String keyFilename = System.getProperty(\"test.src\", \".\") + \"\/\"\n-            + pathToStores + \"\/\" + keyStoreFile;\n-    static String trustFilename = System.getProperty(\"test.src\", \".\") + \"\/\"\n-            + pathToStores + \"\/\" + trustStoreFile;\n-\n-    private static boolean hasServerAPs; \/\/ whether server APs are present\n@@ -118,10 +90,0 @@\n-    \/*\n-     * SSLContext\n-     *\/\n-    SSLContext mySSLContext = null;\n-\n-    \/*\n-     * Is the server ready to serve?\n-     *\/\n-    volatile static boolean serverReady = false;\n-\n@@ -131,1 +93,1 @@\n-    static boolean debug = false;\n+    static boolean debug = Boolean.getBoolean(\"test.debug\");\n@@ -147,10 +109,2 @@\n-    \/*\n-     * Define the server side of the test.\n-     *\n-     * If the server prematurely exits, serverReady will be set to true\n-     * to avoid infinite hangs.\n-     *\/\n-    void doServerSide() throws Exception {\n-        SSLServerSocketFactory sslssf = mySSLContext.getServerSocketFactory();\n-        SSLServerSocket sslServerSocket\n-                = (SSLServerSocket) sslssf.createServerSocket(serverPort);\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket sslServerSocket) {\n@@ -181,0 +135,1 @@\n+    }\n@@ -182,6 +137,8 @@\n-        \/*\n-         * Signal Client, we're ready for his connect.\n-         *\/\n-        serverReady = true;\n-\n-        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();\n+    \/*\n+     * Define the server side of the test.\n+     *\n+     * If the server prematurely exits, serverReady will be set to true\n+     * to avoid infinite hangs.\n+     *\/\n+    @Override\n+    protected void runServerApplication(SSLSocket sslSocket) throws Exception {\n@@ -248,20 +205,3 @@\n-    \/*\n-     * Define the client side of the test.\n-     *\n-     * If the server prematurely exits, serverReady will be set to true\n-     * to avoid infinite hangs.\n-     *\/\n-    void doClientSide() throws Exception {\n-\n-        \/*\n-         * Wait for server to get started.\n-         *\/\n-        while (!serverReady) {\n-            Thread.sleep(50);\n-        }\n-\n-        SSLSocketFactory sslsf = mySSLContext.getSocketFactory();\n-        SSLSocket sslSocket\n-                = (SSLSocket) sslsf.createSocket(\"localhost\", serverPort);\n-\n-        SSLParameters sslp = sslSocket.getSSLParameters();\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        SSLParameters sslp = socket.getSSLParameters();\n@@ -281,1 +221,11 @@\n-        sslSocket.setSSLParameters(sslp);\n+        socket.setSSLParameters(sslp);\n+    }\n+\n+    \/*\n+     * Define the client side of the test.\n+     *\n+     * If the server prematurely exits, serverReady will be set to true\n+     * to avoid infinite hangs.\n+     *\/\n+    @Override\n+    protected void runClientApplication(SSLSocket sslSocket) throws Exception {\n@@ -335,3 +285,0 @@\n-    volatile Exception serverException = null;\n-    volatile Exception clientException = null;\n-\n@@ -354,1 +301,0 @@\n-        hasServerAPs = !args[0].equals(\"UNUSED\"); \/\/ are server APs being used?\n@@ -361,1 +307,1 @@\n-            new SSLServerSocketAlpnTest();\n+            new SSLServerSocketAlpnTest().run();\n@@ -373,34 +319,0 @@\n-    SSLContext getSSLContext(String keyFilename, String trustFilename)\n-            throws Exception {\n-        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n-\n-        \/\/ Keystores\n-        KeyStore keyKS = KeyStore.getInstance(\"JKS\");\n-        keyKS.load(new FileInputStream(keyFilename), passwd.toCharArray());\n-\n-        KeyStore trustKS = KeyStore.getInstance(\"JKS\");\n-        trustKS.load(new FileInputStream(trustFilename), passwd.toCharArray());\n-\n-        \/\/ Generate KeyManager and TrustManager\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(keyKS, passwd.toCharArray());\n-\n-        KeyManager[] kms = kmf.getKeyManagers();\n-        if (!(kms[0] instanceof X509ExtendedKeyManager)) {\n-            throw new Exception(\"kms[0] not X509ExtendedKeyManager\");\n-        }\n-\n-        kms = new KeyManager[] { new MyX509ExtendedKeyManager(\n-                (X509ExtendedKeyManager) kms[0], expectedAP,\n-                !hasCallback && hasServerAPs) };\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(trustKS);\n-        TrustManager[] tms = tmf.getTrustManagers();\n-\n-        \/\/ initial SSLContext\n-        ctx.init(kms, tms, null);\n-\n-        return ctx;\n-    }\n-\n@@ -428,139 +340,0 @@\n-\n-    Thread clientThread = null;\n-    Thread serverThread = null;\n-\n-    \/*\n-     * Primary constructor, used to drive remainder of the test.\n-     *\n-     * Fork off the other side, then do your work.\n-     *\/\n-    SSLServerSocketAlpnTest() throws Exception {\n-        Exception startException = null;\n-        mySSLContext = getSSLContext(keyFilename, trustFilename);\n-        try {\n-            if (separateServerThread) {\n-                startServer(true);\n-                startClient(false);\n-            } else {\n-                startClient(true);\n-                startServer(false);\n-            }\n-        } catch (Exception e) {\n-            startException = e;\n-        }\n-\n-        \/*\n-         * Wait for other side to close down.\n-         *\/\n-        if (separateServerThread) {\n-            if (serverThread != null) {\n-                serverThread.join();\n-            }\n-        } else {\n-            if (clientThread != null) {\n-                clientThread.join();\n-            }\n-        }\n-\n-        \/*\n-         * When we get here, the test is pretty much over.\n-         * Which side threw the error?\n-         *\/\n-        Exception local;\n-        Exception remote;\n-\n-        if (separateServerThread) {\n-            remote = serverException;\n-            local = clientException;\n-        } else {\n-            remote = clientException;\n-            local = serverException;\n-        }\n-\n-        Exception exception = null;\n-\n-        \/*\n-         * Check various exception conditions.\n-         *\/\n-        if ((local != null) && (remote != null)) {\n-            \/\/ If both failed, return the curthread's exception.\n-            local.addSuppressed(remote);\n-            exception = local;\n-        } else if (local != null) {\n-            exception = local;\n-        } else if (remote != null) {\n-            exception = remote;\n-        } else if (startException != null) {\n-            exception = startException;\n-        }\n-\n-        \/*\n-         * If there was an exception *AND* a startException,\n-         * output it.\n-         *\/\n-        if (exception != null) {\n-            if (exception != startException && startException != null) {\n-                exception.addSuppressed(startException);\n-            }\n-            throw exception;\n-        }\n-\n-        \/\/ Fall-through: no exception to throw!\n-    }\n-\n-    void startServer(boolean newThread) throws Exception {\n-        if (newThread) {\n-            serverThread = new Thread() {\n-                @Override\n-                public void run() {\n-                    try {\n-                        doServerSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our server thread just died.\n-                         *\n-                         * Release the client, if not active already...\n-                         *\/\n-                        System.err.println(\"Server died...\");\n-                        serverReady = true;\n-                        serverException = e;\n-                    }\n-                }\n-            };\n-            serverThread.start();\n-        } else {\n-            try {\n-                doServerSide();\n-            } catch (Exception e) {\n-                serverException = e;\n-            } finally {\n-                serverReady = true;\n-            }\n-        }\n-    }\n-\n-    void startClient(boolean newThread) throws Exception {\n-        if (newThread) {\n-            clientThread = new Thread() {\n-                @Override\n-                public void run() {\n-                    try {\n-                        doClientSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our client thread just died.\n-                         *\/\n-                        System.err.println(\"Client died...\");\n-                        clientException = e;\n-                    }\n-                }\n-            };\n-            clientThread.start();\n-        } else {\n-            try {\n-                doClientSide();\n-            } catch (Exception e) {\n-                clientException = e;\n-            }\n-        }\n-    }\n","filename":"test\/jdk\/javax\/net\/ssl\/ALPN\/SSLServerSocketAlpnTest.java","additions":30,"deletions":257,"binary":false,"changes":287,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @compile MyX509ExtendedKeyManager.java\n+ * @library \/javax\/net\/ssl\/templates\n@@ -81,1 +81,0 @@\n-import java.security.KeyStore;\n@@ -86,1 +85,1 @@\n-public class SSLSocketAlpnTest {\n+public class SSLSocketAlpnTest extends SSLSocketTemplate {\n@@ -88,27 +87,0 @@\n-    \/*\n-     * =============================================================\n-     * Set the various variables needed for the tests, then\n-     * specify what tests to run on each side.\n-     *\/\n-\n-    \/*\n-     * Should we run the client or server in a separate thread?\n-     * Both sides can throw exceptions, but do you have a preference\n-     * as to which side should be the main thread.\n-     *\/\n-    static boolean separateServerThread = false;\n-\n-    \/*\n-     * Where do we find the keystores?\n-     *\/\n-    static String pathToStores = \"..\/etc\";\n-    static String keyStoreFile = \"keystore\";\n-    static String trustStoreFile = \"truststore\";\n-    static String passwd = \"passphrase\";\n-\n-    static String keyFilename = System.getProperty(\"test.src\", \".\") + \"\/\"\n-            + pathToStores + \"\/\" + keyStoreFile;\n-    static String trustFilename = System.getProperty(\"test.src\", \".\") + \"\/\"\n-            + pathToStores + \"\/\" + trustStoreFile;\n-\n-    private static boolean hasServerAPs; \/\/ whether server APs are present\n@@ -117,10 +89,0 @@\n-    \/*\n-     * SSLContext\n-     *\/\n-    SSLContext mySSLContext = null;\n-\n-    \/*\n-     * Is the server ready to serve?\n-     *\/\n-    volatile static boolean serverReady = false;\n-\n@@ -130,1 +92,1 @@\n-    static boolean debug = false;\n+    static boolean debug = Boolean.getBoolean(\"test.debug\");\n@@ -146,0 +108,5 @@\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket socket) {\n+        socket.setNeedClientAuth(true);\n+    }\n+\n@@ -152,16 +119,3 @@\n-    void doServerSide() throws Exception {\n-        SSLServerSocketFactory sslssf = mySSLContext.getServerSocketFactory();\n-        SSLServerSocket sslServerSocket\n-                = (SSLServerSocket) sslssf.createServerSocket(serverPort);\n-        \/\/ for both client\/server to call into X509KM\n-        sslServerSocket.setNeedClientAuth(true);\n-\n-        serverPort = sslServerSocket.getLocalPort();\n-\n-        \/*\n-         * Signal Client, we're ready for his connect.\n-         *\/\n-        serverReady = true;\n-\n-        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();\n-\n+    @Override\n+    protected void runServerApplication(SSLSocket sslSocket) throws Exception {\n+        System.out.println(\"in runServerApplication(SSLSocket)\");\n@@ -209,0 +163,1 @@\n+        System.out.println(\"server starting handshake\");\n@@ -250,12 +205,3 @@\n-    void doClientSide() throws Exception {\n-\n-        \/*\n-         * Wait for server to get started.\n-         *\/\n-        while (!serverReady) {\n-            Thread.sleep(50);\n-        }\n-\n-        SSLSocketFactory sslsf = mySSLContext.getSocketFactory();\n-        SSLSocket sslSocket\n-                = (SSLSocket) sslsf.createSocket(\"localhost\", serverPort);\n+    @Override\n+    protected void runClientApplication(SSLSocket sslSocket) throws Exception {\n+        System.out.println(\"in runClientApplication(SSLSocket)\");\n@@ -284,0 +230,1 @@\n+        System.out.println(\"Client starting handshake\");\n@@ -324,10 +271,0 @@\n-    \/*\n-     * =============================================================\n-     * The remainder is just support stuff\n-     *\/\n-    \/\/ use any free port by default\n-    volatile int serverPort = 0;\n-\n-    volatile Exception serverException = null;\n-    volatile Exception clientException = null;\n-\n@@ -350,1 +287,0 @@\n-        hasServerAPs = !args[0].equals(\"UNUSED\"); \/\/ are server APs being used?\n@@ -357,1 +293,1 @@\n-            new SSLSocketAlpnTest();\n+            new SSLSocketAlpnTest().run();\n@@ -369,34 +305,0 @@\n-    SSLContext getSSLContext(String keyFilename, String trustFilename)\n-            throws Exception {\n-        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n-\n-        \/\/ Keystores\n-        KeyStore keyKS = KeyStore.getInstance(\"JKS\");\n-        keyKS.load(new FileInputStream(keyFilename), passwd.toCharArray());\n-\n-        KeyStore trustKS = KeyStore.getInstance(\"JKS\");\n-        trustKS.load(new FileInputStream(trustFilename), passwd.toCharArray());\n-\n-        \/\/ Generate KeyManager and TrustManager\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(keyKS, passwd.toCharArray());\n-\n-        KeyManager[] kms = kmf.getKeyManagers();\n-        if (!(kms[0] instanceof X509ExtendedKeyManager)) {\n-            throw new Exception(\"kms[0] not X509ExtendedKeyManager\");\n-        }\n-\n-        kms = new KeyManager[] { new MyX509ExtendedKeyManager(\n-                (X509ExtendedKeyManager) kms[0], expectedAP,\n-                !hasCallback && hasServerAPs) };\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(trustKS);\n-        TrustManager[] tms = tmf.getTrustManagers();\n-\n-        \/\/ initial SSLContext\n-        ctx.init(kms, tms, null);\n-\n-        return ctx;\n-    }\n-\n@@ -424,139 +326,0 @@\n-\n-    Thread clientThread = null;\n-    Thread serverThread = null;\n-\n-    \/*\n-     * Primary constructor, used to drive remainder of the test.\n-     *\n-     * Fork off the other side, then do your work.\n-     *\/\n-    SSLSocketAlpnTest() throws Exception {\n-        Exception startException = null;\n-        mySSLContext = getSSLContext(keyFilename, trustFilename);\n-        try {\n-            if (separateServerThread) {\n-                startServer(true);\n-                startClient(false);\n-            } else {\n-                startClient(true);\n-                startServer(false);\n-            }\n-        } catch (Exception e) {\n-            startException = e;\n-        }\n-\n-        \/*\n-         * Wait for other side to close down.\n-         *\/\n-        if (separateServerThread) {\n-            if (serverThread != null) {\n-                serverThread.join();\n-            }\n-        } else {\n-            if (clientThread != null) {\n-                clientThread.join();\n-            }\n-        }\n-\n-        \/*\n-         * When we get here, the test is pretty much over.\n-         * Which side threw the error?\n-         *\/\n-        Exception local;\n-        Exception remote;\n-\n-        if (separateServerThread) {\n-            remote = serverException;\n-            local = clientException;\n-        } else {\n-            remote = clientException;\n-            local = serverException;\n-        }\n-\n-        Exception exception = null;\n-\n-        \/*\n-         * Check various exception conditions.\n-         *\/\n-        if ((local != null) && (remote != null)) {\n-            \/\/ If both failed, return the curthread's exception.\n-            local.addSuppressed(remote);\n-            exception = local;\n-        } else if (local != null) {\n-            exception = local;\n-        } else if (remote != null) {\n-            exception = remote;\n-        } else if (startException != null) {\n-            exception = startException;\n-        }\n-\n-        \/*\n-         * If there was an exception *AND* a startException,\n-         * output it.\n-         *\/\n-        if (exception != null) {\n-            if (exception != startException && startException != null) {\n-                exception.addSuppressed(startException);\n-            }\n-            throw exception;\n-        }\n-\n-        \/\/ Fall-through: no exception to throw!\n-    }\n-\n-    void startServer(boolean newThread) throws Exception {\n-        if (newThread) {\n-            serverThread = new Thread() {\n-                @Override\n-                public void run() {\n-                    try {\n-                        doServerSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our server thread just died.\n-                         *\n-                         * Release the client, if not active already...\n-                         *\/\n-                        System.err.println(\"Server died...\");\n-                        serverReady = true;\n-                        serverException = e;\n-                    }\n-                }\n-            };\n-            serverThread.start();\n-        } else {\n-            try {\n-                doServerSide();\n-            } catch (Exception e) {\n-                serverException = e;\n-            } finally {\n-                serverReady = true;\n-            }\n-        }\n-    }\n-\n-    void startClient(boolean newThread) throws Exception {\n-        if (newThread) {\n-            clientThread = new Thread() {\n-                @Override\n-                public void run() {\n-                    try {\n-                        doClientSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our client thread just died.\n-                         *\/\n-                        System.err.println(\"Client died...\");\n-                        clientException = e;\n-                    }\n-                }\n-            };\n-            clientThread.start();\n-        } else {\n-            try {\n-                doClientSide();\n-            } catch (Exception e) {\n-                clientException = e;\n-            }\n-        }\n-    }\n","filename":"test\/jdk\/javax\/net\/ssl\/ALPN\/SSLSocketAlpnTest.java","additions":18,"deletions":255,"binary":false,"changes":273,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-public class HandshakeWithInvalidRecordVersion implements SSLContextTemplate {\n+public class HandshakeWithInvalidRecordVersion extends SSLContextTemplate {\n@@ -43,10 +43,0 @@\n-    private static final String PATH_TO_STORES = \"..\/etc\";\n-    private static final String KEYSTORE_FILE = \"keystore\";\n-    private static final String TRUSTSTORE_FILE = \"truststore\";\n-\n-    private static final String KEYSTORE_PATH =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + PATH_TO_STORES +\n-                    \"\/\" + KEYSTORE_FILE;\n-    private static final String TRUSTSTORE_PATH =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + PATH_TO_STORES +\n-                    \"\/\" + TRUSTSTORE_FILE;\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLEngine\/HandshakeWithInvalidRecordVersion.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,2 +45,0 @@\n-import java.net.*;\n-import java.util.*;\n@@ -50,8 +48,0 @@\n-import java.security.KeyStore;\n-import java.security.KeyFactory;\n-import java.security.cert.Certificate;\n-import java.security.cert.CertificateFactory;\n-import java.security.spec.*;\n-import java.security.interfaces.*;\n-import java.util.Base64;\n-\n@@ -61,51 +51,0 @@\n-    \/*\n-     * Where do we find the keystores?\n-     *\/\n-    \/\/ Certificates and key used in the test.\n-    static String trustedCertStr =\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICkjCCAfugAwIBAgIBADANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n-        \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n-        \"MTEwODE5MDE1MjE5WhcNMzIwNzI5MDE1MjE5WjA7MQswCQYDVQQGEwJVUzENMAsG\\n\" +\n-        \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwgZ8wDQYJ\\n\" +\n-        \"KoZIhvcNAQEBBQADgY0AMIGJAoGBAM8orG08DtF98TMSscjGsidd1ZoN4jiDpi8U\\n\" +\n-        \"ICz+9dMm1qM1d7O2T+KH3\/mxyox7Rc2ZVSCaUD0a3CkhPMnlAx8V4u0H+E9sqso6\\n\" +\n-        \"iDW3JpOyzMExvZiRgRG\/3nvp55RMIUV4vEHOZ1QbhuqG4ebN0Vz2DkRft7+flthf\\n\" +\n-        \"vDld6f5JAgMBAAGjgaUwgaIwHQYDVR0OBBYEFLl81dnfp0wDrv0OJ1sxlWzH83Xh\\n\" +\n-        \"MGMGA1UdIwRcMFqAFLl81dnfp0wDrv0OJ1sxlWzH83XhoT+kPTA7MQswCQYDVQQG\\n\" +\n-        \"EwJVUzENMAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2\\n\" +\n-        \"Y2WCAQAwDwYDVR0TAQH\/BAUwAwEB\/zALBgNVHQ8EBAMCAQYwDQYJKoZIhvcNAQEE\\n\" +\n-        \"BQADgYEALlgaH1gWtoBZ84EW8Hu6YtGLQ\/L9zIFmHonUPZwn3Pr\/\/icR9Sqhc3\/l\\n\" +\n-        \"pVTxOINuFHLRz4BBtEylzRIOPzK3tg8XwuLb1zd0db90x3KBCiAL6E6cklGEPwLe\\n\" +\n-        \"XYMHDn9eDsaq861Tzn6ZwzMgw04zotPMoZN0mVd\/3Qca8UJFucE=\\n\" +\n-        \"-----END CERTIFICATE-----\";\n-\n-    static String targetCertStr =\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICNDCCAZ2gAwIBAgIBDDANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n-        \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n-        \"MTExMTA3MTM1NTUyWhcNMzEwNzI1MTM1NTUyWjBPMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n-        \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxEjAQBgNV\\n\" +\n-        \"BAMTCWxvY2FsaG9zdDBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQC3Pb49OSPfOD2G\\n\" +\n-        \"HSXFCFx1GJEZfqG9ZUf7xuIi\/ra5dLjPGAaoY5QF2QOa8VnOriQCXDfyXHxsuRnE\\n\" +\n-        \"OomxL7EVAgMBAAGjeDB2MAsGA1UdDwQEAwID6DAdBgNVHQ4EFgQUXNCJK3\/dtCIc\\n\" +\n-        \"xb+zlA\/JINlvs\/MwHwYDVR0jBBgwFoAUuXzV2d+nTAOu\/Q4nWzGVbMfzdeEwJwYD\\n\" +\n-        \"VR0lBCAwHgYIKwYBBQUHAwEGCCsGAQUFBwMCBggrBgEFBQcDAzANBgkqhkiG9w0B\\n\" +\n-        \"AQQFAAOBgQB2qIDUxA2caMPpGtUACZAPRUtrGssCINIfItETXJZCx\/cRuZ5sP4D9\\n\" +\n-        \"N1acoNDn0hCULe3lhXAeTC9NZ97680yJzregQMV5wATjo1FGsKY30Ma+sc\/nfzQW\\n\" +\n-        \"+h\/7RhYtoG0OTsiaDCvyhI6swkNJzSzrAccPY4+ZgU8HiDLzZTmM3Q==\\n\" +\n-        \"-----END CERTIFICATE-----\";\n-\n-    \/\/ Private key in the format of PKCS#8, key size is 512 bits.\n-    static String targetPrivateKey =\n-        \"MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEAtz2+PTkj3zg9hh0l\\n\" +\n-        \"xQhcdRiRGX6hvWVH+8biIv62uXS4zxgGqGOUBdkDmvFZzq4kAlw38lx8bLkZxDqJ\\n\" +\n-        \"sS+xFQIDAQABAkByx\/5Oo2hQ\/w2q4L8z+NTRlJ3vdl8iIDtC\/4XPnfYfnGptnpG6\\n\" +\n-        \"ZThQRvbMZiai0xHQPQMszvAHjZVme1eDl3EBAiEA3aKJHynPVCEJhpfCLWuMwX5J\\n\" +\n-        \"1LntwJO7NTOyU5m8rPECIQDTpzn5X44r2rzWBDna\/Sx7HW9IWCxNgUD2Eyi2nA7W\\n\" +\n-        \"ZQIgJerEorw4aCAuzQPxiGu57PB6GRamAihEAtoRTBQlH0ECIQDN08FgTtnesgCU\\n\" +\n-        \"DFYLLcw1CiHvc7fZw4neBDHCrC8NtQIgA8TOUkGnpCZlQ0KaI8KfKWI+vxFcgFnH\\n\" +\n-        \"3fnqsTgaUs4=\";\n-\n-    static char passphrase[] = \"passphrase\".toCharArray();\n-\n@@ -117,0 +56,8 @@\n+    private final String enabledProtocol;\n+    private final String tmAlgorithm;\n+\n+    public DisabledShortRSAKeys(String tmAlgorithm, String enabledProtocol) {\n+        this.tmAlgorithm = tmAlgorithm;\n+        this.enabledProtocol = enabledProtocol;\n+    }\n+\n@@ -118,2 +65,3 @@\n-    protected SSLContext createClientSSLContext() throws Exception {\n-        return generateSSLContext(trustedCertStr, null, null);\n+    public SSLContext createClientSSLContext() throws Exception {\n+        return createSSLContext(new Cert[]{Cert.CA_RSA_512}, null,\n+                new ContextParameters(enabledProtocol, tmAlgorithm, \"NewSunX509\"));\n@@ -123,2 +71,3 @@\n-    protected SSLContext createServerSSLContext() throws Exception {\n-        return generateSSLContext(null, targetCertStr, targetPrivateKey);\n+    public SSLContext createServerSSLContext() throws Exception {\n+        return createSSLContext(null, new Cert[]{Cert.EE_RSA_512},\n+                new ContextParameters(enabledProtocol, tmAlgorithm, \"NewSunX509\"));\n@@ -162,78 +111,0 @@\n-    \/*\n-     * =============================================================\n-     * The remainder is just support stuff\n-     *\/\n-    private static String tmAlgorithm; \/\/ trust manager\n-    private static String enabledProtocol; \/\/ the target protocol\n-\n-    private static void parseArguments(String[] args) {\n-            tmAlgorithm = args[0];\n-            enabledProtocol = args[1];\n-    }\n-\n-    private static SSLContext generateSSLContext(String trustedCertStr,\n-                String keyCertStr, String keySpecStr) throws Exception {\n-\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        \/\/ create a key store\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        ks.load(null, null);\n-\n-        \/\/ import the trused cert\n-        Certificate trusedCert = null;\n-        ByteArrayInputStream is = null;\n-        if (trustedCertStr != null) {\n-            is = new ByteArrayInputStream(trustedCertStr.getBytes());\n-            trusedCert = cf.generateCertificate(is);\n-            is.close();\n-\n-            ks.setCertificateEntry(\"RSA Export Signer\", trusedCert);\n-        }\n-\n-        if (keyCertStr != null) {\n-            \/\/ generate the private key.\n-            PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n-                            Base64.getMimeDecoder().decode(keySpecStr));\n-            KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n-            RSAPrivateKey priKey =\n-                (RSAPrivateKey)kf.generatePrivate(priKeySpec);\n-\n-            \/\/ generate certificate chain\n-            is = new ByteArrayInputStream(keyCertStr.getBytes());\n-            Certificate keyCert = cf.generateCertificate(is);\n-            is.close();\n-\n-            Certificate[] chain = null;\n-            if (trusedCert != null) {\n-                chain = new Certificate[2];\n-                chain[0] = keyCert;\n-                chain[1] = trusedCert;\n-            } else {\n-                chain = new Certificate[1];\n-                chain[0] = keyCert;\n-            }\n-\n-            \/\/ import the key entry.\n-            ks.setKeyEntry(\"Whatever\", priKey, passphrase, chain);\n-        }\n-\n-        \/\/ create SSL context\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmAlgorithm);\n-        tmf.init(ks);\n-\n-        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n-        if (keyCertStr != null && !keyCertStr.isEmpty()) {\n-            KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"NewSunX509\");\n-            kmf.init(ks, passphrase);\n-\n-            ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-            ks = null;\n-        } else {\n-            ctx.init(null, tmf.getTrustManagers(), null);\n-        }\n-\n-        return ctx;\n-    }\n-\n@@ -250,4 +121,2 @@\n-        \/*\n-         * Get the customized arguments.\n-         *\/\n-        parseArguments(args);\n+        String tmAlgorithm = args[0];\n+        String enabledProtocol = args[1];\n@@ -258,1 +127,1 @@\n-        new DisabledShortRSAKeys().run();\n+        new DisabledShortRSAKeys(tmAlgorithm, enabledProtocol).run();\n@@ -260,1 +129,0 @@\n-\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSv12\/DisabledShortRSAKeys.java","additions":18,"deletions":150,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,19 @@\n-public interface SSLContextTemplate {\n+public abstract class SSLContextTemplate {\n+\n+    \/*\n+     * =======================================\n+     * Certificates and keys used in the test.\n+     *\/\n+    \/\/ Trusted certificates.\n+    Cert[] TRUSTED_CERTS = {\n+            Cert.CA_ECDSA_SECP256R1,\n+            Cert.CA_RSA_2048,\n+            Cert.CA_DSA_2048 };\n+\n+    \/\/ End entity certificate.\n+    Cert[] END_ENTITY_CERTS = {\n+            Cert.EE_ECDSA_SECP256R1,\n+            Cert.EE_RSA_2048,\n+            Cert.EE_EC_RSA_SECP256R1,\n+            Cert.EE_DSA_2048 };\n+\n@@ -46,1 +64,1 @@\n-    default SSLContext createClientSSLContext() throws Exception {\n+    protected SSLContext createClientSSLContext() throws Exception {\n@@ -48,1 +66,0 @@\n-                createClientKeyManager(),\n@@ -50,0 +67,1 @@\n+                createClientKeyManager(),\n@@ -56,1 +74,1 @@\n-    default SSLContext createServerSSLContext() throws Exception {\n+    protected SSLContext createServerSSLContext() throws Exception {\n@@ -58,1 +76,0 @@\n-                createServerKeyManager(),\n@@ -60,0 +77,1 @@\n+                createServerKeyManager(),\n@@ -63,10 +81,9 @@\n-    \/*\n-     * Create an instance of KeyManager for client use.\n-     *\/\n-    default KeyManager createClientKeyManager() throws Exception {\n-        return createKeyManager(\n-                endEntityCertStrs,\n-                endEntityPrivateKeys,\n-                endEntityPrivateKeyAlgs,\n-                endEntityPrivateKeyNames,\n-                getServerContextParameters());\n+    private SSLContext createSSLContext(TrustManager trustManager,\n+                                        KeyManager keyManager,\n+                                        ContextParameters params) throws Exception {\n+        SSLContext context = SSLContext.getInstance(params.contextProtocol);\n+        context.init(\n+            new KeyManager[] {keyManager},\n+            new TrustManager[] {trustManager},\n+            null);\n+        return  context;\n@@ -75,10 +92,2 @@\n-    \/*\n-     * Create an instance of TrustManager for client use.\n-     *\/\n-    default TrustManager createClientTrustManager() throws Exception {\n-        return createTrustManager(\n-                trustedCertStrs,\n-                getServerContextParameters());\n-    }\n-    \/*\n-     * Create an instance of KeyManager for server use.\n+    \/**\n+     * Creates a TrustManager with TRUSTED_CERTS and client context parameters\n@@ -86,7 +95,2 @@\n-    default KeyManager createServerKeyManager() throws Exception {\n-        return createKeyManager(\n-                endEntityCertStrs,\n-                endEntityPrivateKeys,\n-                endEntityPrivateKeyAlgs,\n-                endEntityPrivateKeyNames,\n-                getServerContextParameters());\n+    protected TrustManager createClientTrustManager() throws Exception {\n+        return createTrustManager(TRUSTED_CERTS, getClientContextParameters());\n@@ -95,2 +99,2 @@\n-    \/*\n-     * Create an instance of TrustManager for server use.\n+    \/**\n+     * Creates a TrustManager with TRUSTED_CERTS and server context parameters\n@@ -98,4 +102,2 @@\n-    default TrustManager createServerTrustManager() throws Exception {\n-        return createTrustManager(\n-                trustedCertStrs,\n-                getServerContextParameters());\n+    protected TrustManager createServerTrustManager() throws Exception {\n+        return createTrustManager(TRUSTED_CERTS, getServerContextParameters());\n@@ -104,2 +106,3 @@\n-    \/*\n-     * The parameters used to configure SSLContext.\n+    \/**\n+     * Creates a TrustManager with the given array of trusted certs and\n+     * context parameters.\n@@ -107,4 +110,4 @@\n-    static final class ContextParameters {\n-        final String contextProtocol;\n-        final String tmAlgorithm;\n-        final String kmAlgorithm;\n+    protected TrustManager createTrustManager(Cert[] trustedCerts,\n+                                              ContextParameters params) throws Exception {\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        ByteArrayInputStream is;\n@@ -112,2 +115,2 @@\n-        ContextParameters(String contextProtocol,\n-                String tmAlgorithm, String kmAlgorithm) {\n+        KeyStore ts = KeyStore.getInstance(\"JKS\");\n+        ts.load(null, null);\n@@ -115,3 +118,13 @@\n-            this.contextProtocol = contextProtocol;\n-            this.tmAlgorithm = tmAlgorithm;\n-            this.kmAlgorithm = kmAlgorithm;\n+        if (trustedCerts != null && trustedCerts.length != 0) {\n+            Certificate[] trustedCert = new Certificate[trustedCerts.length];\n+            for (int i = 0; i < trustedCerts.length; i++) {\n+                is = new ByteArrayInputStream(trustedCerts[i].certStr.getBytes());\n+                try {\n+                    trustedCert[i] = cf.generateCertificate(is);\n+                } finally {\n+                    is.close();\n+                }\n+\n+                ts.setCertificateEntry(\n+                        \"trusted-cert-\" + trustedCerts[i].name(), trustedCert[i]);\n+            }\n@@ -119,0 +132,6 @@\n+\n+        \/\/ Create an SSLContext object.\n+        TrustManagerFactory tmf =\n+                TrustManagerFactory.getInstance(params.tmAlgorithm);\n+        tmf.init(ts);\n+        return tmf.getTrustManagers()[0];\n@@ -121,2 +140,3 @@\n-    \/*\n-     * Get the client side parameters of SSLContext.\n+    \/**\n+     * Create a key manager with Cert.END_ENTITY_CERTS and the client\n+     * context parameters.\n@@ -124,2 +144,2 @@\n-    default ContextParameters getClientContextParameters() {\n-        return new ContextParameters(\"TLS\", \"PKIX\", \"NewSunX509\");\n+    protected KeyManager createClientKeyManager() throws Exception {\n+        return createKeyManager(END_ENTITY_CERTS, getClientContextParameters());\n@@ -128,2 +148,3 @@\n-    \/*\n-     * Get the server side parameters of SSLContext.\n+    \/**\n+     * Create a key manager with Cert.END_ENTITY_CERTS and the server\n+     * context parameters\n@@ -131,2 +152,2 @@\n-    default ContextParameters getServerContextParameters() {\n-        return new ContextParameters(\"TLS\", \"PKIX\", \"NewSunX509\");\n+    protected KeyManager createServerKeyManager() throws Exception {\n+        return createKeyManager(END_ENTITY_CERTS, getServerContextParameters());\n@@ -135,3 +156,3 @@\n-    \/*\n-     * =======================================\n-     * Certificates and keys used in the test.\n+    \/**\n+     * Creates a KeyManager with the given end-entity Cert's and context\n+     * parameters\n@@ -139,133 +160,4 @@\n-    \/\/ Trusted certificates.\n-    final static String[] trustedCertStrs = {\n-        \/\/ SHA256withECDSA, curve prime256v1\n-        \/\/ Validity\n-        \/\/     Not Before: May 22 07:18:16 2018 GMT\n-        \/\/     Not After : May 17 07:18:16 2038 GMT\n-        \/\/ Subject Key Identifier:\n-        \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIIBvjCCAWOgAwIBAgIJAIvFG6GbTroCMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n-        \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n-        \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYTAlVT\\n\" +\n-        \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTBZ\\n\" +\n-        \"MBMGByqGSM49AgEGCCqGSM49AwEHA0IABBz1WeVb6gM2mh85z3QlvaB\/l11b5h0v\\n\" +\n-        \"LIzmkC3DKlVukZT+ltH2Eq1oEkpXuf7QmbM0ibrUgtjsWH3mULfmcWmjUDBOMB0G\\n\" +\n-        \"A1UdDgQWBBRgz71z\/\/oaMNKk7NNJcUbvGjWghjAfBgNVHSMEGDAWgBRgz71z\/\/oa\\n\" +\n-        \"MNKk7NNJcUbvGjWghjAMBgNVHRMEBTADAQH\/MAoGCCqGSM49BAMCA0kAMEYCIQCG\\n\" +\n-        \"6wluh1r2\/T6L31mZXRKf9JxeSf9pIzoLj+8xQeUChQIhAJ09wAi1kV8yePLh2FD9\\n\" +\n-        \"2YEHlSQUAbwwqCDEVB5KxaqP\\n\" +\n-        \"-----END CERTIFICATE-----\",\n-        \/\/ -----BEGIN PRIVATE KEY-----\n-        \/\/ MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQg\/HcHdoLJCdq3haVd\n-        \/\/ XZTSKP00YzM3xX97l98vGL\/RI1KhRANCAAQc9VnlW+oDNpofOc90Jb2gf5ddW+Yd\n-        \/\/ LyyM5pAtwypVbpGU\/pbR9hKtaBJKV7n+0JmzNIm61ILY7Fh95lC35nFp\n-        \/\/ -----END PRIVATE KEY-----\n-\n-        \/\/ SHA256withRSA, 2048 bits\n-        \/\/ Validity\n-        \/\/     Not Before: May 22 07:18:16 2018 GMT\n-        \/\/     Not After : May 17 07:18:16 2038 GMT\n-        \/\/ Subject Key Identifier:\n-        \/\/     0D:DD:93:C9:FE:4B:BD:35:B7:E8:99:78:90:FB:DB:5A:3D:DB:15:4C\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIIDSTCCAjGgAwIBAgIJAI4ZF3iy8zG+MA0GCSqGSIb3DQEBCwUAMDsxCzAJBgNV\\n\" +\n-        \"BAYTAlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\\n\" +\n-        \"aXZjZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYT\\n\" +\n-        \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n-        \"ZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALpMcY7aWieXDEM1\/YJf\\n\" +\n-        \"JW27b4nRIFZyEYhEloyGsKTuQiiQjc8cqRZFNXe2vwziDB4IyTEl0Hjl5QF6ZaQE\\n\" +\n-        \"huPzzwvQm1pv64KrRXrmj3FisQK8B5OWLty9xp6xDqsaMRoyObLK+oIb20T5fSlE\\n\" +\n-        \"evmo1vYjnh8CX0Yzx5Gr5ye6YSEHQvYOWEws8ad17OlyToR2KMeC8w4qo6rs59pW\\n\" +\n-        \"g7Mxn9vo22ImDzrtAbTbXbCias3xlE0Bp0h5luyf+5U4UgksoL9B9r2oP4GrLNEV\\n\" +\n-        \"oJk57t8lwaR0upiv3CnS8LcJELpegZub5ggqLY8ZPYFQPjlK6IzLOm6rXPgZiZ3m\\n\" +\n-        \"RL0CAwEAAaNQME4wHQYDVR0OBBYEFA3dk8n+S701t+iZeJD721o92xVMMB8GA1Ud\\n\" +\n-        \"IwQYMBaAFA3dk8n+S701t+iZeJD721o92xVMMAwGA1UdEwQFMAMBAf8wDQYJKoZI\\n\" +\n-        \"hvcNAQELBQADggEBAJTRC3rKUUhVH07\/1+stUungSYgpM08dY4utJq0BDk36BbmO\\n\" +\n-        \"0AnLDMbkwFdHEoqF6hQIfpm7SQTmXk0Fss6Eejm8ynYr6+EXiRAsaXOGOBCzF918\\n\" +\n-        \"\/RuKOzqABfgSU4UBKECLM5bMfQTL60qx+HdbdVIpnikHZOFfmjCDVxoHsGyXc1LW\\n\" +\n-        \"Jhkht8IGOgc4PMGvyzTtRFjz01kvrVQZ75aN2E0GQv6dCxaEY0i3ypSzjUWAKqDh\\n\" +\n-        \"3e2OLwUSvumcdaxyCdZAOUsN6pDBQ+8VRG7KxnlRlY1SMEk46QgQYLbPDe\/+W\/yH\\n\" +\n-        \"ca4PejicPeh+9xRAwoTpiE2gulfT7Lm+fVM7Ruc=\\n\" +\n-        \"-----END CERTIFICATE-----\",\n-\n-        \/\/ -----BEGIN PRIVATE KEY-----\n-        \/\/ MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQC6THGO2lonlwxD\n-        \/\/ Nf2CXyVtu2+J0SBWchGIRJaMhrCk7kIokI3PHKkWRTV3tr8M4gweCMkxJdB45eUB\n-        \/\/ emWkBIbj888L0Jtab+uCq0V65o9xYrECvAeTli7cvcaesQ6rGjEaMjmyyvqCG9tE\n-        \/\/ +X0pRHr5qNb2I54fAl9GM8eRq+cnumEhB0L2DlhMLPGndezpck6EdijHgvMOKqOq\n-        \/\/ 7OfaVoOzMZ\/b6NtiJg867QG0212womrN8ZRNAadIeZbsn\/uVOFIJLKC\/Qfa9qD+B\n-        \/\/ qyzRFaCZOe7fJcGkdLqYr9wp0vC3CRC6XoGbm+YIKi2PGT2BUD45SuiMyzpuq1z4\n-        \/\/ GYmd5kS9AgMBAAECggEAFHSoU2MuWwJ+2jJnb5U66t2V1bAcuOE1g5zkWvG\/G5z9\n-        \/\/ rq6Qo5kmB8f5ovdx6tw3MGUOklLwnRXBG3RxDJ1iokz3AvkY1clMNsDPlDsUrQKF\n-        \/\/ JSO4QUBQTPSZhnsyfR8XHSU+qJ8Y+ohMfzpVv95BEoCzebtXdVgxVegBlcEmVHo2\n-        \/\/ kMmkRN+bYNsr8eb2r+b0EpyumS39ZgKYh09+cFb78y3T6IFMGcVJTP6nlGBFkmA\/\n-        \/\/ 25pYeCF2tSki08qtMJZQAvKfw0Kviibk7ZxRbJqmc7B1yfnOEHP6ftjuvKl2+RP\/\n-        \/\/ +5P5f8CfIP6gtA0LwSzAqQX\/hfIKrGV5j0pCqrD0kQKBgQDeNR6Xi4sXVq79lihO\n-        \/\/ a1bSeV7r8yoQrS8x951uO+ox+UIZ1MsAULadl7zB\/P0er92p198I9M\/0Jth3KBuS\n-        \/\/ zj45mucvpiiGvmQlMKMEfNq4nN7WHOu55kufPswQB2mR4J3xmwI+4fM\/nl1zc82h\n-        \/\/ De8JSazRldJXNhfx0RGFPmgzbwKBgQDWoVXrXLbCAn41oVnWB8vwY9wjt92ztDqJ\n-        \/\/ HMFA\/SUohjePep9UDq6ooHyAf\/Lz6oE5NgeVpPfTDkgvrCFVKnaWdwALbYoKXT2W\n-        \/\/ 9FlyJox6eQzrtHAacj3HJooXWuXlphKSizntfxj3LtMR9BmrmRJOfK+SxNOVJzW2\n-        \/\/ +MowT20EkwKBgHmpB8jdZBgxI7o\/\/m2BI5Y1UZ1KE5vx1kc7VXzHXSBjYqeV9FeF\n-        \/\/ 2ZZLP9POWh\/1Fh4pzTmwIDODGT2UPhSQy0zq3O0fwkyT7WzXRknsuiwd53u\/dejg\n-        \/\/ iEL2NPAJvulZ2+AuiHo5Z99LK8tMeidV46xoJDDUIMgTG+UQHNGhK5gNAoGAZn\/S\n-        \/\/ Cn7SgMC0CWSvBHnguULXZO9wH1wZAFYNLL44OqwuaIUFBh2k578M9kkke7woTmwx\n-        \/\/ HxQTjmWpr6qimIuY6q6WBN8hJ2Xz\/d1fwhYKzIp20zHuv5KDUlJjbFfqpsuy3u1C\n-        \/\/ kts5zwI7pr1ObRbDGVyOdKcu7HI3QtR5qqyjwaUCgYABo7Wq6oHva\/9V34+G3Goh\n-        \/\/ 63bYGUnRw2l5BD11yhQv8XzGGZFqZVincD8gltNThB0Dc\/BI+qu3ky4YdgdZJZ7K\n-        \/\/ z51GQGtaHEbrHS5caV79yQ8QGY5mUVH3E+VXSxuIqb6pZq2DH4sTAEFHyncddmOH\n-        \/\/ zoXBInYwRG9KE\/Bw5elhUw==\n-        \/\/ -----END PRIVATE KEY-----\n-\n-\n-        \/\/ SHA256withDSA, 2048 bits\n-        \/\/ Validity\n-        \/\/     Not Before: May 22 07:18:18 2018 GMT\n-        \/\/     Not After : May 17 07:18:18 2038 GMT\n-        \/\/ Subject Key Identifier:\n-        \/\/     76:66:9E:F7:3B:DD:45:E5:3B:D9:72:3C:3F:F0:54:39:86:31:26:53\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIIErjCCBFSgAwIBAgIJAOktYLNCbr02MAsGCWCGSAFlAwQDAjA7MQswCQYDVQQG\\n\" +\n-        \"EwJVUzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2\\n\" +\n-        \"Y2UwHhcNMTgwNTIyMDcxODE4WhcNMzgwNTE3MDcxODE4WjA7MQswCQYDVQQGEwJV\\n\" +\n-        \"UzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2Y2Uw\\n\" +\n-        \"ggNHMIICOQYHKoZIzjgEATCCAiwCggEBAO5GyPhSm0ze3LSu+gicdULLj05iOfTL\\n\" +\n-        \"UvZQ29sYz41zmqrLBQbdKiHqgJu2Re9sgTb5suLNjF047TOLPnU3jhPtWm2X8Xzi\\n\" +\n-        \"VGIcHym\/Q\/MeZxStt\/88seqroI3WOKzIML2GcrishT+lcGrtH36Tf1+ue2Snn3PS\\n\" +\n-        \"WyxygNqPjllP5uUjYmFLvAf4QLMldkd\/D2VxcwsHjB8y5iUZsXezc\/LEhRZS\/02m\\n\" +\n-        \"ivqlRw3AMkq\/OVe\/ZtxFWsP0nsfxEGdZuaUFpppGfixxFvymrB3+J51cTt+pZBDq\\n\" +\n-        \"D2y0DYfc+88iCs4jwHTfcDIpLb538HBjBj2rEgtQESQmB0ooD\/+wsPsCIQC1bYch\\n\" +\n-        \"gElNtDYL3FgpLgNSUYp7gIWv9ehaC7LO2z7biQKCAQBitvFOnDkUja8NAF7lDpOV\\n\" +\n-        \"b5ipQ8SicBLW3kQamxhyuyxgZyy\/PojZ\/oPorkqW\/T\/A0rhnG6MssEpAtdiwVB+c\\n\" +\n-        \"rBYGo3bcwmExJhdOJ6dYuKFppPWhCwKMHs9npK+lqBMl8l5j58xlcFeC7ZfGf8GY\\n\" +\n-        \"GkhFW0c44vEQhMMbac6ZTTP4mw+1t7xJfmDMlLEyIpTXaAAk8uoVLWzQWnR40sHi\\n\" +\n-        \"ybvS0u3JxQkb7\/y8tOOZu8qlz\/YOS7lQ6UxUGX27Ce1E0+agfPphetoRAlS1cezq\\n\" +\n-        \"Wa7r64Ga0nkj1kwkcRqjgTiJx0NwnUXr78VAXFhVF95+O3lfqhvdtEGtkhDGPg7N\\n\" +\n-        \"A4IBBgACggEBAMmSHQK0w2i+iqUjOPzn0yNEZrzepLlLeQ1tqtn0xnlv5vBAeefD\\n\" +\n-        \"Pm9dd3tZOjufVWP7hhEz8xPobb1CS4e3vuQiv5UBfhdPL3f3l9T7JMAKPH6C9Vve\\n\" +\n-        \"OQXE5eGqbjsySbcmseHoYUt1WCSnSda1opX8zchX04e7DhGfE2\/L9flpYEoSt8lI\\n\" +\n-        \"vMNjgOwvKdW3yvPt1\/eBBHYNFG5gWPv\/Q5KoyCtHS03uqGm4rNc\/wZTIEEfd66C+\\n\" +\n-        \"QRaUltjOaHmtwOdDHaNqwhYZSVOip+Mo+TfyzHFREcdHLapo7ZXqbdYkRGxRR3d+\\n\" +\n-        \"3DfHaraJO0OKoYlPkr3JMvM\/MSGR9AnZOcejUDBOMB0GA1UdDgQWBBR2Zp73O91F\\n\" +\n-        \"5TvZcjw\/8FQ5hjEmUzAfBgNVHSMEGDAWgBR2Zp73O91F5TvZcjw\/8FQ5hjEmUzAM\\n\" +\n-        \"BgNVHRMEBTADAQH\/MAsGCWCGSAFlAwQDAgNHADBEAiBzriYE41M2y9Hy5ppkL0Qn\\n\" +\n-        \"dIlNc8JhXT\/PHW7GDtViagIgMko8Qoj9gDGPK3+O9E8DC3wGiiF9CObM4LN387ok\\n\" +\n-        \"J+g=\\n\" +\n-        \"-----END CERTIFICATE-----\"\n-        \/\/ -----BEGIN PRIVATE KEY-----\n-        \/\/ MIICZQIBADCCAjkGByqGSM44BAEwggIsAoIBAQDuRsj4UptM3ty0rvoInHVCy49O\n-        \/\/ Yjn0y1L2UNvbGM+Nc5qqywUG3Soh6oCbtkXvbIE2+bLizYxdOO0ziz51N44T7Vpt\n-        \/\/ l\/F84lRiHB8pv0PzHmcUrbf\/PLHqq6CN1jisyDC9hnK4rIU\/pXBq7R9+k39frntk\n-        \/\/ p59z0lsscoDaj45ZT+blI2JhS7wH+ECzJXZHfw9lcXMLB4wfMuYlGbF3s3PyxIUW\n-        \/\/ Uv9Npor6pUcNwDJKvzlXv2bcRVrD9J7H8RBnWbmlBaaaRn4scRb8pqwd\/iedXE7f\n-        \/\/ qWQQ6g9stA2H3PvPIgrOI8B033AyKS2+d\/BwYwY9qxILUBEkJgdKKA\/\/sLD7AiEA\n-        \/\/ tW2HIYBJTbQ2C9xYKS4DUlGKe4CFr\/XoWguyzts+24kCggEAYrbxTpw5FI2vDQBe\n-        \/\/ 5Q6TlW+YqUPEonAS1t5EGpsYcrssYGcsvz6I2f6D6K5Klv0\/wNK4ZxujLLBKQLXY\n-        \/\/ sFQfnKwWBqN23MJhMSYXTienWLihaaT1oQsCjB7PZ6SvpagTJfJeY+fMZXBXgu2X\n-        \/\/ xn\/BmBpIRVtHOOLxEITDG2nOmU0z+JsPtbe8SX5gzJSxMiKU12gAJPLqFS1s0Fp0\n-        \/\/ eNLB4sm70tLtycUJG+\/8vLTjmbvKpc\/2Dku5UOlMVBl9uwntRNPmoHz6YXraEQJU\n-        \/\/ tXHs6lmu6+uBmtJ5I9ZMJHEao4E4icdDcJ1F6+\/FQFxYVRfefjt5X6ob3bRBrZIQ\n-        \/\/ xj4OzQQjAiEAsceWOM8do4etxp2zgnoNXV8PUUyqWhz1+0srcKV7FR4=\n-        \/\/ -----END PRIVATE KEY-----\n-    };\n+    protected KeyManager createKeyManager(Cert[] endEntityCerts,\n+                                          ContextParameters params) throws Exception {\n+        KeyStore ks = null;     \/\/ key store\n+        char[] passphrase = \"passphrase\".toCharArray();\n@@ -273,183 +165,40 @@\n-    \/\/ End entity certificate.\n-    final static String[] endEntityCertStrs = {\n-        \/\/ SHA256withECDSA, curve prime256v1\n-        \/\/ Validity\n-        \/\/     Not Before: May 22 07:18:16 2018 GMT\n-        \/\/     Not After : May 17 07:18:16 2038 GMT\n-        \/\/ Authority Key Identifier:\n-        \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIIBqjCCAVCgAwIBAgIJAPLY8qZjgNRAMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n-        \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n-        \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYTAlVT\\n\" +\n-        \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTEY\\n\" +\n-        \"MBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcD\\n\" +\n-        \"QgAEb+9n05qfXnfHUb0xtQJNS4JeSi6IjOfW5NqchvKnfJey9VkJzR7QHLuOESdf\\n\" +\n-        \"xlR7q8YIWgih3iWLGfB+wxHiOqMjMCEwHwYDVR0jBBgwFoAUYM+9c\/\/6GjDSpOzT\\n\" +\n-        \"SXFG7xo1oIYwCgYIKoZIzj0EAwIDSAAwRQIgWpRegWXMheiD3qFdd8kMdrkLxRbq\\n\" +\n-        \"1zj8nQMEwFTUjjQCIQDRIrAjZX+YXHN9b0SoWWLPUq0HmiFIi8RwMnO\/\/wJIGQ==\\n\" +\n-        \"-----END CERTIFICATE-----\",\n-\n-        \/\/ SHA256withRSA, 2048 bits\n-        \/\/ Validity\n-        \/\/     Not Before: May 22 07:18:16 2018 GMT\n-        \/\/     Not After : May 17 07:18:16 2038 GMT\n-        \/\/ Authority Key Identifier:\n-        \/\/     0D:DD:93:C9:FE:4B:BD:35:B7:E8:99:78:90:FB:DB:5A:3D:DB:15:4C\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIIDNjCCAh6gAwIBAgIJAO2+yPcFryUTMA0GCSqGSIb3DQEBCwUAMDsxCzAJBgNV\\n\" +\n-        \"BAYTAlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\\n\" +\n-        \"aXZjZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYT\\n\" +\n-        \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n-        \"ZTEYMBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MIIBIjANBgkqhkiG9w0BAQEFAAOC\\n\" +\n-        \"AQ8AMIIBCgKCAQEAszfBobWfZIp8AgC6PiWDDavP65mSvgCXUGxACbxVNAfkLhNR\\n\" +\n-        \"QOsHriRB3X1Q3nvO9PetC6wKlvE9jlnDDj7D+1j1r1CHO7ms1fq8rfcQYdkanDtu\\n\" +\n-        \"4AlHo8v+SSWX16MIXFRYDj2VVHmyPtgbltcg4zGAuwT746FdLI94uXjJjq1IOr\/v\\n\" +\n-        \"0VIlwE5ORWH5Xc+5Tj+oFWK0E4a4GHDgtKKhn2m72hN56\/GkPKGkguP5NRS1qYYV\\n\" +\n-        \"\/EFkdyQMOV8J1M7HaicSft4OL6eKjTrgo93+kHk+tv0Dc6cpVBnalX3TorG8QI6B\\n\" +\n-        \"cHj1XQd78oAlAC+\/jF4pc0mwi0un49kdK9gRfQIDAQABoyMwITAfBgNVHSMEGDAW\\n\" +\n-        \"gBQN3ZPJ\/ku9NbfomXiQ+9taPdsVTDANBgkqhkiG9w0BAQsFAAOCAQEApXS0nKwm\\n\" +\n-        \"Kp8gpmO2yG1rpd1+2wBABiMU4JZaTqmma24DQ3RzyS+V2TeRb29dl5oTUEm98uc0\\n\" +\n-        \"GPZvhK8z5RFr4YE17dc04nI\/VaNDCw4y1NALXGs+AHkjoPjLyGbWpi1S+gfq2sNB\\n\" +\n-        \"Ekkjp6COb\/cb9yiFXOGVls7UOIjnVZVd0r7KaPFjZhYh82\/f4PA\/A1SnIKd1+nfH\\n\" +\n-        \"2yk7mSJNC7Z3qIVDL8MM\/jBVwiC3uNe5GPB2uwhd7k5LGAVN3j4HQQGB0Sz+VC1h\\n\" +\n-        \"92oi6xDa+YBva2fvHuCd8P50DDjxmp9CemC7rnZ5j8egj88w14X44Xjb\/Fd\/ApG9\\n\" +\n-        \"e57NnbT7KM+Grw==\\n\" +\n-        \"-----END CERTIFICATE-----\",\n-\n-        \/\/ SHA256withRSA, curv prime256v1\n-        \/\/ Validity\n-        \/\/     Not Before: May 22 07:18:16 2018 GMT\n-        \/\/     Not After : May 21 07:18:16 2028 GMT\n-        \/\/ Authority Key Identifier:\n-        \/\/     0D:DD:93:C9:FE:4B:BD:35:B7:E8:99:78:90:FB:DB:5A:3D:DB:15:4C\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICazCCAVOgAwIBAgIJAO2+yPcFryUUMA0GCSqGSIb3DQEBCwUAMDsxCzAJBgNV\\n\" +\n-        \"BAYTAlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\\n\" +\n-        \"aXZjZTAeFw0xODA1MjIwNzE4MTZaFw0yODA1MjEwNzE4MTZaMFUxCzAJBgNVBAYT\\n\" +\n-        \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n-        \"ZTEYMBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0D\\n\" +\n-        \"AQcDQgAE59MERNTlVZ1eeps8Z3Oue5ZkgQdPtD+WIE6tj3PbIKpxGPDxvfNP959A\\n\" +\n-        \"yQjEK\/ehWQVrCMmNoEkIzY+IIBgB06MjMCEwHwYDVR0jBBgwFoAUDd2Tyf5LvTW3\\n\" +\n-        \"6Jl4kPvbWj3bFUwwDQYJKoZIhvcNAQELBQADggEBAFOTVEqs70ykhZiIdrEsF1Ra\\n\" +\n-        \"I3B2rLvwXZk52uSltk2\/bzVvewA577ZCoxQ1pL7ynkisPfBN1uVYtHjM1VA3RC+4\\n\" +\n-        \"+TAK78dnI7otYjWoHp5rvs4l6c\/IbOspS290IlNuDUxMErEm5wxIwj+Aukx\/1y68\\n\" +\n-        \"hOyCvHBLMY2c1LskH1MMBbDuS1aI+lnGpToi+MoYObxGcV458vxuT8+wwV8Fkpvd\\n\" +\n-        \"ll8IIFmeNPRv+1E+lXbES6CSNCVaZ\/lFhPgdgYKleN7sfspiz50DG4dqafuEAaX5\\n\" +\n-        \"xaK1NWXJxTRz0ROH\/IUziyuDW6jphrlgit4+3NCzp6vP9hAJQ8Vhcj0n15BKHIQ=\\n\" +\n-        \"-----END CERTIFICATE-----\",\n-\n-        \/\/ SHA256withDSA, 2048 bits\n-        \/\/ Validity\n-        \/\/     Not Before: May 22 07:18:20 2018 GMT\n-        \/\/     Not After : May 17 07:18:20 2038 GMT\n-        \/\/ Authority Key Identifier:\n-        \/\/     76:66:9E:F7:3B:DD:45:E5:3B:D9:72:3C:3F:F0:54:39:86:31:26:53\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIIEnDCCBEGgAwIBAgIJAP\/jh1qVhNVjMAsGCWCGSAFlAwQDAjA7MQswCQYDVQQG\\n\" +\n-        \"EwJVUzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2\\n\" +\n-        \"Y2UwHhcNMTgwNTIyMDcxODIwWhcNMzgwNTE3MDcxODIwWjBVMQswCQYDVQQGEwJV\\n\" +\n-        \"UzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2Y2Ux\\n\" +\n-        \"GDAWBgNVBAMMD1JlZ3Jlc3Npb24gVGVzdDCCA0cwggI6BgcqhkjOOAQBMIICLQKC\\n\" +\n-        \"AQEAmlavgoJrMcjqWRVcDE2dmWAPREgnzQvneEDef68cprDzjSwvOs5QeFyx75ib\\n\" +\n-        \"ado1e6jO\/rW1prCGWHDD1oA\/Tn4Pk3vu0nUxzvl1qATc+aJbpUU5Op0bvp6LbCsQ\\n\" +\n-        \"QslV9FeRh7Eb7bP6gpc\/kHCBzEgC1VCK7prccXWy+t6SMOHbND3h+UbckfSaUuaV\\n\" +\n-        \"sVJNTD1D6GElfRj4Nmz1BGPfSYvKorwNZEU3gXwFgtDoAcGx7tcyClLpDHfqRfw\/\\n\" +\n-        \"7yiqLyeiP7D4hl5lMNouJWDlAdMFp0FMgS3s9VDFinIcr6VtBWMTG7+4+czHAB+3\\n\" +\n-        \"fvrwlqNzhBn3uFHrekN\/w8fNxwIhAJo7Sae1za7IMW0Q6hE5B4b+s2B\/FaKPoA4E\\n\" +\n-        \"jtZu13B9AoIBAQCOZqLMKfvqZWUgT0PQ3QjR7dAFdd06I9Y3+TOQzZk1+j+vw\/6E\\n\" +\n-        \"X4vFItX4gihb\/u5Q9CdmpwhVGi7bvo+7+\/IKeTgoQ6f5+PSug7SrWWUQ5sPwaZui\\n\" +\n-        \"zXZJ5nTeZDucFc2yFx0wgnjbPwiUxZklOT7xGiOMtzOTa2koCz5KuIBL+\/wPKKxm\\n\" +\n-        \"ypo9VoY9xfbdU6LMXZv\/lpD5XTM9rYHr\/vUTNkukvV6Hpm0YMEWhVZKUJiqCqTqG\\n\" +\n-        \"XHaleOxSw6uQWB\/+TznifcC7gB48UOQjCqOKf5VuwQneJLhlhU\/jhRV3xtr+hLZa\\n\" +\n-        \"hW1wYhVi8cjLDrZFKlgEQqhB4crnJU0mJY+tA4IBBQACggEAID0ezl00\/X8mv7eb\\n\" +\n-        \"bzovum1+DEEP7FM57k6HZEG2N3ve4CW+0m9Cd+cWPz8wkZ+M0j\/Eqa6F0IdbkXEc\\n\" +\n-        \"Q7CuzvUyJ57xQ3L\/WCgXsiS+Bh8O4Mz7GwW22CGmHqafbVv+hKBfr8MkskO6GJUt\\n\" +\n-        \"SUF\/CVLzB4gMIvZMH26tBP2xK+i7FeEK9kT+nGdzQSZBAhFYpEVCBplHZO24\/OYq\\n\" +\n-        \"1DNoU327nUuXIhmsfA8N0PjiWbIZIjTPwBGr9H0LpATI7DIDNcvRRvtROP+pBU9y\\n\" +\n-        \"fuykPkptg9C0rCM9t06bukpOSaEz\/2VIQdLE8fHYFA6pHZ6CIc2+5cfvMgTPhcjz\\n\" +\n-        \"W2jCt6MjMCEwHwYDVR0jBBgwFoAUdmae9zvdReU72XI8P\/BUOYYxJlMwCwYJYIZI\\n\" +\n-        \"AWUDBAMCA0gAMEUCIQCeI5fN08b9BpOaHdc3zQNGjp24FOL\/RxlBLeBAorswJgIg\\n\" +\n-        \"JEZ8DhYxQy1O7mmZ2UIT7op6epWMB4dENjs0qWPmcKo=\\n\" +\n-        \"-----END CERTIFICATE-----\"\n-    };\n-\n-    \/\/ Private key in the format of PKCS#8.\n-    final static String[] endEntityPrivateKeys = {\n-        \/\/\n-        \/\/ EC private key related to cert endEntityCertStrs[0].\n-        \/\/\n-        \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgn5K03bpTLjEtFQRa\\n\" +\n-        \"JUtx22gtmGEvvSUSQdimhGthdtihRANCAARv72fTmp9ed8dRvTG1Ak1Lgl5KLoiM\\n\" +\n-        \"59bk2pyG8qd8l7L1WQnNHtAcu44RJ1\/GVHurxghaCKHeJYsZ8H7DEeI6\",\n-\n-        \/\/\n-        \/\/ RSA private key related to cert endEntityCertStrs[1].\n-        \/\/\n-        \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCzN8GhtZ9kinwC\\n\" +\n-        \"ALo+JYMNq8\/rmZK+AJdQbEAJvFU0B+QuE1FA6weuJEHdfVDee870960LrAqW8T2O\\n\" +\n-        \"WcMOPsP7WPWvUIc7uazV+ryt9xBh2RqcO27gCUejy\/5JJZfXowhcVFgOPZVUebI+\\n\" +\n-        \"2BuW1yDjMYC7BPvjoV0sj3i5eMmOrUg6v+\/RUiXATk5FYfldz7lOP6gVYrQThrgY\\n\" +\n-        \"cOC0oqGfabvaE3nr8aQ8oaSC4\/k1FLWphhX8QWR3JAw5XwnUzsdqJxJ+3g4vp4qN\\n\" +\n-        \"OuCj3f6QeT62\/QNzpylUGdqVfdOisbxAjoFwePVdB3vygCUAL7+MXilzSbCLS6fj\\n\" +\n-        \"2R0r2BF9AgMBAAECggEASIkPkMCuw4WdTT44IwERus3IOIYOs2IP3BgEDyyvm4B6\\n\" +\n-        \"JP\/iihDWKfA4zEl1Gqcni1RXMHswSglXra682J4kui02Ov+vzEeJIY37Ibn2YnP5\\n\" +\n-        \"ZjRT2s9GtI\/S2o4hl8A\/mQb2IMViFC+xKehTukhV4j5d6NPKk0XzLR7gcMjnYxwn\\n\" +\n-        \"l21fS6D2oM1xRG\/di7sL+uLF8EXLRzfiWDNi12uQv4nwtxPKvuKhH6yzHt7YqMH0\\n\" +\n-        \"46pmDKDaxV4w1JdycjCb6NrCJOYZygoQobuZqOQ30UZoZsPJrtovkncFr1e+lNcO\\n\" +\n-        \"+aWDfOLCtTH046dEQh5oCShyXMybNlry\/QHsOtHOwQKBgQDh2iIjs+FPpQy7Z3EX\\n\" +\n-        \"DGEvHYqPjrYO9an2KSRr1m9gzRlWYxKY46WmPKwjMerYtra0GP+TBHrgxsfO8tD2\\n\" +\n-        \"wUAII6sd1qup0a\/Sutgf2JxVilLykd0+Ge4\/Cs51tCdJ8EqDV2B6WhTewOY2EGvg\\n\" +\n-        \"JiKYkeNwgRX\/9M9CFSAMAk0hUQKBgQDLJAartL3DoGUPjYtpJnfgGM23yAGl6G5r\\n\" +\n-        \"NSXDn80BiYIC1p0bG3N0xm3yAjqOtJAUj9jZbvDNbCe3GJfLARMr23legX4tRrgZ\\n\" +\n-        \"nEdKnAFKAKL01oM+A5\/lHdkwaZI9yyv+hgSVdYzUjB8rDmzeVQzo1BT7vXypt2yV\\n\" +\n-        \"6O1OnUpCbQKBgA\/0rzDChopv6KRcvHqaX0tK1P0rYeVQqb9ATNhpf9jg5Idb3HZ8\\n\" +\n-        \"rrk91BNwdVz2G5ZBpdynFl9G69rNAMJOCM4KZw5mmh4XOEq09Ivba8AHU7DbaTv3\\n\" +\n-        \"7QL7KnbaUWRB26HHzIMYVh0el6T+KADf8NXCiMTr+bfpfbL3dxoiF3zhAoGAbCJD\\n\" +\n-        \"Qse1dBs\/cKYCHfkSOsI5T6kx52Tw0jS6Y4X\/FOBjyqr\/elyEexbdk8PH9Ar931Qr\\n\" +\n-        \"NKMvn8oA4iA\/PRrXX7M2yi3YQrWwbkGYWYjtzrzEAdzmg+5eARKAeJrZ8\/bg9l3U\\n\" +\n-        \"ttKaItJsDPlizn8rngy3FsJpR9aSAMK6\/+wOiYkCgYEA1tZkI1rD1W9NYZtbI9BE\\n\" +\n-        \"qlJVFi2PBOJMKNuWdouPX3HLQ72GJSQff2BFzLTELjweVVJ0SvY4IipzpQOHQOBy\\n\" +\n-        \"5qh\/p6izXJZh3IHtvwVBjHoEVplg1b2+I5e3jDCfqnwcQw82dW5SxOJMg1h\/BD0I\\n\" +\n-        \"qAL3go42DYeYhu\/WnECMeis=\",\n-\n-        \/\/\n-        \/\/ EC private key related to cert endEntityCertStrs[2].\n-        \/\/\n-        \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgGVc7hICpmp91jbYe\\n\" +\n-        \"nrr8nYHD37RZP3VENY+szuA7WjuhRANCAATn0wRE1OVVnV56mzxnc657lmSBB0+0\\n\" +\n-        \"P5YgTq2Pc9sgqnEY8PG980\/3n0DJCMQr96FZBWsIyY2gSQjNj4ggGAHT\",\n-\n-        \/\/\n-        \/\/ DSA private key related to cert endEntityCertStrs[3].\n-        \/\/\n-        \"MIICZQIBADCCAjoGByqGSM44BAEwggItAoIBAQCaVq+CgmsxyOpZFVwMTZ2ZYA9E\\n\" +\n-        \"SCfNC+d4QN5\/rxymsPONLC86zlB4XLHvmJtp2jV7qM7+tbWmsIZYcMPWgD9Ofg+T\\n\" +\n-        \"e+7SdTHO+XWoBNz5olulRTk6nRu+notsKxBCyVX0V5GHsRvts\/qClz+QcIHMSALV\\n\" +\n-        \"UIrumtxxdbL63pIw4ds0PeH5RtyR9JpS5pWxUk1MPUPoYSV9GPg2bPUEY99Ji8qi\\n\" +\n-        \"vA1kRTeBfAWC0OgBwbHu1zIKUukMd+pF\/D\/vKKovJ6I\/sPiGXmUw2i4lYOUB0wWn\\n\" +\n-        \"QUyBLez1UMWKchyvpW0FYxMbv7j5zMcAH7d++vCWo3OEGfe4Uet6Q3\/Dx83HAiEA\\n\" +\n-        \"mjtJp7XNrsgxbRDqETkHhv6zYH8Voo+gDgSO1m7XcH0CggEBAI5moswp++plZSBP\\n\" +\n-        \"Q9DdCNHt0AV13Toj1jf5M5DNmTX6P6\/D\/oRfi8Ui1fiCKFv+7lD0J2anCFUaLtu+\\n\" +\n-        \"j7v78gp5OChDp\/n49K6DtKtZZRDmw\/Bpm6LNdknmdN5kO5wVzbIXHTCCeNs\/CJTF\\n\" +\n-        \"mSU5PvEaI4y3M5NraSgLPkq4gEv7\/A8orGbKmj1Whj3F9t1Tosxdm\/+WkPldMz2t\\n\" +\n-        \"gev+9RM2S6S9XoembRgwRaFVkpQmKoKpOoZcdqV47FLDq5BYH\/5POeJ9wLuAHjxQ\\n\" +\n-        \"5CMKo4p\/lW7BCd4kuGWFT+OFFXfG2v6EtlqFbXBiFWLxyMsOtkUqWARCqEHhyucl\\n\" +\n-        \"TSYlj60EIgIgLfA75+8KcKxdN8mr6gzGjQe7jPFGG42Ejhd7Q2F4wuw=\"\n-        };\n-\n-    \/\/ Private key algorithm of endEntityPrivateKeys.\n-    final static String[] endEntityPrivateKeyAlgs = {\n-        \"EC\",\n-        \"RSA\",\n-        \"EC\",\n-        \"DSA\",\n-    };\n-\n-    \/\/ Private key names of endEntityPrivateKeys.\n-    static final String[] endEntityPrivateKeyNames = {\n-        \"ecdsa\",\n-        \"rsa\",\n-        \"ec-rsa\",\n-        \"dsa\",\n-    };\n+        if (endEntityCerts == null || endEntityCerts.length == 0) {\n+            return null;\n+\n+        } else {\n+            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+            ks = KeyStore.getInstance(\"JKS\");\n+            ks.load(null, null);\n+\n+            for (Cert endEntityCert : endEntityCerts) {\n+                \/\/ generate the private key.\n+                PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n+                        Base64.getMimeDecoder().decode(endEntityCert.privKeyStr));\n+                KeyFactory kf =\n+                        KeyFactory.getInstance(\n+                                endEntityCert.keyAlgo);\n+                PrivateKey priKey = kf.generatePrivate(priKeySpec);\n+\n+                \/\/ generate certificate chain\n+                ByteArrayInputStream is = new ByteArrayInputStream(\n+                        endEntityCert.certStr.getBytes());\n+                Certificate keyCert = null;\n+                try {\n+                    keyCert = cf.generateCertificate(is);\n+                } finally {\n+                    is.close();\n+                }\n+\n+                Certificate[] chain = new Certificate[]{keyCert};\n+\n+                \/\/ import the key entry.\n+                ks.setKeyEntry(\"cert-\" + endEntityCert.name(),\n+                        priKey, passphrase, chain);\n+            }\n+\n+            KeyManagerFactory kmf =\n+                    KeyManagerFactory.getInstance(params.kmAlgorithm);\n+            kmf.init(ks, passphrase);\n+            return kmf.getKeyManagers()[0];\n+        }\n+    }\n@@ -460,3 +209,3 @@\n-    private SSLContext createSSLContext(\n-            KeyManager keyManager,\n-            TrustManager trustManager,\n+    protected SSLContext createSSLContext(\n+            Cert[] trustedCerts,\n+            Cert[] endEntityCerts,\n@@ -465,9 +214,2 @@\n-        SSLContext context = SSLContext.getInstance(params.contextProtocol);\n-        context.init(\n-                new KeyManager[] {\n-                        keyManager\n-                    },\n-                new TrustManager[] {\n-                        trustManager\n-                    },\n-                null);\n+        \/\/ Generate certificate from cert string.\n+        TrustManager tm = createTrustManager(trustedCerts, params);\n@@ -475,1 +217,5 @@\n-        return  context;\n+        KeyManager km = createKeyManager(endEntityCerts, params);\n+\n+        SSLContext context = SSLContext.getInstance(params.contextProtocol);\n+        context.init(km == null ? null : new KeyManager[]{km}, new TrustManager[]{tm}, null);\n+        return context;\n@@ -479,1 +225,1 @@\n-     * Create an instance of KeyManager with the specified key materials.\n+     * The parameters used to configure SSLContext.\n@@ -481,36 +227,4 @@\n-    static KeyManager createKeyManager(\n-            String[] keyMaterialCerts,\n-            String[] keyMaterialKeys,\n-            String[] keyMaterialKeyAlgs,\n-            String[] keyMaterialKeyNames,\n-            ContextParameters params) throws Exception {\n-\n-        char[] passphrase = \"passphrase\".toCharArray();\n-\n-        \/\/ Generate certificate from cert string.\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        \/\/ Import the key materials.\n-        \/\/\n-        \/\/ Note that certification paths bigger than one are not supported yet.\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        ks.load(null, null);\n-        ByteArrayInputStream is;\n-        for (int i = 0; i < keyMaterialCerts.length; i++) {\n-            String keyCertStr = keyMaterialCerts[i];\n-\n-            \/\/ generate the private key.\n-            PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n-                    Base64.getMimeDecoder().decode(keyMaterialKeys[i]));\n-            KeyFactory kf =\n-                    KeyFactory.getInstance(keyMaterialKeyAlgs[i]);\n-            PrivateKey priKey = kf.generatePrivate(priKeySpec);\n-\n-            \/\/ generate certificate chain\n-            is = new ByteArrayInputStream(keyCertStr.getBytes());\n-            Certificate keyCert = null;\n-            try {\n-                keyCert = cf.generateCertificate(is);\n-            } finally {\n-                is.close();\n-            }\n+    static final class ContextParameters {\n+        final String contextProtocol;\n+        final String tmAlgorithm;\n+        final String kmAlgorithm;\n@@ -518,1 +232,2 @@\n-            Certificate[] chain = new Certificate[] { keyCert };\n+        ContextParameters(String contextProtocol,\n+                String tmAlgorithm, String kmAlgorithm) {\n@@ -520,3 +235,3 @@\n-            \/\/ import the key entry.\n-            ks.setKeyEntry(\"cert-\" + keyMaterialKeyNames[i],\n-                    priKey, passphrase, chain);\n+            this.contextProtocol = contextProtocol;\n+            this.tmAlgorithm = tmAlgorithm;\n+            this.kmAlgorithm = kmAlgorithm;\n@@ -524,8 +239,0 @@\n-\n-        KeyManagerFactory kmf =\n-                KeyManagerFactory.getInstance(params.kmAlgorithm);\n-        kmf.init(ks, passphrase);\n-\n-        KeyManager[] km = kmf.getKeyManagers();\n-\n-        return km[0];\n@@ -535,1 +242,1 @@\n-     * Create an instance of TrustManager with the specified trust materials.\n+     * Get the client side parameters of SSLContext.\n@@ -537,6 +244,3 @@\n-    static TrustManager createTrustManager(\n-            String[] trustedMaterials,\n-            ContextParameters params) throws Exception {\n-\n-        \/\/ Generate certificate from cert string.\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+    protected ContextParameters getClientContextParameters() {\n+        return new ContextParameters(\"TLS\", \"PKIX\", \"NewSunX509\");\n+    }\n@@ -544,3 +248,6 @@\n-        \/\/ Import the trusted certs.\n-        KeyStore ts = KeyStore.getInstance(\"PKCS12\");\n-        ts.load(null, null);\n+    \/*\n+     * Get the server side parameters of SSLContext.\n+     *\/\n+    protected ContextParameters getServerContextParameters() {\n+        return new ContextParameters(\"TLS\", \"PKIX\", \"NewSunX509\");\n+    }\n@@ -548,12 +255,0 @@\n-        Certificate[] trustedCert =\n-                new Certificate[trustedMaterials.length];\n-        ByteArrayInputStream is;\n-        for (int i = 0; i < trustedMaterials.length; i++) {\n-            String trustedCertStr = trustedMaterials[i];\n-\n-            is = new ByteArrayInputStream(trustedCertStr.getBytes());\n-            try {\n-                trustedCert[i] = cf.generateCertificate(is);\n-            } finally {\n-                is.close();\n-            }\n@@ -561,1 +256,695 @@\n-            ts.setCertificateEntry(\"trusted-cert-\" + i, trustedCert[i]);\n+    enum Cert {\n+\n+        CA_ECDSA_SECP256R1(\n+                \"EC\",\n+                \/\/ SHA256withECDSA, curve secp256r1\n+                \/\/ Validity\n+                \/\/     Not Before: May 22 07:18:16 2018 GMT\n+                \/\/     Not After : May 17 07:18:16 2038 GMT\n+                \/\/ Subject Key Identifier:\n+                \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIIBvjCCAWOgAwIBAgIJAIvFG6GbTroCMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n+                \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+                \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYTAlVT\\n\" +\n+                \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTBZ\\n\" +\n+                \"MBMGByqGSM49AgEGCCqGSM49AwEHA0IABBz1WeVb6gM2mh85z3QlvaB\/l11b5h0v\\n\" +\n+                \"LIzmkC3DKlVukZT+ltH2Eq1oEkpXuf7QmbM0ibrUgtjsWH3mULfmcWmjUDBOMB0G\\n\" +\n+                \"A1UdDgQWBBRgz71z\/\/oaMNKk7NNJcUbvGjWghjAfBgNVHSMEGDAWgBRgz71z\/\/oa\\n\" +\n+                \"MNKk7NNJcUbvGjWghjAMBgNVHRMEBTADAQH\/MAoGCCqGSM49BAMCA0kAMEYCIQCG\\n\" +\n+                \"6wluh1r2\/T6L31mZXRKf9JxeSf9pIzoLj+8xQeUChQIhAJ09wAi1kV8yePLh2FD9\\n\" +\n+                \"2YEHlSQUAbwwqCDEVB5KxaqP\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQg\/HcHdoLJCdq3haVd\\n\" +\n+                \"XZTSKP00YzM3xX97l98vGL\/RI1KhRANCAAQc9VnlW+oDNpofOc90Jb2gf5ddW+Yd\\n\" +\n+                \"LyyM5pAtwypVbpGU\/pbR9hKtaBJKV7n+0JmzNIm61ILY7Fh95lC35nFp\"),\n+\n+        CA_ECDSA_SECP384R1(\n+                \"EC\",\n+                \/\/ SHA384withECDSA, curve secp384r1\n+                \/\/ Validity\n+                \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n+                \/\/     Not After : Jun 19 08:15:06 2039 GMT\n+                \/\/ Subject Key Identifier:\n+                \/\/     0a:93:a9:a0:bf:e7:d5:48:9d:4f:89:15:c6:51:98:80:05:51:4e:4e\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIICCDCCAY6gAwIBAgIUCpOpoL\/n1UidT4kVxlGYgAVRTk4wCgYIKoZIzj0EAwMw\\n\" +\n+                \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n+                \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowOzEL\\n\" +\n+                \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n+                \"dCBTZXJpdmNlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAENVQN1wXWFdgC6u\/dDdiC\\n\" +\n+                \"y+WtMTF66oL\/0BSm+1ZqsogamzCryawOcHgiuXgWzx5CQ3LuOC+tDFyXpGfHuCvb\\n\" +\n+                \"dkzxPrP5n9NrR8\/uRPe5l1KOUbchviU8z9cTP+LZxnZDo1MwUTAdBgNVHQ4EFgQU\\n\" +\n+                \"SktSFArR1p\/5mXV0kyo0RxIVa\/UwHwYDVR0jBBgwFoAUSktSFArR1p\/5mXV0kyo0\\n\" +\n+                \"RxIVa\/UwDwYDVR0TAQH\/BAUwAwEB\/zAKBggqhkjOPQQDAwNoADBlAjBZvoNmq3\/v\\n\" +\n+                \"RD2gBTyvxjS9h0rsMRLHDnvul\/KWngytwGPTOBo0Y8ixQXSjdKoc3rkCMQDkiNgx\\n\" +\n+                \"IDxuHedmrLQKIPnVcthTmwv7\/\/jHiqGoKofwChMo2a1P+DQdhszmeHD\/ARQ=\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDChlbt0NF8oIKODSxn2\\n\" +\n+                \"WXCXuJm3z78LRkzYQS3Nx5NMjei5ytkFZz4qvD4XXMWlTEyhZANiAAQ1VA3XBdYV\\n\" +\n+                \"2ALq790N2ILL5a0xMXrqgv\/QFKb7VmqyiBqbMKvJrA5weCK5eBbPHkJDcu44L60M\\n\" +\n+                \"XJekZ8e4K9t2TPE+s\/mf02tHz+5E97mXUo5RtyG+JTzP1xM\/4tnGdkM=\"),\n+\n+        CA_ECDSA_SECP521R1(\n+                \"EC\",\n+                \/\/ SHA512withECDSA, curve secp521r1\n+                \/\/ Validity\n+                \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n+                \/\/     Not After : Jun 19 08:15:06 2039 GMT\n+                \/\/ Subject Key Identifier:\n+                \/\/     25:ca:68:76:6d:29:17:9b:71:78:45:2d:d4:c6:e4:5d:fe:25:ff:90\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIICUzCCAbSgAwIBAgIUJcpodm0pF5txeEUt1MbkXf4l\/5AwCgYIKoZIzj0EAwQw\\n\" +\n+                \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n+                \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowOzEL\\n\" +\n+                \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n+                \"dCBTZXJpdmNlMIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQAmFD5VmB2MdyJ6k+E\\n\" +\n+                \"eP4JncrE65ySL07gVmFwnr8otOt3NtRAyzmviMNNXXjo5R5NqNjKP4pr92JjT0sO\\n\" +\n+                \"D65yngkBtH151Ev\/fiKPLxkXL9GzfKdWHVhDX7Zg6DUydzukzZV2\/dIyloAIqwlz\\n\" +\n+                \"QVKJqT7RypDufdng8hnE9YfKo6ypZiujUzBRMB0GA1UdDgQWBBRAIrxa7WqtqUCe\\n\" +\n+                \"HFuKREDC92spvTAfBgNVHSMEGDAWgBRAIrxa7WqtqUCeHFuKREDC92spvTAPBgNV\\n\" +\n+                \"HRMBAf8EBTADAQH\/MAoGCCqGSM49BAMEA4GMADCBiAJCAe22iirZnODCmlpxcv57\\n\" +\n+                \"3g5BEE60C+dtYmTqR4DtFyDaTRQ5CFf4ZxvQPIbD+SXi5Cbrl6qtrZG0cjUihPkC\\n\" +\n+                \"Hi1hAkIAiEcO7nMPgQLny+GrciojfN+bZXME\/dPz6KHBm\/89f8Me+jawVnv6y+df\\n\" +\n+                \"2Sbafh1KV6ntWQtB4bK3MXV8Ym9Eg1I=\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MIHuAgEAMBAGByqGSM49AgEGBSuBBAAjBIHWMIHTAgEBBEIAV8dZszV6+nLw3LeA\\n\" +\n+                \"Q+qLJLGaqyjlsQkaopCPcmoRdy1HX6AzB\/YnKsPkHp\/9DQN6A2JgUhFG5B0XvKSk\\n\" +\n+                \"BqNNuSGhgYkDgYYABACYUPlWYHYx3InqT4R4\/gmdysTrnJIvTuBWYXCevyi063c2\\n\" +\n+                \"1EDLOa+Iw01deOjlHk2o2Mo\/imv3YmNPSw4PrnKeCQG0fXnUS\/9+Io8vGRcv0bN8\\n\" +\n+                \"p1YdWENftmDoNTJ3O6TNlXb90jKWgAirCXNBUompPtHKkO592eDyGcT1h8qjrKlm\\n\" +\n+                \"Kw==\"),\n+\n+        CA_RSA_2048(\n+                \"RSA\",\n+                \/\/ SHA256withRSA, 2048 bits\n+                \/\/ Validity\n+                \/\/     Not Before: May 22 07:18:16 2018 GMT\n+                \/\/     Not After : May 17 07:18:16 2038 GMT\n+                \/\/ Subject Key Identifier:\n+                \/\/     0D:DD:93:C9:FE:4B:BD:35:B7:E8:99:78:90:FB:DB:5A:3D:DB:15:4C\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIIDSTCCAjGgAwIBAgIJAI4ZF3iy8zG+MA0GCSqGSIb3DQEBCwUAMDsxCzAJBgNV\\n\" +\n+                \"BAYTAlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\\n\" +\n+                \"aXZjZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYT\\n\" +\n+                \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+                \"ZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALpMcY7aWieXDEM1\/YJf\\n\" +\n+                \"JW27b4nRIFZyEYhEloyGsKTuQiiQjc8cqRZFNXe2vwziDB4IyTEl0Hjl5QF6ZaQE\\n\" +\n+                \"huPzzwvQm1pv64KrRXrmj3FisQK8B5OWLty9xp6xDqsaMRoyObLK+oIb20T5fSlE\\n\" +\n+                \"evmo1vYjnh8CX0Yzx5Gr5ye6YSEHQvYOWEws8ad17OlyToR2KMeC8w4qo6rs59pW\\n\" +\n+                \"g7Mxn9vo22ImDzrtAbTbXbCias3xlE0Bp0h5luyf+5U4UgksoL9B9r2oP4GrLNEV\\n\" +\n+                \"oJk57t8lwaR0upiv3CnS8LcJELpegZub5ggqLY8ZPYFQPjlK6IzLOm6rXPgZiZ3m\\n\" +\n+                \"RL0CAwEAAaNQME4wHQYDVR0OBBYEFA3dk8n+S701t+iZeJD721o92xVMMB8GA1Ud\\n\" +\n+                \"IwQYMBaAFA3dk8n+S701t+iZeJD721o92xVMMAwGA1UdEwQFMAMBAf8wDQYJKoZI\\n\" +\n+                \"hvcNAQELBQADggEBAJTRC3rKUUhVH07\/1+stUungSYgpM08dY4utJq0BDk36BbmO\\n\" +\n+                \"0AnLDMbkwFdHEoqF6hQIfpm7SQTmXk0Fss6Eejm8ynYr6+EXiRAsaXOGOBCzF918\\n\" +\n+                \"\/RuKOzqABfgSU4UBKECLM5bMfQTL60qx+HdbdVIpnikHZOFfmjCDVxoHsGyXc1LW\\n\" +\n+                \"Jhkht8IGOgc4PMGvyzTtRFjz01kvrVQZ75aN2E0GQv6dCxaEY0i3ypSzjUWAKqDh\\n\" +\n+                \"3e2OLwUSvumcdaxyCdZAOUsN6pDBQ+8VRG7KxnlRlY1SMEk46QgQYLbPDe\/+W\/yH\\n\" +\n+                \"ca4PejicPeh+9xRAwoTpiE2gulfT7Lm+fVM7Ruc=\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQC6THGO2lonlwxD\\n\" +\n+                \"Nf2CXyVtu2+J0SBWchGIRJaMhrCk7kIokI3PHKkWRTV3tr8M4gweCMkxJdB45eUB\\n\" +\n+                \"emWkBIbj888L0Jtab+uCq0V65o9xYrECvAeTli7cvcaesQ6rGjEaMjmyyvqCG9tE\\n\" +\n+                \"+X0pRHr5qNb2I54fAl9GM8eRq+cnumEhB0L2DlhMLPGndezpck6EdijHgvMOKqOq\\n\" +\n+                \"7OfaVoOzMZ\/b6NtiJg867QG0212womrN8ZRNAadIeZbsn\/uVOFIJLKC\/Qfa9qD+B\\n\" +\n+                \"qyzRFaCZOe7fJcGkdLqYr9wp0vC3CRC6XoGbm+YIKi2PGT2BUD45SuiMyzpuq1z4\\n\" +\n+                \"GYmd5kS9AgMBAAECggEAFHSoU2MuWwJ+2jJnb5U66t2V1bAcuOE1g5zkWvG\/G5z9\\n\" +\n+                \"rq6Qo5kmB8f5ovdx6tw3MGUOklLwnRXBG3RxDJ1iokz3AvkY1clMNsDPlDsUrQKF\\n\" +\n+                \"JSO4QUBQTPSZhnsyfR8XHSU+qJ8Y+ohMfzpVv95BEoCzebtXdVgxVegBlcEmVHo2\\n\" +\n+                \"kMmkRN+bYNsr8eb2r+b0EpyumS39ZgKYh09+cFb78y3T6IFMGcVJTP6nlGBFkmA\/\\n\" +\n+                \"25pYeCF2tSki08qtMJZQAvKfw0Kviibk7ZxRbJqmc7B1yfnOEHP6ftjuvKl2+RP\/\\n\" +\n+                \"+5P5f8CfIP6gtA0LwSzAqQX\/hfIKrGV5j0pCqrD0kQKBgQDeNR6Xi4sXVq79lihO\\n\" +\n+                \"a1bSeV7r8yoQrS8x951uO+ox+UIZ1MsAULadl7zB\/P0er92p198I9M\/0Jth3KBuS\\n\" +\n+                \"zj45mucvpiiGvmQlMKMEfNq4nN7WHOu55kufPswQB2mR4J3xmwI+4fM\/nl1zc82h\\n\" +\n+                \"De8JSazRldJXNhfx0RGFPmgzbwKBgQDWoVXrXLbCAn41oVnWB8vwY9wjt92ztDqJ\\n\" +\n+                \"HMFA\/SUohjePep9UDq6ooHyAf\/Lz6oE5NgeVpPfTDkgvrCFVKnaWdwALbYoKXT2W\\n\" +\n+                \"9FlyJox6eQzrtHAacj3HJooXWuXlphKSizntfxj3LtMR9BmrmRJOfK+SxNOVJzW2\\n\" +\n+                \"+MowT20EkwKBgHmpB8jdZBgxI7o\/\/m2BI5Y1UZ1KE5vx1kc7VXzHXSBjYqeV9FeF\\n\" +\n+                \"2ZZLP9POWh\/1Fh4pzTmwIDODGT2UPhSQy0zq3O0fwkyT7WzXRknsuiwd53u\/dejg\\n\" +\n+                \"iEL2NPAJvulZ2+AuiHo5Z99LK8tMeidV46xoJDDUIMgTG+UQHNGhK5gNAoGAZn\/S\\n\" +\n+                \"Cn7SgMC0CWSvBHnguULXZO9wH1wZAFYNLL44OqwuaIUFBh2k578M9kkke7woTmwx\\n\" +\n+                \"HxQTjmWpr6qimIuY6q6WBN8hJ2Xz\/d1fwhYKzIp20zHuv5KDUlJjbFfqpsuy3u1C\\n\" +\n+                \"kts5zwI7pr1ObRbDGVyOdKcu7HI3QtR5qqyjwaUCgYABo7Wq6oHva\/9V34+G3Goh\\n\" +\n+                \"63bYGUnRw2l5BD11yhQv8XzGGZFqZVincD8gltNThB0Dc\/BI+qu3ky4YdgdZJZ7K\\n\" +\n+                \"z51GQGtaHEbrHS5caV79yQ8QGY5mUVH3E+VXSxuIqb6pZq2DH4sTAEFHyncddmOH\\n\" +\n+                \"zoXBInYwRG9KE\/Bw5elhUw==\"),\n+\n+        CA_RSA_512( \/\/ for DisabledShortRSAKeys test\n+                \"RSA\",\n+                \/\/ md5WithRSAEncryption, 1024 bits\n+                \/\/ Validity\n+                \/\/      Not Before: Aug 19 01:52:19 2011 GMT\n+                \/\/      Not After : Jul 29 01:52:19 2032 GMT\n+                \/\/ X509v3 Authority Key Identifier:\n+                \/\/      keyid:B9:7C:D5:D9:DF:A7:4C:03:AE:FD:0E:27:5B:31:95:6C:C7:F3:75:E1\n+                \/\/      DirName:\/C=US\/O=Java\/OU=SunJSSE Test Serivce\n+                \/\/      serial:00\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIICkjCCAfugAwIBAgIBADANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n+                \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n+                \"MTEwODE5MDE1MjE5WhcNMzIwNzI5MDE1MjE5WjA7MQswCQYDVQQGEwJVUzENMAsG\\n\" +\n+                \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwgZ8wDQYJ\\n\" +\n+                \"KoZIhvcNAQEBBQADgY0AMIGJAoGBAM8orG08DtF98TMSscjGsidd1ZoN4jiDpi8U\\n\" +\n+                \"ICz+9dMm1qM1d7O2T+KH3\/mxyox7Rc2ZVSCaUD0a3CkhPMnlAx8V4u0H+E9sqso6\\n\" +\n+                \"iDW3JpOyzMExvZiRgRG\/3nvp55RMIUV4vEHOZ1QbhuqG4ebN0Vz2DkRft7+flthf\\n\" +\n+                \"vDld6f5JAgMBAAGjgaUwgaIwHQYDVR0OBBYEFLl81dnfp0wDrv0OJ1sxlWzH83Xh\\n\" +\n+                \"MGMGA1UdIwRcMFqAFLl81dnfp0wDrv0OJ1sxlWzH83XhoT+kPTA7MQswCQYDVQQG\\n\" +\n+                \"EwJVUzENMAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2\\n\" +\n+                \"Y2WCAQAwDwYDVR0TAQH\/BAUwAwEB\/zALBgNVHQ8EBAMCAQYwDQYJKoZIhvcNAQEE\\n\" +\n+                \"BQADgYEALlgaH1gWtoBZ84EW8Hu6YtGLQ\/L9zIFmHonUPZwn3Pr\/\/icR9Sqhc3\/l\\n\" +\n+                \"pVTxOINuFHLRz4BBtEylzRIOPzK3tg8XwuLb1zd0db90x3KBCiAL6E6cklGEPwLe\\n\" +\n+                \"XYMHDn9eDsaq861Tzn6ZwzMgw04zotPMoZN0mVd\/3Qca8UJFucE=\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEAtz2+PTkj3zg9hh0l\\n\" +\n+                \"xQhcdRiRGX6hvWVH+8biIv62uXS4zxgGqGOUBdkDmvFZzq4kAlw38lx8bLkZxDqJ\\n\" +\n+                \"sS+xFQIDAQABAkByx\/5Oo2hQ\/w2q4L8z+NTRlJ3vdl8iIDtC\/4XPnfYfnGptnpG6\\n\" +\n+                \"ZThQRvbMZiai0xHQPQMszvAHjZVme1eDl3EBAiEA3aKJHynPVCEJhpfCLWuMwX5J\\n\" +\n+                \"1LntwJO7NTOyU5m8rPECIQDTpzn5X44r2rzWBDna\/Sx7HW9IWCxNgUD2Eyi2nA7W\\n\" +\n+                \"ZQIgJerEorw4aCAuzQPxiGu57PB6GRamAihEAtoRTBQlH0ECIQDN08FgTtnesgCU\\n\" +\n+                \"DFYLLcw1CiHvc7fZw4neBDHCrC8NtQIgA8TOUkGnpCZlQ0KaI8KfKWI+vxFcgFnH\\n\" +\n+                \"3fnqsTgaUs4=\"\n+\n+        ),\n+\n+        CA_DSA_2048(\n+                \"DSA\",\n+                \/\/ SHA256withDSA, 2048 bits\n+                \/\/ Validity\n+                \/\/     Not Before: May 22 07:18:18 2018 GMT\n+                \/\/     Not After : May 17 07:18:18 2038 GMT\n+                \/\/ Subject Key Identifier:\n+                \/\/     76:66:9E:F7:3B:DD:45:E5:3B:D9:72:3C:3F:F0:54:39:86:31:26:53\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIIErjCCBFSgAwIBAgIJAOktYLNCbr02MAsGCWCGSAFlAwQDAjA7MQswCQYDVQQG\\n\" +\n+                \"EwJVUzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2\\n\" +\n+                \"Y2UwHhcNMTgwNTIyMDcxODE4WhcNMzgwNTE3MDcxODE4WjA7MQswCQYDVQQGEwJV\\n\" +\n+                \"UzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2Y2Uw\\n\" +\n+                \"ggNHMIICOQYHKoZIzjgEATCCAiwCggEBAO5GyPhSm0ze3LSu+gicdULLj05iOfTL\\n\" +\n+                \"UvZQ29sYz41zmqrLBQbdKiHqgJu2Re9sgTb5suLNjF047TOLPnU3jhPtWm2X8Xzi\\n\" +\n+                \"VGIcHym\/Q\/MeZxStt\/88seqroI3WOKzIML2GcrishT+lcGrtH36Tf1+ue2Snn3PS\\n\" +\n+                \"WyxygNqPjllP5uUjYmFLvAf4QLMldkd\/D2VxcwsHjB8y5iUZsXezc\/LEhRZS\/02m\\n\" +\n+                \"ivqlRw3AMkq\/OVe\/ZtxFWsP0nsfxEGdZuaUFpppGfixxFvymrB3+J51cTt+pZBDq\\n\" +\n+                \"D2y0DYfc+88iCs4jwHTfcDIpLb538HBjBj2rEgtQESQmB0ooD\/+wsPsCIQC1bYch\\n\" +\n+                \"gElNtDYL3FgpLgNSUYp7gIWv9ehaC7LO2z7biQKCAQBitvFOnDkUja8NAF7lDpOV\\n\" +\n+                \"b5ipQ8SicBLW3kQamxhyuyxgZyy\/PojZ\/oPorkqW\/T\/A0rhnG6MssEpAtdiwVB+c\\n\" +\n+                \"rBYGo3bcwmExJhdOJ6dYuKFppPWhCwKMHs9npK+lqBMl8l5j58xlcFeC7ZfGf8GY\\n\" +\n+                \"GkhFW0c44vEQhMMbac6ZTTP4mw+1t7xJfmDMlLEyIpTXaAAk8uoVLWzQWnR40sHi\\n\" +\n+                \"ybvS0u3JxQkb7\/y8tOOZu8qlz\/YOS7lQ6UxUGX27Ce1E0+agfPphetoRAlS1cezq\\n\" +\n+                \"Wa7r64Ga0nkj1kwkcRqjgTiJx0NwnUXr78VAXFhVF95+O3lfqhvdtEGtkhDGPg7N\\n\" +\n+                \"A4IBBgACggEBAMmSHQK0w2i+iqUjOPzn0yNEZrzepLlLeQ1tqtn0xnlv5vBAeefD\\n\" +\n+                \"Pm9dd3tZOjufVWP7hhEz8xPobb1CS4e3vuQiv5UBfhdPL3f3l9T7JMAKPH6C9Vve\\n\" +\n+                \"OQXE5eGqbjsySbcmseHoYUt1WCSnSda1opX8zchX04e7DhGfE2\/L9flpYEoSt8lI\\n\" +\n+                \"vMNjgOwvKdW3yvPt1\/eBBHYNFG5gWPv\/Q5KoyCtHS03uqGm4rNc\/wZTIEEfd66C+\\n\" +\n+                \"QRaUltjOaHmtwOdDHaNqwhYZSVOip+Mo+TfyzHFREcdHLapo7ZXqbdYkRGxRR3d+\\n\" +\n+                \"3DfHaraJO0OKoYlPkr3JMvM\/MSGR9AnZOcejUDBOMB0GA1UdDgQWBBR2Zp73O91F\\n\" +\n+                \"5TvZcjw\/8FQ5hjEmUzAfBgNVHSMEGDAWgBR2Zp73O91F5TvZcjw\/8FQ5hjEmUzAM\\n\" +\n+                \"BgNVHRMEBTADAQH\/MAsGCWCGSAFlAwQDAgNHADBEAiBzriYE41M2y9Hy5ppkL0Qn\\n\" +\n+                \"dIlNc8JhXT\/PHW7GDtViagIgMko8Qoj9gDGPK3+O9E8DC3wGiiF9CObM4LN387ok\\n\" +\n+                \"J+g=\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MIICZQIBADCCAjkGByqGSM44BAEwggIsAoIBAQDuRsj4UptM3ty0rvoInHVCy49O\" +\n+                \"Yjn0y1L2UNvbGM+Nc5qqywUG3Soh6oCbtkXvbIE2+bLizYxdOO0ziz51N44T7Vpt\" +\n+                \"l\/F84lRiHB8pv0PzHmcUrbf\/PLHqq6CN1jisyDC9hnK4rIU\/pXBq7R9+k39frntk\" +\n+                \"p59z0lsscoDaj45ZT+blI2JhS7wH+ECzJXZHfw9lcXMLB4wfMuYlGbF3s3PyxIUW\" +\n+                \"Uv9Npor6pUcNwDJKvzlXv2bcRVrD9J7H8RBnWbmlBaaaRn4scRb8pqwd\/iedXE7f\" +\n+                \"qWQQ6g9stA2H3PvPIgrOI8B033AyKS2+d\/BwYwY9qxILUBEkJgdKKA\/\/sLD7AiEA\" +\n+                \"tW2HIYBJTbQ2C9xYKS4DUlGKe4CFr\/XoWguyzts+24kCggEAYrbxTpw5FI2vDQBe\" +\n+                \"5Q6TlW+YqUPEonAS1t5EGpsYcrssYGcsvz6I2f6D6K5Klv0\/wNK4ZxujLLBKQLXY\" +\n+                \"sFQfnKwWBqN23MJhMSYXTienWLihaaT1oQsCjB7PZ6SvpagTJfJeY+fMZXBXgu2X\" +\n+                \"xn\/BmBpIRVtHOOLxEITDG2nOmU0z+JsPtbe8SX5gzJSxMiKU12gAJPLqFS1s0Fp0\" +\n+                \"eNLB4sm70tLtycUJG+\/8vLTjmbvKpc\/2Dku5UOlMVBl9uwntRNPmoHz6YXraEQJU\" +\n+                \"tXHs6lmu6+uBmtJ5I9ZMJHEao4E4icdDcJ1F6+\/FQFxYVRfefjt5X6ob3bRBrZIQ\" +\n+                \"xj4OzQQjAiEAsceWOM8do4etxp2zgnoNXV8PUUyqWhz1+0srcKV7FR4=\"),\n+\n+        CA_DSA_1024(\n+                \"DSA\",\n+                \/\/ dsaWithSHA1, 1024 bits\n+                \/\/ Validity\n+                \/\/     Not Before: Apr 24 12:25:43 2020 GMT\n+                \/\/     Not After : Apr 22 12:25:43 2030 GMT\n+                \/\/ Authority Key Identifier:\n+                \/\/     E1:3C:01:52:EB:D1:38:F7:CF:F1:E3:5E:DB:54:75:7F:5E:AB:2D:36\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIIC9TCCArWgAwIBAgIUd52yKk0OxQuxdaYRAfq5VLuF1ZAwCQYHKoZIzjgEAzAu\\n\" +\n+                \"MQswCQYDVQQGEwJVUzENMAsGA1UECgwESmF2YTEQMA4GA1UECwwHU3VuSlNTRTAe\\n\" +\n+                \"Fw0yMDA0MjQxMjI1NDJaFw0zMDA0MjIxMjI1NDJaMC4xCzAJBgNVBAYTAlVTMQ0w\\n\" +\n+                \"CwYDVQQKDARKYXZhMRAwDgYDVQQLDAdTdW5KU1NFMIIBtjCCASsGByqGSM44BAEw\\n\" +\n+                \"ggEeAoGBAKgyb2XpANq43T8yBf5v0PTBOddLPxd0f0FotASron5rQr86JjBTfgIW\\n\" +\n+                \"oE4u7nYlO6bp\/M4Dw6qZr+HaDu9taIDOj6LL51eUShVsOgS7XZcUzLT8vPnkEDDo\\n\" +\n+                \"u326x0B7fuNCbMLm+ipM2d4FhLUTt4Qb5TcY6l7dOGHeWiL7nl43AhUAoGr8DY2m\\n\" +\n+                \"WHZPHk2XbZ5wpaM2lLcCgYBKiFbFFViH\/ylHJRPtYtjtJw4ls1scbVP4TRHnKoZc\\n\" +\n+                \"HPAird1fDYgGC2b0GQNAMABhI+L+ogxS7qakySpJCheuN25AjiSyilygQdlXoWRt\\n\" +\n+                \"Mggsh8EQZT7iP4V4e9m3xRHzb5ECvsSTdZB1BQMcC90W2Avq+orqgBnr2in9UEd8\\n\" +\n+                \"qwOBhAACgYAgVWxjYWlWIv7s4BnNMQoPKppi205f3aC6wv6Rqk4BnYYYrFONEmzQ\\n\" +\n+                \"hzj6lSXfxLpTu4lg2zNeIraZggoS0ztkbZNNADEmAHx+OLshiJJxu2\/KfoopJOZg\\n\" +\n+                \"8ARmuaKOkWbkW9y4hWhfBlVwZbckG3Eibff0xronIXXy7B7UKaccyqNTMFEwHQYD\\n\" +\n+                \"VR0OBBYEFOE8AVLr0Tj3z\/HjXttUdX9eqy02MB8GA1UdIwQYMBaAFOE8AVLr0Tj3\\n\" +\n+                \"z\/HjXttUdX9eqy02MA8GA1UdEwEB\/wQFMAMBAf8wCQYHKoZIzjgEAwMvADAsAhRC\\n\" +\n+                \"YLduLniBEJ51SfBWIkvNW6OG7QIUSKaTY6rgEFDEMoTqOjFChR22nkk=\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MIIBSgIBADCCASsGByqGSM44BAEwggEeAoGBAKgyb2XpANq43T8yBf5v0PTBOddL\\n\" +\n+                \"Pxd0f0FotASron5rQr86JjBTfgIWoE4u7nYlO6bp\/M4Dw6qZr+HaDu9taIDOj6LL\\n\" +\n+                \"51eUShVsOgS7XZcUzLT8vPnkEDDou326x0B7fuNCbMLm+ipM2d4FhLUTt4Qb5TcY\\n\" +\n+                \"6l7dOGHeWiL7nl43AhUAoGr8DY2mWHZPHk2XbZ5wpaM2lLcCgYBKiFbFFViH\/ylH\\n\" +\n+                \"JRPtYtjtJw4ls1scbVP4TRHnKoZcHPAird1fDYgGC2b0GQNAMABhI+L+ogxS7qak\\n\" +\n+                \"ySpJCheuN25AjiSyilygQdlXoWRtMggsh8EQZT7iP4V4e9m3xRHzb5ECvsSTdZB1\\n\" +\n+                \"BQMcC90W2Avq+orqgBnr2in9UEd8qwQWAhQ7rSn+WvIxeuZ\/CK4p04eMe5JzpA==\"),\n+\n+        CA_ED25519(\n+                \"EdDSA\",\n+                \/\/ ED25519\n+                \/\/ Validity\n+                \/\/     Not Before: May 24 23:32:35 2020 GMT\n+                \/\/     Not After : May 22 23:32:35 2030 GMT\n+                \/\/ X509v3 Authority Key Identifier:\n+                \/\/     keyid:06:76:DB:88:EB:61:55:4C:C9:63:41:C2:A0:A8:57:3F:D7:F1:B8:EC\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIIByTCCAXugAwIBAgIUCyxKvhErehsygx50JYArsHby9hAwBQYDK2VwMDsxCzAJ\\n\" +\n+                \"BgNVBAYTAlVTMQ0wCwYDVQQKDARqYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3Qg\\n\" +\n+                \"U2VyaXZjZTAeFw0yMDA1MjQyMzMyMzVaFw0zMDA1MjIyMzMyMzVaMDsxCzAJBgNV\\n\" +\n+                \"BAYTAlVTMQ0wCwYDVQQKDARqYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\\n\" +\n+                \"aXZjZTAqMAUGAytlcAMhAKdotuYIkH8PYbopSLbaf1BtqUY2d6AbTgK2prMzQ6B3\\n\" +\n+                \"o4GQMIGNMA8GA1UdEwEB\/wQFMAMBAf8wHQYDVR0OBBYEFAZ224jrYVVMyWNBwqCo\\n\" +\n+                \"Vz\/X8bjsMB8GA1UdIwQYMBaAFAZ224jrYVVMyWNBwqCoVz\/X8bjsMA4GA1UdDwEB\\n\" +\n+                \"\/wQEAwIBhjAqBgNVHSUBAf8EIDAeBggrBgEFBQcDAwYIKwYBBQUHAwgGCCsGAQUF\\n\" +\n+                \"BwMJMAUGAytlcANBADVAArvME8xFigFhCCCOTBoy\/4ldGkDZQ\/GT3Q6xnAP558FU\\n\" +\n+                \"0G32OprKQZP43D9bmFU0LMgCVM9bHWU+bu\/10AU=\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MC4CAQAwBQYDK2VwBCIEII\/VYp8nu\/eqq2L5y7\/3IzavBgis4LWP6Rikv0N8SpgL\"),\n+\n+        CA_ED448(\n+                \"EdDSA\",\n+                \/\/ ED448\n+                \/\/ Validity\n+                \/\/     Not Before: May 24 23:23:43 2020 GMT\n+                \/\/     Not After : May 22 23:23:43 2030 GMT\n+                \/\/ X509v3 Authority Key Identifier:\n+                \/\/     keyid:F5:D5:9D:FB:6F:B7:50:29:DF:F0:B8:83:10:5F:9B:C4:A8:1C:E9:F4\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIICFDCCAZSgAwIBAgIUKcmLeKilq0LN40sniBJO7F1gb\/owBQYDK2VxMDsxCzAJ\\n\" +\n+                \"BgNVBAYTAlVTMQ0wCwYDVQQKDARqYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3Qg\\n\" +\n+                \"U2VyaXZjZTAeFw0yMDA1MjQyMzIzNDNaFw0zMDA1MjIyMzIzNDNaMDsxCzAJBgNV\\n\" +\n+                \"BAYTAlVTMQ0wCwYDVQQKDARqYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\\n\" +\n+                \"aXZjZTBDMAUGAytlcQM6APYP8iSXS8xPVDike5RgCByfTtg4GGtpYfoBtt6G5szA\\n\" +\n+                \"55ExAKjm03wtk29nEPU2mCHF2QgfBzUrgKOBkDCBjTAPBgNVHRMBAf8EBTADAQH\/\\n\" +\n+                \"MB0GA1UdDgQWBBT11Z37b7dQKd\/wuIMQX5vEqBzp9DAfBgNVHSMEGDAWgBT11Z37\\n\" +\n+                \"b7dQKd\/wuIMQX5vEqBzp9DAOBgNVHQ8BAf8EBAMCAYYwKgYDVR0lAQH\/BCAwHgYI\\n\" +\n+                \"KwYBBQUHAwMGCCsGAQUFBwMIBggrBgEFBQcDCTAFBgMrZXEDcwAlRXA2gPb52yV3\\n\" +\n+                \"MKJErjmKlYSFExj5w5jafbbd0QgI1yDs+qSaZLjQ8ljwabmLDg+KR+167m0djQDI\\n\" +\n+                \"OOoVuL7bgM0RL836KnuuBzm+gTdPp0gCXy3k9lL0KA0V2YLJHXXzu3suu+7rdgoP\\n\" +\n+                \"plCh2hWdLgA=\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MEcCAQAwBQYDK2VxBDsEOd6\/hRZqkUyTlJSwdN5gO\/HnoWYda1fD83YUm5j6m2Bg\\n\" +\n+                \"hAQi+QadFsQLD7R6PI\/4Q0twXqlKnxU5Ug==\"),\n+\n+        EE_ECDSA_SECP256R1(\n+                \"EC\",\n+                \/\/ SHA256withECDSA, curve secp256r1\n+                \/\/ Validity\n+                \/\/     Not Before: May 22 07:18:16 2018 GMT\n+                \/\/     Not After : May 17 07:18:16 2038 GMT\n+                \/\/ Authority Key Identifier:\n+                \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIIBqjCCAVCgAwIBAgIJAPLY8qZjgNRAMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n+                \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+                \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYTAlVT\\n\" +\n+                \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTEY\\n\" +\n+                \"MBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcD\\n\" +\n+                \"QgAEb+9n05qfXnfHUb0xtQJNS4JeSi6IjOfW5NqchvKnfJey9VkJzR7QHLuOESdf\\n\" +\n+                \"xlR7q8YIWgih3iWLGfB+wxHiOqMjMCEwHwYDVR0jBBgwFoAUYM+9c\/\/6GjDSpOzT\\n\" +\n+                \"SXFG7xo1oIYwCgYIKoZIzj0EAwIDSAAwRQIgWpRegWXMheiD3qFdd8kMdrkLxRbq\\n\" +\n+                \"1zj8nQMEwFTUjjQCIQDRIrAjZX+YXHN9b0SoWWLPUq0HmiFIi8RwMnO\/\/wJIGQ==\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgn5K03bpTLjEtFQRa\\n\" +\n+                \"JUtx22gtmGEvvSUSQdimhGthdtihRANCAARv72fTmp9ed8dRvTG1Ak1Lgl5KLoiM\\n\" +\n+                \"59bk2pyG8qd8l7L1WQnNHtAcu44RJ1\/GVHurxghaCKHeJYsZ8H7DEeI6\"),\n+\n+        EE_ECDSA_SECP384R1(\n+                \"EC\",\n+                \/\/ SHA384withECDSA, curve secp384r1\n+                \/\/ Validity\n+                \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n+                \/\/     Not After : Jun 19 08:15:06 2039 GMT\n+                \/\/ Authority Key Identifier:\n+                \/\/     40:2D:AA:EE:66:AA:33:27:AD:9B:5D:52:9B:60:67:6A:2B:AD:52:D2\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIICEjCCAZegAwIBAgIUS3F0AqAXWRg07CnbknJzxofyBQMwCgYIKoZIzj0EAwMw\\n\" +\n+                \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n+                \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowVTEL\\n\" +\n+                \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n+                \"dCBTZXJpdmNlMRgwFgYDVQQDDA9SZWdyZXNzaW9uIFRlc3QwdjAQBgcqhkjOPQIB\\n\" +\n+                \"BgUrgQQAIgNiAARqElz8b6T07eyKomIinhztV3\/3XBk9bKGtJ0W+JOltjuhMmP\/w\\n\" +\n+                \"G8ASSevpgqgpi6EzpBZaaJxE3zNfkNnxXOZmQi2Ypd1uK0zRdbEOKg0XOcTTZwEj\\n\" +\n+                \"iLjYmt3O0pwpklijQjBAMB0GA1UdDgQWBBRALaruZqozJ62bXVKbYGdqK61S0jAf\\n\" +\n+                \"BgNVHSMEGDAWgBRKS1IUCtHWn\/mZdXSTKjRHEhVr9TAKBggqhkjOPQQDAwNpADBm\\n\" +\n+                \"AjEArVDFKf48xijN6huVUJzKCOP0zlWB5Js+DItIkZmLQuhciPLhLIB\/rChf3Y4C\\n\" +\n+                \"xuP4AjEAmfLhQRI0O3pifpYzYSVh2G7\/jHNG4eO+2dvgAcU+Lh2IIj\/cpLaPFSvL\\n\" +\n+                \"J8FXY9Nj\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDASuI9EtK29APXPipkc\\n\" +\n+                \"qDA+qwlewMjv\/OcjUJ77kP1Vz62oVF9iY9SRIyFIUju8wt+hZANiAARqElz8b6T0\\n\" +\n+                \"7eyKomIinhztV3\/3XBk9bKGtJ0W+JOltjuhMmP\/wG8ASSevpgqgpi6EzpBZaaJxE\\n\" +\n+                \"3zNfkNnxXOZmQi2Ypd1uK0zRdbEOKg0XOcTTZwEjiLjYmt3O0pwpklg=\"),\n+\n+        EE_ECDSA_SECP521R1(\n+                \"EC\",\n+                \/\/ SHA512withECDSA, curve secp521r1\n+                \/\/ Validity\n+                \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n+                \/\/     Not After : Jun 19 08:15:06 2039 GMT\n+                \/\/ Authority Key Identifier:\n+                \/\/     7B:AA:79:A4:49:DD:59:34:F0:86:6C:51:C7:30:F4:CE:C5:81:8A:28\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIICXDCCAb2gAwIBAgIUck4QTsbHNqUfPxfGPJLYbedFPdswCgYIKoZIzj0EAwQw\\n\" +\n+                \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n+                \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowVTEL\\n\" +\n+                \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n+                \"dCBTZXJpdmNlMRgwFgYDVQQDDA9SZWdyZXNzaW9uIFRlc3QwgZswEAYHKoZIzj0C\\n\" +\n+                \"AQYFK4EEACMDgYYABAGa2zDLhYQHHCLI3YBqFYJTzrnDIjzwXrxhcRTS8DYkcrjZ\\n\" +\n+                \"+Fih1YyNhix0sdjH+3EqElXAHHuVzn3n3hPOtQCWlQCICkErB34S0cvmtRkeW8Fi\\n\" +\n+                \"hrR5tvJEzEZjPSgwn81kKyhV2L70je6i7Cw884Va8bODckpgw0vTmbQb7T9dupkv\\n\" +\n+                \"1aNCMEAwHQYDVR0OBBYEFHuqeaRJ3Vk08IZsUccw9M7FgYooMB8GA1UdIwQYMBaA\\n\" +\n+                \"FEAivFrtaq2pQJ4cW4pEQML3aym9MAoGCCqGSM49BAMEA4GMADCBiAJCAb33KHdY\\n\" +\n+                \"WDbusORWoY8Euglpd5zsF15hJsk7wtpD5HST1\/NWmdCx405w+TV6a9Gr4VPHeaIQ\\n\" +\n+                \"99i\/+f237ALL5p6IAkIBbwwFL1vt3c\/bx+niyuffQPNjly80rdC9puqAqriSiboS\\n\" +\n+                \"efhxjidJ9HLaIRCMEPyd6vAsC8mO8YvL1uCuEQLsiGM=\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MIHuAgEAMBAGByqGSM49AgEGBSuBBAAjBIHWMIHTAgEBBEIB8C\/2OX2Dt9vFszzV\\n\" +\n+                \"hcAe0CbkMlvu9uQ\/L7Vz88heuIj0rUZIPGshvgIJt1hCMT8HZxYHvDa4lbUvqjFB\\n\" +\n+                \"+zafvPWhgYkDgYYABAGa2zDLhYQHHCLI3YBqFYJTzrnDIjzwXrxhcRTS8DYkcrjZ\\n\" +\n+                \"+Fih1YyNhix0sdjH+3EqElXAHHuVzn3n3hPOtQCWlQCICkErB34S0cvmtRkeW8Fi\\n\" +\n+                \"hrR5tvJEzEZjPSgwn81kKyhV2L70je6i7Cw884Va8bODckpgw0vTmbQb7T9dupkv\\n\" +\n+                \"1Q==\"),\n+\n+        EE_RSA_2048(\n+                \"RSA\",\n+                \/\/ SHA256withRSA, 2048 bits\n+                \/\/ Validity\n+                \/\/     Not Before: May 22 07:18:16 2018 GMT\n+                \/\/     Not After : May 17 07:18:16 2038 GMT\n+                \/\/ Authority Key Identifier:\n+                \/\/     0D:DD:93:C9:FE:4B:BD:35:B7:E8:99:78:90:FB:DB:5A:3D:DB:15:4C\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIIDNjCCAh6gAwIBAgIJAO2+yPcFryUTMA0GCSqGSIb3DQEBCwUAMDsxCzAJBgNV\\n\" +\n+                \"BAYTAlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\\n\" +\n+                \"aXZjZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYT\\n\" +\n+                \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+                \"ZTEYMBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MIIBIjANBgkqhkiG9w0BAQEFAAOC\\n\" +\n+                \"AQ8AMIIBCgKCAQEAszfBobWfZIp8AgC6PiWDDavP65mSvgCXUGxACbxVNAfkLhNR\\n\" +\n+                \"QOsHriRB3X1Q3nvO9PetC6wKlvE9jlnDDj7D+1j1r1CHO7ms1fq8rfcQYdkanDtu\\n\" +\n+                \"4AlHo8v+SSWX16MIXFRYDj2VVHmyPtgbltcg4zGAuwT746FdLI94uXjJjq1IOr\/v\\n\" +\n+                \"0VIlwE5ORWH5Xc+5Tj+oFWK0E4a4GHDgtKKhn2m72hN56\/GkPKGkguP5NRS1qYYV\\n\" +\n+                \"\/EFkdyQMOV8J1M7HaicSft4OL6eKjTrgo93+kHk+tv0Dc6cpVBnalX3TorG8QI6B\\n\" +\n+                \"cHj1XQd78oAlAC+\/jF4pc0mwi0un49kdK9gRfQIDAQABoyMwITAfBgNVHSMEGDAW\\n\" +\n+                \"gBQN3ZPJ\/ku9NbfomXiQ+9taPdsVTDANBgkqhkiG9w0BAQsFAAOCAQEApXS0nKwm\\n\" +\n+                \"Kp8gpmO2yG1rpd1+2wBABiMU4JZaTqmma24DQ3RzyS+V2TeRb29dl5oTUEm98uc0\\n\" +\n+                \"GPZvhK8z5RFr4YE17dc04nI\/VaNDCw4y1NALXGs+AHkjoPjLyGbWpi1S+gfq2sNB\\n\" +\n+                \"Ekkjp6COb\/cb9yiFXOGVls7UOIjnVZVd0r7KaPFjZhYh82\/f4PA\/A1SnIKd1+nfH\\n\" +\n+                \"2yk7mSJNC7Z3qIVDL8MM\/jBVwiC3uNe5GPB2uwhd7k5LGAVN3j4HQQGB0Sz+VC1h\\n\" +\n+                \"92oi6xDa+YBva2fvHuCd8P50DDjxmp9CemC7rnZ5j8egj88w14X44Xjb\/Fd\/ApG9\\n\" +\n+                \"e57NnbT7KM+Grw==\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCzN8GhtZ9kinwC\\n\" +\n+                \"ALo+JYMNq8\/rmZK+AJdQbEAJvFU0B+QuE1FA6weuJEHdfVDee870960LrAqW8T2O\\n\" +\n+                \"WcMOPsP7WPWvUIc7uazV+ryt9xBh2RqcO27gCUejy\/5JJZfXowhcVFgOPZVUebI+\\n\" +\n+                \"2BuW1yDjMYC7BPvjoV0sj3i5eMmOrUg6v+\/RUiXATk5FYfldz7lOP6gVYrQThrgY\\n\" +\n+                \"cOC0oqGfabvaE3nr8aQ8oaSC4\/k1FLWphhX8QWR3JAw5XwnUzsdqJxJ+3g4vp4qN\\n\" +\n+                \"OuCj3f6QeT62\/QNzpylUGdqVfdOisbxAjoFwePVdB3vygCUAL7+MXilzSbCLS6fj\\n\" +\n+                \"2R0r2BF9AgMBAAECggEASIkPkMCuw4WdTT44IwERus3IOIYOs2IP3BgEDyyvm4B6\\n\" +\n+                \"JP\/iihDWKfA4zEl1Gqcni1RXMHswSglXra682J4kui02Ov+vzEeJIY37Ibn2YnP5\\n\" +\n+                \"ZjRT2s9GtI\/S2o4hl8A\/mQb2IMViFC+xKehTukhV4j5d6NPKk0XzLR7gcMjnYxwn\\n\" +\n+                \"l21fS6D2oM1xRG\/di7sL+uLF8EXLRzfiWDNi12uQv4nwtxPKvuKhH6yzHt7YqMH0\\n\" +\n+                \"46pmDKDaxV4w1JdycjCb6NrCJOYZygoQobuZqOQ30UZoZsPJrtovkncFr1e+lNcO\\n\" +\n+                \"+aWDfOLCtTH046dEQh5oCShyXMybNlry\/QHsOtHOwQKBgQDh2iIjs+FPpQy7Z3EX\\n\" +\n+                \"DGEvHYqPjrYO9an2KSRr1m9gzRlWYxKY46WmPKwjMerYtra0GP+TBHrgxsfO8tD2\\n\" +\n+                \"wUAII6sd1qup0a\/Sutgf2JxVilLykd0+Ge4\/Cs51tCdJ8EqDV2B6WhTewOY2EGvg\\n\" +\n+                \"JiKYkeNwgRX\/9M9CFSAMAk0hUQKBgQDLJAartL3DoGUPjYtpJnfgGM23yAGl6G5r\\n\" +\n+                \"NSXDn80BiYIC1p0bG3N0xm3yAjqOtJAUj9jZbvDNbCe3GJfLARMr23legX4tRrgZ\\n\" +\n+                \"nEdKnAFKAKL01oM+A5\/lHdkwaZI9yyv+hgSVdYzUjB8rDmzeVQzo1BT7vXypt2yV\\n\" +\n+                \"6O1OnUpCbQKBgA\/0rzDChopv6KRcvHqaX0tK1P0rYeVQqb9ATNhpf9jg5Idb3HZ8\\n\" +\n+                \"rrk91BNwdVz2G5ZBpdynFl9G69rNAMJOCM4KZw5mmh4XOEq09Ivba8AHU7DbaTv3\\n\" +\n+                \"7QL7KnbaUWRB26HHzIMYVh0el6T+KADf8NXCiMTr+bfpfbL3dxoiF3zhAoGAbCJD\\n\" +\n+                \"Qse1dBs\/cKYCHfkSOsI5T6kx52Tw0jS6Y4X\/FOBjyqr\/elyEexbdk8PH9Ar931Qr\\n\" +\n+                \"NKMvn8oA4iA\/PRrXX7M2yi3YQrWwbkGYWYjtzrzEAdzmg+5eARKAeJrZ8\/bg9l3U\\n\" +\n+                \"ttKaItJsDPlizn8rngy3FsJpR9aSAMK6\/+wOiYkCgYEA1tZkI1rD1W9NYZtbI9BE\\n\" +\n+                \"qlJVFi2PBOJMKNuWdouPX3HLQ72GJSQff2BFzLTELjweVVJ0SvY4IipzpQOHQOBy\\n\" +\n+                \"5qh\/p6izXJZh3IHtvwVBjHoEVplg1b2+I5e3jDCfqnwcQw82dW5SxOJMg1h\/BD0I\\n\" +\n+                \"qAL3go42DYeYhu\/WnECMeis=\"),\n+\n+        EE_EC_RSA_SECP256R1(\n+                \"EC\",\n+                \/\/ SHA256withRSA, curve secp256r1\n+                \/\/ Validity\n+                \/\/     Not Before: May 22 07:18:16 2018 GMT\n+                \/\/     Not After : May 21 07:18:16 2028 GMT\n+                \/\/ Authority Key Identifier:\n+                \/\/     0D:DD:93:C9:FE:4B:BD:35:B7:E8:99:78:90:FB:DB:5A:3D:DB:15:4C\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIICazCCAVOgAwIBAgIJAO2+yPcFryUUMA0GCSqGSIb3DQEBCwUAMDsxCzAJBgNV\\n\" +\n+                \"BAYTAlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\\n\" +\n+                \"aXZjZTAeFw0xODA1MjIwNzE4MTZaFw0yODA1MjEwNzE4MTZaMFUxCzAJBgNVBAYT\\n\" +\n+                \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+                \"ZTEYMBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0D\\n\" +\n+                \"AQcDQgAE59MERNTlVZ1eeps8Z3Oue5ZkgQdPtD+WIE6tj3PbIKpxGPDxvfNP959A\\n\" +\n+                \"yQjEK\/ehWQVrCMmNoEkIzY+IIBgB06MjMCEwHwYDVR0jBBgwFoAUDd2Tyf5LvTW3\\n\" +\n+                \"6Jl4kPvbWj3bFUwwDQYJKoZIhvcNAQELBQADggEBAFOTVEqs70ykhZiIdrEsF1Ra\\n\" +\n+                \"I3B2rLvwXZk52uSltk2\/bzVvewA577ZCoxQ1pL7ynkisPfBN1uVYtHjM1VA3RC+4\\n\" +\n+                \"+TAK78dnI7otYjWoHp5rvs4l6c\/IbOspS290IlNuDUxMErEm5wxIwj+Aukx\/1y68\\n\" +\n+                \"hOyCvHBLMY2c1LskH1MMBbDuS1aI+lnGpToi+MoYObxGcV458vxuT8+wwV8Fkpvd\\n\" +\n+                \"ll8IIFmeNPRv+1E+lXbES6CSNCVaZ\/lFhPgdgYKleN7sfspiz50DG4dqafuEAaX5\\n\" +\n+                \"xaK1NWXJxTRz0ROH\/IUziyuDW6jphrlgit4+3NCzp6vP9hAJQ8Vhcj0n15BKHIQ=\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgGVc7hICpmp91jbYe\\n\" +\n+                \"nrr8nYHD37RZP3VENY+szuA7WjuhRANCAATn0wRE1OVVnV56mzxnc657lmSBB0+0\\n\" +\n+                \"P5YgTq2Pc9sgqnEY8PG980\/3n0DJCMQr96FZBWsIyY2gSQjNj4ggGAHT\"),\n+\n+        EE_RSA_512(\n+                \"RSA\",\n+                \/\/ md5WithRSAEncryption, 512 bits\n+                \/\/ Validity\n+                \/\/      Not Before: Nov  7 13:55:52 2011 GMT\n+                \/\/      Not After : Jul 25 13:55:52 2031 GMT\n+                \/\/ X509v3 Authority Key Identifier:\n+                \/\/      B9:7C:D5:D9:DF:A7:4C:03:AE:FD:0E:27:5B:31:95:6C:C7:F3:75:E1\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIICNDCCAZ2gAwIBAgIBDDANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n+                \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n+                \"MTExMTA3MTM1NTUyWhcNMzEwNzI1MTM1NTUyWjBPMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n+                \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxEjAQBgNV\\n\" +\n+                \"BAMTCWxvY2FsaG9zdDBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQC3Pb49OSPfOD2G\\n\" +\n+                \"HSXFCFx1GJEZfqG9ZUf7xuIi\/ra5dLjPGAaoY5QF2QOa8VnOriQCXDfyXHxsuRnE\\n\" +\n+                \"OomxL7EVAgMBAAGjeDB2MAsGA1UdDwQEAwID6DAdBgNVHQ4EFgQUXNCJK3\/dtCIc\\n\" +\n+                \"xb+zlA\/JINlvs\/MwHwYDVR0jBBgwFoAUuXzV2d+nTAOu\/Q4nWzGVbMfzdeEwJwYD\\n\" +\n+                \"VR0lBCAwHgYIKwYBBQUHAwEGCCsGAQUFBwMCBggrBgEFBQcDAzANBgkqhkiG9w0B\\n\" +\n+                \"AQQFAAOBgQB2qIDUxA2caMPpGtUACZAPRUtrGssCINIfItETXJZCx\/cRuZ5sP4D9\\n\" +\n+                \"N1acoNDn0hCULe3lhXAeTC9NZ97680yJzregQMV5wATjo1FGsKY30Ma+sc\/nfzQW\\n\" +\n+                \"+h\/7RhYtoG0OTsiaDCvyhI6swkNJzSzrAccPY4+ZgU8HiDLzZTmM3Q==\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEAtz2+PTkj3zg9hh0l\\n\" +\n+                \"xQhcdRiRGX6hvWVH+8biIv62uXS4zxgGqGOUBdkDmvFZzq4kAlw38lx8bLkZxDqJ\\n\" +\n+                \"sS+xFQIDAQABAkByx\/5Oo2hQ\/w2q4L8z+NTRlJ3vdl8iIDtC\/4XPnfYfnGptnpG6\\n\" +\n+                \"ZThQRvbMZiai0xHQPQMszvAHjZVme1eDl3EBAiEA3aKJHynPVCEJhpfCLWuMwX5J\\n\" +\n+                \"1LntwJO7NTOyU5m8rPECIQDTpzn5X44r2rzWBDna\/Sx7HW9IWCxNgUD2Eyi2nA7W\\n\" +\n+                \"ZQIgJerEorw4aCAuzQPxiGu57PB6GRamAihEAtoRTBQlH0ECIQDN08FgTtnesgCU\\n\" +\n+                \"DFYLLcw1CiHvc7fZw4neBDHCrC8NtQIgA8TOUkGnpCZlQ0KaI8KfKWI+vxFcgFnH\\n\" +\n+                \"3fnqsTgaUs4=\"\n+        ),\n+\n+        EE_DSA_2048(\n+                \"DSA\",\n+                \/\/ SHA256withDSA, 2048 bits\n+                \/\/ Validity\n+                \/\/     Not Before: May 22 07:18:20 2018 GMT\n+                \/\/     Not After : May 17 07:18:20 2038 GMT\n+                \/\/ Authority Key Identifier:\n+                \/\/     76:66:9E:F7:3B:DD:45:E5:3B:D9:72:3C:3F:F0:54:39:86:31:26:53\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIIEnDCCBEGgAwIBAgIJAP\/jh1qVhNVjMAsGCWCGSAFlAwQDAjA7MQswCQYDVQQG\\n\" +\n+                \"EwJVUzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2\\n\" +\n+                \"Y2UwHhcNMTgwNTIyMDcxODIwWhcNMzgwNTE3MDcxODIwWjBVMQswCQYDVQQGEwJV\\n\" +\n+                \"UzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2Y2Ux\\n\" +\n+                \"GDAWBgNVBAMMD1JlZ3Jlc3Npb24gVGVzdDCCA0cwggI6BgcqhkjOOAQBMIICLQKC\\n\" +\n+                \"AQEAmlavgoJrMcjqWRVcDE2dmWAPREgnzQvneEDef68cprDzjSwvOs5QeFyx75ib\\n\" +\n+                \"ado1e6jO\/rW1prCGWHDD1oA\/Tn4Pk3vu0nUxzvl1qATc+aJbpUU5Op0bvp6LbCsQ\\n\" +\n+                \"QslV9FeRh7Eb7bP6gpc\/kHCBzEgC1VCK7prccXWy+t6SMOHbND3h+UbckfSaUuaV\\n\" +\n+                \"sVJNTD1D6GElfRj4Nmz1BGPfSYvKorwNZEU3gXwFgtDoAcGx7tcyClLpDHfqRfw\/\\n\" +\n+                \"7yiqLyeiP7D4hl5lMNouJWDlAdMFp0FMgS3s9VDFinIcr6VtBWMTG7+4+czHAB+3\\n\" +\n+                \"fvrwlqNzhBn3uFHrekN\/w8fNxwIhAJo7Sae1za7IMW0Q6hE5B4b+s2B\/FaKPoA4E\\n\" +\n+                \"jtZu13B9AoIBAQCOZqLMKfvqZWUgT0PQ3QjR7dAFdd06I9Y3+TOQzZk1+j+vw\/6E\\n\" +\n+                \"X4vFItX4gihb\/u5Q9CdmpwhVGi7bvo+7+\/IKeTgoQ6f5+PSug7SrWWUQ5sPwaZui\\n\" +\n+                \"zXZJ5nTeZDucFc2yFx0wgnjbPwiUxZklOT7xGiOMtzOTa2koCz5KuIBL+\/wPKKxm\\n\" +\n+                \"ypo9VoY9xfbdU6LMXZv\/lpD5XTM9rYHr\/vUTNkukvV6Hpm0YMEWhVZKUJiqCqTqG\\n\" +\n+                \"XHaleOxSw6uQWB\/+TznifcC7gB48UOQjCqOKf5VuwQneJLhlhU\/jhRV3xtr+hLZa\\n\" +\n+                \"hW1wYhVi8cjLDrZFKlgEQqhB4crnJU0mJY+tA4IBBQACggEAID0ezl00\/X8mv7eb\\n\" +\n+                \"bzovum1+DEEP7FM57k6HZEG2N3ve4CW+0m9Cd+cWPz8wkZ+M0j\/Eqa6F0IdbkXEc\\n\" +\n+                \"Q7CuzvUyJ57xQ3L\/WCgXsiS+Bh8O4Mz7GwW22CGmHqafbVv+hKBfr8MkskO6GJUt\\n\" +\n+                \"SUF\/CVLzB4gMIvZMH26tBP2xK+i7FeEK9kT+nGdzQSZBAhFYpEVCBplHZO24\/OYq\\n\" +\n+                \"1DNoU327nUuXIhmsfA8N0PjiWbIZIjTPwBGr9H0LpATI7DIDNcvRRvtROP+pBU9y\\n\" +\n+                \"fuykPkptg9C0rCM9t06bukpOSaEz\/2VIQdLE8fHYFA6pHZ6CIc2+5cfvMgTPhcjz\\n\" +\n+                \"W2jCt6MjMCEwHwYDVR0jBBgwFoAUdmae9zvdReU72XI8P\/BUOYYxJlMwCwYJYIZI\\n\" +\n+                \"AWUDBAMCA0gAMEUCIQCeI5fN08b9BpOaHdc3zQNGjp24FOL\/RxlBLeBAorswJgIg\\n\" +\n+                \"JEZ8DhYxQy1O7mmZ2UIT7op6epWMB4dENjs0qWPmcKo=\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MIICZQIBADCCAjoGByqGSM44BAEwggItAoIBAQCaVq+CgmsxyOpZFVwMTZ2ZYA9E\\n\" +\n+                \"SCfNC+d4QN5\/rxymsPONLC86zlB4XLHvmJtp2jV7qM7+tbWmsIZYcMPWgD9Ofg+T\\n\" +\n+                \"e+7SdTHO+XWoBNz5olulRTk6nRu+notsKxBCyVX0V5GHsRvts\/qClz+QcIHMSALV\\n\" +\n+                \"UIrumtxxdbL63pIw4ds0PeH5RtyR9JpS5pWxUk1MPUPoYSV9GPg2bPUEY99Ji8qi\\n\" +\n+                \"vA1kRTeBfAWC0OgBwbHu1zIKUukMd+pF\/D\/vKKovJ6I\/sPiGXmUw2i4lYOUB0wWn\\n\" +\n+                \"QUyBLez1UMWKchyvpW0FYxMbv7j5zMcAH7d++vCWo3OEGfe4Uet6Q3\/Dx83HAiEA\\n\" +\n+                \"mjtJp7XNrsgxbRDqETkHhv6zYH8Voo+gDgSO1m7XcH0CggEBAI5moswp++plZSBP\\n\" +\n+                \"Q9DdCNHt0AV13Toj1jf5M5DNmTX6P6\/D\/oRfi8Ui1fiCKFv+7lD0J2anCFUaLtu+\\n\" +\n+                \"j7v78gp5OChDp\/n49K6DtKtZZRDmw\/Bpm6LNdknmdN5kO5wVzbIXHTCCeNs\/CJTF\\n\" +\n+                \"mSU5PvEaI4y3M5NraSgLPkq4gEv7\/A8orGbKmj1Whj3F9t1Tosxdm\/+WkPldMz2t\\n\" +\n+                \"gev+9RM2S6S9XoembRgwRaFVkpQmKoKpOoZcdqV47FLDq5BYH\/5POeJ9wLuAHjxQ\\n\" +\n+                \"5CMKo4p\/lW7BCd4kuGWFT+OFFXfG2v6EtlqFbXBiFWLxyMsOtkUqWARCqEHhyucl\\n\" +\n+                \"TSYlj60EIgIgLfA75+8KcKxdN8mr6gzGjQe7jPFGG42Ejhd7Q2F4wuw=\"),\n+\n+        EE_DSA_1024(\n+                \"DSA\",\n+                \/\/ dsaWithSHA1, 1024 bits\n+                \/\/ Validity\n+                \/\/     Not Before: Apr 24 12:25:43 2020 GMT\n+                \/\/     Not After : Apr 22 12:25:43 2030 GMT\n+                \/\/ Authority Key Identifier:\n+                \/\/     E1:3C:01:52:EB:D1:38:F7:CF:F1:E3:5E:DB:54:75:7F:5E:AB:2D:36\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIIDADCCAr+gAwIBAgIUd2XJ5F2VTbk9a92w\/NzLXR5zjUQwCQYHKoZIzjgEAzAu\\n\" +\n+                \"MQswCQYDVQQGEwJVUzENMAsGA1UECgwESmF2YTEQMA4GA1UECwwHU3VuSlNTRTAe\\n\" +\n+                \"Fw0yMDA0MjQxMjI1NDNaFw0zMDA0MjIxMjI1NDNaMEgxCzAJBgNVBAYTAlVTMQ0w\\n\" +\n+                \"CwYDVQQKDARKYXZhMRAwDgYDVQQLDAdTdW5KU1NFMRgwFgYDVQQDDA9SZWdyZXNz\\n\" +\n+                \"aW9uIFRlc3QwggG3MIIBLAYHKoZIzjgEATCCAR8CgYEA7fSkxYISlMJT+i8N5VOb\\n\" +\n+                \"lHhjrPYAy3oR2\/YXQW6T0hCMhm8jmxgk1bDId9ZKHrxsM05EkCtRYaqag4ZZeGde\\n\" +\n+                \"ywv3IwwYqCQfGtkPwT9QAsdSABYwGOrlhEtZtBG1yQ44c+Rz\/Vs+PtkAyZbf5VG1\\n\" +\n+                \"iSxFb9bI5QFJWJ9a2VpZh58CFQCCGALQoK4MsQP8V72WlB7Bvt9erwKBgQDCxu0G\\n\" +\n+                \"M2iZr0J8DaAo9\/ChS4m7E7h6Jz9KOm2cFhzYGekkUXNzny7nyz6Qpgbuf8KNFKjt\\n\" +\n+                \"qoUDC8tlcVQAUlTcESC0TZXR3h21hl9wzIBhE+kJ1j8v1KAxfOaJOxObk5QEvIaA\\n\" +\n+                \"5j+jiHGwRS5tDqywOatz+emwMZv1wKnCNBElNgOBhAACgYBHjuQKucCuuvy\/4DpG\\n\" +\n+                \"rSIzdueK+HrzOW8h2pfvz3lzpsyV6XJPC6we9CjaQjU01VcjwN2PoYtbGyml0pbK\\n\" +\n+                \"We4sdgn6LDL1aCM\/WKRSxGHVTx+wkhKQ719YtiC0T6sA+eLirc6VT3\/6+FbQWC+2\\n\" +\n+                \"bG7N19sGpV\/RAXMBpRXUnBJSQaNCMEAwHQYDVR0OBBYEFNNZxyxuQmKvWowofr\/S\\n\" +\n+                \"HdCIS+W8MB8GA1UdIwQYMBaAFOE8AVLr0Tj3z\/HjXttUdX9eqy02MAkGByqGSM44\\n\" +\n+                \"BAMDMAAwLQIUUzzMhZ9St\/Vo\/YdgNTHdTw4cm14CFQCE6tWG157Wl5YFyYsGHsLY\\n\" +\n+                \"NN8uCA==\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MIIBSwIBADCCASwGByqGSM44BAEwggEfAoGBAO30pMWCEpTCU\/ovDeVTm5R4Y6z2\\n\" +\n+                \"AMt6Edv2F0Fuk9IQjIZvI5sYJNWwyHfWSh68bDNORJArUWGqmoOGWXhnXssL9yMM\\n\" +\n+                \"GKgkHxrZD8E\/UALHUgAWMBjq5YRLWbQRtckOOHPkc\/1bPj7ZAMmW3+VRtYksRW\/W\\n\" +\n+                \"yOUBSVifWtlaWYefAhUAghgC0KCuDLED\/Fe9lpQewb7fXq8CgYEAwsbtBjNoma9C\\n\" +\n+                \"fA2gKPfwoUuJuxO4eic\/SjptnBYc2BnpJFFzc58u58s+kKYG7n\/CjRSo7aqFAwvL\\n\" +\n+                \"ZXFUAFJU3BEgtE2V0d4dtYZfcMyAYRPpCdY\/L9SgMXzmiTsTm5OUBLyGgOY\/o4hx\\n\" +\n+                \"sEUubQ6ssDmrc\/npsDGb9cCpwjQRJTYEFgIUNRiLmNzfTYOuVsjkySPzP5gPImM=\"),\n+\n+        EE_ED25519(\n+                \"EdDSA\",\n+                \/\/ ED25519\n+                \/\/ Validity\n+                \/\/     Not Before: May 24 23:32:36 2020 GMT\n+                \/\/     Not After : May 22 23:32:36 2030 GMT\n+                \/\/ X509v3 Authority Key Identifier:\n+                \/\/     keyid:06:76:DB:88:EB:61:55:4C:C9:63:41:C2:A0:A8:57:3F:D7:F1:B8:EC\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIIBlDCCAUagAwIBAgIUFTt\/jcgQ65nhTG8LkrWFJhhEGuwwBQYDK2VwMDsxCzAJ\\n\" +\n+                \"BgNVBAYTAlVTMQ0wCwYDVQQKDARqYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3Qg\\n\" +\n+                \"U2VyaXZjZTAeFw0yMDA1MjQyMzMyMzZaFw0zMDA1MjIyMzMyMzZaMFUxCzAJBgNV\\n\" +\n+                \"BAYTAlVTMQ0wCwYDVQQKDARqYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\\n\" +\n+                \"aXZjZTEYMBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MCowBQYDK2VwAyEAGAYQmKb7\\n\" +\n+                \"WNYpVxIdsc49lI1emNjF06\/Jl85zlG0wc9OjQjBAMB0GA1UdDgQWBBQkJ2E4\/S8Z\\n\" +\n+                \"EIM1v9uTc0eYtYNk3zAfBgNVHSMEGDAWgBQGdtuI62FVTMljQcKgqFc\/1\/G47DAF\\n\" +\n+                \"BgMrZXADQQCVZnl\/AyIEtZ8r45e\/hcfxwuezgRX+7e9NHZFV1A\/TMGcBRORDfDUi\\n\" +\n+                \"bbh72K528fjT7P4\/WoXvm1zJKOAzUOUL\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MC4CAQAwBQYDK2VwBCIEIGBmdh4tfc0lng\/LWokhfFLlo0ZlmTn2lbI639qou2KP\"),\n+\n+        EE_ED448(\n+                \"EdDSA\",\n+                \/\/ ED448\n+                \/\/ Validity\n+                \/\/     Not Before: May 24 23:23:43 2020 GMT\n+                \/\/     Not After : May 22 23:23:43 2030 GMT\n+                \/\/ X509v3 Authority Key Identifier:\n+                \/\/     keyid:F5:D5:9D:FB:6F:B7:50:29:DF:F0:B8:83:10:5F:9B:C4:A8:1C:E9:F4\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIIB3zCCAV+gAwIBAgIUNlWzFrH2+BILqM3SNYQjKoY98S8wBQYDK2VxMDsxCzAJ\\n\" +\n+                \"BgNVBAYTAlVTMQ0wCwYDVQQKDARqYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3Qg\\n\" +\n+                \"U2VyaXZjZTAeFw0yMDA1MjQyMzIzNDNaFw0zMDA1MjIyMzIzNDNaMFUxCzAJBgNV\\n\" +\n+                \"BAYTAlVTMQ0wCwYDVQQKDARqYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\\n\" +\n+                \"aXZjZTEYMBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MEMwBQYDK2VxAzoAoIubPNAg\\n\" +\n+                \"F11u3MQ5d9wujg10+80I0xzYzTqzzXrfJNtw+eU8NbUk86xiCvlMzJRH0Oo3DbY8\\n\" +\n+                \"NAKAo0IwQDAdBgNVHQ4EFgQUUiI1+qT1x+HsDgfZRIU6hUaAbmUwHwYDVR0jBBgw\\n\" +\n+                \"FoAU9dWd+2+3UCnf8LiDEF+bxKgc6fQwBQYDK2VxA3MAx8P0mle08s5YDd\/p58dt\\n\" +\n+                \"yORqvDPwo5IYPasqN8Zeen1B9u1xF\/kvDGFxCJ6D9Gi4ynnDx0FZFMkA83evZcxJ\\n\" +\n+                \"+X+swt7FyHwXrdkZcvjRKEcsWhkj+0FlxYF\/NZzLTGuGIPYJnRLEwf\/zr+5NDxKs\\n\" +\n+                \"fCoA\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MEcCAQAwBQYDK2VxBDsEOfbhmUSuKP9WCO7Nr6JxVq5rfJESk1MNMyYhC134SiAP\\n\" +\n+                \"Suw0Cu7RZVadpfPR7Kiwb2b\/JXjMdY1HAA==\"),\n+\n+        EE_RSASSA_PSS(\n+                \"RSASSA-PSS\",\n+                \/\/ Signature Algorithm: rsassaPss\n+                \/\/ Hash Algorithm: sha256\n+                \/\/ Mask Algorithm: mgf1 with sha256\n+                \/\/\n+                \/\/ Validity\n+                \/\/      Not Before: Jun  6 07:11:00 2018 GMT\n+                \/\/      Not After : Jun  1 07:11:00 2038 GMT\n+                \/\/ X509v3 Authority Key Identifier:\n+                \/\/      1F:16:2B:79:8A:55:89:99:98:02:5F:84:18:D0:7B:1A:23:D8:88:0C\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIIDZjCCAh2gAwIBAgIUHxwPs3eAgJ057nJwiLgWZWeNqdgwPgYJKoZIhvcNAQEK\\n\" +\n+                \"MDGgDTALBglghkgBZQMEAgGhGjAYBgkqhkiG9w0BAQgwCwYJYIZIAWUDBAIBogQC\\n\" +\n+                \"AgDeMBQxEjAQBgNVBAMMCWxvY2FsaG9zdDAeFw0xODA2MDYwNzExMDBaFw0zODA2\\n\" +\n+                \"MDEwNzExMDBaMBQxEjAQBgNVBAMMCWxvY2FsaG9zdDCCASAwCwYJKoZIhvcNAQEK\\n\" +\n+                \"A4IBDwAwggEKAoIBAQCl8r4Qrg27BYUO\/1Va2Ix8QPGzN\/lvzmKvP5Ff26ovNW4v\\n\" +\n+                \"RUx68HzAhhiWtcl+PwLSbJqJreEkTlle7PnRAypby3fO7ZAK0Y3YiHquaBg7d+7Y\\n\" +\n+                \"FhhHwv8gG0lZcyA0BkXFJHqdq76qar0xHC6DVezXm0K3mcceymGtFR9BzWmAj+7D\\n\" +\n+                \"YsSwvtTQ7WNoQmf0cdDMSM71IwaTwIwvT2wzX1vv5hcdDyXdr64WFqWSA9sNJ2K6\\n\" +\n+                \"arxaaU1klwKSgDokF6njafWQ4UxdR67d5W1MYoiioDs2Yy3utsMpO2OUzZVBZNdT\\n\" +\n+                \"gkr1jsJhIurpz\/5K51lwJIRQBezEFSb+60AFVoMJAgMBAAGjUDBOMB0GA1UdDgQW\\n\" +\n+                \"BBQfFit5ilWJmZgCX4QY0HsaI9iIDDAfBgNVHSMEGDAWgBQfFit5ilWJmZgCX4QY\\n\" +\n+                \"0HsaI9iIDDAMBgNVHRMEBTADAQH\/MD4GCSqGSIb3DQEBCjAxoA0wCwYJYIZIAWUD\\n\" +\n+                \"BAIBoRowGAYJKoZIhvcNAQEIMAsGCWCGSAFlAwQCAaIEAgIA3gOCAQEAa4yUQ3gh\\n\" +\n+                \"d1YWPdEa1sv2hdkhtenw6m5yxbmaQl2+nIKSpk4RfpXC7K1EYwBF8TdfFbD8hGGh\\n\" +\n+                \"5n81BT0\/dn1R9SRGCv7KTxx4lfQt31frlsw\/tVciwyXQtcUZ6DqfnLP0\/aRVLNgx\\n\" +\n+                \"zaP542JUHFYLTC3EGz2zUgv70ZUTlIsPG3\/p8YO1iXdnYGQyzOuQPUBpI7nS7UtR\\n\" +\n+                \"Ug8VE9ACpBxxI3qChMahFZGHlXCCSjSmxpQa6UO4SQl8q5tPNnqdzWwvAW8qkCy4\\n\" +\n+                \"6barRQ4sMcGayhHh\/uSTx7bcl0FMJpcI1ygbw7\/Pc03zKtw0gMTBMns7q4yXjb\/u\\n\" +\n+                \"ef47nW0t+LRAAg==\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MIIEuwIBADALBgkqhkiG9w0BAQoEggSnMIIEowIBAAKCAQEApfK+EK4NuwWFDv9V\\n\" +\n+                \"WtiMfEDxszf5b85irz+RX9uqLzVuL0VMevB8wIYYlrXJfj8C0myaia3hJE5ZXuz5\\n\" +\n+                \"0QMqW8t3zu2QCtGN2Ih6rmgYO3fu2BYYR8L\/IBtJWXMgNAZFxSR6nau+qmq9MRwu\\n\" +\n+                \"g1Xs15tCt5nHHsphrRUfQc1pgI\/uw2LEsL7U0O1jaEJn9HHQzEjO9SMGk8CML09s\\n\" +\n+                \"M19b7+YXHQ8l3a+uFhalkgPbDSdiumq8WmlNZJcCkoA6JBep42n1kOFMXUeu3eVt\\n\" +\n+                \"TGKIoqA7NmMt7rbDKTtjlM2VQWTXU4JK9Y7CYSLq6c\/+SudZcCSEUAXsxBUm\/utA\\n\" +\n+                \"BVaDCQIDAQABAoIBAAc4vRS0vlw5LUUtz2UYr2Ro3xvRf8Vh0eGWfpkRUiKjzJu6\\n\" +\n+                \"BE4FUSh\/rWpBlvcrfs\/xcfgz3OxbjIAZB\/YUkS9Vd21F4VLXM7kMl2onlYZg\/b\/h\\n\" +\n+                \"lkTpM3kONu7xl6Er9LVTlRJveuinpHwSoeONRbVMSGb9BjFM1VtW4\/lVGxZBG05D\\n\" +\n+                \"y9i\/o4vCZqULn9cAumOwicKuCyTcS58XcMJ+puSPfRA71PYLxqFkASAoJsUwCXpo\\n\" +\n+                \"gs39lLsIFgrfO8mBO1ux\/SE+QaRc+9XqFSHHKD1XqF\/9zSYBgWjE910EcpdYEdZx\\n\" +\n+                \"GEkwea7Fn4brO5OpIrHY\/45naqbUOBzv6gufMAECgYEAz7PHCdcrQvmOb8EiNbQH\\n\" +\n+                \"uvSimwObWJFeN1ykp6mfRbSnkXw7p8+M4Tc8HFi8QLpoq63Ev2AwoaQCQvHbFC2Y\\n\" +\n+                \"1Cz0EkC0aOp+tZP7U2AUBdkcDesZAJQTad0zV6KesyIUXdxZXDG8JJ1XSNWfTJV4\\n\" +\n+                \"QD+BjLZ0jiAyCIfVYvWQqYkCgYEAzIln1nKTixLMPr5CldSmR7ZarEtPJU+hHwVg\\n\" +\n+                \"dV\/Lc6d2Yy9JgunOXRo4BXB1TEo8JFbK3HBQH6tS8li4qDr7WK5wyYfh8qb4WZyu\\n\" +\n+                \"lc562f2WVYntcN8\/Ojb+Vyrt7lk9sq\/8KoVHxEAWd6mqL9VTPYuAu1Vw9fTGIZfB\\n\" +\n+                \"lDeELYECgYAvdzU4UXzofGGJtohb332YwwlaBZP9xJLUcg6K5l+orWVSASMc8XiP\\n\" +\n+                \"i3DoRXsYC8GZ4kdBOPlEJ1gA9oaLcPQpIPDSLwlLpLM6Scw4vI822uvnXl\/DWxOo\\n\" +\n+                \"sM1n7Jj59QLUhGPDhvYpI+\/rjC4wcUQe4qR3hMbUKBVnD6u7RsU9iQKBgQCQ17VK\\n\" +\n+                \"7bSCRfuRaxaoGADww7gOTv5rQ6qr1xjpxb7D1hFGR9Rc+smCsPB\/GZZXQjK44SWj\\n\" +\n+                \"WX3ED4Ubzaxmpe4cbNu+O5XMSmWQwB36RFBHUwdE5\/nXdqDFzu\/qNqJrqZLBmVKP\\n\" +\n+                \"ofaiiWffsaytVvotmT6+atElvAMbAua42V+nAQKBgHtIn3mYMHLriYGhQzpkFEA2\\n\" +\n+                \"8YcAMlKppueOMAKVy8nLu2r3MidmLAhMiKJQKG45I3Yg0\/t\/25tXLiOPJlwrOebh\\n\" +\n+                \"xQqUBI\/JUOIpGAEnr48jhOXnCS+i+z294G5U\/RgjXrlR4bCPvrtCmwzWwe0h79w2\\n\" +\n+                \"Q2hO5ZTW6UD9CVA85whf\");\n+\n+        final String keyAlgo;\n+        final String certStr;\n+        final String privKeyStr;\n+\n+        Cert(String keyAlgo, String certStr, String privKeyStr) {\n+            this.keyAlgo = keyAlgo;\n+            this.certStr = certStr;\n+            this.privKeyStr = privKeyStr;\n@@ -563,8 +952,0 @@\n-\n-        \/\/ Create an SSLContext object.\n-        TrustManagerFactory tmf =\n-                TrustManagerFactory.getInstance(params.tmAlgorithm);\n-        tmf.init(ts);\n-\n-        TrustManager[] tms = tmf.getTrustManagers();\n-        return tms[0];\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLContextTemplate.java","additions":851,"deletions":470,"binary":false,"changes":1321,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-public class SSLEngineTemplate implements SSLContextTemplate {\n+public class SSLEngineTemplate extends SSLContextTemplate {\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLEngineTemplate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,532 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/\n-\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n-\/\/ system properties in samevm\/agentvm mode.\n-\/\/\n-\n-\/*\n- * @test\n- * @bug 7105780\n- * @summary Add SSLSocket client\/SSLEngine server to templates directory.\n- * @run main\/othervm SSLSocketSSLEngineTemplate TLSv1\n- * @run main\/othervm SSLSocketSSLEngineTemplate TLSv1.1\n- * @run main\/othervm SSLSocketSSLEngineTemplate TLSv1.2\n- * @run main\/othervm SSLSocketSSLEngineTemplate TLSv1.3\n- *\/\n-\n-\/**\n- * A SSLSocket\/SSLEngine interop test case.  This is not the way to\n- * code SSLEngine-based servers, but works for what we need to do here,\n- * which is to make sure that SSLEngine\/SSLSockets can talk to each other.\n- * SSLEngines can use direct or indirect buffers, and different code\n- * is used to get at the buffer contents internally, so we test that here.\n- *\n- * The test creates one SSLSocket (client) and one SSLEngine (server).\n- * The SSLSocket talks to a raw ServerSocket, and the server code\n- * does the translation between byte [] and ByteBuffers that the SSLEngine\n- * can use.  The \"transport\" layer consists of a Socket Input\/OutputStream\n- * and two byte buffers for the SSLEngines:  think of them\n- * as directly connected pipes.\n- *\n- * Again, this is a *very* simple example: real code will be much more\n- * involved.  For example, different threading and I\/O models could be\n- * used, transport mechanisms could close unexpectedly, and so on.\n- *\n- * When this application runs, notice that several messages\n- * (wrap\/unwrap) pass before any application data is consumed or\n- * produced.  (For more information, please see the SSL\/TLS\n- * specifications.)  There may several steps for a successful handshake,\n- * so it's typical to see the following series of operations:\n- *\n- *      client          server          message\n- *      ======          ======          =======\n- *      write()         ...             ClientHello\n- *      ...             unwrap()        ClientHello\n- *      ...             wrap()          ServerHello\/Certificate\n- *      read()          ...             ServerHello\/Certificate\n- *      write()         ...             ClientKeyExchange\n- *      write()         ...             ChangeCipherSpec\n- *      write()         ...             Finished\n- *      ...             unwrap()        ClientKeyExchange\n- *      ...             unwrap()        ChangeCipherSpec\n- *      ...             unwrap()        Finished\n- *      ...             wrap()          ChangeCipherSpec\n- *      ...             wrap()          Finished\n- *      read()          ...             ChangeCipherSpec\n- *      read()          ...             Finished\n- *\/\n-import javax.net.ssl.*;\n-import javax.net.ssl.SSLEngineResult.*;\n-import java.io.*;\n-import java.net.*;\n-import java.security.*;\n-import java.nio.*;\n-\n-public class SSLSocketSSLEngineTemplate {\n-\n-    \/*\n-     * Enables logging of the SSL\/TLS operations.\n-     *\/\n-    private static final boolean logging = true;\n-\n-    \/*\n-     * Enables the JSSE system debugging system property:\n-     *\n-     *     -Djavax.net.debug=all\n-     *\n-     * This gives a lot of low-level information about operations underway,\n-     * including specific handshake messages, and might be best examined\n-     * after gaining some familiarity with this application.\n-     *\/\n-    private static final boolean debug = false;\n-    private final SSLContext sslc;\n-    private SSLEngine serverEngine;     \/\/ server-side SSLEngine\n-    private SSLSocket clientSocket;\n-\n-    private final byte[] serverMsg =\n-        \"Hi there Client, I'm a Server.\".getBytes();\n-    private final byte[] clientMsg =\n-        \"Hello Server, I'm a Client! Pleased to meet you!\".getBytes();\n-\n-    private ByteBuffer serverOut;       \/\/ write side of serverEngine\n-    private ByteBuffer serverIn;        \/\/ read side of serverEngine\n-\n-    private volatile Exception clientException;\n-    private volatile Exception serverException;\n-\n-    \/*\n-     * For data transport, this example uses local ByteBuffers.\n-     *\/\n-    private ByteBuffer cTOs;            \/\/ \"reliable\" transport client->server\n-    private ByteBuffer sTOc;            \/\/ \"reliable\" transport server->client\n-\n-    \/*\n-     * The following is to set up the keystores\/trust material.\n-     *\/\n-    private static final String pathToStores = \"..\/etc\";\n-    private static final String keyStoreFile = \"keystore\";\n-    private static final String trustStoreFile = \"truststore\";\n-    private static final String keyFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores\n-            + \"\/\" + keyStoreFile;\n-    private static final String trustFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores\n-            + \"\/\" + trustStoreFile;\n-\n-    \/*\n-     * Main entry point for this test.\n-     *\/\n-    public static void main(String args[]) throws Exception {\n-        String protocol = args[0];\n-\n-        \/\/ reset security properties to make sure that the algorithms\n-        \/\/ and keys used in this test are not disabled.\n-        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n-        Security.setProperty(\"jdk.certpath.disabledAlgorithms\", \"\");\n-\n-        if (debug) {\n-            System.setProperty(\"javax.net.debug\", \"all\");\n-        }\n-\n-        \/*\n-         * Run the tests with direct and indirect buffers.\n-         *\/\n-        SSLSocketSSLEngineTemplate test =\n-            new SSLSocketSSLEngineTemplate(protocol);\n-        log(\"-------------------------------------\");\n-        log(\"Testing \" + protocol + \" for direct buffers ...\");\n-        test.runTest(true);\n-\n-        log(\"---------------------------------------\");\n-        log(\"Testing \" + protocol + \" for indirect buffers ...\");\n-        test.runTest(false);\n-\n-        log(\"Test Passed.\");\n-    }\n-\n-    \/*\n-     * Create an initialized SSLContext to use for these tests.\n-     *\/\n-    public SSLSocketSSLEngineTemplate(String protocol) throws Exception {\n-\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        KeyStore ts = KeyStore.getInstance(\"JKS\");\n-\n-        char[] passphrase = \"passphrase\".toCharArray();\n-\n-        try (FileInputStream keyFile = new FileInputStream(keyFilename);\n-                FileInputStream trustFile = new FileInputStream(trustFilename)) {\n-            ks.load(keyFile, passphrase);\n-            ts.load(trustFile, passphrase);\n-        }\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(ks, passphrase);\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(ts);\n-\n-        SSLContext sslCtx = SSLContext.getInstance(protocol);\n-\n-        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-        sslc = sslCtx;\n-    }\n-\n-    \/*\n-     * Run the test.\n-     *\n-     * Sit in a tight loop, with the server engine calling wrap\/unwrap\n-     * regardless of whether data is available or not.  We do this until\n-     * we get the application data.  Then we shutdown and go to the next one.\n-     *\n-     * The main loop handles all of the I\/O phases of the SSLEngine's\n-     * lifetime:\n-     *\n-     *     initial handshaking\n-     *     application data transfer\n-     *     engine closing\n-     *\n-     * One could easily separate these phases into separate\n-     * sections of code.\n-     *\/\n-    private void runTest(boolean direct) throws Exception {\n-        clientSocket = null;\n-        boolean serverClose = direct;\n-\n-        \/\/ generates the server-side Socket\n-        try (ServerSocket serverSocket = new ServerSocket()) {\n-            serverSocket.setReuseAddress(false);\n-            serverSocket.bind(null);\n-            int port = serverSocket.getLocalPort();\n-            log(\"Port: \" + port);\n-            Thread thread = createClientThread(port, serverClose);\n-\n-            createSSLEngine();\n-            createBuffers(direct);\n-\n-            \/\/ server-side socket that will read\n-            try (Socket socket = serverSocket.accept()) {\n-                socket.setSoTimeout(500);\n-\n-                boolean closed = false;\n-                \/\/ will try to read one more time in case client message\n-                \/\/ is fragmented to multiple pieces\n-                boolean retry = true;\n-\n-                InputStream is = socket.getInputStream();\n-                OutputStream os = socket.getOutputStream();\n-\n-                SSLEngineResult serverResult;   \/\/ results from last operation\n-\n-                \/*\n-                 * Examining the SSLEngineResults could be much more involved,\n-                 * and may alter the overall flow of the application.\n-                 *\n-                 * For example, if we received a BUFFER_OVERFLOW when trying\n-                 * to write to the output pipe, we could reallocate a larger\n-                 * pipe, but instead we wait for the peer to drain it.\n-                 *\/\n-                byte[] inbound = new byte[8192];\n-                byte[] outbound = new byte[8192];\n-\n-                while (!isEngineClosed(serverEngine)) {\n-                    int len;\n-\n-                    \/\/ Inbound data\n-                    log(\"================\");\n-\n-                    \/\/ Read from the Client side.\n-                    try {\n-                        len = is.read(inbound);\n-                        if (len == -1) {\n-                            logSocketStatus(clientSocket);\n-                            if (clientSocket.isClosed()\n-                                    || clientSocket.isOutputShutdown()) {\n-                                log(\"Client socket was closed or shutdown output\");\n-                                break;\n-                            } else {\n-                                throw new Exception(\"Unexpected EOF\");\n-                            }\n-                        }\n-                        cTOs.put(inbound, 0, len);\n-                    } catch (SocketTimeoutException ste) {\n-                        \/\/ swallow. Nothing yet, probably waiting on us.\n-                    }\n-\n-                    cTOs.flip();\n-\n-                    serverResult = serverEngine.unwrap(cTOs, serverIn);\n-                    log(\"server unwrap: \", serverResult);\n-                    runDelegatedTasks(serverResult, serverEngine);\n-                    cTOs.compact();\n-\n-                    \/\/ Outbound data\n-                    log(\"----\");\n-\n-                    serverResult = serverEngine.wrap(serverOut, sTOc);\n-                    log(\"server wrap: \", serverResult);\n-                    runDelegatedTasks(serverResult, serverEngine);\n-\n-                    sTOc.flip();\n-\n-                    if ((len = sTOc.remaining()) != 0) {\n-                        sTOc.get(outbound, 0, len);\n-                        os.write(outbound, 0, len);\n-                        \/\/ Give the other side a chance to process\n-                    }\n-\n-                    sTOc.compact();\n-\n-                    if (!closed && (serverOut.remaining() == 0)) {\n-                        closed = true;\n-\n-                        \/*\n-                         * We'll alternate initiatating the shutdown.\n-                         * When the server initiates, it will take one more\n-                         * loop, but tests the orderly shutdown.\n-                         *\/\n-                        if (serverClose) {\n-                            serverEngine.closeOutbound();\n-                        }\n-                        serverIn.flip();\n-\n-                        \/*\n-                         * A sanity check to ensure we got what was sent.\n-                         *\/\n-                        if (serverIn.remaining() !=  clientMsg.length) {\n-                            if (retry &&\n-                                    serverIn.remaining() < clientMsg.length) {\n-                                log(\"Need to read more from client\");\n-                                serverIn.compact();\n-                                retry = false;\n-                                continue;\n-                            } else {\n-                                throw new Exception(\n-                                        \"Client: Data length error\");\n-                            }\n-                        }\n-\n-                        for (int i = 0; i < clientMsg.length; i++) {\n-                            if (clientMsg[i] != serverIn.get()) {\n-                                throw new Exception(\n-                                        \"Client: Data content error\");\n-                            }\n-                        }\n-                        serverIn.compact();\n-                    }\n-                }\n-            } catch (Exception e) {\n-                serverException = e;\n-            } finally {\n-                \/\/ Wait for the client to join up with us.\n-                if (thread != null) {\n-                    thread.join();\n-                }\n-            }\n-        } finally {\n-            if (serverException != null) {\n-                if (clientException != null) {\n-                    serverException.addSuppressed(clientException);\n-                }\n-                throw serverException;\n-            }\n-            if (clientException != null) {\n-                if (serverException != null) {\n-                    clientException.addSuppressed(serverException);\n-                }\n-                throw clientException;\n-            }\n-        }\n-    }\n-\n-    \/*\n-     * Create a client thread which does simple SSLSocket operations.\n-     * We'll write and read one data packet.\n-     *\/\n-    private Thread createClientThread(final int port,\n-            final boolean serverClose) throws Exception {\n-\n-        Thread t = new Thread(\"ClientThread\") {\n-\n-            @Override\n-            public void run() {\n-                \/\/ client-side socket\n-                try (SSLSocket sslSocket = (SSLSocket)sslc.getSocketFactory().\n-                            createSocket(\"localhost\", port)) {\n-                    clientSocket = sslSocket;\n-\n-                    OutputStream os = sslSocket.getOutputStream();\n-                    InputStream is = sslSocket.getInputStream();\n-\n-                    \/\/ write(byte[]) goes in one shot.\n-                    os.write(clientMsg);\n-\n-                    byte[] inbound = new byte[2048];\n-                    int pos = 0;\n-\n-                    int len;\n-                    while ((len = is.read(inbound, pos, 2048 - pos)) != -1) {\n-                        pos += len;\n-                        \/\/ Let the client do the closing.\n-                        if ((pos == serverMsg.length) && !serverClose) {\n-                            sslSocket.close();\n-                            break;\n-                        }\n-                    }\n-\n-                    if (pos != serverMsg.length) {\n-                        throw new Exception(\"Client:  Data length error\");\n-                    }\n-\n-                    for (int i = 0; i < serverMsg.length; i++) {\n-                        if (inbound[i] != serverMsg[i]) {\n-                            throw new Exception(\"Client:  Data content error\");\n-                        }\n-                    }\n-                } catch (Exception e) {\n-                    clientException = e;\n-                }\n-            }\n-        };\n-        t.start();\n-        return t;\n-    }\n-\n-    \/*\n-     * Using the SSLContext created during object creation,\n-     * create\/configure the SSLEngines we'll use for this test.\n-     *\/\n-    private void createSSLEngine() throws Exception {\n-        \/*\n-         * Configure the serverEngine to act as a server in the SSL\/TLS\n-         * handshake.\n-         *\/\n-        serverEngine = sslc.createSSLEngine();\n-        serverEngine.setUseClientMode(false);\n-        serverEngine.getNeedClientAuth();\n-    }\n-\n-    \/*\n-     * Create and size the buffers appropriately.\n-     *\/\n-    private void createBuffers(boolean direct) {\n-\n-        SSLSession session = serverEngine.getSession();\n-        int appBufferMax = session.getApplicationBufferSize();\n-        int netBufferMax = session.getPacketBufferSize();\n-\n-        \/*\n-         * We'll make the input buffers a bit bigger than the max needed\n-         * size, so that unwrap()s following a successful data transfer\n-         * won't generate BUFFER_OVERFLOWS.\n-         *\n-         * We'll use a mix of direct and indirect ByteBuffers for\n-         * tutorial purposes only.  In reality, only use direct\n-         * ByteBuffers when they give a clear performance enhancement.\n-         *\/\n-        if (direct) {\n-            serverIn = ByteBuffer.allocateDirect(appBufferMax + 50);\n-            cTOs = ByteBuffer.allocateDirect(netBufferMax);\n-            sTOc = ByteBuffer.allocateDirect(netBufferMax);\n-        } else {\n-            serverIn = ByteBuffer.allocate(appBufferMax + 50);\n-            cTOs = ByteBuffer.allocate(netBufferMax);\n-            sTOc = ByteBuffer.allocate(netBufferMax);\n-        }\n-\n-        serverOut = ByteBuffer.wrap(serverMsg);\n-    }\n-\n-    \/*\n-     * If the result indicates that we have outstanding tasks to do,\n-     * go ahead and run them in this thread.\n-     *\/\n-    private static void runDelegatedTasks(SSLEngineResult result,\n-            SSLEngine engine) throws Exception {\n-\n-        if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n-            Runnable runnable;\n-            while ((runnable = engine.getDelegatedTask()) != null) {\n-                log(\"\\trunning delegated task...\");\n-                runnable.run();\n-            }\n-            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n-            if (hsStatus == HandshakeStatus.NEED_TASK) {\n-                throw new Exception(\n-                        \"handshake shouldn't need additional tasks\");\n-            }\n-            log(\"\\tnew HandshakeStatus: \" + hsStatus);\n-        }\n-    }\n-\n-    private static boolean isEngineClosed(SSLEngine engine) {\n-        return (engine.isOutboundDone() && engine.isInboundDone());\n-    }\n-\n-    private static void logSocketStatus(Socket socket) {\n-        log(\"##### \" + socket + \" #####\");\n-        log(\"isBound: \" + socket.isBound());\n-        log(\"isConnected: \" + socket.isConnected());\n-        log(\"isClosed: \" + socket.isClosed());\n-        log(\"isInputShutdown: \" + socket.isInputShutdown());\n-        log(\"isOutputShutdown: \" + socket.isOutputShutdown());\n-    }\n-\n-    \/*\n-     * Logging code\n-     *\/\n-    private static boolean resultOnce = true;\n-\n-    private static void log(String str, SSLEngineResult result) {\n-        if (!logging) {\n-            return;\n-        }\n-        if (resultOnce) {\n-            resultOnce = false;\n-            log(\"The format of the SSLEngineResult is: \\n\"\n-                    + \"\\t\\\"getStatus() \/ getHandshakeStatus()\\\" +\\n\"\n-                    + \"\\t\\\"bytesConsumed() \/ bytesProduced()\\\"\\n\");\n-        }\n-        HandshakeStatus hsStatus = result.getHandshakeStatus();\n-        log(str\n-                + result.getStatus() + \"\/\" + hsStatus + \", \"\n-                + result.bytesConsumed() + \"\/\" + result.bytesProduced()\n-                + \" bytes\");\n-        if (hsStatus == HandshakeStatus.FINISHED) {\n-            log(\"\\t...ready for application data\");\n-        }\n-    }\n-\n-    private static void log(String str) {\n-        if (logging) {\n-            if (debug) {\n-                System.err.println(str);\n-            } else {\n-                System.out.println(str);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLSocketSSLEngineTemplate.java","additions":0,"deletions":532,"binary":false,"changes":532,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import java.io.ByteArrayInputStream;\n@@ -41,1 +40,0 @@\n-import javax.net.ssl.KeyManagerFactory;\n@@ -47,1 +45,0 @@\n-import javax.net.ssl.TrustManagerFactory;\n@@ -51,7 +48,0 @@\n-import java.security.KeyStore;\n-import java.security.PrivateKey;\n-import java.security.KeyFactory;\n-import java.security.cert.Certificate;\n-import java.security.cert.CertificateFactory;\n-import java.security.spec.PKCS8EncodedKeySpec;\n-import java.util.Base64;\n@@ -69,1 +59,1 @@\n-public class SSLSocketTemplate {\n+public class SSLSocketTemplate extends SSLContextTemplate {\n@@ -131,47 +121,0 @@\n-    \/*\n-     * Create an instance of SSLContext for client use.\n-     *\/\n-    protected SSLContext createClientSSLContext() throws Exception {\n-        return createSSLContext(TRUSTED_CERTS, END_ENTITY_CERTS,\n-                getClientContextParameters());\n-    }\n-\n-    \/*\n-     * Create an instance of SSLContext for server use.\n-     *\/\n-    protected SSLContext createServerSSLContext() throws Exception {\n-        return createSSLContext(TRUSTED_CERTS, END_ENTITY_CERTS,\n-                getServerContextParameters());\n-    }\n-\n-    \/*\n-     * The parameters used to configure SSLContext.\n-     *\/\n-    protected static final class ContextParameters {\n-        final String contextProtocol;\n-        final String tmAlgorithm;\n-        final String kmAlgorithm;\n-\n-        ContextParameters(String contextProtocol,\n-                String tmAlgorithm, String kmAlgorithm) {\n-\n-            this.contextProtocol = contextProtocol;\n-            this.tmAlgorithm = tmAlgorithm;\n-            this.kmAlgorithm = kmAlgorithm;\n-        }\n-    }\n-\n-    \/*\n-     * Get the client side parameters of SSLContext.\n-     *\/\n-    protected ContextParameters getClientContextParameters() {\n-        return new ContextParameters(\"TLS\", \"PKIX\", \"NewSunX509\");\n-    }\n-\n-    \/*\n-     * Get the server side parameters of SSLContext.\n-     *\/\n-    protected ContextParameters getServerContextParameters() {\n-        return new ContextParameters(\"TLS\", \"PKIX\", \"NewSunX509\");\n-    }\n-\n@@ -363,108 +306,0 @@\n-    \/*\n-     * =============================================\n-     * Stuffs to customize the SSLContext instances.\n-     *\/\n-\n-    \/*\n-     * =======================================\n-     * Certificates and keys used in the test.\n-     *\/\n-    \/\/ Trusted certificates.\n-    protected final static Cert[] TRUSTED_CERTS = {\n-            Cert.CA_ECDSA_SECP256R1,\n-            Cert.CA_RSA_2048,\n-            Cert.CA_DSA_2048 };\n-\n-    \/\/ End entity certificate.\n-    protected final static Cert[] END_ENTITY_CERTS = {\n-            Cert.EE_ECDSA_SECP256R1,\n-            Cert.EE_RSA_2048,\n-            Cert.EE_EC_RSA_SECP256R1,\n-            Cert.EE_DSA_2048 };\n-\n-    \/*\n-     * Create an instance of SSLContext with the specified trust\/key materials.\n-     *\/\n-    public static SSLContext createSSLContext(\n-            Cert[] trustedCerts,\n-            Cert[] endEntityCerts,\n-            ContextParameters params) throws Exception {\n-\n-        KeyStore ts = null;     \/\/ trust store\n-        KeyStore ks = null;     \/\/ key store\n-        char passphrase[] = \"passphrase\".toCharArray();\n-\n-        \/\/ Generate certificate from cert string.\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        \/\/ Import the trused certs.\n-        ByteArrayInputStream is;\n-        if (trustedCerts != null && trustedCerts.length != 0) {\n-            ts = KeyStore.getInstance(\"JKS\");\n-            ts.load(null, null);\n-\n-            Certificate[] trustedCert = new Certificate[trustedCerts.length];\n-            for (int i = 0; i < trustedCerts.length; i++) {\n-                is = new ByteArrayInputStream(trustedCerts[i].certStr.getBytes());\n-                try {\n-                    trustedCert[i] = cf.generateCertificate(is);\n-                } finally {\n-                    is.close();\n-                }\n-\n-                ts.setCertificateEntry(\n-                        \"trusted-cert-\" + trustedCerts[i].name(), trustedCert[i]);\n-            }\n-        }\n-\n-        \/\/ Import the key materials.\n-        if (endEntityCerts != null && endEntityCerts.length != 0) {\n-            ks = KeyStore.getInstance(\"JKS\");\n-            ks.load(null, null);\n-\n-            for (int i = 0; i < endEntityCerts.length; i++) {\n-                \/\/ generate the private key.\n-                PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n-                    Base64.getMimeDecoder().decode(endEntityCerts[i].privKeyStr));\n-                KeyFactory kf =\n-                    KeyFactory.getInstance(\n-                            endEntityCerts[i].keyAlgo);\n-                PrivateKey priKey = kf.generatePrivate(priKeySpec);\n-\n-                \/\/ generate certificate chain\n-                is = new ByteArrayInputStream(\n-                        endEntityCerts[i].certStr.getBytes());\n-                Certificate keyCert = null;\n-                try {\n-                    keyCert = cf.generateCertificate(is);\n-                } finally {\n-                    is.close();\n-                }\n-\n-                Certificate[] chain = new Certificate[] { keyCert };\n-\n-                \/\/ import the key entry.\n-                ks.setKeyEntry(\"cert-\" + endEntityCerts[i].name(),\n-                        priKey, passphrase, chain);\n-            }\n-        }\n-\n-        \/\/ Create an SSLContext object.\n-        TrustManagerFactory tmf =\n-                TrustManagerFactory.getInstance(params.tmAlgorithm);\n-        tmf.init(ts);\n-\n-        SSLContext context = SSLContext.getInstance(params.contextProtocol);\n-        if (endEntityCerts != null && endEntityCerts.length != 0 && ks != null) {\n-            KeyManagerFactory kmf =\n-                    KeyManagerFactory.getInstance(params.kmAlgorithm);\n-            kmf.init(ks, passphrase);\n-\n-            context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-        } else {\n-            context.init(null, tmf.getTrustManagers(), null);\n-        }\n-\n-        return context;\n-    }\n-\n@@ -600,1 +435,1 @@\n-    private void startClient(boolean newThread) throws Exception {\n+    private void startClient(boolean newThread) {\n@@ -632,569 +467,0 @@\n-    public static enum Cert {\n-\n-        CA_ECDSA_SECP256R1(\n-                \"EC\",\n-                \/\/ SHA256withECDSA, curve secp256r1\n-                \/\/ Validity\n-                \/\/     Not Before: May 22 07:18:16 2018 GMT\n-                \/\/     Not After : May 17 07:18:16 2038 GMT\n-                \/\/ Subject Key Identifier:\n-                \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIIBvjCCAWOgAwIBAgIJAIvFG6GbTroCMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n-                \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n-                \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYTAlVT\\n\" +\n-                \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTBZ\\n\" +\n-                \"MBMGByqGSM49AgEGCCqGSM49AwEHA0IABBz1WeVb6gM2mh85z3QlvaB\/l11b5h0v\\n\" +\n-                \"LIzmkC3DKlVukZT+ltH2Eq1oEkpXuf7QmbM0ibrUgtjsWH3mULfmcWmjUDBOMB0G\\n\" +\n-                \"A1UdDgQWBBRgz71z\/\/oaMNKk7NNJcUbvGjWghjAfBgNVHSMEGDAWgBRgz71z\/\/oa\\n\" +\n-                \"MNKk7NNJcUbvGjWghjAMBgNVHRMEBTADAQH\/MAoGCCqGSM49BAMCA0kAMEYCIQCG\\n\" +\n-                \"6wluh1r2\/T6L31mZXRKf9JxeSf9pIzoLj+8xQeUChQIhAJ09wAi1kV8yePLh2FD9\\n\" +\n-                \"2YEHlSQUAbwwqCDEVB5KxaqP\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQg\/HcHdoLJCdq3haVd\\n\" +\n-                \"XZTSKP00YzM3xX97l98vGL\/RI1KhRANCAAQc9VnlW+oDNpofOc90Jb2gf5ddW+Yd\\n\" +\n-                \"LyyM5pAtwypVbpGU\/pbR9hKtaBJKV7n+0JmzNIm61ILY7Fh95lC35nFp\"),\n-\n-        CA_ECDSA_SECP384R1(\n-                \"EC\",\n-                \/\/ SHA384withECDSA, curve secp384r1\n-                \/\/ Validity\n-                \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n-                \/\/     Not After : Jun 19 08:15:06 2039 GMT\n-                \/\/ Subject Key Identifier:\n-                \/\/     0a:93:a9:a0:bf:e7:d5:48:9d:4f:89:15:c6:51:98:80:05:51:4e:4e\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIICCDCCAY6gAwIBAgIUCpOpoL\/n1UidT4kVxlGYgAVRTk4wCgYIKoZIzj0EAwMw\\n\" +\n-                \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n-                \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowOzEL\\n\" +\n-                \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n-                \"dCBTZXJpdmNlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAENVQN1wXWFdgC6u\/dDdiC\\n\" +\n-                \"y+WtMTF66oL\/0BSm+1ZqsogamzCryawOcHgiuXgWzx5CQ3LuOC+tDFyXpGfHuCvb\\n\" +\n-                \"dkzxPrP5n9NrR8\/uRPe5l1KOUbchviU8z9cTP+LZxnZDo1MwUTAdBgNVHQ4EFgQU\\n\" +\n-                \"SktSFArR1p\/5mXV0kyo0RxIVa\/UwHwYDVR0jBBgwFoAUSktSFArR1p\/5mXV0kyo0\\n\" +\n-                \"RxIVa\/UwDwYDVR0TAQH\/BAUwAwEB\/zAKBggqhkjOPQQDAwNoADBlAjBZvoNmq3\/v\\n\" +\n-                \"RD2gBTyvxjS9h0rsMRLHDnvul\/KWngytwGPTOBo0Y8ixQXSjdKoc3rkCMQDkiNgx\\n\" +\n-                \"IDxuHedmrLQKIPnVcthTmwv7\/\/jHiqGoKofwChMo2a1P+DQdhszmeHD\/ARQ=\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDChlbt0NF8oIKODSxn2\\n\" +\n-                \"WXCXuJm3z78LRkzYQS3Nx5NMjei5ytkFZz4qvD4XXMWlTEyhZANiAAQ1VA3XBdYV\\n\" +\n-                \"2ALq790N2ILL5a0xMXrqgv\/QFKb7VmqyiBqbMKvJrA5weCK5eBbPHkJDcu44L60M\\n\" +\n-                \"XJekZ8e4K9t2TPE+s\/mf02tHz+5E97mXUo5RtyG+JTzP1xM\/4tnGdkM=\"),\n-\n-        CA_ECDSA_SECP521R1(\n-                \"EC\",\n-                \/\/ SHA512withECDSA, curve secp521r1\n-                \/\/ Validity\n-                \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n-                \/\/     Not After : Jun 19 08:15:06 2039 GMT\n-                \/\/ Subject Key Identifier:\n-                \/\/     25:ca:68:76:6d:29:17:9b:71:78:45:2d:d4:c6:e4:5d:fe:25:ff:90\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIICUzCCAbSgAwIBAgIUJcpodm0pF5txeEUt1MbkXf4l\/5AwCgYIKoZIzj0EAwQw\\n\" +\n-                \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n-                \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowOzEL\\n\" +\n-                \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n-                \"dCBTZXJpdmNlMIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQAmFD5VmB2MdyJ6k+E\\n\" +\n-                \"eP4JncrE65ySL07gVmFwnr8otOt3NtRAyzmviMNNXXjo5R5NqNjKP4pr92JjT0sO\\n\" +\n-                \"D65yngkBtH151Ev\/fiKPLxkXL9GzfKdWHVhDX7Zg6DUydzukzZV2\/dIyloAIqwlz\\n\" +\n-                \"QVKJqT7RypDufdng8hnE9YfKo6ypZiujUzBRMB0GA1UdDgQWBBRAIrxa7WqtqUCe\\n\" +\n-                \"HFuKREDC92spvTAfBgNVHSMEGDAWgBRAIrxa7WqtqUCeHFuKREDC92spvTAPBgNV\\n\" +\n-                \"HRMBAf8EBTADAQH\/MAoGCCqGSM49BAMEA4GMADCBiAJCAe22iirZnODCmlpxcv57\\n\" +\n-                \"3g5BEE60C+dtYmTqR4DtFyDaTRQ5CFf4ZxvQPIbD+SXi5Cbrl6qtrZG0cjUihPkC\\n\" +\n-                \"Hi1hAkIAiEcO7nMPgQLny+GrciojfN+bZXME\/dPz6KHBm\/89f8Me+jawVnv6y+df\\n\" +\n-                \"2Sbafh1KV6ntWQtB4bK3MXV8Ym9Eg1I=\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MIHuAgEAMBAGByqGSM49AgEGBSuBBAAjBIHWMIHTAgEBBEIAV8dZszV6+nLw3LeA\\n\" +\n-                \"Q+qLJLGaqyjlsQkaopCPcmoRdy1HX6AzB\/YnKsPkHp\/9DQN6A2JgUhFG5B0XvKSk\\n\" +\n-                \"BqNNuSGhgYkDgYYABACYUPlWYHYx3InqT4R4\/gmdysTrnJIvTuBWYXCevyi063c2\\n\" +\n-                \"1EDLOa+Iw01deOjlHk2o2Mo\/imv3YmNPSw4PrnKeCQG0fXnUS\/9+Io8vGRcv0bN8\\n\" +\n-                \"p1YdWENftmDoNTJ3O6TNlXb90jKWgAirCXNBUompPtHKkO592eDyGcT1h8qjrKlm\\n\" +\n-                \"Kw==\"),\n-\n-        CA_RSA_2048(\n-                \"RSA\",\n-                \/\/ SHA256withRSA, 2048 bits\n-                \/\/ Validity\n-                \/\/     Not Before: May 22 07:18:16 2018 GMT\n-                \/\/     Not After : May 17 07:18:16 2038 GMT\n-                \/\/ Subject Key Identifier:\n-                \/\/     0D:DD:93:C9:FE:4B:BD:35:B7:E8:99:78:90:FB:DB:5A:3D:DB:15:4C\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIIDSTCCAjGgAwIBAgIJAI4ZF3iy8zG+MA0GCSqGSIb3DQEBCwUAMDsxCzAJBgNV\\n\" +\n-                \"BAYTAlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\\n\" +\n-                \"aXZjZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYT\\n\" +\n-                \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n-                \"ZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALpMcY7aWieXDEM1\/YJf\\n\" +\n-                \"JW27b4nRIFZyEYhEloyGsKTuQiiQjc8cqRZFNXe2vwziDB4IyTEl0Hjl5QF6ZaQE\\n\" +\n-                \"huPzzwvQm1pv64KrRXrmj3FisQK8B5OWLty9xp6xDqsaMRoyObLK+oIb20T5fSlE\\n\" +\n-                \"evmo1vYjnh8CX0Yzx5Gr5ye6YSEHQvYOWEws8ad17OlyToR2KMeC8w4qo6rs59pW\\n\" +\n-                \"g7Mxn9vo22ImDzrtAbTbXbCias3xlE0Bp0h5luyf+5U4UgksoL9B9r2oP4GrLNEV\\n\" +\n-                \"oJk57t8lwaR0upiv3CnS8LcJELpegZub5ggqLY8ZPYFQPjlK6IzLOm6rXPgZiZ3m\\n\" +\n-                \"RL0CAwEAAaNQME4wHQYDVR0OBBYEFA3dk8n+S701t+iZeJD721o92xVMMB8GA1Ud\\n\" +\n-                \"IwQYMBaAFA3dk8n+S701t+iZeJD721o92xVMMAwGA1UdEwQFMAMBAf8wDQYJKoZI\\n\" +\n-                \"hvcNAQELBQADggEBAJTRC3rKUUhVH07\/1+stUungSYgpM08dY4utJq0BDk36BbmO\\n\" +\n-                \"0AnLDMbkwFdHEoqF6hQIfpm7SQTmXk0Fss6Eejm8ynYr6+EXiRAsaXOGOBCzF918\\n\" +\n-                \"\/RuKOzqABfgSU4UBKECLM5bMfQTL60qx+HdbdVIpnikHZOFfmjCDVxoHsGyXc1LW\\n\" +\n-                \"Jhkht8IGOgc4PMGvyzTtRFjz01kvrVQZ75aN2E0GQv6dCxaEY0i3ypSzjUWAKqDh\\n\" +\n-                \"3e2OLwUSvumcdaxyCdZAOUsN6pDBQ+8VRG7KxnlRlY1SMEk46QgQYLbPDe\/+W\/yH\\n\" +\n-                \"ca4PejicPeh+9xRAwoTpiE2gulfT7Lm+fVM7Ruc=\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQC6THGO2lonlwxD\\n\" +\n-                \"Nf2CXyVtu2+J0SBWchGIRJaMhrCk7kIokI3PHKkWRTV3tr8M4gweCMkxJdB45eUB\\n\" +\n-                \"emWkBIbj888L0Jtab+uCq0V65o9xYrECvAeTli7cvcaesQ6rGjEaMjmyyvqCG9tE\\n\" +\n-                \"+X0pRHr5qNb2I54fAl9GM8eRq+cnumEhB0L2DlhMLPGndezpck6EdijHgvMOKqOq\\n\" +\n-                \"7OfaVoOzMZ\/b6NtiJg867QG0212womrN8ZRNAadIeZbsn\/uVOFIJLKC\/Qfa9qD+B\\n\" +\n-                \"qyzRFaCZOe7fJcGkdLqYr9wp0vC3CRC6XoGbm+YIKi2PGT2BUD45SuiMyzpuq1z4\\n\" +\n-                \"GYmd5kS9AgMBAAECggEAFHSoU2MuWwJ+2jJnb5U66t2V1bAcuOE1g5zkWvG\/G5z9\\n\" +\n-                \"rq6Qo5kmB8f5ovdx6tw3MGUOklLwnRXBG3RxDJ1iokz3AvkY1clMNsDPlDsUrQKF\\n\" +\n-                \"JSO4QUBQTPSZhnsyfR8XHSU+qJ8Y+ohMfzpVv95BEoCzebtXdVgxVegBlcEmVHo2\\n\" +\n-                \"kMmkRN+bYNsr8eb2r+b0EpyumS39ZgKYh09+cFb78y3T6IFMGcVJTP6nlGBFkmA\/\\n\" +\n-                \"25pYeCF2tSki08qtMJZQAvKfw0Kviibk7ZxRbJqmc7B1yfnOEHP6ftjuvKl2+RP\/\\n\" +\n-                \"+5P5f8CfIP6gtA0LwSzAqQX\/hfIKrGV5j0pCqrD0kQKBgQDeNR6Xi4sXVq79lihO\\n\" +\n-                \"a1bSeV7r8yoQrS8x951uO+ox+UIZ1MsAULadl7zB\/P0er92p198I9M\/0Jth3KBuS\\n\" +\n-                \"zj45mucvpiiGvmQlMKMEfNq4nN7WHOu55kufPswQB2mR4J3xmwI+4fM\/nl1zc82h\\n\" +\n-                \"De8JSazRldJXNhfx0RGFPmgzbwKBgQDWoVXrXLbCAn41oVnWB8vwY9wjt92ztDqJ\\n\" +\n-                \"HMFA\/SUohjePep9UDq6ooHyAf\/Lz6oE5NgeVpPfTDkgvrCFVKnaWdwALbYoKXT2W\\n\" +\n-                \"9FlyJox6eQzrtHAacj3HJooXWuXlphKSizntfxj3LtMR9BmrmRJOfK+SxNOVJzW2\\n\" +\n-                \"+MowT20EkwKBgHmpB8jdZBgxI7o\/\/m2BI5Y1UZ1KE5vx1kc7VXzHXSBjYqeV9FeF\\n\" +\n-                \"2ZZLP9POWh\/1Fh4pzTmwIDODGT2UPhSQy0zq3O0fwkyT7WzXRknsuiwd53u\/dejg\\n\" +\n-                \"iEL2NPAJvulZ2+AuiHo5Z99LK8tMeidV46xoJDDUIMgTG+UQHNGhK5gNAoGAZn\/S\\n\" +\n-                \"Cn7SgMC0CWSvBHnguULXZO9wH1wZAFYNLL44OqwuaIUFBh2k578M9kkke7woTmwx\\n\" +\n-                \"HxQTjmWpr6qimIuY6q6WBN8hJ2Xz\/d1fwhYKzIp20zHuv5KDUlJjbFfqpsuy3u1C\\n\" +\n-                \"kts5zwI7pr1ObRbDGVyOdKcu7HI3QtR5qqyjwaUCgYABo7Wq6oHva\/9V34+G3Goh\\n\" +\n-                \"63bYGUnRw2l5BD11yhQv8XzGGZFqZVincD8gltNThB0Dc\/BI+qu3ky4YdgdZJZ7K\\n\" +\n-                \"z51GQGtaHEbrHS5caV79yQ8QGY5mUVH3E+VXSxuIqb6pZq2DH4sTAEFHyncddmOH\\n\" +\n-                \"zoXBInYwRG9KE\/Bw5elhUw==\"),\n-\n-        CA_DSA_2048(\n-                \"DSA\",\n-                \/\/ SHA256withDSA, 2048 bits\n-                \/\/ Validity\n-                \/\/     Not Before: May 22 07:18:18 2018 GMT\n-                \/\/     Not After : May 17 07:18:18 2038 GMT\n-                \/\/ Subject Key Identifier:\n-                \/\/     76:66:9E:F7:3B:DD:45:E5:3B:D9:72:3C:3F:F0:54:39:86:31:26:53\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIIErjCCBFSgAwIBAgIJAOktYLNCbr02MAsGCWCGSAFlAwQDAjA7MQswCQYDVQQG\\n\" +\n-                \"EwJVUzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2\\n\" +\n-                \"Y2UwHhcNMTgwNTIyMDcxODE4WhcNMzgwNTE3MDcxODE4WjA7MQswCQYDVQQGEwJV\\n\" +\n-                \"UzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2Y2Uw\\n\" +\n-                \"ggNHMIICOQYHKoZIzjgEATCCAiwCggEBAO5GyPhSm0ze3LSu+gicdULLj05iOfTL\\n\" +\n-                \"UvZQ29sYz41zmqrLBQbdKiHqgJu2Re9sgTb5suLNjF047TOLPnU3jhPtWm2X8Xzi\\n\" +\n-                \"VGIcHym\/Q\/MeZxStt\/88seqroI3WOKzIML2GcrishT+lcGrtH36Tf1+ue2Snn3PS\\n\" +\n-                \"WyxygNqPjllP5uUjYmFLvAf4QLMldkd\/D2VxcwsHjB8y5iUZsXezc\/LEhRZS\/02m\\n\" +\n-                \"ivqlRw3AMkq\/OVe\/ZtxFWsP0nsfxEGdZuaUFpppGfixxFvymrB3+J51cTt+pZBDq\\n\" +\n-                \"D2y0DYfc+88iCs4jwHTfcDIpLb538HBjBj2rEgtQESQmB0ooD\/+wsPsCIQC1bYch\\n\" +\n-                \"gElNtDYL3FgpLgNSUYp7gIWv9ehaC7LO2z7biQKCAQBitvFOnDkUja8NAF7lDpOV\\n\" +\n-                \"b5ipQ8SicBLW3kQamxhyuyxgZyy\/PojZ\/oPorkqW\/T\/A0rhnG6MssEpAtdiwVB+c\\n\" +\n-                \"rBYGo3bcwmExJhdOJ6dYuKFppPWhCwKMHs9npK+lqBMl8l5j58xlcFeC7ZfGf8GY\\n\" +\n-                \"GkhFW0c44vEQhMMbac6ZTTP4mw+1t7xJfmDMlLEyIpTXaAAk8uoVLWzQWnR40sHi\\n\" +\n-                \"ybvS0u3JxQkb7\/y8tOOZu8qlz\/YOS7lQ6UxUGX27Ce1E0+agfPphetoRAlS1cezq\\n\" +\n-                \"Wa7r64Ga0nkj1kwkcRqjgTiJx0NwnUXr78VAXFhVF95+O3lfqhvdtEGtkhDGPg7N\\n\" +\n-                \"A4IBBgACggEBAMmSHQK0w2i+iqUjOPzn0yNEZrzepLlLeQ1tqtn0xnlv5vBAeefD\\n\" +\n-                \"Pm9dd3tZOjufVWP7hhEz8xPobb1CS4e3vuQiv5UBfhdPL3f3l9T7JMAKPH6C9Vve\\n\" +\n-                \"OQXE5eGqbjsySbcmseHoYUt1WCSnSda1opX8zchX04e7DhGfE2\/L9flpYEoSt8lI\\n\" +\n-                \"vMNjgOwvKdW3yvPt1\/eBBHYNFG5gWPv\/Q5KoyCtHS03uqGm4rNc\/wZTIEEfd66C+\\n\" +\n-                \"QRaUltjOaHmtwOdDHaNqwhYZSVOip+Mo+TfyzHFREcdHLapo7ZXqbdYkRGxRR3d+\\n\" +\n-                \"3DfHaraJO0OKoYlPkr3JMvM\/MSGR9AnZOcejUDBOMB0GA1UdDgQWBBR2Zp73O91F\\n\" +\n-                \"5TvZcjw\/8FQ5hjEmUzAfBgNVHSMEGDAWgBR2Zp73O91F5TvZcjw\/8FQ5hjEmUzAM\\n\" +\n-                \"BgNVHRMEBTADAQH\/MAsGCWCGSAFlAwQDAgNHADBEAiBzriYE41M2y9Hy5ppkL0Qn\\n\" +\n-                \"dIlNc8JhXT\/PHW7GDtViagIgMko8Qoj9gDGPK3+O9E8DC3wGiiF9CObM4LN387ok\\n\" +\n-                \"J+g=\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MIICZQIBADCCAjkGByqGSM44BAEwggIsAoIBAQDuRsj4UptM3ty0rvoInHVCy49O\" +\n-                \"Yjn0y1L2UNvbGM+Nc5qqywUG3Soh6oCbtkXvbIE2+bLizYxdOO0ziz51N44T7Vpt\" +\n-                \"l\/F84lRiHB8pv0PzHmcUrbf\/PLHqq6CN1jisyDC9hnK4rIU\/pXBq7R9+k39frntk\" +\n-                \"p59z0lsscoDaj45ZT+blI2JhS7wH+ECzJXZHfw9lcXMLB4wfMuYlGbF3s3PyxIUW\" +\n-                \"Uv9Npor6pUcNwDJKvzlXv2bcRVrD9J7H8RBnWbmlBaaaRn4scRb8pqwd\/iedXE7f\" +\n-                \"qWQQ6g9stA2H3PvPIgrOI8B033AyKS2+d\/BwYwY9qxILUBEkJgdKKA\/\/sLD7AiEA\" +\n-                \"tW2HIYBJTbQ2C9xYKS4DUlGKe4CFr\/XoWguyzts+24kCggEAYrbxTpw5FI2vDQBe\" +\n-                \"5Q6TlW+YqUPEonAS1t5EGpsYcrssYGcsvz6I2f6D6K5Klv0\/wNK4ZxujLLBKQLXY\" +\n-                \"sFQfnKwWBqN23MJhMSYXTienWLihaaT1oQsCjB7PZ6SvpagTJfJeY+fMZXBXgu2X\" +\n-                \"xn\/BmBpIRVtHOOLxEITDG2nOmU0z+JsPtbe8SX5gzJSxMiKU12gAJPLqFS1s0Fp0\" +\n-                \"eNLB4sm70tLtycUJG+\/8vLTjmbvKpc\/2Dku5UOlMVBl9uwntRNPmoHz6YXraEQJU\" +\n-                \"tXHs6lmu6+uBmtJ5I9ZMJHEao4E4icdDcJ1F6+\/FQFxYVRfefjt5X6ob3bRBrZIQ\" +\n-                \"xj4OzQQjAiEAsceWOM8do4etxp2zgnoNXV8PUUyqWhz1+0srcKV7FR4=\"),\n-\n-        CA_DSA_1024(\n-                \"DSA\",\n-                \/\/ dsaWithSHA1, 1024 bits\n-                \/\/ Validity\n-                \/\/     Not Before: Apr 24 12:25:43 2020 GMT\n-                \/\/     Not After : Apr 22 12:25:43 2030 GMT\n-                \/\/ Authority Key Identifier:\n-                \/\/     E1:3C:01:52:EB:D1:38:F7:CF:F1:E3:5E:DB:54:75:7F:5E:AB:2D:36\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIIC9TCCArWgAwIBAgIUd52yKk0OxQuxdaYRAfq5VLuF1ZAwCQYHKoZIzjgEAzAu\\n\" +\n-                \"MQswCQYDVQQGEwJVUzENMAsGA1UECgwESmF2YTEQMA4GA1UECwwHU3VuSlNTRTAe\\n\" +\n-                \"Fw0yMDA0MjQxMjI1NDJaFw0zMDA0MjIxMjI1NDJaMC4xCzAJBgNVBAYTAlVTMQ0w\\n\" +\n-                \"CwYDVQQKDARKYXZhMRAwDgYDVQQLDAdTdW5KU1NFMIIBtjCCASsGByqGSM44BAEw\\n\" +\n-                \"ggEeAoGBAKgyb2XpANq43T8yBf5v0PTBOddLPxd0f0FotASron5rQr86JjBTfgIW\\n\" +\n-                \"oE4u7nYlO6bp\/M4Dw6qZr+HaDu9taIDOj6LL51eUShVsOgS7XZcUzLT8vPnkEDDo\\n\" +\n-                \"u326x0B7fuNCbMLm+ipM2d4FhLUTt4Qb5TcY6l7dOGHeWiL7nl43AhUAoGr8DY2m\\n\" +\n-                \"WHZPHk2XbZ5wpaM2lLcCgYBKiFbFFViH\/ylHJRPtYtjtJw4ls1scbVP4TRHnKoZc\\n\" +\n-                \"HPAird1fDYgGC2b0GQNAMABhI+L+ogxS7qakySpJCheuN25AjiSyilygQdlXoWRt\\n\" +\n-                \"Mggsh8EQZT7iP4V4e9m3xRHzb5ECvsSTdZB1BQMcC90W2Avq+orqgBnr2in9UEd8\\n\" +\n-                \"qwOBhAACgYAgVWxjYWlWIv7s4BnNMQoPKppi205f3aC6wv6Rqk4BnYYYrFONEmzQ\\n\" +\n-                \"hzj6lSXfxLpTu4lg2zNeIraZggoS0ztkbZNNADEmAHx+OLshiJJxu2\/KfoopJOZg\\n\" +\n-                \"8ARmuaKOkWbkW9y4hWhfBlVwZbckG3Eibff0xronIXXy7B7UKaccyqNTMFEwHQYD\\n\" +\n-                \"VR0OBBYEFOE8AVLr0Tj3z\/HjXttUdX9eqy02MB8GA1UdIwQYMBaAFOE8AVLr0Tj3\\n\" +\n-                \"z\/HjXttUdX9eqy02MA8GA1UdEwEB\/wQFMAMBAf8wCQYHKoZIzjgEAwMvADAsAhRC\\n\" +\n-                \"YLduLniBEJ51SfBWIkvNW6OG7QIUSKaTY6rgEFDEMoTqOjFChR22nkk=\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MIIBSgIBADCCASsGByqGSM44BAEwggEeAoGBAKgyb2XpANq43T8yBf5v0PTBOddL\\n\" +\n-                \"Pxd0f0FotASron5rQr86JjBTfgIWoE4u7nYlO6bp\/M4Dw6qZr+HaDu9taIDOj6LL\\n\" +\n-                \"51eUShVsOgS7XZcUzLT8vPnkEDDou326x0B7fuNCbMLm+ipM2d4FhLUTt4Qb5TcY\\n\" +\n-                \"6l7dOGHeWiL7nl43AhUAoGr8DY2mWHZPHk2XbZ5wpaM2lLcCgYBKiFbFFViH\/ylH\\n\" +\n-                \"JRPtYtjtJw4ls1scbVP4TRHnKoZcHPAird1fDYgGC2b0GQNAMABhI+L+ogxS7qak\\n\" +\n-                \"ySpJCheuN25AjiSyilygQdlXoWRtMggsh8EQZT7iP4V4e9m3xRHzb5ECvsSTdZB1\\n\" +\n-                \"BQMcC90W2Avq+orqgBnr2in9UEd8qwQWAhQ7rSn+WvIxeuZ\/CK4p04eMe5JzpA==\"),\n-\n-        CA_ED25519(\n-                \"EdDSA\",\n-                \/\/ ED25519\n-                \/\/ Validity\n-                \/\/     Not Before: May 24 23:32:35 2020 GMT\n-                \/\/     Not After : May 22 23:32:35 2030 GMT\n-                \/\/ X509v3 Authority Key Identifier:\n-                \/\/     keyid:06:76:DB:88:EB:61:55:4C:C9:63:41:C2:A0:A8:57:3F:D7:F1:B8:EC\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIIByTCCAXugAwIBAgIUCyxKvhErehsygx50JYArsHby9hAwBQYDK2VwMDsxCzAJ\\n\" +\n-                \"BgNVBAYTAlVTMQ0wCwYDVQQKDARqYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3Qg\\n\" +\n-                \"U2VyaXZjZTAeFw0yMDA1MjQyMzMyMzVaFw0zMDA1MjIyMzMyMzVaMDsxCzAJBgNV\\n\" +\n-                \"BAYTAlVTMQ0wCwYDVQQKDARqYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\\n\" +\n-                \"aXZjZTAqMAUGAytlcAMhAKdotuYIkH8PYbopSLbaf1BtqUY2d6AbTgK2prMzQ6B3\\n\" +\n-                \"o4GQMIGNMA8GA1UdEwEB\/wQFMAMBAf8wHQYDVR0OBBYEFAZ224jrYVVMyWNBwqCo\\n\" +\n-                \"Vz\/X8bjsMB8GA1UdIwQYMBaAFAZ224jrYVVMyWNBwqCoVz\/X8bjsMA4GA1UdDwEB\\n\" +\n-                \"\/wQEAwIBhjAqBgNVHSUBAf8EIDAeBggrBgEFBQcDAwYIKwYBBQUHAwgGCCsGAQUF\\n\" +\n-                \"BwMJMAUGAytlcANBADVAArvME8xFigFhCCCOTBoy\/4ldGkDZQ\/GT3Q6xnAP558FU\\n\" +\n-                \"0G32OprKQZP43D9bmFU0LMgCVM9bHWU+bu\/10AU=\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MC4CAQAwBQYDK2VwBCIEII\/VYp8nu\/eqq2L5y7\/3IzavBgis4LWP6Rikv0N8SpgL\"),\n-\n-        CA_ED448(\n-                \"EdDSA\",\n-                \/\/ ED448\n-                \/\/ Validity\n-                \/\/     Not Before: May 24 23:23:43 2020 GMT\n-                \/\/     Not After : May 22 23:23:43 2030 GMT\n-                \/\/ X509v3 Authority Key Identifier:\n-                \/\/     keyid:F5:D5:9D:FB:6F:B7:50:29:DF:F0:B8:83:10:5F:9B:C4:A8:1C:E9:F4\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIICFDCCAZSgAwIBAgIUKcmLeKilq0LN40sniBJO7F1gb\/owBQYDK2VxMDsxCzAJ\\n\" +\n-                \"BgNVBAYTAlVTMQ0wCwYDVQQKDARqYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3Qg\\n\" +\n-                \"U2VyaXZjZTAeFw0yMDA1MjQyMzIzNDNaFw0zMDA1MjIyMzIzNDNaMDsxCzAJBgNV\\n\" +\n-                \"BAYTAlVTMQ0wCwYDVQQKDARqYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\\n\" +\n-                \"aXZjZTBDMAUGAytlcQM6APYP8iSXS8xPVDike5RgCByfTtg4GGtpYfoBtt6G5szA\\n\" +\n-                \"55ExAKjm03wtk29nEPU2mCHF2QgfBzUrgKOBkDCBjTAPBgNVHRMBAf8EBTADAQH\/\\n\" +\n-                \"MB0GA1UdDgQWBBT11Z37b7dQKd\/wuIMQX5vEqBzp9DAfBgNVHSMEGDAWgBT11Z37\\n\" +\n-                \"b7dQKd\/wuIMQX5vEqBzp9DAOBgNVHQ8BAf8EBAMCAYYwKgYDVR0lAQH\/BCAwHgYI\\n\" +\n-                \"KwYBBQUHAwMGCCsGAQUFBwMIBggrBgEFBQcDCTAFBgMrZXEDcwAlRXA2gPb52yV3\\n\" +\n-                \"MKJErjmKlYSFExj5w5jafbbd0QgI1yDs+qSaZLjQ8ljwabmLDg+KR+167m0djQDI\\n\" +\n-                \"OOoVuL7bgM0RL836KnuuBzm+gTdPp0gCXy3k9lL0KA0V2YLJHXXzu3suu+7rdgoP\\n\" +\n-                \"plCh2hWdLgA=\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MEcCAQAwBQYDK2VxBDsEOd6\/hRZqkUyTlJSwdN5gO\/HnoWYda1fD83YUm5j6m2Bg\\n\" +\n-                \"hAQi+QadFsQLD7R6PI\/4Q0twXqlKnxU5Ug==\"),\n-\n-        EE_ECDSA_SECP256R1(\n-                \"EC\",\n-                \/\/ SHA256withECDSA, curve secp256r1\n-                \/\/ Validity\n-                \/\/     Not Before: May 22 07:18:16 2018 GMT\n-                \/\/     Not After : May 17 07:18:16 2038 GMT\n-                \/\/ Authority Key Identifier:\n-                \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIIBqjCCAVCgAwIBAgIJAPLY8qZjgNRAMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n-                \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n-                \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYTAlVT\\n\" +\n-                \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTEY\\n\" +\n-                \"MBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcD\\n\" +\n-                \"QgAEb+9n05qfXnfHUb0xtQJNS4JeSi6IjOfW5NqchvKnfJey9VkJzR7QHLuOESdf\\n\" +\n-                \"xlR7q8YIWgih3iWLGfB+wxHiOqMjMCEwHwYDVR0jBBgwFoAUYM+9c\/\/6GjDSpOzT\\n\" +\n-                \"SXFG7xo1oIYwCgYIKoZIzj0EAwIDSAAwRQIgWpRegWXMheiD3qFdd8kMdrkLxRbq\\n\" +\n-                \"1zj8nQMEwFTUjjQCIQDRIrAjZX+YXHN9b0SoWWLPUq0HmiFIi8RwMnO\/\/wJIGQ==\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgn5K03bpTLjEtFQRa\\n\" +\n-                \"JUtx22gtmGEvvSUSQdimhGthdtihRANCAARv72fTmp9ed8dRvTG1Ak1Lgl5KLoiM\\n\" +\n-                \"59bk2pyG8qd8l7L1WQnNHtAcu44RJ1\/GVHurxghaCKHeJYsZ8H7DEeI6\"),\n-\n-        EE_ECDSA_SECP384R1(\n-                \"EC\",\n-                \/\/ SHA384withECDSA, curve secp384r1\n-                \/\/ Validity\n-                \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n-                \/\/     Not After : Jun 19 08:15:06 2039 GMT\n-                \/\/ Authority Key Identifier:\n-                \/\/     40:2D:AA:EE:66:AA:33:27:AD:9B:5D:52:9B:60:67:6A:2B:AD:52:D2\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIICEjCCAZegAwIBAgIUS3F0AqAXWRg07CnbknJzxofyBQMwCgYIKoZIzj0EAwMw\\n\" +\n-                \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n-                \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowVTEL\\n\" +\n-                \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n-                \"dCBTZXJpdmNlMRgwFgYDVQQDDA9SZWdyZXNzaW9uIFRlc3QwdjAQBgcqhkjOPQIB\\n\" +\n-                \"BgUrgQQAIgNiAARqElz8b6T07eyKomIinhztV3\/3XBk9bKGtJ0W+JOltjuhMmP\/w\\n\" +\n-                \"G8ASSevpgqgpi6EzpBZaaJxE3zNfkNnxXOZmQi2Ypd1uK0zRdbEOKg0XOcTTZwEj\\n\" +\n-                \"iLjYmt3O0pwpklijQjBAMB0GA1UdDgQWBBRALaruZqozJ62bXVKbYGdqK61S0jAf\\n\" +\n-                \"BgNVHSMEGDAWgBRKS1IUCtHWn\/mZdXSTKjRHEhVr9TAKBggqhkjOPQQDAwNpADBm\\n\" +\n-                \"AjEArVDFKf48xijN6huVUJzKCOP0zlWB5Js+DItIkZmLQuhciPLhLIB\/rChf3Y4C\\n\" +\n-                \"xuP4AjEAmfLhQRI0O3pifpYzYSVh2G7\/jHNG4eO+2dvgAcU+Lh2IIj\/cpLaPFSvL\\n\" +\n-                \"J8FXY9Nj\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDASuI9EtK29APXPipkc\\n\" +\n-                \"qDA+qwlewMjv\/OcjUJ77kP1Vz62oVF9iY9SRIyFIUju8wt+hZANiAARqElz8b6T0\\n\" +\n-                \"7eyKomIinhztV3\/3XBk9bKGtJ0W+JOltjuhMmP\/wG8ASSevpgqgpi6EzpBZaaJxE\\n\" +\n-                \"3zNfkNnxXOZmQi2Ypd1uK0zRdbEOKg0XOcTTZwEjiLjYmt3O0pwpklg=\"),\n-\n-        EE_ECDSA_SECP521R1(\n-                \"EC\",\n-                \/\/ SHA512withECDSA, curve secp521r1\n-                \/\/ Validity\n-                \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n-                \/\/     Not After : Jun 19 08:15:06 2039 GMT\n-                \/\/ Authority Key Identifier:\n-                \/\/     7B:AA:79:A4:49:DD:59:34:F0:86:6C:51:C7:30:F4:CE:C5:81:8A:28\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIICXDCCAb2gAwIBAgIUck4QTsbHNqUfPxfGPJLYbedFPdswCgYIKoZIzj0EAwQw\\n\" +\n-                \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n-                \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowVTEL\\n\" +\n-                \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n-                \"dCBTZXJpdmNlMRgwFgYDVQQDDA9SZWdyZXNzaW9uIFRlc3QwgZswEAYHKoZIzj0C\\n\" +\n-                \"AQYFK4EEACMDgYYABAGa2zDLhYQHHCLI3YBqFYJTzrnDIjzwXrxhcRTS8DYkcrjZ\\n\" +\n-                \"+Fih1YyNhix0sdjH+3EqElXAHHuVzn3n3hPOtQCWlQCICkErB34S0cvmtRkeW8Fi\\n\" +\n-                \"hrR5tvJEzEZjPSgwn81kKyhV2L70je6i7Cw884Va8bODckpgw0vTmbQb7T9dupkv\\n\" +\n-                \"1aNCMEAwHQYDVR0OBBYEFHuqeaRJ3Vk08IZsUccw9M7FgYooMB8GA1UdIwQYMBaA\\n\" +\n-                \"FEAivFrtaq2pQJ4cW4pEQML3aym9MAoGCCqGSM49BAMEA4GMADCBiAJCAb33KHdY\\n\" +\n-                \"WDbusORWoY8Euglpd5zsF15hJsk7wtpD5HST1\/NWmdCx405w+TV6a9Gr4VPHeaIQ\\n\" +\n-                \"99i\/+f237ALL5p6IAkIBbwwFL1vt3c\/bx+niyuffQPNjly80rdC9puqAqriSiboS\\n\" +\n-                \"efhxjidJ9HLaIRCMEPyd6vAsC8mO8YvL1uCuEQLsiGM=\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MIHuAgEAMBAGByqGSM49AgEGBSuBBAAjBIHWMIHTAgEBBEIB8C\/2OX2Dt9vFszzV\\n\" +\n-                \"hcAe0CbkMlvu9uQ\/L7Vz88heuIj0rUZIPGshvgIJt1hCMT8HZxYHvDa4lbUvqjFB\\n\" +\n-                \"+zafvPWhgYkDgYYABAGa2zDLhYQHHCLI3YBqFYJTzrnDIjzwXrxhcRTS8DYkcrjZ\\n\" +\n-                \"+Fih1YyNhix0sdjH+3EqElXAHHuVzn3n3hPOtQCWlQCICkErB34S0cvmtRkeW8Fi\\n\" +\n-                \"hrR5tvJEzEZjPSgwn81kKyhV2L70je6i7Cw884Va8bODckpgw0vTmbQb7T9dupkv\\n\" +\n-                \"1Q==\"),\n-\n-        EE_RSA_2048(\n-                \"RSA\",\n-                \/\/ SHA256withRSA, 2048 bits\n-                \/\/ Validity\n-                \/\/     Not Before: May 22 07:18:16 2018 GMT\n-                \/\/     Not After : May 17 07:18:16 2038 GMT\n-                \/\/ Authority Key Identifier:\n-                \/\/     0D:DD:93:C9:FE:4B:BD:35:B7:E8:99:78:90:FB:DB:5A:3D:DB:15:4C\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIIDNjCCAh6gAwIBAgIJAO2+yPcFryUTMA0GCSqGSIb3DQEBCwUAMDsxCzAJBgNV\\n\" +\n-                \"BAYTAlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\\n\" +\n-                \"aXZjZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYT\\n\" +\n-                \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n-                \"ZTEYMBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MIIBIjANBgkqhkiG9w0BAQEFAAOC\\n\" +\n-                \"AQ8AMIIBCgKCAQEAszfBobWfZIp8AgC6PiWDDavP65mSvgCXUGxACbxVNAfkLhNR\\n\" +\n-                \"QOsHriRB3X1Q3nvO9PetC6wKlvE9jlnDDj7D+1j1r1CHO7ms1fq8rfcQYdkanDtu\\n\" +\n-                \"4AlHo8v+SSWX16MIXFRYDj2VVHmyPtgbltcg4zGAuwT746FdLI94uXjJjq1IOr\/v\\n\" +\n-                \"0VIlwE5ORWH5Xc+5Tj+oFWK0E4a4GHDgtKKhn2m72hN56\/GkPKGkguP5NRS1qYYV\\n\" +\n-                \"\/EFkdyQMOV8J1M7HaicSft4OL6eKjTrgo93+kHk+tv0Dc6cpVBnalX3TorG8QI6B\\n\" +\n-                \"cHj1XQd78oAlAC+\/jF4pc0mwi0un49kdK9gRfQIDAQABoyMwITAfBgNVHSMEGDAW\\n\" +\n-                \"gBQN3ZPJ\/ku9NbfomXiQ+9taPdsVTDANBgkqhkiG9w0BAQsFAAOCAQEApXS0nKwm\\n\" +\n-                \"Kp8gpmO2yG1rpd1+2wBABiMU4JZaTqmma24DQ3RzyS+V2TeRb29dl5oTUEm98uc0\\n\" +\n-                \"GPZvhK8z5RFr4YE17dc04nI\/VaNDCw4y1NALXGs+AHkjoPjLyGbWpi1S+gfq2sNB\\n\" +\n-                \"Ekkjp6COb\/cb9yiFXOGVls7UOIjnVZVd0r7KaPFjZhYh82\/f4PA\/A1SnIKd1+nfH\\n\" +\n-                \"2yk7mSJNC7Z3qIVDL8MM\/jBVwiC3uNe5GPB2uwhd7k5LGAVN3j4HQQGB0Sz+VC1h\\n\" +\n-                \"92oi6xDa+YBva2fvHuCd8P50DDjxmp9CemC7rnZ5j8egj88w14X44Xjb\/Fd\/ApG9\\n\" +\n-                \"e57NnbT7KM+Grw==\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCzN8GhtZ9kinwC\\n\" +\n-                \"ALo+JYMNq8\/rmZK+AJdQbEAJvFU0B+QuE1FA6weuJEHdfVDee870960LrAqW8T2O\\n\" +\n-                \"WcMOPsP7WPWvUIc7uazV+ryt9xBh2RqcO27gCUejy\/5JJZfXowhcVFgOPZVUebI+\\n\" +\n-                \"2BuW1yDjMYC7BPvjoV0sj3i5eMmOrUg6v+\/RUiXATk5FYfldz7lOP6gVYrQThrgY\\n\" +\n-                \"cOC0oqGfabvaE3nr8aQ8oaSC4\/k1FLWphhX8QWR3JAw5XwnUzsdqJxJ+3g4vp4qN\\n\" +\n-                \"OuCj3f6QeT62\/QNzpylUGdqVfdOisbxAjoFwePVdB3vygCUAL7+MXilzSbCLS6fj\\n\" +\n-                \"2R0r2BF9AgMBAAECggEASIkPkMCuw4WdTT44IwERus3IOIYOs2IP3BgEDyyvm4B6\\n\" +\n-                \"JP\/iihDWKfA4zEl1Gqcni1RXMHswSglXra682J4kui02Ov+vzEeJIY37Ibn2YnP5\\n\" +\n-                \"ZjRT2s9GtI\/S2o4hl8A\/mQb2IMViFC+xKehTukhV4j5d6NPKk0XzLR7gcMjnYxwn\\n\" +\n-                \"l21fS6D2oM1xRG\/di7sL+uLF8EXLRzfiWDNi12uQv4nwtxPKvuKhH6yzHt7YqMH0\\n\" +\n-                \"46pmDKDaxV4w1JdycjCb6NrCJOYZygoQobuZqOQ30UZoZsPJrtovkncFr1e+lNcO\\n\" +\n-                \"+aWDfOLCtTH046dEQh5oCShyXMybNlry\/QHsOtHOwQKBgQDh2iIjs+FPpQy7Z3EX\\n\" +\n-                \"DGEvHYqPjrYO9an2KSRr1m9gzRlWYxKY46WmPKwjMerYtra0GP+TBHrgxsfO8tD2\\n\" +\n-                \"wUAII6sd1qup0a\/Sutgf2JxVilLykd0+Ge4\/Cs51tCdJ8EqDV2B6WhTewOY2EGvg\\n\" +\n-                \"JiKYkeNwgRX\/9M9CFSAMAk0hUQKBgQDLJAartL3DoGUPjYtpJnfgGM23yAGl6G5r\\n\" +\n-                \"NSXDn80BiYIC1p0bG3N0xm3yAjqOtJAUj9jZbvDNbCe3GJfLARMr23legX4tRrgZ\\n\" +\n-                \"nEdKnAFKAKL01oM+A5\/lHdkwaZI9yyv+hgSVdYzUjB8rDmzeVQzo1BT7vXypt2yV\\n\" +\n-                \"6O1OnUpCbQKBgA\/0rzDChopv6KRcvHqaX0tK1P0rYeVQqb9ATNhpf9jg5Idb3HZ8\\n\" +\n-                \"rrk91BNwdVz2G5ZBpdynFl9G69rNAMJOCM4KZw5mmh4XOEq09Ivba8AHU7DbaTv3\\n\" +\n-                \"7QL7KnbaUWRB26HHzIMYVh0el6T+KADf8NXCiMTr+bfpfbL3dxoiF3zhAoGAbCJD\\n\" +\n-                \"Qse1dBs\/cKYCHfkSOsI5T6kx52Tw0jS6Y4X\/FOBjyqr\/elyEexbdk8PH9Ar931Qr\\n\" +\n-                \"NKMvn8oA4iA\/PRrXX7M2yi3YQrWwbkGYWYjtzrzEAdzmg+5eARKAeJrZ8\/bg9l3U\\n\" +\n-                \"ttKaItJsDPlizn8rngy3FsJpR9aSAMK6\/+wOiYkCgYEA1tZkI1rD1W9NYZtbI9BE\\n\" +\n-                \"qlJVFi2PBOJMKNuWdouPX3HLQ72GJSQff2BFzLTELjweVVJ0SvY4IipzpQOHQOBy\\n\" +\n-                \"5qh\/p6izXJZh3IHtvwVBjHoEVplg1b2+I5e3jDCfqnwcQw82dW5SxOJMg1h\/BD0I\\n\" +\n-                \"qAL3go42DYeYhu\/WnECMeis=\"),\n-\n-        EE_EC_RSA_SECP256R1(\n-                \"EC\",\n-                \/\/ SHA256withRSA, curve secp256r1\n-                \/\/ Validity\n-                \/\/     Not Before: May 22 07:18:16 2018 GMT\n-                \/\/     Not After : May 21 07:18:16 2028 GMT\n-                \/\/ Authority Key Identifier:\n-                \/\/     0D:DD:93:C9:FE:4B:BD:35:B7:E8:99:78:90:FB:DB:5A:3D:DB:15:4C\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIICazCCAVOgAwIBAgIJAO2+yPcFryUUMA0GCSqGSIb3DQEBCwUAMDsxCzAJBgNV\\n\" +\n-                \"BAYTAlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\\n\" +\n-                \"aXZjZTAeFw0xODA1MjIwNzE4MTZaFw0yODA1MjEwNzE4MTZaMFUxCzAJBgNVBAYT\\n\" +\n-                \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n-                \"ZTEYMBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0D\\n\" +\n-                \"AQcDQgAE59MERNTlVZ1eeps8Z3Oue5ZkgQdPtD+WIE6tj3PbIKpxGPDxvfNP959A\\n\" +\n-                \"yQjEK\/ehWQVrCMmNoEkIzY+IIBgB06MjMCEwHwYDVR0jBBgwFoAUDd2Tyf5LvTW3\\n\" +\n-                \"6Jl4kPvbWj3bFUwwDQYJKoZIhvcNAQELBQADggEBAFOTVEqs70ykhZiIdrEsF1Ra\\n\" +\n-                \"I3B2rLvwXZk52uSltk2\/bzVvewA577ZCoxQ1pL7ynkisPfBN1uVYtHjM1VA3RC+4\\n\" +\n-                \"+TAK78dnI7otYjWoHp5rvs4l6c\/IbOspS290IlNuDUxMErEm5wxIwj+Aukx\/1y68\\n\" +\n-                \"hOyCvHBLMY2c1LskH1MMBbDuS1aI+lnGpToi+MoYObxGcV458vxuT8+wwV8Fkpvd\\n\" +\n-                \"ll8IIFmeNPRv+1E+lXbES6CSNCVaZ\/lFhPgdgYKleN7sfspiz50DG4dqafuEAaX5\\n\" +\n-                \"xaK1NWXJxTRz0ROH\/IUziyuDW6jphrlgit4+3NCzp6vP9hAJQ8Vhcj0n15BKHIQ=\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgGVc7hICpmp91jbYe\\n\" +\n-                \"nrr8nYHD37RZP3VENY+szuA7WjuhRANCAATn0wRE1OVVnV56mzxnc657lmSBB0+0\\n\" +\n-                \"P5YgTq2Pc9sgqnEY8PG980\/3n0DJCMQr96FZBWsIyY2gSQjNj4ggGAHT\"),\n-\n-        EE_DSA_2048(\n-                \"DSA\",\n-                \/\/ SHA256withDSA, 2048 bits\n-                \/\/ Validity\n-                \/\/     Not Before: May 22 07:18:20 2018 GMT\n-                \/\/     Not After : May 17 07:18:20 2038 GMT\n-                \/\/ Authority Key Identifier:\n-                \/\/     76:66:9E:F7:3B:DD:45:E5:3B:D9:72:3C:3F:F0:54:39:86:31:26:53\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIIEnDCCBEGgAwIBAgIJAP\/jh1qVhNVjMAsGCWCGSAFlAwQDAjA7MQswCQYDVQQG\\n\" +\n-                \"EwJVUzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2\\n\" +\n-                \"Y2UwHhcNMTgwNTIyMDcxODIwWhcNMzgwNTE3MDcxODIwWjBVMQswCQYDVQQGEwJV\\n\" +\n-                \"UzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2Y2Ux\\n\" +\n-                \"GDAWBgNVBAMMD1JlZ3Jlc3Npb24gVGVzdDCCA0cwggI6BgcqhkjOOAQBMIICLQKC\\n\" +\n-                \"AQEAmlavgoJrMcjqWRVcDE2dmWAPREgnzQvneEDef68cprDzjSwvOs5QeFyx75ib\\n\" +\n-                \"ado1e6jO\/rW1prCGWHDD1oA\/Tn4Pk3vu0nUxzvl1qATc+aJbpUU5Op0bvp6LbCsQ\\n\" +\n-                \"QslV9FeRh7Eb7bP6gpc\/kHCBzEgC1VCK7prccXWy+t6SMOHbND3h+UbckfSaUuaV\\n\" +\n-                \"sVJNTD1D6GElfRj4Nmz1BGPfSYvKorwNZEU3gXwFgtDoAcGx7tcyClLpDHfqRfw\/\\n\" +\n-                \"7yiqLyeiP7D4hl5lMNouJWDlAdMFp0FMgS3s9VDFinIcr6VtBWMTG7+4+czHAB+3\\n\" +\n-                \"fvrwlqNzhBn3uFHrekN\/w8fNxwIhAJo7Sae1za7IMW0Q6hE5B4b+s2B\/FaKPoA4E\\n\" +\n-                \"jtZu13B9AoIBAQCOZqLMKfvqZWUgT0PQ3QjR7dAFdd06I9Y3+TOQzZk1+j+vw\/6E\\n\" +\n-                \"X4vFItX4gihb\/u5Q9CdmpwhVGi7bvo+7+\/IKeTgoQ6f5+PSug7SrWWUQ5sPwaZui\\n\" +\n-                \"zXZJ5nTeZDucFc2yFx0wgnjbPwiUxZklOT7xGiOMtzOTa2koCz5KuIBL+\/wPKKxm\\n\" +\n-                \"ypo9VoY9xfbdU6LMXZv\/lpD5XTM9rYHr\/vUTNkukvV6Hpm0YMEWhVZKUJiqCqTqG\\n\" +\n-                \"XHaleOxSw6uQWB\/+TznifcC7gB48UOQjCqOKf5VuwQneJLhlhU\/jhRV3xtr+hLZa\\n\" +\n-                \"hW1wYhVi8cjLDrZFKlgEQqhB4crnJU0mJY+tA4IBBQACggEAID0ezl00\/X8mv7eb\\n\" +\n-                \"bzovum1+DEEP7FM57k6HZEG2N3ve4CW+0m9Cd+cWPz8wkZ+M0j\/Eqa6F0IdbkXEc\\n\" +\n-                \"Q7CuzvUyJ57xQ3L\/WCgXsiS+Bh8O4Mz7GwW22CGmHqafbVv+hKBfr8MkskO6GJUt\\n\" +\n-                \"SUF\/CVLzB4gMIvZMH26tBP2xK+i7FeEK9kT+nGdzQSZBAhFYpEVCBplHZO24\/OYq\\n\" +\n-                \"1DNoU327nUuXIhmsfA8N0PjiWbIZIjTPwBGr9H0LpATI7DIDNcvRRvtROP+pBU9y\\n\" +\n-                \"fuykPkptg9C0rCM9t06bukpOSaEz\/2VIQdLE8fHYFA6pHZ6CIc2+5cfvMgTPhcjz\\n\" +\n-                \"W2jCt6MjMCEwHwYDVR0jBBgwFoAUdmae9zvdReU72XI8P\/BUOYYxJlMwCwYJYIZI\\n\" +\n-                \"AWUDBAMCA0gAMEUCIQCeI5fN08b9BpOaHdc3zQNGjp24FOL\/RxlBLeBAorswJgIg\\n\" +\n-                \"JEZ8DhYxQy1O7mmZ2UIT7op6epWMB4dENjs0qWPmcKo=\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MIICZQIBADCCAjoGByqGSM44BAEwggItAoIBAQCaVq+CgmsxyOpZFVwMTZ2ZYA9E\\n\" +\n-                \"SCfNC+d4QN5\/rxymsPONLC86zlB4XLHvmJtp2jV7qM7+tbWmsIZYcMPWgD9Ofg+T\\n\" +\n-                \"e+7SdTHO+XWoBNz5olulRTk6nRu+notsKxBCyVX0V5GHsRvts\/qClz+QcIHMSALV\\n\" +\n-                \"UIrumtxxdbL63pIw4ds0PeH5RtyR9JpS5pWxUk1MPUPoYSV9GPg2bPUEY99Ji8qi\\n\" +\n-                \"vA1kRTeBfAWC0OgBwbHu1zIKUukMd+pF\/D\/vKKovJ6I\/sPiGXmUw2i4lYOUB0wWn\\n\" +\n-                \"QUyBLez1UMWKchyvpW0FYxMbv7j5zMcAH7d++vCWo3OEGfe4Uet6Q3\/Dx83HAiEA\\n\" +\n-                \"mjtJp7XNrsgxbRDqETkHhv6zYH8Voo+gDgSO1m7XcH0CggEBAI5moswp++plZSBP\\n\" +\n-                \"Q9DdCNHt0AV13Toj1jf5M5DNmTX6P6\/D\/oRfi8Ui1fiCKFv+7lD0J2anCFUaLtu+\\n\" +\n-                \"j7v78gp5OChDp\/n49K6DtKtZZRDmw\/Bpm6LNdknmdN5kO5wVzbIXHTCCeNs\/CJTF\\n\" +\n-                \"mSU5PvEaI4y3M5NraSgLPkq4gEv7\/A8orGbKmj1Whj3F9t1Tosxdm\/+WkPldMz2t\\n\" +\n-                \"gev+9RM2S6S9XoembRgwRaFVkpQmKoKpOoZcdqV47FLDq5BYH\/5POeJ9wLuAHjxQ\\n\" +\n-                \"5CMKo4p\/lW7BCd4kuGWFT+OFFXfG2v6EtlqFbXBiFWLxyMsOtkUqWARCqEHhyucl\\n\" +\n-                \"TSYlj60EIgIgLfA75+8KcKxdN8mr6gzGjQe7jPFGG42Ejhd7Q2F4wuw=\"),\n-\n-        EE_DSA_1024(\n-                \"DSA\",\n-                \/\/ dsaWithSHA1, 1024 bits\n-                \/\/ Validity\n-                \/\/     Not Before: Apr 24 12:25:43 2020 GMT\n-                \/\/     Not After : Apr 22 12:25:43 2030 GMT\n-                \/\/ Authority Key Identifier:\n-                \/\/     E1:3C:01:52:EB:D1:38:F7:CF:F1:E3:5E:DB:54:75:7F:5E:AB:2D:36\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIIDADCCAr+gAwIBAgIUd2XJ5F2VTbk9a92w\/NzLXR5zjUQwCQYHKoZIzjgEAzAu\\n\" +\n-                \"MQswCQYDVQQGEwJVUzENMAsGA1UECgwESmF2YTEQMA4GA1UECwwHU3VuSlNTRTAe\\n\" +\n-                \"Fw0yMDA0MjQxMjI1NDNaFw0zMDA0MjIxMjI1NDNaMEgxCzAJBgNVBAYTAlVTMQ0w\\n\" +\n-                \"CwYDVQQKDARKYXZhMRAwDgYDVQQLDAdTdW5KU1NFMRgwFgYDVQQDDA9SZWdyZXNz\\n\" +\n-                \"aW9uIFRlc3QwggG3MIIBLAYHKoZIzjgEATCCAR8CgYEA7fSkxYISlMJT+i8N5VOb\\n\" +\n-                \"lHhjrPYAy3oR2\/YXQW6T0hCMhm8jmxgk1bDId9ZKHrxsM05EkCtRYaqag4ZZeGde\\n\" +\n-                \"ywv3IwwYqCQfGtkPwT9QAsdSABYwGOrlhEtZtBG1yQ44c+Rz\/Vs+PtkAyZbf5VG1\\n\" +\n-                \"iSxFb9bI5QFJWJ9a2VpZh58CFQCCGALQoK4MsQP8V72WlB7Bvt9erwKBgQDCxu0G\\n\" +\n-                \"M2iZr0J8DaAo9\/ChS4m7E7h6Jz9KOm2cFhzYGekkUXNzny7nyz6Qpgbuf8KNFKjt\\n\" +\n-                \"qoUDC8tlcVQAUlTcESC0TZXR3h21hl9wzIBhE+kJ1j8v1KAxfOaJOxObk5QEvIaA\\n\" +\n-                \"5j+jiHGwRS5tDqywOatz+emwMZv1wKnCNBElNgOBhAACgYBHjuQKucCuuvy\/4DpG\\n\" +\n-                \"rSIzdueK+HrzOW8h2pfvz3lzpsyV6XJPC6we9CjaQjU01VcjwN2PoYtbGyml0pbK\\n\" +\n-                \"We4sdgn6LDL1aCM\/WKRSxGHVTx+wkhKQ719YtiC0T6sA+eLirc6VT3\/6+FbQWC+2\\n\" +\n-                \"bG7N19sGpV\/RAXMBpRXUnBJSQaNCMEAwHQYDVR0OBBYEFNNZxyxuQmKvWowofr\/S\\n\" +\n-                \"HdCIS+W8MB8GA1UdIwQYMBaAFOE8AVLr0Tj3z\/HjXttUdX9eqy02MAkGByqGSM44\\n\" +\n-                \"BAMDMAAwLQIUUzzMhZ9St\/Vo\/YdgNTHdTw4cm14CFQCE6tWG157Wl5YFyYsGHsLY\\n\" +\n-                \"NN8uCA==\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MIIBSwIBADCCASwGByqGSM44BAEwggEfAoGBAO30pMWCEpTCU\/ovDeVTm5R4Y6z2\\n\" +\n-                \"AMt6Edv2F0Fuk9IQjIZvI5sYJNWwyHfWSh68bDNORJArUWGqmoOGWXhnXssL9yMM\\n\" +\n-                \"GKgkHxrZD8E\/UALHUgAWMBjq5YRLWbQRtckOOHPkc\/1bPj7ZAMmW3+VRtYksRW\/W\\n\" +\n-                \"yOUBSVifWtlaWYefAhUAghgC0KCuDLED\/Fe9lpQewb7fXq8CgYEAwsbtBjNoma9C\\n\" +\n-                \"fA2gKPfwoUuJuxO4eic\/SjptnBYc2BnpJFFzc58u58s+kKYG7n\/CjRSo7aqFAwvL\\n\" +\n-                \"ZXFUAFJU3BEgtE2V0d4dtYZfcMyAYRPpCdY\/L9SgMXzmiTsTm5OUBLyGgOY\/o4hx\\n\" +\n-                \"sEUubQ6ssDmrc\/npsDGb9cCpwjQRJTYEFgIUNRiLmNzfTYOuVsjkySPzP5gPImM=\"),\n-\n-        EE_ED25519(\n-                \"EdDSA\",\n-                \/\/ ED25519\n-                \/\/ Validity\n-                \/\/     Not Before: May 24 23:32:36 2020 GMT\n-                \/\/     Not After : May 22 23:32:36 2030 GMT\n-                \/\/ X509v3 Authority Key Identifier:\n-                \/\/     keyid:06:76:DB:88:EB:61:55:4C:C9:63:41:C2:A0:A8:57:3F:D7:F1:B8:EC\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIIBlDCCAUagAwIBAgIUFTt\/jcgQ65nhTG8LkrWFJhhEGuwwBQYDK2VwMDsxCzAJ\\n\" +\n-                \"BgNVBAYTAlVTMQ0wCwYDVQQKDARqYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3Qg\\n\" +\n-                \"U2VyaXZjZTAeFw0yMDA1MjQyMzMyMzZaFw0zMDA1MjIyMzMyMzZaMFUxCzAJBgNV\\n\" +\n-                \"BAYTAlVTMQ0wCwYDVQQKDARqYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\\n\" +\n-                \"aXZjZTEYMBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MCowBQYDK2VwAyEAGAYQmKb7\\n\" +\n-                \"WNYpVxIdsc49lI1emNjF06\/Jl85zlG0wc9OjQjBAMB0GA1UdDgQWBBQkJ2E4\/S8Z\\n\" +\n-                \"EIM1v9uTc0eYtYNk3zAfBgNVHSMEGDAWgBQGdtuI62FVTMljQcKgqFc\/1\/G47DAF\\n\" +\n-                \"BgMrZXADQQCVZnl\/AyIEtZ8r45e\/hcfxwuezgRX+7e9NHZFV1A\/TMGcBRORDfDUi\\n\" +\n-                \"bbh72K528fjT7P4\/WoXvm1zJKOAzUOUL\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MC4CAQAwBQYDK2VwBCIEIGBmdh4tfc0lng\/LWokhfFLlo0ZlmTn2lbI639qou2KP\"),\n-\n-        EE_ED448(\n-                \"EdDSA\",\n-                \/\/ ED448\n-                \/\/ Validity\n-                \/\/     Not Before: May 24 23:23:43 2020 GMT\n-                \/\/     Not After : May 22 23:23:43 2030 GMT\n-                \/\/ X509v3 Authority Key Identifier:\n-                \/\/     keyid:F5:D5:9D:FB:6F:B7:50:29:DF:F0:B8:83:10:5F:9B:C4:A8:1C:E9:F4\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIIB3zCCAV+gAwIBAgIUNlWzFrH2+BILqM3SNYQjKoY98S8wBQYDK2VxMDsxCzAJ\\n\" +\n-                \"BgNVBAYTAlVTMQ0wCwYDVQQKDARqYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3Qg\\n\" +\n-                \"U2VyaXZjZTAeFw0yMDA1MjQyMzIzNDNaFw0zMDA1MjIyMzIzNDNaMFUxCzAJBgNV\\n\" +\n-                \"BAYTAlVTMQ0wCwYDVQQKDARqYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\\n\" +\n-                \"aXZjZTEYMBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MEMwBQYDK2VxAzoAoIubPNAg\\n\" +\n-                \"F11u3MQ5d9wujg10+80I0xzYzTqzzXrfJNtw+eU8NbUk86xiCvlMzJRH0Oo3DbY8\\n\" +\n-                \"NAKAo0IwQDAdBgNVHQ4EFgQUUiI1+qT1x+HsDgfZRIU6hUaAbmUwHwYDVR0jBBgw\\n\" +\n-                \"FoAU9dWd+2+3UCnf8LiDEF+bxKgc6fQwBQYDK2VxA3MAx8P0mle08s5YDd\/p58dt\\n\" +\n-                \"yORqvDPwo5IYPasqN8Zeen1B9u1xF\/kvDGFxCJ6D9Gi4ynnDx0FZFMkA83evZcxJ\\n\" +\n-                \"+X+swt7FyHwXrdkZcvjRKEcsWhkj+0FlxYF\/NZzLTGuGIPYJnRLEwf\/zr+5NDxKs\\n\" +\n-                \"fCoA\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MEcCAQAwBQYDK2VxBDsEOfbhmUSuKP9WCO7Nr6JxVq5rfJESk1MNMyYhC134SiAP\\n\" +\n-                \"Suw0Cu7RZVadpfPR7Kiwb2b\/JXjMdY1HAA==\");\n-\n-        final String keyAlgo;\n-        final String certStr;\n-        final String privKeyStr;\n-\n-        Cert(String keyAlgo, String certStr, String privKeyStr) {\n-            this.keyAlgo = keyAlgo;\n-            this.certStr = certStr;\n-            this.privKeyStr = privKeyStr;\n-        }\n-    }\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLSocketTemplate.java","additions":3,"deletions":737,"binary":false,"changes":740,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 7154070\n+ * @key headful\n+ * @summary  Verifies if switching between LaFs JTable dividers setting are not lost\n+ * @run main TestJTableGridReset\n+ *\/\n+\n+import javax.swing.JTable;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+public class TestJTableGridReset {\n+\n+    private static JTable table;\n+    private static volatile boolean origHorizLines;\n+    private static volatile boolean origVertLines;\n+    private static volatile boolean curHorizLines;\n+    private static volatile boolean curVertLines;\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported L&F: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        for (UIManager.LookAndFeelInfo laf :\n+                 UIManager.getInstalledLookAndFeels()) {\n+            System.out.println(\"Testing L&F: \" + laf.getClassName());\n+            SwingUtilities.invokeAndWait(() -> {\n+                setLookAndFeel(laf);\n+                table = new JTable();\n+                table.setShowHorizontalLines(true);\n+                table.setShowVerticalLines(true);\n+                SwingUtilities.updateComponentTreeUI(table);\n+                origHorizLines = table.getShowHorizontalLines();\n+                origVertLines = table.getShowVerticalLines();\n+            });\n+            UIManager.setLookAndFeel(\"javax.swing.plaf.nimbus.NimbusLookAndFeel\");\n+            SwingUtilities.invokeAndWait(() -> {\n+                SwingUtilities.updateComponentTreeUI(table);\n+                setLookAndFeel(laf);\n+                SwingUtilities.updateComponentTreeUI(table);\n+                curHorizLines = table.getShowHorizontalLines();\n+                curVertLines = table.getShowVerticalLines();\n+            });\n+            System.out.println(\"origHorizLines \" + origHorizLines +\n+                               \" origVertLines \" + origVertLines);\n+            System.out.println(\"curHorizLines \" + curHorizLines +\n+                                \" curVertLines \" + curVertLines);\n+            if (origHorizLines != curHorizLines ||\n+                origVertLines != curVertLines) {\n+                throw new RuntimeException(\"Horizontal\/Vertical grid lines not restored\");\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/JTable\/TestJTableGridReset.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -322,1 +322,1 @@\n-                                                    var tk = TypeKind.fromDescriptor(pt.descriptorString());\n+                                                    var tk = TypeKind.from(pt);\n","filename":"test\/jdk\/jdk\/classfile\/AdvancedTransformationsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-                List.of(PackageDesc.of(\"foo.bar.baz\"), PackageDesc.of(\"quux\"), PackageDesc.of(\"foo.bar.baz\"), PackageDesc.of(\"quux\")),\n@@ -90,0 +89,1 @@\n+                          .with(ModulePackagesAttribute.ofNames(PackageDesc.of(\"foo.bar.baz\"), PackageDesc.of(\"quux\")))\n@@ -185,1 +185,1 @@\n-        assertEquals(a.packages().stream().map(pe -> pe.asSymbol().packageName()).toList(), List.of(\"0\", \"1\", \"2\", \"3\", \"4\", \"o0\", \"o1\", \"o2\", \"foo.bar.baz\", \"quux\"));\n+        assertEquals(a.packages().stream().map(pe -> pe.asSymbol().packageName()).toList(), List.of(\"foo.bar.baz\", \"quux\"));\n","filename":"test\/jdk\/jdk\/classfile\/ModuleBuilderTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-maxOutputSize = 500000\n+maxOutputSize = 2500000\n","filename":"test\/jdk\/jdk\/classfile\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        byte[] moduleInfo = Classfile.buildModule(ModuleAttribute.of(moduleName, handler), List.of(), clb -> {\n+        byte[] moduleInfo = Classfile.buildModule(ModuleAttribute.of(moduleName, handler), clb -> {\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ModuleExamples.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,0 @@\n-import com.sun.jarsigner.ContentSigner;\n-import com.sun.jarsigner.ContentSignerParameters;\n@@ -132,1 +130,0 @@\n-        npe(()->b1.setProperty(\"altsigner\", null));\n@@ -150,1 +147,0 @@\n-        assertTrue(js2.getProperty(\"altsigner\") == null);\n@@ -166,1 +162,0 @@\n-                .setProperty(\"altsigner\", \"MyContentSigner\")\n@@ -178,2 +173,0 @@\n-        assertTrue(js3.getProperty(\"altsigner\").equals(\"MyContentSigner\"));\n-        assertTrue(js3.getProperty(\"altsignerpath\") == null);\n@@ -210,8 +203,0 @@\n-\n-        \/\/ altsigner does not support modern algorithms\n-        JarSigner.Builder b4 = new JarSigner.Builder(\n-                (PrivateKey)ks.getKey(\"e\", pass),\n-                CertificateFactory.getInstance(\"X.509\")\n-                        .generateCertPath(Arrays.asList(ks.getCertificateChain(\"e\"))));\n-        b4.setProperty(\"altsigner\", \"MyContentSigner\");\n-        iae(() -> b4.build());\n@@ -256,11 +241,0 @@\n-\n-    static class MyContentSigner extends ContentSigner {\n-        @Override\n-        public byte[] generateSignedData(\n-                ContentSignerParameters parameters,\n-                boolean omitContent,\n-                boolean applyTimestamp) throws NoSuchAlgorithmException,\n-                CertificateException, IOException {\n-            return new byte[0];\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/security\/jarsigner\/Spec.java","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    static final boolean debug = false;\n+    static final boolean debug = true;\n@@ -70,1 +70,0 @@\n-\n","filename":"test\/jdk\/sun\/security\/provider\/certpath\/OCSP\/OCSPNoContentLength.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-public class AlpnGreaseTest implements SSLContextTemplate {\n+public class AlpnGreaseTest extends SSLContextTemplate {\n","filename":"test\/jdk\/sun\/security\/ssl\/ALPN\/AlpnGreaseTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+    @Override\n@@ -53,4 +54,4 @@\n-                new SSLSocketTemplate.Cert[] {\n-                        SSLSocketTemplate.Cert.CA_ECDSA_SECP384R1 },\n-                new SSLSocketTemplate.Cert[] {\n-                        SSLSocketTemplate.Cert.EE_ECDSA_SECP384R1 },\n+                new SSLContextTemplate.Cert[] {\n+                        SSLContextTemplate.Cert.CA_ECDSA_SECP384R1 },\n+                new SSLContextTemplate.Cert[] {\n+                        SSLContextTemplate.Cert.EE_ECDSA_SECP384R1 },\n@@ -60,0 +61,1 @@\n+    @Override\n@@ -62,4 +64,4 @@\n-                new SSLSocketTemplate.Cert[] {\n-                        SSLSocketTemplate.Cert.CA_ECDSA_SECP384R1 },\n-                new SSLSocketTemplate.Cert[] {\n-                        SSLSocketTemplate.Cert.EE_ECDSA_SECP384R1 },\n+                new SSLContextTemplate.Cert[] {\n+                        SSLContextTemplate.Cert.CA_ECDSA_SECP384R1 },\n+                new SSLContextTemplate.Cert[] {\n+                        SSLContextTemplate.Cert.EE_ECDSA_SECP384R1 },\n","filename":"test\/jdk\/sun\/security\/ssl\/CipherSuite\/DisabledCurve.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,4 +31,1 @@\n-import java.io.ByteArrayInputStream;\n-import java.security.KeyFactory;\n-import java.security.KeyStore;\n-import java.security.PrivateKey;\n+\n@@ -36,3 +33,0 @@\n-import java.security.cert.Certificate;\n-import java.security.cert.CertificateFactory;\n-import java.security.spec.PKCS8EncodedKeySpec;\n@@ -40,2 +34,0 @@\n-import java.util.Base64;\n-import javax.net.ssl.KeyManagerFactory;\n@@ -45,1 +37,0 @@\n-import javax.net.ssl.TrustManagerFactory;\n@@ -61,1 +52,5 @@\n-        this.context = createSSLContext();\n+        this.context = createSSLContext(\n+                new Cert[]{Cert.EE_RSASSA_PSS},\n+                new Cert[]{Cert.EE_RSASSA_PSS},\n+                new ContextParameters(\"TLS\", \"PKIX\", \"NewSunX509\")\n+        );\n@@ -65,1 +60,1 @@\n-    protected SSLContext createClientSSLContext() throws Exception {\n+    public SSLContext createClientSSLContext() throws Exception {\n@@ -70,1 +65,1 @@\n-    protected SSLContext createServerSSLContext() throws Exception {\n+    public SSLContext createServerSSLContext() throws Exception {\n@@ -120,112 +115,0 @@\n-\n-\n-    private static final String trustedCertStr =\n-        \/**\n-        * Signature Algorithm: rsassaPss\n-        * Issuer: CN = localhost\n-        * Validity Not Before: Jun 6 07:11:00 2018 GMT\n-        * Not After : Jun 1 07:11:00 2038 GMT\n-        * Subject: CN = localhost\n-        * Public Key Algorithm: rsassaPss\n-        *\/\n-       \"-----BEGIN CERTIFICATE-----\\n\"\n-       + \"MIIDZjCCAh2gAwIBAgIUHxwPs3eAgJ057nJwiLgWZWeNqdgwPgYJKoZIhvcNAQEK\\n\"\n-       + \"MDGgDTALBglghkgBZQMEAgGhGjAYBgkqhkiG9w0BAQgwCwYJYIZIAWUDBAIBogQC\\n\"\n-       + \"AgDeMBQxEjAQBgNVBAMMCWxvY2FsaG9zdDAeFw0xODA2MDYwNzExMDBaFw0zODA2\\n\"\n-       + \"MDEwNzExMDBaMBQxEjAQBgNVBAMMCWxvY2FsaG9zdDCCASAwCwYJKoZIhvcNAQEK\\n\"\n-       + \"A4IBDwAwggEKAoIBAQCl8r4Qrg27BYUO\/1Va2Ix8QPGzN\/lvzmKvP5Ff26ovNW4v\\n\"\n-       + \"RUx68HzAhhiWtcl+PwLSbJqJreEkTlle7PnRAypby3fO7ZAK0Y3YiHquaBg7d+7Y\\n\"\n-       + \"FhhHwv8gG0lZcyA0BkXFJHqdq76qar0xHC6DVezXm0K3mcceymGtFR9BzWmAj+7D\\n\"\n-       + \"YsSwvtTQ7WNoQmf0cdDMSM71IwaTwIwvT2wzX1vv5hcdDyXdr64WFqWSA9sNJ2K6\\n\"\n-       + \"arxaaU1klwKSgDokF6njafWQ4UxdR67d5W1MYoiioDs2Yy3utsMpO2OUzZVBZNdT\\n\"\n-       + \"gkr1jsJhIurpz\/5K51lwJIRQBezEFSb+60AFVoMJAgMBAAGjUDBOMB0GA1UdDgQW\\n\"\n-       + \"BBQfFit5ilWJmZgCX4QY0HsaI9iIDDAfBgNVHSMEGDAWgBQfFit5ilWJmZgCX4QY\\n\"\n-       + \"0HsaI9iIDDAMBgNVHRMEBTADAQH\/MD4GCSqGSIb3DQEBCjAxoA0wCwYJYIZIAWUD\\n\"\n-       + \"BAIBoRowGAYJKoZIhvcNAQEIMAsGCWCGSAFlAwQCAaIEAgIA3gOCAQEAa4yUQ3gh\\n\"\n-       + \"d1YWPdEa1sv2hdkhtenw6m5yxbmaQl2+nIKSpk4RfpXC7K1EYwBF8TdfFbD8hGGh\\n\"\n-       + \"5n81BT0\/dn1R9SRGCv7KTxx4lfQt31frlsw\/tVciwyXQtcUZ6DqfnLP0\/aRVLNgx\\n\"\n-       + \"zaP542JUHFYLTC3EGz2zUgv70ZUTlIsPG3\/p8YO1iXdnYGQyzOuQPUBpI7nS7UtR\\n\"\n-       + \"Ug8VE9ACpBxxI3qChMahFZGHlXCCSjSmxpQa6UO4SQl8q5tPNnqdzWwvAW8qkCy4\\n\"\n-       + \"6barRQ4sMcGayhHh\/uSTx7bcl0FMJpcI1ygbw7\/Pc03zKtw0gMTBMns7q4yXjb\/u\\n\"\n-       + \"ef47nW0t+LRAAg==\\n\"\n-       + \"-----END CERTIFICATE-----\\n\";\n-\n-    private static final String keyCertStr = trustedCertStr;\n-\n-    private static final String privateKey =\n-        \"MIIEuwIBADALBgkqhkiG9w0BAQoEggSnMIIEowIBAAKCAQEApfK+EK4NuwWFDv9V\\n\"\n-        + \"WtiMfEDxszf5b85irz+RX9uqLzVuL0VMevB8wIYYlrXJfj8C0myaia3hJE5ZXuz5\\n\"\n-        + \"0QMqW8t3zu2QCtGN2Ih6rmgYO3fu2BYYR8L\/IBtJWXMgNAZFxSR6nau+qmq9MRwu\\n\"\n-        + \"g1Xs15tCt5nHHsphrRUfQc1pgI\/uw2LEsL7U0O1jaEJn9HHQzEjO9SMGk8CML09s\\n\"\n-        + \"M19b7+YXHQ8l3a+uFhalkgPbDSdiumq8WmlNZJcCkoA6JBep42n1kOFMXUeu3eVt\\n\"\n-        + \"TGKIoqA7NmMt7rbDKTtjlM2VQWTXU4JK9Y7CYSLq6c\/+SudZcCSEUAXsxBUm\/utA\\n\"\n-        + \"BVaDCQIDAQABAoIBAAc4vRS0vlw5LUUtz2UYr2Ro3xvRf8Vh0eGWfpkRUiKjzJu6\\n\"\n-        + \"BE4FUSh\/rWpBlvcrfs\/xcfgz3OxbjIAZB\/YUkS9Vd21F4VLXM7kMl2onlYZg\/b\/h\\n\"\n-        + \"lkTpM3kONu7xl6Er9LVTlRJveuinpHwSoeONRbVMSGb9BjFM1VtW4\/lVGxZBG05D\\n\"\n-        + \"y9i\/o4vCZqULn9cAumOwicKuCyTcS58XcMJ+puSPfRA71PYLxqFkASAoJsUwCXpo\\n\"\n-        + \"gs39lLsIFgrfO8mBO1ux\/SE+QaRc+9XqFSHHKD1XqF\/9zSYBgWjE910EcpdYEdZx\\n\"\n-        + \"GEkwea7Fn4brO5OpIrHY\/45naqbUOBzv6gufMAECgYEAz7PHCdcrQvmOb8EiNbQH\\n\"\n-        + \"uvSimwObWJFeN1ykp6mfRbSnkXw7p8+M4Tc8HFi8QLpoq63Ev2AwoaQCQvHbFC2Y\\n\"\n-        + \"1Cz0EkC0aOp+tZP7U2AUBdkcDesZAJQTad0zV6KesyIUXdxZXDG8JJ1XSNWfTJV4\\n\"\n-        + \"QD+BjLZ0jiAyCIfVYvWQqYkCgYEAzIln1nKTixLMPr5CldSmR7ZarEtPJU+hHwVg\\n\"\n-        + \"dV\/Lc6d2Yy9JgunOXRo4BXB1TEo8JFbK3HBQH6tS8li4qDr7WK5wyYfh8qb4WZyu\\n\"\n-        + \"lc562f2WVYntcN8\/Ojb+Vyrt7lk9sq\/8KoVHxEAWd6mqL9VTPYuAu1Vw9fTGIZfB\\n\"\n-        + \"lDeELYECgYAvdzU4UXzofGGJtohb332YwwlaBZP9xJLUcg6K5l+orWVSASMc8XiP\\n\"\n-        + \"i3DoRXsYC8GZ4kdBOPlEJ1gA9oaLcPQpIPDSLwlLpLM6Scw4vI822uvnXl\/DWxOo\\n\"\n-        + \"sM1n7Jj59QLUhGPDhvYpI+\/rjC4wcUQe4qR3hMbUKBVnD6u7RsU9iQKBgQCQ17VK\\n\"\n-        + \"7bSCRfuRaxaoGADww7gOTv5rQ6qr1xjpxb7D1hFGR9Rc+smCsPB\/GZZXQjK44SWj\\n\"\n-        + \"WX3ED4Ubzaxmpe4cbNu+O5XMSmWQwB36RFBHUwdE5\/nXdqDFzu\/qNqJrqZLBmVKP\\n\"\n-        + \"ofaiiWffsaytVvotmT6+atElvAMbAua42V+nAQKBgHtIn3mYMHLriYGhQzpkFEA2\\n\"\n-        + \"8YcAMlKppueOMAKVy8nLu2r3MidmLAhMiKJQKG45I3Yg0\/t\/25tXLiOPJlwrOebh\\n\"\n-        + \"xQqUBI\/JUOIpGAEnr48jhOXnCS+i+z294G5U\/RgjXrlR4bCPvrtCmwzWwe0h79w2\\n\"\n-        + \"Q2hO5ZTW6UD9CVA85whf\";\n-\n-    private static SSLContext createSSLContext() throws Exception {\n-        \/\/ Generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        \/\/ Create a key store\n-        KeyStore ts = KeyStore.getInstance(\"PKCS12\");\n-        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n-        ts.load(null, null);\n-        ks.load(null, null);\n-        char passphrase[] = \"passphrase\".toCharArray();\n-\n-        \/\/ Import the trusted cert\n-        ts.setCertificateEntry(\"trusted-cert-RSASSA-PSS\",\n-                cf.generateCertificate(new ByteArrayInputStream(\n-                        trustedCertStr.getBytes())));\n-\n-        boolean hasKeyMaterials = keyCertStr != null && privateKey != null;\n-        if (hasKeyMaterials) {\n-\n-            \/\/ Generate the private key.\n-            PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n-                    Base64.getMimeDecoder().decode(privateKey));\n-            KeyFactory kf = KeyFactory.getInstance(\"RSASSA-PSS\");\n-            PrivateKey priKey = kf.generatePrivate(priKeySpec);\n-\n-            \/\/ Generate certificate chain\n-            Certificate keyCert = cf.generateCertificate(\n-                    new ByteArrayInputStream(keyCertStr.getBytes()));\n-            Certificate[] chain = new Certificate[]{keyCert};\n-\n-            \/\/ Import the key entry.\n-            ks.setKeyEntry(\"cert-RSASSA-PSS\", priKey, passphrase, chain);\n-        }\n-\n-        \/\/ Create SSL context\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n-        tmf.init(ts);\n-\n-        SSLContext context = SSLContext.getInstance(\"TLS\");\n-        if (hasKeyMaterials) {\n-            KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"NewSunX509\");\n-            kmf.init(ks, passphrase);\n-            context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-        } else {\n-            context.init(null, tmf.getTrustManagers(), null);\n-        }\n-\n-        return context;\n-    }\n","filename":"test\/jdk\/sun\/security\/ssl\/CipherSuite\/RestrictSignatureScheme.java","additions":9,"deletions":126,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/javax\/net\/ssl\/templates\n@@ -85,1 +85,0 @@\n-import java.security.*;\n@@ -92,1 +91,1 @@\n-public class SSLEngineBadBufferArrayAccess {\n+public class SSLEngineBadBufferArrayAccess extends SSLContextTemplate {\n@@ -97,1 +96,2 @@\n-    private static boolean logging = true;\n+    private final static boolean logging = Boolean.parseBoolean(\n+            System.getProperty(\"test.logging\", \"true\"));\n@@ -108,2 +108,3 @@\n-    private static boolean debug = false;\n-    private SSLContext sslc;\n+    private final static boolean debug = Boolean.getBoolean(\"test.debug\");\n+    private final String PROTOCOL;\n+\n@@ -127,14 +128,0 @@\n-    \/*\n-     * The following is to set up the keystores\/trust material.\n-     *\/\n-    private static final String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    private static final String keyStoreFile = \"keystore\";\n-    private static final String trustStoreFile = \"truststore\";\n-    private static final String passwd = \"passphrase\";\n-    private static String keyFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores\n-            + \"\/\" + keyStoreFile;\n-    private static String trustFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores\n-            + \"\/\" + trustStoreFile;\n-\n@@ -159,1 +146,1 @@\n-    public static void main(String args[]) throws Exception {\n+    public static void main(String[] args) throws Exception {\n@@ -168,1 +155,1 @@\n-            \"SSLv3\", \"TLSv1\", \"TLSv1.1\", \"TLSv1.2\" };\n+            \"SSLv3\", \"TLSv1\", \"TLSv1.1\", \"TLSv1.2\", \"TLSv1.3\"};\n@@ -187,22 +174,3 @@\n-    public SSLEngineBadBufferArrayAccess(String protocol) throws Exception {\n-\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        KeyStore ts = KeyStore.getInstance(\"JKS\");\n-\n-        char[] passphrase = \"passphrase\".toCharArray();\n-\n-        try (FileInputStream fis = new FileInputStream(keyFilename)) {\n-            ks.load(fis, passphrase);\n-        }\n-\n-        try (FileInputStream fis = new FileInputStream(trustFilename)) {\n-            ts.load(fis, passphrase);\n-        }\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(ks, passphrase);\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(ts);\n-\n-        SSLContext sslCtx = SSLContext.getInstance(protocol);\n+    public SSLEngineBadBufferArrayAccess(String protocol) {\n+        PROTOCOL = protocol;\n+    }\n@@ -210,1 +178,4 @@\n-        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+    @Override\n+    protected ContextParameters getServerContextParameters() {\n+        return new ContextParameters(PROTOCOL, \"PKIX\", \"NewSunX509\");\n+    }\n@@ -212,1 +183,3 @@\n-        sslc = sslCtx;\n+    @Override\n+    protected ContextParameters getClientContextParameters() {\n+        return new ContextParameters(PROTOCOL, \"PKIX\", \"NewSunX509\");\n@@ -235,0 +208,1 @@\n+        System.out.println(\"Running test serverClose = \" + serverClose);\n@@ -247,1 +221,1 @@\n-            socket = (Socket) serverSocket.accept();\n+            socket = serverSocket.accept();\n@@ -330,1 +304,1 @@\n-            int len = 0;\n+            int len;\n@@ -339,1 +313,8 @@\n-                    throw new Exception(\"Unexpected EOF\");\n+                    logSocketStatus(socket);\n+                    if (socket.isClosed()\n+                            || socket.isOutputShutdown()) {\n+                        log(\"Client socket was closed or shutdown output\");\n+                        break;\n+                    } else {\n+                        throw new Exception(\"Unexpected EOF\");\n+                    }\n@@ -375,1 +356,1 @@\n-                 * We'll alternate initiatating the shutdown.\n+                 * We'll alternate initiating the shutdown.\n@@ -382,3 +363,0 @@\n-            }\n-\n-            if (closed && isEngineClosed(serverEngine)) {\n@@ -406,0 +384,1 @@\n+                break;\n@@ -453,1 +432,1 @@\n-        SSLSocketFactory sslsf = sslc.getSocketFactory();\n+        SSLSocketFactory sslsf = createClientSSLContext().getSocketFactory();\n@@ -495,0 +474,1 @@\n+        System.out.println(\"writing message to server.\");\n@@ -502,0 +482,1 @@\n+            System.out.printf(\"Client read %d bytes. Waiting for %d from server.%n\", len, serverMsg.length);\n@@ -505,0 +486,1 @@\n+                System.out.println(\"Closing the socket\");\n@@ -509,1 +491,1 @@\n-\n+        System.out.println(\"Read everything we're going to, I guess.\");\n@@ -530,1 +512,1 @@\n-        serverEngine = sslc.createSSLEngine();\n+        serverEngine = createServerSSLContext().createSSLEngine();\n@@ -592,0 +574,9 @@\n+    private static void logSocketStatus(Socket socket) {\n+        log(\"##### \" + socket + \" #####\");\n+        log(\"isBound: \" + socket.isBound());\n+        log(\"isConnected: \" + socket.isConnected());\n+        log(\"isClosed: \" + socket.isClosed());\n+        log(\"isInputShutdown: \" + socket.isInputShutdown());\n+        log(\"isOutputShutdown: \" + socket.isOutputShutdown());\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/SSLEngineBadBufferArrayAccess.java","additions":47,"deletions":56,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-public class InvalidateSession implements SSLContextTemplate {\n+public class InvalidateSession extends SSLContextTemplate {\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/InvalidateSession.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-public class ClientSocketCloseHang implements SSLContextTemplate {\n+public class ClientSocketCloseHang extends SSLContextTemplate {\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/ClientSocketCloseHang.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,147 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/\n-\/\/ Please run in othervm mode.  SunJSSE does not support dynamic system\n-\/\/ properties, no way to re-use system properties in samevm\/agentvm mode.\n-\/\/\n-\n-\/*\n- * @test\n- * @bug 8209333\n- * @summary Socket reset issue for TLS 1.3 socket close\n- * @library \/javax\/net\/ssl\/templates\n- * @run main\/othervm SSLSocketBruceForceClose\n- *\/\n-\n-import javax.net.ssl.*;\n-import java.io.*;\n-import java.net.InetAddress;\n-\n-public class SSLSocketBruceForceClose implements SSLContextTemplate {\n-\n-    public static void main(String[] args) throws Exception {\n-        for (int i = 0; i<= 10; i++) {\n-            System.err.println(\"===================================\");\n-            System.err.println(\"loop \" + i);\n-            System.err.println(\"===================================\");\n-            new SSLSocketBruceForceClose().test();\n-        }\n-    }\n-\n-    private void test() throws Exception {\n-        SSLServerSocket listenSocket = null;\n-        SSLSocket serverSocket = null;\n-        ClientSocket clientSocket = null;\n-        try {\n-            SSLServerSocketFactory serversocketfactory =\n-                    createServerSSLContext().getServerSocketFactory();\n-            listenSocket =\n-                    (SSLServerSocket)serversocketfactory.createServerSocket(0);\n-            listenSocket.setNeedClientAuth(false);\n-            listenSocket.setEnableSessionCreation(true);\n-            listenSocket.setUseClientMode(false);\n-\n-\n-            System.err.println(\"Starting client\");\n-            clientSocket = new ClientSocket(listenSocket.getLocalPort());\n-            clientSocket.start();\n-\n-            System.err.println(\"Accepting client requests\");\n-            serverSocket = (SSLSocket) listenSocket.accept();\n-\n-            System.err.println(\"Reading data from client\");\n-            BufferedReader serverReader = new BufferedReader(\n-                    new InputStreamReader(serverSocket.getInputStream()));\n-            String data = serverReader.readLine();\n-            System.err.println(\"Received data from client: \" + data);\n-\n-            System.err.println(\"Reading more data from client\");\n-            data = serverReader.readLine();\n-            System.err.println(\"Received data from client: \" + data);\n-        } finally {\n-            if (listenSocket != null) {\n-                listenSocket.close();\n-            }\n-\n-            if (serverSocket != null) {\n-                serverSocket.close();\n-            }\n-        }\n-\n-        if (clientSocket != null && clientSocket.clientException != null) {\n-            throw clientSocket.clientException;\n-        }\n-    }\n-\n-    private class ClientSocket extends Thread{\n-        int serverPort = 0;\n-        Exception clientException;\n-\n-        public ClientSocket(int serverPort) {\n-            this.serverPort = serverPort;\n-        }\n-\n-        @Override\n-        public void run() {\n-            SSLSocket clientSocket = null;\n-            String clientData = \"Hi, I am client\";\n-            try {\n-                System.err.println(\n-                        \"Connecting to server at port \" + serverPort);\n-                SSLSocketFactory sslSocketFactory =\n-                        createClientSSLContext().getSocketFactory();\n-                clientSocket = (SSLSocket)sslSocketFactory.createSocket(\n-                        InetAddress.getLocalHost(), serverPort);\n-                clientSocket.setSoLinger(true, 3);\n-                clientSocket.setSoTimeout(1000);\n-\n-\n-                System.err.println(\"Sending data to server ...\");\n-\n-                BufferedWriter os = new BufferedWriter(\n-                        new OutputStreamWriter(clientSocket.getOutputStream()));\n-                os.write(clientData, 0, clientData.length());\n-                os.newLine();\n-                os.flush();\n-\n-                System.err.println(\"Sending more data to server ...\");\n-                os.write(clientData, 0, clientData.length());\n-                os.newLine();\n-                os.flush();\n-            } catch (Exception e) {\n-                clientException = e;\n-            } finally {\n-                if (clientSocket != null) {\n-                    try{\n-                        clientSocket.close();\n-                        System.err.println(\"client socket closed\");\n-                    } catch (IOException ioe) {\n-                        clientException = ioe;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SSLSocketBruceForceClose.java","additions":0,"deletions":147,"binary":false,"changes":147,"status":"deleted"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/\n+\/\/ Please run in othervm mode.  SunJSSE does not support dynamic system\n+\/\/ properties, no way to re-use system properties in samevm\/agentvm mode.\n+\/\/\n+\n+\/*\n+ * @test\n+ * @bug 8209333\n+ * @summary Socket reset issue for TLS 1.3 socket close\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm SSLSocketBruteForceClose\n+ *\/\n+\n+import javax.net.ssl.*;\n+import java.io.*;\n+import java.net.SocketException;\n+\n+public class SSLSocketBruteForceClose extends SSLSocketTemplate {\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int i = 0; i<= 10; i++) {\n+            System.err.println(\"===================================\");\n+            System.err.println(\"loop \" + i);\n+            System.err.println(\"===================================\");\n+            new SSLSocketBruteForceClose().run();\n+        }\n+    }\n+\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket socket) {\n+        socket.setNeedClientAuth(false);\n+        socket.setEnableSessionCreation(true);\n+        socket.setUseClientMode(false);\n+    }\n+\n+    @Override\n+    protected void runServerApplication(SSLSocket socket) throws Exception {\n+        System.err.println(\"Reading data from client\");\n+        BufferedReader serverReader = new BufferedReader(\n+                new InputStreamReader(socket.getInputStream()));\n+        String data = serverReader.readLine();\n+        System.err.println(\"Received data from client: \" + data);\n+\n+        System.err.println(\"Reading more data from client\");\n+        data = serverReader.readLine();\n+        System.err.println(\"Received data from client: \" + data);\n+    }\n+\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        try {\n+            socket.setSoLinger(true, 3);\n+            socket.setSoTimeout(1000);\n+        } catch (SocketException exc) {\n+            throw new RuntimeException(\"Could not configure client socket\", exc);\n+        }\n+    }\n+\n+    @Override\n+    protected void runClientApplication(SSLSocket socket) throws Exception {\n+        String clientData = \"Hi, I am client\";\n+\n+        System.err.println(\"Sending data to server ...\");\n+        BufferedWriter os = new BufferedWriter(\n+                new OutputStreamWriter(socket.getOutputStream()));\n+        os.write(clientData, 0, clientData.length());\n+        os.newLine();\n+        os.flush();\n+\n+        System.err.println(\"Sending more data to server ...\");\n+        os.write(clientData, 0, clientData.length());\n+        os.newLine();\n+        os.flush();\n+\n+        socket.close();\n+        System.err.println(\"client socket closed\");\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SSLSocketBruteForceClose.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import java.net.SocketException;\n@@ -41,1 +42,1 @@\n-public class SSLSocketClose implements SSLContextTemplate {\n+public class SSLSocketClose extends SSLSocketTemplate {\n@@ -45,4 +46,4 @@\n-            System.err.println(\"===================================\");\n-            System.err.println(\"loop \" + i);\n-            System.err.println(\"===================================\");\n-            new SSLSocketClose().test();\n+            System.out.println(\"===================================\");\n+            System.out.println(\"loop \" + i);\n+            System.out.println(\"===================================\");\n+            new SSLSocketClose().run();\n@@ -52,51 +53,5 @@\n-    private void test() throws Exception {\n-        SSLServerSocket listenSocket = null;\n-        SSLSocket serverSocket = null;\n-        ClientSocket clientSocket = null;\n-        try {\n-            SSLServerSocketFactory serversocketfactory =\n-                    createServerSSLContext().getServerSocketFactory();\n-            listenSocket =\n-                    (SSLServerSocket)serversocketfactory.createServerSocket(0);\n-            listenSocket.setNeedClientAuth(false);\n-            listenSocket.setEnableSessionCreation(true);\n-            listenSocket.setUseClientMode(false);\n-\n-\n-            System.err.println(\"Starting client\");\n-            clientSocket = new ClientSocket(listenSocket.getLocalPort());\n-            clientSocket.start();\n-\n-            System.err.println(\"Accepting client requests\");\n-            serverSocket = (SSLSocket) listenSocket.accept();\n-\n-            System.err.println(\"Reading data from client\");\n-            BufferedReader serverReader = new BufferedReader(\n-                    new InputStreamReader(serverSocket.getInputStream()));\n-            String data = serverReader.readLine();\n-            System.err.println(\"Received data from client: \" + data);\n-\n-            System.err.println(\"Sending data to client ...\");\n-            String serverData = \"Hi, I am server\";\n-            BufferedWriter os = new BufferedWriter(\n-                    new OutputStreamWriter(serverSocket.getOutputStream()));\n-            os.write(serverData, 0, serverData.length());\n-            os.newLine();\n-            os.flush();\n-\n-            System.err.println(\"Reading more data from client\");\n-            data = serverReader.readLine();\n-            System.err.println(\"Received data from client: \" + data);\n-        } finally {\n-            if (listenSocket != null) {\n-                listenSocket.close();\n-            }\n-\n-            if (serverSocket != null) {\n-                serverSocket.close();\n-            }\n-        }\n-\n-        if (clientSocket != null && clientSocket.clientException != null) {\n-            throw clientSocket.clientException;\n-        }\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket socket) {\n+        socket.setNeedClientAuth(false);\n+        socket.setEnableSessionCreation(true);\n+        socket.setUseClientMode(false);\n@@ -105,3 +60,20 @@\n-    private class ClientSocket extends Thread{\n-        int serverPort = 0;\n-        Exception clientException;\n+    @Override\n+    protected void runServerApplication(SSLSocket socket) throws Exception {\n+        System.out.println(\"Reading data from client\");\n+        BufferedReader serverReader = new BufferedReader(\n+                new InputStreamReader(socket.getInputStream()));\n+        String data = serverReader.readLine();\n+        System.out.println(\"Received data from client: \" + data);\n+\n+        System.out.println(\"Sending data to client ...\");\n+        String serverData = \"Hi, I am server\";\n+        BufferedWriter os = new BufferedWriter(\n+                new OutputStreamWriter(socket.getOutputStream()));\n+        os.write(serverData, 0, serverData.length());\n+        os.newLine();\n+        os.flush();\n+\n+        System.out.println(\"Reading more data from client\");\n+        data = serverReader.readLine();\n+        System.out.println(\"Received data from client: \" + data);\n+    }\n@@ -109,2 +81,6 @@\n-        public ClientSocket(int serverPort) {\n-            this.serverPort = serverPort;\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        try {\n+            socket.setSoLinger(true, 3);\n+        } catch (SocketException e) {\n+            throw new RuntimeException(\"Could not configure client socket\", e);\n@@ -112,0 +88,1 @@\n+    }\n@@ -113,44 +90,23 @@\n-        @Override\n-        public void run() {\n-            SSLSocket clientSocket = null;\n-            String clientData = \"Hi, I am client\";\n-            try {\n-                System.err.println(\n-                        \"Connecting to server at port \" + serverPort);\n-                SSLSocketFactory sslSocketFactory =\n-                        createClientSSLContext().getSocketFactory();\n-                clientSocket = (SSLSocket)sslSocketFactory.createSocket(\n-                        InetAddress.getLocalHost(), serverPort);\n-                clientSocket.setSoLinger(true, 3);\n-\n-                System.err.println(\"Sending data to server ...\");\n-\n-                BufferedWriter os = new BufferedWriter(\n-                        new OutputStreamWriter(clientSocket.getOutputStream()));\n-                os.write(clientData, 0, clientData.length());\n-                os.newLine();\n-                os.flush();\n-\n-                System.err.println(\"Reading data from server\");\n-                BufferedReader is = new BufferedReader(\n-                        new InputStreamReader(clientSocket.getInputStream()));\n-                String data = is.readLine();\n-                System.err.println(\"Received Data from server: \" + data);\n-\n-                System.err.println(\"Sending more data to server ...\");\n-                os.write(clientData, 0, clientData.length());\n-                os.newLine();\n-                os.flush();\n-            } catch (Exception e) {\n-                clientException = e;\n-            } finally {\n-                if (clientSocket != null) {\n-                    try{\n-                        clientSocket.close();\n-                        System.err.println(\"client socket closed\");\n-                    } catch (IOException ioe) {\n-                        clientException = ioe;\n-                    }\n-                }\n-            }\n-        }\n+    @Override\n+    protected void runClientApplication(SSLSocket socket) throws Exception {\n+        String clientData = \"Hi, I am client\";\n+        System.out.println(\"Sending data to server ...\");\n+\n+        BufferedWriter os = new BufferedWriter(\n+                new OutputStreamWriter(socket.getOutputStream()));\n+        os.write(clientData, 0, clientData.length());\n+        os.newLine();\n+        os.flush();\n+\n+        System.out.println(\"Reading data from server\");\n+        BufferedReader is = new BufferedReader(\n+                new InputStreamReader(socket.getInputStream()));\n+        String data = is.readLine();\n+        System.out.println(\"Received Data from server: \" + data);\n+\n+        System.out.println(\"Sending more data to server ...\");\n+        os.write(clientData, 0, clientData.length());\n+        os.newLine();\n+        os.flush();\n+\n+        socket.close();\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SSLSocketClose.java","additions":62,"deletions":106,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -41,1 +43,3 @@\n-public class SocketExceptionForSocketIssues implements SSLContextTemplate {\n+public class SocketExceptionForSocketIssues extends SSLSocketTemplate {\n+\n+    private final CountDownLatch waitForClient = new CountDownLatch(1);\n@@ -44,2 +48,9 @@\n-        System.err.println(\"===================================\");\n-        new SocketExceptionForSocketIssues().test();\n+        System.out.println(\"===================================\");\n+        new SocketExceptionForSocketIssues().run();\n+    }\n+\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket socket) {\n+        socket.setNeedClientAuth(false);\n+        socket.setEnableSessionCreation(true);\n+        socket.setUseClientMode(false);\n@@ -48,4 +59,2 @@\n-    private void test() throws Exception {\n-        SSLServerSocket listenSocket = null;\n-        SSLSocket serverSocket = null;\n-        ClientSocket clientSocket = null;\n+    @Override\n+    protected void runServerApplication(SSLSocket socket) throws Exception {\n@@ -53,18 +62,2 @@\n-            SSLServerSocketFactory serversocketfactory =\n-                    createServerSSLContext().getServerSocketFactory();\n-            listenSocket =\n-                    (SSLServerSocket)serversocketfactory.createServerSocket(0);\n-            listenSocket.setNeedClientAuth(false);\n-            listenSocket.setEnableSessionCreation(true);\n-            listenSocket.setUseClientMode(false);\n-\n-            System.err.println(\"Starting client\");\n-            clientSocket = new ClientSocket(listenSocket.getLocalPort());\n-            clientSocket.start();\n-\n-            System.err.println(\"Accepting client requests\");\n-            serverSocket = (SSLSocket)listenSocket.accept();\n-\n-            if (!clientSocket.isDone) {\n-                System.err.println(\"Waiting 3 seconds for client \");\n-                Thread.sleep(3000);\n+            if (!waitForClient.await(5, TimeUnit.SECONDS)) {\n+                throw new RuntimeException(\"Client didn't complete within 5 seconds.\");\n@@ -73,1 +66,1 @@\n-            System.err.println(\"Sending data to client ...\");\n+            System.out.println(\"Sending data to client ...\");\n@@ -76,1 +69,1 @@\n-                    new OutputStreamWriter(serverSocket.getOutputStream()));\n+                    new OutputStreamWriter(socket.getOutputStream()));\n@@ -80,2 +73,1 @@\n-        } catch (SSLProtocolException | SSLHandshakeException sslhe) {\n-            throw sslhe;\n+            throw new RuntimeException(\"The expected SocketException was not thrown.\");\n@@ -84,9 +76,1 @@\n-            System.err.println(\"server exception: \" + se);\n-        } finally {\n-            if (listenSocket != null) {\n-                listenSocket.close();\n-            }\n-\n-            if (serverSocket != null) {\n-                serverSocket.close();\n-            }\n+            System.out.println(\"Caught expected SocketException: \" + se);\n@@ -94,0 +78,1 @@\n+    }\n@@ -95,2 +80,7 @@\n-        if (clientSocket != null && clientSocket.clientException != null) {\n-            throw clientSocket.clientException;\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        try {\n+            socket.setSoLinger(true, 3);\n+            socket.setSoTimeout(100);\n+        } catch (SocketException exc) {\n+            throw new RuntimeException(\"Could not configure client socket.\", exc);\n@@ -100,0 +90,15 @@\n+    @Override\n+    protected void runClientApplication(SSLSocket socket) throws Exception {\n+        try {\n+            String clientData = \"Hi, I am client\";\n+            BufferedWriter os = new BufferedWriter(\n+                    new OutputStreamWriter(socket.getOutputStream()));\n+            os.write(clientData, 0, clientData.length());\n+            os.newLine();\n+            os.flush();\n+\n+            System.out.println(\"Reading data from server\");\n+            BufferedReader is = new BufferedReader(\n+                    new InputStreamReader(socket.getInputStream()));\n+            String data = is.readLine();\n+            System.out.println(\"Received Data from server: \" + data);\n@@ -101,0 +106,1 @@\n+            throw new RuntimeException(\"The expected client exception was not thrown.\");\n@@ -102,4 +108,3 @@\n-    private class ClientSocket extends Thread{\n-        boolean isDone = false;\n-        int serverPort = 0;\n-        Exception clientException;\n+        } catch (SSLProtocolException | SSLHandshakeException sslhe) {\n+            System.err.println(\"Client had unexpected SSL exception: \" + sslhe);\n+            throw sslhe;\n@@ -107,3 +112,3 @@\n-        public ClientSocket(int serverPort) {\n-            this.serverPort = serverPort;\n-        }\n+        } catch (SSLException | SocketTimeoutException ssle) {\n+            \/\/ the expected exception, ignore it\n+            System.out.println(\"Caught expected client exception: \" + ssle);\n@@ -111,49 +116,2 @@\n-        @Override\n-        public void run() {\n-            SSLSocket clientSocket = null;\n-            String clientData = \"Hi, I am client\";\n-            try {\n-                System.err.println(\n-                        \"Connecting to server at port \" + serverPort);\n-                SSLSocketFactory sslSocketFactory =\n-                        createClientSSLContext().getSocketFactory();\n-                clientSocket = (SSLSocket)sslSocketFactory.createSocket(\n-                        InetAddress.getLocalHost(), serverPort);\n-                clientSocket.setSoLinger(true, 3);\n-                clientSocket.setSoTimeout(100);\n-\n-\n-                System.err.println(\"Sending data to server ...\");\n-\n-                BufferedWriter os = new BufferedWriter(\n-                        new OutputStreamWriter(clientSocket.getOutputStream()));\n-                os.write(clientData, 0, clientData.length());\n-                os.newLine();\n-                os.flush();\n-\n-                System.err.println(\"Reading data from server\");\n-                BufferedReader is = new BufferedReader(\n-                        new InputStreamReader(clientSocket.getInputStream()));\n-                String data = is.readLine();\n-                System.err.println(\"Received Data from server: \" + data);\n-            } catch (SSLProtocolException | SSLHandshakeException sslhe) {\n-                clientException = sslhe;\n-                System.err.println(\"unexpected client exception: \" + sslhe);\n-            } catch (SSLException | SocketTimeoutException ssle) {\n-                \/\/ the expected exception, ignore it\n-                System.err.println(\"expected client exception: \" + ssle);\n-            } catch (Exception e) {\n-                clientException = e;\n-                System.err.println(\"unexpected client exception: \" + e);\n-            } finally {\n-                if (clientSocket != null) {\n-                    try {\n-                        clientSocket.close();\n-                        System.err.println(\"client socket closed\");\n-                    } catch (IOException ioe) {\n-                        clientException = ioe;\n-                    }\n-                }\n-\n-                isDone = true;\n-            }\n+        } finally {\n+            waitForClient.countDown();\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SocketExceptionForSocketIssues.java","additions":54,"deletions":96,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -64,107 +64,0 @@\n-    private static final String[] CA_CERTS = new String[] {\n-            \/\/ SHA256withECDSA, curve secp256r1\n-            \/\/ Validity\n-            \/\/     Not Before: May 22 07:18:16 2018 GMT\n-            \/\/     Not After : May 17 07:18:16 2038 GMT\n-            \/\/ Subject Key Identifier:\n-            \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n-            \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIIBvjCCAWOgAwIBAgIJAIvFG6GbTroCMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n-            \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n-            \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYTAlVT\\n\" +\n-            \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTBZ\\n\" +\n-            \"MBMGByqGSM49AgEGCCqGSM49AwEHA0IABBz1WeVb6gM2mh85z3QlvaB\/l11b5h0v\\n\" +\n-            \"LIzmkC3DKlVukZT+ltH2Eq1oEkpXuf7QmbM0ibrUgtjsWH3mULfmcWmjUDBOMB0G\\n\" +\n-            \"A1UdDgQWBBRgz71z\/\/oaMNKk7NNJcUbvGjWghjAfBgNVHSMEGDAWgBRgz71z\/\/oa\\n\" +\n-            \"MNKk7NNJcUbvGjWghjAMBgNVHRMEBTADAQH\/MAoGCCqGSM49BAMCA0kAMEYCIQCG\\n\" +\n-            \"6wluh1r2\/T6L31mZXRKf9JxeSf9pIzoLj+8xQeUChQIhAJ09wAi1kV8yePLh2FD9\\n\" +\n-            \"2YEHlSQUAbwwqCDEVB5KxaqP\\n\" +\n-            \"-----END CERTIFICATE-----\",\n-\n-            \/\/ SHA384withECDSA, curve secp384r1\n-            \/\/ Validity\n-            \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n-            \/\/     Not After : Jun 19 08:15:06 2039 GMT\n-            \/\/ Subject Key Identifier:\n-            \/\/     0a:93:a9:a0:bf:e7:d5:48:9d:4f:89:15:c6:51:98:80:05:51:4e:4e\n-            \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIICCDCCAY6gAwIBAgIUCpOpoL\/n1UidT4kVxlGYgAVRTk4wCgYIKoZIzj0EAwMw\\n\" +\n-            \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n-            \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowOzEL\\n\" +\n-            \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n-            \"dCBTZXJpdmNlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAENVQN1wXWFdgC6u\/dDdiC\\n\" +\n-            \"y+WtMTF66oL\/0BSm+1ZqsogamzCryawOcHgiuXgWzx5CQ3LuOC+tDFyXpGfHuCvb\\n\" +\n-            \"dkzxPrP5n9NrR8\/uRPe5l1KOUbchviU8z9cTP+LZxnZDo1MwUTAdBgNVHQ4EFgQU\\n\" +\n-            \"SktSFArR1p\/5mXV0kyo0RxIVa\/UwHwYDVR0jBBgwFoAUSktSFArR1p\/5mXV0kyo0\\n\" +\n-            \"RxIVa\/UwDwYDVR0TAQH\/BAUwAwEB\/zAKBggqhkjOPQQDAwNoADBlAjBZvoNmq3\/v\\n\" +\n-            \"RD2gBTyvxjS9h0rsMRLHDnvul\/KWngytwGPTOBo0Y8ixQXSjdKoc3rkCMQDkiNgx\\n\" +\n-            \"IDxuHedmrLQKIPnVcthTmwv7\/\/jHiqGoKofwChMo2a1P+DQdhszmeHD\/ARQ=\\n\" +\n-            \"-----END CERTIFICATE-----\"\n-    };\n-\n-    private static final String[] EE_CERTS = new String[] {\n-            \/\/ SHA256withECDSA, curve secp256r1\n-            \/\/ Validity\n-            \/\/     Not Before: May 22 07:18:16 2018 GMT\n-            \/\/     Not After : May 17 07:18:16 2038 GMT\n-            \/\/ Authority Key Identifier:\n-            \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n-            \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIIBqjCCAVCgAwIBAgIJAPLY8qZjgNRAMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n-            \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n-            \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYTAlVT\\n\" +\n-            \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTEY\\n\" +\n-            \"MBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcD\\n\" +\n-            \"QgAEb+9n05qfXnfHUb0xtQJNS4JeSi6IjOfW5NqchvKnfJey9VkJzR7QHLuOESdf\\n\" +\n-            \"xlR7q8YIWgih3iWLGfB+wxHiOqMjMCEwHwYDVR0jBBgwFoAUYM+9c\/\/6GjDSpOzT\\n\" +\n-            \"SXFG7xo1oIYwCgYIKoZIzj0EAwIDSAAwRQIgWpRegWXMheiD3qFdd8kMdrkLxRbq\\n\" +\n-            \"1zj8nQMEwFTUjjQCIQDRIrAjZX+YXHN9b0SoWWLPUq0HmiFIi8RwMnO\/\/wJIGQ==\\n\" +\n-            \"-----END CERTIFICATE-----\",\n-\n-            \/\/ SHA384withECDSA, curve secp384r1\n-            \/\/ Validity\n-            \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n-            \/\/     Not After : Jun 19 08:15:06 2039 GMT\n-            \/\/ Authority Key Identifier:\n-            \/\/     40:2D:AA:EE:66:AA:33:27:AD:9B:5D:52:9B:60:67:6A:2B:AD:52:D2\n-            \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIICEjCCAZegAwIBAgIUS3F0AqAXWRg07CnbknJzxofyBQMwCgYIKoZIzj0EAwMw\\n\" +\n-            \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n-            \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowVTEL\\n\" +\n-            \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n-            \"dCBTZXJpdmNlMRgwFgYDVQQDDA9SZWdyZXNzaW9uIFRlc3QwdjAQBgcqhkjOPQIB\\n\" +\n-            \"BgUrgQQAIgNiAARqElz8b6T07eyKomIinhztV3\/3XBk9bKGtJ0W+JOltjuhMmP\/w\\n\" +\n-            \"G8ASSevpgqgpi6EzpBZaaJxE3zNfkNnxXOZmQi2Ypd1uK0zRdbEOKg0XOcTTZwEj\\n\" +\n-            \"iLjYmt3O0pwpklijQjBAMB0GA1UdDgQWBBRALaruZqozJ62bXVKbYGdqK61S0jAf\\n\" +\n-            \"BgNVHSMEGDAWgBRKS1IUCtHWn\/mZdXSTKjRHEhVr9TAKBggqhkjOPQQDAwNpADBm\\n\" +\n-            \"AjEArVDFKf48xijN6huVUJzKCOP0zlWB5Js+DItIkZmLQuhciPLhLIB\/rChf3Y4C\\n\" +\n-            \"xuP4AjEAmfLhQRI0O3pifpYzYSVh2G7\/jHNG4eO+2dvgAcU+Lh2IIj\/cpLaPFSvL\\n\" +\n-            \"J8FXY9Nj\\n\" +\n-            \"-----END CERTIFICATE-----\"\n-    };\n-\n-    private static final String[] EE_KEYS = new String[] {\n-            \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgn5K03bpTLjEtFQRa\\n\" +\n-            \"JUtx22gtmGEvvSUSQdimhGthdtihRANCAARv72fTmp9ed8dRvTG1Ak1Lgl5KLoiM\\n\" +\n-            \"59bk2pyG8qd8l7L1WQnNHtAcu44RJ1\/GVHurxghaCKHeJYsZ8H7DEeI6\",\n-            \"MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDASuI9EtK29APXPipkc\\n\" +\n-            \"qDA+qwlewMjv\/OcjUJ77kP1Vz62oVF9iY9SRIyFIUju8wt+hZANiAARqElz8b6T0\\n\" +\n-            \"7eyKomIinhztV3\/3XBk9bKGtJ0W+JOltjuhMmP\/wG8ASSevpgqgpi6EzpBZaaJxE\\n\" +\n-            \"3zNfkNnxXOZmQi2Ypd1uK0zRdbEOKg0XOcTTZwEjiLjYmt3O0pwpklg=\"\n-    };\n-\n-    private static final String[] EE_ALGS = new String[] {\n-            \"EC\",\n-            \"EC\"\n-    };\n-\n-    private static final String[] EE_ALIASES = new String[] {\n-            \"EC-SHA256\",\n-            \"EC-SHA384\"\n-    };\n-\n-    private static final Map<Integer, String> SIG_SCHEMES_MAP = Map.of(\n-            0x0403, \"ecdsa_secp256r1_sha256\",\n-            0x0503, \"ecdsa_secp384r1_sha384\");\n-\n-    private static final int TLS_HS_CLI_HELLO = 1;\n@@ -172,1 +65,0 @@\n-    private static final int HELLO_EXT_SIG_ALGS = 13;\n@@ -181,7 +73,5 @@\n-    public KeyManager createClientKeyManager() throws Exception {\n-        return SSLContextTemplate.createKeyManager(\n-                EE_CERTS,\n-                EE_KEYS,\n-                EE_ALGS,\n-                EE_ALIASES,\n-                getServerContextParameters());\n+    @Override\n+    protected KeyManager createClientKeyManager() throws Exception {\n+        return createKeyManager(\n+                new Cert[]{Cert.EE_ECDSA_SECP256R1, Cert.EE_ECDSA_SECP384R1},\n+                getClientContextParameters());\n@@ -192,2 +82,2 @@\n-        return SSLContextTemplate.createTrustManager(\n-                CA_CERTS,\n+        return createTrustManager(\n+                new Cert[]{Cert.CA_ECDSA_SECP256R1, Cert.CA_ECDSA_SECP384R1},\n@@ -199,5 +89,2 @@\n-        return SSLContextTemplate.createKeyManager(\n-                EE_CERTS,\n-                EE_KEYS,\n-                EE_ALGS,\n-                EE_ALIASES,\n+        return createKeyManager(\n+                new Cert[]{Cert.EE_ECDSA_SECP256R1, Cert.EE_ECDSA_SECP384R1},\n@@ -209,2 +96,2 @@\n-        return SSLContextTemplate.createTrustManager(\n-                CA_CERTS,\n+        return createTrustManager(\n+                new Cert[]{Cert.CA_ECDSA_SECP256R1, Cert.CA_ECDSA_SECP384R1},\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/SigAlgosExtTestWithTLS12.java","additions":11,"deletions":124,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,0 @@\n-import java.net.*;\n-import java.io.*;\n@@ -43,5 +41,0 @@\n-import java.security.*;\n-import java.security.cert.*;\n-import java.security.spec.*;\n-import java.security.interfaces.*;\n-import java.util.Base64;\n@@ -59,2 +52,4 @@\n-    protected SSLContext createServerSSLContext() throws Exception {\n-        return generateSSLContext();\n+    public SSLContext createServerSSLContext() throws Exception {\n+        return createSSLContext(new Cert[]{Cert.CA_ECDSA_SECP256R1},\n+                new Cert[]{Cert.EE_ECDSA_SECP256R1},\n+                new ContextParameters(\"TLSv1.3\", \"PKIX\", \"NewSunX509\"));\n@@ -69,118 +64,4 @@\n-    protected SSLContext createClientSSLContext() throws Exception {\n-        return generateSSLContext();\n-    }\n-\n-    \/*\n-     * =============================================================\n-     * The remainder is just support stuff\n-     *\/\n-\n-    \/\/ Certificates and key used in the test.\n-    \/\/\n-    \/\/ Trusted Certificate.\n-    static String trustedCertStr =\n-        \/\/ SHA256withECDSA, curve prime256v1\n-        \/\/ Validity\n-        \/\/     Not Before: May 22 07:18:16 2018 GMT\n-        \/\/     Not After : May 17 07:18:16 2038 GMT\n-        \/\/ Subject Key Identifier:\n-        \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIIBvjCCAWOgAwIBAgIJAIvFG6GbTroCMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n-        \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n-        \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYTAlVT\\n\" +\n-        \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTBZ\\n\" +\n-        \"MBMGByqGSM49AgEGCCqGSM49AwEHA0IABBz1WeVb6gM2mh85z3QlvaB\/l11b5h0v\\n\" +\n-        \"LIzmkC3DKlVukZT+ltH2Eq1oEkpXuf7QmbM0ibrUgtjsWH3mULfmcWmjUDBOMB0G\\n\" +\n-        \"A1UdDgQWBBRgz71z\/\/oaMNKk7NNJcUbvGjWghjAfBgNVHSMEGDAWgBRgz71z\/\/oa\\n\" +\n-        \"MNKk7NNJcUbvGjWghjAMBgNVHRMEBTADAQH\/MAoGCCqGSM49BAMCA0kAMEYCIQCG\\n\" +\n-        \"6wluh1r2\/T6L31mZXRKf9JxeSf9pIzoLj+8xQeUChQIhAJ09wAi1kV8yePLh2FD9\\n\" +\n-        \"2YEHlSQUAbwwqCDEVB5KxaqP\\n\" +\n-        \"-----END CERTIFICATE-----\";\n-        \/\/ -----BEGIN PRIVATE KEY-----\n-        \/\/ MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQg\/HcHdoLJCdq3haVd\n-        \/\/ XZTSKP00YzM3xX97l98vGL\/RI1KhRANCAAQc9VnlW+oDNpofOc90Jb2gf5ddW+Yd\n-        \/\/ LyyM5pAtwypVbpGU\/pbR9hKtaBJKV7n+0JmzNIm61ILY7Fh95lC35nFp\n-        \/\/ -----END PRIVATE KEY-----\n-\n-    \/\/ End entity certificate.\n-    static String targetCertStr =\n-        \/\/ SHA256withECDSA, curve prime256v1\n-        \/\/ Validity\n-        \/\/     Not Before: May 22 07:18:16 2018 GMT\n-        \/\/     Not After : May 17 07:18:16 2038 GMT\n-        \/\/ Authority Key Identifier:\n-        \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIIBqjCCAVCgAwIBAgIJAPLY8qZjgNRAMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n-        \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n-        \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYTAlVT\\n\" +\n-        \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTEY\\n\" +\n-        \"MBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcD\\n\" +\n-        \"QgAEb+9n05qfXnfHUb0xtQJNS4JeSi6IjOfW5NqchvKnfJey9VkJzR7QHLuOESdf\\n\" +\n-        \"xlR7q8YIWgih3iWLGfB+wxHiOqMjMCEwHwYDVR0jBBgwFoAUYM+9c\/\/6GjDSpOzT\\n\" +\n-        \"SXFG7xo1oIYwCgYIKoZIzj0EAwIDSAAwRQIgWpRegWXMheiD3qFdd8kMdrkLxRbq\\n\" +\n-        \"1zj8nQMEwFTUjjQCIQDRIrAjZX+YXHN9b0SoWWLPUq0HmiFIi8RwMnO\/\/wJIGQ==\\n\" +\n-        \"-----END CERTIFICATE-----\";\n-\n-    \/\/ Private key in the format of PKCS#8.\n-    static String targetPrivateKey =\n-        \/\/\n-        \/\/ EC private key related to cert endEntityCertStrs[0].\n-        \/\/\n-        \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgn5K03bpTLjEtFQRa\\n\" +\n-        \"JUtx22gtmGEvvSUSQdimhGthdtihRANCAARv72fTmp9ed8dRvTG1Ak1Lgl5KLoiM\\n\" +\n-        \"59bk2pyG8qd8l7L1WQnNHtAcu44RJ1\/GVHurxghaCKHeJYsZ8H7DEeI6\";\n-\n-    static char passphrase[] = \"passphrase\".toCharArray();\n-\n-    \/\/ Create the SSLContext instance.\n-    private static SSLContext generateSSLContext() throws Exception {\n-\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        \/\/ create a key store\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        ks.load(null, null);\n-\n-        \/\/ import the trused cert\n-        X509Certificate trusedCert = null;\n-        ByteArrayInputStream is =\n-                new ByteArrayInputStream(trustedCertStr.getBytes());\n-        trusedCert = (X509Certificate)cf.generateCertificate(is);\n-        is.close();\n-\n-        ks.setCertificateEntry(\"Trusted EC Signer\", trusedCert);\n-\n-        \/\/ generate the private key.\n-        PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n-                            Base64.getMimeDecoder().decode(targetPrivateKey));\n-        KeyFactory kf = KeyFactory.getInstance(\"EC\");\n-        ECPrivateKey priKey =\n-                (ECPrivateKey)kf.generatePrivate(priKeySpec);\n-\n-        \/\/ generate certificate chain\n-        is = new ByteArrayInputStream(targetCertStr.getBytes());\n-        X509Certificate keyCert = (X509Certificate)cf.generateCertificate(is);\n-        is.close();\n-\n-        X509Certificate[] chain = new X509Certificate[2];\n-        chain[0] = keyCert;\n-        chain[1] = trusedCert;\n-\n-        \/\/ import the key entry and the chain\n-        ks.setKeyEntry(\"TheKey\", priKey, passphrase, chain);\n-\n-        \/\/ create SSL context\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n-        tmf.init(ks);\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"NewSunX509\");\n-        kmf.init(ks, passphrase);\n-\n-        SSLContext ctx = SSLContext.getInstance(\"TLSv1.3\");\n-        ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-        ks = null;\n-\n-        return ctx;\n+    public SSLContext createClientSSLContext() throws Exception {\n+        return createSSLContext(new Cert[]{Cert.CA_ECDSA_SECP256R1},\n+                new Cert[]{Cert.EE_ECDSA_SECP256R1},\n+                new ContextParameters(\"TLSv1.3\", \"PKIX\", \"NewSunX509\"));\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/Tls13NamedGroups.java","additions":9,"deletions":128,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.net.InetAddress;\n@@ -39,1 +38,1 @@\n-import java.util.Arrays;\n+import java.util.concurrent.CyclicBarrier;\n@@ -46,1 +45,1 @@\n-public class TooManyCAs implements SSLContextTemplate {\n+public class TooManyCAs extends SSLSocketTemplate {\n@@ -58,0 +57,6 @@\n+    \/*\n+     * Used to synchronize client and server; there were intermittent\n+     * failures on Windows due to the connection being killed.\n+     *\/\n+    private final CyclicBarrier barrier = new CyclicBarrier(2);\n+\n@@ -62,0 +67,6 @@\n+\n+        System.out.printf(\"Testing%n\\tclient protocols: %s%n\\t\" +\n+                \"server protocols: %s%n\\tneed client auth: %s%n\",\n+                String.join(\", \", clientProtocols),\n+                String.join(\", \", serverProtocols),\n+                needClientAuth);\n@@ -64,5 +75,4 @@\n-    \/\/ Servers are configured before clients, increment test case after.\n-    void configureClientSocket(SSLSocket clientSocket) {\n-        System.err.print(\"Setting client protocol(s): \");\n-        Arrays.stream(clientProtocols).forEachOrdered(System.err::print);\n-        System.err.println();\n+    @Override\n+    protected void configureClientSocket(SSLSocket clientSocket) {\n+        System.out.println(\"Setting client protocol(s): \"\n+                + String.join(\",\", clientProtocols));\n@@ -73,4 +83,8 @@\n-    void configureServerSocket(SSLServerSocket serverSocket) {\n-        System.err.print(\"Setting server protocol(s): \");\n-        Arrays.stream(serverProtocols).forEachOrdered(System.err::print);\n-        System.err.println();\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket serverSocket) {\n+        serverSocket.setNeedClientAuth(needClientAuth);\n+        serverSocket.setEnableSessionCreation(true);\n+        serverSocket.setUseClientMode(false);\n+\n+        System.out.println(\"Setting server protocol(s): \"\n+                + String.join(\",\", serverProtocols));\n@@ -79,3 +93,0 @@\n-        if (needClientAuth) {\n-            serverSocket.setNeedClientAuth(true);\n-        }\n@@ -85,3 +96,2 @@\n-    public TrustManager createClientTrustManager() throws Exception {\n-        TrustManager trustManager =\n-                SSLContextTemplate.super.createClientTrustManager();\n+    protected TrustManager createClientTrustManager() throws Exception {\n+        TrustManager trustManager = super.createClientTrustManager();\n@@ -93,3 +103,2 @@\n-    public TrustManager createServerTrustManager() throws Exception {\n-        TrustManager trustManager =\n-                SSLContextTemplate.super.createServerTrustManager();\n+    protected TrustManager createServerTrustManager() throws Exception {\n+        TrustManager trustManager = super.createServerTrustManager();\n@@ -110,4 +119,2 @@\n-    private void run() throws Exception {\n-        SSLServerSocket listenSocket = null;\n-        SSLSocket serverSocket = null;\n-        ClientSocket clientSocket = null;\n+    @Override\n+    protected void runServerApplication(SSLSocket socket) throws Exception {\n@@ -115,22 +122,1 @@\n-            SSLServerSocketFactory serversocketfactory =\n-                    createServerSSLContext().getServerSocketFactory();\n-            listenSocket =\n-                    (SSLServerSocket)serversocketfactory.createServerSocket(0);\n-            listenSocket.setNeedClientAuth(false);\n-            listenSocket.setEnableSessionCreation(true);\n-            listenSocket.setUseClientMode(false);\n-            configureServerSocket(listenSocket);\n-\n-            System.err.println(\"Starting client\");\n-            clientSocket = new ClientSocket(listenSocket.getLocalPort());\n-            clientSocket.start();\n-\n-            System.err.println(\"Accepting client requests\");\n-            serverSocket = (SSLSocket)listenSocket.accept();\n-\n-            if (!clientSocket.isDone) {\n-                System.err.println(\"Waiting 3 seconds for client \");\n-                Thread.sleep(3000);\n-            }\n-\n-            System.err.println(\"Sending data to client ...\");\n+            System.out.println(\"Sending data to client ...\");\n@@ -139,1 +125,1 @@\n-                    new OutputStreamWriter(serverSocket.getOutputStream()));\n+                    new OutputStreamWriter(socket.getOutputStream()));\n@@ -144,11 +130,2 @@\n-            if (listenSocket != null) {\n-                listenSocket.close();\n-            }\n-\n-            if (serverSocket != null) {\n-                serverSocket.close();\n-            }\n-        }\n-\n-        if (clientSocket != null && clientSocket.clientException != null) {\n-            throw clientSocket.clientException;\n+            barrier.await();\n+            System.out.println(\"Server done\");\n@@ -158,4 +135,5 @@\n-    private class ClientSocket extends Thread{\n-        boolean isDone = false;\n-        int serverPort = 0;\n-        Exception clientException;\n+    @Override\n+    protected void runClientApplication(SSLSocket socket) throws Exception {\n+        try {\n+            String clientData = \"Hi, I am client\";\n+            System.out.println(\"Sending data to server ...\");\n@@ -163,3 +141,5 @@\n-        public ClientSocket(int serverPort) {\n-            this.serverPort = serverPort;\n-        }\n+            BufferedWriter os = new BufferedWriter(\n+                    new OutputStreamWriter(socket.getOutputStream()));\n+            os.write(clientData, 0, clientData.length());\n+            os.newLine();\n+            os.flush();\n@@ -167,41 +147,8 @@\n-        @Override\n-        public void run() {\n-            SSLSocket clientSocket = null;\n-            String clientData = \"Hi, I am client\";\n-            try {\n-                System.err.println(\n-                        \"Connecting to server at port \" + serverPort);\n-                SSLSocketFactory sslSocketFactory =\n-                        createClientSSLContext().getSocketFactory();\n-                clientSocket = (SSLSocket)sslSocketFactory.createSocket(\n-                        InetAddress.getLocalHost(), serverPort);\n-                configureClientSocket(clientSocket);\n-\n-                System.err.println(\"Sending data to server ...\");\n-\n-                BufferedWriter os = new BufferedWriter(\n-                        new OutputStreamWriter(clientSocket.getOutputStream()));\n-                os.write(clientData, 0, clientData.length());\n-                os.newLine();\n-                os.flush();\n-\n-                System.err.println(\"Reading data from server\");\n-                BufferedReader is = new BufferedReader(\n-                        new InputStreamReader(clientSocket.getInputStream()));\n-                String data = is.readLine();\n-                System.err.println(\"Received Data from server: \" + data);\n-            } catch (Exception e) {\n-                clientException = e;\n-                System.err.println(\"unexpected client exception: \" + e);\n-            } finally {\n-                if (clientSocket != null) {\n-                    try {\n-                        clientSocket.close();\n-                        System.err.println(\"client socket closed\");\n-                    } catch (IOException ioe) {\n-                        clientException = ioe;\n-                    }\n-                }\n-\n-                isDone = true;\n-            }\n+            System.out.println(\"Reading data from server\");\n+            BufferedReader is = new BufferedReader(\n+                    new InputStreamReader(socket.getInputStream()));\n+            String data = is.readLine();\n+            System.out.println(\"Received Data from server: \" + data);\n+        } finally {\n+            barrier.await();\n+            System.out.println(\"client done.\");\n@@ -276,1 +223,1 @@\n-                    i * trustedCerts.length + 0, trustedCerts.length);\n+                    i * trustedCerts.length, trustedCerts.length);\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/TooManyCAs.java","additions":56,"deletions":109,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,0 @@\n-import com.sun.jarsigner.ContentSigner;\n-import com.sun.jarsigner.ContentSignerParameters;\n@@ -55,13 +53,0 @@\n-        \/\/ Help\n-        boolean lastLineHasAltSigner = false;\n-        for (String line : SecurityTools.jarsigner(\"--help\").asLines()) {\n-            if (line.contains(\"-altsigner\")) {\n-                lastLineHasAltSigner = true;\n-            } else {\n-                if (lastLineHasAltSigner) {\n-                    Asserts.assertTrue(line.contains(\"deprecated and will be removed\"));\n-                }\n-                lastLineHasAltSigner = false;\n-            }\n-        }\n-\n@@ -80,32 +65,0 @@\n-        \/\/ -altsign\n-        SecurityTools.jarsigner(\n-                \"-debug -signedjar altsign.jar -keystore jks -storepass changeit\" +\n-                        \" -altsigner Options$X\" +\n-                        \" -altsignerpath \" + System.getProperty(\"test.classes\") +\n-                        \" a.jar a\")\n-                .shouldContain(\"removed in a future release: -altsigner\")\n-                .shouldContain(\"removed in a future release: -altsignerpath\")\n-                .shouldContain(\"PKCS7.parse\");  \/\/ signature not parseable\n-                                                \/\/ but signing succeeds\n-\n-        try (JarFile jf = new JarFile(\"altsign.jar\")) {\n-            JarEntry je = jf.getJarEntry(\"META-INF\/A.RSA\");\n-            try (InputStream is = jf.getInputStream(je)) {\n-                if (!Arrays.equals(is.readAllBytes(), \"1234\".getBytes())) {\n-                    throw new Exception(\"altsign go wrong\");\n-                }\n-            }\n-        }\n-\n-        \/\/ -altsign with no -altsignerpath\n-        Files.copy(Path.of(System.getProperty(\"test.classes\"), \"Options$X.class\"),\n-                Path.of(\"Options$X.class\"));\n-        SecurityTools.jarsigner(\n-                \"-debug -signedjar altsign.jar -keystore jks -storepass changeit\" +\n-                        \" -altsigner Options$X\" +\n-                        \" a.jar a\")\n-                .shouldContain(\"removed in a future release: -altsigner\")\n-                .shouldNotContain(\"removed in a future release: -altsignerpath\")\n-                .shouldContain(\"PKCS7.parse\");  \/\/ signature not parseable\n-                                                \/\/ but signing succeeds\n-\n@@ -158,8 +111,0 @@\n-\n-    public static class X extends ContentSigner {\n-        @Override\n-        public byte[] generateSignedData(ContentSignerParameters parameters,\n-                boolean omitContent, boolean applyTimestamp) {\n-            return \"1234\".getBytes();\n-        }\n-    }\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/Options.java","additions":1,"deletions":56,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.stream.Stream;\n@@ -86,2 +87,4 @@\n-        TKit.assertEquals(expectedEnvVarValue, actualEnvVarValue, String.format(\n-                \"Check value of %s env variable\", envVarName));\n+        TKit.assertTextStream(expectedEnvVarValue)\n+            .predicate(TKit.isLinux() ? String::endsWith : String::equals)\n+            .label(String.format(\"value of %s env variable\", envVarName))\n+            .apply(Stream.of(actualEnvVarValue));\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppLauncherEnvTest.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n- * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/jdk\/jpackage\/tests\/MainClassTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-             8186332 8186703 8182765 8187288 8261976\n+             8186332 8186703 8182765 8187288 8261976 8303349\n@@ -147,0 +147,10 @@\n+                \"\"\"\n+                    <section class=\"detail\" id=\"staticMethod()\">\n+                    <h3>staticMethod<\/h3>\n+                    <div class=\"member-signature\"><span class=\"modifiers\">public static<\/span>&nbsp;\\\n+                    <span class=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">staticMethod<\/span\\\n+                    >()<\/div>\n+                    \"\"\"\n+        );\n+\n+        checkOutput(\"pkg\/ClassWithStaticMembers.html\", false,\n@@ -220,1 +230,2 @@\n-                 class=\"type-name-link\" title=\"interface in pkg2\">Spliterator.OfDouble<\/a><\/code><\/div>\n+                 class=\"type-name-link\" title=\"interface in pkg2\">Spliterator.OfDouble<\/a><\/code\\\n+                ><\/div>\n@@ -250,3 +261,4 @@\n-                 href=\"pkg2\/Spliterator.html\" title=\"interface in pkg2\">Spliterator<\/a>&lt;<a hr\\\n-                ef=\"pkg2\/Spliterator.html\" title=\"type parameter in Spliterator\">T<\/a>&gt;<\/div>\n-                <div class=\"col-last odd-row-color all-classes-table all-classes-table-tab1\">&nbsp;<\/div>\n+                 href=\"pkg2\/Spliterator.html\" title=\"interface in pkg2\">Spliterator&lt;T&gt;<\/a>\\\n+                <\/div>\n+                <div class=\"col-last odd-row-color all-classes-table all-classes-table-tab1\">&nb\\\n+                sp;<\/div>\n@@ -256,1 +268,2 @@\n-                <div class=\"col-last even-row-color all-classes-table all-classes-table-tab1\">&nbsp;<\/div>\n+                <div class=\"col-last even-row-color all-classes-table all-classes-table-tab1\">&n\\\n+                bsp;<\/div>\n@@ -258,4 +271,4 @@\n-                 href=\"pkg2\/Spliterator.OfInt.html\" title=\"interface in pkg2\">Spliterator.OfInt<\\\n-                \/a>&lt;<a href=\"pkg2\/Spliterator.OfInt.html\" title=\"type parameter in Spliterato\\\n-                r.OfInt\">Integer<\/a>&gt;<\/div>\n-                <div class=\"col-last odd-row-color all-classes-table all-classes-table-tab1\">&nbsp;<\/div>\n+                 href=\"pkg2\/Spliterator.OfInt.html\" title=\"interface in pkg2\">Spliterator.OfInt&\\\n+                lt;Integer&gt;<\/a><\/div>\n+                <div class=\"col-last odd-row-color all-classes-table all-classes-table-tab1\">&nb\\\n+                sp;<\/div>\n@@ -264,11 +277,3 @@\n-                .OfPrimitive<\/a>&lt;<a href=\"pkg2\/Spliterator.OfPrimitive.html\" title=\"type para\\\n-                meter in Spliterator.OfPrimitive\">T<\/a>,<wbr><a href=\"pkg2\/Spliterator.OfPrimiti\\\n-                ve.html\" title=\"type parameter in Spliterator.OfPrimitive\">T_CONS<\/a>,<wbr><a hr\\\n-                ef=\"pkg2\/Spliterator.OfPrimitive.html\" title=\"type parameter in Spliterator.OfPr\\\n-                imitive\">T_SPLITR<\/a> extends <a href=\"pkg2\/Spliterator.OfPrimitive.html\" title=\\\n-                \"interface in pkg2\">Spliterator.OfPrimitive<\/a>&lt;<a href=\"pkg2\/Spliterator.OfP\\\n-                rimitive.html\" title=\"type parameter in Spliterator.OfPrimitive\">T<\/a>,<wbr><a h\\\n-                ref=\"pkg2\/Spliterator.OfPrimitive.html\" title=\"type parameter in Spliterator.OfP\\\n-                rimitive\">T_CONS<\/a>,<wbr><a href=\"pkg2\/Spliterator.OfPrimitive.html\" title=\"typ\\\n-                e parameter in Spliterator.OfPrimitive\">T_SPLITR<\/a>&gt;&gt;<\/div>\n-                <div class=\"col-last even-row-color all-classes-table all-classes-table-tab1\">&nbsp;<\/div>\"\"\");\n+                .OfPrimitive&lt;T,<wbr>T_CONS,<wbr>T_SPLITR&gt;<\/a><\/div>\n+                <div class=\"col-last even-row-color all-classes-table all-classes-table-tab1\">&n\\\n+                bsp;<\/div>\"\"\");\n@@ -278,2 +283,2 @@\n-                kg2\">Spliterator<\/a>&lt;<a href=\"pkg2\/Spliterator.html\" title=\"type parameter in\\\n-                 Spliterator\">T<\/a>&gt; - Interface in <a href=\"pkg2\/package-summary.html\">pkg2<\/a><\/dt>\n+                kg2\">Spliterator&lt;T&gt;<\/a> - Interface in <a href=\"pkg2\/package-summary.html\"\\\n+                >pkg2<\/a><\/dt>\n@@ -286,3 +291,2 @@\n-                e in pkg2\">Spliterator.OfInt<\/a>&lt;<a href=\"pkg2\/Spliterator.OfInt.html\" title=\\\n-                \"type parameter in Spliterator.OfInt\">Integer<\/a>&gt; - Interface in <a href=\"pk\\\n-                g2\/package-summary.html\">pkg2<\/a><\/dt>\n+                e in pkg2\">Spliterator.OfInt&lt;Integer&gt;<\/a> - Interface in <a href=\"pkg2\/pac\\\n+                kage-summary.html\">pkg2<\/a><\/dt>\n@@ -291,11 +295,2 @@\n-                terface in pkg2\">Spliterator.OfPrimitive<\/a>&lt;<a href=\"pkg2\/Spliterator.OfPrim\\\n-                itive.html\" title=\"type parameter in Spliterator.OfPrimitive\">T<\/a>,<wbr><a href\\\n-                =\"pkg2\/Spliterator.OfPrimitive.html\" title=\"type parameter in Spliterator.OfPrim\\\n-                itive\">T_CONS<\/a>,<wbr><a href=\"pkg2\/Spliterator.OfPrimitive.html\" title=\"type p\\\n-                arameter in Spliterator.OfPrimitive\">T_SPLITR<\/a> extends <a href=\"pkg2\/Splitera\\\n-                tor.OfPrimitive.html\" title=\"interface in pkg2\">Spliterator.OfPrimitive<\/a>&lt;<\\\n-                a href=\"pkg2\/Spliterator.OfPrimitive.html\" title=\"type parameter in Spliterator.\\\n-                OfPrimitive\">T<\/a>,<wbr><a href=\"pkg2\/Spliterator.OfPrimitive.html\" title=\"type \\\n-                parameter in Spliterator.OfPrimitive\">T_CONS<\/a>,<wbr><a href=\"pkg2\/Spliterator.\\\n-                OfPrimitive.html\" title=\"type parameter in Spliterator.OfPrimitive\">T_SPLITR<\/a>\\\n-                &gt;&gt; - Interface in <a href=\"pkg2\/package-summary.html\">pkg2<\/a><\/dt>\n+                terface in pkg2\">Spliterator.OfPrimitive&lt;T,<wbr>T_CONS,<wbr>T_SPLITR&gt;<\/a> \\\n+                - Interface in <a href=\"pkg2\/package-summary.html\">pkg2<\/a><\/dt>\n@@ -304,0 +299,55 @@\n+\n+    @Test\n+    public void test3() {\n+        javadoc(\"-d\", \"out-3\",\n+                \"--no-platform-links\", \/\/ disable links to simplify output matching\n+                \"-sourcepath\", testSrc,\n+                \"pkg3\");\n+\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"pkg3\/I.html\", true,\n+                \"\"\"\n+                <li>\n+                <section class=\"detail\" id=\"hashCode()\">\n+                <h3>hashCode<\/h3>\n+                <div class=\"member-signature\"><span class=\"return-type\">\\\n+                int<\/span>&nbsp;<span class=\"element-name\">hashCode<\/span>()<\/div>\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code>hashCode<\/code>&nbsp;in class&nbsp;<code>java.lang.Object<\/code><\/dd>\n+                <\/dl>\n+                <\/section>\n+                <\/li>\n+                <li>\n+                <section class=\"detail\" id=\"equals(java.lang.Object)\">\n+                <h3>equals<\/h3>\n+                <div class=\"member-signature\"><span class=\"return-type\">\\\n+                boolean<\/span>&nbsp;<span class=\"element-name\">equals<\/span>\\\n+                <wbr><span class=\"parameters\">(java.lang.Object&nbsp;obj)<\/span><\/div>\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code>equals<\/code>&nbsp;in class&nbsp;<code>java.lang.Object<\/code><\/dd>\n+                <\/dl>\n+                <\/section>\n+                <\/li>\n+                <li>\n+                <section class=\"detail\" id=\"toString()\">\n+                <h3>toString<\/h3>\n+                <div class=\"member-signature\"><span class=\"return-type\">\\\n+                java.lang.String<\/span>&nbsp;<span class=\"element-name\">toString<\/span>()<\/div>\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code>toString<\/code>&nbsp;in class&nbsp;<code>java.lang.Object<\/code><\/dd>\n+                <\/dl>\n+                <\/section>\n+                <\/li>\n+                <li>\n+                <section class=\"detail\" id=\"clone()\">\n+                <h3>clone<\/h3>\n+                <div class=\"member-signature\"><span class=\"return-type\">\\\n+                java.lang.Object<\/span>&nbsp;<span class=\"element-name\">clone<\/span>()<\/div>\n+                <\/section>\n+                <\/li>\n+                \"\"\");\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/TestInterface.java","additions":87,"deletions":37,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg3;\n+\n+public interface I {\n+\n+    int hashCode();\n+\n+    boolean equals(Object obj);\n+\n+    String toString();\n+\n+    \/\/ No matter what your IDE might show you, from JLS 9.6.4.4 it follows that\n+    \/\/ the \"clone\" (as well as currently deprecated \"finalize\") method cannot\n+    \/\/ be overridden by an interface method in the same way \"hashCode\", \"equals\"\n+    \/\/ and \"toString\" can. This is because \"clone\" is not public.\n+    Object clone();\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/pkg3\/I.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,10 +52,2 @@\n-        checkExit(Exit.OK);\n-\n-        checkOutput(\"pkg4\/Foo.html\", true,\n-                \"\"\"\n-                    <section class=\"detail\" id=\"toString()\">\n-                    <h3>toString<\/h3>\n-                    <div class=\"member-signature\"><span class=\"modifiers\">public<\/span>&nbsp;<span c\\\n-                    lass=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">toString<\/span>()<\/div>\n-                    <div class=\"block\">Why can't I do this ?<\/div>\n-                    <\/section>\"\"\");\n+        \/\/ explicitly configure \"no crash\" check, which is the main interest of this test\n+        setAutomaticCheckNoStacktrace(true);\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/TestBadOverride.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4318787\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestSpecifiedBy\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestSpecifiedBy extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        new TestSpecifiedBy().runTests();\n+    }\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void test(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package pkg;\n+\n+                public abstract class A {\n+                    public abstract void m();\n+                }\n+                \"\"\", \"\"\"\n+                package pkg;\n+\n+                public class B extends A {\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package pkg;\n+\n+                public abstract class C extends A {\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package pkg;\n+\n+                public abstract class D extends A {\n+                    public abstract void m();\n+                }\n+                \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+\n+        checkExit(Exit.OK);\n+        \/\/ check that the terminology for an overridden abstract method of an\n+        \/\/ abstract class is the same as that of an overridden interface method;\n+        \/\/ no matter who the overrider is, the overridden method should be\n+        \/\/ listed under \"Specified by\", not \"Overrides\"\n+        for (var f : List.of(\"pkg\/B.html\", \"pkg\/C.html\", \"pkg\/D.html\"))\n+            checkOutput(f, true,\n+                    \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>Specified by:<\/dt>\n+                    <dd><code><a href=\"A.html#m()\">m<\/a><\/code>&nbsp;in class&nbsp;\\\n+                    <code><a href=\"A.html\" title=\"class in pkg\">A<\/a><\/code><\/dd>\n+                    <\/dl>\n+                    \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/TestSpecifiedBy.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary test --ignore-errors works correctly\n+ * @summary test --ignore-source-errors works correctly\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/IgnoreSourceErrors.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8303882\n+ * @summary Verify that Iterators method work as expected\n+ * @modules jdk.compiler\/com.sun.tools.javac.util\n+ * @run junit IteratorsTest\n+ *\/\n+\n+import com.sun.tools.javac.util.Iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+import org.junit.jupiter.api.*;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+\n+public class IteratorsTest {\n+\n+    @Test\n+    public void consistentNext() {\n+        Iterator<?> emptyCompoundIterator = Iterators.createCompoundIterator(List.of(), Function.identity());\n+        Assertions.assertThrows(NoSuchElementException.class, emptyCompoundIterator::next);\n+        Assertions.assertThrows(NoSuchElementException.class, emptyCompoundIterator::next);\n+    }\n+\n+    \/\/ different ways of obtaining an empty iterator are used to make sure\n+    \/\/ the compound iterator doesn't depend on (checking) the identity of\n+    \/\/ any one of them\n+    @Test\n+    public void intermediateEmptyIterators() {\n+        List<Iterator<String>> inputs = List.of(\n+                Collections.<String>emptyList().iterator(),\n+                Collections.emptyListIterator(),\n+                Collections.emptyIterator(),\n+                List.of(\"1\").iterator(),\n+                List.of(\"2\", \"3\").iterator(),\n+                List.<String>of().iterator(),\n+                Collections.<String>emptySet().iterator(),\n+                List.of(\"4\", \"5\").iterator(),\n+                com.sun.tools.javac.util.List.<String>nil().iterator());\n+        Iterator<String> emptyCompoundIterator = Iterators.createCompoundIterator(inputs, Function.identity());\n+        var actual = new ArrayList<String>();\n+        emptyCompoundIterator.forEachRemaining(actual::add);\n+        assertEquals(List.of(\"1\", \"2\", \"3\", \"4\", \"5\"), actual);\n+    }\n+\n+    @Test\n+    public void recursiveEmpty() {\n+        Iterable<Iterator<Object>> inner = () -> Iterators.createCompoundIterator(List.of(), i -> Collections.emptyIterator());\n+        Iterator<Object> outer = Iterators.createCompoundIterator(inner, Function.identity());\n+        assertFalse(outer.hasNext());\n+    }\n+\n+    @Test\n+    public void compoundIterator() {\n+        TestConverter<String> c = new TestConverter<>(it -> it);\n+        TestIterator<String> test1 = new TestIterator<>(List.of(\"1\").iterator());\n+        TestIterator<String> test2 = new TestIterator<>(List.of(\"2\").iterator());\n+        Iterator<String> compound = Iterators.createCompoundIterator(List.of(test1, test2), c);\n+\n+        \/\/nothing should be called before the hasNext or next is called:\n+        assertAndResetMaxCalls(c, 0);\n+        assertAndResetMaxCalls(test1, 0, 0);\n+        assertAndResetMaxCalls(test2, 0, 0);\n+\n+        \/\/when hasNext is called, should invoke the hasNext delegate once:\n+        Assertions.assertTrue(compound.hasNext());\n+\n+        assertAndResetMaxCalls(c, 1);\n+        assertAndResetMaxCalls(test1, 1, 0);\n+        assertAndResetMaxCalls(test2, 0, 0);\n+\n+        Assertions.assertTrue(compound.hasNext());\n+\n+        assertAndResetMaxCalls(c, 0);\n+        assertAndResetMaxCalls(test1, 1, 0);\n+        assertAndResetMaxCalls(test2, 0, 0);\n+\n+        \/\/next may invoke hasNext once:\n+        Assertions.assertEquals(\"1\", compound.next());\n+\n+        assertAndResetMaxCalls(c, 0);\n+        assertAndResetMaxCalls(test1, 1, 1);\n+        assertAndResetMaxCalls(test2, 0, 0);\n+\n+        Assertions.assertTrue(compound.hasNext());\n+\n+        assertAndResetMaxCalls(c, 1);\n+        assertAndResetMaxCalls(test1, 1, 0);\n+        assertAndResetMaxCalls(test2, 1, 0);\n+\n+        Assertions.assertTrue(compound.hasNext());\n+\n+        assertAndResetMaxCalls(c, 0);\n+        assertAndResetMaxCalls(test1, 0, 0);\n+        assertAndResetMaxCalls(test2, 1, 0);\n+\n+        Assertions.assertEquals(\"2\", compound.next());\n+\n+        assertAndResetMaxCalls(c, 0);\n+        assertAndResetMaxCalls(test1, 0, 0);\n+        assertAndResetMaxCalls(test2, 1, 1);\n+\n+        Assertions.assertFalse(compound.hasNext());\n+\n+        assertAndResetMaxCalls(c, 0);\n+        assertAndResetMaxCalls(test1, 0, 0);\n+        assertAndResetMaxCalls(test2, 1, 0);\n+    }\n+\n+    private void assertAndResetMaxCalls(TestIterator<?> test, int maxExpectedHasNextCalls, int maxExpectedNextCalls) {\n+        if (test.hasNextCalls > maxExpectedHasNextCalls) {\n+            Assertions.fail(\"too many hasNext invocations: \" + test.hasNextCalls +\n+                            \", expected: \" + maxExpectedHasNextCalls);\n+        }\n+        test.hasNextCalls = 0;\n+        if (test.nextCalls > maxExpectedNextCalls) {\n+            Assertions.fail(\"too many next invocations: \" + test.nextCalls +\n+                            \", expected: \" + maxExpectedNextCalls);\n+        }\n+        test.nextCalls = 0;\n+    }\n+\n+    private void assertAndResetMaxCalls(TestConverter<?> test, int maxExpectedApplyCalls) {\n+        if (test.applyCalls > maxExpectedApplyCalls) {\n+            Assertions.fail(\"too many apply invocations: \" + test.applyCalls +\n+                            \", expected: \" + maxExpectedApplyCalls);\n+        }\n+        test.applyCalls = 0;\n+    }\n+\n+    static class TestIterator<T> implements Iterator<T> {\n+        int hasNextCalls;\n+        int nextCalls;\n+        final Iterator<T> delegate;\n+\n+        public TestIterator(Iterator<T> delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            hasNextCalls++;\n+            return delegate.hasNext();\n+        }\n+\n+        @Override\n+        public T next() {\n+            nextCalls++;\n+            return delegate.next();\n+        }\n+    }\n+\n+    static class TestConverter<T> implements Function<TestIterator<T>, Iterator<T>> {\n+        int applyCalls;\n+        final Function<TestIterator<T>, Iterator<T>> delegate;\n+\n+        public TestConverter(Function<TestIterator<T>, Iterator<T>> delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public Iterator<T> apply(TestIterator<T> t) {\n+            applyCalls++;\n+            return delegate.apply(t);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/util\/IteratorsTest.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-                    \"cet_ss\",       \"avx512_ifma\"\n+                    \"cet_ss\",       \"avx512_ifma\",      \"serialize\"\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/CPUInfoTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        \"UseSharedSpaces: Unable to allocate region, range is not within java heap.\";\n+        \"Unable to allocate region, range is not within java heap.\";\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -306,1 +306,1 @@\n-                        var skipped = in.skip(len);\n+                        var skipped = (int) in.skip(len);\n","filename":"test\/lib\/jdk\/test\/lib\/hexdump\/ASN1Formatter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,1 +67,3 @@\n-        return LINKER.upcallStub(BLANK, BLANK_DESC, Arena.ofAuto());\n+        try (Arena arena = Arena.openConfined()) {\n+            return LINKER.upcallStub(BLANK, BLANK_DESC, arena.scope());\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LinkUpcall.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class LShiftNodeIdealize {\n+    private static final int SIZE = 3000;\n+\n+    @Benchmark\n+    public void testShiftInt(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume((i >> 4) << 8);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testShiftInt2(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume((i >> 8) << 4);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testShiftAndInt(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(((i >> 4) & 0x01) << 8);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testShiftLong(Blackhole blackhole) {\n+        for (long i = 0; i < SIZE; i++) {\n+            blackhole.consume((i >> 4L) << 8L);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testShiftLong2(Blackhole blackhole) {\n+        for (long i = 0; i < SIZE; i++) {\n+            blackhole.consume((i >> 8L) << 4L);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testShiftAndLong(Blackhole blackhole) {\n+        for (long i = 0; i < SIZE; i++) {\n+            blackhole.consume(((i >> 4L) & 0x01L) << 8L);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRgbaToAbgr(Blackhole blackhole, BenchState state) {\n+        for (int i = 0; i < 64; i++) {\n+            blackhole.consume(rgbaToAbgr(state.ints[i]));\n+        }\n+    }\n+\n+    private static int rgbaToAbgr(int i) {\n+        int r = i & 0xFF;\n+        int g = (i & 0xFF00) >> 8;\n+        int b = (i & 0xFF0000) >> 16;\n+        int a = (i & 0xFF000000) >> 24;\n+\n+        return (r << 24) | (g << 16) | (b << 8) | a;\n+    }\n+\n+    @State(Scope.Benchmark)\n+    public static class BenchState {\n+        int[] ints;\n+\n+        public BenchState() {\n+\n+        }\n+\n+        @Setup\n+        public void setup() {\n+            Random random = new Random(1000);\n+            ints = new int[64];\n+            for (int i = 0; i < 64; i++) {\n+                ints[i] = random.nextInt();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/LShiftNodeIdealize.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"}]}