{"files":[{"patch":"@@ -50,0 +50,1 @@\n+  bool _needs_transition;\n@@ -63,1 +64,2 @@\n-                         int captured_state_mask)\n+                         int captured_state_mask,\n+                         bool needs_transition)\n@@ -73,0 +75,1 @@\n+     _needs_transition(needs_transition),\n@@ -103,0 +106,1 @@\n+<<<<<<< HEAD\n@@ -107,0 +111,6 @@\n+=======\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n+  int locs_size = 64;\n+  CodeBuffer code(\"nep_invoker_blob\", native_invoker_code_size, locs_size);\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n@@ -109,1 +119,2 @@\n-                          needs_return_buffer, captured_state_mask);\n+                          needs_return_buffer, captured_state_mask,\n+                          needs_transition);\n@@ -166,1 +177,1 @@\n-  bool should_save_return_value = !_needs_return_buffer;\n+  bool should_save_return_value = !_needs_return_buffer && _needs_transition;\n@@ -194,1 +205,1 @@\n-  _oop_maps  = new OopMapSet();\n+  _oop_maps  = _needs_transition ? new OopMapSet() : nullptr;\n@@ -204,4 +215,5 @@\n-  address the_pc = __ pc();\n-  __ set_last_Java_frame(sp, rfp, the_pc, tmp1);\n-  OopMap* map = new OopMap(_frame_size_slots, 0);\n-  _oop_maps->add_gc_map(the_pc - start, map);\n+  if (_needs_transition) {\n+    address the_pc = __ pc();\n+    __ set_last_Java_frame(sp, rfp, the_pc, tmp1);\n+    OopMap* map = new OopMap(_frame_size_slots, 0);\n+    _oop_maps->add_gc_map(the_pc - start, map);\n@@ -209,4 +221,5 @@\n-  \/\/ State transition\n-  __ mov(tmp1, _thread_in_native);\n-  __ lea(tmp2, Address(rthread, JavaThread::thread_state_offset()));\n-  __ stlrw(tmp1, tmp2);\n+    \/\/ State transition\n+    __ mov(tmp1, _thread_in_native);\n+    __ lea(tmp2, Address(rthread, JavaThread::thread_state_offset()));\n+    __ stlrw(tmp1, tmp2);\n+  }\n@@ -260,11 +273,0 @@\n-  __ mov(tmp1, _thread_in_native_trans);\n-  __ strw(tmp1, Address(rthread, JavaThread::thread_state_offset()));\n-\n-  \/\/ Force this write out before the read below\n-  if (!UseSystemMemoryBarrier) {\n-    __ membar(Assembler::LoadLoad | Assembler::LoadStore |\n-              Assembler::StoreLoad | Assembler::StoreStore);\n-  }\n-\n-  __ verify_sve_vector_length(tmp1);\n-\n@@ -273,0 +275,11 @@\n+  Label L_reguard;\n+  Label L_after_reguard;\n+  if (_needs_transition) {\n+    __ mov(tmp1, _thread_in_native_trans);\n+    __ strw(tmp1, Address(rthread, JavaThread::thread_state_offset()));\n+\n+    \/\/ Force this write out before the read below\n+    if (!UseSystemMemoryBarrier) {\n+      __ membar(Assembler::LoadLoad | Assembler::LoadStore |\n+                Assembler::StoreLoad | Assembler::StoreStore);\n+    }\n@@ -274,1 +287,1 @@\n-  __ safepoint_poll(L_safepoint_poll_slow_path, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/, tmp1);\n+    __ verify_sve_vector_length(tmp1);\n@@ -276,2 +289,1 @@\n-  __ ldrw(tmp1, Address(rthread, JavaThread::suspend_flags_offset()));\n-  __ cbnzw(tmp1, L_safepoint_poll_slow_path);\n+    __ safepoint_poll(L_safepoint_poll_slow_path, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/, tmp1);\n@@ -279,1 +291,2 @@\n-  __ bind(L_after_safepoint_poll);\n+    __ ldrw(tmp1, Address(rthread, JavaThread::suspend_flags_offset()));\n+    __ cbnzw(tmp1, L_safepoint_poll_slow_path);\n@@ -281,4 +294,1 @@\n-  \/\/ change thread state\n-  __ mov(tmp1, _thread_in_Java);\n-  __ lea(tmp2, Address(rthread, JavaThread::thread_state_offset()));\n-  __ stlrw(tmp1, tmp2);\n+    __ bind(L_after_safepoint_poll);\n@@ -286,7 +296,10 @@\n-  __ block_comment(\"reguard stack check\");\n-  Label L_reguard;\n-  Label L_after_reguard;\n-  __ ldrb(tmp1, Address(rthread, JavaThread::stack_guard_state_offset()));\n-  __ cmpw(tmp1, StackOverflow::stack_guard_yellow_reserved_disabled);\n-  __ br(Assembler::EQ, L_reguard);\n-  __ bind(L_after_reguard);\n+    \/\/ change thread state\n+    __ mov(tmp1, _thread_in_Java);\n+    __ lea(tmp2, Address(rthread, JavaThread::thread_state_offset()));\n+    __ stlrw(tmp1, tmp2);\n+\n+    __ block_comment(\"reguard stack check\");\n+    __ ldrb(tmp1, Address(rthread, JavaThread::stack_guard_state_offset()));\n+    __ cmpw(tmp1, StackOverflow::stack_guard_yellow_reserved_disabled);\n+    __ br(Assembler::EQ, L_reguard);\n+    __ bind(L_after_reguard);\n@@ -294,1 +307,2 @@\n-  __ reset_last_Java_frame(true);\n+    __ reset_last_Java_frame(true);\n+  }\n@@ -301,2 +315,3 @@\n-  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n-  __ bind(L_safepoint_poll_slow_path);\n+  if (_needs_transition) {\n+    __ block_comment(\"{ L_safepoint_poll_slow_path\");\n+    __ bind(L_safepoint_poll_slow_path);\n@@ -304,4 +319,4 @@\n-  if (should_save_return_value) {\n-    \/\/ Need to save the native result registers around any runtime calls.\n-    out_reg_spiller.generate_spill(_masm, spill_offset);\n-  }\n+    if (should_save_return_value) {\n+      \/\/ Need to save the native result registers around any runtime calls.\n+      out_reg_spiller.generate_spill(_masm, spill_offset);\n+    }\n@@ -309,4 +324,4 @@\n-  __ mov(c_rarg0, rthread);\n-  assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n-  __ lea(tmp1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n-  __ blr(tmp1);\n+    __ mov(c_rarg0, rthread);\n+    assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n+    __ lea(tmp1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n+    __ blr(tmp1);\n@@ -314,3 +329,3 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_fill(_masm, spill_offset);\n-  }\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_offset);\n+    }\n@@ -318,2 +333,2 @@\n-  __ b(L_after_safepoint_poll);\n-  __ block_comment(\"} L_safepoint_poll_slow_path\");\n+    __ b(L_after_safepoint_poll);\n+    __ block_comment(\"} L_safepoint_poll_slow_path\");\n@@ -323,2 +338,2 @@\n-  __ block_comment(\"{ L_reguard\");\n-  __ bind(L_reguard);\n+    __ block_comment(\"{ L_reguard\");\n+    __ bind(L_reguard);\n@@ -326,3 +341,3 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_spill(_masm, spill_offset);\n-  }\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_offset);\n+    }\n@@ -330,1 +345,1 @@\n-  __ rt_call(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages), tmp1);\n+    __ rt_call(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages), tmp1);\n@@ -332,3 +347,3 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_fill(_masm, spill_offset);\n-  }\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_offset);\n+    }\n@@ -336,1 +351,1 @@\n-  __ b(L_after_reguard);\n+    __ b(L_after_reguard);\n@@ -338,1 +353,2 @@\n-  __ block_comment(\"} L_reguard\");\n+    __ block_comment(\"} L_reguard\");\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":81,"deletions":65,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+<<<<<<< HEAD\n@@ -108,0 +109,6 @@\n+=======\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n+  int locs_size = 64;\n+  CodeBuffer code(\"nep_invoker_blob\", native_invoker_code_size, locs_size);\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n","filename":"src\/hotspot\/cpu\/riscv\/downcallLinker_riscv.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  bool _needs_transition;\n@@ -62,1 +63,2 @@\n-                         int captured_state_mask)\n+                         int captured_state_mask,\n+                         bool needs_transition)\n@@ -72,0 +74,1 @@\n+     _needs_transition(needs_transition),\n@@ -102,0 +105,1 @@\n+<<<<<<< HEAD\n@@ -106,0 +110,6 @@\n+=======\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n+  int locs_size = 64;\n+  CodeBuffer code(\"nep_invoker_blob\", native_invoker_code_size, locs_size);\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n@@ -108,1 +118,2 @@\n-                          needs_return_buffer, captured_state_mask);\n+                          needs_return_buffer, captured_state_mask,\n+                          needs_transition);\n@@ -164,1 +175,1 @@\n-  bool should_save_return_value = !_needs_return_buffer;\n+  bool should_save_return_value = !_needs_return_buffer && _needs_transition;\n@@ -193,1 +204,1 @@\n-  _oop_maps  = new OopMapSet();\n+  _oop_maps  = _needs_transition ? new OopMapSet() : nullptr;\n@@ -203,1 +214,6 @@\n-  address the_pc = __ pc();\n+  if (_needs_transition) {\n+    __ block_comment(\"{ thread java2native\");\n+    address the_pc = __ pc();\n+    __ set_last_Java_frame(rsp, rbp, (address)the_pc, rscratch1);\n+    OopMap* map = new OopMap(_frame_size_slots, 0);\n+    _oop_maps->add_gc_map(the_pc - start, map);\n@@ -205,8 +221,4 @@\n-  __ block_comment(\"{ thread java2native\");\n-  __ set_last_Java_frame(rsp, rbp, (address)the_pc, rscratch1);\n-  OopMap* map = new OopMap(_frame_size_slots, 0);\n-  _oop_maps->add_gc_map(the_pc - start, map);\n-\n-  \/\/ State transition\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n-  __ block_comment(\"} thread java2native\");\n+    \/\/ State transition\n+    __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n+    __ block_comment(\"} thread java2native\");\n+  }\n@@ -266,12 +278,0 @@\n-  __ block_comment(\"{ thread native2java\");\n-  __ restore_cpu_control_state_after_jni(rscratch1);\n-\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n-\n-  \/\/ Force this write out before the read below\n-  if (!UseSystemMemoryBarrier) {\n-    __ membar(Assembler::Membar_mask_bits(\n-            Assembler::LoadLoad | Assembler::LoadStore |\n-            Assembler::StoreLoad | Assembler::StoreStore));\n-  }\n-\n@@ -280,0 +280,7 @@\n+  Label L_reguard;\n+  Label L_after_reguard;\n+  if (_needs_transition) {\n+    __ block_comment(\"{ thread native2java\");\n+    __ restore_cpu_control_state_after_jni(rscratch1);\n+\n+    __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n@@ -281,3 +288,6 @@\n-  __ safepoint_poll(L_safepoint_poll_slow_path, r15_thread, true \/* at_return *\/, false \/* in_nmethod *\/);\n-  __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);\n-  __ jcc(Assembler::notEqual, L_safepoint_poll_slow_path);\n+    \/\/ Force this write out before the read below\n+    if (!UseSystemMemoryBarrier) {\n+      __ membar(Assembler::Membar_mask_bits(\n+              Assembler::LoadLoad | Assembler::LoadStore |\n+              Assembler::StoreLoad | Assembler::StoreStore));\n+    }\n@@ -285,1 +295,3 @@\n-  __ bind(L_after_safepoint_poll);\n+    __ safepoint_poll(L_safepoint_poll_slow_path, r15_thread, true \/* at_return *\/, false \/* in_nmethod *\/);\n+    __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);\n+    __ jcc(Assembler::notEqual, L_safepoint_poll_slow_path);\n@@ -287,2 +299,1 @@\n-  \/\/ change thread state\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);\n+    __ bind(L_after_safepoint_poll);\n@@ -290,6 +301,2 @@\n-  __ block_comment(\"reguard stack check\");\n-  Label L_reguard;\n-  Label L_after_reguard;\n-  __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), StackOverflow::stack_guard_yellow_reserved_disabled);\n-  __ jcc(Assembler::equal, L_reguard);\n-  __ bind(L_after_reguard);\n+    \/\/ change thread state\n+    __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);\n@@ -297,2 +304,8 @@\n-  __ reset_last_Java_frame(r15_thread, true);\n-  __ block_comment(\"} thread native2java\");\n+    __ block_comment(\"reguard stack check\");\n+    __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), StackOverflow::stack_guard_yellow_reserved_disabled);\n+    __ jcc(Assembler::equal, L_reguard);\n+    __ bind(L_after_reguard);\n+\n+    __ reset_last_Java_frame(r15_thread, true);\n+    __ block_comment(\"} thread native2java\");\n+  }\n@@ -305,3 +318,4 @@\n-  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n-  __ bind(L_safepoint_poll_slow_path);\n-  __ vzeroupper();\n+  if (_needs_transition) {\n+    __ block_comment(\"{ L_safepoint_poll_slow_path\");\n+    __ bind(L_safepoint_poll_slow_path);\n+    __ vzeroupper();\n@@ -309,3 +323,3 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_spill(_masm, spill_rsp_offset);\n-  }\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_rsp_offset);\n+    }\n@@ -313,7 +327,7 @@\n-  __ mov(c_rarg0, r15_thread);\n-  __ mov(r12, rsp); \/\/ remember sp\n-  __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n-  __ andptr(rsp, -16); \/\/ align stack as required by ABI\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n-  __ mov(rsp, r12); \/\/ restore sp\n-  __ reinit_heapbase();\n+    __ mov(c_rarg0, r15_thread);\n+    __ mov(r12, rsp); \/\/ remember sp\n+    __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n+    __ andptr(rsp, -16); \/\/ align stack as required by ABI\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n+    __ mov(rsp, r12); \/\/ restore sp\n+    __ reinit_heapbase();\n@@ -321,3 +335,3 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_fill(_masm, spill_rsp_offset);\n-  }\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_rsp_offset);\n+    }\n@@ -325,2 +339,2 @@\n-  __ jmp(L_after_safepoint_poll);\n-  __ block_comment(\"} L_safepoint_poll_slow_path\");\n+    __ jmp(L_after_safepoint_poll);\n+    __ block_comment(\"} L_safepoint_poll_slow_path\");\n@@ -330,7 +344,3 @@\n-  __ block_comment(\"{ L_reguard\");\n-  __ bind(L_reguard);\n-  __ vzeroupper();\n-\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_spill(_masm, spill_rsp_offset);\n-  }\n+    __ block_comment(\"{ L_reguard\");\n+    __ bind(L_reguard);\n+    __ vzeroupper();\n@@ -338,6 +348,3 @@\n-  __ mov(r12, rsp); \/\/ remember sp\n-  __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n-  __ andptr(rsp, -16); \/\/ align stack as required by ABI\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));\n-  __ mov(rsp, r12); \/\/ restore sp\n-  __ reinit_heapbase();\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_rsp_offset);\n+    }\n@@ -345,3 +352,6 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_fill(_masm, spill_rsp_offset);\n-  }\n+    __ mov(r12, rsp); \/\/ remember sp\n+    __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n+    __ andptr(rsp, -16); \/\/ align stack as required by ABI\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));\n+    __ mov(rsp, r12); \/\/ restore sp\n+    __ reinit_heapbase();\n@@ -349,1 +359,3 @@\n-  __ jmp(L_after_reguard);\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_rsp_offset);\n+    }\n@@ -351,1 +363,1 @@\n-  __ block_comment(\"} L_reguard\");\n+    __ jmp(L_after_reguard);\n@@ -353,0 +365,2 @@\n+    __ block_comment(\"} L_reguard\");\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":89,"deletions":75,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.abi.fallback.FallbackLinker;\n@@ -38,1 +39,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -49,0 +50,1 @@\n+<<<<<<< HEAD\n@@ -53,0 +55,7 @@\n+=======\n+                                                                      Windowsx64Linker, LinuxRISCV64Linker,\n+                                                                      FallbackLinker {\n+\n+    public interface UpcallStubFactory {\n+        MemorySegment makeStub(MethodHandle target, Arena arena);\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n@@ -57,0 +66,1 @@\n+<<<<<<< HEAD\n@@ -58,0 +68,3 @@\n+=======\n+    private final SoftReferenceCache<LinkRequest, UpcallStubFactory> UPCALL_CACHE = new SoftReferenceCache<>();\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n@@ -77,2 +90,2 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, SegmentScope scope) {\n-        Objects.requireNonNull(scope);\n+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, Arena arena, Linker.Option... options) {\n+        Objects.requireNonNull(arena);\n@@ -83,0 +96,1 @@\n+        LinkerOptions optionSet = LinkerOptions.forUpcall(function, options);\n@@ -89,0 +103,1 @@\n+<<<<<<< HEAD\n@@ -94,0 +109,8 @@\n+=======\n+        UpcallStubFactory factory = UPCALL_CACHE.get(new LinkRequest(function, optionSet), linkRequest ->\n+            arrangeUpcall(type, linkRequest.descriptor(), linkRequest.options()));\n+        return factory.makeStub(target, arena);\n+    }\n+\n+    protected abstract UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options);\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -29,0 +28,2 @@\n+import jdk.internal.foreign.abi.BindingInterpreter.LoadFunc;\n+import jdk.internal.foreign.abi.BindingInterpreter.StoreFunc;\n@@ -30,5 +31,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.*;\n@@ -202,0 +199,1 @@\n+<<<<<<< HEAD\n@@ -295,0 +293,17 @@\n+=======\n+    enum Tag {\n+        VM_STORE,\n+        VM_LOAD,\n+        BUFFER_STORE,\n+        BUFFER_LOAD,\n+        COPY_BUFFER,\n+        ALLOC_BUFFER,\n+        BOX_ADDRESS,\n+        UNBOX_ADDRESS,\n+        DUP,\n+        CAST\n+    }\n+\n+    Tag tag();\n+\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n@@ -297,2 +312,2 @@\n-    void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                   BindingInterpreter.LoadFunc loadFunc, Context context);\n+    void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                   LoadFunc loadFunc, SegmentAllocator allocator);\n@@ -355,2 +370,2 @@\n-    static BoxAddress boxAddressRaw(long size) {\n-        return new BoxAddress(size, false);\n+    static BoxAddress boxAddressRaw(long size, long align) {\n+        return new BoxAddress(size, align, false);\n@@ -360,1 +375,1 @@\n-        return new BoxAddress(layout.byteSize(), true);\n+        return new BoxAddress(layout.byteSize(), layout.byteAlignment(), true);\n@@ -364,1 +379,1 @@\n-        return new BoxAddress(byteSize, true);\n+        return new BoxAddress(byteSize, 1, true);\n@@ -466,2 +481,2 @@\n-        public Binding.Builder boxAddressRaw(long size) {\n-            bindings.add(Binding.boxAddressRaw(size));\n+        public Binding.Builder boxAddressRaw(long size, long align) {\n+            bindings.add(Binding.boxAddressRaw(size, align));\n@@ -511,2 +526,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -530,2 +545,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -558,2 +573,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -615,2 +630,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -660,2 +675,2 @@\n-        private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment, Context context) {\n-            return context.allocator().allocate(size, alignment)\n+        private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment, SegmentAllocator allocator) {\n+            return allocator.allocate(size, alignment)\n@@ -673,2 +688,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -676,1 +691,1 @@\n-            MemorySegment copy = copyBuffer(operand, size, alignment, context);\n+            MemorySegment copy = copyBuffer(operand, size, alignment, allocator);\n@@ -686,2 +701,2 @@\n-        private static MemorySegment allocateBuffer(long size, long alignment, Context context) {\n-            return context.allocator().allocate(size, alignment);\n+        private static MemorySegment allocateBuffer(long size, long alignment, SegmentAllocator allocator) {\n+            return allocator.allocate(size, alignment);\n@@ -696,3 +711,3 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n-            stack.push(allocateBuffer(size, alignment, context));\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n+            stack.push(allocateBuffer(size, alignment, allocator));\n@@ -718,3 +733,3 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n-            stack.push(((MemorySegment)stack.pop()).address());\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n+            stack.push(SharedUtils.unboxSegment((MemorySegment)stack.pop()));\n@@ -729,1 +744,1 @@\n-    record BoxAddress(long size, boolean needsScope) implements Binding {\n+    record BoxAddress(long size, long align, boolean needsScope) implements Binding {\n@@ -739,5 +754,7 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n-            SegmentScope scope = needsScope ?\n-                    context.scope() : SegmentScope.global();\n-            stack.push(NativeMemorySegmentImpl.makeNativeSegmentUnchecked((long) stack.pop(), size, scope));\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n+            MemorySegment segment = Utils.longToAddress((long) stack.pop(), size, align);\n+            if (needsScope) {\n+                segment = segment.reinterpret((Arena) allocator, null);\n+            }\n+            stack.push(segment);\n@@ -761,2 +778,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -776,2 +793,2 @@\n-            public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                                  BindingInterpreter.LoadFunc loadFunc, Context context) {\n+            public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                                  LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -816,2 +833,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":64,"deletions":47,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.Arena;\n@@ -32,1 +33,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -144,0 +144,1 @@\n+<<<<<<< HEAD\n@@ -147,0 +148,5 @@\n+=======\n+        Arena allocator = invData.callingSequence.allocationSize() != 0\n+                ? SharedUtils.newBoundedArena(invData.callingSequence.allocationSize())\n+                : SharedUtils.newEmptyArena();\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -47,1 +48,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -54,1 +54,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n@@ -85,1 +84,1 @@\n-    \/\/ r2-7 and v4-7 so they are omitted here.\n+    \/\/ r2-7 and v4-7 so, they are omitted here.\n@@ -161,1 +160,1 @@\n-            csb.addArgumentBindings(MemorySegment.class, AArch64.C_POINTER,\n+            csb.addArgumentBindings(MemorySegment.class, SharedUtils.C_POINTER,\n@@ -193,0 +192,1 @@\n+<<<<<<< HEAD\n@@ -195,0 +195,5 @@\n+=======\n+    public UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc,\n+                                                          LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, true, options);\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n@@ -432,1 +437,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, AArch64.C_POINTER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, SharedUtils.C_POINTER);\n@@ -467,1 +472,1 @@\n-                .boxAddressRaw(Long.MAX_VALUE)\n+                .boxAddressRaw(Long.MAX_VALUE, 1)\n@@ -491,1 +496,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, AArch64.C_POINTER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, SharedUtils.C_POINTER);\n@@ -496,1 +501,2 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, (ValueLayout) layout);\n+                    AddressLayout addressLayout = (AddressLayout) layout;\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, addressLayout);\n@@ -498,1 +504,1 @@\n-                            .boxAddressRaw(Utils.pointeeSize(layout));\n+                            .boxAddressRaw(Utils.pointeeByteSize(addressLayout), Utils.pointeeByteAlign(addressLayout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -34,0 +33,1 @@\n+<<<<<<< HEAD\n@@ -35,0 +35,2 @@\n+=======\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n@@ -37,1 +39,0 @@\n-import java.util.function.Consumer;\n@@ -63,0 +64,1 @@\n+<<<<<<< HEAD\n@@ -79,0 +81,4 @@\n+=======\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.LINUX.arrangeUpcall(targetType, function, options);\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+<<<<<<< HEAD\n@@ -35,0 +36,2 @@\n+=======\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n@@ -37,1 +40,0 @@\n-import java.util.function.Consumer;\n@@ -63,0 +65,1 @@\n+<<<<<<< HEAD\n@@ -79,0 +82,4 @@\n+=======\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.MACOS.arrangeUpcall(targetType, function, options);\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+<<<<<<< HEAD\n@@ -36,0 +37,2 @@\n+=======\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n@@ -38,1 +41,0 @@\n-import java.util.function.Consumer;\n@@ -60,0 +62,1 @@\n+<<<<<<< HEAD\n@@ -78,0 +81,6 @@\n+=======\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return  CallArranger.WINDOWS.arrangeUpcall(targetType, function, options);\n+    }\n+\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -45,1 +46,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.ValueLayout;\n@@ -55,1 +56,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n@@ -94,1 +94,1 @@\n-            MemoryLayout layout = RISCV64.C_POINTER;\n+            MemoryLayout layout = SharedUtils.C_POINTER;\n@@ -124,0 +124,1 @@\n+<<<<<<< HEAD\n@@ -126,0 +127,4 @@\n+=======\n+    public static UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, true, options);\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n@@ -394,0 +399,1 @@\n+                    AddressLayout addressLayout = (AddressLayout) layout;\n@@ -396,1 +402,1 @@\n-                            .boxAddressRaw(Utils.pointeeSize(layout));\n+                            .boxAddressRaw(Utils.pointeeByteSize(addressLayout), Utils.pointeeByteAlign(addressLayout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64CallArranger.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -34,2 +33,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.VaList;\n@@ -38,1 +35,0 @@\n-import java.util.function.Consumer;\n@@ -60,0 +56,1 @@\n+<<<<<<< HEAD\n@@ -76,0 +73,4 @@\n+=======\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return LinuxRISCV64CallArranger.arrangeUpcall(targetType, function, options);\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.AddressLayout;\n@@ -46,0 +46,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -52,1 +53,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.SysV;\n@@ -68,0 +68,5 @@\n+    \/**\n+     * The {@code long} native type.\n+     *\/\n+    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;\n+\n@@ -100,1 +105,1 @@\n-            MemoryLayout layout = SysV.C_POINTER;\n+            MemoryLayout layout = SharedUtils.C_POINTER;\n@@ -116,1 +121,1 @@\n-            csb.addArgumentBindings(long.class, SysV.C_LONG,\n+            csb.addArgumentBindings(long.class, C_LONG,\n@@ -136,0 +141,1 @@\n+<<<<<<< HEAD\n@@ -138,0 +144,4 @@\n+=======\n+    public static UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, true, options);\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n@@ -317,0 +327,1 @@\n+                    AddressLayout addressLayout = (AddressLayout) layout;\n@@ -319,1 +330,1 @@\n-                            .boxAddressRaw(Utils.pointeeSize(layout));\n+                            .boxAddressRaw(Utils.pointeeByteSize(addressLayout), Utils.pointeeByteAlign(addressLayout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -33,0 +32,1 @@\n+<<<<<<< HEAD\n@@ -34,0 +34,2 @@\n+=======\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n@@ -36,1 +38,0 @@\n-import java.util.function.Consumer;\n@@ -61,0 +62,1 @@\n+<<<<<<< HEAD\n@@ -77,0 +79,4 @@\n+=======\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.arrangeUpcall(targetType, function, options);\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.AddressLayout;\n@@ -45,0 +45,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -50,1 +51,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.Win64;\n@@ -107,1 +107,1 @@\n-            MemoryLayout layout = Win64.C_POINTER;\n+            MemoryLayout layout = SharedUtils.C_POINTER;\n@@ -135,0 +135,1 @@\n+<<<<<<< HEAD\n@@ -137,0 +138,4 @@\n+=======\n+    public static UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, true, options);\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n@@ -267,0 +272,1 @@\n+<<<<<<< HEAD\n@@ -271,0 +277,8 @@\n+=======\n+                case POINTER: {\n+                    AddressLayout addressLayout = (AddressLayout) layout;\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n+                    bindings.vmLoad(storage, long.class)\n+                            .boxAddressRaw(Utils.pointeeByteSize(addressLayout), Utils.pointeeByteAlign(addressLayout));\n+                    break;\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.VaList;\n@@ -36,1 +33,0 @@\n-import java.util.function.Consumer;\n@@ -61,0 +57,1 @@\n+<<<<<<< HEAD\n@@ -77,0 +74,4 @@\n+=======\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.arrangeUpcall(targetType, function, options);\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.Arena;\n@@ -38,0 +39,1 @@\n+<<<<<<< HEAD\n@@ -40,0 +42,2 @@\n+=======\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n@@ -68,0 +72,1 @@\n+<<<<<<< HEAD\n@@ -71,0 +76,3 @@\n+=======\n+        return LINKER.upcallStub(BLANK, BLANK_DESC, Arena.ofAuto());\n+>>>>>>> 21ebfddd0a434c247249da093304aa55c962c652\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LinkUpcall.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}