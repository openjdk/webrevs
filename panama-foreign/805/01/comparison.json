{"files":[{"patch":"@@ -3,1 +3,1 @@\n-**January 2023**\n+**March 2023**\n@@ -15,1 +15,1 @@\n-If clients want to dereference a zero-length memory segment, they can do so *unsafely* in two ways. First, the client can create a new memory segment from the zero-length memory segment *unsafely*, using the `MemorySegment::ofAddress` factory. This method is *restricted* and will generate runtime warnings if called without specifying the `--enable-native-access` command-line flag. By calling `MemorySegment::ofAddress` a client inject extra knowledge about spatial bounds which might be available in the native library the client is interacting with:\n+To work with native zero-length memory segments, clients have several options, all of which are <em>unsafe<\/em>. First, clients can unsafely resize a zero-length memory segment by obtaining a memory segment with the same base address as the zero-length memory segment, but with the desired size, so that the resulting segment can then be accessed directly, as follows:\n@@ -18,5 +18,3 @@\n-MemorySegment raw = ... \/\/obtain address from native code\n-try (Arena arena = Arena.openConfined()) {\n-    MemorySegment segment = MemorySegment.ofAddress(raw.address(), 100, arena.scope());\n-    int x = segment.get(JAVA_INT, 0);\n-}\n+MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ size = 0\n+                                   .reinterpret(4)               \/\/ size = 4\n+int x = foreign.get(ValueLayout.JAVA_INT, 0);                    \/\/ ok\n@@ -25,1 +23,1 @@\n-Alternatively, clients can obtain an *unbounded* address value layout. This is done using the `ValueLayout.OfAddress::asUnbounded` method (which is also a restricted method). When an access operation uses an unbounded address value layouts, the runtime will wrap any corresponding raw addresses with native segments with <em>maximal<\/em> size (i.e. `Long.MAX_VALUE`). As such, these segments can be accessed directly, as follows:\n+In some cases, a client might additionally want to assign new temporal bounds to a zero-length memory segment. This can be done using another variant of the `MemorySegment::reinterpret` method, which returns a new native segment with the desired size and temporal bounds:\n@@ -28,21 +26,5 @@\n-MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.asUnbounded(), 0); \/\/ wrap address into segment (size = Long.MAX_VALUE)\n-int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ok\n-```\n-\n-Which approach is taken largely depends on the information that a client has available when obtaining a memory segment wrapping a native pointer. For instance, if such pointer points to a C struct, the client might prefer to resize the segment unsafely, to match the size of the struct (so that out-of-bounds access will be detected by the API). In other instances, however, there will be no, or little information as to what spatial and\/or temporal bounds should be associated with a given native pointer. In these cases using an unbounded address layout might be preferable.\n-### Segment allocators\n-\n-Idiomatic C code implicitly relies on stack allocation to allow for concise variable declarations; consider this example:\n-\n-```c\n-int arr[] = { 0, 1, 2, 3, 4 };\n-```\n-\n-A variable initializer such as the one above can be implemented as follows, using the Foreign Memory Access API:\n-\n-```java\n-try (Arena arena = Arena openConfined()) {\n-    MemorySegment arr = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(5, JAVA_INT), arena.scope());\n-    for (int i = 0 ; i < 5 ; i++) {\n-        arr.setAtIndex(JAVA_INT, i, i);\n-    }\n+MemorySegment foreign = null;\n+try (Arena arena = Arena.ofConfined()) {\n+      foreign = someSegment.get(ValueLayout.ADDRESS, 0)           \/\/ size = 0, scope = always alive\n+                           .reinterpret(4, arena, null);          \/\/ size = 4, scope = arena.scope()\n+      int x = foreign.get(ValueLayout.JAVA_INT, 0);               \/\/ ok\n@@ -50,0 +32,1 @@\n+int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ throws IllegalStateException\n@@ -52,7 +35,1 @@\n-There are a number of issues with the above code snippet:\n-\n-* compared to the C code, it is more verbose — the native array has to be initialized *element by element*\n-* allocation is very slow compared to C; allocating the `arr` variable now takes a full `malloc`, while in C the variable was simply stack-allocated\n-* when having multiple declarations like the one above, it might become increasingly harder to manage the lifecycle of the various segments\n-\n-To address these problems, the FFM API provides a `SegmentAllocator` abstraction, a functional interface which provides methods to allocate commonly used values. Since `Arena` implements the `SegmentAllocator` interface, the above code can be rewritten conveniently as follows:\n+Note how the new segment will behave as if it was allocated in the provided arena: when the arena is closed, the new segment is no longer accessible.\n@@ -60,0 +37,1 @@\n+Alternatively, if the size of the foreign segment is known statically, clients can associate a *target layout* with the address layout used to obtain the segment. When an access operation, or a function descriptor that is passed to a downcall method handle (see below), uses an address value layout with target layout `T`, the runtime will wrap any corresponding raw addresses as segments with size set to `T.byteSize()`:\n@@ -61,3 +39,2 @@\n-try (Arena arena = Arena.openConfined()) {\n-    MemorySegment arr = arena.allocateArray(JAVA_INT, 0, 1, 2, 3, 4);\n-} \/\/ 'arr' is released here\n+MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.withTargetLayout(JAVA_INT), 0); \/\/ size = 4\n+int x = foreign.get(ValueLayout.JAVA_INT, 0);                                               \/\/ ok\n@@ -66,3 +43,1 @@\n-In the above code, the arena acts as a *native* allocator (that is, an allocator built on top of `MemorySegment::allocateNative`). The arena is then used to create a native array, initialized to the values `0, 1, 2, 3, 4`.  The array initialization is more efficient, compared to the previous snippet, as the Java array is copied *in bulk* into the memory region associated with the newly allocated memory segment. The returned segment is associated with the scope of the arena which performed the allocation, meaning that the segment will no longer be accessible after the try-with-resource construct.\n-\n-Custom segment allocators are also critical to achieve optimal allocation performance; for this reason, a number of predefined allocators are available via factories in the `SegmentAllocator` interface. For example, the following code creates a *slicing* allocator and uses it to allocate a segment whose content is initialized from a Java `int` array:\n+Which approach is taken largely depends on the information that a client has available when obtaining a memory segment wrapping a native pointer. For instance, if such pointer points to a C struct, the client might prefer to resize the segment unsafely, to match the size of the struct (so that out-of-bounds access will be detected by the API). If the size is known statically, using an address layout with the correct target layout might be preferable. In other instances, however, there will be no, or little information as to what spatial and\/or temporal bounds should be associated with a given native pointer. In these cases using an unbounded address layout might be preferable.\n@@ -70,14 +45,1 @@\n-```java\n-try (Arena arena = Arena.openConfined()) {\n-    SegmentAllocator allocator = SegmentAllocator.slicingAllocator(arena.allocate(1024));\n-    for (int i = 0 ; i < 10 ; i++) {\n-        MemorySegment s = allocator.allocateArray(JAVA_INT,  new int[] { 1, 2, 3, 4, 5 });\n-        ...\n-    }\n-    ...\n- } \/\/ all memory allocated is released here\n-```\n-\n-This code creates a native segment whose size is 1024 bytes. The segment is then used to create a slicing allocator, which responds to  allocation requests by returning slices of that pre-allocated segment.  If the current segment does not have sufficient space to accommodate an  allocation request, an exception is thrown. All of the memory associated with the segments created by the allocator (i.e., in the body of the  for loop) is deallocated atomically when the arena is closed. This  technique combines the advantages of deterministic deallocation,  provided by the `Arena` abstraction, with a more flexible and scalable allocation scheme. It can be very useful when writing code  which manages a large number of off-heap segments.\n-\n-All the methods in the FFM API which *produce* memory segments (see `VaList::nextVarg` and downcall method handles), allow for an allocator parameter to be provided — this is key in ensuring that an application using the FFM API achieves optimal allocation performances, especially in non-trivial use cases.\n+> Note: Memory segments created using `MemorySegment::reinterpret`, or `OfAddress::withTargetLayout` are completely *unsafe*. There is no way for the runtime to verify that the provided address indeed points to a valid memory location, or that the size and temporal bounds of the memory region pointed by the address indeed conforms to the parameters provided by the client. For these reasons, these methods are *restricted method* in the FFM API. The first time a restricted method is invoked, a runtime warning is generated. Developers can get rid of warnings by specifying the set of modules that are allowed to call restricted methods. This is done by specifying the option `--enable-native-access=M`, where `M` is a module name. Multiple module names can be specified in a comma-separated list, where the special name `ALL-UNNAMED` is used to enable restricted access for all code on the class path. If the `--enable-native-access` option is specified, any attempt to call restricted operations from a module not listed in the option will fail with a runtime exception.\n@@ -89,1 +51,1 @@\n-* `SymbolLookup::libraryLookup(String, SegmentScope)` — creates a symbol lookup which can be used to search symbol in a library with the given name. The provided segment scope parameter controls the library lifecycle: that is, when the scope is not longer alive, the library referred to by the lookup will also be closed;\n+* `SymbolLookup::libraryLookup(String, SegmentScope)` — creates a symbol lookup which can be used to search symbol in a library with the given name. The provided segment scope parameter controls the library lifecycle: that is, when the scope is no longer alive, the library referred to by the lookup will also be closed;\n@@ -98,2 +60,2 @@\n-try (Arena arena = Arena.openConfined()) {\n-    SymbolLookup libclang = SymbolLookup.libraryLookup(\"libclang.so\", arena.scope());\n+try (Arena arena = Arena.ofConfined()) {\n+    SymbolLookup libclang = SymbolLookup.libraryLookup(\"libclang.so\", arena);\n@@ -110,1 +72,1 @@\n-    MethodHandle downcallHandle(Addressable symbol, FunctionDescriptor function);\n+    MethodHandle downcallHandle(MemorySegment symbol, FunctionDescriptor function);\n@@ -118,1 +80,1 @@\n-Both functions take a `FunctionDescriptor` instance — essentially an aggregate of memory layouts which is used to describe the argument and return types of a foreign function in full. Supported layouts are *value layouts* (for scalars and pointers) and *group layouts* (for structs\/unions). Each layout in a function descriptor is associated with a carrier Java type (see table below); together, all the carrier types associated with layouts in a function descriptor will determine a unique Java `MethodType`  — that is, the Java signature that clients will be using when interacting with said downcall handles, or upcall stubs.\n+Both functions take a `FunctionDescriptor` instance — essentially an aggregate of memory layouts which is used to describe the argument and return types of a foreign function in full. Supported layouts are *value layouts* (for scalars and pointers) and *group layouts* (for structs\/unions). Each layout in a function descriptor is associated with a carrier Java type (see table below); together, all the carrier types associated with layouts in a function descriptor will determine a unique Java `MethodType` — that is, the Java signature that clients will be using when interacting with said downcall handles, or upcall stubs.\n@@ -167,1 +129,1 @@\n-Note that, since the function `strlen` is part of the standard C library, which is loaded with the VM, we can just use the default lookup of the native linker to look it up. The rest is pretty straightforward — the only tricky detail is how to model `size_t`: typically this type has the size of a pointer, so we can use `JAVA_LONG` both Linux and Windows. On the Java side, we model the `size_t` using a `long` and the pointer is modelled using an `Addressable` parameter.\n+Note that, since the function `strlen` is part of the standard C library, which is loaded with the VM, we can just use the default lookup of the native linker to look it up. The rest is pretty straightforward — the only tricky detail is how to model `size_t`: typically this type has the size of a pointer, so we can use `JAVA_LONG` both Linux and Windows. On the Java side, we model the `size_t` using a `long` and the pointer is modelled using an `MemorySegment` parameter.\n@@ -169,1 +131,1 @@\n-Once we have obtained the downcall method handle, we can just use it as any other method handle<a href=\"#2\"><sup>1<\/sup><\/a>:\n+Once we have obtained the downcall method handle, we can just use it as any other method handle:\n@@ -172,2 +134,2 @@\n-try (Arena arena = Arena.openConfined()) {\n-    long len = strlen.invoke(arena.allocateUtf8String(\"Hello\")); \/\/ 5\n+try (Arena arena = Arena.ofConfined()) {\n+    long len = strlen.invokeExact(arena.allocateUtf8String(\"Hello\")); \/\/ 5\n@@ -186,2 +148,2 @@\n-try (Arena arena = Arena openConfined()) {\n-    long len = strlen_virtual.invoke(\n+try (Arena arena = Arena.ofConfined()) {\n+    long len = strlen_virtual.invokeExact(\n@@ -194,1 +156,1 @@\n-It is important to note that, albeit the interop code is written in Java, the above code can *not* be considered 100% safe. There are many arbitrary decisions to be made when setting up downcall method handles such as the one above, some of which might be obvious to us (e.g. how many parameters does the function take), but which cannot ultimately be verified by the Java runtime. After all, a symbol in a dynamic library is nothing but a numeric offset and, unless we are using a shared library with debugging information, no type information is attached to a given library symbol. This means that the Java runtime has to *trust* the function descriptor passed in<a href=\"#2\"><sup>2<\/sup><\/a>; for this reason, the `Linker::nativeLinker` factory is also a restricted method.\n+It is important to note that, albeit the interop code is written in Java, the above code can *not* be considered 100% safe. There are many arbitrary decisions to be made when setting up downcall method handles such as the one above, some of which might be obvious to us (e.g. how many parameters does the function take), but which cannot ultimately be verified by the Java runtime. After all, a symbol in a dynamic library is nothing but a numeric offset and, unless we are using a shared library with debugging information, no type information is attached to a given library symbol. This means that the Java runtime has to *trust* the function descriptor passed in<a href=\"#1\"><sup>1<\/sup><\/a>; for this reason, the `Linker::nativeLinker` factory is also a restricted method.\n@@ -196,1 +158,1 @@\n-When working with shared arenas, it is always possible for the arena associated with a memory segment passed *by reference* to a native function to be closed (by another thread) *while* the native function is executing. When this happens, the native code is at risk of dereferencing already-freed memory, which might trigger a JVM crash, or even result in silent memory corruption. For this reason, the `Linker` API provides some basic temporal safety guarantees: any `MemorySegment` instance passed by reference to a downcall method handle will be *kept alive* for the entire duration of the call. In other words, it's as if the call to the downcall method handle occurred inside an invisible call to `SegmentScope::whileAlive`.\n+When working with shared arenas, it is always possible for the arena associated with a memory segment passed *by reference* to a native function to be closed (by another thread) *while* the native function is executing. When this happens, the native code is at risk of dereferencing already-freed memory, which might trigger a JVM crash, or even result in silent memory corruption. For this reason, the `Linker` API provides some basic temporal safety guarantees: any `MemorySegment` instance passed by reference to a downcall method handle will be *kept alive* for the entire duration of the call.\n@@ -225,3 +187,3 @@\n-\tstatic int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) {\n-\t\treturn addr1.get(JAVA_INT, 0) - addr2.get(JAVA_INT, 0);\n-\t}\n+    static int qsortCompare(MemorySegment elem1, MemorySegmet elem2) {\n+        return elem1.get(JAVA_INT, 0) - elem2.get(JAVA_INT, 0);\n+    }\n@@ -236,1 +198,3 @@\n-FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT, ADDRESS, ADDRESS);\n+FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT,\n+                                                      ADDRESS.withTargetLayout(JAVA_INT),\n+                                                      ADDRESS.withTargetLayout(JAVA_INT));\n@@ -239,1 +203,1 @@\n-                                                     CLinker.upcallType(comparDesc));\n+                                                     comparDesc.toMethodType());\n@@ -242,1 +206,1 @@\n-To do that, we first create a function descriptor for the function pointer type, and then we use the `CLinker::upcallType` to turn that function descriptor into a suitable `MethodType` instance to be used in a method handle lookup. Now that we have a method handle for our Java comparator function, we finally have all the ingredients to create an upcall stub, and pass it to the `qsort` downcall handle:\n+To do that, we first create a function descriptor for the function pointer type. This descriptor uses address layouts that have a `JAVA_INT` target layout, to allow access operations inside the upcall method handle. We use the `CLinker::upcallType` to turn that function descriptor into a suitable `MethodType` instance to be used in a method handle lookup. Now that we have a method handle for our Java comparator function, we finally have all the ingredients to create an upcall stub, and pass it to the `qsort` downcall handle:\n@@ -245,2 +209,2 @@\n-try (Arena arena = Arena.openConfined()) {\n-    MemorySegment comparFunc = linker.upcallStub(comparHandle, comparDesc, session);\n+try (Arena arena = Arena.ofConfined()) {\n+    MemorySegment comparFunc = linker.upcallStub(comparHandle, comparDesc, arena);\n@@ -248,1 +212,1 @@\n-    qsort.invoke(array, 10L, 4L, comparFunc);\n+    qsort.invokeExact(array, 10L, 4L, comparFunc);\n@@ -257,1 +221,1 @@\n-### Varargs\n+### Variadic calls\n@@ -269,1 +233,1 @@\n-```C\n+```c\n@@ -287,2 +251,2 @@\n-try (Arena arena = Arena.openConfined()) {\n-    printf.invoke(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n+try (Arena arena = Arena.ofConfined()) {\n+    int res = (int)printf.invokeExact(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n@@ -292,1 +256,1 @@\n-While this works, and provides optimal performance, it has some limitations<a href=\"#3\"><sup>3<\/sup><\/a>:\n+While this works, and provides optimal performance, it has some limitations<a href=\"#2\"><sup>2<\/sup><\/a>:\n@@ -307,1 +271,0 @@\n-import java.lang.foreign.VaList;\n@@ -333,1 +296,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -335,1 +298,1 @@\n-            long len = (long) strlen.invoke(hello); \/\/ 5\n+            long len = (long) strlen.invokeExact(hello); \/\/ 5\n@@ -345,1 +308,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -347,1 +310,1 @@\n-            long len = (long) strlen_virtual.invoke(\n+            long len = (long) strlen_virtual.invokeExact(\n@@ -365,1 +328,3 @@\n-        FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT, ADDRESS.asUnbounded(), ADDRESS.asUnbounded());\n+        FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT,\n+                                                              ADDRESS.withTargetLayout(JAVA_INT),\n+                                                              ADDRESS.withTargetLayout(JAVA_INT));\n@@ -370,1 +335,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -372,1 +337,1 @@\n-                comparHandle, comparDesc, arena.scope());\n+                comparHandle, comparDesc, arena);\n@@ -375,1 +340,1 @@\n-            qsort.invoke(array, 10L, 4L, comparFunc);\n+            qsort.invokeExact(array, 10L, 4L, comparFunc);\n@@ -387,1 +352,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -389,1 +354,1 @@\n-            printf.invoke(s, 2, 2, 4);\n+            int res = (int)printf.invokeExact(s, 2, 2, 4);\n@@ -397,3 +362,2 @@\n-* <a id=\"1\"\/>(<sup>1<\/sup>):<small> For simplicity, the examples shown in this document use `MethodHandle::invoke` rather than `MethodHandle::invokeExact`; by doing so we avoid having to cast by-reference arguments back to `Addressable`. With `invokeExact` the method handle invocation should be rewritten as `strlen.invokeExact((Addressable)session.allocateUtf8String(\"Hello\"));`<\/small>\n-* <a id=\"2\"\/>(<sup>2<\/sup>):<small> In reality this is not entirely new; even in JNI, when you call a `native` method the VM trusts that the corresponding implementing function in C will feature compatible parameter types and return values; if not a crash might occur.<\/small>\n-* <a id=\"3\"\/>(<sup>3<\/sup>):<small> Previous iterations of the FFM API provided a `VaList` class that could be used to model a C `va_list`. This class was later dropped from the FFM API as too implementation specific. It is possible that a future version of the `jextract` tool might provide higher-level bindings for variadic calls. <\/small>\n+* <a id=\"1\"\/>(<sup>1<\/sup>):<small> In reality this is not entirely new; even in JNI, when you call a `native` method the VM trusts that the corresponding implementing function in C will feature compatible parameter types and return values; if not a crash might occur.<\/small>\n+* <a id=\"2\"\/>(<sup>2<\/sup>):<small> Previous iterations of the FFM API provided a `VaList` class that could be used to model a C `va_list`. This class was later dropped from the FFM API as too implementation specific. It is possible that a future version of the `jextract` tool might provide higher-level bindings for variadic calls. <\/small>\n","filename":"doc\/panama_ffi.md","additions":61,"deletions":97,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-**December 2022**\n+**March 2023**\n@@ -9,1 +9,1 @@\n-### Memory segments and lifetimes\n+### Memory segments and arenas\n@@ -16,1 +16,1 @@\n-MemorySegment segment = MemorySegment.allocateNative(100, SegmentScope.global());\n+MemorySegment segment = Arena.global().allocate(100);\n@@ -19,1 +19,1 @@\n-The above code allocates a 100-bytes long memory segment. The lifecycle of a memory segment is controlled by an abstraction called `SegmentScope`. In this example, the segment is associated with the simplest scope, called the *global* scope. Memory segments associated with this scope are always *alive* and their backing region of memory are never deallocated. In other words, we say that the above segment has an *unbounded* lifetime.\n+The above code allocates a 100-bytes long memory segment, using an *arena*. The FFM API provides several kinds of arena, which can be used to control the lifecycle of the allocated native segments in different ways. In this example, the segment is allocated with the *global* arena. Memory segments allocated with this arena are always *alive* and their backing regions of memory are never deallocated. In other words, we say that the above segment has an *unbounded* lifetime.\n@@ -21,1 +21,3 @@\n-Most programs, though, require off-heap memory to be deallocated  while the program is running, and thus need memory segments with *bounded* lifetimes. The simplest way to obtain a segment with bounded lifetime is to use an *automatic scope*:\n+> Note: the lifetime of a memory segment is modelled by a *scope* (see `MemorySegment.Scope`). A memory segment can be accessed as long as its associated scope is *alive* (see `Scope::isAlive`). In most cases, the scope of a memory segment is the scope of the arena which allocated that segment. Accessing the scope of a segment can be useful to perform lifetime queries (e.g. asking whether a segment has the same lifetime as that of another segment), creating custom arenas and unsafely assigning new temporal bounds to an existing native memory segments (these topics are explored in more details below).\n+\n+Most programs, though, require off-heap memory to be deallocated while the program is running, and thus need memory segments with *bounded* lifetimes. The simplest way to obtain a segment with bounded lifetime is to use an *automatic arena*:\n@@ -24,1 +26,1 @@\n-MemorySegment segment = MemorySegment.allocateNative(100, SegmentScope.auto());\n+MemorySegment segment = Arena.ofAuto().allocate(100);\n@@ -27,1 +29,1 @@\n-Segments associated with an automatic scope are alive as long as they are determined to be reachable by the garbage collector. In other words, the above snippet creates a native segment whose behavior closely matches that of a `ByteBuffer` allocated with the `allocateDirect` factory.\n+Segments allocated with an automatic arena are alive as long as they are determined to be reachable by the garbage collector. In other words, the above snippet creates a native segment whose behavior closely matches that of a `ByteBuffer` allocated with the `allocateDirect` factory.\n@@ -29,1 +31,1 @@\n-There are cases, however, where automatic deallocation is not enough: consider the case where a large memory segment is mapped from a file (this is possible using `MemorySegment::map`); in this case, an application would probably prefer to release (e.g. `unmap`) the memory associated with this segment in a *deterministic* fashion, to ensure that memory doesn't remain available for longer than it needs to.\n+There are cases, however, where automatic deallocation is not enough: consider the case where a large memory segment is mapped from a file (this is possible using `FileChannel::map`); in this case, an application would probably prefer to release (e.g. `unmap`) the memory associated with this segment in a *deterministic* fashion, to ensure that memory doesn't remain available for longer than it needs to.\n@@ -31,1 +33,1 @@\n-An `Arena` provides a scope - the arena scope - which features a bounded and deterministic lifetime. The arena scope is alive from the time when the arena is opened, until the time when the arena is closed. Multiple segments allocated with the same arena scope  enjoy the same bounded lifetime and can safely contain mutual references. For example, this code opens an arena and uses the arena's scope to specify the lifetime of two segments:\n+A *confined* arena allocates segment featuring a bounded *and* deterministic lifetime. A memory segment allocated with a confined arena is alive from the time when the arena is opened, until the time when the arena is closed (at which point the segments become inaccessible). Multiple segments allocated with the same arena enjoy the *same* bounded lifetime and can safely contain mutual references. For example, this code opens an arena and uses it to allocate several native segments:\n@@ -33,4 +35,4 @@\n-```\n-try (Arena arena = Arena.openConfined()) {\n-    MemorySegment segment1 = MemorySegment.allocateNative(100, arena.scope());\n-    MemorySegment segment2 = MemorySegment.allocateNative(100, arena.scope());\n+```java\n+try (Arena arena = Arena.ofConfined()) {\n+    MemorySegment segment1 = arena.allocate(100);\n+    MemorySegment segment2 = arena.allocate(100);\n@@ -38,1 +40,1 @@\n-    MemorySegment segmentN = MemorySegment.allocateNative(100, arena.scope());\n+    MemorySegment segmentN = arena.allocate(100);\n@@ -42,5 +44,1 @@\n-When the arena is closed (above, this is done with the *try-with-resources* construct) the arena scope is no longer alive, all the segments associated with it are invalidated atomically, and the regions of memory backing the segments are deallocated.\n-\n-### Thread-confinement\n-\n-Arenas provide a strong temporal safety guarantee: memory segments associated with an arena scope cannot be accessed after the arena is closed, since the arena scope is no longer alive. If an arena is opened and closed by the same thread, and all memory segments allocated with the arena's scope are accessed only  by that thread, then ensuring correctness is straightforward. However, if memory segments allocated with the arena scope are accessed by  multiple threads then ensuring correctness is complex. For example, a segment allocated with an arena scope might be accessed by one thread while another thread attempts to close the arena. To guarantee temporal safety without making single-threaded clients pay undue cost, there are  two kinds of arenas: *confined* and *shared*.\n+When the arena is closed (above, this is done with the *try-with-resources* construct) the arena is no longer alive, all the segments associated with it are invalidated atomically, and the regions of memory backing the segments are deallocated.\n@@ -48,2 +46,1 @@\n-- A confined arena (`Arena::openConfined`) supports strong thread-confinement guarantees. A confined arena has an *owner thread*, typically the thread which opened it. The memory segments allocated in a confined arena (i.e., with the confined arena's scope) can be accessed  only by the owner thread. Any attempt to close the confined arena from a thread other than the owner thread will fail with an exception.\n-- A shared arena (`Arena::openShared`) has no owner thread.  The memory segments allocated in a shared arena can be accessed by  multiple threads. Moreover, a shared arena can be closed by any thread,  and the closure is guaranteed to be safe and atomic even under races<a href=\"#1\"><sup>1<\/sup><\/a>.\n+A confined arena's deterministic lifetime comes at a price: only one thread can access the memory segments allocated in a confined arena. If multiple threads need access to a segment, then a *shared* arena can be used (`Arena::ofShared`). The memory segments allocated in a shared arena can be accessed by multiple threads, and any thread (regardless of whether it was involved in access) can close the shared arena to deallocate the segments. The closure will atomically invalidate the segments, though deallocation of the regions of memory backing the segments might not occur immediately: an expensive synchronization operation<a href=\"#1\"><sup>1<\/sup><\/a> is needed to detect and cancel pending concurrent access operations on the segments.\n@@ -51,1 +48,1 @@\n-In summary, a segment scope controls which threads can access a  memory segment, and when. A memory segment with global scope or  automatic scope can be accessed by any thread. Conversely, arena scopes  restrict access to specific threads in order to provide both strong  temporal safety and a predictable performance model.\n+In summary, an arena controls *which* threads can access a memory segment and *when*, in order to provide both strong temporal safety and a predictable performance model. The FFM API offers a choice of arenas so that a client can trade off breadth-of-access against timeliness of deallocation.\n@@ -58,1 +55,1 @@\n-MemorySegment segment = MemorySement.allocateNative(10, SegmentScope.auto());\n+MemorySegment segment = Arena.ofAuto().allocate(10);\n@@ -70,2 +67,2 @@\n-try (Arena arena = Arena.openShared()) {\n-    MemorySegment segment = MemorySegment.allocateNative(seq, arena.scope());\n+try (Arena arena = Arena.ofShared()) {\n+    MemorySegment segment = arena.allocate(seq);\n@@ -98,1 +95,1 @@\n-MemorySegment segment = MemorySement.allocateNative(10 * 4 * 2, SegmentScope.auto());\n+MemorySegment segment = Arena.ofAuto().allocate(10 * 4 * 2);\n@@ -107,1 +104,1 @@\n-The above snippet allocates a flat array of 80 bytes using `MemorySegment::allocateNative`. Then, inside the loop, elements in the array are accessed using the `MemorySegment::getAtIndex` method, which accesses `int` elements in a segment at a certain *logical* index (under the hood, the segment offset being accessed is obtained by multiplying the logical index by 4, which is the stride of a Java `int` array). Thus, all coordinates `x` and `y` are collected into instances of a `Point` record.\n+The above snippet allocates a flat array of 80 bytes using an automatic arena. Then, inside the loop, elements in the array are accessed using the `MemorySegment::getAtIndex` method, which accesses `int` elements in a segment at a certain *logical* index (under the hood, the segment offset being accessed is obtained by multiplying the logical index by 4, which is the stride of a Java `int` array). Thus, all coordinates `x` and `y` are collected into instances of a `Point` record.\n@@ -111,1 +108,1 @@\n-Expressing byte offsets (as in the example above) can lead to code that is hard to read, and very fragile — as memory layout invariants are captured, implicitly, in the constants used to scale offsets. To address this issue, clients can use a `MemoryLayout` to to describe the contents of a memory segment *programmatically*. For instance, the layout of the array used in the above example can be expressed using the following code <a href=\"#2\"><sup>2<\/sup><\/a>:\n+Expressing byte offsets (as in the example above) can lead to code that is hard to read, and very fragile — as memory layout invariants are captured, implicitly, in the constants used to scale offsets. To address this issue, clients can use a `MemoryLayout` to describe the contents of a memory segment *programmatically*. For instance, the layout of the array used in the above example can be expressed using the following code <a href=\"#2\"><sup>2<\/sup><\/a>:\n@@ -133,1 +130,1 @@\n-MemorySegment segment = MemorySegment.allocateNative(points, SegmentScope.auto());\n+MemorySegment segment = Arena.ofAuto().allocate(points);\n@@ -181,1 +178,1 @@\n-### Unsafe segments\n+### Segment allocators and custom arenas\n@@ -183,1 +180,1 @@\n-The FFM API provides basic safety guarantees for all memory segments created using the API. More specifically, a memory dereference operation should either succeed, or result in a runtime exception — but, crucially, should never result in a VM crash, or, more subtly, in memory corruption occurring *outside* the region of memory associated with a memory segment. This is indeed the case, as all memory segments feature immutable *spatial bounds*, and, as we have seen, are associated with a segment scope which make sure that segments cannot be dereferenced after their backing regions of memory have been deallocated.\n+Memory allocation is often a bottleneck when clients use off-heap memory. The FFM API therefore includes a `SegmentAllocator` interface to define operations to allocate and initialize memory segments. As a convenience, the `Arena` interface extends the `SegmentAllocator` interface so that arenas can be used to allocate native segments. In other words, `Arena` is a \"one-stop shop\" for flexible allocation and timely deallocation of off-heap memory:\n@@ -185,3 +182,10 @@\n-That said, it is sometimes necessary to create a segment out of an existing memory source, which might be managed by native code. This is the case, for instance, if we want to create a segment out of a memory region managed by a *custom allocator*.\n-\n-The `ByteBuffer` API allows such a move, through a JNI [method](https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/jni\/spec\/functions.html#NewDirectByteBuffer), namely `NewDirectByteBuffer`. This native method can be used to wrap a long address in a fresh direct byte buffer instance which is then returned to unsuspecting Java code.\n+```java\n+FileChannel channel = ...\n+try (Arena offHeap = Arena.ofConfined()) {\n+    MemorySegment nativeArray   = offHeap.allocateArray(ValueLayout.JAVA_INT, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+    MemorySegment nativeString  = offHeap.allocateUtf8String(\"Hello!\");\n+\n+    MemorySegment mappedSegment = channel.map(MapMode.READ_WRITE, 0, 1000, arena);\n+   ...\n+} \/\/ memory released here\n+```\n@@ -189,1 +193,1 @@\n-Memory segments provide a similar capability — that is, given an address (which might have been obtained through some native calls), it is possible to wrap a segment around it, with given spatial bounds and segment scope, as follows:\n+Segment allocators can also be obtained via factories in the `SegmentAllocator` interface. For example, one factory creates a *slicing allocator* that responds to allocation requests by returning memory segments which are part of a previously allocated segment; thus, many requests can be satisfied without physically allocating more memory. The following code obtains a slicing allocator over an existing segment, then uses it to allocate a segment initialized from a Java array:\n@@ -192,3 +196,4 @@\n-try (Arena arena = Arena.openShared()) {\n-    long addr = ...\n-    var unsafeSegment = MemorySegment.ofAddress(addr, 10, arena.scope());\n+MemorySegment segment = ...\n+SegmentAllocator allocator = SegmentAllocator.slicingAllocator(segment);\n+for (int i = 0 ; i < 10 ; i++) {\n+    MemorySegment s = allocator.allocateArray(JAVA_INT, new int[] { 1, 2, 3, 4, 5 });\n@@ -199,1 +204,1 @@\n-The above code creates a shared arena and then, inside the *try-with-resources* it creates a *new* unsafe segment from a given address; the size of the segment is 10 bytes, and the unsafe segment is associated with the current shared arena. This means that the unsafe segment cannot be dereferenced after the shared arena has been closed.\n+A segment allocator can be used as a building block to create an arena that supports a custom allocation strategy. For example, if many segments share the same bounded lifetime, then an arena could use a slicing allocator to allocate the segments efficiently. This lets clients enjoy both scalable allocation (thanks to slicing) and deterministic deallocation (thanks to the arena).\n@@ -201,1 +206,6 @@\n-Of course, segments created this way are completely *unsafe*. There is no way for the runtime to verify that the provided address indeed points to a valid memory location, or that the size of the memory region pointed to by `addr` is indeed 10 bytes. Similarly, there are no guarantees that the underlying memory region associated with `addr` will not be deallocated *prior* to the call to `Arena::close`.\n+As an example, the following code defines a *slicing arena* that behaves like a confined arena (i.e., single-threaded access), but internally uses a slicing allocator to respond to allocation requests.  When the slicing arena is closed, the underlying confined arena is also closed; this will invalidate all segments allocated with the slicing arena:\n+\n+```java\n+class SlicingArena {\n+     final Arena arena = Arena.ofConfined();\n+     final SegmentAllocator slicingAllocator;\n@@ -203,1 +213,28 @@\n-For these reasons, `MemorySegment::ofAddress` is a *restricted method* in the FFM API. The first time a restricted method is invoked, a runtime warning is generated. Developers can get rid of warnings by specifying the set of modules that are allowed to call restricted methods. This is done by specifying the option `--enable-native-access=M`, where `M` is a module name. Multiple module names can be specified in a comma-separated list, where the special name `ALL-UNNAMED` is used to enable restricted access for all code on the class path. If the `--enable-native-access` option is specified, any attempt to call restricted operations from a module not listed in the option will fail with a runtime exception.\n+     SlicingArena(long size) {\n+         slicingAllocator = SegmentAllocator.slicingAllocator(arena.allocate(size));\n+     }\n+\n+public void allocate(long byteSize, long byteAlignment) {\n+         return slicingAllocator.allocate(byteSize, byteAlignment);\n+     }\n+\n+     public MemorySegment.Scope scope() {\n+         return arena.scope();\n+     }\n+\n+     public void close() {\n+         return arena.close();\n+     }\n+}\n+```\n+\n+The earlier code which used a slicing allocator directly can now be written more succinctly, as follows:\n+\n+```java\n+try (Arena slicingArena = new SlicingArena(1000)) {\n+     for (int i = 0 ; i < 10 ; i++) {\n+         MemorySegment s = arena.allocateArray(JAVA_INT, new int[] { 1, 2, 3, 4, 5 });\n+         ...\n+     }\n+} \/\/ all memory allocated is released here\n+```\n","filename":"doc\/panama_memaccess.md","additions":78,"deletions":41,"binary":false,"changes":119,"status":"modified"}]}