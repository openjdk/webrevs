{"files":[{"patch":"@@ -3,1 +3,1 @@\n-**February 2023**\n+**March 2023**\n@@ -29,1 +29,1 @@\n-                           .reinterpret(4, arena.scope(), null);  \/\/ size = 4, scope = arena.scope()\n+                           .reinterpret(4, arena, null);          \/\/ size = 4, scope = arena.scope()\n@@ -35,1 +35,3 @@\n-Alternatively, if the size of the foreign segment is known statically, clients can associate a *target layout*  with the address layout used to obtain the segment. When an access operation, or a function descriptor that is passed to a downcall method handle (see below), uses an address value layout with target layout `T`, the runtime will wrap any corresponding raw addresses as segments with size set to `T.byteSize()`:\n+Note how the new segment will behave as if it was allocated in the provided arena: when the arena is closed, the new segment is no longer accessible.\n+\n+Alternatively, if the size of the foreign segment is known statically, clients can associate a *target layout* with the address layout used to obtain the segment. When an access operation, or a function descriptor that is passed to a downcall method handle (see below), uses an address value layout with target layout `T`, the runtime will wrap any corresponding raw addresses as segments with size set to `T.byteSize()`:\n@@ -49,1 +51,1 @@\n-* `SymbolLookup::libraryLookup(String, SegmentScope)` — creates a symbol lookup which can be used to search symbol in a library with the given name. The provided segment scope parameter controls the library lifecycle: that is, when the scope is not longer alive, the library referred to by the lookup will also be closed;\n+* `SymbolLookup::libraryLookup(String, SegmentScope)` — creates a symbol lookup which can be used to search symbol in a library with the given name. The provided segment scope parameter controls the library lifecycle: that is, when the scope is no longer alive, the library referred to by the lookup will also be closed;\n@@ -78,1 +80,1 @@\n-Both functions take a `FunctionDescriptor` instance — essentially an aggregate of memory layouts which is used to describe the argument and return types of a foreign function in full. Supported layouts are *value layouts* (for scalars and pointers) and *group layouts* (for structs\/unions). Each layout in a function descriptor is associated with a carrier Java type (see table below); together, all the carrier types associated with layouts in a function descriptor will determine a unique Java `MethodType`  — that is, the Java signature that clients will be using when interacting with said downcall handles, or upcall stubs.\n+Both functions take a `FunctionDescriptor` instance — essentially an aggregate of memory layouts which is used to describe the argument and return types of a foreign function in full. Supported layouts are *value layouts* (for scalars and pointers) and *group layouts* (for structs\/unions). Each layout in a function descriptor is associated with a carrier Java type (see table below); together, all the carrier types associated with layouts in a function descriptor will determine a unique Java `MethodType` — that is, the Java signature that clients will be using when interacting with said downcall handles, or upcall stubs.\n@@ -204,1 +206,1 @@\n-To do that, we first create a function descriptor for the function pointer type. This descriptor uses address layouts that have a `JAVA_INT` target layout, so as to allow dereference operations inside the upcall method handle. We use the `CLinker::upcallType` to turn that function descriptor into a suitable `MethodType` instance to be used in a method handle lookup. Now that we have a method handle for our Java comparator function, we finally have all the ingredients to create an upcall stub, and pass it to the `qsort` downcall handle:\n+To do that, we first create a function descriptor for the function pointer type. This descriptor uses address layouts that have a `JAVA_INT` target layout, to allow access operations inside the upcall method handle. We use the `CLinker::upcallType` to turn that function descriptor into a suitable `MethodType` instance to be used in a method handle lookup. Now that we have a method handle for our Java comparator function, we finally have all the ingredients to create an upcall stub, and pass it to the `qsort` downcall handle:\n@@ -231,1 +233,1 @@\n-```C\n+```c\n","filename":"doc\/panama_ffi.md","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-**February 2023**\n+**March 2023**\n@@ -23,1 +23,1 @@\n-Most programs, though, require off-heap memory to be deallocated  while the program is running, and thus need memory segments with *bounded* lifetimes. The simplest way to obtain a segment with bounded lifetime is to use an *automatic arena*:\n+Most programs, though, require off-heap memory to be deallocated while the program is running, and thus need memory segments with *bounded* lifetimes. The simplest way to obtain a segment with bounded lifetime is to use an *automatic arena*:\n@@ -35,1 +35,1 @@\n-```\n+```java\n@@ -46,1 +46,1 @@\n-A confined arena's deterministic lifetime comes at a price: only one  thread can access the memory segments allocated in a confined arena. If  multiple threads need access to a segment, then a *shared* arena can be used (`Arena::ofShared`). The memory segments allocated in a shared arena can be accessed by  multiple threads, and any thread (whether or not involved in access) can close the shared arena to deallocate the segments. The closure will  atomically invalidate the segments, though deallocation of the regions  of memory backing the segments might not occur immediately: an expensive synchronization operation<a href=\"#1\"><sup>1<\/sup><\/a>  is needed to detect and cancel pending  concurrent access operations on the segments.\n+A confined arena's deterministic lifetime comes at a price: only one thread can access the memory segments allocated in a confined arena. If multiple threads need access to a segment, then a *shared* arena can be used (`Arena::ofShared`). The memory segments allocated in a shared arena can be accessed by multiple threads, and any thread (regardless of whether it was involved in access) can close the shared arena to deallocate the segments. The closure will atomically invalidate the segments, though deallocation of the regions of memory backing the segments might not occur immediately: an expensive synchronization operation<a href=\"#1\"><sup>1<\/sup><\/a> is needed to detect and cancel pending concurrent access operations on the segments.\n@@ -48,1 +48,1 @@\n-In summary, an arena controls *which* threads can access a memory segment and *when*, in order to provide both strong temporal safety and a predictable  performance model. The FFM API offers a choice of arenas so that a  client can trade off breadth-of-access against timeliness of  deallocation.\n+In summary, an arena controls *which* threads can access a memory segment and *when*, in order to provide both strong temporal safety and a predictable performance model. The FFM API offers a choice of arenas so that a client can trade off breadth-of-access against timeliness of deallocation.\n@@ -108,1 +108,1 @@\n-Expressing byte offsets (as in the example above) can lead to code that is hard to read, and very fragile — as memory layout invariants are captured, implicitly, in the constants used to scale offsets. To address this issue, clients can use a `MemoryLayout` to to describe the contents of a memory segment *programmatically*. For instance, the layout of the array used in the above example can be expressed using the following code <a href=\"#2\"><sup>2<\/sup><\/a>:\n+Expressing byte offsets (as in the example above) can lead to code that is hard to read, and very fragile — as memory layout invariants are captured, implicitly, in the constants used to scale offsets. To address this issue, clients can use a `MemoryLayout` to describe the contents of a memory segment *programmatically*. For instance, the layout of the array used in the above example can be expressed using the following code <a href=\"#2\"><sup>2<\/sup><\/a>:\n@@ -180,1 +180,1 @@\n-Memory allocation is often a bottleneck when clients use off-heap memory. The FFM API therefore includes a `SegmentAllocator` interface to define operations to allocate and initialize memory segments. As a convenience, the `Arena` interface extends the `SegmentAllocator` interface so that arenas can be used to allocate native segments. In other words, `Arena` is a \"one stop shop\" for flexible allocation and timely deallocation of off-heap memory:\n+Memory allocation is often a bottleneck when clients use off-heap memory. The FFM API therefore includes a `SegmentAllocator` interface to define operations to allocate and initialize memory segments. As a convenience, the `Arena` interface extends the `SegmentAllocator` interface so that arenas can be used to allocate native segments. In other words, `Arena` is a \"one-stop shop\" for flexible allocation and timely deallocation of off-heap memory:\n@@ -193,1 +193,1 @@\n-Segment allocators can also be obtained via factories in the `SegmentAllocator` interface. For example, one factory creates a *slicing allocator* that responds to allocation requests by returning memory segments which are part of a previously allocated segment; thus, many requests can be  satisfied without physically allocating more memory. The following code  obtains a slicing allocator over an existing segment, then uses it to  allocate a segment initialized from a Java array:\n+Segment allocators can also be obtained via factories in the `SegmentAllocator` interface. For example, one factory creates a *slicing allocator* that responds to allocation requests by returning memory segments which are part of a previously allocated segment; thus, many requests can be satisfied without physically allocating more memory. The following code obtains a slicing allocator over an existing segment, then uses it to allocate a segment initialized from a Java array:\n@@ -195,1 +195,1 @@\n-```\n+```java\n@@ -204,1 +204,1 @@\n-A segment allocator can be used as a building block to create an  arena that supports a custom allocation strategy. For example, if a  large number of native segments will share the same bounded lifetime,  then an arena could use a slicing allocator to allocate the segments  efficiently. This lets clients enjoy both scalable allocation (thanks to slicing) and deterministic deallocation (thanks to the arena).\n+A segment allocator can be used as a building block to create an arena that supports a custom allocation strategy. For example, if many segments share the same bounded lifetime, then an arena could use a slicing allocator to allocate the segments efficiently. This lets clients enjoy both scalable allocation (thanks to slicing) and deterministic deallocation (thanks to the arena).\n@@ -206,1 +206,1 @@\n-As an example, the following code defines a *slicing arena*  that behaves like a confined arena (i.e., single-threaded access), but  internally uses a slicing allocator to respond to allocation requests.  When the slicing arena is closed, the underlying confined arena is also  closed; this will invalidate all segments allocated with the slicing arena:\n+As an example, the following code defines a *slicing arena* that behaves like a confined arena (i.e., single-threaded access), but internally uses a slicing allocator to respond to allocation requests.  When the slicing arena is closed, the underlying confined arena is also closed; this will invalidate all segments allocated with the slicing arena:\n@@ -208,1 +208,1 @@\n-```\n+```java\n@@ -233,1 +233,1 @@\n-```\n+```java\n","filename":"doc\/panama_memaccess.md","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"}]}