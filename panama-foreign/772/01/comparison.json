{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,0 @@\n-          --enable-jtreg-failure-handler\n","filename":".github\/workflows\/build-linux.yml","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,0 @@\n-          --enable-jtreg-failure-handler\n","filename":".github\/workflows\/build-macos.yml","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,0 @@\n-          --enable-jtreg-failure-handler\n","filename":".github\/workflows\/build-windows.yml","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,0 +105,23 @@\n+# Setup what kind of build environment type we have (CI or local developer)\n+AC_DEFUN_ONCE([BASIC_SETUP_BUILD_ENV],\n+[\n+  if test \"x$CI\" = \"xtrue\"; then\n+    DEFAULT_BUILD_ENV=\"ci\"\n+    AC_MSG_NOTICE([CI environment variable set to $CI])\n+  else\n+    DEFAULT_BUILD_ENV=\"dev\"\n+  fi\n+\n+  UTIL_ARG_WITH(NAME: build-env, TYPE: literal,\n+      RESULT: BUILD_ENV,\n+      VALID_VALUES: [auto dev ci], DEFAULT: auto,\n+      CHECKING_MSG: [for build environment type],\n+      DESC: [select build environment type (affects certain default values)],\n+      IF_AUTO: [\n+        RESULT=$DEFAULT_BUILD_ENV\n+      ]\n+  )\n+  AC_SUBST(BUILD_ENV)\n+])\n+\n+###############################################################################\n","filename":"make\/autoconf\/basic.m4","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,1 @@\n+  UTIL_LOOKUP_PROGS(WHOAMI, whoami)\n","filename":"make\/autoconf\/basic_tools.m4","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,1 @@\n+BASIC_SETUP_BUILD_ENV\n","filename":"make\/autoconf\/configure.ac","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -413,1 +413,1 @@\n-  UTIL_ARG_ENABLE(NAME: asan, DEFAULT: false,\n+  UTIL_ARG_ENABLE(NAME: asan, DEFAULT: false, RESULT: ASAN_ENABLED,\n@@ -429,1 +429,1 @@\n-        ASAN_CFLAGS=\"-fsanitize=address -Wno-stringop-truncation -fno-omit-frame-pointer\"\n+        ASAN_CFLAGS=\"-fsanitize=address -Wno-stringop-truncation -fno-omit-frame-pointer -DADDRESS_SANITIZER\"\n@@ -439,4 +439,0 @@\n-        ASAN_ENABLED=\"yes\"\n-      ],\n-      IF_DISABLED: [\n-        ASAN_ENABLED=\"no\"\n@@ -456,2 +452,3 @@\n-  UBSAN_CFLAGS=\"-fsanitize=undefined -fsanitize=float-divide-by-zero -Wno-stringop-truncation -Wno-format-overflow -fno-omit-frame-pointer -DUNDEFINED_BEHAVIOR_SANITIZER\"\n-  UBSAN_LDFLAGS=\"-fsanitize=undefined -fsanitize=float-divide-by-zero\"\n+  UBSAN_CHECKS=\"-fsanitize=undefined -fsanitize=float-divide-by-zero -fno-sanitize=shift-base\"\n+  UBSAN_CFLAGS=\"$UBSAN_CHECKS -Wno-stringop-truncation -Wno-format-overflow -fno-omit-frame-pointer -DUNDEFINED_BEHAVIOR_SANITIZER\"\n+  UBSAN_LDFLAGS=\"$UBSAN_CHECKS\"\n@@ -786,1 +783,1 @@\n-  $CODESIGN $PARAMS \"$CODESIGN_TESTFILE\" 2>&AS_MESSAGE_LOG_FD \\\n+  eval \\\"$CODESIGN\\\" $PARAMS \\\"$CODESIGN_TESTFILE\\\" 2>&AS_MESSAGE_LOG_FD \\\n@@ -799,1 +796,1 @@\n-  JDKOPT_CHECK_CODESIGN_PARAMS([-s \"$MACOSX_CODESIGN_IDENTITY\" --option runtime],\n+  JDKOPT_CHECK_CODESIGN_PARAMS([-s \\\"$MACOSX_CODESIGN_IDENTITY\\\" --option runtime],\n","filename":"make\/autoconf\/jdk-options.m4","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,5 @@\n+  # $USER may be not defined in dockers, so try to check with $WHOAMI\n+  if test \"x$USERNAME\" = x && test \"x$WHOAMI\" != x; then\n+    [ USERNAME=`$WHOAMI | $TR -d -c '[a-z][A-Z][0-9]'` ]\n+  fi\n+\n","filename":"make\/autoconf\/jdk-version.m4","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -288,1 +288,7 @@\n-  UTIL_ARG_ENABLE(NAME: jtreg-failure-handler, DEFAULT: auto,\n+  if test \"x$BUILD_ENV\" = \"xci\"; then\n+    BUILD_FAILURE_HANDLER_DEFAULT=auto\n+  else\n+    BUILD_FAILURE_HANDLER_DEFAULT=false\n+  fi\n+\n+  UTIL_ARG_ENABLE(NAME: jtreg-failure-handler, DEFAULT: $BUILD_FAILURE_HANDLER_DEFAULT,\n@@ -291,1 +297,1 @@\n-      DEFAULT_DESC: [enabled if jtreg is present],\n+      DEFAULT_DESC: [enabled if jtreg is present and build env is CI],\n","filename":"make\/autoconf\/lib-tests.m4","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,0 +92,27 @@\n+################################################################################\n+# Setup BASIC_JVM_LIBS that can be different depending on build\/target platform\n+################################################################################\n+AC_DEFUN([LIB_SETUP_JVM_LIBS],\n+[\n+  # Atomic library\n+  # 32-bit platforms needs fallback library for 8-byte atomic ops on Zero\n+  if HOTSPOT_CHECK_JVM_VARIANT(zero); then\n+    if test \"x$OPENJDK_$1_OS\" = xlinux &&\n+        (test \"x$OPENJDK_$1_CPU\" = xarm ||\n+         test \"x$OPENJDK_$1_CPU\" = xm68k ||\n+         test \"x$OPENJDK_$1_CPU\" = xmips ||\n+         test \"x$OPENJDK_$1_CPU\" = xmipsel ||\n+         test \"x$OPENJDK_$1_CPU\" = xppc ||\n+         test \"x$OPENJDK_$1_CPU\" = xsh ||\n+         test \"x$OPENJDK_$1_CPU\" = xriscv32); then\n+      BASIC_JVM_LIBS_$1=\"$BASIC_JVM_LIBS_$1 -latomic\"\n+    fi\n+  fi\n+\n+  # Because RISC-V only has word-sized atomics, it requires libatomic where\n+  # other common architectures do not, so link libatomic by default.\n+  if test \"x$OPENJDK_$1_OS\" = xlinux && test \"x$OPENJDK_$1_CPU\" = xriscv64; then\n+    BASIC_JVM_LIBS_$1=\"$BASIC_JVM_LIBS_$1 -latomic\"\n+  fi\n+])\n+\n@@ -112,0 +139,1 @@\n+  BASIC_JDKLIB_LIBS_TARGET=\"\"\n@@ -138,21 +166,0 @@\n-  # Atomic library\n-  # 32-bit platforms needs fallback library for 8-byte atomic ops on Zero\n-  if HOTSPOT_CHECK_JVM_VARIANT(zero); then\n-    if test \"x$OPENJDK_TARGET_OS\" = xlinux &&\n-        (test \"x$OPENJDK_TARGET_CPU\" = xarm ||\n-         test \"x$OPENJDK_TARGET_CPU\" = xm68k ||\n-         test \"x$OPENJDK_TARGET_CPU\" = xmips ||\n-         test \"x$OPENJDK_TARGET_CPU\" = xmipsel ||\n-         test \"x$OPENJDK_TARGET_CPU\" = xppc ||\n-         test \"x$OPENJDK_TARGET_CPU\" = xsh ||\n-         test \"x$OPENJDK_TARGET_CPU\" = xriscv32); then\n-      BASIC_JVM_LIBS=\"$BASIC_JVM_LIBS -latomic\"\n-    fi\n-  fi\n-\n-  # Because RISC-V only has word-sized atomics, it requires libatomic where\n-  # other common architectures do not.  So link libatomic by default.\n-  if test \"x$OPENJDK_TARGET_OS\" = xlinux && test \"x$OPENJDK_TARGET_CPU\" = xriscv64; then\n-    BASIC_JVM_LIBS=\"$BASIC_JVM_LIBS -latomic\"\n-  fi\n-\n@@ -169,0 +176,2 @@\n+  LIB_SETUP_JVM_LIBS(BUILD)\n+  LIB_SETUP_JVM_LIBS(TARGET)\n@@ -172,1 +181,1 @@\n-  JVM_LIBS=\"$BASIC_JVM_LIBS\"\n+  JVM_LIBS=\"$BASIC_JVM_LIBS $BASIC_JVM_LIBS_TARGET\"\n@@ -174,1 +183,1 @@\n-  OPENJDK_BUILD_JVM_LIBS=\"$BASIC_JVM_LIBS\"\n+  OPENJDK_BUILD_JVM_LIBS=\"$BASIC_JVM_LIBS $BASIC_JVM_LIBS_BUILD\"\n","filename":"make\/autoconf\/libraries.m4","additions":33,"deletions":24,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -452,8 +452,1 @@\n-export ASAN_ENABLED:=@ASAN_ENABLED@\n-export DEVKIT_LIB_DIR:=@DEVKIT_LIB_DIR@\n-ifeq ($(ASAN_ENABLED), yes)\n-  export ASAN_OPTIONS=handle_segv=0 detect_leaks=0\n-  ifneq ($(DEVKIT_LIB_DIR),)\n-    export LD_LIBRARY_PATH:=$(LD_LIBRARY_PATH):$(DEVKIT_LIB_DIR)\n-  endif\n-endif\n+ASAN_ENABLED:=@ASAN_ENABLED@\n","filename":"make\/autoconf\/spec.gmk.in","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -147,0 +147,6 @@\n+  $1_EXTRA_FILES := $(LAUNCHER_SRC)\/main.c\n+\n+  ifeq ($(ASAN_ENABLED), true)\n+    $1_EXTRA_FILES += $(TOPDIR)\/make\/data\/asan\/asan_default_options.c\n+  endif\n+\n@@ -149,1 +155,1 @@\n-      EXTRA_FILES := $(LAUNCHER_SRC)\/main.c, \\\n+      EXTRA_FILES := $$($1_EXTRA_FILES), \\\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -245,1 +245,2 @@\n-        \"linux-aarch64\", \"linux-arm32\", \"linux-ppc64le\", \"linux-s390x\"\n+        \"linux-aarch64\", \"linux-arm32\", \"linux-ppc64le\", \"linux-s390x\",\n+        \"linux-riscv64\"\n@@ -252,1 +253,1 @@\n-        configure_args: concat(\"--enable-jtreg-failure-handler\",\n+        configure_args: concat(\n@@ -522,0 +523,11 @@\n+\n+        \"linux-riscv64\": {\n+            target_os: \"linux\",\n+            target_cpu: \"riscv64\",\n+            build_cpu: \"x64\",\n+            dependencies: [\"devkit\", \"gtest\", \"build_devkit\"],\n+            configure_args: [\n+                \"--openjdk-target=riscv64-linux-gnu\", \"--with-freetype=bundled\",\n+                \"--disable-warnings-as-errors\"\n+            ],\n+        },\n@@ -718,1 +730,4 @@\n-        }\n+        },\n+        \"linux-riscv64\": {\n+            platform: \"linux-riscv64\",\n+        },\n@@ -1078,1 +1093,2 @@\n-        linux_s390x: \"gcc8.2.0-Fedora27+1.0\"\n+        linux_s390x: \"gcc8.2.0-Fedora27+1.0\",\n+        linux_riscv64: \"gcc11.3.0-Fedora_rawhide_68692+1.1\"\n","filename":"make\/conf\/jib-profiles.js","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef ADDRESS_SANITIZER\n+#error \"Build misconfigured, preprocessor macro ADDRESS_SANITIZER should be defined\"\n+#endif\n+\n+#ifndef __has_attribute\n+#define __has_attribute(x) 0\n+#endif\n+\n+#if (defined(__GNUC__) && !defined(__clang__)) || __has_attribute(visibility)\n+#define ATTRIBUTE_DEFAULT_VISIBILITY __attribute__((visibility(\"default\")))\n+#else\n+#define ATTRIBUTE_DEFAULT_VISIBILITY\n+#endif\n+\n+#if (defined(__GNUC__) && !defined(__clang__)) || __has_attribute(used)\n+#define ATTRIBUTE_USED __attribute__((used))\n+#else\n+#define ATTRIBUTE_USED\n+#endif\n+\n+\/\/ Override weak symbol exposed by ASan to override default options. This is called by ASan\n+\/\/ extremely early during library loading, before main is called. We need to override the default\n+\/\/ options because LSan is enabled by default and Hotspot is not yet compatible with it.\n+\/\/ Additionally we need to prevent ASan from handling SIGSEGV, so that Hotspot's crash handler is\n+\/\/ used. You can override these options by setting the environment variable ASAN_OPTIONS.\n+ATTRIBUTE_DEFAULT_VISIBILITY ATTRIBUTE_USED const char* __asan_default_options() {\n+  return\n+#ifndef LEAK_SANITIZER\n+    \"detect_leaks=0,\"\n+#endif\n+    \"handle_segv=0\";\n+}\n","filename":"make\/data\/asan\/asan_default_options.c","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,12 +66,6 @@\n-  DEFAULT_OS_VERSION := 27\n-  ifeq ($(BASE_OS_VERSION), )\n-    BASE_OS_VERSION := $(DEFAULT_OS_VERSION)\n-  endif\n-  ifeq ($(filter x86_64 armhfp, $(ARCH)), )\n-    FEDORA_TYPE := fedora-secondary\n-  else\n-    FEDORA_TYPE := fedora\/linux\n-  endif\n-  ARCHIVED := $(shell [ $(BASE_OS_VERSION) -lt $(DEFAULT_OS_VERSION) ] && echo true)\n-  ifeq ($(ARCHIVED),true)\n-    BASE_URL := https:\/\/archives.fedoraproject.org\/pub\/archive\/$(FEDORA_TYPE)\/releases\/$(BASE_OS_VERSION)\/Everything\/$(ARCH)\/os\/Packages\/\n+  ifeq ($(ARCH), riscv64)\n+    DEFAULT_OS_VERSION := rawhide\/68692\n+    ifeq ($(BASE_OS_VERSION), )\n+      BASE_OS_VERSION := $(DEFAULT_OS_VERSION)\n+    endif\n+    BASE_URL := http:\/\/fedora.riscv.rocks\/repos-dist\/$(BASE_OS_VERSION)\/$(ARCH)\/Packages\/\n@@ -79,1 +73,15 @@\n-    BASE_URL := https:\/\/dl.fedoraproject.org\/pub\/$(FEDORA_TYPE)\/releases\/$(BASE_OS_VERSION)\/Everything\/$(ARCH)\/os\/Packages\/\n+    DEFAULT_OS_VERSION := 27\n+    ifeq ($(BASE_OS_VERSION), )\n+      BASE_OS_VERSION := $(DEFAULT_OS_VERSION)\n+    endif\n+    ifeq ($(filter x86_64 armhfp, $(ARCH)), )\n+      FEDORA_TYPE := fedora-secondary\n+    else\n+      FEDORA_TYPE := fedora\/linux\n+    endif\n+    ARCHIVED := $(shell [ $(BASE_OS_VERSION) -lt $(DEFAULT_OS_VERSION) ] && echo true)\n+    ifeq ($(ARCHIVED),true)\n+      BASE_URL := https:\/\/archives.fedoraproject.org\/pub\/archive\/$(FEDORA_TYPE)\/releases\/$(BASE_OS_VERSION)\/Everything\/$(ARCH)\/os\/Packages\/\n+    else\n+      BASE_URL := https:\/\/dl.fedoraproject.org\/pub\/$(FEDORA_TYPE)\/releases\/$(BASE_OS_VERSION)\/Everything\/$(ARCH)\/os\/Packages\/\n+    endif\n@@ -90,2 +98,11 @@\n-GCC_VER := 11.2.0\n-ifeq ($(GCC_VER), 11.2.0)\n+GCC_VER := 11.3.0\n+ifeq ($(GCC_VER), 11.3.0)\n+  gcc_ver := gcc-11.3.0\n+  binutils_ver := binutils-2.39\n+  ccache_ver := ccache-3.7.12\n+  mpfr_ver := mpfr-4.1.1\n+  gmp_ver := gmp-6.2.1\n+  mpc_ver := mpc-1.2.1\n+  gdb_ver := gdb-11.2\n+  REQUIRED_MIN_MAKE_MAJOR_VERSION := 4\n+else ifeq ($(GCC_VER), 11.2.0)\n@@ -192,1 +209,1 @@\n-    libgcc \\\n+    libgcc libxcrypt \\\n@@ -248,1 +265,1 @@\n-\t$$(foreach p,$$(abspath $$(wildcard patches\/$$(notdir $$($(1)_DIR)).patch)), \\\n+\t$$(foreach p,$$(abspath $$(wildcard patches\/$$(ARCH)-$$(notdir $$($(1)_DIR)).patch)), \\\n@@ -417,0 +434,6 @@\n+ifneq ($(ARCH), riscv64)\n+  # gold is not available for riscv64 for some reason,\n+  # and subsequent linking will fail if we try to enable it.\n+  LINKER_CONFIG := --enable-gold=default\n+endif\n+\n@@ -429,0 +452,1 @@\n+        $(LINKER_CONFIG) \\\n@@ -433,1 +457,0 @@\n-\t      --enable-gold=default \\\n@@ -497,1 +520,1 @@\n-ifneq ($(filter ppc64 ppc64le s390x, $(ARCH)), )\n+ifneq ($(filter riscv64 ppc64 ppc64le s390x, $(ARCH)), )\n","filename":"make\/devkit\/Tools.gmk","additions":43,"deletions":20,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -0,0 +1,14 @@\n+diff -ur a\/libsanitizer\/sanitizer_common\/sanitizer_platform_limits_posix.cpp b\/libsanitizer\/sanitizer_common\/sanitizer_platform_limits_posix.cpp\n+--- a\/libsanitizer\/sanitizer_common\/sanitizer_platform_limits_posix.cpp\t2022-11-30 12:25:37.363419659 +0100\n++++ b\/libsanitizer\/sanitizer_common\/sanitizer_platform_limits_posix.cpp\t2022-11-30 12:42:48.135412054 +0100\n+@@ -59,7 +59,9 @@\n+ \n+ #if !SANITIZER_ANDROID\n+ #include <fstab.h>\n+-#include <sys\/mount.h>\n++\/\/ sys\/mount.h conflicts with linux\/fs.h in glibc 2.36+\n++\/\/ See https:\/\/sourceware.org\/glibc\/wiki\/Release\/2.36#Usage_of_.3Clinux.2Fmount.h.3E_and_.3Csys.2Fmount.h.3E\n++\/\/ This has been fixed elsewhere, but apparently not in Fedora riscv.\n+ #include <sys\/timeb.h>\n+ #include <utmpx.h>\n+ #endif\n","filename":"make\/devkit\/patches\/riscv64-gcc-11.3.0.patch","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,0 +169,1 @@\n+    DISABLED_WARNINGS_clang_notificationThread.cpp := bitwise-instead-of-logical, \\\n@@ -171,0 +172,1 @@\n+    DISABLED_WARNINGS_clang_serviceThread.cpp := bitwise-instead-of-logical, \\\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,0 +143,1 @@\n+    DISABLED_WARNINGS_clang := deprecated-non-prototype, \\\n@@ -214,1 +215,1 @@\n-    DISABLED_WARNINGS_clang := format-nonliteral, \\\n+    DISABLED_WARNINGS_clang := format-nonliteral deprecated-non-prototype, \\\n","filename":"make\/modules\/java.base\/lib\/CoreLibraries.gmk","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,1 @@\n-    DISABLED_WARNINGS_clang_awt_ImagingLib.c := sign-compare, \\\n+    DISABLED_WARNINGS_clang_awt_ImagingLib.c := sign-compare deprecated-non-prototype, \\\n@@ -760,0 +760,1 @@\n+      DISABLED_WARNINGS_clang := deprecated-non-prototype, \\\n@@ -832,0 +833,1 @@\n+      DISABLED_WARNINGS_clang_MTLRenderer.m := gnu-folding-constant, \\\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-### Font SubMenu (under Themes) \n+### Font SubMenu (under Themes)\n","filename":"src\/demo\/share\/jfc\/SwingSet2\/resources\/swingset.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-### Font SubMenu (under Themes) \n+### Font SubMenu (under Themes)\n","filename":"src\/demo\/share\/jfc\/SwingSet2\/resources\/swingset_de.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-### Font SubMenu (under Themes) \n+### Font SubMenu (under Themes)\n","filename":"src\/demo\/share\/jfc\/SwingSet2\/resources\/swingset_ja.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-### Font SubMenu (under Themes) \n+### Font SubMenu (under Themes)\n","filename":"src\/demo\/share\/jfc\/SwingSet2\/resources\/swingset_zh_CN.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11167,1 +11167,0 @@\n-\n@@ -12983,0 +12982,1 @@\n+\n@@ -13054,1 +13054,0 @@\n-\n@@ -13768,0 +13767,292 @@\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_reg_lt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, $src2 lt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             $src2$$Register,\n+             Assembler::LT);\n+  %}\n+  ins_pipe(icond_reg_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_reg_gt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, $src2 gt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             $src2$$Register,\n+             Assembler::GT);\n+  %}\n+  ins_pipe(icond_reg_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm0_lt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, zr lt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::LT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm0_gt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, zr gt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::GT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm1_le(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csincw $dst, $src1, zr le\\t\"  %}\n+\n+  ins_encode %{\n+    __ csincw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::LE);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm1_gt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csincw $dst, $src1, zr gt\\t\"  %}\n+\n+  ins_encode %{\n+    __ csincw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::GT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_immM1_lt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csinvw $dst, $src1, zr lt\\t\"  %}\n+\n+  ins_encode %{\n+    __ csinvw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::LT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_immM1_ge(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csinvw $dst, $src1, zr ge\\t\"  %}\n+\n+  ins_encode %{\n+    __ csinvw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::GE);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_reg_imm0(iRegINoSp dst, iRegIorL2I src, immI0 imm)\n+%{\n+  match(Set dst (MinI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_imm0_reg(iRegINoSp dst, immI0 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MinI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_reg_imm1(iRegINoSp dst, iRegIorL2I src, immI_1 imm)\n+%{\n+  match(Set dst (MinI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_le(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_imm1_reg(iRegINoSp dst, immI_1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MinI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_le(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_reg_immM1(iRegINoSp dst, iRegIorL2I src, immI_M1 imm)\n+%{\n+  match(Set dst (MinI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_immM1_reg(iRegINoSp dst, immI_M1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MinI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_reg_imm0(iRegINoSp dst, iRegIorL2I src, immI0 imm)\n+%{\n+  match(Set dst (MaxI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_imm0_reg(iRegINoSp dst, immI0 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MaxI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_reg_imm1(iRegINoSp dst, iRegIorL2I src, immI_1 imm)\n+%{\n+  match(Set dst (MaxI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_imm1_reg(iRegINoSp dst, immI_1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MaxI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_reg_immM1(iRegINoSp dst, iRegIorL2I src, immI_M1 imm)\n+%{\n+  match(Set dst (MaxI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_ge(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_immM1_reg(iRegINoSp dst, immI_M1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MaxI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_ge(dst, src, cr);\n+  %}\n+%}\n+\n@@ -15778,3 +16069,1 @@\n-instruct cmovI_reg_reg_lt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n-%{\n-  effect( DEF dst, USE src1, USE src2, USE cr );\n+\/\/ Like compI_reg_reg or compI_reg_immI0 but without match rule and second zero parameter.\n@@ -15782,2 +16071,5 @@\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"cselw $dst, $src1, $src2 lt\\t\"  %}\n+instruct compI_reg_imm0(rFlagsReg cr, iRegI src)\n+%{\n+  effect(DEF cr, USE src);\n+  ins_cost(INSN_COST);\n+  format %{ \"cmpw $src, 0\" %}\n@@ -15786,4 +16078,1 @@\n-    __ cselw(as_Register($dst$$reg),\n-             as_Register($src1$$reg),\n-             as_Register($src2$$reg),\n-             Assembler::LT);\n+    __ cmpw($src$$Register, 0);\n@@ -15791,2 +16080,1 @@\n-\n-  ins_pipe(icond_reg_reg);\n+  ins_pipe(icmp_reg_imm);\n@@ -15795,1 +16083,1 @@\n-instruct minI_rReg(iRegINoSp dst, iRegI src1, iRegI src2)\n+instruct minI_reg_reg(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2)\n@@ -15805,19 +16093,0 @@\n-\n-%}\n-\/\/ FROM HERE\n-\n-instruct cmovI_reg_reg_gt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n-%{\n-  effect( DEF dst, USE src1, USE src2, USE cr );\n-\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"cselw $dst, $src1, $src2 gt\\t\"  %}\n-\n-  ins_encode %{\n-    __ cselw(as_Register($dst$$reg),\n-             as_Register($src1$$reg),\n-             as_Register($src2$$reg),\n-             Assembler::GT);\n-  %}\n-\n-  ins_pipe(icond_reg_reg);\n@@ -15826,1 +16095,1 @@\n-instruct maxI_rReg(iRegINoSp dst, iRegI src1, iRegI src2)\n+instruct maxI_reg_reg(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2)\n@@ -15830,0 +16099,1 @@\n+\n@@ -15837,0 +16107,1 @@\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":305,"deletions":34,"binary":false,"changes":339,"status":"modified"},{"patch":"@@ -30,2 +30,4 @@\n-dnl\n-define(`ORL2I', `ifelse($1,I,orL2I)')\n+\n+define(`upcase', `translit(`$*', `a-z', `A-Z')')dnl\n+define(`downcase', `translit(`$*', `A-Z', `a-z')')dnl\n+define(`ORL2I', `ifelse($1,I,orL2I)')dnl\n@@ -192,1 +194,1 @@\n-define(`EXTEND', `($2$1 (LShift$1 $3 $4) $5)') dnl\n+define(`EXTEND', `($2$1 (LShift$1 $3 $4) $5)')dnl\n@@ -215,1 +217,1 @@\n-')\n+')dnl\n@@ -339,1 +341,1 @@\n-\/\/ Rotations dnl\n+\/\/ Rotations\n@@ -542,0 +544,74 @@\n+define(`CMOV_INSN', `\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmov$1_reg_reg_$3(iReg$1NoSp dst, iReg$1 src1, iReg$1 src2, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"$2 $dst, $src1, $src2 $3\\t\"  %}\n+\n+  ins_encode %{\n+    __ $2($dst$$Register,\n+             $src1$$Register,\n+             $src2$$Register,\n+             Assembler::upcase($3));\n+  %}\n+  ins_pipe(icond_reg_reg);\n+%}\n+')dnl\n+CMOV_INSN(I, cselw, lt)\n+CMOV_INSN(I, cselw, gt)\n+dnl\n+define(`CMOV_DRAW_INSN', `\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmov$1_reg_imm$2_$4(iReg$1NoSp dst, iReg$1 src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"$3 $dst, $src1, zr $4\\t\"  %}\n+\n+  ins_encode %{\n+    __ $3($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::upcase($4));\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+')dnl\n+CMOV_DRAW_INSN(I, 0, cselw, lt)\n+CMOV_DRAW_INSN(I, 0, cselw, gt)\n+CMOV_DRAW_INSN(I, 1, csincw, le)\n+CMOV_DRAW_INSN(I, 1, csincw, gt)\n+CMOV_DRAW_INSN(I, M1, csinvw, lt)\n+CMOV_DRAW_INSN(I, M1, csinvw, ge)\n+dnl\n+define(`MINMAX_DRAW_INSN', `\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+ifelse($6,,\n+instruct downcase($1)$2_reg_imm$4(iReg$2NoSp dst, iReg$2`'ORL2I($2) src, imm$2$3$4 imm),\n+instruct downcase($1)$2_imm$4_reg(iReg$2NoSp dst, imm$2$3$4 imm, iReg$2`'ORL2I($2) src))\n+%{\n+  ifelse($6,,\n+  match(Set dst ($1$2 src imm));,\n+  match(Set dst ($1$2 imm src));)\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    comp$2_reg_imm0(cr, src);\n+    cmov$2_reg_imm$4_$5(dst, src, cr);\n+  %}\n+%}\n+')dnl\n+MINMAX_DRAW_INSN(Min, I,  , 0, lt)\n+MINMAX_DRAW_INSN(Min, I,  , 0, lt, rev)\n+MINMAX_DRAW_INSN(Min, I, _, 1, le)\n+MINMAX_DRAW_INSN(Min, I, _, 1, le, rev)\n+MINMAX_DRAW_INSN(Min, I, _, M1, lt)\n+MINMAX_DRAW_INSN(Min, I, _, M1, lt, rev)\n+dnl\n+MINMAX_DRAW_INSN(Max, I,  , 0, gt)\n+MINMAX_DRAW_INSN(Max, I,  , 0, gt, rev)\n+MINMAX_DRAW_INSN(Max, I, _, 1, gt)\n+MINMAX_DRAW_INSN(Max, I, _, 1, gt, rev)\n+MINMAX_DRAW_INSN(Max, I, _, M1, ge)\n+MINMAX_DRAW_INSN(Max, I, _, M1, ge, rev)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_ad.m4","additions":81,"deletions":5,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n-\/\/ Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n+\/\/ Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, 2023, Arm Limited. All rights reserved.\n@@ -4162,0 +4162,46 @@\n+\/\/ VectorCastHF2F\n+\n+instruct vcvtHFtoF(vReg dst, vReg src) %{\n+  match(Set dst (VectorCastHF2F src));\n+  format %{ \"vcvtHFtoF $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 4HF to 4F\n+      __ fcvtl($dst$$FloatRegister, __ T4S, $src$$FloatRegister, __ T4H);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_vector_extend($dst$$FloatRegister, __ S, $src$$FloatRegister, __ H);\n+      __ sve_fcvt($dst$$FloatRegister, __ S, ptrue, $dst$$FloatRegister, __ H);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastF2HF\n+\n+instruct vcvtFtoHF_neon(vReg dst, vReg src) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastF2HF src));\n+  format %{ \"vcvtFtoHF_neon $dst, $src\\t# 4F to 4HF\" %}\n+  ins_encode %{\n+    \/\/ 4F to 4HF\n+    __ fcvtn($dst$$FloatRegister, __ T4H, $src$$FloatRegister, __ T4S);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtFtoHF_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastF2HF src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtFtoHF_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fcvt($dst$$FloatRegister, __ H, ptrue, $src$$FloatRegister, __ S);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ H,\n+                         $dst$$FloatRegister, __ S, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n-\/\/ Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n+\/\/ Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, 2023, Arm Limited. All rights reserved.\n@@ -2734,0 +2734,46 @@\n+\/\/ VectorCastHF2F\n+\n+instruct vcvtHFtoF(vReg dst, vReg src) %{\n+  match(Set dst (VectorCastHF2F src));\n+  format %{ \"vcvtHFtoF $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      \/\/ 4HF to 4F\n+      __ fcvtl($dst$$FloatRegister, __ T4S, $src$$FloatRegister, __ T4H);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_vector_extend($dst$$FloatRegister, __ S, $src$$FloatRegister, __ H);\n+      __ sve_fcvt($dst$$FloatRegister, __ S, ptrue, $dst$$FloatRegister, __ H);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ VectorCastF2HF\n+\n+instruct vcvtFtoHF_neon(vReg dst, vReg src) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastF2HF src));\n+  format %{ \"vcvtFtoHF_neon $dst, $src\\t# 4F to 4HF\" %}\n+  ins_encode %{\n+    \/\/ 4F to 4HF\n+    __ fcvtn($dst$$FloatRegister, __ T4H, $src$$FloatRegister, __ T4S);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtFtoHF_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorCastF2HF src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtFtoHF_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fcvt($dst$$FloatRegister, __ H, ptrue, $src$$FloatRegister, __ S);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ H,\n+                         $dst$$FloatRegister, __ S, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -3946,3 +3946,23 @@\n-    guarantee(T_src != H && T_dst != H, \"half-precision unsupported\");\n-    f(0b01100101, 31, 24), f(0b11, 23, 22), f(0b0010, 21, 18);\n-    f(T_dst, 17, 16), f(0b101, 15, 13);\n+    \/\/ The encodings of fields op1 (bits 17-16) and op2 (bits 23-22)\n+    \/\/ depend on T_src and T_dst as given below -\n+    \/\/ +-----+------+---------------------------------------------+\n+    \/\/ | op2 | op1  |             Instruction Details             |\n+    \/\/ +-----+------+---------------------------------------------+\n+    \/\/ |  10 |  01  | FCVT - half-precision to single-precision   |\n+    \/\/ |  11 |  01  | FCVT - half-precision to double-precision   |\n+    \/\/ |  10 |  00  | FCVT - single-precision to half-precision   |\n+    \/\/ |  11 |  11  | FCVT - single-precision to double-precision |\n+    \/\/ |  11 |  00  | FCVT - double-preciison to half-precision   |\n+    \/\/ |  11 |  10  | FCVT - double-precision to single-precision |\n+    \/\/ +-----+------+---+-----------------------------------------+\n+    int op1 = 0b00;\n+    int op2 = (T_src == D || T_dst == D) ? 0b11 : 0b10;\n+    if (T_src == H) {\n+      op1 = 0b01;\n+    } else if (T_dst == S) {\n+      op1 = 0b10;\n+    } else if (T_dst == D) {\n+      op1 = 0b11;\n+    }\n+    f(0b01100101, 31, 24), f(op2, 23, 22), f(0b0010, 21, 18);\n+    f(op1, 17, 16), f(0b101, 15, 13);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,2 +125,2 @@\n-  STATIC_ASSERT(JNIHandles::weak_tag_mask == 1);\n-  __ andr(obj, obj, ~JNIHandles::weak_tag_mask);\n+  STATIC_ASSERT(JNIHandles::tag_mask == 0b11);\n+  __ andr(obj, obj, ~JNIHandles::tag_mask);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1104,0 +1104,1 @@\n+  InlineSkippedInstructionsCounter skipCounter(this);\n@@ -2460,1 +2461,3 @@\n-  Label done, not_weak;\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done, tagged, weak_tagged;\n+\n@@ -2462,0 +2465,7 @@\n+  tst(value, JNIHandles::tag_mask); \/\/ Test for tag.\n+  br(Assembler::NE, tagged);\n+\n+  \/\/ Resolve local handle\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, value, Address(value, 0), tmp1, tmp2);\n+  verify_oop(value);\n+  b(done);\n@@ -2463,2 +2473,3 @@\n-  STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);\n-  tbz(value, 0, not_weak);    \/\/ Test for jweak tag.\n+  bind(tagged);\n+  STATIC_ASSERT(JNIHandles::TypeTag::weak_global == 0b1);\n+  tbnz(value, 0, weak_tagged);    \/\/ Test for weak tag.\n@@ -2466,3 +2477,2 @@\n-  \/\/ Resolve jweak.\n-  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF, value,\n-                 Address(value, -JNIHandles::weak_tag_value), tmp1, tmp2);\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp1, tmp2);\n@@ -2472,3 +2482,4 @@\n-  bind(not_weak);\n-  \/\/ Resolve (untagged) jobject.\n-  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp1, tmp2);\n+  bind(weak_tagged);\n+  \/\/ Resolve jweak.\n+  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,\n+                 value, Address(value, -JNIHandles::TypeTag::weak_global), tmp1, tmp2);\n@@ -2476,0 +2487,24 @@\n+\n+  bind(done);\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value, Register tmp1, Register tmp2) {\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done;\n+\n+  cbz(value, done);           \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    STATIC_ASSERT(JNIHandles::TypeTag::global == 0b10);\n+    Label valid_global_tag;\n+    tbnz(value, 1, valid_global_tag); \/\/ Test for global tag\n+    stop(\"non global jobject using resolve_global_jobject\");\n+    bind(valid_global_tag);\n+  }\n+#endif\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp1, tmp2);\n+  verify_oop(value);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":45,"deletions":10,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -826,0 +826,1 @@\n+  void resolve_global_jobject(Register value, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1233,0 +1233,9 @@\n+    \/\/ handle pending exception thrown by freeze\n+    __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));\n+    Label ok;\n+    __ cbz(rscratch1, ok);\n+    __ leave();\n+    __ lea(rscratch1, RuntimeAddress(StubRoutines::forward_exception_entry()));\n+    __ br(rscratch1);\n+    __ bind(ok);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -6926,6 +6926,1 @@\n-    Label null_jobject;\n-    __ cbz(r0, null_jobject);\n-    DecoratorSet decorators = ACCESS_READ | IN_NATIVE;\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(_masm, decorators, T_OBJECT, r0, Address(r0, 0), rscratch1, rscratch2);\n-    __ bind(null_jobject);\n+    __ resolve_global_jobject(r0, rscratch1, rscratch2);\n@@ -6946,1 +6941,1 @@\n-    int insts_size = 512;\n+    int insts_size = 1024;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -345,4 +345,8 @@\n-    \/\/ Do not auto-enable UseSHA3Intrinsics until it has been fully tested on hardware\n-    \/\/ if (FLAG_IS_DEFAULT(UseSHA3Intrinsics)) {\n-      \/\/ FLAG_SET_DEFAULT(UseSHA3Intrinsics, true);\n-    \/\/ }\n+    \/\/ Auto-enable UseSHA3Intrinsics on hardware with performance benefit.\n+    \/\/ Note that the evaluation of UseSHA3Intrinsics shows better performance\n+    \/\/ on Apple silicon but worse performance on Neoverse V1 and N2.\n+    if (_cpu == CPU_APPLE) {  \/\/ Apple silicon\n+      if (FLAG_IS_DEFAULT(UseSHA3Intrinsics)) {\n+        FLAG_SET_DEFAULT(UseSHA3Intrinsics, true);\n+      }\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,1 +116,1 @@\n-  __ bic(R1, R1, JNIHandles::weak_tag_mask);\n+  __ bic(R1, R1, JNIHandles::tag_mask);\n","filename":"src\/hotspot\/cpu\/arm\/jniFastGetField_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1287,4 +1287,1 @@\n-  Label done, not_weak;\n-  cbz(value, done);             \/\/ Use NULL as-is.\n-  STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);\n-  tbz(value, 0, not_weak);      \/\/ Test for jweak tag.\n+  Label done, tagged, weak_tagged;\n@@ -1292,0 +1289,19 @@\n+  cbz(value, done);           \/\/ Use NULL as-is.\n+  tst(value, JNIHandles::tag_mask); \/\/ Test for tag.\n+  b(tagged, ne);\n+\n+  \/\/ Resolve local handle\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, Address(value, 0), value, tmp1, tmp2, noreg);\n+  verify_oop(value);\n+  b(done);\n+\n+  bind(tagged);\n+  tst(value, JNIHandles::TypeTag::weak_global); \/\/ Test for weak tag.\n+  b(weak_tagged, ne);\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, Address(value, -JNIHandles::TypeTag::global), value, tmp1, tmp2, noreg);\n+  verify_oop(value);\n+  b(done);\n+\n+  bind(weak_tagged);\n@@ -1294,6 +1310,1 @@\n-                 Address(value, -JNIHandles::weak_tag_value), value, tmp1, tmp2, noreg);\n-  b(done);\n-  bind(not_weak);\n-  \/\/ Resolve (untagged) jobject.\n-  access_load_at(T_OBJECT, IN_NATIVE,\n-                 Address(value, 0), value, tmp1, tmp2, noreg);\n+                 Address(value, -JNIHandles::TypeTag::weak_global), value, tmp1, tmp2, noreg);\n@@ -1301,0 +1312,26 @@\n+\n+  bind(done);\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value,\n+                                     Register tmp1,\n+                                     Register tmp2) {\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done;\n+\n+  cbz(value, done);           \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    Label valid_global_tag;\n+    tst(value, JNIHandles::TypeTag::global); \/\/ Test for global tag.\n+    b(valid_global_tag, ne);\n+    stop(\"non global jobject using resolve_global_jobject\");\n+    bind(valid_global_tag);\n+  }\n+#endif\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, Address(value, -JNIHandles::TypeTag::global), value, tmp1, tmp2, noreg);\n+  verify_oop(value);\n+\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":48,"deletions":11,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -359,0 +359,1 @@\n+  void resolve_global_jobject(Register value, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3056,7 +3056,1 @@\n-    Label L_null_jobject;\n-    __ cbz(R0, L_null_jobject);\n-\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(masm, ACCESS_READ | IN_NATIVE, T_OBJECT, R0, Address(R0, 0), Rtemp, R1, R2);\n-\n-    __ bind(L_null_jobject);\n+    __ resolve_global_jobject(R0, Rtemp, R1);\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -380,2 +380,2 @@\n-  __ clrrdi(tmp1, value, JNIHandles::weak_tag_size);\n-  __ andi_(tmp2, value, JNIHandles::weak_tag_mask);\n+  __ clrrdi(tmp1, value, JNIHandles::tag_size);\n+  __ andi_(tmp2, value, JNIHandles::TypeTag::weak_global);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,1 +118,1 @@\n-  Label done, not_weak, verify;\n+  Label done, tagged, weak_tagged, verify;\n@@ -122,2 +122,2 @@\n-  __ andi_(tmp1, value, JNIHandles::weak_tag_mask);\n-  __ beq(CCR0, not_weak);     \/\/ Test for jweak tag.\n+  __ andi_(tmp1, value, JNIHandles::tag_mask);\n+  __ bne(CCR0, tagged);       \/\/ Test for tag.\n@@ -125,4 +125,2 @@\n-  \/\/ Resolve (untagged) jobject.\n-  __ clrrdi(value, value, JNIHandles::weak_tag_size);\n-  load_at(masm, IN_NATIVE | ON_PHANTOM_OOP_REF, T_OBJECT,\n-          value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n+  __ access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, \/\/ no uncoloring\n+                    value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n@@ -131,3 +129,12 @@\n-  __ bind(not_weak);\n-  load_at(masm, IN_NATIVE, T_OBJECT,\n-          value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n+  __ bind(tagged);\n+  __ andi_(tmp1, value, JNIHandles::TypeTag::weak_global);\n+  __ clrrdi(value, value, JNIHandles::tag_size); \/\/ Untag.\n+  __ bne(CCR0, weak_tagged);   \/\/ Test for jweak tag.\n+\n+  __ access_load_at(T_OBJECT, IN_NATIVE,\n+                    value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n+  __ b(verify);\n+\n+  __ bind(weak_tagged);\n+  __ access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,\n+                    value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n@@ -140,0 +147,27 @@\n+\/\/ Generic implementation. GCs can provide an optimized one.\n+void BarrierSetAssembler::resolve_global_jobject(MacroAssembler* masm, Register value,\n+                                          Register tmp1, Register tmp2,\n+                                          MacroAssembler::PreservationLevel preservation_level) {\n+  Label done;\n+\n+  __ cmpdi(CCR0, value, 0);\n+  __ beq(CCR0, done);         \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    Label valid_global_tag;\n+    __ andi_(tmp1, value, JNIHandles::TypeTag::global);\n+    __ bne(CCR0, valid_global_tag);       \/\/ Test for global tag.\n+    __ stop(\"non global jobject using resolve_global_jobject\");\n+    __ bind(valid_global_tag);\n+  }\n+#endif\n+\n+  __ clrrdi(value, value, JNIHandles::tag_size); \/\/ Untag.\n+  __ access_load_at(T_OBJECT, IN_NATIVE,\n+                    value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n+  __ verify_oop(value, FILE_AND_LINE);\n+\n+  __ bind(done);\n+}\n+\n@@ -142,1 +176,1 @@\n-  __ clrrdi(dst, obj, JNIHandles::weak_tag_size);\n+  __ clrrdi(dst, obj, JNIHandles::tag_size);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":46,"deletions":12,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,3 @@\n+  virtual void resolve_global_jobject(MacroAssembler* masm, Register value,\n+                                      Register tmp1, Register tmp2,\n+                                      MacroAssembler::PreservationLevel preservation_level);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-  __ clrrdi(tmp1, value, JNIHandles::weak_tag_size);\n+  __ clrrdi(tmp1, value, JNIHandles::tag_size);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/modRefBarrierSetAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1188,0 +1188,1 @@\n+  InlineSkippedInstructionsCounter skipCounter(this);\n@@ -2894,0 +2895,6 @@\n+void MacroAssembler::resolve_global_jobject(Register value, Register tmp1, Register tmp2,\n+                                     MacroAssembler::PreservationLevel preservation_level) {\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->resolve_global_jobject(this, value, tmp1, tmp2, preservation_level);\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -664,0 +664,2 @@\n+  void resolve_global_jobject(Register value, Register tmp1, Register tmp2,\n+                              MacroAssembler::PreservationLevel preservation_level);\n@@ -701,1 +703,0 @@\n- private:\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1993,0 +1993,13 @@\n+  \/\/ handle pending exception thrown by freeze\n+  Label ok;\n+  __ ld(tmp, in_bytes(JavaThread::pending_exception_offset()), R16_thread);\n+  __ cmpdi(CCR0, tmp, 0);\n+  __ beq(CCR0, ok);\n+  __ pop_frame();\n+  __ ld(R0, _abi0(lr), R1_SP); \/\/ Return pc\n+  __ mtlr(R0);\n+  __ load_const_optimized(tmp, StubRoutines::forward_exception_entry(), R0);\n+  __ mtctr(tmp);\n+  __ bctr();\n+  __ bind(ok);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -4631,7 +4631,1 @@\n-    Label null_jobject;\n-    __ cmpdi(CCR0, R3_RET, 0);\n-    __ beq(CCR0, null_jobject);\n-    DecoratorSet decorators = ACCESS_READ | IN_NATIVE;\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(_masm, decorators, T_OBJECT, R3_RET \/*base*\/, (intptr_t)0, R3_RET \/*dst*\/, tmp1, tmp2, MacroAssembler::PRESERVATION_NONE);\n-    __ bind(null_jobject);\n+    __ resolve_global_jobject(R3_RET, tmp1, tmp2, MacroAssembler::PRESERVATION_NONE);\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,1 +3,2 @@\n- * Copyright (c) 2022, Institute of Software, Chinese Academy of Sciences. All rights reserved.\n+ * Copyright (c) 2022, Institute of Software, Chinese Academy of Sciences.\n+ * All rights reserved.\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -27,0 +27,7 @@\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"code\/vmreg.inline.hpp\"\n+#include \"compiler\/oopMap.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n@@ -28,1 +35,60 @@\n-#include \"utilities\/debug.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/stubCodeGenerator.hpp\"\n+\n+#define __ _masm->\n+\n+class DowncallStubGenerator : public StubCodeGenerator {\n+  BasicType* _signature;\n+  int _num_args;\n+  BasicType _ret_bt;\n+\n+  const ABIDescriptor& _abi;\n+  const GrowableArray<VMStorage>& _input_registers;\n+  const GrowableArray<VMStorage>& _output_registers;\n+\n+  bool _needs_return_buffer;\n+  int _captured_state_mask;\n+\n+  int _frame_complete;\n+  int _frame_size_slots;\n+  OopMapSet* _oop_maps;\n+public:\n+  DowncallStubGenerator(CodeBuffer* buffer,\n+                        BasicType* signature,\n+                        int num_args,\n+                        BasicType ret_bt,\n+                        const ABIDescriptor& abi,\n+                        const GrowableArray<VMStorage>& input_registers,\n+                        const GrowableArray<VMStorage>& output_registers,\n+                        bool needs_return_buffer,\n+                        int captured_state_mask)\n+   : StubCodeGenerator(buffer, PrintMethodHandleStubs),\n+     _signature(signature),\n+     _num_args(num_args),\n+     _ret_bt(ret_bt),\n+     _abi(abi),\n+     _input_registers(input_registers),\n+     _output_registers(output_registers),\n+     _needs_return_buffer(needs_return_buffer),\n+     _captured_state_mask(captured_state_mask),\n+     _frame_complete(0),\n+     _frame_size_slots(0),\n+     _oop_maps(NULL) {\n+  }\n+\n+  void generate();\n+\n+  int frame_complete() const {\n+    return _frame_complete;\n+  }\n+\n+  int framesize() const {\n+    return (_frame_size_slots >> (LogBytesPerWord - LogBytesPerInt));\n+  }\n+\n+  OopMapSet* oop_maps() const {\n+    return _oop_maps;\n+  }\n+};\n+\n+static const int native_invoker_code_size = 1024;\n@@ -38,2 +104,232 @@\n-  Unimplemented();\n-  return nullptr;\n+  int locs_size = 64;\n+  CodeBuffer code(\"nep_invoker_blob\", native_invoker_code_size, locs_size);\n+  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi,\n+                          input_registers, output_registers,\n+                          needs_return_buffer, captured_state_mask);\n+  g.generate();\n+  code.log_section_sizes(\"nep_invoker_blob\");\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(\"nep_invoker_blob\",\n+                                  &code,\n+                                  g.frame_complete(),\n+                                  g.framesize(),\n+                                  g.oop_maps(), false);\n+\n+#ifndef PRODUCT\n+  LogTarget(Trace, foreign, downcall) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    stub->print_on(&ls);\n+  }\n+#endif\n+\n+  return stub;\n+}\n+\n+void DowncallStubGenerator::generate() {\n+  enum layout {\n+    fp_off,\n+    fp_off2,\n+    ra_off,\n+    ra_off2,\n+    framesize \/\/ inclusive of return address\n+    \/\/ The following are also computed dynamically:\n+    \/\/ spill area for return value\n+    \/\/ out arg area (e.g. for stack args)\n+  };\n+\n+  VMStorage shuffle_reg = as_VMStorage(x9);\n+  JavaCallingConvention in_conv;\n+  NativeCallingConvention out_conv(_input_registers);\n+  ArgumentShuffle arg_shuffle(_signature, _num_args, _signature, _num_args, &in_conv, &out_conv, shuffle_reg);\n+\n+#ifndef PRODUCT\n+  LogTarget(Trace, foreign, downcall) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    arg_shuffle.print_on(&ls);\n+  }\n+#endif\n+\n+  int allocated_frame_size = 0;\n+  assert(_abi._shadow_space_bytes == 0, \"not expecting shadow space on RISCV64\");\n+  allocated_frame_size += arg_shuffle.out_arg_bytes();\n+\n+  bool should_save_return_value = !_needs_return_buffer;\n+  RegSpiller out_reg_spiller(_output_registers);\n+  int spill_offset = -1;\n+\n+  if (should_save_return_value) {\n+    spill_offset = 0;\n+    \/\/ spill area can be shared with shadow space and out args,\n+    \/\/ since they are only used before the call,\n+    \/\/ and spill area is only used after.\n+    allocated_frame_size = out_reg_spiller.spill_size_bytes() > allocated_frame_size\n+                           ? out_reg_spiller.spill_size_bytes()\n+                           : allocated_frame_size;\n+  }\n+\n+  StubLocations locs;\n+  locs.set(StubLocations::TARGET_ADDRESS, _abi._scratch1);\n+  if (_needs_return_buffer) {\n+    locs.set_frame_data(StubLocations::RETURN_BUFFER, allocated_frame_size);\n+    allocated_frame_size += BytesPerWord; \/\/ for address spill\n+  }\n+  if (_captured_state_mask != 0) {\n+    locs.set_frame_data(StubLocations::CAPTURED_STATE_BUFFER, allocated_frame_size);\n+    allocated_frame_size += BytesPerWord;\n+  }\n+\n+  allocated_frame_size = align_up(allocated_frame_size, 16);\n+  \/\/ _frame_size_slots is in 32-bit stack slots:\n+  _frame_size_slots += framesize + (allocated_frame_size >> LogBytesPerInt);\n+  assert(is_even(_frame_size_slots \/ 2), \"sp not 16-byte aligned\");\n+\n+  _oop_maps = new OopMapSet();\n+  address start = __ pc();\n+\n+  __ enter();\n+\n+  \/\/ ra and fp are already in place\n+  __ sub(sp, sp, allocated_frame_size); \/\/ prolog\n+\n+  _frame_complete = __ pc() - start; \/\/ frame build complete.\n+\n+  __ block_comment(\"{ thread java2native\");\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, fp, the_pc, t0);\n+  OopMap* map = new OopMap(_frame_size_slots, 0);\n+  _oop_maps->add_gc_map(the_pc - start, map);\n+\n+  \/\/ State transition\n+  __ mv(t0, _thread_in_native);\n+  __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n+  __ sw(t0, Address(xthread, JavaThread::thread_state_offset()));\n+  __ block_comment(\"} thread java2native\");\n+\n+  __ block_comment(\"{ argument shuffle\");\n+  arg_shuffle.generate(_masm, shuffle_reg, 0, _abi._shadow_space_bytes, locs);\n+  __ block_comment(\"} argument shuffle\");\n+\n+  __ jalr(as_Register(locs.get(StubLocations::TARGET_ADDRESS)));\n+  \/\/ this call is assumed not to have killed xthread\n+\n+  if (_needs_return_buffer) {\n+    \/\/ when use return buffer, copy content of return registers to return buffer,\n+    \/\/ then operations created in BoxBindingCalculator will be operated.\n+    __ ld(t0, Address(sp, locs.data_offset(StubLocations::RETURN_BUFFER)));\n+    int offset = 0;\n+    for (int i = 0; i < _output_registers.length(); i++) {\n+      VMStorage reg = _output_registers.at(i);\n+      if (reg.type() == StorageType::INTEGER) {\n+        __ sd(as_Register(reg), Address(t0, offset));\n+        offset += 8;\n+      } else if (reg.type() == StorageType::FLOAT) {\n+        __ fsd(as_FloatRegister(reg), Address(t0, offset));\n+        offset += 8;\n+      } else {\n+        ShouldNotReachHere();\n+      }\n+    }\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  if (_captured_state_mask != 0) {\n+    __ block_comment(\"{ save thread local\");\n+\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_offset);\n+    }\n+\n+    __ ld(c_rarg0, Address(sp, locs.data_offset(StubLocations::CAPTURED_STATE_BUFFER)));\n+    __ mv(c_rarg1, _captured_state_mask);\n+    __ rt_call(CAST_FROM_FN_PTR(address, DowncallLinker::capture_state));\n+\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_offset);\n+    }\n+\n+    __ block_comment(\"} save thread local\");\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ thread native2java\");\n+  __ mv(t0, _thread_in_native_trans);\n+  __ sw(t0, Address(xthread, JavaThread::thread_state_offset()));\n+\n+  \/\/ Force this write out before the read below\n+  __ membar(MacroAssembler::AnyAny);\n+\n+  Label L_after_safepoint_poll;\n+  Label L_safepoint_poll_slow_path;\n+  __ safepoint_poll(L_safepoint_poll_slow_path, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/);\n+  __ lwu(t0, Address(xthread, JavaThread::suspend_flags_offset()));\n+  __ bnez(t0, L_safepoint_poll_slow_path);\n+\n+  __ bind(L_after_safepoint_poll);\n+\n+  __ mv(t0, _thread_in_Java);\n+  __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n+  __ sw(t0, Address(xthread, JavaThread::thread_state_offset()));\n+\n+  __ block_comment(\"reguard stack check\");\n+  Label L_reguard;\n+  Label L_after_reguard;\n+  __ lbu(t0, Address(xthread, JavaThread::stack_guard_state_offset()));\n+  __ mv(t1, StackOverflow::stack_guard_yellow_reserved_disabled);\n+  __ beq(t0, t1, L_reguard);\n+  __ bind(L_after_reguard);\n+\n+  __ reset_last_Java_frame(true);\n+  __ block_comment(\"} thread native2java\");\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret();\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n+  __ bind(L_safepoint_poll_slow_path);\n+\n+  if (should_save_return_value) {\n+    \/\/ Need to save the native result registers around any runtime calls.\n+    out_reg_spiller.generate_spill(_masm, spill_offset);\n+  }\n+\n+  __ mv(c_rarg0, xthread);\n+  assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n+  __ rt_call(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans));\n+\n+  if (should_save_return_value) {\n+    out_reg_spiller.generate_fill(_masm, spill_offset);\n+  }\n+  __ j(L_after_safepoint_poll);\n+  __ block_comment(\"} L_safepoint_poll_slow_path\");\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ L_reguard\");\n+  __ bind(L_reguard);\n+\n+  if (should_save_return_value) {\n+    \/\/ Need to save the native result registers around any runtime calls.\n+    out_reg_spiller.generate_spill(_masm, spill_offset);\n+  }\n+\n+  __ rt_call(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));\n+\n+  if (should_save_return_value) {\n+    out_reg_spiller.generate_fill(_masm, spill_offset);\n+  }\n+\n+  __ j(L_after_reguard);\n+  __ block_comment(\"} L_reguard\");\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ flush();\n","filename":"src\/hotspot\/cpu\/riscv\/downcallLinker_riscv.cpp","additions":300,"deletions":4,"binary":false,"changes":304,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -27,1 +27,5 @@\n-#include \"code\/vmreg.hpp\"\n+#include \"code\/vmreg.inline.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n+#include \"oops\/typeArrayOop.inline.hpp\"\n+#include \"oops\/oopCast.inline.hpp\"\n@@ -29,1 +33,3 @@\n-#include \"utilities\/debug.hpp\"\n+#include \"prims\/foreignGlobals.inline.hpp\"\n+#include \"prims\/vmstorage.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -31,1 +37,9 @@\n-class MacroAssembler;\n+bool ABIDescriptor::is_volatile_reg(Register reg) const {\n+  return _integer_argument_registers.contains(reg)\n+         || _integer_additional_volatile_registers.contains(reg);\n+}\n+\n+bool ABIDescriptor::is_volatile_reg(FloatRegister reg) const {\n+  return _float_argument_registers.contains(reg)\n+         || _float_additional_volatile_registers.contains(reg);\n+}\n@@ -38,2 +52,22 @@\n-  ShouldNotCallThis();\n-  return {};\n+  oop abi_oop = JNIHandles::resolve_non_null(jabi);\n+  ABIDescriptor abi;\n+\n+  objArrayOop inputStorage = jdk_internal_foreign_abi_ABIDescriptor::inputStorage(abi_oop);\n+  parse_register_array(inputStorage, StorageType::INTEGER, abi._integer_argument_registers, as_Register);\n+  parse_register_array(inputStorage, StorageType::FLOAT, abi._float_argument_registers, as_FloatRegister);\n+\n+  objArrayOop outputStorage = jdk_internal_foreign_abi_ABIDescriptor::outputStorage(abi_oop);\n+  parse_register_array(outputStorage, StorageType::INTEGER, abi._integer_return_registers, as_Register);\n+  parse_register_array(outputStorage, StorageType::FLOAT, abi._float_return_registers, as_FloatRegister);\n+\n+  objArrayOop volatileStorage = jdk_internal_foreign_abi_ABIDescriptor::volatileStorage(abi_oop);\n+  parse_register_array(volatileStorage, StorageType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n+  parse_register_array(volatileStorage, StorageType::FLOAT, abi._float_additional_volatile_registers, as_FloatRegister);\n+\n+  abi._stack_alignment_bytes = jdk_internal_foreign_abi_ABIDescriptor::stackAlignment(abi_oop);\n+  abi._shadow_space_bytes = jdk_internal_foreign_abi_ABIDescriptor::shadowSpace(abi_oop);\n+\n+  abi._scratch1 = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::scratch1(abi_oop));\n+  abi._scratch2 = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::scratch2(abi_oop));\n+\n+  return abi;\n@@ -43,2 +77,4 @@\n-  Unimplemented();\n-  return -1;\n+  if (reg.type() == StorageType::INTEGER || reg.type() == StorageType::FLOAT) {\n+    return 8;\n+  }\n+  return 0; \/\/ stack and BAD\n@@ -48,1 +84,7 @@\n-  Unimplemented();\n+  if (reg.type() == StorageType::INTEGER) {\n+    masm->sd(as_Register(reg), Address(sp, offset));\n+  } else if (reg.type() == StorageType::FLOAT) {\n+    masm->fsd(as_FloatRegister(reg), Address(sp, offset));\n+  } else {\n+    \/\/ stack and BAD\n+  }\n@@ -52,1 +94,70 @@\n-  Unimplemented();\n+  if (reg.type() == StorageType::INTEGER) {\n+    masm->ld(as_Register(reg), Address(sp, offset));\n+  } else if (reg.type() == StorageType::FLOAT) {\n+    masm->fld(as_FloatRegister(reg), Address(sp, offset));\n+  } else {\n+    \/\/ stack and BAD\n+  }\n+}\n+\n+static constexpr int FP_BIAS = 0; \/\/ sender_sp_offset is 0 on RISCV\n+\n+static void move_reg64(MacroAssembler* masm, int out_stk_bias,\n+                       Register from_reg, VMStorage to_reg) {\n+  int out_bias = 0;\n+  switch (to_reg.type()) {\n+    case StorageType::INTEGER:\n+      assert(to_reg.segment_mask() == REG64_MASK, \"only moves to 64-bit integer registers supported\");\n+      masm->mv(as_Register(to_reg), from_reg);\n+      break;\n+    case StorageType::STACK:\n+      out_bias = out_stk_bias;\n+    case StorageType::FRAME_DATA: {\n+      Address dest(sp, to_reg.offset() + out_bias);\n+      masm->sd(from_reg, dest);\n+    } break;\n+    default: ShouldNotReachHere();\n+  }\n+}\n+\n+static void move_stack(MacroAssembler* masm, Register tmp_reg, int in_stk_bias, int out_stk_bias,\n+                       VMStorage from_reg, VMStorage to_reg) {\n+  Address from_addr(fp, FP_BIAS + from_reg.offset() + in_stk_bias);\n+  int out_bias = 0;\n+  switch (to_reg.type()) {\n+    case StorageType::INTEGER:\n+      assert(to_reg.segment_mask() == REG64_MASK, \"only moves to 64-bit integer registers supported\");\n+      masm->ld(as_Register(to_reg), from_addr);\n+      break;\n+    case StorageType::FLOAT:\n+      assert(to_reg.segment_mask() == FP_MASK, \"only moves to floating-point registers supported\");\n+      masm->fld(as_FloatRegister(to_reg), from_addr);\n+      break;\n+    case StorageType::STACK:\n+      out_bias = out_stk_bias;\n+    case StorageType::FRAME_DATA: {\n+      masm->ld(tmp_reg, from_addr);\n+      Address dest(sp, to_reg.offset() + out_bias);\n+      masm->sd(tmp_reg, dest); break;\n+    } break;\n+    default: ShouldNotReachHere();\n+  }\n+}\n+\n+static void move_fp(MacroAssembler* masm, int out_stk_bias,\n+                    FloatRegister from_reg, VMStorage to_reg) {\n+  switch (to_reg.type()) {\n+    case StorageType::INTEGER:\n+      assert(to_reg.segment_mask() == REG64_MASK, \"only moves to 64-bit integer registers supported\");\n+      masm->fmv_x_d(as_Register(to_reg), from_reg);\n+      break;\n+    case StorageType::FLOAT:\n+      assert(to_reg.segment_mask() == FP_MASK, \"only moves to floating-point registers supported\");\n+      masm->fmv_d(as_FloatRegister(to_reg), from_reg); break;\n+      break;\n+    case StorageType::STACK: {\n+      Address dest(sp, to_reg.offset() + out_stk_bias);\n+      masm->fsd(from_reg, dest); break;\n+    } break;\n+    default: ShouldNotReachHere();\n+  }\n@@ -56,1 +167,29 @@\n-  Unimplemented();\n+  Register tmp_reg = as_Register(tmp);\n+  for (int i = 0; i < _moves.length(); i++) {\n+    Move move = _moves.at(i);\n+    VMStorage from_reg = move.from;\n+    VMStorage to_reg   = move.to;\n+\n+    \/\/ replace any placeholders\n+    if (from_reg.type() == StorageType::PLACEHOLDER) {\n+      from_reg = locs.get(from_reg);\n+    }\n+    if (to_reg.type() == StorageType::PLACEHOLDER) {\n+      to_reg = locs.get(to_reg);\n+    }\n+\n+    switch (from_reg.type()) {\n+      case StorageType::INTEGER:\n+        assert(from_reg.segment_mask() == REG64_MASK, \"only 64-bit integer register supported\");\n+        move_reg64(masm, out_stk_bias, as_Register(from_reg), to_reg);\n+        break;\n+      case StorageType::FLOAT:\n+        assert(from_reg.segment_mask() == FP_MASK, \"only floating-point register supported\");\n+        move_fp(masm, out_stk_bias, as_FloatRegister(from_reg), to_reg);\n+        break;\n+      case StorageType::STACK:\n+        move_stack(masm, tmp_reg, in_stk_bias, out_stk_bias, from_reg, to_reg);\n+        break;\n+      default: ShouldNotReachHere();\n+    }\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/foreignGlobals_riscv.cpp","additions":150,"deletions":11,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -29,1 +29,22 @@\n-class ABIDescriptor {};\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+struct ABIDescriptor {\n+  GrowableArray<Register> _integer_argument_registers;\n+  GrowableArray<Register> _integer_return_registers;\n+\n+  GrowableArray<FloatRegister> _float_argument_registers;\n+  GrowableArray<FloatRegister> _float_return_registers;\n+\n+  GrowableArray<Register> _integer_additional_volatile_registers;\n+  GrowableArray<FloatRegister> _float_additional_volatile_registers;\n+\n+  int32_t _stack_alignment_bytes;\n+  int32_t _shadow_space_bytes;\n+\n+  VMStorage _scratch1;\n+  VMStorage _scratch2;\n+\n+  bool is_volatile_reg(Register reg) const;\n+  bool is_volatile_reg(FloatRegister reg) const;\n+};\n","filename":"src\/hotspot\/cpu\/riscv\/foreignGlobals_riscv.hpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -349,2 +349,4 @@\n-  ShouldNotCallThis();\n-  return nullptr;\n+  assert(frame.is_upcall_stub_frame(), \"wrong frame\");\n+  \/\/ need unextended_sp here, since normal sp is wrong for interpreter callees\n+  return reinterpret_cast<UpcallStub::FrameData*>(\n+          reinterpret_cast<address>(frame.unextended_sp()) + in_bytes(_frame_data_offset));\n@@ -354,2 +356,4 @@\n-  ShouldNotCallThis();\n-  return false;\n+  assert(is_upcall_stub_frame(), \"must be optimzed entry frame\");\n+  UpcallStub* blob = _cb->as_upcall_stub();\n+  JavaFrameAnchor* jfa = blob->jfa_for_frame(*this);\n+  return jfa->last_Java_sp() == NULL;\n@@ -359,2 +363,15 @@\n-  ShouldNotCallThis();\n-  return {};\n+  assert(map != NULL, \"map must be set\");\n+  UpcallStub* blob = _cb->as_upcall_stub();\n+  \/\/ Java frame called from C; skip all C frames and return top C\n+  \/\/ frame of that chunk as the sender\n+  JavaFrameAnchor* jfa = blob->jfa_for_frame(*this);\n+  assert(!upcall_stub_frame_is_first(), \"must have a frame anchor to go back to\");\n+  assert(jfa->last_Java_sp() > sp(), \"must be above this frame on stack\");\n+  \/\/ Since we are walking the stack now this nested anchor is obviously walkable\n+  \/\/ even if it wasn't when it was stacked.\n+  jfa->make_walkable();\n+  map->clear();\n+  assert(map->include_argument_oops(), \"should be set by clear\");\n+  frame fr(jfa->last_Java_sp(), jfa->last_Java_fp(), jfa->last_Java_pc());\n+\n+  return fr;\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -387,1 +387,3 @@\n-\n+  if (is_upcall_stub_frame()) {\n+    return sender_for_upcall_stub_frame(map);\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.inline.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,2 +125,2 @@\n-  STATIC_ASSERT(JNIHandles::weak_tag_mask == 1);\n-  __ andi(obj, obj, ~JNIHandles::weak_tag_mask);\n+  STATIC_ASSERT(JNIHandles::tag_mask == 3);\n+  __ andi(obj, obj, ~JNIHandles::tag_mask);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -559,1 +559,3 @@\n-  Label done, not_weak;\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done, tagged, weak_tagged;\n+\n@@ -561,0 +563,3 @@\n+  \/\/ Test for tag.\n+  andi(t0, value, JNIHandles::tag_mask);\n+  bnez(t0, tagged);\n@@ -562,0 +567,6 @@\n+  \/\/ Resolve local handle\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, value, Address(value, 0), tmp1, tmp2);\n+  verify_oop(value);\n+  j(done);\n+\n+  bind(tagged);\n@@ -563,2 +574,7 @@\n-  andi(t0, value, JNIHandles::weak_tag_mask);\n-  beqz(t0, not_weak);\n+  andi(t0, value, JNIHandles::TypeTag::weak_global);\n+  bnez(t0, weak_tagged);\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value,\n+                 Address(value, -JNIHandles::TypeTag::global), tmp1, tmp2);\n+  j(done);\n@@ -566,0 +582,1 @@\n+  bind(weak_tagged);\n@@ -568,1 +585,1 @@\n-                 Address(value, -JNIHandles::weak_tag_value), tmp1, tmp2);\n+                 Address(value, -JNIHandles::TypeTag::weak_global), tmp1, tmp2);\n@@ -570,1 +587,0 @@\n-  j(done);\n@@ -572,3 +588,22 @@\n-  bind(not_weak);\n-  \/\/ Resolve (untagged) jobject.\n-  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp1, tmp2);\n+  bind(done);\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value, Register tmp1, Register tmp2) {\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done;\n+\n+  beqz(value, done);           \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    Label valid_global_tag;\n+    andi(t0, value, JNIHandles::TypeTag::global); \/\/ Test for global tag.\n+    bnez(t0, valid_global_tag);\n+    stop(\"non global jobject using resolve_global_jobject\");\n+    bind(valid_global_tag);\n+  }\n+#endif\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value,\n+                 Address(value, -JNIHandles::TypeTag::global), tmp1, tmp2);\n@@ -576,0 +611,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":45,"deletions":9,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -184,0 +184,1 @@\n+  void resolve_global_jobject(Register value, Register tmp1, Register tmp2);\n@@ -911,1 +912,1 @@\n-          int32_t offset= 0;                                                                       \\\n+          int32_t offset = 0;                                                                      \\\n@@ -1316,1 +1317,0 @@\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -258,1 +258,10 @@\n-  __ stop(\"Should not reach here\");\n+  assert_different_registers(nep_reg, temp_target);\n+  assert(nep_reg != noreg, \"required register\");\n+\n+  \/\/ Load the invoker, as NEP -> .invoker\n+  __ verify_oop(nep_reg);\n+  __ access_load_at(T_ADDRESS, IN_HEAP, temp_target,\n+                    Address(nep_reg, NONZERO(jdk_internal_foreign_abi_NativeEntryPoint::downcall_stub_address_offset_in_bytes())),\n+                    noreg, noreg);\n+\n+  __ jr(temp_target);\n@@ -273,1 +282,1 @@\n-    assert(receiver_reg == (iid == vmIntrinsics::_linkToStatic ? noreg : j_rarg0), \"only valid assignment\");\n+    assert(receiver_reg == (iid == vmIntrinsics::_linkToStatic || iid == vmIntrinsics::_linkToNative ? noreg : j_rarg0), \"only valid assignment\");\n","filename":"src\/hotspot\/cpu\/riscv\/methodHandles_riscv.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -73,3 +73,3 @@\n-    int raw_encoding() const { return this - first(); }\n-    int encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-    bool is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int     encoding() const { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    constexpr bool    is_valid() const { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -107,1 +107,1 @@\n-  const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n+  constexpr const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n@@ -190,3 +190,3 @@\n-    int raw_encoding() const { return this - first(); }\n-    int encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-    bool is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int     encoding() const { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    constexpr bool    is_valid() const { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -222,1 +222,1 @@\n-  const FloatRegisterImpl* operator->() const { return FloatRegisterImpl::first() + _encoding; }\n+  constexpr const FloatRegisterImpl* operator->() const { return FloatRegisterImpl::first() + _encoding; }\n@@ -300,3 +300,3 @@\n-    int raw_encoding() const { return this - first(); }\n-    int encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n-    bool is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+    constexpr int raw_encoding() const { return this - first(); }\n+    constexpr int     encoding() const { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    constexpr bool    is_valid() const { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -317,1 +317,1 @@\n-  const VectorRegisterImpl* operator->() const { return VectorRegisterImpl::first() + _encoding; }\n+  constexpr const VectorRegisterImpl* operator->() const { return VectorRegisterImpl::first() + _encoding; }\n","filename":"src\/hotspot\/cpu\/riscv\/register_riscv.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -943,1 +943,1 @@\n-  int_def BRANCH_COST          (  100,  1 * DEFAULT_COST);          \/\/ branch, jmp, call\n+  int_def BRANCH_COST          (  200,  2 * DEFAULT_COST);          \/\/ branch, jmp, call\n@@ -3820,1 +3820,1 @@\n-    greater(0x1, \"gt\");\n+    greater(0x1, \"gtu\");\n@@ -3822,1 +3822,1 @@\n-    less(0x3, \"lt\");\n+    less(0x3, \"ltu\");\n@@ -3824,1 +3824,1 @@\n-    less_equal(0x5, \"le\");\n+    less_equal(0x5, \"leu\");\n@@ -3826,1 +3826,1 @@\n-    greater_equal(0x7, \"ge\");\n+    greater_equal(0x7, \"geu\");\n@@ -3842,1 +3842,1 @@\n-    greater(0x1, \"gt\");\n+    greater(0x1, \"gtu\");\n@@ -3844,1 +3844,1 @@\n-    less(0x3, \"lt\");\n+    less(0x3, \"ltu\");\n@@ -3846,1 +3846,1 @@\n-    less_equal(0x5, \"le\");\n+    less_equal(0x5, \"leu\");\n@@ -3848,1 +3848,1 @@\n-    greater_equal(0x7, \"ge\");\n+    greater_equal(0x7, \"geu\");\n@@ -4376,1 +4376,1 @@\n-\/\/------- Store pipeline operations -----------------------\n+\/\/------- Control transfer pipeline operations ------------\n@@ -8660,0 +8660,90 @@\n+instruct minI_reg_reg(iRegINoSp dst, iRegI src)\n+%{\n+  match(Set dst (MinI dst src));\n+\n+  ins_cost(BRANCH_COST + ALU_COST);\n+  format %{\n+    \"ble $dst, $src, skip\\t#@minI_reg_reg\\n\\t\"\n+    \"mv  $dst, $src\\n\\t\"\n+    \"skip:\"\n+  %}\n+\n+  ins_encode %{\n+    Label Lskip;\n+    __ ble(as_Register($dst$$reg), as_Register($src$$reg), Lskip);\n+    __ mv(as_Register($dst$$reg), as_Register($src$$reg));\n+    __ bind(Lskip);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct maxI_reg_reg(iRegINoSp dst, iRegI src)\n+%{\n+  match(Set dst (MaxI dst src));\n+\n+  ins_cost(BRANCH_COST + ALU_COST);\n+  format %{\n+    \"bge $dst, $src, skip\\t#@maxI_reg_reg\\n\\t\"\n+    \"mv  $dst, $src\\n\\t\"\n+    \"skip:\"\n+  %}\n+\n+  ins_encode %{\n+    Label Lskip;\n+    __ bge(as_Register($dst$$reg), as_Register($src$$reg), Lskip);\n+    __ mv(as_Register($dst$$reg), as_Register($src$$reg));\n+    __ bind(Lskip);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+\/\/ special case for comparing with zero\n+\/\/ n.b. this is selected in preference to the rule above because it\n+\/\/ avoids loading constant 0 into a source register\n+\n+instruct minI_reg_zero(iRegINoSp dst, immI0 zero)\n+%{\n+  match(Set dst (MinI dst zero));\n+  match(Set dst (MinI zero dst));\n+\n+  ins_cost(BRANCH_COST + ALU_COST);\n+  format %{\n+    \"blez $dst, skip\\t#@minI_reg_zero\\n\\t\"\n+    \"mv   $dst, zr\\n\\t\"\n+    \"skip:\"\n+  %}\n+\n+  ins_encode %{\n+    Label Lskip;\n+    __ blez(as_Register($dst$$reg), Lskip);\n+    __ mv(as_Register($dst$$reg), zr);\n+    __ bind(Lskip);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct maxI_reg_zero(iRegINoSp dst, immI0 zero)\n+%{\n+  match(Set dst (MaxI dst zero));\n+  match(Set dst (MaxI zero dst));\n+\n+  ins_cost(BRANCH_COST + ALU_COST);\n+  format %{\n+    \"bgez $dst, skip\\t#@maxI_reg_zero\\n\\t\"\n+    \"mv   $dst, zr\\n\\t\"\n+    \"skip:\"\n+  %}\n+\n+  ins_encode %{\n+    Label Lskip;\n+    __ bgez(as_Register($dst$$reg), Lskip);\n+    __ mv(as_Register($dst$$reg), zr);\n+    __ bind(Lskip);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n@@ -8686,1 +8776,1 @@\n-  ins_pipe(ialu_reg_reg);\n+  ins_pipe(pipe_class_compare);\n@@ -8716,1 +8806,1 @@\n-  ins_pipe(ialu_reg_reg);\n+  ins_pipe(pipe_class_compare);\n@@ -9893,4 +9983,2 @@\n-             \"bneg$cop $op1, $op2, skip\\t#@cmovI_cmpI\\n\\t\"\n-             \"mv $dst, $src\\n\\t\"\n-             \"skip:\"\n-         %}\n+    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpI\\n\\t\"\n+  %}\n@@ -9904,1 +9992,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_compare);\n@@ -9912,4 +10000,2 @@\n-             \"bneg$cop $op1, $op2, skip\\t#@cmovI_cmpU\\n\\t\"\n-             \"mv $dst, $src\\n\\t\"\n-             \"skip:\"\n-         %}\n+    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpU\\n\\t\"\n+  %}\n@@ -9923,1 +10009,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_compare);\n@@ -9931,4 +10017,2 @@\n-             \"bneg$cop $op1, $op2, skip\\t#@cmovI_cmpL\\n\\t\"\n-             \"mv $dst, $src\\n\\t\"\n-             \"skip:\"\n-         %}\n+    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpL\\n\\t\"\n+  %}\n@@ -9942,1 +10026,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_compare);\n@@ -9950,4 +10034,2 @@\n-             \"bneg$cop $op1, $op2, skip\\t#@cmovL_cmpL\\n\\t\"\n-             \"mv $dst, $src\\n\\t\"\n-             \"skip:\"\n-         %}\n+    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpL\\n\\t\"\n+  %}\n@@ -9961,1 +10043,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_compare);\n@@ -9969,4 +10051,2 @@\n-             \"bneg$cop $op1, $op2, skip\\t#@cmovL_cmpUL\\n\\t\"\n-             \"mv $dst, $src\\n\\t\"\n-             \"skip:\"\n-         %}\n+    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpUL\\n\\t\"\n+  %}\n@@ -9980,1 +10060,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_compare);\n@@ -9986,0 +10066,1 @@\n+\n@@ -9987,4 +10068,2 @@\n-             \"bneg$cop $op1, $op2\\t#@cmovI_cmpUL\\n\\t\"\n-             \"mv $dst, $src\\n\\t\"\n-             \"skip:\"\n-         %}\n+    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpUL\\n\\t\"\n+  %}\n@@ -9998,1 +10077,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_compare);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":121,"deletions":42,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -1110,0 +1110,9 @@\n+  \/\/ handle pending exception thrown by freeze\n+  __ ld(t0, Address(xthread, in_bytes(Thread::pending_exception_offset())));\n+  Label ok;\n+  __ beqz(t0, ok);\n+  __ leave();\n+  __ la(t0, RuntimeAddress(StubRoutines::forward_exception_entry()));\n+  __ jr(t0);\n+  __ bind(ok);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3982,6 +3982,1 @@\n-    Label null_jobject;\n-    __ beqz(x10, null_jobject);\n-    DecoratorSet decorators = ACCESS_READ | IN_NATIVE;\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(_masm, decorators, T_OBJECT, x10, Address(x10, 0), t0, t1);\n-    __ bind(null_jobject);\n+    __ resolve_global_jobject(x10, t0, t1);\n@@ -3989,1 +3984,0 @@\n-\n@@ -4015,0 +4009,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -27,0 +27,3 @@\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n@@ -28,1 +31,85 @@\n-#include \"utilities\/debug.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/signature.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"vmreg_riscv.inline.hpp\"\n+\n+#define __ _masm->\n+\n+\/\/ for callee saved regs, according to the caller's ABI\n+static int compute_reg_save_area_size(const ABIDescriptor& abi) {\n+  int size = 0;\n+  for (int i = 0; i < Register::number_of_registers; i++) {\n+    Register reg = as_Register(i);\n+    if (reg == fp || reg == sp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      size += 8; \/\/ bytes\n+    }\n+  }\n+\n+  for (int i = 0; i < FloatRegister::number_of_registers; i++) {\n+    FloatRegister reg = as_FloatRegister(i);\n+    if (!abi.is_volatile_reg(reg)) {\n+      size += 8; \/\/ bytes\n+    }\n+  }\n+\n+  return size;\n+}\n+\n+static void preserve_callee_saved_registers(MacroAssembler* _masm, const ABIDescriptor& abi, int reg_save_area_offset) {\n+  \/\/ 1. iterate all registers in the architecture\n+  \/\/     - check if they are volatile or not for the given abi\n+  \/\/     - if NOT, we need to save it here\n+\n+  int offset = reg_save_area_offset;\n+\n+  __ block_comment(\"{ preserve_callee_saved_regs \");\n+  for (int i = 0; i < Register::number_of_registers; i++) {\n+    Register reg = as_Register(i);\n+    if (reg == fp || reg == sp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      __ sd(reg, Address(sp, offset));\n+      offset += 8;\n+    }\n+  }\n+\n+  for (int i = 0; i < FloatRegister::number_of_registers; i++) {\n+    FloatRegister reg = as_FloatRegister(i);\n+    if (!abi.is_volatile_reg(reg)) {\n+      __ fsd(reg, Address(sp, offset));\n+      offset += 8;\n+    }\n+  }\n+\n+  __ block_comment(\"} preserve_callee_saved_regs \");\n+}\n+\n+static void restore_callee_saved_registers(MacroAssembler* _masm, const ABIDescriptor& abi, int reg_save_area_offset) {\n+  \/\/ 1. iterate all registers in the architecture\n+  \/\/     - check if they are volatile or not for the given abi\n+  \/\/     - if NOT, we need to restore it here\n+\n+  int offset = reg_save_area_offset;\n+\n+  __ block_comment(\"{ restore_callee_saved_regs \");\n+  for (int i = 0; i < Register::number_of_registers; i++) {\n+    Register reg = as_Register(i);\n+    if (reg == fp || reg == sp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      __ ld(reg, Address(sp, offset));\n+      offset += 8;\n+    }\n+  }\n+\n+  for (int i = 0; i < FloatRegister::number_of_registers; i++) {\n+    FloatRegister reg = as_FloatRegister(i);\n+    if (!abi.is_volatile_reg(reg)) {\n+      __ fld(reg, Address(sp, offset));\n+      offset += 8;\n+    }\n+  }\n+\n+  __ block_comment(\"} restore_callee_saved_regs \");\n+}\n@@ -36,2 +123,238 @@\n-  ShouldNotCallThis();\n-  return nullptr;\n+\n+  ResourceMark rm;\n+  const ABIDescriptor abi = ForeignGlobals::parse_abi_descriptor(jabi);\n+  const CallRegs call_regs = ForeignGlobals::parse_call_regs(jconv);\n+  CodeBuffer buffer(\"upcall_stub\", \/* code_size = *\/ 2048, \/* locs_size = *\/ 1024);\n+\n+  Register shuffle_reg = x9;\n+  JavaCallingConvention out_conv;\n+  NativeCallingConvention in_conv(call_regs._arg_regs);\n+  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, as_VMStorage(shuffle_reg));\n+  int preserved_bytes = SharedRuntime::out_preserve_stack_slots() * VMRegImpl::stack_slot_size;\n+  int stack_bytes = preserved_bytes + arg_shuffle.out_arg_bytes();\n+  int out_arg_area = align_up(stack_bytes , StackAlignmentInBytes);\n+\n+#ifndef PRODUCT\n+  LogTarget(Trace, foreign, upcall) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    arg_shuffle.print_on(&ls);\n+  }\n+#endif\n+\n+  \/\/ out_arg_area (for stack arguments) doubles as shadow space for native calls.\n+  \/\/ make sure it is big enough.\n+  if (out_arg_area < frame::arg_reg_save_area_bytes) {\n+    out_arg_area = frame::arg_reg_save_area_bytes;\n+  }\n+\n+  int reg_save_area_size = compute_reg_save_area_size(abi);\n+  RegSpiller arg_spiller(call_regs._arg_regs);\n+  RegSpiller result_spiller(call_regs._ret_regs);\n+\n+  int shuffle_area_offset   = 0;\n+  int res_save_area_offset  = shuffle_area_offset   + out_arg_area;\n+  int arg_save_area_offset  = res_save_area_offset  + result_spiller.spill_size_bytes();\n+  int reg_save_area_offset  = arg_save_area_offset  + arg_spiller.spill_size_bytes();\n+  int frame_data_offset     = reg_save_area_offset  + reg_save_area_size;\n+  int frame_bottom_offset   = frame_data_offset     + sizeof(UpcallStub::FrameData);\n+\n+  StubLocations locs;\n+  int ret_buf_offset = -1;\n+  if (needs_return_buffer) {\n+    ret_buf_offset = frame_bottom_offset;\n+    frame_bottom_offset += ret_buf_size;\n+    \/\/ use a free register for shuffling code to pick up return\n+    \/\/ buffer address from\n+    locs.set(StubLocations::RETURN_BUFFER, abi._scratch1);\n+  }\n+\n+  int frame_size = frame_bottom_offset;\n+  frame_size = align_up(frame_size, StackAlignmentInBytes);\n+\n+  \/\/ The space we have allocated will look like:\n+  \/\/\n+  \/\/\n+  \/\/ FP-> |                     |\n+  \/\/      |---------------------| = frame_bottom_offset = frame_size\n+  \/\/      | (optional)          |\n+  \/\/      | ret_buf             |\n+  \/\/      |---------------------| = ret_buf_offset\n+  \/\/      |                     |\n+  \/\/      | FrameData           |\n+  \/\/      |---------------------| = frame_data_offset\n+  \/\/      |                     |\n+  \/\/      | reg_save_area       |\n+  \/\/      |---------------------| = reg_save_area_offset\n+  \/\/      |                     |\n+  \/\/      | arg_save_area       |\n+  \/\/      |---------------------| = arg_save_area_offset\n+  \/\/      |                     |\n+  \/\/      | res_save_area       |\n+  \/\/      |---------------------| = res_save_area_offset\n+  \/\/      |                     |\n+  \/\/ SP-> | out_arg_area        |   needs to be at end for shadow space\n+  \/\/\n+  \/\/\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  MacroAssembler* _masm = new MacroAssembler(&buffer);\n+  address start = __ pc();\n+  __ enter(); \/\/ set up frame\n+  assert((abi._stack_alignment_bytes % 16) == 0, \"must be 16 byte aligned\");\n+  \/\/ allocate frame (frame_size is also aligned, so stack is still aligned)\n+  __ sub(sp, sp, frame_size);\n+\n+  \/\/ we have to always spill args since we need to do a call to get the thread\n+  \/\/ (and maybe attach it). so store those registers temporarily.\n+  arg_spiller.generate_spill(_masm, arg_save_area_offset);\n+  preserve_callee_saved_registers(_masm, abi, reg_save_area_offset);\n+\n+  __ block_comment(\"{ on_entry\");\n+  __ la(c_rarg0, Address(sp, frame_data_offset));\n+  __ rt_call(CAST_FROM_FN_PTR(address, UpcallLinker::on_entry));\n+  __ mv(xthread, x10);\n+  __ reinit_heapbase();\n+  __ block_comment(\"} on_entry\");\n+\n+  __ block_comment(\"{ argument shuffle\");\n+  arg_spiller.generate_fill(_masm, arg_save_area_offset);\n+\n+  if (needs_return_buffer) {\n+    assert(ret_buf_offset != -1, \"no return buffer allocated\");\n+\n+    \/\/ According to RISC-V ISA SPEC, when multiple floating-point precisions are supported,\n+    \/\/ then valid values of narrower n-bit types, n < FLEN , are represented in the lower n\n+    \/\/ bits of an FLEN-bit NaN value, in a process termed NaN-boxing. The upper bits of a\n+    \/\/ valid NaN-boxed value must be all 1s. Any operation that writes a narrower result to\n+    \/\/ an f register must write all 1s to the uppermost FLEN - n bits to yield a legal\n+    \/\/ NaN-boxed value. We could make use of this initializing all bits of return buffer with\n+    \/\/ 1s so that we could always transfer returned floating-point value from return buffer\n+    \/\/ into register with a single fld without knowing the current type of the value.\n+    __ mv(t1, -1L);\n+    int offset = 0;\n+    for (int i = 0; i < ret_buf_size \/ 8; i++) {\n+      __ sd(t1, Address(sp, ret_buf_offset + offset));\n+      offset += 8;\n+    }\n+    for (int i = 0; i < ret_buf_size % 8; i++) {\n+      __ sb(t1, Address(sp, ret_buf_offset + offset));\n+      offset += 1;\n+    }\n+\n+    __ la(as_Register(locs.get(StubLocations::RETURN_BUFFER)), Address(sp, ret_buf_offset));\n+  }\n+\n+  arg_shuffle.generate(_masm, as_VMStorage(shuffle_reg), abi._shadow_space_bytes, 0, locs);\n+  __ block_comment(\"} argument shuffle\");\n+\n+  __ block_comment(\"{ receiver \");\n+  __ movptr(shuffle_reg, (intptr_t) receiver);\n+  __ resolve_jobject(shuffle_reg, t0, t1);\n+  __ mv(j_rarg0, shuffle_reg);\n+  __ block_comment(\"} receiver \");\n+\n+  __ mov_metadata(xmethod, entry);\n+  __ sd(xmethod, Address(xthread, JavaThread::callee_target_offset())); \/\/ just in case callee is deoptimized\n+\n+  __ ld(t0, Address(xmethod, Method::from_compiled_offset()));\n+  __ jalr(t0);\n+\n+  \/\/ return value shuffle\n+  if (!needs_return_buffer) {\n+#ifdef ASSERT\n+    if (call_regs._ret_regs.length() == 1) { \/\/ 0 or 1\n+      VMStorage j_expected_result_reg;\n+      switch (ret_type) {\n+        case T_BOOLEAN:\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_CHAR:\n+        case T_INT:\n+        case T_LONG:\n+          j_expected_result_reg = as_VMStorage(x10);\n+          break;\n+        case T_FLOAT:\n+        case T_DOUBLE:\n+          j_expected_result_reg = as_VMStorage(f10);\n+          break;\n+        default:\n+          fatal(\"unexpected return type: %s\", type2name(ret_type));\n+      }\n+      \/\/ No need to move for now, since CallArranger can pick a return type\n+      \/\/ that goes in the same reg for both CCs. But, at least assert they are the same\n+      assert(call_regs._ret_regs.at(0) == j_expected_result_reg, \"unexpected result register\");\n+    }\n+#endif\n+  } else {\n+    assert(ret_buf_offset != -1, \"no return buffer allocated\");\n+    __ la(t0, Address(sp, ret_buf_offset));\n+    int offset = 0;\n+    for (int i = 0; i < call_regs._ret_regs.length(); i++) {\n+      VMStorage reg = call_regs._ret_regs.at(i);\n+      if (reg.type() == StorageType::INTEGER) {\n+        __ ld(as_Register(reg), Address(t0, offset));\n+      } else if (reg.type() == StorageType::FLOAT) {\n+        __ fld(as_FloatRegister(reg), Address(t0, offset));\n+      } else {\n+        ShouldNotReachHere();\n+      }\n+      offset += 8;\n+    }\n+  }\n+\n+  result_spiller.generate_spill(_masm, res_save_area_offset);\n+\n+  __ block_comment(\"{ on_exit\");\n+  __ la(c_rarg0, Address(sp, frame_data_offset));\n+  \/\/ stack already aligned\n+  __ rt_call(CAST_FROM_FN_PTR(address, UpcallLinker::on_exit));\n+  __ block_comment(\"} on_exit\");\n+\n+  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n+\n+  result_spiller.generate_fill(_masm, res_save_area_offset);\n+\n+  __ leave();\n+  __ ret();\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ exception handler\");\n+\n+  intptr_t exception_handler_offset = __ pc() - start;\n+\n+  \/\/ Native caller has no idea how to handle exceptions,\n+  \/\/ so we just crash here. Up to callee to catch exceptions.\n+  __ verify_oop(x10); \/\/ return a exception oop in a0\n+  __ rt_call(CAST_FROM_FN_PTR(address, UpcallLinker::handle_uncaught_exception));\n+  __ should_not_reach_here();\n+\n+  __ block_comment(\"} exception handler\");\n+  __ flush();\n+\n+#ifndef PRODUCT\n+  stringStream ss;\n+  ss.print(\"upcall_stub_%s\", entry->signature()->as_C_string());\n+  const char *name = _masm->code_string(ss.as_string());\n+#else \/\/ PRODUCT\n+  const char* name = \"upcall_stub\";\n+#endif \/\/ PRODUCT\n+\n+  UpcallStub* blob\n+    = UpcallStub::create(name,\n+                         &buffer,\n+                         exception_handler_offset,\n+                         receiver,\n+                         in_ByteSize(frame_data_offset));\n+#ifndef PRODUCT\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    blob->print_on(&ls);\n+  }\n+#endif\n+\n+  return blob->code_begin();\n","filename":"src\/hotspot\/cpu\/riscv\/upcallLinker_riscv.cpp","additions":327,"deletions":4,"binary":false,"changes":331,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"vmreg_riscv.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/riscv\/vmreg_riscv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+\/\/ keep in sync with jdk\/internal\/foreign\/abi\/riscv64\/RISCV64Architecture\n@@ -32,2 +33,4 @@\n-  STACK = 0,\n-  PLACEHOLDER = 1,\n+  INTEGER = 0,\n+  FLOAT = 1,\n+  STACK = 2,\n+  PLACEHOLDER = 3,\n@@ -41,1 +44,1 @@\n-   return false;\n+   return type == StorageType::INTEGER || type == StorageType::FLOAT;\n@@ -47,0 +50,21 @@\n+constexpr uint16_t REG64_MASK = 0b0000000000000001;\n+constexpr uint16_t FP_MASK    = 0b0000000000000001;\n+\n+inline Register as_Register(VMStorage vms) {\n+  assert(vms.type() == StorageType::INTEGER, \"not the right type\");\n+  return ::as_Register(vms.index());\n+}\n+\n+inline FloatRegister as_FloatRegister(VMStorage vms) {\n+  assert(vms.type() == StorageType::FLOAT, \"not the right type\");\n+  return ::as_FloatRegister(vms.index());\n+}\n+\n+constexpr inline VMStorage as_VMStorage(Register reg) {\n+  return VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, reg->encoding());\n+}\n+\n+constexpr inline VMStorage as_VMStorage(FloatRegister reg) {\n+  return VMStorage::reg_storage(StorageType::FLOAT, FP_MASK, reg->encoding());\n+}\n+\n@@ -48,0 +72,10 @@\n+  if (reg->is_Register()) {\n+    return as_VMStorage(reg->as_Register());\n+  } else if (reg->is_FloatRegister()) {\n+    return as_VMStorage(reg->as_FloatRegister());\n+  } else if (reg->is_stack()) {\n+    return VMStorage::stack_storage(reg);\n+  } else if (!reg->is_valid()) {\n+    return VMStorage::invalid();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vmstorage_riscv.hpp","additions":37,"deletions":3,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -400,1 +400,1 @@\n-  __ z_nill(value, ~JNIHandles::weak_tag_mask);\n+  __ z_nill(value, ~JNIHandles::tag_mask);\n@@ -403,1 +403,1 @@\n-  __ z_tmll(tmp1, JNIHandles::weak_tag_mask); \/\/ Test for jweak tag.\n+  __ z_tmll(tmp1, JNIHandles::TypeTag::weak_global); \/\/ Test for jweak tag.\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-  __ z_nill(value, ~JNIHandles::weak_tag_mask);\n+  __ z_nill(value, ~JNIHandles::tag_mask);\n@@ -122,1 +122,1 @@\n-  __ z_nill(obj, ~JNIHandles::weak_tag_mask);\n+  __ z_nill(obj, ~JNIHandles::tag_mask);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1766,2 +1766,3 @@\n-  assert(!dst.base_needs_rex() && !dst.index_needs_rex(), \"no extended registers\");\n-  emit_int16(0x66, (unsigned char)0x81);\n+  emit_int8(0x66);\n+  prefix(dst);\n+  emit_int8((unsigned char)0x81);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3206,0 +3206,189 @@\n+int C2_MacroAssembler::arrays_hashcode_elsize(BasicType eltype) {\n+  switch (eltype) {\n+  case T_BOOLEAN: return sizeof(jboolean);\n+  case T_BYTE:  return sizeof(jbyte);\n+  case T_SHORT: return sizeof(jshort);\n+  case T_CHAR:  return sizeof(jchar);\n+  case T_INT:   return sizeof(jint);\n+  default:\n+    ShouldNotReachHere();\n+    return -1;\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elload(Register dst, Address src, BasicType eltype) {\n+  switch (eltype) {\n+  \/\/ T_BOOLEAN used as surrogate for unsigned byte\n+  case T_BOOLEAN: movzbl(dst, src);   break;\n+  case T_BYTE:    movsbl(dst, src);   break;\n+  case T_SHORT:   movswl(dst, src);   break;\n+  case T_CHAR:    movzwl(dst, src);   break;\n+  case T_INT:     movl(dst, src);     break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvload(XMMRegister dst, Address src, BasicType eltype) {\n+  load_vector(dst, src, arrays_hashcode_elsize(eltype) * 8);\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvload(XMMRegister dst, AddressLiteral src, BasicType eltype) {\n+  load_vector(dst, src, arrays_hashcode_elsize(eltype) * 8);\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype) {\n+  const int vlen = Assembler::AVX_256bit;\n+  switch (eltype) {\n+  case T_BOOLEAN: vector_unsigned_cast(dst, dst, vlen, T_BYTE, T_INT);  break;\n+  case T_BYTE:      vector_signed_cast(dst, dst, vlen, T_BYTE, T_INT);  break;\n+  case T_SHORT:     vector_signed_cast(dst, dst, vlen, T_SHORT, T_INT); break;\n+  case T_CHAR:    vector_unsigned_cast(dst, dst, vlen, T_SHORT, T_INT); break;\n+  case T_INT:\n+    \/\/ do nothing\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode(Register ary1, Register cnt1, Register result,\n+                                        Register index, Register tmp2, Register tmp3, XMMRegister vnext,\n+                                        XMMRegister vcoef0, XMMRegister vcoef1, XMMRegister vcoef2, XMMRegister vcoef3,\n+                                        XMMRegister vresult0, XMMRegister vresult1, XMMRegister vresult2, XMMRegister vresult3,\n+                                        XMMRegister vtmp0, XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3,\n+                                        BasicType eltype) {\n+  ShortBranchVerifier sbv(this);\n+  assert(UseAVX >= 2, \"AVX2 intrinsics are required\");\n+  assert_different_registers(ary1, cnt1, result, index, tmp2, tmp3);\n+  assert_different_registers(vnext, vcoef0, vcoef1, vcoef2, vcoef3, vresult0, vresult1, vresult2, vresult3, vtmp0, vtmp1, vtmp2, vtmp3);\n+\n+  Label SHORT_UNROLLED_BEGIN, SHORT_UNROLLED_LOOP_BEGIN,\n+        SHORT_UNROLLED_LOOP_EXIT,\n+        UNROLLED_SCALAR_LOOP_BEGIN, UNROLLED_SCALAR_SKIP, UNROLLED_SCALAR_RESUME,\n+        UNROLLED_VECTOR_LOOP_BEGIN,\n+        END;\n+  switch (eltype) {\n+  case T_BOOLEAN: BLOCK_COMMENT(\"arrays_hashcode(unsigned byte) {\"); break;\n+  case T_CHAR:    BLOCK_COMMENT(\"arrays_hashcode(char) {\");          break;\n+  case T_BYTE:    BLOCK_COMMENT(\"arrays_hashcode(byte) {\");          break;\n+  case T_SHORT:   BLOCK_COMMENT(\"arrays_hashcode(short) {\");         break;\n+  case T_INT:     BLOCK_COMMENT(\"arrays_hashcode(int) {\");           break;\n+  default:        BLOCK_COMMENT(\"arrays_hashcode {\");                break;\n+  }\n+\n+  \/\/ For \"renaming\" for readibility of the code\n+  XMMRegister vcoef[] = { vcoef0, vcoef1, vcoef2, vcoef3 },\n+              vresult[] = { vresult0, vresult1, vresult2, vresult3 },\n+              vtmp[] = { vtmp0, vtmp1, vtmp2, vtmp3 };\n+\n+  const int elsize = arrays_hashcode_elsize(eltype);\n+\n+  \/*\n+    if (cnt1 >= 2) {\n+      if (cnt1 >= 32) {\n+        UNROLLED VECTOR LOOP\n+      }\n+      UNROLLED SCALAR LOOP\n+    }\n+    SINGLE SCALAR\n+   *\/\n+\n+  cmpl(cnt1, 32);\n+  jcc(Assembler::less, SHORT_UNROLLED_BEGIN);\n+\n+  \/\/ cnt1 >= 32 && generate_vectorized_loop\n+  xorl(index, index);\n+\n+  \/\/ vresult = IntVector.zero(I256);\n+  for (int idx = 0; idx < 4; idx++) {\n+    vpxor(vresult[idx], vresult[idx]);\n+  }\n+  \/\/ vnext = IntVector.broadcast(I256, power_of_31_backwards[0]);\n+  Register bound = tmp2;\n+  Register next = tmp3;\n+  lea(tmp2, ExternalAddress(StubRoutines::x86::arrays_hashcode_powers_of_31() + (0 * sizeof(jint))));\n+  movl(next, Address(tmp2, 0));\n+  movdl(vnext, next);\n+  vpbroadcastd(vnext, vnext, Assembler::AVX_256bit);\n+\n+  \/\/ index = 0;\n+  \/\/ bound = cnt1 & ~(32 - 1);\n+  movl(bound, cnt1);\n+  andl(bound, ~(32 - 1));\n+  \/\/ for (; index < bound; index += 32) {\n+  bind(UNROLLED_VECTOR_LOOP_BEGIN);\n+  \/\/ result *= next;\n+  imull(result, next);\n+  \/\/ loop fission to upfront the cost of fetching from memory, OOO execution\n+  \/\/ can then hopefully do a better job of prefetching\n+  for (int idx = 0; idx < 4; idx++) {\n+    arrays_hashcode_elvload(vtmp[idx], Address(ary1, index, Address::times(elsize), 8 * idx * elsize), eltype);\n+  }\n+  \/\/ vresult = vresult * vnext + ary1[index+8*idx:index+8*idx+7];\n+  for (int idx = 0; idx < 4; idx++) {\n+    vpmulld(vresult[idx], vresult[idx], vnext, Assembler::AVX_256bit);\n+    arrays_hashcode_elvcast(vtmp[idx], eltype);\n+    vpaddd(vresult[idx], vresult[idx], vtmp[idx], Assembler::AVX_256bit);\n+  }\n+  \/\/ index += 32;\n+  addl(index, 32);\n+  \/\/ index < bound;\n+  cmpl(index, bound);\n+  jcc(Assembler::less, UNROLLED_VECTOR_LOOP_BEGIN);\n+  \/\/ }\n+\n+  lea(ary1, Address(ary1, bound, Address::times(elsize)));\n+  subl(cnt1, bound);\n+  \/\/ release bound\n+\n+  \/\/ vresult *= IntVector.fromArray(I256, power_of_31_backwards, 1);\n+  for (int idx = 0; idx < 4; idx++) {\n+    lea(tmp2, ExternalAddress(StubRoutines::x86::arrays_hashcode_powers_of_31() + ((8 * idx + 1) * sizeof(jint))));\n+    arrays_hashcode_elvload(vcoef[idx], Address(tmp2, 0), T_INT);\n+    vpmulld(vresult[idx], vresult[idx], vcoef[idx], Assembler::AVX_256bit);\n+  }\n+  \/\/ result += vresult.reduceLanes(ADD);\n+  for (int idx = 0; idx < 4; idx++) {\n+    reduceI(Op_AddReductionVI, 256\/(sizeof(jint) * 8), result, result, vresult[idx], vtmp[(idx * 2 + 0) % 4], vtmp[(idx * 2 + 1) % 4]);\n+  }\n+\n+  \/\/ } else if (cnt1 < 32) {\n+\n+  bind(SHORT_UNROLLED_BEGIN);\n+  \/\/ int i = 1;\n+  movl(index, 1);\n+  cmpl(index, cnt1);\n+  jcc(Assembler::greaterEqual, SHORT_UNROLLED_LOOP_EXIT);\n+\n+  \/\/ for (; i < cnt1 ; i += 2) {\n+  bind(SHORT_UNROLLED_LOOP_BEGIN);\n+  movl(tmp3, 961);\n+  imull(result, tmp3);\n+  arrays_hashcode_elload(tmp2, Address(ary1, index, Address::times(elsize), -elsize), eltype);\n+  movl(tmp3, tmp2);\n+  shll(tmp3, 5);\n+  subl(tmp3, tmp2);\n+  addl(result, tmp3);\n+  arrays_hashcode_elload(tmp3, Address(ary1, index, Address::times(elsize)), eltype);\n+  addl(result, tmp3);\n+  addl(index, 2);\n+  cmpl(index, cnt1);\n+  jccb(Assembler::less, SHORT_UNROLLED_LOOP_BEGIN);\n+\n+  \/\/ }\n+  \/\/ if (i >= cnt1) {\n+  bind(SHORT_UNROLLED_LOOP_EXIT);\n+  jccb(Assembler::greater, END);\n+  movl(tmp2, result);\n+  shll(result, 5);\n+  subl(result, tmp2);\n+  arrays_hashcode_elload(tmp3, Address(ary1, index, Address::times(elsize), -elsize), eltype);\n+  addl(result, tmp3);\n+  \/\/ }\n+  bind(END);\n+\n+  BLOCK_COMMENT(\"} \/\/ arrays_hashcode\");\n+\n+} \/\/ arrays_hashcode\n+\n@@ -4688,0 +4877,27 @@\n+void C2_MacroAssembler::vector_signed_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                                           BasicType from_elem_bt, BasicType to_elem_bt) {\n+  switch (from_elem_bt) {\n+    case T_BYTE:\n+      switch (to_elem_bt) {\n+        case T_SHORT: vpmovsxbw(dst, src, vlen_enc); break;\n+        case T_INT:   vpmovsxbd(dst, src, vlen_enc); break;\n+        case T_LONG:  vpmovsxbq(dst, src, vlen_enc); break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case T_SHORT:\n+      switch (to_elem_bt) {\n+        case T_INT:  vpmovsxwd(dst, src, vlen_enc); break;\n+        case T_LONG: vpmovsxwq(dst, src, vlen_enc); break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case T_INT:\n+      assert(to_elem_bt == T_LONG, \"\");\n+      vpmovsxdq(dst, src, vlen_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":217,"deletions":1,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,0 +295,13 @@\n+  void arrays_hashcode(Register str1, Register cnt1, Register result,\n+                       Register tmp1, Register tmp2, Register tmp3, XMMRegister vnext,\n+                       XMMRegister vcoef0, XMMRegister vcoef1, XMMRegister vcoef2, XMMRegister vcoef3,\n+                       XMMRegister vresult0, XMMRegister vresult1, XMMRegister vresult2, XMMRegister vresult3,\n+                       XMMRegister vtmp0, XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3,\n+                       BasicType eltype);\n+\n+  \/\/ helper functions for arrays_hashcode\n+  int arrays_hashcode_elsize(BasicType eltype);\n+  void arrays_hashcode_elload(Register dst, Address src, BasicType eltype);\n+  void arrays_hashcode_elvload(XMMRegister dst, Address src, BasicType eltype);\n+  void arrays_hashcode_elvload(XMMRegister dst, AddressLiteral src, BasicType eltype);\n+  void arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype);\n@@ -312,0 +325,3 @@\n+\n+  void vector_signed_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                          BasicType from_elem_bt, BasicType to_elem_bt);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -200,1 +200,1 @@\n-  __ clear_jweak_tag(obj);\n+  __ clear_jobject_tag(obj);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-  __ clear_jweak_tag(rdx);\n+  __ clear_jobject_tag(rdx);\n@@ -217,1 +217,1 @@\n-  __ clear_jweak_tag(rdx);\n+  __ clear_jobject_tag(rdx);\n@@ -307,1 +307,1 @@\n-  __ clear_jweak_tag(rdx);\n+  __ clear_jobject_tag(rdx);\n","filename":"src\/hotspot\/cpu\/x86\/jniFastGetField_x86_32.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-#define BUFFER_SIZE 30*wordSize\n+#define BUFFER_SIZE 40*wordSize\n","filename":"src\/hotspot\/cpu\/x86\/jniFastGetField_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2038,0 +2038,1 @@\n+  InlineSkippedInstructionsCounter skipCounter(this);\n@@ -3876,3 +3877,3 @@\n-void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {\n-  const int32_t inverted_jweak_mask = ~static_cast<int32_t>(JNIHandles::weak_tag_mask);\n-  STATIC_ASSERT(inverted_jweak_mask == -2); \/\/ otherwise check this code\n+void MacroAssembler::clear_jobject_tag(Register possibly_non_local) {\n+  const int32_t inverted_mask = ~static_cast<int32_t>(JNIHandles::tag_mask);\n+  STATIC_ASSERT(inverted_mask == -4); \/\/ otherwise check this code\n@@ -3880,1 +3881,1 @@\n-  andptr(possibly_jweak, inverted_jweak_mask);\n+  andptr(possibly_non_local, inverted_mask);\n@@ -3887,1 +3888,1 @@\n-  Label done, not_weak;\n+  Label done, tagged, weak_tagged;\n@@ -3889,3 +3890,19 @@\n-  jcc(Assembler::zero, done);                \/\/ Use NULL as-is.\n-  testptr(value, JNIHandles::weak_tag_mask); \/\/ Test for jweak tag.\n-  jcc(Assembler::zero, not_weak);\n+  jcc(Assembler::zero, done);           \/\/ Use NULL as-is.\n+  testptr(value, JNIHandles::tag_mask); \/\/ Test for tag.\n+  jcc(Assembler::notZero, tagged);\n+\n+  \/\/ Resolve local handle\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, value, Address(value, 0), tmp, thread);\n+  verify_oop(value);\n+  jmp(done);\n+\n+  bind(tagged);\n+  testptr(value, JNIHandles::TypeTag::weak_global); \/\/ Test for weak tag.\n+  jcc(Assembler::notZero, weak_tagged);\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp, thread);\n+  verify_oop(value);\n+  jmp(done);\n+\n+  bind(weak_tagged);\n@@ -3894,1 +3911,1 @@\n-                 value, Address(value, -JNIHandles::weak_tag_value), tmp, thread);\n+                 value, Address(value, -JNIHandles::TypeTag::weak_global), tmp, thread);\n@@ -3896,4 +3913,25 @@\n-  jmp(done);\n-  bind(not_weak);\n-  \/\/ Resolve (untagged) jobject.\n-  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);\n+\n+  bind(done);\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value,\n+                                            Register thread,\n+                                            Register tmp) {\n+  assert_different_registers(value, thread, tmp);\n+  Label done;\n+\n+  testptr(value, value);\n+  jcc(Assembler::zero, done);           \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    Label valid_global_tag;\n+    testptr(value, JNIHandles::TypeTag::global); \/\/ Test for global tag.\n+    jcc(Assembler::notZero, valid_global_tag);\n+    stop(\"non global jobject using resolve_global_jobject\");\n+    bind(valid_global_tag);\n+  }\n+#endif\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp, thread);\n@@ -3901,0 +3939,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":52,"deletions":13,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -329,1 +329,1 @@\n-  void clear_jweak_tag(Register possibly_jweak);\n+  void clear_jobject_tag(Register possibly_non_local);\n@@ -331,0 +331,1 @@\n+  void resolve_global_jobject(Register value, Register thread, Register tmp);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1590,0 +1590,9 @@\n+\n+  \/\/ handle pending exception thrown by freeze\n+  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n+  Label ok;\n+  __ jcc(Assembler::equal, ok);\n+  __ leave();\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+  __ bind(ok);\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -4014,7 +4014,1 @@\n-    Label null_jobject;\n-    __ testptr(rax, rax);\n-    __ jcc(Assembler::zero, null_jobject);\n-    DecoratorSet decorators = ACCESS_READ | IN_NATIVE;\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(masm, decorators, T_OBJECT, rax, Address(rax, 0), noreg, java_thread);\n-    __ bind(null_jobject);\n+    __ resolve_global_jobject(rax, java_thread, rdx);\n@@ -4039,1 +4033,1 @@\n-    int insts_size = 512;\n+    int insts_size = 1024;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3507,1 +3507,1 @@\n-  CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n+  CodeBuffer code(\"jfr_write_checkpoint\", 1024, 64);\n@@ -3522,8 +3522,1 @@\n-  Label L_null_jobject;\n-  __ testptr(rax, rax);\n-  __ jcc(Assembler::zero, L_null_jobject);\n-\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->load_at(_masm, ACCESS_READ | IN_NATIVE, T_OBJECT, rax, Address(rax, 0), c_rarg0, r15_thread);\n-\n-  __ bind(L_null_jobject);\n+  __ resolve_global_jobject(rax, r15_thread, c_rarg0);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,0 +230,37 @@\n+jint StubRoutines::x86::_arrays_hashcode_powers_of_31[] =\n+{\n+     2111290369,\n+    -2010103841,\n+      350799937,\n+       11316127,\n+      693101697,\n+     -254736545,\n+      961614017,\n+       31019807,\n+    -2077209343,\n+      -67006753,\n+     1244764481,\n+    -2038056289,\n+      211350913,\n+     -408824225,\n+     -844471871,\n+     -997072353,\n+     1353309697,\n+     -510534177,\n+     1507551809,\n+     -505558625,\n+     -293403007,\n+      129082719,\n+    -1796951359,\n+     -196513505,\n+    -1807454463,\n+     1742810335,\n+      887503681,\n+       28629151,\n+         923521,\n+          29791,\n+            961,\n+             31,\n+              1,\n+};\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,0 +140,2 @@\n+  \/\/ table for arrays_hashcode\n+  static jint _arrays_hashcode_powers_of_31[];\n@@ -328,0 +330,1 @@\n+  static address arrays_hashcode_powers_of_31() { return (address)_arrays_hashcode_powers_of_31; }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1698,0 +1698,7 @@\n+  if (UseAVX >= 2) {\n+    FLAG_SET_DEFAULT(UseVectorizedHashCodeIntrinsic, true);\n+  } else if (UseVectorizedHashCodeIntrinsic) {\n+    if (!FLAG_IS_DEFAULT(UseVectorizedHashCodeIntrinsic))\n+      warning(\"vectorizedHashCode intrinsics are not available on this CPU\");\n+    FLAG_SET_DEFAULT(UseVectorizedHashCodeIntrinsic, false);\n+  }\n@@ -1705,0 +1712,6 @@\n+  if (UseVectorizedHashCodeIntrinsic) {\n+    if (!FLAG_IS_DEFAULT(UseVectorizedHashCodeIntrinsic)) {\n+      warning(\"vectorizedHashCode intrinsic is not available in 32-bit VM\");\n+    }\n+    FLAG_SET_DEFAULT(UseVectorizedHashCodeIntrinsic, false);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-\/\/ Singleton class for RCX int register\n+\/\/ Singleton class for RDX int register\n@@ -311,1 +311,1 @@\n-\/\/ Singleton class for RCX int register\n+\/\/ Singleton class for RDI int register\n@@ -12077,0 +12077,26 @@\n+instruct arrays_hashcode(rdi_RegP ary1, rdx_RegI cnt1, rbx_RegI result, immU8 basic_type,\n+                         legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                         legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                         legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                         legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2);\n+  match(Set result (VectorizedHashCode (Binary ary1 cnt1) (Binary result basic_type)));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL ary1, USE_KILL cnt1,\n+         USE basic_type, KILL cr);\n+\n+  format %{ \"Array HashCode array[] $ary1,$cnt1,$result,$basic_type -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($ary1$$Register, $cnt1$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                       $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                       $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                       $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                       $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                       $tmp_vec13$$XMMRegister, (BasicType)$basic_type$$constant);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1969,1 +1969,1 @@\n-      status = setrlimit(RLIMIT_NOFILE, &nbr_files);\n+\n@@ -1971,10 +1971,7 @@\n-      if (status != 0 && errno == EINVAL) {\n-        \/\/ On macOS >= 10.6 if we define _DARWIN_UNLIMITED_STREAMS or _DARWIN_C_SOURCE\n-        \/\/ (we define _DARWIN_C_SOURCE) we can ask for RLIM_INFINITY,\n-        \/\/ however, on macOS < 10.6 Darwin returns RLIM_INFINITY for rlim_max,\n-        \/\/ but fails with EINVAL if you attempt to use RLIM_INFINITY.\n-        \/\/ As per setrlimit(2), OPEN_MAX must be used instead.\n-        nbr_files.rlim_cur = MIN(OPEN_MAX, nbr_files.rlim_cur);\n-        status = setrlimit(RLIMIT_NOFILE, &nbr_files);\n-      }\n-#endif \/\/ __APPLE__\n+      \/\/ Darwin returns RLIM_INFINITY for rlim_max, but fails with EINVAL if\n+      \/\/ you attempt to use RLIM_INFINITY. As per setrlimit(2), OPEN_MAX must\n+      \/\/ be used instead\n+      nbr_files.rlim_cur = MIN(OPEN_MAX, nbr_files.rlim_cur);\n+#endif\n+\n+      status = setrlimit(RLIMIT_NOFILE, &nbr_files);\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-         && _PdhCloseQuery != NULL && PdhCollectQueryData != NULL\n+         && _PdhCloseQuery != NULL && _PdhCollectQueryData != NULL\n@@ -116,1 +116,1 @@\n-         && _PdhRemoveCounter != NULL && PdhLookupPerfNameByIndex != NULL\n+         && _PdhRemoveCounter != NULL && _PdhLookupPerfNameByIndex != NULL\n@@ -169,1 +169,1 @@\n-  assert(_initialized && PdhExpandWildCardPath != NULL, \"PdhAvailable() not yet called\");\n+  assert(_initialized && _PdhExpandWildCardPath != NULL, \"PdhAvailable() not yet called\");\n","filename":"src\/hotspot\/os\/windows\/pdh_interface.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,5 +56,15 @@\n-  \/\/ hw.optional.floatingpoint always returns 1, see\n-  \/\/ https:\/\/github.com\/apple\/darwin-xnu\/blob\/master\/bsd\/kern\/kern_mib.c#L416.\n-  \/\/ ID_AA64PFR0_EL1 describes AdvSIMD always equals to FP field.\n-  assert(cpu_has(\"hw.optional.floatingpoint\"), \"should be\");\n-  assert(cpu_has(\"hw.optional.neon\"), \"should be\");\n+  \/\/ cpu_has() uses sysctlbyname function to check the existence of CPU\n+  \/\/ features. References: Apple developer document [1] and XNU kernel [2].\n+  \/\/ [1] https:\/\/developer.apple.com\/documentation\/kernel\/1387446-sysctlbyname\/determining_instruction_set_characteristics\n+  \/\/ [2] https:\/\/github.com\/apple-oss-distributions\/xnu\/blob\/main\/bsd\/kern\/kern_mib.c\n+  \/\/\n+  \/\/ Note that for some features (e.g., LSE, SHA512 and SHA3) there are two\n+  \/\/ parameters for sysctlbyname, which are invented at different times.\n+  \/\/ Considering backward compatibility, we check both here.\n+  \/\/\n+  \/\/ Floating-point and Advance SIMD features are standard in Apple processors\n+  \/\/ beginning with M1 and A7, and don't need to be checked [1].\n+  \/\/ 1) hw.optional.floatingpoint always returns 1 [2].\n+  \/\/ 2) ID_AA64PFR0_EL1 describes AdvSIMD always equals to FP field.\n+  \/\/    See the Arm ARM, section \"ID_AA64PFR0_EL1, AArch64 Processor Feature\n+  \/\/    Register 0\".\n@@ -63,2 +73,7 @@\n-  \/\/ All Apple-darwin Arm processors have AES and PMULL.\n-  _features |= CPU_AES | CPU_PMULL;\n+  \/\/ All Apple-darwin Arm processors have AES, PMULL, SHA1 and SHA2.\n+  \/\/ See https:\/\/github.com\/apple-oss-distributions\/xnu\/blob\/main\/osfmk\/arm\/commpage\/commpage.c#L412\n+  \/\/ Note that we ought to add assertions to check sysctlbyname parameters for\n+  \/\/ these four CPU features, e.g., \"hw.optional.arm.FEAT_AES\", but the\n+  \/\/ corresponding string names are not available before xnu-8019 version.\n+  \/\/ Hence, assertions are omitted considering backward compatibility.\n+  _features |= CPU_AES | CPU_PMULL | CPU_SHA1 | CPU_SHA2;\n@@ -66,4 +81,15 @@\n-  \/\/ Only few features are available via sysctl, see line 614\n-  \/\/ https:\/\/opensource.apple.com\/source\/xnu\/xnu-6153.141.1\/bsd\/kern\/kern_mib.c.auto.html\n-  if (cpu_has(\"hw.optional.armv8_crc32\"))     _features |= CPU_CRC32;\n-  if (cpu_has(\"hw.optional.armv8_1_atomics\")) _features |= CPU_LSE;\n+  if (cpu_has(\"hw.optional.armv8_crc32\")) {\n+    _features |= CPU_CRC32;\n+  }\n+  if (cpu_has(\"hw.optional.arm.FEAT_LSE\") ||\n+      cpu_has(\"hw.optional.armv8_1_atomics\")) {\n+    _features |= CPU_LSE;\n+  }\n+  if (cpu_has(\"hw.optional.arm.FEAT_SHA512\") ||\n+      cpu_has(\"hw.optional.armv8_2_sha512\")) {\n+    _features |= CPU_SHA512;\n+  }\n+  if (cpu_has(\"hw.optional.arm.FEAT_SHA3\") ||\n+      cpu_has(\"hw.optional.armv8_2_sha3\")) {\n+    _features |= CPU_SHA3;\n+  }\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/vm_version_bsd_aarch64.cpp","additions":38,"deletions":12,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -608,2 +608,2 @@\n-  \/\/ String.(compareTo\/equals\/indexOf) and Arrays.equals use many memorys edges,\n-  \/\/ but writes none\n+  \/\/ String.(compareTo\/equals\/indexOf\/hashCode) and Arrays.(equals\/hashCode)\n+  \/\/ use many memorys edges, but writes none\n@@ -616,1 +616,2 @@\n-        strcmp(_matrule->_rChild->_opType,\"AryEq\"      )==0 ))\n+        strcmp(_matrule->_rChild->_opType,\"AryEq\"      )==0 ||\n+        strcmp(_matrule->_rChild->_opType,\"VectorizedHashCode\")==0 ))\n@@ -899,0 +900,1 @@\n+        strcmp(_matrule->_rChild->_opType,\"VectorizedHashCode\")==0 ||\n@@ -907,1 +909,1 @@\n-        \/\/ String.(compareTo\/equals\/indexOf) and Arrays.equals\n+        \/\/ String.(compareTo\/equals\/indexOf\/hashCode) and Arrays.equals\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -244,0 +244,13 @@\n+\n+  \/\/ count size of instructions which are skipped from inline heuristics\n+  class InlineSkippedInstructionsCounter: public StackObj {\n+   private:\n+    AbstractAssembler* _assm;\n+    address _start;\n+   public:\n+    InlineSkippedInstructionsCounter(AbstractAssembler* assm) : _assm(assm), _start(assm->pc()) {\n+    }\n+    ~InlineSkippedInstructionsCounter() {\n+      _assm->register_skipped(_assm->pc() - _start);\n+    }\n+  };\n@@ -336,0 +349,2 @@\n+  void   register_skipped(int size) { code_section()->register_skipped(size); }\n+\n@@ -340,0 +355,1 @@\n+\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -599,0 +599,11 @@\n+int CodeBuffer::total_skipped_instructions_size() const {\n+  int total_skipped_size = 0;\n+  for (int n = (int) SECT_FIRST; n < (int) SECT_LIMIT; n++) {\n+    const CodeSection* cur_cs = code_section(n);\n+    if (!cur_cs->is_empty()) {\n+      total_skipped_size += cur_cs->_skipped_instructions_size;\n+    }\n+  }\n+  return total_skipped_size;\n+}\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+  int         _skipped_instructions_size;\n@@ -117,0 +118,1 @@\n+    _skipped_instructions_size = 0;\n@@ -147,0 +149,1 @@\n+    _skipped_instructions_size = cs->_skipped_instructions_size;\n@@ -207,0 +210,4 @@\n+  void register_skipped(int size) {\n+    _skipped_instructions_size += size;\n+  }\n+\n@@ -641,0 +648,2 @@\n+  int total_skipped_instructions_size() const;\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1717,1 +1717,1 @@\n-  if (GenerateRangeChecks && needs_range_check) {\n+  if (needs_range_check) {\n@@ -2006,1 +2006,1 @@\n-  if (GenerateRangeChecks && needs_range_check) {\n+  if (needs_range_check) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-ArchiveBuilder* ArchiveBuilder::_current = NULL;\n+ArchiveBuilder* ArchiveBuilder::_current = nullptr;\n@@ -98,1 +98,1 @@\n-  assert(*field_addr != NULL, \"should have checked\");\n+  assert(*field_addr != nullptr, \"should have checked\");\n@@ -144,3 +144,3 @@\n-  _current_dump_space(NULL),\n-  _buffer_bottom(NULL),\n-  _last_verified_top(NULL),\n+  _current_dump_space(nullptr),\n+  _buffer_bottom(nullptr),\n+  _last_verified_top(nullptr),\n@@ -149,6 +149,6 @@\n-  _requested_static_archive_bottom(NULL),\n-  _requested_static_archive_top(NULL),\n-  _requested_dynamic_archive_bottom(NULL),\n-  _requested_dynamic_archive_top(NULL),\n-  _mapped_static_archive_bottom(NULL),\n-  _mapped_static_archive_top(NULL),\n+  _requested_static_archive_bottom(nullptr),\n+  _requested_static_archive_top(nullptr),\n+  _requested_dynamic_archive_bottom(nullptr),\n+  _requested_dynamic_archive_top(nullptr),\n+  _mapped_static_archive_bottom(nullptr),\n+  _mapped_static_archive_top(nullptr),\n@@ -172,1 +172,1 @@\n-  assert(_current == NULL, \"must be\");\n+  assert(_current == nullptr, \"must be\");\n@@ -178,1 +178,1 @@\n-  _current = NULL;\n+  _current = nullptr;\n@@ -210,1 +210,1 @@\n-  if (ref->obj() == NULL) {\n+  if (ref->obj() == nullptr) {\n@@ -433,1 +433,1 @@\n-    if (ref->obj() != NULL) {\n+    if (ref->obj() != nullptr) {\n@@ -442,1 +442,1 @@\n-  if (src_obj == NULL) {\n+  if (src_obj == nullptr) {\n@@ -479,1 +479,1 @@\n-  assert(ref->obj() != NULL, \"should have checked\");\n+  assert(ref->obj() != nullptr, \"should have checked\");\n@@ -481,1 +481,1 @@\n-  if (enclosing_ref != NULL) {\n+  if (enclosing_ref != nullptr) {\n@@ -483,1 +483,1 @@\n-    if (src_info == NULL) {\n+    if (src_info == nullptr) {\n@@ -644,1 +644,1 @@\n-  if (archived_vtable != NULL) {\n+  if (archived_vtable != nullptr) {\n@@ -657,1 +657,1 @@\n-  assert(p != NULL, \"must be\");\n+  assert(p != nullptr, \"must be\");\n@@ -665,1 +665,1 @@\n-  assert(src_p != NULL && *src_p != NULL, \"must be\");\n+  assert(src_p != nullptr && *src_p != nullptr, \"must be\");\n@@ -849,1 +849,1 @@\n-\/\/   [a] NULL:\n+\/\/   [a] nullptr:\n@@ -889,1 +889,1 @@\n-    if (*p == NULL) {\n+    if (*p == nullptr) {\n@@ -1067,1 +1067,1 @@\n-        if (original_oop != NULL) {\n+        if (original_oop != nullptr) {\n@@ -1146,1 +1146,1 @@\n-    if (closed_heap_regions != NULL) {\n+    if (closed_heap_regions != nullptr) {\n@@ -1149,1 +1149,1 @@\n-    if (open_heap_regions != NULL) {\n+    if (open_heap_regions != nullptr) {\n@@ -1183,1 +1183,1 @@\n-  if (closed_heap_regions != NULL) {\n+  if (closed_heap_regions != nullptr) {\n@@ -1242,1 +1242,1 @@\n-  if (closed_heap_regions != NULL) {\n+  if (closed_heap_regions != nullptr) {\n@@ -1258,1 +1258,1 @@\n-  int arr_len = regions == NULL ? 0 : regions->length();\n+  int arr_len = regions == nullptr ? 0 : regions->length();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,1 +162,1 @@\n-        _buffered_addr = NULL;\n+        _buffered_addr = nullptr;\n@@ -170,2 +170,2 @@\n-      assert(_buffered_addr == NULL, \"cannot be copied twice\");\n-      assert(addr != NULL, \"must be a valid copy\");\n+      assert(_buffered_addr == nullptr, \"cannot be copied twice\");\n+      assert(addr != nullptr, \"must be a valid copy\");\n@@ -425,1 +425,1 @@\n-    return (_current != NULL);\n+    return (_current != nullptr);\n@@ -430,1 +430,1 @@\n-    assert(_current != NULL, \"ArchiveBuilder must be active\");\n+    assert(_current != nullptr, \"ArchiveBuilder must be active\");\n@@ -450,1 +450,1 @@\n-    assert(klass != NULL && klass->is_klass(), \"must be\");\n+    assert(klass != nullptr && klass->is_klass(), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -452,1 +452,1 @@\n-    \/\/ must be NULL, or must point to a valid object in the loaded regions.\n+    \/\/ must be null, or must point to a valid object in the loaded regions.\n@@ -543,1 +543,1 @@\n-    if (r->mapped_base() != NULL && r->has_ptrmap()) {\n+    if (r->mapped_base() != nullptr && r->has_ptrmap()) {\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,1 +106,1 @@\n-  inline static oop decode_from_archive(narrowOop v) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  inline static oop decode_from_archive(narrowOop v) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n@@ -109,1 +109,1 @@\n-  inline static oop decode_from_mapped_archive(narrowOop v) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  inline static oop decode_from_mapped_archive(narrowOop v) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n@@ -175,1 +175,1 @@\n-  inline static oop decode_from_archive_impl(narrowOop v) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  inline static oop decode_from_archive_impl(narrowOop v) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-CHeapBitMap* ArchivePtrMarker::_ptrmap = NULL;\n+CHeapBitMap* ArchivePtrMarker::_ptrmap = nullptr;\n@@ -53,1 +53,1 @@\n-  assert(_ptrmap == NULL, \"initialize only once\");\n+  assert(_ptrmap == nullptr, \"initialize only once\");\n@@ -70,1 +70,1 @@\n-  assert(_ptrmap != NULL, \"not initialized\");\n+  assert(_ptrmap != nullptr, \"not initialized\");\n@@ -77,1 +77,1 @@\n-    \/\/ to nothing (NULL) vs a pointer to an objects that happens to be at the very bottom\n+    \/\/ to nothing (null) vs a pointer to an objects that happens to be at the very bottom\n@@ -81,1 +81,1 @@\n-    if (value != NULL) {\n+    if (value != nullptr) {\n@@ -95,1 +95,1 @@\n-  assert(_ptrmap != NULL, \"not initialized\");\n+  assert(_ptrmap != nullptr, \"not initialized\");\n@@ -121,1 +121,1 @@\n-    if (ptr_value != NULL) {\n+    if (ptr_value != nullptr) {\n@@ -128,1 +128,1 @@\n-      DEBUG_ONLY(log_trace(cds, reloc)(\"Clearing pointer [\" PTR_FORMAT  \"] -> NULL @ \" SIZE_FORMAT_W(9), p2i(ptr_loc), offset));\n+      DEBUG_ONLY(log_trace(cds, reloc)(\"Clearing pointer [\" PTR_FORMAT  \"] -> null @ \" SIZE_FORMAT_W(9), p2i(ptr_loc), offset));\n@@ -256,1 +256,1 @@\n-  if (next != NULL) {\n+  if (next != nullptr) {\n@@ -265,1 +265,1 @@\n-  if (*o == NULL) {\n+  if (*o == nullptr) {\n@@ -291,1 +291,1 @@\n-  assert(*p == NULL, \"initializing previous initialized pointer.\");\n+  assert(*p == nullptr, \"initializing previous initialized pointer.\");\n@@ -320,1 +320,1 @@\n-      *p = NULL;\n+      *p = nullptr;\n@@ -329,1 +329,1 @@\n-      *p = NULL;\n+      *p = nullptr;\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,1 +145,1 @@\n-    : _name(name), _base(NULL), _top(NULL), _end(NULL),\n+    : _name(name), _base(nullptr), _top(nullptr), _end(nullptr),\n@@ -160,1 +160,1 @@\n-    return !is_packed() && _base != NULL;\n+    return !is_packed() && _base != nullptr;\n@@ -168,1 +168,1 @@\n-  void pack(DumpRegion* next = NULL);\n+  void pack(DumpRegion* next = nullptr);\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  assert(old_ptr != NULL, \"bits for NULL pointers should have been cleaned at dump time\");\n+  assert(old_ptr != nullptr, \"bits for null pointers should have been cleaned at dump time\");\n@@ -41,1 +41,1 @@\n-  assert(new_ptr != NULL, \"don't point to the bottom of the archive\"); \/\/ See ArchivePtrMarker::mark_pointer().\n+  assert(new_ptr != nullptr, \"don't point to the bottom of the archive\"); \/\/ See ArchivePtrMarker::mark_pointer().\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-# define ADD_EXCL(...) { static const char* e[] = {__VA_ARGS__, NULL}; add_exclusion(e); }\n+# define ADD_EXCL(...) { static const char* e[] = {__VA_ARGS__, nullptr}; add_exclusion(e); }\n@@ -169,1 +169,1 @@\n-    if (static_obj_field != NULL) {\n+    if (static_obj_field != nullptr) {\n@@ -171,2 +171,2 @@\n-      if (_exclusions != NULL) {\n-        for (const char** p = _exclusions; *p != NULL; p++) {\n+      if (_exclusions != nullptr) {\n+        for (const char** p = _exclusions; *p != nullptr; p++) {\n@@ -231,1 +231,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -239,1 +239,1 @@\n-    trace_to_root(&ls, orig_obj, NULL, &value);\n+    trace_to_root(&ls, orig_obj, nullptr, &value);\n@@ -270,2 +270,2 @@\n-  if (info != NULL) {\n-    trace_to_root(st, orig_obj, NULL, info);\n+  if (info != nullptr) {\n+    trace_to_root(st, orig_obj, nullptr, info);\n@@ -279,1 +279,1 @@\n-  if (info->_referrer != NULL) {\n+  if (info->_referrer != nullptr) {\n@@ -281,1 +281,1 @@\n-    assert(ref != NULL, \"sanity\");\n+    assert(ref != nullptr, \"sanity\");\n@@ -291,1 +291,1 @@\n-  if (orig_field != NULL) {\n+  if (orig_field != nullptr) {\n@@ -311,1 +311,0 @@\n-#ifdef ASSERT\n@@ -316,1 +315,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -85,1 +85,1 @@\n-  static void verify() NOT_DEBUG_RETURN;\n+  static void verify();\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    assert(pkg_entry != NULL, \"archived class in module image cannot be from unnamed package\");\n+    assert(pkg_entry != nullptr, \"archived class in module image cannot be from unnamed package\");\n@@ -86,1 +86,1 @@\n-    \/\/   Note that if an element of these 3 _shared_xxx arrays is NULL, it will be initialized by\n+    \/\/   Note that if an element of these 3 _shared_xxx arrays is null, it will be initialized by\n@@ -92,1 +92,1 @@\n-      if (pkg_entry == NULL || !pkg_entry->is_defined_by_cds_in_class_path(index_offset)) {\n+      if (pkg_entry == nullptr || !pkg_entry->is_defined_by_cds_in_class_path(index_offset)) {\n@@ -96,1 +96,1 @@\n-        if (pkg_entry != NULL) {\n+        if (pkg_entry != nullptr) {\n@@ -111,1 +111,1 @@\n-  if (pkg != NULL) { \/\/ Package prefix found\n+  if (pkg != nullptr) { \/\/ Package prefix found\n@@ -121,1 +121,1 @@\n-  if (MetaspaceShared::use_full_module_graph() && ik->is_shared() && pkg_entry != NULL) {\n+  if (MetaspaceShared::use_full_module_graph() && ik->is_shared() && pkg_entry != nullptr) {\n@@ -128,1 +128,1 @@\n-  if (pkg_name != NULL) {\n+  if (pkg_name != nullptr) {\n@@ -131,1 +131,1 @@\n-    pkg_entry = NULL;\n+    pkg_entry = nullptr;\n@@ -145,1 +145,1 @@\n-  \/\/ get_package_name() returns a NULL handle if the class is in unnamed package\n+  \/\/ get_package_name() returns a null handle if the class is in unnamed package\n@@ -180,1 +180,1 @@\n-  if (shared_jar_manifest(shared_path_index) == NULL) {\n+  if (shared_jar_manifest(shared_path_index) == nullptr) {\n@@ -189,1 +189,1 @@\n-    assert(src != NULL, \"No Manifest data\");\n+    assert(src != nullptr, \"No Manifest data\");\n@@ -200,1 +200,1 @@\n-  if (shared_jar_url(shared_path_index) == NULL) {\n+  if (shared_jar_url(shared_path_index) == nullptr) {\n@@ -243,1 +243,1 @@\n-  if (shared_protection_domain(shared_path_index) == NULL) {\n+  if (shared_protection_domain(shared_path_index) == nullptr) {\n@@ -260,1 +260,1 @@\n-  if (mod->shared_protection_domain() == NULL) {\n+  if (mod->shared_protection_domain() == nullptr) {\n@@ -262,1 +262,1 @@\n-    if (location != NULL) {\n+    if (location != nullptr) {\n@@ -304,1 +304,1 @@\n-  if (_shared_protection_domains.resolve() == NULL) {\n+  if (_shared_protection_domains.resolve() == nullptr) {\n@@ -316,1 +316,1 @@\n-  if (_shared_jar_urls.resolve() == NULL) {\n+  if (_shared_jar_urls.resolve() == nullptr) {\n@@ -328,1 +328,1 @@\n-  if (_shared_jar_manifests.resolve() == NULL) {\n+  if (_shared_jar_manifests.resolve() == nullptr) {\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-  product(ccstr, SharedArchiveConfigFile, NULL,                             \\\n+  product(ccstr, SharedArchiveConfigFile, nullptr,                             \\\n@@ -70,1 +70,1 @@\n-  develop(ccstr, ArchiveHeapTestClass, NULL,                                \\\n+  develop(ccstr, ArchiveHeapTestClass, nullptr,                                \\\n@@ -75,1 +75,1 @@\n-  product(ccstr, DumpLoadedClassList, NULL,                                 \\\n+  product(ccstr, DumpLoadedClassList, nullptr,                                 \\\n@@ -79,1 +79,1 @@\n-  product(ccstr, SharedClassListFile, NULL,                                 \\\n+  product(ccstr, SharedClassListFile, nullptr,                                 \\\n@@ -82,1 +82,1 @@\n-  product(ccstr, SharedArchiveFile, NULL,                                   \\\n+  product(ccstr, SharedArchiveFile, nullptr,                                   \\\n@@ -85,1 +85,1 @@\n-  product(ccstr, ArchiveClassesAtExit, NULL,                                \\\n+  product(ccstr, ArchiveClassesAtExit, nullptr,                                \\\n@@ -88,1 +88,1 @@\n-  product(ccstr, ExtraSharedClassListFile, NULL,                            \\\n+  product(ccstr, ExtraSharedClassListFile, nullptr,                            \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,2 @@\n-volatile Thread* ClassListParser::_parsing_thread = NULL;\n-ClassListParser* ClassListParser::_instance = NULL;\n+volatile Thread* ClassListParser::_parsing_thread = nullptr;\n+ClassListParser* ClassListParser::_instance = nullptr;\n@@ -61,1 +61,1 @@\n-  _file = NULL;\n+  _file = nullptr;\n@@ -70,1 +70,1 @@\n-  if (_file == NULL) {\n+  if (_file == nullptr) {\n@@ -81,1 +81,1 @@\n-  assert(_instance == NULL, \"must be singleton\");\n+  assert(_instance == nullptr, \"must be singleton\");\n@@ -91,1 +91,1 @@\n-  if (_file != NULL) {\n+  if (_file != nullptr) {\n@@ -94,1 +94,1 @@\n-  Atomic::store(&_parsing_thread, (Thread*)NULL);\n+  Atomic::store(&_parsing_thread, (Thread*)nullptr);\n@@ -97,1 +97,1 @@\n-  _instance = NULL;\n+  _instance = nullptr;\n@@ -133,1 +133,1 @@\n-      if (message != NULL) {\n+      if (message != nullptr) {\n@@ -144,1 +144,1 @@\n-    assert(klass != NULL, \"sanity\");\n+    assert(klass != nullptr, \"sanity\");\n@@ -168,1 +168,1 @@\n-    if (fgets(_line, sizeof(_line), _file) == NULL) {\n+    if (fgets(_line, sizeof(_line), _file) == nullptr) {\n@@ -210,1 +210,1 @@\n-  _source = NULL;\n+  _source = nullptr;\n@@ -219,1 +219,1 @@\n-  if ((_token = strchr(_line, ' ')) == NULL) {\n+  if ((_token = strchr(_line, ' ')) == nullptr) {\n@@ -245,1 +245,1 @@\n-      if (s == NULL) {\n+      if (s == nullptr) {\n@@ -287,1 +287,1 @@\n-  if ((ptr = strchr(_line, ' ')) == NULL) {\n+  if ((ptr = strchr(_line, ' ')) == nullptr) {\n@@ -448,1 +448,1 @@\n-  vm_exit_during_initialization(\"class list format error.\", NULL);\n+  vm_exit_during_initialization(\"class list format error.\", nullptr);\n@@ -547,1 +547,1 @@\n-    if (message != NULL) {\n+    if (message != nullptr) {\n@@ -643,1 +643,1 @@\n-    assert(obj != NULL, \"jdk.internal.loader.BuiltinClassLoader::loadClass never returns null\");\n+    assert(obj != nullptr, \"jdk.internal.loader.BuiltinClassLoader::loadClass never returns null\");\n@@ -651,1 +651,1 @@\n-  assert(klass != NULL, \"exception should have been thrown\");\n+  assert(klass != nullptr, \"exception should have been thrown\");\n@@ -672,1 +672,1 @@\n-  return (_source != NULL);\n+  return (_source != nullptr);\n@@ -677,1 +677,1 @@\n-  if (klass_ptr == NULL) {\n+  if (klass_ptr == nullptr) {\n@@ -680,1 +680,1 @@\n-  assert(*klass_ptr != NULL, \"must be\");\n+  assert(*klass_ptr != nullptr, \"must be\");\n@@ -687,1 +687,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -701,1 +701,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -724,1 +724,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  CDSIndyInfo() : _items(NULL) {}\n+  CDSIndyInfo() : _items(nullptr) {}\n@@ -44,1 +44,1 @@\n-    if (_items == NULL) {\n+    if (_items == nullptr) {\n@@ -47,1 +47,1 @@\n-    assert(_items != NULL, \"sanity\");\n+    assert(_items != nullptr, \"sanity\");\n@@ -147,1 +147,1 @@\n-    assert(_instance != NULL, \"must be\");\n+    assert(_instance != nullptr, \"must be\");\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-fileStream* ClassListWriter::_classlist_file = NULL;\n+fileStream* ClassListWriter::_classlist_file = nullptr;\n@@ -41,2 +41,2 @@\n-  if (DumpLoadedClassList != NULL) {\n-    const char* list_name = make_log_name(DumpLoadedClassList, NULL);\n+  if (DumpLoadedClassList != nullptr) {\n+    const char* list_name = make_log_name(DumpLoadedClassList, nullptr);\n@@ -59,1 +59,1 @@\n-    DumpLoadedClassList = NULL;\n+    DumpLoadedClassList = nullptr;\n@@ -72,1 +72,1 @@\n-ClassListWriter::IDTable* ClassListWriter::_id_table = NULL;\n+ClassListWriter::IDTable* ClassListWriter::_id_table = nullptr;\n@@ -77,1 +77,1 @@\n-  if (_id_table == NULL) {\n+  if (_id_table == nullptr) {\n@@ -90,2 +90,2 @@\n-  if (_id_table != NULL) {\n-    return _id_table->get(k) != NULL;\n+  if (_id_table != nullptr) {\n+    return _id_table->get(k) != nullptr;\n@@ -99,1 +99,1 @@\n-  if (_id_table != NULL) {\n+  if (_id_table != nullptr) {\n@@ -135,1 +135,1 @@\n-    if (super != NULL && !has_id(super)) {\n+    if (super != nullptr && !has_id(super)) {\n@@ -161,1 +161,1 @@\n-    assert(super != NULL, \"must be\");\n+    assert(super != nullptr, \"must be\");\n@@ -188,1 +188,1 @@\n-  if (_classlist_file != NULL) {\n+  if (_classlist_file != nullptr) {\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-    return _classlist_file != NULL && _classlist_file->is_open();\n+    return _classlist_file != nullptr && _classlist_file->is_open();\n@@ -68,1 +68,1 @@\n-  static void write_to_stream(const InstanceKlass* k, outputStream* stream, const ClassFileStream* cfs = NULL) NOT_CDS_RETURN;\n+  static void write_to_stream(const InstanceKlass* k, outputStream* stream, const ClassFileStream* cfs = nullptr) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/classListWriter.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-ClassPrelinker::ClassesTable* ClassPrelinker::_processed_classes = NULL;\n-ClassPrelinker::ClassesTable* ClassPrelinker::_vm_classes = NULL;\n+ClassPrelinker::ClassesTable* ClassPrelinker::_processed_classes = nullptr;\n+ClassPrelinker::ClassesTable* ClassPrelinker::_vm_classes = nullptr;\n@@ -40,1 +40,1 @@\n-  return (_vm_classes->get(ik) != NULL);\n+  return (_vm_classes->get(ik) != nullptr);\n@@ -48,1 +48,1 @@\n-    if (super != NULL) {\n+    if (super != nullptr) {\n@@ -59,1 +59,1 @@\n-  assert(_vm_classes == NULL, \"must be\");\n+  assert(_vm_classes == nullptr, \"must be\");\n@@ -68,1 +68,1 @@\n-  assert(_vm_classes != NULL, \"must be\");\n+  assert(_vm_classes != nullptr, \"must be\");\n@@ -71,2 +71,2 @@\n-  _vm_classes = NULL;\n-  _processed_classes = NULL;\n+  _vm_classes = nullptr;\n+  _processed_classes = nullptr;\n@@ -80,1 +80,1 @@\n-  assert(resolved_klass != NULL, \"must be\");\n+  assert(resolved_klass != nullptr, \"must be\");\n@@ -118,2 +118,2 @@\n-  if (cp->cache() == NULL || cp->reference_map() == NULL) {\n-    \/\/ The cache may be NULL if the pool_holder klass fails verification\n+  if (cp->cache() == nullptr || cp->reference_map() == nullptr) {\n+    \/\/ The cache may be null if the pool_holder klass fails verification\n@@ -149,1 +149,1 @@\n-  if (k != NULL) {\n+  if (k != nullptr) {\n@@ -155,1 +155,1 @@\n-    return find_loaded_class(THREAD, NULL, name);\n+    return find_loaded_class(THREAD, nullptr, name);\n@@ -158,1 +158,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -169,1 +169,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -174,1 +174,1 @@\n-  if (resolved_klass != NULL && can_archive_resolved_klass(cp_holder, resolved_klass)) {\n+  if (resolved_klass != nullptr && can_archive_resolved_klass(cp_holder, resolved_klass)) {\n@@ -196,1 +196,1 @@\n-  if (!Thread::current()->is_VM_thread() || ArchiveBuilder::current() == NULL) {\n+  if (!Thread::current()->is_VM_thread() || ArchiveBuilder::current() == nullptr) {\n","filename":"src\/hotspot\/share\/cds\/classPrelinker.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,1 @@\n-\/\/   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return NULL}; };\n+\/\/   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return nullptr}; };\n@@ -152,1 +152,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -215,1 +215,1 @@\n-CppVtableInfo** CppVtables::_index = NULL;\n+CppVtableInfo** CppVtables::_index = nullptr;\n@@ -280,1 +280,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-      return NULL;\n+      return nullptr;\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,3 +49,3 @@\n-  _verifier_constraints = NULL;\n-  _verifier_constraint_flags = NULL;\n-  _loader_constraints = NULL;\n+  _verifier_constraints = nullptr;\n+  _verifier_constraint_flags = nullptr;\n+  _loader_constraints = nullptr;\n@@ -53,2 +53,2 @@\n-  assert(src._enum_klass_static_fields == NULL, \"This should not happen with dynamic dump.\");\n-  _enum_klass_static_fields = NULL;\n+  assert(src._enum_klass_static_fields == nullptr, \"This should not happen with dynamic dump.\");\n+  _enum_klass_static_fields = nullptr;\n@@ -80,2 +80,2 @@\n-  if (_verifier_constraints != NULL) {\n-    assert(_verifier_constraint_flags != NULL, \"must be\");\n+  if (_verifier_constraints != nullptr) {\n+    assert(_verifier_constraint_flags != nullptr, \"must be\");\n@@ -85,1 +85,1 @@\n-  if (_loader_constraints != NULL) {\n+  if (_loader_constraints != nullptr) {\n@@ -98,1 +98,1 @@\n-  if (_verifier_constraints == NULL) {\n+  if (_verifier_constraints == nullptr) {\n@@ -101,1 +101,1 @@\n-  if (_verifier_constraint_flags == NULL) {\n+  if (_verifier_constraint_flags == nullptr) {\n@@ -143,1 +143,1 @@\n-  if (_loader_constraints == NULL) {\n+  if (_loader_constraints == nullptr) {\n@@ -175,1 +175,1 @@\n-  if (_enum_klass_static_fields == NULL) {\n+  if (_enum_klass_static_fields == nullptr) {\n@@ -182,1 +182,1 @@\n-  assert(_enum_klass_static_fields != NULL, \"must be\");\n+  assert(_enum_klass_static_fields != nullptr, \"must be\");\n@@ -202,1 +202,1 @@\n-  assert(p != NULL, \"we must not see any non-shared InstanceKlass* that's \"\n+  assert(p != nullptr, \"we must not see any non-shared InstanceKlass* that's \"\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    DTLoaderConstraint() : _name(NULL), _loader_type1('0'), _loader_type2('0') {}\n+    DTLoaderConstraint() : _name(nullptr), _loader_type1('0'), _loader_type2('0') {}\n@@ -87,1 +87,1 @@\n-    DTVerifierConstraint() : _name(NULL), _from_name(NULL) {}\n+    DTVerifierConstraint() : _name(nullptr), _from_name(nullptr) {}\n@@ -133,2 +133,2 @@\n-    _klass = NULL;\n-    _nest_host = NULL;\n+    _klass = nullptr;\n+    _nest_host = nullptr;\n@@ -143,4 +143,4 @@\n-    _verifier_constraints = NULL;\n-    _verifier_constraint_flags = NULL;\n-    _loader_constraints = NULL;\n-    _enum_klass_static_fields = NULL;\n+    _verifier_constraints = nullptr;\n+    _verifier_constraint_flags = nullptr;\n+    _loader_constraints = nullptr;\n+    _enum_klass_static_fields = nullptr;\n@@ -162,1 +162,1 @@\n-    if (array == NULL) {\n+    if (array == nullptr) {\n@@ -186,1 +186,1 @@\n-    if (_verifier_constraints != NULL) {\n+    if (_verifier_constraints != nullptr) {\n@@ -191,1 +191,1 @@\n-    if (_loader_constraints != NULL) {\n+    if (_loader_constraints != nullptr) {\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,1 +204,1 @@\n-  assert(mapinfo != NULL && _header == mapinfo->dynamic_header(), \"must be\");\n+  assert(mapinfo != nullptr && _header == mapinfo->dynamic_header(), \"must be\");\n@@ -207,1 +207,1 @@\n-  _header = NULL;\n+  _header = nullptr;\n@@ -228,1 +228,1 @@\n-  assert(ik != NULL, \"DynamicArchiveBuilder currently doesn't support dumping the base archive\");\n+  assert(ik != nullptr, \"DynamicArchiveBuilder currently doesn't support dumping the base archive\");\n@@ -234,2 +234,2 @@\n-  if (ik->java_mirror() == NULL) {\n-    \/\/ NULL mirror means this class has already been visited and methods are already sorted\n+  if (ik->java_mirror() == nullptr) {\n+    \/\/ null mirror means this class has already been visited and methods are already sorted\n@@ -260,1 +260,1 @@\n-  if (ik->methods() != NULL) {\n+  if (ik->methods() != nullptr) {\n@@ -266,1 +266,1 @@\n-  if (ik->default_methods() != NULL) {\n+  if (ik->default_methods() != nullptr) {\n@@ -275,1 +275,1 @@\n-  if (ik->default_methods() != NULL) {\n+  if (ik->default_methods() != nullptr) {\n@@ -323,1 +323,1 @@\n-  assert(dynamic_info != NULL, \"Sanity\");\n+  assert(dynamic_info != nullptr, \"Sanity\");\n@@ -326,1 +326,1 @@\n-  ArchiveBuilder::write_archive(dynamic_info, NULL, NULL, NULL, NULL);\n+  ArchiveBuilder::write_archive(dynamic_info, nullptr, nullptr, nullptr, nullptr);\n@@ -370,1 +370,1 @@\n-      vm_exit_during_initialization(\"-XX:+RecordDynamicDumpInfo\" __THEMSG, NULL);\n+      vm_exit_during_initialization(\"-XX:+RecordDynamicDumpInfo\" __THEMSG, nullptr);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-  static bool is_mapped() { return FileMapInfo::dynamic_info() != NULL; }\n+  static bool is_mapped() { return FileMapInfo::dynamic_info() != nullptr; }\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-  vm_exit_during_initialization(\"Unable to use shared archive.\", NULL);\n+  vm_exit_during_initialization(\"Unable to use shared archive.\", nullptr);\n@@ -183,1 +183,1 @@\n-    assert(_current_info == NULL, \"must be singleton\"); \/\/ not thread safe\n+    assert(_current_info == nullptr, \"must be singleton\"); \/\/ not thread safe\n@@ -186,1 +186,1 @@\n-    assert(_dynamic_archive_info == NULL, \"must be singleton\"); \/\/ not thread safe\n+    assert(_dynamic_archive_info == nullptr, \"must be singleton\"); \/\/ not thread safe\n@@ -194,1 +194,1 @@\n-    _current_info = NULL;\n+    _current_info = nullptr;\n@@ -197,1 +197,1 @@\n-    _dynamic_archive_info = NULL;\n+    _dynamic_archive_info = nullptr;\n@@ -210,1 +210,1 @@\n-  assert(_header == NULL, \"Sanity check\");\n+  assert(_header == nullptr, \"Sanity check\");\n@@ -431,1 +431,1 @@\n-  if (ent->is_jar() && !ent->is_signed() && ent->manifest() != NULL) {\n+  if (ent->is_jar() && !ent->is_signed() && ent->manifest() != nullptr) {\n@@ -564,1 +564,1 @@\n-  assert(jrt != NULL,\n+  assert(jrt != nullptr,\n@@ -567,1 +567,1 @@\n-  if (_saved_shared_path_table_array != NULL) {\n+  if (_saved_shared_path_table_array != nullptr) {\n@@ -569,1 +569,1 @@\n-    _saved_shared_path_table_array = NULL;\n+    _saved_shared_path_table_array = nullptr;\n@@ -581,1 +581,1 @@\n-  assert(jrt != NULL,\n+  assert(jrt != nullptr,\n@@ -602,1 +602,1 @@\n-  while (cpe != NULL) {\n+  while (cpe != nullptr) {\n@@ -646,1 +646,1 @@\n-    ClassLoader::exit_with_path_failure(\"Cannot have non-empty directory in paths\", NULL);\n+    ClassLoader::exit_with_path_failure(\"Cannot have non-empty directory in paths\", nullptr);\n@@ -653,1 +653,1 @@\n-  if (_non_existent_class_paths == NULL) {\n+  if (_non_existent_class_paths == nullptr) {\n@@ -661,1 +661,1 @@\n-  if (_non_existent_class_paths != NULL) {\n+  if (_non_existent_class_paths != nullptr) {\n@@ -732,1 +732,1 @@\n-        if (value != NULL) {\n+        if (value != nullptr) {\n@@ -734,1 +734,1 @@\n-          if (strstr((char*)attr, \"-Digest\") != NULL) {\n+          if (strstr((char*)attr, \"-Digest\") != nullptr) {\n@@ -755,1 +755,1 @@\n-  if (manifest != NULL) {\n+  if (manifest != nullptr) {\n@@ -776,1 +776,1 @@\n-  if (p != NULL) {\n+  if (p != nullptr) {\n@@ -793,1 +793,1 @@\n-  if (path == NULL) {\n+  if (path == nullptr) {\n@@ -798,1 +798,1 @@\n-  while (p != NULL) {\n+  while (p != nullptr) {\n@@ -801,1 +801,1 @@\n-    if (p != NULL) {\n+    if (p != nullptr) {\n@@ -831,1 +831,1 @@\n-  while (cpe != NULL) {\n+  while (cpe != nullptr) {\n@@ -852,2 +852,2 @@\n-      if (canonical_path != NULL) {\n-        char* error_msg = NULL;\n+      if (canonical_path != nullptr) {\n+        char* error_msg = nullptr;\n@@ -855,1 +855,1 @@\n-        if (zip != NULL && error_msg == NULL) {\n+        if (zip != nullptr && error_msg == nullptr) {\n@@ -942,1 +942,1 @@\n-  if (dp_len == 0 && rp == NULL) {\n+  if (dp_len == 0 && rp == nullptr) {\n@@ -944,1 +944,1 @@\n-  } else if (dp_len == 0 && rp != NULL) {\n+  } else if (dp_len == 0 && rp != nullptr) {\n@@ -955,1 +955,1 @@\n-  } else if (dp_len > 0 && rp != NULL) {\n+  } else if (dp_len > 0 && rp != nullptr) {\n@@ -987,1 +987,1 @@\n-  assert(appcp != NULL, \"NULL app classpath\");\n+  assert(appcp != nullptr, \"null app classpath\");\n@@ -1112,1 +1112,1 @@\n-        if (_dynamic_archive_info != NULL && _dynamic_archive_info->_is_static) {\n+        if (_dynamic_archive_info != nullptr && _dynamic_archive_info->_is_static) {\n@@ -1121,1 +1121,1 @@\n-        if (_dynamic_archive_info != NULL && _dynamic_archive_info->_is_static) {\n+        if (_dynamic_archive_info != nullptr && _dynamic_archive_info->_is_static) {\n@@ -1147,1 +1147,1 @@\n-  if (_classpath_entries_for_jvmti != NULL) {\n+  if (_classpath_entries_for_jvmti != nullptr) {\n@@ -1212,1 +1212,1 @@\n-    assert(_archive_name != nullptr, \"Archive name is NULL\");\n+    assert(_archive_name != nullptr, \"Archive name is null\");\n@@ -1223,1 +1223,1 @@\n-    assert(_archive_name != nullptr, \"Archive name is NULL\");\n+    assert(_archive_name != nullptr, \"Archive name is null\");\n@@ -1361,1 +1361,1 @@\n-\/\/ true && (*base_archive_name) == NULL:\n+\/\/ true && (*base_archive_name) == nullptr:\n@@ -1363,1 +1363,1 @@\n-\/\/ true && (*base_archive_name) != NULL:\n+\/\/ true && (*base_archive_name) != nullptr:\n@@ -1368,1 +1368,1 @@\n-  *base_archive_name = NULL;\n+  *base_archive_name = nullptr;\n@@ -1568,1 +1568,1 @@\n-  _mapped_base = NULL;\n+  _mapped_base = nullptr;\n@@ -1630,1 +1630,1 @@\n-    requested_base = NULL; \/\/ always NULL for bm region\n+    requested_base = nullptr; \/\/ always null for bm region\n@@ -1633,1 +1633,1 @@\n-    requested_base = NULL;\n+    requested_base = nullptr;\n@@ -1663,1 +1663,1 @@\n-  if (base != NULL) {\n+  if (base != nullptr) {\n@@ -1691,1 +1691,1 @@\n-  if (closed_bitmaps != NULL && open_bitmaps != NULL) {\n+  if (closed_bitmaps != nullptr && open_bitmaps != nullptr) {\n@@ -1700,1 +1700,1 @@\n-  if (closed_bitmaps != NULL && open_bitmaps != NULL) {\n+  if (closed_bitmaps != nullptr && open_bitmaps != nullptr) {\n@@ -1745,1 +1745,1 @@\n-  int arr_len = regions == NULL ? 0 : regions->length();\n+  int arr_len = regions == nullptr ? 0 : regions->length();\n@@ -1756,1 +1756,1 @@\n-    char* start = NULL;\n+    char* start = nullptr;\n@@ -1853,1 +1853,1 @@\n-  if (base == NULL) {\n+  if (base == nullptr) {\n@@ -1870,1 +1870,1 @@\n-  DEBUG_ONLY(FileMapRegion* last_region = NULL);\n+  DEBUG_ONLY(FileMapRegion* last_region = nullptr);\n@@ -1884,1 +1884,1 @@\n-    DEBUG_ONLY(if (last_region != NULL) {\n+    DEBUG_ONLY(if (last_region != nullptr) {\n@@ -1933,2 +1933,2 @@\n-  assert(r->mapped_base() == NULL, \"must be not mapped yet\");\n-  assert(requested_addr != NULL, \"must be specified\");\n+  assert(r->mapped_base() == nullptr, \"must be not mapped yet\");\n+  assert(requested_addr != nullptr, \"must be specified\");\n@@ -1987,1 +1987,1 @@\n-  if (r->mapped_base() != NULL) {\n+  if (r->mapped_base() != nullptr) {\n@@ -1991,1 +1991,1 @@\n-  char* requested_addr = NULL; \/\/ allow OS to pick any location\n+  char* requested_addr = nullptr; \/\/ allow OS to pick any location\n@@ -1994,1 +1994,1 @@\n-  if (bitmap_base == NULL) {\n+  if (bitmap_base == nullptr) {\n@@ -1996,1 +1996,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2004,1 +2004,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2022,1 +2022,1 @@\n-  if (bitmap_base == NULL) {\n+  if (bitmap_base == nullptr) {\n@@ -2083,2 +2083,2 @@\n-static MemRegion *closed_heap_regions = NULL;\n-static MemRegion *open_heap_regions = NULL;\n+static MemRegion *closed_heap_regions = nullptr;\n+static MemRegion *open_heap_regions = nullptr;\n@@ -2099,1 +2099,1 @@\n-  address end   = NULL;\n+  address end   = nullptr;\n@@ -2119,1 +2119,1 @@\n-  assert(end != NULL, \"must have at least one used heap region\");\n+  assert(end != nullptr, \"must have at least one used heap region\");\n@@ -2322,1 +2322,1 @@\n-    if (bitmap_base == NULL) {\n+    if (bitmap_base == nullptr) {\n@@ -2350,1 +2350,1 @@\n-    assert(closed_heap_regions == NULL &&\n+    assert(closed_heap_regions == nullptr &&\n@@ -2355,1 +2355,1 @@\n-    assert(open_heap_regions == NULL && num_open_heap_regions == 0, \"sanity\");\n+    assert(open_heap_regions == nullptr && num_open_heap_regions == 0, \"sanity\");\n@@ -2416,1 +2416,1 @@\n-    if (base == NULL || base != addr) {\n+    if (base == nullptr || base != addr) {\n@@ -2466,1 +2466,1 @@\n-  assert(bitmap_base != NULL, \"must have already been mapped\");\n+  assert(bitmap_base != nullptr, \"must have already been mapped\");\n@@ -2483,1 +2483,1 @@\n-  \/\/ Note that closed_heap_regions may be non-NULL even if no regions were found.\n+  \/\/ Note that closed_heap_regions may be non-null even if no regions were found.\n@@ -2485,1 +2485,1 @@\n-    assert(closed_heap_regions != NULL,\n+    assert(closed_heap_regions != nullptr,\n@@ -2498,1 +2498,1 @@\n-    assert(open_heap_regions != NULL, \"NULL open_heap_regions array with non-zero count\");\n+    assert(open_heap_regions != nullptr, \"Null open_heap_regions array with non-zero count\");\n@@ -2514,1 +2514,1 @@\n-    assert(regions != NULL, \"Null archive regions array with non-zero count\");\n+    assert(regions != nullptr, \"Null archive regions array with non-zero count\");\n@@ -2555,1 +2555,1 @@\n-  if (mapped_base != NULL) {\n+  if (mapped_base != nullptr) {\n@@ -2563,1 +2563,1 @@\n-    r->set_mapped_base(NULL);\n+    r->set_mapped_base(nullptr);\n@@ -2581,2 +2581,2 @@\n-FileMapInfo* FileMapInfo::_current_info = NULL;\n-FileMapInfo* FileMapInfo::_dynamic_archive_info = NULL;\n+FileMapInfo* FileMapInfo::_current_info = nullptr;\n+FileMapInfo* FileMapInfo::_dynamic_archive_info = nullptr;\n@@ -2586,1 +2586,1 @@\n-Array<u8>*      FileMapInfo::_saved_shared_path_table_array = NULL;\n+Array<u8>*      FileMapInfo::_saved_shared_path_table_array = nullptr;\n@@ -2589,1 +2589,1 @@\n-GrowableArray<const char*>* FileMapInfo::_non_existent_class_paths = NULL;\n+GrowableArray<const char*>* FileMapInfo::_non_existent_class_paths = nullptr;\n@@ -2682,1 +2682,1 @@\n-  if (prop != NULL) {\n+  if (prop != nullptr) {\n@@ -2760,1 +2760,1 @@\n-  MetaspaceShared::set_shared_metaspace_range(NULL, NULL, NULL);\n+  MetaspaceShared::set_shared_metaspace_range(nullptr, nullptr, nullptr);\n@@ -2782,1 +2782,1 @@\n-ClassPathEntry** FileMapInfo::_classpath_entries_for_jvmti = NULL;\n+ClassPathEntry** FileMapInfo::_classpath_entries_for_jvmti = nullptr;\n@@ -2791,1 +2791,1 @@\n-  if (ent == NULL) {\n+  if (ent == nullptr) {\n@@ -2800,1 +2800,1 @@\n-      THROW_MSG_(vmSymbols::java_io_IOException(), msg, NULL);\n+      THROW_MSG_(vmSymbols::java_io_IOException(), msg, nullptr);\n@@ -2803,1 +2803,1 @@\n-      if (ent == NULL) {\n+      if (ent == nullptr) {\n@@ -2806,1 +2806,1 @@\n-        THROW_MSG_(vmSymbols::java_io_IOException(), msg, NULL);\n+        THROW_MSG_(vmSymbols::java_io_IOException(), msg, nullptr);\n@@ -2811,1 +2811,1 @@\n-    if (_classpath_entries_for_jvmti[i] == NULL) {\n+    if (_classpath_entries_for_jvmti[i] == nullptr) {\n@@ -2829,1 +2829,1 @@\n-  assert(cpe != NULL, \"must be\");\n+  assert(cpe != nullptr, \"must be\");\n@@ -2837,1 +2837,1 @@\n-  assert(cfs != NULL, \"must be able to read the classfile data of shared classes for built-in loaders.\");\n+  assert(cfs != nullptr, \"must be able to read the classfile data of shared classes for built-in loaders.\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":87,"deletions":87,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-    return (_manifest == NULL) ? NULL : (const char*)_manifest->data();\n+    return (_manifest == nullptr) ? nullptr : (const char*)_manifest->data();\n@@ -94,1 +94,1 @@\n-    return (_manifest == NULL) ? 0 : _manifest->length();\n+    return (_manifest == nullptr) ? 0 : _manifest->length();\n@@ -118,1 +118,1 @@\n-  SharedPathTable() : _table(NULL), _size(0) {}\n+  SharedPathTable() : _table(nullptr), _size(0) {}\n@@ -129,1 +129,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -432,1 +432,1 @@\n-    NOT_CDS(return NULL;)\n+    NOT_CDS(return nullptr;)\n@@ -441,1 +441,1 @@\n-    NOT_CDS(return NULL;)\n+    NOT_CDS(return nullptr;)\n@@ -564,1 +564,1 @@\n-  char* skip_first_path_entry(const char* path) NOT_CDS_RETURN_(NULL);\n+  char* skip_first_path_entry(const char* path) NOT_CDS_RETURN_(nullptr);\n@@ -567,2 +567,2 @@\n-  GrowableArray<const char*>* create_dumptime_app_classpath_array() NOT_CDS_RETURN_(NULL);\n-  GrowableArray<const char*>* create_path_array(const char* path) NOT_CDS_RETURN_(NULL);\n+  GrowableArray<const char*>* create_dumptime_app_classpath_array() NOT_CDS_RETURN_(nullptr);\n+  GrowableArray<const char*>* create_path_array(const char* path) NOT_CDS_RETURN_(nullptr);\n@@ -593,3 +593,3 @@\n-  address heap_region_dumptime_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n-  address heap_region_requested_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n-  address heap_region_mapped_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  address heap_region_dumptime_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  address heap_region_requested_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  address heap_region_mapped_address(FileMapRegion* r) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -75,1 +76,1 @@\n-  : klass_name(k), field_name(f), klass(NULL), offset(0), type(T_ILLEGAL) {}\n+  : klass_name(k), field_name(f), klass(nullptr), offset(0), type(T_ILLEGAL) {}\n@@ -78,1 +79,1 @@\n-    return klass_name != NULL;\n+    return klass_name != nullptr;\n@@ -83,2 +84,2 @@\n-DumpedInternedStrings *HeapShared::_dumped_interned_strings = NULL;\n-GrowableArrayCHeap<Metadata**, mtClassShared>* HeapShared::_native_pointers = NULL;\n+DumpedInternedStrings *HeapShared::_dumped_interned_strings = nullptr;\n+GrowableArrayCHeap<Metadata**, mtClassShared>* HeapShared::_native_pointers = nullptr;\n@@ -93,4 +94,4 @@\n-static Array<char>* _archived_ArchiveHeapTestClass = NULL;\n-static const char* _test_class_name = NULL;\n-static const Klass* _test_class = NULL;\n-static const ArchivedKlassSubGraphInfoRecord* _test_class_record = NULL;\n+static Array<char>* _archived_ArchiveHeapTestClass = nullptr;\n+static const char* _test_class_name = nullptr;\n+static const Klass* _test_class = nullptr;\n+static const ArchivedKlassSubGraphInfoRecord* _test_class_record = nullptr;\n@@ -115,1 +116,1 @@\n-  {NULL, NULL},\n+  {nullptr, nullptr},\n@@ -125,1 +126,1 @@\n-  {NULL, NULL}, \/\/ Extra slot for -XX:ArchiveHeapTestClass\n+  {nullptr, nullptr}, \/\/ Extra slot for -XX:ArchiveHeapTestClass\n@@ -127,1 +128,1 @@\n-  {NULL, NULL},\n+  {nullptr, nullptr},\n@@ -135,1 +136,1 @@\n-  {NULL, NULL},\n+  {nullptr, nullptr},\n@@ -138,1 +139,2 @@\n-GrowableArrayCHeap<oop, mtClassShared>* HeapShared::_pending_roots = NULL;\n+KlassSubGraphInfo* HeapShared::_default_subgraph_info;\n+GrowableArrayCHeap<oop, mtClassShared>* HeapShared::_pending_roots = nullptr;\n@@ -140,0 +142,2 @@\n+OopHandle HeapShared::_scratch_basic_type_mirrors[T_VOID+1];\n+KlassToOopHandleTable* HeapShared::_scratch_java_mirror_table = nullptr;\n@@ -176,1 +180,1 @@\n-  while (klass != NULL) {\n+  while (klass != nullptr) {\n@@ -178,1 +182,1 @@\n-    if (method != NULL) {\n+    if (method != nullptr) {\n@@ -217,2 +221,2 @@\n-HeapShared::ArchivedObjectCache* HeapShared::_archived_object_cache = NULL;\n-HeapShared::OriginalObjectTable* HeapShared::_original_object_table = NULL;\n+HeapShared::ArchivedObjectCache* HeapShared::_archived_object_cache = nullptr;\n+HeapShared::OriginalObjectTable* HeapShared::_original_object_table = nullptr;\n@@ -223,1 +227,1 @@\n-  if (p != NULL) {\n+  if (p != nullptr) {\n@@ -226,1 +230,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -236,1 +240,1 @@\n-  if (_pending_roots == NULL) {\n+  if (_pending_roots == nullptr) {\n@@ -247,1 +251,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -254,1 +258,1 @@\n-  assert(roots != NULL, \"should have been initialized\");\n+  assert(roots != nullptr, \"should have been initialized\");\n@@ -263,1 +267,1 @@\n-    assert(_pending_roots != NULL, \"sanity\");\n+    assert(_pending_roots != nullptr, \"sanity\");\n@@ -284,1 +288,1 @@\n-    roots()->obj_at_put(index, NULL);\n+    roots()->obj_at_put(index, nullptr);\n@@ -294,1 +298,1 @@\n-  if (ao != NULL) {\n+  if (ao != nullptr) {\n@@ -303,1 +307,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -307,1 +311,1 @@\n-  if (archived_oop != NULL) {\n+  if (archived_oop != nullptr) {\n@@ -326,1 +330,1 @@\n-    if (_original_object_table != NULL) {\n+    if (_original_object_table != nullptr) {\n@@ -346,5 +350,29 @@\n-void HeapShared::archive_klass_objects() {\n-  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n-  assert(klasses != NULL, \"sanity\");\n-  for (int i = 0; i < klasses->length(); i++) {\n-    Klass* k = ArchiveBuilder::get_buffered_klass(klasses->at(i));\n+class KlassToOopHandleTable: public ResourceHashtable<Klass*, OopHandle,\n+    36137, \/\/ prime number\n+    AnyObj::C_HEAP,\n+    mtClassShared> {\n+public:\n+  oop get_oop(Klass* k) {\n+    MutexLocker ml(ScratchObjects_lock, Mutex::_no_safepoint_check_flag);\n+    OopHandle* handle = get(k);\n+    if (handle != nullptr) {\n+      return handle->resolve();\n+    } else {\n+      return nullptr;\n+    }\n+  }\n+  void set_oop(Klass* k, oop o) {\n+    MutexLocker ml(ScratchObjects_lock, Mutex::_no_safepoint_check_flag);\n+    OopHandle handle(Universe::vm_global(), o);\n+    bool is_new = put(k, handle);\n+    assert(is_new, \"cannot set twice\");\n+  }\n+  void remove_oop(Klass* k) {\n+    MutexLocker ml(ScratchObjects_lock, Mutex::_no_safepoint_check_flag);\n+    OopHandle* handle = get(k);\n+    if (handle != nullptr) {\n+      handle->release(Universe::vm_global());\n+      remove(k);\n+    }\n+  }\n+};\n@@ -352,2 +380,10 @@\n-    \/\/ archive mirror object\n-    java_lang_Class::archive_mirror(k);\n+void HeapShared::init_scratch_objects(TRAPS) {\n+  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+    BasicType bt = (BasicType)i;\n+    if (!is_reference_type(bt)) {\n+      oop m = java_lang_Class::create_basic_type_mirror(type2name(bt), bt, CHECK);\n+      _scratch_basic_type_mirrors[i] = OopHandle(Universe::vm_global(), m);\n+    }\n+  }\n+  _scratch_java_mirror_table = new (mtClass)KlassToOopHandleTable();\n+}\n@@ -355,4 +391,57 @@\n-    \/\/ archive the resolved_referenes array\n-    if (k->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      ik->constants()->archive_resolved_references();\n+oop HeapShared::scratch_java_mirror(BasicType t) {\n+  assert((uint)t < T_VOID+1, \"range check\");\n+  assert(!is_reference_type(t), \"sanity\");\n+  return _scratch_basic_type_mirrors[t].resolve();\n+}\n+\n+oop HeapShared::scratch_java_mirror(Klass* k) {\n+  return _scratch_java_mirror_table->get_oop(k);\n+}\n+\n+void HeapShared::set_scratch_java_mirror(Klass* k, oop mirror) {\n+  _scratch_java_mirror_table->set_oop(k, mirror);\n+}\n+\n+void HeapShared::remove_scratch_objects(Klass* k) {\n+  _scratch_java_mirror_table->remove_oop(k);\n+}\n+\n+void HeapShared::archive_java_mirrors() {\n+  init_seen_objects_table();\n+\n+  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+    BasicType bt = (BasicType)i;\n+    if (!is_reference_type(bt)) {\n+      oop m = _scratch_basic_type_mirrors[i].resolve();\n+      assert(m != nullptr, \"sanity\");\n+      oop archived_m = archive_reachable_objects_from(1, _default_subgraph_info, m, \/*is_closed_archive=*\/ false);\n+      assert(archived_m != nullptr, \"sanity\");\n+\n+      log_trace(cds, heap, mirror)(\n+        \"Archived %s mirror object from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n+        type2name(bt), p2i(m), p2i(archived_m));\n+\n+      Universe::set_archived_basic_type_mirror_index(bt, append_root(archived_m));\n+    }\n+  }\n+\n+  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n+  assert(klasses != nullptr, \"sanity\");\n+  for (int i = 0; i < klasses->length(); i++) {\n+    Klass* orig_k = klasses->at(i);\n+    oop m = scratch_java_mirror(orig_k);\n+    if (m != nullptr) {\n+      Klass* buffered_k = ArchiveBuilder::get_buffered_klass(orig_k);\n+      oop archived_m = archive_reachable_objects_from(1, _default_subgraph_info, m, \/*is_closed_archive=*\/ false);\n+      guarantee(archived_m != nullptr, \"scratch mirrors should not point to any unachivable objects\");\n+      buffered_k->set_archived_java_mirror(append_root(archived_m));\n+      ResourceMark rm;\n+      log_trace(cds, heap, mirror)(\n+        \"Archived %s mirror object from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n+        buffered_k->external_name(), p2i(m), p2i(archived_m));\n+\n+      \/\/ archive the resolved_referenes array\n+      if (buffered_k->is_instance_klass()) {\n+        InstanceKlass* ik = InstanceKlass::cast(buffered_k);\n+        ik->constants()->archive_resolved_references();\n+      }\n@@ -361,0 +450,2 @@\n+\n+  delete_seen_objects_table();\n@@ -372,1 +463,1 @@\n-  if (ptr != NULL) {\n+  if (ptr != nullptr) {\n@@ -432,1 +523,1 @@\n-        if (oop_field == NULL) {\n+        if (oop_field == nullptr) {\n@@ -457,1 +548,1 @@\n-  assert(info != NULL, \"sanity\");\n+  assert(info != nullptr, \"sanity\");\n@@ -504,0 +595,2 @@\n+    _default_subgraph_info = init_subgraph_info(vmClasses::Object_klass(), false);\n+\n@@ -519,0 +612,1 @@\n+    check_default_subgraph_classes();\n@@ -545,3 +639,1 @@\n-  java_lang_Class::archive_basic_type_mirrors();\n-\n-  archive_klass_objects();\n+  archive_java_mirrors();\n@@ -573,1 +665,1 @@\n-  int length = _pending_roots != NULL ? _pending_roots->length() : 0;\n+  int length = _pending_roots != nullptr ? _pending_roots->length() : 0;\n@@ -600,1 +692,1 @@\n-HeapShared::DumpTimeKlassSubGraphInfoTable* HeapShared::_dump_time_subgraph_info_table = NULL;\n+HeapShared::DumpTimeKlassSubGraphInfoTable* HeapShared::_dump_time_subgraph_info_table = nullptr;\n@@ -620,1 +712,1 @@\n-  assert(info != NULL, \"must have been initialized\");\n+  assert(info != nullptr, \"must have been initialized\");\n@@ -628,1 +720,1 @@\n-  if (_subgraph_entry_fields == NULL) {\n+  if (_subgraph_entry_fields == nullptr) {\n@@ -642,1 +734,1 @@\n-  if (_subgraph_object_klasses == NULL) {\n+  if (_subgraph_object_klasses == nullptr) {\n@@ -698,1 +790,1 @@\n-    assert(ik->package() != NULL, \"classes in java.base cannot be in unnamed package\");\n+    assert(ik->package() != nullptr, \"classes in java.base cannot be in unnamed package\");\n@@ -703,1 +795,1 @@\n-  if (!ik->module()->is_named() && ik->package() == NULL) {\n+  if (!ik->module()->is_named() && ik->package() == nullptr) {\n@@ -738,2 +830,2 @@\n-  _entry_field_records = NULL;\n-  _subgraph_object_klasses = NULL;\n+  _entry_field_records = nullptr;\n+  _subgraph_object_klasses = nullptr;\n@@ -760,1 +852,1 @@\n-  if (entry_fields != NULL) {\n+  if (entry_fields != nullptr) {\n@@ -772,1 +864,1 @@\n-  if (subgraph_object_klasses != NULL) {\n+  if (subgraph_object_klasses != nullptr) {\n@@ -799,1 +891,1 @@\n-    if (info.subgraph_object_klasses() != NULL || info.subgraph_entry_fields() != NULL) {\n+    if (info.subgraph_object_klasses() != nullptr || info.subgraph_entry_fields() != nullptr) {\n@@ -833,1 +925,1 @@\n-  if (ArchiveHeapTestClass != NULL) {\n+  if (ArchiveHeapTestClass != nullptr) {\n@@ -846,1 +938,1 @@\n-  oop roots_oop = NULL;\n+  oop roots_oop = nullptr;\n@@ -852,1 +944,1 @@\n-    if (roots_oop != NULL) {\n+    if (roots_oop != nullptr) {\n@@ -867,1 +959,1 @@\n-  if (soc->reading() && _archived_ArchiveHeapTestClass != NULL) {\n+  if (soc->reading() && _archived_ArchiveHeapTestClass != nullptr) {\n@@ -924,1 +1016,1 @@\n-    assert(k != NULL && k->is_shared_boot_class(), \"sanity\");\n+    assert(k != nullptr && k->is_shared_boot_class(), \"sanity\");\n@@ -937,1 +1029,1 @@\n-  if (record == NULL) {\n+  if (record == nullptr) {\n@@ -960,1 +1052,1 @@\n-  if (record != NULL) {\n+  if (record != nullptr) {\n@@ -970,1 +1062,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -976,1 +1068,1 @@\n-  if (_test_class_name != NULL && k->name()->equals(_test_class_name) && record != NULL) {\n+  if (_test_class_name != nullptr && k->name()->equals(_test_class_name) && record != nullptr) {\n@@ -984,1 +1076,1 @@\n-  if (record != NULL) {\n+  if (record != nullptr) {\n@@ -991,1 +1083,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1000,1 +1092,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1011,1 +1103,1 @@\n-    \/\/ NULL class loader is used.\n+    \/\/ nullptr class loader is used.\n@@ -1013,1 +1105,1 @@\n-    if (klasses != NULL) {\n+    if (klasses != nullptr) {\n@@ -1017,1 +1109,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -1029,1 +1121,1 @@\n-    if (k->class_loader_data() == NULL) {\n+    if (k->class_loader_data() == nullptr) {\n@@ -1034,1 +1126,1 @@\n-    assert(k->class_loader_data() != NULL, \"must have been resolved by HeapShared::resolve_classes\");\n+    assert(k->class_loader_data() != nullptr, \"must have been resolved by HeapShared::resolve_classes\");\n@@ -1052,1 +1144,1 @@\n-  if (entry_field_records != NULL) {\n+  if (entry_field_records != nullptr) {\n@@ -1078,1 +1170,1 @@\n-  if (record != NULL) {\n+  if (record != nullptr) {\n@@ -1080,1 +1172,1 @@\n-    if (entry_field_records != NULL) {\n+    if (entry_field_records != nullptr) {\n@@ -1137,3 +1229,5 @@\n-        LogTarget(Trace, cds, heap) log;\n-        LogStream out(log);\n-        obj->print_on(&out);\n+        if (log_is_enabled(Trace, cds, heap)) {\n+          LogTarget(Trace, cds, heap) log;\n+          LogStream out(log);\n+          obj->print_on(&out);\n+        }\n@@ -1144,1 +1238,1 @@\n-      assert(archived != NULL, \"VM should have exited with unarchivable objects for _level > 1\");\n+      assert(archived != nullptr, \"VM should have exited with unarchivable objects for _level > 1\");\n@@ -1162,1 +1256,1 @@\n-WalkOopAndArchiveClosure* WalkOopAndArchiveClosure::_current = NULL;\n+WalkOopAndArchiveClosure* WalkOopAndArchiveClosure::_current = nullptr;\n@@ -1168,2 +1262,2 @@\n-  info._subgraph_info = (walker == NULL) ? NULL : walker->subgraph_info();\n-  info._referrer = (walker == NULL) ? NULL : walker->orig_referencing_obj();\n+  info._subgraph_info = (walker == nullptr) ? nullptr : walker->subgraph_info();\n+  info._referrer = (walker == nullptr) ? nullptr : walker->orig_referencing_obj();\n@@ -1199,1 +1293,1 @@\n-  assert(orig_obj != NULL, \"must be\");\n+  assert(orig_obj != nullptr, \"must be\");\n@@ -1216,1 +1310,1 @@\n-  if (java_lang_Class::is_instance(orig_obj)) {\n+  if (java_lang_Class::is_instance(orig_obj) && subgraph_info != _default_subgraph_info) {\n@@ -1222,1 +1316,1 @@\n-  if (java_lang_String::is_instance(orig_obj) && archived_obj != NULL) {\n+  if (java_lang_String::is_instance(orig_obj) && archived_obj != nullptr) {\n@@ -1235,2 +1329,2 @@\n-  bool record_klasses_only = (archived_obj != NULL);\n-  if (archived_obj == NULL) {\n+  bool record_klasses_only = (archived_obj != nullptr);\n+  if (archived_obj == nullptr) {\n@@ -1239,1 +1333,1 @@\n-    if (archived_obj == NULL) {\n+    if (archived_obj == nullptr) {\n@@ -1249,1 +1343,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1262,1 +1356,1 @@\n-      java_lang_Module::set_module_entry(archived_obj, NULL);\n+      java_lang_Module::set_module_entry(archived_obj, nullptr);\n@@ -1267,2 +1361,2 @@\n-                java_lang_ClassLoader::loader_data(orig_obj) == NULL, \"must be\");\n-      java_lang_ClassLoader::release_set_loader_data(archived_obj, NULL);\n+                java_lang_ClassLoader::loader_data(orig_obj) == nullptr, \"must be\");\n+      java_lang_ClassLoader::release_set_loader_data(archived_obj, nullptr);\n@@ -1272,1 +1366,1 @@\n-  assert(archived_obj != NULL, \"must be\");\n+  assert(archived_obj != nullptr, \"must be\");\n@@ -1345,1 +1439,1 @@\n-    if (af == NULL) {\n+    if (af == nullptr) {\n@@ -1358,1 +1452,1 @@\n-    subgraph_info->add_subgraph_entry_field(field_offset, NULL, false);\n+    subgraph_info->add_subgraph_entry_field(field_offset, nullptr, false);\n@@ -1395,1 +1489,1 @@\n-  if (archived_obj == NULL) {\n+  if (archived_obj == nullptr) {\n@@ -1422,1 +1516,1 @@\n-      assert(find_archived_heap_object(obj) == NULL, \"must be\");\n+      assert(find_archived_heap_object(obj) == nullptr, \"must be\");\n@@ -1425,1 +1519,1 @@\n-      assert(find_archived_heap_object(obj) != NULL, \"must be\");\n+      assert(find_archived_heap_object(obj) != nullptr, \"must be\");\n@@ -1434,1 +1528,26 @@\n-HeapShared::SeenObjectsTable* HeapShared::_seen_objects_table = NULL;\n+\/\/ The \"default subgraph\" contains special objects (see heapShared.hpp) that\n+\/\/ can be accessed before we load any Java classes (including java\/lang\/Class).\n+\/\/ Make sure that these are only instances of the very few specific types\n+\/\/ that we can handle.\n+void HeapShared::check_default_subgraph_classes() {\n+  GrowableArray<Klass*>* klasses = _default_subgraph_info->subgraph_object_klasses();\n+  int num = klasses->length();\n+  for (int i = 0; i < num; i++) {\n+    Klass* subgraph_k = klasses->at(i);\n+    if (log_is_enabled(Info, cds, heap)) {\n+      ResourceMark rm;\n+      log_info(cds, heap)(\n+          \"Archived object klass (default subgraph %d) => %s\",\n+          i, subgraph_k->external_name());\n+    }\n+\n+    guarantee(subgraph_k->name()->equals(\"java\/lang\/Class\") ||\n+              subgraph_k->name()->equals(\"java\/lang\/String\") ||\n+              subgraph_k->name()->equals(\"[Ljava\/lang\/Object;\") ||\n+              subgraph_k->name()->equals(\"[C\") ||\n+              subgraph_k->name()->equals(\"[B\"),\n+              \"default subgraph can have only these objects\");\n+  }\n+}\n+\n+HeapShared::SeenObjectsTable* HeapShared::_seen_objects_table = nullptr;\n@@ -1446,1 +1565,1 @@\n-  return _seen_objects_table->get(obj) != NULL;\n+  return _seen_objects_table->get(obj) != nullptr;\n@@ -1511,1 +1630,1 @@\n-    bool is_test_class = (ArchiveHeapTestClass != NULL) && (strcmp(info->klass_name, ArchiveHeapTestClass) == 0);\n+    bool is_test_class = (ArchiveHeapTestClass != nullptr) && (strcmp(info->klass_name, ArchiveHeapTestClass) == 0);\n@@ -1547,1 +1666,1 @@\n-      if (ik->package() != NULL) {\n+      if (ik->package() != nullptr) {\n@@ -1596,2 +1715,2 @@\n-  assert(p[num_slots - 2].klass_name == NULL, \"must have empty slot that's patched below\");\n-  assert(p[num_slots - 1].klass_name == NULL, \"must have empty slot that marks the end of the list\");\n+  assert(p[num_slots - 2].klass_name == nullptr, \"must have empty slot that's patched below\");\n+  assert(p[num_slots - 1].klass_name == nullptr, \"must have empty slot that marks the end of the list\");\n@@ -1599,1 +1718,1 @@\n-  if (test_class_name != NULL) {\n+  if (test_class_name != nullptr) {\n@@ -1609,1 +1728,1 @@\n-  if (_test_class != NULL) {\n+  if (_test_class != nullptr) {\n@@ -1614,1 +1733,1 @@\n-    if (klasses == NULL) {\n+    if (klasses == nullptr) {\n@@ -1755,1 +1874,1 @@\n-    if ((*p) != NULL) {\n+    if ((*p) != nullptr) {\n@@ -1773,1 +1892,1 @@\n-  if (dumptime_addr == NULL || UseCompressedOops) {\n+  if (dumptime_addr == nullptr || UseCompressedOops) {\n@@ -1794,1 +1913,1 @@\n-  assert(REQUESTED_BASE != 0 && requested_addr != NULL, \"sanity\");\n+  assert(REQUESTED_BASE != 0 && requested_addr != nullptr, \"sanity\");\n@@ -1805,1 +1924,1 @@\n-  ArchiveBuilder* builder = DumpSharedSpaces ? ArchiveBuilder::current() : NULL;\n+  ArchiveBuilder* builder = DumpSharedSpaces ? ArchiveBuilder::current() : nullptr;\n@@ -1836,1 +1955,1 @@\n-      assert(*p != NULL, \"must be non-null\");\n+      assert(*p != nullptr, \"must be non-null\");\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":234,"deletions":115,"binary":false,"changes":349,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+class KlassToOopHandleTable;\n@@ -78,2 +79,2 @@\n-    _k(k),  _subgraph_object_klasses(NULL),\n-    _subgraph_entry_fields(NULL),\n+    _k(k),  _subgraph_object_klasses(nullptr),\n+    _subgraph_entry_fields(nullptr),\n@@ -84,1 +85,1 @@\n-    if (_subgraph_object_klasses != NULL) {\n+    if (_subgraph_object_klasses != nullptr) {\n@@ -87,1 +88,1 @@\n-    if (_subgraph_entry_fields != NULL) {\n+    if (_subgraph_entry_fields != nullptr) {\n@@ -103,1 +104,1 @@\n-    return _subgraph_object_klasses == NULL ? 0 :\n+    return _subgraph_object_klasses == nullptr ? 0 :\n@@ -127,1 +128,1 @@\n-    _k(NULL), _entry_field_records(NULL), _subgraph_object_klasses(NULL) {}\n+    _k(nullptr), _entry_field_records(nullptr), _subgraph_object_klasses(nullptr) {}\n@@ -159,0 +160,5 @@\n+\n+  \/\/ Scratch objects for archiving Klass::java_mirror()\n+  static oop scratch_java_mirror(BasicType t) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  static oop scratch_java_mirror(Klass* k)    NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+\n@@ -250,0 +256,1 @@\n+  static void check_default_subgraph_classes();\n@@ -272,0 +279,7 @@\n+  \/\/ The \"default subgraph\" is the root of all archived objects that do not belong to any\n+  \/\/ of the classes defined in the <xxx>_archive_subgraph_entry_fields[] arrays:\n+  \/\/    - interned strings\n+  \/\/    - Klass::java_mirror()\n+  \/\/    - ConstantPool::resolved_references()\n+  static KlassSubGraphInfo* _default_subgraph_info;\n+\n@@ -274,0 +288,2 @@\n+  static OopHandle _scratch_basic_type_mirrors[T_VOID+1];\n+  static KlassToOopHandleTable* _scratch_java_mirror_table;\n@@ -276,1 +292,1 @@\n-    assert(_seen_objects_table == NULL, \"must be\");\n+    assert(_seen_objects_table == nullptr, \"must be\");\n@@ -280,1 +296,1 @@\n-    assert(_seen_objects_table != NULL, \"must be\");\n+    assert(_seen_objects_table != nullptr, \"must be\");\n@@ -282,1 +298,1 @@\n-    _seen_objects_table = NULL;\n+    _seen_objects_table = nullptr;\n@@ -334,1 +350,1 @@\n-      _original_object_table = NULL;\n+      _original_object_table = nullptr;\n@@ -339,2 +355,2 @@\n-    _archived_object_cache = NULL;\n-    if (_original_object_table != NULL) {\n+    _archived_object_cache = nullptr;\n+    if (_original_object_table != nullptr) {\n@@ -342,1 +358,1 @@\n-      _original_object_table = NULL;\n+      _original_object_table = nullptr;\n@@ -349,1 +365,1 @@\n-    assert(_original_object_table != NULL, \"sanity\");\n+    assert(_original_object_table != nullptr, \"sanity\");\n@@ -351,2 +367,2 @@\n-    if (r == NULL) {\n-      return NULL;\n+    if (r == nullptr) {\n+      return nullptr;\n@@ -361,1 +377,1 @@\n-  static void archive_klass_objects();\n+  static void archive_java_mirrors();\n@@ -377,0 +393,4 @@\n+  \/\/ Scratch objects for archiving Klass::java_mirror()\n+  static void set_scratch_java_mirror(Klass* k, oop mirror);\n+  static void remove_scratch_objects(Klass* k);\n+\n@@ -406,0 +426,1 @@\n+  static void init_scratch_objects(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -427,1 +448,1 @@\n-  static address to_requested_address(address dumptime_addr) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  static address to_requested_address(address dumptime_addr) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":40,"deletions":19,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-  if (_lambdaform_lines == NULL) {\n+  if (_lambdaform_lines == nullptr) {\n@@ -121,1 +121,1 @@\n-  guarantee(cds_klass != NULL, \"jdk\/internal\/misc\/CDS must exist!\");\n+  guarantee(cds_klass != nullptr, \"jdk\/internal\/misc\/CDS must exist!\");\n@@ -164,2 +164,2 @@\n-    assert(h_name != NULL, \"Class name is NULL\");\n-    assert(h_bytes != NULL, \"Class bytes is NULL\");\n+    assert(h_name != nullptr, \"Class name is null\");\n+    assert(h_bytes != nullptr, \"Class bytes is null\");\n@@ -174,1 +174,1 @@\n-      assert(klass != NULL, \"must already be loaded\");\n+      assert(klass != nullptr, \"must already be loaded\");\n@@ -187,1 +187,1 @@\n-      ClassFileStream st((u1*)buf, len, NULL, ClassFileStream::verify);\n+      ClassFileStream st((u1*)buf, len, nullptr, ClassFileStream::verify);\n@@ -196,1 +196,1 @@\n-  assert(klass != NULL, \"must exist\");\n+  assert(klass != nullptr, \"must exist\");\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,2 @@\n-  _proxy_klasses = NULL;\n-  if (src._proxy_klasses != NULL && src._proxy_klasses->length() > 0) {\n+  _proxy_klasses = nullptr;\n+  if (src._proxy_klasses != nullptr && src._proxy_klasses->length() > 0) {\n@@ -44,1 +44,1 @@\n-  if (_proxy_klasses != NULL) {\n+  if (_proxy_klasses != nullptr) {\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,2 +80,2 @@\n-    if (sym == NULL) {\n-      \/\/ _invoked_name maybe NULL\n+    if (sym == nullptr) {\n+      \/\/ _invoked_name maybe null\n@@ -110,1 +110,1 @@\n-  DumpTimeLambdaProxyClassInfo() : _proxy_klasses(NULL) {}\n+  DumpTimeLambdaProxyClassInfo() : _proxy_klasses(nullptr) {}\n@@ -116,1 +116,1 @@\n-    if (_proxy_klasses == NULL) {\n+    if (_proxy_klasses == nullptr) {\n@@ -119,1 +119,1 @@\n-    assert(_proxy_klasses != NULL, \"sanity\");\n+    assert(_proxy_klasses != nullptr, \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-void* MetaspaceShared::_shared_metaspace_static_top = NULL;\n+void* MetaspaceShared::_shared_metaspace_static_top = nullptr;\n@@ -188,1 +188,1 @@\n-    for (Klass* klass = cld->klasses(); klass != NULL; klass = klass->next_link()) {\n+    for (Klass* klass = cld->klasses(); klass != nullptr; klass = klass->next_link()) {\n@@ -209,1 +209,1 @@\n-  if (specified_base != NULL && aligned_base < specified_base) {\n+  if (specified_base != nullptr && aligned_base < specified_base) {\n@@ -226,1 +226,1 @@\n-  const char* err = NULL;\n+  const char* err = nullptr;\n@@ -285,1 +285,1 @@\n-        if (FileMapInfo::dynamic_info() == NULL) {\n+        if (FileMapInfo::dynamic_info() == nullptr) {\n@@ -297,2 +297,2 @@\n-static GrowableArrayCHeap<OopHandle, mtClassShared>* _extra_interned_strings = NULL;\n-static GrowableArrayCHeap<Symbol*, mtClassShared>* _extra_symbols = NULL;\n+static GrowableArrayCHeap<OopHandle, mtClassShared>* _extra_interned_strings = nullptr;\n+static GrowableArrayCHeap<Symbol*, mtClassShared>* _extra_symbols = nullptr;\n@@ -347,1 +347,1 @@\n-        assert(str != NULL, \"must succeed\");\n+        assert(str != nullptr, \"must succeed\");\n@@ -462,4 +462,4 @@\n-    _closed_heap_regions(NULL),\n-    _open_heap_regions(NULL),\n-    _closed_heap_bitmaps(NULL),\n-    _open_heap_bitmaps(NULL) {}\n+    _closed_heap_regions(nullptr),\n+    _open_heap_regions(nullptr),\n+    _closed_heap_bitmaps(nullptr),\n+    _open_heap_bitmaps(nullptr) {}\n@@ -489,1 +489,1 @@\n-    if (_extra_symbols != NULL) {\n+    if (_extra_symbols != nullptr) {\n@@ -627,1 +627,1 @@\n-    \/\/ tolerate this. (Note that unregistered classes are loaded by the NULL\n+    \/\/ tolerate this. (Note that unregistered classes are loaded by the null\n@@ -665,1 +665,1 @@\n-      for (Klass* klass = cld->klasses(); klass != NULL; klass = klass->next_link()) {\n+      for (Klass* klass = cld->klasses(); klass != nullptr; klass = klass->next_link()) {\n@@ -743,1 +743,1 @@\n-    if (end != NULL) *end = '\\0';\n+    if (end != nullptr) *end = '\\0';\n@@ -768,1 +768,1 @@\n-  if (SharedClassListFile == NULL) {\n+  if (SharedClassListFile == nullptr) {\n@@ -839,1 +839,1 @@\n-    if (ik->is_shared_unregistered_class() && ik->class_loader() == NULL) {\n+    if (ik->is_shared_unregistered_class() && ik->class_loader() == nullptr) {\n@@ -841,1 +841,1 @@\n-      \/\/ for non-system classes. Since we are using the NULL classloader\n+      \/\/ for non-system classes. Since we are using the null classloader\n@@ -886,1 +886,1 @@\n-  if (_extra_interned_strings != NULL) {\n+  if (_extra_interned_strings != nullptr) {\n@@ -936,1 +936,1 @@\n-    buffer = NULL;\n+    buffer = nullptr;\n@@ -973,1 +973,1 @@\n-  FileMapInfo* dynamic_mapinfo = NULL;\n+  FileMapInfo* dynamic_mapinfo = nullptr;\n@@ -975,1 +975,1 @@\n-  if (static_mapinfo != NULL) {\n+  if (static_mapinfo != nullptr) {\n@@ -990,1 +990,1 @@\n-    bool dynamic_mapped = (dynamic_mapinfo != NULL && dynamic_mapinfo->is_mapped());\n+    bool dynamic_mapped = (dynamic_mapinfo != nullptr && dynamic_mapinfo->is_mapped());\n@@ -1004,1 +1004,1 @@\n-    set_shared_metaspace_range(NULL, NULL, NULL);\n+    set_shared_metaspace_range(nullptr, nullptr, nullptr);\n@@ -1018,1 +1018,1 @@\n-  if (static_mapinfo != NULL && !static_mapinfo->is_mapped()) {\n+  if (static_mapinfo != nullptr && !static_mapinfo->is_mapped()) {\n@@ -1021,1 +1021,1 @@\n-  if (dynamic_mapinfo != NULL && !dynamic_mapinfo->is_mapped()) {\n+  if (dynamic_mapinfo != nullptr && !dynamic_mapinfo->is_mapped()) {\n@@ -1028,1 +1028,1 @@\n-  assert(static_archive != nullptr, \"SharedArchivePath is NULL\");\n+  assert(static_archive != nullptr, \"SharedArchivePath is nullptr\");\n@@ -1032,1 +1032,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1039,1 +1039,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1043,1 +1043,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1049,1 +1049,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1059,1 +1059,1 @@\n-  if (use_requested_addr && static_mapinfo->requested_base_address() == NULL) {\n+  if (use_requested_addr && static_mapinfo->requested_base_address() == nullptr) {\n@@ -1077,1 +1077,1 @@\n-  if (dynamic_mapinfo != NULL) {\n+  if (dynamic_mapinfo != nullptr) {\n@@ -1091,1 +1091,1 @@\n-  if (mapped_base_address == NULL) {\n+  if (mapped_base_address == nullptr) {\n@@ -1166,1 +1166,1 @@\n-        assert(dynamic_mapinfo != NULL && !dynamic_mapinfo->is_mapped(), \"must have failed\");\n+        assert(dynamic_mapinfo != nullptr && !dynamic_mapinfo->is_mapped(), \"must have failed\");\n@@ -1271,1 +1271,1 @@\n-\/\/ - On error: NULL is returned and the spaces remain unreserved.\n+\/\/ - On error: null is returned and the spaces remain unreserved.\n@@ -1279,1 +1279,1 @@\n-  address const base_address = (address) (use_archive_base_addr ? static_mapinfo->requested_base_address() : NULL);\n+  address const base_address = (address) (use_archive_base_addr ? static_mapinfo->requested_base_address() : nullptr);\n@@ -1284,1 +1284,1 @@\n-  size_t archive_end_offset  = (dynamic_mapinfo == NULL) ? static_mapinfo->mapping_end_offset() : dynamic_mapinfo->mapping_end_offset();\n+  size_t archive_end_offset  = (dynamic_mapinfo == nullptr) ? static_mapinfo->mapping_end_offset() : dynamic_mapinfo->mapping_end_offset();\n@@ -1288,1 +1288,1 @@\n-  if (base_address != NULL) {\n+  if (base_address != nullptr) {\n@@ -1303,1 +1303,1 @@\n-      assert(base_address == NULL ||\n+      assert(base_address == nullptr ||\n@@ -1309,1 +1309,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1356,1 +1356,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1368,1 +1368,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1372,1 +1372,1 @@\n-    assert(base_address == NULL || (address)total_space_rs.base() == base_address,\n+    assert(base_address == nullptr || (address)total_space_rs.base() == base_address,\n@@ -1399,1 +1399,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1427,1 +1427,1 @@\n-  if (mapinfo == NULL) {\n+  if (mapinfo == nullptr) {\n@@ -1457,1 +1457,1 @@\n-  if (mapinfo != NULL) {\n+  if (mapinfo != nullptr) {\n@@ -1506,1 +1506,1 @@\n-  if (dynamic_mapinfo != NULL) {\n+  if (dynamic_mapinfo != nullptr) {\n@@ -1544,1 +1544,1 @@\n-    if (FileMapInfo::current_info() == NULL || _archive_loading_failed) {\n+    if (FileMapInfo::current_info() == nullptr || _archive_loading_failed) {\n@@ -1564,1 +1564,1 @@\n-    if (FileMapInfo::dynamic_info() != NULL) {\n+    if (FileMapInfo::dynamic_info() != nullptr) {\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":52,"deletions":52,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-  assert(name != NULL, \"invariant\");\n+  assert(name != nullptr, \"invariant\");\n@@ -80,1 +80,1 @@\n-static URLClassLoaderTable* _url_classloader_table = NULL;\n+static URLClassLoaderTable* _url_classloader_table = nullptr;\n@@ -104,1 +104,1 @@\n-  if (_url_classloader_table == NULL) {\n+  if (_url_classloader_table == nullptr) {\n@@ -108,1 +108,1 @@\n-  if (url_classloader_ptr != NULL) {\n+  if (url_classloader_ptr != nullptr) {\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-  _instructions_size = -1;\n+  _inline_instructions_size = -1;\n@@ -175,1 +175,1 @@\n-  _instructions_size(-1),\n+  _inline_instructions_size(-1),\n@@ -1090,1 +1090,1 @@\n-  return instructions_size() > 0;\n+  return inline_instructions_size() > 0;\n@@ -1113,1 +1113,1 @@\n-\/\/ ciMethod::instructions_size\n+\/\/ ciMethod::inline_instructions_size\n@@ -1120,2 +1120,4 @@\n-int ciMethod::instructions_size() {\n-  if (_instructions_size == -1) {\n+\/\/ Also some instructions inside the code are excluded from inline\n+\/\/ heuristic (e.g. post call nop instructions; see InlineSkippedInstructionsCounter)\n+int ciMethod::inline_instructions_size() {\n+  if (_inline_instructions_size == -1) {\n@@ -1123,7 +1125,8 @@\n-                     CompiledMethod* code = get_Method()->code();\n-                     if (code != NULL && (code->comp_level() == CompLevel_full_optimization)) {\n-                       _instructions_size = code->insts_end() - code->verified_entry_point();\n-                     } else {\n-                       _instructions_size = 0;\n-                     }\n-                     );\n+      CompiledMethod* code = get_Method()->code();\n+      if (code != NULL && (code->comp_level() == CompLevel_full_optimization)) {\n+        int isize = code->insts_end() - code->verified_entry_point() - code->skipped_instructions_size();\n+        _inline_instructions_size = isize > 0 ? isize : 0;\n+      } else {\n+        _inline_instructions_size = 0;\n+      }\n+    );\n@@ -1131,1 +1134,1 @@\n-  return _instructions_size;\n+  return _inline_instructions_size;\n@@ -1318,1 +1321,1 @@\n-               _instructions_size);\n+               _inline_instructions_size);\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  int _instructions_size;\n+  int _inline_instructions_size;\n@@ -318,1 +318,2 @@\n-  int instructions_size();\n+\n+  int inline_instructions_size();\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1532,1 +1532,1 @@\n-    m->_instructions_size = -1;\n+    m->_inline_instructions_size = -1;\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -809,12 +809,0 @@\n-#if INCLUDE_CDS_JAVA_HEAP\n-static void initialize_static_string_field_for_dump(fieldDescriptor* fd, Handle mirror) {\n-  DEBUG_ONLY(assert_valid_static_string_field(fd);)\n-  assert(DumpSharedSpaces, \"must be\");\n-  assert(HeapShared::is_archived_object_during_dumptime(mirror()), \"must be\");\n-  \/\/ Archive the String field and update the pointer.\n-  oop s = mirror()->obj_field(fd->offset());\n-  oop archived_s = StringTable::create_archived_string(s);\n-  mirror()->obj_field_put(fd->offset(), archived_s);\n-}\n-#endif\n-\n@@ -867,13 +855,0 @@\n-#if INCLUDE_CDS_JAVA_HEAP\n-static void initialize_static_field_for_dump(fieldDescriptor* fd, Handle mirror) {\n-  assert(mirror.not_null() && fd->is_static(), \"just checking\");\n-  if (fd->has_initial_value()) {\n-    if (fd->field_type() != T_OBJECT) {\n-      initialize_static_primitive_field(fd, mirror);\n-    } else {\n-      initialize_static_string_field_for_dump(fd, mirror);\n-    }\n-  }\n-}\n-#endif\n-\n@@ -976,0 +951,55 @@\n+void java_lang_Class::allocate_mirror(Klass* k, bool is_scratch, Handle protection_domain, Handle classData,\n+                                      Handle& mirror, Handle& comp_mirror, TRAPS) {\n+  \/\/ Allocate mirror (java.lang.Class instance)\n+  oop mirror_oop = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(k, CHECK);\n+  mirror = Handle(THREAD, mirror_oop);\n+\n+  \/\/ Setup indirection from mirror->klass\n+  set_klass(mirror(), k);\n+\n+  InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror->klass());\n+  assert(oop_size(mirror()) == mk->instance_size(k), \"should have been set\");\n+\n+  set_static_oop_field_count(mirror(), mk->compute_static_oop_field_count(mirror()));\n+\n+  \/\/ It might also have a component mirror.  This mirror must already exist.\n+  if (k->is_array_klass()) {\n+    if (k->is_typeArray_klass()) {\n+      BasicType type = TypeArrayKlass::cast(k)->element_type();\n+      if (is_scratch) {\n+        comp_mirror = Handle(THREAD, HeapShared::scratch_java_mirror(type));\n+      } else {\n+        comp_mirror = Handle(THREAD, Universe::java_mirror(type));\n+      }\n+    } else {\n+      assert(k->is_objArray_klass(), \"Must be\");\n+      Klass* element_klass = ObjArrayKlass::cast(k)->element_klass();\n+      assert(element_klass != NULL, \"Must have an element klass\");\n+      if (is_scratch) {\n+        comp_mirror = Handle(THREAD, HeapShared::scratch_java_mirror(element_klass));\n+      } else {\n+        comp_mirror = Handle(THREAD, element_klass->java_mirror());\n+      }\n+    }\n+    assert(comp_mirror() != NULL, \"must have a mirror\");\n+\n+    \/\/ Two-way link between the array klass and its component mirror:\n+    \/\/ (array_klass) k -> mirror -> component_mirror -> array_klass -> k\n+    set_component_mirror(mirror(), comp_mirror());\n+    \/\/ See below for ordering dependencies between field array_klass in component mirror\n+    \/\/ and java_mirror in this klass.\n+  } else {\n+    assert(k->is_instance_klass(), \"Must be\");\n+\n+    initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      \/\/ If any of the fields throws an exception like OOM remove the klass field\n+      \/\/ from the mirror so GC doesn't follow it after the klass has been deallocated.\n+      \/\/ This mirror looks like a primitive type, which logically it is because it\n+      \/\/ it represents no class.\n+      set_klass(mirror(), NULL);\n+      return;\n+    }\n+  }\n+}\n+\n@@ -991,3 +1021,1 @@\n-    \/\/ Allocate mirror (java.lang.Class instance)\n-    oop mirror_oop = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(k, CHECK);\n-    Handle mirror(THREAD, mirror_oop);\n+    Handle mirror;\n@@ -996,39 +1024,1 @@\n-    \/\/ Setup indirection from mirror->klass\n-    set_klass(mirror(), k);\n-\n-    InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror->klass());\n-    assert(oop_size(mirror()) == mk->instance_size(k), \"should have been set\");\n-\n-    set_static_oop_field_count(mirror(), mk->compute_static_oop_field_count(mirror()));\n-\n-    \/\/ It might also have a component mirror.  This mirror must already exist.\n-    if (k->is_array_klass()) {\n-      if (k->is_typeArray_klass()) {\n-        BasicType type = TypeArrayKlass::cast(k)->element_type();\n-        comp_mirror = Handle(THREAD, Universe::java_mirror(type));\n-      } else {\n-        assert(k->is_objArray_klass(), \"Must be\");\n-        Klass* element_klass = ObjArrayKlass::cast(k)->element_klass();\n-        assert(element_klass != NULL, \"Must have an element klass\");\n-        comp_mirror = Handle(THREAD, element_klass->java_mirror());\n-      }\n-      assert(comp_mirror() != NULL, \"must have a mirror\");\n-\n-      \/\/ Two-way link between the array klass and its component mirror:\n-      \/\/ (array_klass) k -> mirror -> component_mirror -> array_klass -> k\n-      set_component_mirror(mirror(), comp_mirror());\n-      \/\/ See below for ordering dependencies between field array_klass in component mirror\n-      \/\/ and java_mirror in this klass.\n-    } else {\n-      assert(k->is_instance_klass(), \"Must be\");\n-\n-      initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);\n-      if (HAS_PENDING_EXCEPTION) {\n-        \/\/ If any of the fields throws an exception like OOM remove the klass field\n-        \/\/ from the mirror so GC doesn't follow it after the klass has been deallocated.\n-        \/\/ This mirror looks like a primitive type, which logically it is because it\n-        \/\/ it represents no class.\n-        set_klass(mirror(), NULL);\n-        return;\n-      }\n-    }\n+    allocate_mirror(k, \/*is_scratch=*\/false, protection_domain, classData, mirror, comp_mirror, CHECK);\n@@ -1053,0 +1043,3 @@\n+    if (DumpSharedSpaces) {\n+      create_scratch_mirror(k, CHECK);\n+    }\n@@ -1060,86 +1053,4 @@\n-\/\/ Clears mirror fields. Static final fields with initial values are reloaded\n-\/\/ from constant pool. The object identity hash is in the object header and is\n-\/\/ not affected.\n-class ResetMirrorField: public FieldClosure {\n- private:\n-  Handle _m;\n-\n- public:\n-  ResetMirrorField(Handle mirror) : _m(mirror) {}\n-\n-  void do_field(fieldDescriptor* fd) {\n-    assert(DumpSharedSpaces, \"dump time only\");\n-    assert(_m.not_null(), \"Mirror cannot be NULL\");\n-\n-    if (fd->is_static() && fd->has_initial_value()) {\n-      initialize_static_field_for_dump(fd, _m);\n-      return;\n-    }\n-\n-    BasicType ft = fd->field_type();\n-    switch (ft) {\n-      case T_BYTE:\n-        _m()->byte_field_put(fd->offset(), 0);\n-        break;\n-      case T_CHAR:\n-        _m()->char_field_put(fd->offset(), 0);\n-        break;\n-      case T_DOUBLE:\n-        _m()->double_field_put(fd->offset(), 0);\n-        break;\n-      case T_FLOAT:\n-        _m()->float_field_put(fd->offset(), 0);\n-        break;\n-      case T_INT:\n-        _m()->int_field_put(fd->offset(), 0);\n-        break;\n-      case T_LONG:\n-        _m()->long_field_put(fd->offset(), 0);\n-        break;\n-      case T_SHORT:\n-        _m()->short_field_put(fd->offset(), 0);\n-        break;\n-      case T_BOOLEAN:\n-        _m()->bool_field_put(fd->offset(), false);\n-        break;\n-      case T_ARRAY:\n-      case T_OBJECT: {\n-        \/\/ It might be useful to cache the String field, but\n-        \/\/ for now just clear out any reference field\n-        oop o = _m()->obj_field(fd->offset());\n-        _m()->obj_field_put(fd->offset(), NULL);\n-        break;\n-      }\n-      default:\n-        ShouldNotReachHere();\n-        break;\n-     }\n-  }\n-};\n-\n-void java_lang_Class::archive_basic_type_mirrors() {\n-  assert(HeapShared::can_write(), \"must be\");\n-\n-  for (int t = T_BOOLEAN; t < T_VOID+1; t++) {\n-    BasicType bt = (BasicType)t;\n-    if (!is_reference_type(bt)) {\n-      oop m = Universe::java_mirror(bt);\n-      assert(m != NULL, \"sanity\");\n-      \/\/ Update the field at _array_klass_offset to point to the relocated array klass.\n-      oop archived_m = HeapShared::archive_object(m);\n-      assert(archived_m != NULL, \"sanity\");\n-\n-      \/\/ Clear the fields. Just to be safe\n-      Klass *k = m->klass();\n-      Handle archived_mirror_h(Thread::current(), archived_m);\n-      ResetMirrorField reset(archived_mirror_h);\n-      InstanceKlass::cast(k)->do_nonstatic_fields(&reset);\n-\n-      log_trace(cds, heap, mirror)(\n-        \"Archived %s mirror object from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n-        type2name(bt), p2i(m), p2i(archived_m));\n-\n-      Universe::set_archived_basic_type_mirror_index(bt, HeapShared::append_root(archived_m));\n-    }\n-  }\n-}\n+\/\/ The \"scratch mirror\" stores the states of the mirror object that can be\n+\/\/ decided at dump time (such as the initial values of the static fields, the\n+\/\/ component mirror, etc). At runtime, more information is added to it by\n+\/\/ java_lang_Class::restore_archived_mirror().\n@@ -1147,2 +1058,2 @@\n-\/\/ After the mirror object is successfully archived, the archived\n-\/\/ klass is set with _has_archived_raw_mirror flag.\n+\/\/ Essentially, \/*dumptime*\/create_scratch_mirror() + \/*runtime*\/restore_archived_mirror()\n+\/\/ produces the same result as \/*runtime*\/create_mirror().\n@@ -1150,40 +1061,9 @@\n-\/\/ The _has_archived_raw_mirror flag is cleared at runtime when the\n-\/\/ archived mirror is restored. If archived java heap data cannot\n-\/\/ be used at runtime, new mirror object is created for the shared\n-\/\/ class. The _has_archived_raw_mirror is cleared also during the process.\n-oop java_lang_Class::archive_mirror(Klass* k) {\n-  assert(HeapShared::can_write(), \"must be\");\n-\n-  \/\/ Mirror is already archived\n-  if (k->has_archived_mirror_index()) {\n-    assert(k->archived_java_mirror() != NULL, \"no archived mirror\");\n-    return k->archived_java_mirror();\n-  }\n-\n-  \/\/ No mirror\n-  oop mirror = k->java_mirror();\n-  if (mirror == NULL) {\n-    return NULL;\n-  }\n-\n-  if (k->is_instance_klass()) {\n-    InstanceKlass *ik = InstanceKlass::cast(k);\n-    assert(ik->signers() == NULL, \"class with signer should have been excluded\");\n-\n-    if (!(ik->is_shared_boot_class() || ik->is_shared_platform_class() ||\n-          ik->is_shared_app_class())) {\n-      \/\/ Archiving mirror for classes from non-builtin loaders is not\n-      \/\/ supported.\n-      return NULL;\n-    }\n-  }\n-\n-  \/\/ Now start archiving the mirror object\n-  oop archived_mirror = HeapShared::archive_object(mirror);\n-  if (archived_mirror == NULL) {\n-    return NULL;\n-  }\n-\n-  archived_mirror = process_archived_mirror(k, mirror, archived_mirror);\n-  if (archived_mirror == NULL) {\n-    return NULL;\n+\/\/ Note: we archive the \"scratch mirror\" instead of k->java_mirror(), because the\n+\/\/ latter may contain dumptime-specific information that cannot be archived\n+\/\/ (e.g., ClassLoaderData*, or static fields that are modified by Java code execution).\n+void java_lang_Class::create_scratch_mirror(Klass* k, TRAPS) {\n+  if (k->class_loader() != NULL &&\n+      k->class_loader() != SystemDictionary::java_platform_loader() &&\n+      k->class_loader() != SystemDictionary::java_system_loader()) {\n+    \/\/ We only archive the mirrors of classes loaded by the built-in loaders\n+    return;\n@@ -1192,42 +1072,4 @@\n-  k->set_archived_java_mirror(archived_mirror);\n-\n-  ResourceMark rm;\n-  log_trace(cds, heap, mirror)(\n-    \"Archived %s mirror object from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n-    k->external_name(), p2i(mirror), p2i(archived_mirror));\n-\n-  return archived_mirror;\n-}\n-\n-\/\/ The process is based on create_mirror().\n-oop java_lang_Class::process_archived_mirror(Klass* k, oop mirror,\n-                                             oop archived_mirror) {\n-  \/\/ Clear nonstatic fields in archived mirror. Some of the fields will be set\n-  \/\/ to archived metadata and objects below.\n-  Klass *c = archived_mirror->klass();\n-  Handle archived_mirror_h(Thread::current(), archived_mirror);\n-  ResetMirrorField reset(archived_mirror_h);\n-  InstanceKlass::cast(c)->do_nonstatic_fields(&reset);\n-\n-  if (k->is_array_klass()) {\n-    oop archived_comp_mirror;\n-    if (k->is_typeArray_klass()) {\n-      \/\/ The primitive type mirrors are already archived. Get the archived mirror.\n-      oop comp_mirror = component_mirror(mirror);\n-      archived_comp_mirror = HeapShared::find_archived_heap_object(comp_mirror);\n-      assert(archived_comp_mirror != NULL, \"Must be\");\n-    } else {\n-      assert(k->is_objArray_klass(), \"Must be\");\n-      Klass* element_klass = ObjArrayKlass::cast(k)->element_klass();\n-      assert(element_klass != NULL, \"Must have an element klass\");\n-      archived_comp_mirror = archive_mirror(element_klass);\n-      if (archived_comp_mirror == NULL) {\n-        return NULL;\n-      }\n-    }\n-    set_component_mirror(archived_mirror, archived_comp_mirror);\n-  } else {\n-    assert(k->is_instance_klass(), \"Must be\");\n-\n-    \/\/ Reset local static fields in the mirror\n-    InstanceKlass::cast(k)->do_local_static_fields(&reset);\n+  Handle protection_domain, classData; \/\/ set to NULL. Will be reinitialized at runtime\n+  Handle mirror;\n+  Handle comp_mirror;\n+  allocate_mirror(k, \/*is_scratch=*\/true, protection_domain, classData, mirror, comp_mirror, CHECK);\n@@ -1235,3 +1077,2 @@\n-    set_protection_domain(archived_mirror, NULL);\n-    set_signers(archived_mirror, NULL);\n-    set_source_file(archived_mirror, NULL);\n+  if (comp_mirror() != NULL) {\n+    release_set_array_klass(comp_mirror(), k);\n@@ -1240,5 +1081,1 @@\n-  \/\/ clear class loader and mirror_module_field\n-  set_class_loader(archived_mirror, NULL);\n-  set_module(archived_mirror, NULL);\n-\n-  return archived_mirror;\n+  HeapShared::set_scratch_java_mirror(k, mirror());\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":83,"deletions":246,"binary":false,"changes":329,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -252,0 +252,2 @@\n+  static void allocate_mirror(Klass* k, bool is_scratch, Handle protection_domain, Handle classData,\n+                              Handle& mirror, Handle& comp_mirror, TRAPS); \/\/ returns mirror and comp_mirror\n@@ -259,4 +261,1 @@\n-  static void archive_basic_type_mirrors() NOT_CDS_JAVA_HEAP_RETURN;\n-  static oop  archive_mirror(Klass* k) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n-  static oop  process_archived_mirror(Klass* k, oop mirror, oop archived_mirror)\n-                                      NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  static void create_scratch_mirror(Klass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,0 +224,1 @@\n+    case vmIntrinsics::_vectorizedHashCode:\n@@ -530,0 +531,3 @@\n+  case vmIntrinsics::_vectorizedHashCode:\n+    if (!UseVectorizedHashCodeIntrinsic) return true;\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -353,0 +353,4 @@\n+  do_intrinsic(_vectorizedHashCode,       jdk_internal_util_ArraysSupport, vectorizedHashCode_name,  vectorizedHashCode_signature, F_S)   \\\n+   do_name(     vectorizedHashCode_name,                         \"vectorizedHashCode\")                                  \\\n+   do_signature(vectorizedHashCode_signature,                    \"(Ljava\/lang\/Object;IIII)I\")                           \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-CompiledICProtectionBehaviour* CompiledICProtectionBehaviour::_current = NULL;\n+CompiledICProtectionBehaviour* CompiledICProtectionBehaviour::_current = nullptr;\n","filename":"src\/hotspot\/share\/code\/codeBehaviours.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,1 @@\n-  : CodeBlob(name, compiler_none, CodeBlobLayout((address) this, size, header_size, locs_size, size), frame_complete, 0, NULL, false \/* caller_must_gc_arguments *\/)\n+  : CodeBlob(name, compiler_none, CodeBlobLayout((address) this, size, header_size, locs_size, size), frame_complete, 0, nullptr, false \/* caller_must_gc_arguments *\/)\n@@ -165,1 +165,1 @@\n-  assert(blob != NULL, \"caller must check for NULL\");\n+  assert(blob != nullptr, \"caller must check for nullptr\");\n@@ -178,1 +178,1 @@\n-  _oop_maps = NULL;\n+  _oop_maps = nullptr;\n@@ -186,1 +186,1 @@\n-  if (p != NULL) {\n+  if (p != nullptr) {\n@@ -189,1 +189,1 @@\n-    _oop_maps = NULL;\n+    _oop_maps = nullptr;\n@@ -198,1 +198,1 @@\n-  if (stub != NULL && (PrintStubCode ||\n+  if (stub != nullptr && (PrintStubCode ||\n@@ -210,1 +210,1 @@\n-      if ((stub->oop_maps() != NULL) && AbstractDisassembler::show_structs()) {\n+      if ((stub->oop_maps() != nullptr) && AbstractDisassembler::show_structs()) {\n@@ -233,1 +233,1 @@\n-  assert(_oop_maps != NULL, \"nope\");\n+  assert(_oop_maps != nullptr, \"nope\");\n@@ -253,1 +253,1 @@\n-  BufferBlob* blob = NULL;\n+  BufferBlob* blob = nullptr;\n@@ -258,1 +258,1 @@\n-  assert(name != NULL, \"must provide a name\");\n+  assert(name != nullptr, \"must provide a name\");\n@@ -271,1 +271,1 @@\n-  : RuntimeBlob(name, cb, sizeof(BufferBlob), size, CodeOffsets::frame_never_safe, 0, NULL)\n+  : RuntimeBlob(name, cb, sizeof(BufferBlob), size, CodeOffsets::frame_never_safe, 0, nullptr)\n@@ -277,1 +277,1 @@\n-  BufferBlob* blob = NULL;\n+  BufferBlob* blob = nullptr;\n@@ -279,1 +279,1 @@\n-  assert(name != NULL, \"must provide a name\");\n+  assert(name != nullptr, \"must provide a name\");\n@@ -312,1 +312,1 @@\n-  AdapterBlob* blob = NULL;\n+  AdapterBlob* blob = nullptr;\n@@ -341,1 +341,1 @@\n-  VtableBlob* blob = NULL;\n+  VtableBlob* blob = nullptr;\n@@ -346,1 +346,1 @@\n-  assert(name != NULL, \"must provide a name\");\n+  assert(name != nullptr, \"must provide a name\");\n@@ -359,1 +359,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -376,1 +376,1 @@\n-  MethodHandlesAdapterBlob* blob = NULL;\n+  MethodHandlesAdapterBlob* blob = nullptr;\n@@ -384,1 +384,1 @@\n-    if (blob == NULL) {\n+    if (blob == nullptr) {\n@@ -417,1 +417,1 @@\n-  RuntimeStub* stub = NULL;\n+  RuntimeStub* stub = nullptr;\n@@ -476,1 +476,1 @@\n-  DeoptimizationBlob* blob = NULL;\n+  DeoptimizationBlob* blob = nullptr;\n@@ -515,1 +515,1 @@\n-  UncommonTrapBlob* blob = NULL;\n+  UncommonTrapBlob* blob = nullptr;\n@@ -551,1 +551,1 @@\n-  ExceptionBlob* blob = NULL;\n+  ExceptionBlob* blob = nullptr;\n@@ -586,1 +586,1 @@\n-  SafepointBlob* blob = NULL;\n+  SafepointBlob* blob = nullptr;\n@@ -618,1 +618,1 @@\n-    if (i != NULL) {\n+    if (i != nullptr) {\n@@ -635,1 +635,1 @@\n-    if (d != NULL) {\n+    if (d != nullptr) {\n@@ -651,1 +651,1 @@\n-    if (v != NULL) {\n+    if (v != nullptr) {\n@@ -778,1 +778,1 @@\n-  assert(blob != nullptr, \"caller must check for NULL\");\n+  assert(blob != nullptr, \"caller must check for nullptr\");\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,1 +168,1 @@\n-  nmethod* as_nmethod_or_null()                { return is_nmethod() ? (nmethod*) this : NULL; }\n+  nmethod* as_nmethod_or_null()                { return is_nmethod() ? (nmethod*) this : nullptr; }\n@@ -170,1 +170,1 @@\n-  CompiledMethod* as_compiled_method_or_null() { return is_compiled() ? (CompiledMethod*) this : NULL; }\n+  CompiledMethod* as_compiled_method_or_null() { return is_compiled() ? (CompiledMethod*) this : nullptr; }\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-  assert(_oop_maps != NULL, \"nope\");\n+  assert(_oop_maps != nullptr, \"nope\");\n","filename":"src\/hotspot\/share\/code\/codeBlob.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -166,1 +166,1 @@\n-#define FOR_ALL_BLOBS(cb, heap) for (CodeBlob* cb = first_blob(heap); cb != NULL; cb = next_blob(heap, cb))\n+#define FOR_ALL_BLOBS(cb, heap) for (CodeBlob* cb = first_blob(heap); cb != nullptr; cb = next_blob(heap, cb))\n@@ -171,1 +171,1 @@\n-ExceptionCache* volatile CodeCache::_exception_cache_purge_list = NULL;\n+ExceptionCache* volatile CodeCache::_exception_cache_purge_list = nullptr;\n@@ -401,1 +401,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -458,1 +458,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -462,1 +462,1 @@\n-  assert(cb != NULL, \"CodeBlob is null\");\n+  assert(cb != nullptr, \"CodeBlob is null\");\n@@ -469,1 +469,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -478,1 +478,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -483,1 +483,1 @@\n-  assert(heap != NULL, \"heap is null\");\n+  assert(heap != nullptr, \"heap is null\");\n@@ -491,1 +491,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -497,1 +497,1 @@\n-  assert(heap != NULL, \"heap is null\");\n+  assert(heap != nullptr, \"heap is null\");\n@@ -512,1 +512,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -514,1 +514,1 @@\n-  CodeBlob* cb = NULL;\n+  CodeBlob* cb = nullptr;\n@@ -518,1 +518,1 @@\n-  assert(heap != NULL, \"heap is null\");\n+  assert(heap != nullptr, \"heap is null\");\n@@ -522,1 +522,1 @@\n-    if (cb != NULL) break;\n+    if (cb != nullptr) break;\n@@ -561,1 +561,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -635,1 +635,1 @@\n-  S390_ONLY(if (_heaps == NULL) return false;)\n+  S390_ONLY(if (_heaps == nullptr) return false;)\n@@ -653,1 +653,1 @@\n-  if (_heaps != NULL) {\n+  if (_heaps != nullptr) {\n@@ -655,1 +655,1 @@\n-    if (heap != NULL) {\n+    if (heap != nullptr) {\n@@ -659,1 +659,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -874,1 +874,1 @@\n-  if (bs_nm != NULL) {\n+  if (bs_nm != nullptr) {\n@@ -920,1 +920,1 @@\n-      if (nm != NULL) {\n+      if (nm != nullptr) {\n@@ -950,1 +950,1 @@\n-  while (curr != NULL) {\n+  while (curr != nullptr) {\n@@ -955,1 +955,1 @@\n-  _exception_cache_purge_list = NULL;\n+  _exception_cache_purge_list = nullptr;\n@@ -960,1 +960,1 @@\n-  assert(nm->unlinked_next() == NULL, \"Only register for unloading once\");\n+  assert(nm->unlinked_next() == nullptr, \"Only register for unloading once\");\n@@ -965,1 +965,1 @@\n-    nmethod* next = head != NULL ? head : nm; \/\/ Self looped means end of list\n+    nmethod* next = head != nullptr ? head : nm; \/\/ Self looped means end of list\n@@ -976,1 +976,1 @@\n-  _unlinked_head = NULL;\n+  _unlinked_head = nullptr;\n@@ -978,1 +978,1 @@\n-  while (nm != NULL) {\n+  while (nm != nullptr) {\n@@ -1001,1 +1001,1 @@\n-nmethod* volatile CodeCache::_unlinked_head = NULL;\n+nmethod* volatile CodeCache::_unlinked_head = nullptr;\n@@ -1040,1 +1040,1 @@\n-  return (heap != NULL) ? heap->blob_count() : 0;\n+  return (heap != nullptr) ? heap->blob_count() : 0;\n@@ -1053,1 +1053,1 @@\n-  return (heap != NULL) ? heap->nmethod_count() : 0;\n+  return (heap != nullptr) ? heap->nmethod_count() : 0;\n@@ -1066,1 +1066,1 @@\n-  return (heap != NULL) ? heap->adapter_count() : 0;\n+  return (heap != nullptr) ? heap->adapter_count() : 0;\n@@ -1079,1 +1079,1 @@\n-  return (heap != NULL) ? (address)heap->low_boundary() : NULL;\n+  return (heap != nullptr) ? (address)heap->low_boundary() : nullptr;\n@@ -1084,1 +1084,1 @@\n-  return (heap != NULL) ? (address)heap->high_boundary() : NULL;\n+  return (heap != nullptr) ? (address)heap->high_boundary() : nullptr;\n@@ -1097,1 +1097,1 @@\n-  return (heap != NULL) ? heap->unallocated_capacity() : 0;\n+  return (heap != nullptr) ? heap->unallocated_capacity() : 0;\n@@ -1269,1 +1269,1 @@\n-  assert(cb == NULL || cb->is_compiled(), \"did not find an compiled_method\");\n+  assert(cb == nullptr || cb->is_compiled(), \"did not find an compiled_method\");\n@@ -1276,1 +1276,1 @@\n-static GrowableArray<CompiledMethod*>* old_compiled_method_table = NULL;\n+static GrowableArray<CompiledMethod*>* old_compiled_method_table = nullptr;\n@@ -1279,1 +1279,1 @@\n-  if (old_compiled_method_table == NULL) {\n+  if (old_compiled_method_table == nullptr) {\n@@ -1286,1 +1286,1 @@\n-  if (old_compiled_method_table != NULL) {\n+  if (old_compiled_method_table != nullptr) {\n@@ -1288,1 +1288,1 @@\n-    old_compiled_method_table = NULL;\n+    old_compiled_method_table = nullptr;\n@@ -1295,1 +1295,1 @@\n-  if (old_compiled_method_table != NULL) {\n+  if (old_compiled_method_table != nullptr) {\n@@ -1306,1 +1306,1 @@\n-  if (old_compiled_method_table != NULL) {\n+  if (old_compiled_method_table != nullptr) {\n@@ -1471,1 +1471,1 @@\n-  assert(heap != NULL, \"heap is null\");\n+  assert(heap != nullptr, \"heap is null\");\n@@ -1539,1 +1539,1 @@\n-      for (CodeBlob* cb = (CodeBlob*)curr_heap->first(); cb != NULL; cb = (CodeBlob*)curr_heap->next(cb)) {\n+      for (CodeBlob* cb = (CodeBlob*)curr_heap->first(); cb != nullptr; cb = (CodeBlob*)curr_heap->next(cb)) {\n@@ -1589,1 +1589,1 @@\n-        if (Verbose && nm->method() != NULL) {\n+        if (Verbose && nm->method() != nullptr) {\n@@ -1599,1 +1599,1 @@\n-        if(nm->method() != NULL && nm->is_native_method()) { nmethodNative++; }\n+        if(nm->method() != nullptr && nm->is_native_method()) { nmethodNative++; }\n@@ -1601,1 +1601,1 @@\n-        if(nm->method() != NULL && nm->is_java_method()) {\n+        if(nm->method() != nullptr && nm->is_java_method()) {\n@@ -1627,1 +1627,1 @@\n-    if(nm->method() != NULL && nm->is_java_method()) {\n+    if(nm->method() != nullptr && nm->is_java_method()) {\n@@ -1740,1 +1740,1 @@\n-        if (set != NULL) {\n+        if (set != nullptr) {\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":49,"deletions":49,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,1 +118,1 @@\n-  static CodeHeap* get_code_heap_containing(void* p);         \/\/ Returns the CodeHeap containing the given pointer, or NULL\n+  static CodeHeap* get_code_heap_containing(void* p);         \/\/ Returns the CodeHeap containing the given pointer, or nullptr\n@@ -324,1 +324,1 @@\n-    return (heap != NULL) ? heap->full_count() : 0;\n+    return (heap != nullptr) ? heap->full_count() : 0;\n@@ -369,1 +369,1 @@\n-        if (cm != NULL && cm->is_unloading()) {\n+        if (cm != nullptr && cm->is_unloading()) {\n@@ -379,1 +379,1 @@\n-  CodeBlobIterator(LivenessFilter filter, T* nm = NULL)\n+  CodeBlobIterator(LivenessFilter filter, T* nm = nullptr)\n@@ -382,1 +382,1 @@\n-    if (Filter::heaps() == NULL) {\n+    if (Filter::heaps() == nullptr) {\n@@ -391,1 +391,1 @@\n-    \/\/ If set to NULL, initialized by first call to next()\n+    \/\/ If set to nullptr, initialized by first call to next()\n@@ -393,1 +393,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -412,1 +412,1 @@\n-  bool end()  const { return _code_blob == NULL; }\n+  bool end()  const { return _code_blob == nullptr; }\n@@ -424,1 +424,1 @@\n-    if (_code_blob == NULL) {\n+    if (_code_blob == nullptr) {\n@@ -426,1 +426,1 @@\n-      if (_code_blob == NULL) {\n+      if (_code_blob == nullptr) {\n@@ -434,1 +434,1 @@\n-    while (_code_blob != NULL && !Filter::apply(_code_blob)) {\n+    while (_code_blob != nullptr && !Filter::apply(_code_blob)) {\n@@ -437,1 +437,1 @@\n-    return _code_blob != NULL;\n+    return _code_blob != nullptr;\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-  if (nop != NULL && nop->displacement() != 0) {\n+  if (nop != nullptr && nop->displacement() != 0) {\n@@ -49,1 +49,1 @@\n-  assert(cb != NULL, \"must be\");\n+  assert(cb != nullptr, \"must be\");\n@@ -55,1 +55,1 @@\n-  return (nop != NULL && nop->displacement() != 0)\n+  return (nop != nullptr && nop->displacement() != 0)\n","filename":"src\/hotspot\/share\/code\/codeCache.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,1 @@\n-    if (((_termString) != NULL) && (strlen(_termString) > 0)){\\\n+    if (((_termString) != nullptr) && (strlen(_termString) > 0)){\\\n@@ -156,1 +156,1 @@\n-    if (((_termString) != NULL) && (strlen(_termString) > 0)){\\\n+    if (((_termString) != nullptr) && (strlen(_termString) > 0)){\\\n@@ -196,1 +196,1 @@\n-    if (((_termString) != NULL) && (strlen(_termString) > 0)){\\\n+    if (((_termString) != nullptr) && (strlen(_termString) > 0)){\\\n@@ -240,2 +240,2 @@\n-\/\/ static struct StatElement *StatArray      = NULL;\n-static StatElement* StatArray             = NULL;\n+\/\/ static struct StatElement *StatArray      = nullptr;\n+static StatElement* StatArray             = nullptr;\n@@ -252,1 +252,1 @@\n-static struct FreeBlk*          FreeArray = NULL;\n+static struct FreeBlk*          FreeArray = nullptr;\n@@ -255,1 +255,1 @@\n-static struct TopSizeBlk*    TopSizeArray = NULL;\n+static struct TopSizeBlk*    TopSizeArray = nullptr;\n@@ -259,1 +259,1 @@\n-static struct SizeDistributionElement*  SizeDistributionArray = NULL;\n+static struct SizeDistributionElement*  SizeDistributionArray = nullptr;\n@@ -274,1 +274,1 @@\n-  if (heapName == NULL) {\n+  if (heapName == nullptr) {\n@@ -280,1 +280,1 @@\n-      if (CodeHeapStatArray[i].heapName != NULL && strcmp(heapName, CodeHeapStatArray[i].heapName) == 0) {\n+      if (CodeHeapStatArray[i].heapName != nullptr && strcmp(heapName, CodeHeapStatArray[i].heapName) == 0) {\n@@ -321,1 +321,1 @@\n-    StatArray             = NULL;\n+    StatArray             = nullptr;\n@@ -331,1 +331,1 @@\n-    FreeArray             = NULL;\n+    FreeArray             = nullptr;\n@@ -333,1 +333,1 @@\n-    TopSizeArray          = NULL;\n+    TopSizeArray          = nullptr;\n@@ -336,1 +336,1 @@\n-    SizeDistributionArray = NULL;\n+    SizeDistributionArray = nullptr;\n@@ -363,1 +363,1 @@\n-  if (StatArray == NULL) {\n+  if (StatArray == nullptr) {\n@@ -370,1 +370,1 @@\n-  if (StatArray == NULL) {\n+  if (StatArray == nullptr) {\n@@ -384,1 +384,1 @@\n-  if (FreeArray == NULL) {\n+  if (FreeArray == nullptr) {\n@@ -390,1 +390,1 @@\n-  if (FreeArray == NULL) {\n+  if (FreeArray == nullptr) {\n@@ -402,1 +402,1 @@\n-  if (TopSizeArray == NULL) {\n+  if (TopSizeArray == nullptr) {\n@@ -409,1 +409,1 @@\n-  if (TopSizeArray == NULL) {\n+  if (TopSizeArray == nullptr) {\n@@ -422,1 +422,1 @@\n-  if (SizeDistributionArray == NULL) {\n+  if (SizeDistributionArray == nullptr) {\n@@ -426,1 +426,1 @@\n-  if (SizeDistributionArray == NULL) {\n+  if (SizeDistributionArray == nullptr) {\n@@ -443,1 +443,1 @@\n-  if (SizeDistributionArray != NULL) {\n+  if (SizeDistributionArray != nullptr) {\n@@ -455,1 +455,1 @@\n-  if (StatArray != NULL) {\n+  if (StatArray != nullptr) {\n@@ -457,1 +457,1 @@\n-    StatArray        = NULL;\n+    StatArray        = nullptr;\n@@ -464,1 +464,1 @@\n-  if (FreeArray != NULL) {\n+  if (FreeArray != nullptr) {\n@@ -466,1 +466,1 @@\n-    FreeArray        = NULL;\n+    FreeArray        = nullptr;\n@@ -472,1 +472,1 @@\n-  if (TopSizeArray != NULL) {\n+  if (TopSizeArray != nullptr) {\n@@ -474,1 +474,1 @@\n-      if (TopSizeArray[i].blob_name != NULL) {\n+      if (TopSizeArray[i].blob_name != nullptr) {\n@@ -479,1 +479,1 @@\n-    TopSizeArray        = NULL;\n+    TopSizeArray        = nullptr;\n@@ -486,1 +486,1 @@\n-  if (SizeDistributionArray != NULL) {\n+  if (SizeDistributionArray != nullptr) {\n@@ -488,1 +488,1 @@\n-    SizeDistributionArray = NULL;\n+    SizeDistributionArray = nullptr;\n@@ -507,1 +507,1 @@\n-      CodeHeapStatArray[ix].heapName = NULL;\n+      CodeHeapStatArray[ix].heapName = nullptr;\n@@ -541,1 +541,1 @@\n-    printBox(ast, '=', \"C O D E   H E A P   A N A L Y S I S   (general remarks)\", NULL);\n+    printBox(ast, '=', \"C O D E   H E A P   A N A L Y S I S   (general remarks)\", nullptr);\n@@ -654,1 +654,1 @@\n-    if (StatArray == NULL) {\n+    if (StatArray == nullptr) {\n@@ -672,1 +672,1 @@\n-    HeapBlock*   maxFreeBlock           = NULL;\n+    HeapBlock*   maxFreeBlock           = nullptr;\n@@ -677,1 +677,1 @@\n-    for (HeapBlock *h = heap->first_block(); h != NULL && !insane; h = heap->next_block(h)) {\n+    for (HeapBlock *h = heap->first_block(); h != nullptr && !insane; h = heap->next_block(h)) {\n@@ -725,1 +725,1 @@\n-        cbType = get_cbType(cb);  \/\/ Will check for cb == NULL and other safety things.\n+        cbType = get_cbType(cb);  \/\/ Will check for cb == nullptr and other safety things.\n@@ -730,1 +730,1 @@\n-          if (nm != NULL) { \/\/ no is_readable check required, nm = (nmethod*)cb.\n+          if (nm != nullptr) { \/\/ no is_readable check required, nm = (nmethod*)cb.\n@@ -793,1 +793,1 @@\n-              blob_name  = NULL; \/\/ indicate blob_name was consumed\n+              blob_name  = nullptr; \/\/ indicate blob_name was consumed\n@@ -809,1 +809,1 @@\n-              blob_name  = NULL; \/\/ indicate blob_name was consumed\n+              blob_name  = nullptr; \/\/ indicate blob_name was consumed\n@@ -849,1 +849,1 @@\n-                      blob_name  = NULL; \/\/ indicate blob_name was consumed\n+                      blob_name  = nullptr; \/\/ indicate blob_name was consumed\n@@ -873,1 +873,1 @@\n-                        if (TopSizeArray[j].blob_name != NULL) {\n+                        if (TopSizeArray[j].blob_name != nullptr) {\n@@ -905,1 +905,1 @@\n-                        blob_name  = NULL; \/\/ indicate blob_name was consumed\n+                        blob_name  = nullptr; \/\/ indicate blob_name was consumed\n@@ -920,1 +920,1 @@\n-          if (blob_name != NULL) {\n+          if (blob_name != nullptr) {\n@@ -922,1 +922,1 @@\n-            blob_name = NULL;\n+            blob_name = nullptr;\n@@ -1141,1 +1141,1 @@\n-    if (FreeArray == NULL) {\n+    if (FreeArray == nullptr) {\n@@ -1153,1 +1153,1 @@\n-    while (cur != NULL) {\n+    while (cur != nullptr) {\n@@ -1188,1 +1188,1 @@\n-  if (FreeArray != NULL) {\n+  if (FreeArray != nullptr) {\n@@ -1194,1 +1194,1 @@\n-      for (HeapBlock *h = heap->next_block(FreeArray[ix].start); (h != NULL) && (h != FreeArray[ix+1].start); h = heap->next_block(h)) {\n+      for (HeapBlock *h = heap->next_block(FreeArray[ix].start); (h != nullptr) && (h != FreeArray[ix+1].start); h = heap->next_block(h)) {\n@@ -1196,1 +1196,1 @@\n-        if ((cb != NULL) && !cb->is_nmethod()) { \/\/ checks equivalent to those in get_cbType()\n+        if ((cb != nullptr) && !cb->is_nmethod()) { \/\/ checks equivalent to those in get_cbType()\n@@ -1225,1 +1225,1 @@\n-  if ((StatArray == NULL) || (TopSizeArray == NULL) || (used_topSizeBlocks == 0)) {\n+  if ((StatArray == nullptr) || (TopSizeArray == nullptr) || (used_topSizeBlocks == 0)) {\n@@ -1266,1 +1266,1 @@\n-        if (TopSizeArray[i].blob_name == NULL) {\n+        if (TopSizeArray[i].blob_name == nullptr) {\n@@ -1270,1 +1270,1 @@\n-        \/\/ Returns NULL or void*. Returned CodeBlob may be uninitialized.\n+        \/\/ Returns nullptr or void*. Returned CodeBlob may be uninitialized.\n@@ -1273,1 +1273,1 @@\n-        if (this_blob != NULL) {\n+        if (this_blob != nullptr) {\n@@ -1332,1 +1332,1 @@\n-  if (SizeDistributionArray != NULL) {\n+  if (SizeDistributionArray != nullptr) {\n@@ -1435,1 +1435,1 @@\n-  if ((StatArray == NULL) || (FreeArray == NULL) || (alloc_granules == 0)) {\n+  if ((StatArray == nullptr) || (FreeArray == nullptr) || (alloc_granules == 0)) {\n@@ -1486,1 +1486,1 @@\n-      for (iy = 0; iy < nTop && FreeTopTen[iy] != NULL; iy++) {\n+      for (iy = 0; iy < nTop && FreeTopTen[iy] != nullptr; iy++) {\n@@ -1492,1 +1492,1 @@\n-          if (FreeTopTen[nTop-1] != NULL) {\n+          if (FreeTopTen[nTop-1] != nullptr) {\n@@ -1503,1 +1503,1 @@\n-      if (FreeTopTen[iy] == NULL) {\n+      if (FreeTopTen[iy] == nullptr) {\n@@ -1517,1 +1517,1 @@\n-    for (unsigned int iy = 0; (iy < nTop) && (FreeTopTen[iy] != NULL); iy++) {\n+    for (unsigned int iy = 0; (iy < nTop) && (FreeTopTen[iy] != nullptr); iy++) {\n@@ -1551,1 +1551,1 @@\n-      for (iy = 0; (iy < nTop) && (FreeTopTenTriple[iy] != NULL); iy++) {\n+      for (iy = 0; (iy < nTop) && (FreeTopTenTriple[iy] != nullptr); iy++) {\n@@ -1557,1 +1557,1 @@\n-          if (FreeTopTenTriple[nTop-1] != NULL) {\n+          if (FreeTopTenTriple[nTop-1] != nullptr) {\n@@ -1568,1 +1568,1 @@\n-      if (FreeTopTenTriple[iy] == NULL) {\n+      if (FreeTopTenTriple[iy] == nullptr) {\n@@ -1587,1 +1587,1 @@\n-    for (unsigned int iy = 0; (iy < nTop) && (FreeTopTenTriple[iy] != NULL); iy++) {\n+    for (unsigned int iy = 0; (iy < nTop) && (FreeTopTenTriple[iy] != nullptr); iy++) {\n@@ -1609,1 +1609,1 @@\n-  if ((StatArray == NULL) || (alloc_granules == 0)) {\n+  if ((StatArray == nullptr) || (alloc_granules == 0)) {\n@@ -1633,1 +1633,1 @@\n-      printBox(ast, '-', \"Total (all types) count for granule size == segment size\", NULL);\n+      printBox(ast, '-', \"Total (all types) count for granule size == segment size\", nullptr);\n@@ -1641,1 +1641,1 @@\n-      printBox(ast, '-', \"Total (all tiers) count, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", NULL);\n+      printBox(ast, '-', \"Total (all tiers) count, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", nullptr);\n@@ -1656,1 +1656,1 @@\n-      printBox(ast, '-', \"Tier1 nMethod count only, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", NULL);\n+      printBox(ast, '-', \"Tier1 nMethod count only, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", nullptr);\n@@ -1676,1 +1676,1 @@\n-      printBox(ast, '-', \"Tier2 nMethod count only, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", NULL);\n+      printBox(ast, '-', \"Tier2 nMethod count only, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", nullptr);\n@@ -1696,1 +1696,1 @@\n-      printBox(ast, '-', \"not_used\/not_entrant\/not_installed nMethod count only, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", NULL);\n+      printBox(ast, '-', \"not_used\/not_entrant\/not_installed nMethod count only, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", nullptr);\n@@ -1716,1 +1716,1 @@\n-      printBox(ast, '-', \"Stub & Blob count only, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", NULL);\n+      printBox(ast, '-', \"Stub & Blob count only, 0x1..0xf. '*' indicates >= 16 blocks, ' ' indicates empty\", nullptr);\n@@ -1736,1 +1736,1 @@\n-      printBox(ast, '-', \"Count by tier (combined): <#t1>:<#t2>:<#s>, 0x0..0xf. '*' indicates >= 16 blocks\", NULL);\n+      printBox(ast, '-', \"Count by tier (combined): <#t1>:<#t2>:<#s>, 0x0..0xf. '*' indicates >= 16 blocks\", nullptr);\n@@ -1767,1 +1767,1 @@\n-  if ((StatArray == NULL) || (alloc_granules == 0)) {\n+  if ((StatArray == nullptr) || (alloc_granules == 0)) {\n@@ -1794,1 +1794,1 @@\n-      printBox(ast, '-', \"Total (all types) space consumption for granule size == segment size\", NULL);\n+      printBox(ast, '-', \"Total (all types) space consumption for granule size == segment size\", nullptr);\n@@ -1802,1 +1802,1 @@\n-      printBox(ast, '-', \"Total (all types) space consumption. ' ' indicates empty, '*' indicates full.\", NULL);\n+      printBox(ast, '-', \"Total (all types) space consumption. ' ' indicates empty, '*' indicates full.\", nullptr);\n@@ -1817,1 +1817,1 @@\n-      printBox(ast, '-', \"Tier1 space consumption. ' ' indicates empty, '*' indicates full\", NULL);\n+      printBox(ast, '-', \"Tier1 space consumption. ' ' indicates empty, '*' indicates full\", nullptr);\n@@ -1837,1 +1837,1 @@\n-      printBox(ast, '-', \"Tier2 space consumption. ' ' indicates empty, '*' indicates full\", NULL);\n+      printBox(ast, '-', \"Tier2 space consumption. ' ' indicates empty, '*' indicates full\", nullptr);\n@@ -1857,1 +1857,1 @@\n-      printBox(ast, '-', \"not_used\/not_entrant\/not_installed space consumption. ' ' indicates empty, '*' indicates full\", NULL);\n+      printBox(ast, '-', \"not_used\/not_entrant\/not_installed space consumption. ' ' indicates empty, '*' indicates full\", nullptr);\n@@ -1877,1 +1877,1 @@\n-      printBox(ast, '-', \"Stub and Blob space consumption. ' ' indicates empty, '*' indicates full\", NULL);\n+      printBox(ast, '-', \"Stub and Blob space consumption. ' ' indicates empty, '*' indicates full\", nullptr);\n@@ -1897,1 +1897,1 @@\n-      printBox(ast, '-', \"Space consumption by tier (combined): <t1%>:<t2%>:<s%>. ' ' indicates empty, '*' indicates full\", NULL);\n+      printBox(ast, '-', \"Space consumption by tier (combined): <t1%>:<t2%>:<s%>. ' ' indicates empty, '*' indicates full\", nullptr);\n@@ -1936,1 +1936,1 @@\n-  if ((StatArray == NULL) || (alloc_granules == 0)) {\n+  if ((StatArray == nullptr) || (alloc_granules == 0)) {\n@@ -1957,1 +1957,1 @@\n-    printBox(ast, '-', \"Age distribution. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", NULL);\n+    printBox(ast, '-', \"Age distribution. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", nullptr);\n@@ -1975,1 +1975,1 @@\n-      printBox(ast, '-', \"Tier1 age distribution. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", NULL);\n+      printBox(ast, '-', \"Tier1 age distribution. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", nullptr);\n@@ -1991,1 +1991,1 @@\n-      printBox(ast, '-', \"Tier2 age distribution. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", NULL);\n+      printBox(ast, '-', \"Tier2 age distribution. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", nullptr);\n@@ -2007,1 +2007,1 @@\n-      printBox(ast, '-', \"not_used\/not_entrant\/not_installed age distribution. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", NULL);\n+      printBox(ast, '-', \"not_used\/not_entrant\/not_installed age distribution. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", nullptr);\n@@ -2023,1 +2023,1 @@\n-      printBox(ast, '-', \"age distribution by tier <a1>:<a2>. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", NULL);\n+      printBox(ast, '-', \"age distribution by tier <a1>:<a2>. '0' indicates youngest 1\/256, '8': oldest half, ' ': no age information\", nullptr);\n@@ -2048,1 +2048,1 @@\n-  if ((StatArray == NULL) || (alloc_granules == 0)) {\n+  if ((StatArray == nullptr) || (alloc_granules == 0)) {\n@@ -2055,1 +2055,1 @@\n-  CodeBlob*    last_blob           = NULL;\n+  CodeBlob*    last_blob           = nullptr;\n@@ -2093,1 +2093,1 @@\n-      \/\/ Returns NULL or void*. Returned CodeBlob may be uninitialized.\n+      \/\/ Returns nullptr or void*. Returned CodeBlob may be uninitialized.\n@@ -2115,1 +2115,1 @@\n-        nmethod*           nm = NULL;\n+        nmethod*           nm = nullptr;\n@@ -2119,2 +2119,2 @@\n-          \/\/ this_blob->name() could return NULL if no name was given to CTOR. Inlined, maybe invisible on stack\n-          if (blob_name == NULL) {\n+          \/\/ this_blob->name() could return nullptr if no name was given to CTOR. Inlined, maybe invisible on stack\n+          if (blob_name == nullptr) {\n@@ -2143,1 +2143,1 @@\n-        \/\/ This fact is implicitly transported via nm != NULL.\n+        \/\/ This fact is implicitly transported via nm != nullptr.\n@@ -2163,2 +2163,2 @@\n-            const char*   methNameS = (methName == NULL) ? NULL : methName->as_C_string();\n-            methNameS = (methNameS == NULL) ? \"<method name unavailable>\" : methNameS;\n+            const char*   methNameS = (methName == nullptr) ? nullptr : methName->as_C_string();\n+            methNameS = (methNameS == nullptr) ? \"<method name unavailable>\" : methNameS;\n@@ -2166,2 +2166,2 @@\n-            const char*   methSigS  = (methSig  == NULL) ? NULL : methSig->as_C_string();\n-            methSigS  = (methSigS  == NULL) ? \"<method signature unavailable>\" : methSigS;\n+            const char*   methSigS  = (methSig  == nullptr) ? nullptr : methSig->as_C_string();\n+            methSigS  = (methSigS  == nullptr) ? \"<method signature unavailable>\" : methSigS;\n@@ -2189,1 +2189,1 @@\n-      } else if (!blob_is_safe && (this_blob != last_blob) && (this_blob != NULL)) {\n+      } else if (!blob_is_safe && (this_blob != last_blob) && (this_blob != nullptr)) {\n@@ -2203,1 +2203,1 @@\n-  if (text1 != NULL) {\n+  if (text1 != nullptr) {\n@@ -2206,1 +2206,1 @@\n-  if (text2 != NULL) {\n+  if (text2 != nullptr) {\n@@ -2224,1 +2224,1 @@\n-  if (text1 != NULL) {\n+  if (text1 != nullptr) {\n@@ -2227,1 +2227,1 @@\n-  if (text2 != NULL) {\n+  if (text2 != nullptr) {\n@@ -2241,1 +2241,1 @@\n-  printBox(out, '-', \"Block types used in the following CodeHeap dump\", NULL);\n+  printBox(out, '-', \"Block types used in the following CodeHeap dump\", nullptr);\n@@ -2252,1 +2252,1 @@\n-  printBox(out, '-', \"Space ranges, based on granule occupancy\", NULL);\n+  printBox(out, '-', \"Space ranges, based on granule occupancy\", nullptr);\n@@ -2267,1 +2267,1 @@\n-  printBox(out, '-', \"Age ranges, based on compilation id\", NULL);\n+  printBox(out, '-', \"Age ranges, based on compilation id\", nullptr);\n@@ -2349,1 +2349,1 @@\n-  if (cb != NULL) {\n+  if (cb != nullptr) {\n@@ -2363,1 +2363,1 @@\n-      if (nm != NULL) { \/\/ no is_readable check required, nm = (nmethod*)cb.\n+      if (nm != nullptr) { \/\/ no is_readable check required, nm = (nmethod*)cb.\n@@ -2375,1 +2375,1 @@\n-  return (this_blob != NULL) && \/\/ a blob must have been found, obviously\n+  return (this_blob != nullptr) && \/\/ a blob must have been found, obviously\n@@ -2384,2 +2384,2 @@\n-  Method* method = (nm == NULL) ? NULL : nm->method(); \/\/ nm->method() was found to be uninitialized, i.e. != NULL, but invalid.\n-  return (nm != NULL) && (method != NULL) && (method->signature() != NULL);\n+  Method* method = (nm == nullptr) ? nullptr : nm->method(); \/\/ nm->method() was found to be uninitialized, i.e. != nullptr, but invalid.\n+  return (nm != nullptr) && (method != nullptr) && (method->signature() != nullptr);\n","filename":"src\/hotspot\/share\/code\/codeHeapState.cpp","additions":112,"deletions":112,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-  assert(cb != NULL && cb->is_compiled(), \"must be compiled\");\n+  assert(cb != nullptr && cb->is_compiled(), \"must be compiled\");\n@@ -88,1 +88,1 @@\n-    assert(data != NULL || Universe::non_oop_word() == NULL,\n+    assert(data != nullptr || Universe::non_oop_word() == nullptr,\n@@ -90,1 +90,1 @@\n-    return (data == (void*)Universe::non_oop_word()) ? NULL : data;\n+    return (data == (void*)Universe::non_oop_word()) ? nullptr : data;\n@@ -98,1 +98,1 @@\n-  assert(entry_point != NULL, \"must set legal entry point\");\n+  assert(entry_point != nullptr, \"must set legal entry point\");\n@@ -100,2 +100,2 @@\n-  assert (!is_optimized() || cache == NULL, \"an optimized virtual call does not have a cached metadata\");\n-  assert (cache == NULL || cache != (Metadata*)badOopVal, \"invalid metadata\");\n+  assert (!is_optimized() || cache == nullptr, \"an optimized virtual call does not have a cached metadata\");\n+  assert (cache == nullptr || cache != (Metadata*)badOopVal, \"invalid metadata\");\n@@ -132,1 +132,1 @@\n-    assert(cb != NULL && cb->is_compiled(), \"must be compiled\");\n+    assert(cb != nullptr && cb->is_compiled(), \"must be compiled\");\n@@ -140,1 +140,1 @@\n-    assert(cache == NULL, \"must be null\");\n+    assert(cache == nullptr, \"must be null\");\n@@ -144,1 +144,1 @@\n-  if (cache == NULL)  cache = Universe::non_oop_word();\n+  if (cache == nullptr)  cache = Universe::non_oop_word();\n@@ -151,1 +151,1 @@\n-  internal_set_ic_destination(stub->code_begin(), true, NULL, false);\n+  internal_set_ic_destination(stub->code_begin(), true, nullptr, false);\n@@ -205,1 +205,1 @@\n-    _value = NULL;\n+    _value = nullptr;\n@@ -215,2 +215,2 @@\n-  assert(ic_call != NULL, \"ic_call address must be set\");\n-  assert(cm != NULL, \"must pass compiled method\");\n+  assert(ic_call != nullptr, \"ic_call address must be set\");\n+  assert(cm != nullptr, \"must pass compiled method\");\n@@ -235,2 +235,2 @@\n-  assert(ic_call != NULL, \"ic_call address must be set\");\n-  assert(nm != NULL, \"must pass compiled method\");\n+  assert(ic_call != nullptr, \"ic_call address must be set\");\n+  assert(nm != nullptr, \"must pass compiled method\");\n@@ -258,1 +258,1 @@\n-    if (entry == NULL) {\n+    if (entry == nullptr) {\n@@ -281,1 +281,1 @@\n-    if (entry == NULL) {\n+    if (entry == nullptr) {\n@@ -284,1 +284,1 @@\n-    if (!InlineCacheBuffer::create_transition_stub(this, NULL, entry)) {\n+    if (!InlineCacheBuffer::create_transition_stub(this, nullptr, entry)) {\n@@ -292,1 +292,1 @@\n-    assert(call_info->selected_method() != NULL, \"Unexpected null selected method\");\n+    assert(call_info->selected_method() != nullptr, \"Unexpected null selected method\");\n@@ -314,1 +314,1 @@\n-  return VtableStubs::entry_point(ic_destination()) != NULL;\n+  return VtableStubs::entry_point(ic_destination()) != nullptr;\n@@ -321,1 +321,1 @@\n-  bool is_monomorphic = (cb != NULL && cb->is_compiled());\n+  bool is_monomorphic = (cb != nullptr && cb->is_compiled());\n@@ -324,1 +324,1 @@\n-  \/\/ for calling directly to vep without using the inline cache (i.e., cached_value == NULL).\n+  \/\/ for calling directly to vep without using the inline cache (i.e., cached_value == nullptr).\n@@ -333,1 +333,1 @@\n-         (cached_metadata() != NULL && cached_metadata()->is_klass()), \"sanity check\");\n+         (cached_metadata() != nullptr && cached_metadata()->is_klass()), \"sanity check\");\n@@ -346,2 +346,2 @@\n-    is_call_to_interpreted = (cb != NULL && cb->is_adapter_blob());\n-    assert(!is_call_to_interpreted || (is_icholder_call() && cached_icholder() != NULL), \"sanity check\");\n+    is_call_to_interpreted = (cb != nullptr && cb->is_adapter_blob());\n+    assert(!is_call_to_interpreted || (is_icholder_call() && cached_icholder() != nullptr), \"sanity check\");\n@@ -378,1 +378,1 @@\n-      set_ic_destination_and_value(entry, (void*)NULL);\n+      set_ic_destination_and_value(entry, (void*)nullptr);\n@@ -382,1 +382,1 @@\n-    if (!InlineCacheBuffer::create_transition_stub(this, NULL, entry)) {\n+    if (!InlineCacheBuffer::create_transition_stub(this, nullptr, entry)) {\n@@ -401,1 +401,1 @@\n-  assert(!is_clean || is_optimized() || cached_value() == NULL, \"sanity check\");\n+  assert(!is_clean || is_optimized() || cached_value() == nullptr, \"sanity check\");\n@@ -428,1 +428,1 @@\n-      assert(info.cached_metadata() != NULL && info.cached_metadata()->is_method(), \"sanity check\");\n+      assert(info.cached_metadata() != nullptr && info.cached_metadata()->is_method(), \"sanity check\");\n@@ -452,1 +452,1 @@\n-    bool static_bound = info.is_optimized() || (info.cached_metadata() == NULL);\n+    bool static_bound = info.is_optimized() || (info.cached_metadata() == nullptr);\n@@ -455,1 +455,1 @@\n-    assert (cb != NULL && cb->is_compiled(), \"must be compiled!\");\n+    assert (cb != nullptr && cb->is_compiled(), \"must be compiled!\");\n@@ -477,1 +477,1 @@\n-      assert(info.cached_metadata() == NULL || info.cached_metadata()->is_klass(), \"must be\");\n+      assert(info.cached_metadata() == nullptr || info.cached_metadata()->is_klass(), \"must be\");\n@@ -480,1 +480,1 @@\n-        (info.cached_metadata() != NULL) ? ((Klass*)info.cached_metadata())->print_value_string() : \"NULL\",\n+        (info.cached_metadata() != nullptr) ? ((Klass*)info.cached_metadata())->print_value_string() : \"nullptr\",\n@@ -509,2 +509,2 @@\n-  address entry = NULL;\n-  if (method_code != NULL && method_code->is_in_use() && !method_code->is_unloading()) {\n+  address entry = nullptr;\n+  if (method_code != nullptr && method_code->is_in_use() && !method_code->is_unloading()) {\n@@ -535,1 +535,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n@@ -537,1 +537,1 @@\n-    info.set_compiled_entry(entry, is_optimized ? NULL : receiver_klass, is_optimized);\n+    info.set_compiled_entry(entry, is_optimized ? nullptr : receiver_klass, is_optimized);\n@@ -544,1 +544,1 @@\n-      assert(method_code == NULL || method_code->is_compiled(), \"must be compiled\");\n+      assert(method_code == nullptr || method_code->is_compiled(), \"must be compiled\");\n@@ -555,1 +555,1 @@\n-  if (cb != NULL && cb->is_adapter_blob()) {\n+  if (cb != nullptr && cb->is_adapter_blob()) {\n@@ -559,1 +559,1 @@\n-  if (cb != NULL && cb->is_vtable_blob()) {\n+  if (cb != nullptr && cb->is_vtable_blob()) {\n@@ -561,1 +561,1 @@\n-    return (s != NULL) && s->is_itable_stub();\n+    return (s != nullptr) && s->is_itable_stub();\n@@ -636,1 +636,1 @@\n-  if (m_code != NULL && m_code->is_in_use() && !m_code->is_unloading()) {\n+  if (m_code != nullptr && m_code->is_in_use() && !m_code->is_unloading()) {\n@@ -657,1 +657,1 @@\n-  RelocIterator iter((nmethod*)NULL, instruction);\n+  RelocIterator iter((nmethod*)nullptr, instruction);\n@@ -674,1 +674,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -702,1 +702,1 @@\n-             p2i(instruction_address()), is_call_to_interpreted() ? \"interpreted \" : \"\", p2i(ic_destination()), p2i(is_optimized() ? NULL : cached_value()));\n+             p2i(instruction_address()), is_call_to_interpreted() ? \"interpreted \" : \"\", p2i(ic_destination()), p2i(is_optimized() ? nullptr : cached_value()));\n@@ -725,1 +725,1 @@\n-  assert(old_method == NULL || old_method == callee() ||\n+  assert(old_method == nullptr || old_method == callee() ||\n@@ -733,1 +733,1 @@\n-         || old_method == NULL || !old_method->method_holder()->is_loader_alive() \/\/ may have a race due to class unloading.\n+         || old_method == nullptr || !old_method->method_holder()->is_loader_alive() \/\/ may have a race due to class unloading.\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":48,"deletions":48,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-    assert(_cached_value != NULL, \"must be non-NULL\");\n+    assert(_cached_value != nullptr, \"must be non-nullptr\");\n@@ -129,1 +129,1 @@\n-  CompiledICInfo(): _entry(NULL), _cached_value(NULL), _is_icholder(false),\n+  CompiledICInfo(): _entry(nullptr), _cached_value(nullptr), _is_icholder(false),\n@@ -189,1 +189,1 @@\n-    internal_set_ic_destination(entry_point, false, NULL, false);\n+    internal_set_ic_destination(entry_point, false, nullptr, false);\n@@ -341,1 +341,1 @@\n-  static address emit_to_interp_stub(CodeBuffer &cbuf, address mark = NULL);\n+  static address emit_to_interp_stub(CodeBuffer &cbuf, address mark = nullptr);\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    _gc_data(NULL)\n+    _gc_data(nullptr)\n@@ -71,1 +71,1 @@\n-    _gc_data(NULL)\n+    _gc_data(nullptr)\n@@ -78,4 +78,4 @@\n-    _scopes_data_begin          = NULL;\n-    _deopt_handler_begin        = NULL;\n-    _deopt_mh_handler_begin     = NULL;\n-    _exception_cache            = NULL;\n+    _scopes_data_begin          = nullptr;\n+    _deopt_handler_begin        = nullptr;\n+    _deopt_mh_handler_begin     = nullptr;\n+    _exception_cache            = nullptr;\n@@ -92,1 +92,1 @@\n-  if (pd == NULL)\n+  if (pd == nullptr)\n@@ -111,1 +111,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -118,1 +118,1 @@\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? NULL : CompiledMethod_lock,\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n@@ -133,2 +133,2 @@\n-  assert(new_entry != NULL,\"Must be non null\");\n-  assert(new_entry->next() == NULL, \"Must be null\");\n+  assert(new_entry != nullptr,\"Must be non null\");\n+  assert(new_entry->next() == nullptr, \"Must be null\");\n@@ -138,1 +138,1 @@\n-    if (ec != NULL) {\n+    if (ec != nullptr) {\n@@ -154,1 +154,1 @@\n-      if (ec != NULL) {\n+      if (ec != nullptr) {\n@@ -180,1 +180,1 @@\n-  ExceptionCache* prev = NULL;\n+  ExceptionCache* prev = nullptr;\n@@ -183,1 +183,1 @@\n-  while (curr != NULL) {\n+  while (curr != nullptr) {\n@@ -187,1 +187,1 @@\n-      if (prev == NULL) {\n+      if (prev == nullptr) {\n@@ -192,1 +192,1 @@\n-          prev = NULL;\n+          prev = nullptr;\n@@ -220,1 +220,1 @@\n-  while (ec != NULL) {\n+  while (ec != nullptr) {\n@@ -222,1 +222,1 @@\n-    if ((ret_val = ec->match(exception,pc)) != NULL) {\n+    if ((ret_val = ec->match(exception,pc)) != nullptr) {\n@@ -227,1 +227,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -240,1 +240,1 @@\n-  if (target_entry == NULL || !target_entry->add_address_and_handler(pc,handler)) {\n+  if (target_entry == nullptr || !target_entry->add_address_and_handler(pc,handler)) {\n@@ -251,1 +251,1 @@\n-  while (ec != NULL) {\n+  while (ec != nullptr) {\n@@ -257,1 +257,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -284,1 +284,1 @@\n-  RelocIterator iter(this, NULL, NULL);\n+  RelocIterator iter(this, nullptr, nullptr);\n@@ -298,1 +298,1 @@\n-  guarantee(pd != NULL, \"scope must be present\");\n+  guarantee(pd != nullptr, \"scope must be present\");\n@@ -304,1 +304,1 @@\n-  guarantee(pd != NULL, \"scope must be present\");\n+  guarantee(pd != nullptr, \"scope must be present\");\n@@ -325,1 +325,1 @@\n-  \/\/ assert(BarrierSet::barrier_set()->barrier_set_nmethod() == NULL, \"Not safe oop scan\");\n+  \/\/ assert(BarrierSet::barrier_set()->barrier_set_nmethod() == nullptr, \"Not safe oop scan\");\n@@ -351,1 +351,1 @@\n-        assert(ic->cached_icholder() != NULL, \"must be non-NULL\");\n+        assert(ic->cached_icholder() != nullptr, \"must be non-nullptr\");\n@@ -363,1 +363,1 @@\n-  if (method() == NULL) {\n+  if (method() == nullptr) {\n@@ -381,1 +381,1 @@\n-    if (callee != NULL) {\n+    if (callee != nullptr) {\n@@ -415,1 +415,1 @@\n-  return NULL; \/\/ not found\n+  return nullptr; \/\/ not found\n@@ -423,1 +423,1 @@\n-  return NULL; \/\/ not a call\n+  return nullptr; \/\/ not a call\n@@ -452,1 +452,1 @@\n-    Klass* klass = NULL;\n+    Klass* klass = nullptr;\n@@ -483,1 +483,1 @@\n-    if (ic_metdata != NULL) {\n+    if (ic_metdata != nullptr) {\n@@ -512,2 +512,2 @@\n-  CompiledMethod* nm = (cb != NULL) ? cb->as_compiled_method_or_null() : NULL;\n-  if (nm != NULL) {\n+  CompiledMethod* nm = (cb != nullptr) ? cb->as_compiled_method_or_null() : nullptr;\n+  if (nm != nullptr) {\n@@ -564,1 +564,1 @@\n-  if (bs_nm != NULL) {\n+  if (bs_nm != nullptr) {\n@@ -570,1 +570,1 @@\n-    if (nm != NULL && bs_nm->is_armed(nm)) {\n+    if (nm != nullptr && bs_nm->is_armed(nm)) {\n@@ -658,1 +658,1 @@\n-      if (md != NULL && md->is_method()) {\n+      if (md != nullptr && md->is_method()) {\n@@ -661,1 +661,1 @@\n-          Atomic::store(r->metadata_addr(), (Method*)NULL);\n+          Atomic::store(r->metadata_addr(), (Method*)nullptr);\n@@ -689,1 +689,1 @@\n-    assert(cb != NULL && cb == this, \"\");\n+    assert(cb != nullptr && cb == this, \"\");\n@@ -700,1 +700,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-  PcDescCache() { debug_only(_pc_descs[0] = NULL); }\n+  PcDescCache() { debug_only(_pc_descs[0] = nullptr); }\n@@ -133,1 +133,1 @@\n-    if (desc != NULL && desc->pc_offset() == pc - base_address) {\n+    if (desc != nullptr && desc->pc_offset() == pc - base_address) {\n@@ -224,2 +224,2 @@\n-  bool is_native_method() const { return _method != NULL && _method->is_native(); }\n-  bool is_java_method() const { return _method != NULL && !_method->is_native(); }\n+  bool is_native_method() const { return _method != nullptr && _method->is_native(); }\n+  bool is_java_method() const { return _method != nullptr && !_method->is_native(); }\n@@ -284,0 +284,2 @@\n+  virtual int skipped_instructions_size() const = 0;\n+\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-  if (fr->cb() == NULL)  return NULL;\n+  if (fr->cb() == nullptr)  return nullptr;\n@@ -64,1 +64,1 @@\n-  if (cm != NULL && cm->is_deopt_pc(fr->pc()))\n+  if (cm != nullptr && cm->is_deopt_pc(fr->pc()))\n@@ -67,1 +67,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-CompressedWriteStream::CompressedWriteStream(int initial_size) : CompressedStream(NULL, 0) {\n+CompressedWriteStream::CompressedWriteStream(int initial_size) : CompressedStream(nullptr, 0) {\n","filename":"src\/hotspot\/share\/code\/compressedStream.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -71,1 +71,1 @@\n-  assert(_obj_pool != NULL, \"object pool does not exist\");\n+  assert(_obj_pool != nullptr, \"object pool does not exist\");\n@@ -85,1 +85,1 @@\n-  assert(_obj_pool != NULL, \"object pool does not exist\");\n+  assert(_obj_pool != nullptr, \"object pool does not exist\");\n@@ -93,1 +93,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -104,1 +104,1 @@\n-  ScopeValue* result = NULL;\n+  ScopeValue* result = nullptr;\n@@ -247,1 +247,1 @@\n-    assert(JNIHandles::resolve(value()) == NULL ||\n+    assert(JNIHandles::resolve(value()) == nullptr ||\n@@ -268,1 +268,1 @@\n-  assert(_value() == NULL ||\n+  assert(_value() == nullptr ||\n@@ -277,1 +277,1 @@\n-  if (value()() != NULL) {\n+  if (value()() != nullptr) {\n@@ -280,1 +280,1 @@\n-    st->print(\"NULL\");\n+    st->print(\"nullptr\");\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,1 @@\n-     , _klass(NULL)\n+     , _klass(nullptr)\n@@ -304,1 +304,1 @@\n-  DebugInfoReadStream(const CompiledMethod* code, int offset, GrowableArray<ScopeValue*>* obj_pool = NULL) :\n+  DebugInfoReadStream(const CompiledMethod* code, int offset, GrowableArray<ScopeValue*>* obj_pool = nullptr) :\n@@ -315,1 +315,1 @@\n-    assert(o == NULL || o->is_metadata(), \"meta data only\");\n+    assert(o == nullptr || o->is_metadata(), \"meta data only\");\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -140,1 +140,1 @@\n-  _next_chunk = _next_chunk_limit = NULL;\n+  _next_chunk = _next_chunk_limit = nullptr;\n@@ -199,1 +199,1 @@\n-  if (monitors == NULL || monitors->is_empty()) return DebugInformationRecorder::serialized_null;\n+  if (monitors == nullptr || monitors->is_empty()) return DebugInformationRecorder::serialized_null;\n@@ -220,1 +220,1 @@\n-  if (values == NULL || values->is_empty()) return DebugInformationRecorder::serialized_null;\n+  if (values == nullptr || values->is_empty()) return DebugInformationRecorder::serialized_null;\n@@ -318,1 +318,1 @@\n-  if (method != NULL) {\n+  if (method != nullptr) {\n@@ -323,1 +323,1 @@\n-    method_enc = NULL;\n+    method_enc = nullptr;\n@@ -328,1 +328,1 @@\n-  assert(method == NULL ||\n+  assert(method == nullptr ||\n@@ -355,1 +355,1 @@\n-  if (objects != NULL) {\n+  if (objects != nullptr) {\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,3 +112,3 @@\n-                      DebugToken* locals      = NULL,\n-                      DebugToken* expressions = NULL,\n-                      DebugToken* monitors    = NULL);\n+                      DebugToken* locals      = nullptr,\n+                      DebugToken* expressions = nullptr,\n+                      DebugToken* monitors    = nullptr);\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-  DEBUG_ONLY(_deps[end_marker] = NULL);\n+  DEBUG_ONLY(_deps[end_marker] = nullptr);\n@@ -74,1 +74,1 @@\n-  _content_bytes = NULL;\n+  _content_bytes = nullptr;\n@@ -142,1 +142,1 @@\n-  DEBUG_ONLY(_dep_values[end_marker] = NULL);\n+  DEBUG_ONLY(_dep_values[end_marker] = nullptr);\n@@ -146,1 +146,1 @@\n-  _content_bytes = NULL;\n+  _content_bytes = nullptr;\n@@ -484,1 +484,1 @@\n-    return NULL;  \/\/ let NULL be NULL\n+    return nullptr;  \/\/ let nullptr be nullptr\n@@ -496,1 +496,1 @@\n-    return NULL;  \/\/ let NULL be NULL\n+    return nullptr;  \/\/ let nullptr be nullptr\n@@ -633,1 +633,1 @@\n-    if (witness != NULL) {\n+    if (witness != nullptr) {\n@@ -636,1 +636,1 @@\n-        if (failure_detail != NULL && klass_violations == 0) {\n+        if (failure_detail != nullptr && klass_violations == 0) {\n@@ -646,1 +646,1 @@\n-      if (xtty == NULL) {\n+      if (xtty == nullptr) {\n@@ -660,1 +660,1 @@\n-  if (log() == NULL)  return;\n+  if (log() == nullptr)  return;\n@@ -687,1 +687,1 @@\n-  if (log == NULL) {\n+  if (log == nullptr) {\n@@ -710,1 +710,1 @@\n-  if (log == NULL) {\n+  if (log == nullptr) {\n@@ -723,1 +723,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -742,1 +742,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -753,1 +753,1 @@\n-  if (xtty == NULL) {\n+  if (xtty == nullptr) {\n@@ -760,1 +760,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -789,1 +789,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -801,1 +801,1 @@\n-                (witness == NULL)? \"Dependency\": \"Failed dependency\",\n+                (witness == nullptr)? \"Dependency\": \"Failed dependency\",\n@@ -816,1 +816,1 @@\n-      put_star = !Dependencies::is_concrete_method((Method*)arg.metadata_value(), NULL);\n+      put_star = !Dependencies::is_concrete_method((Method*)arg.metadata_value(), nullptr);\n@@ -835,1 +835,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -844,1 +844,1 @@\n-  if (_deps == NULL && xtty == NULL)  return;  \/\/ fast cutout for runtime\n+  if (_deps == nullptr && xtty == nullptr)  return;  \/\/ fast cutout for runtime\n@@ -856,2 +856,2 @@\n-  if (_deps != NULL && _deps->log() != NULL) {\n-    if (ciEnv::current() != NULL) {\n+  if (_deps != nullptr && _deps->log() != nullptr) {\n+    if (ciEnv::current() != nullptr) {\n@@ -883,1 +883,1 @@\n-    if (_code != NULL) {\n+    if (_code != nullptr) {\n@@ -900,1 +900,1 @@\n-  assert((_code!=NULL) + (_deps!=NULL) == 1, \"one or t'other\");\n+  assert((_code!=nullptr) + (_deps!=nullptr) == 1, \"one or t'other\");\n@@ -906,1 +906,1 @@\n-  if (_bytes.position() == 0 && _code != NULL\n+  if (_bytes.position() == 0 && _code != nullptr\n@@ -937,2 +937,2 @@\n-  Metadata* o = NULL;\n-  if (_code != NULL) {\n+  Metadata* o = nullptr;\n+  if (_code != nullptr) {\n@@ -947,1 +947,1 @@\n-  return (_code != NULL)\n+  return (_code != nullptr)\n@@ -955,1 +955,1 @@\n-  if (result == NULL) { \/\/ Explicit context argument can be compressed\n+  if (result == nullptr) { \/\/ Explicit context argument can be compressed\n@@ -962,1 +962,1 @@\n-  assert(result == NULL || result->is_klass() || result->is_method(), \"must be\");\n+  assert(result == nullptr || result->is_klass() || result->is_method(), \"must be\");\n@@ -991,1 +991,1 @@\n-      assert(k != NULL && k->is_klass(), \"type check\");\n+      assert(k != nullptr && k->is_klass(), \"type check\");\n@@ -1002,1 +1002,1 @@\n-      assert(k != NULL, \"type check\");\n+      assert(k != nullptr, \"type check\");\n@@ -1009,1 +1009,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1061,1 +1061,1 @@\n-      _participants[i] = NULL;\n+      _participants[i] = nullptr;\n@@ -1063,1 +1063,1 @@\n-    if (participant != NULL) {\n+    if (participant != nullptr) {\n@@ -1112,1 +1112,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1129,1 +1129,1 @@\n-  Klass* find_witness(InstanceKlass* context_type, KlassDepChange* changes = NULL);\n+  Klass* find_witness(InstanceKlass* context_type, KlassDepChange* changes = nullptr);\n@@ -1135,3 +1135,3 @@\n-PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_anywhere_calls_count = NULL;\n-PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_anywhere_steps_count = NULL;\n-PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_in_calls_count       = NULL;\n+PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_anywhere_calls_count = nullptr;\n+PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_anywhere_steps_count = nullptr;\n+PerfCounter* AbstractClassHierarchyWalker::_perf_find_witness_in_calls_count       = nullptr;\n@@ -1158,1 +1158,1 @@\n-  assert(changes == NULL || changes->involves_context(context_type), \"irrelevant dependency\");\n+  assert(changes == nullptr || changes->involves_context(context_type), \"irrelevant dependency\");\n@@ -1166,1 +1166,1 @@\n-      return NULL; \/\/ no implementors\n+      return nullptr; \/\/ no implementors\n@@ -1182,1 +1182,1 @@\n-  if (changes != NULL) {\n+  if (changes != nullptr) {\n@@ -1204,1 +1204,1 @@\n-  ConcreteSubtypeFinder(Klass* participant = NULL) : AbstractClassHierarchyWalker(participant) {}\n+  ConcreteSubtypeFinder(Klass* participant = nullptr) : AbstractClassHierarchyWalker(participant) {}\n@@ -1225,1 +1225,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1232,1 +1232,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1247,1 +1247,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1267,2 +1267,2 @@\n-  ConcreteMethodFinder(Method* m, Klass* participant = NULL) : AbstractClassHierarchyWalker(participant) {\n-    assert(m != NULL && m->is_method(), \"sanity\");\n+  ConcreteMethodFinder(Method* m, Klass* participant = nullptr) : AbstractClassHierarchyWalker(participant) {\n+    assert(m != nullptr && m->is_method(), \"sanity\");\n@@ -1273,1 +1273,1 @@\n-      _found_methods[i] = NULL;\n+      _found_methods[i] = nullptr;\n@@ -1277,1 +1277,1 @@\n-  \/\/ Note:  If n==num_participants, returns NULL.\n+  \/\/ Note:  If n==num_participants, returns nullptr.\n@@ -1281,2 +1281,2 @@\n-    assert(n == num_participants() || fm != NULL, \"proper usage\");\n-    if (fm != NULL && fm->method_holder() != participant(n)) {\n+    assert(n == num_participants() || fm != nullptr, \"proper usage\");\n+    if (fm != nullptr && fm->method_holder() != participant(n)) {\n@@ -1287,1 +1287,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1294,1 +1294,1 @@\n-    _found_methods[num_participants()] = NULL;\n+    _found_methods[num_participants()] = nullptr;\n@@ -1325,1 +1325,1 @@\n-      if (!ik->is_interface() && m != NULL && m->is_abstract()) {\n+      if (!ik->is_interface() && m != nullptr && m->is_abstract()) {\n@@ -1335,1 +1335,1 @@\n-        if (w != NULL) {\n+        if (w != nullptr) {\n@@ -1347,1 +1347,1 @@\n-      if (default_methods != NULL) {\n+      if (default_methods != nullptr) {\n@@ -1349,1 +1349,1 @@\n-        if (Dependencies::is_concrete_method(dm, NULL)) {\n+        if (Dependencies::is_concrete_method(dm, nullptr)) {\n@@ -1374,1 +1374,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1384,1 +1384,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -1387,1 +1387,1 @@\n-      for (InstanceKlass* super = k->java_super(); super != NULL; super = super->java_super()) {\n+      for (InstanceKlass* super = k->java_super(); super != nullptr; super = super->java_super()) {\n@@ -1389,1 +1389,1 @@\n-        if (m != NULL) { \/\/ inherited method found\n+        if (m != nullptr) { \/\/ inherited method found\n@@ -1413,1 +1413,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1455,1 +1455,1 @@\n-      _found_methods[i] = NULL;\n+      _found_methods[i] = nullptr;\n@@ -1457,1 +1457,1 @@\n-    if (participant != NULL) {\n+    if (participant != nullptr) {\n@@ -1475,1 +1475,1 @@\n-  LinkedConcreteMethodFinder(InstanceKlass* resolved_klass, Method* resolved_method, Method* uniqm = NULL) : AbstractClassHierarchyWalker(NULL) {\n+  LinkedConcreteMethodFinder(InstanceKlass* resolved_klass, Method* resolved_method, Method* uniqm = nullptr) : AbstractClassHierarchyWalker(nullptr) {\n@@ -1490,1 +1490,1 @@\n-  \/\/ Note:  If n==num_participants, returns NULL.\n+  \/\/ Note:  If n==num_participants, returns nullptr.\n@@ -1493,1 +1493,1 @@\n-    assert(participant(n) != NULL || n == num_participants(), \"proper usage\");\n+    assert(participant(n) != nullptr || n == num_participants(), \"proper usage\");\n@@ -1506,1 +1506,1 @@\n-  return NULL; \/\/ No witness found.  The dependency remains unbroken.\n+  return nullptr; \/\/ No witness found.  The dependency remains unbroken.\n@@ -1519,1 +1519,1 @@\n-  return NULL; \/\/ No witness found. The dependency remains unbroken.\n+  return nullptr; \/\/ No witness found. The dependency remains unbroken.\n@@ -1539,1 +1539,1 @@\n-  Method* selected_method = NULL;\n+  Method* selected_method = nullptr;\n@@ -1549,1 +1549,1 @@\n-  return selected_method; \/\/ NULL when corresponding slot is empty (AbstractMethodError case)\n+  return selected_method; \/\/ nullptr when corresponding slot is empty (AbstractMethodError case)\n@@ -1600,1 +1600,1 @@\n-  if (lm == NULL && ctxk->is_instance_klass()) {\n+  if (lm == nullptr && ctxk->is_instance_klass()) {\n@@ -1609,1 +1609,1 @@\n-  if (lm != NULL) {\n+  if (lm != nullptr) {\n@@ -1636,1 +1636,1 @@\n-  if (lm != NULL) {\n+  if (lm != nullptr) {\n@@ -1653,2 +1653,2 @@\n-  \/\/ NULL is not a concrete method.\n-  if (m == NULL) {\n+  \/\/ nullptr is not a concrete method.\n+  if (m == nullptr) {\n@@ -1666,1 +1666,1 @@\n-  if (m->is_overpass() && k != NULL) {\n+  if (m->is_overpass() && k != nullptr) {\n@@ -1669,1 +1669,1 @@\n-  \/\/ Note \"true\" is conservative answer: overpass clause is false if k == NULL,\n+  \/\/ Note \"true\" is conservative answer: overpass clause is false if k == nullptr,\n@@ -1681,1 +1681,1 @@\n-  return NULL; \/\/ not found\n+  return nullptr; \/\/ not found\n@@ -1708,1 +1708,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1723,1 +1723,1 @@\n-  if (sub != NULL) {\n+  if (sub != nullptr) {\n@@ -1729,1 +1729,1 @@\n-    assert(impl != NULL, \"must be set\");\n+    assert(impl != nullptr, \"must be set\");\n@@ -1732,1 +1732,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1749,1 +1749,1 @@\n-\/\/ Find the unique concrete proper subtype of ctxk, or NULL if there\n+\/\/ Find the unique concrete proper subtype of ctxk, or nullptr if there\n@@ -1753,1 +1753,1 @@\n-\/\/ That is, return CC1 for CX > CC1 > CC2, but NULL for CX > { CC1, CC2 }.\n+\/\/ That is, return CC1 for CX > CC1 > CC2, but nullptr for CX > { CC1, CC2 }.\n@@ -1758,1 +1758,1 @@\n-  if (wit != NULL)  return NULL;   \/\/ Too many witnesses.\n+  if (wit != nullptr)  return nullptr;   \/\/ Too many witnesses.\n@@ -1760,1 +1760,1 @@\n-  if (conck == NULL) {\n+  if (conck == nullptr) {\n@@ -1769,1 +1769,1 @@\n-        guarantee(NULL == (void *)\n+        guarantee(nullptr == (void *)\n@@ -1793,1 +1793,1 @@\n-  if (uniqm == NULL) {\n+  if (uniqm == nullptr) {\n@@ -1813,1 +1813,1 @@\n-\/\/ If a class (or interface) has a unique concrete method uniqm, return NULL.\n+\/\/ If a class (or interface) has a unique concrete method uniqm, return nullptr.\n@@ -1820,1 +1820,1 @@\n-  if (k != NULL) {\n+  if (k != nullptr) {\n@@ -1823,1 +1823,1 @@\n-  if (!Dependencies::is_concrete_root_method(uniqm, ctxk) || changes != NULL) {\n+  if (!Dependencies::is_concrete_root_method(uniqm, ctxk) || changes != nullptr) {\n@@ -1825,1 +1825,1 @@\n-    if (conck != NULL) {\n+    if (conck != nullptr) {\n@@ -1830,1 +1830,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1838,1 +1838,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1849,2 +1849,2 @@\n-  if (m != NULL) {\n-    if (changes != NULL) {\n+  if (m != nullptr) {\n+    if (changes != nullptr) {\n@@ -1861,1 +1861,1 @@\n-      if (conck != NULL) {\n+      if (conck != nullptr) {\n@@ -1869,1 +1869,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1875,2 +1875,2 @@\n-  assert(base_m != NULL, \"base method should be non null\");\n-  if (sub_m == NULL) {\n+  assert(base_m != nullptr, \"base method should be non null\");\n+  if (sub_m == nullptr) {\n@@ -1898,1 +1898,1 @@\n-  \/\/ Return NULL if m is marked old; must have been a redefined method.\n+  \/\/ Return nullptr if m is marked old; must have been a redefined method.\n@@ -1900,1 +1900,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1903,1 +1903,1 @@\n-    return NULL; \/\/ not supported\n+    return nullptr; \/\/ not supported\n@@ -1909,3 +1909,3 @@\n-  if (wit != NULL)  return NULL;  \/\/ Too many witnesses.\n-  Method* fm = wf.found_method(0);  \/\/ Will be NULL if num_parts == 0.\n-  if (participant != NULL) {\n+  if (wit != nullptr)  return nullptr;  \/\/ Too many witnesses.\n+  Method* fm = wf.found_method(0);  \/\/ Will be nullptr if num_parts == 0.\n+  if (participant != nullptr) {\n@@ -1914,2 +1914,2 @@\n-  if (!Dependencies::is_concrete_method(fm, NULL)) {\n-    fm = NULL; \/\/ ignore abstract methods\n+  if (!Dependencies::is_concrete_method(fm, nullptr)) {\n+    fm = nullptr; \/\/ ignore abstract methods\n@@ -1918,1 +1918,1 @@\n-    if (fm == NULL) {\n+    if (fm == nullptr) {\n@@ -1924,1 +1924,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1926,1 +1926,1 @@\n-  } else if (Dependencies::find_witness_AME(ctxk, fm) != NULL) {\n+  } else if (Dependencies::find_witness_AME(ctxk, fm) != nullptr) {\n@@ -1928,1 +1928,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1931,1 +1931,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1936,2 +1936,2 @@\n-  if (VerifyDependencies && fm != NULL) {\n-    guarantee(NULL == (void *)check_unique_concrete_method(ctxk, fm),\n+  if (VerifyDependencies && fm != nullptr) {\n+    guarantee(nullptr == (void *)check_unique_concrete_method(ctxk, fm),\n@@ -1944,1 +1944,1 @@\n-\/\/ If a class (or interface) has a unique concrete method uniqm, return NULL.\n+\/\/ If a class (or interface) has a unique concrete method uniqm, return nullptr.\n@@ -1960,1 +1960,1 @@\n-    return NULL; \/\/ no vtable index available\n+    return nullptr; \/\/ no vtable index available\n@@ -1974,1 +1974,1 @@\n-  \/\/ Return NULL if m is marked old; must have been a redefined method.\n+  \/\/ Return nullptr if m is marked old; must have been a redefined method.\n@@ -1976,1 +1976,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1987,2 +1987,2 @@\n-  if (wit != NULL) {\n-    return NULL;  \/\/ Too many witnesses.\n+  if (wit != nullptr) {\n+    return nullptr;  \/\/ Too many witnesses.\n@@ -1990,4 +1990,4 @@\n-  \/\/ p == NULL when no participants are found (wf.num_participants() == 0).\n-  \/\/ fm == NULL case has 2 meanings:\n-  \/\/  * when p == NULL: no method found;\n-  \/\/  * when p != NULL: AbstractMethodError-throwing method found.\n+  \/\/ p == nullptr when no participants are found (wf.num_participants() == 0).\n+  \/\/ fm == nullptr case has 2 meanings:\n+  \/\/  * when p == nullptr: no method found;\n+  \/\/  * when p != nullptr: AbstractMethodError-throwing method found.\n@@ -1997,2 +1997,2 @@\n-  assert(fm == NULL || p != NULL, \"no participant\");\n-  \/\/ Normalize all error-throwing cases to NULL.\n+  assert(fm == nullptr || p != nullptr, \"no participant\");\n+  \/\/ Normalize all error-throwing cases to nullptr.\n@@ -2002,1 +2002,1 @@\n-    fm = NULL; \/\/ error-throwing method\n+    fm = nullptr; \/\/ error-throwing method\n@@ -2005,1 +2005,1 @@\n-    if (p == NULL) {\n+    if (p == nullptr) {\n@@ -2007,1 +2007,1 @@\n-      assert(fm == NULL, \"sanity\");\n+      assert(fm == nullptr, \"sanity\");\n@@ -2013,2 +2013,2 @@\n-  if (VerifyDependencies && fm != NULL) {\n-    guarantee(NULL == check_unique_concrete_method(ctxk, fm, resolved_klass, resolved_method),\n+  if (VerifyDependencies && fm != nullptr) {\n+    guarantee(nullptr == check_unique_concrete_method(ctxk, fm, resolved_klass, resolved_method),\n@@ -2018,1 +2018,1 @@\n-  assert(fm == NULL || !fm->is_abstract(), \"sanity\");\n+  assert(fm == nullptr || !fm->is_abstract(), \"sanity\");\n@@ -2023,1 +2023,1 @@\n-  Klass*  uniqp = NULL;\n+  Klass*  uniqp = nullptr;\n@@ -2025,1 +2025,1 @@\n-  assert(uniqm == NULL || uniqm == fm ||\n+  assert(uniqm == nullptr || uniqm == fm ||\n@@ -2028,1 +2028,1 @@\n-         (fm == NULL && uniqm != NULL && uniqp != NULL && !InstanceKlass::cast(uniqp)->is_linked()),\n+         (fm == nullptr && uniqm != nullptr && uniqp != nullptr && !InstanceKlass::cast(uniqp)->is_linked()),\n@@ -2036,1 +2036,1 @@\n-  if (changes != NULL) {\n+  if (changes != nullptr) {\n@@ -2043,2 +2043,2 @@\n-  assert(call_site != NULL, \"sanity\");\n-  assert(method_handle != NULL, \"sanity\");\n+  assert(call_site != nullptr, \"sanity\");\n+  assert(method_handle != nullptr, \"sanity\");\n@@ -2047,1 +2047,1 @@\n-  if (changes == NULL) {\n+  if (changes == nullptr) {\n@@ -2058,1 +2058,1 @@\n-  return NULL;  \/\/ assertion still valid\n+  return nullptr;  \/\/ assertion still valid\n@@ -2062,1 +2062,1 @@\n-  if (witness != NULL) {\n+  if (witness != nullptr) {\n@@ -2075,1 +2075,1 @@\n-  Klass* witness = NULL;\n+  Klass* witness = nullptr;\n@@ -2099,1 +2099,1 @@\n-    witness = NULL;\n+    witness = nullptr;\n@@ -2111,1 +2111,1 @@\n-  Klass* witness = NULL;\n+  Klass* witness = nullptr;\n@@ -2117,1 +2117,1 @@\n-    witness = NULL;\n+    witness = nullptr;\n@@ -2128,1 +2128,1 @@\n-  if (changes != NULL) {\n+  if (changes != nullptr) {\n@@ -2135,1 +2135,1 @@\n-    Klass* witness = check_new_klass_dependency(NULL);\n+    Klass* witness = check_new_klass_dependency(nullptr);\n@@ -2137,1 +2137,1 @@\n-    assert(witness != NULL || check_klass_init_dependency(NULL) == NULL, \"missed dependency\");\n+    assert(witness != nullptr || check_klass_init_dependency(nullptr) == nullptr, \"missed dependency\");\n@@ -2146,1 +2146,1 @@\n-  Klass* witness = NULL;\n+  Klass* witness = nullptr;\n@@ -2152,1 +2152,1 @@\n-    witness = NULL;\n+    witness = nullptr;\n@@ -2170,1 +2170,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2206,2 +2206,2 @@\n-  Klass* type = (_changes.is_klass_change() ? _changes.as_klass_change()->type() : (Klass*) NULL);\n-  _change_type = (type == NULL ? NO_CHANGE : Start_Klass);\n+  Klass* type = (_changes.is_klass_change() ? _changes.as_klass_change()->type() : (Klass*) nullptr);\n+  _change_type = (type == nullptr ? NO_CHANGE : Start_Klass);\n@@ -2209,1 +2209,1 @@\n-  _ti_base = NULL;\n+  _ti_base = nullptr;\n@@ -2228,1 +2228,1 @@\n-      if (_klass != NULL) {\n+      if (_klass != nullptr) {\n@@ -2233,1 +2233,1 @@\n-    _ti_limit = (_ti_base == NULL) ? 0 : _ti_base->length();\n+    _ti_limit = (_ti_base == nullptr) ? 0 : _ti_base->length();\n@@ -2273,1 +2273,1 @@\n-  if (k == NULL || !k->is_instance_klass()) {\n+  if (k == nullptr || !k->is_instance_klass()) {\n@@ -2300,1 +2300,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":164,"deletions":164,"binary":false,"changes":328,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,3 +206,3 @@\n-    DepValue(OopRecorder* rec, Metadata* metadata, DepValue* candidate = NULL) {\n-      assert(candidate == NULL || candidate->is_metadata(), \"oops\");\n-      if (candidate != NULL && candidate->as_metadata(rec) == metadata) {\n+    DepValue(OopRecorder* rec, Metadata* metadata, DepValue* candidate = nullptr) {\n+      assert(candidate == nullptr || candidate->is_metadata(), \"oops\");\n+      if (candidate != nullptr && candidate->as_metadata(rec) == metadata) {\n@@ -214,3 +214,3 @@\n-    DepValue(OopRecorder* rec, jobject obj, DepValue* candidate = NULL) {\n-      assert(candidate == NULL || candidate->is_object(), \"oops\");\n-      if (candidate != NULL && candidate->as_object(rec) == obj) {\n+    DepValue(OopRecorder* rec, jobject obj, DepValue* candidate = nullptr) {\n+      assert(candidate == nullptr || candidate->is_object(), \"oops\");\n+      if (candidate != nullptr && candidate->as_object(rec) == obj) {\n@@ -236,1 +236,1 @@\n-      assert(m != NULL, \"as_metadata returned NULL\");\n+      assert(m != nullptr, \"as_metadata returned nullptr\");\n@@ -242,1 +242,1 @@\n-      assert(m != NULL, \"as_metadata returned NULL\");\n+      assert(m != nullptr, \"as_metadata returned nullptr\");\n@@ -269,1 +269,1 @@\n-    assert(_dep_seen != NULL, \"deps must be writable\");\n+    assert(_dep_seen != nullptr, \"deps must be writable\");\n@@ -281,1 +281,1 @@\n-    assert(_dep_seen != NULL, \"deps must be writable\");\n+    assert(_dep_seen != nullptr, \"deps must be writable\");\n@@ -394,1 +394,1 @@\n-  static Klass* find_witness_AME(InstanceKlass* ctxk, Method* m, KlassDepChange* changes = NULL);\n+  static Klass* find_witness_AME(InstanceKlass* ctxk, Method* m, KlassDepChange* changes = nullptr);\n@@ -421,8 +421,8 @@\n-  static Klass* check_abstract_with_unique_concrete_subtype(InstanceKlass* ctxk, Klass* conck, NewKlassDepChange* changes = NULL);\n-  static Klass* check_unique_implementor(InstanceKlass* ctxk, Klass* uniqk, NewKlassDepChange* changes = NULL);\n-  static Klass* check_unique_concrete_method(InstanceKlass* ctxk, Method* uniqm, NewKlassDepChange* changes = NULL);\n-  static Klass* check_unique_concrete_method(InstanceKlass* ctxk, Method* uniqm, Klass* resolved_klass, Method* resolved_method, KlassDepChange* changes = NULL);\n-  static Klass* check_has_no_finalizable_subclasses(InstanceKlass* ctxk, NewKlassDepChange* changes = NULL);\n-  static Klass* check_call_site_target_value(oop call_site, oop method_handle, CallSiteDepChange* changes = NULL);\n-  \/\/ A returned Klass* is NULL if the dependency assertion is still\n-  \/\/ valid.  A non-NULL Klass* is a 'witness' to the assertion\n+  static Klass* check_abstract_with_unique_concrete_subtype(InstanceKlass* ctxk, Klass* conck, NewKlassDepChange* changes = nullptr);\n+  static Klass* check_unique_implementor(InstanceKlass* ctxk, Klass* uniqk, NewKlassDepChange* changes = nullptr);\n+  static Klass* check_unique_concrete_method(InstanceKlass* ctxk, Method* uniqm, NewKlassDepChange* changes = nullptr);\n+  static Klass* check_unique_concrete_method(InstanceKlass* ctxk, Method* uniqm, Klass* resolved_klass, Method* resolved_method, KlassDepChange* changes = nullptr);\n+  static Klass* check_has_no_finalizable_subclasses(InstanceKlass* ctxk, NewKlassDepChange* changes = nullptr);\n+  static Klass* check_call_site_target_value(oop call_site, oop method_handle, CallSiteDepChange* changes = nullptr);\n+  \/\/ A returned Klass* is nullptr if the dependency assertion is still\n+  \/\/ valid.  A non-nullptr Klass* is a 'witness' to the assertion\n@@ -431,1 +431,1 @@\n-  \/\/ non-NULL, the value is a subtype of the supposed leaf type.  This\n+  \/\/ non-nullptr, the value is a subtype of the supposed leaf type.  This\n@@ -444,1 +444,1 @@\n-                                             Klass** participant = NULL); \/\/ out parameter\n+                                             Klass** participant = nullptr); \/\/ out parameter\n@@ -455,1 +455,1 @@\n-    assert(_content_bytes != NULL, \"encode it first\");\n+    assert(_content_bytes != nullptr, \"encode it first\");\n@@ -459,1 +459,1 @@\n-    assert(_content_bytes != NULL, \"encode it first\");\n+    assert(_content_bytes != nullptr, \"encode it first\");\n@@ -468,1 +468,1 @@\n-  DepType validate_dependencies(CompileTask* task, char** failure_detail = NULL);\n+  DepType validate_dependencies(CompileTask* task, char** failure_detail = nullptr);\n@@ -482,4 +482,4 @@\n-                      ciBaseObject* x1 = NULL,\n-                      ciBaseObject* x2 = NULL,\n-                      ciBaseObject* x3 = NULL) {\n-    if (log() == NULL) {\n+                      ciBaseObject* x1 = nullptr,\n+                      ciBaseObject* x2 = nullptr,\n+                      ciBaseObject* x3 = nullptr) {\n+    if (log() == nullptr) {\n@@ -491,1 +491,1 @@\n-    assert (x0 != NULL, \"no log x0\");\n+    assert (x0 != nullptr, \"no log x0\");\n@@ -494,1 +494,1 @@\n-    if (x1 != NULL) {\n+    if (x1 != nullptr) {\n@@ -497,1 +497,1 @@\n-    if (x2 != NULL) {\n+    if (x2 != nullptr) {\n@@ -500,1 +500,1 @@\n-    if (x3 != NULL) {\n+    if (x3 != nullptr) {\n@@ -513,1 +513,1 @@\n-    DepArgument() : _is_oop(false), _valid(false), _value(NULL) {}\n+    DepArgument() : _is_oop(false), _valid(false), _value(nullptr) {}\n@@ -517,1 +517,1 @@\n-    bool is_null() const               { return _value == NULL; }\n+    bool is_null() const               { return _value == nullptr; }\n@@ -529,1 +529,1 @@\n-                               Klass* witness = NULL, outputStream* st = tty);\n+                               Klass* witness = nullptr, outputStream* st = tty);\n@@ -540,1 +540,1 @@\n-                                  Klass* witness = NULL);\n+                                  Klass* witness = nullptr);\n@@ -544,1 +544,1 @@\n-                                  Klass* witness = NULL);\n+                                  Klass* witness = nullptr);\n@@ -548,1 +548,1 @@\n-                                  Klass* witness = NULL);\n+                                  Klass* witness = nullptr);\n@@ -588,1 +588,1 @@\n-      : _code(NULL),\n+      : _code(nullptr),\n@@ -596,1 +596,1 @@\n-        _deps(NULL),\n+        _deps(nullptr),\n@@ -630,3 +630,3 @@\n-      Klass* result = check_klass_dependency(NULL);\n-      if (result != NULL)  return result;\n-      return check_call_site_dependency(NULL);\n+      Klass* result = check_klass_dependency(nullptr);\n+      if (result != nullptr)  return result;\n+      return check_call_site_dependency(nullptr);\n@@ -640,1 +640,1 @@\n-    void log_dependency(Klass* witness = NULL);\n+    void log_dependency(Klass* witness = nullptr);\n@@ -643,1 +643,1 @@\n-    void print_dependency(Klass* witness = NULL, bool verbose = false, outputStream* st = tty);\n+    void print_dependency(Klass* witness = nullptr, bool verbose = false, outputStream* st = tty);\n","filename":"src\/hotspot\/share\/code\/dependencies.hpp","additions":46,"deletions":46,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,5 +36,5 @@\n-PerfCounter* DependencyContext::_perf_total_buckets_allocated_count   = NULL;\n-PerfCounter* DependencyContext::_perf_total_buckets_deallocated_count = NULL;\n-PerfCounter* DependencyContext::_perf_total_buckets_stale_count       = NULL;\n-PerfCounter* DependencyContext::_perf_total_buckets_stale_acc_count   = NULL;\n-nmethodBucket* volatile DependencyContext::_purge_list                = NULL;\n+PerfCounter* DependencyContext::_perf_total_buckets_allocated_count   = nullptr;\n+PerfCounter* DependencyContext::_perf_total_buckets_deallocated_count = nullptr;\n+PerfCounter* DependencyContext::_perf_total_buckets_stale_count       = nullptr;\n+PerfCounter* DependencyContext::_perf_total_buckets_stale_acc_count   = nullptr;\n+nmethodBucket* volatile DependencyContext::_purge_list                = nullptr;\n@@ -69,1 +69,1 @@\n-  for (nmethodBucket* b = dependencies_not_unloading(); b != NULL; b = b->next_not_unloading()) {\n+  for (nmethodBucket* b = dependencies_not_unloading(); b != nullptr; b = b->next_not_unloading()) {\n@@ -71,7 +71,15 @@\n-    if (b->count() > 0 && !nm->is_marked_for_deoptimization() && nm->check_dependency_on(changes)) {\n-      if (TraceDependencies) {\n-        ResourceMark rm;\n-        tty->print_cr(\"Marked for deoptimization\");\n-        changes.print();\n-        nm->print();\n-        nm->print_dependencies();\n+    if (b->count() > 0) {\n+      if (nm->is_marked_for_deoptimization()) {\n+        \/\/ Also count already (concurrently) marked nmethods to make sure\n+        \/\/ deoptimization is triggered before execution in this thread continues.\n+        found++;\n+      } else if (nm->check_dependency_on(changes)) {\n+        if (TraceDependencies) {\n+          ResourceMark rm;\n+          tty->print_cr(\"Marked for deoptimization\");\n+          changes.print();\n+          nm->print();\n+          nm->print_dependencies();\n+        }\n+        changes.mark_for_deoptimization(nm);\n+        found++;\n@@ -79,2 +87,0 @@\n-      changes.mark_for_deoptimization(nm);\n-      found++;\n@@ -94,1 +100,1 @@\n-  for (nmethodBucket* b = dependencies_not_unloading(); b != NULL; b = b->next_not_unloading()) {\n+  for (nmethodBucket* b = dependencies_not_unloading(); b != nullptr; b = b->next_not_unloading()) {\n@@ -100,1 +106,1 @@\n-  nmethodBucket* new_head = new nmethodBucket(nm, NULL);\n+  nmethodBucket* new_head = new nmethodBucket(nm, nullptr);\n@@ -143,1 +149,1 @@\n-  for (nmethodBucket* b = _purge_list; b != NULL;) {\n+  for (nmethodBucket* b = _purge_list; b != nullptr;) {\n@@ -152,1 +158,1 @@\n-  _purge_list = NULL;\n+  _purge_list = nullptr;\n@@ -166,1 +172,1 @@\n-  while (b != NULL) {\n+  while (b != nullptr) {\n@@ -182,1 +188,1 @@\n-  set_dependencies(NULL);\n+  set_dependencies(nullptr);\n@@ -188,1 +194,1 @@\n-  set_dependencies(NULL);\n+  set_dependencies(nullptr);\n@@ -190,1 +196,1 @@\n-  while (b != NULL) {\n+  while (b != nullptr) {\n@@ -192,1 +198,3 @@\n-    if (b->count() > 0 && !nm->is_marked_for_deoptimization()) {\n+    if (b->count() > 0) {\n+      \/\/ Also count already (concurrently) marked nmethods to make sure\n+      \/\/ deoptimization is triggered before execution in this thread continues.\n@@ -204,1 +212,1 @@\n-  for (nmethodBucket* b = dependencies_not_unloading(); b != NULL; b = b->next_not_unloading()) {\n+  for (nmethodBucket* b = dependencies_not_unloading(); b != nullptr; b = b->next_not_unloading()) {\n@@ -220,1 +228,1 @@\n-  for (nmethodBucket* b = dependencies_not_unloading(); b != NULL; b = b->next_not_unloading()) {\n+  for (nmethodBucket* b = dependencies_not_unloading(); b != nullptr; b = b->next_not_unloading()) {\n@@ -255,1 +263,1 @@\n-    if (head == NULL || !head->get_nmethod()->is_unloading()) {\n+    if (head == nullptr || !head->get_nmethod()->is_unloading()) {\n@@ -309,1 +317,1 @@\n-    if (next == NULL || !next->get_nmethod()->is_unloading()) {\n+    if (next == nullptr || !next->get_nmethod()->is_unloading()) {\n","filename":"src\/hotspot\/share\/code\/dependencyContext.cpp","additions":37,"deletions":29,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-    _nmethod(nmethod), _count(1), _next(next), _purge_list_next(NULL) {}\n+    _nmethod(nmethod), _count(1), _next(next), _purge_list_next(nullptr) {}\n","filename":"src\/hotspot\/share\/code\/dependencyContext.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -81,1 +81,1 @@\n-  assert(subtable_for(catch_pco) == NULL, \"catch handlers for this catch_pco added twice\");\n+  assert(subtable_for(catch_pco) == nullptr, \"catch handlers for this catch_pco added twice\");\n@@ -83,1 +83,1 @@\n-  assert(scope_depths_from_top_scope == NULL || handler_bcis->length() == scope_depths_from_top_scope->length(), \"bci & scope_depths table have different length\");\n+  assert(scope_depths_from_top_scope == nullptr || handler_bcis->length() == scope_depths_from_top_scope->length(), \"bci & scope_depths table have different length\");\n@@ -90,1 +90,1 @@\n-      if (scope_depths_from_top_scope != NULL) {\n+      if (scope_depths_from_top_scope != nullptr) {\n@@ -112,1 +112,1 @@\n-  if (t != NULL) {\n+  if (t != nullptr) {\n@@ -119,1 +119,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -125,1 +125,1 @@\n-  bool have_base_addr = (base != NULL);\n+  bool have_base_addr = (base != nullptr);\n@@ -157,1 +157,1 @@\n-  if( subtable != NULL ) { print_subtable( subtable ); }\n+  if( subtable != nullptr ) { print_subtable( subtable ); }\n@@ -221,1 +221,1 @@\n-    _data = NULL;\n+    _data = nullptr;\n","filename":"src\/hotspot\/share\/code\/exceptionHandlerTable.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,2 +126,2 @@\n-  void print_subtable(HandlerTableEntry* t, address base = NULL) const;\n-  void print(address base = NULL) const;\n+  void print_subtable(HandlerTableEntry* t, address base = nullptr) const;\n+  void print(address base = nullptr) const;\n","filename":"src\/hotspot\/share\/code\/exceptionHandlerTable.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-StubQueue* InlineCacheBuffer::_buffer    = NULL;\n+StubQueue* InlineCacheBuffer::_buffer    = nullptr;\n@@ -47,1 +47,1 @@\n-CompiledICHolder* InlineCacheBuffer::_pending_released = NULL;\n+CompiledICHolder* InlineCacheBuffer::_pending_released = nullptr;\n@@ -56,1 +56,1 @@\n-  assert(thread->missed_ic_stub_refill_verifier() == NULL, \"nesting not supported\");\n+  assert(thread->missed_ic_stub_refill_verifier() == nullptr, \"nesting not supported\");\n@@ -63,1 +63,1 @@\n-  Thread::current()->set_missed_ic_stub_refill_verifier(NULL);\n+  Thread::current()->set_missed_ic_stub_refill_verifier(nullptr);\n@@ -68,1 +68,1 @@\n-  assert(thread->missed_ic_stub_refill_verifier() == NULL, \"nesting not supported\");\n+  assert(thread->missed_ic_stub_refill_verifier() == nullptr, \"nesting not supported\");\n@@ -73,1 +73,1 @@\n-  Thread::current()->set_missed_ic_stub_refill_verifier(NULL);\n+  Thread::current()->set_missed_ic_stub_refill_verifier(nullptr);\n@@ -79,1 +79,1 @@\n-  assert(verifier != NULL, \"need a verifier for safety\");\n+  assert(verifier != nullptr, \"need a verifier for safety\");\n@@ -88,1 +88,1 @@\n-    assert(CodeCache::find_compiled(ic->instruction_address()) != NULL, \"inline cache in non-compiled?\");\n+    assert(CodeCache::find_compiled(ic->instruction_address()) != nullptr, \"inline cache in non-compiled?\");\n@@ -122,1 +122,1 @@\n-  _ic_site = NULL;\n+  _ic_site = nullptr;\n@@ -142,1 +142,1 @@\n-  if (_buffer != NULL) return; \/\/ already initialized\n+  if (_buffer != nullptr) return; \/\/ already initialized\n@@ -144,1 +144,1 @@\n-  assert (_buffer != NULL, \"cannot allocate InlineCacheBuffer\");\n+  assert (_buffer != nullptr, \"cannot allocate InlineCacheBuffer\");\n@@ -199,1 +199,1 @@\n-  if (ic_stub == NULL) {\n+  if (ic_stub == nullptr) {\n@@ -237,2 +237,2 @@\n-  _pending_released = NULL;\n-  while (holder != NULL) {\n+  _pending_released = nullptr;\n+  while (holder != nullptr) {\n","filename":"src\/hotspot\/share\/code\/icBuffer.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-  void    initialize(int size)                   { _size = size; _ic_site = NULL; }\n+  void    initialize(int size)                   { _size = size; _ic_site = nullptr; }\n@@ -80,1 +80,1 @@\n-  bool    is_empty() const                       { return _ic_site == NULL; }\n+  bool    is_empty() const                       { return _ic_site == nullptr; }\n","filename":"src\/hotspot\/share\/code\/icBuffer.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-    if (m != NULL) {                                                      \\\n+    if (m != nullptr) {                                                   \\\n@@ -271,1 +271,1 @@\n-  assert(pc != NULL, \"Must be non null\");\n+  assert(pc != nullptr, \"Must be non null\");\n@@ -273,1 +273,1 @@\n-  assert(handler != NULL, \"Must be non null\");\n+  assert(handler != nullptr, \"Must be non null\");\n@@ -277,2 +277,2 @@\n-  _next = NULL;\n-  _purge_list_next = NULL;\n+  _next = nullptr;\n+  _purge_list_next = nullptr;\n@@ -285,1 +285,1 @@\n-  assert(pc != NULL,\"Must be non null\");\n+  assert(pc != nullptr,\"Must be non null\");\n@@ -291,1 +291,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -311,1 +311,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -349,2 +349,2 @@\n-  if (initial_pc_desc == NULL) {\n-    _pc_descs[0] = NULL; \/\/ native method; no PcDescs at all\n+  if (initial_pc_desc == nullptr) {\n+    _pc_descs[0] = nullptr; \/\/ native method; no PcDescs at all\n@@ -376,1 +376,1 @@\n-  if (res == NULL) return NULL;  \/\/ native method; no PcDescs at all\n+  if (res == nullptr) return nullptr;  \/\/ native method; no PcDescs at all\n@@ -393,1 +393,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -432,1 +432,1 @@\n-  if (method() != NULL && is_native_method()) {\n+  if (method() != nullptr && is_native_method()) {\n@@ -438,1 +438,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -447,2 +447,2 @@\n-  _oops_do_mark_link       = NULL;\n-  _osr_link                = NULL;\n+  _oops_do_mark_link       = nullptr;\n+  _osr_link                = nullptr;\n@@ -502,1 +502,1 @@\n-  nmethod* nm = NULL;\n+  nmethod* nm = nullptr;\n@@ -525,1 +525,1 @@\n-    NOT_PRODUCT(if (nm != NULL) native_nmethod_stats.note_native_nmethod(nm));\n+    NOT_PRODUCT(if (nm != nullptr) native_nmethod_stats.note_native_nmethod(nm));\n@@ -528,1 +528,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -562,1 +562,1 @@\n-  nmethod* nm = NULL;\n+  nmethod* nm = nullptr;\n@@ -595,1 +595,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -617,1 +617,1 @@\n-          if (klass == NULL) {\n+          if (klass == nullptr) {\n@@ -624,1 +624,1 @@\n-      NOT_PRODUCT(if (nm != NULL)  note_java_nmethod(nm));\n+      NOT_PRODUCT(if (nm != nullptr)  note_java_nmethod(nm));\n@@ -628,1 +628,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -649,1 +649,1 @@\n-  _unlinked_next(NULL),\n+  _unlinked_next(nullptr),\n@@ -680,0 +680,1 @@\n+    _skipped_instructions_size = code_buffer->total_skipped_instructions_size();\n@@ -690,3 +691,3 @@\n-    _osr_entry_point         = NULL;\n-    _exception_cache         = NULL;\n-    _pc_desc_container.reset_to(NULL);\n+    _osr_entry_point         = nullptr;\n+    _exception_cache         = nullptr;\n+    _pc_desc_container.reset_to(nullptr);\n@@ -718,1 +719,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n@@ -732,1 +733,1 @@\n-        if (oop_maps != NULL) {\n+        if (oop_maps != nullptr) {\n@@ -750,1 +751,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n@@ -792,1 +793,1 @@\n-  _unlinked_next(NULL),\n+  _unlinked_next(nullptr),\n@@ -816,0 +817,1 @@\n+    _skipped_instructions_size      = code_buffer->total_skipped_instructions_size();\n@@ -828,1 +830,1 @@\n-        _deopt_handler_begin = NULL;\n+        _deopt_handler_begin = nullptr;\n@@ -833,1 +835,1 @@\n-        _deopt_mh_handler_begin = NULL;\n+        _deopt_mh_handler_begin = nullptr;\n@@ -847,1 +849,1 @@\n-        _deopt_mh_handler_begin  = NULL;\n+        _deopt_mh_handler_begin  = nullptr;\n@@ -874,1 +876,1 @@\n-    _exception_cache         = NULL;\n+    _exception_cache         = nullptr;\n@@ -917,1 +919,1 @@\n-  if (nm_kind != NULL)  log->print(\" compile_kind='%s'\", nm_kind);\n+  if (nm_kind != nullptr)  log->print(\" compile_kind='%s'\", nm_kind);\n@@ -923,1 +925,1 @@\n-  if (jvmci_nmethod_data() != NULL) {\n+  if (jvmci_nmethod_data() != nullptr) {\n@@ -925,1 +927,1 @@\n-    if (jvmci_name != NULL) {\n+    if (jvmci_name != nullptr) {\n@@ -942,1 +944,1 @@\n-  if (LogCompilation && xtty != NULL) {\n+  if (LogCompilation && xtty != nullptr) {\n@@ -972,1 +974,1 @@\n-  if (st != NULL) {\n+  if (st != nullptr) {\n@@ -992,1 +994,1 @@\n-  if (xtty != NULL) {\n+  if (xtty != nullptr) {\n@@ -1022,1 +1024,1 @@\n-      if (oop_maps() != NULL) {\n+      if (oop_maps() != nullptr) {\n@@ -1064,1 +1066,1 @@\n-  if (xtty != NULL) {\n+  if (xtty != nullptr) {\n@@ -1072,1 +1074,1 @@\n-  if (handle == NULL ||\n+  if (handle == nullptr ||\n@@ -1096,1 +1098,1 @@\n-  fix_oop_relocations(NULL, NULL, \/*initialize_immediates=*\/ true);\n+  fix_oop_relocations(nullptr, nullptr, \/*initialize_immediates=*\/ true);\n@@ -1116,1 +1118,2 @@\n-        initialize_immediate_oop(dest, cast_from_oop<jobject>(*dest));\n+        jobject obj = *reinterpret_cast<jobject*>(dest);\n+        initialize_immediate_oop(dest, obj);\n@@ -1163,1 +1166,1 @@\n-  assert(method() == NULL || can_be_deoptimized(), \"\");\n+  assert(method() == nullptr || can_be_deoptimized(), \"\");\n@@ -1178,1 +1181,1 @@\n-        if (nop != NULL) {\n+        if (nop != nullptr) {\n@@ -1189,1 +1192,1 @@\n-        if (nop != NULL) {\n+        if (nop != nullptr) {\n@@ -1216,1 +1219,1 @@\n-        assert(cb != NULL, \"destination not in CodeBlob?\");\n+        assert(cb != nullptr, \"destination not in CodeBlob?\");\n@@ -1218,1 +1221,1 @@\n-        if( nm != NULL ) {\n+        if( nm != nullptr ) {\n@@ -1229,1 +1232,1 @@\n-        assert(cb != NULL, \"destination not in CodeBlob?\");\n+        assert(cb != nullptr, \"destination not in CodeBlob?\");\n@@ -1231,1 +1234,1 @@\n-        if( nm != NULL ) {\n+        if( nm != nullptr ) {\n@@ -1259,1 +1262,1 @@\n-  if (m == NULL)  return;\n+  if (m == nullptr)  return;\n@@ -1261,1 +1264,1 @@\n-  if (mdo == NULL)  return;\n+  if (mdo == nullptr)  return;\n@@ -1281,1 +1284,1 @@\n-  if (method() != NULL) {\n+  if (method() != nullptr) {\n@@ -1288,1 +1291,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n@@ -1305,1 +1308,1 @@\n-  if (method() != NULL) {\n+  if (method() != nullptr) {\n@@ -1331,1 +1334,1 @@\n-    MutexLocker ml(CompiledMethod_lock->owned_by_self() ? NULL : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n@@ -1379,1 +1382,1 @@\n-  if (nmethod_data != NULL) {\n+  if (nmethod_data != nullptr) {\n@@ -1385,1 +1388,1 @@\n-  if (is_osr_method() && method() != NULL) {\n+  if (is_osr_method() && method() != nullptr) {\n@@ -1397,1 +1400,1 @@\n-  if (_unlinked_next != NULL) {\n+  if (_unlinked_next != nullptr) {\n@@ -1420,1 +1423,1 @@\n-  if (nmethod_data != NULL) {\n+  if (nmethod_data != nullptr) {\n@@ -1448,1 +1451,1 @@\n-  while(ec != NULL) {\n+  while(ec != nullptr) {\n@@ -1463,1 +1466,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1470,1 +1473,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1489,1 +1492,1 @@\n-        if (klass == NULL) {\n+        if (klass == nullptr) {\n@@ -1509,1 +1512,1 @@\n-  if (CompilationLog::log() != NULL) {\n+  if (CompilationLog::log() != nullptr) {\n@@ -1543,1 +1546,1 @@\n-    if (state == NULL) {\n+    if (state == nullptr) {\n@@ -1556,1 +1559,1 @@\n-  assert(_method != NULL, \"just checking\");\n+  assert(_method != nullptr, \"just checking\");\n@@ -1585,1 +1588,1 @@\n-        if (r->metadata_is_immediate() && r->metadata_value() != NULL) {\n+        if (r->metadata_is_immediate() && r->metadata_value() != nullptr) {\n@@ -1599,1 +1602,1 @@\n-          if (ic_oop != NULL) {\n+          if (ic_oop != nullptr) {\n@@ -1609,1 +1612,1 @@\n-    if (*p == Universe::non_oop_word() || *p == NULL)  continue;  \/\/ skip non-oops\n+    if (*p == Universe::non_oop_word() || *p == nullptr)  continue;  \/\/ skip non-oops\n@@ -1615,1 +1618,1 @@\n-  if (_method != NULL) f->do_metadata(_method);\n+  if (_method != nullptr) f->do_metadata(_method);\n@@ -1742,1 +1745,1 @@\n-    if (bs_nm != NULL) {\n+    if (bs_nm != nullptr) {\n@@ -1761,1 +1764,1 @@\n-        if (r->oop_is_immediate() && r->oop_value() != NULL) {\n+        if (r->oop_is_immediate() && r->oop_value() != nullptr) {\n@@ -1803,1 +1806,1 @@\n-    assert(result == NULL, \"adding to global list as weak done must always succeed.\");\n+    assert(result == nullptr, \"adding to global list as weak done must always succeed.\");\n@@ -1812,1 +1815,1 @@\n-  if ((_oops_do_mark_link == NULL) &&\n+  if ((_oops_do_mark_link == nullptr) &&\n@@ -1827,2 +1830,2 @@\n-  oops_do_mark_link* old_next = Atomic::cmpxchg(&_oops_do_mark_link, mark_link(NULL, claim_weak_request_tag), mark_link(this, claim_strong_done_tag));\n-  if (old_next == NULL) {\n+  oops_do_mark_link* old_next = Atomic::cmpxchg(&_oops_do_mark_link, mark_link(nullptr, claim_weak_request_tag), mark_link(this, claim_strong_done_tag));\n+  if (old_next == nullptr) {\n@@ -1866,1 +1869,1 @@\n-  if (old_head == NULL) {\n+  if (old_head == nullptr) {\n@@ -1872,1 +1875,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1883,1 +1886,1 @@\n-  if (old_head == NULL) {\n+  if (old_head == nullptr) {\n@@ -1902,1 +1905,1 @@\n-  if (old_head == NULL) {\n+  if (old_head == nullptr) {\n@@ -1919,1 +1922,1 @@\n-  if (next_raw == NULL) {\n+  if (next_raw == nullptr) {\n@@ -1952,1 +1955,1 @@\n-  assert(_oops_do_mark_nmethods == NULL, \"must be empty\");\n+  assert(_oops_do_mark_nmethods == nullptr, \"must be empty\");\n@@ -1959,2 +1962,2 @@\n-  _oops_do_mark_nmethods = NULL;\n-  if (next != NULL) {\n+  _oops_do_mark_nmethods = nullptr;\n+  if (next != nullptr) {\n@@ -1965,1 +1968,1 @@\n-      cur->_oops_do_mark_link = NULL;\n+      cur->_oops_do_mark_link = nullptr;\n@@ -2008,1 +2011,1 @@\n-  assert(has_method_handle_invokes() == (_deopt_mh_handler_begin != NULL), \"must have deopt mh handler\");\n+  assert(has_method_handle_invokes() == (_deopt_mh_handler_begin != nullptr), \"must have deopt mh handler\");\n@@ -2039,1 +2042,1 @@\n-  PcDesc* res = NULL;\n+  PcDesc* res = nullptr;\n@@ -2043,1 +2046,1 @@\n-      if (res == NULL)\n+      if (res == nullptr)\n@@ -2059,1 +2062,1 @@\n-    return NULL;  \/\/ PC is wildly out of range\n+    return nullptr;  \/\/ PC is wildly out of range\n@@ -2066,1 +2069,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -2078,1 +2081,1 @@\n-  if (lower >= upper)  return NULL;  \/\/ native method; no PcDescs at all\n+  if (lower >= upper)  return nullptr;  \/\/ native method; no PcDescs at all\n@@ -2131,2 +2134,2 @@\n-    assert(NULL == linear_search(search, pc_offset, approximate), \"search ok\");\n-    return NULL;\n+    assert(nullptr == linear_search(search, pc_offset, approximate), \"search ok\");\n+    return nullptr;\n@@ -2165,1 +2168,1 @@\n-          if (deps.check_dependency() != NULL) {\n+          if (deps.check_dependency() != nullptr) {\n@@ -2188,1 +2191,1 @@\n-    if (deps.spot_check_dependency_at(changes) != NULL) {\n+    if (deps.spot_check_dependency_at(changes) != nullptr) {\n@@ -2284,1 +2287,1 @@\n-        assert(pc_desc_at(code_begin() + exec_offset) != NULL, \"missing PcDesc\");\n+        assert(pc_desc_at(code_begin() + exec_offset) != nullptr, \"missing PcDesc\");\n@@ -2304,1 +2307,1 @@\n-  assert(_oops_do_mark_link == NULL, \"_oops_do_mark_link for %s should be NULL but is \" PTR_FORMAT,\n+  assert(_oops_do_mark_link == nullptr, \"_oops_do_mark_link for %s should be nullptr but is \" PTR_FORMAT,\n@@ -2329,1 +2332,1 @@\n-  assert(pd != NULL, \"PcDesc must exist\");\n+  assert(pd != nullptr, \"PcDesc must exist\");\n@@ -2343,1 +2346,1 @@\n-    address stub = NULL;\n+    address stub = nullptr;\n@@ -2367,1 +2370,1 @@\n-    assert(stub == NULL || stub_contains(stub), \"static call stub outside stub section\");\n+    assert(stub == nullptr || stub_contains(stub), \"static call stub outside stub section\");\n@@ -2395,1 +2398,1 @@\n-  print_on(st, NULL);\n+  print_on(st, nullptr);\n@@ -2480,1 +2483,1 @@\n-    if (ctxk != NULL) {\n+    if (ctxk != nullptr) {\n@@ -2505,2 +2508,2 @@\n-      if (*p == NULL) {\n-        st->print_cr(\"NULL-oop\");\n+      if (*p == nullptr) {\n+        st->print_cr(\"nullptr-oop\");\n@@ -2548,1 +2551,1 @@\n-      while (sd != NULL) {\n+      while (sd != nullptr) {\n@@ -2593,1 +2596,1 @@\n-    value = NULL;\n+    value = nullptr;\n@@ -2610,1 +2613,1 @@\n-      tty->print(\"NULL-oop\");\n+      tty->print(\"nullptr-oop\");\n@@ -2644,2 +2647,2 @@\n-      } else if (m == NULL) {\n-        tty->print(\"NULL-oop\");\n+      } else if (m == nullptr) {\n+        tty->print(\"nullptr-oop\");\n@@ -2774,1 +2777,1 @@\n-  if ((start == NULL) || (end == NULL)) {\n+  if ((start == nullptr) || (end == nullptr)) {\n@@ -2787,1 +2790,1 @@\n-    const char* header = NULL;\n+    const char* header = nullptr;\n@@ -2791,1 +2794,1 @@\n-      while ((p < end) && (header == NULL)) {\n+      while ((p < end) && (header == nullptr)) {\n@@ -2800,2 +2803,2 @@\n-        header = NULL;\n-      } else if (header != NULL) {\n+        header = nullptr;\n+      } else if (header != nullptr) {\n@@ -2804,1 +2807,1 @@\n-        header = NULL;\n+        header = nullptr;\n@@ -2821,1 +2824,1 @@\n-    while ((p < end) && (p != NULL)) {\n+    while ((p < end) && (p != nullptr)) {\n@@ -2901,1 +2904,1 @@\n-          if (obj == NULL) st.print(\"NULL\");\n+          if (obj == nullptr) st.print(\"nullptr\");\n@@ -2911,1 +2914,1 @@\n-          if (obj == NULL) st.print(\"NULL\");\n+          if (obj == nullptr) st.print(\"nullptr\");\n@@ -2923,1 +2926,1 @@\n-          if (cb != NULL) {\n+          if (cb != nullptr) {\n@@ -2944,1 +2947,1 @@\n-          if (m != NULL) {\n+          if (m != nullptr) {\n@@ -2955,1 +2958,1 @@\n-          if (m != NULL) {\n+          if (m != nullptr) {\n@@ -2966,1 +2969,1 @@\n-          if (m != NULL) {\n+          if (m != nullptr) {\n@@ -2985,1 +2988,1 @@\n-  return have_one ? \"other\" : NULL;\n+  return have_one ? \"other\" : nullptr;\n@@ -2991,1 +2994,1 @@\n-  if (p != NULL && p->real_pc(this) <= end) {\n+  if (p != nullptr && p->real_pc(this) <= end) {\n@@ -2994,1 +2997,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2998,1 +3001,1 @@\n-  const char* label = NULL;\n+  const char* label = nullptr;\n@@ -3007,1 +3010,1 @@\n-  if (JVMCI_ONLY(_deopt_handler_begin != NULL &&) pos == deopt_handler_begin()) label = \"[Deopt Handler Code]\";\n+  if (JVMCI_ONLY(_deopt_handler_begin != nullptr &&) pos == deopt_handler_begin()) label = \"[Deopt Handler Code]\";\n@@ -3014,1 +3017,1 @@\n-    if (label != NULL) {\n+    if (label != nullptr) {\n@@ -3022,1 +3025,1 @@\n-    if (m != NULL) {\n+    if (m != nullptr) {\n@@ -3027,1 +3030,1 @@\n-    if (m != NULL && !is_osr_method()) {\n+    if (m != nullptr && !is_osr_method()) {\n@@ -3117,1 +3120,1 @@\n-  if (sd != NULL) return true;\n+  if (sd != nullptr) return true;\n@@ -3121,1 +3124,1 @@\n-  if (str != NULL) return true;\n+  if (str != nullptr) return true;\n@@ -3152,1 +3155,1 @@\n-  if (oms != NULL) {\n+  if (oms != nullptr) {\n@@ -3181,1 +3184,1 @@\n-  if (sd != NULL) {\n+  if (sd != nullptr) {\n@@ -3196,2 +3199,2 @@\n-      if (sd->method() == NULL) {\n-        st->print(\"method is NULL\");\n+      if (sd->method() == nullptr) {\n+        st->print(\"method is nullptr\");\n@@ -3211,1 +3214,1 @@\n-            if (invoke.name() != NULL)\n+            if (invoke.name() != nullptr)\n@@ -3224,1 +3227,1 @@\n-            if (field.name() != NULL)\n+            if (field.name() != nullptr)\n@@ -3237,1 +3240,1 @@\n-    for (;sd != NULL; sd = sd->sender()) {\n+    for (;sd != nullptr; sd = sd->sender()) {\n@@ -3243,2 +3246,2 @@\n-      if (sd->method() == NULL) {\n-        st->print(\"method is NULL\");\n+      if (sd->method() == nullptr) {\n+        st->print(\"method is nullptr\");\n@@ -3262,2 +3265,2 @@\n-  if (str != NULL) {\n-    if (sd != NULL) st->cr();\n+  if (str != nullptr) {\n+    if (sd != nullptr) st->cr();\n@@ -3309,1 +3312,1 @@\n-    assert(db != NULL && !db->is_adapter_blob(), \"must use stub!\");\n+    assert(db != nullptr && !db->is_adapter_blob(), \"must use stub!\");\n@@ -3345,1 +3348,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3363,1 +3366,1 @@\n-  print_on(st, NULL);\n+  print_on(st, nullptr);\n@@ -3391,1 +3394,1 @@\n-  if (xtty != NULL)  xtty->head(\"statistics type='nmethod'\");\n+  if (xtty != nullptr)  xtty->head(\"statistics type='nmethod'\");\n@@ -3408,1 +3411,1 @@\n-  if (xtty != NULL)  xtty->tail(\"statistics\");\n+  if (xtty != nullptr)  xtty->tail(\"statistics\");\n@@ -3417,1 +3420,1 @@\n-    guarantee(jvmci_nmethod_data() != NULL, \"failed speculation in nmethod without failed speculation list\");\n+    guarantee(jvmci_nmethod_data() != nullptr, \"failed speculation in nmethod without failed speculation list\");\n@@ -3424,1 +3427,1 @@\n-  if (jvmci_nmethod_data() != NULL) {\n+  if (jvmci_nmethod_data() != nullptr) {\n@@ -3427,1 +3430,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":160,"deletions":157,"binary":false,"changes":317,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-  \/\/   _oops_do_mark_link == NULL: the nmethod has not been visited at all yet, i.e.\n+  \/\/   _oops_do_mark_link == nullptr: the nmethod has not been visited at all yet, i.e.\n@@ -176,1 +176,1 @@\n-  \/\/ Attempt N|WR -> X|WD transition. Returns NULL if successful, X otherwise.\n+  \/\/ Attempt N|WR -> X|WD transition. Returns nullptr if successful, X otherwise.\n@@ -263,0 +263,2 @@\n+  int _skipped_instructions_size;\n+\n@@ -344,1 +346,1 @@\n-                              , char* speculations = NULL,\n+                              , char* speculations = nullptr,\n@@ -347,2 +349,2 @@\n-                              const char* nmethod_mirror_name = NULL,\n-                              FailedSpeculation** failed_speculations = NULL\n+                              const char* nmethod_mirror_name = nullptr,\n+                              FailedSpeculation** failed_speculations = nullptr\n@@ -381,1 +383,1 @@\n-  address unwind_handler_begin  () const          { return _unwind_handler_offset != -1 ? (header_begin() + _unwind_handler_offset) : NULL; }\n+  address unwind_handler_begin  () const          { return _unwind_handler_offset != -1 ? (header_begin() + _unwind_handler_offset) : nullptr; }\n@@ -396,0 +398,3 @@\n+\n+  int skipped_instructions_size () const          { return           _skipped_instructions_size             ; }\n+\n@@ -489,1 +494,1 @@\n-  Metadata*     metadata_at(int index) const      { return index == 0 ? NULL: *metadata_addr_at(index); }\n+  Metadata*     metadata_at(int index) const      { return index == 0 ? nullptr: *metadata_addr_at(index); }\n@@ -506,1 +511,1 @@\n-  void fix_oop_relocations()                           { fix_oop_relocations(NULL, NULL, false); }\n+  void fix_oop_relocations()                           { fix_oop_relocations(nullptr, nullptr, false); }\n@@ -540,1 +545,1 @@\n-  \/\/ This returns a non-NULL value iff this nmethod was\n+  \/\/ This returns a non-nullptr value iff this nmethod was\n@@ -543,1 +548,1 @@\n-    return jvmci_data_size() == 0 ? NULL : (JVMCINMethodData*) jvmci_data_begin();\n+    return jvmci_data_size() == 0 ? nullptr : (JVMCINMethodData*) jvmci_data_begin();\n@@ -599,1 +604,1 @@\n-  void post_compiled_method_load_event(JvmtiThreadState* state = NULL);\n+  void post_compiled_method_load_event(JvmtiThreadState* state = nullptr);\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n-  _handles  = NULL;\n-  _indexes  = NULL;\n+  _handles  = nullptr;\n+  _indexes  = nullptr;\n@@ -57,1 +57,1 @@\n-  if (_handles == NULL)  return 0;\n+  if (_handles == nullptr)  return 0;\n@@ -68,2 +68,2 @@\n-  if (_handles == NULL) {\n-    if (_arena != NULL) {\n+  if (_handles == nullptr) {\n+    if (_arena != nullptr) {\n@@ -81,2 +81,2 @@\n-  \/\/ there is always a NULL virtually present as first object\n-  if (index == null_index)  return NULL;\n+  \/\/ there is always a nullptr virtually present as first object\n+  if (index == null_index)  return nullptr;\n@@ -98,1 +98,1 @@\n-    if (_indexes != NULL) {\n+    if (_indexes != nullptr) {\n@@ -101,1 +101,1 @@\n-    } else if (index == index_cache_threshold && _arena != NULL) {\n+    } else if (index == index_cache_threshold && _arena != nullptr) {\n@@ -114,1 +114,1 @@\n-    \/\/ an argument of NULL or Universe::non_oop_word.\n+    \/\/ an argument of nullptr or Universe::non_oop_word.\n@@ -127,1 +127,1 @@\n-  if (h == NULL)  return null_index;\n+  if (h == nullptr)  return null_index;\n@@ -129,2 +129,2 @@\n-  int* cloc = (_indexes == NULL)? NULL: _indexes->cache_location(h);\n-  if (cloc != NULL) {\n+  int* cloc = (_indexes == nullptr)? nullptr: _indexes->cache_location(h);\n+  if (cloc != nullptr) {\n@@ -150,1 +150,1 @@\n-      if (cloc != NULL) {\n+      if (cloc != nullptr) {\n@@ -191,1 +191,1 @@\n-  if (handle == NULL) {\n+  if (handle == nullptr) {\n@@ -211,1 +211,1 @@\n-    _object_lookup = NULL;\n+    _object_lookup = nullptr;\n","filename":"src\/hotspot\/share\/code\/oopRecorder.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  \/\/ Use the given arena to manage storage, if not NULL.\n+  \/\/ Use the given arena to manage storage, if not nullptr.\n@@ -43,1 +43,1 @@\n-  ValueRecorder(Arena* arena = NULL);\n+  ValueRecorder(Arena* arena = nullptr);\n@@ -73,2 +73,2 @@\n-    if (_handles == NULL) return 0;\n-    \/\/ there is always a NULL virtually present as first object\n+    if (_handles == nullptr) return 0;\n+    \/\/ there is always a nullptr virtually present as first object\n@@ -78,1 +78,1 @@\n-  \/\/ Helper function; returns false for NULL or Universe::non_oop_word().\n+  \/\/ Helper function; returns false for nullptr or Universe::non_oop_word().\n@@ -84,1 +84,1 @@\n-  bool is_unused() { return _handles == NULL && !_complete; }\n+  bool is_unused() { return _handles == nullptr && !_complete; }\n@@ -135,1 +135,1 @@\n-  GrowableArray<T>*        _handles;  \/\/ ordered list (first is always NULL)\n+  GrowableArray<T>*        _handles;  \/\/ ordered list (first is always nullptr)\n@@ -157,1 +157,1 @@\n-    ObjectEntry() : _value(NULL), _index(0) {}\n+    ObjectEntry() : _value(nullptr), _index(0) {}\n@@ -184,1 +184,1 @@\n-  OopRecorder(Arena* arena = NULL, bool deduplicate = false);\n+  OopRecorder(Arena* arena = nullptr, bool deduplicate = false);\n@@ -190,1 +190,1 @@\n-    return _object_lookup != NULL ? _object_lookup->find_index(h, this) : _oops.find_index(h);\n+    return _object_lookup != nullptr ? _object_lookup->find_index(h, this) : _oops.find_index(h);\n","filename":"src\/hotspot\/share\/code\/oopRecorder.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-  return h != NULL && h != (T)Universe::non_oop_word();\n+  return h != nullptr && h != (T)Universe::non_oop_word();\n","filename":"src\/hotspot\/share\/code\/oopRecorder.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-       sd != NULL;\n+       sd != nullptr;\n","filename":"src\/hotspot\/share\/code\/pcDesc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,1 +122,1 @@\n-  if (nm == NULL && begin != NULL) {\n+  if (nm == nullptr && begin != nullptr) {\n@@ -125,1 +125,1 @@\n-    nm = (cb != NULL) ? cb->as_compiled_method_or_null() : NULL;\n+    nm = (cb != nullptr) ? cb->as_compiled_method_or_null() : nullptr;\n@@ -127,1 +127,1 @@\n-  guarantee(nm != NULL, \"must be able to deduce nmethod from other arguments\");\n+  guarantee(nm != nullptr, \"must be able to deduce nmethod from other arguments\");\n@@ -144,2 +144,2 @@\n-  assert(begin == NULL || begin >= nm->code_begin(), \"in bounds\");\n-  assert(limit == NULL || limit <= nm->code_end(),   \"in bounds\");\n+  assert(begin == nullptr || begin >= nm->code_begin(), \"in bounds\");\n+  assert(limit == nullptr || limit <= nm->code_end(),   \"in bounds\");\n@@ -156,1 +156,1 @@\n-  _code    = NULL; \/\/ Not cb->blob();\n+  _code    = nullptr; \/\/ Not cb->blob();\n@@ -168,2 +168,2 @@\n-  assert(begin == NULL || begin >= cs->start(), \"in bounds\");\n-  assert(limit == NULL || limit <= cs->end(),   \"in bounds\");\n+  assert(begin == nullptr || begin >= cs->start(), \"in bounds\");\n+  assert(limit == nullptr || limit <= cs->end(),   \"in bounds\");\n@@ -183,1 +183,1 @@\n-  if (begin != NULL) {\n+  if (begin != nullptr) {\n@@ -224,2 +224,2 @@\n-    _section_start[i] = NULL;  \/\/ these will be lazily computed, if needed\n-    _section_end  [i] = NULL;\n+    _section_start[i] = nullptr;  \/\/ these will be lazily computed, if needed\n+    _section_end  [i] = nullptr;\n@@ -307,1 +307,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -364,1 +364,1 @@\n-  for (; src != NULL; src = src->before_expand()) {\n+  for (; src != nullptr; src = src->before_expand()) {\n@@ -376,1 +376,1 @@\n-  if (addr0 == NULL || dest->allocates2(addr0))  return;\n+  if (addr0 == nullptr || dest->allocates2(addr0))  return;\n@@ -439,1 +439,1 @@\n-  _cached_value = x0==0? NULL: address_from_scaled_offset(x0, point);\n+  _cached_value = x0==0? nullptr: address_from_scaled_offset(x0, point);\n@@ -511,1 +511,1 @@\n-  if (sindex == CodeBuffer::SECT_NONE && _target != NULL\n+  if (sindex == CodeBuffer::SECT_NONE && _target != nullptr\n@@ -527,1 +527,1 @@\n-    guarantee(_target == NULL || dest->allocates2(_target), \"must be within the given code section\");\n+    guarantee(_target == nullptr || dest->allocates2(_target), \"must be within the given code section\");\n@@ -529,1 +529,1 @@\n-    assert(!(x0 == 0 && _target != NULL), \"correct encoding of null target\");\n+    assert(!(x0 == 0 && _target != nullptr), \"correct encoding of null target\");\n@@ -532,1 +532,1 @@\n-    assert(_target != NULL, \"sanity\");\n+    assert(_target != nullptr, \"sanity\");\n@@ -548,1 +548,1 @@\n-  _target = x0==0? NULL: address_from_scaled_offset(x0, addr());\n+  _target = x0==0? nullptr: address_from_scaled_offset(x0, addr());\n@@ -579,1 +579,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -616,1 +616,1 @@\n-  if (v == (Metadata*)Universe::non_oop_word())  v = NULL;\n+  if (v == (Metadata*)Universe::non_oop_word())  v = nullptr;\n@@ -629,1 +629,1 @@\n-  assert(_cached_value != NULL && _cached_value < addr(), \"must precede ic_call\");\n+  assert(_cached_value != nullptr && _cached_value < addr(), \"must precede ic_call\");\n@@ -635,1 +635,1 @@\n-  if (cm == NULL) return (Method*)NULL;\n+  if (cm == nullptr) return (Method*)nullptr;\n@@ -637,2 +637,2 @@\n-  assert(m != NULL || _method_index == 0, \"should be non-null for non-zero index\");\n-  assert(m == NULL || m->is_method(), \"not a method\");\n+  assert(m != nullptr || _method_index == 0, \"should be non-null for non-zero index\");\n+  assert(m == nullptr || m->is_method(), \"not a method\");\n@@ -663,1 +663,1 @@\n-  if (cm == NULL) return (Method*)NULL;\n+  if (cm == nullptr) return (Method*)nullptr;\n@@ -665,2 +665,2 @@\n-  assert(m != NULL || _method_index == 0, \"should be non-null for non-zero index\");\n-  assert(m == NULL || m->is_method(), \"not a method\");\n+  assert(m != nullptr || _method_index == 0, \"should be non-null for non-zero index\");\n+  assert(m == nullptr || m->is_method(), \"not a method\");\n@@ -696,1 +696,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -701,1 +701,1 @@\n-  if (cm == NULL) return (Method*)NULL;\n+  if (cm == nullptr) return (Method*)nullptr;\n@@ -703,2 +703,2 @@\n-  assert(m != NULL || _method_index == 0, \"should be non-null for non-zero index\");\n-  assert(m == NULL || m->is_method(), \"not a method\");\n+  assert(m != nullptr || _method_index == 0, \"should be non-null for non-zero index\");\n+  assert(m == nullptr || m->is_method(), \"not a method\");\n@@ -737,1 +737,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -741,1 +741,1 @@\n-\/\/ found NULL is returned which can be handled by the caller.\n+\/\/ found nullptr is returned which can be handled by the caller.\n@@ -746,1 +746,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -757,1 +757,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -769,1 +769,1 @@\n-  if (_target != NULL) {\n+  if (_target != nullptr) {\n@@ -774,1 +774,1 @@\n-  \/\/ If target is NULL, this is  an absolute embedded reference to an external\n+  \/\/ If target is nullptr, this is  an absolute embedded reference to an external\n@@ -784,1 +784,1 @@\n-  if (target == NULL) {\n+  if (target == nullptr) {\n@@ -793,1 +793,1 @@\n-  if (target == NULL) {\n+  if (target == nullptr) {\n@@ -802,1 +802,1 @@\n-  if (target == NULL) {\n+  if (target == nullptr) {\n@@ -859,4 +859,4 @@\n-      oop* oop_addr  = NULL;\n-      oop  raw_oop   = NULL;\n-      oop  oop_value = NULL;\n-      if (code() != NULL || r->oop_is_immediate()) {\n+      oop* oop_addr  = nullptr;\n+      oop  raw_oop   = nullptr;\n+      oop  oop_value = nullptr;\n+      if (code() != nullptr || r->oop_is_immediate()) {\n@@ -871,1 +871,1 @@\n-      if (WizardMode && oop_value != NULL) {\n+      if (WizardMode && oop_value != nullptr) {\n@@ -882,4 +882,4 @@\n-      Metadata** metadata_addr  = NULL;\n-      Metadata*    raw_metadata   = NULL;\n-      Metadata*    metadata_value = NULL;\n-      if (code() != NULL || r->metadata_is_immediate()) {\n+      Metadata** metadata_addr  = nullptr;\n+      Metadata*    raw_metadata   = nullptr;\n+      Metadata*    metadata_value = nullptr;\n+      if (code() != nullptr || r->metadata_is_immediate()) {\n@@ -892,1 +892,1 @@\n-      if (metadata_value != NULL) {\n+      if (metadata_value != nullptr) {\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":53,"deletions":53,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -583,1 +583,1 @@\n-    debug_only(_data = NULL);\n+    debug_only(_data = nullptr);\n@@ -607,2 +607,2 @@\n-  RelocIterator(CompiledMethod* nm, address begin = NULL, address limit = NULL);\n-  RelocIterator(CodeSection* cb, address begin = NULL, address limit = NULL);\n+  RelocIterator(CompiledMethod* nm, address begin = nullptr, address limit = nullptr);\n+  RelocIterator(CodeSection* cb, address begin = nullptr, address limit = nullptr);\n@@ -627,1 +627,1 @@\n-    if (_limit != NULL && _addr >= _limit) {\n+    if (_limit != nullptr && _addr >= _limit) {\n@@ -692,1 +692,1 @@\n-    assert(_binding != NULL, \"must be bound\");\n+    assert(_binding != nullptr, \"must be bound\");\n@@ -696,1 +696,1 @@\n-    assert(_binding == NULL, \"must be unbound\");\n+    assert(_binding == nullptr, \"must be unbound\");\n@@ -698,1 +698,1 @@\n-    assert(_binding != NULL, \"must now be bound\");\n+    assert(_binding != nullptr, \"must now be bound\");\n@@ -701,1 +701,1 @@\n-  explicit Relocation(relocInfo::relocType rtype) : _binding(NULL), _rtype(rtype) { }\n+  explicit Relocation(relocInfo::relocType rtype) : _binding(nullptr), _rtype(rtype) { }\n@@ -791,1 +791,1 @@\n-  address    pd_call_destination     (address orig_addr = NULL);\n+  address    pd_call_destination     (address orig_addr = nullptr);\n@@ -808,1 +808,1 @@\n-    \/\/ Some relocations treat offset=0 as meaning NULL.\n+    \/\/ Some relocations treat offset=0 as meaning nullptr.\n@@ -810,1 +810,1 @@\n-    if (x == NULL)  return 0;\n+    if (x == nullptr)  return 0;\n@@ -1023,1 +1023,1 @@\n-  \/\/ Note:  oop_value transparently converts Universe::non_oop_word to NULL.\n+  \/\/ Note:  oop_value transparently converts Universe::non_oop_word to nullptr.\n@@ -1077,1 +1077,1 @@\n-  \/\/ Note:  metadata_value transparently converts Universe::non_metadata_word to NULL.\n+  \/\/ Note:  metadata_value transparently converts Universe::non_metadata_word to nullptr.\n@@ -1101,1 +1101,1 @@\n-    assert(cached_value != NULL, \"first oop address must be specified\");\n+    assert(cached_value != nullptr, \"first oop address must be specified\");\n@@ -1299,1 +1299,1 @@\n-    assert(target != NULL, \"must not be null\");\n+    assert(target != nullptr, \"must not be null\");\n@@ -1314,2 +1314,2 @@\n-    assert(target == NULL || (uintptr_t)target >= (uintptr_t)OSInfo::vm_page_size(), INTPTR_FORMAT, (intptr_t)target);\n-    return target != NULL;\n+    assert(target == nullptr || (uintptr_t)target >= (uintptr_t)OSInfo::vm_page_size(), INTPTR_FORMAT, (intptr_t)target);\n+    return target != nullptr;\n@@ -1331,1 +1331,1 @@\n-  \/\/ If the \"a\" value is 0 (i.e., _target is NULL), the address is stored\n+  \/\/ If the \"a\" value is 0 (i.e., _target is nullptr), the address is stored\n@@ -1337,1 +1337,1 @@\n-  address  target();        \/\/ if _target==NULL, fetch addr from code stream\n+  address  target();        \/\/ if _target==nullptr, fetch addr from code stream\n@@ -1345,1 +1345,1 @@\n-    assert(target != NULL, \"must not be null\");\n+    assert(target != nullptr, \"must not be null\");\n@@ -1374,1 +1374,1 @@\n-  \/\/ If the \"o\" value is 0 (i.e., _target is NULL), the offset is stored\n+  \/\/ If the \"o\" value is 0 (i.e., _target is nullptr), the offset is stored\n@@ -1381,1 +1381,1 @@\n-  address  target();        \/\/ if _target==NULL, fetch addr from code stream\n+  address  target();        \/\/ if _target==nullptr, fetch addr from code stream\n@@ -1396,1 +1396,1 @@\n-    assert(target != NULL, \"must not be null\");\n+    assert(target != nullptr, \"must not be null\");\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-  if (decode_offset == DebugInformationRecorder::serialized_null) return NULL;\n+  if (decode_offset == DebugInformationRecorder::serialized_null) return nullptr;\n@@ -108,1 +108,1 @@\n-  if (decode_offset == DebugInformationRecorder::serialized_null) return NULL;\n+  if (decode_offset == DebugInformationRecorder::serialized_null) return nullptr;\n@@ -123,1 +123,1 @@\n-  if (decode_offset == DebugInformationRecorder::serialized_null) return NULL;\n+  if (decode_offset == DebugInformationRecorder::serialized_null) return nullptr;\n@@ -158,1 +158,1 @@\n-  if (is_top()) return NULL;\n+  if (is_top()) return nullptr;\n@@ -181,1 +181,1 @@\n-  print_on(st, NULL);\n+  print_on(st, nullptr);\n@@ -186,1 +186,1 @@\n-  if (pd != NULL) {\n+  if (pd != nullptr) {\n@@ -204,1 +204,1 @@\n-    if (l != NULL) {\n+    if (l != nullptr) {\n@@ -215,1 +215,1 @@\n-    if (l != NULL) {\n+    if (l != nullptr) {\n@@ -226,1 +226,1 @@\n-    if (l != NULL) {\n+    if (l != nullptr) {\n@@ -237,1 +237,1 @@\n-  if (NOT_JVMCI(DoEscapeAnalysis &&) is_top() && _objects != NULL) {\n+  if (NOT_JVMCI(DoEscapeAnalysis &&) is_top() && _objects != nullptr) {\n@@ -260,1 +260,1 @@\n-    if (l != NULL) {\n+    if (l != nullptr) {\n","filename":"src\/hotspot\/share\/code\/scopeDesc.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    assert(pc_desc != NULL, \"Must be able to find matching PcDesc\");\n+    assert(pc_desc != nullptr, \"Must be able to find matching PcDesc\");\n@@ -85,1 +85,1 @@\n-  \/\/ Stack walking, returns NULL if this is the outer most scope.\n+  \/\/ Stack walking, returns nullptr if this is the outer most scope.\n@@ -93,1 +93,1 @@\n-  \/\/ Tells whether sender() returns NULL\n+  \/\/ Tells whether sender() returns nullptr\n","filename":"src\/hotspot\/share\/code\/scopeDesc.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-  if( blob == NULL) {\n+  if( blob == nullptr) {\n@@ -102,1 +102,1 @@\n-    for (Stub* s = first(); s != NULL; s = next(s)) {\n+    for (Stub* s = first(); s != nullptr; s = next(s)) {\n@@ -106,1 +106,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -112,1 +112,1 @@\n-  if (s != NULL) commit(code_size);\n+  if (s != nullptr) commit(code_size);\n@@ -125,1 +125,1 @@\n-  if (_mutex != NULL) _mutex->lock_without_safepoint_check();\n+  if (_mutex != nullptr) _mutex->lock_without_safepoint_check();\n@@ -156,2 +156,2 @@\n-  if (_mutex != NULL) _mutex->unlock();\n-  return NULL;\n+  if (_mutex != nullptr) _mutex->unlock();\n+  return nullptr;\n@@ -169,1 +169,1 @@\n-  if (_mutex != NULL) _mutex->unlock();\n+  if (_mutex != nullptr) _mutex->unlock();\n@@ -212,1 +212,1 @@\n-  if (_stub_buffer == NULL) return;\n+  if (_stub_buffer == nullptr) return;\n@@ -230,1 +230,1 @@\n-  for (Stub* s = first(); s != NULL; s = next(s)) {\n+  for (Stub* s = first(); s != nullptr; s = next(s)) {\n@@ -241,1 +241,1 @@\n-  for (Stub* s = first(); s != NULL; s = next(s)) {\n+  for (Stub* s = first(); s != nullptr; s = next(s)) {\n","filename":"src\/hotspot\/share\/code\/stubs.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,2 +71,2 @@\n-  address code_begin() const                     { ShouldNotCallThis(); return NULL; }   \/\/ points to the first byte of    the code\n-  address code_end() const                       { ShouldNotCallThis(); return NULL; }   \/\/ points to the first byte after the code\n+  address code_begin() const                     { ShouldNotCallThis(); return nullptr; }   \/\/ points to the first byte of    the code\n+  address code_end() const                       { ShouldNotCallThis(); return nullptr; }   \/\/ points to the first byte after the code\n@@ -204,1 +204,1 @@\n-  Stub* first() const                            { return number_of_stubs() > 0 ? stub_at(_queue_begin) : NULL; }\n+  Stub* first() const                            { return number_of_stubs() > 0 ? stub_at(_queue_begin) : nullptr; }\n@@ -208,1 +208,1 @@\n-                                                   return (i == _queue_end) ? NULL : stub_at(i);\n+                                                   return (i == _queue_end) ? nullptr : stub_at(i);\n","filename":"src\/hotspot\/share\/code\/stubs.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    assert(VMRegImpl::regName[value()], \"VMRegImpl::regName[\" INTPTR_FORMAT \"] returns NULL\", value());\n+    assert(VMRegImpl::regName[value()], \"VMRegImpl::regName[\" INTPTR_FORMAT \"] returns nullptr\", value());\n","filename":"src\/hotspot\/share\/code\/vmreg.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,2 +50,2 @@\n-address VtableStub::_chunk             = NULL;\n-address VtableStub::_chunk_end         = NULL;\n+address VtableStub::_chunk             = nullptr;\n+address VtableStub::_chunk_end         = nullptr;\n@@ -62,1 +62,1 @@\n-  if (_chunk == NULL || _chunk + real_size > _chunk_end) {\n+  if (_chunk == nullptr || _chunk + real_size > _chunk_end) {\n@@ -68,2 +68,2 @@\n-    if (blob == NULL) {\n-      return NULL;\n+    if (blob == nullptr) {\n+      return nullptr;\n@@ -135,1 +135,1 @@\n-      _table[i] = NULL;\n+      _table[i] = nullptr;\n@@ -219,1 +219,1 @@\n-    if (s == NULL) {\n+    if (s == nullptr) {\n@@ -227,2 +227,2 @@\n-      if (s == NULL) {\n-        return NULL;\n+      if (s == nullptr) {\n+        return nullptr;\n@@ -282,2 +282,2 @@\n-  for (s = _table[hash]; s != NULL && s != stub; s = s->next()) {}\n-  return (s == stub) ? s : NULL;\n+  for (s = _table[hash]; s != nullptr && s != stub; s = s->next()) {}\n+  return (s == stub) ? s : nullptr;\n@@ -289,1 +289,1 @@\n-  return stub_containing(pc) != NULL;\n+  return stub_containing(pc) != nullptr;\n@@ -298,1 +298,1 @@\n-    for (VtableStub* s = _table[i]; s != NULL; s = s->next()) {\n+    for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n@@ -302,1 +302,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -311,1 +311,1 @@\n-        for (VtableStub* s = _table[i]; s != NULL; s = s->next()) {\n+        for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-  static VtableStub* stub_containing(address pc);                    \/\/ stub containing pc or NULL\n+  static VtableStub* stub_containing(address pc);                    \/\/ stub containing pc or nullptr\n@@ -134,1 +134,1 @@\n-        : _next(NULL), _index(index), _ame_offset(-1), _npe_offset(-1),\n+        : _next(nullptr), _index(index), _ame_offset(-1), _npe_offset(-1),\n","filename":"src\/hotspot\/share\/code\/vtableStubs.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -314,1 +314,1 @@\n-  assert(st != NULL, \"need an output stream (no default)!\");\n+  assert(st != nullptr, \"need an output stream (no default)!\");\n@@ -318,1 +318,1 @@\n-  while ((pos != NULL) && (pos < range_end)) {\n+  while ((pos != nullptr) && (pos < range_end)) {\n@@ -352,1 +352,1 @@\n-  outputStream* st = (ost == NULL) ? tty : ost;\n+  outputStream* st = (ost == nullptr) ? tty : ost;\n","filename":"src\/hotspot\/share\/compiler\/abstractDisassembler.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-  task->print(&sstr, NULL, true, false);\n+  task->print(&sstr, nullptr, true, false);\n@@ -56,1 +56,1 @@\n-  if (retry_message != NULL) {\n+  if (retry_message != nullptr) {\n","filename":"src\/hotspot\/share\/compiler\/compilationLog.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,1 +164,1 @@\n-  for (CompileTask* task = compile_queue->first(); task != NULL; ) {\n+  for (CompileTask* task = compile_queue->first(); task != nullptr; ) {\n@@ -180,1 +180,1 @@\n-    for (CompileTask* task = compile_queue->first(); task != NULL; task = task->next()) {\n+    for (CompileTask* task = compile_queue->first(); task != nullptr; task = task->next()) {\n@@ -205,1 +205,1 @@\n-      if (comp != NULL && comp->is_jvmci() && ((JVMCICompiler*) comp)->force_comp_at_level_simple(method)) {\n+      if (comp != nullptr && comp->is_jvmci() && ((JVMCICompiler*) comp)->force_comp_at_level_simple(method)) {\n@@ -216,1 +216,1 @@\n-  if (nm != NULL && nm->is_in_use()) {\n+  if (nm != nullptr && nm->is_in_use()) {\n@@ -332,1 +332,1 @@\n-  if (mdh != NULL) {\n+  if (mdh != nullptr) {\n@@ -609,1 +609,1 @@\n-  if (mcs != NULL) {\n+  if (mcs != nullptr) {\n@@ -614,1 +614,1 @@\n-  if (mdo != NULL) {\n+  if (mdo != nullptr) {\n@@ -622,3 +622,3 @@\n-  CompileTask *max_blocking_task = NULL;\n-  CompileTask *max_task = NULL;\n-  Method* max_method = NULL;\n+  CompileTask *max_blocking_task = nullptr;\n+  CompileTask *max_task = nullptr;\n+  Method* max_method = nullptr;\n@@ -628,1 +628,1 @@\n-  for (CompileTask* task = compile_queue->first(); task != NULL;) {\n+  for (CompileTask* task = compile_queue->first(); task != nullptr;) {\n@@ -649,1 +649,1 @@\n-    if (max_task == NULL || compare_methods(method, max_method)) {\n+    if (max_task == nullptr || compare_methods(method, max_method)) {\n@@ -656,1 +656,1 @@\n-      if (max_blocking_task == NULL || compare_methods(method, max_blocking_task->method())) {\n+      if (max_blocking_task == nullptr || compare_methods(method, max_blocking_task->method())) {\n@@ -664,1 +664,1 @@\n-  if (max_blocking_task != NULL) {\n+  if (max_blocking_task != nullptr) {\n@@ -676,2 +676,2 @@\n-  if (max_task != NULL && max_task->comp_level() == CompLevel_full_profile && TieredStopAtLevel > CompLevel_full_profile &&\n-      max_method != NULL && is_method_profiled(max_method_h) && !Arguments::is_compiler_only()) {\n+  if (max_task != nullptr && max_task->comp_level() == CompLevel_full_profile && TieredStopAtLevel > CompLevel_full_profile &&\n+      max_method != nullptr && is_method_profiled(max_method_h) && !Arguments::is_compiler_only()) {\n@@ -686,1 +686,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -703,1 +703,1 @@\n-    if (mdo != NULL) {\n+    if (mdo != nullptr) {\n@@ -719,1 +719,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -723,1 +723,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -745,2 +745,2 @@\n-      assert(osr_nm == NULL || osr_nm->comp_level() >= expected_comp_level, \"lookup_osr_nmethod_for is broken\");\n-      if (osr_nm != NULL && osr_nm->comp_level() != comp_level) {\n+      assert(osr_nm == nullptr || osr_nm->comp_level() >= expected_comp_level, \"lookup_osr_nmethod_for is broken\");\n+      if (osr_nm != nullptr && osr_nm->comp_level() != comp_level) {\n@@ -752,1 +752,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -793,1 +793,1 @@\n-        if (osr_nm != NULL && osr_nm->comp_level() > CompLevel_simple) {\n+        if (osr_nm != nullptr && osr_nm->comp_level() > CompLevel_simple) {\n@@ -819,1 +819,1 @@\n-  if (method->method_counters() == NULL)  return;\n+  if (method->method_counters() == nullptr)  return;\n@@ -897,1 +897,1 @@\n-  if (mdo != NULL) {\n+  if (mdo != nullptr) {\n@@ -914,1 +914,1 @@\n-  if (mdo != NULL) {\n+  if (mdo != nullptr) {\n@@ -963,1 +963,1 @@\n-  if (mh->method_data() == NULL) {\n+  if (mh->method_data() == nullptr) {\n@@ -968,1 +968,1 @@\n-    if (mdo != NULL) {\n+    if (mdo != nullptr) {\n@@ -1060,1 +1060,1 @@\n-          if (mdo != NULL) {\n+          if (mdo != nullptr) {\n@@ -1083,1 +1083,1 @@\n-          if (mdo != NULL) {\n+          if (mdo != nullptr) {\n@@ -1114,1 +1114,1 @@\n-    guarantee(mdo != NULL, \"MDO should not be NULL\");\n+    guarantee(mdo != nullptr, \"MDO should not be nullptr\");\n@@ -1177,1 +1177,1 @@\n-        guarantee(nm != NULL, \"Should have nmethod here\");\n+        guarantee(nm != nullptr, \"Should have nmethod here\");\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -269,1 +269,1 @@\n-  \/\/ Select task is called by CompileBroker. We should return a task or NULL.\n+  \/\/ Select task is called by CompileBroker. We should return a task or nullptr.\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,2 +135,2 @@\n-jobject* CompileBroker::_compiler1_objects = NULL;\n-jobject* CompileBroker::_compiler2_objects = NULL;\n+jobject* CompileBroker::_compiler1_objects = nullptr;\n+jobject* CompileBroker::_compiler2_objects = nullptr;\n@@ -138,2 +138,2 @@\n-CompileLog** CompileBroker::_compiler1_logs = NULL;\n-CompileLog** CompileBroker::_compiler2_logs = NULL;\n+CompileLog** CompileBroker::_compiler1_logs = nullptr;\n+CompileLog** CompileBroker::_compiler2_logs = nullptr;\n@@ -147,22 +147,22 @@\n-PerfCounter* CompileBroker::_perf_total_compilation = NULL;\n-PerfCounter* CompileBroker::_perf_osr_compilation = NULL;\n-PerfCounter* CompileBroker::_perf_standard_compilation = NULL;\n-\n-PerfCounter* CompileBroker::_perf_total_bailout_count = NULL;\n-PerfCounter* CompileBroker::_perf_total_invalidated_count = NULL;\n-PerfCounter* CompileBroker::_perf_total_compile_count = NULL;\n-PerfCounter* CompileBroker::_perf_total_osr_compile_count = NULL;\n-PerfCounter* CompileBroker::_perf_total_standard_compile_count = NULL;\n-\n-PerfCounter* CompileBroker::_perf_sum_osr_bytes_compiled = NULL;\n-PerfCounter* CompileBroker::_perf_sum_standard_bytes_compiled = NULL;\n-PerfCounter* CompileBroker::_perf_sum_nmethod_size = NULL;\n-PerfCounter* CompileBroker::_perf_sum_nmethod_code_size = NULL;\n-\n-PerfStringVariable* CompileBroker::_perf_last_method = NULL;\n-PerfStringVariable* CompileBroker::_perf_last_failed_method = NULL;\n-PerfStringVariable* CompileBroker::_perf_last_invalidated_method = NULL;\n-PerfVariable*       CompileBroker::_perf_last_compile_type = NULL;\n-PerfVariable*       CompileBroker::_perf_last_compile_size = NULL;\n-PerfVariable*       CompileBroker::_perf_last_failed_type = NULL;\n-PerfVariable*       CompileBroker::_perf_last_invalidated_type = NULL;\n+PerfCounter* CompileBroker::_perf_total_compilation = nullptr;\n+PerfCounter* CompileBroker::_perf_osr_compilation = nullptr;\n+PerfCounter* CompileBroker::_perf_standard_compilation = nullptr;\n+\n+PerfCounter* CompileBroker::_perf_total_bailout_count = nullptr;\n+PerfCounter* CompileBroker::_perf_total_invalidated_count = nullptr;\n+PerfCounter* CompileBroker::_perf_total_compile_count = nullptr;\n+PerfCounter* CompileBroker::_perf_total_osr_compile_count = nullptr;\n+PerfCounter* CompileBroker::_perf_total_standard_compile_count = nullptr;\n+\n+PerfCounter* CompileBroker::_perf_sum_osr_bytes_compiled = nullptr;\n+PerfCounter* CompileBroker::_perf_sum_standard_bytes_compiled = nullptr;\n+PerfCounter* CompileBroker::_perf_sum_nmethod_size = nullptr;\n+PerfCounter* CompileBroker::_perf_sum_nmethod_code_size = nullptr;\n+\n+PerfStringVariable* CompileBroker::_perf_last_method = nullptr;\n+PerfStringVariable* CompileBroker::_perf_last_failed_method = nullptr;\n+PerfStringVariable* CompileBroker::_perf_last_invalidated_method = nullptr;\n+PerfVariable*       CompileBroker::_perf_last_compile_type = nullptr;\n+PerfVariable*       CompileBroker::_perf_last_compile_size = nullptr;\n+PerfVariable*       CompileBroker::_perf_last_failed_type = nullptr;\n+PerfVariable*       CompileBroker::_perf_last_invalidated_type = nullptr;\n@@ -194,2 +194,2 @@\n-CompileQueue* CompileBroker::_c2_compile_queue     = NULL;\n-CompileQueue* CompileBroker::_c1_compile_queue     = NULL;\n+CompileQueue* CompileBroker::_c2_compile_queue     = nullptr;\n+CompileQueue* CompileBroker::_c1_compile_queue     = nullptr;\n@@ -219,1 +219,1 @@\n-  if (log != NULL && !task->is_unloaded())  task->log_task_start(log);\n+  if (log != nullptr && !task->is_unloaded())  task->log_task_start(log);\n@@ -226,3 +226,3 @@\n-  if (log != NULL && !task->is_unloaded())  task->log_task_done(log);\n-  thread->set_task(NULL);\n-  thread->set_env(NULL);\n+  if (log != nullptr && !task->is_unloaded())  task->log_task_done(log);\n+  thread->set_task(nullptr);\n+  thread->set_env(nullptr);\n@@ -240,1 +240,1 @@\n-        task->set_blocking_jvmci_compile_state(NULL);\n+        task->set_blocking_jvmci_compile_state(nullptr);\n@@ -302,1 +302,1 @@\n-        _compiler2_objects[compiler_count - 1] = NULL;\n+        _compiler2_objects[compiler_count - 1] = nullptr;\n@@ -317,2 +317,2 @@\n-  task->set_next(NULL);\n-  task->set_prev(NULL);\n+  task->set_next(nullptr);\n+  task->set_prev(nullptr);\n@@ -320,1 +320,1 @@\n-  if (_last == NULL) {\n+  if (_last == nullptr) {\n@@ -322,1 +322,1 @@\n-    assert(_first == NULL, \"queue is empty\");\n+    assert(_first == nullptr, \"queue is empty\");\n@@ -327,1 +327,1 @@\n-    assert(_last->next() == NULL, \"not last\");\n+    assert(_last->next() == nullptr, \"not last\");\n@@ -341,1 +341,1 @@\n-  if (LogCompilation && xtty != NULL) {\n+  if (LogCompilation && xtty != nullptr) {\n@@ -360,1 +360,1 @@\n-  while (next != NULL) {\n+  while (next != nullptr) {\n@@ -371,2 +371,2 @@\n-  _first = NULL;\n-  _last = NULL;\n+  _first = nullptr;\n+  _last = nullptr;\n@@ -388,1 +388,1 @@\n-  \/\/ If _first is NULL we have no more compile jobs. There are two reasons for\n+  \/\/ If _first is nullptr we have no more compile jobs. There are two reasons for\n@@ -393,1 +393,1 @@\n-  while (_first == NULL) {\n+  while (_first == nullptr) {\n@@ -396,1 +396,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -416,1 +416,1 @@\n-    if (UseDynamicNumberOfCompilerThreads && _first == NULL) {\n+    if (UseDynamicNumberOfCompilerThreads && _first == nullptr) {\n@@ -418,1 +418,1 @@\n-      if (CompileBroker::can_remove(CompilerThread::current(), false)) return NULL;\n+      if (CompileBroker::can_remove(CompilerThread::current(), false)) return nullptr;\n@@ -423,1 +423,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -430,1 +430,1 @@\n-    if (task != NULL) {\n+    if (task != nullptr) {\n@@ -435,1 +435,1 @@\n-  if (task != NULL) {\n+  if (task != nullptr) {\n@@ -452,1 +452,1 @@\n-  if (_first_stale != NULL) {\n+  if (_first_stale != nullptr) {\n@@ -458,1 +458,1 @@\n-    _first_stale = NULL;\n+    _first_stale = nullptr;\n@@ -461,1 +461,1 @@\n-      for (CompileTask* task = head; task != NULL; ) {\n+      for (CompileTask* task = head; task != nullptr; ) {\n@@ -473,1 +473,1 @@\n-  if (task->prev() != NULL) {\n+  if (task->prev() != nullptr) {\n@@ -481,1 +481,1 @@\n-  if (task->next() != NULL) {\n+  if (task->next() != nullptr) {\n@@ -497,1 +497,1 @@\n-  task->set_prev(NULL);\n+  task->set_prev(nullptr);\n@@ -505,1 +505,1 @@\n-  while (task != NULL) {\n+  while (task != nullptr) {\n@@ -515,1 +515,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -526,1 +526,1 @@\n-  if (_c1_compile_queue != NULL) {\n+  if (_c1_compile_queue != nullptr) {\n@@ -529,1 +529,1 @@\n-  if (_c2_compile_queue != NULL) {\n+  if (_c2_compile_queue != nullptr) {\n@@ -538,1 +538,1 @@\n-  if (task == NULL) {\n+  if (task == nullptr) {\n@@ -541,2 +541,2 @@\n-    while (task != NULL) {\n-      task->print(st, NULL, true, true);\n+    while (task != nullptr) {\n+      task->print(st, nullptr, true, true);\n@@ -835,1 +835,1 @@\n-  JavaThread* new_thread = NULL;\n+  JavaThread* new_thread = nullptr;\n@@ -839,1 +839,1 @@\n-      assert(comp != NULL, \"Compiler instance missing.\");\n+      assert(comp != nullptr, \"Compiler instance missing.\");\n@@ -864,1 +864,1 @@\n-  if (new_thread != NULL && new_thread->osthread() != NULL) {\n+  if (new_thread != nullptr && new_thread->osthread() != nullptr) {\n@@ -895,1 +895,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -930,1 +930,1 @@\n-    jobject thread_handle = NULL;\n+    jobject thread_handle = nullptr;\n@@ -940,1 +940,1 @@\n-    _compiler2_logs[i] = NULL;\n+    _compiler2_logs[i] = nullptr;\n@@ -944,1 +944,1 @@\n-      assert(ct != NULL, \"should have been handled for initial thread\");\n+      assert(ct != nullptr, \"should have been handled for initial thread\");\n@@ -961,1 +961,1 @@\n-    _compiler1_logs[i] = NULL;\n+    _compiler1_logs[i] = nullptr;\n@@ -965,1 +965,1 @@\n-      assert(ct != NULL, \"should have been handled for initial thread\");\n+      assert(ct != nullptr, \"should have been handled for initial thread\");\n@@ -987,1 +987,1 @@\n-      make_thread(deoptimizer_t, thread_handle, NULL, NULL, THREAD);\n+      make_thread(deoptimizer_t, thread_handle, nullptr, nullptr, THREAD);\n@@ -1003,1 +1003,1 @@\n-  if (_c2_compile_queue != NULL) {\n+  if (_c2_compile_queue != nullptr) {\n@@ -1040,1 +1040,1 @@\n-        assert(compiler2_object(i) == NULL, \"Old one must be released!\");\n+        assert(compiler2_object(i) == nullptr, \"Old one must be released!\");\n@@ -1045,1 +1045,1 @@\n-      if (ct == NULL) break;\n+      if (ct == nullptr) break;\n@@ -1057,1 +1057,1 @@\n-  if (_c1_compile_queue != NULL) {\n+  if (_c1_compile_queue != nullptr) {\n@@ -1066,1 +1066,1 @@\n-      if (ct == NULL) break;\n+      if (ct == nullptr) break;\n@@ -1090,1 +1090,1 @@\n-  if (_c2_compile_queue != NULL) {\n+  if (_c2_compile_queue != nullptr) {\n@@ -1093,1 +1093,1 @@\n-  if (_c1_compile_queue != NULL) {\n+  if (_c1_compile_queue != nullptr) {\n@@ -1170,1 +1170,1 @@\n-  CompileTask* task     = NULL;\n+  CompileTask* task     = nullptr;\n@@ -1292,1 +1292,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1296,1 +1296,1 @@\n-  assert(comp != NULL, \"Ensure we have a compiler\");\n+  assert(comp != nullptr, \"Ensure we have a compiler\");\n@@ -1322,2 +1322,2 @@\n-  if (comp == NULL || compilation_is_prohibited(method, osr_bci, comp_level, directive->ExcludeOption)) {\n-    return NULL;\n+  if (comp == nullptr || compilation_is_prohibited(method, osr_bci, comp_level, directive->ExcludeOption)) {\n+    return nullptr;\n@@ -1328,1 +1328,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1335,1 +1335,1 @@\n-    if (method_code != NULL && method_code->is_nmethod()) {\n+    if (method_code != nullptr && method_code->is_nmethod()) {\n@@ -1341,1 +1341,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1347,2 +1347,2 @@\n-    if (nm != NULL) return nm;\n-    if (method->is_not_osr_compilable(comp_level)) return NULL;\n+    if (nm != nullptr) return nm;\n+    if (method->is_not_osr_compilable(comp_level)) return nullptr;\n@@ -1373,1 +1373,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1380,1 +1380,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1412,1 +1412,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1423,1 +1423,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1429,1 +1429,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1439,1 +1439,1 @@\n-    if (code == NULL) {\n+    if (code == nullptr) {\n@@ -1462,1 +1462,1 @@\n-      return (result != NULL);\n+      return (result != nullptr);\n@@ -1469,1 +1469,1 @@\n-      if (result == NULL) return false;\n+      if (result == nullptr) return false;\n@@ -1498,1 +1498,1 @@\n-  if (is_native && (!CICompileNatives || comp == NULL)) {\n+  if (is_native && (!CICompileNatives || comp == nullptr)) {\n@@ -1505,1 +1505,1 @@\n-  if (is_osr && (!CICompileOSR || comp == NULL)) {\n+  if (is_osr && (!CICompileOSR || comp == nullptr)) {\n@@ -1625,1 +1625,1 @@\n-    if (jvmci_compile_state != NULL) {\n+    if (jvmci_compile_state != nullptr) {\n@@ -1715,1 +1715,1 @@\n-  guarantee(comp != NULL, \"Compiler object must exist\");\n+  guarantee(comp != nullptr, \"Compiler object must exist\");\n@@ -1720,1 +1720,1 @@\n-    ciEnv ci_env((CompileTask*)NULL);\n+    ciEnv ci_env((CompileTask*)nullptr);\n@@ -1742,1 +1742,1 @@\n-  if (comp->is_c1() && (thread->get_buffer_blob() == NULL)) {\n+  if (comp->is_c1() && (thread->get_buffer_blob() == nullptr)) {\n@@ -1757,1 +1757,1 @@\n-  if (thread->get_buffer_blob() != NULL) {\n+  if (thread->get_buffer_blob() != nullptr) {\n@@ -1773,1 +1773,1 @@\n-    if (_c1_compile_queue != NULL) {\n+    if (_c1_compile_queue != nullptr) {\n@@ -1777,1 +1777,1 @@\n-    if (_c2_compile_queue != NULL) {\n+    if (_c2_compile_queue != nullptr) {\n@@ -1795,1 +1795,1 @@\n-  if (!LogCompilation) return NULL;\n+  if (!LogCompilation) return nullptr;\n@@ -1800,1 +1800,1 @@\n-  assert(compiler_objects != NULL, \"must be initialized at this point\");\n+  assert(compiler_objects != nullptr, \"must be initialized at this point\");\n@@ -1802,1 +1802,1 @@\n-  assert(logs != NULL, \"must be initialized at this point\");\n+  assert(logs != nullptr, \"must be initialized at this point\");\n@@ -1822,1 +1822,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -1857,1 +1857,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -1883,1 +1883,1 @@\n-    if (task == NULL) {\n+    if (task == nullptr) {\n@@ -1897,1 +1897,1 @@\n-          if (thread->get_buffer_blob() != NULL) {\n+          if (thread->get_buffer_blob() != nullptr) {\n@@ -1945,1 +1945,1 @@\n-    FILE* fp = NULL;\n+    FILE* fp = nullptr;\n@@ -1948,2 +1948,2 @@\n-      const char* dir = (try_temp_dir ? os::get_temp_directory() : NULL);\n-      if (dir == NULL) {\n+      const char* dir = (try_temp_dir ? os::get_temp_directory() : nullptr);\n+      if (dir == nullptr) {\n@@ -1959,1 +1959,1 @@\n-      if (fp != NULL) {\n+      if (fp != nullptr) {\n@@ -1964,1 +1964,1 @@\n-        if (log == NULL) {\n+        if (log == nullptr) {\n@@ -1970,1 +1970,1 @@\n-        if (xtty != NULL) {\n+        if (xtty != nullptr) {\n@@ -1984,1 +1984,1 @@\n-  if (CompilationLog::log() != NULL) {\n+  if (CompilationLog::log() != nullptr) {\n@@ -2048,1 +2048,1 @@\n-    if (eol == NULL) {\n+    if (eol == nullptr) {\n@@ -2073,1 +2073,1 @@\n-  assert(task != NULL, \"invariant\");\n+  assert(task != nullptr, \"invariant\");\n@@ -2086,2 +2086,2 @@\n-CompilerDirectives* DirectivesStack::_top = NULL;\n-CompilerDirectives* DirectivesStack::_bottom = NULL;\n+CompilerDirectives* DirectivesStack::_top = nullptr;\n+CompilerDirectives* DirectivesStack::_bottom = nullptr;\n@@ -2107,1 +2107,1 @@\n-  if (CompilationLog::log() != NULL) {\n+  if (CompilationLog::log() != nullptr) {\n@@ -2115,1 +2115,1 @@\n-  bool should_log = (thread->log() != NULL);\n+  bool should_log = (thread->log() != nullptr);\n@@ -2145,1 +2145,1 @@\n-  const char* failure_reason = NULL;\n+  const char* failure_reason = nullptr;\n@@ -2147,1 +2147,1 @@\n-  const char* retry_message = NULL;\n+  const char* retry_message = nullptr;\n@@ -2150,1 +2150,1 @@\n-  if (UseJVMCICompiler && comp != NULL && comp->is_jvmci()) {\n+  if (UseJVMCICompiler && comp != nullptr && comp->is_jvmci()) {\n@@ -2156,1 +2156,1 @@\n-    JVMCIRuntime *runtime = NULL;\n+    JVMCIRuntime *runtime = nullptr;\n@@ -2182,1 +2182,1 @@\n-          assert(failure_reason != NULL, \"must specify failure_reason\");\n+          assert(failure_reason != nullptr, \"must specify failure_reason\");\n@@ -2187,1 +2187,1 @@\n-      handle_compile_error(thread, task, NULL, compilable, failure_reason);\n+      handle_compile_error(thread, task, nullptr, compilable, failure_reason);\n@@ -2228,1 +2228,1 @@\n-    if (comp == NULL) {\n+    if (comp == nullptr) {\n@@ -2275,1 +2275,1 @@\n-  if (failure_reason != NULL) {\n+  if (failure_reason != nullptr) {\n@@ -2277,1 +2277,1 @@\n-    if (CompilationLog::log() != NULL) {\n+    if (CompilationLog::log() != nullptr) {\n@@ -2281,1 +2281,1 @@\n-      FormatBufferResource msg = retry_message != NULL ?\n+      FormatBufferResource msg = retry_message != nullptr ?\n@@ -2347,1 +2347,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n@@ -2561,1 +2561,1 @@\n-  if (comp == NULL) {\n+  if (comp == nullptr) {\n@@ -2569,1 +2569,1 @@\n-  return _perf_total_compilation != NULL ? _perf_total_compilation->get_value() : 0;\n+  return _perf_total_compilation != nullptr ? _perf_total_compilation->get_value() : 0;\n@@ -2590,1 +2590,1 @@\n-      if (comp != NULL) {\n+      if (comp != nullptr) {\n@@ -2648,1 +2648,1 @@\n-  if (comp != NULL) {\n+  if (comp != nullptr) {\n@@ -2653,1 +2653,1 @@\n-  if (comp != NULL) {\n+  if (comp != nullptr) {\n@@ -2685,1 +2685,1 @@\n-  if (out == NULL) out = tty;\n+  if (out == nullptr) out = tty;\n@@ -2723,1 +2723,1 @@\n-  if (out == NULL) {\n+  if (out == nullptr) {\n@@ -2769,4 +2769,4 @@\n-  Mutex*   global_lock_1   = allFun ? (should_take_Compile_lock   ? Compile_lock   : NULL) : NULL;\n-  Monitor* global_lock_2   = allFun ? (should_take_CodeCache_lock ? CodeCache_lock : NULL) : NULL;\n-  Mutex*   function_lock_1 = allFun ? NULL : (should_take_Compile_lock   ? Compile_lock    : NULL);\n-  Monitor* function_lock_2 = allFun ? NULL : (should_take_CodeCache_lock ? CodeCache_lock  : NULL);\n+  Mutex*   global_lock_1   = allFun ? (should_take_Compile_lock   ? Compile_lock   : nullptr) : nullptr;\n+  Monitor* global_lock_2   = allFun ? (should_take_CodeCache_lock ? CodeCache_lock : nullptr) : nullptr;\n+  Mutex*   function_lock_1 = allFun ? nullptr : (should_take_Compile_lock   ? Compile_lock    : nullptr);\n+  Monitor* function_lock_2 = allFun ? nullptr : (should_take_CodeCache_lock ? CodeCache_lock  : nullptr);\n@@ -2776,1 +2776,1 @@\n-  if ((global_lock_1 != NULL) || (global_lock_2 != NULL)) {\n+  if ((global_lock_1 != nullptr) || (global_lock_2 != nullptr)) {\n@@ -2785,1 +2785,1 @@\n-    if ((function_lock_1 != NULL) || (function_lock_1 != NULL)) {\n+    if ((function_lock_1 != nullptr) || (function_lock_1 != nullptr)) {\n@@ -2791,1 +2791,1 @@\n-    if ((function_lock_1 != NULL) || (function_lock_1 != NULL)) {\n+    if ((function_lock_1 != nullptr) || (function_lock_1 != nullptr)) {\n@@ -2812,1 +2812,1 @@\n-  if ((global_lock_1 != NULL) || (global_lock_2 != NULL)) {\n+  if ((global_lock_1 != nullptr) || (global_lock_2 != nullptr)) {\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":155,"deletions":155,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,2 +96,2 @@\n-    _first = NULL;\n-    _last = NULL;\n+    _first = nullptr;\n+    _last = nullptr;\n@@ -99,1 +99,1 @@\n-    _first_stale = NULL;\n+    _first_stale = nullptr;\n@@ -112,1 +112,1 @@\n-  bool         is_empty() const                  { return _first == NULL; }\n+  bool         is_empty() const                  { return _first == nullptr; }\n@@ -284,1 +284,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -292,1 +292,1 @@\n-    return q != NULL ? q->size() : 0;\n+    return q != nullptr ? q->size() : 0;\n@@ -382,1 +382,1 @@\n-    assert(_compiler1_objects != NULL, \"must be initialized\");\n+    assert(_compiler1_objects != nullptr, \"must be initialized\");\n@@ -388,1 +388,1 @@\n-    assert(_compiler2_objects != NULL, \"must be initialized\");\n+    assert(_compiler2_objects != nullptr, \"must be initialized\");\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-CompileLog* CompileLog::_first = NULL;\n+CompileLog* CompileLog::_first = nullptr;\n@@ -61,1 +61,1 @@\n-  _out = NULL;\n+  _out = nullptr;\n@@ -72,1 +72,1 @@\n-  if (_context.size() > 0 && _out != NULL) {\n+  if (_context.size() > 0 && _out != nullptr) {\n@@ -87,1 +87,1 @@\n-  if (obj == NULL)  return 0;\n+  if (obj == nullptr)  return 0;\n@@ -172,1 +172,1 @@\n-  if (name == NULL)  return;\n+  if (name == nullptr)  return;\n@@ -207,1 +207,1 @@\n-  while (log != NULL) {\n+  while (log != nullptr) {\n@@ -294,1 +294,1 @@\n-  _first = NULL;\n+  _first = nullptr;\n","filename":"src\/hotspot\/share\/compiler\/compileLog.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-CompileTask*  CompileTask::_task_free_list = NULL;\n+CompileTask*  CompileTask::_task_free_list = nullptr;\n@@ -46,1 +46,1 @@\n-  CompileTask* task = NULL;\n+  CompileTask* task = nullptr;\n@@ -48,1 +48,1 @@\n-  if (_task_free_list != NULL) {\n+  if (_task_free_list != nullptr) {\n@@ -51,1 +51,1 @@\n-    task->set_next(NULL);\n+    task->set_next(nullptr);\n@@ -54,1 +54,1 @@\n-    task->set_next(NULL);\n+    task->set_next(nullptr);\n@@ -69,2 +69,2 @@\n-    if ((task->_method_holder != NULL && JNIHandles::is_weak_global_handle(task->_method_holder)) ||\n-        (task->_hot_method_holder != NULL && JNIHandles::is_weak_global_handle(task->_hot_method_holder))) {\n+    if ((task->_method_holder != nullptr && JNIHandles::is_weak_global_handle(task->_method_holder)) ||\n+        (task->_hot_method_holder != nullptr && JNIHandles::is_weak_global_handle(task->_hot_method_holder))) {\n@@ -77,1 +77,1 @@\n-    if (task->_failure_reason_on_C_heap && task->_failure_reason != NULL) {\n+    if (task->_failure_reason_on_C_heap && task->_failure_reason != nullptr) {\n@@ -80,1 +80,1 @@\n-    task->_failure_reason = NULL;\n+    task->_failure_reason = nullptr;\n@@ -106,1 +106,1 @@\n-  JVMCI_ONLY(_blocking_jvmci_compile_state = NULL;)\n+  JVMCI_ONLY(_blocking_jvmci_compile_state = nullptr;)\n@@ -113,2 +113,2 @@\n-  _hot_method = NULL;\n-  _hot_method_holder = NULL;\n+  _hot_method = nullptr;\n+  _hot_method_holder = nullptr;\n@@ -124,1 +124,1 @@\n-  _failure_reason = NULL;\n+  _failure_reason = nullptr;\n@@ -139,1 +139,1 @@\n-  _next = NULL;\n+  _next = nullptr;\n@@ -153,1 +153,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -161,1 +161,1 @@\n-  if (_hot_method != NULL) {\n+  if (_hot_method != nullptr) {\n@@ -173,1 +173,1 @@\n-  if (_hot_method != NULL) {\n+  if (_hot_method != nullptr) {\n@@ -179,1 +179,1 @@\n-  return _method_holder != NULL && JNIHandles::is_weak_global_handle(_method_holder) && JNIHandles::is_global_weak_cleared(_method_holder);\n+  return _method_holder != nullptr && JNIHandles::is_weak_global_handle(_method_holder) && JNIHandles::is_weak_global_cleared(_method_holder);\n@@ -188,1 +188,1 @@\n-  if (hot_method() != NULL && hot_method() != method()) {\n+  if (hot_method() != nullptr && hot_method() != method()) {\n@@ -247,1 +247,1 @@\n-  if (method != NULL) {\n+  if (method != nullptr) {\n@@ -268,1 +268,1 @@\n-  if (method == NULL) {\n+  if (method == nullptr) {\n@@ -281,1 +281,1 @@\n-  if (msg != NULL) {\n+  if (msg != nullptr) {\n@@ -308,1 +308,1 @@\n-  print_impl(st, is_unloaded() ? NULL : method(), compile_id(), comp_level(), is_osr_method, osr_bci(), is_blocking(), msg, short_form, cr, _time_queued, _time_started);\n+  print_impl(st, is_unloaded() ? nullptr : method(), compile_id(), comp_level(), is_osr_method, osr_bci(), is_blocking(), msg, short_form, cr, _time_queued, _time_started);\n@@ -347,1 +347,1 @@\n-  if (_hot_method != NULL && _hot_method != _method) {\n+  if (_hot_method != nullptr && _hot_method != _method) {\n@@ -374,2 +374,2 @@\n-    assert(_failure_reason != NULL, \"missing\");\n-    const char* reason = _failure_reason != NULL ? _failure_reason : \"unknown\";\n+    assert(_failure_reason != nullptr, \"missing\");\n+    const char* reason = _failure_reason != nullptr ? _failure_reason : \"unknown\";\n@@ -449,1 +449,1 @@\n-  if (msg != NULL) {\n+  if (msg != nullptr) {\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-  CompileTask() : _failure_reason(NULL), _failure_reason_on_C_heap(false) {\n+  CompileTask() : _failure_reason(nullptr), _failure_reason_on_C_heap(false) {\n@@ -198,1 +198,1 @@\n-                                      const char* msg = NULL, bool short_form = false, bool cr = true,\n+                                      const char* msg = nullptr, bool short_form = false, bool cr = true,\n@@ -202,3 +202,3 @@\n-  void         print(outputStream* st = tty, const char* msg = NULL, bool short_form = false, bool cr = true);\n-  void         print_ul(const char* msg = NULL);\n-  static void  print(outputStream* st, const nmethod* nm, const char* msg = NULL, bool short_form = false, bool cr = true) {\n+  void         print(outputStream* st = tty, const char* msg = nullptr, bool short_form = false, bool cr = true);\n+  void         print_ul(const char* msg = nullptr);\n+  static void  print(outputStream* st, const nmethod* nm, const char* msg = nullptr, bool short_form = false, bool cr = true) {\n@@ -209,1 +209,1 @@\n-  static void  print_ul(const nmethod* nm, const char* msg = NULL);\n+  static void  print_ul(const nmethod* nm, const char* msg = nullptr);\n@@ -228,2 +228,2 @@\n-  static void print_inlining_inner(outputStream* st, ciMethod* method, int inline_level, int bci, const char* msg = NULL);\n-  static void print_inlining_tty(ciMethod* method, int inline_level, int bci, const char* msg = NULL) {\n+  static void print_inlining_inner(outputStream* st, ciMethod* method, int inline_level, int bci, const char* msg = nullptr);\n+  static void print_inlining_tty(ciMethod* method, int inline_level, int bci, const char* msg = nullptr) {\n@@ -232,1 +232,1 @@\n-  static void print_inlining_ul(ciMethod* method, int inline_level, int bci, const char* msg = NULL);\n+  static void print_inlining_ul(ciMethod* method, int inline_level, int bci, const char* msg = nullptr);\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-  if (CompilationMode != NULL) {\n+  if (CompilationMode != nullptr) {\n@@ -328,1 +328,1 @@\n-    vm_exit_during_initialization(\"Negative value specified for CompileThresholdScaling\", NULL);\n+    vm_exit_during_initialization(\"Negative value specified for CompileThresholdScaling\", nullptr);\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-inline const char* compilertype2name(CompilerType t) { return (uint)t < compiler_number_of_types ? compilertype2name_tab[t] : NULL; }\n+inline const char* compilertype2name(CompilerType t) { return (uint)t < compiler_number_of_types ? compilertype2name_tab[t] : nullptr; }\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-CompilerDirectives::CompilerDirectives() : _next(NULL), _match(NULL), _ref_count(0) {\n+CompilerDirectives::CompilerDirectives() : _next(nullptr), _match(nullptr), _ref_count(0) {\n@@ -45,1 +45,1 @@\n-  if (_c1_store != NULL) {\n+  if (_c1_store != nullptr) {\n@@ -48,1 +48,1 @@\n-  if (_c2_store != NULL) {\n+  if (_c2_store != nullptr) {\n@@ -54,1 +54,1 @@\n-  while (tmp != NULL) {\n+  while (tmp != nullptr) {\n@@ -63,1 +63,1 @@\n-  if (_match != NULL) {\n+  if (_match != nullptr) {\n@@ -74,1 +74,1 @@\n-    while (tmp != NULL) {\n+    while (tmp != nullptr) {\n@@ -84,1 +84,1 @@\n-  if (_c1_store != NULL) {\n+  if (_c1_store != nullptr) {\n@@ -88,1 +88,1 @@\n-  if (_c2_store != NULL) {\n+  if (_c2_store != nullptr) {\n@@ -97,1 +97,1 @@\n-  if (_c1_store != NULL) {\n+  if (_c1_store != nullptr) {\n@@ -100,1 +100,1 @@\n-  if (_c2_store != NULL) {\n+  if (_c2_store != nullptr) {\n@@ -126,1 +126,1 @@\n-    if (_inlinematchers != NULL) {\n+    if (_inlinematchers != nullptr) {\n@@ -148,1 +148,1 @@\n-  if (method == NULL) {\n+  if (method == nullptr) {\n@@ -159,2 +159,2 @@\n-  if (bm == NULL) {\n-    assert(error_msg != NULL, \"Must have error message\");\n+  if (bm == nullptr) {\n+    assert(error_msg != nullptr, \"Must have error message\");\n@@ -186,1 +186,1 @@\n-  if (comp == NULL) { \/\/ Xint\n+  if (comp == nullptr) { \/\/ Xint\n@@ -244,1 +244,1 @@\n-  _token = strtok_r(NULL, \",\", &_saved_ptr);\n+  _token = strtok_r(nullptr, \",\", &_saved_ptr);\n@@ -263,1 +263,1 @@\n-  for (ControlIntrinsicIter iter(ControlIntrinsic); *iter != NULL; ++iter) {\n+  for (ControlIntrinsicIter iter(ControlIntrinsic); *iter != nullptr; ++iter) {\n@@ -272,1 +272,1 @@\n-  for (ControlIntrinsicIter iter(DisableIntrinsic, true\/*disable_all*\/); *iter != NULL; ++iter) {\n+  for (ControlIntrinsicIter iter(DisableIntrinsic, true\/*disable_all*\/); *iter != nullptr; ++iter) {\n@@ -281,1 +281,1 @@\n-DirectiveSet::DirectiveSet(CompilerDirectives* d) :_inlinematchers(NULL), _directive(d) {\n+DirectiveSet::DirectiveSet(CompilerDirectives* d) :_inlinematchers(nullptr), _directive(d) {\n@@ -294,1 +294,1 @@\n-  while (tmp != NULL) {\n+  while (tmp != nullptr) {\n@@ -318,1 +318,1 @@\n-    assert(origin != nullptr, \"DirectiveSetPtr cannot be initialized with a NULL pointer.\");\n+    assert(origin != nullptr, \"DirectiveSetPtr cannot be initialized with a nullptr pointer.\");\n@@ -434,1 +434,1 @@\n-      while (*iter != NULL) {\n+      while (*iter != nullptr) {\n@@ -454,1 +454,1 @@\n-      while (*iter != NULL) {\n+      while (*iter != nullptr) {\n@@ -471,1 +471,1 @@\n-  assert(_directive != NULL, \"Must have been initialized\");\n+  assert(_directive != nullptr, \"Must have been initialized\");\n@@ -476,1 +476,1 @@\n-  if (_inlinematchers != NULL) {\n+  if (_inlinematchers != nullptr) {\n@@ -489,1 +489,1 @@\n-  if (_inlinematchers != NULL) {\n+  if (_inlinematchers != nullptr) {\n@@ -503,1 +503,1 @@\n-  if (_inlinematchers != NULL) {\n+  if (_inlinematchers != nullptr) {\n@@ -514,1 +514,1 @@\n-  if (m != NULL) {\n+  if (m != nullptr) {\n@@ -519,1 +519,1 @@\n-    assert(error_msg != NULL, \"Error message must be set\");\n+    assert(error_msg != nullptr, \"Error message must be set\");\n@@ -525,1 +525,1 @@\n-  if (_inlinematchers == NULL) {\n+  if (_inlinematchers == nullptr) {\n@@ -530,1 +530,1 @@\n-  while (tmp->next() != NULL) {\n+  while (tmp->next() != nullptr) {\n@@ -537,1 +537,1 @@\n-  if (_inlinematchers == NULL) {\n+  if (_inlinematchers == nullptr) {\n@@ -543,1 +543,1 @@\n-    while (tmp != NULL) {\n+    while (tmp != nullptr) {\n@@ -565,1 +565,1 @@\n-  DirectiveSet* set = new DirectiveSet(NULL);\n+  DirectiveSet* set = new DirectiveSet(nullptr);\n@@ -575,1 +575,1 @@\n-  while (tmp != NULL) {\n+  while (tmp != nullptr) {\n@@ -594,1 +594,1 @@\n-  const char* error_msg = NULL;\n+  const char* error_msg = nullptr;\n@@ -604,1 +604,1 @@\n-  assert(error_msg == NULL, \"Must succeed.\");\n+  assert(error_msg == nullptr, \"Must succeed.\");\n@@ -611,1 +611,1 @@\n-  assert(_bottom != NULL, \"Must never be empty\");\n+  assert(_bottom != nullptr, \"Must never be empty\");\n@@ -620,2 +620,2 @@\n-  if (_top == NULL) {\n-    assert(_bottom == NULL, \"There can only be one default directive\");\n+  if (_top == nullptr) {\n+    assert(_bottom == nullptr, \"There can only be one default directive\");\n@@ -641,1 +641,1 @@\n-  if (_top->next() == NULL) {\n+  if (_top->next() == nullptr) {\n@@ -662,1 +662,1 @@\n-  while (_top->next() != NULL) {\n+  while (_top->next() != nullptr) {\n@@ -670,1 +670,1 @@\n-  while (tmp != NULL) {\n+  while (tmp != nullptr) {\n@@ -678,1 +678,1 @@\n-  assert(set != NULL, \"Never NULL\");\n+  assert(set != nullptr, \"Never nullptr\");\n@@ -684,1 +684,1 @@\n-    assert(set->directive() != NULL, \"Never NULL\");\n+    assert(set->directive() != nullptr, \"Never nullptr\");\n@@ -701,1 +701,1 @@\n-  DirectiveSet* match = NULL;\n+  DirectiveSet* match = nullptr;\n@@ -706,1 +706,1 @@\n-    assert(dir != NULL, \"Must be initialized\");\n+    assert(dir != nullptr, \"Must be initialized\");\n@@ -708,1 +708,1 @@\n-    while (dir != NULL) {\n+    while (dir != nullptr) {\n@@ -711,1 +711,1 @@\n-        assert(match != NULL, \"Consistency\");\n+        assert(match != nullptr, \"Consistency\");\n@@ -721,1 +721,1 @@\n-  guarantee(match != NULL, \"There should always be a default directive that matches\");\n+  guarantee(match != nullptr, \"There should always be a default directive that matches\");\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":51,"deletions":51,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,1 @@\n-  bool is_exclusive_copy() { return _directive == NULL; }\n+  bool is_exclusive_copy() { return _directive == nullptr; }\n@@ -209,1 +209,1 @@\n-    for (ControlIntrinsicIter iter(option, disable_all); *iter != NULL && _valid; ++iter) {\n+    for (ControlIntrinsicIter iter(option, disable_all); *iter != nullptr && _valid; ++iter) {\n@@ -213,1 +213,1 @@\n-        \/\/ strncpy always writes len characters. If the source string is shorter, the function fills the remaining bytes with NULLs.\n+        \/\/ strncpy always writes len characters. If the source string is shorter, the function fills the remaining bytes with nullptrs.\n@@ -221,1 +221,1 @@\n-    if (_bad != NULL) {\n+    if (_bad != nullptr) {\n@@ -254,1 +254,1 @@\n-  bool is_default_directive() { return _next == NULL; }\n+  bool is_default_directive() { return _next == nullptr; }\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-static GrowableArray<const char*>* phase_names = NULL;\n+static GrowableArray<const char*>* phase_names = nullptr;\n@@ -66,1 +66,1 @@\n-    assert(phase_names != NULL, \"invariant\");\n+    assert(phase_names != nullptr, \"invariant\");\n@@ -92,1 +92,1 @@\n-    if (phase_names == NULL) {\n+    if (phase_names == nullptr) {\n","filename":"src\/hotspot\/share\/compiler\/compilerEvent.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-static TypedMethodOptionMatcher* option_list = NULL;\n+static TypedMethodOptionMatcher* option_list = nullptr;\n@@ -139,1 +139,1 @@\n-    _next(NULL),\n+    _next(nullptr),\n@@ -239,1 +239,1 @@\n-   if (_next != NULL) {\n+   if (_next != nullptr) {\n@@ -253,1 +253,1 @@\n-  if (_class_name != NULL) {\n+  if (_class_name != nullptr) {\n@@ -256,1 +256,1 @@\n-  if (_method_name != NULL) {\n+  if (_method_name != nullptr) {\n@@ -259,1 +259,1 @@\n-  if (_signature != NULL) {\n+  if (_signature != nullptr) {\n@@ -275,1 +275,1 @@\n-  const char* error_msg = NULL;\n+  const char* error_msg = nullptr;\n@@ -278,1 +278,1 @@\n-  if (error_msg != NULL) {\n+  if (error_msg != nullptr) {\n@@ -281,1 +281,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -288,1 +288,1 @@\n-  while (current != NULL) {\n+  while (current != nullptr) {\n@@ -296,1 +296,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -335,1 +335,1 @@\n-  if (option_list != NULL) {\n+  if (option_list != nullptr) {\n@@ -337,1 +337,1 @@\n-    if (m != NULL) {\n+    if (m != nullptr) {\n@@ -358,1 +358,1 @@\n-      while (current != NULL) {\n+      while (current != nullptr) {\n@@ -752,1 +752,1 @@\n-\/\/ Scan next option and value in line, return MethodMatcher object on success, NULL on failure.\n+\/\/ Scan next option and value in line, return MethodMatcher object on success, nullptr on failure.\n@@ -855,1 +855,1 @@\n-    if (archetype == NULL) {\n+    if (archetype == nullptr) {\n@@ -894,1 +894,1 @@\n-      assert(typed_matcher != NULL, \"sanity\");\n+      assert(typed_matcher != nullptr, \"sanity\");\n@@ -908,1 +908,1 @@\n-    if (matcher == NULL) {\n+    if (matcher == nullptr) {\n@@ -929,1 +929,1 @@\n-    assert(matcher != NULL, \"consistency\");\n+    assert(matcher != nullptr, \"consistency\");\n@@ -937,1 +937,1 @@\n-  if (CompileCommandFile == NULL)\n+  if (CompileCommandFile == nullptr)\n@@ -944,1 +944,1 @@\n-  return cc_file() != NULL;\n+  return cc_file() != nullptr;\n@@ -952,1 +952,1 @@\n-  if (stream == NULL) return;\n+  if (stream == nullptr) return;\n@@ -1015,2 +1015,2 @@\n-  const char* className = NULL;\n-  const char* methodName = NULL;\n+  const char* className = nullptr;\n+  const char* methodName = nullptr;\n@@ -1018,1 +1018,1 @@\n-  bool have_colon = (strstr(line, \"::\") != NULL);\n+  bool have_colon = (strstr(line, \"::\") != nullptr);\n@@ -1039,1 +1039,1 @@\n-      if (newName == NULL)\n+      if (newName == nullptr)\n@@ -1044,1 +1044,1 @@\n-      if (className == NULL) {\n+      if (className == nullptr) {\n@@ -1052,1 +1052,1 @@\n-      if (className == NULL) {\n+      if (className == nullptr) {\n@@ -1058,1 +1058,1 @@\n-      if (className == NULL) {\n+      if (className == nullptr) {\n@@ -1070,1 +1070,1 @@\n-      if (methodName == NULL) {\n+      if (methodName == nullptr) {\n@@ -1080,1 +1080,1 @@\n-      Symbol* signature = NULL;\n+      Symbol* signature = nullptr;\n@@ -1090,2 +1090,2 @@\n-      className = NULL;\n-      methodName = NULL;\n+      className = nullptr;\n+      methodName = nullptr;\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,3 +35,3 @@\n-  _env   = NULL;\n-  _log   = NULL;\n-  _task  = NULL;\n+  _env   = nullptr;\n+  _log   = nullptr;\n+  _task  = nullptr;\n@@ -40,2 +40,2 @@\n-  _buffer_blob = NULL;\n-  _compiler = NULL;\n+  _buffer_blob = nullptr;\n+  _compiler = nullptr;\n@@ -47,1 +47,1 @@\n-  _ideal_graph_printer = NULL;\n+  _ideal_graph_printer = nullptr;\n@@ -62,1 +62,1 @@\n-  return _compiler != NULL && _compiler->is_jvmci();\n+  return _compiler != nullptr && _compiler->is_jvmci();\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-    assert(_log == NULL, \"set only once\");\n+    assert(_log == nullptr, \"set only once\");\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -299,1 +299,1 @@\n-  product(ccstr, CompileCommandFile, NULL,                                  \\\n+  product(ccstr, CompileCommandFile, nullptr,                               \\\n@@ -302,1 +302,1 @@\n-  product(ccstr, CompilerDirectivesFile, NULL, DIAGNOSTIC,                  \\\n+  product(ccstr, CompilerDirectivesFile, nullptr, DIAGNOSTIC,               \\\n@@ -314,1 +314,1 @@\n-  product(ccstr, ReplayDataFile, NULL,                                      \\\n+  product(ccstr, ReplayDataFile, nullptr,                                   \\\n@@ -318,1 +318,1 @@\n-  product(ccstr, InlineDataFile, NULL,                                      \\\n+  product(ccstr, InlineDataFile, nullptr,                                   \\\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n-  if (_tmp_top == NULL) {\n-    return NULL;\n+  if (_tmp_top == nullptr) {\n+    return nullptr;\n@@ -46,1 +46,1 @@\n-  tmp->set_next(NULL);\n+  tmp->set_next(nullptr);\n@@ -53,1 +53,1 @@\n-  while (tmp != NULL) {\n+  while (tmp != nullptr) {\n@@ -73,1 +73,1 @@\n-  return CompilerDirectivesFile != NULL;\n+  return CompilerDirectivesFile != nullptr;\n@@ -81,1 +81,1 @@\n-  assert(filename != NULL, \"Test before calling this\");\n+  assert(filename != nullptr, \"Test before calling this\");\n@@ -119,1 +119,1 @@\n-  while (tmp != NULL) {\n+  while (tmp != nullptr) {\n@@ -138,1 +138,1 @@\n-: JSON(text, silent, st), depth(0), current_directive(NULL), current_directiveset(NULL), _tmp_top(NULL), _tmp_depth(0) {\n+: JSON(text, silent, st), depth(0), current_directive(nullptr), current_directiveset(nullptr), _tmp_top(nullptr), _tmp_depth(0) {\n@@ -146,1 +146,1 @@\n-  assert(_tmp_top == NULL, \"Consistency\");\n+  assert(_tmp_top == nullptr, \"Consistency\");\n@@ -152,4 +152,4 @@\n-    { \"c1\",     type_c1,     0, mask(type_directives), NULL, UnknownFlagType },\n-    { \"c2\",     type_c2,     0, mask(type_directives), NULL, UnknownFlagType },\n-    { \"match\",  type_match,  1, mask(type_directives), NULL, UnknownFlagType },\n-    { \"inline\", type_inline, 1, mask(type_directives) | mask(type_c1) | mask(type_c2), NULL, UnknownFlagType },\n+    { \"c1\",     type_c1,     0, mask(type_directives), nullptr, UnknownFlagType },\n+    { \"c2\",     type_c2,     0, mask(type_directives), nullptr, UnknownFlagType },\n+    { \"match\",  type_match,  1, mask(type_directives), nullptr, UnknownFlagType },\n+    { \"inline\", type_inline, 1, mask(type_directives) | mask(type_c1) | mask(type_c2), nullptr, UnknownFlagType },\n@@ -182,1 +182,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -193,1 +193,1 @@\n-  if (k == NULL) {\n+  if (k == nullptr) {\n@@ -217,1 +217,1 @@\n-  assert(stack[depth] == NULL, \"element not nulled, something is wrong\");\n+  assert(stack[depth] == nullptr, \"element not nulled, something is wrong\");\n@@ -240,1 +240,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -249,1 +249,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -255,1 +255,1 @@\n-  stack[depth] = NULL;\n+  stack[depth] = nullptr;\n@@ -376,1 +376,1 @@\n-    if (current_directiveset == NULL) {\n+    if (current_directiveset == nullptr) {\n@@ -408,1 +408,1 @@\n-      const char* error_msg = NULL;\n+      const char* error_msg = nullptr;\n@@ -410,1 +410,1 @@\n-        assert (error_msg != NULL, \"Must have valid error message\");\n+        assert (error_msg != nullptr, \"Must have valid error message\");\n@@ -428,2 +428,2 @@\n-      const char* error_msg = NULL;\n-      if (current_directiveset == NULL) {\n+      const char* error_msg = nullptr;\n+      if (current_directiveset == nullptr) {\n@@ -432,1 +432,1 @@\n-            assert (error_msg != NULL, \"Must have valid error message\");\n+            assert (error_msg != nullptr, \"Must have valid error message\");\n@@ -436,1 +436,1 @@\n-          assert (error_msg != NULL, \"Must have valid error message\");\n+          assert (error_msg != nullptr, \"Must have valid error message\");\n@@ -441,1 +441,1 @@\n-          assert (error_msg != NULL, \"Must have valid error message\");\n+          assert (error_msg != nullptr, \"Must have valid error message\");\n@@ -538,1 +538,1 @@\n-        current_directiveset = NULL;\n+        current_directiveset = nullptr;\n@@ -543,1 +543,1 @@\n-        if (current_directive->match() == NULL) {\n+        if (current_directive->match() == nullptr) {\n@@ -549,1 +549,1 @@\n-        current_directive = NULL;\n+        current_directive = nullptr;\n","filename":"src\/hotspot\/share\/compiler\/directivesParser.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-void*       Disassembler::_library               = NULL;\n+void*       Disassembler::_library               = nullptr;\n@@ -50,1 +50,1 @@\n-Disassembler::decode_func_virtual Disassembler::_decode_instructions_virtual = NULL;\n+Disassembler::decode_func_virtual Disassembler::_decode_instructions_virtual = nullptr;\n@@ -60,2 +60,2 @@\n-  CodeBlob*     _codeBlob;    \/\/ != NULL only when decoding a CodeBlob\n-  nmethod*      _nm;          \/\/ != NULL only when decoding a nmethod\n+  CodeBlob*     _codeBlob;    \/\/ != nullptr only when decoding a CodeBlob\n+  nmethod*      _nm;          \/\/ != nullptr only when decoding a nmethod\n@@ -63,2 +63,2 @@\n-  address       _start;       \/\/ != NULL when decoding a range of unknown type\n-  address       _end;         \/\/ != NULL when decoding a range of unknown type\n+  address       _start;       \/\/ != nullptr when decoding a range of unknown type\n+  address       _end;         \/\/ != nullptr when decoding a range of unknown type\n@@ -101,1 +101,1 @@\n-    if (p == NULL || p[0] == '\\0')  return;\n+    if (p == nullptr || p[0] == '\\0')  return;\n@@ -109,1 +109,1 @@\n-    while ((q = strpbrk(q, \" \\t\\n\")) != NULL)\n+    while ((q = strpbrk(q, \" \\t\\n\")) != nullptr)\n@@ -149,1 +149,1 @@\n-      if ((_nm != NULL) && _nm->has_code_comment(pc0, pc)) {\n+      if ((_nm != nullptr) && _nm->has_code_comment(pc0, pc)) {\n@@ -156,1 +156,1 @@\n-      print_hook_comments(pc0, _nm != NULL);\n+      print_hook_comments(pc0, _nm != nullptr);\n@@ -169,1 +169,1 @@\n-      Link(const char* f, int l) : file(f), line(l), next(NULL) {}\n+      Link(const char* f, int l) : file(f), line(l), next(nullptr) {}\n@@ -174,1 +174,1 @@\n-      if (tail != NULL && tail->file == file && tail->line == line) {\n+      if (tail != nullptr && tail->file == file && tail->line == line) {\n@@ -180,1 +180,1 @@\n-      if (head == NULL) {\n+      if (head == nullptr) {\n@@ -187,1 +187,1 @@\n-    SourceFileInfo(const char* file, int line) : head(NULL), tail(NULL) {\n+    SourceFileInfo(const char* file, int line) : head(nullptr), tail(nullptr) {\n@@ -202,1 +202,1 @@\n-    if (_src_table == NULL) {\n+    if (_src_table == nullptr) {\n@@ -214,1 +214,1 @@\n-             NOT_PRODUCT(COMMA const AsmRemarks* remarks = NULL COMMA ptrdiff_t disp = 0));\n+             NOT_PRODUCT(COMMA const AsmRemarks* remarks = nullptr COMMA ptrdiff_t disp = 0));\n@@ -218,1 +218,1 @@\n-  address decode_instructions(address start, address end, address original_start = NULL);\n+  address decode_instructions(address start, address end, address original_start = nullptr);\n@@ -231,3 +231,3 @@\n-decode_env::SourceFileInfoTable* decode_env::_src_table = NULL;\n-const char* decode_env::_cached_src = NULL;\n-GrowableArray<const char*>* decode_env::_cached_src_lines = NULL;\n+decode_env::SourceFileInfoTable* decode_env::_src_table = nullptr;\n+const char* decode_env::_cached_src = nullptr;\n+GrowableArray<const char*>* decode_env::_cached_src_lines = nullptr;\n@@ -241,1 +241,1 @@\n-  if (found != NULL) {\n+  if (found != nullptr) {\n@@ -252,1 +252,1 @@\n-  if (found != NULL) {\n+  if (found != nullptr) {\n@@ -256,1 +256,1 @@\n-      if (_cached_src == NULL || strcmp(_cached_src, file) != 0) {\n+      if (_cached_src == nullptr || strcmp(_cached_src, file) != 0) {\n@@ -262,1 +262,1 @@\n-        if (_cached_src_lines != NULL) {\n+        if (_cached_src_lines != nullptr) {\n@@ -271,2 +271,2 @@\n-        if ((fp = os::fopen(file, \"r\")) == NULL) {\n-          _cached_src = NULL;\n+        if ((fp = os::fopen(file, \"r\")) == nullptr) {\n+          _cached_src = nullptr;\n@@ -278,1 +278,1 @@\n-        while (fgets(line, sizeof(line), fp) != NULL) {\n+        while (fgets(line, sizeof(line), fp) != nullptr) {\n@@ -320,3 +320,3 @@\n-  _nm(_codeBlob != NULL && _codeBlob->is_nmethod() ? (nmethod*) code : NULL),\n-  _start(NULL),\n-  _end(NULL),\n+  _nm(_codeBlob != nullptr && _codeBlob->is_nmethod() ? (nmethod*) code : nullptr),\n+  _start(nullptr),\n+  _end(nullptr),\n@@ -325,1 +325,1 @@\n-  _cur_insn(NULL),\n+  _cur_insn(nullptr),\n@@ -341,1 +341,1 @@\n-  _codeBlob(NULL),\n+  _codeBlob(nullptr),\n@@ -347,1 +347,1 @@\n-  _cur_insn(NULL),\n+  _cur_insn(nullptr),\n@@ -366,2 +366,2 @@\n-  _codeBlob(NULL),\n-  _nm(NULL),\n+  _codeBlob(nullptr),\n+  _nm(nullptr),\n@@ -372,1 +372,1 @@\n-  _cur_insn(NULL),\n+  _cur_insn(nullptr),\n@@ -472,1 +472,1 @@\n-\/\/ - NULL for all standard invocations. The function result is not\n+\/\/ - nullptr for all standard invocations. The function result is not\n@@ -498,1 +498,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -504,1 +504,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -511,1 +511,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -520,1 +520,1 @@\n-    if (arg != NULL) {\n+    if (arg != nullptr) {\n@@ -526,1 +526,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -546,1 +546,1 @@\n-    guarantee(arg != NULL, \"event_to_env - arg must not be NULL for event 'mach'\");\n+    guarantee(arg != nullptr, \"event_to_env - arg must not be nullptr for event 'mach'\");\n@@ -557,1 +557,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -563,1 +563,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -566,1 +566,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -578,2 +578,2 @@\n-  if (adr == NULL) {\n-    st->print(\"NULL\");\n+  if (adr == nullptr) {\n+    st->print(\"nullptr\");\n@@ -593,1 +593,1 @@\n-      if (desc == NULL) {\n+      if (desc == nullptr) {\n@@ -596,1 +596,1 @@\n-      if (desc != NULL) {\n+      if (desc != nullptr) {\n@@ -618,1 +618,1 @@\n-  if (_nm == NULL) {\n+  if (_nm == nullptr) {\n@@ -674,1 +674,1 @@\n-  const char* raw = NULL;\n+  const char* raw = nullptr;\n@@ -678,1 +678,1 @@\n-      strchr(format, '%') == NULL) {\n+      strchr(format, '%') == nullptr) {\n@@ -681,1 +681,1 @@\n-             strchr(format+2, '%') == NULL) {\n+             strchr(format+2, '%') == nullptr) {\n@@ -686,1 +686,1 @@\n-  if (raw != NULL) {\n+  if (raw != nullptr) {\n@@ -700,1 +700,1 @@\n-\/\/ the instructions were located in the originating system. If zero (NULL)\n+\/\/ the instructions were located in the originating system. If zero (nullptr)\n@@ -706,5 +706,5 @@\n-  assert((_start == NULL) || (start == NULL) || (_start == start), \"don't overwrite CTOR values\");\n-  assert((_end   == NULL) || (end   == NULL) || (_end   == end  ), \"don't overwrite CTOR values\");\n-  if (start != NULL) set_start(start);\n-  if (end   != NULL) set_end(end);\n-  if (original_start == NULL) {\n+  assert((_start == nullptr) || (start == nullptr) || (_start == start), \"don't overwrite CTOR values\");\n+  assert((_end   == nullptr) || (end   == nullptr) || (_end   == end  ), \"don't overwrite CTOR values\");\n+  if (start != nullptr) set_start(start);\n+  if (end   != nullptr) set_end(end);\n+  if (original_start == nullptr) {\n@@ -724,1 +724,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -733,1 +733,1 @@\n-    FILE* xmlout = (_print_raw > 1 ? out : NULL);\n+    FILE* xmlout = (_print_raw > 1 ? out : nullptr);\n@@ -738,2 +738,2 @@\n-                                                    NULL, (void*) xmlout,\n-                                                    NULL, (void*) out,\n+                                                    nullptr, (void*) xmlout,\n+                                                    nullptr, (void*) out,\n@@ -767,1 +767,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -780,1 +780,1 @@\n-  st = ((st == NULL) && Verbose) ? tty : st;\n+  st = ((st == nullptr) && Verbose) ? tty : st;\n@@ -799,1 +799,1 @@\n-    if (p != NULL) lib_offset = p - base + 1; \/\/ this points to the first char after separator\n+    if (p != nullptr) lib_offset = p - base + 1; \/\/ this points to the first char after separator\n@@ -802,1 +802,1 @@\n-    if (p != NULL) jvm_offset = p - base;     \/\/ this points to 'j' in jvm.\n+    if (p != nullptr) jvm_offset = p - base;     \/\/ this points to 'j' in jvm.\n@@ -805,1 +805,1 @@\n-    if (p != NULL) jvm_offset = p - base + 3; \/\/ this points to 'j' in libjvm.\n+    if (p != nullptr) jvm_offset = p - base + 3; \/\/ this points to 'j' in libjvm.\n@@ -819,1 +819,1 @@\n-    if (_library == NULL && lib_offset >= 0) {\n+    if (_library == nullptr && lib_offset >= 0) {\n@@ -823,1 +823,1 @@\n-    if (_library == NULL && lib_offset > 0) {\n+    if (_library == nullptr && lib_offset > 0) {\n@@ -827,1 +827,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n@@ -833,1 +833,1 @@\n-  if (_library == NULL) {\n+  if (_library == nullptr) {\n@@ -838,1 +838,1 @@\n-  if (_library != NULL) {\n+  if (_library != nullptr) {\n@@ -845,1 +845,1 @@\n-  _library_usable        = _decode_instructions_virtual != NULL;\n+  _library_usable        = _decode_instructions_virtual != nullptr;\n@@ -852,1 +852,1 @@\n-  if (st != NULL) {\n+  if (st != nullptr) {\n@@ -859,1 +859,1 @@\n-                   ((_library != NULL)\n+                   ((_library != nullptr)\n@@ -885,1 +885,1 @@\n-  if (cb->name() != NULL) {\n+  if (cb->name() != nullptr) {\n@@ -926,2 +926,2 @@\n-    \/\/---<  Allow output suppression, but prevent writing to a NULL stream. Could happen with +PrintStubCode.  >---\n-    if (st != NULL) {\n+    \/\/---<  Allow output suppression, but prevent writing to a nullptr stream. Could happen with +PrintStubCode.  >---\n+    if (st != nullptr) {\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":82,"deletions":82,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-  \/\/ No output at all if stream is NULL. Can be overridden\n+  \/\/ No output at all if stream is nullptr. Can be overridden\n@@ -67,1 +67,1 @@\n-  static bool load_library(outputStream* st = NULL);\n+  static bool load_library(outputStream* st = nullptr);\n@@ -103,1 +103,1 @@\n-  static void decode(CodeBlob* cb,               outputStream* st = NULL);\n+  static void decode(CodeBlob* cb,               outputStream* st = nullptr);\n@@ -105,1 +105,1 @@\n-  static void decode(nmethod* nm,                outputStream* st = NULL);\n+  static void decode(nmethod* nm,                outputStream* st = nullptr);\n@@ -107,2 +107,2 @@\n-  static void decode(address start, address end, outputStream* st = NULL\n-                     NOT_PRODUCT(COMMA const AsmRemarks* remarks = NULL COMMA ptrdiff_t disp = 0));\n+  static void decode(address start, address end, outputStream* st = nullptr\n+                     NOT_PRODUCT(COMMA const AsmRemarks* remarks = nullptr COMMA ptrdiff_t disp = 0));\n","filename":"src\/hotspot\/share\/compiler\/disassembler.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-  _block_map = new (arena()) GrowableArray<BasicBlock*>(arena(), method_len, method_len, NULL);\n+  _block_map = new (arena()) GrowableArray<BasicBlock*>(arena(), method_len, method_len, nullptr);\n@@ -135,1 +135,1 @@\n-        assert( next != NULL, \"must be a block immediately following this one.\");\n+        assert( next != nullptr, \"must be a block immediately following this one.\");\n@@ -146,1 +146,1 @@\n-    assert (current_block != NULL, \"we must have a current block\");\n+    assert (current_block != nullptr, \"we must have a current block\");\n@@ -167,1 +167,1 @@\n-          assert(dest != NULL, \"must be a block immediately following this one.\");\n+          assert(dest != nullptr, \"must be a block immediately following this one.\");\n@@ -171,1 +171,1 @@\n-        assert(dest != NULL, \"branch destination must start a block.\");\n+        assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -176,1 +176,1 @@\n-        assert(dest != NULL, \"branch destination must start a block.\");\n+        assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -181,1 +181,1 @@\n-        assert(dest != NULL, \"branch destination must start a block.\");\n+        assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -191,1 +191,1 @@\n-          assert(dest != NULL, \"branch destination must start a block.\");\n+          assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -195,1 +195,1 @@\n-            assert(dest != NULL, \"branch destination must start a block.\");\n+            assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -208,1 +208,1 @@\n-          assert(dest != NULL, \"branch destination must start a block.\");\n+          assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -213,1 +213,1 @@\n-            assert(dest != NULL, \"branch destination must start a block.\");\n+            assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -223,1 +223,1 @@\n-          assert(dest != NULL, \"branch destination must start a block.\");\n+          assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -226,1 +226,1 @@\n-          assert(jsrExit != NULL, \"jsr return bci must start a block.\");\n+          assert(jsrExit != nullptr, \"jsr return bci must start a block.\");\n@@ -233,1 +233,1 @@\n-          assert(dest != NULL, \"branch destination must start a block.\");\n+          assert(dest != nullptr, \"branch destination must start a block.\");\n@@ -236,1 +236,1 @@\n-          assert(jsrExit != NULL, \"jsr return bci must start a block.\");\n+          assert(jsrExit != nullptr, \"jsr return bci must start a block.\");\n@@ -328,1 +328,1 @@\n-  _work_list = NULL;\n+  _work_list = nullptr;\n@@ -337,1 +337,1 @@\n-  while ((block = work_list_get()) != NULL) {\n+  while ((block = work_list_get()) != nullptr) {\n@@ -352,1 +352,1 @@\n-  if (block != NULL) {\n+  if (block != nullptr) {\n@@ -377,1 +377,1 @@\n-    while (block == NULL && t > 0) {\n+    while (block == nullptr && t > 0) {\n@@ -380,1 +380,1 @@\n-    guarantee(block != NULL, \"invalid bytecode index; must be instruction index\");\n+    guarantee(block != nullptr, \"invalid bytecode index; must be instruction index\");\n@@ -414,1 +414,1 @@\n-    new (analyzer->arena()) GrowableArray<MethodLiveness::BasicBlock*>(analyzer->arena(), 5, 0, NULL);\n+    new (analyzer->arena()) GrowableArray<MethodLiveness::BasicBlock*>(analyzer->arena(), 5, 0, nullptr);\n@@ -416,1 +416,1 @@\n-    new (analyzer->arena()) GrowableArray<MethodLiveness::BasicBlock*>(analyzer->arena(), 5, 0, NULL);\n+    new (analyzer->arena()) GrowableArray<MethodLiveness::BasicBlock*>(analyzer->arena(), 5, 0, nullptr);\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,3 +75,3 @@\n-    _class_name(NULL)\n-  , _method_name(NULL)\n-  , _signature(NULL)\n+    _class_name(nullptr)\n+  , _method_name(nullptr)\n+  , _signature(nullptr)\n@@ -83,1 +83,1 @@\n-  if (_class_name != NULL) {\n+  if (_class_name != nullptr) {\n@@ -86,1 +86,1 @@\n-  if (_method_name != NULL) {\n+  if (_method_name != nullptr) {\n@@ -89,1 +89,1 @@\n-  if (_signature != NULL) {\n+  if (_signature != nullptr) {\n@@ -106,1 +106,1 @@\n-  bool have_colon = (colon != NULL);\n+  bool have_colon = (colon != nullptr);\n@@ -117,1 +117,1 @@\n-    if (pos != NULL) {\n+    if (pos != nullptr) {\n@@ -133,1 +133,1 @@\n-    if (pos != NULL) {\n+    if (pos != nullptr) {\n@@ -213,1 +213,1 @@\n-    return strstr(candidate_string, match_string) != NULL;\n+    return strstr(candidate_string, match_string) != nullptr;\n@@ -241,1 +241,1 @@\n-  if (strstr(name, \"*\") != NULL) {\n+  if (strstr(name, \"*\") != nullptr) {\n@@ -267,1 +267,1 @@\n-  assert(error_msg == NULL, \"Dont call here with error_msg already set\");\n+  assert(error_msg == nullptr, \"Dont call here with error_msg already set\");\n@@ -270,1 +270,1 @@\n-    assert(error_msg != NULL, \"Message must be set if parsing failed\");\n+    assert(error_msg != nullptr, \"Message must be set if parsing failed\");\n@@ -291,1 +291,1 @@\n-        strstr(line + bytes_read, method_name) == NULL) {\n+        strstr(line + bytes_read, method_name) == nullptr) {\n@@ -297,2 +297,2 @@\n-    if ((strchr(class_name, JVM_SIGNATURE_SPECIAL) != NULL) ||\n-        (strchr(class_name, JVM_SIGNATURE_ENDSPECIAL) != NULL)) {\n+    if ((strchr(class_name, JVM_SIGNATURE_SPECIAL) != nullptr) ||\n+        (strchr(class_name, JVM_SIGNATURE_ENDSPECIAL) != nullptr)) {\n@@ -303,2 +303,2 @@\n-    if ((strchr(method_name, JVM_SIGNATURE_SPECIAL) != NULL) ||\n-        (strchr(method_name, JVM_SIGNATURE_ENDSPECIAL) != NULL)) {\n+    if ((strchr(method_name, JVM_SIGNATURE_SPECIAL) != nullptr) ||\n+        (strchr(method_name, JVM_SIGNATURE_ENDSPECIAL) != nullptr)) {\n@@ -313,1 +313,1 @@\n-      assert(error_msg != NULL, \"Must have been set by check_mode()\");\n+      assert(error_msg != nullptr, \"Must have been set by check_mode()\");\n@@ -318,1 +318,1 @@\n-    Symbol* signature = NULL;\n+    Symbol* signature = nullptr;\n@@ -331,1 +331,1 @@\n-        if (strchr(sig, '*') != NULL) {\n+        if (strchr(sig, '*') != nullptr) {\n@@ -356,1 +356,1 @@\n-      ((this->signature() == NULL) || match(signature, this->signature(), Prefix))) {\n+      ((this->signature() == nullptr) || match(signature, this->signature(), Prefix))) {\n@@ -380,1 +380,1 @@\n-  if (signature() != NULL) {\n+  if (signature() != nullptr) {\n@@ -386,1 +386,1 @@\n-  assert(error_msg == NULL, \"Don't call here with error_msg already set\");\n+  assert(error_msg == nullptr, \"Don't call here with error_msg already set\");\n@@ -389,1 +389,1 @@\n-  if (error_msg != NULL) {\n+  if (error_msg != nullptr) {\n@@ -391,1 +391,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -400,1 +400,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -407,1 +407,1 @@\n-  for (BasicMatcher* current = this; current != NULL; current = current->next()) {\n+  for (BasicMatcher* current = this; current != nullptr; current = current->next()) {\n@@ -425,1 +425,1 @@\n-  assert(error_msg == NULL, \"Dont call here with error_msg already set\");\n+  assert(error_msg == nullptr, \"Dont call here with error_msg already set\");\n@@ -428,1 +428,1 @@\n-  if (error_msg != NULL) {\n+  if (error_msg != nullptr) {\n@@ -430,1 +430,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -436,1 +436,1 @@\n-  for (InlineMatcher* current = this; current != NULL; current = current->next()) {\n+  for (InlineMatcher* current = this; current != nullptr; current = current->next()) {\n@@ -456,1 +456,1 @@\n-     return NULL;\n+     return nullptr;\n@@ -460,1 +460,1 @@\n-   assert(error_msg == NULL, \"error_msg must not be set yet\");\n+   assert(error_msg == nullptr, \"error_msg must not be set yet\");\n@@ -462,3 +462,3 @@\n-   if (im == NULL) {\n-     assert(error_msg != NULL, \"Must have error message\");\n-     return NULL;\n+   if (im == nullptr) {\n+     assert(error_msg != nullptr, \"Must have error message\");\n+     return nullptr;\n@@ -476,1 +476,1 @@\n-   if(_class_name != NULL) {\n+   if(_class_name != nullptr) {\n@@ -480,1 +480,1 @@\n-   if (_method_name != NULL) {\n+   if (_method_name != nullptr) {\n@@ -484,1 +484,1 @@\n-   if (_signature != NULL) {\n+   if (_signature != nullptr) {\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.cpp","additions":41,"deletions":41,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-    _next(NULL) {\n+    _next(nullptr) {\n@@ -92,1 +92,1 @@\n-    if (_next != NULL) {\n+    if (_next != nullptr) {\n@@ -111,1 +111,1 @@\n-    _inline_action(unknown_inline), _next(NULL) {\n+    _inline_action(unknown_inline), _next(nullptr) {\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -446,1 +446,1 @@\n-  assert(derived_oop_fn != NULL, \"sanity\");\n+  assert(derived_oop_fn != nullptr, \"sanity\");\n@@ -509,1 +509,1 @@\n-  assert(cb != NULL, \"no codeblob\");\n+  assert(cb != nullptr, \"no codeblob\");\n@@ -511,1 +511,1 @@\n-  assert( reg_map->_update_for_id == NULL || fr->is_older(reg_map->_update_for_id),\n+  assert( reg_map->_update_for_id == nullptr || fr->is_older(reg_map->_update_for_id),\n@@ -528,1 +528,1 @@\n-  assert(cb == NULL || cb->is_compiled_by_c1() || cb->is_compiled_by_jvmci() || !cb->is_runtime_stub() ||\n+  assert(cb == nullptr || cb->is_compiled_by_c1() || cb->is_compiled_by_jvmci() || !cb->is_runtime_stub() ||\n@@ -539,1 +539,1 @@\n-  assert(cb != NULL, \"no codeblob\");\n+  assert(cb != nullptr, \"no codeblob\");\n@@ -541,1 +541,1 @@\n-  assert(map != NULL, \"no ptr map found\");\n+  assert(map != nullptr, \"no ptr map found\");\n@@ -575,1 +575,1 @@\n-  if (reg_map != NULL) {\n+  if (reg_map != nullptr) {\n@@ -643,1 +643,1 @@\n-  const ImmutableOopMap* last = NULL;\n+  const ImmutableOopMap* last = nullptr;\n@@ -707,1 +707,1 @@\n-  ImmutableOopMapPair* last  = NULL;\n+  ImmutableOopMapPair* last  = nullptr;\n@@ -717,1 +717,1 @@\n-  guarantee(last != NULL, \"last may not be null\");\n+  guarantee(last != nullptr, \"last may not be null\");\n@@ -750,1 +750,1 @@\n-ImmutableOopMapBuilder::ImmutableOopMapBuilder(const OopMapSet* set) : _set(set), _empty(NULL), _last(NULL), _empty_offset(-1), _last_offset(-1), _offset(0), _required(-1), _new_set(NULL) {\n+ImmutableOopMapBuilder::ImmutableOopMapBuilder(const OopMapSet* set) : _set(set), _empty(nullptr), _last(nullptr), _empty_offset(-1), _last_offset(-1), _offset(0), _required(-1), _new_set(nullptr) {\n@@ -819,1 +819,1 @@\n-    ImmutableOopMapPair* pair = NULL;\n+    ImmutableOopMapPair* pair = nullptr;\n@@ -888,1 +888,1 @@\n-    _location(location), _offset(offset), _next(NULL) {}\n+    _location(location), _offset(offset), _next(nullptr) {}\n@@ -898,1 +898,1 @@\n-DerivedPointerTable::Entry::List* DerivedPointerTable::Entry::_list = NULL;\n+DerivedPointerTable::Entry::List* DerivedPointerTable::Entry::_list = nullptr;\n@@ -902,1 +902,1 @@\n-  return Entry::_list == NULL || Entry::_list->empty();\n+  return Entry::_list == nullptr || Entry::_list->empty();\n@@ -911,1 +911,1 @@\n-  if (Entry::_list == NULL) {\n+  if (Entry::_list == nullptr) {\n@@ -924,1 +924,1 @@\n-  assert(Entry::_list != NULL, \"list must exist\");\n+  assert(Entry::_list != nullptr, \"list must exist\");\n@@ -946,1 +946,1 @@\n-  assert(Entry::_list != NULL, \"list must exist\");\n+  assert(Entry::_list != nullptr, \"list must exist\");\n@@ -948,1 +948,1 @@\n-  while (entries != NULL) {\n+  while (entries != nullptr) {\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,1 +233,1 @@\n-  \/\/ Methods oops_do() and all_do() filter out NULL oops and\n+  \/\/ Methods oops_do() and all_do() filter out nullptr oops and\n@@ -407,1 +407,1 @@\n-    Mapping() : _kind(OOPMAP_UNKNOWN), _offset(-1), _size(-1), _map(NULL) {}\n+    Mapping() : _kind(OOPMAP_UNKNOWN), _offset(-1), _size(-1), _map(nullptr) {}\n@@ -430,1 +430,1 @@\n-    if (_last != NULL && _last->count() > 0 && _last->equals(map)) {\n+    if (_last != nullptr && _last->count() > 0 && _last->equals(map)) {\n","filename":"src\/hotspot\/share\/compiler\/oopMap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-  return val == (oop)NULL || CompressedOops::is_base(val);\n+  return val == (oop)nullptr || CompressedOops::is_base(val);\n@@ -58,1 +58,1 @@\n-  assert(fr != NULL, \"\");\n+  assert(fr != nullptr, \"\");\n@@ -79,1 +79,1 @@\n-      DEBUG_ONLY(if (loc == NULL && reg_map->should_skip_missing()) continue;)\n+      DEBUG_ONLY(if (loc == nullptr && reg_map->should_skip_missing()) continue;)\n@@ -81,1 +81,1 @@\n-      if (loc == NULL) {\n+      if (loc == nullptr) {\n@@ -85,1 +85,1 @@\n-      guarantee(loc != NULL, \"missing saved register\");\n+      guarantee(loc != nullptr, \"missing saved register\");\n@@ -88,1 +88,1 @@\n-      \/\/ Ignore NULL oops and decoded NULL narrow oops which\n+      \/\/ Ignore nullptr oops and decoded nullptr narrow oops which\n@@ -91,1 +91,1 @@\n-      \/\/ The narrow_oop_base could be NULL or be the address\n+      \/\/ The narrow_oop_base could be nullptr or be the address\n@@ -93,1 +93,1 @@\n-      if (base_loc != NULL && *base_loc != (oop)NULL && !CompressedOops::is_base(*base_loc)) {\n+      if (base_loc != nullptr && *base_loc != (oop)nullptr && !CompressedOops::is_base(*base_loc)) {\n@@ -111,1 +111,1 @@\n-      if (loc == NULL) {\n+      if (loc == nullptr) {\n@@ -119,1 +119,1 @@\n-      if (loc == NULL) {\n+      if (loc == nullptr) {\n@@ -123,1 +123,1 @@\n-      guarantee(loc != NULL, \"missing saved register\");\n+      guarantee(loc != nullptr, \"missing saved register\");\n@@ -127,1 +127,1 @@\n-          \/\/ Ignore NULL oops and decoded NULL narrow oops which\n+          \/\/ Ignore nullptr oops and decoded nullptr narrow oops which\n@@ -130,1 +130,1 @@\n-          \/\/ The narrow_oop_base could be NULL or be the address\n+          \/\/ The narrow_oop_base could be nullptr or be the address\n","filename":"src\/hotspot\/share\/compiler\/oopMap.inline.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +60,1 @@\n-  virtual Name kind() const {\n+  Name kind() const override {\n@@ -63,1 +64,1 @@\n-  virtual const char* name() const {\n+  const char* name() const override {\n@@ -67,1 +68,1 @@\n-  virtual SoftRefPolicy* soft_ref_policy() {\n+  SoftRefPolicy* soft_ref_policy() override {\n@@ -71,2 +72,2 @@\n-  virtual jint initialize();\n-  virtual void initialize_serviceability();\n+  jint initialize() override;\n+  void initialize_serviceability() override;\n@@ -74,2 +75,2 @@\n-  virtual GrowableArray<GCMemoryManager*> memory_managers();\n-  virtual GrowableArray<MemoryPool*> memory_pools();\n+  GrowableArray<GCMemoryManager*> memory_managers() override;\n+  GrowableArray<MemoryPool*> memory_pools() override;\n@@ -77,3 +78,3 @@\n-  virtual size_t max_capacity() const { return _virtual_space.reserved_size();  }\n-  virtual size_t capacity()     const { return _virtual_space.committed_size(); }\n-  virtual size_t used()         const { return _space->used(); }\n+  size_t max_capacity() const override { return _virtual_space.reserved_size();  }\n+  size_t capacity()     const override { return _virtual_space.committed_size(); }\n+  size_t used()         const override { return _space->used(); }\n@@ -81,1 +82,1 @@\n-  virtual bool is_in(const void* p) const {\n+  bool is_in(const void* p) const override {\n@@ -85,1 +86,1 @@\n-  virtual bool requires_barriers(stackChunkOop obj) const { return false; }\n+  bool requires_barriers(stackChunkOop obj) const override { return false; }\n@@ -87,1 +88,1 @@\n-  virtual bool is_maximal_no_gc() const {\n+  bool is_maximal_no_gc() const override {\n@@ -94,4 +95,4 @@\n-  virtual HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded);\n-  virtual HeapWord* allocate_new_tlab(size_t min_size,\n-                                      size_t requested_size,\n-                                      size_t* actual_size);\n+  HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) override;\n+  HeapWord* allocate_new_tlab(size_t min_size,\n+                              size_t requested_size,\n+                              size_t* actual_size) override;\n@@ -100,4 +101,4 @@\n-  virtual size_t tlab_capacity(Thread* thr)         const { return capacity();     }\n-  virtual size_t tlab_used(Thread* thr)             const { return used();         }\n-  virtual size_t max_tlab_size()                    const { return _max_tlab_size; }\n-  virtual size_t unsafe_max_tlab_alloc(Thread* thr) const;\n+  size_t tlab_capacity(Thread* thr)         const override { return capacity();     }\n+  size_t tlab_used(Thread* thr)             const override { return used();         }\n+  size_t max_tlab_size()                    const override { return _max_tlab_size; }\n+  size_t unsafe_max_tlab_alloc(Thread* thr) const override;\n@@ -105,2 +106,2 @@\n-  virtual void collect(GCCause::Cause cause);\n-  virtual void do_full_collection(bool clear_all_soft_refs);\n+  void collect(GCCause::Cause cause) override;\n+  void do_full_collection(bool clear_all_soft_refs) override;\n@@ -109,1 +110,1 @@\n-  virtual void object_iterate(ObjectClosure* cl);\n+  void object_iterate(ObjectClosure* cl) override;\n@@ -112,3 +113,2 @@\n-  virtual bool supports_object_pinning() const           { return true; }\n-  virtual oop pin_object(JavaThread* thread, oop obj)    { return obj; }\n-  virtual void unpin_object(JavaThread* thread, oop obj) { }\n+  void pin_object(JavaThread* thread, oop obj) override { }\n+  void unpin_object(JavaThread* thread, oop obj) override { }\n@@ -121,1 +121,1 @@\n-  virtual void gc_threads_do(ThreadClosure* tc) const {}\n+  void gc_threads_do(ThreadClosure* tc) const override {}\n@@ -124,3 +124,3 @@\n-  virtual void register_nmethod(nmethod* nm) {}\n-  virtual void unregister_nmethod(nmethod* nm) {}\n-  virtual void verify_nmethod(nmethod* nm) {}\n+  void register_nmethod(nmethod* nm) override {}\n+  void unregister_nmethod(nmethod* nm) override {}\n+  void verify_nmethod(nmethod* nm) override {}\n@@ -129,2 +129,2 @@\n-  virtual void prepare_for_verify() {}\n-  virtual void verify(VerifyOption option) {}\n+  void prepare_for_verify() override {}\n+  void verify(VerifyOption option) override {}\n@@ -136,2 +136,2 @@\n-  virtual bool can_load_archived_objects() const { return UseCompressedOops; }\n-  virtual HeapWord* allocate_loaded_archive_space(size_t size);\n+  bool can_load_archived_objects() const override { return UseCompressedOops; }\n+  HeapWord* allocate_loaded_archive_space(size_t size) override;\n@@ -139,3 +139,3 @@\n-  virtual void print_on(outputStream* st) const;\n-  virtual void print_tracing_info() const;\n-  virtual bool print_location(outputStream* st, void* addr) const;\n+  void print_on(outputStream* st) const override;\n+  void print_tracing_info() const override;\n+  bool print_location(outputStream* st, void* addr) const override;\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.hpp","additions":38,"deletions":38,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-#include \"gc\/shared\/gcLocker.hpp\"\n+#include \"gc\/shared\/gcLocker.inline.hpp\"\n@@ -2402,0 +2402,8 @@\n+void G1CollectedHeap::pin_object(JavaThread* thread, oop obj) {\n+  GCLocker::lock_critical(thread);\n+}\n+\n+void G1CollectedHeap::unpin_object(JavaThread* thread, oop obj) {\n+  GCLocker::unlock_critical(thread);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1315,0 +1315,3 @@\n+  void pin_object(JavaThread* thread, oop obj) override;\n+  void unpin_object(JavaThread* thread, oop obj) override;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-#include \"gc\/shared\/gcLocker.hpp\"\n+#include \"gc\/shared\/gcLocker.inline.hpp\"\n@@ -863,0 +863,8 @@\n+\n+void ParallelScavengeHeap::pin_object(JavaThread* thread, oop obj) {\n+  GCLocker::lock_critical(thread);\n+}\n+\n+void ParallelScavengeHeap::unpin_object(JavaThread* thread, oop obj) {\n+  GCLocker::unlock_critical(thread);\n+}\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-  virtual void initialize_serviceability();\n+  void initialize_serviceability() override;\n@@ -99,1 +99,1 @@\n-  void trace_heap(GCWhen::Type when, const GCTracer* tracer);\n+  void trace_heap(GCWhen::Type when, const GCTracer* tracer) override;\n@@ -106,1 +106,1 @@\n-  HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size);\n+  HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size) override;\n@@ -129,1 +129,1 @@\n-  virtual Name kind() const {\n+  Name kind() const override {\n@@ -133,1 +133,1 @@\n-  virtual const char* name() const {\n+  const char* name() const override {\n@@ -137,1 +137,1 @@\n-  virtual SoftRefPolicy* soft_ref_policy() { return &_soft_ref_policy; }\n+  SoftRefPolicy* soft_ref_policy() override { return &_soft_ref_policy; }\n@@ -139,2 +139,2 @@\n-  virtual GrowableArray<GCMemoryManager*> memory_managers();\n-  virtual GrowableArray<MemoryPool*> memory_pools();\n+  GrowableArray<GCMemoryManager*> memory_managers() override;\n+  GrowableArray<MemoryPool*> memory_pools() override;\n@@ -145,1 +145,1 @@\n-  virtual PSAdaptiveSizePolicy* size_policy() { return _size_policy; }\n+  PSAdaptiveSizePolicy* size_policy() { return _size_policy; }\n@@ -157,1 +157,1 @@\n-  virtual jint initialize();\n+  jint initialize() override;\n@@ -159,2 +159,2 @@\n-  virtual void safepoint_synchronize_begin();\n-  virtual void safepoint_synchronize_end();\n+  void safepoint_synchronize_begin() override;\n+  void safepoint_synchronize_end() override;\n@@ -162,1 +162,1 @@\n-  void post_initialize();\n+  void post_initialize() override;\n@@ -165,2 +165,2 @@\n-  size_t capacity() const;\n-  size_t used() const;\n+  size_t capacity() const override;\n+  size_t used() const override;\n@@ -171,1 +171,1 @@\n-  virtual bool is_maximal_no_gc() const;\n+  bool is_maximal_no_gc() const override;\n@@ -173,3 +173,3 @@\n-  virtual void register_nmethod(nmethod* nm);\n-  virtual void unregister_nmethod(nmethod* nm);\n-  virtual void verify_nmethod(nmethod* nm);\n+  void register_nmethod(nmethod* nm) override;\n+  void unregister_nmethod(nmethod* nm) override;\n+  void verify_nmethod(nmethod* nm) override;\n@@ -179,1 +179,1 @@\n-  size_t max_capacity() const;\n+  size_t max_capacity() const override;\n@@ -182,1 +182,1 @@\n-  bool is_in(const void* p) const;\n+  bool is_in(const void* p) const override;\n@@ -188,1 +188,1 @@\n-  virtual bool requires_barriers(stackChunkOop obj) const;\n+  bool requires_barriers(stackChunkOop obj) const override;\n@@ -198,1 +198,1 @@\n-  HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded);\n+  HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) override;\n@@ -206,1 +206,1 @@\n-  void collect(GCCause::Cause cause);\n+  void collect(GCCause::Cause cause) override;\n@@ -218,1 +218,1 @@\n-  virtual void do_full_collection(bool clear_all_soft_refs);\n+  void do_full_collection(bool clear_all_soft_refs) override;\n@@ -220,2 +220,2 @@\n-  void ensure_parsability(bool retire_tlabs);\n-  void resize_all_tlabs();\n+  void ensure_parsability(bool retire_tlabs) override;\n+  void resize_all_tlabs() override;\n@@ -223,3 +223,3 @@\n-  size_t tlab_capacity(Thread* thr) const;\n-  size_t tlab_used(Thread* thr) const;\n-  size_t unsafe_max_tlab_alloc(Thread* thr) const;\n+  size_t tlab_capacity(Thread* thr) const override;\n+  size_t tlab_used(Thread* thr) const override;\n+  size_t unsafe_max_tlab_alloc(Thread* thr) const override;\n@@ -227,1 +227,1 @@\n-  void object_iterate(ObjectClosure* cl);\n+  void object_iterate(ObjectClosure* cl) override;\n@@ -229,1 +229,1 @@\n-  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint thread_num);\n+  ParallelObjectIteratorImpl* parallel_object_iterator(uint thread_num) override;\n@@ -234,1 +234,1 @@\n-  void prepare_for_verify();\n+  void prepare_for_verify() override;\n@@ -236,4 +236,4 @@\n-  virtual void print_on(outputStream* st) const;\n-  virtual void print_on_error(outputStream* st) const;\n-  virtual void gc_threads_do(ThreadClosure* tc) const;\n-  virtual void print_tracing_info() const;\n+  void print_on(outputStream* st) const override;\n+  void print_on_error(outputStream* st) const override;\n+  void gc_threads_do(ThreadClosure* tc) const override;\n+  void print_tracing_info() const override;\n@@ -241,1 +241,1 @@\n-  virtual WorkerThreads* safepoint_workers() { return &_workers; }\n+  WorkerThreads* safepoint_workers() override { return &_workers; }\n@@ -247,1 +247,1 @@\n-  virtual bool print_location(outputStream* st, void* addr) const;\n+  bool print_location(outputStream* st, void* addr) const override;\n@@ -249,1 +249,1 @@\n-  void verify(VerifyOption option \/* ignored *\/);\n+  void verify(VerifyOption option \/* ignored *\/) override;\n@@ -273,3 +273,6 @@\n-  bool can_load_archived_objects() const { return UseCompressedOops; }\n-  HeapWord* allocate_loaded_archive_space(size_t size);\n-  void complete_loaded_archive_space(MemRegion archive_space);\n+  bool can_load_archived_objects() const override { return UseCompressedOops; }\n+  HeapWord* allocate_loaded_archive_space(size_t size) override;\n+  void complete_loaded_archive_space(MemRegion archive_space) override;\n+\n+  void pin_object(JavaThread* thread, oop obj) override;\n+  void unpin_object(JavaThread* thread, oop obj) override;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":47,"deletions":44,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -230,1 +230,2 @@\n-  totally_drain = totally_drain || (_target_stack_size == 0);\n+  const uint threshold = totally_drain ? 0\n+                                       : _target_stack_size;\n@@ -239,9 +240,1 @@\n-      process_popped_location_depth(task);\n-    }\n-\n-    if (totally_drain) {\n-      while (tq->pop_local(task)) {\n-        process_popped_location_depth(task);\n-      }\n-    } else {\n-      while (tq->size() > _target_stack_size && tq->pop_local(task)) {\n+      if (!tq->try_push_to_taskqueue(task)) {\n@@ -251,1 +244,5 @@\n-  } while ((totally_drain && !tq->taskqueue_empty()) || !tq->overflow_empty());\n+\n+    while (tq->pop_local(task, threshold)) {\n+      process_popped_location_depth(task);\n+    }\n+  } while (!tq->overflow_empty());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -775,7 +775,0 @@\n-void DefNewGeneration::reset_saved_marks() {\n-  eden()->reset_saved_mark();\n-  to()->reset_saved_mark();\n-  from()->reset_saved_mark();\n-}\n-\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n-  void reset_saved_marks();\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -239,7 +239,0 @@\n-\n-  \/\/ It is not required that we traverse spaces in the same order in\n-  \/\/ phase2, phase3 and phase4, but the ValidateMarkSweep live oops\n-  \/\/ tracking expects us to do so. See comment under phase4.\n-\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n-\n@@ -248,1 +241,1 @@\n-  gch->prepare_for_compaction();\n+  GenCollectedHeap::heap()->prepare_for_compaction();\n@@ -289,12 +282,0 @@\n-\n-  \/\/ It is imperative that we traverse perm_gen first in phase4. All\n-  \/\/ classes must be allocated earlier than their instances, and traversing\n-  \/\/ perm_gen first makes sure that all Klass*s have moved to their new\n-  \/\/ location before any instance does a dispatch through it's klass!\n-\n-  \/\/ The ValidateMarkSweep live oops tracking expects us to traverse spaces\n-  \/\/ in the same order in phase2, phase3 and phase4. We don't quite do that\n-  \/\/ here (perm_gen first rather than last), so we tell the validate code\n-  \/\/ to use a higher index (saved from phase2) when verifying perm_gen.\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n-\n@@ -304,1 +285,1 @@\n-  gch->generation_iterate(&blk, true);\n+  GenCollectedHeap::heap()->generation_iterate(&blk, true);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/gcLocker.inline.hpp\"\n@@ -126,0 +127,8 @@\n+\n+void SerialHeap::pin_object(JavaThread* thread, oop obj) {\n+  GCLocker::lock_critical(thread);\n+}\n+\n+void SerialHeap::unpin_object(JavaThread* thread, oop obj) {\n+  GCLocker::unlock_critical(thread);\n+}\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-  virtual void initialize_serviceability();\n+  void initialize_serviceability() override;\n@@ -71,1 +71,1 @@\n-  virtual Name kind() const {\n+  Name kind() const override {\n@@ -75,1 +75,1 @@\n-  virtual const char* name() const {\n+  const char* name() const override {\n@@ -79,2 +79,2 @@\n-  virtual GrowableArray<GCMemoryManager*> memory_managers();\n-  virtual GrowableArray<MemoryPool*> memory_pools();\n+  GrowableArray<GCMemoryManager*> memory_managers() override;\n+  GrowableArray<MemoryPool*> memory_pools() override;\n@@ -104,2 +104,2 @@\n-  virtual void safepoint_synchronize_begin();\n-  virtual void safepoint_synchronize_end();\n+  void safepoint_synchronize_begin() override;\n+  void safepoint_synchronize_end() override;\n@@ -108,3 +108,6 @@\n-  bool can_load_archived_objects() const { return UseCompressedOops; }\n-  HeapWord* allocate_loaded_archive_space(size_t size);\n-  void complete_loaded_archive_space(MemRegion archive_space);\n+  bool can_load_archived_objects() const override { return UseCompressedOops; }\n+  HeapWord* allocate_loaded_archive_space(size_t size) override;\n+  void complete_loaded_archive_space(MemRegion archive_space) override;\n+\n+  void pin_object(JavaThread* thread, oop obj) override;\n+  void unpin_object(JavaThread* thread, oop obj) override;\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -503,4 +503,0 @@\n-void TenuredGeneration::reset_saved_marks() {\n-  _the_space->reset_saved_mark();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-  void reset_saved_marks();\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,3 +88,0 @@\n-  bool in_native = (decorators & IN_NATIVE) != 0;\n-  assert(!in_native || (unsafe && !access.is_oop()), \"not supported yet\");\n-\n@@ -147,2 +144,0 @@\n-  bool in_native = (decorators & IN_NATIVE) != 0;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -638,13 +638,0 @@\n-bool CollectedHeap::supports_object_pinning() const {\n-  return false;\n-}\n-\n-oop CollectedHeap::pin_object(JavaThread* thread, oop obj) {\n-  ShouldNotReachHere();\n-  return NULL;\n-}\n-\n-void CollectedHeap::unpin_object(JavaThread* thread, oop obj) {\n-  ShouldNotReachHere();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -504,5 +504,5 @@\n-  \/\/ and Release*Critical() family of functions. If supported, the GC\n-  \/\/ must guarantee that pinned objects never move.\n-  virtual bool supports_object_pinning() const;\n-  virtual oop pin_object(JavaThread* thread, oop obj);\n-  virtual void unpin_object(JavaThread* thread, oop obj);\n+  \/\/ and Release*Critical() family of functions. The GC must guarantee\n+  \/\/ that pinned objects never move and don't get reclaimed as garbage.\n+  \/\/ These functions are potentially safepointing.\n+  virtual void pin_object(JavaThread* thread, oop obj) = 0;\n+  virtual void unpin_object(JavaThread* thread, oop obj) = 0;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -109,7 +109,0 @@\n-  \/\/ While there are no constraints in the GC code that HeapWordSize\n-  \/\/ be any particular value, there are multiple other areas in the\n-  \/\/ system which believe this to be true (e.g. oop->object_size in some\n-  \/\/ cases incorrectly returns the size in wordSize units rather than\n-  \/\/ HeapWordSize).\n-  guarantee(HeapWordSize == wordSize, \"HeapWordSize must equal wordSize\");\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-  virtual void do_full_collection(bool clear_all_soft_refs);\n+  void do_full_collection(bool clear_all_soft_refs) override;\n@@ -142,1 +142,1 @@\n-  virtual jint initialize();\n+  jint initialize() override;\n@@ -150,1 +150,1 @@\n-  void post_initialize();\n+  void post_initialize() override;\n@@ -164,1 +164,1 @@\n-  virtual SoftRefPolicy* soft_ref_policy() { return &_soft_ref_gen_policy; }\n+  SoftRefPolicy* soft_ref_policy() override { return &_soft_ref_gen_policy; }\n@@ -174,2 +174,2 @@\n-  size_t capacity() const;\n-  size_t used() const;\n+  size_t capacity() const override;\n+  size_t used() const override;\n@@ -180,1 +180,1 @@\n-  size_t max_capacity() const;\n+  size_t max_capacity() const override;\n@@ -182,1 +182,1 @@\n-  HeapWord* mem_allocate(size_t size, bool*  gc_overhead_limit_was_exceeded);\n+  HeapWord* mem_allocate(size_t size, bool*  gc_overhead_limit_was_exceeded) override;\n@@ -187,1 +187,1 @@\n-  virtual void collect(GCCause::Cause cause);\n+  void collect(GCCause::Cause cause) override;\n@@ -193,1 +193,1 @@\n-  bool is_in(const void* p) const;\n+  bool is_in(const void* p) const override;\n@@ -199,1 +199,1 @@\n-  virtual bool requires_barriers(stackChunkOop obj) const;\n+  bool requires_barriers(stackChunkOop obj) const override;\n@@ -206,3 +206,3 @@\n-  virtual void register_nmethod(nmethod* nm);\n-  virtual void unregister_nmethod(nmethod* nm);\n-  virtual void verify_nmethod(nmethod* nm);\n+  void register_nmethod(nmethod* nm) override;\n+  void unregister_nmethod(nmethod* nm) override;\n+  void verify_nmethod(nmethod* nm) override;\n@@ -214,1 +214,1 @@\n-  void object_iterate(ObjectClosure* cl);\n+  void object_iterate(ObjectClosure* cl) override;\n@@ -239,6 +239,6 @@\n-  virtual size_t tlab_capacity(Thread* thr) const;\n-  virtual size_t tlab_used(Thread* thr) const;\n-  virtual size_t unsafe_max_tlab_alloc(Thread* thr) const;\n-  virtual HeapWord* allocate_new_tlab(size_t min_size,\n-                                      size_t requested_size,\n-                                      size_t* actual_size);\n+  size_t tlab_capacity(Thread* thr) const override;\n+  size_t tlab_used(Thread* thr) const override;\n+  size_t unsafe_max_tlab_alloc(Thread* thr) const override;\n+  HeapWord* allocate_new_tlab(size_t min_size,\n+                              size_t requested_size,\n+                              size_t* actual_size) override;\n@@ -257,2 +257,2 @@\n-  \/\/ Ensure parsability: override\n-  virtual void ensure_parsability(bool retire_tlabs);\n+  \/\/ Ensure parsability\n+  void ensure_parsability(bool retire_tlabs) override;\n@@ -277,2 +277,2 @@\n-  \/\/ Override.\n-  void prepare_for_verify();\n+  void prepare_for_verify() override;\n+  void verify(VerifyOption option) override;\n@@ -280,7 +280,3 @@\n-  \/\/ Override.\n-  void verify(VerifyOption option);\n-\n-  \/\/ Override.\n-  virtual void print_on(outputStream* st) const;\n-  virtual void gc_threads_do(ThreadClosure* tc) const;\n-  virtual void print_tracing_info() const;\n+  void print_on(outputStream* st) const override;\n+  void gc_threads_do(ThreadClosure* tc) const override;\n+  void print_tracing_info() const override;\n@@ -289,1 +285,1 @@\n-  virtual bool print_location(outputStream* st, void* addr) const;\n+  bool print_location(outputStream* st, void* addr) const override;\n@@ -309,1 +305,1 @@\n-  virtual bool is_maximal_no_gc() const;\n+  virtual bool is_maximal_no_gc() const override;\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":31,"deletions":35,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -336,4 +336,0 @@\n-  \/\/ This function allows generations to initialize any \"saved marks\".  That\n-  \/\/ is, should only be called when the generation is empty.\n-  virtual void reset_saved_marks() {}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"metaprogramming\/conditional.hpp\"\n@@ -365,1 +364,1 @@\n-  typedef typename Conditional<std::is_const<Storage>::value, const Block*, Block*>::type BlockPtr;\n+  using BlockPtr = std::conditional_t<std::is_const<Storage>::value, const Block*, Block*>;\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+#include <type_traits>\n+\n@@ -170,3 +172,1 @@\n-  typedef typename Conditional<is_const,\n-                               const OopStorage*,\n-                               OopStorage*>::type StoragePtr;\n+  using StoragePtr = std::conditional_t<is_const, const OopStorage*, OopStorage*>;\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageParState.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"metaprogramming\/conditional.hpp\"\n@@ -34,0 +33,2 @@\n+#include <type_traits>\n+\n@@ -59,1 +60,1 @@\n-    typedef typename Conditional<is_const, const Block*, Block*>::type BlockPtr;\n+    using BlockPtr = std::conditional_t<is_const, const Block*, Block*>;\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageParState.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -568,0 +568,2 @@\n+        Op_VectorizedHashCode,\n+        { { 2, ShenandoahLoad },                  { -1, ShenandoahNone } },\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -485,0 +485,1 @@\n+         cause == GCCause::_wb_young_gc ||\n@@ -488,1 +489,1 @@\n-         \"only requested GCs here\");\n+         \"only requested GCs here: %s\", GCCause::to_string(cause));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1919,1 +1920,1 @@\n-oop ShenandoahHeap::pin_object(JavaThread* thr, oop o) {\n+void ShenandoahHeap::pin_object(JavaThread* thr, oop o) {\n@@ -1921,1 +1922,0 @@\n-  return o;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,2 +147,2 @@\n-  const char* name()          const { return \"Shenandoah\"; }\n-  ShenandoahHeap::Name kind() const { return CollectedHeap::Shenandoah; }\n+  const char* name()          const override { return \"Shenandoah\"; }\n+  ShenandoahHeap::Name kind() const override { return CollectedHeap::Shenandoah; }\n@@ -150,2 +151,2 @@\n-  jint initialize();\n-  void post_initialize();\n+  jint initialize() override;\n+  void post_initialize() override;\n@@ -155,1 +156,1 @@\n-  void initialize_serviceability();\n+  void initialize_serviceability() override;\n@@ -157,3 +158,3 @@\n-  void print_on(outputStream* st)              const;\n-  void print_extended_on(outputStream *st)     const;\n-  void print_tracing_info()                    const;\n+  void print_on(outputStream* st)              const override;\n+  void print_extended_on(outputStream *st)     const override;\n+  void print_tracing_info()                    const override;\n@@ -162,1 +163,1 @@\n-  void stop();\n+  void stop() override;\n@@ -164,2 +165,2 @@\n-  void prepare_for_verify();\n-  void verify(VerifyOption vo);\n+  void prepare_for_verify() override;\n+  void verify(VerifyOption vo) override;\n@@ -168,1 +169,1 @@\n-  bool supports_concurrent_gc_breakpoints() const {\n+  bool supports_concurrent_gc_breakpoints() const override {\n@@ -197,1 +198,1 @@\n-  size_t max_capacity()      const;\n+  size_t max_capacity()      const override;\n@@ -200,2 +201,2 @@\n-  size_t capacity()          const;\n-  size_t used()              const;\n+  size_t capacity()          const override;\n+  size_t used()              const override;\n@@ -218,1 +219,1 @@\n-  WorkerThreads* safepoint_workers();\n+  WorkerThreads* safepoint_workers() override;\n@@ -220,1 +221,1 @@\n-  void gc_threads_do(ThreadClosure* tcl) const;\n+  void gc_threads_do(ThreadClosure* tcl) const override;\n@@ -420,8 +421,8 @@\n-  ShenandoahMonitoringSupport* monitoring_support() { return _monitoring_support;    }\n-  GCMemoryManager* cycle_memory_manager()           { return &_cycle_memory_manager; }\n-  GCMemoryManager* stw_memory_manager()             { return &_stw_memory_manager;   }\n-  SoftRefPolicy* soft_ref_policy()                  { return &_soft_ref_policy;      }\n-\n-  GrowableArray<GCMemoryManager*> memory_managers();\n-  GrowableArray<MemoryPool*> memory_pools();\n-  MemoryUsage memory_usage();\n+  ShenandoahMonitoringSupport* monitoring_support()          { return _monitoring_support;    }\n+  GCMemoryManager* cycle_memory_manager()                    { return &_cycle_memory_manager; }\n+  GCMemoryManager* stw_memory_manager()                      { return &_stw_memory_manager;   }\n+  SoftRefPolicy* soft_ref_policy()                  override { return &_soft_ref_policy;      }\n+\n+  GrowableArray<GCMemoryManager*> memory_managers() override;\n+  GrowableArray<MemoryPool*> memory_pools() override;\n+  MemoryUsage memory_usage() override;\n@@ -468,2 +469,1 @@\n-  AdaptiveSizePolicy* size_policy() shenandoah_not_implemented_return(NULL);\n-  bool is_maximal_no_gc() const shenandoah_not_implemented_return(false);\n+  bool is_maximal_no_gc() const override shenandoah_not_implemented_return(false);\n@@ -471,1 +471,1 @@\n-  bool is_in(const void* p) const;\n+  bool is_in(const void* p) const override;\n@@ -473,1 +473,1 @@\n-  bool requires_barriers(stackChunkOop obj) const;\n+  bool requires_barriers(stackChunkOop obj) const override;\n@@ -478,2 +478,2 @@\n-  void collect(GCCause::Cause cause);\n-  void do_full_collection(bool clear_all_soft_refs);\n+  void collect(GCCause::Cause cause) override;\n+  void do_full_collection(bool clear_all_soft_refs) override;\n@@ -484,1 +484,1 @@\n-  bool print_location(outputStream* st, void* addr) const;\n+  bool print_location(outputStream* st, void* addr) const override;\n@@ -487,1 +487,1 @@\n-  void object_iterate(ObjectClosure* cl);\n+  void object_iterate(ObjectClosure* cl) override;\n@@ -489,1 +489,1 @@\n-  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint workers);\n+  ParallelObjectIteratorImpl* parallel_object_iterator(uint workers) override;\n@@ -492,1 +492,1 @@\n-  void keep_alive(oop obj);\n+  void keep_alive(oop obj) override;\n@@ -497,2 +497,2 @@\n-  void safepoint_synchronize_begin();\n-  void safepoint_synchronize_end();\n+  void safepoint_synchronize_begin() override;\n+  void safepoint_synchronize_end() override;\n@@ -503,3 +503,3 @@\n-  void register_nmethod(nmethod* nm);\n-  void unregister_nmethod(nmethod* nm);\n-  void verify_nmethod(nmethod* nm) {}\n+  void register_nmethod(nmethod* nm) override;\n+  void unregister_nmethod(nmethod* nm) override;\n+  void verify_nmethod(nmethod* nm) override {}\n@@ -511,4 +511,2 @@\n-  bool supports_object_pinning() const { return true; }\n-\n-  oop pin_object(JavaThread* thread, oop obj);\n-  void unpin_object(JavaThread* thread, oop obj);\n+  void pin_object(JavaThread* thread, oop obj) override;\n+  void unpin_object(JavaThread* thread, oop obj) override;\n@@ -522,1 +520,1 @@\n-  bool uses_stack_watermark_barrier() const { return true; }\n+  bool uses_stack_watermark_barrier() const override { return true; }\n@@ -534,1 +532,1 @@\n-  HeapWord* mem_allocate(size_t size, bool* what);\n+  HeapWord* mem_allocate(size_t size, bool* what) override;\n@@ -537,1 +535,1 @@\n-                                               Metaspace::MetadataType mdtype);\n+                                               Metaspace::MetadataType mdtype) override;\n@@ -541,5 +539,5 @@\n-  HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size);\n-  size_t tlab_capacity(Thread *thr) const;\n-  size_t unsafe_max_tlab_alloc(Thread *thread) const;\n-  size_t max_tlab_size() const;\n-  size_t tlab_used(Thread* ignored) const;\n+  HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size) override;\n+  size_t tlab_capacity(Thread *thr) const override;\n+  size_t unsafe_max_tlab_alloc(Thread *thread) const override;\n+  size_t max_tlab_size() const override;\n+  size_t tlab_used(Thread* ignored) const override;\n@@ -547,1 +545,1 @@\n-  void ensure_parsability(bool retire_labs);\n+  void ensure_parsability(bool retire_labs) override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":51,"deletions":53,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/gcLocker.inline.hpp\"\n@@ -292,0 +293,8 @@\n+void ZCollectedHeap::pin_object(JavaThread* thread, oop obj) {\n+  GCLocker::lock_critical(thread);\n+}\n+\n+void ZCollectedHeap::unpin_object(JavaThread* thread, oop obj) {\n+  GCLocker::unlock_critical(thread);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,3 +53,3 @@\n-  virtual HeapWord* allocate_new_tlab(size_t min_size,\n-                                      size_t requested_size,\n-                                      size_t* actual_size);\n+  HeapWord* allocate_new_tlab(size_t min_size,\n+                              size_t requested_size,\n+                              size_t* actual_size) override;\n@@ -61,5 +61,5 @@\n-  virtual Name kind() const;\n-  virtual const char* name() const;\n-  virtual jint initialize();\n-  virtual void initialize_serviceability();\n-  virtual void stop();\n+  Name kind() const override;\n+  const char* name() const override;\n+  jint initialize() override;\n+  void initialize_serviceability() override;\n+  void stop() override;\n@@ -67,1 +67,1 @@\n-  virtual SoftRefPolicy* soft_ref_policy();\n+  SoftRefPolicy* soft_ref_policy() override;\n@@ -69,4 +69,4 @@\n-  virtual size_t max_capacity() const;\n-  virtual size_t capacity() const;\n-  virtual size_t used() const;\n-  virtual size_t unused() const;\n+  size_t max_capacity() const override;\n+  size_t capacity() const override;\n+  size_t used() const override;\n+  size_t unused() const override;\n@@ -74,3 +74,3 @@\n-  virtual bool is_maximal_no_gc() const;\n-  virtual bool is_in(const void* p) const;\n-  virtual bool requires_barriers(stackChunkOop obj) const;\n+  bool is_maximal_no_gc() const override;\n+  bool is_in(const void* p) const override;\n+  bool requires_barriers(stackChunkOop obj) const override;\n@@ -78,8 +78,8 @@\n-  virtual oop array_allocate(Klass* klass, size_t size, int length, bool do_zero, TRAPS);\n-  virtual HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded);\n-  virtual MetaWord* satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,\n-                                                       size_t size,\n-                                                       Metaspace::MetadataType mdtype);\n-  virtual void collect(GCCause::Cause cause);\n-  virtual void collect_as_vm_thread(GCCause::Cause cause);\n-  virtual void do_full_collection(bool clear_all_soft_refs);\n+  oop array_allocate(Klass* klass, size_t size, int length, bool do_zero, TRAPS) override;\n+  HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) override;\n+  MetaWord* satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,\n+                                               size_t size,\n+                                               Metaspace::MetadataType mdtype) override;\n+  void collect(GCCause::Cause cause) override;\n+  void collect_as_vm_thread(GCCause::Cause cause) override;\n+  void do_full_collection(bool clear_all_soft_refs) override;\n@@ -87,4 +87,4 @@\n-  virtual size_t tlab_capacity(Thread* thr) const;\n-  virtual size_t tlab_used(Thread* thr) const;\n-  virtual size_t max_tlab_size() const;\n-  virtual size_t unsafe_max_tlab_alloc(Thread* thr) const;\n+  size_t tlab_capacity(Thread* thr) const override;\n+  size_t tlab_used(Thread* thr) const override;\n+  size_t max_tlab_size() const override;\n+  size_t unsafe_max_tlab_alloc(Thread* thr) const override;\n@@ -92,1 +92,1 @@\n-  virtual bool uses_stack_watermark_barrier() const;\n+  bool uses_stack_watermark_barrier() const override;\n@@ -94,3 +94,3 @@\n-  virtual MemoryUsage memory_usage();\n-  virtual GrowableArray<GCMemoryManager*> memory_managers();\n-  virtual GrowableArray<MemoryPool*> memory_pools();\n+  MemoryUsage memory_usage() override;\n+  GrowableArray<GCMemoryManager*> memory_managers() override;\n+  GrowableArray<MemoryPool*> memory_pools() override;\n@@ -98,2 +98,2 @@\n-  virtual void object_iterate(ObjectClosure* cl);\n-  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint nworkers);\n+  void object_iterate(ObjectClosure* cl) override;\n+  ParallelObjectIteratorImpl* parallel_object_iterator(uint nworkers) override;\n@@ -101,1 +101,1 @@\n-  virtual void keep_alive(oop obj);\n+  void keep_alive(oop obj) override;\n@@ -103,3 +103,3 @@\n-  virtual void register_nmethod(nmethod* nm);\n-  virtual void unregister_nmethod(nmethod* nm);\n-  virtual void verify_nmethod(nmethod* nmethod);\n+  void register_nmethod(nmethod* nm) override;\n+  void unregister_nmethod(nmethod* nm) override;\n+  void verify_nmethod(nmethod* nmethod) override;\n@@ -107,1 +107,1 @@\n-  virtual WorkerThreads* safepoint_workers();\n+  WorkerThreads* safepoint_workers() override;\n@@ -109,1 +109,1 @@\n-  virtual void gc_threads_do(ThreadClosure* tc) const;\n+  void gc_threads_do(ThreadClosure* tc) const override;\n@@ -111,1 +111,1 @@\n-  virtual VirtualSpaceSummary create_heap_space_summary();\n+  VirtualSpaceSummary create_heap_space_summary() override;\n@@ -113,2 +113,2 @@\n-  virtual void safepoint_synchronize_begin();\n-  virtual void safepoint_synchronize_end();\n+  void safepoint_synchronize_begin() override;\n+  void safepoint_synchronize_end() override;\n@@ -116,5 +116,2 @@\n-  virtual void print_on(outputStream* st) const;\n-  virtual void print_on_error(outputStream* st) const;\n-  virtual void print_extended_on(outputStream* st) const;\n-  virtual void print_tracing_info() const;\n-  virtual bool print_location(outputStream* st, void* addr) const;\n+  void pin_object(JavaThread* thread, oop obj) override;\n+  void unpin_object(JavaThread* thread, oop obj) override;\n@@ -122,4 +119,10 @@\n-  virtual void prepare_for_verify();\n-  virtual void verify(VerifyOption option \/* ignored *\/);\n-  virtual bool is_oop(oop object) const;\n-  virtual bool supports_concurrent_gc_breakpoints() const;\n+  void print_on(outputStream* st) const override;\n+  void print_on_error(outputStream* st) const override;\n+  void print_extended_on(outputStream* st) const override;\n+  void print_tracing_info() const override;\n+  bool print_location(outputStream* st, void* addr) const override;\n+\n+  void prepare_for_verify() override;\n+  void verify(VerifyOption option \/* ignored *\/) override;\n+  bool is_oop(oop object) const override;\n+  bool supports_concurrent_gc_breakpoints() const override;\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":56,"deletions":53,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -607,1 +607,1 @@\n-      THREAD->set_do_not_unlock();\n+      THREAD->set_do_not_unlock_if_synchronized(true);\n@@ -642,1 +642,1 @@\n-      THREAD->clr_do_not_unlock();\n+      THREAD->set_do_not_unlock_if_synchronized(false);\n@@ -3101,1 +3101,1 @@\n-    if (THREAD->do_not_unlock()) {\n+    if (THREAD->do_not_unlock_if_synchronized()) {\n@@ -3106,1 +3106,1 @@\n-      THREAD->clr_do_not_unlock();\n+      THREAD->set_do_not_unlock_if_synchronized(false);\n@@ -3232,1 +3232,1 @@\n-    THREAD->clr_do_not_unlock();\n+    THREAD->set_do_not_unlock_if_synchronized(false);\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -421,0 +421,2 @@\n+  assert(result != nullptr, \"invariant\");\n+  assert(result->get_oop() == nullptr, \"result not initialized\");\n@@ -435,0 +437,1 @@\n+  result->set_oop(nullptr); \/\/ Initialize result in case klass initialize throws.\n@@ -440,1 +443,1 @@\n-static void write_field(JfrJavaArguments* args, JavaValue* result, TRAPS) {\n+static void write_field(JfrJavaArguments* args, TRAPS) {\n@@ -442,1 +445,0 @@\n-  assert(result != NULL, \"invariant\");\n@@ -460,1 +462,1 @@\n-  write_field(args, args->result(), THREAD);\n+  write_field(args, THREAD);\n@@ -468,1 +470,1 @@\n-void JfrJavaSupport::get_field(JfrJavaArguments* args, Thread* thread) {\n+static void get_field_ref(JfrJavaArguments* args, bool local_ref, TRAPS) {\n@@ -470,7 +472,1 @@\n-  read_field(args, args->result(), thread);\n-}\n-\n-void JfrJavaSupport::get_field_local_ref(JfrJavaArguments* args, TRAPS) {\n-  assert(args != NULL, \"invariant\");\n-  DEBUG_ONLY(check_java_thread_in_vm(THREAD));\n-\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n@@ -480,1 +476,0 @@\n-\n@@ -483,3 +478,7 @@\n-\n-  if (obj != NULL) {\n-    result->set_jobject(local_jni_handle(obj, THREAD));\n+  if (obj == nullptr) {\n+    return;\n+  }\n+  if (local_ref) {\n+    result->set_jobject(JfrJavaSupport::local_jni_handle(obj, THREAD));\n+  } else {\n+    result->set_jobject(JfrJavaSupport::global_jni_handle(obj, THREAD));\n@@ -489,3 +488,3 @@\n-void JfrJavaSupport::get_field_global_ref(JfrJavaArguments* args, TRAPS) {\n-  assert(args != NULL, \"invariant\");\n-  DEBUG_ONLY(check_java_thread_in_vm(THREAD));\n+void JfrJavaSupport::get_field_local_ref(JfrJavaArguments* args, TRAPS) {\n+  get_field_ref(args, true \/* local_ref *\/, THREAD);\n+}\n@@ -493,8 +492,2 @@\n-  JavaValue* const result = args->result();\n-  assert(result != NULL, \"invariant\");\n-  assert(result->get_type() == T_OBJECT, \"invariant\");\n-  read_field(args, result, CHECK);\n-  const oop obj = result->get_oop();\n-  if (obj != NULL) {\n-    result->set_jobject(global_jni_handle(obj, THREAD));\n-  }\n+void JfrJavaSupport::get_field_global_ref(JfrJavaArguments* args, TRAPS) {\n+  get_field_ref(args, false \/* local_ref *\/, THREAD);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,0 @@\n-  static void get_field(JfrJavaArguments* args, Thread* thread);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -792,1 +792,3 @@\n-  <Event name=\"CPUInformation\" category=\"Operating System, Processor\" label=\"CPU Information\" period=\"endChunk\">\n+  <Event name=\"CPUInformation\" category=\"Operating System, Processor\" label=\"CPU Information\"\n+         description=\"Characteristics and descriptions of the processor(s) the JVM is running on\"\n+         period=\"endChunk\">\n@@ -800,1 +802,3 @@\n-  <Event name=\"CPUTimeStampCounter\" category=\"Operating System, Processor\" label=\"CPU Time Stamp Counter\" period=\"endChunk\">\n+  <Event name=\"CPUTimeStampCounter\" category=\"Operating System, Processor\" label=\"CPU Time Stamp Counter\"\n+         description=\"Information about the CPU time stamp mechanism \/ (RD)TSC\"\n+         period=\"endChunk\">\n@@ -807,1 +811,3 @@\n-  <Event name=\"CPULoad\" category=\"Operating System, Processor\" label=\"CPU Load\" description=\"OS CPU Load\" period=\"everyChunk\">\n+  <Event name=\"CPULoad\" category=\"Operating System, Processor\" label=\"CPU Load\"\n+         description=\"Information about the recent CPU usage of the JVM process\"\n+         period=\"everyChunk\">\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/stackWatermark.hpp\"\n@@ -259,0 +260,5 @@\n+  \/\/ Process the oops in the thread head before calling into code that wants to\n+  \/\/ stack walk over Loom continuations. The stack walking code will otherwise\n+  \/\/ skip frames in stack chunks on the Java heap.\n+  StackWatermarkSet::start_processing(thread, StackWatermarkKind::gc);\n+\n@@ -277,0 +283,5 @@\n+  \/\/ Process the oops in the thread head before calling into code that wants to\n+  \/\/ stack walk over Loom continuations. The stack walking code will otherwise\n+  \/\/ skip frames in stack chunks on the Java heap.\n+  StackWatermarkSet::start_processing(thread, StackWatermarkKind::gc);\n+\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -135,1 +135,3 @@\n-  assert(buffer != NULL, \"invariant\");\n+  if (buffer == nullptr) {\n+    return;\n+  }\n@@ -296,2 +298,3 @@\n-  assert(new_buffer != NULL, \"invariant\");\n-  migrate_outstanding_writes(old, new_buffer, used, requested);\n+  if (new_buffer != nullptr) {\n+    migrate_outstanding_writes(old, new_buffer, used, requested);\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"logging\/log.hpp\"\n@@ -59,1 +60,6 @@\n-  JfrJavaSupport::notify_all(get_chunk_monitor(thread), thread);\n+  jobject monitor = get_chunk_monitor(thread);\n+  if (monitor == nullptr) {\n+    log_error(jfr, system)(\"Unable to create chunk rotation monitor\");\n+    return;\n+  }\n+  JfrJavaSupport::notify_all(monitor, thread);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrChunkRotation.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -151,0 +151,12 @@\n+static RegisterMap::WalkContinuation walk_continuation(JavaThread* jt) {\n+  \/\/ NOTE: WalkContinuation::skip, because of interactions with ZGC relocation\n+  \/\/       and load barriers. This code is run while generating stack traces for\n+  \/\/       the ZPage allocation event, even when ZGC is relocating  objects.\n+  \/\/       When ZGC is relocating, it is forbidden to run code that performs\n+  \/\/       load barriers. With WalkContinuation::include, we visit heap stack\n+  \/\/       chunks and could be using load barriers.\n+  return (UseZGC && !StackWatermarkSet::processing_started(jt))\n+      ? RegisterMap::WalkContinuation::skip\n+      : RegisterMap::WalkContinuation::include;\n+}\n+\n@@ -155,1 +167,1 @@\n-                                 RegisterMap::WalkContinuation::include)),\n+                                 walk_continuation(jt))),\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-                         _context(0) {}\n+                         _context(0)\n+                         LP64_ONLY(COMMA _pad(0)) {}\n@@ -43,2 +44,3 @@\n-  _header_size = (u2)header_size;\n-  _size = (u4)(size \/ BytesPerWord);\n+  assert(header_size <= max_jushort, \"invariant\");\n+  _header_size = static_cast<u2>(header_size);\n+  _size = size;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrBuffer.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-  u4 _size;\n+  size_t _size;\n@@ -77,0 +77,1 @@\n+  LP64_ONLY(const u4 _pad;)\n@@ -128,1 +129,1 @@\n-    return _size * BytesPerWord;\n+    return _size;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrBuffer.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -205,0 +205,4 @@\n+  if (requested_size > static_cast<size_t>(min_intx)) {\n+    assert(false, \"requested size: \" SIZE_FORMAT \" is too large\", requested_size);\n+    return 0;\n+  }\n@@ -209,1 +213,2 @@\n-  return (size_t)alloc_size_bytes;\n+  assert(alloc_size_bytes <= static_cast<size_t>(min_intx), \"invariant\");\n+  return static_cast<size_t>(alloc_size_bytes);\n@@ -215,0 +220,3 @@\n+  if (aligned_size_bytes == 0) {\n+    return NULL;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrMemorySpace.inline.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+  assert(len <= max_jint, \"invariant\");\n@@ -128,2 +129,3 @@\n-  \/\/ Might need T + 1 size\n-  u1* const pos = ensure_size(sizeof(T) * len + len);\n+  assert(len <= max_jint, \"invariant\");\n+  \/\/ Big endian writes map one-to-one for length, so no extra space is needed.\n+  u1* const pos = ensure_size(sizeof(T) * len);\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrWriterHost.inline.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,1 +167,1 @@\n-    return (LogTargetImpl<LogLevel::level, T0, T1, T2, T3, T4, GuardTag>*)NULL; \\\n+    return (LogTargetImpl<LogLevel::level, T0, T1, T2, T3, T4, GuardTag>*)nullptr; \\\n","filename":"src\/hotspot\/share\/logging\/log.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-    \/\/ All readers of _instance after the fence see non-NULL.\n+    \/\/ All readers of _instance after the fence see non-nullptr.\n@@ -198,1 +198,1 @@\n-    for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+    for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-LogOutput** LogConfiguration::_outputs = NULL;\n+LogOutput** LogConfiguration::_outputs = nullptr;\n@@ -46,1 +46,1 @@\n-LogConfiguration::UpdateListenerFunction* LogConfiguration::_listener_callbacks = NULL;\n+LogConfiguration::UpdateListenerFunction* LogConfiguration::_listener_callbacks = nullptr;\n@@ -108,1 +108,1 @@\n-  assert(_outputs == NULL, \"Should not initialize _outputs before this function, initialize called twice?\");\n+  assert(_outputs == nullptr, \"Should not initialize _outputs before this function, initialize called twice?\");\n@@ -117,1 +117,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -132,1 +132,1 @@\n-  const bool quoted = start_quote != NULL;\n+  const bool quoted = start_quote != nullptr;\n@@ -137,1 +137,1 @@\n-    equals = NULL;\n+    equals = nullptr;\n@@ -143,1 +143,1 @@\n-  if (equals != NULL) {\n+  if (equals != nullptr) {\n@@ -156,1 +156,1 @@\n-    if (end_quote == NULL) {\n+    if (end_quote == nullptr) {\n@@ -193,1 +193,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -200,1 +200,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -248,1 +248,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -288,1 +288,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -306,1 +306,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -331,1 +331,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -379,1 +379,1 @@\n-    if (next != NULL && next[0] == ':' && (next[1] == '\\\\' || next[1] == '\/')) {\n+    if (next != nullptr && next[0] == ':' && (next[1] == '\\\\' || next[1] == '\/')) {\n@@ -385,1 +385,1 @@\n-    while (next != NULL && *next == '\"') {\n+    while (next != nullptr && *next == '\"') {\n@@ -387,1 +387,1 @@\n-      if (end_quote == NULL) {\n+      if (end_quote == nullptr) {\n@@ -396,1 +396,1 @@\n-    if (next != NULL) {\n+    if (next != nullptr) {\n@@ -400,1 +400,1 @@\n-      str = NULL;\n+      str = nullptr;\n@@ -405,1 +405,1 @@\n-  if (str != NULL) {\n+  if (str != nullptr) {\n@@ -426,1 +426,1 @@\n-  if (output == NULL || strlen(output) == 0 ||\n+  if (output == nullptr || strlen(output) == 0 ||\n@@ -432,1 +432,1 @@\n-      output_options = NULL;\n+      output_options = nullptr;\n@@ -441,1 +441,1 @@\n-      output_options = NULL;\n+      output_options = nullptr;\n@@ -459,1 +459,1 @@\n-    assert(end != NULL, \"line must end with newline '%s'\", start);\n+    assert(end != nullptr, \"line must end with newline '%s'\", start);\n@@ -468,2 +468,2 @@\n-      assert(end != NULL || *start == '\\0', \"line must end with newline '%s'\", start);\n-    } while (end != NULL);\n+      assert(end != nullptr || *start == '\\0', \"line must end with newline '%s'\", start);\n+    } while (end != nullptr);\n@@ -481,2 +481,2 @@\n-  assert(errstream != NULL, \"errstream can not be NULL\");\n-  if (outputstr == NULL || strlen(outputstr) == 0) {\n+  assert(errstream != nullptr, \"errstream can not be nullptr\");\n+  if (outputstr == nullptr || strlen(outputstr) == 0) {\n@@ -517,1 +517,1 @@\n-      if (output != NULL) {\n+      if (output != nullptr) {\n@@ -528,1 +528,1 @@\n-  if (!added && output_options != NULL && strlen(output_options) > 0) {\n+  if (!added && output_options != nullptr && strlen(output_options) > 0) {\n@@ -693,1 +693,1 @@\n-  assert(cb != NULL, \"Should not register NULL as listener\");\n+  assert(cb != nullptr, \"Should not register nullptr as listener\");\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-  \/\/ Create a new output. Returns NULL if failed.\n+  \/\/ Create a new output. Returns nullptr if failed.\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-const char* volatile LogDecorations::_host_name = NULL;\n+const char* volatile LogDecorations::_host_name = nullptr;\n@@ -38,1 +38,1 @@\n-  if (host_name == NULL) {\n+  if (host_name == nullptr) {\n@@ -42,2 +42,2 @@\n-      const char* old_value = Atomic::cmpxchg(&_host_name, (const char*)NULL, host_name);\n-      if (old_value != NULL) {\n+      const char* old_value = Atomic::cmpxchg(&_host_name, (const char*)nullptr, host_name);\n+      if (old_value != nullptr) {\n","filename":"src\/hotspot\/share\/logging\/logDecorations.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-  if (decorator_args == NULL || strlen(decorator_args) == 0) {\n+  if (decorator_args == nullptr || strlen(decorator_args) == 0) {\n@@ -76,1 +76,1 @@\n-    if (comma_pos != NULL) {\n+    if (comma_pos != nullptr) {\n@@ -81,1 +81,1 @@\n-      if (errstream != NULL) {\n+      if (errstream != nullptr) {\n@@ -89,1 +89,1 @@\n-  } while (comma_pos != NULL);\n+  } while (comma_pos != nullptr);\n","filename":"src\/hotspot\/share\/logging\/logDecorators.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,1 +116,1 @@\n-  bool parse(const char* decorator_args, outputStream* errstream = NULL);\n+  bool parse(const char* decorator_args, outputStream* errstream = nullptr);\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,2 +50,2 @@\n-  LogDiagnosticCommand* dcmd = new LogDiagnosticCommand(NULL, false);\n-  if (dcmd != NULL) {\n+  LogDiagnosticCommand* dcmd = new LogDiagnosticCommand(nullptr, false);\n+  if (dcmd != nullptr) {\n","filename":"src\/hotspot\/share\/logging\/logDiagnosticCommand.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"control\", NULL};\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"control\", nullptr};\n","filename":"src\/hotspot\/share\/logging\/logDiagnosticCommand.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,2 @@\n-    : LogFileStreamOutput(NULL), _name(os::strdup_check_oom(name, mtLogging)),\n-      _file_name(NULL), _archive_name(NULL), _current_file(0),\n+    : LogFileStreamOutput(nullptr), _name(os::strdup_check_oom(name, mtLogging)),\n+      _file_name(nullptr), _archive_name(nullptr), _current_file(0),\n@@ -75,1 +75,1 @@\n-  if (_stream != NULL) {\n+  if (_stream != nullptr) {\n@@ -241,1 +241,1 @@\n-  if (_stream == NULL) {\n+  if (_stream == nullptr) {\n@@ -270,1 +270,1 @@\n-  if (_stream == NULL) {\n+  if (_stream == nullptr) {\n@@ -290,1 +290,1 @@\n-  if (_stream == NULL) {\n+  if (_stream == nullptr) {\n@@ -305,1 +305,1 @@\n-  if (_stream == NULL) {\n+  if (_stream == nullptr) {\n@@ -330,1 +330,1 @@\n-  assert(_archive_name != NULL && _archive_name_len > 0, \"Rotation must be configured before using this function.\");\n+  assert(_archive_name != nullptr && _archive_name_len > 0, \"Rotation must be configured before using this function.\");\n@@ -367,1 +367,1 @@\n-  if (_stream == NULL) {\n+  if (_stream == nullptr) {\n@@ -381,1 +381,1 @@\n-  char* result = NULL;\n+  char* result = nullptr;\n@@ -388,1 +388,1 @@\n-  if (pid == NULL && timestamp == NULL) {\n+  if (pid == nullptr && timestamp == nullptr) {\n@@ -403,2 +403,2 @@\n-  if (pid != NULL) {\n-    if (timestamp == NULL || pid < timestamp) {\n+  if (pid != nullptr) {\n+    if (timestamp == nullptr || pid < timestamp) {\n@@ -415,2 +415,2 @@\n-  if (timestamp != NULL) {\n-    if (pid == NULL || timestamp < pid) {\n+  if (timestamp != nullptr) {\n+    if (pid == nullptr || timestamp < pid) {\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,1 +137,1 @@\n-      if (next == NULL) {\n+      if (next == nullptr) {\n@@ -145,1 +145,1 @@\n-    } while (next != NULL);\n+    } while (next != nullptr);\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-                                       _message_buffer(NULL),\n+                                       _message_buffer(nullptr),\n@@ -44,1 +44,1 @@\n-                                       _lines(NULL),\n+                                       _lines(nullptr),\n@@ -47,1 +47,1 @@\n-                                       _prefix_fn(NULL) {\n+                                       _prefix_fn(nullptr) {\n@@ -101,1 +101,1 @@\n-    if (_prefix_fn != NULL) {\n+    if (_prefix_fn != nullptr) {\n","filename":"src\/hotspot\/share\/logging\/logMessageBuffer.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,1 +112,1 @@\n-  \/\/ Setting this to NULL will disable prefixing.\n+  \/\/ Setting this to nullptr will disable prefixing.\n","filename":"src\/hotspot\/share\/logging\/logMessageBuffer.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-                                    LogTagType subset[LogTag::MaxTags] = NULL,\n+                                    LogTagType subset[LogTag::MaxTags] = nullptr,\n@@ -94,1 +94,1 @@\n-  if (subset == NULL) {\n+  if (subset == nullptr) {\n@@ -164,1 +164,1 @@\n-    for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+    for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -230,1 +230,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -262,1 +262,1 @@\n-      for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+      for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -288,1 +288,1 @@\n-    for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+    for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -326,1 +326,1 @@\n-  if (options == NULL || strlen(options) == 0) {\n+  if (options == nullptr || strlen(options) == 0) {\n@@ -336,1 +336,1 @@\n-    if (comma_pos != NULL) {\n+    if (comma_pos != nullptr) {\n@@ -340,1 +340,1 @@\n-    if (equals_pos == NULL) {\n+    if (equals_pos == nullptr) {\n@@ -358,1 +358,1 @@\n-  } while (comma_pos != NULL);\n+  } while (comma_pos != nullptr);\n","filename":"src\/hotspot\/share\/logging\/logOutput.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-  if (level == LogLevel::Off && node != NULL) {\n+  if (level == LogLevel::Off && node != nullptr) {\n@@ -58,1 +58,1 @@\n-  } else if (level != LogLevel::Off && node == NULL) {\n+  } else if (level != LogLevel::Off && node == nullptr) {\n@@ -60,1 +60,1 @@\n-  } else if (node != NULL) {\n+  } else if (node != nullptr) {\n@@ -66,1 +66,1 @@\n-  for (LogOutputNode* node = _level_start[LogLevel::Last]; node != NULL; node = node->_next) {\n+  for (LogOutputNode* node = _level_start[LogLevel::Last]; node != nullptr; node = node->_next) {\n@@ -71,1 +71,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -81,1 +81,1 @@\n-    _level_start[level] = NULL;\n+    _level_start[level] = nullptr;\n@@ -86,1 +86,1 @@\n-  while (cur != NULL) {\n+  while (cur != nullptr) {\n@@ -94,1 +94,1 @@\n-  assert(node != NULL, \"Node must be non-null\");\n+  assert(node != nullptr, \"Node must be non-null\");\n@@ -106,1 +106,1 @@\n-  for (LogOutputNode* cur = _level_start[LogLevel::Last]; cur != NULL; cur = cur->_next) {\n+  for (LogOutputNode* cur = _level_start[LogLevel::Last]; cur != nullptr; cur = cur->_next) {\n@@ -126,1 +126,1 @@\n-       node->_next != NULL && node->_next->_level == level;\n+       node->_next != nullptr && node->_next->_level == level;\n@@ -132,1 +132,1 @@\n-    if (_level_start[l] == NULL || _level_start[l]->_level < level) {\n+    if (_level_start[l] == nullptr || _level_start[l]->_level < level) {\n@@ -138,1 +138,1 @@\n-  for (LogOutputNode* cur = _level_start[LogLevel::Last]; cur != NULL; cur = cur->_next) {\n+  for (LogOutputNode* cur = _level_start[LogLevel::Last]; cur != nullptr; cur = cur->_next) {\n","filename":"src\/hotspot\/share\/logging\/logOutputList.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-      _level_start[i] = NULL;\n+      _level_start[i] = nullptr;\n@@ -76,1 +76,1 @@\n-    return _level_start[level] != NULL;\n+    return _level_start[level] != nullptr;\n@@ -81,1 +81,1 @@\n-    if (node == NULL) {\n+    if (node == nullptr) {\n@@ -145,1 +145,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/logging\/logOutputList.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -76,1 +76,1 @@\n-  if (equals != NULL) {\n+  if (equals != nullptr) {\n@@ -80,1 +80,1 @@\n-      if (errstream != NULL) {\n+      if (errstream != nullptr) {\n@@ -104,1 +104,1 @@\n-  if (asterisk_pos != NULL && asterisk_pos[1] == '\\0') {\n+  if (asterisk_pos != nullptr && asterisk_pos[1] == '\\0') {\n@@ -114,1 +114,1 @@\n-    if (plus_pos != NULL) {\n+    if (plus_pos != nullptr) {\n@@ -119,1 +119,1 @@\n-      if (errstream != NULL) {\n+      if (errstream != nullptr) {\n@@ -130,1 +130,1 @@\n-      if (errstream != NULL) {\n+      if (errstream != nullptr) {\n@@ -138,1 +138,1 @@\n-  } while (plus_pos != NULL);\n+  } while (plus_pos != nullptr);\n@@ -143,1 +143,1 @@\n-        if (errstream != NULL) {\n+        if (errstream != nullptr) {\n@@ -278,1 +278,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n","filename":"src\/hotspot\/share\/logging\/logSelection.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-  static LogSelection parse(const char* str, outputStream* error_stream = NULL);\n+  static LogSelection parse(const char* str, outputStream* error_stream = nullptr);\n","filename":"src\/hotspot\/share\/logging\/logSelection.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-      if (out == NULL) {\n+      if (out == nullptr) {\n@@ -59,1 +59,1 @@\n-  if (str == NULL || strcmp(str, \"\") == 0) {\n+  if (str == nullptr || strcmp(str, \"\") == 0) {\n@@ -64,1 +64,1 @@\n-  for (char *comma_pos = copy, *cur = copy; success && comma_pos != NULL; cur = comma_pos + 1) {\n+  for (char *comma_pos = copy, *cur = copy; success && comma_pos != nullptr; cur = comma_pos + 1) {\n@@ -66,1 +66,1 @@\n-      if (errstream != NULL) {\n+      if (errstream != nullptr) {\n@@ -75,1 +75,1 @@\n-    if (comma_pos != NULL) {\n+    if (comma_pos != nullptr) {\n","filename":"src\/hotspot\/share\/logging\/logSelectionList.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-  bool parse(const char* str, outputStream* errstream = NULL);\n+  bool parse(const char* str, outputStream* errstream = nullptr);\n@@ -62,1 +62,1 @@\n-  bool verify_selections(outputStream* out = NULL) const;\n+  bool verify_selections(outputStream* out = nullptr) const;\n","filename":"src\/hotspot\/share\/logging\/logSelectionList.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-  if (newbuf == NULL) { \/\/ OOM. Leave object unchanged.\n+  if (newbuf == nullptr) { \/\/ OOM. Leave object unchanged.\n","filename":"src\/hotspot\/share\/logging\/logStream.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n-  \/\/ Constructor to support creation from typed (likely NULL) pointer. Mostly used by the logging framework.\n+  \/\/ Constructor to support creation from typed (likely nullptr) pointer. Mostly used by the logging framework.\n@@ -107,1 +107,1 @@\n-  \/\/ LogStream stream((LogTargetImpl<level, T0, T1, T2, T3, T4, GuardTag>*)NULL);\n+  \/\/ LogStream stream((LogTargetImpl<level, T0, T1, T2, T3, T4, GuardTag>*)nullptr);\n@@ -136,1 +136,1 @@\n-    : LogStream((LogTargetImpl<level, T0, T1, T2, T3, T4, GuardTag>*)NULL) {}\n+    : LogStream((LogTargetImpl<level, T0, T1, T2, T3, T4, GuardTag>*)nullptr) {}\n","filename":"src\/hotspot\/share\/logging\/logStream.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-LogTagSet*  LogTagSet::_list      = NULL;\n+LogTagSet*  LogTagSet::_list      = nullptr;\n@@ -184,1 +184,1 @@\n-  for (const LogTagSetDescription* d = tagset_descriptions; d->tagset != NULL; d++) {\n+  for (const LogTagSetDescription* d = tagset_descriptions; d->tagset != nullptr; d++) {\n@@ -200,1 +200,1 @@\n-  for (LogTagSet* ts = first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = first(); ts != nullptr; ts = ts->next()) {\n","filename":"src\/hotspot\/share\/logging\/logTagSet.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  { NULL, NULL }\n+  { nullptr, nullptr }\n","filename":"src\/hotspot\/share\/logging\/logTagSetDescriptions.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -481,0 +481,3 @@\n+    if (DumpSharedSpaces) {\n+      HeapShared::init_scratch_objects(CHECK);\n+    }\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_METAPROGRAMMING_CONDITIONAL_HPP\n-#define SHARE_METAPROGRAMMING_CONDITIONAL_HPP\n-\n-#include \"memory\/allStatic.hpp\"\n-\n-\/\/ This trait evaluates its typedef called \"type\" to TrueType iff the condition\n-\/\/ is true. Otherwise it evaluates to FalseType.\n-\n-template <bool condition, typename TrueType, typename FalseType>\n-struct Conditional: AllStatic {\n-  typedef TrueType type;\n-};\n-\n-template <typename TrueType, typename FalseType>\n-struct Conditional<false, TrueType, FalseType>: AllStatic {\n-  typedef FalseType type;\n-};\n-\n-#endif \/\/ SHARE_METAPROGRAMMING_CONDITIONAL_HPP\n","filename":"src\/hotspot\/share\/metaprogramming\/conditional.hpp","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_METAPROGRAMMING_ISPOINTER_HPP\n-#define SHARE_METAPROGRAMMING_ISPOINTER_HPP\n-\n-#include \"metaprogramming\/integralConstant.hpp\"\n-\n-\/\/ This metafunction returns true iff the type T is (irrespective of CV qualifiers)\n-\/\/ a pointer type.\n-\n-template <typename T> class IsPointer: public FalseType {};\n-\n-template <typename T> class IsPointer<T*>: public TrueType {};\n-template <typename T> class IsPointer<T* const>: public TrueType {};\n-template <typename T> class IsPointer<T* volatile>: public TrueType {};\n-template <typename T> class IsPointer<T* const volatile>: public TrueType {};\n-\n-#endif \/\/ SHARE_METAPROGRAMMING_ISPOINTER_HPP\n","filename":"src\/hotspot\/share\/metaprogramming\/isPointer.hpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_METAPROGRAMMING_REMOVEREFERENCE_HPP\n-#define SHARE_METAPROGRAMMING_REMOVEREFERENCE_HPP\n-\n-#include \"memory\/allStatic.hpp\"\n-\n-\/\/ This metafunction returns for a type T either the underlying type behind\n-\/\/ the reference iff T is a reference type, or the same type T if T is not\n-\/\/ a reference type.\n-\n-template <typename T> struct RemoveReference: AllStatic { typedef T type; };\n-\n-template <typename T> struct RemoveReference<T&>: AllStatic { typedef T type; };\n-\n-#endif \/\/ SHARE_METAPROGRAMMING_REMOVEREFERENCE_HPP\n","filename":"src\/hotspot\/share\/metaprogramming\/removeReference.hpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"metaprogramming\/conditional.hpp\"\n@@ -33,1 +32,0 @@\n-#include \"metaprogramming\/isPointer.hpp\"\n@@ -49,1 +47,1 @@\n-  typedef typename Conditional<needs_oop_compress, narrowOop, oop>::type type;\n+  using type = std::conditional_t<needs_oop_compress, narrowOop, oop>;\n@@ -76,3 +74,3 @@\n-    typedef typename Conditional<\n-      HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value,\n-      typename HeapOopType<decorators>::type, T>::type type;\n+    using type = std::conditional_t<HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value,\n+                                    typename HeapOopType<decorators>::type,\n+                                    T>;\n@@ -1096,1 +1094,1 @@\n-                   (IsPointer<T>::value || std::is_integral<T>::value) ||\n+                   (std::is_pointer<T>::value || std::is_integral<T>::value) ||\n@@ -1129,3 +1127,3 @@\n-    typedef typename Conditional<HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value,\n-                                 typename OopOrNarrowOop<T>::type,\n-                                 std::decay_t<T>>::type DecayedT;\n+    using DecayedT = std::conditional_t<HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value,\n+                                        typename OopOrNarrowOop<T>::type,\n+                                        std::decay_t<T>>;\n@@ -1143,3 +1141,3 @@\n-    typedef typename Conditional<HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value,\n-                                 typename OopOrNarrowOop<T>::type,\n-                                 std::decay_t<T>>::type DecayedT;\n+    using DecayedT = std::conditional_t<HasDecorator<decorators, INTERNAL_VALUE_IS_OOP>::value,\n+                                        typename OopOrNarrowOop<T>::type,\n+                                        std::decay_t<T>>;\n","filename":"src\/hotspot\/share\/oops\/accessBackend.hpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1735,1 +1735,1 @@\n-  assert(in.is_reference() | in.is_value(), \"sanity check\");\n+  assert(in.is_reference() || in.is_value(), \"sanity check\");\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -695,0 +695,6 @@\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (DumpSharedSpaces) {\n+    HeapShared::remove_scratch_objects(this);\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -645,3 +645,3 @@\n-void Klass::set_archived_java_mirror(oop m) {\n-  assert(DumpSharedSpaces, \"called only during runtime\");\n-  _archived_mirror_index = HeapShared::append_root(m);\n+void Klass::set_archived_java_mirror(int mirror_index) {\n+  assert(DumpSharedSpaces, \"called only during dumptime\");\n+  _archived_mirror_index = mirror_index;\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -269,1 +269,1 @@\n-  void set_archived_java_mirror(oop m) NOT_CDS_JAVA_HEAP_RETURN;\n+  void set_archived_java_mirror(int mirror_index) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-        callee_method->instructions_size() > inline_small_code_size) {\n+        callee_method->inline_instructions_size() > inline_small_code_size) {\n@@ -281,1 +281,1 @@\n-      callee_method->instructions_size() > InlineSmallCode) {\n+      callee_method->inline_instructions_size() > InlineSmallCode) {\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,0 +224,3 @@\n+  case vmIntrinsics::_vectorizedHashCode:\n+    if (!Matcher::match_rule_supported(Op_VectorizedHashCode)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -514,0 +514,1 @@\n+macro(VectorizedHashCode)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -812,0 +812,1 @@\n+    case Op_VectorizedHashCode:\n@@ -3444,2 +3445,2 @@\n-              op == Op_FastLock || op == Op_AryEq || op == Op_StrComp ||\n-              op == Op_CountPositives ||\n+              op == Op_FastLock || op == Op_AryEq ||\n+              op == Op_StrComp || op == Op_CountPositives ||\n@@ -3447,1 +3448,2 @@\n-              op == Op_StrEquals || op == Op_StrIndexOf || op == Op_StrIndexOfChar ||\n+              op == Op_StrEquals || op == Op_VectorizedHashCode ||\n+              op == Op_StrIndexOf || op == Op_StrIndexOfChar ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,15 @@\n+uint VectorizedHashCodeNode::match_edge(uint idx) const {\n+  \/\/ Do not match memory edge.\n+  return idx >= 2 && idx <=  5; \/\/ VectorizedHashCodeNode (Binary ary1 cnt1) (Binary result bt)\n+}\n+\n+Node* VectorizedHashCodeNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+}\n+\n+const Type* VectorizedHashCodeNode::Value(PhaseGVN* phase) const {\n+  if (in(0) && phase->type(in(0)) == Type::TOP) return Type::TOP;\n+  return bottom_type();\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,0 +169,14 @@\n+\/\/------------------------------VectorizedHashCodeNode----------------------\n+class VectorizedHashCodeNode: public Node {\n+ public:\n+  VectorizedHashCodeNode(Node* control, Node* ary_mem, Node* arg1, Node* cnt1, Node* result, Node* basic_type)\n+    : Node(control, ary_mem, arg1, cnt1, result, basic_type) {};\n+  virtual int Opcode() const;\n+  virtual bool depends_only_on_test() const { return false; }\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n+  virtual const TypePtr* adr_type() const { return TypePtr::BOTTOM; }\n+  virtual uint match_edge(uint idx) const;\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+};\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,0 +204,1 @@\n+    case Op_VectorizedHashCode:\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -310,0 +311,2 @@\n+  case vmIntrinsics::_vectorizedHashCode:       return inline_vectorizedHashCode();\n+\n@@ -1069,0 +1072,1 @@\n+\n@@ -3124,1 +3128,2 @@\n-  Node* event_writer = access_load(jobj, xtype, T_OBJECT, IN_NATIVE | C2_CONTROL_DEPENDENT_LOAD);\n+  Node* jobj_untagged = _gvn.transform(new AddPNode(top(), jobj, _gvn.MakeConX(-JNIHandles::TypeTag::global)));\n+  Node* event_writer = access_load(jobj_untagged, xtype, T_OBJECT, IN_NATIVE | C2_CONTROL_DEPENDENT_LOAD);\n@@ -3353,3 +3358,1 @@\n-  \/\/ Stores of oops to native memory not supported yet by BarrierSetC2::store_at_resolved\n-  \/\/ access_store_at(NULL, thread_obj_handle, adr_type, arr, _gvn.type(arr), T_OBJECT, IN_NATIVE | MO_UNORDERED);\n-  store_to_memory(control(), thread_obj_handle, arr, T_OBJECT, adr_type, MemNode::unordered);\n+  access_store_at(NULL, thread_obj_handle, adr_type, arr, _gvn.type(arr), T_OBJECT, IN_NATIVE | MO_UNORDERED);\n@@ -5929,0 +5932,32 @@\n+\/\/------------------------------inline_vectorizedHashcode----------------------------\n+bool LibraryCallKit::inline_vectorizedHashCode() {\n+  assert(UseVectorizedHashCodeIntrinsic, \"not implemented on this platform\");\n+\n+  assert(callee()->signature()->size() == 5, \"vectorizedHashCode has 5 parameters\");\n+  Node* array          = argument(0);\n+  Node* offset         = argument(1);\n+  Node* length         = argument(2);\n+  Node* initialValue   = argument(3);\n+  Node* basic_type     = argument(4);\n+\n+  array = must_be_not_null(array, true);\n+  if (basic_type == top()) {\n+    return false; \/\/ failed input validation\n+  }\n+\n+  const TypeInt* basic_type_t = _gvn.type(basic_type)->is_int();\n+  if (!basic_type_t->is_con()) {\n+    return false; \/\/ Only intrinsify if mode argument is constant\n+  }\n+  BasicType bt = (BasicType)basic_type_t->get_con();\n+\n+  \/\/ Resolve address of first element\n+  Node* array_start = array_element_address(array, offset, bt);\n+\n+  set_result(_gvn.transform(new VectorizedHashCodeNode(control(), memory(TypeAryPtr::get_array_body_type(bt)),\n+    array_start, length, initialValue, basic_type)));\n+  clear_upper_avx();\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":40,"deletions":5,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,0 +198,1 @@\n+  bool inline_vectorizedHashCode();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -852,0 +852,1 @@\n+      case Op_VectorizedHashCode:\n@@ -1020,0 +1021,1 @@\n+      case Op_VectorizedHashCode:\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -5831,0 +5831,1 @@\n+    case Op_VectorizedHashCode:\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1070,0 +1070,1 @@\n+    case Op_VectorizedHashCode:\n@@ -2247,0 +2248,1 @@\n+    case Op_VectorizedHashCode:\n@@ -2386,6 +2388,0 @@\n-    case Op_VectorCmpMasked: {\n-      Node* pair1 = new BinaryNode(n->in(2), n->in(3));\n-      n->set_req(2, pair1);\n-      n->del_req(3);\n-      break;\n-    }\n@@ -2423,1 +2419,2 @@\n-    case Op_StrIndexOf: {\n+    case Op_StrIndexOf:\n+    case Op_VectorizedHashCode: {\n@@ -2432,0 +2429,1 @@\n+    case Op_EncodeISOArray:\n@@ -2433,2 +2431,1 @@\n-    case Op_StrInflatedCopy:\n-    case Op_EncodeISOArray: {\n+    case Op_StrInflatedCopy: {\n@@ -2461,0 +2458,1 @@\n+    case Op_VectorCmpMasked:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,1 @@\n-  if (GenerateRangeChecks && need_range_check) {\n+  if (need_range_check) {\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -782,0 +782,3 @@\n+\n+  const Type* t_sub = sub(t1, t2); \/\/ compare based on immediate inputs\n+\n@@ -834,2 +837,4 @@\n-        \/\/ compute union, so that cmp handles all possible results from the two cases\n-        return cmp1->meet(cmp2);\n+        \/\/ Compute union, so that cmp handles all possible results from the two cases\n+        const Type* t_cmp = cmp1->meet(cmp2);\n+        \/\/ Pick narrowest type, based on overflow computation and on immediate inputs\n+        return t_sub->filter(t_cmp);\n@@ -840,1 +845,1 @@\n-  return sub(t1, t2);            \/\/ Local flavor of type subtraction\n+  return t_sub;\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -886,3 +886,3 @@\n-    int _hash_computed:1;\n-    int _exact_klass_computed:1;\n-    int _is_loaded_computed:1;\n+    uint _hash_computed:1;\n+    uint _exact_klass_computed:1;\n+    uint _is_loaded_computed:1;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2796,19 +2796,0 @@\n-static oop lock_gc_or_pin_object(JavaThread* thread, jobject obj) {\n-  if (Universe::heap()->supports_object_pinning()) {\n-    const oop o = JNIHandles::resolve_non_null(obj);\n-    return Universe::heap()->pin_object(thread, o);\n-  } else {\n-    GCLocker::lock_critical(thread);\n-    return JNIHandles::resolve_non_null(obj);\n-  }\n-}\n-\n-static void unlock_gc_or_unpin_object(JavaThread* thread, jobject obj) {\n-  if (Universe::heap()->supports_object_pinning()) {\n-    const oop o = JNIHandles::resolve_non_null(obj);\n-    return Universe::heap()->unpin_object(thread, o);\n-  } else {\n-    GCLocker::unlock_critical(thread);\n-  }\n-}\n-\n@@ -2817,0 +2798,8 @@\n+  Handle a(thread, JNIHandles::resolve_non_null(array));\n+  assert(a->is_typeArray(), \"just checking\");\n+\n+  \/\/ Pin object\n+  Universe::heap()->pin_object(thread, a());\n+\n+  BasicType type = TypeArrayKlass::cast(a->klass())->element_type();\n+  void* ret = arrayOop(a())->base(type);\n@@ -2820,4 +2809,0 @@\n-  oop a = lock_gc_or_pin_object(thread, array);\n-  assert(a->is_typeArray(), \"Primitive array only\");\n-  BasicType type = TypeArrayKlass::cast(a->klass())->element_type();\n-  void* ret = arrayOop(a)->base(type);\n@@ -2831,1 +2816,2 @@\n-  unlock_gc_or_unpin_object(thread, array);\n+  \/\/ Unpin object\n+  Universe::heap()->unpin_object(thread, JNIHandles::resolve_non_null(array));\n@@ -2836,28 +2822,0 @@\n-static typeArrayOop lock_gc_or_pin_string_value(JavaThread* thread, oop str) {\n-  if (Universe::heap()->supports_object_pinning()) {\n-    \/\/ Forbid deduplication before obtaining the value array, to prevent\n-    \/\/ deduplication from replacing the value array while setting up or in\n-    \/\/ the critical section.  That would lead to the release operation\n-    \/\/ unpinning the wrong object.\n-    if (StringDedup::is_enabled()) {\n-      NoSafepointVerifier nsv;\n-      StringDedup::forbid_deduplication(str);\n-    }\n-    typeArrayOop s_value = java_lang_String::value(str);\n-    return (typeArrayOop) Universe::heap()->pin_object(thread, s_value);\n-  } else {\n-    Handle h(thread, str);      \/\/ Handlize across potential safepoint.\n-    GCLocker::lock_critical(thread);\n-    return java_lang_String::value(h());\n-  }\n-}\n-\n-static void unlock_gc_or_unpin_string_value(JavaThread* thread, oop str) {\n-  if (Universe::heap()->supports_object_pinning()) {\n-    typeArrayOop s_value = java_lang_String::value(str);\n-    Universe::heap()->unpin_object(thread, s_value);\n-  } else {\n-    GCLocker::unlock_critical(thread);\n-  }\n-}\n-\n@@ -2869,1 +2827,5 @@\n-    typeArrayOop s_value = lock_gc_or_pin_string_value(thread, s);\n+    typeArrayHandle s_value(thread, java_lang_String::value(s));\n+\n+    \/\/ Pin value array\n+    Universe::heap()->pin_object(thread, s_value());\n+\n@@ -2895,0 +2857,1 @@\n+\n@@ -2900,2 +2863,6 @@\n-    \/\/ For non-latin1 string, drop the associated gc-locker\/pin.\n-    unlock_gc_or_unpin_string_value(thread, s);\n+    \/\/ StringDedup can have replaced the value array, so don't fetch the array from 's'.\n+    \/\/ Instead, we calculate the address based on the jchar array exposed with GetStringCritical.\n+    oop value = cast_to_oop((address)chars - arrayOopDesc::base_offset_in_bytes(T_CHAR));\n+\n+    \/\/ Unpin value array\n+    Universe::heap()->unpin_object(thread, value);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":23,"deletions":56,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-void JvmtiTagMap::entry_iterate(JvmtiTagMapEntryClosure* closure) {\n+void JvmtiTagMap::entry_iterate(JvmtiTagMapKeyClosure* closure) {\n@@ -173,8 +173,1 @@\n-  JvmtiTagMapEntry* entry = tag_map->hashmap()->find(o);\n-  if (entry == NULL) {\n-    return 0;\n-  } else {\n-    jlong tag = entry->tag();\n-    assert(tag != 0, \"should not be zero\");\n-    return entry->tag();\n-  }\n+  return tag_map->hashmap()->find(o);\n@@ -183,1 +176,0 @@\n-\n@@ -194,3 +186,4 @@\n-\/\/ } \/\/ wrapper goes out of scope here which results in the destructor\n-\/\/      checking to see if the object has been tagged, untagged, or the\n-\/\/      tag value has changed.\n+\/\/ }\n+\/\/ wrapper goes out of scope here which results in the destructor\n+\/\/ checking to see if the object has been tagged, untagged, or the\n+\/\/ tag value has changed.\n@@ -202,1 +195,0 @@\n-  JvmtiTagMapEntry* _entry;\n@@ -209,1 +201,1 @@\n-  JvmtiTagMap* tag_map() const      { return _tag_map; }\n+  JvmtiTagMap* tag_map() const { return _tag_map; }\n@@ -213,1 +205,1 @@\n-                                       JvmtiTagMapEntry* entry, jlong obj_tag);\n+                                       jlong obj_tag);\n@@ -228,1 +220,0 @@\n-    _entry = _hashmap->find(_o);\n@@ -231,1 +222,1 @@\n-    _obj_tag = (_entry == NULL) ? 0 : _entry->tag();\n+    _obj_tag = _hashmap->find(_o);\n@@ -240,1 +231,1 @@\n-    post_callback_tag_update(_o, _hashmap, _entry, _obj_tag);\n+    post_callback_tag_update(_o, _hashmap, _obj_tag);\n@@ -249,2 +240,0 @@\n-\n-\n@@ -254,1 +243,0 @@\n-                                                      JvmtiTagMapEntry* entry,\n@@ -256,1 +244,2 @@\n-  if (entry == NULL) {\n+  jlong current_tag = hashmap->find(o);\n+  if (current_tag == 0) {\n@@ -268,2 +257,2 @@\n-      if (obj_tag != entry->tag()) {\n-         entry->set_tag(obj_tag);\n+      if (obj_tag != current_tag) {\n+        hashmap->update(o, obj_tag);\n@@ -286,3 +275,4 @@\n-\/\/ } \/\/ wrapper goes out of scope here which results in the destructor\n-\/\/      checking to see if the referrer object has been tagged, untagged,\n-\/\/      or the tag value has changed.\n+\/\/ }\n+\/\/ wrapper goes out of scope here which results in the destructor\n+\/\/ checking to see if the referrer object has been tagged, untagged,\n+\/\/ or the tag value has changed.\n@@ -294,1 +284,0 @@\n-  JvmtiTagMapEntry* _referrer_entry;\n@@ -316,1 +305,0 @@\n-      _referrer_entry = _referrer_hashmap->find(_referrer);\n@@ -319,1 +307,2 @@\n-      _referrer_obj_tag = (_referrer_entry == NULL) ? 0 : _referrer_entry->tag();\n+      _referrer_obj_tag = _referrer_hashmap->find(_referrer);\n+\n@@ -328,1 +317,1 @@\n-    if (!is_reference_to_self()){\n+    if (!is_reference_to_self()) {\n@@ -331,1 +320,0 @@\n-                               _referrer_entry,\n@@ -338,1 +326,1 @@\n-  inline jlong* referrer_tag_p()        { return _referrer_tag_p; }\n+  inline jlong* referrer_tag_p() { return _referrer_tag_p; }\n@@ -341,1 +329,1 @@\n-  inline jlong referrer_klass_tag()     { return _referrer_klass_tag; }\n+  inline jlong referrer_klass_tag() { return _referrer_klass_tag; }\n@@ -362,1 +350,1 @@\n-  JvmtiTagMapEntry* entry = hashmap->find(o);\n+  jlong found_tag = hashmap->find(o);\n@@ -365,1 +353,1 @@\n-  if (entry == NULL) {\n+  if (found_tag == 0) {\n@@ -378,1 +366,1 @@\n-      entry->set_tag(tag);\n+      hashmap->update(o, tag);\n@@ -517,1 +505,1 @@\n-   enum {\n+  enum {\n@@ -519,1 +507,1 @@\n-   };\n+  };\n@@ -522,1 +510,1 @@\n-  ClassFieldMap* field_map() const          { return _field_map; }\n+  ClassFieldMap* field_map() const { return _field_map; }\n@@ -576,1 +564,0 @@\n-\n@@ -1242,1 +1229,1 @@\n-class TagObjectCollector : public JvmtiTagMapEntryClosure {\n+class TagObjectCollector : public JvmtiTagMapKeyClosure {\n@@ -1273,4 +1260,4 @@\n-  \/\/\n-  void do_entry(JvmtiTagMapEntry* entry) {\n-    for (int i=0; i<_tag_count; i++) {\n-      if (_tags[i] == entry->tag()) {\n+  \/\/ Always return true so the iteration continues.\n+  bool do_entry(JvmtiTagMapKey& key, jlong& value) {\n+    for (int i = 0; i < _tag_count; i++) {\n+      if (_tags[i] == value) {\n@@ -1281,1 +1268,1 @@\n-        oop o = entry->object();\n+        oop o = key.object();\n@@ -1285,1 +1272,1 @@\n-          return;\n+          return true;\n@@ -1290,1 +1277,1 @@\n-        _tag_results->append((uint64_t)entry->tag());\n+        _tag_results->append(value);\n@@ -1293,0 +1280,1 @@\n+    return true;\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":39,"deletions":51,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-class JvmtiTagMapEntryClosure;\n+class JvmtiTagMapKeyClosure;\n@@ -37,1 +37,1 @@\n-class JvmtiTagMap :  public CHeapObj<mtInternal> {\n+class JvmtiTagMap :  public CHeapObj<mtServiceability> {\n@@ -56,1 +56,1 @@\n-  void entry_iterate(JvmtiTagMapEntryClosure* closure);\n+  void entry_iterate(JvmtiTagMapKeyClosure* closure);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,3 +41,0 @@\n-oop JvmtiTagMapEntry::object() {\n-  return literal().resolve();\n-}\n@@ -45,4 +42,1 @@\n-oop JvmtiTagMapEntry::object_no_keepalive() {\n-  \/\/ Just peek at the object without keeping it alive.\n-  return literal().peek();\n-}\n+JvmtiTagMapKey::JvmtiTagMapKey(oop obj) : _obj(obj) {}\n@@ -50,2 +44,6 @@\n-JvmtiTagMapTable::JvmtiTagMapTable()\n-  : Hashtable<WeakHandle, mtServiceability>(_table_size, sizeof(JvmtiTagMapEntry)) {}\n+JvmtiTagMapKey::JvmtiTagMapKey(const JvmtiTagMapKey& src) {\n+  \/\/ move object into WeakHandle when copying into the table\n+  assert(src._obj != nullptr, \"must be set\");\n+  _wh = WeakHandle(JvmtiExport::weak_tag_storage(), src._obj);\n+  _obj = nullptr;\n+}\n@@ -53,12 +51,8 @@\n-void JvmtiTagMapTable::clear() {\n-  \/\/ Clear this table\n-  log_debug(jvmti, table)(\"JvmtiTagMapTable cleared\");\n-  for (int i = 0; i < table_size(); ++i) {\n-    for (JvmtiTagMapEntry* m = bucket(i); m != NULL;) {\n-      JvmtiTagMapEntry* entry = m;\n-      \/\/ read next before freeing.\n-      m = m->next();\n-      free_entry(entry);\n-    }\n-    JvmtiTagMapEntry** p = bucket_addr(i);\n-    *p = NULL; \/\/ clear out buckets.\n+JvmtiTagMapKey::~JvmtiTagMapKey() {\n+  \/\/ If obj is set null it out, this is called for stack object on lookup,\n+  \/\/ and it should not have a WeakHandle created for it yet.\n+  if (_obj != nullptr) {\n+    _obj = nullptr;\n+    assert(_wh.is_null(), \"WeakHandle should be null\");\n+  } else {\n+    _wh.release(JvmtiExport::weak_tag_storage());\n@@ -66,1 +60,0 @@\n-  assert(number_of_entries() == 0, \"should have removed all entries\");\n@@ -69,3 +62,3 @@\n-JvmtiTagMapTable::~JvmtiTagMapTable() {\n-  clear();\n-  \/\/ base class ~BasicHashtable deallocates the buckets.\n+oop JvmtiTagMapKey::object() const {\n+  assert(_obj == nullptr, \"Must have a handle and not object\");\n+  return _wh.resolve();\n@@ -74,5 +67,3 @@\n-\/\/ Entries are C_Heap allocated\n-JvmtiTagMapEntry* JvmtiTagMapTable::new_entry(unsigned int hash, WeakHandle w, jlong tag) {\n-  JvmtiTagMapEntry* entry = (JvmtiTagMapEntry*)Hashtable<WeakHandle, mtServiceability>::new_entry(hash, w);\n-  entry->set_tag(tag);\n-  return entry;\n+oop JvmtiTagMapKey::object_no_keepalive() const {\n+  assert(_obj == nullptr, \"Must have a handle and not object\");\n+  return _wh.peek();\n@@ -81,4 +72,1 @@\n-void JvmtiTagMapTable::free_entry(JvmtiTagMapEntry* entry) {\n-  entry->literal().release(JvmtiExport::weak_tag_storage()); \/\/ release to OopStorage\n-  BasicHashtable<mtServiceability>::free_entry(entry);\n-}\n+JvmtiTagMapTable::JvmtiTagMapTable() : _table(Constants::_table_size) {}\n@@ -86,3 +74,13 @@\n-unsigned int JvmtiTagMapTable::compute_hash(oop obj) {\n-  assert(obj != NULL, \"obj is null\");\n-  return obj->identity_hash();\n+void JvmtiTagMapTable::clear() {\n+  struct RemoveAll {\n+    bool do_entry(const JvmtiTagMapKey& entry, const jlong& tag) {\n+      return true;\n+    }\n+  } remove_all;\n+  \/\/ The unlink method of ResourceHashTable gets a pointer to a type whose 'do_entry(K,V)' method is callled\n+  \/\/ while iterating over all the elements of the table. If the do_entry() method returns true the element\n+  \/\/ will be removed.\n+  \/\/ In this case, we always return true from do_entry to clear all the elements.\n+  _table.unlink(&remove_all);\n+\n+  assert(_table.number_of_entries() == 0, \"should have removed all entries\");\n@@ -91,8 +89,3 @@\n-JvmtiTagMapEntry* JvmtiTagMapTable::find(int index, unsigned int hash, oop obj) {\n-  assert(obj != NULL, \"Cannot search for a NULL object\");\n-\n-  for (JvmtiTagMapEntry* p = bucket(index); p != NULL; p = p->next()) {\n-    if (p->hash() == hash) {\n-\n-      \/\/ Peek the object to check if it is the right target.\n-      oop target = p->object_no_keepalive();\n+JvmtiTagMapTable::~JvmtiTagMapTable() {\n+  clear();\n+}\n@@ -100,11 +93,3 @@\n-      \/\/ The obj is in the table as a target already\n-      if (target == obj) {\n-        ResourceMark rm;\n-        log_trace(jvmti, table)(\"JvmtiTagMap entry found for %s index %d\",\n-                                obj->print_value_string(), index);\n-        \/\/ The object() accessor makes sure the target object is kept alive before\n-        \/\/ leaking out.\n-        (void)p->object();\n-        return p;\n-      }\n-    }\n+jlong JvmtiTagMapTable::find(oop obj) {\n+  if (is_empty()) {\n+    return 0;\n@@ -112,2 +97,0 @@\n-  return NULL;\n-}\n@@ -115,1 +98,0 @@\n-JvmtiTagMapEntry* JvmtiTagMapTable::find(oop obj) {\n@@ -118,1 +100,1 @@\n-    return NULL;\n+    return 0;\n@@ -120,14 +102,0 @@\n-  unsigned int hash = compute_hash(obj);\n-  int index = hash_to_index(hash);\n-  return find(index, hash, obj);\n-}\n-\n-JvmtiTagMapEntry* JvmtiTagMapTable::add(oop obj, jlong tag) {\n-  unsigned int hash = compute_hash(obj);\n-  int index = hash_to_index(hash);\n-  \/\/ One was added while acquiring the lock\n-  assert(find(index, hash, obj) == NULL, \"shouldn't already be present\");\n-\n-  \/\/ obj was read with AS_NO_KEEPALIVE, or equivalent.\n-  \/\/ The object needs to be kept alive when it is published.\n-  Universe::heap()->keep_alive(obj);\n@@ -135,6 +103,4 @@\n-  WeakHandle w(JvmtiExport::weak_tag_storage(), obj);\n-  JvmtiTagMapEntry* p = new_entry(hash, w, tag);\n-  Hashtable<WeakHandle, mtServiceability>::add_entry(index, p);\n-  ResourceMark rm;\n-  log_trace(jvmti, table)(\"JvmtiTagMap entry added for %s index %d\",\n-                          obj->print_value_string(), index);\n+  JvmtiTagMapKey jtme(obj);\n+  jlong* found = _table.get(jtme);\n+  return found == nullptr ? 0 : *found;\n+}\n@@ -142,2 +108,6 @@\n-  \/\/ Resize if the table is getting too big.\n-  resize_if_needed();\n+void JvmtiTagMapTable::add(oop obj, jlong tag) {\n+  JvmtiTagMapKey new_entry(obj);\n+  bool is_added = false;\n+  _table.put_if_absent(new_entry, tag, &is_added);\n+  assert(is_added, \"should be added\");\n+}\n@@ -145,1 +115,4 @@\n-  return p;\n+void JvmtiTagMapTable::update(oop obj, jlong tag) {\n+  JvmtiTagMapKey new_entry(obj);\n+  bool is_updated = _table.put(new_entry, tag) == false;\n+  assert(is_updated, \"should be updated and not added\");\n@@ -149,16 +122,3 @@\n-  unsigned int hash = compute_hash(obj);\n-  int index = hash_to_index(hash);\n-  JvmtiTagMapEntry** p = bucket_addr(index);\n-  JvmtiTagMapEntry* entry = bucket(index);\n-  while (entry != NULL) {\n-    oop target = entry->object_no_keepalive();\n-    if (target != NULL && target == obj) {\n-      log_trace(jvmti, table)(\"JvmtiTagMap entry removed for index %d\", index);\n-      *p = entry->next();\n-      free_entry(entry);\n-      return; \/\/ done\n-    }\n-    \/\/ get next entry and address\n-    p = entry->next_addr();\n-    entry = entry->next();\n-  }\n+  JvmtiTagMapKey jtme(obj);\n+  bool is_removed = _table.remove(jtme);\n+  assert(is_removed, \"remove not succesfull.\");\n@@ -167,6 +127,2 @@\n-void JvmtiTagMapTable::entry_iterate(JvmtiTagMapEntryClosure* closure) {\n-  for (int i = 0; i < table_size(); ++i) {\n-    for (JvmtiTagMapEntry* p = bucket(i); p != NULL; p = p->next()) {\n-      closure->do_entry(p);\n-    }\n-  }\n+void JvmtiTagMapTable::entry_iterate(JvmtiTagMapKeyClosure* closure) {\n+  _table.iterate(closure);\n@@ -175,3 +131,0 @@\n-const int _resize_load_trigger = 5;       \/\/ load factor that will trigger the resize\n-static bool _resizable = true;\n-\n@@ -179,12 +132,1 @@\n-  if (_resizable && number_of_entries() > (_resize_load_trigger*table_size())) {\n-    int desired_size = calculate_resize(true);\n-    if (desired_size == table_size()) {\n-      _resizable = false; \/\/ hit max\n-    } else {\n-      if (!resize(desired_size)) {\n-        \/\/ Something went wrong, turn resizing off\n-        _resizable = false;\n-      }\n-      log_info(jvmti, table) (\"JvmtiTagMap table resized to %d\", table_size());\n-    }\n-  }\n+  _table.maybe_grow();\n@@ -193,2 +135,0 @@\n-\/\/ Serially remove entries for dead oops from the table and store dead oops'\n-\/\/ tag in objects array if provided.\n@@ -196,21 +136,7 @@\n-  int oops_removed = 0;\n-  int oops_counted = 0;\n-  for (int i = 0; i < table_size(); ++i) {\n-    JvmtiTagMapEntry** p = bucket_addr(i);\n-    JvmtiTagMapEntry* entry = bucket(i);\n-    while (entry != NULL) {\n-      oops_counted++;\n-      oop l = entry->object_no_keepalive();\n-      if (l != NULL) {\n-        p = entry->next_addr();\n-      } else {\n-        \/\/ Entry has been removed.\n-        oops_removed++;\n-        log_trace(jvmti, table)(\"JvmtiTagMap entry removed for index %d\", i);\n-        jlong tag = entry->tag();\n-        *p = entry->next();\n-        free_entry(entry);\n-\n-        \/\/ collect object tags for posting JVMTI events later\n-        if (objects != NULL) {\n-          objects->append(tag);\n+  struct IsDead {\n+    GrowableArray<jlong>* _objects;\n+    IsDead(GrowableArray<jlong>* objects) : _objects(objects) {}\n+    bool do_entry(const JvmtiTagMapKey& entry, jlong tag) {\n+      if (entry.object_no_keepalive() == NULL) {\n+        if (_objects != NULL) {\n+          _objects->append(tag);\n@@ -218,0 +144,1 @@\n+        return true;\n@@ -219,2 +146,1 @@\n-      \/\/ get next entry\n-      entry = *p;\n+      return false;;\n@@ -222,4 +148,2 @@\n-  }\n-\n-  log_info(jvmti, table) (\"JvmtiTagMap entries counted %d removed %d\",\n-                          oops_counted, oops_removed);\n+  } is_dead(objects);\n+  _table.unlink(&is_dead);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":74,"deletions":150,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"utilities\/resizeableResourceHash.hpp\"\n@@ -32,6 +35,12 @@\n-\n-\/\/ Hashtable to record oops used for JvmtiTagMap\n-class JvmtiTagMapEntryClosure;\n-\n-class JvmtiTagMapEntry : public HashtableEntry<WeakHandle, mtServiceability> {\n-  jlong _tag;                           \/\/ the tag\n+class JvmtiTagMapKeyClosure;\n+\n+\/\/ The oop is needed for lookup rather than creating a WeakHandle during\n+\/\/ lookup because the HeapWalker may walk soon to be dead objects and\n+\/\/ creating a WeakHandle for an otherwise dead object makes G1 unhappy.\n+\/\/\n+\/\/ This class is the Key type for inserting in ResizeableResourceHashTable\n+\/\/ Its get_hash() and equals() methods are also used for getting the hash\n+\/\/ value of a Key and comparing two Keys, respectively.\n+class JvmtiTagMapKey : public CHeapObj<mtServiceability> {\n+  WeakHandle _wh;\n+  oop _obj; \/\/ temporarily hold obj while searching\n@@ -39,3 +48,3 @@\n-  JvmtiTagMapEntry* next() const {\n-    return (JvmtiTagMapEntry*)HashtableEntry<WeakHandle, mtServiceability>::next();\n-  }\n+  JvmtiTagMapKey(oop obj);\n+  JvmtiTagMapKey(const JvmtiTagMapKey& src);\n+  JvmtiTagMapKey& operator=(const JvmtiTagMapKey&) = delete;\n@@ -43,3 +52,1 @@\n-  JvmtiTagMapEntry** next_addr() {\n-    return (JvmtiTagMapEntry**)HashtableEntry<WeakHandle, mtServiceability>::next_addr();\n-  }\n+  ~JvmtiTagMapKey();\n@@ -47,5 +54,3 @@\n-  oop object();\n-  oop object_no_keepalive();\n-  jlong tag() const       { return _tag; }\n-  void set_tag(jlong tag) { _tag = tag; }\n-};\n+  void resolve();\n+  oop object() const;\n+  oop object_no_keepalive() const;\n@@ -53,8 +58,3 @@\n-class JvmtiTagMapTable : public Hashtable<WeakHandle, mtServiceability> {\n-  enum Constants {\n-    _table_size  = 1007\n-  };\n-\n-private:\n-  JvmtiTagMapEntry* bucket(int i) {\n-    return (JvmtiTagMapEntry*) Hashtable<WeakHandle, mtServiceability>::bucket(i);\n+  static unsigned get_hash(const JvmtiTagMapKey& entry) {\n+    assert(entry._obj != NULL, \"must lookup obj to hash\");\n+    return entry._obj->identity_hash();\n@@ -63,2 +63,4 @@\n-  JvmtiTagMapEntry** bucket_addr(int i) {\n-    return (JvmtiTagMapEntry**) Hashtable<WeakHandle, mtServiceability>::bucket_addr(i);\n+  static bool equals(const JvmtiTagMapKey& lhs, const JvmtiTagMapKey& rhs) {\n+    oop lhs_obj = lhs._obj != nullptr ? lhs._obj : lhs.object_no_keepalive();\n+    oop rhs_obj = rhs._obj != nullptr ? rhs._obj : rhs.object_no_keepalive();\n+    return lhs_obj == rhs_obj;\n@@ -66,0 +68,1 @@\n+};\n@@ -67,4 +70,5 @@\n-  JvmtiTagMapEntry* new_entry(unsigned int hash, WeakHandle w, jlong tag);\n-  void free_entry(JvmtiTagMapEntry* entry);\n-\n-  unsigned int compute_hash(oop obj);\n+typedef\n+ResizeableResourceHashtable <JvmtiTagMapKey, jlong,\n+                              AnyObj::C_HEAP, mtServiceability,\n+                              JvmtiTagMapKey::get_hash,\n+                              JvmtiTagMapKey::equals> ResizableResourceHT;\n@@ -72,1 +76,4 @@\n-  JvmtiTagMapEntry* find(int index, unsigned int hash, oop obj);\n+class JvmtiTagMapTable : public CHeapObj<mtServiceability> {\n+ enum Constants {\n+  _table_size  = 1007\n+ };\n@@ -74,0 +81,1 @@\n+ private:\n@@ -75,0 +83,1 @@\n+  ResizableResourceHT _table;\n@@ -76,1 +85,1 @@\n-public:\n+ public:\n@@ -80,2 +89,3 @@\n-  JvmtiTagMapEntry* find(oop obj);\n-  JvmtiTagMapEntry* add(oop obj, jlong tag);\n+  jlong find(oop obj);\n+  void add(oop obj, jlong tag);\n+  void update(oop obj, jlong tag);\n@@ -86,1 +96,1 @@\n-  void entry_iterate(JvmtiTagMapEntryClosure* closure);\n+  void entry_iterate(JvmtiTagMapKeyClosure* closure);\n@@ -88,1 +98,1 @@\n-  bool is_empty() const { return number_of_entries() == 0; }\n+  bool is_empty() const { return _table.number_of_entries() == 0; }\n@@ -96,1 +106,1 @@\n-class JvmtiTagMapEntryClosure {\n+class JvmtiTagMapKeyClosure {\n@@ -98,1 +108,1 @@\n-  virtual void do_entry(JvmtiTagMapEntry* entry) = 0;\n+  virtual bool do_entry(JvmtiTagMapKey& key, jlong& value) = 0;\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":50,"deletions":40,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"metaprogramming\/conditional.hpp\"\n@@ -31,1 +30,0 @@\n-#include \"metaprogramming\/isPointer.hpp\"\n@@ -395,1 +393,1 @@\n-  typename EnableIf<std::is_integral<T>::value || IsPointer<T>::value>::type>\n+  typename EnableIf<std::is_integral<T>::value || std::is_pointer<T>::value>::type>\n@@ -512,2 +510,2 @@\n-  STATIC_ASSERT(IsPointer<D>::value || std::is_integral<D>::value);\n-  typedef typename Conditional<IsPointer<D>::value, ptrdiff_t, D>::type I;\n+  STATIC_ASSERT(std::is_pointer<D>::value || std::is_integral<D>::value);\n+  using I = std::conditional_t<std::is_pointer<D>::value, ptrdiff_t, D>;\n@@ -519,2 +517,2 @@\n-  STATIC_ASSERT(IsPointer<D>::value || std::is_integral<D>::value);\n-  typedef typename Conditional<IsPointer<D>::value, ptrdiff_t, D>::type I;\n+  STATIC_ASSERT(std::is_pointer<D>::value || std::is_integral<D>::value);\n+  using I = std::conditional_t<std::is_pointer<D>::value, ptrdiff_t, D>;\n@@ -528,1 +526,1 @@\n-  STATIC_ASSERT(IsPointer<D>::value || std::is_integral<D>::value);\n+  STATIC_ASSERT(std::is_pointer<D>::value || std::is_integral<D>::value);\n@@ -532,2 +530,2 @@\n-  typedef typename Conditional<IsSigned<I>::value, intptr_t, uintptr_t>::type PI;\n-  typedef typename Conditional<IsPointer<D>::value, PI, D>::type AddendType;\n+  using PI = std::conditional_t<IsSigned<I>::value, intptr_t, uintptr_t>;\n+  using AddendType = std::conditional_t<std::is_pointer<D>::value, PI, D>;\n@@ -703,1 +701,1 @@\n-  using SI = typename Conditional<IsSigned<I>::value, intptr_t, uintptr_t>::type;\n+  using SI = std::conditional_t<IsSigned<I>::value, intptr_t, uintptr_t>;\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"metaprogramming\/conditional.hpp\"\n@@ -71,0 +70,2 @@\n+#include <type_traits>\n+\n@@ -263,1 +264,1 @@\n-  typedef typename Conditional<oops == oop_kind::NARROW, narrowOop, oop>::type OopT;\n+  using OopT = std::conditional_t<oops == oop_kind::NARROW, narrowOop, oop>;\n@@ -277,1 +278,1 @@\n-    if (sp - size < thread->stack_overflow_state()->stack_overflow_limit()) {\n+    if (sp - size < thread->stack_overflow_state()->shadow_zone_safe_limit()) {\n@@ -1262,1 +1263,1 @@\n-  if (os::current_stack_pointer() < t->stack_overflow_state()->stack_overflow_limit()) {\n+  if (os::current_stack_pointer() < t->stack_overflow_state()->shadow_zone_safe_limit()) {\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,3 @@\n+  product(bool, UseVectorizedHashCodeIntrinsic, false, DIAGNOSTIC,           \\\n+          \"Enables intrinsification of ArraysSupport.vectorizedHashCode()\") \\\n+                                                                            \\\n@@ -944,3 +947,0 @@\n-  develop(bool, GenerateRangeChecks, true,                                  \\\n-          \"Generate range checks for array accesses\")                       \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -744,4 +744,0 @@\n-  void set_do_not_unlock(void)                   { _do_not_unlock_if_synchronized = true; }\n-  void clr_do_not_unlock(void)                   { _do_not_unlock_if_synchronized = false; }\n-  bool do_not_unlock(void)                       { return _do_not_unlock_if_synchronized; }\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,1 @@\n+    STATIC_ASSERT(TypeTag::local == 0);\n@@ -94,1 +95,1 @@\n-      assert(*ptr == NULL, \"invariant\");\n+      assert(NativeAccess<AS_NO_KEEPALIVE>::oop_load(ptr) == oop(NULL), \"invariant\");\n@@ -96,1 +97,2 @@\n-      res = reinterpret_cast<jobject>(ptr);\n+      char* tptr = reinterpret_cast<char*>(ptr) + TypeTag::global;\n+      res = reinterpret_cast<jobject>(tptr);\n@@ -105,1 +107,1 @@\n-jobject JNIHandles::make_weak_global(Handle obj, AllocFailType alloc_failmode) {\n+jweak JNIHandles::make_weak_global(Handle obj, AllocFailType alloc_failmode) {\n@@ -108,1 +110,1 @@\n-  jobject res = NULL;\n+  jweak res = NULL;\n@@ -115,1 +117,1 @@\n-      assert(*ptr == NULL, \"invariant\");\n+      assert(NativeAccess<AS_NO_KEEPALIVE>::oop_load(ptr) == oop(NULL), \"invariant\");\n@@ -117,2 +119,2 @@\n-      char* tptr = reinterpret_cast<char*>(ptr) + weak_tag_value;\n-      res = reinterpret_cast<jobject>(tptr);\n+      char* tptr = reinterpret_cast<char*>(ptr) + TypeTag::weak_global;\n+      res = reinterpret_cast<jweak>(tptr);\n@@ -138,1 +140,1 @@\n-bool JNIHandles::is_global_weak_cleared(jweak handle) {\n+bool JNIHandles::is_weak_global_cleared(jweak handle) {\n@@ -140,2 +142,1 @@\n-  assert(is_jweak(handle), \"not a weak handle\");\n-  oop* oop_ptr = jweak_ptr(handle);\n+  oop* oop_ptr = weak_global_ptr(handle);\n@@ -148,2 +149,1 @@\n-    assert(!is_jweak(handle), \"wrong method for destroying jweak\");\n-    oop* oop_ptr = jobject_ptr(handle);\n+    oop* oop_ptr = global_ptr(handle);\n@@ -156,1 +156,1 @@\n-void JNIHandles::destroy_weak_global(jobject handle) {\n+void JNIHandles::destroy_weak_global(jweak handle) {\n@@ -158,2 +158,1 @@\n-    assert(is_jweak(handle), \"JNI handle not jweak\");\n-    oop* oop_ptr = jweak_ptr(handle);\n+    oop* oop_ptr = weak_global_ptr(handle);\n@@ -187,2 +186,2 @@\n-  if (is_jweak(handle)) {\n-    if (is_storage_handle(weak_global_handles(), jweak_ptr(handle))) {\n+  if (is_weak_global_tagged(handle)) {\n+    if (is_storage_handle(weak_global_handles(), weak_global_ptr(handle))) {\n@@ -191,2 +190,2 @@\n-  } else {\n-    switch (global_handles()->allocation_status(jobject_ptr(handle))) {\n+  } else if (is_global_tagged(handle)) {\n+    switch (global_handles()->allocation_status(global_ptr(handle))) {\n@@ -200,7 +199,0 @@\n-    case OopStorage::INVALID_ENTRY:\n-      \/\/ Not in global storage.  Might be a local handle.\n-      if (is_local_handle(thread, handle) || is_frame_handle(thread, handle)) {\n-        result = JNILocalRefType;\n-      }\n-      break;\n-\n@@ -210,0 +202,7 @@\n+  } else {\n+    \/\/ Not in global storage.  Might be a local handle.\n+    if (is_local_handle(thread, handle) || is_frame_handle(thread, handle)) {\n+      result = JNILocalRefType;\n+    } else {\n+      ShouldNotReachHere();\n+    }\n@@ -246,1 +245,2 @@\n-  return !is_jweak(handle) && is_storage_handle(global_handles(), jobject_ptr(handle));\n+  assert(!is_global_tagged(handle) || is_storage_handle(global_handles(), global_ptr(handle)), \"invalid storage\");\n+  return is_global_tagged(handle);\n@@ -252,1 +252,2 @@\n-  return is_jweak(handle) && is_storage_handle(weak_global_handles(), jweak_ptr(handle));\n+  assert(!is_weak_global_tagged(handle) || is_storage_handle(weak_global_handles(), weak_global_ptr(handle)), \"invalid storage\");\n+  return is_weak_global_tagged(handle);\n@@ -458,1 +459,1 @@\n-    NativeAccess<IS_DEST_UNINITIALIZED>::oop_store(handle, obj);\n+    *handle = obj;\n@@ -466,1 +467,1 @@\n-    NativeAccess<IS_DEST_UNINITIALIZED>::oop_store(handle, obj);\n+    *handle = obj;\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":32,"deletions":31,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,3 +48,6 @@\n-  inline static bool is_jweak(jobject handle);\n-  inline static oop* jobject_ptr(jobject handle); \/\/ NOT jweak!\n-  inline static oop* jweak_ptr(jobject handle);\n+  inline static bool is_local_tagged(jobject handle);\n+  inline static bool is_weak_global_tagged(jobject handle);\n+  inline static bool is_global_tagged(jobject handle);\n+  inline static oop* local_ptr(jobject handle);\n+  inline static oop* global_ptr(jobject handle);\n+  inline static oop* weak_global_ptr(jweak handle);\n@@ -62,12 +65,18 @@\n-  \/\/ Low tag bit in jobject used to distinguish a jweak.  jweak is\n-  \/\/ type equivalent to jobject, but there are places where we need to\n-  \/\/ be able to distinguish jweak values from other jobjects, and\n-  \/\/ is_weak_global_handle is unsuitable for performance reasons.  To\n-  \/\/ provide such a test we add weak_tag_value to the (aligned) byte\n-  \/\/ address designated by the jobject to produce the corresponding\n-  \/\/ jweak.  Accessing the value of a jobject must account for it\n-  \/\/ being a possibly offset jweak.\n-  static const uintptr_t weak_tag_size = 1;\n-  static const uintptr_t weak_tag_alignment = (1u << weak_tag_size);\n-  static const uintptr_t weak_tag_mask = weak_tag_alignment - 1;\n-  static const int weak_tag_value = 1;\n+  \/\/ Low tag bits in jobject used to distinguish its type. Checking\n+  \/\/ the underlying storage type is unsuitable for performance reasons.\n+  enum TypeTag {\n+    local = 0b00,\n+    weak_global = 0b01,\n+    global = 0b10,\n+  };\n+\n+private:\n+  inline static bool is_tagged_with(jobject handle, TypeTag tag);\n+\n+public:\n+  static const uintptr_t tag_size = 2;\n+  static const uintptr_t tag_mask = ((1u << tag_size) - 1u);\n+\n+  STATIC_ASSERT((TypeTag::local & tag_mask) == TypeTag::local);\n+  STATIC_ASSERT((TypeTag::weak_global & tag_mask) == TypeTag::weak_global);\n+  STATIC_ASSERT((TypeTag::global & tag_mask) == TypeTag::global);\n@@ -97,4 +106,4 @@\n-  static jobject make_weak_global(Handle obj,\n-                                  AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n-  static void destroy_weak_global(jobject handle);\n-  static bool is_global_weak_cleared(jweak handle); \/\/ Test jweak without resolution\n+  static jweak make_weak_global(Handle obj,\n+                                AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n+  static void destroy_weak_global(jweak handle);\n+  static bool is_weak_global_cleared(jweak handle); \/\/ Test jweak without resolution\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.hpp","additions":29,"deletions":20,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,4 +35,2 @@\n-inline bool JNIHandles::is_jweak(jobject handle) {\n-  STATIC_ASSERT(weak_tag_size == 1);\n-  STATIC_ASSERT(weak_tag_value == 1);\n-  return (reinterpret_cast<uintptr_t>(handle) & weak_tag_mask) != 0;\n+inline bool JNIHandles::is_tagged_with(jobject handle, TypeTag tag) {\n+  return (reinterpret_cast<uintptr_t>(handle) & tag_mask) == tag;\n@@ -41,2 +39,15 @@\n-inline oop* JNIHandles::jobject_ptr(jobject handle) {\n-  assert(!is_jweak(handle), \"precondition\");\n+inline bool JNIHandles::is_local_tagged(jobject handle) {\n+  return is_tagged_with(handle, TypeTag::local);\n+}\n+\n+inline bool JNIHandles::is_weak_global_tagged(jobject handle) {\n+  return is_tagged_with(handle, TypeTag::weak_global);\n+}\n+\n+inline bool JNIHandles::is_global_tagged(jobject handle) {\n+  return is_tagged_with(handle, TypeTag::global);\n+}\n+\n+inline oop* JNIHandles::local_ptr(jobject handle) {\n+  assert(is_local_tagged(handle), \"precondition\");\n+  STATIC_ASSERT(TypeTag::local == 0);\n@@ -46,3 +57,9 @@\n-inline oop* JNIHandles::jweak_ptr(jobject handle) {\n-  assert(is_jweak(handle), \"precondition\");\n-  char* ptr = reinterpret_cast<char*>(handle) - weak_tag_value;\n+inline oop* JNIHandles::global_ptr(jobject handle) {\n+  assert(is_global_tagged(handle), \"precondition\");\n+  char* ptr = reinterpret_cast<char*>(handle) - TypeTag::global;\n+  return reinterpret_cast<oop*>(ptr);\n+}\n+\n+inline oop* JNIHandles::weak_global_ptr(jweak handle) {\n+  assert(is_weak_global_tagged(handle), \"precondition\");\n+  char* ptr = reinterpret_cast<char*>(handle) - TypeTag::weak_global;\n@@ -58,2 +75,7 @@\n-  if (is_jweak(handle)) {       \/\/ Unlikely\n-    result = NativeAccess<ON_PHANTOM_OOP_REF|decorators>::oop_load(jweak_ptr(handle));\n+  if (is_weak_global_tagged(handle)) {       \/\/ Unlikely\n+    result = NativeAccess<ON_PHANTOM_OOP_REF|decorators>::oop_load(weak_global_ptr(handle));\n+  } else if (is_global_tagged(handle)) {\n+    result = NativeAccess<decorators>::oop_load(global_ptr(handle));\n+    \/\/ Construction of jobjects canonicalize a null value into a null\n+    \/\/ jobject, so for non-jweak the pointee should never be null.\n+    assert(external_guard || result != NULL, \"Invalid JNI handle\");\n@@ -61,1 +83,1 @@\n-    result = NativeAccess<decorators>::oop_load(jobject_ptr(handle));\n+    result = *local_ptr(handle);\n@@ -100,2 +122,1 @@\n-    assert(!is_jweak(handle), \"Invalid JNI local handle\");\n-    NativeAccess<>::oop_store(jobject_ptr(handle), (oop)NULL);\n+    *local_ptr(handle) = NULL;\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.inline.hpp","additions":36,"deletions":15,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,0 +158,1 @@\n+Mutex*   ScratchObjects_lock          = NULL;\n@@ -332,0 +333,1 @@\n+  def(ScratchObjects_lock          , PaddedMutex  , nosafepoint-1); \/\/ Holds DumpTimeTable_lock\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,0 +129,1 @@\n+extern Mutex*   ScratchObjects_lock;             \/\/ Protecting _scratch_xxx_table in heapShared.cpp\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -817,1 +817,1 @@\n-  nonstatic_field(ciMethod,                    _instructions_size,                            int)                                   \\\n+  nonstatic_field(ciMethod,                    _inline_instructions_size,                     int)                                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -477,1 +477,1 @@\n-  long amount_diff = diff_in_current_scale(current_amount, early_amount);\n+  int64_t amount_diff = diff_in_current_scale(current_amount, early_amount);\n@@ -479,1 +479,1 @@\n-    out->print(\" %+ld%s\", amount_diff, scale);\n+    out->print(\" \" INT64_PLUS_FORMAT \"%s\", amount_diff, scale);\n@@ -496,1 +496,1 @@\n-    out->print(\" %+ld\", diff_in_current_scale(current_amount, early_amount));\n+    out->print(\" \" INT64_PLUS_FORMAT \"d\", diff_in_current_scale(current_amount, early_amount));\n@@ -511,1 +511,1 @@\n-  long reserved_diff = diff_in_current_scale(current_reserved, early_reserved);\n+  int64_t reserved_diff = diff_in_current_scale(current_reserved, early_reserved);\n@@ -513,1 +513,1 @@\n-    out->print(\" %+ld%s\", reserved_diff, scale);\n+    out->print(\" \" INT64_PLUS_FORMAT \"%s\", reserved_diff, scale);\n@@ -517,1 +517,1 @@\n-  long committed_diff = diff_in_current_scale(current_committed, early_committed);\n+  int64_t committed_diff = diff_in_current_scale(current_committed, early_committed);\n@@ -519,1 +519,1 @@\n-    out->print(\" %+ld%s\", committed_diff, scale);\n+    out->print(\" \" INT64_PLUS_FORMAT \"%s\", committed_diff, scale);\n@@ -663,2 +663,2 @@\n-      long overhead_diff = diff_in_current_scale(_current_baseline.malloc_tracking_overhead(),\n-           _early_baseline.malloc_tracking_overhead());\n+      int64_t overhead_diff = diff_in_current_scale(_current_baseline.malloc_tracking_overhead(),\n+                                                    _early_baseline.malloc_tracking_overhead());\n@@ -666,1 +666,1 @@\n-        out->print(\" %+ld%s\", overhead_diff, scale);\n+        out->print(\" \" INT64_PLUS_FORMAT \"%s\", overhead_diff, scale);\n@@ -698,2 +698,2 @@\n-  long diff_used = diff_in_current_scale(current_stats.used(),\n-                                         early_stats.used());\n+  int64_t diff_used = diff_in_current_scale(current_stats.used(),\n+                                            early_stats.used());\n@@ -703,1 +703,1 @@\n-  long diff_waste = diff_in_current_scale(current_waste, early_waste);\n+  int64_t diff_waste = diff_in_current_scale(current_waste, early_waste);\n@@ -709,1 +709,1 @@\n-    out->print(\" %+ld%s\", diff_used, scale);\n+    out->print(\" \" INT64_PLUS_FORMAT \"%s\", diff_used, scale);\n@@ -719,1 +719,1 @@\n-    out->print(\" %+ld%s\", diff_waste, scale);\n+    out->print(\" \" INT64_PLUS_FORMAT \"%s\", diff_waste, scale);\n","filename":"src\/hotspot\/share\/services\/memReporter.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,5 +74,31 @@\n-  inline long diff_in_current_scale(size_t s1, size_t s2) const {\n-    long amount = (long)(s1 - s2);\n-    long scale = (long)_scale;\n-    amount = (amount > 0) ? (amount + scale \/ 2) : (amount - scale \/ 2);\n-    return amount \/ scale;\n+  \/\/ We use int64_t instead of ssize_t because on 32-bit it allows us to express deltas larger than 2 gb.\n+  \/\/ On 64-bit we never expect memory sizes larger than INT64_MAX.\n+  int64_t diff_in_current_scale(size_t s1, size_t s2) const {\n+    assert(_scale != 0, \"wrong scale\");\n+\n+    assert(s1 < INT64_MAX, \"exceeded possible memory limits\");\n+    assert(s2 < INT64_MAX, \"exceeded possible memory limits\");\n+\n+    bool is_negative = false;\n+    if (s1 < s2) {\n+      is_negative = true;\n+      swap(s1, s2);\n+    }\n+\n+    size_t amount = s1 - s2;\n+    \/\/ We can split amount into p + q, where\n+    \/\/     q = amount % _scale\n+    \/\/ and p = amount - q   (which is also (amount \/ _scale) * _scale).\n+    \/\/ Then use\n+    \/\/   size_t scaled = (p + q + _scale\/2) \/ _scale;\n+    \/\/ =>\n+    \/\/   size_t scaled = (p \/ _scale) + ((q + _scale\/2) \/ _scale);\n+    \/\/ The lefthand side of the addition is exact.\n+    \/\/ The righthand side is 0 if q <= (_scale - 1)\/2, else 1. (The -1 is to account for odd _scale values.)\n+    size_t scaled = (amount \/ _scale);\n+    if ((amount % _scale) > (_scale - 1)\/2) {\n+      scaled += 1;\n+    }\n+\n+    int64_t result = static_cast<int64_t>(scaled);\n+    return is_negative ? -result : result;\n","filename":"src\/hotspot\/share\/services\/memReporter.hpp","additions":32,"deletions":6,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-  if (old_map != NULL) {\n+  if (old_map != nullptr) {\n@@ -57,1 +57,1 @@\n-  assert(map() == NULL, \"precondition\");\n+  assert(map() == nullptr, \"precondition\");\n@@ -83,1 +83,1 @@\n-    update(NULL, 0);\n+    update(nullptr, 0);\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-  ChunkedList<T, F>() : _top(_values), _next_used(NULL), _next_free(NULL) {}\n+  ChunkedList<T, F>() : _top(_values), _next_used(nullptr), _next_free(nullptr) {}\n","filename":"src\/hotspot\/share\/utilities\/chunkedList.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -69,1 +70,1 @@\n-    Node(const VALUE& value, Node* next = NULL)\n+    Node(const VALUE& value, Node* next = nullptr)\n@@ -82,1 +83,1 @@\n-    static Node* create_node(void* context, const VALUE& value, Node* next = NULL) {\n+    static Node* create_node(void* context, const VALUE& value, Node* next = nullptr) {\n@@ -140,1 +141,1 @@\n-    Bucket() : _first(NULL) {};\n+    Bucket() : _first(nullptr) {};\n@@ -274,2 +275,11 @@\n-  \/\/ Max number of deletes in one bucket chain during bulk delete.\n-  static const size_t BULK_DELETE_LIMIT = 256;\n+  \/\/ When doing deletes, we need to store the pointers until the next\n+  \/\/ visible epoch.  In the normal case (good hash function and\n+  \/\/ reasonable sizing), we can save these pointers on the stack\n+  \/\/ (there should not be more than a few entries per bucket). But if\n+  \/\/ the hash function is bad and\/or the sizing of the table is bad,\n+  \/\/ we can not use a fixed size stack buffer alone. We will use a\n+  \/\/ heap buffer as fall-back when the stack is not enough, and then\n+  \/\/ we have to pay for a dynamic allocation.  `StackBufferSize` tells\n+  \/\/ the size of optimistic stack buffer that will almost always be\n+  \/\/ used.\n+  static const size_t StackBufferSize = 256;\n@@ -305,1 +315,1 @@\n-                 bool* have_dead, size_t* loops = NULL) const;\n+                 bool* have_dead, size_t* loops = nullptr) const;\n@@ -326,1 +336,1 @@\n-                      bool* grow_hint = NULL);\n+                      bool* grow_hint = nullptr);\n@@ -352,1 +362,1 @@\n-                            size_t num_del, Node** ndel);\n+                            size_t num_del, Node** ndel, GrowableArrayCHeap<Node*, F>& ndel_heap);\n@@ -414,1 +424,1 @@\n-  bool is_safepoint_safe() { return _resize_lock_owner == NULL; }\n+  bool is_safepoint_safe() { return _resize_lock_owner == nullptr; }\n@@ -433,1 +443,1 @@\n-           bool* grow_hint = NULL);\n+           bool* grow_hint = nullptr);\n@@ -439,1 +449,1 @@\n-              bool* grow_hint = NULL, bool* clean_hint = NULL) {\n+              bool* grow_hint = nullptr, bool* clean_hint = nullptr) {\n@@ -450,1 +460,1 @@\n-                  bool* grow_hint = NULL, bool* clean_hint = NULL) {\n+                  bool* grow_hint = nullptr, bool* clean_hint = nullptr) {\n@@ -527,1 +537,1 @@\n-    VALUE* get(LOOKUP_FUNC& lookup_f, bool* grow_hint = NULL);\n+    VALUE* get(LOOKUP_FUNC& lookup_f, bool* grow_hint = nullptr);\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -39,0 +40,2 @@\n+#include <type_traits>\n+\n@@ -50,1 +53,1 @@\n-static const void* POISON_PTR = (void*)UCONST64(0xfbadbadbadbadbac);\n+static void* const POISON_PTR = (void*)UCONST64(0xfbadbadbadbadbac);\n@@ -53,1 +56,1 @@\n-static const void* POISON_PTR = (void*)0xffbadbac;\n+static void* const POISON_PTR = (void*)0xffbadbac;\n@@ -135,1 +138,1 @@\n-  while (clear_state(*ret) != NULL) {\n+  while (clear_state(*ret) != nullptr) {\n@@ -222,2 +225,2 @@\n-  if (Atomic::load_acquire(&_cht->_invisible_epoch) != NULL) {\n-    Atomic::release_store_fence(&_cht->_invisible_epoch, (Thread*)NULL);\n+  if (Atomic::load_acquire(&_cht->_invisible_epoch) != nullptr) {\n+    Atomic::release_store_fence(&_cht->_invisible_epoch, (Thread*)nullptr);\n@@ -252,3 +255,3 @@\n-  Node* pref = prefetch_bucket != NULL ? prefetch_bucket->first() : NULL;\n-  for (Node* next = bucket->first(); next != NULL ; next = next->next()) {\n-    if (pref != NULL) {\n+  Node* pref = prefetch_bucket != nullptr ? prefetch_bucket->first() : nullptr;\n+  for (Node* next = bucket->first(); next != nullptr ; next = next->next()) {\n+    if (pref != nullptr) {\n@@ -261,1 +264,1 @@\n-    if (next_pref != NULL) {\n+    if (next_pref != nullptr) {\n@@ -278,1 +281,1 @@\n-  for (Node* next = bucket->first(); next != NULL ; next = next->next()) {\n+  for (Node* next = bucket->first(); next != nullptr ; next = next->next()) {\n@@ -297,1 +300,1 @@\n-  assert(_invisible_epoch == NULL, \"Two thread doing bulk operations\");\n+  assert(_invisible_epoch == nullptr, \"Two thread doing bulk operations\");\n@@ -309,1 +312,1 @@\n-    if (_resize_lock_owner != NULL) {\n+    if (_resize_lock_owner != nullptr) {\n@@ -335,1 +338,1 @@\n-    if (_resize_lock_owner != NULL) {\n+    if (_resize_lock_owner != nullptr) {\n@@ -354,1 +357,1 @@\n-  _resize_lock_owner = NULL;\n+  _resize_lock_owner = nullptr;\n@@ -366,1 +369,1 @@\n-    while (node != NULL) {\n+    while (node != nullptr) {\n@@ -401,1 +404,1 @@\n-  _new_table = NULL;\n+  _new_table = nullptr;\n@@ -411,1 +414,1 @@\n-  assert(_new_table != NULL, \"Grow not proper setup before start\");\n+  assert(_new_table != nullptr, \"Grow not proper setup before start\");\n@@ -456,1 +459,1 @@\n-  while (rem_n != NULL) {\n+  while (rem_n != nullptr) {\n@@ -468,1 +471,1 @@\n-  if (rem_n == NULL) {\n+  if (rem_n == nullptr) {\n@@ -487,1 +490,1 @@\n-  assert((is_mt && _resize_lock_owner != NULL) ||\n+  assert((is_mt && _resize_lock_owner != nullptr) ||\n@@ -489,1 +492,1 @@\n-  Node* ndel[BULK_DELETE_LIMIT];\n+  Node* ndel_stack[StackBufferSize];\n@@ -502,1 +505,1 @@\n-                              table->get_bucket(bucket_it+1) : NULL;\n+                              table->get_bucket(bucket_it+1) : nullptr;\n@@ -504,1 +507,1 @@\n-    if (!HaveDeletables<IsPointer<VALUE>::value, EVALUATE_FUNC>::\n+    if (!HaveDeletables<std::is_pointer<VALUE>::value, EVALUATE_FUNC>::\n@@ -514,1 +517,2 @@\n-    size_t nd = delete_check_nodes(bucket, eval_f, BULK_DELETE_LIMIT, ndel);\n+    GrowableArrayCHeap<Node*, F> extra(0); \/\/ use this buffer if StackBufferSize is not enough\n+    size_t nd = delete_check_nodes(bucket, eval_f, StackBufferSize, ndel_stack, extra);\n@@ -522,2 +526,3 @@\n-      del_f(ndel[node_it]->value());\n-      Node::destroy_node(_context, ndel[node_it]);\n+      Node*& ndel = node_it < StackBufferSize ? ndel_stack[node_it] : extra.at(static_cast<int>(node_it - StackBufferSize));\n+      del_f(ndel->value());\n+      Node::destroy_node(_context, ndel);\n@@ -525,1 +530,1 @@\n-      DEBUG_ONLY(ndel[node_it] = (Node*)POISON_PTR;)\n+      DEBUG_ONLY(ndel = static_cast<Node*>(POISON_PTR);)\n@@ -540,1 +545,1 @@\n-  Node* ndel[BULK_DELETE_LIMIT];\n+  Node* ndel[StackBufferSize];\n@@ -543,1 +548,1 @@\n-  while (rem_n != NULL) {\n+  while (rem_n != nullptr) {\n@@ -551,1 +556,1 @@\n-      if (dels == BULK_DELETE_LIMIT) {\n+      if (dels == StackBufferSize) {\n@@ -623,1 +628,1 @@\n-  while (node != NULL) {\n+  while (node != nullptr) {\n@@ -634,1 +639,1 @@\n-  if (loops != NULL) {\n+  if (loops != nullptr) {\n@@ -646,1 +651,1 @@\n-  if (aux == NULL) {\n+  if (aux == nullptr) {\n@@ -652,1 +657,1 @@\n-  Node* delete_me = NULL;\n+  Node* delete_me = nullptr;\n@@ -655,1 +660,1 @@\n-  while (aux != NULL) {\n+  while (aux != nullptr) {\n@@ -690,1 +695,1 @@\n-    if (delete_me != NULL) {\n+    if (delete_me != nullptr) {\n@@ -692,1 +697,1 @@\n-      delete_me = NULL;\n+      delete_me = nullptr;\n@@ -790,1 +795,1 @@\n-  assert(_table != NULL, \"table failed\");\n+  assert(_table != nullptr, \"table failed\");\n@@ -867,1 +872,1 @@\n-  VALUE* ret = NULL;\n+  VALUE* ret = nullptr;\n@@ -871,1 +876,1 @@\n-  if (node != NULL) {\n+  if (node != nullptr) {\n@@ -874,1 +879,1 @@\n-  if (grow_hint != NULL) {\n+  if (grow_hint != nullptr) {\n@@ -893,1 +898,1 @@\n-  Node* new_node = Node::create_node(_context, value, NULL);\n+  Node* new_node = Node::create_node(_context, value, nullptr);\n@@ -901,1 +906,1 @@\n-      if (old == NULL) {\n+      if (old == nullptr) {\n@@ -906,1 +911,1 @@\n-          new_node = NULL;\n+          new_node = nullptr;\n@@ -926,1 +931,1 @@\n-  if (new_node != NULL) {\n+  if (new_node != nullptr) {\n@@ -937,1 +942,1 @@\n-  if (grow_hint != NULL) {\n+  if (grow_hint != nullptr) {\n@@ -941,1 +946,1 @@\n-  if (clean_hint != NULL) {\n+  if (clean_hint != nullptr) {\n@@ -954,1 +959,1 @@\n-  while (current_node != NULL) {\n+  while (current_node != nullptr) {\n@@ -985,1 +990,1 @@\n-                     size_t num_del, Node** ndel)\n+                     size_t num_del, Node** ndel, GrowableArrayCHeap<Node*, F>& extra)\n@@ -990,1 +995,1 @@\n-  while (rem_n != NULL) {\n+  while (rem_n != nullptr) {\n@@ -992,1 +997,8 @@\n-      ndel[dels++] = rem_n;\n+      if (dels < num_del) {\n+        ndel[dels] = rem_n;\n+      } else {\n+        guarantee(dels < std::numeric_limits<int>::max(),\n+                  \"Growable array size is limited by a (signed) int, something is seriously bad if we reach this point, better exit\");\n+        extra.append(rem_n);\n+      }\n+      ++dels;\n@@ -996,3 +1008,0 @@\n-      if (dels == num_del) {\n-        break;\n-      }\n@@ -1011,1 +1020,1 @@\n-    : _context(context), _new_table(NULL), _log2_size_limit(log2size_limit),\n+    : _context(context), _new_table(nullptr), _log2_size_limit(log2size_limit),\n@@ -1013,1 +1022,1 @@\n-      _size_limit_reached(false), _resize_lock_owner(NULL),\n+      _size_limit_reached(false), _resize_lock_owner(nullptr),\n@@ -1087,1 +1096,1 @@\n-  if (val != NULL) {\n+  if (val != nullptr) {\n@@ -1157,1 +1166,1 @@\n-  if (table == NULL) {\n+  if (table == nullptr) {\n@@ -1232,1 +1241,1 @@\n-    while (current_node != NULL) {\n+    while (current_node != nullptr) {\n@@ -1286,1 +1295,1 @@\n-  assert(_new_table == NULL || _new_table == POISON_PTR, \"Must be NULL\");\n+  assert(_new_table == nullptr || _new_table == POISON_PTR, \"Must be nullptr\");\n@@ -1290,1 +1299,1 @@\n-    while (bucket->first() != NULL) {\n+    while (bucket->first() != nullptr) {\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":71,"deletions":62,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,1 +172,1 @@\n-    assert(BucketsOperation::_cht->_resize_lock_owner != NULL,\n+    assert(BucketsOperation::_cht->_resize_lock_owner != nullptr,\n@@ -180,1 +180,1 @@\n-    assert(BucketsOperation::_cht->_resize_lock_owner != NULL,\n+    assert(BucketsOperation::_cht->_resize_lock_owner != nullptr,\n@@ -213,1 +213,1 @@\n-    assert(BucketsOperation::_cht->_resize_lock_owner != NULL,\n+    assert(BucketsOperation::_cht->_resize_lock_owner != nullptr,\n@@ -219,1 +219,1 @@\n-    assert(BucketsOperation::_cht->_resize_lock_owner != NULL,\n+    assert(BucketsOperation::_cht->_resize_lock_owner != nullptr,\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTableTasks.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,2 +70,2 @@\n-    assert(src != NULL, \"address must not be NULL\");\n-    assert(dst != NULL, \"address must not be NULL\");\n+    assert(src != nullptr, \"address must not be nullptr\");\n+    assert(dst != nullptr, \"address must not be nullptr\");\n","filename":"src\/hotspot\/share\/utilities\/copy.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-static void* g_assertion_context = NULL;\n+static void* g_assertion_context = nullptr;\n@@ -113,1 +113,1 @@\n-    if (s != NULL && ::strcmp(s, \"1\") == 0) {\n+    if (s != nullptr && ::strcmp(s, \"1\") == 0) {\n@@ -138,1 +138,1 @@\n-static const char* last_file_name = NULL;\n+static const char* last_file_name = nullptr;\n@@ -152,1 +152,1 @@\n-  if (base_name == NULL)\n+  if (base_name == nullptr)\n@@ -188,1 +188,1 @@\n-             && (foundp = strchr(look, sfile[0])) != NULL\n+             && (foundp = strchr(look, sfile[0])) != nullptr\n@@ -248,1 +248,1 @@\n-    if (detail_fmt != NULL) {\n+    if (detail_fmt != nullptr) {\n@@ -257,1 +257,1 @@\n-      if (message == NULL) {\n+      if (message == nullptr) {\n@@ -277,1 +277,1 @@\n-  void* context = NULL;\n+  void* context = nullptr;\n@@ -279,1 +279,1 @@\n-  if (g_assertion_context != NULL && os::current_thread_id() == g_asserting_thread) {\n+  if (g_assertion_context != nullptr && os::current_thread_id() == g_asserting_thread) {\n@@ -299,1 +299,1 @@\n-  void* context = NULL;\n+  void* context = nullptr;\n@@ -301,1 +301,1 @@\n-  if (g_assertion_context != NULL && os::current_thread_id() == g_asserting_thread) {\n+  if (g_assertion_context != nullptr && os::current_thread_id() == g_asserting_thread) {\n@@ -309,1 +309,1 @@\n-                          Thread::current_or_null(), NULL, NULL, context,\n+                          Thread::current_or_null(), nullptr, nullptr, context,\n@@ -320,1 +320,1 @@\n-  print_error_for_unit_test(NULL, detail_fmt, detail_args);\n+  print_error_for_unit_test(nullptr, detail_fmt, detail_args);\n@@ -424,2 +424,2 @@\n-  if (cb == NULL) {\n-    tty->print_cr(\"NULL\");\n+  if (cb == nullptr) {\n+    tty->print_cr(\"null\");\n@@ -435,1 +435,1 @@\n-  if (cb != NULL) {\n+  if (cb != nullptr) {\n@@ -437,1 +437,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -452,1 +452,1 @@\n-  if (cb != NULL && cb->is_nmethod()) {\n+  if (cb != nullptr && cb->is_nmethod()) {\n@@ -487,2 +487,2 @@\n-  if (p == NULL) {\n-    tty->print_cr(\"NULL\");\n+  if (p == nullptr) {\n+    tty->print_cr(\"null\");\n@@ -519,1 +519,1 @@\n-  if (Thread::current_or_null() == NULL) return;\n+  if (Thread::current_or_null() == nullptr) return;\n@@ -586,1 +586,1 @@\n-  if (Thread::current_or_null() == NULL) return;\n+  if (Thread::current_or_null() == nullptr) return;\n@@ -623,1 +623,1 @@\n-  return (nm == NULL) ? (Method*)NULL : nm->method();\n+  return (nm == nullptr) ? (Method*)nullptr : nm->method();\n@@ -764,1 +764,1 @@\n-  if (os::platform_print_native_stack(tty, NULL, buf, sizeof(buf))) {\n+  if (os::platform_print_native_stack(tty, nullptr, buf, sizeof(buf))) {\n@@ -778,1 +778,1 @@\n-  return p != NULL && SafeFetchN((intptr_t*)const_cast<void*>(p), errvalue) != errvalue;\n+  return p != nullptr && SafeFetchN((intptr_t*)const_cast<void*>(p), errvalue) != errvalue;\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n-AbstractDecoder*  Decoder::_shared_decoder = NULL;\n-AbstractDecoder*  Decoder::_error_handler_decoder = NULL;\n+AbstractDecoder*  Decoder::_shared_decoder = nullptr;\n+AbstractDecoder*  Decoder::_error_handler_decoder = nullptr;\n@@ -48,1 +48,1 @@\n-  if (_shared_decoder == NULL) {\n+  if (_shared_decoder == nullptr) {\n@@ -55,1 +55,1 @@\n-  if (_error_handler_decoder == NULL) {\n+  if (_error_handler_decoder == nullptr) {\n@@ -72,2 +72,2 @@\n-  if (decoder == NULL || decoder->has_error()) {\n-    if (decoder != NULL) {\n+  if (decoder == nullptr || decoder->has_error()) {\n+    if (decoder != nullptr) {\n@@ -82,1 +82,1 @@\n-  assert(SharedDecoder_lock != NULL, \"Just check\");\n+  assert(SharedDecoder_lock != nullptr, \"Just check\");\n","filename":"src\/hotspot\/share\/utilities\/decoder.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-                      const char* modulepath = NULL, bool demangle = true) = 0;\n+                      const char* modulepath = nullptr, bool demangle = true) = 0;\n@@ -109,1 +109,1 @@\n-  static bool decode(address pc, char* buf, int buflen, int* offset, const char* modulepath = NULL, bool demangle = true);\n+  static bool decode(address pc, char* buf, int buflen, int* offset, const char* modulepath = nullptr, bool demangle = true);\n@@ -111,1 +111,1 @@\n-    return decode(pc, buf, buflen, offset, (const char*) NULL, demangle);\n+    return decode(pc, buf, buflen, offset, (const char*) nullptr, demangle);\n@@ -117,1 +117,1 @@\n-  \/\/ If filename != NULL, points to a buffer of size filename_len which will receive the\n+  \/\/ If filename != nullptr, points to a buffer of size filename_len which will receive the\n","filename":"src\/hotspot\/share\/utilities\/decoder.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-  if (_opened_elf_files != NULL) {\n+  if (_opened_elf_files != nullptr) {\n@@ -35,1 +35,1 @@\n-    _opened_elf_files = NULL;\n+    _opened_elf_files = nullptr;\n@@ -41,1 +41,1 @@\n-  assert(buf != NULL && buflen > 0, \"Invalid buffer\");\n+  assert(buf != nullptr && buflen > 0, \"Invalid buffer\");\n@@ -44,1 +44,1 @@\n-  if (file == NULL) {\n+  if (file == nullptr) {\n@@ -84,1 +84,1 @@\n-  if (file == NULL) {\n+  if (file == nullptr) {\n@@ -109,1 +109,1 @@\n-  while (file != NULL) {\n+  while (file != nullptr) {\n@@ -117,2 +117,2 @@\n-  if (file != NULL) {\n-    if (_opened_elf_files != NULL) {\n+  if (file != nullptr) {\n+    if (_opened_elf_files != nullptr) {\n","filename":"src\/hotspot\/share\/utilities\/decoder_elf.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    _opened_elf_files = NULL;\n+    _opened_elf_files = nullptr;\n","filename":"src\/hotspot\/share\/utilities\/decoder_elf.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-    _log_file = NULL;\n+    _log_file = nullptr;\n","filename":"src\/hotspot\/share\/utilities\/defaultStream.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-ElfSection::ElfSection(FILE* fd, const Elf_Shdr& hdr) : _section_data(NULL) {\n+ElfSection::ElfSection(FILE* fd, const Elf_Shdr& hdr) : _section_data(nullptr) {\n@@ -54,1 +54,1 @@\n-  if (_section_data != NULL) {\n+  if (_section_data != nullptr) {\n@@ -70,1 +70,1 @@\n-  if (_section_data == NULL) return NullDecoder::no_error;\n+  if (_section_data == nullptr) return NullDecoder::no_error;\n@@ -79,1 +79,1 @@\n-    _section_data = NULL;\n+    _section_data = nullptr;\n@@ -85,1 +85,1 @@\n-  assert(buf != NULL, \"no buffer\");\n+  assert(buf != nullptr, \"no buffer\");\n@@ -91,1 +91,1 @@\n-  assert(buf != NULL, \"no buffer\");\n+  assert(buf != nullptr, \"no buffer\");\n@@ -110,2 +110,2 @@\n-  _next(NULL), _filepath(os::strdup(filepath)), _file(NULL),\n-  _symbol_tables(NULL), _string_tables(NULL), _shdr_string_table(NULL), _funcDesc_table(NULL),\n+  _next(nullptr), _filepath(os::strdup(filepath)), _file(nullptr),\n+  _symbol_tables(nullptr), _string_tables(nullptr), _shdr_string_table(nullptr), _funcDesc_table(nullptr),\n@@ -124,1 +124,1 @@\n-  if (_file != NULL) {\n+  if (_file != nullptr) {\n@@ -168,1 +168,1 @@\n-  if (_file != NULL) {\n+  if (_file != nullptr) {\n@@ -214,1 +214,1 @@\n-      if (table == NULL) {\n+      if (table == nullptr) {\n@@ -218,1 +218,1 @@\n-        assert(_shdr_string_table == NULL, \"Only set once\");\n+        assert(_shdr_string_table == nullptr, \"Only set once\");\n@@ -226,1 +226,1 @@\n-      if (table == NULL) {\n+      if (table == nullptr) {\n@@ -250,1 +250,1 @@\n-  if (_funcDesc_table == NULL) {\n+  if (_funcDesc_table == nullptr) {\n@@ -259,1 +259,1 @@\n-  assert(name != NULL, \"No section name\");\n+  assert(name != nullptr, \"No section name\");\n@@ -262,1 +262,1 @@\n-  if (buf == NULL) {\n+  if (buf == nullptr) {\n@@ -266,1 +266,1 @@\n-  assert(_shdr_string_table != NULL, \"Section header string table should be loaded\");\n+  assert(_shdr_string_table != nullptr, \"Section header string table should be loaded\");\n@@ -302,1 +302,1 @@\n-  while (symbol_table != NULL) {\n+  while (symbol_table != nullptr) {\n@@ -315,1 +315,1 @@\n-  if (string_table == NULL) {\n+  if (string_table == nullptr) {\n@@ -325,1 +325,1 @@\n-  if (_symbol_tables == NULL) {\n+  if (_symbol_tables == nullptr) {\n@@ -334,1 +334,1 @@\n-  if (_string_tables == NULL) {\n+  if (_string_tables == nullptr) {\n@@ -344,1 +344,1 @@\n-  while (p != NULL) {\n+  while (p != nullptr) {\n@@ -348,1 +348,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/utilities\/elfFile.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -186,2 +186,2 @@\n-    assert(filepath != NULL, \"null file path\");\n-    return (_filepath != NULL && !strcmp(filepath, _filepath));\n+    assert(filepath != nullptr, \"null file path\");\n+    return (_filepath != nullptr && !strcmp(filepath, _filepath));\n","filename":"src\/hotspot\/share\/utilities\/elfFile.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -58,1 +58,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -61,1 +61,1 @@\n-  if (func_descs != NULL) {\n+  if (func_descs != nullptr) {\n@@ -70,1 +70,1 @@\n-      return NULL;\n+      return nullptr;\n","filename":"src\/hotspot\/share\/utilities\/elfFuncDescTable.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-  \/\/ return the function address for the function descriptor at 'index' or NULL on error\n+  \/\/ return the function address for the function descriptor at 'index' or nullptr on error\n","filename":"src\/hotspot\/share\/utilities\/elfFuncDescTable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  _next(NULL), _index(index), _section(file, shdr), _fd(file) {\n+  _next(nullptr), _index(index), _section(file, shdr), _fd(file) {\n@@ -42,1 +42,1 @@\n-  if (_next != NULL) {\n+  if (_next != nullptr) {\n@@ -58,1 +58,1 @@\n-  if (data != NULL) {\n+  if (data != nullptr) {\n","filename":"src\/hotspot\/share\/utilities\/elfStringTable.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n-  _next(NULL), _fd(file), _section(file, shdr) {\n-  assert(file != NULL, \"null file handle\");\n+  _next(nullptr), _fd(file), _section(file, shdr) {\n+  assert(file != nullptr, \"null file handle\");\n@@ -44,1 +44,1 @@\n-  if (_next != NULL) {\n+  if (_next != nullptr) {\n@@ -54,1 +54,1 @@\n-    if (funcDescTable != NULL && funcDescTable->get_index() == sym->st_shndx) {\n+    if (funcDescTable != nullptr && funcDescTable->get_index() == sym->st_shndx) {\n@@ -83,1 +83,1 @@\n-  if (symbols != NULL) {\n+  if (symbols != nullptr) {\n","filename":"src\/hotspot\/share\/utilities\/elfSymbolTable.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,9 +36,9 @@\n-EventLog* Events::_logs = NULL;\n-StringEventLog* Events::_messages = NULL;\n-StringEventLog* Events::_vm_operations = NULL;\n-ExceptionsEventLog* Events::_exceptions = NULL;\n-StringEventLog* Events::_redefinitions = NULL;\n-UnloadingEventLog* Events::_class_unloading = NULL;\n-StringEventLog* Events::_class_loading = NULL;\n-StringEventLog* Events::_deopt_messages = NULL;\n-StringEventLog* Events::_dll_messages = NULL;\n+EventLog* Events::_logs = nullptr;\n+StringEventLog* Events::_messages = nullptr;\n+StringEventLog* Events::_vm_operations = nullptr;\n+ExceptionsEventLog* Events::_exceptions = nullptr;\n+StringEventLog* Events::_redefinitions = nullptr;\n+UnloadingEventLog* Events::_class_unloading = nullptr;\n+StringEventLog* Events::_class_loading = nullptr;\n+StringEventLog* Events::_deopt_messages = nullptr;\n+StringEventLog* Events::_dll_messages = nullptr;\n@@ -59,1 +59,1 @@\n-  while (log != NULL) {\n+  while (log != nullptr) {\n@@ -69,1 +69,1 @@\n-  while (log != NULL) {\n+  while (log != nullptr) {\n@@ -81,1 +81,1 @@\n-    while (log != NULL) {\n+    while (log != nullptr) {\n@@ -121,1 +121,1 @@\n-  _log_function(NULL, \"%s\", _buffer.buffer());\n+  _log_function(nullptr, \"%s\", _buffer.buffer());\n@@ -127,1 +127,1 @@\n-  _log_function(NULL, \"%s\", _buffer.buffer());\n+  _log_function(nullptr, \"%s\", _buffer.buffer());\n","filename":"src\/hotspot\/share\/utilities\/events.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,1 +151,1 @@\n-    if (e.thread != NULL) {\n+    if (e.thread != nullptr) {\n@@ -280,1 +280,1 @@\n-  if (LogEvents && _messages != NULL) {\n+  if (LogEvents && _messages != nullptr) {\n@@ -289,1 +289,1 @@\n-  if (LogEvents && _vm_operations != NULL) {\n+  if (LogEvents && _vm_operations != nullptr) {\n@@ -298,1 +298,1 @@\n-  if (LogEvents && _exceptions != NULL) {\n+  if (LogEvents && _exceptions != nullptr) {\n@@ -307,1 +307,1 @@\n-  if (LogEvents && _exceptions != NULL) {\n+  if (LogEvents && _exceptions != nullptr) {\n@@ -313,1 +313,1 @@\n-  if (LogEvents && _redefinitions != NULL) {\n+  if (LogEvents && _redefinitions != nullptr) {\n@@ -322,1 +322,1 @@\n-  if (LogEvents && _class_unloading != NULL) {\n+  if (LogEvents && _class_unloading != nullptr) {\n@@ -328,1 +328,1 @@\n-  if (LogEvents && _class_loading != NULL) {\n+  if (LogEvents && _class_loading != nullptr) {\n@@ -337,1 +337,1 @@\n-  if (LogEvents && _deopt_messages != NULL) {\n+  if (LogEvents && _deopt_messages != nullptr) {\n@@ -346,1 +346,1 @@\n-  if (LogEvents && _dll_messages != NULL) {\n+  if (LogEvents && _dll_messages != nullptr) {\n@@ -362,1 +362,1 @@\n-      if (Thread::current_or_null() == NULL) {\n+      if (Thread::current_or_null() == nullptr) {\n","filename":"src\/hotspot\/share\/utilities\/events.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-  assert(exception != NULL && oopDesc::is_oop(exception), \"invalid exception oop\");\n+  assert(exception != nullptr && oopDesc::is_oop(exception), \"invalid exception oop\");\n@@ -64,1 +64,1 @@\n-  if (_pending_exception != NULL && lt.is_enabled()) {\n+  if (_pending_exception != nullptr && lt.is_enabled()) {\n@@ -70,2 +70,2 @@\n-  _pending_exception = NULL;\n-  _exception_file    = NULL;\n+  _pending_exception = nullptr;\n+  _exception_file    = nullptr;\n@@ -117,1 +117,1 @@\n-    if (h_name == NULL) {\n+    if (h_name == nullptr) {\n@@ -138,1 +138,1 @@\n-  assert(exception != NULL, \"exception should not be NULL\");\n+  assert(exception != nullptr, \"exception should not be nullptr\");\n@@ -145,1 +145,1 @@\n-  assert(h_exception() != NULL, \"exception should not be NULL\");\n+  assert(h_exception() != nullptr, \"exception should not be nullptr\");\n@@ -192,1 +192,1 @@\n-  Handle h_cause(thread, NULL);\n+  Handle h_cause(thread, nullptr);\n@@ -212,1 +212,1 @@\n-  _throw(thread, file, line, h_exception, NULL);\n+  _throw(thread, file, line, h_exception, nullptr);\n@@ -217,1 +217,1 @@\n-  if (special_exception(thread, file, line, name, NULL)) return;\n+  if (special_exception(thread, file, line, name, nullptr)) return;\n@@ -219,2 +219,2 @@\n-  Handle h_loader(thread, NULL);\n-  Handle h_prot(thread, NULL);\n+  Handle h_loader(thread, nullptr);\n+  Handle h_prot(thread, nullptr);\n@@ -229,1 +229,1 @@\n-  _throw_msg_cause(thread, file, line, name, message, h_cause, Handle(thread, NULL), Handle(thread, NULL));\n+  _throw_msg_cause(thread, file, line, name, message, h_cause, Handle(thread, nullptr), Handle(thread, nullptr));\n@@ -232,1 +232,1 @@\n-  _throw_msg(thread, file, line, name, message, Handle(thread, NULL), Handle(thread, NULL));\n+  _throw_msg(thread, file, line, name, message, Handle(thread, nullptr), Handle(thread, nullptr));\n@@ -235,1 +235,1 @@\n-  _throw_cause(thread, file, line, name, h_cause, Handle(thread, NULL), Handle(thread, NULL));\n+  _throw_cause(thread, file, line, name, h_cause, Handle(thread, nullptr), Handle(thread, nullptr));\n@@ -284,1 +284,1 @@\n-    assert(klass != NULL, \"klass must exist\");\n+    assert(klass != nullptr, \"klass must exist\");\n@@ -338,1 +338,1 @@\n-  Symbol* signature = NULL;\n+  Symbol* signature = nullptr;\n@@ -355,2 +355,2 @@\n-  Symbol* signature = NULL;\n-  if (message == NULL) {\n+  Symbol* signature = nullptr;\n+  if (message == nullptr) {\n@@ -404,3 +404,3 @@\n-  Handle       h_loader(thread, NULL);\n-  Handle       h_prot(thread, NULL);\n-  Handle       h_cause(thread, NULL);\n+  Handle       h_loader(thread, nullptr);\n+  Handle       h_prot(thread, nullptr);\n+  Handle       h_cause(thread, nullptr);\n@@ -423,1 +423,1 @@\n-    LogStream* ls = NULL;\n+    LogStream* ls = nullptr;\n@@ -436,1 +436,1 @@\n-      if (ls != NULL) {\n+      if (ls != nullptr) {\n@@ -444,1 +444,1 @@\n-    if (ls != NULL) {\n+    if (ls != nullptr) {\n@@ -535,1 +535,1 @@\n-  if (AbortVMOnException != NULL && value_string != NULL &&\n+  if (AbortVMOnException != nullptr && value_string != nullptr &&\n@@ -537,1 +537,1 @@\n-    if (AbortVMOnExceptionMessage == NULL || (message != NULL &&\n+    if (AbortVMOnExceptionMessage == nullptr || (message != nullptr &&\n@@ -539,1 +539,1 @@\n-      if (message == NULL) {\n+      if (message == nullptr) {\n@@ -549,1 +549,1 @@\n-  if (AbortVMOnException != NULL) {\n+  if (AbortVMOnException != nullptr) {\n@@ -556,1 +556,1 @@\n-  if (message == NULL && exception->is_a(vmClasses::Throwable_klass())) {\n+  if (message == nullptr && exception->is_a(vmClasses::Throwable_klass())) {\n@@ -558,1 +558,1 @@\n-    if (msg != NULL) {\n+    if (msg != nullptr) {\n@@ -569,1 +569,1 @@\n-  if (detail_message != NULL) {\n+  if (detail_message != nullptr) {\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-  bool has_pending_exception() const             { return _pending_exception != NULL; }\n+  bool has_pending_exception() const             { return _pending_exception != nullptr; }\n@@ -97,2 +97,2 @@\n-  ThreadShadow() : _pending_exception(NULL),\n-                   _exception_file(NULL), _exception_line(0) {}\n+  ThreadShadow() : _pending_exception(nullptr),\n+                   _exception_file(nullptr), _exception_line(0) {}\n@@ -127,1 +127,1 @@\n-  static void _throw(JavaThread* thread, const char* file, int line, Handle exception, const char* msg = NULL);\n+  static void _throw(JavaThread* thread, const char* file, int line, Handle exception, const char* msg = nullptr);\n@@ -187,3 +187,3 @@\n-  static void debug_check_abort(Handle exception, const char* message = NULL);\n-  static void debug_check_abort_helper(Handle exception, const char* message = NULL);\n-  static void debug_check_abort(const char *value_string, const char* message = NULL);\n+  static void debug_check_abort(Handle exception, const char* message = nullptr);\n+  static void debug_check_abort_helper(Handle exception, const char* message = nullptr);\n+  static void debug_check_abort(const char *value_string, const char* message = nullptr);\n@@ -228,1 +228,1 @@\n-#define CHECK_NULL                               CHECK_(NULL)\n+#define CHECK_NULL                               CHECK_(nullptr)\n@@ -237,1 +237,1 @@\n-#define CHECK_AND_CLEAR_NULL                    CHECK_AND_CLEAR_(NULL)\n+#define CHECK_AND_CLEAR_NULL                    CHECK_AND_CLEAR_(nullptr)\n@@ -247,1 +247,1 @@\n-#define CHECK_AND_CLEAR_NONASYNC_NULL           CHECK_AND_CLEAR_NONASYNC_(NULL)\n+#define CHECK_AND_CLEAR_NONASYNC_NULL           CHECK_AND_CLEAR_NONASYNC_(nullptr)\n@@ -263,1 +263,1 @@\n-  { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, NULL); return;  }\n+  { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, nullptr); return;  }\n@@ -284,1 +284,1 @@\n-  { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, NULL); return result; }\n+  { Exceptions::_throw_msg(THREAD_AND_LOCATION, name, nullptr); return result; }\n@@ -309,1 +309,1 @@\n-#define THROW_MSG_CAUSE_NULL(name, message, cause) THROW_MSG_CAUSE_(name, message, cause, NULL)\n+#define THROW_MSG_CAUSE_NULL(name, message, cause) THROW_MSG_CAUSE_(name, message, cause, nullptr)\n@@ -311,2 +311,2 @@\n-#define THROW_NULL(name)                    THROW_(name, NULL)\n-#define THROW_MSG_NULL(name, message)       THROW_MSG_(name, message, NULL)\n+#define THROW_NULL(name)                    THROW_(name, nullptr)\n+#define THROW_MSG_NULL(name, message)       THROW_MSG_(name, message, nullptr)\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    Node(const E& e): _next(NULL), _data(e) { }\n+    Node(const E& e): _next(nullptr), _data(e) { }\n@@ -53,1 +53,1 @@\n-  FilterQueue() : _first(NULL) { }\n+  FilterQueue() : _first(nullptr) { }\n@@ -56,1 +56,1 @@\n-    return load_first() == NULL;\n+    return load_first() == nullptr;\n","filename":"src\/hotspot\/share\/utilities\/filterQueue.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-  if (cur == NULL) {\n+  if (cur == nullptr) {\n@@ -60,1 +60,1 @@\n-  } while (cur != NULL);\n+  } while (cur != nullptr);\n@@ -70,3 +70,3 @@\n-  Node*  prev        = NULL;\n-  Node*  match       = NULL;\n-  Node*  match_prev  = NULL;\n+  Node*  prev        = nullptr;\n+  Node*  match       = nullptr;\n+  Node*  match_prev  = nullptr;\n@@ -74,2 +74,2 @@\n-  if (cur == NULL) {\n-    return (E)NULL;\n+  if (cur == nullptr) {\n+    return (E)nullptr;\n@@ -86,1 +86,1 @@\n-    } while (cur != NULL);\n+    } while (cur != nullptr);\n@@ -88,2 +88,2 @@\n-    if (match == NULL) {\n-      return (E)NULL;\n+    if (match == nullptr) {\n+      return (E)nullptr;\n@@ -92,1 +92,1 @@\n-    if (match_prev == NULL) {\n+    if (match_prev == nullptr) {\n@@ -103,3 +103,3 @@\n-      prev        = NULL;\n-      match       = NULL;\n-      match_prev  = NULL;\n+      prev        = nullptr;\n+      match       = nullptr;\n+      match_prev  = nullptr;\n@@ -121,1 +121,1 @@\n-  Node*  match       = NULL;\n+  Node*  match       = nullptr;\n@@ -123,2 +123,2 @@\n-  if (cur == NULL) {\n-    return (E)NULL;\n+  if (cur == nullptr) {\n+    return (E)nullptr;\n@@ -131,1 +131,1 @@\n-  } while (cur != NULL);\n+  } while (cur != nullptr);\n@@ -133,2 +133,2 @@\n-  if (match == NULL) {\n-    return (E)NULL;\n+  if (match == nullptr) {\n+    return (E)nullptr;\n","filename":"src\/hotspot\/share\/utilities\/filterQueue.inline.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,5 +81,5 @@\n-  assert(min_intx ==  (intx)CONST64(0x8000000000000000), \"correct constant\");\n-  assert(max_intx ==  CONST64(0x7FFFFFFFFFFFFFFF), \"correct constant\");\n-  assert(max_uintx == CONST64(0xFFFFFFFFFFFFFFFF), \"correct constant\");\n-  assert( 8 == sizeof( intx),      \"wrong size for basic type\");\n-  assert( 8 == sizeof( jobject),   \"wrong size for basic type\");\n+  static_assert(min_intx ==  (intx)CONST64(0x8000000000000000), \"correct constant\");\n+  static_assert(max_intx ==  CONST64(0x7FFFFFFFFFFFFFFF), \"correct constant\");\n+  static_assert(max_uintx == CONST64(0xFFFFFFFFFFFFFFFF), \"correct constant\");\n+  static_assert( 8 == sizeof( intx),      \"wrong size for basic type\");\n+  static_assert( 8 == sizeof( jobject),   \"wrong size for basic type\");\n@@ -87,5 +87,5 @@\n-  assert(min_intx ==  (intx)0x80000000,  \"correct constant\");\n-  assert(max_intx ==  0x7FFFFFFF,  \"correct constant\");\n-  assert(max_uintx == 0xFFFFFFFF,  \"correct constant\");\n-  assert( 4 == sizeof( intx),      \"wrong size for basic type\");\n-  assert( 4 == sizeof( jobject),   \"wrong size for basic type\");\n+  static_assert(min_intx ==  (intx)0x80000000,  \"correct constant\");\n+  static_assert(max_intx ==  0x7FFFFFFF,  \"correct constant\");\n+  static_assert(max_uintx == 0xFFFFFFFF,  \"correct constant\");\n+  static_assert( 4 == sizeof( intx),      \"wrong size for basic type\");\n+  static_assert( 4 == sizeof( jobject),   \"wrong size for basic type\");\n@@ -93,17 +93,17 @@\n-  assert( (~max_juint) == 0,  \"max_juint has all its bits\");\n-  assert( (~max_uintx) == 0,  \"max_uintx has all its bits\");\n-  assert( (~max_julong) == 0, \"max_julong has all its bits\");\n-  assert( 1 == sizeof( jbyte),     \"wrong size for basic type\");\n-  assert( 2 == sizeof( jchar),     \"wrong size for basic type\");\n-  assert( 2 == sizeof( jshort),    \"wrong size for basic type\");\n-  assert( 4 == sizeof( juint),     \"wrong size for basic type\");\n-  assert( 4 == sizeof( jint),      \"wrong size for basic type\");\n-  assert( 1 == sizeof( jboolean),  \"wrong size for basic type\");\n-  assert( 8 == sizeof( jlong),     \"wrong size for basic type\");\n-  assert( 4 == sizeof( jfloat),    \"wrong size for basic type\");\n-  assert( 8 == sizeof( jdouble),   \"wrong size for basic type\");\n-  assert( 1 == sizeof( u1),        \"wrong size for basic type\");\n-  assert( 2 == sizeof( u2),        \"wrong size for basic type\");\n-  assert( 4 == sizeof( u4),        \"wrong size for basic type\");\n-  assert(wordSize == BytesPerWord, \"should be the same since they're used interchangeably\");\n-  assert(wordSize == HeapWordSize, \"should be the same since they're also used interchangeably\");\n+  static_assert( (~max_juint) == 0,  \"max_juint has all its bits\");\n+  static_assert( (~max_uintx) == 0,  \"max_uintx has all its bits\");\n+  static_assert( (~max_julong) == 0, \"max_julong has all its bits\");\n+  static_assert( 1 == sizeof( jbyte),     \"wrong size for basic type\");\n+  static_assert( 2 == sizeof( jchar),     \"wrong size for basic type\");\n+  static_assert( 2 == sizeof( jshort),    \"wrong size for basic type\");\n+  static_assert( 4 == sizeof( juint),     \"wrong size for basic type\");\n+  static_assert( 4 == sizeof( jint),      \"wrong size for basic type\");\n+  static_assert( 1 == sizeof( jboolean),  \"wrong size for basic type\");\n+  static_assert( 8 == sizeof( jlong),     \"wrong size for basic type\");\n+  static_assert( 4 == sizeof( jfloat),    \"wrong size for basic type\");\n+  static_assert( 8 == sizeof( jdouble),   \"wrong size for basic type\");\n+  static_assert( 1 == sizeof( u1),        \"wrong size for basic type\");\n+  static_assert( 2 == sizeof( u2),        \"wrong size for basic type\");\n+  static_assert( 4 == sizeof( u4),        \"wrong size for basic type\");\n+  static_assert(wordSize == BytesPerWord, \"should be the same since they're used interchangeably\");\n+  static_assert(wordSize == HeapWordSize, \"should be the same since they're also used interchangeably\");\n@@ -158,5 +158,5 @@\n-  assert(is_power_of_2(sizeof(juint)), \"juint must be power of 2\");\n-  assert(is_power_of_2(HeapWordSize), \"HeapWordSize must be power of 2\");\n-  assert((size_t)HeapWordSize >= sizeof(juint),\n-         \"HeapWord should be at least as large as juint\");\n-  assert(sizeof(NULL) == sizeof(char*), \"NULL must be same size as pointer\");\n+  static_assert(is_power_of_2(sizeof(juint)), \"juint must be power of 2\");\n+  static_assert(is_power_of_2(HeapWordSize), \"HeapWordSize must be power of 2\");\n+  static_assert((size_t)HeapWordSize >= sizeof(juint),\n+                \"HeapWord should be at least as large as juint\");\n+  static_assert(sizeof(NULL) == sizeof(char*), \"NULL must be same size as pointer\");\n@@ -221,1 +221,1 @@\n-  NULL, NULL, NULL, NULL,\n+  nullptr, nullptr, nullptr, nullptr,\n@@ -255,1 +255,1 @@\n-    if (type2name_tab[t] != NULL && 0 == strcmp(type2name_tab[t], name))\n+    if (type2name_tab[t] != nullptr && 0 == strcmp(type2name_tab[t], name))\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+#define INT64_PLUS_FORMAT        \"%+\"         PRId64\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -508,1 +508,1 @@\n-  if (this->_data != NULL) {\n+  if (this->_data != nullptr) {\n@@ -517,1 +517,1 @@\n-  expand_to(next_power_of_2((uint32_t)j));\n+  expand_to(next_power_of_2(j));\n@@ -788,1 +788,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -845,1 +845,1 @@\n-  GrowableArrayIterator() : _array(NULL), _position(0) { }\n+  GrowableArrayIterator() : _array(nullptr), _position(0) { }\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-  _buckets = NULL;\n+  _buckets = nullptr;\n@@ -77,1 +77,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -124,1 +124,1 @@\n-  if (buckets_new == NULL) {\n+  if (buckets_new == nullptr) {\n@@ -139,1 +139,1 @@\n-    for (BasicHashtableEntry<F>* p = _buckets[index_old].get_entry(); p != NULL; ) {\n+    for (BasicHashtableEntry<F>* p = _buckets[index_old].get_entry(); p != nullptr; ) {\n@@ -178,1 +178,1 @@\n-         e != NULL; e = e->next()) {\n+         e != nullptr; e = e->next()) {\n@@ -180,1 +180,1 @@\n-      T l = (literal_load_barrier != NULL) ? literal_load_barrier(e) : e->literal();\n+      T l = (literal_load_barrier != nullptr) ? literal_load_barrier(e) : e->literal();\n@@ -205,1 +205,1 @@\n-    while(entry != NULL) {\n+    while(entry != nullptr) {\n@@ -221,1 +221,1 @@\n-    for (T* probe = (T*)bucket(index); probe != NULL; probe = probe->next()) {\n+    for (T* probe = (T*)bucket(index); probe != nullptr; probe = probe->next()) {\n@@ -240,1 +240,1 @@\n-      for (T* probe = (T*)bucket(index); probe != NULL; probe = probe->next()) {\n+      for (T* probe = (T*)bucket(index); probe != nullptr; probe = probe->next()) {\n","filename":"src\/hotspot\/share\/utilities\/hashtable.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-  void clear()                        { _entry = NULL; }\n+  void clear()                        { _entry = nullptr; }\n@@ -157,1 +157,1 @@\n-    entry->set_next(NULL);\n+    entry->set_next(nullptr);\n@@ -205,2 +205,2 @@\n-  TableStatistics statistics_calculate(T (*literal_load_barrier)(HashtableEntry<T, F>*) = NULL);\n-  void print_table_statistics(outputStream* st, const char *table_name, T (*literal_load_barrier)(HashtableEntry<T, F>*) = NULL);\n+  TableStatistics statistics_calculate(T (*literal_load_barrier)(HashtableEntry<T, F>*) = nullptr);\n+  void print_table_statistics(outputStream* st, const char *table_name, T (*literal_load_barrier)(HashtableEntry<T, F>*) = nullptr);\n","filename":"src\/hotspot\/share\/utilities\/hashtable.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-  if (entry != NULL) {\n+  if (entry != nullptr) {\n","filename":"src\/hotspot\/share\/utilities\/hashtable.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  return tmp == NULL ? s + strlen(s) : tmp;\n+  return tmp == nullptr ? s + strlen(s) : tmp;\n@@ -51,2 +51,2 @@\n-  assert(start != NULL, \"Need something to parse\");\n-  if (start == NULL) {\n+  assert(start != nullptr, \"Need something to parse\");\n+  if (start == nullptr) {\n@@ -54,1 +54,1 @@\n-    error(INTERNAL_ERROR, \"JSON parser was called with a string that was NULL.\");\n+    error(INTERNAL_ERROR, \"JSON parser was called with a string that was null.\");\n@@ -161,1 +161,1 @@\n-  if (!callback(JSON_OBJECT_BEGIN, NULL, level++)) {\n+  if (!callback(JSON_OBJECT_BEGIN, nullptr, level++)) {\n@@ -210,1 +210,1 @@\n-  return callback(JSON_OBJECT_END, NULL, --level);\n+  return callback(JSON_OBJECT_END, nullptr, --level);\n@@ -225,1 +225,1 @@\n-  if (!callback(JSON_ARRAY_BEGIN, NULL, level++)) {\n+  if (!callback(JSON_ARRAY_BEGIN, nullptr, level++)) {\n@@ -261,1 +261,1 @@\n-  return callback(JSON_ARRAY_END, NULL, --level);\n+  return callback(JSON_ARRAY_END, nullptr, --level);\n@@ -274,1 +274,1 @@\n-  if (end == NULL) {\n+  if (end == nullptr) {\n@@ -387,1 +387,1 @@\n-  return callback(symbol, NULL, level);\n+  return callback(symbol, nullptr, level);\n@@ -479,1 +479,1 @@\n-  assert(expected_string != NULL, \"need non-null string\");\n+  assert(expected_string != nullptr, \"need non-null string\");\n","filename":"src\/hotspot\/share\/utilities\/json.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-  LinkedListNode() : _next(NULL) { }\n+  LinkedListNode() : _next(nullptr) { }\n@@ -66,1 +66,1 @@\n-  LinkedListNode(const E& e): _data(e), _next(NULL) { }\n+  LinkedListNode(const E& e): _data(e), _next(nullptr) { }\n@@ -75,1 +75,1 @@\n-    return equal<E>(_data, t, NULL);\n+    return equal<E>(_data, t, nullptr);\n@@ -88,1 +88,1 @@\n-  LinkedList() : _head(NULL) { }\n+  LinkedList() : _head(nullptr) { }\n@@ -93,1 +93,1 @@\n-  inline bool is_empty()           const     { return head() == NULL; }\n+  inline bool is_empty()           const     { return head() == nullptr; }\n@@ -98,1 +98,1 @@\n-    for (p = head(); p != NULL; count++, p = p->next());\n+    for (p = head(); p != nullptr; count++, p = p->next());\n@@ -129,1 +129,1 @@\n-    if (h != NULL) {\n+    if (h != nullptr) {\n@@ -146,1 +146,1 @@\n-  LinkedListImpl() :  _arena(NULL) { }\n+  LinkedListImpl() :  _arena(nullptr) { }\n@@ -155,2 +155,2 @@\n-    this->set_head(NULL);\n-    while (p != NULL) {\n+    this->set_head(nullptr);\n+    while (p != nullptr) {\n@@ -166,1 +166,1 @@\n-    if (node != NULL) {\n+    if (node != nullptr) {\n@@ -174,1 +174,1 @@\n-    assert(node != NULL, \"NULL pointer\");\n+    assert(node != nullptr, \"nullptr pointer\");\n@@ -184,1 +184,1 @@\n-    while (node != NULL && node->next() != NULL) {\n+    while (node != nullptr && node->next() != nullptr) {\n@@ -187,1 +187,1 @@\n-    if (node == NULL) {\n+    if (node == nullptr) {\n@@ -193,1 +193,1 @@\n-    list->set_head(NULL);\n+    list->set_head(nullptr);\n@@ -198,2 +198,2 @@\n-    while (node != NULL) {\n-      if (this->add(*node->peek()) == NULL) {\n+    while (node != nullptr) {\n+      if (this->add(*node->peek()) == nullptr) {\n@@ -210,1 +210,1 @@\n-    while (p != NULL && !p->equals(e)) {\n+    while (p != nullptr && !p->equals(e)) {\n@@ -218,1 +218,1 @@\n-    return (node == NULL) ? NULL : node->data();\n+    return (node == nullptr) ? nullptr : node->data();\n@@ -225,1 +225,1 @@\n-    if (node == NULL) return NULL;\n+    if (node == nullptr) return nullptr;\n@@ -231,1 +231,1 @@\n-      while (p != NULL && p->next() != ref_node) {\n+      while (p != nullptr && p->next() != ref_node) {\n@@ -234,1 +234,1 @@\n-      assert(p != NULL, \"ref_node not in the list\");\n+      assert(p != nullptr, \"ref_node not in the list\");\n@@ -244,1 +244,1 @@\n-     if (node == NULL) return NULL;\n+     if (node == nullptr) return nullptr;\n@@ -254,1 +254,1 @@\n-     LinkedListNode<E>* prev = NULL;\n+     LinkedListNode<E>* prev = nullptr;\n@@ -256,1 +256,1 @@\n-     while (tmp != NULL) {\n+     while (tmp != nullptr) {\n@@ -269,1 +269,1 @@\n-    if (prev == NULL) {\n+    if (prev == nullptr) {\n@@ -273,1 +273,1 @@\n-      if (to_delete != NULL) {\n+      if (to_delete != nullptr) {\n@@ -278,1 +278,1 @@\n-    if (to_delete != NULL) {\n+    if (to_delete != nullptr) {\n@@ -292,1 +292,1 @@\n-    while (p != NULL && p->next() != node) {\n+    while (p != nullptr && p->next() != node) {\n@@ -295,1 +295,1 @@\n-    if (p != NULL) {\n+    if (p != nullptr) {\n@@ -305,1 +305,1 @@\n-    assert(ref != NULL, \"NULL pointer\");\n+    assert(ref != nullptr, \"null pointer\");\n@@ -307,3 +307,3 @@\n-    LinkedListNode<E>* to_delete = NULL; \/\/ to be deleted\n-    LinkedListNode<E>* prev = NULL;      \/\/ node before the node to be deleted\n-    while (p != NULL && p != ref) {\n+    LinkedListNode<E>* to_delete = nullptr; \/\/ to be deleted\n+    LinkedListNode<E>* prev = nullptr;      \/\/ node before the node to be deleted\n+    while (p != nullptr && p != ref) {\n@@ -314,1 +314,1 @@\n-    if (p == NULL || to_delete == NULL) return false;\n+    if (p == nullptr || to_delete == nullptr) return false;\n@@ -316,1 +316,1 @@\n-    assert(prev == NULL || prev->next() == to_delete,\n+    assert(prev == nullptr || prev->next() == to_delete,\n@@ -318,1 +318,1 @@\n-    if (prev == NULL) {\n+    if (prev == nullptr) {\n@@ -334,1 +334,1 @@\n-         assert(_arena != NULL, \"Arena not set\");\n+         assert(_arena != nullptr, \"Arena not set\");\n@@ -353,1 +353,1 @@\n-     return NULL;\n+     return nullptr;\n@@ -381,1 +381,1 @@\n-    while ((node = list->unlink_head()) != NULL) {\n+    while ((node = list->unlink_head()) != nullptr) {\n@@ -388,1 +388,1 @@\n-    assert(node != NULL, \"NULL pointer\");\n+    assert(node != nullptr, \"nullptr pointer\");\n@@ -390,1 +390,1 @@\n-    LinkedListNode<E>* prev = NULL;\n+    LinkedListNode<E>* prev = nullptr;\n@@ -393,1 +393,1 @@\n-    while (tmp != NULL) {\n+    while (tmp != nullptr) {\n@@ -402,1 +402,1 @@\n-    if (prev != NULL) {\n+    if (prev != nullptr) {\n@@ -418,1 +418,1 @@\n-    while (p != NULL) {\n+    while (p != nullptr) {\n@@ -423,1 +423,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -427,1 +427,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -439,1 +439,1 @@\n-  bool is_empty() const { return _p == NULL; }\n+  bool is_empty() const { return _p == nullptr; }\n@@ -442,1 +442,1 @@\n-    if (_p == NULL) return NULL;\n+    if (_p == nullptr) return nullptr;\n@@ -449,1 +449,1 @@\n-    if (_p == NULL) return NULL;\n+    if (_p == nullptr) return nullptr;\n","filename":"src\/hotspot\/share\/utilities\/linkedlist.hpp","additions":51,"deletions":51,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-  LockFreeStack() : _top(NULL) {}\n+  LockFreeStack() : _top(nullptr) {}\n@@ -79,1 +79,1 @@\n-  \/\/ pointer to that object, or NULL if this stack is empty. Acts as a\n+  \/\/ pointer to that object, or nullptr if this stack is empty. Acts as a\n@@ -87,2 +87,2 @@\n-      T* new_top = NULL;\n-      if (result != NULL) {\n+      T* new_top = nullptr;\n+      if (result != nullptr) {\n@@ -94,2 +94,2 @@\n-    if (result != NULL) {\n-      set_next(*result, NULL);\n+    if (result != nullptr) {\n+      set_next(*result, nullptr);\n@@ -100,1 +100,1 @@\n-  \/\/ Atomically exchange the list of elements with NULL, returning the old\n+  \/\/ Atomically exchange the list of elements with nullptr, returning the old\n@@ -104,1 +104,1 @@\n-    return Atomic::xchg(&_top, (T*)NULL);\n+    return Atomic::xchg(&_top, (T*)nullptr);\n@@ -110,1 +110,1 @@\n-    assert(next(value) == NULL, \"precondition\");\n+    assert(next(value) == nullptr, \"precondition\");\n@@ -117,1 +117,1 @@\n-  \/\/ precondition: next(last) == NULL.\n+  \/\/ precondition: next(last) == nullptr.\n@@ -120,1 +120,1 @@\n-    assert(next(last) == NULL, \"precondition\");\n+    assert(next(last) == nullptr, \"precondition\");\n@@ -123,1 +123,1 @@\n-      assert(p != NULL, \"invalid prepend list\");\n+      assert(p != nullptr, \"invalid prepend list\");\n@@ -137,1 +137,1 @@\n-      if (step_to == NULL) break;\n+      if (step_to == nullptr) break;\n@@ -144,1 +144,1 @@\n-  bool empty() const { return top() == NULL; }\n+  bool empty() const { return top() == nullptr; }\n@@ -146,1 +146,1 @@\n-  \/\/ Return the most recently pushed element, or NULL if the stack is empty.\n+  \/\/ Return the most recently pushed element, or nullptr if the stack is empty.\n@@ -154,1 +154,1 @@\n-    for (const T* current = top(); current != NULL; current = next(*current)) {\n+    for (const T* current = top(); current != nullptr; current = next(*current)) {\n","filename":"src\/hotspot\/share\/utilities\/lockFreeStack.hpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"metaprogramming\/conditional.hpp\"\n@@ -31,0 +30,1 @@\n+\n@@ -41,1 +41,1 @@\n-  using I = typename Conditional<NB <= 32, uint32_t, uint64_t>::type;\n+  using I = std::conditional_t<NB <= 32, uint32_t, uint64_t>;\n","filename":"src\/hotspot\/share\/utilities\/moveBits.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    _stack[index] = NULL;\n+    _stack[index] = nullptr;\n@@ -67,1 +67,1 @@\n-    if (_stack[index] == NULL) {\n+    if (_stack[index] == nullptr) {\n@@ -90,1 +90,1 @@\n-      if (pc == NULL) break;\n+      if (pc == nullptr) break;\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-    return _stack[0] == NULL;\n+    return _stack[0] == nullptr;\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-    if (parts[i] != NULL && total->num() != parts[i]->num())\n+    if (parts[i] != nullptr && total->num() != parts[i]->num())\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n-        _fragment_list(NULL),\n-        _last_fragment_bits(NULL),\n+        _fragment_list(nullptr),\n+        _last_fragment_bits(nullptr),\n@@ -50,1 +50,1 @@\n-  while (current != NULL) {\n+  while (current != nullptr) {\n@@ -70,1 +70,1 @@\n-  CHeapBitMap* bits = NULL;\n+  CHeapBitMap* bits = nullptr;\n@@ -73,1 +73,1 @@\n-  if (found != NULL) {\n+  if (found != nullptr) {\n","filename":"src\/hotspot\/share\/utilities\/objectBitSet.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-  _scratch     = NULL;\n+  _scratch     = nullptr;\n@@ -58,1 +58,1 @@\n-  _scratch     = NULL;\n+  _scratch     = nullptr;\n@@ -249,1 +249,1 @@\n-  if (iso8601_result != NULL) {\n+  if (iso8601_result != nullptr) {\n@@ -393,1 +393,1 @@\n-  assert(_buffer != NULL &&\n+  assert(_buffer != nullptr &&\n@@ -466,1 +466,1 @@\n-  if (force_directory != NULL) {\n+  if (force_directory != nullptr) {\n@@ -474,1 +474,1 @@\n-  int pid_pos = (pts == NULL) ? -1 : (pts - nametail);\n+  int pid_pos = (pts == nullptr) ? -1 : (pts - nametail);\n@@ -482,1 +482,1 @@\n-  int tms_pos = (pts == NULL) ? -1 : (pts - nametail);\n+  int tms_pos = (pts == nullptr) ? -1 : (pts - nametail);\n@@ -489,1 +489,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -496,1 +496,1 @@\n-  if (force_directory != NULL) {\n+  if (force_directory != nullptr) {\n@@ -504,2 +504,2 @@\n-  const char *p1st = NULL;\n-  const char *p2nd = NULL;\n+  const char *p1st = nullptr;\n+  const char *p2nd = nullptr;\n@@ -563,1 +563,1 @@\n-  if (_file != NULL) {\n+  if (_file != nullptr) {\n@@ -573,1 +573,1 @@\n-  if (_file != NULL) {\n+  if (_file != nullptr) {\n@@ -582,1 +582,1 @@\n-  if (_file != NULL)  {\n+  if (_file != nullptr)  {\n@@ -591,1 +591,1 @@\n-  if (_file != NULL) {\n+  if (_file != nullptr) {\n@@ -603,2 +603,2 @@\n-  char * ret = NULL;\n-  if (_file != NULL) {\n+  char * ret = nullptr;\n+  if (_file != nullptr) {\n@@ -616,1 +616,1 @@\n-  if (_file != NULL) {\n+  if (_file != nullptr) {\n@@ -618,1 +618,1 @@\n-    _file      = NULL;\n+    _file      = nullptr;\n@@ -623,1 +623,1 @@\n-  if (_file != NULL) {\n+  if (_file != nullptr) {\n@@ -639,1 +639,1 @@\n-defaultStream* defaultStream::instance = NULL;\n+defaultStream* defaultStream::instance = nullptr;\n@@ -661,1 +661,1 @@\n-  return _log_file != NULL;\n+  return _log_file != nullptr;\n@@ -665,2 +665,2 @@\n-  const char* try_name = make_log_name(log_name, NULL);\n-  if (try_name == NULL) {\n+  const char* try_name = make_log_name(log_name, nullptr);\n+  if (try_name == nullptr) {\n@@ -668,1 +668,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -682,1 +682,1 @@\n-  if (try_name == NULL) {\n+  if (try_name == nullptr) {\n@@ -684,1 +684,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -696,1 +696,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -701,1 +701,1 @@\n-  const char* log_name = LogFile != NULL ? LogFile : \"hotspot_%p.log\";\n+  const char* log_name = LogFile != nullptr ? LogFile : \"hotspot_%p.log\";\n@@ -704,1 +704,1 @@\n-  if (file != NULL) {\n+  if (file != nullptr) {\n@@ -709,1 +709,1 @@\n-    \/\/ and leave xtty as NULL\n+    \/\/ and leave xtty as nullptr\n@@ -751,1 +751,1 @@\n-    if (Arguments::java_command() != NULL) {\n+    if (Arguments::java_command() != nullptr) {\n@@ -755,1 +755,1 @@\n-    if (Arguments::sun_java_launcher() != NULL) {\n+    if (Arguments::sun_java_launcher() != nullptr) {\n@@ -759,1 +759,1 @@\n-    if (Arguments::system_properties() !=  NULL) {\n+    if (Arguments::system_properties() !=  nullptr) {\n@@ -764,2 +764,2 @@\n-      for (SystemProperty* p = Arguments::system_properties(); p != NULL; p = p->next()) {\n-        assert(p->key() != NULL, \"p->key() is NULL\");\n+      for (SystemProperty* p = Arguments::system_properties(); p != nullptr; p = p->next()) {\n+        assert(p->key() != nullptr, \"p->key() is nullptr\");\n@@ -771,1 +771,1 @@\n-          assert(p->value() != NULL, \"p->value() is NULL\");\n+          assert(p->value() != nullptr, \"p->value() is nullptr\");\n@@ -798,1 +798,1 @@\n-  _log_file = NULL;\n+  _log_file = nullptr;\n@@ -801,1 +801,1 @@\n-  _outer_xmlStream = NULL;\n+  _outer_xmlStream = nullptr;\n@@ -821,2 +821,2 @@\n-    _log_file = NULL;\n-    _outer_xmlStream = NULL;\n+    _log_file = nullptr;\n+    _outer_xmlStream = nullptr;\n@@ -840,1 +840,1 @@\n-      tty_lock == NULL ||\n+      tty_lock == nullptr ||\n@@ -843,1 +843,1 @@\n-      Thread::current_or_null() == NULL ||\n+      Thread::current_or_null() == nullptr ||\n@@ -914,1 +914,1 @@\n-  if (defaultStream::instance == NULL)  return defaultStream::NO_WRITER;\n+  if (defaultStream::instance == nullptr)  return defaultStream::NO_WRITER;\n@@ -936,1 +936,1 @@\n-  if (defaultStream::instance != NULL &&\n+  if (defaultStream::instance != nullptr &&\n@@ -938,1 +938,1 @@\n-    if (xtty != NULL) {\n+    if (xtty != nullptr) {\n@@ -947,1 +947,1 @@\n-  if (defaultStream::instance == NULL) {\n+  if (defaultStream::instance == nullptr) {\n@@ -984,2 +984,2 @@\n-  xtty = NULL;\n-  defaultStream::instance = NULL;\n+  xtty = nullptr;\n+  defaultStream::instance = nullptr;\n@@ -993,1 +993,1 @@\n-  if (defaultStream::instance != NULL) {\n+  if (defaultStream::instance != nullptr) {\n@@ -1142,1 +1142,1 @@\n-    if (host != NULL) {\n+    if (host != nullptr) {\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":52,"deletions":52,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,1 +131,1 @@\n-   virtual void rotate_log(bool force, outputStream* out = NULL) {} \/\/ GC log rotation\n+   virtual void rotate_log(bool force, outputStream* out = nullptr) {} \/\/ GC log rotation\n@@ -238,1 +238,1 @@\n-  fileStream() { _file = NULL; _need_close = false; }\n+  fileStream() { _file = nullptr; _need_close = false; }\n@@ -243,1 +243,1 @@\n-  bool is_open() const { return _file != NULL; }\n+  bool is_open() const { return _file != nullptr; }\n@@ -245,1 +245,1 @@\n-  size_t read(void *data, size_t size, size_t count) { return _file != NULL ? ::fread(data, size, count, _file) : 0; }\n+  size_t read(void *data, size_t size, size_t count) { return _file != nullptr ? ::fread(data, size, count, _file) : 0; }\n@@ -247,1 +247,1 @@\n-  int eof() { return _file != NULL ? feof(_file) : -1; }\n+  int eof() { return _file != nullptr ? feof(_file) : -1; }\n@@ -249,1 +249,1 @@\n-  void rewind() { if (_file != NULL) ::rewind(_file); }\n+  void rewind() { if (_file != nullptr) ::rewind(_file); }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"metaprogramming\/conditional.hpp\"\n@@ -56,1 +55,1 @@\n-  typedef typename Conditional<(sizeof(T) < sizeof(unsigned)), unsigned, T>::type P;\n+  using P = std::conditional_t<(sizeof(T) < sizeof(unsigned)), unsigned, T>;\n","filename":"src\/hotspot\/share\/utilities\/population_count.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  if (_preserved_exception_oop() != NULL) {\n+  if (_preserved_exception_oop() != nullptr) {\n","filename":"src\/hotspot\/share\/utilities\/preserveException.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-      while (node != NULL) {\n+      while (node != nullptr) {\n","filename":"src\/hotspot\/share\/utilities\/resizeableResourceHash.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-    _hash(hash), _key(key), _value(value), _next(NULL) {}\n+    _hash(hash), _key(key), _value(value), _next(nullptr) {}\n@@ -46,1 +46,1 @@\n-    _hash(hash), _key(key), _value(), _next(NULL) {}\n+    _hash(hash), _key(key), _value(), _next(nullptr) {}\n@@ -77,1 +77,1 @@\n-    while (*ptr != NULL) {\n+    while (*ptr != nullptr) {\n@@ -105,1 +105,1 @@\n-        while (node != NULL) {\n+        while (node != nullptr) {\n@@ -120,1 +120,1 @@\n-    return get(key) != NULL;\n+    return get(key) != nullptr;\n@@ -126,1 +126,1 @@\n-    if (*ptr != NULL) {\n+    if (*ptr != nullptr) {\n@@ -129,1 +129,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -141,1 +141,1 @@\n-    if (*ptr != NULL) {\n+    if (*ptr != nullptr) {\n@@ -163,1 +163,1 @@\n-    if (*ptr == NULL) {\n+    if (*ptr == nullptr) {\n@@ -185,1 +185,1 @@\n-    if (*ptr == NULL) {\n+    if (*ptr == nullptr) {\n@@ -205,1 +205,1 @@\n-    if (node != NULL) {\n+    if (node != nullptr) {\n@@ -231,1 +231,3 @@\n-    while (bucket < bucket_at(sz)) {\n+    int cnt = _number_of_entries;\n+\n+    while (cnt > 0 && bucket < bucket_at(sz)) {\n@@ -233,1 +235,1 @@\n-      while (node != NULL) {\n+      while (node != nullptr) {\n@@ -237,0 +239,1 @@\n+        --cnt;\n@@ -260,1 +263,1 @@\n-      while (*ptr != NULL) {\n+      while (*ptr != nullptr) {\n@@ -286,1 +289,1 @@\n-      while (node != NULL) {\n+      while (node != nullptr) {\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,1 +107,1 @@\n-  inline bool is_empty() const { return this->_cur_seg == NULL; }\n+  inline bool is_empty() const { return this->_cur_seg == nullptr; }\n@@ -172,1 +172,1 @@\n-  \/\/ Set the segment pointers to NULL so the parent dtor does not free them;\n+  \/\/ Set the segment pointers to nullptr so the parent dtor does not free them;\n@@ -192,1 +192,1 @@\n-  bool is_empty() const { return _cur_seg == NULL; }\n+  bool is_empty() const { return _cur_seg == nullptr; }\n","filename":"src\/hotspot\/share\/utilities\/stack.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,1 +190,1 @@\n-  const bool at_empty_transition = prev == NULL;\n+  const bool at_empty_transition = prev == nullptr;\n@@ -201,1 +201,1 @@\n-  while (seg != NULL) {\n+  while (seg != nullptr) {\n@@ -213,1 +213,1 @@\n-  _cur_seg = NULL;\n+  _cur_seg = nullptr;\n@@ -216,1 +216,1 @@\n-    _cache = NULL;\n+    _cache = nullptr;\n@@ -230,1 +230,1 @@\n-  assert((_cache == NULL) == (this->cache_size() == 0), \"mismatch\");\n+  assert((_cache == nullptr) == (this->cache_size() == 0), \"mismatch\");\n","filename":"src\/hotspot\/share\/utilities\/stack.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-  for (char* dst = string; *dst && (dst = strstr(dst, from)) != NULL;) {\n+  for (char* dst = string; *dst && (dst = strstr(dst, from)) != nullptr;) {\n@@ -51,1 +51,1 @@\n-  assert(str1 != NULL && str2 != NULL, \"sanity\");\n+  assert(str1 != nullptr && str2 != nullptr, \"sanity\");\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,2 @@\n-  if (left == NULL)   left = \"U5: [\";\n-  if (right == NULL)  right = \"] (values=%d\/length=%d)\\n\";\n+  if (left == nullptr)   left = \"U5: [\";\n+  if (right == nullptr)  right = \"] (values=%d\/length=%d)\\n\";\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -309,1 +309,1 @@\n-                  const char* left = NULL, const char* right = NULL);\n+                  const char* left = nullptr, const char* right = nullptr);\n@@ -326,2 +326,2 @@\n-      : _array(const_cast<ARR&>(array)), _limit_ptr(NULL), _position(0) {\n-      \/\/ Note: if _limit_ptr is NULL, the ARR& is never reassigned,\n+      : _array(const_cast<ARR&>(array)), _limit_ptr(nullptr), _position(0) {\n+      \/\/ Note: if _limit_ptr is nullptr, the ARR& is never reassigned,\n@@ -366,1 +366,1 @@\n-    bool has_limit() { return _limit_ptr != NULL; }\n+    bool has_limit() { return _limit_ptr != nullptr; }\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,1 +240,1 @@\n-  char* result = NULL;\n+  char* result = nullptr;\n@@ -251,1 +251,1 @@\n-  char* buffer = NULL;\n+  char* buffer = nullptr;\n@@ -255,1 +255,1 @@\n-        if (buffer != NULL) {\n+        if (buffer != nullptr) {\n@@ -283,1 +283,1 @@\n-            if (buffer == NULL) {\n+            if (buffer == nullptr) {\n@@ -293,4 +293,4 @@\n-          case 't': if (buffer != NULL) buffer[length] = '\\t'; ptr += 2; length++; break;\n-          case 'n': if (buffer != NULL) buffer[length] = '\\n'; ptr += 2; length++; break;\n-          case 'r': if (buffer != NULL) buffer[length] = '\\r'; ptr += 2; length++; break;\n-          case 'f': if (buffer != NULL) buffer[length] = '\\f'; ptr += 2; length++; break;\n+          case 't': if (buffer != nullptr) buffer[length] = '\\t'; ptr += 2; length++; break;\n+          case 'n': if (buffer != nullptr) buffer[length] = '\\n'; ptr += 2; length++; break;\n+          case 'r': if (buffer != nullptr) buffer[length] = '\\r'; ptr += 2; length++; break;\n+          case 'f': if (buffer != nullptr) buffer[length] = '\\f'; ptr += 2; length++; break;\n","filename":"src\/hotspot\/share\/utilities\/utf8.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-  \/\/ Returns NULL if 'c' it not found. This only works as long\n+  \/\/ Returns nullptr if 'c' it not found. This only works as long\n@@ -83,1 +83,1 @@\n-    return (length < 0) ? NULL : &base[length];\n+    return (length < 0) ? nullptr : &base[length];\n","filename":"src\/hotspot\/share\/utilities\/utf8.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-static void *dlHandle = NULL;\n+static void *dlHandle = nullptr;\n@@ -33,2 +33,2 @@\n-static GuestLib_StatGet_t GuestLib_StatGet = NULL;\n-static GuestLib_StatFree_t GuestLib_StatFree = NULL;\n+static GuestLib_StatGet_t GuestLib_StatGet = nullptr;\n+static GuestLib_StatFree_t GuestLib_StatFree = nullptr;\n@@ -51,1 +51,1 @@\n-  if (dlHandle == NULL) {\n+  if (dlHandle == nullptr) {\n@@ -58,1 +58,1 @@\n-  if (dlHandle == NULL) {\n+  if (dlHandle == nullptr) {\n@@ -65,2 +65,2 @@\n-  if (GuestLib_StatGet != NULL && GuestLib_StatFree != NULL) {\n-    char* result_info = NULL;\n+  if (GuestLib_StatGet != nullptr && GuestLib_StatFree != nullptr) {\n+    char* result_info = nullptr;\n@@ -94,2 +94,2 @@\n-  if (GuestLib_StatGet != NULL && GuestLib_StatFree != NULL) {\n-    char* result_info = NULL;\n+  if (GuestLib_StatGet != nullptr && GuestLib_StatFree != nullptr) {\n+    char* result_info = nullptr;\n","filename":"src\/hotspot\/share\/utilities\/virtualizationSupport.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +127,1 @@\n-\/\/  while ((cmd = next_OnError_command(buffer, sizeof(buffer), &ptr) != NULL)\n+\/\/  while ((cmd = next_OnError_command(buffer, sizeof(buffer), &ptr) != nullptr)\n@@ -130,1 +130,1 @@\n-  if (ptr == NULL || *ptr == NULL) return NULL;\n+  if (ptr == nullptr || *ptr == nullptr) return nullptr;\n@@ -137,1 +137,1 @@\n-  if (*cmd == '\\0') return NULL;\n+  if (*cmd == '\\0') return nullptr;\n@@ -149,1 +149,1 @@\n-  if (out == NULL) return;\n+  if (out == nullptr) return;\n@@ -151,1 +151,1 @@\n-  if (url == NULL || *url == '\\0')\n+  if (url == nullptr || *url == '\\0')\n@@ -153,1 +153,1 @@\n-  if (url != NULL && *url != '\\0') {\n+  if (url != nullptr && *url != '\\0') {\n@@ -185,1 +185,1 @@\n-  } else if (_filename != NULL && _lineno > 0) {\n+  } else if (_filename != nullptr && _lineno > 0) {\n@@ -274,1 +274,1 @@\n- * @param printed array of code units that have already been printed (delimited by NULL entry)\n+ * @param printed array of code units that have already been printed (delimited by nullptr entry)\n@@ -429,1 +429,1 @@\n-   const char* runtime_name = JDK_Version::runtime_name() != NULL ?\n+   const char* runtime_name = JDK_Version::runtime_name() != nullptr ?\n@@ -431,1 +431,1 @@\n-   const char* runtime_version = JDK_Version::runtime_version() != NULL ?\n+   const char* runtime_version = JDK_Version::runtime_version() != nullptr ?\n@@ -433,1 +433,1 @@\n-   const char* vendor_version = JDK_Version::runtime_vendor_version() != NULL ?\n+   const char* vendor_version = JDK_Version::runtime_vendor_version() != nullptr ?\n@@ -435,1 +435,1 @@\n-   const char* jdk_debug_level = VM_Version::printable_jdk_debug_level() != NULL ?\n+   const char* jdk_debug_level = VM_Version::printable_jdk_debug_level() != nullptr ?\n@@ -674,1 +674,1 @@\n-      if (_siginfo != NULL && os::signal_sent_by_kill(_siginfo)) {\n+      if (_siginfo != nullptr && os::signal_sent_by_kill(_siginfo)) {\n@@ -683,1 +683,1 @@\n-      if (_filename != NULL && _lineno > 0) {\n+      if (_filename != nullptr && _lineno > 0) {\n@@ -841,1 +841,1 @@\n-    if (thread != NULL && thread->is_Java_thread()) {\n+    if (thread != nullptr && thread->is_Java_thread()) {\n@@ -1009,1 +1009,1 @@\n-    if (Universe::heap() != NULL) {\n+    if (Universe::heap() != nullptr) {\n@@ -1302,1 +1302,1 @@\n-  if (pattern != NULL) {\n+  if (pattern != nullptr) {\n@@ -1310,1 +1310,1 @@\n-    if (cwd != NULL) {\n+    if (cwd != nullptr) {\n@@ -1323,1 +1323,1 @@\n-     if (tmpdir != NULL && strlen(tmpdir) > 0) {\n+     if (tmpdir != nullptr && strlen(tmpdir) > 0) {\n@@ -1339,1 +1339,1 @@\n-  report_and_die(sig, NULL, detail_fmt, detail_args, thread, pc, siginfo, context, NULL, 0, 0);\n+  report_and_die(sig, nullptr, detail_fmt, detail_args, thread, pc, siginfo, context, nullptr, 0, 0);\n@@ -1351,1 +1351,1 @@\n-  report_and_die(INTERNAL_ERROR, message, detail_fmt, detail_args, thread, NULL, NULL, context, filename, lineno, 0);\n+  report_and_die(INTERNAL_ERROR, message, detail_fmt, detail_args, thread, nullptr, nullptr, context, filename, lineno, 0);\n@@ -1356,1 +1356,1 @@\n-  report_and_die(vm_err_type, NULL, detail_fmt, detail_args, thread, NULL, NULL, NULL, filename, lineno, size);\n+  report_and_die(vm_err_type, nullptr, detail_fmt, detail_args, thread, nullptr, nullptr, nullptr, filename, lineno, size);\n@@ -1517,1 +1517,1 @@\n-              filename == NULL ? \"??\" : filename, lineno);\n+              filename == nullptr ? \"??\" : filename, lineno);\n@@ -1520,1 +1520,1 @@\n-              filename == NULL ? \"??\" : filename, lineno);\n+              filename == nullptr ? \"??\" : filename, lineno);\n@@ -1612,1 +1612,1 @@\n-    if (env != NULL) {\n+    if (env != nullptr) {\n@@ -1617,1 +1617,1 @@\n-        if (replay_data_file != NULL) {\n+        if (replay_data_file != nullptr) {\n@@ -1632,1 +1632,1 @@\n-  if (JVMCI::fatal_log_filename() != NULL) {\n+  if (JVMCI::fatal_log_filename() != nullptr) {\n@@ -1660,1 +1660,1 @@\n-    while ((cmd = next_OnError_command(buffer, sizeof(buffer), &ptr)) != NULL){\n+    while ((cmd = next_OnError_command(buffer, sizeof(buffer), &ptr)) != nullptr){\n@@ -1678,1 +1678,1 @@\n-    OnError = NULL;\n+    OnError = nullptr;\n@@ -1721,1 +1721,1 @@\n-  while ((cmd = next_OnError_command(buffer, sizeof(buffer), &ptr)) != NULL){\n+  while ((cmd = next_OnError_command(buffer, sizeof(buffer), &ptr)) != nullptr){\n@@ -1763,2 +1763,2 @@\n-      || (OnError != NULL && OnError[0] != '\\0')\n-      || Arguments::abort_hook() != NULL) {\n+      || (OnError != nullptr && OnError[0] != '\\0')\n+      || Arguments::abort_hook() != nullptr) {\n@@ -1806,1 +1806,1 @@\n-static void crash_with_sigfpe() {\n+static void ALWAYSINLINE crash_with_sigfpe() {\n@@ -1822,1 +1822,1 @@\n-static void crash_with_segfault() {\n+static void ALWAYSINLINE crash_with_segfault() {\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-  static Thread*     _thread;           \/\/ NULL if it's native thread\n+  static Thread*     _thread;           \/\/ nullptr if it's native thread\n@@ -190,1 +190,1 @@\n-  \/\/ Non-NULL address guaranteed to generate a SEGV mapping error on read, for test purposes.\n+  \/\/ Non-null address guaranteed to generate a SEGV mapping error on read, for test purposes.\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-    const char* esc = NULL;\n+    const char* esc = nullptr;\n@@ -107,1 +107,1 @@\n-    if (esc != NULL) {\n+    if (esc != nullptr) {\n@@ -156,1 +156,1 @@\n-  size_t tag_len = (tag_end == NULL) ? strlen(tag) : tag_end - tag;\n+  size_t tag_len = (tag_end == nullptr) ? strlen(tag) : tag_end - tag;\n@@ -358,1 +358,1 @@\n-  if (kind_end != NULL) {\n+  if (kind_end != nullptr) {\n@@ -391,1 +391,1 @@\n-  if (method == NULL)  return;\n+  if (method == nullptr)  return;\n@@ -402,1 +402,1 @@\n-  if (mdo != NULL) {\n+  if (mdo != nullptr) {\n@@ -420,1 +420,1 @@\n-  if (method == NULL)  return;\n+  if (method == nullptr)  return;\n@@ -434,1 +434,1 @@\n-  if (klass == NULL) return;\n+  if (klass == nullptr) return;\n@@ -442,1 +442,1 @@\n-  if (klass == NULL) return;\n+  if (klass == nullptr) return;\n@@ -449,1 +449,1 @@\n-  if (name == NULL)  return;\n+  if (name == nullptr)  return;\n@@ -457,1 +457,1 @@\n-  if (name == NULL)  return;\n+  if (name == nullptr)  return;\n@@ -464,1 +464,1 @@\n-  if (x == NULL)  return;\n+  if (x == nullptr)  return;\n@@ -474,1 +474,1 @@\n-  if (x == NULL)  return;\n+  if (x == nullptr)  return;\n@@ -481,1 +481,1 @@\n-  if (x == NULL)  return;\n+  if (x == nullptr)  return;\n@@ -491,1 +491,1 @@\n-  if (x == NULL)  return;\n+  if (x == nullptr)  return;\n@@ -508,1 +508,1 @@\n-  if (_outer_xmlStream == NULL)  return;\n+  if (_outer_xmlStream == nullptr)  return;\n@@ -513,1 +513,1 @@\n-  if (_outer_xmlStream == NULL)  return;\n+  if (_outer_xmlStream == nullptr)  return;\n","filename":"src\/hotspot\/share\/utilities\/xmlstream.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-  xmlTextStream() { _outer_xmlStream = NULL; }\n+  xmlTextStream() { _outer_xmlStream = nullptr; }\n@@ -100,1 +100,1 @@\n-  bool is_open() { return _out != NULL; }\n+  bool is_open() { return _out != nullptr; }\n@@ -185,1 +185,1 @@\n-\/\/ Note:  If ::xtty != NULL, ::tty == ::xtty->text().\n+\/\/ Note:  If ::xtty != nullptr, ::tty == ::xtty->text().\n","filename":"src\/hotspot\/share\/utilities\/xmlstream.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,1 +42,3 @@\n-    return sysconf(_SC_PHYS_PAGES) * sysconf(_SC_PAGESIZE);\n+    jlong pages = sysconf(_SC_PHYS_PAGES);\n+    jlong page_size = sysconf(_SC_PAGESIZE);\n+    return pages * page_size;\n","filename":"src\/java.base\/linux\/native\/libjava\/CgroupMetrics.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import static sun.security.util.SecurityProviderConstants.getDefDHPrivateExpSize;\n@@ -63,3 +64,0 @@\n-    \/\/ The size in bits of the random exponent (private value)\n-    private int lSize;\n-\n@@ -74,1 +72,2 @@\n-    private static void checkKeySize(int keysize)\n+    \/\/ pkg private; used by DHParameterGenerator class as well\n+    static void checkKeySize(int keysize, int expSize)\n@@ -83,0 +82,7 @@\n+\n+        \/\/ optional, could be 0 if not specified\n+        if ((expSize < 0) || (expSize > keysize)) {\n+            throw new InvalidParameterException\n+                    (\"Exponent size must be positive and no larger than\" +\n+                    \" modulus size\");\n+        }\n@@ -94,1 +100,1 @@\n-        checkKeySize(keysize);\n+        checkKeySize(keysize, 0);\n@@ -96,9 +102,6 @@\n-        \/\/ Use the built-in parameters (ranging from 512 to 8192)\n-        \/\/ when available.\n-        this.params = ParameterCache.getCachedDHParameterSpec(keysize);\n-\n-        \/\/ Due to performance issue, only support DH parameters generation\n-        \/\/ up to 1024 bits.\n-        if ((this.params == null) && (keysize > 1024)) {\n-            throw new InvalidParameterException(\n-                \"Unsupported \" + keysize + \"-bit DH parameter generation\");\n+        try {\n+            \/\/ Use the built-in parameters (ranging from 512 to 8192)\n+            \/\/ when available.\n+            this.params = ParameterCache.getDHParameterSpec(keysize, random);\n+        } catch (GeneralSecurityException e) {\n+            throw new InvalidParameterException(e.getMessage());\n@@ -108,1 +111,0 @@\n-        this.lSize = 0;\n@@ -133,1 +135,1 @@\n-        params = (DHParameterSpec)algParams;\n+        params = (DHParameterSpec) algParams;\n@@ -136,1 +138,1 @@\n-            checkKeySize(pSize);\n+            checkKeySize(pSize, params.getL());\n@@ -140,9 +142,0 @@\n-\n-        \/\/ exponent size is optional, could be 0\n-        lSize = params.getL();\n-\n-        \/\/ Require exponentSize < primeSize\n-        if ((lSize != 0) && (lSize > pSize)) {\n-            throw new InvalidAlgorithmParameterException\n-                (\"Exponent size must not be larger than modulus size\");\n-        }\n@@ -162,9 +155,0 @@\n-        if (params == null) {\n-            try {\n-                params = ParameterCache.getDHParameterSpec(pSize, random);\n-            } catch (GeneralSecurityException e) {\n-                \/\/ should never happen\n-                throw new ProviderException(e);\n-            }\n-        }\n-\n@@ -174,6 +158,3 @@\n-        if (lSize <= 0) {\n-            lSize = pSize >> 1;\n-            \/\/ use an exponent size of (pSize \/ 2) but at least 384 bits\n-            if (lSize < 384) {\n-                lSize = 384;\n-            }\n+        int lSize = params.getL();\n+        if (lSize == 0) { \/\/ not specified; use our own default\n+            lSize = getDefDHPrivateExpSize(params);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKeyPairGenerator.java","additions":22,"deletions":41,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-    private static void checkKeySize(int keysize)\n+    private static void checkSupport(int keysize, int exponentSize)\n@@ -70,1 +70,1 @@\n-                    \"DH key size must be multiple of 64 and range \" +\n+                    \"Supported DH key size must be multiple of 64 and range \" +\n@@ -72,1 +72,5 @@\n-                    \"The specific key size \" + keysize + \" is not supported\");\n+                    \"The specified key size \" + keysize + \" is not supported\");\n+        }\n+\n+        if (exponentSize != 0) {\n+            DHKeyPairGenerator.checkKeySize(keysize, exponentSize);\n@@ -86,1 +90,2 @@\n-        checkKeySize(keysize);\n+        checkSupport(keysize, 0);\n+\n@@ -111,9 +116,3 @@\n-        DHGenParameterSpec dhParamSpec = (DHGenParameterSpec)genParamSpec;\n-        primeSize = dhParamSpec.getPrimeSize();\n-        exponentSize = dhParamSpec.getExponentSize();\n-        if ((exponentSize <= 0) || (exponentSize >= primeSize)) {\n-            throw new InvalidAlgorithmParameterException(\n-                    \"Exponent size (\" + exponentSize +\n-                    \") must be positive and less than modulus size (\" +\n-                    primeSize + \")\");\n-        }\n+        DHGenParameterSpec dhParamSpec = (DHGenParameterSpec) genParamSpec;\n+        int primeSize = dhParamSpec.getPrimeSize();\n+        int exponentSize = dhParamSpec.getExponentSize();\n@@ -121,1 +120,1 @@\n-            checkKeySize(primeSize);\n+            checkSupport(primeSize, exponentSize);\n@@ -126,0 +125,2 @@\n+        this.primeSize = primeSize;\n+        this.exponentSize = exponentSize;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHParameterGenerator.java","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,4 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+\n@@ -30,1 +34,1 @@\n- * using big-endian byte ordering.\n+ * using big-endian byte ordering (i.e. \"Network Order\").\n@@ -32,1 +36,6 @@\n-class Bits {\n+final class Bits {\n+    private Bits() {}\n+\n+    private static final VarHandle SHORT = create(short[].class);\n+    private static final VarHandle INT = create(int[].class);\n+    private static final VarHandle LONG = create(long[].class);\n@@ -44,2 +53,1 @@\n-        return (char) ((b[off + 1] & 0xFF) +\n-                       (b[off] << 8));\n+        return (char) (short) SHORT.get(b, off);\n@@ -49,2 +57,1 @@\n-        return (short) ((b[off + 1] & 0xFF) +\n-                        (b[off] << 8));\n+        return (short) SHORT.get(b, off);\n@@ -54,4 +61,1 @@\n-        return ((b[off + 3] & 0xFF)      ) +\n-               ((b[off + 2] & 0xFF) <<  8) +\n-               ((b[off + 1] & 0xFF) << 16) +\n-               ((b[off    ]       ) << 24);\n+        return (int) INT.get(b, off);\n@@ -61,1 +65,3 @@\n-        return Float.intBitsToFloat(getInt(b, off));\n+        \/\/ Using Float.intBitsToFloat collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        return Float.intBitsToFloat((int) INT.get(b, off));\n@@ -65,8 +71,1 @@\n-        return ((b[off + 7] & 0xFFL)      ) +\n-               ((b[off + 6] & 0xFFL) <<  8) +\n-               ((b[off + 5] & 0xFFL) << 16) +\n-               ((b[off + 4] & 0xFFL) << 24) +\n-               ((b[off + 3] & 0xFFL) << 32) +\n-               ((b[off + 2] & 0xFFL) << 40) +\n-               ((b[off + 1] & 0xFFL) << 48) +\n-               (((long) b[off])      << 56);\n+        return (long) LONG.get(b, off);\n@@ -76,1 +75,3 @@\n-        return Double.longBitsToDouble(getLong(b, off));\n+        \/\/ Using Double.longBitsToDouble collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        return Double.longBitsToDouble((long) LONG.get(b, off));\n@@ -89,2 +90,1 @@\n-        b[off + 1] = (byte) (val      );\n-        b[off    ] = (byte) (val >>> 8);\n+        SHORT.set(b, off, (short) val);\n@@ -94,2 +94,1 @@\n-        b[off + 1] = (byte) (val      );\n-        b[off    ] = (byte) (val >>> 8);\n+        SHORT.set(b, off, val);\n@@ -99,4 +98,1 @@\n-        b[off + 3] = (byte) (val       );\n-        b[off + 2] = (byte) (val >>>  8);\n-        b[off + 1] = (byte) (val >>> 16);\n-        b[off    ] = (byte) (val >>> 24);\n+        INT.set(b, off, val);\n@@ -106,1 +102,3 @@\n-        putInt(b, off,  Float.floatToIntBits(val));\n+        \/\/ Using Float.floatToIntBits collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        INT.set(b, off, Float.floatToIntBits(val));\n@@ -110,8 +108,1 @@\n-        b[off + 7] = (byte) (val       );\n-        b[off + 6] = (byte) (val >>>  8);\n-        b[off + 5] = (byte) (val >>> 16);\n-        b[off + 4] = (byte) (val >>> 24);\n-        b[off + 3] = (byte) (val >>> 32);\n-        b[off + 2] = (byte) (val >>> 40);\n-        b[off + 1] = (byte) (val >>> 48);\n-        b[off    ] = (byte) (val >>> 56);\n+        LONG.set(b, off, val);\n@@ -121,1 +112,7 @@\n-        putLong(b, off, Double.doubleToLongBits(val));\n+        \/\/ Using Double.doubleToLongBits collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        LONG.set(b, off, Double.doubleToLongBits(val));\n+    }\n+\n+    private static VarHandle create(Class<?> viewArrayClass) {\n+        return MethodHandles.byteArrayViewVarHandle(viewArrayClass, ByteOrder.BIG_ENDIAN);\n","filename":"src\/java.base\/share\/classes\/java\/io\/Bits.java","additions":36,"deletions":39,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,2 +76,2 @@\n-     * <a href=\"{@docRoot}\/java.base\/java\/lang\/Character.html#unicode\">surrogate<\/a>, the surrogate\n-     * value is returned.\n+     * {@linkplain Character##unicode surrogate}, the surrogate value\n+     * is returned.\n@@ -135,3 +135,3 @@\n-     * from this sequence.  Any char which maps to a <a\n-     * href=\"{@docRoot}\/java.base\/java\/lang\/Character.html#unicode\">surrogate code\n-     * point<\/a> is passed through uninterpreted.\n+     * from this sequence.  Any char which maps to a\n+     * {@linkplain Character##unicode surrogate code point} is passed\n+     * through uninterpreted.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/CharSequence.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.util.ArraysSupport;\n+\n@@ -32,1 +34,0 @@\n-import java.util.Locale;\n@@ -62,1 +63,1 @@\n-            byte ba[] = new byte[cpEnd];\n+            byte[] ba = new byte[cpEnd];\n@@ -79,3 +80,3 @@\n-            int next = -1;\n-            int hash = 0;\n-            int hsh = 0;\n+            int next;\n+            int hash;\n+            int hsh;\n@@ -114,6 +115,2 @@\n-    private static final int hashN(byte[] a, int off, int len) {\n-        int h = 1;\n-        while (len-- > 0) {\n-            h = 31 * h + a[off++];\n-        }\n-        return h;\n+    private static int hashN(byte[] a, int off, int len) {\n+        return ArraysSupport.vectorizedHashCode(a, off, len, 1, ArraysSupport.T_BYTE);\n@@ -135,1 +132,1 @@\n-        CharacterName cname = null;\n+        CharacterName cname;\n@@ -144,1 +141,1 @@\n-        int off = 0;\n+        int off;\n@@ -160,1 +157,1 @@\n-                int off = -1;\n+                int off;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/CharacterName.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -4070,3 +4070,3 @@\n-     * from this sequence.  Any char which maps to a <a\n-     * href=\"{@docRoot}\/java.base\/java\/lang\/Character.html#unicode\">surrogate code\n-     * point<\/a> is passed through uninterpreted.\n+     * from this sequence.  Any char which maps to a {@linkplain\n+     * Character##unicode surrogate code point} is passed through\n+     * uninterpreted.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -192,5 +192,5 @@\n-        int h = 0;\n-        for (byte v : value) {\n-            h = 31 * h + (v & 0xff);\n-        }\n-        return h;\n+        return switch (value.length) {\n+            case 0 -> 0;\n+            case 1 -> value[0] & 0xff;\n+            default -> ArraysSupport.vectorizedHashCode(value, 0, value.length, 0, ArraysSupport.T_BOOLEAN);\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -415,6 +415,5 @@\n-        int h = 0;\n-        int length = value.length >> 1;\n-        for (int i = 0; i < length; i++) {\n-            h = 31 * h + getChar(value, i);\n-        }\n-        return h;\n+        return switch (value.length) {\n+            case 0 -> 0;\n+            case 2 -> getChar(value, 0);\n+            default -> ArraysSupport.vectorizedHashCode(value, 0, value.length >> 1, 0, ArraysSupport.T_CHAR);\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2467,1 +2467,3 @@\n-\n+            public char getUTF16Char(byte[] bytes, int index) {\n+                return StringUTF16.getChar(bytes, index);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+import java.util.Comparator;\n@@ -6747,2 +6748,1 @@\n-        final List<Class<?>> empty = List.of();\n-        final List<Class<?>> longest = mhs.filter(Objects::nonNull).\n+        return mhs.filter(Objects::nonNull)\n@@ -6750,10 +6750,5 @@\n-                        map(MethodHandle::type).\n-                        filter(t -> t.parameterCount() > skipSize).\n-                        map(MethodType::parameterList).\n-                        reduce((p, q) -> p.size() >= q.size() ? p : q).orElse(empty);\n-        return longest.isEmpty() ? empty : longest.subList(skipSize, longest.size());\n-    }\n-\n-    private static List<Class<?>> longestParameterList(List<List<Class<?>>> lists) {\n-        final List<Class<?>> empty = List.of();\n-        return lists.stream().reduce((p, q) -> p.size() >= q.size() ? p : q).orElse(empty);\n+                .map(MethodHandle::type)\n+                .filter(t -> t.parameterCount() > skipSize)\n+                .max(Comparator.comparingInt(MethodType::parameterCount))\n+                .map(methodType -> List.of(Arrays.copyOfRange(methodType.ptypes(), skipSize, methodType.parameterCount())))\n+                .orElse(List.of());\n@@ -6765,1 +6760,1 @@\n-        return longestParameterList(List.of(longest1, longest2));\n+        return longest1.size() >= longest2.size() ? longest1 : longest2;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n- * resolution<\/a> or resolution with\n- * <a href=\"{@docRoot}\/java.base\/java\/lang\/module\/Configuration.html#service-binding\">service binding<\/a>.\n+ * resolution<\/a> or resolution with {@linkplain\n+ * Configuration##service-binding service binding}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/Configuration.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -271,0 +271,2 @@\n+     * @since 21\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ClassFileFormatVersion.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3105,3 +3105,2 @@\n-     * equality to 0 is analogous to checking the <a\n-     * href=\"{@docRoot}\/java.base\/java\/lang\/Double.html#fpNumericalEq\">numerical\n-     * equality<\/a> of {@code double} values.\n+     * equality to 0 is analogous to checking the {@linkplain\n+     * Double##fpNumericalEq numerical equality} of {@code double} values.\n@@ -3200,3 +3199,3 @@\n-     * The behavior of this method is analogous to checking the <a\n-     * href=\"{@docRoot}\/java.base\/java\/lang\/Double.html#repEquivalence\">representation\n-     * equivalence<\/a> of {@code double} values.\n+     * The behavior of this method is analogous to checking the\n+     * {@linkplain Double##repEquivalence representation equivalence}\n+     * of {@code double} values.\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1511,0 +1511,4 @@\n+                    if (numericZone != -1 || ifname != null) {\n+                        \/\/ IPv4-mapped address must not contain zone-id\n+                        throw new UnknownHostException(host + \": invalid IPv4-mapped address\");\n+                    }\n@@ -1555,0 +1559,1 @@\n+        int multmax = Integer.MAX_VALUE \/ 10; \/\/ for int overflow detection\n@@ -1560,6 +1565,2 @@\n-            if (c == ']') {\n-                if (i == percent+1) {\n-                    \/* empty per-cent field *\/\n-                    return -1;\n-                }\n-                break;\n+            if ((digit = IPAddressUtil.parseAsciiDigit(c, 10)) < 0) {\n+                return -1;\n@@ -1567,1 +1568,1 @@\n-            if ((digit = Character.digit (c, 10)) < 0) {\n+            if (zone > multmax) {\n@@ -1571,0 +1572,4 @@\n+            if (zone < 0) {\n+                return -1;\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n- * <a href=\"{@docRoot}\/java.base\/java\/net\/InetAddress.html#host-name-resolution\">\n- * InetAddress<\/a>. It is set after the VM is fully initialized and when an\n+ * {@linkplain InetAddress##host-name-resolution\n+ * InetAddress}. It is set after the VM is fully initialized and when an\n@@ -63,2 +63,2 @@\n- *      <a href=\"{@docRoot}\/java.base\/java\/net\/InetAddress.html#built-in-resolver\">\n- *      built-in resolver<\/a> will be set as the system-wide resolver.\n+ *      {@linkplain InetAddress##built-in-resolver\n+ *      built-in resolver} will be set as the system-wide resolver.\n","filename":"src\/java.base\/share\/classes\/java\/net\/spi\/InetAddressResolverProvider.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,11 +79,9 @@\n- * <pre>\n- *\n- *  String testString = \"This is a test\";\n- *  Collator col = Collator.getInstance();\n- *  if (col instanceof RuleBasedCollator) {\n- *      RuleBasedCollator ruleBasedCollator = (RuleBasedCollator)col;\n- *      CollationElementIterator collationElementIterator = ruleBasedCollator.getCollationElementIterator(testString);\n- *      int primaryOrder = CollationElementIterator.primaryOrder(collationElementIterator.next());\n- *          :\n- *  }\n- * <\/pre>\n+ * {@snippet lang=java :\n+ * String testString = \"This is a test\";\n+ * Collator col = Collator.getInstance();\n+ * if (col instanceof RuleBasedCollator ruleBasedCollator) {\n+ *     CollationElementIterator collationElementIterator = ruleBasedCollator.getCollationElementIterator(testString);\n+ *     int primaryOrder = CollationElementIterator.primaryOrder(collationElementIterator.next());\n+ *         \\u22ee\n+ * }\n+ * }\n","filename":"src\/java.base\/share\/classes\/java\/text\/CollationElementIterator.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n- * <pre>{@code\n+ * {@snippet lang=java :\n@@ -78,1 +78,1 @@\n- * if( myCollator.compare(\"abc\", \"ABC\") < 0 )\n+ * if (myCollator.compare(\"abc\", \"ABC\") < 0) {\n@@ -80,1 +80,1 @@\n- * else\n+ * } else {\n@@ -82,1 +82,2 @@\n- * }<\/pre>\n+ * }\n+ * }\n@@ -97,2 +98,2 @@\n- * <pre>\n- * \/\/Get the Collator for US English and set its strength to PRIMARY\n+ * {@snippet lang=java :\n+ * \/\/ Get the Collator for US English and set its strength to PRIMARY\n@@ -101,1 +102,1 @@\n- * if( usCollator.compare(\"abc\", \"ABC\") == 0 ) {\n+ * if (usCollator.compare(\"abc\", \"ABC\") == 0) {\n@@ -104,1 +105,1 @@\n- * <\/pre>\n+ * }\n","filename":"src\/java.base\/share\/classes\/java\/text\/Collator.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n- * <pre>{@code\n+ * {@snippet lang=java :\n@@ -79,1 +79,1 @@\n- * }<\/pre>\n+ * }\n@@ -86,1 +86,1 @@\n- * <pre>{@code\n+ * {@snippet lang=java :\n@@ -91,1 +91,1 @@\n- * }<\/pre>\n+ * }\n@@ -96,1 +96,1 @@\n- * <pre>{@code\n+ * {@snippet lang=java :\n@@ -98,1 +98,1 @@\n- * }<\/pre>\n+ * }\n@@ -109,1 +109,1 @@\n- * <pre>{@code\n+ * {@snippet lang=java :\n@@ -111,1 +111,1 @@\n- * }<\/pre>\n+ * }\n@@ -700,3 +700,3 @@\n-     * <blockquote><pre>{@code\n-     * getCalendar().setTimeZone(zone)\n-     * }<\/pre><\/blockquote>\n+     * <blockquote>{@snippet lang=java :\n+     * getCalendar().setTimeZone(zone);\n+     * }<\/blockquote>\n@@ -720,3 +720,3 @@\n-     * <blockquote><pre>{@code\n-     * getCalendar().getTimeZone()\n-     * }<\/pre><\/blockquote>\n+     * <blockquote>{@snippet lang=java :\n+     * getCalendar().getTimeZone();\n+     * }<\/blockquote>\n@@ -738,3 +738,3 @@\n-     * <blockquote><pre>{@code\n-     * getCalendar().setLenient(lenient)\n-     * }<\/pre><\/blockquote>\n+     * <blockquote>{@snippet lang=java :\n+     * getCalendar().setLenient(lenient);\n+     * }<\/blockquote>\n@@ -756,3 +756,3 @@\n-     * <blockquote><pre>{@code\n-     * getCalendar().isLenient()\n-     * }<\/pre><\/blockquote>\n+     * <blockquote>{@snippet lang=java :\n+     * getCalendar().isLenient();\n+     * }<\/blockquote>\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormat.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -233,1 +233,2 @@\n- * <blockquote><pre>\n+ * <blockquote>\n+ * {@snippet lang=java :\n@@ -240,1 +241,2 @@\n- * <\/pre><\/blockquote>\n+ * }\n+ * <\/blockquote>\n@@ -249,1 +251,2 @@\n- * <blockquote><pre>\n+ * <blockquote>\n+ * {@snippet lang=java :\n@@ -258,1 +261,2 @@\n- * <\/pre><\/blockquote>\n+ * }\n+ * <\/blockquote>\n@@ -269,1 +273,2 @@\n- * <blockquote><pre>\n+ * <blockquote>\n+ * {@snippet lang=java :\n@@ -281,1 +286,2 @@\n- * <\/pre><\/blockquote>\n+ * }\n+ * <\/blockquote>\n@@ -293,1 +299,2 @@\n- * <blockquote><pre>{@code\n+ * <blockquote>\n+ * {@snippet lang=java :\n@@ -296,1 +303,2 @@\n- * }<\/pre><\/blockquote>\n+ * }\n+ * <\/blockquote>\n@@ -308,1 +316,2 @@\n- * <blockquote><pre>\n+ * <blockquote>\n+ * {@snippet lang=java :\n@@ -315,1 +324,2 @@\n- * <\/pre><\/blockquote>\n+ * }\n+ * <\/blockquote>\n@@ -321,1 +331,2 @@\n- * <blockquote><pre>\n+ * <blockquote>\n+ * {@snippet lang=java :\n@@ -325,2 +336,3 @@\n- * \/\/ result now equals {new String(\"z\")}\n- * <\/pre><\/blockquote>\n+ * \/\/ objs now equals {new String(\"z\")}\n+ * }\n+ * <\/blockquote>\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -4269,1 +4270,1 @@\n-        if (a == null)\n+        if (a == null) {\n@@ -4271,1 +4272,1 @@\n-\n+        }\n@@ -4277,1 +4278,0 @@\n-\n@@ -4298,1 +4298,1 @@\n-        if (a == null)\n+        if (a == null) {\n@@ -4300,6 +4300,6 @@\n-\n-        int result = 1;\n-        for (int element : a)\n-            result = 31 * result + element;\n-\n-        return result;\n+        }\n+        return switch (a.length) {\n+            case 0 -> 1;\n+            case 1 -> 31 + a[0];\n+            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_INT);\n+        };\n@@ -4325,1 +4325,1 @@\n-        if (a == null)\n+        if (a == null) {\n@@ -4327,6 +4327,6 @@\n-\n-        int result = 1;\n-        for (short element : a)\n-            result = 31 * result + element;\n-\n-        return result;\n+        }\n+        return switch (a.length) {\n+            case 0 -> 1;\n+            case 1 -> 31 + (int)a[0];\n+            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_SHORT);\n+        };\n@@ -4352,1 +4352,1 @@\n-        if (a == null)\n+        if (a == null) {\n@@ -4354,6 +4354,6 @@\n-\n-        int result = 1;\n-        for (char element : a)\n-            result = 31 * result + element;\n-\n-        return result;\n+        }\n+        return switch (a.length) {\n+            case 0 -> 1;\n+            case 1 -> 31 + (int)a[0];\n+            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_CHAR);\n+        };\n@@ -4379,1 +4379,1 @@\n-        if (a == null)\n+        if (a == null) {\n@@ -4381,6 +4381,6 @@\n-\n-        int result = 1;\n-        for (byte element : a)\n-            result = 31 * result + element;\n-\n-        return result;\n+        }\n+        return switch (a.length) {\n+            case 0 -> 1;\n+            case 1 -> 31 + (int)a[0];\n+            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_BYTE);\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -283,1 +283,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -286,1 +286,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -466,1 +466,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -469,1 +469,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -488,1 +488,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -492,1 +492,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>),\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -538,1 +538,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -542,1 +542,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>),\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -597,1 +597,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -601,1 +601,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>),\n+     *         ({@linkplain Collection##optional-restrictions optional})\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collection.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -366,1 +366,1 @@\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -369,1 +369,1 @@\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -385,1 +385,1 @@\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -388,1 +388,1 @@\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -568,1 +568,1 @@\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -571,1 +571,1 @@\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -584,1 +584,1 @@\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -587,1 +587,1 @@\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n","filename":"src\/java.base\/share\/classes\/java\/util\/Deque.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,2 +191,1 @@\n-     *         this map\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         this map ({@linkplain Collection##optional-restrictions optional})\n@@ -194,2 +193,1 @@\n-     *         does not permit null keys\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         does not permit null keys ({@linkplain Collection##optional-restrictions optional})\n@@ -211,2 +209,1 @@\n-     *         this map\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         this map ({@linkplain Collection##optional-restrictions optional})\n@@ -214,2 +211,1 @@\n-     *         map does not permit null values\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         map does not permit null values ({@linkplain Collection##optional-restrictions optional})\n@@ -239,2 +235,1 @@\n-     *         this map\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         this map ({@linkplain Collection##optional-restrictions optional})\n@@ -242,2 +237,1 @@\n-     *         does not permit null keys\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         does not permit null keys ({@linkplain Collection##optional-restrictions optional})\n@@ -299,2 +293,1 @@\n-     *         this map\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         this map ({@linkplain Collection##optional-restrictions optional})\n@@ -302,2 +295,1 @@\n-     *         map does not permit null keys\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         map does not permit null keys ({@linkplain Collection##optional-restrictions optional})\n@@ -665,2 +657,1 @@\n-     * this map\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     * this map ({@linkplain Collection##optional-restrictions optional})\n@@ -668,2 +659,1 @@\n-     * does not permit null keys\n-     * (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     * does not permit null keys ({@linkplain Collection##optional-restrictions optional})\n@@ -743,1 +733,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -746,1 +736,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -749,1 +739,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -809,1 +799,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -811,2 +801,1 @@\n-     *         type for this map\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         type for this map ({@linkplain Collection##optional-restrictions optional})\n@@ -815,1 +804,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -818,1 +807,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -855,1 +844,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -858,1 +847,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -861,1 +850,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -903,2 +892,1 @@\n-     *         is not supported by this map\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         is not supported by this map ({@linkplain Collection##optional-restrictions optional})\n@@ -910,2 +898,1 @@\n-     *         permit null values\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         permit null values ({@linkplain Collection##optional-restrictions optional})\n@@ -954,1 +941,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -957,1 +944,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -1037,1 +1024,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -1040,1 +1027,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -1043,1 +1030,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -1114,1 +1101,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -1117,1 +1104,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -1120,1 +1107,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -1200,1 +1187,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+               ({@linkplain Collection##optional-restrictions optional})\n@@ -1203,1 +1190,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -1206,1 +1193,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -1295,1 +1282,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -1298,1 +1285,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n@@ -1301,1 +1288,1 @@\n-     *         (<a href=\"{@docRoot}\/java.base\/java\/util\/Collection.html#optional-restrictions\">optional<\/a>)\n+     *         ({@linkplain Collection##optional-restrictions optional})\n","filename":"src\/java.base\/share\/classes\/java\/util\/Map.java","additions":37,"deletions":50,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -254,4 +254,3 @@\n- * <p>If the caller module is a\n- * <a href=\"{@docRoot}\/java.base\/java\/util\/spi\/ResourceBundleProvider.html#obtain-resource-bundle\">\n- * resource bundle provider<\/a>, it does not fall back to the\n- * class loader search.\n+ * <p>If the caller module is a {@linkplain\n+ * ResourceBundleProvider##obtain-resource-bundle resource bundle\n+ * provider}, it does not fall back to the class loader search.\n@@ -270,2 +269,2 @@\n- * deployed as an <a href=\"{@docRoot}\/java.base\/java\/lang\/module\/ModuleFinder.html#automatic-modules\">\n- * automatic module<\/a>.  For example, if the JAR file contains the\n+ * deployed as an {@linkplain java.lang.module.ModuleFinder##automatic-modules\n+ * automatic module}.  For example, if the JAR file contains the\n","filename":"src\/java.base\/share\/classes\/java\/util\/ResourceBundle.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n- * <blockquote><pre>\n+ * <blockquote>\n+ * {@snippet lang=java :\n@@ -68,1 +69,2 @@\n- * <\/pre><\/blockquote>\n+ * }\n+ * <\/blockquote>\n@@ -312,4 +314,8 @@\n-     * <blockquote><pre>\n-     * getDisplayName(false, {@link #LONG},\n-     *                Locale.getDefault({@link Locale.Category#DISPLAY}))\n-     * <\/pre><\/blockquote>\n+     * <blockquote>\n+     * {@snippet lang=java :\n+     * \/\/ @link substring=\"LONG\" target=\"#LONG\" :\n+     * getDisplayName(false, LONG,\n+     *                \/\/ @link substring=\"Locale.Category.DISPLAY\" target=\"Locale.Category#DISPLAY\" :\n+     *                Locale.getDefault(Locale.Category.DISPLAY));\n+     * }\n+     * <\/blockquote>\n@@ -333,3 +339,6 @@\n-     * <blockquote><pre>\n-     * getDisplayName(false, {@link #LONG}, locale)\n-     * <\/pre><\/blockquote>\n+     * <blockquote>\n+     * {@snippet lang=java :\n+     * \/\/ @link substring=\"LONG\" target=\"#LONG\" :\n+     * getDisplayName(false, LONG, locale);\n+     * }\n+     * <\/blockquote>\n@@ -355,1 +364,2 @@\n-     * <blockquote><pre>\n+     * <blockquote>\n+     * {@snippet lang=java :\n@@ -357,2 +367,4 @@\n-     *                Locale.getDefault({@link Locale.Category#DISPLAY}))\n-     * <\/pre><\/blockquote>\n+     *                \/\/ @link substring=\"Locale.Category.DISPLAY\" target=\"Locale.Category#DISPLAY\" :\n+     *                Locale.getDefault(Locale.Category.DISPLAY));\n+     * }\n+     * <\/blockquote>\n@@ -677,7 +689,2 @@\n-            String javaHome = StaticProperty.javaHome();\n-            try {\n-                zoneID = getSystemTimeZoneID(javaHome);\n-                if (zoneID == null) {\n-                    zoneID = GMT_ID;\n-                }\n-            } catch (NullPointerException e) {\n+            zoneID = getSystemTimeZoneID(StaticProperty.javaHome());\n+            if (zoneID == null) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/TimeZone.java","additions":26,"deletions":19,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -294,3 +294,1 @@\n-     * @param  regex\n-     *         the <a href=\"{@docRoot}\/java.base\/java\/util\/regex\/Pattern.html#sum\">\n-     *         regular expression pattern<\/a>\n+     * @param  regex the {@linkplain Pattern##sum regular expression pattern}\n@@ -334,3 +332,1 @@\n-         * @param  regex\n-         *         the <a href=\"{@docRoot}\/java.base\/java\/util\/regex\/Pattern.html#sum\">\n-         *         regular expression pattern<\/a>\n+         * @param  regex the {@linkplain Pattern##sum regular expression pattern}\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SNIHostName.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -345,0 +345,10 @@\n+    \/**\n+     * Get the char at index in a byte[] in internal UTF-16 representation,\n+     * with no bounds checks.\n+     *\n+     * @param bytes the UTF-16 encoded bytes\n+     * @param index of the char to retrieve, 0 <= index < (bytes.length >> 1)\n+     * @return the char value\n+     *\/\n+    char getUTF16Char(byte[] bytes, int index);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+    LINUX_RISCV_64,\n@@ -73,0 +74,4 @@\n+            } else if (arch.equals(\"riscv64\")) {\n+                if (os.startsWith(\"Linux\")) {\n+                    return LINUX_RISCV_64;\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -186,1 +186,1 @@\n-        return owner == thread;\n+        return owner == null || owner == thread;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -213,0 +213,56 @@\n+\n+    public static final class RISCV64 {\n+        private RISCV64() {\n+            \/\/just the one\n+        }\n+\n+        \/**\n+         * The {@code bool} native type.\n+         *\/\n+        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+\n+        \/**\n+         * The {@code char} native type.\n+         *\/\n+        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+\n+        \/**\n+         * The {@code short} native type.\n+         *\/\n+        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n+\n+        \/**\n+         * The {@code int} native type.\n+         *\/\n+        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n+\n+        \/**\n+         * The {@code long} native type.\n+         *\/\n+        public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n+\n+        \/**\n+         * The {@code long long} native type.\n+         *\/\n+        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n+\n+        \/**\n+         * The {@code float} native type.\n+         *\/\n+        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n+\n+        \/**\n+         * The {@code double} native type.\n+         *\/\n+        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n+\n+        \/**\n+         * The {@code T*} native type.\n+         *\/\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n+\n+        \/**\n+         * The {@code va_list} native type, as it is passed to a function.\n+         *\/\n+        public static final ValueLayout.OfAddress C_VA_LIST = RISCV64.C_POINTER;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -197,2 +197,1 @@\n-        gmtime\n-        ;\n+        gmtime;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.foreign.abi.fallback.FallbackLinker;\n@@ -32,0 +31,2 @@\n+import jdk.internal.foreign.abi.fallback.FallbackLinker;\n+import jdk.internal.foreign.abi.riscv64.linux.LinuxRISCV64Linker;\n@@ -49,1 +50,2 @@\n-                                                                      Windowsx64Linker, FallbackLinker {\n+                                                                      Windowsx64Linker, LinuxRISCV64Linker,\n+                                                                      FallbackLinker {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.foreign.abi.riscv64.linux.LinuxRISCV64Linker;\n@@ -192,0 +193,1 @@\n+            case LINUX_RISCV_64 -> LinuxRISCV64Linker.getInstance();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Institute of Software, Chinese Academy of Sciences.\n+ * All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package jdk.internal.foreign.abi.riscv64;\n+\n+import jdk.internal.foreign.abi.ABIDescriptor;\n+import jdk.internal.foreign.abi.Architecture;\n+import jdk.internal.foreign.abi.StubLocations;\n+import jdk.internal.foreign.abi.VMStorage;\n+import jdk.internal.foreign.abi.riscv64.linux.TypeClass;\n+\n+public class RISCV64Architecture implements Architecture {\n+    public static final Architecture INSTANCE = new RISCV64Architecture();\n+\n+    private static final short REG64_MASK = 0b0000_0000_0000_0001;\n+    private static final short FP_MASK = 0b0000_0000_0000_0001;\n+\n+    private static final int INTEGER_REG_SIZE = 8; \/\/ bytes\n+    private static final int FLOAT_REG_SIZE = 8;\n+\n+    @Override\n+    public boolean isStackType(int cls) {\n+        return cls == StorageType.STACK;\n+    }\n+\n+    @Override\n+    public int typeSize(int cls) {\n+        switch (cls) {\n+            case StorageType.INTEGER: return INTEGER_REG_SIZE;\n+            case StorageType.FLOAT: return FLOAT_REG_SIZE;\n+            \/\/ STACK is deliberately omitted\n+        }\n+\n+        throw new IllegalArgumentException(\"Invalid Storage Class: \" + cls);\n+    }\n+\n+    public interface StorageType {\n+        byte INTEGER = 0;\n+        byte FLOAT = 1;\n+        byte STACK = 2;\n+        byte PLACEHOLDER = 3;\n+    }\n+\n+    public static class Regs { \/\/ break circular dependency\n+        public static final VMStorage x0 = integerRegister(0, \"zr\");\n+        public static final VMStorage x1 = integerRegister(1, \"ra\");\n+        public static final VMStorage x2 = integerRegister(2, \"sp\");\n+        public static final VMStorage x3 = integerRegister(3, \"gp\");\n+        public static final VMStorage x4 = integerRegister(4, \"tp\");\n+        public static final VMStorage x5 = integerRegister(5, \"t0\");\n+        public static final VMStorage x6 = integerRegister(6, \"t1\");\n+        public static final VMStorage x7 = integerRegister(7, \"t2\");\n+        public static final VMStorage x8 = integerRegister(8, \"s0\/fp\");\n+        public static final VMStorage x9 = integerRegister(9, \"s1\");\n+        public static final VMStorage x10 = integerRegister(10, \"a0\");\n+        public static final VMStorage x11 = integerRegister(11, \"a1\");\n+        public static final VMStorage x12 = integerRegister(12, \"a2\");\n+        public static final VMStorage x13 = integerRegister(13, \"a3\");\n+        public static final VMStorage x14 = integerRegister(14, \"a4\");\n+        public static final VMStorage x15 = integerRegister(15, \"a5\");\n+        public static final VMStorage x16 = integerRegister(16, \"a6\");\n+        public static final VMStorage x17 = integerRegister(17, \"a7\");\n+        public static final VMStorage x18 = integerRegister(18, \"s2\");\n+        public static final VMStorage x19 = integerRegister(19, \"s3\");\n+        public static final VMStorage x20 = integerRegister(20, \"s4\");\n+        public static final VMStorage x21 = integerRegister(21, \"s5\");\n+        public static final VMStorage x22 = integerRegister(22, \"s6\");\n+        public static final VMStorage x23 = integerRegister(23, \"s7\");\n+        public static final VMStorage x24 = integerRegister(24, \"s8\");\n+        public static final VMStorage x25 = integerRegister(25, \"s9\");\n+        public static final VMStorage x26 = integerRegister(26, \"s10\");\n+        public static final VMStorage x27 = integerRegister(27, \"s11\");\n+        public static final VMStorage x28 = integerRegister(28, \"t3\");\n+        public static final VMStorage x29 = integerRegister(29, \"t4\");\n+        public static final VMStorage x30 = integerRegister(30, \"t5\");\n+        public static final VMStorage x31 = integerRegister(31, \"t6\");\n+\n+        public static final VMStorage f0 = floatRegister(0, \"ft0\");\n+        public static final VMStorage f1 = floatRegister(1, \"ft1\");\n+        public static final VMStorage f2 = floatRegister(2, \"ft2\");\n+        public static final VMStorage f3 = floatRegister(3, \"ft3\");\n+        public static final VMStorage f4 = floatRegister(4, \"ft4\");\n+        public static final VMStorage f5 = floatRegister(5, \"ft5\");\n+        public static final VMStorage f6 = floatRegister(6, \"ft6\");\n+        public static final VMStorage f7 = floatRegister(7, \"ft7\");\n+        public static final VMStorage f8 = floatRegister(8, \"fs0\");\n+        public static final VMStorage f9 = floatRegister(9, \"fs1\");\n+        public static final VMStorage f10 = floatRegister(10, \"fa0\");\n+        public static final VMStorage f11 = floatRegister(11, \"fa1\");\n+        public static final VMStorage f12 = floatRegister(12, \"fa2\");\n+        public static final VMStorage f13 = floatRegister(13, \"fa3\");\n+        public static final VMStorage f14 = floatRegister(14, \"fa4\");\n+        public static final VMStorage f15 = floatRegister(15, \"fa5\");\n+        public static final VMStorage f16 = floatRegister(16, \"fa6\");\n+        public static final VMStorage f17 = floatRegister(17, \"fa7\");\n+        public static final VMStorage f18 = floatRegister(18, \"fs2\");\n+        public static final VMStorage f19 = floatRegister(19, \"fs3\");\n+        public static final VMStorage f20 = floatRegister(20, \"fs4\");\n+        public static final VMStorage f21 = floatRegister(21, \"fs5\");\n+        public static final VMStorage f22 = floatRegister(22, \"fs6\");\n+        public static final VMStorage f23 = floatRegister(23, \"fs7\");\n+        public static final VMStorage f24 = floatRegister(24, \"fs8\");\n+        public static final VMStorage f25 = floatRegister(25, \"fs9\");\n+        public static final VMStorage f26 = floatRegister(26, \"fs10\");\n+        public static final VMStorage f27 = floatRegister(27, \"fs11\");\n+        public static final VMStorage f28 = floatRegister(28, \"ft8\");\n+        public static final VMStorage f29 = floatRegister(29, \"ft9\");\n+        public static final VMStorage f30 = floatRegister(30, \"ft10\");\n+        public static final VMStorage f31 = floatRegister(31, \"ft11\");\n+    }\n+\n+    private static VMStorage integerRegister(int index, String debugName) {\n+        return new VMStorage(StorageType.INTEGER, REG64_MASK, index, debugName);\n+    }\n+\n+    private static VMStorage floatRegister(int index, String debugName) {\n+        return new VMStorage(StorageType.FLOAT, FP_MASK, index, debugName);\n+    }\n+\n+    public static VMStorage stackStorage(short size, int byteOffset) {\n+        return new VMStorage(StorageType.STACK, size, byteOffset);\n+    }\n+\n+    public static ABIDescriptor abiFor(VMStorage[] inputIntRegs,\n+                                       VMStorage[] inputFloatRegs,\n+                                       VMStorage[] outputIntRegs,\n+                                       VMStorage[] outputFloatRegs,\n+                                       VMStorage[] volatileIntRegs,\n+                                       VMStorage[] volatileFloatRegs,\n+                                       int stackAlignment,\n+                                       int shadowSpace,\n+                                       VMStorage scratch1, VMStorage scratch2) {\n+        return new ABIDescriptor(\n+            INSTANCE,\n+            new VMStorage[][]{\n+                inputIntRegs,\n+                inputFloatRegs,\n+            },\n+            new VMStorage[][]{\n+                outputIntRegs,\n+                outputFloatRegs,\n+            },\n+            new VMStorage[][]{\n+                volatileIntRegs,\n+                volatileFloatRegs,\n+            },\n+            stackAlignment,\n+            shadowSpace,\n+            scratch1, scratch2,\n+            StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER),\n+            StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER),\n+            StubLocations.CAPTURED_STATE_BUFFER.storage(StorageType.PLACEHOLDER));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/RISCV64Architecture.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -0,0 +1,473 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Institute of Software, Chinese Academy of Sciences.\n+ * All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package jdk.internal.foreign.abi.riscv64.linux;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import jdk.internal.foreign.abi.ABIDescriptor;\n+import jdk.internal.foreign.abi.Binding;\n+import jdk.internal.foreign.abi.CallingSequence;\n+import jdk.internal.foreign.abi.CallingSequenceBuilder;\n+import jdk.internal.foreign.abi.DowncallLinker;\n+import jdk.internal.foreign.abi.LinkerOptions;\n+import jdk.internal.foreign.abi.UpcallLinker;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.VMStorage;\n+import jdk.internal.foreign.Utils;\n+\n+import java.lang.foreign.SegmentScope;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static jdk.internal.foreign.abi.riscv64.linux.TypeClass.*;\n+import static jdk.internal.foreign.abi.riscv64.RISCV64Architecture.*;\n+import static jdk.internal.foreign.abi.riscv64.RISCV64Architecture.Regs.*;\n+import static jdk.internal.foreign.PlatformLayouts.*;\n+\n+\/**\n+ * For the RISCV64 C ABI specifically, this class uses CallingSequenceBuilder\n+ * to translate a C FunctionDescriptor into a CallingSequence, which can then be turned into a MethodHandle.\n+ *\n+ * This includes taking care of synthetic arguments like pointers to return buffers for 'in-memory' returns.\n+ *\/\n+public class LinuxRISCV64CallArranger {\n+    private static final int STACK_SLOT_SIZE = 8;\n+    public static final int MAX_REGISTER_ARGUMENTS = 8;\n+    private static final ABIDescriptor CLinux = abiFor(\n+            new VMStorage[]{x10, x11, x12, x13, x14, x15, x16, x17},\n+            new VMStorage[]{f10, f11, f12, f13, f14, f15, f16, f17},\n+            new VMStorage[]{x10, x11},\n+            new VMStorage[]{f10, f11},\n+            new VMStorage[]{x5, x6, x7, x28, x29, x30, x31},\n+            new VMStorage[]{f0, f1, f2, f3, f4, f5, f6, f7, f28, f29, f30, f31},\n+            16, \/\/ stackAlignment\n+            0,  \/\/ no shadow space\n+            x28, x29 \/\/ scratch 1 & 2\n+    );\n+\n+    public record Bindings(CallingSequence callingSequence,\n+                           boolean isInMemoryReturn) {\n+    }\n+\n+    public static Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall) {\n+        return getBindings(mt, cDesc, forUpcall, LinkerOptions.empty());\n+    }\n+\n+    public static Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall, LinkerOptions options) {\n+        CallingSequenceBuilder csb = new CallingSequenceBuilder(CLinux, forUpcall, options);\n+        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true);\n+        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false) : new BoxBindingCalculator(false);\n+\n+        boolean returnInMemory = isInMemoryReturn(cDesc.returnLayout());\n+        if (returnInMemory) {\n+            Class<?> carrier = MemorySegment.class;\n+            MemoryLayout layout = RISCV64.C_POINTER;\n+            csb.addArgumentBindings(carrier, layout, argCalc.getBindings(carrier, layout, false));\n+        } else if (cDesc.returnLayout().isPresent()) {\n+            Class<?> carrier = mt.returnType();\n+            MemoryLayout layout = cDesc.returnLayout().get();\n+            csb.setReturnBindings(carrier, layout, retCalc.getBindings(carrier, layout, false));\n+        }\n+\n+        for (int i = 0; i < mt.parameterCount(); i++) {\n+            Class<?> carrier = mt.parameterType(i);\n+            MemoryLayout layout = cDesc.argumentLayouts().get(i);\n+            boolean isVar = options.isVarargsIndex(i);\n+            csb.addArgumentBindings(carrier, layout, argCalc.getBindings(carrier, layout, isVar));\n+        }\n+\n+        return new Bindings(csb.build(), returnInMemory);\n+    }\n+\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, false, options);\n+\n+        MethodHandle handle = new DowncallLinker(CLinux, bindings.callingSequence).getBoundMethodHandle();\n+\n+        if (bindings.isInMemoryReturn) {\n+            handle = SharedUtils.adaptDowncallForIMR(handle, cDesc, bindings.callingSequence);\n+        }\n+\n+        return handle;\n+    }\n+\n+    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope scope) {\n+\n+        Bindings bindings = getBindings(mt, cDesc, true);\n+\n+        if (bindings.isInMemoryReturn) {\n+            target = SharedUtils.adaptUpcallForIMR(target, true \/* drop return, since we don't have bindings for it *\/);\n+        }\n+\n+        return UpcallLinker.make(CLinux, target, bindings.callingSequence, scope);\n+    }\n+\n+    private static boolean isInMemoryReturn(Optional<MemoryLayout> returnLayout) {\n+        return returnLayout\n+                .filter(GroupLayout.class::isInstance)\n+                .filter(g -> TypeClass.classifyLayout(g) == TypeClass.STRUCT_REFERENCE)\n+                .isPresent();\n+    }\n+\n+    static class StorageCalculator {\n+        private final boolean forArguments;\n+        \/\/ next available register index. 0=integerRegIdx, 1=floatRegIdx\n+        private final int IntegerRegIdx = 0;\n+        private final int FloatRegIdx = 1;\n+        private final int[] nRegs = {0, 0};\n+\n+        private long stackOffset = 0;\n+\n+        public StorageCalculator(boolean forArguments) {\n+            this.forArguments = forArguments;\n+        }\n+\n+        \/\/ Aggregates or scalars passed on the stack are aligned to the greater of\n+        \/\/ the type alignment and XLEN bits, but never more than the stack alignment.\n+        void alignStack(long alignment) {\n+            alignment = Utils.alignUp(Math.min(Math.max(alignment, STACK_SLOT_SIZE), 16), STACK_SLOT_SIZE);\n+            stackOffset = Utils.alignUp(stackOffset, alignment);\n+        }\n+\n+        VMStorage stackAlloc() {\n+            assert forArguments : \"no stack returns\";\n+            VMStorage storage = stackStorage((short) STACK_SLOT_SIZE, (int) stackOffset);\n+            stackOffset += STACK_SLOT_SIZE;\n+            return storage;\n+        }\n+\n+        Optional<VMStorage> regAlloc(int storageClass) {\n+            if (nRegs[storageClass] < MAX_REGISTER_ARGUMENTS) {\n+                VMStorage[] source = (forArguments ? CLinux.inputStorage : CLinux.outputStorage)[storageClass];\n+                Optional<VMStorage> result = Optional.of(source[nRegs[storageClass]]);\n+                nRegs[storageClass] += 1;\n+                return result;\n+            }\n+            return Optional.empty();\n+        }\n+\n+        VMStorage getStorage(int storageClass) {\n+            Optional<VMStorage> storage = regAlloc(storageClass);\n+            if (storage.isPresent()) {\n+                return storage.get();\n+            }\n+            \/\/ If storageClass is StorageType.FLOAT, and no floating-point register is available,\n+            \/\/ try to allocate an integer register.\n+            if (storageClass == StorageType.FLOAT) {\n+                storage = regAlloc(StorageType.INTEGER);\n+                if (storage.isPresent()) {\n+                    return storage.get();\n+                }\n+            }\n+            return stackAlloc();\n+        }\n+\n+        VMStorage[] getStorages(MemoryLayout layout, boolean isVariadicArg) {\n+            int regCnt = (int) SharedUtils.alignUp(layout.byteSize(), 8) \/ 8;\n+            if (isVariadicArg && layout.byteAlignment() == 16 && layout.byteSize() <= 16) {\n+                alignStorage();\n+                \/\/ Two registers or stack slots will be allocated, even layout.byteSize <= 8B.\n+                regCnt = 2;\n+            }\n+            VMStorage[] storages = new VMStorage[regCnt];\n+            for (int i = 0; i < regCnt; i++) {\n+                \/\/ use integer calling convention.\n+                storages[i] = getStorage(StorageType.INTEGER);\n+            }\n+            return storages;\n+        }\n+\n+        boolean regsAvailable(int integerRegs, int floatRegs) {\n+            return nRegs[IntegerRegIdx] + integerRegs <= MAX_REGISTER_ARGUMENTS &&\n+                   nRegs[FloatRegIdx] + floatRegs <= MAX_REGISTER_ARGUMENTS;\n+        }\n+\n+        \/\/ Variadic arguments with 2 * XLEN-bit alignment and size at most 2 * XLEN bits\n+        \/\/ are passed in an aligned register pair (i.e., the first register in the pair\n+        \/\/ is even-numbered), or on the stack by value if none is available.\n+        \/\/ After a variadic argument has been passed on the stack, all future arguments\n+        \/\/ will also be passed on the stack.\n+        void alignStorage() {\n+            if (nRegs[IntegerRegIdx] + 2 <= MAX_REGISTER_ARGUMENTS) {\n+                nRegs[IntegerRegIdx] = (nRegs[IntegerRegIdx] + 1) & -2;\n+            } else {\n+                nRegs[IntegerRegIdx] = MAX_REGISTER_ARGUMENTS;\n+                stackOffset = Utils.alignUp(stackOffset, 16);\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String nReg = \"iReg: \" + nRegs[IntegerRegIdx] + \", fReg: \" + nRegs[FloatRegIdx];\n+            String stack = \", stackOffset: \" + stackOffset;\n+            return \"{\" + nReg + stack + \"}\";\n+        }\n+    }\n+\n+    abstract static class BindingCalculator {\n+        protected final StorageCalculator storageCalculator;\n+\n+        @Override\n+        public String toString() {\n+            return storageCalculator.toString();\n+        }\n+\n+        protected BindingCalculator(boolean forArguments) {\n+            this.storageCalculator = new LinuxRISCV64CallArranger.StorageCalculator(forArguments);\n+        }\n+\n+        abstract List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, boolean isVariadicArg);\n+\n+        \/\/ When handling variadic part, integer calling convention should be used.\n+        static final Map<TypeClass, TypeClass> conventionConverterMap =\n+                Map.ofEntries(Map.entry(FLOAT, INTEGER),\n+                              Map.entry(STRUCT_REGISTER_F, STRUCT_REGISTER_X),\n+                              Map.entry(STRUCT_REGISTER_XF, STRUCT_REGISTER_X));\n+    }\n+\n+    static class UnboxBindingCalculator extends BindingCalculator {\n+        boolean forArguments;\n+\n+        UnboxBindingCalculator(boolean forArguments) {\n+            super(forArguments);\n+            this.forArguments = forArguments;\n+        }\n+\n+        @Override\n+        List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, boolean isVariadicArg) {\n+            TypeClass typeClass = TypeClass.classifyLayout(layout);\n+            if (isVariadicArg) {\n+                typeClass = BindingCalculator.conventionConverterMap.getOrDefault(typeClass, typeClass);\n+            }\n+            return getBindings(carrier, layout, typeClass, isVariadicArg);\n+        }\n+\n+        List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, TypeClass argumentClass, boolean isVariadicArg) {\n+            Binding.Builder bindings = Binding.builder();\n+            switch (argumentClass) {\n+                case INTEGER -> {\n+                    VMStorage storage = storageCalculator.getStorage(StorageType.INTEGER);\n+                    bindings.vmStore(storage, carrier);\n+                }\n+                case FLOAT -> {\n+                    VMStorage storage = storageCalculator.getStorage(StorageType.FLOAT);\n+                    bindings.vmStore(storage, carrier);\n+                }\n+                case POINTER -> {\n+                    bindings.unboxAddress();\n+                    VMStorage storage = storageCalculator.getStorage(StorageType.INTEGER);\n+                    bindings.vmStore(storage, long.class);\n+                }\n+                case STRUCT_REGISTER_X -> {\n+                    assert carrier == MemorySegment.class;\n+\n+                    \/\/ When no register is available, struct will be passed by stack.\n+                    \/\/ Before allocation, stack must be aligned.\n+                    if (!storageCalculator.regsAvailable(1, 0)) {\n+                        storageCalculator.alignStack(layout.byteAlignment());\n+                    }\n+                    VMStorage[] locations = storageCalculator.getStorages(layout, isVariadicArg);\n+                    int locIndex = 0;\n+                    long offset = 0;\n+                    while (offset < layout.byteSize()) {\n+                        final long copy = Math.min(layout.byteSize() - offset, 8);\n+                        VMStorage storage = locations[locIndex++];\n+                        Class<?> type = SharedUtils.primitiveCarrierForSize(copy, false);\n+                        if (offset + copy < layout.byteSize()) {\n+                            bindings.dup();\n+                        }\n+                        bindings.bufferLoad(offset, type)\n+                                .vmStore(storage, type);\n+                        offset += copy;\n+                    }\n+                }\n+                case STRUCT_REGISTER_F -> {\n+                    assert carrier == MemorySegment.class;\n+                    List<FlattenedFieldDesc> descs = getFlattenedFields((GroupLayout) layout);\n+                    if (storageCalculator.regsAvailable(0, descs.size())) {\n+                        for (int i = 0; i < descs.size(); i++) {\n+                            FlattenedFieldDesc desc = descs.get(i);\n+                            Class<?> type = desc.layout().carrier();\n+                            VMStorage storage = storageCalculator.getStorage(StorageType.FLOAT);\n+                            if (i < descs.size() - 1) {\n+                                bindings.dup();\n+                            }\n+                            bindings.bufferLoad(desc.offset(), type)\n+                                    .vmStore(storage, type);\n+                        }\n+                    } else {\n+                        \/\/ If there is not enough register can be used, then fall back to integer calling convention.\n+                        return getBindings(carrier, layout, STRUCT_REGISTER_X, isVariadicArg);\n+                    }\n+                }\n+                case STRUCT_REGISTER_XF -> {\n+                    assert carrier == MemorySegment.class;\n+                    if (storageCalculator.regsAvailable(1, 1)) {\n+                        List<FlattenedFieldDesc> descs = getFlattenedFields((GroupLayout) layout);\n+                        for (int i = 0; i < 2; i++) {\n+                            FlattenedFieldDesc desc = descs.get(i);\n+                            int storageClass;\n+                            if (desc.typeClass() == INTEGER) {\n+                                storageClass = StorageType.INTEGER;\n+                            } else {\n+                                storageClass = StorageType.FLOAT;\n+                            }\n+                            VMStorage storage = storageCalculator.getStorage(storageClass);\n+                            Class<?> type = desc.layout().carrier();\n+                            if (i < 1) {\n+                                bindings.dup();\n+                            }\n+                            bindings.bufferLoad(desc.offset(), type)\n+                                    .vmStore(storage, type);\n+                        }\n+                    } else {\n+                        return getBindings(carrier, layout, STRUCT_REGISTER_X, isVariadicArg);\n+                    }\n+                }\n+                case STRUCT_REFERENCE -> {\n+                    assert carrier == MemorySegment.class;\n+                    bindings.copy(layout)\n+                            .unboxAddress();\n+                    VMStorage storage = storageCalculator.getStorage(StorageType.INTEGER);\n+                    bindings.vmStore(storage, long.class);\n+                }\n+                default -> throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n+            }\n+\n+            return bindings.build();\n+        }\n+    }\n+\n+    static class BoxBindingCalculator extends BindingCalculator {\n+\n+        BoxBindingCalculator(boolean forArguments) {\n+            super(forArguments);\n+        }\n+\n+        @Override\n+        List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, boolean isVariadicArg) {\n+            TypeClass typeClass = TypeClass.classifyLayout(layout);\n+            if (isVariadicArg) {\n+                typeClass = BindingCalculator.conventionConverterMap.getOrDefault(typeClass, typeClass);\n+            }\n+            return getBindings(carrier, layout, typeClass, isVariadicArg);\n+        }\n+\n+        List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, TypeClass argumentClass, boolean isVariadicArg) {\n+            Binding.Builder bindings = Binding.builder();\n+            switch (argumentClass) {\n+                case INTEGER -> {\n+                    VMStorage storage = storageCalculator.getStorage(StorageType.INTEGER);\n+                    bindings.vmLoad(storage, carrier);\n+                }\n+                case FLOAT -> {\n+                    VMStorage storage = storageCalculator.getStorage(StorageType.FLOAT);\n+                    bindings.vmLoad(storage, carrier);\n+                }\n+                case POINTER -> {\n+                    VMStorage storage = storageCalculator.getStorage(StorageType.INTEGER);\n+                    bindings.vmLoad(storage, long.class)\n+                            .boxAddressRaw(Utils.pointeeSize(layout));\n+                }\n+                case STRUCT_REGISTER_X -> {\n+                    assert carrier == MemorySegment.class;\n+\n+                    \/\/ When no register is available, struct will be passed by stack.\n+                    \/\/ Before allocation, stack must be aligned.\n+                    if (!storageCalculator.regsAvailable(1, 0)) {\n+                        storageCalculator.alignStack(layout.byteAlignment());\n+                    }\n+                    bindings.allocate(layout);\n+                    VMStorage[] locations = storageCalculator.getStorages(layout, isVariadicArg);\n+                    int locIndex = 0;\n+                    long offset = 0;\n+                    while (offset < layout.byteSize()) {\n+                        final long copy = Math.min(layout.byteSize() - offset, 8);\n+                        VMStorage storage = locations[locIndex++];\n+                        Class<?> type = SharedUtils.primitiveCarrierForSize(copy, false);\n+                        bindings.dup().vmLoad(storage, type)\n+                                .bufferStore(offset, type);\n+                        offset += copy;\n+                    }\n+                }\n+                case STRUCT_REGISTER_F -> {\n+                    assert carrier == MemorySegment.class;\n+                    bindings.allocate(layout);\n+                    List<FlattenedFieldDesc> descs = getFlattenedFields((GroupLayout) layout);\n+                    if (storageCalculator.regsAvailable(0, descs.size())) {\n+                        for (FlattenedFieldDesc desc : descs) {\n+                            Class<?> type = desc.layout().carrier();\n+                            VMStorage storage = storageCalculator.getStorage(StorageType.FLOAT);\n+                            bindings.dup()\n+                                    .vmLoad(storage, type)\n+                                    .bufferStore(desc.offset(), type);\n+                        }\n+                    } else {\n+                        return getBindings(carrier, layout, STRUCT_REGISTER_X, isVariadicArg);\n+                    }\n+                }\n+                case STRUCT_REGISTER_XF -> {\n+                    assert carrier == MemorySegment.class;\n+                    bindings.allocate(layout);\n+                    if (storageCalculator.regsAvailable(1, 1)) {\n+                        List<FlattenedFieldDesc> descs = getFlattenedFields((GroupLayout) layout);\n+                        for (int i = 0; i < 2; i++) {\n+                            FlattenedFieldDesc desc = descs.get(i);\n+                            int storageClass;\n+                            if (desc.typeClass() == INTEGER) {\n+                                storageClass = StorageType.INTEGER;\n+                            } else {\n+                                storageClass = StorageType.FLOAT;\n+                            }\n+                            VMStorage storage = storageCalculator.getStorage(storageClass);\n+                            Class<?> type = desc.layout().carrier();\n+                            bindings.dup()\n+                                    .vmLoad(storage, type)\n+                                    .bufferStore(desc.offset(), type);\n+                        }\n+                    } else {\n+                        return getBindings(carrier, layout, STRUCT_REGISTER_X, isVariadicArg);\n+                    }\n+                }\n+                case STRUCT_REFERENCE -> {\n+                    assert carrier == MemorySegment.class;\n+                    VMStorage storage = storageCalculator.getStorage(StorageType.INTEGER);\n+                    bindings.vmLoad(storage, long.class)\n+                            .boxAddress(layout);\n+                }\n+                default -> throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n+            }\n+\n+            return bindings.build();\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64CallArranger.java","additions":473,"deletions":0,"binary":false,"changes":473,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Institute of Software, Chinese Academy of Sciences.\n+ * All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package jdk.internal.foreign.abi.riscv64.linux;\n+\n+import jdk.internal.foreign.abi.AbstractLinker;\n+import jdk.internal.foreign.abi.LinkerOptions;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentScope;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+public final class LinuxRISCV64Linker extends AbstractLinker {\n+\n+    public static LinuxRISCV64Linker getInstance() {\n+        final class Holder {\n+            private static final LinuxRISCV64Linker INSTANCE = new LinuxRISCV64Linker();\n+        }\n+\n+        return Holder.INSTANCE;\n+    }\n+\n+    private LinuxRISCV64Linker() {\n+        \/\/ Ensure there is only one instance\n+    }\n+\n+    @Override\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n+        return LinuxRISCV64CallArranger.arrangeDowncall(inferredMethodType, function, options);\n+    }\n+\n+    @Override\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n+        return LinuxRISCV64CallArranger.arrangeUpcall(target, targetType, function, scope);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Institute of Software, Chinese Academy of Sciences.\n+ * All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package jdk.internal.foreign.abi.riscv64.linux;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.UnionLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public enum TypeClass {\n+    \/*\n+     * STRUCT_REFERENCE: Aggregates larger than 2 * XLEN bits are passed by reference and are replaced\n+     *     in the argument list with the address. The address will be passed in a register if at least\n+     *     one register is available, otherwise it will be passed on the stack.\n+     *\n+     * STRUCT_REGISTER_F: A struct containing just one floating-point real is passed as though it were\n+     *     a standalone floating-point real. A struct containing two floating-point reals is passed in two\n+     *     floating-point registers, if neither real is more than ABI_FLEN bits wide and at least two\n+     *     floating-point argument registers are available. (The registers need not be an aligned pair.)\n+     *     Otherwise, it is passed according to the integer calling convention.\n+     *\n+     * STRUCT_REGISTER_XF: A struct containing one floating-point real and one integer (or bitfield), in either\n+     *     order, is passed in a floating-point register and an integer register, provided the floating-point real\n+     *     is no more than ABI_FLEN bits wide and the integer is no more than XLEN bits wide, and at least one\n+     *     floating-point argument register and at least one integer argument register is available. If the struct\n+     *     is not passed in this manner, then it is passed according to the integer calling convention.\n+     *\n+     * STRUCT_REGISTER_X: Aggregates whose total size is no more than XLEN bits are passed in a register, with the\n+     *     fields laid out as though they were passed in memory. If no register is available, the aggregate is\n+     *     passed on the stack. Aggregates whose total size is no more than 2 * XLEN bits are passed in a pair of\n+     *     registers; if only one register is available, the first XLEN bits are passed in a register and the\n+     *     remaining bits are passed on the stack. If no registers are available, the aggregate is passed on the stack.\n+     *\n+     * See https:\/\/github.com\/riscv-non-isa\/riscv-elf-psabi-doc\/blob\/master\/riscv-cc.adoc\n+     * *\/\n+    INTEGER,\n+    FLOAT,\n+    POINTER,\n+    STRUCT_REFERENCE,\n+    STRUCT_REGISTER_F,\n+    STRUCT_REGISTER_XF,\n+    STRUCT_REGISTER_X;\n+\n+    private static final int MAX_AGGREGATE_REGS_SIZE = 2;\n+\n+    \/*\n+     * Struct will be flattened while classifying. That is, struct{struct{int, double}} will be treated\n+     * same as struct{int, double} and struct{int[2]} will be treated same as struct{int, int}.\n+     * *\/\n+    private static record FieldCounter(long integerCnt, long floatCnt, long pointerCnt) {\n+        static final FieldCounter EMPTY = new FieldCounter(0, 0, 0);\n+        static final FieldCounter SINGLE_INTEGER = new FieldCounter(1, 0, 0);\n+        static final FieldCounter SINGLE_FLOAT = new FieldCounter(0, 1, 0);\n+        static final FieldCounter SINGLE_POINTER = new FieldCounter(0, 0, 1);\n+\n+        static FieldCounter flatten(MemoryLayout layout) {\n+            if (layout instanceof ValueLayout valueLayout) {\n+                return switch (classifyValueType(valueLayout)) {\n+                    case INTEGER -> FieldCounter.SINGLE_INTEGER;\n+                    case FLOAT -> FieldCounter.SINGLE_FLOAT;\n+                    case POINTER -> FieldCounter.SINGLE_POINTER;\n+                    default -> throw new IllegalStateException(\"Should not reach here.\");\n+                };\n+            } else if (layout instanceof GroupLayout groupLayout) {\n+                FieldCounter currCounter = FieldCounter.EMPTY;\n+                for (MemoryLayout memberLayout : groupLayout.memberLayouts()) {\n+                    if (memberLayout instanceof PaddingLayout) {\n+                        continue;\n+                    }\n+                    currCounter = currCounter.add(flatten(memberLayout));\n+                }\n+                return currCounter;\n+            } else if (layout instanceof SequenceLayout sequenceLayout) {\n+                long elementCount = sequenceLayout.elementCount();\n+                if (elementCount == 0) {\n+                    return FieldCounter.EMPTY;\n+                }\n+                return flatten(sequenceLayout.elementLayout()).mul(elementCount);\n+            } else {\n+                throw new IllegalStateException(\"Cannot get here: \" + layout);\n+            }\n+        }\n+\n+        FieldCounter mul(long m) {\n+            return new FieldCounter(integerCnt * m,\n+                                    floatCnt * m,\n+                                    pointerCnt * m);\n+        }\n+\n+        FieldCounter add(FieldCounter other) {\n+            return new FieldCounter(integerCnt + other.integerCnt,\n+                                    floatCnt + other.floatCnt,\n+                                    pointerCnt + other.pointerCnt);\n+        }\n+    }\n+\n+    public static record FlattenedFieldDesc(TypeClass typeClass, long offset, ValueLayout layout) {\n+\n+    }\n+\n+    private static List<FlattenedFieldDesc> getFlattenedFieldsInner(long offset, MemoryLayout layout) {\n+        if (layout instanceof ValueLayout valueLayout) {\n+            TypeClass typeClass = classifyValueType(valueLayout);\n+            return List.of(switch (typeClass) {\n+                case INTEGER, FLOAT -> new FlattenedFieldDesc(typeClass, offset, valueLayout);\n+                default -> throw new IllegalStateException(\"Should not reach here.\");\n+            });\n+        } else if (layout instanceof GroupLayout groupLayout) {\n+            List<FlattenedFieldDesc> fields = new ArrayList<>();\n+            for (MemoryLayout memberLayout : groupLayout.memberLayouts()) {\n+                if (memberLayout instanceof PaddingLayout) {\n+                    offset += memberLayout.byteSize();\n+                    continue;\n+                }\n+                fields.addAll(getFlattenedFieldsInner(offset, memberLayout));\n+                offset += memberLayout.byteSize();\n+            }\n+            return fields;\n+        } else if (layout instanceof SequenceLayout sequenceLayout) {\n+            List<FlattenedFieldDesc> fields = new ArrayList<>();\n+            MemoryLayout elementLayout = sequenceLayout.elementLayout();\n+            for (long i = 0; i < sequenceLayout.elementCount(); i++) {\n+                fields.addAll(getFlattenedFieldsInner(offset, elementLayout));\n+                offset += elementLayout.byteSize();\n+            }\n+            return fields;\n+        } else {\n+            throw new IllegalStateException(\"Cannot get here: \" + layout);\n+        }\n+    }\n+\n+    public static List<FlattenedFieldDesc> getFlattenedFields(GroupLayout layout) {\n+        return getFlattenedFieldsInner(0, layout);\n+    }\n+\n+    \/\/ ValueLayout will be classified by its carrier type.\n+    private static TypeClass classifyValueType(ValueLayout type) {\n+        Class<?> carrier = type.carrier();\n+        if (carrier == boolean.class || carrier == byte.class || carrier == char.class ||\n+            carrier == short.class || carrier == int.class || carrier == long.class) {\n+            return INTEGER;\n+        } else if (carrier == float.class || carrier == double.class) {\n+            return FLOAT;\n+        } else if (carrier == MemorySegment.class) {\n+            return POINTER;\n+        } else {\n+            throw new IllegalStateException(\"Cannot get here: \" + carrier.getName());\n+        }\n+    }\n+\n+    private static boolean isRegisterAggregate(MemoryLayout type) {\n+        return type.bitSize() <= MAX_AGGREGATE_REGS_SIZE * 64;\n+    }\n+\n+    private static TypeClass classifyStructType(GroupLayout layout) {\n+        if (layout instanceof UnionLayout) {\n+            return isRegisterAggregate(layout) ? STRUCT_REGISTER_X : STRUCT_REFERENCE;\n+        }\n+\n+        if (!isRegisterAggregate(layout)) {\n+            return STRUCT_REFERENCE;\n+        }\n+\n+        \/\/ classify struct by its fields.\n+        FieldCounter counter = FieldCounter.flatten(layout);\n+        if (counter.integerCnt == 0 && counter.pointerCnt == 0 &&\n+            (counter.floatCnt == 1 || counter.floatCnt == 2)) {\n+            return STRUCT_REGISTER_F;\n+        } else if (counter.integerCnt == 1 && counter.floatCnt == 1 &&\n+                   counter.pointerCnt == 0) {\n+            return STRUCT_REGISTER_XF;\n+        } else {\n+            return STRUCT_REGISTER_X;\n+        }\n+    }\n+\n+    public static TypeClass classifyLayout(MemoryLayout type) {\n+        if (type instanceof ValueLayout vt) {\n+            return classifyValueType(vt);\n+        } else if (type instanceof GroupLayout gt) {\n+            return classifyStructType(gt);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported layout: \" + type);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/TypeClass.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.nio.file.InvalidPathException;\n@@ -135,2 +136,2 @@\n-        \/\/ convert to file path\n-        Path path;\n+        \/\/ map resource name to a file path string\n+        String pathString;\n@@ -138,1 +139,1 @@\n-            path = fs.getPath(name);\n+            pathString = name;\n@@ -143,1 +144,10 @@\n-            path = fs.getPath(name.replace('\/', File.separatorChar));\n+            pathString = name.replace('\/', File.separatorChar);\n+        }\n+\n+        \/\/ try to convert to a Path\n+        Path path;\n+        try {\n+            path = fs.getPath(pathString);\n+        } catch (InvalidPathException e) {\n+            \/\/ not a valid file path\n+            return null;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/Resources.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -163,0 +165,99 @@\n+    \/\/ Possible values for the type operand of the NEWARRAY instruction.\n+    \/\/ See https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-6.html#jvms-6.5.newarray.\n+\n+    public static final int T_BOOLEAN = 4;\n+    public static final int T_CHAR = 5;\n+    public static final int T_FLOAT = 6;\n+    public static final int T_DOUBLE = 7;\n+    public static final int T_BYTE = 8;\n+    public static final int T_SHORT = 9;\n+    public static final int T_INT = 10;\n+    public static final int T_LONG = 11;\n+\n+    \/**\n+     * Calculate the hash code for an array in a way that enables efficient\n+     * vectorization.\n+     *\n+     * <p>This method does not perform type checks or bounds checks.  It is the\n+     * responsibility of the caller to perform such checks before calling this\n+     * method.\n+     *\n+     * @param array for which to calculate hash code\n+     * @param fromIndex start index, scaled to basicType\n+     * @param length number of elements to include in the hash\n+     * @param initialValue the initial value for the hash (typically constant 0 or 1)\n+     * @param basicType type constant denoting how to interpret the array content.\n+     *                  T_BOOLEAN is used to signify unsigned bytes, and T_CHAR might be used\n+     *                  even if array is a byte[].\n+     * @implNote currently basicType must be constant at the call site for this method\n+     *           to be intrinsified.\n+     *\n+     * @return the calculated hash value\n+     *\/\n+    @IntrinsicCandidate\n+    public static int vectorizedHashCode(Object array, int fromIndex, int length, int initialValue,\n+                                         int basicType) {\n+        return switch (basicType) {\n+            case T_BOOLEAN -> signedHashCode(initialValue, (byte[]) array, fromIndex, length);\n+            case T_CHAR -> array instanceof byte[]\n+                    ? utf16hashCode(initialValue, (byte[]) array, fromIndex, length)\n+                    : hashCode(initialValue, (char[]) array, fromIndex, length);\n+            case T_BYTE -> hashCode(initialValue, (byte[]) array, fromIndex, length);\n+            case T_SHORT -> hashCode(initialValue, (short[]) array, fromIndex, length);\n+            case T_INT -> hashCode(initialValue, (int[]) array, fromIndex, length);\n+                default -> throw new IllegalArgumentException(\"unrecognized basic type: \" + basicType);\n+        };\n+    }\n+\n+    private static int signedHashCode(int result, byte[] a, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + (a[i] & 0xff);\n+        }\n+        return result;\n+    }\n+\n+    private static int hashCode(int result, byte[] a, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + a[i];\n+        }\n+        return result;\n+    }\n+\n+    private static int hashCode(int result, char[] a, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + a[i];\n+        }\n+        return result;\n+    }\n+\n+    private static int hashCode(int result, short[] a, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + a[i];\n+        }\n+        return result;\n+    }\n+\n+    private static int hashCode(int result, int[] a, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + a[i];\n+        }\n+        return result;\n+    }\n+\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+    \/*\n+     * fromIndex and length must be scaled to char indexes.\n+     *\/\n+    public static int utf16hashCode(int result, byte[] value, int fromIndex, int length) {\n+        int end = fromIndex + length;\n+        for (int i = fromIndex; i < end; i++) {\n+            result = 31 * result + JLA.getUTF16Char(value, i);\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ArraysSupport.java","additions":102,"deletions":1,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -832,1 +832,1 @@\n-    private static int parseAsciiDigit(char c, int radix) {\n+    public static int parseAsciiDigit(char c, int radix) {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/IPAddressUtil.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import java.util.Objects;\n@@ -68,1 +69,1 @@\n-    private static final boolean exclusiveBind;\n+    private static final boolean EXCLUSIVE_BIND;\n@@ -71,1 +72,1 @@\n-    private static final boolean fastLoopback;\n+    private static final boolean FAST_LOOPBACK;\n@@ -75,4 +76,2 @@\n-    private static volatile boolean checkedIPv6;\n-    private static volatile boolean isIPv6Available;\n-    private static volatile boolean checkedReusePort;\n-    private static volatile boolean isReusePortAvailable;\n+    private static final boolean IPV6_AVAILABLE;\n+    private static final boolean SO_REUSEPORT_AVAILABLE;\n@@ -84,5 +83,1 @@\n-        if (!checkedIPv6) {\n-            isIPv6Available = isIPv6Available0();\n-            checkedIPv6 = true;\n-        }\n-        return isIPv6Available;\n+        return IPV6_AVAILABLE;\n@@ -95,5 +90,1 @@\n-        if (!checkedReusePort) {\n-            isReusePortAvailable = isReusePortAvailable0();\n-            checkedReusePort = true;\n-        }\n-        return isReusePortAvailable;\n+        return SO_REUSEPORT_AVAILABLE;\n@@ -106,1 +97,1 @@\n-        return exclusiveBind;\n+        return EXCLUSIVE_BIND;\n@@ -143,3 +134,2 @@\n-        if (sa == null)\n-            throw new NullPointerException();\n-        if (!(sa instanceof InetSocketAddress))\n+        Objects.requireNonNull(sa);\n+        if (!(sa instanceof InetSocketAddress isa))\n@@ -147,1 +137,0 @@\n-        InetSocketAddress isa = (InetSocketAddress)sa;\n@@ -152,1 +141,1 @@\n-            throw new IllegalArgumentException(\"Invalid address type\");\n+            throw new IllegalArgumentException(\"Invalid address type: \" + addr.getClass().getName());\n@@ -167,1 +156,1 @@\n-        if (!(sa instanceof InetSocketAddress))\n+        if (!(sa instanceof InetSocketAddress isa))\n@@ -169,1 +158,1 @@\n-        return (InetSocketAddress)sa;\n+        return isa;\n@@ -175,2 +164,2 @@\n-        if (x instanceof SocketException)\n-            throw (SocketException)x;\n+        if (x instanceof SocketException se)\n+            throw se;\n@@ -179,1 +168,1 @@\n-            nx = new SocketException(\"Socket is closed\");\n+            nx = newSocketException(\"Socket is closed\");\n@@ -181,1 +170,1 @@\n-            nx = new SocketException(\"Socket is not connected\");\n+            nx = newSocketException(\"Socket is not connected\");\n@@ -183,1 +172,1 @@\n-            nx = new SocketException(\"Already bound\");\n+            nx = newSocketException(\"Already bound\");\n@@ -185,1 +174,1 @@\n-            nx = new SocketException(\"Socket is not bound yet\");\n+            nx = newSocketException(\"Socket is not bound yet\");\n@@ -187,1 +176,1 @@\n-            nx = new SocketException(\"Unsupported address type\");\n+            nx = newSocketException(\"Unsupported address type\");\n@@ -189,1 +178,1 @@\n-            nx = new SocketException(\"Unresolved address\");\n+            nx = newSocketException(\"Unresolved address\");\n@@ -191,1 +180,1 @@\n-            nx = new SocketException(x.getMessage());\n+            nx = newSocketException(x.getMessage());\n@@ -196,4 +185,4 @@\n-        if (nx instanceof SocketException)\n-            throw (SocketException)nx;\n-        else if (nx instanceof RuntimeException)\n-            throw (RuntimeException)nx;\n+        if (nx instanceof SocketException se)\n+            throw se;\n+        else if (nx instanceof RuntimeException re)\n+            throw re;\n@@ -204,0 +193,4 @@\n+    private static SocketException newSocketException(String msg) {\n+        return new SocketException(msg);\n+    }\n+\n@@ -208,2 +201,2 @@\n-        if (x instanceof IOException)\n-            throw (IOException)x;\n+        if (x instanceof IOException ioe)\n+            throw ioe;\n@@ -258,4 +251,4 @@\n-    private static final InetAddress anyLocalInet4Address;\n-    private static final InetAddress anyLocalInet6Address;\n-    private static final InetAddress inet4LoopbackAddress;\n-    private static final InetAddress inet6LoopbackAddress;\n+    private static final InetAddress ANY_LOCAL_INET4ADDRESS;\n+    private static final InetAddress ANY_LOCAL_INET6ADDRESS;\n+    private static final InetAddress INET4_LOOPBACK_ADDRESS;\n+    private static final InetAddress INET6_LOOPBACK_ADDRESS;\n@@ -264,3 +257,3 @@\n-            anyLocalInet4Address = inet4FromInt(0);\n-            assert anyLocalInet4Address instanceof Inet4Address\n-                    && anyLocalInet4Address.isAnyLocalAddress();\n+            ANY_LOCAL_INET4ADDRESS = inet4FromInt(0);\n+            assert ANY_LOCAL_INET4ADDRESS instanceof Inet4Address\n+                    && ANY_LOCAL_INET4ADDRESS.isAnyLocalAddress();\n@@ -268,3 +261,3 @@\n-            anyLocalInet6Address = InetAddress.getByAddress(new byte[16]);\n-            assert anyLocalInet6Address instanceof Inet6Address\n-                    && anyLocalInet6Address.isAnyLocalAddress();\n+            ANY_LOCAL_INET6ADDRESS = InetAddress.getByAddress(new byte[16]);\n+            assert ANY_LOCAL_INET6ADDRESS instanceof Inet6Address\n+                    && ANY_LOCAL_INET6ADDRESS.isAnyLocalAddress();\n@@ -272,3 +265,3 @@\n-            inet4LoopbackAddress = inet4FromInt(0x7f000001);\n-            assert inet4LoopbackAddress instanceof Inet4Address\n-                    && inet4LoopbackAddress.isLoopbackAddress();\n+            INET4_LOOPBACK_ADDRESS = inet4FromInt(0x7f000001);\n+            assert INET4_LOOPBACK_ADDRESS instanceof Inet4Address\n+                    && INET4_LOOPBACK_ADDRESS.isLoopbackAddress();\n@@ -278,3 +271,3 @@\n-            inet6LoopbackAddress = InetAddress.getByAddress(bytes);\n-            assert inet6LoopbackAddress instanceof Inet6Address\n-                    && inet6LoopbackAddress.isLoopbackAddress();\n+            INET6_LOOPBACK_ADDRESS = InetAddress.getByAddress(bytes);\n+            assert INET6_LOOPBACK_ADDRESS instanceof Inet6Address\n+                    && INET6_LOOPBACK_ADDRESS.isLoopbackAddress();\n@@ -287,1 +280,1 @@\n-        return inet4LoopbackAddress;\n+        return INET4_LOOPBACK_ADDRESS;\n@@ -291,1 +284,1 @@\n-        return inet6LoopbackAddress;\n+        return INET6_LOOPBACK_ADDRESS;\n@@ -301,1 +294,1 @@\n-            return anyLocalInet4Address;\n+            return ANY_LOCAL_INET4ADDRESS;\n@@ -303,1 +296,1 @@\n-            return anyLocalInet6Address;\n+            return ANY_LOCAL_INET6ADDRESS;\n@@ -320,2 +313,2 @@\n-                    if (addr instanceof Inet4Address) {\n-                        return (Inet4Address)addr;\n+                    if (addr instanceof Inet4Address inet4Address) {\n+                        return inet4Address;\n@@ -341,1 +334,1 @@\n-        throw new AssertionError(\"Should not reach here\");\n+        throw shouldNotReachHere();\n@@ -357,1 +350,1 @@\n-            throw new AssertionError(\"Should not reach here\");\n+            throw shouldNotReachHere();\n@@ -382,1 +375,1 @@\n-        throw new AssertionError(\"Should not reach here\");\n+        throw shouldNotReachHere();\n@@ -387,1 +380,1 @@\n-    static final ExtendedSocketOptions extendedOptions =\n+    static final ExtendedSocketOptions EXTENDED_OPTIONS =\n@@ -407,2 +400,2 @@\n-        if (extendedOptions.isOptionSupported(name)) {\n-            extendedOptions.setOption(fd, name, value, isIPv6);\n+        if (EXTENDED_OPTIONS.isOptionSupported(name)) {\n+            EXTENDED_OPTIONS.setOption(fd, name, value, isIPv6);\n@@ -413,1 +406,1 @@\n-            throw new AssertionError(\"Should not reach here\");\n+            throw shouldNotReachHere();\n@@ -469,1 +462,1 @@\n-        if (extendedOptions.isOptionSupported(name)) {\n+        if (EXTENDED_OPTIONS.isOptionSupported(name)) {\n@@ -471,1 +464,1 @@\n-            return extendedOptions.getOption(fd, name, isIPv6);\n+            return EXTENDED_OPTIONS.getOption(fd, name, isIPv6);\n@@ -476,1 +469,1 @@\n-            throw new AssertionError(\"Should not reach here\");\n+            throw shouldNotReachHere();\n@@ -496,1 +489,1 @@\n-        return loopbackProp.isEmpty() ? true : Boolean.parseBoolean(loopbackProp);\n+        return loopbackProp.isEmpty() || Boolean.parseBoolean(loopbackProp);\n@@ -525,1 +518,1 @@\n-        return IOUtil.newFD(socket0(preferIPv6, stream, false, fastLoopback));\n+        return IOUtil.newFD(socket0(preferIPv6, stream, false, FAST_LOOPBACK));\n@@ -535,1 +528,1 @@\n-        return IOUtil.newFD(socket0(preferIPv6, stream, true, fastLoopback));\n+        return IOUtil.newFD(socket0(preferIPv6, stream, true, FAST_LOOPBACK));\n@@ -538,1 +531,1 @@\n-    \/\/ Due to oddities SO_REUSEADDR on windows reuse is ignored\n+    \/\/ Due to oddities SO_REUSEADDR on Windows reuse is ignored\n@@ -556,1 +549,1 @@\n-        bind0(fd, preferIPv6, exclusiveBind, addr, port);\n+        bind0(fd, preferIPv6, EXCLUSIVE_BIND, addr, port);\n@@ -658,1 +651,1 @@\n-     * @apiNote This method is public to allow it be used by code in jdk.sctp.\n+     * @apiNote This method is public to allow it to be used by code in jdk.sctp.\n@@ -824,4 +817,1 @@\n-                exclusiveBind = exclBindProp.isEmpty() ?\n-                        true : Boolean.parseBoolean(exclBindProp);\n-            } else if (availLevel == 1) {\n-                exclusiveBind = true;\n+                EXCLUSIVE_BIND = exclBindProp.isEmpty() || Boolean.parseBoolean(exclBindProp);\n@@ -829,1 +819,1 @@\n-                exclusiveBind = false;\n+                EXCLUSIVE_BIND = (availLevel == 1);\n@@ -832,1 +822,1 @@\n-            exclusiveBind = false;\n+            EXCLUSIVE_BIND = false;\n@@ -835,1 +825,8 @@\n-        fastLoopback = isFastTcpLoopbackRequested();\n+        FAST_LOOPBACK = isFastTcpLoopbackRequested();\n+\n+        IPV6_AVAILABLE = isIPv6Available0();\n+        SO_REUSEPORT_AVAILABLE = isReusePortAvailable0();\n+    }\n+\n+    private static AssertionError shouldNotReachHere() {\n+        return new AssertionError(\"Should not reach here\");\n@@ -837,0 +834,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Net.java","additions":83,"deletions":85,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import sun.security.util.SafeDHParameterSpec;\n@@ -58,0 +59,20 @@\n+    \/\/ convert DHParameterSpec to SafeDHParameterSpec if its parameters are\n+    \/\/ safe primes; validation takes time but should be worthwhile for the\n+    \/\/ parameter cache since the parameters may be reused many times.\n+    private static DHParameterSpec makeSafe(DHParameterSpec spec) {\n+        if (spec instanceof SafeDHParameterSpec) {\n+            return spec;\n+        }\n+\n+        BigInteger p = spec.getP();\n+        BigInteger g = spec.getG();\n+\n+        boolean isSafe = (g.equals(BigInteger.TWO) && p.testBit(0) &&\n+                p.shiftRight(1).isProbablePrime(100));\n+        if (isSafe) {\n+            return new SafeDHParameterSpec(p, g, spec.getL());\n+        } else {\n+            return spec;\n+        }\n+    }\n+\n@@ -77,1 +98,1 @@\n-        return dhCache.get(Integer.valueOf(keyLength));\n+        return dhCache.get(keyLength);\n@@ -135,1 +156,1 @@\n-        dhCache.put(Integer.valueOf(keyLength), spec);\n+        dhCache.put(keyLength, makeSafe(spec));\n@@ -396,0 +417,6 @@\n+        \/\/ Self generated following the approach from RFC 2412 Appendix E but\n+        \/\/ using random source instead of binary expansion of pi\n+        BigInteger dhP512 = new BigInteger(\n+                \"FFFFFFFFFFFFFFFF8B479B3A6E8DE86C294188F0BF2CD86C\" +\n+                \"DB950ADB36D0F61FD51E46F69C99ED95ABE5A7BBB230A6ED\" +\n+                \"1D0B4506B5317284FFFFFFFFFFFFFFFF\", 16);\n@@ -564,11 +591,13 @@\n-        \/\/ use DSA parameters for DH for sizes not defined in RFC 7296, 3526\n-        dhCache.put(Integer.valueOf(512), new DHParameterSpec(p512, g512));\n-\n-        dhCache.put(Integer.valueOf(768), new DHParameterSpec(dhP768, dhG));\n-        dhCache.put(Integer.valueOf(1024), new DHParameterSpec(dhP1024, dhG));\n-        dhCache.put(Integer.valueOf(1536), new DHParameterSpec(dhP1536, dhG));\n-        dhCache.put(Integer.valueOf(2048), new DHParameterSpec(dhP2048, dhG));\n-        dhCache.put(Integer.valueOf(3072), new DHParameterSpec(dhP3072, dhG));\n-        dhCache.put(Integer.valueOf(4096), new DHParameterSpec(dhP4096, dhG));\n-        dhCache.put(Integer.valueOf(6144), new DHParameterSpec(dhP6144, dhG));\n-        dhCache.put(Integer.valueOf(8192), new DHParameterSpec(dhP8192, dhG));\n+        \/\/ self-generated safe prime\n+        dhCache.put(512, new SafeDHParameterSpec(dhP512, dhG));\n+\n+        \/\/ from RFC 7296\n+        dhCache.put(768, new SafeDHParameterSpec(dhP768, dhG));\n+        dhCache.put(1024, new SafeDHParameterSpec(dhP1024, dhG));\n+        \/\/ from RFC 3526\n+        dhCache.put(1536, new SafeDHParameterSpec(dhP1536, dhG));\n+        dhCache.put(2048, new SafeDHParameterSpec(dhP2048, dhG));\n+        dhCache.put(3072, new SafeDHParameterSpec(dhP3072, dhG));\n+        dhCache.put(4096, new SafeDHParameterSpec(dhP4096, dhG));\n+        dhCache.put(6144, new SafeDHParameterSpec(dhP6144, dhG));\n+        dhCache.put(8192, new SafeDHParameterSpec(dhP8192, dhG));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ParameterCache.java","additions":42,"deletions":13,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1381,12 +1381,0 @@\n-            HelloCookieManager hcm =\n-                shc.sslContext.getHelloCookieManager(ProtocolVersion.DTLS10);\n-            if (!shc.isResumption &&\n-                !hcm.isCookieValid(shc, clientHello, clientHello.cookie)) {\n-                \/\/\n-                \/\/ Perform cookie exchange for DTLS handshaking if no cookie\n-                \/\/ or the cookie is invalid in the ClientHello message.\n-                \/\/\n-                \/\/ update the responders\n-                shc.handshakeProducers.put(\n-                        SSLHandshake.HELLO_VERIFY_REQUEST.id,\n-                        SSLHandshake.HELLO_VERIFY_REQUEST);\n@@ -1394,4 +1382,20 @@\n-                \/\/\n-                \/\/ produce response handshake message\n-                \/\/\n-                SSLHandshake.HELLO_VERIFY_REQUEST.produce(context, clientHello);\n+            \/\/ We will by default exchange DTLS cookies for all handshakes\n+            \/\/ (new and resumed) unless jdk.tls.enableDtlsResumeCookie=false.\n+            \/\/ The property only affects the cookie exchange for resumption.\n+            if (!shc.isResumption || SSLConfiguration.enableDtlsResumeCookie) {\n+                HelloCookieManager hcm =\n+                        shc.sslContext.getHelloCookieManager(ProtocolVersion.DTLS10);\n+                if (!hcm.isCookieValid(shc, clientHello, clientHello.cookie)) {\n+                    \/\/\n+                    \/\/ Perform cookie exchange for DTLS handshaking if no cookie\n+                    \/\/ or the cookie is invalid in the ClientHello message.\n+                    \/\/\n+                    \/\/ update the responders\n+                    shc.handshakeProducers.put(\n+                            SSLHandshake.HELLO_VERIFY_REQUEST.id,\n+                            SSLHandshake.HELLO_VERIFY_REQUEST);\n+\n+                    \/\/\n+                    \/\/ produce response handshake message\n+                    \/\/\n+                    SSLHandshake.HELLO_VERIFY_REQUEST.produce(context, clientHello);\n@@ -1399,1 +1403,2 @@\n-                return;\n+                    return;\n+                }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ClientHello.java","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import sun.security.util.SafeDHParameterSpec;\n@@ -283,1 +284,0 @@\n-                    DHParameterSpec spec = new DHParameterSpec(p, g);\n@@ -285,0 +285,1 @@\n+                    DHParameterSpec spec = new DHParameterSpec(p, g);\n@@ -296,1 +297,1 @@\n-            DHParameterSpec dhps = new DHParameterSpec(p, BigInteger.TWO);\n+            DHParameterSpec dhps = new SafeDHParameterSpec(p, BigInteger.TWO);\n@@ -304,2 +305,2 @@\n-                defaultParams.put(primeLen,\n-                    new DHParameterSpec(p, BigInteger.TWO));\n+                defaultParams.put(primeLen, new SafeDHParameterSpec(p,\n+                        BigInteger.TWO));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PredefinedDHParameterSpecs.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -119,0 +119,3 @@\n+    static final boolean enableDtlsResumeCookie = Utilities.getBooleanProperty(\n+            \"jdk.tls.enableDtlsResumeCookie\", true);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -1260,5 +1261,1 @@\n-        int result = tag;\n-        for (int i = start; i < end; i++) {\n-            result = 31 * result + buffer[i];\n-        }\n-        return result;\n+        return ArraysSupport.vectorizedHashCode(buffer, start, end - start, tag, ArraysSupport.T_BYTE);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerValue.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.math.BigInteger;\n+import javax.crypto.spec.DHParameterSpec;\n+\n+\/**\n+ * Internal marker class for well-known safe DH parameters. It should\n+ * only be used with trusted callers since it does not have all the needed\n+ * values for validation.\n+ *\/\n+\n+public final class SafeDHParameterSpec extends DHParameterSpec {\n+    public SafeDHParameterSpec(BigInteger p, BigInteger g) {\n+        super(p, g);\n+    }\n+\n+    public SafeDHParameterSpec(BigInteger p, BigInteger g, int l) {\n+        super(p, g, l);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SafeDHParameterSpec.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -36,0 +36,1 @@\n+import javax.crypto.spec.DHParameterSpec;\n@@ -105,0 +106,36 @@\n+    public static final int getDefDHPrivateExpSize(DHParameterSpec spec) {\n+\n+        int dhGroupSize = spec.getP().bitLength();\n+\n+        if (spec instanceof SafeDHParameterSpec) {\n+            \/\/ Known safe primes\n+            \/\/ use 2*security strength as default private exponent size\n+            \/\/ as in table 2 of NIST SP 800-57 part 1 rev 5, sec 5.6.1.1\n+            \/\/ and table 25 of NIST SP 800-56A rev 3, appendix D.\n+            if (dhGroupSize >= 15360) {\n+                return 512;\n+            } else if (dhGroupSize >= 8192) {\n+                return 400;\n+            } else if (dhGroupSize >= 7680) {\n+                return 384;\n+            } else if (dhGroupSize >= 6144) {\n+                return 352;\n+            } else if (dhGroupSize >= 4096) {\n+                return 304;\n+            } else if (dhGroupSize >= 3072) {\n+                return 256;\n+            } else if (dhGroupSize >= 2048) {\n+                return 224;\n+            } else {\n+                \/\/ min value for legacy key sizes\n+                return 160;\n+            }\n+        } else {\n+            \/\/ assume the worst and use groupSize\/2 as private exp length\n+            \/\/ up to 1024-bit and use the same minimum 384 as before\n+            return Math.max((dhGroupSize >= 2048 ? 1024 : dhGroupSize >> 1),\n+                    384);\n+        }\n+\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SecurityProviderConstants.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/java.base\/share\/classes\/sun\/util\/resources\/CurrencyNames_en_US.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -872,0 +872,7 @@\n+    \/\/ Check `jint` overflow\n+    if (rlen < 0) {\n+        (*env)->ReleasePrimitiveArrayCritical(env, value, str, 0);\n+        JNU_ThrowOutOfMemoryError(env, \"requested array size exceeds VM limit\");\n+        return NULL;\n+    }\n+\n","filename":"src\/java.base\/share\/native\/libjava\/jni_util.c","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-                && arrayEquals(getBytes(), ((ExternalData) o).getBytes());\n+                && Arrays.equals(getBytes(), ((ExternalData) o).getBytes());\n@@ -152,1 +152,1 @@\n-            return arrayHash(getBytes());\n+            return Arrays.hashCode(getBytes());\n@@ -181,1 +181,1 @@\n-            return arrayCompare(getBytes(), variable.getBytes());\n+            return Arrays.compare(getBytes(), variable.getBytes());\n@@ -214,1 +214,1 @@\n-            return arrayCompare(getBytes(), value.getBytes());\n+            return Arrays.compare(getBytes(), value.getBytes());\n@@ -415,27 +415,0 @@\n-    \/\/ Replace with general purpose method someday\n-    private static int arrayCompare(byte[]x, byte[] y) {\n-        int min = x.length < y.length ? x.length : y.length;\n-        for (int i = 0; i < min; i++)\n-            if (x[i] != y[i])\n-                return x[i] - y[i];\n-        return x.length - y.length;\n-    }\n-\n-    \/\/ Replace with general purpose method someday\n-    private static boolean arrayEquals(byte[] x, byte[] y) {\n-        if (x.length != y.length)\n-            return false;\n-        for (int i = 0; i < x.length; i++)\n-            if (x[i] != y[i])\n-                return false;\n-        return true;\n-    }\n-\n-    \/\/ Replace with general purpose method someday\n-    private static int arrayHash(byte[] x) {\n-        int hash = 0;\n-        for (int i = 0; i < x.length; i++)\n-            hash = 31 * hash + x[i];\n-        return hash;\n-    }\n-\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessEnvironment.java","additions":4,"deletions":31,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -748,1 +748,1 @@\n-            .filter(f -> access(f.getPath()) && f.exists())\n+            .filter(f -> access(f.getPath()))\n","filename":"src\/java.base\/windows\/classes\/java\/io\/WinNTFileSystem.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,0 @@\n-static HANDLE hStdOut = INVALID_HANDLE_VALUE;\n-static HANDLE hStdIn = INVALID_HANDLE_VALUE;\n@@ -39,6 +37,5 @@\n-    if (hStdIn == INVALID_HANDLE_VALUE &&\n-        (hStdIn = GetStdHandle(STD_INPUT_HANDLE)) == INVALID_HANDLE_VALUE) {\n-        return JNI_FALSE;\n-    }\n-    if (hStdOut == INVALID_HANDLE_VALUE &&\n-        (hStdOut = GetStdHandle(STD_OUTPUT_HANDLE)) == INVALID_HANDLE_VALUE) {\n+    HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);\n+    HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE);\n+\n+    if (hStdIn == INVALID_HANDLE_VALUE ||\n+        hStdOut == INVALID_HANDLE_VALUE) {\n@@ -47,0 +44,1 @@\n+\n@@ -48,1 +46,1 @@\n-        GetFileType(hStdOut) != FILE_TYPE_CHAR)\n+        GetFileType(hStdOut) != FILE_TYPE_CHAR) {\n@@ -50,0 +48,2 @@\n+    }\n+\n@@ -66,21 +66,0 @@\n-\n-JNIEXPORT jboolean JNICALL\n-Java_java_io_Console_echo(JNIEnv *env, jclass cls, jboolean on)\n-{\n-    DWORD fdwMode;\n-    jboolean old;\n-    if (! GetConsoleMode(hStdIn, &fdwMode)) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"GetConsoleMode failed\");\n-        return !on;\n-    }\n-    old = (fdwMode & ENABLE_ECHO_INPUT) != 0;\n-    if (on) {\n-        fdwMode |= ENABLE_ECHO_INPUT;\n-    } else {\n-        fdwMode &= ~ENABLE_ECHO_INPUT;\n-    }\n-    if (! SetConsoleMode(hStdIn, fdwMode)) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"SetConsoleMode failed\");\n-    }\n-    return old;\n-}\n","filename":"src\/java.base\/windows\/native\/libjava\/Console_md.c","additions":10,"deletions":31,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+#include \"jdk_internal_io_JdkConsoleImpl.h\"\n+\n+#include <stdlib.h>\n+#include <Wincon.h>\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_io_JdkConsoleImpl_echo(JNIEnv *env, jclass cls, jboolean on)\n+{\n+    DWORD fdwMode;\n+    jboolean old;\n+    HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE);\n+\n+    if (! GetConsoleMode(hStdIn, &fdwMode)) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"GetConsoleMode failed\");\n+        return !on;\n+    }\n+    old = (fdwMode & ENABLE_ECHO_INPUT) != 0;\n+    if (on) {\n+        fdwMode |= ENABLE_ECHO_INPUT;\n+    } else {\n+        fdwMode &= ~ENABLE_ECHO_INPUT;\n+    }\n+    if (! SetConsoleMode(hStdIn, fdwMode)) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"SetConsoleMode failed\");\n+    }\n+    return old;\n+}\n","filename":"src\/java.base\/windows\/native\/libjava\/JdkConsoleImpl_md.c","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,2 +135,2 @@\n-     * ModuleElement#getSimpleName module}, an <a\n-     * href=Name.html#empty_name>empty name<\/a> is returned.\n+     * ModuleElement#getSimpleName module}, an {@linkplain\n+     * Name##empty_name empty name} is returned.\n@@ -145,2 +145,2 @@\n-     * instance initializer}, an <a href=Name.html#empty_name>empty\n-     * name<\/a> is returned.\n+     * instance initializer}, an {@linkplain Name##empty_name empty\n+     * name} is returned.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Element.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,1 +145,1 @@\n-     * initializer, an <a href=Name.html#empty_name>empty name<\/a> is\n+     * initializer, an {@linkplain Name##empty_name empty name} is\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ExecutableElement.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,2 +71,2 @@\n-     * {@linkplain #isUnnamed() unnamed module}, an <a\n-     * href=Name.html#empty_name>empty name<\/a> is returned.\n+     * {@linkplain #isUnnamed() unnamed module}, an {@linkplain\n+     * Name##empty_name empty name} is returned.\n@@ -90,2 +90,2 @@\n-     * #isUnnamed() unnamed module}, an <a\n-     * href=Name.html#empty_name>empty name<\/a> is returned.\n+     * #isUnnamed() unnamed module}, an {@linkplain\n+     * Name##empty_name empty name} is returned.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ModuleElement.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,2 +77,2 @@\n-     * {@linkplain #isUnnamed() unnamed package}, an <a\n-     * href=Name.html#empty_name>empty name<\/a> is returned.\n+     * {@linkplain #isUnnamed() unnamed package}, an {@linkplain\n+     * Name##empty_name empty name} is returned.\n@@ -95,2 +95,2 @@\n-     * #isUnnamed() unnamed package}, an <a\n-     * href=Name.html#empty_name>empty name<\/a> is returned.\n+     * #isUnnamed() unnamed package}, an {@linkplain\n+     * Name##empty_name empty name} is returned.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/PackageElement.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,1 +151,1 @@\n-     * names, an <a href=Name.html#empty_name>empty name<\/a> is\n+     * names, an {@linkplain Name##empty_name empty name} is\n@@ -172,2 +172,2 @@\n-     * For an anonymous class, an <a href=Name.html#empty_name> empty\n-     * name<\/a> is returned.\n+     * For an anonymous class, an {@linkplain Name##empty_name empty\n+     * name} is returned.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeElement.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-     *         <a href=\"..\/..\/..\/..\/..\/java.base\/java\/lang\/module\/package-summary.html#root-modules\">root module<\/a>,\n+     *         {@linkplain java.lang.module##root-modules root module},\n@@ -147,1 +147,1 @@\n-     *         <a href=\"..\/..\/..\/..\/..\/java.base\/java\/lang\/module\/package-summary.html#root-modules\">root module<\/a>,\n+     *         {@linkplain java.lang.module##root-modules root module},\n@@ -814,3 +814,3 @@\n-     * <p>The returned file object is for the <a\n-     * href=\"..\/element\/package-summary.html#accurate_model\">reference\n-     * representation<\/a> of the information used to construct the\n+     * <p>The returned file object is for the {@linkplain\n+     * javax.lang.model.element##accurate_model reference\n+     * representation} of the information used to construct the\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -391,2 +391,2 @@\n-     * representing the specified <a href=\"JavaFileManager.html#relative_name\">relative\n-     * name<\/a> in the specified package in the given package-oriented location.\n+     * representing the specified {@linkplain JavaFileManager##relative_name relative\n+     * name} in the specified package in the given package-oriented location.\n@@ -438,2 +438,2 @@\n-     * representing the specified <a href=\"JavaFileManager.html#relative_name\">relative\n-     * name<\/a> in the specified package in the given location.\n+     * representing the specified {@linkplain JavaFileManager##relative_name relative\n+     * name} in the specified package in the given location.\n@@ -485,2 +485,2 @@\n-     * representing the specified <a href=\"JavaFileManager.html#relative_name\">relative\n-     * name<\/a> in the specified package in the given location.\n+     * representing the specified {@linkplain JavaFileManager##relative_name relative\n+     * name} in the specified package in the given location.\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/JavaFileManager.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-# MIME type strings, which will be converted into \n+# MIME type strings, which will be converted into\n@@ -57,3 +57,3 @@\n-# The COMPOUND_TEXT support for inter-client text transfer is disabled by \n-# default. The reason is that many native applications prefer this format over \n-# other native text formats, but are unable to decode the textual data in this \n+# The COMPOUND_TEXT support for inter-client text transfer is disabled by\n+# default. The reason is that many native applications prefer this format over\n+# other native text formats, but are unable to decode the textual data in this\n@@ -61,1 +61,1 @@\n-# To enable the COMPOUND_TEXT support for this JRE installation uncomment \n+# To enable the COMPOUND_TEXT support for this JRE installation uncomment\n","filename":"src\/java.datatransfer\/macosx\/classes\/sun\/datatransfer\/resources\/flavormap.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,3 +57,3 @@\n-# The COMPOUND_TEXT support for inter-client text transfer is disabled by \n-# default. The reason is that many native applications prefer this format over \n-# other native text formats, but are unable to decode the textual data in this \n+# The COMPOUND_TEXT support for inter-client text transfer is disabled by\n+# default. The reason is that many native applications prefer this format over\n+# other native text formats, but are unable to decode the textual data in this\n@@ -61,1 +61,1 @@\n-# To enable the COMPOUND_TEXT support for this JRE installation uncomment \n+# To enable the COMPOUND_TEXT support for this JRE installation uncomment\n","filename":"src\/java.datatransfer\/unix\/classes\/sun\/datatransfer\/resources\/flavormap.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -596,0 +596,5 @@\n+    @Override\n+    public JButton getDefaultButton(JFileChooser fc) {\n+        return getApproveButton(fc);\n+    }\n+\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaFileChooserUI.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import java.util.function.Function;\n@@ -70,0 +69,1 @@\n+import sun.swing.SwingAccessor;\n@@ -827,0 +827,12 @@\n+    \/\/ This method is called from the native in OutlineRowAccessibility.m\n+    private static Accessible getAccessibleCurrentAccessible(Accessible a, Component c) {\n+        if (a == null) return null;\n+        return invokeAndWait(() -> {\n+            AccessibleContext ac = a.getAccessibleContext();\n+            if (ac != null) {\n+                return SwingAccessor.getAccessibleComponentAccessor().getCurrentAccessible(ac);\n+            }\n+            return null;\n+        }, c);\n+    }\n+\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CAccessibility.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,1 +230,1 @@\n-    (*env)->ReleaseLongArrayElements(env, returnValue, saveFormats, JNI_COMMIT);\n+    (*env)->ReleaseLongArrayElements(env, returnValue, saveFormats, 0);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CClipboard.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -270,1 +270,1 @@\n-    (*env)->ReleaseLongArrayElements(env, sDraggingFormats, jformats, JNI_COMMIT);\n+    (*env)->ReleaseLongArrayElements(env, sDraggingFormats, jformats, 0);\n@@ -371,1 +371,1 @@\n-    (*env)->ReleaseByteArrayElements(env, gbyteArray, jbytes, JNI_COMMIT);\n+    (*env)->ReleaseByteArrayElements(env, gbyteArray, jbytes, 0);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CDropTarget.m","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-static NSPrintInfo* createDefaultNSPrintInfo();\n+static NSPrintInfo* createDefaultNSPrintInfo(JNIEnv* env, jstring printer);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CPrinterJob.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,3 +35,1 @@\n-static jclass sjc_CAccessible = NULL;\n-#define GET_CACCESSIBLE_CLASS_RETURN(ret) \\\n-    GET_CLASS_RETURN(sjc_CAccessible, \"sun\/lwawt\/macosx\/CAccessible\", ret);\n+static jclass sjc_CAccessibility = NULL;\n@@ -45,5 +43,3 @@\n-    jobject jAxContext = getAxContext(env, fAccessible, fComponent);\n-    if (jAxContext == NULL) return NULL;\n-    jclass axContextClass = (*env)->GetObjectClass(env, jAxContext);\n-    DECLARE_METHOD_RETURN(jm_getCurrentComponent, axContextClass, \"getCurrentComponent\", \"()Ljava\/awt\/Component;\", NULL);\n-    jobject newComponent = (*env)->CallObjectMethod(env, jAxContext, jm_getCurrentComponent);\n+    GET_CACCESSIBILITY_CLASS_RETURN(NULL);\n+    DECLARE_STATIC_METHOD_RETURN(sjm_getAccessibleCurrentAccessible, sjc_CAccessibility, \"getAccessibleCurrentAccessible\", \"(Ljavax\/accessibility\/Accessible;Ljava\/awt\/Component;)Ljavax\/accessibility\/Accessible;\", NULL);\n+    jobject currentAccessible = (*env)->CallStaticObjectMethod(env, sjc_CAccessibility, sjm_getAccessibleCurrentAccessible, fAccessible, fComponent);\n@@ -51,11 +47,1 @@\n-    (*env)->DeleteLocalRef(env, jAxContext);\n-    if (newComponent != NULL) {\n-        GET_CACCESSIBLE_CLASS_RETURN(NULL);\n-        DECLARE_STATIC_METHOD_RETURN(sjm_getCAccessible, sjc_CAccessible, \"getCAccessible\", \"(Ljavax\/accessibility\/Accessible;)Lsun\/lwawt\/macosx\/CAccessible;\", NULL);\n-        jobject currentAccessible = (*env)->CallStaticObjectMethod(env, sjc_CAccessible, sjm_getCAccessible, newComponent);\n-        CHECK_EXCEPTION();\n-        (*env)->DeleteLocalRef(env, newComponent);\n-        return currentAccessible;\n-    } else {\n-        return NULL;\n-    }\n+    return currentAccessible;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/OutlineRowAccessibility.m","additions":5,"deletions":19,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -32,2 +32,2 @@\n-# workings of Accessibility.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Accessibility as we improve \n+# workings of Accessibility.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Accessibility as we improve\n@@ -134,1 +134,1 @@\n-# \n+#\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/accessibility\/internal\/resources\/accessibility.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -32,2 +32,2 @@\n-# workings of Accessibility.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Accessibility as we improve \n+# workings of Accessibility.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Accessibility as we improve\n@@ -134,1 +134,1 @@\n-# \n+#\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/accessibility\/internal\/resources\/accessibility_de.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -32,2 +32,2 @@\n-# workings of Accessibility.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Accessibility as we improve \n+# workings of Accessibility.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Accessibility as we improve\n@@ -130,1 +130,1 @@\n-# \n+#\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/accessibility\/internal\/resources\/accessibility_en.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -32,2 +32,2 @@\n-# workings of Accessibility.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Accessibility as we improve \n+# workings of Accessibility.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Accessibility as we improve\n@@ -134,1 +134,1 @@\n-# \n+#\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/accessibility\/internal\/resources\/accessibility_es.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -32,2 +32,2 @@\n-# workings of Accessibility.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Accessibility as we improve \n+# workings of Accessibility.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Accessibility as we improve\n@@ -134,1 +134,1 @@\n-# \n+#\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/accessibility\/internal\/resources\/accessibility_fr.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -32,2 +32,2 @@\n-# workings of Accessibility.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Accessibility as we improve \n+# workings of Accessibility.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Accessibility as we improve\n@@ -134,1 +134,1 @@\n-# \n+#\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/accessibility\/internal\/resources\/accessibility_it.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -32,2 +32,2 @@\n-# workings of Accessibility.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Accessibility as we improve \n+# workings of Accessibility.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Accessibility as we improve\n@@ -134,1 +134,1 @@\n-# \n+#\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/accessibility\/internal\/resources\/accessibility_ja.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -32,2 +32,2 @@\n-# workings of Accessibility.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Accessibility as we improve \n+# workings of Accessibility.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Accessibility as we improve\n@@ -134,1 +134,1 @@\n-# \n+#\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/accessibility\/internal\/resources\/accessibility_ko.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -32,2 +32,2 @@\n-# workings of Accessibility.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Accessibility as we improve \n+# workings of Accessibility.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Accessibility as we improve\n@@ -134,1 +134,1 @@\n-# \n+#\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/accessibility\/internal\/resources\/accessibility_pt_BR.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -32,2 +32,2 @@\n-# workings of Accessibility.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Accessibility as we improve \n+# workings of Accessibility.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Accessibility as we improve\n@@ -134,1 +134,1 @@\n-# \n+#\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/accessibility\/internal\/resources\/accessibility_sv.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -32,2 +32,2 @@\n-# workings of Accessibility.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Accessibility as we improve \n+# workings of Accessibility.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Accessibility as we improve\n@@ -134,1 +134,1 @@\n-# \n+#\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/accessibility\/internal\/resources\/accessibility_zh_CN.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -32,2 +32,2 @@\n-# workings of Accessibility.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Accessibility as we improve \n+# workings of Accessibility.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Accessibility as we improve\n@@ -134,1 +134,1 @@\n-# \n+#\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/accessibility\/internal\/resources\/accessibility_zh_TW.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -610,2 +610,2 @@\n-            byte[] profile = new byte[profileSize];\n-            iis.readFully(profile, 0, profileSize);\n+            byte[] profile = ReaderUtil.\n+                    staggeredReadByteStream(iis, profileSize);\n@@ -614,6 +614,4 @@\n-            try {\n-                if (metadata.colorSpace == PROFILE_LINKED &&\n-                    isLinkedProfileAllowed() &&\n-                    !isUncOrDevicePath(profile))\n-                {\n-                    String path = new String(profile, \"windows-1252\");\n+            if (metadata.colorSpace == PROFILE_LINKED &&\n+                isLinkedProfileAllowed())\n+            {\n+                String path = new String(profile, \"windows-1252\");\n@@ -621,8 +619,5 @@\n-                    colorSpace =\n-                        new ICC_ColorSpace(ICC_Profile.getInstance(path));\n-                } else {\n-                    colorSpace =\n-                        new ICC_ColorSpace(ICC_Profile.getInstance(profile));\n-                }\n-            } catch (Exception e) {\n-                colorSpace = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+                colorSpace =\n+                    new ICC_ColorSpace(ICC_Profile.getInstance(path));\n+            } else if (metadata.colorSpace == PROFILE_EMBEDDED) {\n+                colorSpace =\n+                    new ICC_ColorSpace(ICC_Profile.getInstance(profile));\n@@ -2043,1 +2038,1 @@\n-    private static Boolean isLinkedProfileDisabled = null;\n+    private static Boolean isLinkedProfileAllowed = null;\n@@ -2047,28 +2042,1 @@\n-        if (isLinkedProfileDisabled == null) {\n-            PrivilegedAction<Boolean> a = new PrivilegedAction<Boolean>() {\n-                @Override\n-                public Boolean run() {\n-                    return Boolean.getBoolean(\"sun.imageio.plugins.bmp.disableLinkedProfiles\");\n-                }\n-            };\n-            isLinkedProfileDisabled = AccessController.doPrivileged(a);\n-        }\n-        return !isLinkedProfileDisabled;\n-    }\n-\n-    private static Boolean isWindowsPlatform = null;\n-\n-    \/**\n-     * Verifies whether the byte array contains a unc path.\n-     * Non-UNC path examples:\n-     *  c:\\path\\to\\file  - simple notation\n-     *  \\\\?\\c:\\path\\to\\file - long notation\n-     *\n-     * UNC path examples:\n-     *  \\\\server\\share - a UNC path in simple notation\n-     *  \\\\?\\UNC\\server\\share - a UNC path in long notation\n-     *  \\\\.\\some\\device - a path to device.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private static boolean isUncOrDevicePath(byte[] p) {\n-        if (isWindowsPlatform == null) {\n+        if (isLinkedProfileAllowed == null) {\n@@ -2078,3 +2046,2 @@\n-                    String osname = System.getProperty(\"os.name\");\n-                    return (osname != null &&\n-                            osname.toLowerCase().startsWith(\"win\"));\n+                    return Boolean.\n+                        getBoolean(\"sun.imageio.bmp.enableLinkedProfiles\");\n@@ -2083,26 +2050,1 @@\n-            isWindowsPlatform = AccessController.doPrivileged(a);\n-        }\n-\n-        if (!isWindowsPlatform) {\n-            \/* no need for the check on platforms except windows *\/\n-            return false;\n-        }\n-\n-        \/* normalize prefix of the path *\/\n-        if (p[0] == '\/') p[0] = '\\\\';\n-        if (p[1] == '\/') p[1] = '\\\\';\n-        if (p[3] == '\/') p[3] = '\\\\';\n-\n-\n-        if ((p[0] == '\\\\') && (p[1] == '\\\\')) {\n-            if ((p[2] == '?') && (p[3] == '\\\\')) {\n-                \/\/ long path: whether unc or local\n-                return ((p[4] == 'U' || p[4] == 'u') &&\n-                        (p[5] == 'N' || p[5] == 'n') &&\n-                        (p[6] == 'C' || p[6] == 'c'));\n-            } else {\n-                \/\/ device path or short unc notation\n-                return true;\n-            }\n-        } else {\n-            return false;\n+            isLinkedProfileAllowed = AccessController.doPrivileged(a);\n@@ -2110,0 +2052,1 @@\n+        return isLinkedProfileAllowed;\n@@ -2112,1 +2055,0 @@\n-\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/bmp\/BMPImageReader.java","additions":18,"deletions":76,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,0 @@\n-import sun.awt.AppContext;\n-import sun.awt.SunToolkit;\n-\n-import java.util.Collections;\n-import java.util.Map;\n-import java.util.WeakHashMap;\n@@ -37,0 +31,3 @@\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Stroke;\n@@ -38,0 +35,5 @@\n+import java.awt.geom.AffineTransform;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+\n@@ -41,0 +43,5 @@\n+import sun.awt.AppContext;\n+import sun.awt.SunToolkit;\n+\n+import static sun.java2d.pipe.Region.clipRound;\n+\n@@ -138,0 +145,110 @@\n+\n+    \/**\n+     * A task which paints an <i>unscaled<\/i> border after {@code Graphics}\n+     * transforms are removed. It's used with the\n+     * {@link #paintBorder(Component, Graphics, int, int, int, int, UnscaledBorderPainter)\n+     * SwingUtilities3.paintBorder} which manages changing the transforms and calculating\n+     * the coordinates and size of the border.\n+     *\/\n+    @FunctionalInterface\n+    public interface UnscaledBorderPainter {\n+        \/**\n+         * Paints the border for the specified component after the\n+         * {@code Graphics} transforms are removed.\n+         *\n+         * <p>\n+         * The <i>x<\/i> and <i>y<\/i> of the painted border are zero.\n+         *\n+         * @param c the component for which this border is being painted\n+         * @param g the paint graphics\n+         * @param w the width of the painted border, in physical pixels\n+         * @param h the height of the painted border, in physical pixels\n+         * @param scaleFactor the scale that was in the {@code Graphics}\n+         *\n+         * @see #paintBorder(Component, Graphics, int, int, int, int, UnscaledBorderPainter)\n+         * SwingUtilities3.paintBorder\n+         * @see javax.swing.border.Border#paintBorder(Component, Graphics, int, int, int, int)\n+         * Border.paintBorder\n+         *\/\n+        void paintUnscaledBorder(Component c, Graphics g,\n+                                 int w, int h,\n+                                 double scaleFactor);\n+    }\n+\n+    \/**\n+     * Paints the border for a component ensuring its sides have consistent\n+     * thickness at different scales.\n+     * <p>\n+     * It performs the following steps:\n+     * <ol>\n+     *     <li>Reset the scale transform on the {@code Graphics},<\/li>\n+     *     <li>Call {@code painter} to paint the border,<\/li>\n+     *     <li>Restores the transform.<\/li>\n+     * <\/ol>\n+     *\n+     * @param c the component for which this border is being painted\n+     * @param g the paint graphics\n+     * @param x the x position of the painted border\n+     * @param y the y position of the painted border\n+     * @param w the width of the painted border\n+     * @param h the height of the painted border\n+     * @param painter the painter object which paints the border after\n+     *                the transform on the {@code Graphics} is reset\n+     *\/\n+    public static void paintBorder(Component c, Graphics g,\n+                                   int x, int y,\n+                                   int w, int h,\n+                                   UnscaledBorderPainter painter) {\n+\n+        \/\/ Step 1: Reset Transform\n+        AffineTransform at = null;\n+        Stroke oldStroke = null;\n+        boolean resetTransform = false;\n+        double scaleFactor = 1;\n+\n+        int xtranslation = x;\n+        int ytranslation = y;\n+        int width = w;\n+        int height = h;\n+\n+        if (g instanceof Graphics2D) {\n+            Graphics2D g2d = (Graphics2D) g;\n+            at = g2d.getTransform();\n+            oldStroke = g2d.getStroke();\n+            scaleFactor = Math.min(at.getScaleX(), at.getScaleY());\n+\n+            \/\/ if m01 or m10 is non-zero, then there is a rotation or shear,\n+            \/\/ or if scale=1, skip resetting the transform in these cases.\n+            resetTransform = ((at.getShearX() == 0) && (at.getShearY() == 0))\n+                    && ((at.getScaleX() > 1) || (at.getScaleY() > 1));\n+\n+            if (resetTransform) {\n+                \/* Deactivate the HiDPI scaling transform,\n+                 * so we can do paint operations in the device\n+                 * pixel coordinate system instead of the logical coordinate system.\n+                 *\/\n+                g2d.setTransform(new AffineTransform());\n+                double xx = at.getScaleX() * x + at.getTranslateX();\n+                double yy = at.getScaleY() * y + at.getTranslateY();\n+                xtranslation = clipRound(xx);\n+                ytranslation = clipRound(yy);\n+                width = clipRound(at.getScaleX() * w + xx) - xtranslation;\n+                height = clipRound(at.getScaleY() * h + yy) - ytranslation;\n+            }\n+        }\n+\n+        g.translate(xtranslation, ytranslation);\n+\n+        \/\/ Step 2: Call respective paintBorder with transformed values\n+        painter.paintUnscaledBorder(c, g, width, height, scaleFactor);\n+\n+        \/\/ Step 3: Restore previous stroke & transform\n+        g.translate(-xtranslation, -ytranslation);\n+        if (g instanceof Graphics2D) {\n+            Graphics2D g2d = (Graphics2D) g;\n+            g2d.setStroke(oldStroke);\n+            if (resetTransform) {\n+                g2d.setTransform(at);\n+            }\n+        }\n+    }\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/SwingUtilities3.java","additions":124,"deletions":7,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/resources\/motif.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/resources\/motif_de.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/resources\/motif_es.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/resources\/motif_fr.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/resources\/motif_it.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/resources\/motif_ja.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/resources\/motif_ko.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/resources\/motif_pt_BR.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/resources\/motif_sv.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/resources\/motif_zh_CN.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/resources\/motif_zh_TW.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,7 @@\n+    \/*\n+     * Name of the system property that enables the Jar soundbank loading\n+     * true if jar sound bank is allowed to be loaded\n+     * default is false\n+     *\/\n+    private final static String JAR_SOUNDBANK_ENABLED = \"jdk.sound.jarsoundbank\";\n+\n@@ -73,1 +80,2 @@\n-        if (!isZIP(url))\n+        Objects.requireNonNull(url);\n+        if (!Boolean.getBoolean(JAR_SOUNDBANK_ENABLED) || !isZIP(url))\n@@ -75,0 +83,1 @@\n+\n@@ -119,0 +128,1 @@\n+        Objects.requireNonNull(file);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/JARSoundbankReader.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,2 +94,2 @@\n-     * <a href=\"{@docRoot}\/java.desktop\/java\/awt\/Shape.html#def_insideness\">\n-     * definition of insideness<\/a> can lead to situations where points\n+     * {@linkplain Shape##def_insideness\n+     * definition of insideness} can lead to situations where points\n@@ -140,2 +140,2 @@\n-     * <a href=\"{@docRoot}\/java.desktop\/java\/awt\/Shape.html#def_insideness\">\n-     * definition of insideness<\/a> can lead to situations where points\n+     * {@linkplain Shape##def_insideness\n+     * definition of insideness} can lead to situations where points\n@@ -174,2 +174,1 @@\n-     * <a href=\"{@docRoot}\/java.desktop\/java\/awt\/Shape.html#def_insideness\">\n-     * definition of insideness<\/a>.\n+     * {@linkplain Shape##def_insideness definition of insideness}.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Shape.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -347,4 +347,4 @@\n-     * occupy in the system tray.  Developers may use this methods to\n-     * acquire the preferred size for the image property of a tray icon\n-     * before it is created.  For convenience, there is a similar\n-     * method {@link TrayIcon#getSize} in the {@code TrayIcon} class.\n+     * occupy in the system tray. Developers may use this method to\n+     * acquire the preferred size for the tray icon before it is created.\n+     * For convenience, there is a similar method {@link TrayIcon#getSize}\n+     * in the {@code TrayIcon} class.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/SystemTray.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,1 +224,0 @@\n-    private static ColorModel RGBdefault;\n@@ -243,7 +242,5 @@\n-        if (RGBdefault == null) {\n-            RGBdefault = new DirectColorModel(32,\n-                                              0x00ff0000,       \/\/ Red\n-                                              0x0000ff00,       \/\/ Green\n-                                              0x000000ff,       \/\/ Blue\n-                                              0xff000000        \/\/ Alpha\n-                                              );\n+        interface RGBdefault {\n+            ColorModel INSTANCE = new DirectColorModel(32, 0x00ff0000,  \/\/ Red\n+                                                           0x0000ff00,  \/\/ Green\n+                                                           0x000000ff,  \/\/ Blue\n+                                                           0xff000000); \/\/ Alpha\n@@ -251,1 +248,1 @@\n-        return RGBdefault;\n+        return RGBdefault.INSTANCE;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/ColorModel.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+import sun.swing.SwingAccessor;\n@@ -4743,0 +4744,20 @@\n+            static {\n+                SwingAccessor.setAccessibleComponentAccessor(new AccessibleJTreeNodeAccessor());\n+            }\n+\n+            private static class AccessibleJTreeNodeAccessor implements SwingAccessor.AccessibleComponentAccessor {\n+\n+                private AccessibleJTreeNodeAccessor() {}\n+\n+                @Override\n+                public Accessible getCurrentAccessible(AccessibleContext ac) {\n+                    if (ac instanceof AccessibleJTreeNode) {\n+                        Component c = ((AccessibleJTreeNode) ac).getCurrentComponent();\n+                        if (c instanceof Accessible) {\n+                            return (Accessible)c;\n+                        }\n+                    }\n+                    return null;\n+                }\n+            }\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTree.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,0 @@\n-import java.awt.Stroke;\n-import java.awt.geom.AffineTransform;\n@@ -37,0 +35,2 @@\n+import com.sun.java.swing.SwingUtilities3;\n+\n@@ -153,19 +153,5 @@\n-        \/\/ We remove any initial transforms to prevent rounding errors\n-        \/\/ when drawing in non-integer scales\n-        AffineTransform at = null;\n-        Stroke oldStk = null;\n-        int stkWidth = 1;\n-        boolean resetTransform = false;\n-        if (g instanceof Graphics2D) {\n-            Graphics2D g2d = (Graphics2D) g;\n-            at = g2d.getTransform();\n-            oldStk = g2d.getStroke();\n-            \/\/ if m01 or m10 is non-zero, then there is a rotation or shear\n-            \/\/ skip resetting the transform\n-            resetTransform = (at.getShearX() == 0) && (at.getShearY() == 0);\n-            if (resetTransform) {\n-                g2d.setTransform(new AffineTransform());\n-                stkWidth = (int) Math.floor(Math.min(at.getScaleX(), at.getScaleY()));\n-                g2d.setStroke(new BasicStroke((float) stkWidth));\n-            }\n-        }\n+        SwingUtilities3.paintBorder(c, g,\n+                                    x, y,\n+                                    width, height,\n+                                    this::paintUnscaledBorder);\n+    }\n@@ -173,14 +159,6 @@\n-        int w;\n-        int h;\n-        int xtranslation;\n-        int ytranslation;\n-        if (resetTransform) {\n-            w = (int) Math.floor(at.getScaleX() * width - 1);\n-            h = (int) Math.floor(at.getScaleY() * height - 1);\n-            xtranslation = (int) Math.ceil(at.getScaleX()*x+at.getTranslateX());\n-            ytranslation = (int) Math.ceil(at.getScaleY()*y+at.getTranslateY());\n-        } else {\n-            w = width;\n-            h = height;\n-            xtranslation = x;\n-            ytranslation = y;\n+    private void paintUnscaledBorder(Component c, Graphics g,\n+                                     int w, int h,\n+                                     double scaleFactor) {\n+        int stkWidth = (int) Math.floor(scaleFactor);\n+        if (g instanceof Graphics2D) {\n+            ((Graphics2D) g).setStroke(new BasicStroke((float) stkWidth));\n@@ -189,2 +167,0 @@\n-        g.translate(xtranslation, ytranslation);\n-\n@@ -197,9 +173,0 @@\n-\n-        g.translate(-xtranslation, -ytranslation);\n-\n-        \/\/ Set the transform we removed earlier\n-        if (resetTransform) {\n-            Graphics2D g2d = (Graphics2D) g;\n-            g2d.setTransform(at);\n-            g2d.setStroke(oldStk);\n-        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/border\/EtchedBorder.java","additions":14,"deletions":47,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import java.awt.geom.AffineTransform;\n@@ -39,1 +38,1 @@\n-import static sun.java2d.pipe.Region.clipRound;\n+import com.sun.java.swing.SwingUtilities3;\n@@ -147,0 +146,9 @@\n+        SwingUtilities3.paintBorder(c, g,\n+                                    x, y,\n+                                    width, height,\n+                                    this::paintUnscaledBorder);\n+    }\n+\n+    private void paintUnscaledBorder(Component c, Graphics g,\n+                                     int w, int h,\n+                                     double scaleFactor) {\n@@ -150,37 +158,0 @@\n-            AffineTransform at = g2d.getTransform();\n-\n-            \/\/ if m01 or m10 is non-zero, then there is a rotation or shear\n-            \/\/ or if no Scaling enabled,\n-            \/\/ skip resetting the transform\n-            boolean resetTransform = ((at.getShearX() == 0) && (at.getShearY() == 0)) &&\n-                    ((at.getScaleX() > 1) || (at.getScaleY() > 1));\n-\n-            int xtranslation;\n-            int ytranslation;\n-            int w;\n-            int h;\n-            int offs;\n-\n-            if (resetTransform) {\n-                \/* Deactivate the HiDPI scaling transform,\n-                 * so we can do paint operations in the device\n-                 * pixel coordinate system instead of the logical coordinate system.\n-                 *\/\n-                g2d.setTransform(new AffineTransform());\n-                double xx = at.getScaleX() * x + at.getTranslateX();\n-                double yy = at.getScaleY() * y + at.getTranslateY();\n-                xtranslation = clipRound(xx);\n-                ytranslation = clipRound(yy);\n-                w = clipRound(at.getScaleX() * width + xx) - xtranslation;\n-                h = clipRound(at.getScaleY() * height + yy) - ytranslation;\n-                offs = this.thickness * (int) at.getScaleX();\n-            } else {\n-                w = width;\n-                h = height;\n-                xtranslation = x;\n-                ytranslation = y;\n-                offs = this.thickness;\n-            }\n-\n-            g2d.translate(xtranslation, ytranslation);\n-\n@@ -193,0 +164,1 @@\n+            int offs = this.thickness * (int) scaleFactor;\n@@ -198,2 +170,1 @@\n-            }\n-            else {\n+            } else {\n@@ -203,0 +174,1 @@\n+\n@@ -207,1 +179,0 @@\n-            g2d.setColor(oldColor);\n@@ -209,5 +180,1 @@\n-            g2d.translate(-xtranslation, -ytranslation);\n-\n-            if (resetTransform) {\n-                g2d.setTransform(at);\n-            }\n+            g2d.setColor(oldColor);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/border\/LineBorder.java","additions":15,"deletions":48,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import java.awt.Font;\n+import java.awt.AWTEvent;\n@@ -30,3 +30,0 @@\n-import java.awt.SystemColor;\n-import java.awt.event.*;\n-import java.awt.Insets;\n@@ -34,7 +31,0 @@\n-import java.awt.Container;\n-import java.awt.FocusTraversalPolicy;\n-import java.awt.AWTEvent;\n-import java.awt.Toolkit;\n-import java.awt.Point;\n-import java.net.URL;\n-import java.io.*;\n@@ -42,1 +32,16 @@\n-import java.awt.KeyboardFocusManager;\n+import java.awt.Font;\n+import java.awt.Point;\n+import java.awt.SystemColor;\n+import java.awt.Toolkit;\n+import java.awt.Window;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.MouseEvent;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyVetoException;\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n@@ -45,11 +50,9 @@\n-import java.util.*;\n-import java.lang.reflect.*;\n-import javax.sound.sampled.*;\n-\n-import sun.awt.AppContext;\n-import sun.awt.SunToolkit;\n-import sun.swing.SwingAccessor;\n-import sun.swing.SwingUtilities2;\n-import sun.swing.icon.SortArrowIcon;\n-\n-import javax.swing.LookAndFeel;\n+import java.util.HashSet;\n+import java.util.Locale;\n+\n+import javax.sound.sampled.AudioInputStream;\n+import javax.sound.sampled.AudioSystem;\n+import javax.sound.sampled.Clip;\n+import javax.sound.sampled.DataLine;\n+import javax.sound.sampled.LineEvent;\n+import javax.sound.sampled.LineListener;\n@@ -59,1 +62,1 @@\n-import javax.swing.BorderFactory;\n+import javax.swing.DefaultListCellRenderer;\n@@ -61,4 +64,2 @@\n-import javax.swing.ImageIcon;\n-import javax.swing.UIDefaults;\n-import javax.swing.UIManager;\n-import javax.swing.KeyStroke;\n+import javax.swing.JInternalFrame;\n+import javax.swing.JPopupMenu;\n@@ -66,5 +67,1 @@\n-import javax.swing.DefaultListCellRenderer;\n-import javax.swing.FocusManager;\n-import javax.swing.LayoutFocusTraversalPolicy;\n-import javax.swing.SwingUtilities;\n-import javax.swing.MenuSelectionManager;\n+import javax.swing.LookAndFeel;\n@@ -72,3 +69,12 @@\n-import javax.swing.border.*;\n-import javax.swing.plaf.*;\n-import javax.swing.text.JTextComponent;\n+import javax.swing.MenuSelectionManager;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.border.BevelBorder;\n+import javax.swing.plaf.ActionMapUIResource;\n+import javax.swing.plaf.BorderUIResource;\n+import javax.swing.plaf.ColorUIResource;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.DimensionUIResource;\n+import javax.swing.plaf.FontUIResource;\n+import javax.swing.plaf.InsetsUIResource;\n@@ -76,1 +82,7 @@\n-import javax.swing.JInternalFrame;\n+\n+import sun.awt.AppContext;\n+import sun.awt.SunToolkit;\n+import sun.swing.SwingAccessor;\n+import sun.swing.SwingUtilities2;\n+import sun.swing.icon.SortArrowIcon;\n+\n@@ -78,4 +90,0 @@\n-import java.beans.PropertyVetoException;\n-import java.awt.Window;\n-import java.beans.PropertyChangeListener;\n-import java.beans.PropertyChangeEvent;\n@@ -2224,1 +2232,2 @@\n-                        if(src.getComponentPopupMenu() != null) {\n+                        JPopupMenu componentPopupMenu = src.getComponentPopupMenu();\n+                        if(componentPopupMenu != null) {\n@@ -2231,1 +2240,1 @@\n-                            src.getComponentPopupMenu().show(src, pt.x, pt.y);\n+                            componentPopupMenu.show(src, pt.x, pt.y);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicLookAndFeel.java","additions":53,"deletions":44,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.awt.Stroke;\n@@ -38,1 +37,0 @@\n-import java.awt.geom.AffineTransform;\n@@ -65,0 +63,1 @@\n+import com.sun.java.swing.SwingUtilities3;\n@@ -253,0 +252,8 @@\n+            SwingUtilities3.paintBorder(c, g,\n+                                        x, y, w, h,\n+                                        this::paintUnscaledBorder);\n+        }\n+\n+        private void paintUnscaledBorder(Component c, Graphics g,\n+                                         int width, int height,\n+                                         double scaleFactor) {\n@@ -267,42 +274,0 @@\n-            AffineTransform at = null;\n-            Stroke oldStk = null;\n-            boolean resetTransform = false;\n-            int stkWidth = 1;\n-            double scaleFactor = 1;\n-\n-            if (g instanceof Graphics2D g2d) {\n-                at = g2d.getTransform();\n-                scaleFactor = at.getScaleX();\n-                oldStk = g2d.getStroke();\n-\n-                \/\/ if m01 or m10 is non-zero, then there is a rotation or shear\n-                \/\/ skip resetting the transform\n-                resetTransform = ((at.getShearX() == 0) && (at.getShearY() == 0));\n-\n-                if (resetTransform) {\n-                    g2d.setTransform(new AffineTransform());\n-                    stkWidth = clipRound(Math.min(at.getScaleX(), at.getScaleY()));\n-                    g2d.setStroke(new BasicStroke((float) stkWidth));\n-                }\n-            }\n-\n-            int xtranslation;\n-            int ytranslation;\n-            int width;\n-            int height;\n-\n-            if (resetTransform) {\n-                double xx = at.getScaleX() * x + at.getTranslateX();\n-                double yy = at.getScaleY() * y + at.getTranslateY();\n-                xtranslation = clipRound(xx);\n-                ytranslation = clipRound(yy);\n-                width = clipRound(at.getScaleX() * w + xx) - xtranslation;\n-                height = clipRound(at.getScaleY() * h + yy) - ytranslation;\n-            } else {\n-                xtranslation = x;\n-                ytranslation = y;\n-                width = w;\n-                height = h;\n-            }\n-            g.translate(xtranslation, ytranslation);\n-\n@@ -322,0 +287,1 @@\n+                int stkWidth = clipRound(scaleFactor);\n@@ -328,0 +294,4 @@\n+                if (g instanceof Graphics2D) {\n+                    ((Graphics2D) g).setStroke(new BasicStroke((float) stkWidth));\n+                }\n+\n@@ -346,8 +316,0 @@\n-\n-            \/\/ restore previous transform\n-            g.translate(-xtranslation, -ytranslation);\n-            if (resetTransform) {\n-                Graphics2D g2d = (Graphics2D) g;\n-                g2d.setTransform(at);\n-                g2d.setStroke(oldStk);\n-            }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalBorders.java","additions":15,"deletions":53,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -938,1 +938,1 @@\n-             *  Constructs an AccessiblJTableHeaaderEntry\n+             * Constructs an AccessibleJTableHeaderEntry\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/table\/JTableHeader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-            Class<?> c = Class.forName(classname, true,Thread.currentThread().\n+            Class<?> c = Class.forName(classname, false,Thread.currentThread().\n@@ -96,5 +96,7 @@\n-            Object o = c.newInstance();\n-            if (o instanceof Component) {\n-                Component comp = (Component) o;\n-                setParameters(comp, attr);\n-                return comp;\n+            if (Component.class.isAssignableFrom(c)) {\n+                Object o = c.newInstance();\n+                if (o instanceof Component) {\n+                    Component comp = (Component) o;\n+                    setParameters(comp, attr);\n+                    return comp;\n+                }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/ObjectView.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -337,1 +337,2 @@\n-            l.pixelType = CHANNELS_SH(br.getNumBands()) | BYTES_SH(1);\n+            int numBands = br.getNumBands();\n+            l.pixelType = CHANNELS_SH(numBands) | BYTES_SH(1);\n@@ -346,1 +347,1 @@\n-                    firstBand  = csm.getNumBands() - 1;\n+                    firstBand  = numBands - 1;\n@@ -360,1 +361,0 @@\n-            l.dataArray = br.getDataStorage();\n@@ -362,0 +362,3 @@\n+            byte[] data = br.getDataStorage();\n+            l.dataArray = data;\n+            l.dataArrayLength = data.length;\n@@ -365,0 +368,1 @@\n+            l.verify();\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSImageLayout.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1472,1 +1472,0 @@\n-        float[] firstCoord = new float[2];\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/loops\/ProcessPath.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-# (in some cases the space character is replaced by '-' and the pound \n+# (in some cases the space character is replaced by '-' and the pound\n@@ -203,1 +203,1 @@\n-# The following keys match the Strings returned by \n+# The following keys match the Strings returned by\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/resources\/serviceui.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-# (in some cases the space character is replaced by '-' and the pound \n+# (in some cases the space character is replaced by '-' and the pound\n@@ -203,1 +203,1 @@\n-# The following keys match the Strings returned by \n+# The following keys match the Strings returned by\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/resources\/serviceui_de.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-# (in some cases the space character is replaced by '-' and the pound \n+# (in some cases the space character is replaced by '-' and the pound\n@@ -203,1 +203,1 @@\n-# The following keys match the Strings returned by \n+# The following keys match the Strings returned by\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/resources\/serviceui_es.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-# (in some cases the space character is replaced by '-' and the pound \n+# (in some cases the space character is replaced by '-' and the pound\n@@ -203,1 +203,1 @@\n-# The following keys match the Strings returned by \n+# The following keys match the Strings returned by\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/resources\/serviceui_fr.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-# (in some cases the space character is replaced by '-' and the pound \n+# (in some cases the space character is replaced by '-' and the pound\n@@ -203,1 +203,1 @@\n-# The following keys match the Strings returned by \n+# The following keys match the Strings returned by\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/resources\/serviceui_it.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-# (in some cases the space character is replaced by '-' and the pound \n+# (in some cases the space character is replaced by '-' and the pound\n@@ -203,1 +203,1 @@\n-# The following keys match the Strings returned by \n+# The following keys match the Strings returned by\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/resources\/serviceui_ja.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-# (in some cases the space character is replaced by '-' and the pound \n+# (in some cases the space character is replaced by '-' and the pound\n@@ -203,1 +203,1 @@\n-# The following keys match the Strings returned by \n+# The following keys match the Strings returned by\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/resources\/serviceui_ko.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-# (in some cases the space character is replaced by '-' and the pound \n+# (in some cases the space character is replaced by '-' and the pound\n@@ -203,1 +203,1 @@\n-# The following keys match the Strings returned by \n+# The following keys match the Strings returned by\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/resources\/serviceui_pt_BR.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-# (in some cases the space character is replaced by '-' and the pound \n+# (in some cases the space character is replaced by '-' and the pound\n@@ -203,1 +203,1 @@\n-# The following keys match the Strings returned by \n+# The following keys match the Strings returned by\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/resources\/serviceui_sv.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-# (in some cases the space character is replaced by '-' and the pound \n+# (in some cases the space character is replaced by '-' and the pound\n@@ -203,1 +203,1 @@\n-# The following keys match the Strings returned by \n+# The following keys match the Strings returned by\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/resources\/serviceui_zh_CN.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-# (in some cases the space character is replaced by '-' and the pound \n+# (in some cases the space character is replaced by '-' and the pound\n@@ -203,1 +203,1 @@\n-# The following keys match the Strings returned by \n+# The following keys match the Strings returned by\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/resources\/serviceui_zh_TW.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-import java.awt.*;\n+import java.awt.Component;\n+import java.awt.Point;\n@@ -30,1 +31,2 @@\n-import javax.swing.*;\n+import javax.accessibility.Accessible;\n+import javax.accessibility.AccessibleContext;\n@@ -32,0 +34,1 @@\n+import javax.swing.*;\n@@ -50,0 +53,8 @@\n+    \/**\n+     * This interface provides access to the renderer's accessibility component.\n+     * For example, the renderer of a list element, a table cell, or a tree node\n+     *\/\n+    public interface AccessibleComponentAccessor {\n+        Accessible getCurrentAccessible(AccessibleContext ac);\n+    }\n+\n@@ -293,0 +304,15 @@\n+    private static AccessibleComponentAccessor accessibleComponentAccessor = null;\n+\n+    public static AccessibleComponentAccessor getAccessibleComponentAccessor() {\n+        var access = accessibleComponentAccessor;\n+        if (access == null) {\n+            ensureClassInitialized(JTree.class);\n+            access = accessibleComponentAccessor;\n+        }\n+        return access;\n+    }\n+\n+    public static void setAccessibleComponentAccessor(final AccessibleComponentAccessor accessibleAccessor) {\n+        accessibleComponentAccessor = accessibleAccessor;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/SwingAccessor.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-#if defined(__GNUC__) && __GNUC__ < 5\n+#if defined(__GNUC__) && __GNUC__ < 5 && !defined(__clang__)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-meta.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/resources\/windows.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/resources\/windows_de.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/resources\/windows_es.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/resources\/windows_fr.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/resources\/windows_it.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/resources\/windows_ja.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/resources\/windows_ko.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/resources\/windows_pt_BR.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/resources\/windows_sv.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/resources\/windows_zh_CN.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-# When this file is read in, the strings are put into the \n+# When this file is read in, the strings are put into the\n@@ -34,2 +34,2 @@\n-# workings of Swing.  DO NOT DEPEND ON THIS.  \n-# This may change in future versions of Swing as we improve localization \n+# workings of Swing.  DO NOT DEPEND ON THIS.\n+# This may change in future versions of Swing as we improve localization\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/resources\/windows_zh_TW.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1133,0 +1133,8 @@\n+    \/**\n+     * The data is not available yet.\n+     * @see\n+     * <a href=\"https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/com\/com-error-codes-1\">COM\n+     * Error Codes<\/a>.\n+     *\/\n+    private static final long E_PENDING = 0x8000000AL;\n+\n@@ -1158,1 +1166,1 @@\n-                    if (hIcon <= 0) {\n+                    if (hIcon == E_PENDING || hIcon == 0) {\n@@ -1161,1 +1169,1 @@\n-                        if (hIcon <= 0) {\n+                        if (hIcon == 0) {\n@@ -1398,0 +1406,2 @@\n+            assert !resolutionVariants.containsValue(null)\n+                   : \"There are null icons in the MRI variants map\";\n@@ -1403,0 +1413,1 @@\n+            assert image != null : \"Null icon passed as the base image for MRI\";\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/shell\/Win32ShellFolder2.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# \n+#\n","filename":"src\/java.desktop\/windows\/data\/fontconfig\/fontconfig.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -977,1 +977,1 @@\n-    HICON hIcon = NULL;\n+    HICON hIcon;\n@@ -998,3 +998,7 @@\n-            if (size < 24) {\n-                fn_DestroyIcon((HICON)hIcon);\n-                hIcon = hIconSmall;\n+            if (SUCCEEDED(hres)) {\n+                if (size < 24) {\n+                    fn_DestroyIcon((HICON)hIcon);\n+                    hIcon = hIconSmall;\n+                } else {\n+                    fn_DestroyIcon((HICON)hIconSmall);\n+                }\n@@ -1002,1 +1006,1 @@\n-                fn_DestroyIcon((HICON)hIconSmall);\n+                hIcon = NULL;\n@@ -1006,1 +1010,3 @@\n-            return E_PENDING;\n+            return (unsigned) E_PENDING;\n+        } else {\n+            hIcon = NULL;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/ShellFolder2.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include <strsafe.h>\n@@ -290,1 +291,0 @@\n-\n@@ -466,1 +466,1 @@\n-    wcscpy(tmpname, name);\n+    StringCchCopy(tmpname, 80, name);\n@@ -474,1 +474,1 @@\n-    wcscpy(&(logFont.lfFaceName[0]), tmpname);\n+    StringCchCopy(&(logFont.lfFaceName[0]), LF_FACESIZE, tmpname);\n@@ -505,1 +505,1 @@\n-    wsprintf(longName, L\"%ls-%d-%d\", name, style, height);\n+    StringCchPrintf(longName, 80, L\"%ls-%d-%d\", name, style, height);\n@@ -1753,1 +1753,1 @@\n-    strcpy(szSubKey, \"EUDC\\\\\");\n+    StringCchCopyA(szSubKey, KEYLEN, \"EUDC\\\\\");\n@@ -1757,2 +1757,2 @@\n-    strcpy(&(szSubKey[strlen(szSubKey)]), lpszCP);\n-    strcpy(m_szCodePageSubkey, szSubKey);\n+    StringCchCatA(szSubKey, KEYLEN, lpszCP);\n+    StringCchCopyA(m_szCodePageSubkey, KEYLEN, szSubKey);\n@@ -1783,1 +1783,1 @@\n-    wcscpy(szFamilyName, GetFontName());\n+    StringCchCopy(szFamilyName, 80, GetFontName());\n@@ -1802,1 +1802,1 @@\n-            wcscpy(lpszFileName, m_szDefaultEUDCFile);\n+            StringCchCopy(lpszFileName, cchFileName, m_szDefaultEUDCFile);\n@@ -1828,1 +1828,1 @@\n-        wcscpy(m_szDefaultEUDCFile, lpszFileName);\n+        StringCchCopy(m_szDefaultEUDCFile, _MAX_PATH, lpszFileName);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Font.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include <strsafe.h>\n@@ -2411,1 +2412,1 @@\n-        wcscpy(lf.lfFaceName, fontNameW);\n+        StringCchCopyW(lf.lfFaceName, LF_FACESIZE, fontNameW);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintJob.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1116,1 +1116,1 @@\n-    CATCH_BAD_ALLOC(NULL);\n+    CATCH_BAD_ALLOC;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_TrayIcon.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include <windef.h>\n@@ -47,5 +48,3 @@\n- *   BOOL SetProcessDPIAware(VOID);\n- * which is only present on Windows Vista, and which instructs the\n- * Vista Windows Display Manager that this application is High DPI Aware\n- * and does not need to be scaled by the WDM and lied about the\n- * actual system dpi.\n+ *   BOOL SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT);\n+ * to set Process DPI Awareness to DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2\n+ * to match what we have in the manifest file.\n@@ -56,1 +55,1 @@\n-    typedef BOOL (WINAPI SetProcessDPIAwareFunc)(void);\n+    typedef BOOL (WINAPI SetProcessDpiAwarenessContextFunc)(DPI_AWARENESS_CONTEXT);\n@@ -69,5 +68,6 @@\n-        SetProcessDPIAwareFunc *lpSetProcessDPIAware =\n-            (SetProcessDPIAwareFunc*)GetProcAddress(hLibUser32Dll,\n-                                                    \"SetProcessDPIAware\");\n-        if (lpSetProcessDPIAware != NULL) {\n-            lpSetProcessDPIAware();\n+        SetProcessDpiAwarenessContextFunc *lpSetProcessDpiAwarenessContext =\n+                    (SetProcessDpiAwarenessContextFunc*)GetProcAddress(hLibUser32Dll,\n+                                                            \"SetProcessDpiAwarenessContext\");\n+\n+        if (lpSetProcessDpiAwarenessContext != NULL) {\n+            lpSetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);\n@@ -75,0 +75,1 @@\n+\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Win32GraphicsEnv.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include <strsafe.h>\n@@ -66,1 +67,1 @@\n-         strcat(sysdir, \"\\\\Fonts\");\n+        StringCchCatA(sysdir, BSIZE, \"\\\\Fonts\");\n@@ -73,1 +74,1 @@\n-        strcat(windir, \"\\\\Fonts\");\n+        StringCchCatA(windir, BSIZE, \"\\\\Fonts\");\n@@ -76,1 +77,1 @@\n-    strcpy(fontpath,sysdir);\n+    StringCchCopyA(fontpath, BSIZE*2, sysdir);\n@@ -78,2 +79,2 @@\n-        strcat(fontpath,\";\");\n-        strcat(fontpath,windir);\n+        StringCchCatA(fontpath, BSIZE*2, \";\");\n+        StringCchCatA(fontpath, BSIZE*2, windir);\n@@ -155,1 +156,1 @@\n-    wcscpy(lfw.lfFaceName, fullName);\n+    StringCchCopyW(lfw.lfFaceName, LF_FACESIZE, fullName);\n@@ -352,1 +353,1 @@\n-    wcscpy(lfw.lfFaceName, lpelfe->elfLogFont.lfFaceName);\n+    StringCchCopyW(lfw.lfFaceName, LF_FACESIZE, lpelfe->elfLogFont.lfFaceName);\n@@ -656,1 +657,1 @@\n-    wcscpy(lfw.lfFaceName, L\"\");      \/* one face per family (CHECK) *\/\n+    StringCchCopyW(lfw.lfFaceName, LF_FACESIZE, L\"\");      \/* one face per family (CHECK) *\/\n","filename":"src\/java.desktop\/windows\/native\/libfontmanager\/fontpath.c","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include <strsafe.h>\n@@ -239,1 +240,1 @@\n-        wcscpy(lf.lfFaceName, name);\n+        StringCchCopyW(lf.lfFaceName, LF_FACESIZE, name);\n","filename":"src\/java.desktop\/windows\/native\/libfontmanager\/lcdglyph.c","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,6 +34,5 @@\n- * <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#platform-threads\">\n- * platform threads<\/a> in the Java virtual machine. Platform threads are\n- * typically mapped to kernel threads scheduled by the operating system.\n- * {@code ThreadMXBean} does not support monitoring or management of\n- * <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">\n- * virtual threads<\/a>.\n+ * {@linkplain Thread##platform-threads platform threads} in the Java\n+ * virtual machine. Platform threads are typically mapped to kernel\n+ * threads scheduled by the operating system.  {@code ThreadMXBean}\n+ * does not support monitoring or management of {@linkplain\n+ * Thread##virtual-threads virtual threads}.\n","filename":"src\/java.management\/share\/classes\/java\/lang\/management\/ThreadMXBean.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,2 +139,2 @@\n- * example, it may support <a\n- * href=\"{@docRoot}\/java.base\/java\/util\/ServiceLoader.html#developing-service-providers\">service providers<\/a>,\n+ * example, it may support {@linkplain\n+ * ServiceLoader##developing-service-providers service providers},\n","filename":"src\/java.management\/share\/classes\/javax\/management\/remote\/JMXConnectorFactory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,2 +129,2 @@\n- * example, it may support <a\n- * href=\"{@docRoot}\/java.base\/java\/util\/ServiceLoader.html#developing-service-providers\">service providers<\/a>,\n+ * example, it may support {@linkplain\n+ * java.util.ServiceLoader##developing-service-providers service providers},\n","filename":"src\/java.management\/share\/classes\/javax\/management\/remote\/JMXConnectorServerFactory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n-# RemoteToCorbaToAttrs: Turn RMI\/IIOP object into corbaObject LDAP entry. \n+# RemoteToCorbaToAttrs: Turn RMI\/IIOP object into corbaObject LDAP entry.\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/jndiprovider.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,3 +125,1 @@\n- * <a href=\"{@docRoot}\/java.base\/java\/lang\/reflect\/Proxy.html#membership\">\n- * {@code Proxy}\n- * <\/a>\n+ * {@link java.lang.reflect.Proxy##membership Proxy}\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/UnicastRemoteObject.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * <a href=\"{@docRoot}\/java.sql\/javax\/sql\/RowSet.html\">RowSet<\/a> interface described in the JDBC 3.0\n+ * {@link java.sql\/javax.sql.RowSet} interface described in the JDBC 3.0\n@@ -89,1 +89,1 @@\n- * (an extension of the <a href=\"{@docRoot}\/java.sql\/javax\/sql\/RowSetReader.html\">{@code RowSetReader}<\/a>\n+ * (an extension of the {@link java.sql\/javax.sql.RowSetReader RowSetReader}\n@@ -92,1 +92,1 @@\n- * <a href=\"{@docRoot}\/java.sql\/javax\/sql\/RowSetWriter.html\">{@code RowSetWriter}<\/a> interface)\n+ * {@link java.sql\/javax.sql.RowSetWriter RowSetWriter} interface)\n@@ -109,1 +109,1 @@\n- * an implementation of the <a href=\"Predicate.html\">{@code Predicate}<\/a>\n+ * an implementation of the {@link Predicate}\n@@ -149,1 +149,1 @@\n- * <a href=\"BaseRowSet.html\">{@code BaseRowSet}<\/a> abstract class. For example, a\n+ * {@link BaseRowSet} abstract class. For example, a\n@@ -236,1 +236,1 @@\n- * <a href=\"{@docRoot}\/java.sql\/javax\/sql\/RowSetMetaData.html\">RowSetMetaData<\/a> interface, supplying standard setter\n+ * {@link java.sql\/javax.sql.RowSetMetaData RowSetMetaData} interface, supplying standard setter\n@@ -245,1 +245,1 @@\n- * Similar to <a href=\"{@docRoot}\/java.sql\/java\/sql\/SQLWarning.html\">SQLWarning<\/a> objects,\n+ * Similar to {@link java.sql\/java.sql.SQLWarning SQLWarning} objects,\n","filename":"src\/java.sql.rowset\/share\/classes\/javax\/sql\/rowset\/package-info.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/DOMMessages.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/DOMMessages_de.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/DOMMessages_es.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/DOMMessages_fr.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/DOMMessages_it.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/DOMMessages_ja.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/DOMMessages_ko.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/DOMMessages_pt_BR.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/DOMMessages_sv.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/DOMMessages_zh_CN.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/DOMMessages_zh_TW.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-        \n+\n@@ -61,1 +61,1 @@\n-        \n+\n@@ -85,1 +85,1 @@\n-        \n+\n@@ -144,1 +144,1 @@\n-        \n+\n@@ -232,1 +232,1 @@\n-        \n+\n@@ -295,1 +295,1 @@\n-        \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-        \n+\n@@ -61,1 +61,1 @@\n-        \n+\n@@ -85,1 +85,1 @@\n-        \n+\n@@ -144,1 +144,1 @@\n-        \n+\n@@ -232,1 +232,1 @@\n-        \n+\n@@ -295,1 +295,1 @@\n-        \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages_de.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-        \n+\n@@ -44,1 +44,1 @@\n-        \n+\n@@ -68,1 +68,1 @@\n-        \n+\n@@ -127,1 +127,1 @@\n-        \n+\n@@ -215,1 +215,1 @@\n-        \n+\n@@ -278,1 +278,1 @@\n-        \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages_es.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-        \n+\n@@ -44,1 +44,1 @@\n-        \n+\n@@ -68,1 +68,1 @@\n-        \n+\n@@ -127,1 +127,1 @@\n-        \n+\n@@ -215,1 +215,1 @@\n-        \n+\n@@ -278,1 +278,1 @@\n-        \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages_fr.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-        \n+\n@@ -44,1 +44,1 @@\n-        \n+\n@@ -68,1 +68,1 @@\n-        \n+\n@@ -127,1 +127,1 @@\n-        \n+\n@@ -215,1 +215,1 @@\n-        \n+\n@@ -278,1 +278,1 @@\n-        \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages_it.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-        \n+\n@@ -61,1 +61,1 @@\n-        \n+\n@@ -85,1 +85,1 @@\n-        \n+\n@@ -144,1 +144,1 @@\n-        \n+\n@@ -232,1 +232,1 @@\n-        \n+\n@@ -295,1 +295,1 @@\n-        \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages_ja.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-        \n+\n@@ -44,1 +44,1 @@\n-        \n+\n@@ -68,1 +68,1 @@\n-        \n+\n@@ -127,1 +127,1 @@\n-        \n+\n@@ -215,1 +215,1 @@\n-        \n+\n@@ -278,1 +278,1 @@\n-        \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages_ko.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-        \n+\n@@ -44,1 +44,1 @@\n-        \n+\n@@ -68,1 +68,1 @@\n-        \n+\n@@ -127,1 +127,1 @@\n-        \n+\n@@ -215,1 +215,1 @@\n-        \n+\n@@ -278,1 +278,1 @@\n-        \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages_pt_BR.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-        \n+\n@@ -44,1 +44,1 @@\n-        \n+\n@@ -68,1 +68,1 @@\n-        \n+\n@@ -127,1 +127,1 @@\n-        \n+\n@@ -215,1 +215,1 @@\n-        \n+\n@@ -278,1 +278,1 @@\n-        \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages_sv.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-        \n+\n@@ -61,1 +61,1 @@\n-        \n+\n@@ -85,1 +85,1 @@\n-        \n+\n@@ -144,1 +144,1 @@\n-        \n+\n@@ -232,1 +232,1 @@\n-        \n+\n@@ -295,1 +295,1 @@\n-        \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages_zh_CN.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-        \n+\n@@ -44,1 +44,1 @@\n-        \n+\n@@ -68,1 +68,1 @@\n-        \n+\n@@ -127,1 +127,1 @@\n-        \n+\n@@ -215,1 +215,1 @@\n-        \n+\n@@ -278,1 +278,1 @@\n-        \n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages_zh_TW.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -19,1 +19,1 @@\n-# serializer.  Many DOM Load\/Save error messages also \n+# serializer.  Many DOM Load\/Save error messages also\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLSerializerMessages.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -19,1 +19,1 @@\n-# serializer.  Many DOM Load\/Save error messages also \n+# serializer.  Many DOM Load\/Save error messages also\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLSerializerMessages_de.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-# serializer.  Many DOM Load\/Save error messages also \n+# serializer.  Many DOM Load\/Save error messages also\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLSerializerMessages_es.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-# serializer.  Many DOM Load\/Save error messages also \n+# serializer.  Many DOM Load\/Save error messages also\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLSerializerMessages_fr.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-# serializer.  Many DOM Load\/Save error messages also \n+# serializer.  Many DOM Load\/Save error messages also\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLSerializerMessages_it.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -19,1 +19,1 @@\n-# serializer.  Many DOM Load\/Save error messages also \n+# serializer.  Many DOM Load\/Save error messages also\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLSerializerMessages_ja.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-# serializer.  Many DOM Load\/Save error messages also \n+# serializer.  Many DOM Load\/Save error messages also\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLSerializerMessages_ko.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-# serializer.  Many DOM Load\/Save error messages also \n+# serializer.  Many DOM Load\/Save error messages also\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLSerializerMessages_pt_BR.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-# serializer.  Many DOM Load\/Save error messages also \n+# serializer.  Many DOM Load\/Save error messages also\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLSerializerMessages_sv.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -19,1 +19,1 @@\n-# serializer.  Many DOM Load\/Save error messages also \n+# serializer.  Many DOM Load\/Save error messages also\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLSerializerMessages_zh_CN.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-# serializer.  Many DOM Load\/Save error messages also \n+# serializer.  Many DOM Load\/Save error messages also\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLSerializerMessages_zh_TW.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -593,8 +593,4 @@\n-                if (c.caseKind == CaseTree.CaseKind.STATEMENT) {\n-                    previousCompletesNormally = c.completesNormally;\n-                } else {\n-                    previousCompletesNormally = false;\n-                    JCBreak brk = make.at(TreeInfo.endPos(c.stats.last())).Break(null);\n-                    brk.target = tree;\n-                    c.stats = c.stats.append(brk);\n-                }\n+                previousCompletesNormally =\n+                        c.caseKind == CaseTree.CaseKind.STATEMENT &&\n+                        c.completesNormally;\n+                appendBreakIfNeeded(tree, c);\n@@ -645,0 +641,8 @@\n+    private void appendBreakIfNeeded(JCTree switchTree, JCCase c) {\n+        if (c.caseKind == CaseTree.CaseKind.RULE) {\n+            JCBreak brk = make.at(TreeInfo.endPos(c.stats.last())).Break(null);\n+            brk.target = switchTree;\n+            c.stats = c.stats.append(brk);\n+        }\n+    }\n+\n@@ -743,0 +747,1 @@\n+                        appendBreakIfNeeded(currentSwitch, accummulated);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,1 +239,1 @@\n-header extends java\/lang\/Object implements java\/lang\/foreign\/Linker$Option nestHost java\/lang\/foreign\/Linker sealed true flags 601\n+header extends java\/lang\/Object implements java\/lang\/foreign\/Linker$Option nestHost java\/lang\/foreign\/Linker sealed true flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;FOREIGN;)\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.base-K.sym.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,3 +213,1 @@\n-        if (message == null) {\n-            return false;\n-        }\n+        ensureMessageInit();\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/EdDSASignature.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -603,1 +603,1 @@\n-  env->ReleaseLongArrayElements(array, regs, JNI_COMMIT);\n+  env->ReleaseLongArrayElements(array, regs, 0);\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/LinuxDebuggerLocal.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -624,1 +624,1 @@\n-  (*env)->ReleaseLongArrayElements(env, array, regs, JNI_COMMIT);\n+  (*env)->ReleaseLongArrayElements(env, array, regs, 0);\n","filename":"src\/jdk.hotspot.agent\/macosx\/native\/libsaproc\/MacosxDebuggerLocal.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+  private static final Cleaner CLEANER = Cleaner.create();\n@@ -44,0 +45,4 @@\n+  private static Runnable cleanerFor(long context) {\n+    return () -> DwarfParser.destroyDwarfContext(context);\n+  }\n+\n@@ -51,2 +56,1 @@\n-    Cleaner.create()\n-           .register(this, () -> DwarfParser.destroyDwarfContext(p_dwarf_context));\n+    CLEANER.register(this, cleanerFor(p_dwarf_context));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/amd64\/DwarfParser.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -628,1 +628,1 @@\n-    env->ReleaseLongArrayElements(regs, ptrRegs, JNI_COMMIT);\n+    env->ReleaseLongArrayElements(regs, ptrRegs, 0);\n","filename":"src\/jdk.hotspot.agent\/windows\/native\/libsaproc\/sawindbg.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,8 +79,9 @@\n- * <pre>\n- * JarSigner signer = new JarSigner.Builder(key, certPath)\n- *         .digestAlgorithm(\"SHA-1\")\n- *         .signatureAlgorithm(\"SHA1withDSA\")\n- *         .build();\n- * try (ZipFile in = new ZipFile(inputFile);\n- *         FileOutputStream out = new FileOutputStream(outputFile)) {\n- *     signer.sign(in, out);\n+ * {@snippet lang=\"java\" :\n+ *     JarSigner signer = new JarSigner.Builder(key, certPath)\n+ *             .digestAlgorithm(\"SHA-256\")\n+ *             .signatureAlgorithm(\"SHA256withRSA\")\n+ *             .build();\n+ *     try (ZipFile  in = new ZipFile(inputFile);\n+ *             FileOutputStream out = new FileOutputStream(outputFile)) {\n+ *         signer.sign(in, out);\n+ *     }\n@@ -88,1 +89,0 @@\n- * <\/pre>\n","filename":"src\/jdk.jartool\/share\/classes\/jdk\/security\/jarsigner\/JarSigner.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1448,18 +1448,1 @@\n-    synchronized void removeObjectMirror(ObjectReferenceImpl object) {\n-        \/\/ Handle any queue elements that are not strongly reachable\n-        processQueue();\n-\n-        SoftObjectReference ref = objectsByID.remove(object.ref());\n-        if (ref != null) {\n-            batchForDispose(ref);\n-        } else {\n-            \/*\n-             * If there's a live ObjectReference about, it better be part\n-             * of the cache.\n-             *\/\n-            throw new InternalException(\"ObjectReference \" + object.ref() +\n-                                        \" not found in object cache\");\n-        }\n-    }\n-\n-    synchronized void removeObjectMirror(SoftObjectReference ref) {\n+    private synchronized void removeObjectMirror(SoftObjectReference ref) {\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/VirtualMachineImpl.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CalendarData_el_CY.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CalendarData_en_MT.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CalendarData_es_US.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CalendarData_id_ID.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CalendarData_ms_MY.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CalendarData_mt.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CalendarData_mt_MT.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CalendarData_sr.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CalendarData_tr.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CalendarData_uk.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CalendarData_vi.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CalendarData_zh.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ar_AE.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ar_BH.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ar_DZ.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ar_EG.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ar_IQ.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ar_JO.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ar_KW.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ar_LB.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ar_LY.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ar_MA.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ar_OM.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ar_QA.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ar_SA.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ar_SD.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ar_SY.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ar_TN.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ar_YE.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_be_BY.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_bg_BG.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ca_ES.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_cs_CZ.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_da_DK.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_de_AT.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_de_CH.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_de_DE.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_de_LU.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_el_CY.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_el_GR.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_en_AU.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_en_CA.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_en_GB.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_en_IE.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_en_IN.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_en_MT.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_en_NZ.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_en_PH.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_en_SG.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_en_ZA.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_AR.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_BO.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_CL.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_CO.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_CR.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_DO.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_EC.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_ES.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_GT.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_HN.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_MX.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_NI.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_PA.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_PR.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_PY.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_SV.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_US.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_UY.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_es_VE.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_fi_FI.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_fr_BE.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_fr_CA.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_fr_CH.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_fr_FR.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_fr_LU.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ga_IE.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_he_IL.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_hi_IN.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_hr_HR.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_hu_HU.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_id_ID.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_is_IS.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_it_CH.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_it_IT.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ja_JP.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ko_KR.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_lt_LT.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_lv_LV.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_mk_MK.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ms_MY.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_mt_MT.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_nl_BE.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_nl_NL.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_no_NO.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_pl_PL.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_pt_BR.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_pt_PT.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ro_RO.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_ru_RU.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_sl_SI.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_sq_AL.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_sr_BA.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_sr_CS.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_sr_ME.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_sv_SE.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_th_TH.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_tr_TR.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_uk_UA.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -24,1 +24,1 @@\n-# \n+#\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/CurrencyNames_vi_VN.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/LocaleNames_el.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/LocaleNames_el_CY.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/LocaleNames_en_MT.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/LocaleNames_en_PH.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/LocaleNames_en_SG.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/LocaleNames_es_US.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/LocaleNames_ga.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/LocaleNames_id.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/LocaleNames_ms.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/LocaleNames_mt.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/LocaleNames_pt.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/LocaleNames_pt_BR.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/LocaleNames_pt_PT.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/LocaleNames_sr.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-# language names                                                 \n+# language names\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/LocaleNames_th.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- \n+\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/LocaleNames_zh_SG.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1775,0 +1775,4 @@\n+                        [\"fcvt\",     \"__ sve_fcvt(z5, __ S, p3, z4, __ H);\",               \"fcvt\\tz5.s, p3\/m, z4.h\"],\n+                        [\"fcvt\",     \"__ sve_fcvt(z1, __ H, p3, z0, __ S);\",               \"fcvt\\tz1.h, p3\/m, z0.s\"],\n+                        [\"fcvt\",     \"__ sve_fcvt(z5, __ D, p3, z4, __ H);\",               \"fcvt\\tz5.d, p3\/m, z4.h\"],\n+                        [\"fcvt\",     \"__ sve_fcvt(z1, __ H, p3, z0, __ D);\",               \"fcvt\\tz1.h, p3\/m, z0.d\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -918,0 +918,4 @@\n+    __ sve_fcvt(z5, __ S, p3, z4, __ H);               \/\/       fcvt    z5.s, p3\/m, z4.h\n+    __ sve_fcvt(z1, __ H, p3, z0, __ S);               \/\/       fcvt    z1.h, p3\/m, z0.s\n+    __ sve_fcvt(z5, __ D, p3, z4, __ H);               \/\/       fcvt    z5.d, p3\/m, z4.h\n+    __ sve_fcvt(z1, __ H, p3, z0, __ D);               \/\/       fcvt    z1.h, p3\/m, z0.d\n@@ -1248,7 +1252,7 @@\n-    0x14000000,     0x17ffffd7,     0x14000405,     0x94000000,\n-    0x97ffffd4,     0x94000402,     0x3400000a,     0x34fffa2a,\n-    0x34007fea,     0x35000008,     0x35fff9c8,     0x35007f88,\n-    0xb400000b,     0xb4fff96b,     0xb4007f2b,     0xb500001d,\n-    0xb5fff91d,     0xb5007edd,     0x10000013,     0x10fff8b3,\n-    0x10007e73,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36307df6,     0x3758000c,     0x375ff7cc,     0x37587d8c,\n+    0x14000000,     0x17ffffd7,     0x14000409,     0x94000000,\n+    0x97ffffd4,     0x94000406,     0x3400000a,     0x34fffa2a,\n+    0x3400806a,     0x35000008,     0x35fff9c8,     0x35008008,\n+    0xb400000b,     0xb4fff96b,     0xb4007fab,     0xb500001d,\n+    0xb5fff91d,     0xb5007f5d,     0x10000013,     0x10fff8b3,\n+    0x10007ef3,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36307e76,     0x3758000c,     0x375ff7cc,     0x37587e0c,\n@@ -1259,13 +1263,13 @@\n-    0x54007b60,     0x54000001,     0x54fff541,     0x54007b01,\n-    0x54000002,     0x54fff4e2,     0x54007aa2,     0x54000002,\n-    0x54fff482,     0x54007a42,     0x54000003,     0x54fff423,\n-    0x540079e3,     0x54000003,     0x54fff3c3,     0x54007983,\n-    0x54000004,     0x54fff364,     0x54007924,     0x54000005,\n-    0x54fff305,     0x540078c5,     0x54000006,     0x54fff2a6,\n-    0x54007866,     0x54000007,     0x54fff247,     0x54007807,\n-    0x54000008,     0x54fff1e8,     0x540077a8,     0x54000009,\n-    0x54fff189,     0x54007749,     0x5400000a,     0x54fff12a,\n-    0x540076ea,     0x5400000b,     0x54fff0cb,     0x5400768b,\n-    0x5400000c,     0x54fff06c,     0x5400762c,     0x5400000d,\n-    0x54fff00d,     0x540075cd,     0x5400000e,     0x54ffefae,\n-    0x5400756e,     0x5400000f,     0x54ffef4f,     0x5400750f,\n+    0x54007be0,     0x54000001,     0x54fff541,     0x54007b81,\n+    0x54000002,     0x54fff4e2,     0x54007b22,     0x54000002,\n+    0x54fff482,     0x54007ac2,     0x54000003,     0x54fff423,\n+    0x54007a63,     0x54000003,     0x54fff3c3,     0x54007a03,\n+    0x54000004,     0x54fff364,     0x540079a4,     0x54000005,\n+    0x54fff305,     0x54007945,     0x54000006,     0x54fff2a6,\n+    0x540078e6,     0x54000007,     0x54fff247,     0x54007887,\n+    0x54000008,     0x54fff1e8,     0x54007828,     0x54000009,\n+    0x54fff189,     0x540077c9,     0x5400000a,     0x54fff12a,\n+    0x5400776a,     0x5400000b,     0x54fff0cb,     0x5400770b,\n+    0x5400000c,     0x54fff06c,     0x540076ac,     0x5400000d,\n+    0x54fff00d,     0x5400764d,     0x5400000e,     0x54ffefae,\n+    0x540075ee,     0x5400000f,     0x54ffef4f,     0x5400758f,\n@@ -1437,1 +1441,2 @@\n-    0x65caac01,     0x65dea833,     0x659ca509,     0x65d8a801,\n+    0x65caac01,     0x6589ac85,     0x6588ac01,     0x65c9ac85,\n+    0x65c8ac01,     0x65dea833,     0x659ca509,     0x65d8a801,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":26,"deletions":21,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"metaprogramming\/conditional.hpp\"\n@@ -573,3 +572,1 @@\n-  typedef typename Conditional<is_const,\n-                               const OopStorage,\n-                               OopStorage>::type Storage;\n+  using Storage = std::conditional_t<is_const, const OopStorage, OopStorage>;\n@@ -798,3 +795,1 @@\n-  typedef typename Conditional<is_const,\n-                               const OopStorage,\n-                               OopStorage>::type Storage;\n+  using Storage = std::conditional_t<is_const, const OopStorage, OopStorage>;\n@@ -895,3 +890,1 @@\n-  typedef typename Conditional<is_const,\n-                               const OopStorage,\n-                               OopStorage>::type Storage;\n+  using Storage = std::conditional_t<is_const, const OopStorage, OopStorage>;\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_oopStorage.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"metaprogramming\/conditional.hpp\"\n-#include \"metaprogramming\/isSame.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-class ConditionalTest {\n-  class A: AllStatic {};\n-  class B: AllStatic {};\n-\n-  typedef Conditional<true, A, B>::type A_B_if_true;\n-  static const bool A_B_if_true_is_A = IsSame<A_B_if_true, A>::value;\n-  static const bool A_B_if_true_is_B = IsSame<A_B_if_true, B>::value;\n-  STATIC_ASSERT(A_B_if_true_is_A);\n-  STATIC_ASSERT(!A_B_if_true_is_B);\n-\n-  typedef Conditional<false, A, B>::type A_B_if_false;\n-  static const bool A_B_if_false_is_A = IsSame<A_B_if_false, A>::value;\n-  static const bool A_B_if_false_is_B = IsSame<A_B_if_false, B>::value;\n-  STATIC_ASSERT(!A_B_if_false_is_A);\n-  STATIC_ASSERT(A_B_if_false_is_B);\n-};\n","filename":"test\/hotspot\/gtest\/metaprogramming\/test_conditional.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"metaprogramming\/isPointer.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-class IsPointerTest: AllStatic {\n-  class A: AllStatic {};\n-\n-  static const bool ip_voidptr = IsPointer<void*>::value;\n-  STATIC_ASSERT(ip_voidptr);\n-\n-  static const bool ip_Aptr = IsPointer<A*>::value;\n-  STATIC_ASSERT(ip_Aptr);\n-\n-  static const bool ip_cAptr = IsPointer<const A*>::value;\n-  STATIC_ASSERT(ip_cAptr);\n-\n-  static const bool ip_vAptr = IsPointer<volatile A*>::value;\n-  STATIC_ASSERT(ip_vAptr);\n-\n-  static const bool ip_Avptr = IsPointer<A* volatile>::value;\n-  STATIC_ASSERT(ip_Avptr);\n-\n-  static const bool ip_intptrt = IsPointer<intptr_t>::value;\n-  STATIC_ASSERT(!ip_intptrt);\n-\n-  static const bool ip_char = IsPointer<char>::value;\n-  STATIC_ASSERT(!ip_char);\n-};\n","filename":"test\/hotspot\/gtest\/metaprogramming\/test_isPointer.cpp","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"metaprogramming\/removeReference.hpp\"\n-#include \"metaprogramming\/isSame.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-class RemoveReferenceTest {\n-  class A: AllStatic {};\n-\n-  typedef const volatile A cvA;\n-  typedef const volatile A& cvAref;\n-  typedef const volatile A* const volatile cvAptrcv;\n-\n-  typedef RemoveReference<cvAref>::type rr_cvAref;\n-  static const bool rr_cvAref_is_cvAref = IsSame<rr_cvAref, cvA>::value;\n-  STATIC_ASSERT(rr_cvAref_is_cvAref);\n-\n-  typedef RemoveReference<cvAptrcv>::type rr_cvAptrcv;\n-  static const bool rr_cvAptrcv_is_cvAptrcv = IsSame<rr_cvAptrcv, cvAptrcv>::value;\n-  STATIC_ASSERT(rr_cvAptrcv_is_cvAptrcv);\n-};\n","filename":"test\/hotspot\/gtest\/metaprogramming\/test_removeReference.cpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -216,30 +216,56 @@\n-  uintptr_t val1 = 1;\n-  uintptr_t val2 = 2;\n-  uintptr_t val3 = 3;\n-  SimpleTestLookup stl1(val1), stl2(val2), stl3(val3);\n-\n-  SimpleTestTable* cht = new SimpleTestTable();\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val1, false, true);\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val2, false, true);\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val3, false, true);\n-\n-  EXPECT_TRUE(cht->remove(thr, stl2)) << \"Remove did not find value.\";\n-\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val1, true, false); \/\/ val1 should be present\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val2, false, true); \/\/ val2 should be inserted\n-  cht_getinsert_bulkdelete_insert_verified(thr, cht, val3, true, false); \/\/ val3 should be present\n-\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl1), val1) << \"Get did not find value.\";\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl2), val2) << \"Get did not find value.\";\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl3), val3) << \"Get did not find value.\";\n-\n-  \/\/ Removes all odd values.\n-  cht->bulk_delete(thr, getinsert_bulkdelete_eval, getinsert_bulkdelete_del);\n-\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl1), (uintptr_t)0) << \"Odd value should not exist.\";\n-  EXPECT_FALSE(cht->remove(thr, stl1)) << \"Odd value should not exist.\";\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl2), val2) << \"Even value should not have been removed.\";\n-  EXPECT_EQ(cht_get_copy(cht, thr, stl3), (uintptr_t)0) << \"Add value should not exists.\";\n-  EXPECT_FALSE(cht->remove(thr, stl3)) << \"Odd value should not exists.\";\n-\n-  delete cht;\n+  SimpleTestTable a[] = {SimpleTestTable(), SimpleTestTable(2, 2, 14) \/* force long lists in the buckets*\/ };\n+  const unsigned iter = 1000;\n+  for (auto& table: a) {\n+    for (unsigned i = 0; i < iter; ++i) {\n+      uintptr_t val1 = i * 10 + 1;\n+      uintptr_t val2 = i * 10 + 2;\n+      uintptr_t val3 = i * 10 + 3;\n+      SimpleTestLookup stl1(val1), stl2(val2), stl3(val3);\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val1, false, true);\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val2, false, true);\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val3, false, true);\n+\n+      EXPECT_TRUE(table.remove(thr, stl2)) << \"Remove did not find value.\";\n+\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val1, true, false); \/\/ val1 should be present\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val2, false, true); \/\/ val2 should be inserted\n+      cht_getinsert_bulkdelete_insert_verified(thr, &table, val3, true, false); \/\/ val3 should be present\n+\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl1), val1) << \"Get did not find value.\";\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl2), val2) << \"Get did not find value.\";\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl3), val3) << \"Get did not find value.\";\n+    }\n+\n+    unsigned delete_count = 0;\n+    unsigned scan_count = 0;\n+    auto eval_odd_f = [](uintptr_t* val)                  { return *val & 0x1; };\n+    auto eval_true_f = [](uintptr_t* val)                 { return true; };\n+    auto scan_count_f = [&scan_count](uintptr_t* val)     { scan_count++; return true; };\n+    auto delete_count_f = [&delete_count](uintptr_t* val) { delete_count++; };\n+    table.bulk_delete(thr, eval_odd_f, delete_count_f);\n+    EXPECT_EQ(iter*2, delete_count) << \"All odd values should have been deleted\";\n+    table.do_scan(thr, scan_count_f);\n+    EXPECT_EQ(iter, scan_count) << \"All odd values should have been deleted\";\n+\n+    for (unsigned i = 0; i < iter; ++i) {\n+      uintptr_t val1 = i * 10 + 1;\n+      uintptr_t val2 = i * 10 + 2;\n+      uintptr_t val3 = i * 10 + 3;\n+      SimpleTestLookup stl1(val1), stl2(val2), stl3(val3);\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl1), (uintptr_t)0) << \"Odd value should not exist.\";\n+      EXPECT_FALSE(table.remove(thr, stl1)) << \"Odd value should not exist.\";\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl2), val2) << \"Even value should not have been removed.\";\n+      EXPECT_EQ(cht_get_copy(&table, thr, stl3), (uintptr_t)0) << \"Add value should not exists.\";\n+      EXPECT_FALSE(table.remove(thr, stl3)) << \"Odd value should not exists.\";\n+    }\n+\n+    scan_count = 0;\n+    table.do_scan(thr, scan_count_f);\n+    EXPECT_EQ(iter, scan_count) << \"All values should have been deleted\";\n+    delete_count = 0;\n+    table.bulk_delete(thr, eval_true_f, delete_count_f);\n+    EXPECT_EQ(iter, delete_count) << \"All odd values should have been deleted\";\n+    scan_count = 0;\n+    table.do_scan(thr, scan_count_f);\n+    EXPECT_EQ(0u, scan_count) << \"All values should have been deleted\";\n+  }\n","filename":"test\/hotspot\/gtest\/utilities\/test_concurrentHashtable.cpp","additions":56,"deletions":30,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java 8205957 linux-x64,windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain008\/chain008.java 8298596 linux-x64\n+vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain007\/chain007.java 8298991 linux-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +199,1 @@\n-        testStrideNegScalePosInIntLoop1(0, 100, 200, 0);\n+        testStrideNegScalePosInIntLoop2(0, 100, 200, 0);\n@@ -246,1 +247,1 @@\n-        testStridePosScaleNegInIntLoop1(0, 100, 200, 198);\n+        testStridePosScaleNegInIntLoop2(0, 100, 200, 198);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestLongRangeChecks.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +68,2 @@\n-        TestFramework.runWithFlags(\"-XX:CompileCommand=exclude,*.urshift\");\n+        TestFramework framework = new TestFramework(TestVectorizeURShiftSubword.class);\n+        framework.setDefaultWarmup(1).addFlags(\"-XX:CompileCommand=exclude,*.urshift\").start();\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizeURShiftSubword.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2022, BELLSOFT. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8153837\n+* @summary Test integer min and max intrinsics\n+* @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+* @library \/test\/lib \/\n+* @modules java.base\/jdk.internal.misc\n+*\n+* @build jdk.test.whitebox.WhiteBox\n+* @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+*\n+* @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+*                   -server -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+*                   compiler.intrinsics.math.TestMinMaxIntrinsics\n+*\/\n+\n+package compiler.intrinsics.math;\n+\n+import java.lang.reflect.Method;\n+import java.util.function.IntUnaryOperator;\n+import java.util.function.IntBinaryOperator;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import static jdk.test.lib.Asserts.assertEQ;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n+\n+public class TestMinMaxIntrinsics {\n+\n+    static WhiteBox wb = WhiteBox.getWhiteBox();\n+    static int[] intCases = { Integer.MIN_VALUE, -2, -1, 0, 1, 2, Integer.MAX_VALUE };\n+    public static long im3l = Integer.MIN_VALUE * 3L;\n+\n+    static void test(IntUnaryOperator std, IntUnaryOperator alt) throws ReflectiveOperationException {\n+        for (int a : intCases) {\n+            assertEQ(std.applyAsInt(a), alt.applyAsInt(a), String.format(\"Failed on %d\", a));\n+        }\n+        var method = alt.getClass().getDeclaredMethod(\"applyAsInt\", int.class);\n+        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n+        assertTrue(wb.isMethodCompiled(method));\n+        for (int a : intCases) {\n+            assertEQ(std.applyAsInt(a), alt.applyAsInt(a), String.format(\"Failed on %d\", a));\n+        }\n+    }\n+\n+    static void test(IntBinaryOperator std, IntBinaryOperator alt) throws ReflectiveOperationException {\n+        for (int a : intCases) {\n+            for (int b : intCases) {\n+                assertEQ(std.applyAsInt(a, b), alt.applyAsInt(a, b), String.format(\"Failed on %d, %d\", a, b));\n+            }\n+        }\n+        var method = alt.getClass().getDeclaredMethod(\"applyAsInt\", int.class, int.class);\n+        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n+        assertTrue(wb.isMethodCompiled(method));\n+        for (int a : intCases) {\n+            for (int b : intCases) {\n+                assertEQ(std.applyAsInt(a, b), alt.applyAsInt(a, b), String.format(\"Failed on %d, %d\", a, b));\n+            }\n+        }\n+    }\n+\n+    static int maxL2I(long a, int b) {\n+        return Math.max((int) a, b);\n+    }\n+\n+    static void testL2I() throws NoSuchMethodException {\n+        assertEQ(0, maxL2I(im3l, 0));\n+        var method = TestMinMaxIntrinsics.class.getDeclaredMethod(\"maxL2I\", long.class, int.class);\n+        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n+        assertTrue(wb.isMethodCompiled(method));\n+        assertEQ(0, maxL2I(im3l, 0));\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        test(a -> (a <= 0) ? a : 0, a -> Math.min(a, 0));\n+        test(a -> (a <= 1) ? a : 1, a -> Math.min(a, 1));\n+        test(a -> (a <= -1) ? a : -1, a -> Math.min(a, -1));\n+\n+        test(a -> (0 >= a) ? 0 : a, a -> Math.max(0, a));\n+        test(a -> (1 >= a) ? 1 : a, a -> Math.max(1, a));\n+        test(a -> (-1 >= a) ? -1 : a, a -> Math.max(-1, a));\n+\n+        test((a, b) -> (a <= b) ? a : b, (a, b) -> Math.min(a, b));\n+        test((a, b) -> (a >= b) ? a : b, (a, b) -> Math.max(a, b));\n+\n+        testL2I();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/math\/TestMinMaxIntrinsics.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -44,1 +44,1 @@\n-        long iterations = 100000;\n+        long iterations = 5000;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/unsafe\/DirectByteBufferTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        long iterations = 100000;\n+        long iterations = 5000;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/unsafe\/HeapByteBufferTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,0 +133,6 @@\n+\n+    public static final String ABS_V = PREFIX + \"ABS_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ABS_V, \"AbsV(B|S|I|L|F|D)\");\n+    }\n+\n@@ -148,0 +154,5 @@\n+    public static final String ADD_V = PREFIX + \"ADD_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_V, \"AddV(B|S|I|L|F|D)\");\n+    }\n+\n@@ -158,0 +169,5 @@\n+    public static final String ADD_REDUCTION_V = PREFIX + \"ADD_REDUCTION_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_REDUCTION_V, \"AddReductionV(B|S|I|L|F|D)\");\n+    }\n+\n@@ -363,0 +379,5 @@\n+    public static final String DIV_V = PREFIX + \"DIV_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_V, \"DivV(F|D)\");\n+    }\n+\n@@ -390,0 +411,5 @@\n+    public static final String FMA_V = PREFIX + \"FMA_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(FMA_V, \"FmaV(F|D)\");\n+    }\n+\n@@ -591,0 +617,5 @@\n+    public static final String LSHIFT_V = PREFIX + \"LSHIFT_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LSHIFT_V, \"LShiftV(B|S|I|L)\");\n+    }\n+\n@@ -661,0 +692,5 @@\n+    public static final String MUL_V = PREFIX + \"MUL_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_V, \"MulV(B|S|I|L|F|D)\");\n+    }\n+\n@@ -676,0 +712,5 @@\n+    public static final String NEG_V = PREFIX + \"NEG_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(NEG_V, \"NegV(F|D)\");\n+    }\n+\n@@ -712,0 +753,5 @@\n+    public static final String POPCOUNT_VI = PREFIX + \"POPCOUNT_VI\" + POSTFIX;\n+    static {\n+        superWordNodes(POPCOUNT_VI, \"PopCountVI\");\n+    }\n+\n@@ -745,0 +791,48 @@\n+    public static final String REPLICATE_B = PREFIX + \"REPLICATE_B\" + POSTFIX;\n+    static {\n+        String regex = START + \"ReplicateB\" + MID + END;\n+        IR_NODE_MAPPINGS.put(REPLICATE_B, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                    CompilePhase.AFTER_CLOOPS,\n+                                                                    CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+    public static final String REPLICATE_S = PREFIX + \"REPLICATE_S\" + POSTFIX;\n+    static {\n+        String regex = START + \"ReplicateS\" + MID + END;\n+        IR_NODE_MAPPINGS.put(REPLICATE_S, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                    CompilePhase.AFTER_CLOOPS,\n+                                                                    CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+    public static final String REPLICATE_I = PREFIX + \"REPLICATE_I\" + POSTFIX;\n+    static {\n+        String regex = START + \"ReplicateI\" + MID + END;\n+        IR_NODE_MAPPINGS.put(REPLICATE_I, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                    CompilePhase.AFTER_CLOOPS,\n+                                                                    CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+    public static final String REPLICATE_L = PREFIX + \"REPLICATE_L\" + POSTFIX;\n+    static {\n+        String regex = START + \"ReplicateL\" + MID + END;\n+        IR_NODE_MAPPINGS.put(REPLICATE_L, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                    CompilePhase.AFTER_CLOOPS,\n+                                                                    CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+    public static final String REPLICATE_F = PREFIX + \"REPLICATE_F\" + POSTFIX;\n+    static {\n+        String regex = START + \"ReplicateF\" + MID + END;\n+        IR_NODE_MAPPINGS.put(REPLICATE_F, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                    CompilePhase.AFTER_CLOOPS,\n+                                                                    CompilePhase.BEFORE_MATCHING));\n+    }\n+\n+    public static final String REPLICATE_D = PREFIX + \"REPLICATE_D\" + POSTFIX;\n+    static {\n+        String regex = START + \"ReplicateD\" + MID + END;\n+        IR_NODE_MAPPINGS.put(REPLICATE_D, new SinglePhaseRangeEntry(CompilePhase.PRINT_IDEAL, regex,\n+                                                                    CompilePhase.AFTER_CLOOPS,\n+                                                                    CompilePhase.BEFORE_MATCHING));\n+    }\n+\n@@ -785,0 +879,15 @@\n+    public static final String ROTATE_LEFT_V = PREFIX + \"ROTATE_LEFT_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ROTATE_LEFT_V, \"RotateLeftV\");\n+    }\n+\n+    public static final String ROTATE_RIGHT_V = PREFIX + \"ROTATE_RIGHT_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ROTATE_RIGHT_V, \"RotateRightV\");\n+    }\n+\n+    public static final String ROUND_DOUBLE_MODE_V = PREFIX + \"ROUND_DOUBLE_MODE_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ROUND_DOUBLE_MODE_V, \"RoundDoubleModeV\");\n+    }\n+\n@@ -810,0 +919,5 @@\n+    public static final String RSHIFT_V = PREFIX + \"RSHIFT_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(RSHIFT_V, \"RShiftV(B|S|I|L)\");\n+    }\n+\n@@ -831,0 +945,5 @@\n+    public static final String SQRT_V = PREFIX + \"SQRT_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SQRT_V, \"SqrtV(F|D)\");\n+    }\n+\n@@ -967,0 +1086,5 @@\n+    public static final String SUB_V = PREFIX + \"SUB_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_V, \"SubV(B|S|I|L|F|D)\");\n+    }\n+\n@@ -1037,0 +1161,5 @@\n+    public static final String URSHIFT_V = PREFIX + \"URSHIFT_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(URSHIFT_V, \"URShiftV(B|S|I|L)\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8299959\n+ * @summary In CmpU::Value, the sub computation may be narrower than the overflow computation.\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+StressCCP -Xcomp -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.rangechecks.TestRangeCheckCmpUOverflowVsSub::test\n+ *                   -XX:RepeatCompilation=50\n+ *                   compiler.rangechecks.TestRangeCheckCmpUOverflowVsSub\n+*\/\n+\n+package compiler.rangechecks;\n+\n+public class TestRangeCheckCmpUOverflowVsSub {\n+    static int arr[] = new int[400];\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 10; i++) {\n+            test(); \/\/ repeat for multiple compilations\n+        }\n+    }\n+\n+    static void test() {\n+        for(int i = 0; i < 50_000; i++) {} \/\/empty loop - trigger OSR faster\n+        int val;\n+        int zero = arr[5];\n+        int i = 1;\n+        do {\n+            for (int j = 1; j < 3; j++) {\n+                for (int k = 2; k > i; k -= 3) {\n+                    try {\n+                        val = arr[i + 1] % k;\n+                        val = arr[i - 1] % zero;\n+                        val = arr[k - 1];\n+                    } catch (ArithmeticException e) {} \/\/ catch div by zero\n+                }\n+            }\n+        } while (++i < 3);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckCmpUOverflowVsSub.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires os.simpleArch == \"x64\"\n+ * @requires (os.simpleArch == \"x64\" & (vm.cpu.features ~= \".*avx512f.*\" | vm.cpu.features ~= \".*f16c.*\")) | os.arch == \"aarch64\"\n@@ -37,0 +37,1 @@\n+import jdk.test.lib.Asserts;\n@@ -39,6 +40,6 @@\n-  private static final int ARRLEN = 1024;\n-  private static final int ITERS  = 11000;\n-  private static float  [] finp;\n-  private static short  [] sout;\n-  private static short  [] sinp;\n-  private static float  [] fout;\n+    private static final int ARRLEN = 1024;\n+    private static final int ITERS  = 11000;\n+    private static float  [] finp;\n+    private static short  [] sout;\n+    private static short  [] sinp;\n+    private static float  [] fout;\n@@ -46,5 +47,5 @@\n-  public static void main(String args[]) {\n-      TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n-                                 \"-XX:CompileThresholdScaling=0.3\");\n-      System.out.println(\"PASSED\");\n-  }\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                   \"-XX:CompileThresholdScaling=0.3\");\n+        System.out.println(\"PASSED\");\n+    }\n@@ -52,7 +53,7 @@\n-  @Test\n-  @IR(counts = {IRNode.VECTOR_CAST_F2HF, \"> 0\"}, applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"f16c\", \"true\"})\n-  public void test_float_float16(short[] sout, float[] finp) {\n-      for (int i = 0; i < finp.length; i++) {\n-          sout[i] = Float.floatToFloat16(finp[i]);\n-      }\n-  }\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_CAST_F2HF, \"> 0\"})\n+    public void test_float_float16(short[] sout, float[] finp) {\n+        for (int i = 0; i < finp.length; i++) {\n+            sout[i] = Float.floatToFloat16(finp[i]);\n+        }\n+    }\n@@ -60,4 +61,4 @@\n-  @Run(test = {\"test_float_float16\"}, mode = RunMode.STANDALONE)\n-  public void kernel_test_float_float16() {\n-      finp = new float[ARRLEN];\n-      sout = new short[ARRLEN];\n+    @Run(test = {\"test_float_float16\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_float_float16() {\n+        finp = new float[ARRLEN];\n+        sout = new short[ARRLEN];\n@@ -65,3 +66,3 @@\n-      for (int i = 0; i < ARRLEN; i++) {\n-          finp[i] = (float) i * 1.4f;\n-      }\n+        for (int i = 0; i < ARRLEN; i++) {\n+            finp[i] = (float) i * 1.4f;\n+        }\n@@ -69,4 +70,3 @@\n-      for (int i = 0; i < ITERS; i++) {\n-         test_float_float16(sout, finp);\n-      }\n-  }\n+        for (int i = 0; i < ITERS; i++) {\n+            test_float_float16(sout, finp);\n+        }\n@@ -74,7 +74,5 @@\n-  @Test\n-  @IR(counts = {IRNode.VECTOR_CAST_HF2F, \"> 0\"}, applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"f16c\", \"true\"})\n-  public void test_float16_float(float[] fout, short[] sinp) {\n-      for (int i = 0; i < sinp.length; i++) {\n-          fout[i] = Float.float16ToFloat(sinp[i]);\n-      }\n-  }\n+        \/\/ Verifying the result\n+        for (int i = 0; i < ARRLEN; i++) {\n+            Asserts.assertEquals(Float.floatToFloat16(finp[i]), sout[i]);\n+        }\n+    }\n@@ -82,4 +80,7 @@\n-  @Run(test = {\"test_float16_float\"}, mode = RunMode.STANDALONE)\n-  public void kernel_test_float16_float() {\n-      sinp = new short[ARRLEN];\n-      fout = new float[ARRLEN];\n+    @Test\n+    @IR(counts = {IRNode.VECTOR_CAST_HF2F, \"> 0\"})\n+    public void test_float16_float(float[] fout, short[] sinp) {\n+        for (int i = 0; i < sinp.length; i++) {\n+            fout[i] = Float.float16ToFloat(sinp[i]);\n+        }\n+    }\n@@ -87,3 +88,4 @@\n-      for (int i = 0; i < ARRLEN; i++) {\n-          sinp[i] = (short)i;\n-      }\n+    @Run(test = {\"test_float16_float\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test_float16_float() {\n+        sinp = new short[ARRLEN];\n+        fout = new float[ARRLEN];\n@@ -91,4 +93,13 @@\n-      for (int i = 0; i < ITERS; i++) {\n-          test_float16_float(fout , sinp);\n-      }\n-  }\n+        for (int i = 0; i < ARRLEN; i++) {\n+            sinp[i] = (short)i;\n+        }\n+\n+        for (int i = 0; i < ITERS; i++) {\n+            test_float16_float(fout, sinp);\n+        }\n+\n+        \/\/ Verifying the result\n+        for (int i = 0; i < ARRLEN; i++) {\n+            Asserts.assertEquals(Float.float16ToFloat(sinp[i]), fout[i]);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVector.java","additions":60,"deletions":49,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -45,1 +47,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -76,0 +78,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -85,0 +89,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -94,0 +100,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -103,0 +111,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -112,0 +122,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -121,0 +133,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -130,0 +144,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -140,0 +156,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -150,0 +168,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -161,0 +181,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -173,0 +195,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -182,0 +206,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -190,1 +216,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayCopyTest.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -45,1 +47,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -57,0 +59,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n@@ -66,0 +70,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n@@ -75,0 +81,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n@@ -84,0 +92,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n@@ -102,0 +112,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n@@ -111,0 +123,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n@@ -122,0 +136,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n@@ -142,1 +158,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayIndexFillTest.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -44,0 +44,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -48,1 +50,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -65,0 +67,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.REPLICATE_B, \">0\"})\n@@ -74,0 +78,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.REPLICATE_S, \">0\"})\n@@ -83,0 +89,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.REPLICATE_S, \">0\"})\n@@ -92,0 +100,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.REPLICATE_I, \">0\"})\n@@ -101,0 +111,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.REPLICATE_L, \">0\"})\n@@ -110,0 +122,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.REPLICATE_F, \">0\"})\n@@ -119,0 +133,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.REPLICATE_D, \">0\"})\n@@ -129,0 +145,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.REPLICATE_L, \">0\"})\n@@ -138,0 +156,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.REPLICATE_L, \">0\"})\n@@ -147,0 +167,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.REPLICATE_L, \">0\"})\n@@ -156,0 +178,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.REPLICATE_I, \">0\"})\n@@ -164,1 +188,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayInvariantFillTest.java","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -47,1 +49,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -71,0 +73,4 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeature = {\"avx512f\", \"true\"},\n+        counts = {IRNode.ROTATE_RIGHT_V, \">0\"})\n@@ -80,0 +86,4 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeature = {\"avx512f\", \"true\"},\n+        counts = {IRNode.ROTATE_RIGHT_V, \">0\"})\n@@ -89,0 +99,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.RSHIFT_V, \">0\"})\n@@ -98,0 +110,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.RSHIFT_V, \">0\"})\n@@ -107,0 +121,24 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.RSHIFT_V, \">0\"})\n+    public short[] shortShiftLargeDistConstant() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) (shorts1[i] >> 65);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.RSHIFT_V, \">0\"})\n+    public short[] shortShiftLargeDistInvariant() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) (shorts2[i] >> (largeDist - 25));\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.LSHIFT_V, \">0\"})\n@@ -116,0 +154,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.URSHIFT_V, \">0\"})\n@@ -125,2 +165,2 @@\n-    \/\/ Note that any shift operation with distance value from another array\n-    \/\/ cannot be vectorized since C2 vector shift node doesn't support it.\n+    \/\/ Note that shift with variant distance cannot be vectorized.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n@@ -136,0 +176,13 @@\n+    \/\/ Note that shift with variant distance cannot be vectorized.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    public short[] loopIndexShiftDistance() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) (shorts1[i] >> i);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.RSHIFT_V, \">0\"})\n@@ -146,1 +199,2 @@\n-    \/\/ vectorized since precise type info about signness is missing.\n+    \/\/ vectorized since precise type info about signedness is missing.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n@@ -155,1 +209,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java","additions":59,"deletions":6,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -45,1 +47,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -132,0 +134,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_I2X, \">0\"})\n@@ -141,0 +145,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_I2X, \">0\"})\n@@ -150,0 +156,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx512dq\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_L2X, \">0\"})\n@@ -159,0 +167,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512dq\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_L2X, \">0\"})\n@@ -169,0 +179,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_S2X, \">0\"})\n@@ -178,0 +190,3 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        counts = {IRNode.VECTOR_CAST_S2X, \">0\"})\n@@ -206,0 +221,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_F2X, \">0\"})\n@@ -215,0 +232,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512dq\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_F2X, \">0\"})\n@@ -224,0 +243,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_D2X, \">0\"})\n@@ -233,0 +254,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512dq\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_D2X, \">0\"})\n@@ -243,0 +266,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_F2X, \">0\"})\n@@ -252,0 +277,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_F2X, \">0\"})\n@@ -261,0 +288,3 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        counts = {IRNode.VECTOR_CAST_D2X, \">0\"})\n@@ -270,0 +300,3 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        counts = {IRNode.VECTOR_CAST_D2X, \">0\"})\n@@ -280,0 +313,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_F2X, \">0\"})\n@@ -289,0 +324,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\"},\n+        counts = {IRNode.VECTOR_CAST_D2X, \">0\"})\n@@ -297,1 +334,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":39,"deletions":3,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -49,1 +51,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -95,0 +97,1 @@\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n@@ -103,1 +106,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayUnsafeOpTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -45,1 +47,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -72,0 +74,4 @@\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        counts = {IRNode.AND_V, \">0\"})\n+    @IR(applyIfCPUFeature = {\"avx512vl\", \"true\"},\n+        counts = {IRNode.MACRO_LOGIC_V, \">0\"})\n@@ -81,0 +87,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.OR_V, \">0\"})\n@@ -90,0 +98,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.XOR_V, \">0\"})\n@@ -98,1 +108,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicBooleanOpTest.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -45,1 +47,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -64,0 +66,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.SUB_V, \">0\"})\n@@ -73,0 +77,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"ssse3\", \"true\"},\n+        counts = {IRNode.ABS_V, \">0\"})\n@@ -82,0 +88,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.ADD_V, \">0\"})\n@@ -91,0 +99,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.SUB_V, \">0\"})\n@@ -100,0 +110,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\"})\n@@ -109,0 +121,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\", IRNode.ADD_V, \">0\"})\n@@ -118,0 +132,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\", IRNode.SUB_V, \">0\"})\n@@ -128,0 +144,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.XOR_V, \">0\"})\n@@ -137,0 +155,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.AND_V, \">0\"})\n@@ -146,0 +166,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.OR_V, \">0\"})\n@@ -155,0 +177,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.XOR_V, \">0\"})\n@@ -165,0 +189,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.LSHIFT_V, \">0\"})\n@@ -174,0 +200,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.RSHIFT_V, \">0\"})\n@@ -183,0 +211,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.RSHIFT_V, \">0\"})\n@@ -191,1 +221,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicByteOpTest.java","additions":32,"deletions":3,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -45,1 +47,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -67,0 +69,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.SUB_V, \">0\"})\n@@ -76,2 +80,3 @@\n-    \/\/ Note that Math.abs() on unsigned subword types can NOT be vectorized\n-    \/\/ since all the values are non-negative according to the semantics.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    @IR(failOn = {IRNode.ABS_V})\n@@ -87,0 +92,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.ADD_V, \">0\"})\n@@ -96,0 +103,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.SUB_V, \">0\"})\n@@ -105,0 +114,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\"})\n@@ -114,0 +125,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\", IRNode.ADD_V, \">0\"})\n@@ -123,0 +136,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\", IRNode.SUB_V, \">0\"})\n@@ -133,0 +148,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.XOR_V, \">0\"})\n@@ -142,0 +159,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.AND_V, \">0\"})\n@@ -151,0 +170,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.OR_V, \">0\"})\n@@ -160,0 +181,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.XOR_V, \">0\"})\n@@ -170,0 +193,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.LSHIFT_V, \">0\"})\n@@ -179,0 +204,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.URSHIFT_V, \">0\"})\n@@ -188,0 +215,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.URSHIFT_V, \">0\"})\n@@ -198,0 +227,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.REVERSE_BYTES_V, \">0\"})\n@@ -207,0 +238,3 @@\n+    \/\/ Note that reverseBytes cannot be vectorized if the vector element\n+    \/\/ type doesn't match the caller's class type.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n@@ -215,1 +249,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicCharOpTest.java","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -45,1 +47,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -64,0 +66,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.NEG_V, \">0\"})\n@@ -73,0 +77,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.ABS_V, \">0\"})\n@@ -82,0 +88,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\"},\n+        counts = {IRNode.SQRT_V, \">0\"})\n@@ -91,0 +99,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse\", \"true\"},\n+        counts = {IRNode.ROUND_DOUBLE_MODE_V, \">0\"})\n@@ -100,0 +110,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4_1\", \"true\"},\n+        counts = {IRNode.ROUND_DOUBLE_MODE_V, \">0\"})\n@@ -109,0 +121,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4_1\", \"true\"},\n+        counts = {IRNode.ROUND_DOUBLE_MODE_V, \">0\"})\n@@ -118,0 +132,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.ADD_V, \">0\"})\n@@ -127,0 +143,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.SUB_V, \">0\"})\n@@ -136,0 +154,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\"})\n@@ -145,0 +165,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.DIV_V, \">0\"})\n@@ -154,0 +176,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse\", \"true\"},\n+        counts = {IRNode.MAX_V, \">0\"})\n@@ -163,0 +187,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse\", \"true\"},\n+        counts = {IRNode.MIN_V, \">0\"})\n@@ -172,0 +198,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"fma\", \"true\"},\n+        counts = {IRNode.FMA_V, \">0\"})\n@@ -181,0 +209,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"fma\", \"true\"},\n+        counts = {IRNode.FMA_V, \">0\"})\n@@ -190,0 +220,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"fma\", \"true\"},\n+        counts = {IRNode.FMA_V, \">0\"})\n@@ -199,0 +231,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"fma\", \"true\"},\n+        counts = {IRNode.FMA_V, \">0\"})\n@@ -208,0 +242,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"fma\", \"true\"},\n+        counts = {IRNode.FMA_V, \">0\"})\n@@ -217,0 +253,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"fma\", \"true\"},\n+        counts = {IRNode.FMA_V, \">0\"})\n@@ -253,1 +291,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicDoubleOpTest.java","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -45,1 +47,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -64,0 +66,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse\", \"true\"},\n+        counts = {IRNode.NEG_V, \">0\"})\n@@ -73,0 +77,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse\", \"true\"},\n+        counts = {IRNode.ABS_V, \">0\"})\n@@ -82,0 +88,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx\", \"true\"},\n+        counts = {IRNode.SQRT_V, \">0\"})\n@@ -91,0 +99,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.ADD_V, \">0\"})\n@@ -100,0 +110,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.SUB_V, \">0\"})\n@@ -109,0 +121,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\"})\n@@ -118,0 +132,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.DIV_V, \">0\"})\n@@ -127,0 +143,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse\", \"true\"},\n+        counts = {IRNode.MAX_V, \">0\"})\n@@ -136,0 +154,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse\", \"true\"},\n+        counts = {IRNode.MIN_V, \">0\"})\n@@ -145,0 +165,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"fma\", \"true\"},\n+        counts = {IRNode.FMA_V, \">0\"})\n@@ -154,0 +176,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"fma\", \"true\"},\n+        counts = {IRNode.FMA_V, \">0\"})\n@@ -163,0 +187,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"fma\", \"true\"},\n+        counts = {IRNode.FMA_V, \">0\"})\n@@ -172,0 +198,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"fma\", \"true\"},\n+        counts = {IRNode.FMA_V, \">0\"})\n@@ -181,0 +209,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"fma\", \"true\"},\n+        counts = {IRNode.FMA_V, \">0\"})\n@@ -190,0 +220,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"fma\", \"true\"},\n+        counts = {IRNode.FMA_V, \">0\"})\n@@ -226,1 +258,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicFloatOpTest.java","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -45,1 +47,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -64,0 +66,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.SUB_V, \">0\"})\n@@ -73,0 +77,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"ssse3\", \"true\"},\n+        counts = {IRNode.ABS_V, \">0\"})\n@@ -82,0 +88,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.ADD_V, \">0\"})\n@@ -91,0 +99,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.SUB_V, \">0\"})\n@@ -100,0 +110,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4_1\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\"})\n@@ -109,0 +121,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4_1\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\", IRNode.ADD_V, \">0\"})\n@@ -118,0 +132,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4_1\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\", IRNode.SUB_V, \">0\"})\n@@ -127,0 +143,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.POPCOUNT_VI, \">0\"})\n@@ -137,0 +155,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.XOR_V, \">0\"})\n@@ -146,0 +166,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.AND_V, \">0\"})\n@@ -155,0 +177,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.OR_V, \">0\"})\n@@ -164,0 +188,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.XOR_V, \">0\"})\n@@ -174,0 +200,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.LSHIFT_V, \">0\"})\n@@ -183,0 +211,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.RSHIFT_V, \">0\"})\n@@ -192,0 +222,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.URSHIFT_V, \">0\"})\n@@ -238,0 +270,2 @@\n+    \/\/ Note that integer max produces non-vectorizable CMoveI node.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n@@ -247,0 +281,2 @@\n+    \/\/ Note that integer min produces non-vectorizable CMoveI node.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n@@ -255,1 +291,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicIntOpTest.java","additions":38,"deletions":3,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -45,1 +47,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -64,0 +66,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.SUB_V, \">0\"})\n@@ -73,0 +77,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx512vl\", \"true\"},\n+        counts = {IRNode.ABS_V, \">0\"})\n@@ -82,0 +88,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.ADD_V, \">0\"})\n@@ -91,0 +99,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.SUB_V, \">0\"})\n@@ -100,0 +110,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx512dq\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\"})\n@@ -109,0 +121,4 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.ADD_V, \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx512dq\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\"})\n@@ -118,0 +134,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\", IRNode.SUB_V, \">0\"})\n@@ -128,0 +146,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.XOR_V, \">0\"})\n@@ -137,0 +157,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.AND_V, \">0\"})\n@@ -146,0 +168,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.OR_V, \">0\"})\n@@ -155,0 +179,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.XOR_V, \">0\"})\n@@ -165,0 +191,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.LSHIFT_V, \">0\"})\n@@ -174,0 +202,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.RSHIFT_V, \">0\"})\n@@ -183,0 +213,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.URSHIFT_V, \">0\"})\n@@ -229,0 +261,2 @@\n+    \/\/ Note that long integer max produces non-vectorizable CMoveL node.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n@@ -238,0 +272,2 @@\n+    \/\/ Note that long integer min produces non-vectorizable CMoveL node.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n@@ -246,1 +282,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicLongOpTest.java","additions":38,"deletions":3,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -45,1 +47,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -67,0 +69,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.SUB_V, \">0\"})\n@@ -76,0 +80,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"ssse3\", \"true\"},\n+        counts = {IRNode.ABS_V, \">0\"})\n@@ -85,0 +91,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.ADD_V, \">0\"})\n@@ -94,0 +102,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.SUB_V, \">0\"})\n@@ -103,0 +113,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\"})\n@@ -112,0 +124,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\", IRNode.ADD_V, \">0\"})\n@@ -121,0 +135,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\", IRNode.SUB_V, \">0\"})\n@@ -131,0 +147,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.XOR_V, \">0\"})\n@@ -140,0 +158,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.AND_V, \">0\"})\n@@ -149,0 +169,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.OR_V, \">0\"})\n@@ -158,0 +180,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.XOR_V, \">0\"})\n@@ -168,0 +192,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.LSHIFT_V, \">0\"})\n@@ -177,0 +203,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.RSHIFT_V, \">0\"})\n@@ -186,0 +214,27 @@\n+    \/\/ Note that min operations on subword types cannot be vectorized\n+    \/\/ because higher bits will be lost.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    public short[] vectorMin() {\n+        short[] res = new short[SIZE];\n+        int val = 65536;\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) Math.min(a[i], val);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Note that max operations on subword types cannot be vectorized\n+    \/\/ because higher bits will be lost.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    public short[] vectorMax() {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = (short) Math.max(a[i], b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.RSHIFT_V, \">0\"})\n@@ -196,0 +251,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.REVERSE_BYTES_V, \">0\"})\n@@ -205,0 +262,3 @@\n+    \/\/ Note that reverseBytes cannot be vectorized if the vector element\n+    \/\/ type doesn't match the caller's class type.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n@@ -213,1 +273,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicShortOpTest.java","additions":62,"deletions":3,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -47,1 +49,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -78,0 +80,4 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.ADD_VI, \">0\"})\n@@ -87,0 +93,4 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"sse4_1\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\"})\n@@ -96,0 +106,4 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4_1\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\"})\n@@ -106,0 +120,4 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"sse4_1\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\"})\n@@ -116,0 +134,4 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4_1\", \"true\"},\n+        counts = {IRNode.MUL_V, \">0\"})\n@@ -126,0 +148,4 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.SUB_V, \">0\"})\n@@ -136,1 +162,2 @@\n-    \/\/ Note that this case cannot be vectorized due to data dependence\n+    \/\/ Note that this case cannot be vectorized due to data dependence.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n@@ -146,1 +173,2 @@\n-    \/\/ Note that this case cannot be vectorized due to data dependence\n+    \/\/ Note that this case cannot be vectorized due to data dependence.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n@@ -207,2 +235,2 @@\n-    \/\/ Note that this case cannot be vectorized due to data dependence\n-    \/\/ between src and dest of the assignment.\n+    \/\/ Note that this case cannot be vectorized due to data dependence.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n@@ -220,1 +248,2 @@\n-    \/\/ Note that this case cannot be vectorized due to data dependence\n+    \/\/ Note that this case cannot be vectorized due to data dependence.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n@@ -231,1 +260,2 @@\n-    \/\/ Note that this case cannot be vectorized due to data dependence\n+    \/\/ Note that this case cannot be vectorized due to data dependence.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n@@ -242,1 +272,2 @@\n-    \/\/ Note that this case cannot be vectorized due to data dependence\n+    \/\/ Note that this case cannot be vectorized due to data dependence.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n@@ -253,1 +284,2 @@\n-    \/\/ Note that this case cannot be vectorized due to data dependence\n+    \/\/ Note that this case cannot be vectorized due to data dependence.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n@@ -265,0 +297,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -276,1 +310,2 @@\n-    \/\/ Note that this case cannot be vectorized due to data dependence\n+    \/\/ Note that this case cannot be vectorized due to data dependence.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n@@ -287,1 +322,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopArrayIndexComputeTest.java","additions":46,"deletions":12,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -47,1 +49,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -83,0 +85,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -92,0 +96,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -101,0 +107,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -110,0 +118,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -119,0 +129,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -128,0 +140,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -141,0 +155,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -154,0 +170,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -165,0 +183,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -178,0 +198,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -189,0 +211,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -200,0 +224,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -211,0 +237,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -221,0 +249,14 @@\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    public int[] multipleOpsWith2DifferentTypesAndSharedOp() {\n+        int i = 0, sum = 0;\n+        int[] res1 = new int[SIZE];\n+        short[] res2 = new short[SIZE];\n+        while (++i < SIZE) {\n+            sum += (res1[i]--);\n+            res2[i]++;\n+        }\n+        return res1;\n+    }\n+\n@@ -258,0 +300,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -268,0 +312,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -278,1 +324,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopCombinedOpTest.java","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -47,1 +49,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -65,0 +67,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -89,1 +93,0 @@\n-}\n@@ -91,0 +94,12 @@\n+    @Test\n+    \/\/ Note that this loop cannot be vectorized due to early break.\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    public int conditionalBreakReduction() {\n+        int sum = 0, i = 0;\n+        for (i = 0; i < SIZE; i++) {\n+            sum += i;\n+            if (invCond) break;\n+        }\n+        return i;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopControlFlowTest.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -47,1 +49,1 @@\n-    private static final int SIZE = 3333;\n+    private static final int SIZE = 543;\n@@ -53,0 +55,3 @@\n+    \/\/ tmp[] may be modified and thus should not be returned in cases.\n+    private int[] tmp;\n+\n@@ -58,0 +63,1 @@\n+        tmp = new int[SIZE];\n@@ -59,2 +65,2 @@\n-        start = 999 + ran.nextInt() % 100;\n-        limit = start + 1357;\n+        start = ran.nextInt() % 100;\n+        limit = start + 235;\n@@ -64,0 +70,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -74,0 +82,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -84,0 +94,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -94,0 +106,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -104,0 +118,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -111,1 +127,1 @@\n-            res[j] = a[j - 500] + 2323;\n+            res[j] = a[j] + 2323;\n@@ -136,1 +152,0 @@\n-}\n@@ -138,0 +153,11 @@\n+    @Test\n+    public int nestedLoopIndexLiveOut() {\n+        int k = 0;\n+        for (int i = 0; i < 50; i += 2) {\n+            for (int j = 0; j < 10; j++) {\n+                tmp[k++] = 5;\n+            }\n+        }\n+        return k;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopLiveOutNodesTest.java","additions":32,"deletions":6,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -47,1 +49,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -63,2 +65,2 @@\n-        start = Math.abs(ran.nextInt() % 1000);\n-        end = start + 1315;\n+        start = Math.abs(ran.nextInt() % 100);\n+        end = start + 315;\n@@ -78,0 +80,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -87,0 +91,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -96,0 +102,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -105,0 +113,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -107,1 +117,1 @@\n-        for (short s = 123; s < 789; s++) {\n+        for (short s = 123; s < 456; s++) {\n@@ -114,0 +124,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -125,0 +137,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -163,1 +177,0 @@\n-\n@@ -165,0 +178,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -184,0 +199,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -193,0 +210,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -201,1 +220,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopRangeStrideTest.java","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -39,0 +39,1 @@\n+ *\n@@ -43,0 +44,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -47,1 +50,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -77,0 +80,4 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.LOAD_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.ADD_REDUCTION_V, \">0\"})\n@@ -95,2 +102,2 @@\n-    \/\/ Note that adding constant in loop would be directly optimized to\n-    \/\/ scalar operations, hence this case is not vectorized.\n+    \/\/ Note that this loop should be optimized to straight-line code.\n+    @IR(failOn = {IRNode.COUNTED_LOOP})\n@@ -115,0 +122,4 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.LOAD_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.ADD_REDUCTION_V, \">0\"})\n@@ -168,0 +179,4 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"sse2\", \"true\"},\n+        counts = {IRNode.ADD_REDUCTION_V, \">0\"})\n@@ -189,1 +204,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopReductionOpTest.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -43,0 +43,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -63,0 +65,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -80,0 +84,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -94,0 +100,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -108,0 +116,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -117,1 +127,0 @@\n-}\n@@ -119,0 +128,21 @@\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    public float reductionLoopWithAnotherReductionInput() {\n+        float res = 0.0F;\n+        int N = 400;\n+        int[] arr = new int[N];\n+        int i1 = 0, i2 = 0, i3, i4;\n+        for (int j = 0; j < N; ++j) {\n+            for (i3 = 1; i3 < 63; ++i3) {\n+                arr[i3] -= 1;\n+                i1 += i3;\n+            }\n+            for (i4 = 2; i4 < 63; ++i4) {\n+                res += i4 - i2;\n+                i2 = i1;\n+            }\n+        }\n+        return res;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/MultipleLoopsTest.java","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -44,0 +44,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -48,1 +50,1 @@\n-    private static final int SIZE = 2345;\n+    private static final int SIZE = 543;\n@@ -61,0 +63,2 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n@@ -77,1 +81,0 @@\n-}\n@@ -79,0 +82,15 @@\n+    @Test\n+    public int stripMinedOneIterationLoop() {\n+        int[] res = new int[SIZE];\n+        int i1, i2, i3, i4 = 11937;\n+        for (i1 = 1; i1 < SIZE; i1++) {\n+            for (i2 = 1; i2 < 2; i2++) {\n+                for (i3 = 1; i3 < 2; i3++) {\n+                    i4 &= i3;\n+                }\n+            }\n+            res[i1] = 0;\n+        }\n+        return res[0] + i4;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/StripMinedLoopTest.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n@@ -26,0 +26,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -37,0 +39,1 @@\n+import jdk.test.lib.Platform;\n@@ -53,4 +56,0 @@\n-    @Target(ElementType.METHOD)\n-    @Retention(RetentionPolicy.RUNTIME)\n-    protected @interface Test {}\n-\n@@ -58,4 +57,1 @@\n-        \/\/ Add extra VM options to enable post loop vectorization\n-        WB.setBooleanVMFlag(\"UnlockExperimentalVMOptions\", true);\n-        WB.setBooleanVMFlag(\"PostLoopMultiversioning\", true);\n-\n+        \/\/ 1) Vectorization correctness test\n@@ -68,0 +64,3 @@\n+        \/\/ Add extra VM options to verify experimental auto-vectorization\n+        WB.setBooleanVMFlag(\"UnlockExperimentalVMOptions\", true);\n+        WB.setBooleanVMFlag(\"PostLoopMultiversioning\", true);\n@@ -79,0 +78,8 @@\n+\n+        \/\/ 2) Vectorization ability test\n+        \/\/ To test vectorizability, invoke the IR test framework to check existence of\n+        \/\/ expected C2 IR node.\n+        TestFramework irTest = new TestFramework(klass);\n+        \/\/ Add extra VM options to enable more auto-vectorization chances\n+        irTest.addFlags(\"-XX:-OptimizeFill\");\n+        irTest.start();\n@@ -207,1 +214,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/VectorizationTestRunner.java","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-                throw new RuntimeException(\"hs-err file incomplete (first missing pattern: \" + positivePatternStack.peek() + \")\");\n+                throw new RuntimeException(\"hs-err file incomplete (first missing pattern: \" + currentPositivePattern.pattern() + \")\");\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/HsErrFileUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires os.family == \"linux\" & vm.bits == \"64\" & (os.arch==\"amd64\" | os.arch==\"x86_64\")\n+ * @requires vm.cds & vm.bits == \"64\"\n@@ -37,0 +37,3 @@\n+import java.util.HashMap;\n+import jdk.test.lib.artifacts.ArtifactResolver;\n+import jdk.test.lib.artifacts.ArtifactResolverException;\n@@ -38,0 +41,1 @@\n+import jdk.test.lib.Platform;\n@@ -40,0 +44,1 @@\n+import jtreg.SkippedException;\n@@ -42,0 +47,1 @@\n+\n@@ -51,2 +57,5 @@\n-    \/\/ the test.boot.jdk property is passed by make\/RunTests.gmk\n-    private static final String BOOT_JDK = System.getProperty(\"test.boot.jdk\", null);\n+    \/\/ the test.boot.jdk property is normally passed by make\/RunTests.gmk\n+    private static String BOOT_JDK = System.getProperty(\"test.boot.jdk\", null);\n+\n+    \/\/ Comma separated list of JDK major versions that will be tested\n+    private static String JDK_VERSIONS = System.getProperty(\"test.autocreatesharedarchive.jdk.version\", null);\n@@ -64,2 +73,24 @@\n-        setupJVMs();\n-        doTest();\n+        \/\/ Earliest testable version is 19\n+        int n = java.lang.Runtime.version().major();\n+\n+        \/\/ If JDK_VERSIONS is specified, test against each specified version;\n+        \/\/ otherwise test with PREV_JDK if specified;\n+        \/\/ otherwise test with BOOT_JDK if specified;\n+        \/\/ otherwise throw SkippedException.\n+        if (JDK_VERSIONS == null) {\n+            System.out.println(\"JDK_VERSIONS not specified\");\n+            setupJVMs(0);\n+            doTest();\n+            return;\n+        }\n+\n+        String[] versions = JDK_VERSIONS.split(\",\");\n+        for (int i = 0; i < versions.length; i++) {\n+            System.out.println(\"Testing JDK: \" + versions[i]);\n+            try {\n+                setupJVMs(Integer.parseInt(versions[i]));\n+                doTest();\n+            } catch (NumberFormatException e) {\n+                throw new RuntimeException(\"Invalid AutoCreateSharedArchive JDK version: \" + versions[i]);\n+            }\n+        }\n@@ -68,1 +99,1 @@\n-    static void setupJVMs() throws Throwable {\n+    static void setupJVMs(int fetchVersion) throws Throwable {\n@@ -75,1 +106,3 @@\n-        if (PREV_JDK != null) {\n+        if (fetchVersion >= 19) {\n+            oldJVM = fetchJDK(fetchVersion) + FS + \"bin\" + FS + \"java\";\n+        } else if (PREV_JDK != null) {\n@@ -80,1 +113,1 @@\n-            throw new RuntimeException(\"Use -Dtest.previous.jdk or -Dtest.boot.jdk to specify a \" +\n+            throw new SkippedException(\"Use -Dtest.previous.jdk or -Dtest.boot.jdk to specify a \" +\n@@ -104,1 +137,0 @@\n-        assertJSAVersionMismatch(output);\n@@ -112,1 +144,0 @@\n-        assertJSAVersionMismatch(output);\n@@ -137,4 +168,0 @@\n-    static void assertJSAVersionMismatch(OutputAnalyzer output) {\n-        output.shouldContain(\"does not match the required version\");\n-    }\n-\n@@ -144,0 +171,63 @@\n+\n+    \/\/ Fetch JDK artifact depending on platform\n+    \/\/ If the artifact cannot be found, throw RuntimeException\n+    private static String fetchJDK(int version) throws Throwable {\n+        int build;\n+        String architecture;\n+        HashMap<String, Object> jdkArtifactMap = new HashMap<>();\n+        jdkArtifactMap.put(\"server\", \"jpg\");\n+        jdkArtifactMap.put(\"product\", \"jdk\");\n+\n+        \/\/ Select the correct release build number for each version\n+        \/\/ *UPDATE THIS* after each release\n+        switch(version) {\n+            case 19:\n+                build = 36;\n+                break;\n+            case 20:\n+                build = 29;\n+                break;\n+            default:\n+                throw new RuntimeException(\"Unsupported JDK version \" + version);\n+        }\n+        jdkArtifactMap.put(\"version\", version);\n+        jdkArtifactMap.put(\"build_number\", build);\n+\n+        \/\/ Get correct file name for architecture\n+        if (Platform.isX64()) {\n+            architecture = \"x64\";\n+        } else if (Platform.isAArch64()) {\n+            architecture = \"aarch64\";\n+        } else {\n+            throw new RuntimeException(\"Unsupported architecture \" + Platform.getOsArch());\n+        }\n+\n+        \/\/ File name is bundles\/<os>-<architecture>\/jdk-<version>_<os>-<architecture>_bin.<extension>\n+        \/\/ Ex: bundles\/linux-x64\/jdk-19_linux-x64_bin.tar.gz\n+        if (Platform.isWindows()) {\n+            jdkArtifactMap.put(\"file\", \"bundles\/windows-\" + architecture + \"\/jdk-\" + version + \"_windows-\" + architecture + \"_bin.zip\");\n+            return fetchJDK(jdkArtifactMap, version);\n+        } else if (Platform.isOSX()) {\n+            jdkArtifactMap.put(\"file\", \"bundles\/macos-\" + architecture + \"\/jdk-\" + version + \"_macos-\" + architecture + \"_bin.tar.gz\");\n+            return fetchJDK(jdkArtifactMap, version) +  \".jdk\" + FS + \"Contents\" + FS + \"Home\";\n+        } else if (Platform.isLinux()) {\n+            jdkArtifactMap.put(\"file\", \"bundles\/linux-\" + architecture + \"\/jdk-\" + version + \"_linux-\" + architecture + \"_bin.tar.gz\");\n+            return fetchJDK(jdkArtifactMap, version);\n+        } else {\n+            throw new RuntimeException(\"Unsupported operating system \" + Platform.getOsName());\n+        }\n+    }\n+\n+    \/\/ Fetch JDK artifact\n+    private static String fetchJDK(HashMap<String, Object> jdkArtifactMap, int version) {\n+        try {\n+            String path = null;\n+            path = ArtifactResolver.resolve(\"jdk\", jdkArtifactMap, true) + \"\/jdk-\" + version;\n+            System.out.println(\"Boot JDK path: \" + path);\n+            return path;\n+        } catch (ArtifactResolverException e) {\n+            Throwable cause = e.getCause();\n+            throw new RuntimeException(\"Fetch artifact failed: \"\n+                    + \"\\nPlease make sure the artifact is available.\", e);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchiveUpgrade.java","additions":105,"deletions":15,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +32,6 @@\n- * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields FastGetField\n- * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields -XX:+UnlockDiagnosticVMOptions -XX:+ForceUnreachable -XX:+SafepointALot -XX:GuaranteedSafepointInterval=1 FastGetField\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields FastGetField 0\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields FastGetField 1\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields FastGetField 2\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields -XX:+UnlockDiagnosticVMOptions -XX:+ForceUnreachable -XX:+SafepointALot -XX:GuaranteedSafepointInterval=1 FastGetField 0\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields -XX:+UnlockDiagnosticVMOptions -XX:+ForceUnreachable -XX:+SafepointALot -XX:GuaranteedSafepointInterval=1 FastGetField 1\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields -XX:+UnlockDiagnosticVMOptions -XX:+ForceUnreachable -XX:+SafepointALot -XX:GuaranteedSafepointInterval=1 FastGetField 2\n@@ -37,1 +42,0 @@\n-\n@@ -44,0 +48,2 @@\n+    public native void registerGlobal(MyItem i);\n+    public native void registerWeak(MyItem i);\n@@ -45,0 +51,1 @@\n+    public native long accessFieldsViaHandle();\n@@ -95,0 +102,27 @@\n+    private int mode;\n+    private MyItem obj;\n+\n+    private FastGetField(int mode) {\n+        this.mode = mode;\n+        this.obj = new MyItem();\n+\n+        if (mode == 0) {\n+            \/\/ Direct\n+        } else if (mode == 1) {\n+            registerGlobal(this.obj);\n+        } else if ( mode == 2) {\n+            registerWeak(this.obj);\n+        } else {\n+          throw new IllegalArgumentException(\"Unexpected mode\");\n+        }\n+    }\n+\n+    private long accessFields() {\n+        if (mode == 0) {\n+            return accessFields(obj);\n+        }\n+\n+        \/\/ Otherwise through a handle\n+        return accessFieldsViaHandle();\n+    }\n+\n@@ -96,1 +130,1 @@\n-        MyItem i = new MyItem();\n+\n@@ -101,4 +135,4 @@\n-            if (accessFields(i) != 0l) throw new RuntimeException(\"Wrong initial result!\");\n-            i.change_values();\n-            if (accessFields(i) != 8l) throw new RuntimeException(\"Wrong result after changing!\");\n-            i.reset_values();\n+            if (accessFields() != 0l) throw new RuntimeException(\"Wrong initial result!\");\n+            obj.change_values();\n+            if (accessFields() != 8l) throw new RuntimeException(\"Wrong result after changing!\");\n+            obj.reset_values();\n@@ -115,3 +149,3 @@\n-        if (accessFields(i) != 0l) throw new RuntimeException(\"Wrong initial result!\");\n-        i.change_values();\n-        if (accessFields(i) != 8l) throw new RuntimeException(\"Wrong result after changing!\");\n+        if (accessFields() != 0l) throw new RuntimeException(\"Wrong initial result!\");\n+        obj.change_values();\n+        if (accessFields() != 8l) throw new RuntimeException(\"Wrong result after changing!\");\n@@ -122,1 +156,7 @@\n-        FastGetField inst = new FastGetField();\n+        if (args.length != 1) {\n+           throw new IllegalArgumentException(\"Expected one argument\");\n+        }\n+\n+        int mode = Integer.parseInt(args[0]);\n+\n+        FastGetField inst = new FastGetField(mode);\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/FastGetField\/FastGetField.java","additions":52,"deletions":12,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +36,1 @@\n-\n+static jobject objHandle;\n@@ -66,0 +67,7 @@\n+JNIEXPORT void JNICALL Java_FastGetField_registerGlobal(JNIEnv *env, jobject this, jobject obj) {\n+  objHandle = (*env)->NewGlobalRef(env, obj);\n+}\n+\n+JNIEXPORT void JNICALL Java_FastGetField_registerWeak(JNIEnv *env, jobject this, jobject obj) {\n+  objHandle = (*env)->NewWeakGlobalRef(env, obj);\n+}\n@@ -79,0 +87,3 @@\n+JNIEXPORT jlong JNICALL Java_FastGetField_accessFieldsViaHandle(JNIEnv *env, jobject this) {\n+  return Java_FastGetField_accessFields(env, this, objHandle);\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/FastGetField\/libFastGetField.c","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,3 @@\n-\/* @test\n+\/*\n+ * @test id=default\n+ * @bug 8284161\n@@ -27,2 +29,10 @@\n- * @compile --enable-preview -source ${jdk.version} IsVirtualThread.java\n- * @run main\/native\/othervm --enable-preview IsVirtualThread\n+ * @enablePreview\n+ * @run main\/native\/othervm IsVirtualThread\n+ *\/\n+\n+\/*\n+ * @test id=no-vmcontinuations\n+ * @requires vm.continuations\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @run main\/native\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations IsVirtualThread\n@@ -43,3 +53,6 @@\n-        test(thread);   \/\/ started, probably parked\n-        LockSupport.unpark(thread);\n-        thread.join();\n+        try {\n+            test(thread);   \/\/ started, probably parked\n+        } finally {\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n@@ -52,3 +65,6 @@\n-        test(vthread);   \/\/ started, probably parked\n-        LockSupport.unpark(vthread);\n-        vthread.join();\n+        try {\n+            test(vthread);   \/\/ started, probably parked\n+        } finally {\n+            LockSupport.unpark(vthread);\n+            vthread.join();\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/IsVirtualThread\/IsVirtualThread.java","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,1 +169,1 @@\n-                env->ReleaseByteArrayElements(result, arrayPtr, JNI_COMMIT);\n+                env->ReleaseByteArrayElements(result, arrayPtr, 0);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/libRedefineRetransform.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp byteArr -ms low\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp byteArr\n+ *      -ms low\n@@ -51,0 +56,1 @@\n+        private Object[] indexLocks;\n@@ -55,2 +61,4 @@\n-                        synchronized (this) {\n-                                int index = LocalRandom.nextInt(array.length);\n+                        int index = LocalRandom.nextInt(array.length);\n+                        \/\/ Synchronizing to prevent multiple object creation for the same index at the same time.\n+                        synchronized (indexLocks[index]) {\n+                                array[index] = null;\n@@ -75,0 +83,4 @@\n+                indexLocks = new Object[objectCount - 1];\n+                for (int i = 0; i < indexLocks.length; i++) {\n+                    indexLocks[i] = new Object();\n+                }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle01\/Juggle01.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp byteArr -ms medium\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp byteArr\n+ *      -ms medium\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle02\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp byteArr -ms high\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp byteArr\n+ *      -ms high\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle03\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp byteArr -ms low\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp byteArr\n+ *      -ms low\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle04\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle05\/TestDescription.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp booleanArr -ms high\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp booleanArr\n+ *      -ms high\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle06\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp shortArr -ms low\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp shortArr\n+ *      -ms low\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle07\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp shortArr -ms medium\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp shortArr\n+ *      -ms medium\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle08\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp shortArr -ms high\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp shortArr\n+ *      -ms high\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle09\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp charArr -ms low\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp charArr\n+ *      -ms low\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle10\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,7 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log -Djava.security.manager=allow gc.ArrayJuggle.Juggle01.Juggle01 -gp charArr -ms medium\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      -Djava.security.manager=allow\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp charArr\n+ *      -ms medium\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle11\/TestDescription.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp charArr -ms high\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp charArr\n+ *      -ms high\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle12\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp intArr -ms low\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp intArr\n+ *      -ms low\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle13\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp intArr -ms medium\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp intArr\n+ *      -ms medium\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle14\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp intArr -ms high\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp intArr\n+ *      -ms high\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle15\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp longArr -ms low\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp longArr\n+ *      -ms low\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle16\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp longArr -ms medium\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp longArr\n+ *      -ms medium\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle17\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp longArr -ms high\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp longArr\n+ *      -ms high\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle18\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp floatArr -ms low\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp floatArr\n+ *      -ms low\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle19\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp floatArr -ms medium\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp floatArr\n+ *      -ms medium\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle20\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp floatArr -ms high\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp floatArr\n+ *      -ms high\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle21\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp doubleArr -ms low\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp doubleArr\n+ *      -ms low\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle22\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp doubleArr -ms medium\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp doubleArr\n+ *      -ms medium\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle23\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp doubleArr -ms high\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp doubleArr\n+ *      -ms high\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle24\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp objectArr -ms low\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp objectArr\n+ *      -ms low\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle25\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp objectArr -ms medium\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp objectArr\n+ *      -ms medium\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle26\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,6 @@\n- * @run main\/othervm -Xlog:gc=debug:gc.log gc.ArrayJuggle.Juggle01.Juggle01 -gp objectArr -ms high\n+ * @run main\/othervm\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n+ *      -Xlog:gc=debug:gc.log\n+ *      gc.ArrayJuggle.Juggle01.Juggle01\n+ *      -gp objectArr\n+ *      -ms high\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle27\/TestDescription.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle28\/TestDescription.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle29\/TestDescription.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle30\/TestDescription.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle31\/TestDescription.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle32\/TestDescription.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle33\/TestDescription.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ *      -XX:+HeapDumpOnOutOfMemoryError\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/ArrayJuggle\/Juggle34\/TestDescription.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -237,0 +237,12 @@\n+         private static MethodHandle eat;\n+\n+         static {\n+             try {\n+                 eat = MethodHandles.lookup().findStatic(GarbageUtils.class, \"eatMemoryImpl\", mt);\n+             } catch (Exception nsme) {\n+                 \/\/ Can't run the test for some unexpected reason\n+                 throw new RuntimeException(nsme);\n+             }\n+         }\n+\n+\n@@ -240,2 +252,0 @@\n-               MethodHandles.Lookup lookup = MethodHandles.lookup();\n-               MethodHandle eat = lookup.findStatic(GarbageUtils.class, \"eatMemoryImpl\", mt);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/gp\/GarbageUtils.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java 8298066 windows-x64\n","filename":"test\/jdk\/ProblemList-zgc.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -593,1 +593,0 @@\n-javax\/net\/ssl\/SSLEngine\/Basics.java                             8298867 generic-all\n@@ -675,2 +674,0 @@\n-javax\/swing\/JFileChooser\/8046391\/bug8046391.java 8293862 windows-x64\n-javax\/swing\/JFileChooser\/4847375\/bug4847375.java 8293862 windows-x64\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+    vm.cds.write.archived.java.heap \\\n","filename":"test\/jdk\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.awt.event.MouseAdapter;\n@@ -37,1 +38,3 @@\n-import java.awt.event.*;\n+import java.io.File;\n+import java.util.stream.IntStream;\n+import javax.imageio.ImageIO;\n@@ -39,1 +42,1 @@\n-\/**\n+\/*\n@@ -50,0 +53,1 @@\n+    public static final int OFFSET = 50;\n@@ -51,0 +55,4 @@\n+    private static Robot robot;\n+    private static Frame frame;\n+    private static Rectangle screenBounds;\n+\n@@ -53,0 +61,2 @@\n+        robot = new Robot();\n+        robot.setAutoDelay(200);\n@@ -58,2 +68,1 @@\n-            Rectangle bounds = gc.getBounds();\n-            Point point = new Point(bounds.x, bounds.y);\n+            screenBounds = gc.getBounds();\n@@ -61,3 +70,8 @@\n-            while (point.y < bounds.y + bounds.height - insets.bottom - SIZE) {\n-                while (point.x\n-                        < bounds.x + bounds.width - insets.right - SIZE) {\n+            Point point = new Point(screenBounds.x + insets.left,\n+                                    screenBounds.y + insets.top);\n+            final int yBound = screenBounds.y + screenBounds.height\n+                               - insets.bottom - SIZE;\n+            final int xBound = screenBounds.x + screenBounds.width\n+                               - insets.right - SIZE;\n+            while (point.y < yBound) {\n+                while (point.x < xBound) {\n@@ -65,1 +79,1 @@\n-                    point.translate(bounds.width \/ 5, 0);\n+                    point.translate(screenBounds.width \/ 5, 0);\n@@ -67,1 +81,2 @@\n-                point.setLocation(bounds.x, point.y + bounds.height \/ 5);\n+                point.setLocation(screenBounds.x,\n+                                  point.y + screenBounds.height \/ 5);\n@@ -72,1 +87,2 @@\n-    private static void test(final Point tmp) throws Exception {\n+    private static void test(final Point loc) {\n+        frame = new Frame();\n@@ -74,5 +90,6 @@\n-        for (int i = 1; i < 7; i++) {\n-            pm.add(TEXT + i);\n-        }\n-        pm.addActionListener(e -> action = true);\n-        Frame frame = new Frame();\n+        IntStream.rangeClosed(1, 6).forEach(i -> pm.add(TEXT + i));\n+        pm.addActionListener(e -> {\n+            action = true;\n+            System.out.println(\" Got action event \" + e);\n+        });\n+\n@@ -80,0 +97,1 @@\n+            frame.setUndecorated(true);\n@@ -85,0 +103,1 @@\n+            frame.setLocation(loc);\n@@ -86,1 +105,1 @@\n-            frame.setLocation(tmp.x, tmp.y);\n+\n@@ -108,3 +127,1 @@\n-    private static void openPopup(final Frame frame) throws Exception {\n-        Robot robot = new Robot();\n-        robot.setAutoDelay(200);\n+    private static void openPopup(final Frame frame) {\n@@ -113,1 +130,3 @@\n-        robot.mouseMove(pt.x + frame.getWidth() \/ 2, pt.y + 50);\n+        int x = pt.x + frame.getWidth() \/ 2;\n+        int y = pt.y + OFFSET;\n+        robot.mouseMove(x, y);\n@@ -116,2 +135,2 @@\n-        int x = pt.x + frame.getWidth() \/ 2;\n-        int y = pt.y + 130;\n+        robot.delay(200);\n+        y += OFFSET;\n@@ -123,1 +142,4 @@\n-            throw new RuntimeException();\n+            captureScreen();\n+            throw new RuntimeException(\n+                    \"Failed, didn't receive the PopupMenu ActionEvent on \" +\n+                    \"frame= \" + frame + \", isFocused = \" + frame.isFocused());\n@@ -127,0 +149,11 @@\n+\n+    private static void captureScreen() {\n+        try {\n+            ImageIO.write(robot.createScreenCapture(screenBounds),\n+                          \"png\",\n+                          new File(\"screen.png\"));\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/awt\/PopupMenu\/PopupMenuLocation.java","additions":57,"deletions":24,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.image.ColorModel;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * @test\n+ * @bug 8299772\n+ * @summary \"ColorModel.getRGBdefault()\" should always return the same object\n+ *\/\n+public final class RGBdefaultSingleton {\n+\n+    private static volatile boolean failed;\n+    private static final Map<ColorModel, ?> map =\n+            Collections.synchronizedMap(new IdentityHashMap<>(1));\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread[] ts = new Thread[10];\n+        CountDownLatch latch = new CountDownLatch(ts.length);\n+        for (int i = 0; i < ts.length; i++) {\n+            ts[i] = new Thread(() -> {\n+                latch.countDown();\n+                try {\n+                    ColorModel cm;\n+                    latch.await();\n+                    cm = ColorModel.getRGBdefault();\n+                    map.put(cm, null);\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                    failed = true;\n+                }\n+            });\n+        }\n+        for (Thread t : ts) {\n+            t.start();\n+        }\n+        for (Thread t : ts) {\n+            t.join();\n+        }\n+        if (failed) {\n+            throw new RuntimeException(\"Unexpected exception\");\n+        } else if (map.size() != 1) {\n+            throw new RuntimeException(\"The size of the map != 1\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/image\/ColorModel\/RGBdefaultSingleton.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -43,1 +43,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/LibraryLookupTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestClassLoaderFindNative.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestDowncallScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestDowncallStack.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+        addLayoutConstants(testValues, PlatformLayouts.RISCV64.class);\n","filename":"test\/jdk\/java\/foreign\/TestLayoutEquality.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -48,1 +48,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -60,1 +60,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -72,1 +72,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -84,1 +84,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -95,1 +95,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -106,1 +106,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -117,1 +117,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -128,1 +128,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -140,1 +140,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -152,1 +152,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -164,1 +164,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -176,1 +176,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -188,1 +188,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -200,1 +200,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -212,1 +212,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -224,1 +224,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -236,1 +236,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -248,1 +248,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -260,1 +260,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -273,1 +273,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestMatrix.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -194,0 +194,19 @@\n+    @DataProvider(name = \"scopes\")\n+    public Object[][] scopes() {\n+        return new Object[][] {\n+                { SegmentScope.auto(), false },\n+                { SegmentScope.global(), false },\n+                { Arena.openConfined().scope(), true },\n+                { Arena.openShared().scope(), false }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"scopes\")\n+    public void testIsAccessibleBy(SegmentScope scope, boolean isConfined) {\n+        assertTrue(scope.isAccessibleBy(Thread.currentThread()));\n+        assertTrue(scope.isAccessibleBy(new Thread()) != isConfined);\n+        MemorySegment segment = MemorySegment.ofAddress(0, 0, scope);\n+        assertTrue(segment.scope().isAccessibleBy(Thread.currentThread()));\n+        assertTrue(segment.scope().isAccessibleBy(new Thread()) != isConfined);\n+    }\n+\n@@ -267,1 +286,1 @@\n-        if (segment.scope().isAccessibleBy(Thread.currentThread())) {\n+        if (!segment.scope().isAccessibleBy(Thread.currentThread())) {\n@@ -269,3 +288,1 @@\n-            if (!(e instanceof IllegalStateException)) {\n-                throw e;\n-            }\n+            throw e;\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,543 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Institute of Software, Chinese Academy of Sciences.\n+ * All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @requires sun.arch.data.model == \"64\"\n+ * @modules java.base\/jdk.internal.foreign\n+ *          java.base\/jdk.internal.foreign.abi\n+ *          java.base\/jdk.internal.foreign.abi.riscv64\n+ *          java.base\/jdk.internal.foreign.abi.riscv64.linux\n+ * @build CallArrangerTestBase\n+ * @run testng TestRISCV64CallArranger\n+ *\/\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.StructLayout;\n+import jdk.internal.foreign.abi.Binding;\n+import jdk.internal.foreign.abi.CallingSequence;\n+import jdk.internal.foreign.abi.LinkerOptions;\n+import jdk.internal.foreign.abi.riscv64.linux.LinuxRISCV64CallArranger;\n+import jdk.internal.foreign.abi.StubLocations;\n+import jdk.internal.foreign.abi.VMStorage;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.foreign.Linker.Option.firstVariadicArg;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static jdk.internal.foreign.PlatformLayouts.RISCV64.*;\n+import static jdk.internal.foreign.abi.Binding.*;\n+import static jdk.internal.foreign.abi.riscv64.RISCV64Architecture.*;\n+import static jdk.internal.foreign.abi.riscv64.RISCV64Architecture.Regs.*;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestRISCV64CallArranger extends CallArrangerTestBase {\n+\n+    private static final short STACK_SLOT_SIZE = 8;\n+    private static final VMStorage TARGET_ADDRESS_STORAGE = StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER);\n+    private static final VMStorage RETURN_BUFFER_STORAGE = StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER);\n+\n+    @Test\n+    public void testEmpty() {\n+        MethodType mt = MethodType.methodType(void.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n+        LinuxRISCV64CallArranger.Bindings bindings = LinuxRISCV64CallArranger.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testInteger() {\n+        MethodType mt = MethodType.methodType(void.class,\n+            byte.class, short.class, int.class, int.class,\n+            int.class, int.class, long.class, int.class,\n+            int.class, byte.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+            C_CHAR, C_SHORT, C_INT, C_INT,\n+            C_INT, C_INT, C_LONG, C_INT,\n+            C_INT, C_CHAR);\n+        LinuxRISCV64CallArranger.Bindings bindings = LinuxRISCV64CallArranger.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { cast(byte.class, int.class), vmStore(x10, int.class) },\n+            { cast(short.class, int.class), vmStore(x11, int.class) },\n+            { vmStore(x12, int.class) },\n+            { vmStore(x13, int.class) },\n+            { vmStore(x14, int.class) },\n+            { vmStore(x15, int.class) },\n+            { vmStore(x16, long.class) },\n+            { vmStore(x17, int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 0), int.class) },\n+            { cast(byte.class, int.class), vmStore(stackStorage(STACK_SLOT_SIZE, 8), int.class) }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testTwoIntTwoFloat() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT, C_FLOAT);\n+        LinuxRISCV64CallArranger.Bindings bindings = LinuxRISCV64CallArranger.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(x10, int.class) },\n+            { vmStore(x11, int.class) },\n+            { vmStore(f10, float.class) },\n+            { vmStore(f11, float.class) }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test(dataProvider = \"structs\")\n+    public void testStruct(MemoryLayout struct, Binding[] expectedBindings) {\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct);\n+        LinuxRISCV64CallArranger.Bindings bindings = LinuxRISCV64CallArranger.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            expectedBindings\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @DataProvider\n+    public static Object[][] structs() {\n+        MemoryLayout struct1 = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE, C_INT);\n+        return new Object[][]{\n+            \/\/ struct s { void* a; double c; };\n+            {\n+                MemoryLayout.structLayout(C_POINTER, C_DOUBLE),\n+                new Binding[]{\n+                    dup(),\n+                    bufferLoad(0, long.class), vmStore(x10, long.class),\n+                    bufferLoad(8, long.class), vmStore(x11, long.class)\n+                }\n+            },\n+            \/\/ struct s { int32_t a, b; double c; };\n+            { MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE),\n+                new Binding[]{\n+                    dup(),\n+                    \/\/ s.a & s.b\n+                    bufferLoad(0, long.class), vmStore(x10, long.class),\n+                    \/\/ s.c\n+                    bufferLoad(8, long.class), vmStore(x11, long.class)\n+                }\n+            },\n+            \/\/ struct s { int32_t a, b; double c; int32_t d; };\n+            { struct1,\n+                new Binding[]{\n+                    copy(struct1),\n+                    unboxAddress(),\n+                    vmStore(x10, long.class)\n+                }\n+            },\n+            \/\/ struct s { int32_t a[1]; float b[1]; };\n+            { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(1, C_INT),\n+                MemoryLayout.sequenceLayout(1, C_FLOAT)),\n+                new Binding[]{\n+                    dup(),\n+                    \/\/ s.a[0]\n+                    bufferLoad(0, int.class), vmStore(x10, int.class),\n+                    \/\/ s.b[0]\n+                    bufferLoad(4, float.class), vmStore(f10, float.class)\n+                }\n+            },\n+            \/\/ struct s { float a; \/* padding *\/ double b };\n+            { MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(32), C_DOUBLE),\n+                new Binding[]{\n+                    dup(),\n+                    \/\/ s.a\n+                    bufferLoad(0, float.class), vmStore(f10, float.class),\n+                    \/\/ s.b\n+                    bufferLoad(8, double.class), vmStore(f11, double.class),\n+                }\n+            },\n+            \/\/ struct __attribute__((__packed__)) s { float a; double b; };\n+            { MemoryLayout.structLayout(C_FLOAT, C_DOUBLE),\n+                new Binding[]{\n+                    dup(),\n+                    \/\/ s.a\n+                    bufferLoad(0, float.class), vmStore(f10, float.class),\n+                    \/\/ s.b\n+                    bufferLoad(4, double.class), vmStore(f11, double.class),\n+                }\n+            },\n+            \/\/ struct s { float a; float b __attribute__ ((aligned (8))); }\n+            { MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(32),\n+                C_FLOAT, MemoryLayout.paddingLayout(32)),\n+                new Binding[]{\n+                    dup(),\n+                    \/\/ s.a\n+                    bufferLoad(0, float.class), vmStore(f10, float.class),\n+                    \/\/ s.b\n+                    bufferLoad(8, float.class), vmStore(f11, float.class),\n+                }\n+            }\n+        };\n+    }\n+\n+    @Test\n+    public void testStructFA1() {\n+        MemoryLayout fa = MemoryLayout.structLayout(C_FLOAT, C_FLOAT);\n+\n+        MethodType mt = MethodType.methodType(MemorySegment.class, float.class, int.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.of(fa, C_FLOAT, C_INT, fa);\n+        LinuxRISCV64CallArranger.Bindings bindings = LinuxRISCV64CallArranger.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(f10, float.class) },\n+            { vmStore(x10, int.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, float.class),\n+                vmStore(f11, float.class),\n+                bufferLoad(4, float.class),\n+                vmStore(f12, float.class)\n+            }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{\n+            allocate(fa),\n+            dup(),\n+            vmLoad(f10, float.class),\n+            bufferStore(0, float.class),\n+            dup(),\n+            vmLoad(f11, float.class),\n+            bufferStore(4, float.class)\n+        });\n+    }\n+\n+    @Test\n+    public void testStructFA2() {\n+        MemoryLayout fa = MemoryLayout.structLayout(C_FLOAT, C_DOUBLE);\n+\n+        MethodType mt = MethodType.methodType(MemorySegment.class, float.class, int.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.of(fa, C_FLOAT, C_INT, fa);\n+        LinuxRISCV64CallArranger.Bindings bindings = LinuxRISCV64CallArranger.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(f10, float.class) },\n+            { vmStore(x10, int.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, float.class),\n+                vmStore(f11, float.class),\n+                bufferLoad(4, double.class),\n+                vmStore(f12, double.class)\n+            }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{\n+            allocate(fa),\n+            dup(),\n+            vmLoad(f10, float.class),\n+            bufferStore(0, float.class),\n+            dup(),\n+            vmLoad(f11, double.class),\n+            bufferStore(4, double.class)\n+        });\n+    }\n+\n+    @Test\n+    void spillFloatingPointStruct() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_FLOAT, C_FLOAT);\n+        \/\/ void f(float, float, float, float, float, float, float, struct)\n+        MethodType mt = MethodType.methodType(void.class, float.class, float.class,\n+            float.class, float.class, float.class,\n+            float.class, float.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT,\n+            C_FLOAT, C_FLOAT, C_FLOAT, struct);\n+        LinuxRISCV64CallArranger.Bindings bindings = LinuxRISCV64CallArranger.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(f10, float.class) },\n+            { vmStore(f11, float.class) },\n+            { vmStore(f12, float.class) },\n+            { vmStore(f13, float.class) },\n+            { vmStore(f14, float.class) },\n+            { vmStore(f15, float.class) },\n+            { vmStore(f16, float.class) },\n+            {\n+                bufferLoad(0, long.class),\n+                vmStore(x10, long.class)\n+            }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testStructBoth() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_INT, C_FLOAT);\n+\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, struct, struct);\n+        LinuxRISCV64CallArranger.Bindings bindings = LinuxRISCV64CallArranger.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, int.class),\n+                vmStore(x10, int.class),\n+                bufferLoad(4, float.class),\n+                vmStore(f10, float.class)\n+            },\n+            {\n+                dup(),\n+                bufferLoad(0, int.class),\n+                vmStore(x11, int.class),\n+                bufferLoad(4, float.class),\n+                vmStore(f11, float.class)\n+            },\n+            {\n+                dup(),\n+                bufferLoad(0, int.class),\n+                vmStore(x12, int.class),\n+                bufferLoad(4, float.class),\n+                vmStore(f12, float.class)\n+            }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testStructStackSpill() {\n+        \/\/ A large (> 16 byte) struct argument that is spilled to the\n+        \/\/ stack should be passed as a pointer to a copy and occupy one\n+        \/\/ stack slot.\n+\n+        MemoryLayout struct = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE, C_INT);\n+\n+        MethodType mt = MethodType.methodType(\n+            void.class, MemorySegment.class, MemorySegment.class, int.class, int.class,\n+            int.class, int.class, int.class, int.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+            struct, struct, C_INT, C_INT, C_INT, C_INT, C_INT, C_INT, struct, C_INT);\n+        LinuxRISCV64CallArranger.Bindings bindings = LinuxRISCV64CallArranger.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { copy(struct), unboxAddress(), vmStore(x10, long.class) },\n+            { copy(struct), unboxAddress(), vmStore(x11, long.class) },\n+            { vmStore(x12, int.class) },\n+            { vmStore(x13, int.class) },\n+            { vmStore(x14, int.class) },\n+            { vmStore(x15, int.class) },\n+            { vmStore(x16, int.class) },\n+            { vmStore(x17, int.class) },\n+            { copy(struct), unboxAddress(), vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 8), int.class) }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testVarArgsInRegs() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT);\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT, C_INT, C_FLOAT);\n+        LinuxRISCV64CallArranger.Bindings bindings = LinuxRISCV64CallArranger.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        \/\/ This is identical to the non-variadic calling sequence\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(x10, int.class) },\n+            { vmStore(x11, int.class) },\n+            { vmStore(x12, float.class) }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testVarArgsLong() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, int.class, double.class,\n+            double.class, long.class, long.class, int.class,\n+            double.class, double.class, long.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_DOUBLE, C_DOUBLE,\n+            C_LONG, C_LONG, C_INT, C_DOUBLE,\n+            C_DOUBLE, C_LONG);\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT, C_INT, C_INT, C_DOUBLE,\n+            C_DOUBLE, C_LONG, C_LONG, C_INT,\n+            C_DOUBLE, C_DOUBLE, C_LONG);\n+        LinuxRISCV64CallArranger.Bindings bindings = LinuxRISCV64CallArranger.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        \/\/ This is identical to the non-variadic calling sequence\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(x10, int.class) },\n+            { vmStore(x11, int.class) },\n+            { vmStore(x12, int.class) },\n+            { vmStore(x13, double.class) },\n+            { vmStore(x14, double.class) },\n+            { vmStore(x15, long.class) },\n+            { vmStore(x16, long.class) },\n+            { vmStore(x17, int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 0), double.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 8), double.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 16), long.class) }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testReturnStruct1() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_LONG, C_LONG, C_FLOAT);\n+\n+        MethodType mt = MethodType.methodType(MemorySegment.class, int.class, int.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.of(struct, C_INT, C_INT, C_FLOAT);\n+        LinuxRISCV64CallArranger.Bindings bindings = LinuxRISCV64CallArranger.getBindings(mt, fd, false);\n+\n+        assertTrue(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(),\n+            MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class,\n+                int.class, int.class, float.class));\n+        assertEquals(callingSequence.functionDesc(),\n+            FunctionDescriptor.ofVoid(ADDRESS, C_POINTER, C_INT, C_INT, C_FLOAT));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { unboxAddress(), vmStore(x10, long.class) },\n+            { vmStore(x11, int.class) },\n+            { vmStore(x12, int.class) },\n+            { vmStore(f10, float.class) }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testReturnStruct2() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_LONG, C_LONG);\n+\n+        MethodType mt = MethodType.methodType(MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.of(struct);\n+        LinuxRISCV64CallArranger.Bindings bindings = LinuxRISCV64CallArranger.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{\n+            allocate(struct),\n+            dup(),\n+            vmLoad(x10, long.class),\n+            bufferStore(0, long.class),\n+            dup(),\n+            vmLoad(x11, long.class),\n+            bufferStore(8, long.class)\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestRISCV64CallArranger.java","additions":543,"deletions":0,"binary":false,"changes":543,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/dontrelease\/TestDontRelease.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessDynamic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/handles\/Driver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookupJNI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/normalize\/TestNormalize.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/passheapsegment\/TestPassHeapSegment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -45,1 +45,1 @@\n- * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\")\n+ * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\")\n@@ -64,1 +64,1 @@\n- * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\")\n+ * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\")\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n@@ -45,1 +45,1 @@\n- * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\")\n+ * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\")\n@@ -64,1 +64,1 @@\n- * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\")\n+ * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\")\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,319 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8299576\n+ * @summary Verify that reads and writes of primitives are correct\n+ * @compile\/module=java.base java\/io\/BitsProxy.java\n+ * @run junit ReadWriteValues\n+ *\/\n+\n+import java.io.BitsProxy;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.*;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class ReadWriteValues {\n+\n+    \/\/ Makes sure unaligned read\/write can be made.\n+    private static final int OFFSET = 1;\n+\n+    private static final byte[] BUFF = new byte[Long.BYTES + OFFSET];\n+\n+    private static final int ITERATIONS = 1 << 10;\n+\n+    @Test\n+    void testGetShort() {\n+        longs().forEach(l -> {\n+            short expected = (short) l;\n+            RefImpl.putShort(BUFF, OFFSET, expected);\n+            short actual = BitsProxy.getShort(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutShort() {\n+        longs().forEach(l -> {\n+            short expected = (short) l;\n+            BitsProxy.putShort(BUFF, OFFSET, expected);\n+            short actual = RefImpl.getShort(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetChar() {\n+        longs().forEach(l -> {\n+            char expected = (char) l;\n+            RefImpl.putChar(BUFF, OFFSET, expected);\n+            char actual = BitsProxy.getChar(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutChar() {\n+        longs().forEach(l -> {\n+            char expected = (char) l;\n+            BitsProxy.putChar(BUFF, OFFSET, expected);\n+            char actual = RefImpl.getChar(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetInt() {\n+        longs().forEach(l -> {\n+            int expected = (int) l;\n+            RefImpl.putInt(BUFF, OFFSET, expected);\n+            int actual = BitsProxy.getInt(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutInt() {\n+        longs().forEach(l -> {\n+            int expected = (int) l;\n+            BitsProxy.putInt(BUFF, OFFSET, expected);\n+            int actual = RefImpl.getInt(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetLong() {\n+        longs().forEach(expected -> {\n+            RefImpl.putLong(BUFF, OFFSET, expected);\n+            long actual = BitsProxy.getLong(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutLong() {\n+        longs().forEach(expected -> {\n+            BitsProxy.putLong(BUFF, OFFSET, expected);\n+            long actual = RefImpl.getLong(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetFloat() {\n+        floats().forEach(expected -> {\n+            RefImpl.putFloat(BUFF, OFFSET, expected);\n+            float actual = BitsProxy.getFloat(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutFloat() {\n+        floats().forEach(expected -> {\n+            BitsProxy.putFloat(BUFF, OFFSET, expected);\n+            float actual = RefImpl.getFloat(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testGetDouble() {\n+        doubles().forEach(expected -> {\n+            RefImpl.putDouble(BUFF, OFFSET, expected);\n+            double actual = BitsProxy.getDouble(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    @Test\n+    void testPutDouble() {\n+        doubles().forEach(expected -> {\n+            BitsProxy.putDouble(BUFF, OFFSET, expected);\n+            double actual = RefImpl.getDouble(BUFF, OFFSET);\n+            assertEquals(expected, actual);\n+        });\n+    }\n+\n+    \/\/ Unusual cases\n+\n+    @Test\n+    void testNullArray() {\n+        assertThrowsOriginal(NullPointerException.class, () -> BitsProxy.getInt(null, OFFSET));\n+        assertThrowsOriginal(NullPointerException.class, () -> BitsProxy.putInt(null, OFFSET, 1));\n+    }\n+\n+    @Test\n+    void testNegArg() {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> BitsProxy.getInt(BUFF, -1));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> BitsProxy.putInt(BUFF, -1, 1));\n+    }\n+\n+    @Test\n+    void testOutOfBounds() {\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> BitsProxy.getInt(BUFF, BUFF.length));\n+        assertThrowsOriginal(IndexOutOfBoundsException.class, () -> BitsProxy.putInt(BUFF, BUFF.length, 1));\n+    }\n+\n+    static LongStream longs() {\n+        return ThreadLocalRandom.current().longs(ITERATIONS);\n+    }\n+\n+    static DoubleStream doubles() {\n+        return DoubleStream.concat(\n+                ThreadLocalRandom.current().doubles(ITERATIONS),\n+                DoubleStream.of(Double.NaN,\n+                        Double.NEGATIVE_INFINITY,\n+                        Double.POSITIVE_INFINITY,\n+                        Double.MAX_VALUE,\n+                        Double.MIN_VALUE,\n+                        -0.0d\n+                        +0.0d)\n+        );\n+    }\n+    static Stream<Float> floats() {\n+        return Stream.concat(\n+                ThreadLocalRandom.current().doubles(ITERATIONS).mapToObj(d -> (float)d),\n+                Stream.of(Float.NaN,\n+                        Float.NEGATIVE_INFINITY,\n+                        Float.POSITIVE_INFINITY,\n+                        Float.MAX_VALUE,\n+                        Float.MIN_VALUE,\n+                        -0.0f\n+                        +0.0f)\n+        );\n+    }\n+\n+    @FunctionalInterface\n+    interface ThrowingRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    <X extends Exception> void assertThrowsOriginal(Class<X> type,\n+                                                    ThrowingRunnable runnable) {\n+        try {\n+            runnable.run();\n+        } catch (Exception e) {\n+            if (type.isInstance(e)) {\n+                return;\n+            }\n+            if (type.isInstance(e.getCause())) {\n+                return;\n+            }\n+            throw new AssertionError(e);\n+        }\n+\n+    }\n+\n+    \/**\n+    * Reference implementation from the old java.io.Bits implementation\n+    *\/\n+    private static final class RefImpl {\n+        private RefImpl() {}\n+\n+        static char getChar(byte[] b, int off) {\n+            return (char) ((b[off + 1] & 0xFF) +\n+                    (b[off] << 8));\n+        }\n+\n+        static short getShort(byte[] b, int off) {\n+            return (short) ((b[off + 1] & 0xFF) +\n+                    (b[off] << 8));\n+        }\n+\n+        static int getInt(byte[] b, int off) {\n+            return ((b[off + 3] & 0xFF)) +\n+                    ((b[off + 2] & 0xFF) << 8) +\n+                    ((b[off + 1] & 0xFF) << 16) +\n+                    ((b[off]) << 24);\n+        }\n+\n+        static float getFloat(byte[] b, int off) {\n+            return Float.intBitsToFloat(getInt(b, off));\n+        }\n+\n+        static long getLong(byte[] b, int off) {\n+            return ((b[off + 7] & 0xFFL)) +\n+                    ((b[off + 6] & 0xFFL) << 8) +\n+                    ((b[off + 5] & 0xFFL) << 16) +\n+                    ((b[off + 4] & 0xFFL) << 24) +\n+                    ((b[off + 3] & 0xFFL) << 32) +\n+                    ((b[off + 2] & 0xFFL) << 40) +\n+                    ((b[off + 1] & 0xFFL) << 48) +\n+                    (((long) b[off]) << 56);\n+        }\n+\n+        static double getDouble(byte[] b, int off) {\n+            return Double.longBitsToDouble(getLong(b, off));\n+        }\n+\n+        \/*\n+         * Methods for packing primitive values into byte arrays starting at given\n+         * offsets.\n+         *\/\n+\n+        static void putChar(byte[] b, int off, char val) {\n+            b[off + 1] = (byte) (val);\n+            b[off] = (byte) (val >>> 8);\n+        }\n+\n+        static void putShort(byte[] b, int off, short val) {\n+            b[off + 1] = (byte) (val);\n+            b[off] = (byte) (val >>> 8);\n+        }\n+\n+        static void putInt(byte[] b, int off, int val) {\n+            b[off + 3] = (byte) (val);\n+            b[off + 2] = (byte) (val >>> 8);\n+            b[off + 1] = (byte) (val >>> 16);\n+            b[off] = (byte) (val >>> 24);\n+        }\n+\n+        static void putFloat(byte[] b, int off, float val) {\n+            putInt(b, off, Float.floatToIntBits(val));\n+        }\n+\n+        static void putLong(byte[] b, int off, long val) {\n+            b[off + 7] = (byte) (val);\n+            b[off + 6] = (byte) (val >>> 8);\n+            b[off + 5] = (byte) (val >>> 16);\n+            b[off + 4] = (byte) (val >>> 24);\n+            b[off + 3] = (byte) (val >>> 32);\n+            b[off + 2] = (byte) (val >>> 40);\n+            b[off + 1] = (byte) (val >>> 48);\n+            b[off] = (byte) (val >>> 56);\n+        }\n+\n+        static void putDouble(byte[] b, int off, double val) {\n+            putLong(b, off, Double.doubleToLongBits(val));\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/io\/Bits\/ReadWriteValues.java","additions":319,"deletions":0,"binary":false,"changes":319,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.io;\n+\n+\/**\n+ * Class to allow public access to package-private methods.\n+ *\/\n+public final class BitsProxy {\n+\n+    public static boolean getBoolean(byte[] b, int off) {\n+        return Bits.getBoolean(b, off);\n+    }\n+\n+    public static char getChar(byte[] b, int off) {\n+        return Bits.getChar(b, off);\n+    }\n+\n+    public static short getShort(byte[] b, int off) {\n+        return Bits.getShort(b, off);\n+    }\n+\n+    public static int getInt(byte[] b, int off) {\n+        return Bits.getInt(b, off);\n+    }\n+\n+    public static float getFloat(byte[] b, int off) {\n+        return Bits.getFloat(b, off);\n+    }\n+\n+    public static long getLong(byte[] b, int off) {\n+        return Bits.getLong(b, off);\n+    }\n+\n+    public static double getDouble(byte[] b, int off) {\n+        return Bits.getDouble(b, off);\n+    }\n+\n+\n+    public static void putBoolean(byte[] b, int off, boolean val) {\n+        Bits.putBoolean(b, off, val);\n+    }\n+\n+    public static void putChar(byte[] b, int off, char val) {\n+        Bits.putChar(b, off, val);\n+    }\n+\n+    public static void putShort(byte[] b, int off, short val) {\n+        Bits.putShort(b, off, val);\n+    }\n+\n+    public static void putInt(byte[] b, int off, int val) {\n+        Bits.putInt(b, off, val);\n+    }\n+\n+    public static void putFloat(byte[] b, int off, float val) {\n+        Bits.putFloat(b, off, val);\n+    }\n+\n+    public static void putLong(byte[] b, int off, long val) {\n+        Bits.putLong(b, off, val);\n+    }\n+\n+    public static void putDouble(byte[] b, int off, double val) {\n+        Bits.putDouble(b, off, val);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/io\/Bits\/java.base\/java\/io\/BitsProxy.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-   @summary Basic test for listRoots method\n+   @summary Basic test for File.listRoots method\n@@ -29,2 +29,8 @@\n-import java.io.*;\n-\n+import java.io.File;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n@@ -40,2 +46,1 @@\n-        File f = new File(System.getProperty(\"test.src\", \".\"),\n-                          \"ListRoots.java\");\n+        File f = new File(System.getProperty(\"test.src\", \".\"), \"ListRoots.java\");\n@@ -43,4 +48,5 @@\n-        for (int i = 0; i < rs.length; i++) {\n-            if (cp.startsWith(rs[i].getPath())) break;\n-            if (i == rs.length - 1)\n-                throw new Exception(cp + \" does not have a recognized root\");\n+        boolean found = Stream.of(rs)\n+                .map(File::getPath)\n+                .anyMatch(p -> cp.startsWith(p));\n+        if (!found) {\n+            throw new RuntimeException(cp + \" does not have a recognized root\");\n@@ -49,0 +55,10 @@\n+        \/\/ the list of roots should match FileSystem::getRootDirectories\n+        Set<File> roots1 = Stream.of(rs).collect(Collectors.toSet());\n+        FileSystem fs = FileSystems.getDefault();\n+        Set<File> roots2 = StreamSupport.stream(fs.getRootDirectories().spliterator(), false)\n+                .map(Path::toFile)\n+                .collect(Collectors.toSet());\n+        if (!roots1.equals(roots2)) {\n+            System.out.println(roots2);\n+            throw new RuntimeException(\"Does not match FileSystem::getRootDirectories\");\n+        }\n","filename":"test\/jdk\/java\/io\/File\/ListRoots.java","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Basic hashCode functionality and stability\n+ * @run main\/othervm -XX:+CompactStrings HashCode\n+ * @run main\/othervm -XX:-CompactStrings HashCode\n+ *\/\n+\n+public class HashCode {\n+    private static String [] tests = { \"\", \" \", \"a\", \"\",\n+                                       \"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair, we had everything before us, we had nothing before us, we were all going direct to Heaven, we were all going direct the other way- in short, the period was so far like the present period, that some of its noisiest authorities insisted on its being received, for good or for evil, in the superlative degree of comparison only.  -- Charles Dickens, Tale of Two Cities\",\n+                                       \"C'tait le meilleur des temps, c'tait le pire des temps, c'tait l'ge de la sagesse, c'tait l'ge de la folie, c'tait l'poque de la croyance, c'tait l'poque de l'incrdulit, c'tait la saison de la Lumire, c'tait C'tait la saison des Tnbres, c'tait le printemps de l'espoir, c'tait l'hiver du dsespoir, nous avions tout devant nous, nous n'avions rien devant nous, nous allions tous directement au Ciel, nous allions tous directement dans l'autre sens bref, la priode ressemblait tellement  la priode actuelle, que certaines de ses autorits les plus bruyantes ont insist pour qu'elle soit reue, pour le bien ou pour le mal, au degr superlatif de la comparaison seulement. -- Charles Dickens, Tale of Two Cities (in French)\",\n+                                       \"\",\n+                                       \"\"\n+    };\n+\n+    private static int [] expected = { 0, 32, 97, 229, 1094896285, -331808333, 31109, 349367663 };\n+\n+    public static void main(String [] args) throws Exception {\n+        for (int j = 0; j < 20_000; j++) {\n+            for (int i = 0; i < tests.length; i++) {\n+                \/\/ Force use of a new String without cached hash\n+                String s = new String(tests[i].getBytes(\"UTF-8\"), \"UTF-8\");\n+                int e = expected[i];\n+                int hashCode = s.hashCode();\n+                if (hashCode != e)\n+                    throw new RuntimeException(\"String \\\"\" + s + \"\\\": \"\n+                            + \" e = \" + e\n+                            + \", hashCode = \" + hashCode\n+                            + \", repetition = \" + j);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/HashCode.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8142968 8300228\n@@ -67,1 +68,0 @@\n-@Test\n@@ -69,1 +69,0 @@\n-\n@@ -113,0 +112,6 @@\n+\n+        \/\/ junk resource names\n+        \"java\\u0000\",\n+        \"C:java\",\n+        \"C:\\\\java\",\n+        \"java\\\\lang\\\\Object.class\"\n@@ -139,2 +144,1 @@\n-        \"p\/..\/p\/Main.class\"\n-    };\n+        \"p\/..\/p\/Main.class\",\n@@ -142,0 +146,6 @@\n+        \/\/ junk resource names\n+        \"p\\u0000\",\n+        \"C:p\",\n+        \"C:\\\\p\",\n+        \"p\\\\Main.class\"\n+    };\n@@ -145,1 +155,0 @@\n-\n@@ -147,3 +156,2 @@\n-        boolean compiled\n-            = CompilerUtils.compile(SRC_DIR.resolve(TEST_MODULE),\n-                                    MODS_DIR.resolve(TEST_MODULE));\n+        boolean compiled = CompilerUtils.compile(SRC_DIR.resolve(TEST_MODULE),\n+                                                 MODS_DIR.resolve(TEST_MODULE));\n@@ -153,1 +161,0 @@\n-\n@@ -155,1 +162,1 @@\n-     * Test ModuleReader to module in runtime image\n+     * Test ModuleReader with module in runtime image.\n@@ -157,0 +164,1 @@\n+    @Test\n@@ -158,1 +166,0 @@\n-\n@@ -230,1 +237,0 @@\n-\n@@ -232,1 +238,1 @@\n-     * Test ModuleReader to exploded module\n+     * Test ModuleReader with exploded module.\n@@ -234,0 +240,1 @@\n+    @Test\n@@ -238,1 +245,0 @@\n-\n@@ -240,1 +246,1 @@\n-     * Test ModuleReader to modular JAR\n+     * Test ModuleReader with module in modular JAR.\n@@ -242,0 +248,1 @@\n+    @Test\n@@ -252,1 +259,0 @@\n-\n@@ -254,1 +260,1 @@\n-     * Test ModuleReader to JMOD\n+     * Test ModuleReader with module in a JMOD file.\n@@ -256,0 +262,1 @@\n+    @Test\n@@ -272,1 +279,0 @@\n-\n@@ -278,1 +284,0 @@\n-\n@@ -287,0 +292,1 @@\n+                System.out.println(\"resource: \" + name);\n@@ -300,1 +306,1 @@\n-                System.out.println(name);\n+                System.out.println(\"resource: \" + name);\n@@ -310,0 +316,1 @@\n+                System.out.println(\"resource: \" + name);\n","filename":"test\/jdk\/java\/lang\/module\/ModuleReader\/ModuleReaderTest.java","additions":28,"deletions":21,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,2 @@\n+\n+import jdk.internal.net.http.common.OperationTrackers.Tracker;\n@@ -95,0 +97,2 @@\n+    static final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+\n@@ -133,1 +137,1 @@\n-                                         .build();\n+                    .build();\n@@ -138,0 +142,19 @@\n+\n+            \/\/ if sameClient we will reuse the client for the next\n+            \/\/ operation, so there's nothing more to do.\n+            if (sameClient) continue;\n+\n+            \/\/ if no error and not same client then wait for the\n+            \/\/ client to be GC'ed before performing the nex operation\n+            Tracker tracker = TRACKER.getTracker(client);\n+            client = null;\n+            System.gc();\n+            AssertionError error = TRACKER.check(tracker, 1500);\n+            if (error != null) throw error; \/\/ the client didn't shut down properly\n+        }\n+        if (sameClient) {\n+            Tracker tracker = TRACKER.getTracker(client);\n+            client = null;\n+            System.gc();\n+            AssertionError error = TRACKER.check(tracker,1500);\n+            if (error != null) throw error; \/\/ the client didn't shut down properly\n","filename":"test\/jdk\/java\/net\/httpclient\/MappingResponseSubscriber.java","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Basic array hashCode functionality\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.util=ALL-UNNAMED -Xcomp -Xbatch HashCode\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+public class HashCode {\n+    private static String[] tests = { \"\", \" \", \"a\", \"abcdefg\",\n+            \"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair, we had everything before us, we had nothing before us, we were all going direct to Heaven, we were all going direct the other way- in short, the period was so far like the present period, that some of its noisiest authorities insisted on its being received, for good or for evil, in the superlative degree of comparison only.  -- Charles Dickens, Tale of Two Cities\",\n+            \"C'tait le meilleur des temps, c'tait le pire des temps, c'tait l'ge de la sagesse, c'tait l'ge de la folie, c'tait l'poque de la croyance, c'tait l'poque de l'incrdulit, c'tait la saison de la Lumire, c'tait C'tait la saison des Tnbres, c'tait le printemps de l'espoir, c'tait l'hiver du dsespoir, nous avions tout devant nous, nous n'avions rien devant nous, nous allions tous directement au Ciel, nous allions tous directement dans l'autre sens bref, la priode ressemblait tellement  la priode actuelle, que certaines de ses autorits les plus bruyantes ont insist pour qu'elle soit reue, pour le bien ou pour le mal, au degr superlatif de la comparaison seulement. -- Charles Dickens, Tale of Two Cities (in French)\",\n+            \"\"\n+    };\n+\n+    byte[][] zeroes = new byte[64][];\n+    private static byte[][] testBytes = new byte[tests.length][];\n+    private static short[][] testShorts = new short[tests.length][];\n+    private static char[][] testChars = new char[tests.length][];\n+    private static int[][] testInts = new int[tests.length][];\n+\n+    private static int[] expected = { 1, 63, 128, 536518979, -1174896354, -1357593156, 428276276};\n+    private static int[] expectedUnsigned = { 1, 63, 128, 536518979, -1174896354, 584369596, -2025326028};\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Deep introspection into range-based hash functions\n+        Class<?> arraysSupport = Class.forName(\"jdk.internal.util.ArraysSupport\");\n+        Method vectorizedHashCode = arraysSupport.getDeclaredMethod(\"vectorizedHashCode\", Object.class, int.class, int.class, int.class, int.class);\n+        vectorizedHashCode.setAccessible(true);\n+\n+        for (int i = 0; i < tests.length; i++) {\n+            testBytes[i] = tests[i].getBytes(\"UTF-8\");\n+            int len = testBytes[i].length;\n+            testChars[i] = new char[len];\n+            testShorts[i] = new short[len];\n+            testInts[i] = new int[len];\n+            for (int j = 0; j < len; j++) {\n+                testChars[i][j] = (char) testBytes[i][j];\n+                testShorts[i][j] = testBytes[i][j];\n+                testInts[i][j] = testBytes[i][j];\n+            }\n+        }\n+\n+        boolean failed = false;\n+        try {\n+            int zeroResult = 1;\n+            for (int i = 0; i < 64; i++) {\n+                byte[] zeroes = new byte[i];\n+                byte[] extraZeroes = new byte[i + 47];\n+                for (int j = 0; j < 10_000; j++) {\n+                    int hashCode = Arrays.hashCode(zeroes);\n+                    if (hashCode != zeroResult) {\n+                        throw new RuntimeException(\"byte[] \\\"\" + Arrays.toString(zeroes) + \"\\\": \"\n+                                + \" e = \" + zeroResult\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n+                    hashCode = (int) vectorizedHashCode.invoke(null, extraZeroes, 17, i, 1, \/* ArraysSupport.T_BYTE *\/ 8);\n+                    if (hashCode != zeroResult) {\n+                        throw new RuntimeException(\"byte[] subrange \\\"\" + Arrays.toString(extraZeroes)\n+                                + \"\\\" at offset 17, limit \" + i + \": \"\n+                                + \" e = \" + zeroResult\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n+                }\n+                zeroResult *= 31;\n+            }\n+            for (int i = 0; i < tests.length; i++) {\n+                for (int j = 0; j < 64; j++) {\n+                    int e = expected[i];\n+                    int hashCode = Arrays.hashCode(testBytes[i]);\n+                    if (hashCode != e) {\n+                        throw new RuntimeException(\"byte[] \\\"\" + Arrays.toString(testBytes[i]) + \"\\\": \"\n+                                + \" e = \" + e\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n+                }\n+            }\n+            System.out.println(\"byte[] tests passed\");\n+        } catch (RuntimeException e) {\n+            System.out.println(e.getMessage());\n+            failed = true;\n+        }\n+\n+        try {\n+            for (int i = 0; i < tests.length; i++) {\n+                for (int j = 0; j < 64; j++) {\n+                    int e = expected[i];\n+                    int hashCode = Arrays.hashCode(testShorts[i]);\n+                    if (hashCode != e) {\n+                        throw new RuntimeException(\"short[] \\\"\" + Arrays.toString(testShorts[i]) + \"\\\": \"\n+                                + \" e = \" + e\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n+                }\n+            }\n+            System.out.println(\"short[] tests passed\");\n+        } catch (RuntimeException e) {\n+            System.out.println(e.getMessage());\n+            failed = true;\n+        }\n+\n+        try {\n+            for (int i = 0; i < tests.length; i++) {\n+                for (int j = 0; j < 64; j++) {\n+                    int e = expected[i];\n+                    int hashCode = Arrays.hashCode(testInts[i]);\n+                    if (hashCode != e) {\n+                        throw new RuntimeException(\"int[] \\\"\" + Arrays.toString(testInts[i]) + \"\\\": \"\n+                                + \" e = \" + e\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n+                }\n+            }\n+            System.out.println(\"int[] tests passed\");\n+        } catch (RuntimeException e) {\n+            System.out.println(e.getMessage());\n+            failed = true;\n+        }\n+\n+        try {\n+            for (int i = 0; i < tests.length; i++) {\n+                for (int j = 0; j < 64; j++) {\n+                    int e = expectedUnsigned[i];\n+                    int hashCode = Arrays.hashCode(testChars[i]);\n+                    if (hashCode != e) {\n+                        throw new RuntimeException(\"char[] \\\"\" + Arrays.toString(testChars[i]) + \"\\\": \"\n+                                + \" e = \" + e\n+                                + \", hashCode = \" + hashCode\n+                                + \", repetition = \" + j);\n+                    }\n+                }\n+            }\n+            System.out.println(\"char[] tests passed\");\n+        } catch (RuntimeException e) {\n+            System.out.println(e.getMessage());\n+            failed = true;\n+        }\n+\n+        if (failed) {\n+            throw new RuntimeException(\"Some tests failed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Arrays\/HashCode.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/PluggableLocale\/providersrc\/barprovider\/com\/bar\/LocaleNames.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/PluggableLocale\/providersrc\/barprovider\/com\/bar\/LocaleNames_ja.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/PluggableLocale\/providersrc\/barprovider\/com\/bar\/LocaleNames_ja_JP_kyoto.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/PluggableLocale\/providersrc\/barprovider\/com\/bar\/LocaleNames_ja_JP_osaka.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/PluggableLocale\/providersrc\/barprovider\/com\/bar\/LocaleNames_xx.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/Properties\/Bug6609431.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Bug4083270Test.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Bug4177489_Resource_jf_JF.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Bug6190861Data.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Bug6190861Data_en_US.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Bug6204853.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Bug6204853_Utf8.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Bug6356571.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Control\/Bug6530694_de_DE.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Control\/Chinese.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Control\/Chinese_zh.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Control\/Chinese_zh_CN.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Control\/Chinese_zh_TW.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Control\/MalformedDataRB_en.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Control\/StressOut.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Control\/StressOut_en_CA.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Control\/StressOut_ja.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Control\/StressOut_ja_JP.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Control\/StressOut_ko.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Control\/StressOut_zh_CN.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/KeySetResources.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/KeySetResources_ja_JP.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/RB4353454_en.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/ReferencesTestBundle.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Test4314141A.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Test4314141A_.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Test4314141A__DE.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Test4314141A___EURO.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Test4314141A_de.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Test4314141A_de_.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Test4314141B_en.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Test4314141B_fr.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Test4314141B_fr_CH.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Test4318520RB_de.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Test4318520RB_en.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/bug4195978Test.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/logging\/bundlesearch\/ClassPathTestBundle_en.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/logging\/bundlesearch\/resources\/CallerSearchableResource_en.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/logging\/bundlesearch\/resources\/ContextClassLoaderTestBundle_en.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/logging\/bundlesearch\/resources\/StackSearchableResource_en.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-# \"handlers\" specifies a comma separated list of log Handler \n+# \"handlers\" specifies a comma separated list of log Handler\n@@ -42,1 +42,1 @@\n-# Example to customize the SimpleFormatter output format \n+# Example to customize the SimpleFormatter output format\n","filename":"test\/jdk\/java\/util\/logging\/modules\/LogManagerInModule\/logging.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# \n+#\n@@ -4,1 +4,1 @@\n-# \n+#\n@@ -8,1 +8,1 @@\n-# \n+#\n@@ -14,1 +14,1 @@\n-# \n+#\n@@ -18,1 +18,1 @@\n-# \n+#\n","filename":"test\/jdk\/java\/util\/spi\/ResourceBundleControlProvider\/simple.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-#   deserialization of parameters sent to the JMX default agent to validate the \n+#   deserialization of parameters sent to the JMX default agent to validate the\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/connection\/mgmt1.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-#   deserialization of parameters sent to the JMX default agent to validate the \n+#   deserialization of parameters sent to the JMX default agent to validate the\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/connection\/mgmt2.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLEngine\/Arrays.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- *\n@@ -33,0 +32,1 @@\n+ * @library \/test\/lib\n@@ -34,0 +34,1 @@\n+ * @run main\/othervm Basics\n@@ -39,0 +40,1 @@\n+import java.util.Arrays;\n@@ -42,0 +44,2 @@\n+import jdk.test.lib.security.SecurityUtils;\n+\n@@ -44,4 +48,10 @@\n-    private static String pathToStores = \"..\/etc\";\n-    private static String keyStoreFile = \"keystore\";\n-    private static String trustStoreFile = \"truststore\";\n-    private static String passwd = \"passphrase\";\n+    private static final String PATH_TO_STORES = \"..\/etc\";\n+    private static final String KEY_STORE_FILE = \"keystore\";\n+    private static final String TRUSTSTORE_FILE = \"truststore\";\n+\n+    private static final String KEYSTORE_PATH =\n+            System.getProperty(\"test.src\", \".\/\") + \"\/\" + PATH_TO_STORES +\n+                \"\/\" + KEY_STORE_FILE;\n+    private static final String TRUSTSTORE_PATH =\n+            System.getProperty(\"test.src\", \".\/\") + \"\/\" + PATH_TO_STORES +\n+                \"\/\" + TRUSTSTORE_FILE;\n@@ -49,6 +59,7 @@\n-    private static String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-    private static String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n+    public static void main(String[] args) throws Exception {\n+        SecurityUtils.removeFromDisabledTlsAlgs(\"TLSv1.1\");\n+\n+        runTest(\"TLSv1.3\", \"TLS_AES_256_GCM_SHA384\");\n+        runTest(\"TLSv1.2\", \"TLS_RSA_WITH_AES_256_GCM_SHA384\");\n+        runTest(\"TLSv1.1\", \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA\");\n+    }\n@@ -56,1 +67,2 @@\n-    public static void main(String args[]) throws Exception {\n+    private static void runTest(String protocol, String cipherSuite) throws Exception {\n+        System.out.printf(\"Testing %s with %s%n\", protocol, cipherSuite);\n@@ -62,2 +74,2 @@\n-        ks.load(new FileInputStream(keyFilename), passphrase);\n-        ts.load(new FileInputStream(trustFilename), passphrase);\n+        ks.load(new FileInputStream(KEYSTORE_PATH), passphrase);\n+        ts.load(new FileInputStream(TRUSTSTORE_PATH), passphrase);\n@@ -80,2 +92,7 @@\n-        String secondSuite = suites[1];\n-        String [] oneSuites = new String [] { secondSuite };\n+        \/\/ sanity check that the ciphersuite we want to use is still supported\n+        Arrays.stream(suites)\n+                .filter(s -> s.equals(cipherSuite))\n+                .findFirst()\n+                .orElseThrow((() ->\n+                        new RuntimeException(cipherSuite +\n+                                \" is not a supported ciphersuite.\")));\n@@ -85,1 +102,1 @@\n-        ssle.setEnabledCipherSuites(oneSuites);\n+        ssle.setEnabledCipherSuites(new String [] { cipherSuite });\n@@ -90,2 +107,2 @@\n-                !(suites[0].equals(secondSuite))) {\n-            throw new Exception(\"set ciphers not what was expected\");\n+                !(suites[0].equals(cipherSuite))) {\n+            throw new RuntimeException(\"set ciphers not what was expected\");\n@@ -97,2 +114,7 @@\n-        String secondProtocol = protocols[1];\n-        String [] oneProtocols = new String [] { protocols[1] };\n+        \/\/ sanity check that the protocol we want is still supported\n+        Arrays.stream(protocols)\n+                .filter(p -> p.equals(protocol))\n+                .findFirst()\n+                .orElseThrow(() ->\n+                        new RuntimeException(protocol +\n+                                \" is not a supported TLS protocol.\"));\n@@ -102,1 +124,1 @@\n-        ssle.setEnabledProtocols(oneProtocols);\n+        ssle.setEnabledProtocols(new String[]{ protocol });\n@@ -107,2 +129,2 @@\n-                !(protocols[0].equals(secondProtocol))) {\n-            throw new Exception(\"set protocols not what was expected\");\n+                !(protocols[0].equals(protocol))) {\n+            throw new RuntimeException(\"set protocols not what was expected\");\n@@ -114,2 +136,2 @@\n-        if (ssle.getUseClientMode() != true) {\n-            throw new Exception(\"set\/getUseClientMode false\");\n+        if (!ssle.getUseClientMode()) {\n+            throw new RuntimeException(\"set\/getUseClientMode false\");\n@@ -119,2 +141,2 @@\n-        if (ssle.getUseClientMode() != false) {\n-            throw new Exception(\"set\/getUseClientMode true\");\n+        if (ssle.getUseClientMode()) {\n+            throw new RuntimeException(\"set\/getUseClientMode true\");\n@@ -127,2 +149,2 @@\n-        if (ssle.getNeedClientAuth() != false) {\n-            throw new Exception(\"set\/getNeedClientAuth true\");\n+        if (ssle.getNeedClientAuth()) {\n+            throw new RuntimeException(\"set\/getNeedClientAuth true\");\n@@ -132,2 +154,2 @@\n-        if (ssle.getNeedClientAuth() != true) {\n-            throw new Exception(\"set\/getNeedClientAuth false\");\n+        if (!ssle.getNeedClientAuth()) {\n+            throw new RuntimeException(\"set\/getNeedClientAuth false\");\n@@ -138,2 +160,2 @@\n-        if (ssle.getNeedClientAuth() == true) {\n-            throw new Exception(\"set\/getWantClientAuth need = true\");\n+        if (ssle.getNeedClientAuth()) {\n+            throw new RuntimeException(\"set\/getWantClientAuth need = true\");\n@@ -142,2 +164,2 @@\n-        if (ssle.getWantClientAuth() != true) {\n-            throw new Exception(\"set\/getNeedClientAuth false\");\n+        if (!ssle.getWantClientAuth()) {\n+            throw new RuntimeException(\"set\/getNeedClientAuth false\");\n@@ -147,2 +169,2 @@\n-        if (ssle.getWantClientAuth() != false) {\n-            throw new Exception(\"set\/getNeedClientAuth true\");\n+        if (ssle.getWantClientAuth()) {\n+            throw new RuntimeException(\"set\/getNeedClientAuth true\");\n@@ -159,2 +181,2 @@\n-        if (ssle.getEnableSessionCreation() != false) {\n-            throw new Exception(\"set\/getSessionCreation true\");\n+        if (ssle.getEnableSessionCreation()) {\n+            throw new RuntimeException(\"set\/getSessionCreation true\");\n@@ -164,2 +186,2 @@\n-        if (ssle.getEnableSessionCreation() != true) {\n-            throw new Exception(\"set\/getSessionCreation false\");\n+        if (!ssle.getEnableSessionCreation()) {\n+            throw new RuntimeException(\"set\/getSessionCreation false\");\n@@ -173,1 +195,1 @@\n-            throw new Exception(\"wrap should have overflowed\");\n+            throw new RuntimeException(\"wrap should have overflowed\");\n@@ -180,5 +202,0 @@\n-        \/\/\n-        \/\/if (ssle.unwrap(smallBB, smallBB).getStatus() !=\n-        \/\/      Status.BUFFER_OVERFLOW) {\n-        \/\/    throw new Exception(\"unwrap should have overflowed\");\n-        \/\/}\n@@ -199,1 +216,1 @@\n-            throw new Exception(\"initial client hello needs unwrap\");\n+            throw new RuntimeException(\"initial client hello needs unwrap\");\n@@ -202,5 +219,9 @@\n-        \/* Checking for overflow wrap\/unwrap() *\/\n-\n-        if (ssle.wrap(appBB, netBB).getStatus() !=\n-                Status.BUFFER_OVERFLOW) {\n-            throw new Exception(\"unwrap should have overflowed\");\n+        \/*\n+         * After the first call to wrap(), the handshake status is\n+         * NEED_UNWRAP and we need to receive data before doing anymore\n+         * handshaking.\n+         *\/\n+        SSLEngineResult result = ssle.wrap(appBB, netBB);\n+        if (result.getStatus() != Status.OK\n+            && result.bytesConsumed() != 0 && result.bytesProduced() != 0) {\n+            throw new RuntimeException(\"wrap should have returned without doing anything\");\n@@ -221,1 +242,1 @@\n-            throw new Exception(\"unwrap wasn't ReadOnlyBufferException\");\n+            throw new RuntimeException(\"unwrap wasn't ReadOnlyBufferException\");\n@@ -236,1 +257,1 @@\n-            throw new Exception(\"unwrap should underflow\");\n+            throw new RuntimeException(\"unwrap should underflow\");\n@@ -244,1 +265,1 @@\n-            throw new Exception(\"unwrap should underflow\");\n+            throw new RuntimeException(\"unwrap should underflow\");\n@@ -252,1 +273,1 @@\n-            throw new Exception(\"unwrap should underflow\");\n+            throw new RuntimeException(\"unwrap should underflow\");\n@@ -257,0 +278,5 @@\n+            \/*\n+             * Exceptions are thrown when:\n+             *    - the length field is correct but the data can't be decoded.\n+             *    - the length field is larger than max allowed.\n+             *\/\n@@ -258,3 +284,5 @@\n-            throw new Exception(\"Didn't catch the nasty SSLException\");\n-        } catch (SSLException e) {\n-            System.out.println(\"caught the nasty SSLException: \" + e);\n+            throw new RuntimeException(\"Expected SSLProtocolException was not thrown \"\n+                    + \"for bad input\");\n+        } catch (SSLProtocolException e) {\n+            System.out.println(\"caught the SSLProtocolException for bad decoding: \"\n+                    + e);\n@@ -281,2 +309,2 @@\n-        \/\/ \"HELLO HELLO\"\n-        (byte) 0x48, (byte) 0x45, (byte) 0x4C, (byte) 0x4C, (byte) 0x20,\n+        \/\/ bad data but correct record length to cause decryption error\n+        (byte) 0x48, (byte) 0x45, (byte) 0x4C, (byte) 0x00, (byte) 0x04,\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLEngine\/Basics.java","additions":92,"deletions":64,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8046391\n+ * @bug 8046391 8293862\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/8046391\/bug8046391.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.awt.Component;\n@@ -34,0 +33,2 @@\n+import java.util.Arrays;\n+import java.util.Collection;\n@@ -37,1 +38,0 @@\n-import javax.swing.BorderFactory;\n@@ -39,1 +39,1 @@\n-import javax.swing.BoxLayout;\n+import javax.swing.JComponent;\n@@ -44,0 +44,3 @@\n+import static javax.swing.BorderFactory.createEmptyBorder;\n+import static javax.swing.BorderFactory.createEtchedBorder;\n+\n@@ -46,1 +49,1 @@\n- * @bug 8279614\n+ * @bug 8279614 8294921\n@@ -51,1 +54,0 @@\n-\n@@ -54,1 +56,1 @@\n-    public static final Dimension SIZE = new Dimension(120, 20);\n+    private static final Dimension SIZE = new Dimension(125, 25);\n@@ -56,2 +58,5 @@\n-    public static Color highlight = Color.RED;\n-    public static Color shadow = Color.BLUE;\n+    private static final Color OUTER_COLOR = Color.BLACK;\n+    private static final Color INSIDE_COLOR = Color.WHITE;\n+    private static final Color HIGHLIGHT = Color.RED;\n+    private static final Color SHADOW = Color.BLUE;\n+    private static final Color TRANSPARENT_COLOR = new Color(0x00000000, true);\n@@ -69,2 +74,4 @@\n-        boolean showFrame = args.length > 0 && \"-show\".equals(args[0]);\n-        SwingUtilities.invokeAndWait(() -> testScaling(showFrame));\n+        Collection<String> params = Arrays.asList(args);\n+        final boolean showFrame = params.contains(\"-show\");\n+        final boolean saveImages = params.contains(\"-save\");\n+        SwingUtilities.invokeAndWait(() -> testScaling(showFrame, saveImages));\n@@ -73,2 +80,9 @@\n-    private static void testScaling(boolean show) {\n-        createGUI(show);\n+    private static void testScaling(boolean showFrame, boolean saveImages) {\n+        JComponent content = createUI();\n+        if (showFrame) {\n+            showFrame(content);\n+        }\n+\n+        paintToImages(content, saveImages);\n+        verifyBorderRendering(saveImages);\n+    }\n@@ -76,1 +90,4 @@\n-        for (int i = 0; i < scales.length; i++) {\n+    private static void verifyBorderRendering(final boolean saveImages) {\n+        String errorMessage = null;\n+        int errorCount = 0;\n+        for (int i = 0; i < images.size(); i++) {\n@@ -79,2 +96,2 @@\n-            System.out.println(\"Testing scaling: \" + scaling);\n-\n+            try {\n+                int thickness = (int) Math.floor(scaling);\n@@ -82,3 +99,1 @@\n-            \/\/ checking vertical border\n-            int x = SIZE.width \/ 2;\n-            checkVerticalBorder(x, img, scaling);\n+                checkVerticalBorders(SIZE.width \/ 2, thickness, img);\n@@ -86,19 +101,3 @@\n-            for (Point p : panelLocations) {\n-                int y = (int) (p.y * scaling) + SIZE.height \/ 2;\n-                checkHorizontalBorder(y, img, scaling);\n-            }\n-        }\n-    }\n-\n-    private static void checkHorizontalBorder(int y, BufferedImage img, double scaling) {\n-        int thickness = 0;\n-        boolean checkShadow = false;\n-        boolean checkHighlight = false;\n-        for (int x = 0; x < img.getWidth(); x++) {\n-            int color = img.getRGB(x, y);\n-            if (!checkHighlight && !checkShadow) {\n-                if (color == shadow.getRGB()) {\n-                    checkHighlight = true;\n-                    thickness++;\n-                } else if (color == highlight.getRGB()) {\n-                    throw new RuntimeException(\"Horizontal Border was clipped or overdrawn.\");\n+                for (Point p : panelLocations) {\n+                    int y = (int) (p.y * scaling) + SIZE.height \/ 2;\n+                    checkHorizontalBorder(y, thickness, img);\n@@ -106,10 +105,3 @@\n-            } else if (checkHighlight) {\n-                if (color == shadow.getRGB()) {\n-                    thickness++;\n-                } else if (color == highlight.getRGB()) {\n-                    verifyThickness(x, y, thickness, scaling, \"Horizontal\");\n-                    checkHighlight = false;\n-                    checkShadow = true;\n-                    thickness = 1;\n-                } else {\n-                    throw new RuntimeException(\"Horizontal Border has empty space between highlight and shadow.\");\n+            } catch (Error e) {\n+                if (errorMessage == null) {\n+                    errorMessage = e.getMessage();\n@@ -117,9 +109,8 @@\n-            } else {\n-                if (color == shadow.getRGB()) {\n-                    throw new RuntimeException(\"Border colors reversed.\");\n-                } else if (color == highlight.getRGB()) {\n-                    thickness++;\n-                } else {\n-                    verifyThickness(x, y, thickness, scaling, \"Horizontal\");\n-                    checkShadow = false;\n-                    thickness = 0;\n+                errorCount++;\n+\n+                System.err.printf(\"Scaling: %.2f\\n\", scaling);\n+                e.printStackTrace();\n+\n+                \/\/ Save the image if it wasn't already saved\n+                if (!saveImages) {\n+                    saveImage(img, getImageFileName(scaling));\n@@ -129,1 +120,0 @@\n-    }\n@@ -131,5 +121,4 @@\n-    private static void verifyThickness(int x, int y, int thickness, double scaling, String orientation) {\n-        int expected = (int) Math.floor(scaling);\n-        if (thickness != expected) {\n-            throw new RuntimeException(\"Unexpected \" + orientation + \" Border thickness at x:\"\n-                                       + x + \" y: \" + y + \". Expected: \" + expected + \" Actual: \" + thickness);\n+        if (errorCount > 0) {\n+            throw new Error(\"Test failed: \"\n+                            + errorCount + \" error(s) detected - \"\n+                            + errorMessage);\n@@ -139,33 +128,113 @@\n-    private static void checkVerticalBorder(int x, BufferedImage img, double scaling) {\n-        int thickness = 0;\n-        boolean checkShadow = false;\n-        boolean checkHighlight = false;\n-        for (int y = 0; y < img.getHeight(); y++) {\n-            int color = img.getRGB(x, y);\n-            if (!checkHighlight && !checkShadow) {\n-                if (color == shadow.getRGB()) {\n-                    checkHighlight = true;\n-                    thickness++;\n-                } else if (color == highlight.getRGB()) {\n-                    throw new RuntimeException(\"Vertical Border was clipped or overdrawn.\");\n-                }\n-            } else if (checkHighlight) {\n-                if (color == shadow.getRGB()) {\n-                    thickness++;\n-                } else if (color == highlight.getRGB()) {\n-                    verifyThickness(x, y, thickness, scaling, \"Vertical\");\n-                    checkHighlight = false;\n-                    checkShadow = true;\n-                    thickness = 1;\n-                } else {\n-                    throw new RuntimeException(\"Vertical Border has empty space between highlight and shadow.\");\n-                }\n-            } else {\n-                if (color == shadow.getRGB()) {\n-                    throw new RuntimeException(\"Border colors reversed.\");\n-                } else if (color == highlight.getRGB()) {\n-                    thickness++;\n-                } else {\n-                    verifyThickness(x, y, thickness, scaling, \"Vertical\");\n-                    checkShadow = false;\n-                    thickness = 0;\n+    private static void checkVerticalBorders(final int x,\n+                                             final int thickness,\n+                                             final BufferedImage img) {\n+        checkBorder(x, 0,\n+                    0, 1,\n+                    thickness, img);\n+    }\n+\n+    private static void checkHorizontalBorder(final int y,\n+                                              final int thickness,\n+                                              final BufferedImage img) {\n+        checkBorder(0, y,\n+                    1, 0,\n+                    thickness, img);\n+    }\n+\n+    private enum State {\n+        BACKGROUND,\n+        LEFT_SHADOW, LEFT_HIGHLIGHT,\n+        INSIDE,\n+        RIGHT_SHADOW, RIGHT_HIGHLIGHT\n+    }\n+\n+    private static void checkBorder(final int xStart, final int yStart,\n+                                    final int xStep,  final int yStep,\n+                                    final int thickness,\n+                                    final BufferedImage img) {\n+        final int width = img.getWidth();\n+        final int height = img.getHeight();\n+\n+        State state = State.BACKGROUND;\n+        int borderThickness = 0;\n+\n+        int x = xStart;\n+        int y = yStart;\n+        do {\n+            do {\n+                final int color = img.getRGB(x, y);\n+                switch (state) {\n+                    case BACKGROUND:\n+                        if (color == SHADOW.getRGB()) {\n+                            state = State.LEFT_SHADOW;\n+                            borderThickness = 1;\n+                        } else if (color != OUTER_COLOR.getRGB()\n+                                   && color != TRANSPARENT_COLOR.getRGB()) {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n+\n+                    case LEFT_SHADOW:\n+                        if (color == SHADOW.getRGB()) {\n+                            borderThickness++;\n+                        } else if (color == HIGHLIGHT.getRGB()) {\n+                            if (borderThickness != thickness) {\n+                                throwWrongThickness(thickness, borderThickness, x, y);\n+                            }\n+                            borderThickness = 1;\n+                            state = State.LEFT_HIGHLIGHT;\n+                        } else {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n+\n+                    case LEFT_HIGHLIGHT:\n+                        if (color == HIGHLIGHT.getRGB()) {\n+                            borderThickness++;\n+                        } else if (color == INSIDE_COLOR.getRGB()) {\n+                            if (borderThickness != thickness) {\n+                                throwWrongThickness(thickness, borderThickness, x, y);\n+                            }\n+                            borderThickness = 0;\n+                            state = State.INSIDE;\n+                        } else {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n+\n+                    case INSIDE:\n+                        if (color == SHADOW.getRGB()) {\n+                            state = State.RIGHT_SHADOW;\n+                            borderThickness = 1;\n+                        } else if (color != INSIDE_COLOR.getRGB()) {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n+\n+                    case RIGHT_SHADOW:\n+                        if (color == SHADOW.getRGB()) {\n+                            borderThickness++;\n+                        } else if (color == HIGHLIGHT.getRGB()) {\n+                            if (borderThickness != thickness) {\n+                                throwWrongThickness(thickness, borderThickness, x, y);\n+                            }\n+                            borderThickness = 1;\n+                            state = State.RIGHT_HIGHLIGHT;\n+                        } else {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n+\n+                    case RIGHT_HIGHLIGHT:\n+                        if (color == HIGHLIGHT.getRGB()) {\n+                            borderThickness++;\n+                        } else if (color == OUTER_COLOR.getRGB()) {\n+                            if (borderThickness != thickness) {\n+                                throwWrongThickness(thickness, borderThickness, x, y);\n+                            }\n+                            borderThickness = 0;\n+                            state = State.BACKGROUND;\n+                        } else {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n@@ -173,2 +242,9 @@\n-            }\n-        }\n+            } while (yStep > 0 && ((y += yStep) < height));\n+        } while (xStep > 0 && ((x += xStep) < width));\n+    }\n+\n+    private static void throwWrongThickness(int thickness, int borderThickness,\n+                                            int x, int y) {\n+        throw new Error(\n+                String.format(\"Wrong border thickness at %d, %d: %d vs %d\",\n+                              x, y, borderThickness, thickness));\n@@ -177,4 +253,9 @@\n-    private static void createGUI(boolean show) {\n-        \/\/ Render content panel\n-        JPanel contentPanel = new JPanel();\n-        contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));\n+    private static void throwUnexpectedColor(int x, int y, int color) {\n+        throw new Error(\n+                String.format(\"Unexpected color at %d, %d: %08x\",\n+                              x, y, color));\n+    }\n+\n+    private static JComponent createUI() {\n+        Box contentPanel = Box.createVerticalBox();\n+        contentPanel.setBackground(OUTER_COLOR);\n@@ -184,0 +265,6 @@\n+            JComponent filler = new JPanel(null);\n+            filler.setBackground(INSIDE_COLOR);\n+            filler.setPreferredSize(SIZE);\n+            filler.setBounds(i, 0, SIZE.width, SIZE.height);\n+            filler.setBorder(createEtchedBorder(HIGHLIGHT, SHADOW));\n+\n@@ -185,4 +272,3 @@\n-            childPanel.setBorder(BorderFactory.createCompoundBorder(\n-                    BorderFactory.createEmptyBorder(0, i, 4, 4),\n-                    BorderFactory.createEtchedBorder(highlight, shadow)));\n-            childPanel.add(Box.createRigidArea(SIZE), BorderLayout.CENTER);\n+            childPanel.setBorder(createEmptyBorder(0, i, 4, 4));\n+            childPanel.add(filler, BorderLayout.CENTER);\n+            childPanel.setBackground(OUTER_COLOR);\n@@ -194,1 +280,4 @@\n-            childPanel.setBounds(0, childSize.height * i, childSize.width, childSize.height);\n+            childPanel.setBounds(0, childSize.height * i,\n+                                 childSize.width, childSize.height);\n+\n+            panelLocations.add(childPanel.getLocation());\n@@ -199,0 +288,14 @@\n+        return contentPanel;\n+    }\n+\n+    private static void showFrame(final JComponent content) {\n+        JFrame frame = new JFrame(\"Scaled Etched Border Test\");\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        frame.getContentPane().add(content, BorderLayout.CENTER);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static void paintToImages(final JComponent content,\n+                                      final boolean saveImages) {\n@@ -200,17 +303,9 @@\n-            \/\/ Create BufferedImage\n-            BufferedImage buff = new BufferedImage((int) Math.ceil(contentPanel.getWidth() * scaling),\n-                    (int) Math.ceil(contentPanel.getHeight() * scaling),\n-                    BufferedImage.TYPE_INT_ARGB);\n-            Graphics2D graph = buff.createGraphics();\n-            graph.scale(scaling, scaling);\n-            \/\/ Painting panel onto BufferedImage\n-            contentPanel.paint(graph);\n-            graph.dispose();\n-            \/\/ Save each image ? -- Here it's useful for debugging\n-            saveImage(buff, String.format(\"test%.2f.png\", scaling));\n-            images.add(buff);\n-        }\n-        \/\/ Save coordinates of the panels\n-        for (Component comp : contentPanel.getComponents()) {\n-            panelLocations.add(comp.getLocation());\n-        }\n+            BufferedImage image =\n+                    new BufferedImage((int) Math.ceil(content.getWidth() * scaling),\n+                                      (int) Math.ceil(content.getHeight() * scaling),\n+                                      BufferedImage.TYPE_INT_ARGB);\n+\n+            Graphics2D g2d = image.createGraphics();\n+            g2d.scale(scaling, scaling);\n+            content.paint(g2d);\n+            g2d.dispose();\n@@ -218,7 +313,4 @@\n-        if (show) {\n-            JFrame frame = new JFrame(\"Swing Test\");\n-            frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n-            frame.getContentPane().add(contentPanel, BorderLayout.CENTER);\n-            frame.pack();\n-            frame.setLocationRelativeTo(null);\n-            frame.setVisible(true);\n+            if (saveImages) {\n+                saveImage(image, getImageFileName(scaling));\n+            }\n+            images.add(image);\n@@ -228,0 +320,4 @@\n+    private static String getImageFileName(final double scaling) {\n+        return String.format(\"test%.2f.png\", scaling);\n+    }\n+\n","filename":"test\/jdk\/javax\/swing\/border\/EtchedBorder\/ScaledEtchedBorderTest.java","additions":227,"deletions":131,"binary":false,"changes":358,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.awt.Component;\n@@ -141,0 +140,4 @@\n+    private enum State {\n+        BACKGROUND, LEFT, INSIDE, RIGHT\n+    }\n+\n@@ -207,4 +210,0 @@\n-    private enum State {\n-        BACKGROUND, LEFT, INSIDE, RIGHT\n-    }\n-\n@@ -246,0 +245,2 @@\n+\n+            panelLocations.add(childPanel.getLocation());\n@@ -250,5 +251,0 @@\n-        \/\/ Save coordinates of the panels\n-        for (Component comp : contentPanel.getComponents()) {\n-            panelLocations.add(comp.getLocation());\n-        }\n-\n","filename":"test\/jdk\/javax\/swing\/border\/LineBorder\/ScaledLineBorderTest.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.awt.Component;\n","filename":"test\/jdk\/javax\/swing\/border\/LineBorder\/ScaledTextFieldBorderTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,2 @@\n-    private static final long TIMEOUT = 10_000;\n+    private static final float tf = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n+    private static final long TIMEOUT = 10_000 * (long)tf;\n@@ -64,1 +65,1 @@\n-            throw new RuntimeException(\"Parsing takes too long.\");\n+            throw new RuntimeException(\"Parsing takes too long. Current timeout is \" + TIMEOUT);\n","filename":"test\/jdk\/javax\/swing\/text\/html\/parser\/Parser\/8078268\/bug8078268.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"","filename":"test\/jdk\/jdk\/internal\/misc\/CDS\/ArchivedEnumApp.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchivedEnumApp.java","status":"renamed"},{"patch":"","filename":"test\/jdk\/jdk\/internal\/misc\/CDS\/ArchivedEnumTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchivedEnumTest.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-# A \"screenshots\" test requires a 100% headful graphical environment \n+# A \"screenshots\" test requires a 100% headful graphical environment\n","filename":"test\/jdk\/sanity\/client\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-### Font SubMenu (under Themes) \n+### Font SubMenu (under Themes)\n","filename":"test\/jdk\/sanity\/client\/lib\/SwingSet2\/src\/resources\/swingset.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-# \"handlers\" specifies a comma separated list of log Handler \n+# \"handlers\" specifies a comma separated list of log Handler\n@@ -42,1 +42,1 @@\n-# Example to customize the SimpleFormatter output format \n+# Example to customize the SimpleFormatter output format\n","filename":"test\/jdk\/sun\/management\/LoggingTest\/logging.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8300399\n+ * @summary EdDSA does not verify when there is no message\n+ * @run main EmptyMessage\n+ *\/\n+import java.security.KeyPairGenerator;\n+import java.security.Signature;\n+import java.security.spec.NamedParameterSpec;\n+\n+public class EmptyMessage {\n+    public static void main(String[] args) throws Exception {\n+        var g = KeyPairGenerator.getInstance(\"EdDSA\");\n+        g.initialize(NamedParameterSpec.ED25519);\n+        var kp = g.generateKeyPair();\n+\n+        var ss = Signature.getInstance(\"EdDSA\");\n+        ss.initSign(kp.getPrivate());\n+        var sig = ss.sign();\n+\n+        var ps = Signature.getInstance(\"EdDSA\");\n+        ps.initVerify(kp.getPublic());\n+        if (!ps.verify(sig)) {\n+            throw new RuntimeException();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ec\/ed\/EmptyMessage.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -2,21 +2,21 @@\n-  * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n-  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-  *\n-  * This code is free software; you can redistribute it and\/or modify it\n-  * under the terms of the GNU General Public License version 2 only, as\n-  * published by the Free Software Foundation.\n-  *\n-  * This code is distributed in the hope that it will be useful, but WITHOUT\n-  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-  * version 2 for more details (a copy is included in the LICENSE file that\n-  * accompanied this code).\n-  *\n-  * You should have received a copy of the GNU General Public License version\n-  * 2 along with this work; if not, write to the Free Software Foundation,\n-  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-  *\n-  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-  * or visit www.oracle.com if you need additional information or have any\n-  * questions.\n-  *\/\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testReporterStreams\/TestReporterStreams.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-    public static void main(String argv[]) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/4980495\/static\/Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-    public static void main(String argv[]) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/4980495\/std\/Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-    public static void main(String... args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/6491592\/T6491592.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-   public static void main() {\n+   public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/6857948\/T6857948.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/8062359\/UnresolvableClassNPEInAttrTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-    public static void main(String [] arg) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/8161985\/T8161985a.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-     public static void main(String[] args) {\n+     public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/8238735\/T8238735.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,5 +27,1 @@\n-\n-    public static void main(String[] args) {\n-        new JavacBug();\n-    }\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/tools\/javac\/AnonymousClass\/AnonymousInSuperCallNegTest.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-     public static void main(String argv[]) {\n+     public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/BreakAcrossClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,10 +40,0 @@\n-\n-    public static void main(String[] args) {\n-        SuperOfShowFlaw sosf = new ShowFlaw();\n-        SuperOfFlaw<List<?>> sof = sosf.m();\n-        List<String> ls = new ArrayList<String>();\n-        ls.add(\"Smalltalk rules!\");\n-        sof.put(ls);\n-        Number n = ShowFlaw.fn.get().get(0);\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/CaptureInSubtype.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    public static void main(final String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/DASwitch.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    public static void main(final String[] args) {\n+    public static void meth(final String[] args) {\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/DUParam1.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-    public static void main(String argv[]) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/DefAssignAfterTry1.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-    public static void main(String argv[]) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/DefAssignAfterTry2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-    public static void main(String argv[]) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/DefAssignAfterTry3.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/T4717164.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/T4718142.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/T4718142a.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,4 +24,0 @@\n-    public static void main (String[] args) {\n-        I b = new B();\n-        b.throwCheckedException();\n-    }\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/UncaughtException.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -21,1 +21,1 @@\n-        public static void main(String[] args) {\n+        public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/OverrideChecks\/T4721069.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/ParseConditional.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    public static void main(String[] args) {\n+    public static void meth(String[] args) {\n","filename":"test\/langtools\/tools\/javac\/SwitchScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n-    public static void main(String args[]) {\n+    public static void meth(String args[]) {\n","filename":"test\/langtools\/tools\/javac\/SynthName2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/T5003235\/T5003235b.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/T6306967.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    public static void main(String... arg){\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/T6326754.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    public static void main(String[] args) {\n+    public static void meth(String[] args) {\n","filename":"test\/langtools\/tools\/javac\/T6379327.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,3 +12,0 @@\n-    public static void main(String... args) {\n-        main(args);\n-    }\n","filename":"test\/langtools\/tools\/javac\/T6407257.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-    public static void main(String... args) {\n+    public static void meth(String... args) {\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/BadTwr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-BadTwr.java:12:46: compiler.err.already.defined: kindname.variable, r1, kindname.method, main(java.lang.String...)\n-BadTwr.java:17:20: compiler.err.already.defined: kindname.variable, args, kindname.method, main(java.lang.String...)\n+BadTwr.java:12:46: compiler.err.already.defined: kindname.variable, r1, kindname.method, meth(java.lang.String...)\n+BadTwr.java:17:20: compiler.err.already.defined: kindname.variable, args, kindname.method, meth(java.lang.String...)\n@@ -4,1 +4,1 @@\n-BadTwr.java:25:24: compiler.err.already.defined: kindname.variable, name, kindname.method, main(java.lang.String...)\n+BadTwr.java:25:24: compiler.err.already.defined: kindname.variable, name, kindname.method, meth(java.lang.String...)\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/BadTwr.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    public static void main(String... args) throws Exception {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/BadTwrSyntax.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/DuplicateResourceDecl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-DuplicateResourceDecl.java:12:56: compiler.err.already.defined: kindname.variable, c, kindname.method, main(java.lang.String[])\n+DuplicateResourceDecl.java:12:56: compiler.err.already.defined: kindname.variable, c, kindname.method, meth()\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/DuplicateResourceDecl.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-    public static void main(String... args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/ImplicitFinal.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-    public static void main(String... args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/PlainTry.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    public static void main (String args[]) throws Exception {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/T7022711.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-    public static void main(String... args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/TwrAndLambda.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    public static void main(String... args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/TwrFlow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-    public static void main(String... args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/TwrForVariable2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n-    public static void main(String... args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/TwrForVariable3.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-    public static void main(String... args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/TwrForVariable4.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-    public static void main(String... args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/TwrOnNonResource.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-    public static void main(String... args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/TwrVarKinds.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-    public static void main(String... args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/TwrVarRedeclaration.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,3 +1,3 @@\n-TwrVarRedeclaration.java:14:33: compiler.err.already.defined: kindname.variable, r, kindname.method, main(java.lang.String...)\n-TwrVarRedeclaration.java:18:20: compiler.err.already.defined: kindname.variable, r, kindname.method, main(java.lang.String...)\n-TwrVarRedeclaration.java:23:23: compiler.err.already.defined: kindname.variable, r, kindname.method, main(java.lang.String...)\n+TwrVarRedeclaration.java:14:33: compiler.err.already.defined: kindname.variable, r, kindname.method, meth()\n+TwrVarRedeclaration.java:18:20: compiler.err.already.defined: kindname.variable, r, kindname.method, meth()\n+TwrVarRedeclaration.java:23:23: compiler.err.already.defined: kindname.variable, r, kindname.method, meth()\n","filename":"test\/langtools\/tools\/javac\/TryWithResources\/TwrVarRedeclaration.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n-    public static void main(String args[]) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/UseEnum.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -22,4 +22,0 @@\n-    public static void main(String[] args) {\n-        A a = Main.class.getAnnotation(A.class);\n-        System.out.println(a);\n-    }\n","filename":"test\/langtools\/tools\/javac\/annotations\/neg\/Cycle3.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -21,1 +21,1 @@\n-  public static void main(String... args) {\n+  public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/failures\/StaticFields.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/failures\/target\/DotClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-    public static void main(String[] args) throws Throwable {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/capture\/Martin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -20,1 +20,1 @@\n-    public static void main(String [] args) {\n+    public static void meth() {\n@@ -27,1 +27,1 @@\n-    public static void main(String [] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/defaultMethods\/private\/Private06.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/defaultMethods\/static\/Static02.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-    public static void main(String argv[]) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/depDocComment\/DeprecatedDocComment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/6245699\/T6245699b.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-    public static void main(String... args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/6413682\/T6413682.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-    public static void main(String... args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/6495506\/T6495506.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-    public static void main(String[] args) throws Exception {\n+    public static void meth() throws Exception {\n","filename":"test\/langtools\/tools\/javac\/generics\/6723444\/T6723444.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/GetClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-    public static void main (String [] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/Nonlinear.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/UnsoundInference.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-   public static void main(String[] args) {\n+   public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/neg\/Neg08.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/neg\/Neg13.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/neg\/Neg14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/neg\/Neg15.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-   public static void main(String[] args) {\n+   void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/neg\/Neg17.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n-   public static void main(String[] args) {\n+   public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/neg\/Neg18.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/neg\/Neg19.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,5 +25,0 @@\n-\n-\n-    public static void main(String[] args) {\n-        B b = new B<Sun1>();\n-    }\n","filename":"test\/langtools\/tools\/javac\/generics\/inference\/4972073\/T4972073.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    public static void main(String... args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/inference\/5081782\/Neg.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-        public static void main(String[] args) {\n+        public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/odersky\/BadTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-        public static void main(String[] args) {\n+        public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/odersky\/BadTest3.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,6 +35,0 @@\n-\n-    public static void main(String[] args) {\n-        T<Integer> x = new <Object>T<Integer>();\n-        T<Integer>.U<Float> y = x.new <Object>U<Float>();\n-        x.<Object>f(\"\");\n-    }\n","filename":"test\/langtools\/tools\/javac\/generics\/typeargs\/Metharg1.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/typeargs\/Metharg2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -17,1 +17,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/typeargs\/Newarg1.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/typeargs\/Newarg2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,6 +35,0 @@\n-\n-    public static void main(String[] args) {\n-        T<Integer> x = new <Object>T<Integer>(\"\");\n-        T<Integer>.U<Float> y = x.new <Object>U<Float>();\n-        x.<Object>f();\n-    }\n","filename":"test\/langtools\/tools\/javac\/generics\/typeargs\/Superarg1.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,6 +35,0 @@\n-\n-    public static void main(String[] args) {\n-        T<Integer> x = new <Object>T<Integer>();\n-        T<Integer>.U<Float> y = x.new <Object>U<Float>(\"\");\n-        x.<Object>f();\n-    }\n","filename":"test\/langtools\/tools\/javac\/generics\/typeargs\/Superarg2.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,6 +35,0 @@\n-\n-    public static void main(String[] args) {\n-        T<Integer> x = new <Object>T<Integer>();\n-        T<Integer>.U<Float> y = x.new <Object>U<Float>(\"\");\n-        x.<Object>f();\n-    }\n","filename":"test\/langtools\/tools\/javac\/generics\/typeargs\/ThisArg.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n-    public static void main(String... args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/wildcards\/6437894\/T6437894.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/wildcards\/AssignmentDifferentTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/wildcards\/AssignmentSameType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -17,1 +17,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/generics\/wildcards\/T6450290.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,5 +27,0 @@\n-    public static void main(String[] args) {\n-        NewBeforeOuterConstructed2 c = new NewBeforeOuterConstructed2(new Object());\n-        Middle m = c.new Middle();\n-        m.f();\n-    }\n","filename":"test\/langtools\/tools\/javac\/implicitThis\/NewBeforeOuterConstructed2.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/8071432\/T8071432.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-    public static void main( final String... notUsed ) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/LambdaConv10.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -20,1 +20,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReference20.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReference25.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReference41.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReference42.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReference43.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReference44.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReference46.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReference47.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReference48.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReference60.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/MostSpecific04.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/MostSpecific05.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/funcInterfaces\/LambdaTest2_neg1.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -16,1 +16,1 @@\n-    public static void main(String argv[]) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/MethodRefIntColonColonNewTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -20,1 +20,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/MethodRefToInnerWithoutOuter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -16,1 +16,1 @@\n-  public static void main(String[] args) {\n+  public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReferenceExecution\/MethodReferenceTestVarHandle_neg.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/lambda\/typeInference\/InferenceTest_neg1_2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-    public static void main(String[] args) {\n-    }\n","filename":"test\/langtools\/tools\/javac\/limits\/ArrayDims1.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-    public static void main(String[] args) {\n-    }\n","filename":"test\/langtools\/tools\/javac\/limits\/ArrayDims2.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-    public static void main(String[] args) {\n-    }\n","filename":"test\/langtools\/tools\/javac\/limits\/ArrayDims3.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-    public static void main(String[] args) {\n-    }\n","filename":"test\/langtools\/tools\/javac\/limits\/ArrayDims4.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3334,2 +3334,0 @@\n-    public static void main(String args[]) {\n-    System.out.println(\"Ok\"); }\n","filename":"test\/langtools\/tools\/javac\/limits\/PoolSize2.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -23,3 +23,0 @@\n-    public static void main(String[] args) {\n-        System.out.println(X.length());\n-    }\n","filename":"test\/langtools\/tools\/javac\/limits\/StringLength.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-   public static void main(String[] args) {\n+   public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/nested\/5009484\/X.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/overload\/T5090220.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/patterns\/BindingsTest1Merging.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/patterns\/BindingsTest2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-    public static void main(String [] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/patterns\/CastConversionMatch.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-    public static void main(String... args) throws Throwable {\n+    public static void meth() throws Throwable {\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -23,2 +23,2 @@\n-DeconstructionPatternErrors.java:30:56: compiler.err.already.defined: kindname.variable, v1, kindname.method, main(java.lang.String...)\n-DeconstructionPatternErrors.java:30:64: compiler.err.already.defined: kindname.variable, v2, kindname.method, main(java.lang.String...)\n+DeconstructionPatternErrors.java:30:56: compiler.err.already.defined: kindname.variable, v1, kindname.method, meth()\n+DeconstructionPatternErrors.java:30:64: compiler.err.already.defined: kindname.variable, v2, kindname.method, meth()\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-    public static void main(String [] args) {\n+    public static void meth(String[] args) {\n","filename":"test\/langtools\/tools\/javac\/patterns\/EnsureTypesOrderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/patterns\/ImpossibleTypeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/patterns\/MatchBindingScopeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullsInPatterns.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8291769\n+ * @bug 8291769 8300195\n@@ -28,0 +28,1 @@\n+ * @enablePreview\n@@ -37,0 +38,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -38,0 +40,5 @@\n+import java.io.PrintStream;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.charset.StandardCharsets;\n@@ -41,1 +48,1 @@\n-import java.util.List;\n+import java.util.Objects;\n@@ -201,0 +208,99 @@\n+    @Test\n+    public void testRuleCases(Path base) throws Exception {\n+        doTestRun(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   public static void main(String... args) {\n+                       System.out.println(test(new R(\"a\")));\n+                       System.out.println(test(new R(3)));\n+                       System.out.println(test(new R(new R(\"a\"))));\n+                       System.out.println(test(new R(new R(3))));\n+                   }\n+                   public static int test(Object obj) {\n+                       int res;\n+                       switch (obj) {\n+                           case R(String s) -> res = s.length();\n+                           case R(Integer i) -> res = i;\n+                           case R(R(String s)) -> res = 10 + s.length();\n+                           case R(R(Integer i)) -> res = 10 + i;\n+                           default -> res = -1;\n+                       }\n+                       return res;\n+                   }\n+                   record R(Object o) {}\n+               }\n+               \"\"\",\n+               output -> {\n+                   String expectedOutput = \"\"\"\n+                                           1\n+                                           3\n+                                           11\n+                                           13\n+                                           \"\"\";\n+                   if (!Objects.equals(output, expectedOutput)) {\n+                       throw new AssertionError(\"Unexpected output,\" +\n+                                                \" expected: \" + expectedOutput +\n+                                                \" actual: \" + output);\n+                   }\n+               });\n+    }\n+\n+    private void doTestRun(Path base, String[] libraryCode, String testCode, Consumer<String> validate) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path libClasses = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        if (libraryCode.length != 0) {\n+            Path libSrc = current.resolve(\"lib-src\");\n+\n+            for (String code : libraryCode) {\n+                tb.writeJavaFiles(libSrc, code);\n+            }\n+\n+            new JavacTask(tb)\n+                    .options(\"--enable-preview\",\n+                             \"-source\", JAVA_VERSION)\n+                    .outdir(libClasses)\n+                    .files(tb.findJavaFiles(libSrc))\n+                    .run();\n+        }\n+\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src, testCode);\n+\n+        Path classes = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        var log =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\",\n+                             \"-source\", JAVA_VERSION,\n+                             \"-XDrawDiagnostics\",\n+                             \"-Xlint:-preview\",\n+                             \"--class-path\", libClasses.toString(),\n+                             \"-XDshould-stop.at=FLOW\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.SUCCESS)\n+                    .writeAll();\n+\n+        ClassLoader cl = new URLClassLoader(new URL[] {classes.toUri().toURL()});\n+        Class<?> testClass = cl.loadClass(\"test.Test\");\n+        Method main = testClass.getMethod(\"main\", String[].class);\n+        PrintStream prevOut = System.out;\n+        var data = new ByteArrayOutputStream();\n+        try (var outStream = new PrintStream(data, true, StandardCharsets.UTF_8)) {\n+            System.setOut(outStream);\n+            main.invoke(null, (Object) new String[0]);\n+        } finally {\n+            System.setOut(prevOut);\n+        }\n+        String output = new String(data.toByteArray(), StandardCharsets.UTF_8);\n+        output = output.replaceAll(\"\\\\R\", \"\\n\");\n+        validate.accept(output);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternDesugaring.java","additions":109,"deletions":3,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/patterns\/PatternVariablesAreNonFinal.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    public static void main(String [] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/patterns\/UncheckedWarningOnMatchesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-  public static void main(String[] s) {\n+  public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/scope\/6225935\/Estatico4.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -21,1 +21,1 @@\n-    public static void main(String argv[]) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/staticImport\/ImportPrivate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/DefiniteAssignment2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/ExpressionSwitchUnreachable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/switchextra\/DefiniteAssignment2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/unicode\/NonasciiDigit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -22,1 +22,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/varargs\/6313164\/T7175433.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -17,1 +17,1 @@\n-    public static void main(String[] args) {\n+    public static void meth() {\n","filename":"test\/langtools\/tools\/javac\/varargs\/Warn2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.Map;\n@@ -30,0 +31,4 @@\n+    default public Path resolve(String name, Map<String, Object> artifactDescription,\n+                        boolean unpack) throws ArtifactResolverException {\n+        throw new ArtifactResolverException(\"not implemented\");\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/artifacts\/ArtifactManager.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-    public static Map<String, Path> resolve(Class<?> klass) throws ArtifactResolverException {\n+    private static ArtifactManager getManager() throws ArtifactResolverException {\n@@ -45,0 +45,2 @@\n+        return manager;\n+    }\n@@ -46,0 +48,2 @@\n+    public static Map<String, Path> resolve(Class<?> klass) throws ArtifactResolverException {\n+        ArtifactManager manager = getManager();\n@@ -62,0 +66,5 @@\n+    public static Path resolve(String name, Map<String, Object> artifactDescription, boolean unpack) throws ArtifactResolverException {\n+        ArtifactManager manager = getManager();\n+        return  manager.resolve(name, artifactDescription, unpack);\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/artifacts\/ArtifactResolver.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -70,0 +70,13 @@\n+\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @Warmup(iterations = 5, time = 1)\n+    @Measurement(iterations = 5, time = 1)\n+    @Fork(3)\n+    public static class CodePoints {\n+        @Benchmark\n+        public void codePointOf() {\n+            Character.codePointOf(\"Latin Capital Letter B with hook\");\n+        }\n+\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Characters.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -36,0 +37,2 @@\n+import java.util.Arrays;\n+import java.util.Random;\n@@ -37,0 +40,4 @@\n+import java.io.UnsupportedEncodingException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n@@ -86,0 +93,62 @@\n+\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @State(Scope.Thread)\n+    @Warmup(iterations = 5, time = 1)\n+    @Measurement(iterations = 5, time = 1)\n+    @Fork(value = 3, jvmArgsAppend = {\"--add-exports\", \"java.base\/java.lang=ALL-UNNAMED\", \"--add-opens\", \"java.base\/java.lang=ALL-UNNAMED\"})\n+    public static class Algorithm {\n+\n+        private final static String alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n+\n+        private final static MethodHandle defaultLatin1HashCodeMH;\n+        private final static MethodHandle defaultUTF16HashCodeMH;\n+\n+        static {\n+            try {\n+                Class<?> stringLatin1 = Class.forName(\"java.lang.StringLatin1\");\n+                Method stringLatin1HashCode = stringLatin1.getDeclaredMethod(\"hashCode\", byte[].class);\n+                stringLatin1HashCode.setAccessible(true);\n+\n+                defaultLatin1HashCodeMH = MethodHandles.lookup().unreflect(stringLatin1HashCode);\n+\n+                Class<?> stringUTF16 = Class.forName(\"java.lang.StringUTF16\");\n+                Method stringUTF16HashCode = stringUTF16.getDeclaredMethod(\"hashCode\", byte[].class);\n+                stringUTF16HashCode.setAccessible(true);\n+\n+                defaultUTF16HashCodeMH = MethodHandles.lookup().unreflect(stringUTF16HashCode);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Param({\"1\", \"10\", \"100\", \"10000\"})\n+        private int size;\n+\n+        private byte[] latin1;\n+        private byte[] utf16;\n+\n+        @Setup\n+        public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n+            Random rnd = new Random(42);\n+\n+            char[] str = new char[size];\n+            for (int i = 0; i < size; i++) {\n+                str[i] = alphabet.charAt(rnd.nextInt(alphabet.length()));\n+            }\n+            latin1 = new String(str).getBytes(\"US-ASCII\");\n+            utf16 = new String(str).getBytes(\"UTF-16\");\n+            \/\/ strip out byte order byte(s)\n+            utf16 = Arrays.copyOfRange(utf16, utf16.length - str.length * 2, utf16.length);\n+        }\n+\n+        @Benchmark\n+        public int defaultLatin1() throws Throwable {\n+            return (int)defaultLatin1HashCodeMH.invokeExact(latin1);\n+        }\n+\n+        @Benchmark\n+        public int defaultUTF16() throws Throwable {\n+            return (int)defaultUTF16HashCodeMH.invokeExact(utf16);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringHashCode.java","additions":70,"deletions":1,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.io.UnsupportedEncodingException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * Performance test of Arrays.hashCode() methods\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class ArraysHashCode {\n+\n+    @Param({\"1\", \"10\", \"100\", \"10000\"})\n+    private int size;\n+\n+    private byte[] bytes;\n+    private char[] chars;\n+    private short[] shorts;\n+    private int[] ints;\n+    private byte[][] multibytes;\n+    private char[][] multichars;\n+    private short[][] multishorts;\n+    private int[][] multiints;\n+\n+    @Setup\n+    public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n+        Random rnd = new Random(42);\n+\n+        bytes = new byte[size];\n+        chars = new char[size];\n+        shorts = new short[size];\n+        ints = new int[size];\n+        for (int i = 0; i < size; i++) {\n+            int next = rnd.nextInt();\n+            bytes[i] = (byte)next;\n+            chars[i] = (char)next;\n+            shorts[i] = (short)next;\n+            ints[i] = next;\n+        }\n+\n+        multibytes = new byte[100][];\n+        multichars = new char[100][];\n+        multishorts = new short[100][];\n+        multiints = new int[100][];\n+        for (int i = 0; i < 100; i++) {\n+            int next = rnd.nextInt(size + 1);\n+            multibytes[i] = new byte[next];\n+            multichars[i] = new char[next];\n+            multishorts[i] = new short[next];\n+            multiints[i] = new int[next];\n+            for (int j = 0; j < next; j++) {\n+                int nextj = rnd.nextInt();\n+                multibytes[i][j] = (byte)nextj;\n+                multichars[i][j] = (char)nextj;\n+                multishorts[i][j] = (short)nextj;\n+                multiints[i][j] = nextj;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public int bytes() throws Throwable {\n+        return Arrays.hashCode(bytes);\n+    }\n+\n+    @Benchmark\n+    public int chars() throws Throwable {\n+        return Arrays.hashCode(chars);\n+    }\n+\n+    @Benchmark\n+    public int shorts() throws Throwable {\n+        return Arrays.hashCode(shorts);\n+    }\n+\n+    @Benchmark\n+    public int ints() throws Throwable {\n+        return Arrays.hashCode(ints);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(100)\n+    public void multibytes(Blackhole bh) throws Throwable {\n+        for (int i = 0; i < multibytes.length; i++) {\n+            bh.consume(Arrays.hashCode(multibytes[i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(100)\n+    public void multichars(Blackhole bh) throws Throwable {\n+        for (int i = 0; i < multichars.length; i++) {\n+            bh.consume(Arrays.hashCode(multichars[i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(100)\n+    public void multishorts(Blackhole bh) throws Throwable {\n+        for (int i = 0; i < multishorts.length; i++) {\n+            bh.consume(Arrays.hashCode(multishorts[i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(100)\n+    public void multiints(Blackhole bh) throws Throwable {\n+        for (int i = 0; i < multibytes.length; i++) {\n+            bh.consume(Arrays.hashCode(multiints[i]));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArraysHashCode.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"}]}