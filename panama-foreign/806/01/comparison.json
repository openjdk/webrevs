{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -317,1 +318,1 @@\n-        long size = Wrapper.forPrimitiveType(carrier).bitWidth() \/ 8;\n+        long size = Utils.byteWidthOfPrimitive(carrier);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import sun.invoke.util.Wrapper;\n+\n@@ -240,0 +242,4 @@\n+\n+    public static int byteWidthOfPrimitive(Class<?> primitive) {\n+        return Wrapper.forPrimitiveType(primitive).bitWidth() \/ 8;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.ByteOrder;\n@@ -39,0 +40,4 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_INT_UNALIGNED;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT_UNALIGNED;\n+\n@@ -224,0 +229,5 @@\n+    private static void checkByteWidth(int byteWidth, Class<?> type) {\n+        if (byteWidth < 0 || byteWidth > Utils.byteWidthOfPrimitive(type))\n+            throw new IllegalArgumentException(\"Illegal byteWidth: \" + byteWidth);\n+    }\n+\n@@ -235,0 +245,4 @@\n+        return bufferStore(offset, type, Utils.byteWidthOfPrimitive(type));\n+    }\n+\n+    static BufferStore bufferStore(long offset, Class<?> type, int byteWidth) {\n@@ -237,1 +251,2 @@\n-        return new BufferStore(offset, type);\n+        checkByteWidth(byteWidth, type);\n+        return new BufferStore(offset, type, byteWidth);\n@@ -241,0 +256,4 @@\n+        return Binding.bufferLoad(offset, type, Utils.byteWidthOfPrimitive(type));\n+    }\n+\n+    static BufferLoad bufferLoad(long offset, Class<?> type, int byteWidth) {\n@@ -243,1 +262,2 @@\n-        return new BufferLoad(offset, type);\n+        checkByteWidth(byteWidth, type);\n+        return new BufferLoad(offset, type, byteWidth);\n@@ -340,0 +360,5 @@\n+        public Binding.Builder bufferStore(long offset, Class<?> type, int byteWidth) {\n+            bindings.add(Binding.bufferStore(offset, type, byteWidth));\n+            return this;\n+        }\n+\n@@ -345,0 +370,5 @@\n+        public Binding.Builder bufferLoad(long offset, Class<?> type, int byteWidth) {\n+            bindings.add(Binding.bufferLoad(offset, type, byteWidth));\n+            return this;\n+        }\n+\n@@ -439,1 +469,1 @@\n-     * BUFFER_STORE([offset into memory region], [type])\n+     * BUFFER_STORE([offset into memory region], [type], [width])\n@@ -441,1 +471,1 @@\n-     * Stores the [type] to [offset into memory region].\n+     * Stores [width] bytes of the value contained in the [type] to [offset into memory region].\n@@ -444,1 +474,1 @@\n-    record BufferStore(long offset, Class<?> type) implements Dereference {\n+    record BufferStore(long offset, Class<?> type, int byteWidth) implements Dereference {\n@@ -462,3 +492,34 @@\n-            MemorySegment operand = (MemorySegment) stack.pop();\n-            MemorySegment writeAddress = operand.asSlice(offset());\n-            SharedUtils.write(writeAddress, type(), value);\n+            MemorySegment writeAddress = (MemorySegment) stack.pop();\n+            if (SharedUtils.isPowerOfTwo(byteWidth())) {\n+                \/\/ exact size match\n+                SharedUtils.write(writeAddress, offset(), type(), value);\n+            } else {\n+                \/\/ non-exact match, need to do chunked load\n+                long longValue = ((Number) value).longValue();\n+                \/\/ byteWidth is smaller than the width of 'type', so it will always be < 8 here\n+                int remaining = byteWidth();\n+                int chunkOffset = 0;\n+                do {\n+                    int chunkSize = Integer.highestOneBit(remaining); \/\/ next power of 2, in bytes\n+                    long writeOffset = offset() + SharedUtils.pickChunkOffset(chunkOffset, byteWidth(), chunkSize);\n+                    int shiftAmount = chunkOffset * Byte.SIZE;\n+                    switch (chunkSize) {\n+                        case 4 -> {\n+                            int writeChunk = (int) (((0xFFFF_FFFFL << shiftAmount) & longValue) >>> shiftAmount);\n+                            writeAddress.set(JAVA_INT_UNALIGNED, writeOffset, writeChunk);\n+                        }\n+                        case 2 -> {\n+                            short writeChunk = (short) (((0xFFFFL << shiftAmount) & longValue) >>> shiftAmount);\n+                            writeAddress.set(JAVA_SHORT_UNALIGNED, writeOffset, writeChunk);\n+                        }\n+                        case 1 -> {\n+                            byte writeChunk = (byte) (((0xFFL << shiftAmount) & longValue) >>> shiftAmount);\n+                            writeAddress.set(JAVA_BYTE, writeOffset, writeChunk);\n+                        }\n+                        default ->\n+                           throw new IllegalStateException(\"Unexpected chunk size for chunked write: \" + chunkSize);\n+                    }\n+                    remaining -= chunkSize;\n+                    chunkOffset += chunkSize;\n+                } while (remaining != 0);\n+            }\n@@ -469,3 +530,3 @@\n-     * BUFFER_LOAD([offset into memory region], [type])\n-     * Pops a [type], and then a MemorySegment from the operand stack,\n-     * and then stores [type] to [offset into memory region] of the MemorySegment.\n+     * BUFFER_LOAD([offset into memory region], [type], [width])\n+     * Pops a MemorySegment from the operand stack,\n+     * and then loads [width] bytes from it at [offset into memory region], into a [type].\n@@ -474,1 +535,1 @@\n-    record BufferLoad(long offset, Class<?> type) implements Dereference {\n+    record BufferLoad(long offset, Class<?> type, int byteWidth) implements Dereference {\n@@ -491,3 +552,33 @@\n-            MemorySegment operand = (MemorySegment) stack.pop();\n-            MemorySegment readAddress = operand.asSlice(offset());\n-            stack.push(SharedUtils.read(readAddress, type()));\n+            MemorySegment readAddress = (MemorySegment) stack.pop();\n+            if (SharedUtils.isPowerOfTwo(byteWidth())) {\n+                \/\/ exact size match\n+                stack.push(SharedUtils.read(readAddress, offset(), type()));\n+            } else {\n+                \/\/ non-exact match, need to do chunked load\n+                long result = 0;\n+                \/\/ byteWidth is smaller than the width of 'type', so it will always be < 8 here\n+                int remaining = byteWidth();\n+                int chunkOffset = 0;\n+                do {\n+                    int chunkSize = Integer.highestOneBit(remaining); \/\/ next power of 2\n+                    long readOffset = offset() + SharedUtils.pickChunkOffset(chunkOffset, byteWidth(), chunkSize);\n+                    long readChunk = switch (chunkSize) {\n+                        case 4 -> Integer.toUnsignedLong(readAddress.get(JAVA_INT_UNALIGNED, readOffset));\n+                        case 2 -> Short.toUnsignedLong(readAddress.get(JAVA_SHORT_UNALIGNED, readOffset));\n+                        case 1 -> Byte.toUnsignedLong(readAddress.get(JAVA_BYTE, readOffset));\n+                        default ->\n+                            throw new IllegalStateException(\"Unexpected chunk size for chunked write: \" + chunkSize);\n+                    };\n+                    result |= readChunk << (chunkOffset * Byte.SIZE);\n+                    remaining -= chunkSize;\n+                    chunkOffset += chunkSize;\n+                } while (remaining != 0);\n+\n+                if (type() == int.class) { \/\/ 3 byte write\n+                    stack.push((int) result);\n+                } else if (type() == long.class) { \/\/ 5, 6, 7 byte write\n+                    stack.push(result);\n+                } else {\n+                    throw new IllegalStateException(\"Unexpected type for chunked load: \" + type());\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":106,"deletions":15,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -91,0 +91,3 @@\n+    private static final String INTEGER_TO_UNSIGNED_LONG_DESC = MethodType.methodType(long.class, int.class).descriptorString();\n+    private static final String SHORT_TO_UNSIGNED_LONG_DESC = MethodType.methodType(long.class, short.class).descriptorString();\n+    private static final String BYTE_TO_UNSIGNED_LONG_DESC = MethodType.methodType(long.class, byte.class).descriptorString();\n@@ -599,0 +602,1 @@\n+        int byteWidth = bufferStore.byteWidth();\n@@ -602,8 +606,72 @@\n-        int valueIdx = newLocal(storeType);\n-        emitStore(storeType, valueIdx);\n-\n-        Class<?> valueLayoutType = emitLoadLayoutConstant(storeType);\n-        emitConst(offset);\n-        emitLoad(storeType, valueIdx);\n-        String descriptor = methodType(void.class, valueLayoutType, long.class, storeType).descriptorString();\n-        emitInvokeInterface(MemorySegment.class, \"set\", descriptor);\n+\n+        if (SharedUtils.isPowerOfTwo(byteWidth)) {\n+            int valueIdx = newLocal(storeType);\n+            emitStore(storeType, valueIdx);\n+\n+            Class<?> valueLayoutType = emitLoadLayoutConstant(storeType);\n+            emitConst(offset);\n+            emitLoad(storeType, valueIdx);\n+            String descriptor = methodType(void.class, valueLayoutType, long.class, storeType).descriptorString();\n+            emitInvokeInterface(MemorySegment.class, \"set\", descriptor);\n+        } else {\n+            \/\/ long longValue = ((Number) value).longValue();\n+            if (storeType == int.class) {\n+                mv.visitInsn(I2L);\n+            } else {\n+                assert storeType == long.class; \/\/ chunking only for int and long\n+            }\n+            int longValueIdx = newLocal(long.class);\n+            emitStore(long.class, longValueIdx);\n+            int writeAddrIdx = newLocal(MemorySegment.class);\n+            emitStore(MemorySegment.class, writeAddrIdx);\n+\n+            int remaining = byteWidth;\n+            int chunkOffset = 0;\n+            do {\n+                int chunkSize = Integer.highestOneBit(remaining); \/\/ next power of 2, in bytes\n+                Class<?> chunkStoreType;\n+                long mask;\n+                switch (chunkSize) {\n+                    case 4 -> {\n+                        chunkStoreType = int.class;\n+                        mask = 0xFFFF_FFFFL;\n+                    }\n+                    case 2 -> {\n+                        chunkStoreType = short.class;\n+                        mask = 0xFFFFL;\n+                    }\n+                    case 1 -> {\n+                        chunkStoreType = byte.class;\n+                        mask = 0xFFL;\n+                    }\n+                    default ->\n+                       throw new IllegalStateException(\"Unexpected chunk size for chunked write: \" + chunkSize);\n+                }\n+                \/\/int writeChunk = (int) (((0xFFFF_FFFFL << shiftAmount) & longValue) >>> shiftAmount);\n+                int shiftAmount = chunkOffset * Byte.SIZE;\n+                mask = mask << shiftAmount;\n+                emitLoad(long.class, longValueIdx);\n+                emitConst(mask);\n+                mv.visitInsn(LAND);\n+                if (shiftAmount != 0) {\n+                    emitConst(shiftAmount);\n+                    mv.visitInsn(LUSHR);\n+                }\n+                mv.visitInsn(L2I);\n+                int chunkIdx = newLocal(chunkStoreType);\n+                emitStore(chunkStoreType, chunkIdx);\n+                \/\/ chunk done, now write it\n+\n+                \/\/writeAddress.set(JAVA_SHORT_UNALIGNED, offset, writeChunk);\n+                emitLoad(MemorySegment.class, writeAddrIdx);\n+                Class<?> valueLayoutType = emitLoadLayoutConstant(chunkStoreType);\n+                long writeOffset = offset + SharedUtils.pickChunkOffset(chunkOffset, byteWidth, chunkSize);\n+                emitConst(writeOffset);\n+                emitLoad(chunkStoreType, chunkIdx);\n+                String descriptor = methodType(void.class, valueLayoutType, long.class, chunkStoreType).descriptorString();\n+                emitInvokeInterface(MemorySegment.class, \"set\", descriptor);\n+\n+                remaining -= chunkSize;\n+                chunkOffset += chunkSize;\n+            } while (remaining != 0);\n+        }\n@@ -705,0 +773,1 @@\n+        int byteWidth = bufferLoad.byteWidth();\n@@ -708,4 +777,72 @@\n-        Class<?> valueLayoutType = emitLoadLayoutConstant(loadType);\n-        emitConst(offset);\n-        String descriptor = methodType(loadType, valueLayoutType, long.class).descriptorString();\n-        emitInvokeInterface(MemorySegment.class, \"get\", descriptor);\n+        if (SharedUtils.isPowerOfTwo(byteWidth)) {\n+            Class<?> valueLayoutType = emitLoadLayoutConstant(loadType);\n+            emitConst(offset);\n+            String descriptor = methodType(loadType, valueLayoutType, long.class).descriptorString();\n+            emitInvokeInterface(MemorySegment.class, \"get\", descriptor);\n+        } else {\n+            \/\/ chunked\n+            int readAddrIdx = newLocal(MemorySegment.class);\n+            emitStore(MemorySegment.class, readAddrIdx);\n+\n+            emitConstZero(long.class); \/\/ result\n+            int resultIdx = newLocal(long.class);\n+            emitStore(long.class, resultIdx);\n+\n+            int remaining = byteWidth;\n+            int chunkOffset = 0;\n+            do {\n+                int chunkSize = Integer.highestOneBit(remaining); \/\/ next power of 2\n+                Class<?> chunkType;\n+                Class<?> toULongHolder;\n+                String toULongDescriptor;\n+                switch (chunkSize) {\n+                    case 4 -> {\n+                        chunkType = int.class;\n+                        toULongHolder = Integer.class;\n+                        toULongDescriptor = INTEGER_TO_UNSIGNED_LONG_DESC;\n+                    }\n+                    case 2 -> {\n+                        chunkType = short.class;\n+                        toULongHolder = Short.class;\n+                        toULongDescriptor = SHORT_TO_UNSIGNED_LONG_DESC;\n+                    }\n+                    case 1 -> {\n+                        chunkType = byte.class;\n+                        toULongHolder = Byte.class;\n+                        toULongDescriptor = BYTE_TO_UNSIGNED_LONG_DESC;\n+                    }\n+                    default ->\n+                        throw new IllegalStateException(\"Unexpected chunk size for chunked write: \" + chunkSize);\n+                }\n+                \/\/ read from segment\n+                emitLoad(MemorySegment.class, readAddrIdx);\n+                Class<?> valueLayoutType = emitLoadLayoutConstant(chunkType);\n+                String descriptor = methodType(chunkType, valueLayoutType, long.class).descriptorString();\n+                long readOffset = offset + SharedUtils.pickChunkOffset(chunkOffset, byteWidth, chunkSize);\n+                emitConst(readOffset);\n+                emitInvokeInterface(MemorySegment.class, \"get\", descriptor);\n+                emitInvokeStatic(toULongHolder, \"toUnsignedLong\", toULongDescriptor);\n+\n+                \/\/ shift to right offset\n+                int shiftAmount = chunkOffset * Byte.SIZE;\n+                if (shiftAmount != 0) {\n+                    emitConst(shiftAmount);\n+                    mv.visitInsn(LSHL);\n+                }\n+                \/\/ add to result\n+                emitLoad(long.class, resultIdx);\n+                mv.visitInsn(LOR);\n+                emitStore(long.class, resultIdx);\n+\n+                remaining -= chunkSize;\n+                chunkOffset += chunkSize;\n+            } while (remaining != 0);\n+\n+            emitLoad(long.class, resultIdx);\n+            if (loadType == int.class) {\n+                mv.visitInsn(L2I);\n+            } else {\n+                assert loadType == long.class; \/\/ should not have chunking for other types\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":149,"deletions":12,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-                                Object result1 = SharedUtils.read(finalReturnBuffer.asSlice(retBufReadOffset), type);\n+                                Object result1 = SharedUtils.read(finalReturnBuffer, retBufReadOffset, type);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import java.nio.ByteOrder;\n@@ -361,0 +362,10 @@\n+    public static boolean isPowerOfTwo(int width) {\n+        return Integer.bitCount(width) == 1;\n+    }\n+\n+    static long pickChunkOffset(long chunkOffset, long byteWidth, int chunkWidth) {\n+        return ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN\n+                ? byteWidth - chunkWidth - chunkOffset\n+                : chunkOffset;\n+    }\n+\n@@ -442,1 +453,1 @@\n-    static void write(MemorySegment ptr, Class<?> type, Object o) {\n+    static void write(MemorySegment ptr, long offset, Class<?> type, Object o) {\n@@ -444,1 +455,1 @@\n-            ptr.set(JAVA_LONG_UNALIGNED, 0, (long) o);\n+            ptr.set(JAVA_LONG_UNALIGNED, offset, (long) o);\n@@ -446,1 +457,1 @@\n-            ptr.set(JAVA_INT_UNALIGNED, 0, (int) o);\n+            ptr.set(JAVA_INT_UNALIGNED, offset, (int) o);\n@@ -448,1 +459,1 @@\n-            ptr.set(JAVA_SHORT_UNALIGNED, 0, (short) o);\n+            ptr.set(JAVA_SHORT_UNALIGNED, offset, (short) o);\n@@ -450,1 +461,1 @@\n-            ptr.set(JAVA_CHAR_UNALIGNED, 0, (char) o);\n+            ptr.set(JAVA_CHAR_UNALIGNED, offset, (char) o);\n@@ -452,1 +463,1 @@\n-            ptr.set(JAVA_BYTE, 0, (byte) o);\n+            ptr.set(JAVA_BYTE, offset, (byte) o);\n@@ -454,1 +465,1 @@\n-            ptr.set(JAVA_FLOAT_UNALIGNED, 0, (float) o);\n+            ptr.set(JAVA_FLOAT_UNALIGNED, offset, (float) o);\n@@ -456,1 +467,1 @@\n-            ptr.set(JAVA_DOUBLE_UNALIGNED, 0, (double) o);\n+            ptr.set(JAVA_DOUBLE_UNALIGNED, offset, (double) o);\n@@ -458,1 +469,1 @@\n-            ptr.set(JAVA_BOOLEAN, 0, (boolean) o);\n+            ptr.set(JAVA_BOOLEAN, offset, (boolean) o);\n@@ -464,1 +475,1 @@\n-    static Object read(MemorySegment ptr, Class<?> type) {\n+    static Object read(MemorySegment ptr, long offset, Class<?> type) {\n@@ -466,1 +477,1 @@\n-            return ptr.get(JAVA_LONG_UNALIGNED, 0);\n+            return ptr.get(JAVA_LONG_UNALIGNED, offset);\n@@ -468,1 +479,1 @@\n-            return ptr.get(JAVA_INT_UNALIGNED, 0);\n+            return ptr.get(JAVA_INT_UNALIGNED, offset);\n@@ -470,1 +481,1 @@\n-            return ptr.get(JAVA_SHORT_UNALIGNED, 0);\n+            return ptr.get(JAVA_SHORT_UNALIGNED, offset);\n@@ -472,1 +483,1 @@\n-            return ptr.get(JAVA_CHAR_UNALIGNED, 0);\n+            return ptr.get(JAVA_CHAR_UNALIGNED, offset);\n@@ -474,1 +485,1 @@\n-            return ptr.get(JAVA_BYTE, 0);\n+            return ptr.get(JAVA_BYTE, offset);\n@@ -476,1 +487,1 @@\n-            return ptr.get(JAVA_FLOAT_UNALIGNED, 0);\n+            return ptr.get(JAVA_FLOAT_UNALIGNED, offset);\n@@ -478,1 +489,1 @@\n-            return ptr.get(JAVA_DOUBLE_UNALIGNED, 0);\n+            return ptr.get(JAVA_DOUBLE_UNALIGNED, offset);\n@@ -480,1 +491,1 @@\n-            return ptr.get(JAVA_BOOLEAN, 0);\n+            return ptr.get(JAVA_BOOLEAN, offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":29,"deletions":18,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-        record StructStorage(long offset, Class<?> carrier, VMStorage storage) {}\n+        record StructStorage(long offset, Class<?> carrier, int byteWidth, VMStorage storage) {}\n@@ -305,0 +305,1 @@\n+                long copySize;\n@@ -308,0 +309,1 @@\n+                    copySize = Utils.byteWidthOfPrimitive(copyLayout.carrier());\n@@ -310,1 +312,1 @@\n-                    long copySize = Math.min(layout.byteSize() - offset, MAX_COPY_SIZE);\n+                    copySize = Math.min(layout.byteSize() - offset, MAX_COPY_SIZE);\n@@ -322,1 +324,1 @@\n-                structStorages[i] = new StructStorage(offset, carrier, storage);\n+                structStorages[i] = new StructStorage(offset, carrier, (int) copySize, storage);\n@@ -421,1 +423,1 @@\n-                        bindings.bufferLoad(structStorage.offset(), structStorage.carrier())\n+                        bindings.bufferLoad(structStorage.offset(), structStorage.carrier(), structStorage.byteWidth())\n@@ -483,1 +485,1 @@\n-                                .bufferStore(structStorage.offset(), structStorage.carrier());\n+                                .bufferStore(structStorage.offset(), structStorage.carrier(), structStorage.byteWidth());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-                        bindings.bufferLoad(offset, type)\n+                        bindings.bufferLoad(offset, type, (int) copy)\n@@ -316,1 +316,1 @@\n-                                .bufferStore(offset, type);\n+                                .bufferStore(offset, type, (int) copy);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -167,0 +167,12 @@\n+    public static TestValue[] genTestArgs(FunctionDescriptor descriptor, SegmentAllocator allocator) {\n+        return genTestArgs(DEFAULT_RANDOM, descriptor, allocator);\n+    }\n+\n+    public static TestValue[] genTestArgs(RandomGenerator random, FunctionDescriptor descriptor, SegmentAllocator allocator) {\n+        TestValue[] result = new TestValue[descriptor.argumentLayouts().size()];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = genTestValue(random, descriptor.argumentLayouts().get(i), allocator);\n+        }\n+        return result;\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=specialized\n+ * @enablePreview\n+ * @library ..\/\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=true\n+ *   TestArrayStructs\n+ *\/\n+\n+\/*\n+ * @test id=interpreted\n+ * @enablePreview\n+ * @library ..\/\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.UpcallLinker.USE_SPEC=false\n+ *   TestArrayStructs\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.StructLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+import static java.lang.foreign.MemoryLayout.sequenceLayout;\n+import static java.lang.foreign.MemoryLayout.structLayout;\n+\n+public class TestArrayStructs extends NativeTestHelper {\n+    static {\n+        System.loadLibrary(\"ArrayStructs\");\n+    }\n+\n+    \/\/ Test if structs of various different sizes, including non-powers of two, work correctly\n+    @Test(dataProvider = \"arrayStructs\")\n+    public void testArrayStruct(String functionName, FunctionDescriptor baseDesc, int numPrefixArgs, int numElements) throws Throwable {\n+        FunctionDescriptor downcallDesc = baseDesc.insertArgumentLayouts(0, C_POINTER); \/\/ CB\n+        MemoryLayout[] elementLayouts = Collections.nCopies(numElements, C_CHAR).toArray(MemoryLayout[]::new);\n+        FunctionDescriptor upcallDesc = baseDesc.appendArgumentLayouts(elementLayouts);\n+        try (Arena arena = Arena.ofConfined()) {\n+            TestValue[] testArgs = genTestArgs(baseDesc, arena);\n+\n+            MethodHandle downcallHandle = downcallHandle(functionName, downcallDesc);\n+            Object[] args = new Object[downcallDesc.argumentLayouts().size() + 1]; \/\/ +1 for return allocator\n+            AtomicReference<Object[]> returnBox = new AtomicReference<>();\n+            int returnIdx = numPrefixArgs;\n+            int argIdx = 0;\n+            args[argIdx++] = arena;\n+            args[argIdx++] = makeArgSaverCB(upcallDesc, arena, returnBox, returnIdx);\n+            for (TestValue testArg : testArgs) {\n+                args[argIdx++] = testArg.value();\n+            }\n+\n+            MemorySegment returned = (MemorySegment) downcallHandle.invokeWithArguments(args);\n+            Consumer<Object> structCheck = testArgs[returnIdx].check();\n+\n+            structCheck.accept(returned);\n+\n+            Object[] capturedArgs = returnBox.get();\n+            int capturedArgIdx;\n+            for (capturedArgIdx = numPrefixArgs; capturedArgIdx < testArgs.length; capturedArgIdx++) {\n+                testArgs[capturedArgIdx].check().accept(capturedArgs[capturedArgIdx]);\n+            }\n+\n+            byte[] elements = new byte[numElements];\n+            for (int elIdx = 0; elIdx < numElements; elIdx++, capturedArgIdx++) {\n+                elements[elIdx] = (byte) capturedArgs[capturedArgIdx];\n+            }\n+\n+            structCheck.accept(MemorySegment.ofArray(elements)); \/\/ reuse the check for the struct\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] arrayStructs() {\n+        List<Object[]> cases = new ArrayList<>();\n+        for (int i = 0; i < layouts.size(); i++) {\n+            StructLayout layout = layouts.get(i);\n+            int numElements = i + 1;\n+            cases.add(new Object[]{\"F\" + numElements, FunctionDescriptor.of(layout, layout), 0, numElements});\n+        }\n+        for (int i = 0; i < layouts.size(); i++) {\n+            StructLayout layout = layouts.get(i);\n+            MemoryLayout[] argLayouts = Stream.concat(PREFIX_LAYOUTS.stream(), Stream.of(layout)).toArray(MemoryLayout[]::new);\n+            int numElements = i + 1;\n+            cases.add(new Object[]{\"F\" + numElements + \"_stack\", FunctionDescriptor.of(layout, argLayouts), PREFIX_LAYOUTS.size(), numElements});\n+        }\n+\n+        return cases.toArray(Object[][]::new);\n+    }\n+\n+    static final List<MemoryLayout> PREFIX_LAYOUTS = List.of(\n+        C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+        C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE);\n+\n+    static final List<StructLayout> layouts = List.of(\n+        structLayout(sequenceLayout(1, C_CHAR).withName(\"f0\")).withName(\"S1\"),\n+        structLayout(sequenceLayout(2, C_CHAR).withName(\"f0\")).withName(\"S2\"),\n+        structLayout(sequenceLayout(3, C_CHAR).withName(\"f0\")).withName(\"S3\"),\n+        structLayout(sequenceLayout(4, C_CHAR).withName(\"f0\")).withName(\"S4\"),\n+        structLayout(sequenceLayout(5, C_CHAR).withName(\"f0\")).withName(\"S5\"),\n+        structLayout(sequenceLayout(6, C_CHAR).withName(\"f0\")).withName(\"S6\"),\n+        structLayout(sequenceLayout(7, C_CHAR).withName(\"f0\")).withName(\"S7\"),\n+        structLayout(sequenceLayout(8, C_CHAR).withName(\"f0\")).withName(\"S8\"),\n+        structLayout(sequenceLayout(9, C_CHAR).withName(\"f0\")).withName(\"S9\"),\n+        structLayout(sequenceLayout(10, C_CHAR).withName(\"f0\")).withName(\"S10\"),\n+        structLayout(sequenceLayout(11, C_CHAR).withName(\"f0\")).withName(\"S11\"),\n+        structLayout(sequenceLayout(12, C_CHAR).withName(\"f0\")).withName(\"S12\"),\n+        structLayout(sequenceLayout(13, C_CHAR).withName(\"f0\")).withName(\"S13\"),\n+        structLayout(sequenceLayout(14, C_CHAR).withName(\"f0\")).withName(\"S14\"),\n+        structLayout(sequenceLayout(15, C_CHAR).withName(\"f0\")).withName(\"S15\"),\n+        structLayout(sequenceLayout(16, C_CHAR).withName(\"f0\")).withName(\"S16\"));\n+}\n","filename":"test\/jdk\/java\/foreign\/arraystructs\/TestArrayStructs.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct S1 { char f0[1]; };\n+struct S2 { char f0[2]; };\n+struct S3 { char f0[3]; };\n+struct S4 { char f0[4]; };\n+struct S5 { char f0[5]; };\n+struct S6 { char f0[6]; };\n+struct S7 { char f0[7]; };\n+struct S8 { char f0[8]; };\n+struct S9 { char f0[9]; };\n+struct S10 { char f0[10]; };\n+struct S11 { char f0[11]; };\n+struct S12 { char f0[12]; };\n+struct S13 { char f0[13]; };\n+struct S14 { char f0[14]; };\n+struct S15 { char f0[15]; };\n+struct S16 { char f0[16]; };\n+\n+EXPORT struct S1 F1(struct S1 (*cb)(struct S1, char), struct S1 a0) {\n+  return cb(a0, a0.f0[0]);\n+}\n+EXPORT struct S2 F2(struct S2 (*cb)(struct S2, char, char), struct S2 a0) {\n+  return cb(a0, a0.f0[0], a0.f0[1]);\n+}\n+EXPORT struct S3 F3(struct S3 (*cb)(struct S3, char, char, char), struct S3 a0) {\n+  return cb(a0, a0.f0[0], a0.f0[1], a0.f0[2]);\n+}\n+EXPORT struct S4 F4(struct S4 (*cb)(struct S4, char, char, char, char), struct S4 a0) {\n+  return cb(a0, a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3]);\n+}\n+EXPORT struct S5 F5(struct S5 (*cb)(struct S5, char, char, char, char, char), struct S5 a0) {\n+  return cb(a0, a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4]);\n+}\n+EXPORT struct S6 F6(struct S6 (*cb)(struct S6, char, char, char, char, char, char), struct S6 a0) {\n+  return cb(a0, a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5]);\n+}\n+EXPORT struct S7 F7(struct S7 (*cb)(struct S7, char, char, char, char, char, char, char), struct S7 a0) {\n+  return cb(a0, a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6]);\n+}\n+EXPORT struct S8 F8(struct S8 (*cb)(struct S8, char, char, char, char, char, char, char, char), struct S8 a0) {\n+  return cb(a0, a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7]);\n+}\n+EXPORT struct S9 F9(struct S9 (*cb)(struct S9, char, char, char, char, char, char, char, char, char), struct S9 a0) {\n+  return cb(a0, a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7], a0.f0[8]);\n+}\n+EXPORT struct S10 F10(struct S10 (*cb)(struct S10, char, char, char, char, char, char, char, char, char, char), struct S10 a0) {\n+  return cb(a0, a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7], a0.f0[8], a0.f0[9]);\n+}\n+EXPORT struct S11 F11(struct S11 (*cb)(struct S11, char, char, char, char, char, char, char, char, char, char, char), struct S11 a0) {\n+  return cb(a0, a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7], a0.f0[8], a0.f0[9], a0.f0[10]);\n+}\n+EXPORT struct S12 F12(struct S12 (*cb)(struct S12, char, char, char, char, char, char, char, char, char, char, char, char), struct S12 a0) {\n+  return cb(a0, a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7], a0.f0[8], a0.f0[9], a0.f0[10], a0.f0[11]);\n+}\n+EXPORT struct S13 F13(struct S13 (*cb)(struct S13, char, char, char, char, char, char, char, char, char, char, char, char, char), struct S13 a0) {\n+  return cb(a0, a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7], a0.f0[8], a0.f0[9], a0.f0[10], a0.f0[11], a0.f0[12]);\n+}\n+EXPORT struct S14 F14(struct S14 (*cb)(struct S14, char, char, char, char, char, char, char, char, char, char, char, char, char, char), struct S14 a0) {\n+  return cb(a0, a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7], a0.f0[8], a0.f0[9], a0.f0[10], a0.f0[11], a0.f0[12], a0.f0[13]);\n+}\n+EXPORT struct S15 F15(struct S15 (*cb)(struct S15, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char), struct S15 a0) {\n+  return cb(a0, a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7], a0.f0[8], a0.f0[9], a0.f0[10], a0.f0[11], a0.f0[12], a0.f0[13], a0.f0[14]);\n+}\n+EXPORT struct S16 F16(struct S16 (*cb)(struct S16, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char), struct S16 a0) {\n+  return cb(a0, a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7], a0.f0[8], a0.f0[9], a0.f0[10], a0.f0[11], a0.f0[12], a0.f0[13], a0.f0[14], a0.f0[15]);\n+}\n+\n+EXPORT struct S1 F1_stack(struct S1 (*cb)(long long, long long, long long, long long, long long, long long, long long, long long,\n+                                          double, double, double, double, double, double, double, double, struct S1,\n+                                          char),\n+                          long long pf0, long long pf1, long long pf2, long long pf3, long long pf4, long long pf5, long long pf6, long long pf7,\n+                          double pf8, double pf9, double pf10, double pf11, double pf12, double pf13, double pf14, double pf15,\n+                          struct S1 a0) {\n+    return cb(pf0, pf1, pf2, pf3, pf4, pf5, pf6, pf7, pf8, pf9, pf10, pf11, pf12, pf13, pf14, pf15, a0,\n+              a0.f0[0]);\n+}\n+EXPORT struct S2 F2_stack(struct S2 (*cb)(long long, long long, long long, long long, long long, long long, long long, long long,\n+                                          double, double, double, double, double, double, double, double, struct S2,\n+                                          char, char),\n+                          long long pf0, long long pf1, long long pf2, long long pf3, long long pf4, long long pf5, long long pf6, long long pf7,\n+                          double pf8, double pf9, double pf10, double pf11, double pf12, double pf13, double pf14, double pf15,\n+                          struct S2 a0) {\n+    return cb(pf0, pf1, pf2, pf3, pf4, pf5, pf6, pf7, pf8, pf9, pf10, pf11, pf12, pf13, pf14, pf15, a0,\n+              a0.f0[0], a0.f0[1]);\n+}\n+EXPORT struct S3 F3_stack(struct S3 (*cb)(long long, long long, long long, long long, long long, long long, long long, long long,\n+                                          double, double, double, double, double, double, double, double, struct S3,\n+                                          char, char, char),\n+                          long long pf0, long long pf1, long long pf2, long long pf3, long long pf4, long long pf5, long long pf6, long long pf7,\n+                          double pf8, double pf9, double pf10, double pf11, double pf12, double pf13, double pf14, double pf15,\n+                          struct S3 a0) {\n+    return cb(pf0, pf1, pf2, pf3, pf4, pf5, pf6, pf7, pf8, pf9, pf10, pf11, pf12, pf13, pf14, pf15, a0,\n+              a0.f0[0], a0.f0[1], a0.f0[2]);\n+}\n+EXPORT struct S4 F4_stack(struct S4 (*cb)(long long, long long, long long, long long, long long, long long, long long, long long,\n+                                          double, double, double, double, double, double, double, double, struct S4,\n+                                          char, char, char, char),\n+                          long long pf0, long long pf1, long long pf2, long long pf3, long long pf4, long long pf5, long long pf6, long long pf7,\n+                          double pf8, double pf9, double pf10, double pf11, double pf12, double pf13, double pf14, double pf15,\n+                          struct S4 a0) {\n+    return cb(pf0, pf1, pf2, pf3, pf4, pf5, pf6, pf7, pf8, pf9, pf10, pf11, pf12, pf13, pf14, pf15, a0,\n+              a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3]);\n+}\n+EXPORT struct S5 F5_stack(struct S5 (*cb)(long long, long long, long long, long long, long long, long long, long long, long long,\n+                                          double, double, double, double, double, double, double, double, struct S5,\n+                                          char, char, char, char, char),\n+                          long long pf0, long long pf1, long long pf2, long long pf3, long long pf4, long long pf5, long long pf6, long long pf7,\n+                          double pf8, double pf9, double pf10, double pf11, double pf12, double pf13, double pf14, double pf15,\n+                          struct S5 a0) {\n+    return cb(pf0, pf1, pf2, pf3, pf4, pf5, pf6, pf7, pf8, pf9, pf10, pf11, pf12, pf13, pf14, pf15, a0,\n+              a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4]);\n+}\n+EXPORT struct S6 F6_stack(struct S6 (*cb)(long long, long long, long long, long long, long long, long long, long long, long long,\n+                                          double, double, double, double, double, double, double, double, struct S6,\n+                                          char, char, char, char, char, char),\n+                          long long pf0, long long pf1, long long pf2, long long pf3, long long pf4, long long pf5, long long pf6, long long pf7,\n+                          double pf8, double pf9, double pf10, double pf11, double pf12, double pf13, double pf14, double pf15,\n+                          struct S6 a0) {\n+    return cb(pf0, pf1, pf2, pf3, pf4, pf5, pf6, pf7, pf8, pf9, pf10, pf11, pf12, pf13, pf14, pf15, a0,\n+              a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5]);\n+}\n+EXPORT struct S7 F7_stack(struct S7 (*cb)(long long, long long, long long, long long, long long, long long, long long, long long,\n+                                          double, double, double, double, double, double, double, double, struct S7,\n+                                          char, char, char, char, char, char, char),\n+                          long long pf0, long long pf1, long long pf2, long long pf3, long long pf4, long long pf5, long long pf6, long long pf7,\n+                          double pf8, double pf9, double pf10, double pf11, double pf12, double pf13, double pf14, double pf15,\n+                          struct S7 a0) {\n+    return cb(pf0, pf1, pf2, pf3, pf4, pf5, pf6, pf7, pf8, pf9, pf10, pf11, pf12, pf13, pf14, pf15, a0,\n+              a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6]);\n+}\n+EXPORT struct S8 F8_stack(struct S8 (*cb)(long long, long long, long long, long long, long long, long long, long long, long long,\n+                                          double, double, double, double, double, double, double, double, struct S8,\n+                                          char, char, char, char, char, char, char, char),\n+                          long long pf0, long long pf1, long long pf2, long long pf3, long long pf4, long long pf5, long long pf6, long long pf7,\n+                          double pf8, double pf9, double pf10, double pf11, double pf12, double pf13, double pf14, double pf15,\n+                          struct S8 a0) {\n+    return cb(pf0, pf1, pf2, pf3, pf4, pf5, pf6, pf7, pf8, pf9, pf10, pf11, pf12, pf13, pf14, pf15, a0,\n+              a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7]);\n+}\n+EXPORT struct S9 F9_stack(struct S9 (*cb)(long long, long long, long long, long long, long long, long long, long long, long long,\n+                                          double, double, double, double, double, double, double, double, struct S9,\n+                                          char, char, char, char, char, char, char, char, char),\n+                          long long pf0, long long pf1, long long pf2, long long pf3, long long pf4, long long pf5, long long pf6, long long pf7,\n+                          double pf8, double pf9, double pf10, double pf11, double pf12, double pf13, double pf14, double pf15,\n+                          struct S9 a0) {\n+    return cb(pf0, pf1, pf2, pf3, pf4, pf5, pf6, pf7, pf8, pf9, pf10, pf11, pf12, pf13, pf14, pf15, a0,\n+              a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7], a0.f0[8]);\n+}\n+EXPORT struct S10 F10_stack(struct S10 (*cb)(long long, long long, long long, long long, long long, long long, long long, long long,\n+                                          double, double, double, double, double, double, double, double, struct S10,\n+                                          char, char, char, char, char, char, char, char, char, char),\n+                          long long pf0, long long pf1, long long pf2, long long pf3, long long pf4, long long pf5, long long pf6, long long pf7,\n+                          double pf8, double pf9, double pf10, double pf11, double pf12, double pf13, double pf14, double pf15,\n+                          struct S10 a0) {\n+    return cb(pf0, pf1, pf2, pf3, pf4, pf5, pf6, pf7, pf8, pf9, pf10, pf11, pf12, pf13, pf14, pf15, a0,\n+              a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7], a0.f0[8], a0.f0[9]);\n+}\n+EXPORT struct S11 F11_stack(struct S11 (*cb)(long long, long long, long long, long long, long long, long long, long long, long long,\n+                                          double, double, double, double, double, double, double, double, struct S11,\n+                                          char, char, char, char, char, char, char, char, char, char, char),\n+                          long long pf0, long long pf1, long long pf2, long long pf3, long long pf4, long long pf5, long long pf6, long long pf7,\n+                          double pf8, double pf9, double pf10, double pf11, double pf12, double pf13, double pf14, double pf15,\n+                          struct S11 a0) {\n+    return cb(pf0, pf1, pf2, pf3, pf4, pf5, pf6, pf7, pf8, pf9, pf10, pf11, pf12, pf13, pf14, pf15, a0,\n+              a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7], a0.f0[8], a0.f0[9], a0.f0[10]);\n+}\n+EXPORT struct S12 F12_stack(struct S12 (*cb)(long long, long long, long long, long long, long long, long long, long long, long long,\n+                                          double, double, double, double, double, double, double, double, struct S12,\n+                                          char, char, char, char, char, char, char, char, char, char, char, char),\n+                          long long pf0, long long pf1, long long pf2, long long pf3, long long pf4, long long pf5, long long pf6, long long pf7,\n+                          double pf8, double pf9, double pf10, double pf11, double pf12, double pf13, double pf14, double pf15,\n+                          struct S12 a0) {\n+    return cb(pf0, pf1, pf2, pf3, pf4, pf5, pf6, pf7, pf8, pf9, pf10, pf11, pf12, pf13, pf14, pf15, a0,\n+              a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7], a0.f0[8], a0.f0[9], a0.f0[10], a0.f0[11]);\n+}\n+EXPORT struct S13 F13_stack(struct S13 (*cb)(long long, long long, long long, long long, long long, long long, long long, long long,\n+                                          double, double, double, double, double, double, double, double, struct S13,\n+                                          char, char, char, char, char, char, char, char, char, char, char, char, char),\n+                          long long pf0, long long pf1, long long pf2, long long pf3, long long pf4, long long pf5, long long pf6, long long pf7,\n+                          double pf8, double pf9, double pf10, double pf11, double pf12, double pf13, double pf14, double pf15,\n+                          struct S13 a0) {\n+    return cb(pf0, pf1, pf2, pf3, pf4, pf5, pf6, pf7, pf8, pf9, pf10, pf11, pf12, pf13, pf14, pf15, a0,\n+              a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7], a0.f0[8], a0.f0[9], a0.f0[10], a0.f0[11], a0.f0[12]);\n+}\n+EXPORT struct S14 F14_stack(struct S14 (*cb)(long long, long long, long long, long long, long long, long long, long long, long long,\n+                                          double, double, double, double, double, double, double, double, struct S14,\n+                                          char, char, char, char, char, char, char, char, char, char, char, char, char, char),\n+                          long long pf0, long long pf1, long long pf2, long long pf3, long long pf4, long long pf5, long long pf6, long long pf7,\n+                          double pf8, double pf9, double pf10, double pf11, double pf12, double pf13, double pf14, double pf15,\n+                          struct S14 a0) {\n+    return cb(pf0, pf1, pf2, pf3, pf4, pf5, pf6, pf7, pf8, pf9, pf10, pf11, pf12, pf13, pf14, pf15, a0,\n+              a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7], a0.f0[8], a0.f0[9], a0.f0[10], a0.f0[11], a0.f0[12], a0.f0[13]);\n+}\n+EXPORT struct S15 F15_stack(struct S15 (*cb)(long long, long long, long long, long long, long long, long long, long long, long long,\n+                                          double, double, double, double, double, double, double, double, struct S15,\n+                                          char, char, char, char, char, char, char, char, char, char, char, char, char, char, char),\n+                          long long pf0, long long pf1, long long pf2, long long pf3, long long pf4, long long pf5, long long pf6, long long pf7,\n+                          double pf8, double pf9, double pf10, double pf11, double pf12, double pf13, double pf14, double pf15,\n+                          struct S15 a0) {\n+    return cb(pf0, pf1, pf2, pf3, pf4, pf5, pf6, pf7, pf8, pf9, pf10, pf11, pf12, pf13, pf14, pf15, a0,\n+              a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7], a0.f0[8], a0.f0[9], a0.f0[10], a0.f0[11], a0.f0[12], a0.f0[13], a0.f0[14]);\n+}\n+EXPORT struct S16 F16_stack(struct S16 (*cb)(long long, long long, long long, long long, long long, long long, long long, long long,\n+                                          double, double, double, double, double, double, double, double, struct S16,\n+                                          char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char),\n+                          long long pf0, long long pf1, long long pf2, long long pf3, long long pf4, long long pf5, long long pf6, long long pf7,\n+                          double pf8, double pf9, double pf10, double pf11, double pf12, double pf13, double pf14, double pf15,\n+                          struct S16 a0) {\n+    return cb(pf0, pf1, pf2, pf3, pf4, pf5, pf6, pf7, pf8, pf9, pf10, pf11, pf12, pf13, pf14, pf15, a0,\n+              a0.f0[0], a0.f0[1], a0.f0[2], a0.f0[3], a0.f0[4], a0.f0[5], a0.f0[6], a0.f0[7], a0.f0[8], a0.f0[9], a0.f0[10], a0.f0[11], a0.f0[12], a0.f0[13], a0.f0[14], a0.f0[15]);\n+}\n","filename":"test\/jdk\/java\/foreign\/arraystructs\/libArrayStructs.c","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"}]}